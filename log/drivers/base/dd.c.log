commit cec72f3efc6272420c2c2c699607f03d09b93e41
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 1 12:42:57 2020 -0700

    driver core: Don't do deferred probe in parallel with kernel_init thread
    
    The current deferred probe implementation can mess up suspend/resume
    ordering if deferred probe thread is kicked off in parallel with the
    main initcall thread (kernel_init thread) [1].
    
    For example:
    
    Say device-B is a consumer of device-A.
    
    Initcall thread                                 Deferred probe thread
    ===============                                 =====================
    1. device-A is added.
    2. device-B is added.
    3. dpm_list is now [device-A, device-B].
    4. driver-A defers probe of device-A.
                                                    5. device-A is moved to
                                                       end of dpm_list
                                                    6. dpm_list is now
                                                       [device-B, device-A]
    7. driver-B is registereed and probes device-B.
    8. dpm_list stays as [device-B, device-A].
    
    The reverse order of dpm_list is used for suspend. So in this case
    device-A would incorrectly get suspended before device-B.
    
    Commit 716a7a259690 ("driver core: fw_devlink: Add support for batching
    fwnode parsing") kicked off the deferred probe thread early during boot
    to run in parallel with the initcall thread and caused suspend/resume
    regressions.  This patch removes the parallel run of the deferred probe
    thread to avoid the suspend/resume regressions.
    
    [1] - https://lore.kernel.org/lkml/CAGETcx8W96KAw-d_siTX4qHB_-7ddk0miYRDQeHE6E0_8qx-6Q@mail.gmail.com/
    
    Fixes: 716a7a259690 ("driver core: fw_devlink: Add support for batching fwnode parsing")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20200701194259.3337652-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 9a1d940342ac..48ca81cb8ebc 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -164,11 +164,6 @@ static void driver_deferred_probe_trigger(void)
 	if (!driver_deferred_probe_enable)
 		return;
 
-	driver_deferred_probe_force_trigger();
-}
-
-void driver_deferred_probe_force_trigger(void)
-{
 	/*
 	 * A successful probe means that all the devices in the pending list
 	 * should be triggered to be reprobed.  Move all the deferred devices

commit fefcfc968723caf93318613a08e1f3ad07a6154f
Author: Saravana Kannan <saravanak@google.com>
Date:   Sun May 17 10:34:53 2020 -0700

    driver core: Remove check in driver_deferred_probe_force_trigger()
    
    The whole point behind adding driver_deferred_probe_force_trigger() in
    commit 716a7a259690 ("driver core: fw_devlink: Add support for batching
    fwnode parsing") was to skip the check for driver_deferred_probe_enable.
    Otherwise, it's identical to driver_deferred_probe_trigger().
    
    Delete the check in driver_deferred_probe_force_trigger() so that
    fw_devlink_pause() and fw_devlink_resume() can kick off deferred probe
    as intended. Without doing this forced deferred probe trigger, some
    platforms seem to be crashing during boot because they assume probe
    order of devices.
    
    Fixes: 716a7a259690 ("driver core: fw_devlink: Add support for batching fwnode parsing")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200517173453.157703-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 63991d97adcc..9a1d940342ac 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -169,9 +169,6 @@ static void driver_deferred_probe_trigger(void)
 
 void driver_deferred_probe_force_trigger(void)
 {
-	if (!driver_deferred_probe_enable)
-		return;
-
 	/*
 	 * A successful probe means that all the devices in the pending list
 	 * should be triggered to be reprobed.  Move all the deferred devices

commit 716a7a25969003d82ab738179c3f1068a120ed11
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu May 14 22:34:59 2020 -0700

    driver core: fw_devlink: Add support for batching fwnode parsing
    
    The amount of time spent parsing fwnodes of devices can become really
    high if the devices are added in an non-ideal order. Worst case can be
    O(N^2) when N devices are added. But this can be optimized to O(N) by
    adding all the devices and then parsing all their fwnodes in one batch.
    
    This commit adds fw_devlink_pause() and fw_devlink_resume() to allow
    doing this.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200515053500.215929-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 48ca81cb8ebc..63991d97adcc 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -160,6 +160,14 @@ static bool driver_deferred_probe_enable = false;
  * again.
  */
 static void driver_deferred_probe_trigger(void)
+{
+	if (!driver_deferred_probe_enable)
+		return;
+
+	driver_deferred_probe_force_trigger();
+}
+
+void driver_deferred_probe_force_trigger(void)
 {
 	if (!driver_deferred_probe_enable)
 		return;

commit c8be6af9ef16cf44d690fc227a0d2dd7a526ef05
Merge: c78c31b374a6 2ef96a5bb12b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 11 09:00:09 2020 +0200

    Merge v5.7-rc5 into driver-core-next
    
    We want the driver core fixes in here and this resolves a merge issue
    with drivers/base/dd.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eb7fbc9fb1185a7f89adeb2de724c2c96ff608e9
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sat Apr 11 15:31:58 2020 +0200

    driver core: Add missing '\n' in log messages
    
    Message logged by 'dev_xxx()' or 'pr_xxx()' should end with a '\n'.
    
    While at it, convert some "printk(KERN_" into equivalent but less verbose
    (pr|dev)_xxx functions.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Link: https://lore.kernel.org/r/20200411133158.27390-1-christophe.jaillet@wanadoo.fr
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 06ec0e851fa1..efe6df5bff26 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -262,12 +262,12 @@ __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
 int driver_deferred_probe_check_state(struct device *dev)
 {
 	if (!IS_ENABLED(CONFIG_MODULES) && initcalls_done) {
-		dev_warn(dev, "ignoring dependency for device, assuming no driver");
+		dev_warn(dev, "ignoring dependency for device, assuming no driver\n");
 		return -ENODEV;
 	}
 
 	if (!driver_deferred_probe_timeout) {
-		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
+		dev_WARN(dev, "deferred probe timeout, ignoring dependency\n");
 		return -ETIMEDOUT;
 	}
 
@@ -283,7 +283,7 @@ static void deferred_probe_timeout_work_func(struct work_struct *work)
 	flush_work(&deferred_probe_work);
 
 	list_for_each_entry_safe(private, p, &deferred_probe_pending_list, deferred_probe)
-		dev_info(private->device, "deferred probe pending");
+		dev_info(private->device, "deferred probe pending\n");
 }
 static DECLARE_DELAYED_WORK(deferred_probe_timeout_work, deferred_probe_timeout_work_func);
 
@@ -343,7 +343,7 @@ bool device_is_bound(struct device *dev)
 static void driver_bound(struct device *dev)
 {
 	if (device_is_bound(dev)) {
-		printk(KERN_WARNING "%s: device %s already bound\n",
+		pr_warn("%s: device %s already bound\n",
 			__func__, kobject_name(&dev->kobj));
 		return;
 	}
@@ -512,8 +512,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	}
 
 	if (driver_sysfs_add(dev)) {
-		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
-			__func__, dev_name(dev));
+		pr_err("%s: driver_sysfs_add(%s) failed\n",
+		       __func__, dev_name(dev));
 		goto probe_failed;
 	}
 
@@ -604,9 +604,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		break;
 	default:
 		/* driver matched but the probe failed */
-		printk(KERN_WARNING
-		       "%s: probe of %s failed with error %d\n",
-		       drv->name, dev_name(dev), ret);
+		pr_warn("%s: probe of %s failed with error %d\n",
+			drv->name, dev_name(dev), ret);
 	}
 	/*
 	 * Ignore errors returned by ->probe so that the next driver can try
@@ -631,8 +630,8 @@ static int really_probe_debug(struct device *dev, struct device_driver *drv)
 	ret = really_probe(dev, drv);
 	rettime = ktime_get();
 	delta = ktime_sub(rettime, calltime);
-	printk(KERN_DEBUG "probe of %s returned %d after %lld usecs\n",
-	       dev_name(dev), ret, (s64) ktime_to_us(delta));
+	pr_debug("probe of %s returned %d after %lld usecs\n",
+		 dev_name(dev), ret, (s64) ktime_to_us(delta));
 	return ret;
 }
 
@@ -717,8 +716,7 @@ static inline bool cmdline_requested_async_probing(const char *drv_name)
 static int __init save_async_options(char *buf)
 {
 	if (strlen(buf) >= ASYNC_DRV_NAMES_MAX_LEN)
-		printk(KERN_WARNING
-			"Too long list of driver names for 'driver_async_probe'!\n");
+		pr_warn("Too long list of driver names for 'driver_async_probe'!\n");
 
 	strlcpy(async_probe_drv_names, buf, ASYNC_DRV_NAMES_MAX_LEN);
 	return 0;
@@ -793,7 +791,7 @@ static int __device_attach_driver(struct device_driver *drv, void *_data)
 		dev_dbg(dev, "Device match requests probe deferral\n");
 		driver_deferred_probe_add(dev);
 	} else if (ret < 0) {
-		dev_dbg(dev, "Bus failed to match device: %d", ret);
+		dev_dbg(dev, "Bus failed to match device: %d\n", ret);
 		return ret;
 	} /* ret > 0 means positive match */
 
@@ -1026,7 +1024,7 @@ static int __driver_attach(struct device *dev, void *data)
 		dev_dbg(dev, "Device match requests probe deferral\n");
 		driver_deferred_probe_add(dev);
 	} else if (ret < 0) {
-		dev_dbg(dev, "Bus failed to match device: %d", ret);
+		dev_dbg(dev, "Bus failed to match device: %d\n", ret);
 		return ret;
 	} /* ret > 0 means positive match */
 

commit 35a672363ab3e8dfe4ebcadb4dd0b2d06bb85ebe
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 22 20:32:45 2020 +0000

    driver core: Ensure wait_for_device_probe() waits until the deferred_probe_timeout fires
    
    In commit c8c43cee29f6 ("driver core: Fix
    driver_deferred_probe_check_state() logic"), we set the default
    driver_deferred_probe_timeout value to 30 seconds to allow for
    drivers that are missing dependencies to have some time so that
    the dependency may be loaded from userland after initcalls_done
    is set.
    
    However, Yoshihiro Shimoda reported that on his device that
    expects to have unmet dependencies (due to "optional links" in
    its devicetree), was failing to mount the NFS root.
    
    In digging further, it seemed the problem was that while the
    device properly probes after waiting 30 seconds for any missing
    modules to load, the ip_auto_config() had already failed,
    resulting in NFS to fail. This was due to ip_auto_config()
    calling wait_for_device_probe() which doesn't wait for the
    driver_deferred_probe_timeout to fire.
    
    This patch tries to fix the issue by creating a waitqueue
    for the driver_deferred_probe_timeout, and calling wait_event()
    to make sure driver_deferred_probe_timeout is zero in
    wait_for_device_probe() to make sure all the probing is
    finished.
    
    The downside to this solution is that kernel functionality that
    uses wait_for_device_probe(), will block until the
    driver_deferred_probe_timeout fires, regardless of if there is
    any missing dependencies.
    
    However, the previous patch reverts the default timeout value to
    zero, so this side-effect will only affect users who specify a
    driver_deferred_probe_timeout= value as a boot argument, where
    the additional delay would be beneficial to allow modules to
    load later during boot.
    
    Thanks to Geert for chasing down that ip_auto_config was why NFS
    was failing in this case!
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Naresh Kamboju <naresh.kamboju@linaro.org>
    Cc: Basil Eljuse <Basil.Eljuse@arm.com>
    Cc: Ferry Toth <fntoth@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Anders Roxell <anders.roxell@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Reported-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Fixes: c8c43cee29f6 ("driver core: Fix driver_deferred_probe_check_state() logic")
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200422203245.83244-4-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 9c88afa5c74a..94037be7f5d7 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -226,6 +226,7 @@ DEFINE_SHOW_ATTRIBUTE(deferred_devs);
 
 int driver_deferred_probe_timeout;
 EXPORT_SYMBOL_GPL(driver_deferred_probe_timeout);
+static DECLARE_WAIT_QUEUE_HEAD(probe_timeout_waitqueue);
 
 static int __init deferred_probe_timeout_setup(char *str)
 {
@@ -275,6 +276,7 @@ static void deferred_probe_timeout_work_func(struct work_struct *work)
 
 	list_for_each_entry_safe(private, p, &deferred_probe_pending_list, deferred_probe)
 		dev_info(private->device, "deferred probe pending");
+	wake_up(&probe_timeout_waitqueue);
 }
 static DECLARE_DELAYED_WORK(deferred_probe_timeout_work, deferred_probe_timeout_work_func);
 
@@ -649,6 +651,9 @@ int driver_probe_done(void)
  */
 void wait_for_device_probe(void)
 {
+	/* wait for probe timeout */
+	wait_event(probe_timeout_waitqueue, !driver_deferred_probe_timeout);
+
 	/* wait for the deferred probe workqueue to finish */
 	flush_work(&deferred_probe_work);
 

commit 4ccc03e28ec309173f434fa38b48b6ad65ff5d1b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 22 20:32:44 2020 +0000

    driver core: Use dev_warn() instead of dev_WARN() for deferred_probe_timeout warnings
    
    In commit c8c43cee29f6 ("driver core: Fix
    driver_deferred_probe_check_state() logic") and following
    changes the logic was changes slightly so that if there is no
    driver to match whats found in the dtb, we wait the sepcified
    seconds for modules to be loaded by userland, and then timeout,
    where as previously we'd print "ignoring dependency for device,
    assuming no driver" and immediately return -ENODEV after
    initcall_done.
    
    However, in the timeout case (which previously existed but was
    practicaly un-used without a boot argument), the timeout message
    uses dev_WARN(). This means folks are now seeing a big backtrace
    in their boot logs if there a entry in their dts that doesn't
    have a driver.
    
    To fix this, lets use dev_warn(), instead of dev_WARN() to match
    the previous error path.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Naresh Kamboju <naresh.kamboju@linaro.org>
    Cc: Basil Eljuse <Basil.Eljuse@arm.com>
    Cc: Ferry Toth <fntoth@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Anders Roxell <anders.roxell@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Fixes: c8c43cee29f6 ("driver core: Fix driver_deferred_probe_check_state() logic")
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200422203245.83244-3-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 908ae4d7805e..9c88afa5c74a 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -258,7 +258,7 @@ int driver_deferred_probe_check_state(struct device *dev)
 	}
 
 	if (!driver_deferred_probe_timeout && initcalls_done) {
-		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
+		dev_warn(dev, "deferred probe timeout, ignoring dependency");
 		return -ETIMEDOUT;
 	}
 

commit ce68929f07de0780c1afbbeef9aa6cf3550163d6
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 22 20:32:43 2020 +0000

    driver core: Revert default driver_deferred_probe_timeout value to 0
    
    This patch addresses a regression in 5.7-rc1+
    
    In commit c8c43cee29f6 ("driver core: Fix
    driver_deferred_probe_check_state() logic"), we both cleaned up
    the logic and also set the default driver_deferred_probe_timeout
    value to 30 seconds to allow for drivers that are missing
    dependencies to have some time so that the dependency may be
    loaded from userland after initcalls_done is set.
    
    However, Yoshihiro Shimoda reported that on his device that
    expects to have unmet dependencies (due to "optional links" in
    its devicetree), was failing to mount the NFS root.
    
    In digging further, it seemed the problem was that while the
    device properly probes after waiting 30 seconds for any missing
    modules to load, the ip_auto_config() had already failed,
    resulting in NFS to fail. This was due to ip_auto_config()
    calling wait_for_device_probe() which doesn't wait for the
    driver_deferred_probe_timeout to fire.
    
    Fixing that issue is possible, but could also introduce 30
    second delays in bootups for users who don't have any
    missing dependencies, which is not ideal.
    
    So I think the best solution to avoid any regressions is to
    revert back to a default timeout value of zero, and allow
    systems that need to utilize the timeout in order for userland
    to load any modules that supply misisng dependencies in the dts
    to specify the timeout length via the exiting documented boot
    argument.
    
    Thanks to Geert for chasing down that ip_auto_config was why NFS
    was failing in this case!
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Naresh Kamboju <naresh.kamboju@linaro.org>
    Cc: Basil Eljuse <Basil.Eljuse@arm.com>
    Cc: Ferry Toth <fntoth@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Anders Roxell <anders.roxell@linaro.org>
    Reported-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Fixes: c8c43cee29f6 ("driver core: Fix driver_deferred_probe_check_state() logic")
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200422203245.83244-2-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 06ec0e851fa1..908ae4d7805e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -224,16 +224,7 @@ static int deferred_devs_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(deferred_devs);
 
-#ifdef CONFIG_MODULES
-/*
- * In the case of modules, set the default probe timeout to
- * 30 seconds to give userland some time to load needed modules
- */
-int driver_deferred_probe_timeout = 30;
-#else
-/* In the case of !modules, no probe timeout needed */
-int driver_deferred_probe_timeout = -1;
-#endif
+int driver_deferred_probe_timeout;
 EXPORT_SYMBOL_GPL(driver_deferred_probe_timeout);
 
 static int __init deferred_probe_timeout_setup(char *str)
@@ -266,7 +257,7 @@ int driver_deferred_probe_check_state(struct device *dev)
 		return -ENODEV;
 	}
 
-	if (!driver_deferred_probe_timeout) {
+	if (!driver_deferred_probe_timeout && initcalls_done) {
 		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
 		return -ETIMEDOUT;
 	}

commit a3a87d66d3f64c74acbc25799d38effb63695ea0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 24 14:20:23 2020 +0200

    driver core: Replace open-coded list_last_entry()
    
    There is a place in the code where open-coded version of list entry accessors
    list_last_entry() is used.
    
    Replace that with the standard macro.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20200324122023.9649-3-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3f5b8bdd94f0..06ec0e851fa1 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -1199,7 +1199,7 @@ void driver_detach(struct device_driver *drv)
 			spin_unlock(&drv->p->klist_devices.k_lock);
 			break;
 		}
-		dev_prv = list_entry(drv->p->klist_devices.k_list.prev,
+		dev_prv = list_last_entry(&drv->p->klist_devices.k_list,
 				     struct device_private,
 				     knode_driver.n_node);
 		dev = dev_prv->device;

commit 927f82875c272e8c1159cb2c00bda473402c7c28
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 24 14:20:22 2020 +0200

    driver core: Read atomic counter once in driver_probe_done()
    
    Between printing the debug message and actual check atomic counter can be
    altered. For better debugging experience read atomic counter value only once.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Ferry Toth <fntoth@gmail.com>
    Link: https://lore.kernel.org/r/20200324122023.9649-2-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 76888a7459d8..3f5b8bdd94f0 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -644,9 +644,10 @@ static int really_probe_debug(struct device *dev, struct device_driver *drv)
  */
 int driver_probe_done(void)
 {
-	pr_debug("%s: probe_count = %d\n", __func__,
-		 atomic_read(&probe_count));
-	if (atomic_read(&probe_count))
+	int local_probe_count = atomic_read(&probe_count);
+
+	pr_debug("%s: probe_count = %d\n", __func__, local_probe_count);
+	if (local_probe_count)
 		return -EBUSY;
 	return 0;
 }

commit 64c775fb4b21ab2532555e833edf52055df5fb1c
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 25 05:08:27 2020 +0000

    driver core: Rename deferred_probe_timeout and make it global
    
    Since other subsystems (like regulator) have similar arbitrary
    timeouts for how long they try to resolve driver dependencies,
    rename deferred_probe_timeout to driver_deferred_probe_timeout
    and set it as global, so it can be shared.
    
    Cc: linux-pm@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200225050828.56458-6-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index c09e4e7277d4..76888a7459d8 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -229,17 +229,19 @@ DEFINE_SHOW_ATTRIBUTE(deferred_devs);
  * In the case of modules, set the default probe timeout to
  * 30 seconds to give userland some time to load needed modules
  */
-static int deferred_probe_timeout = 30;
+int driver_deferred_probe_timeout = 30;
 #else
 /* In the case of !modules, no probe timeout needed */
-static int deferred_probe_timeout = -1;
+int driver_deferred_probe_timeout = -1;
 #endif
+EXPORT_SYMBOL_GPL(driver_deferred_probe_timeout);
+
 static int __init deferred_probe_timeout_setup(char *str)
 {
 	int timeout;
 
 	if (!kstrtoint(str, 10, &timeout))
-		deferred_probe_timeout = timeout;
+		driver_deferred_probe_timeout = timeout;
 	return 1;
 }
 __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
@@ -264,7 +266,7 @@ int driver_deferred_probe_check_state(struct device *dev)
 		return -ENODEV;
 	}
 
-	if (!deferred_probe_timeout) {
+	if (!driver_deferred_probe_timeout) {
 		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
 		return -ETIMEDOUT;
 	}
@@ -276,7 +278,7 @@ static void deferred_probe_timeout_work_func(struct work_struct *work)
 {
 	struct device_private *private, *p;
 
-	deferred_probe_timeout = 0;
+	driver_deferred_probe_timeout = 0;
 	driver_deferred_probe_trigger();
 	flush_work(&deferred_probe_work);
 
@@ -310,9 +312,9 @@ static int deferred_probe_initcall(void)
 	driver_deferred_probe_trigger();
 	flush_work(&deferred_probe_work);
 
-	if (deferred_probe_timeout > 0) {
+	if (driver_deferred_probe_timeout > 0) {
 		schedule_delayed_work(&deferred_probe_timeout_work,
-			deferred_probe_timeout * HZ);
+			driver_deferred_probe_timeout * HZ);
 	}
 	return 0;
 }

commit 0e9f8d09d2806aa2e10a04a78f82544e4ee737a1
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 25 05:08:26 2020 +0000

    driver core: Remove driver_deferred_probe_check_state_continue()
    
    Now that driver_deferred_probe_check_state() works better, and
    we've converted the only user of
    driver_deferred_probe_check_state_continue() we can simply
    remove it and simplify some of the logic.
    
    Cc: linux-pm@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200225050828.56458-5-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index fe26f2574a6d..c09e4e7277d4 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -244,19 +244,6 @@ static int __init deferred_probe_timeout_setup(char *str)
 }
 __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
 
-static int __driver_deferred_probe_check_state(struct device *dev)
-{
-	if (!IS_ENABLED(CONFIG_MODULES) && initcalls_done)
-		return -ENODEV;
-
-	if (!deferred_probe_timeout) {
-		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
-		return -ETIMEDOUT;
-	}
-
-	return -EPROBE_DEFER;
-}
-
 /**
  * driver_deferred_probe_check_state() - Check deferred probe state
  * @dev: device to check
@@ -272,39 +259,15 @@ static int __driver_deferred_probe_check_state(struct device *dev)
  */
 int driver_deferred_probe_check_state(struct device *dev)
 {
-	int ret;
-
-	ret = __driver_deferred_probe_check_state(dev);
-	if (ret != -ENODEV)
-		return ret;
-
-	dev_warn(dev, "ignoring dependency for device, assuming no driver");
-
-	return -ENODEV;
-}
-
-/**
- * driver_deferred_probe_check_state_continue() - check deferred probe state
- * @dev: device to check
- *
- * Returns -ETIMEDOUT if deferred probe debug timeout has expired, or
- * -EPROBE_DEFER otherwise.
- *
- * Drivers or subsystems can opt-in to calling this function instead of
- * directly returning -EPROBE_DEFER.
- *
- * This is similar to driver_deferred_probe_check_state(), but it allows the
- * subsystem to keep deferring probe after built-in drivers have had a chance
- * to probe. One scenario where that is useful is if built-in drivers rely on
- * resources that are provided by modular drivers.
- */
-int driver_deferred_probe_check_state_continue(struct device *dev)
-{
-	int ret;
+	if (!IS_ENABLED(CONFIG_MODULES) && initcalls_done) {
+		dev_warn(dev, "ignoring dependency for device, assuming no driver");
+		return -ENODEV;
+	}
 
-	ret = __driver_deferred_probe_check_state(dev);
-	if (ret != -ENODEV)
-		return ret;
+	if (!deferred_probe_timeout) {
+		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
+		return -ETIMEDOUT;
+	}
 
 	return -EPROBE_DEFER;
 }

commit e2cec7d6853712295cef5377762165a489b2957f
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 25 05:08:24 2020 +0000

    driver core: Set deferred_probe_timeout to a longer default if CONFIG_MODULES is set
    
    When using modules, its common for the modules not to be loaded
    until quite late by userland. With the current code,
    driver_deferred_probe_check_state() will stop returning
    EPROBE_DEFER after late_initcall, which can cause module
    dependency resolution to fail after that.
    
    So allow a longer window of 30 seconds (picked somewhat
    arbitrarily, but influenced by the similar regulator core
    timeout value) in the case where modules are enabled.
    
    Cc: linux-pm@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200225050828.56458-3-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index d75b34de6964..fe26f2574a6d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -224,7 +224,16 @@ static int deferred_devs_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(deferred_devs);
 
+#ifdef CONFIG_MODULES
+/*
+ * In the case of modules, set the default probe timeout to
+ * 30 seconds to give userland some time to load needed modules
+ */
+static int deferred_probe_timeout = 30;
+#else
+/* In the case of !modules, no probe timeout needed */
 static int deferred_probe_timeout = -1;
+#endif
 static int __init deferred_probe_timeout_setup(char *str)
 {
 	int timeout;

commit c8c43cee29f6ca2575c953ae600263690db28f41
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 25 05:08:23 2020 +0000

    driver core: Fix driver_deferred_probe_check_state() logic
    
    driver_deferred_probe_check_state() has some uninituitive behavior.
    
    * From boot to late_initcall, it returns -EPROBE_DEFER
    
    * From late_initcall to the deferred_probe_timeout (if set)
      it returns -ENODEV
    
    * If the deferred_probe_timeout it set, after it fires, it
      returns -ETIMEDOUT
    
    This is a bit confusing, as its useful to have the function
    return -EPROBE_DEFER while the timeout is still running. This
    behavior has resulted in the somwhat duplicative
    driver_deferred_probe_check_state_continue() function being
    added.
    
    Thus this patch tries to improve the logic, so that it behaves
    as such:
    
    * If late_initcall has passed, and modules are not enabled
      it returns -ENODEV
    
    * If modules are enabled and deferred_probe_timeout is set,
      it returns -EPROBE_DEFER until the timeout, afterwhich it
      returns -ETIMEDOUT.
    
    * In all other cases, it returns -EPROBE_DEFER
    
    This will make the deferred_probe_timeout value much more
    functional, and will allow us to consolidate the
    driver_deferred_probe_check_state() and
    driver_deferred_probe_check_state_continue() logic in a later
    patch.
    
    Cc: linux-pm@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200225050828.56458-2-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index b25bcab2a26b..d75b34de6964 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -237,24 +237,26 @@ __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
 
 static int __driver_deferred_probe_check_state(struct device *dev)
 {
-	if (!initcalls_done)
-		return -EPROBE_DEFER;
+	if (!IS_ENABLED(CONFIG_MODULES) && initcalls_done)
+		return -ENODEV;
 
 	if (!deferred_probe_timeout) {
 		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
 		return -ETIMEDOUT;
 	}
 
-	return 0;
+	return -EPROBE_DEFER;
 }
 
 /**
  * driver_deferred_probe_check_state() - Check deferred probe state
  * @dev: device to check
  *
- * Returns -ENODEV if init is done and all built-in drivers have had a chance
- * to probe (i.e. initcalls are done), -ETIMEDOUT if deferred probe debug
- * timeout has expired, or -EPROBE_DEFER if none of those conditions are met.
+ * Return:
+ * -ENODEV if initcalls have completed and modules are disabled.
+ * -ETIMEDOUT if the deferred probe timeout was set and has expired
+ *  and modules are enabled.
+ * -EPROBE_DEFER in other cases.
  *
  * Drivers or subsystems can opt-in to calling this function instead of directly
  * returning -EPROBE_DEFER.
@@ -264,7 +266,7 @@ int driver_deferred_probe_check_state(struct device *dev)
 	int ret;
 
 	ret = __driver_deferred_probe_check_state(dev);
-	if (ret < 0)
+	if (ret != -ENODEV)
 		return ret;
 
 	dev_warn(dev, "ignoring dependency for device, assuming no driver");
@@ -292,7 +294,7 @@ int driver_deferred_probe_check_state_continue(struct device *dev)
 	int ret;
 
 	ret = __driver_deferred_probe_check_state(dev);
-	if (ret < 0)
+	if (ret != -ENODEV)
 		return ret;
 
 	return -EPROBE_DEFER;

commit 7c35e699c88bd60734277b26962783c60e04b494
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Dec 6 14:22:19 2019 +0100

    driver core: Print device when resources present in really_probe()
    
    If a device already has devres items attached before probing, a warning
    backtrace is printed.  However, this backtrace does not reveal the
    offending device, leaving the user uninformed.  Furthermore, using
    WARN_ON() causes systems with panic-on-warn to reboot.
    
    Fix this by replacing the WARN_ON() by a dev_crit() message.
    Abort probing the device, to prevent doing more damage to the device's
    resources.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20191206132219.28908-1-geert+renesas@glider.be
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index d811e60610d3..b25bcab2a26b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -516,7 +516,10 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
 		 drv->bus->name, __func__, drv->name, dev_name(dev));
-	WARN_ON(!list_empty(&dev->devres_head));
+	if (!list_empty(&dev->devres_head)) {
+		dev_crit(dev, "Resources present before probing\n");
+		return -EBUSY;
+	}
 
 re_probe:
 	dev->driver = drv;

commit 33cbfe54499338af08ab906a99afac247ea533f6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 27 21:41:06 2019 +0200

    Revert "driver core: Add edit_links() callback for drivers"
    
    This reverts commit 134b23eec9e3a3c795a6ceb0efe2fa63e87983b2.
    
    Based on a lot of email and in-person discussions, this patch series is
    being reworked to address a number of issues that were pointed out that
    needed to be taken care of before it should be merged.  It will be
    resubmitted with those changes hopefully soon.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 55fbc2467b37..d811e60610d3 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -710,12 +710,6 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
-	if (drv->edit_links) {
-		if (drv->edit_links(dev))
-			dev->has_edit_links = true;
-		else
-			device_link_remove_from_wfs(dev);
-	}
 	pm_runtime_get_suppliers(dev);
 	if (dev->parent)
 		pm_runtime_get_sync(dev->parent);
@@ -804,29 +798,6 @@ struct device_attach_data {
 	bool have_async;
 };
 
-static int __driver_edit_links(struct device_driver *drv, void *data)
-{
-	struct device *dev = data;
-
-	if (!drv->edit_links)
-		return 0;
-
-	if (driver_match_device(drv, dev) <= 0)
-		return 0;
-
-	return drv->edit_links(dev);
-}
-
-int driver_edit_links(struct device *dev)
-{
-	int ret;
-
-	device_lock(dev);
-	ret = bus_for_each_drv(dev->bus, NULL, dev, __driver_edit_links);
-	device_unlock(dev);
-	return ret;
-}
-
 static int __device_attach_driver(struct device_driver *drv, void *_data)
 {
 	struct device_attach_data *data = _data;

commit 97e2551de3f91add297c1dc4c9dc95297eaadf12
Merge: b3173c2292fb 23b6904442d0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 2 12:47:05 2019 +0200

    Merge tag 'dev_groups_all_drivers' into driver-core-next
    
    dev_groups added to struct driver
    
    Persistent tag for others to pull this branch from
    
    This is the first patch in a longer series that adds the ability for the
    driver core to create and remove a list of attribute groups
    automatically when the device is bound/unbound from a specific driver.
    
    See:
            https://lore.kernel.org/r/20190731124349.4474-2-gregkh@linuxfoundation.org
    for details on this patch, and examples of how to use it in other
    drivers.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 23b6904442d08b7dbed7622ed33b236d41a3aa8b
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Jul 31 14:43:40 2019 +0200

    driver core: add dev_groups to all drivers
    
    Add the ability for the driver core to create and remove a list of
    attribute groups automatically when the device is bound/unbound from a
    specific driver.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Tested-by: Richard Gong <richard.gong@linux.intel.com>
    Link: https://lore.kernel.org/r/20190731124349.4474-2-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 994a90747420..d811e60610d3 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -554,9 +554,16 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 			goto probe_failed;
 	}
 
+	if (device_add_groups(dev, drv->dev_groups)) {
+		dev_err(dev, "device_add_groups() failed\n");
+		goto dev_groups_failed;
+	}
+
 	if (test_remove) {
 		test_remove = false;
 
+		device_remove_groups(dev, drv->dev_groups);
+
 		if (dev->bus->remove)
 			dev->bus->remove(dev);
 		else if (drv->remove)
@@ -584,6 +591,11 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 	goto done;
 
+dev_groups_failed:
+	if (dev->bus->remove)
+		dev->bus->remove(dev);
+	else if (drv->remove)
+		drv->remove(dev);
 probe_failed:
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
@@ -1114,6 +1126,8 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 
 		pm_runtime_put_sync(dev);
 
+		device_remove_groups(dev, drv->dev_groups);
+
 		if (dev->bus && dev->bus->remove)
 			dev->bus->remove(dev);
 		else if (drv->remove)

commit 134b23eec9e3a3c795a6ceb0efe2fa63e87983b2
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 31 15:17:15 2019 -0700

    driver core: Add edit_links() callback for drivers
    
    The driver core/bus adding supplier-consumer dependencies by default
    enables functional dependencies to be tracked correctly even when the
    consumer devices haven't had their drivers registered or loaded (if they
    are modules).
    
    However, when the bus incorrectly adds dependencies that it shouldn't
    have added, the devices might never probe.
    
    For example, if device-C is a consumer of device-S and they have
    phandles to each other in DT, the following could happen:
    
    1.  Device-S get added first.
    2.  The bus add_links() callback will (incorrectly) try to link it as
        a consumer of device-C.
    3.  Since device-C isn't present, device-S will be put in
        "waiting-for-supplier" list.
    4.  Device-C gets added next.
    5.  All devices in "waiting-for-supplier" list are retried for linking.
    6.  Device-S gets linked as consumer to Device-C.
    7.  The bus add_links() callback will (correctly) try to link it as
        a consumer of device-S.
    8.  This isn't allowed because it would create a cyclic device links.
    
    Neither devices will get probed since the supplier is marked as
    dependent on the consumer. And the consumer will never probe because the
    consumer can't get resources from the supplier.
    
    Without this patch, things stay in this broken state. However, with this
    patch, the execution will continue like this:
    
    9.  Device-C's driver is loaded.
    10. Device-C's driver removes Device-S as a consumer of Device-C.
    11. Device-C's driver adds Device-C as a consumer of Device-S.
    12. Device-S probes.
    14. Device-C probes.
    
    kbuild test robot reported missing documentation for device.has_edit_links
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190731221721.187713-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 994a90747420..5e7041ede0d7 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -698,6 +698,12 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
+	if (drv->edit_links) {
+		if (drv->edit_links(dev))
+			dev->has_edit_links = true;
+		else
+			device_link_remove_from_wfs(dev);
+	}
 	pm_runtime_get_suppliers(dev);
 	if (dev->parent)
 		pm_runtime_get_sync(dev->parent);
@@ -786,6 +792,29 @@ struct device_attach_data {
 	bool have_async;
 };
 
+static int __driver_edit_links(struct device_driver *drv, void *data)
+{
+	struct device *dev = data;
+
+	if (!drv->edit_links)
+		return 0;
+
+	if (driver_match_device(drv, dev) <= 0)
+		return 0;
+
+	return drv->edit_links(dev);
+}
+
+int driver_edit_links(struct device *dev)
+{
+	int ret;
+
+	device_lock(dev);
+	ret = bus_for_each_drv(dev->bus, NULL, dev, __driver_edit_links);
+	device_unlock(dev);
+	return ret;
+}
+
 static int __device_attach_driver(struct device_driver *drv, void *_data)
 {
 	struct device_attach_data *data = _data;

commit 62a6bc3a1e4f4ee9ae0076fa295f9af1c3725ce3
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jun 21 17:17:25 2019 +0200

    driver: core: Allow subsystems to continue deferring probe
    
    Some subsystems, such as pinctrl, allow continuing to defer probe
    indefinitely. This is useful for devices that depend on resources
    provided by devices that are only probed after the init stage.
    
    One example of this can be seen on Tegra, where the DPAUX hardware
    contains pinmuxing controls for pins that it shares with an I2C
    controller. The I2C controller is typically used for communication
    with a monitor over HDMI (DDC). However, other instances of the I2C
    controller are used to access system critical components, such as a
    PMIC. The I2C controller driver will therefore usually be a builtin
    driver, whereas the DPAUX driver is part of the display driver that
    is loaded from a module to avoid bloating the kernel image with all
    of the DRM/KMS subsystem.
    
    In this particular case the pins used by this I2C/DDC controller
    become accessible very late in the boot process. However, since the
    controller is only used in conjunction with display, that's not an
    issue.
    
    Unfortunately the driver core currently outputs a warning message
    when a device fails to get the pinctrl before the end of the init
    stage. That can be confusing for the user because it may sound like
    an unwanted error occurred, whereas it's really an expected and
    harmless situation.
    
    In order to eliminate this warning, this patch allows callers of the
    driver_deferred_probe_check_state() helper to specify that they want
    to continue deferring probe, regardless of whether we're past the
    init stage or not. All of the callers of that function are updated
    for the new signature, but only the pinctrl subsystem passes a true
    value in the new persist parameter if appropriate.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190621151725.20414-1-thierry.reding@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 0df9b4461766..994a90747420 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -235,6 +235,19 @@ static int __init deferred_probe_timeout_setup(char *str)
 }
 __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
 
+static int __driver_deferred_probe_check_state(struct device *dev)
+{
+	if (!initcalls_done)
+		return -EPROBE_DEFER;
+
+	if (!deferred_probe_timeout) {
+		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
 /**
  * driver_deferred_probe_check_state() - Check deferred probe state
  * @dev: device to check
@@ -248,14 +261,40 @@ __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
  */
 int driver_deferred_probe_check_state(struct device *dev)
 {
-	if (initcalls_done) {
-		if (!deferred_probe_timeout) {
-			dev_WARN(dev, "deferred probe timeout, ignoring dependency");
-			return -ETIMEDOUT;
-		}
-		dev_warn(dev, "ignoring dependency for device, assuming no driver");
-		return -ENODEV;
-	}
+	int ret;
+
+	ret = __driver_deferred_probe_check_state(dev);
+	if (ret < 0)
+		return ret;
+
+	dev_warn(dev, "ignoring dependency for device, assuming no driver");
+
+	return -ENODEV;
+}
+
+/**
+ * driver_deferred_probe_check_state_continue() - check deferred probe state
+ * @dev: device to check
+ *
+ * Returns -ETIMEDOUT if deferred probe debug timeout has expired, or
+ * -EPROBE_DEFER otherwise.
+ *
+ * Drivers or subsystems can opt-in to calling this function instead of
+ * directly returning -EPROBE_DEFER.
+ *
+ * This is similar to driver_deferred_probe_check_state(), but it allows the
+ * subsystem to keep deferring probe after built-in drivers have had a chance
+ * to probe. One scenario where that is useful is if built-in drivers rely on
+ * resources that are provided by modular drivers.
+ */
+int driver_deferred_probe_check_state_continue(struct device *dev)
+{
+	int ret;
+
+	ret = __driver_deferred_probe_check_state(dev);
+	if (ret < 0)
+		return ret;
+
 	return -EPROBE_DEFER;
 }
 

commit 0b777eee88d712256ba8232a9429edb17c4f9ceb
Author: John Garry <john.garry@huawei.com>
Date:   Thu Mar 28 18:08:05 2019 +0800

    driver core: Postpone DMA tear-down until after devres release for probe failure
    
    In commit 376991db4b64 ("driver core: Postpone DMA tear-down until after
    devres release"), we changed the ordering of tearing down the device DMA
    ops and releasing all the device's resources; this was because the DMA ops
    should be maintained until we release the device's managed DMA memories.
    
    However, we have seen another crash on an arm64 system when a
    device driver probe fails:
    
      hisi_sas_v3_hw 0000:74:02.0: Adding to iommu group 2
      scsi host1: hisi_sas_v3_hw
      BUG: Bad page state in process swapper/0  pfn:313f5
      page:ffff7e0000c4fd40 count:1 mapcount:0
      mapping:0000000000000000 index:0x0
      flags: 0xfffe00000001000(reserved)
      raw: 0fffe00000001000 ffff7e0000c4fd48 ffff7e0000c4fd48
    0000000000000000
      raw: 0000000000000000 0000000000000000 00000001ffffffff
    0000000000000000
      page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set
      bad because of flags: 0x1000(reserved)
      Modules linked in:
      CPU: 49 PID: 1 Comm: swapper/0 Not tainted
    5.1.0-rc1-43081-g22d97fd-dirty #1433
      Hardware name: Huawei D06/D06, BIOS Hisilicon D06 UEFI
    RC0 - V1.12.01 01/29/2019
      Call trace:
      dump_backtrace+0x0/0x118
      show_stack+0x14/0x1c
      dump_stack+0xa4/0xc8
      bad_page+0xe4/0x13c
      free_pages_check_bad+0x4c/0xc0
      __free_pages_ok+0x30c/0x340
      __free_pages+0x30/0x44
      __dma_direct_free_pages+0x30/0x38
      dma_direct_free+0x24/0x38
      dma_free_attrs+0x9c/0xd8
      dmam_release+0x20/0x28
      release_nodes+0x17c/0x220
      devres_release_all+0x34/0x54
      really_probe+0xc4/0x2c8
      driver_probe_device+0x58/0xfc
      device_driver_attach+0x68/0x70
      __driver_attach+0x94/0xdc
      bus_for_each_dev+0x5c/0xb4
      driver_attach+0x20/0x28
      bus_add_driver+0x14c/0x200
      driver_register+0x6c/0x124
      __pci_register_driver+0x48/0x50
      sas_v3_pci_driver_init+0x20/0x28
      do_one_initcall+0x40/0x25c
      kernel_init_freeable+0x2b8/0x3c0
      kernel_init+0x10/0x100
      ret_from_fork+0x10/0x18
      Disabling lock debugging due to kernel taint
      BUG: Bad page state in process swapper/0  pfn:313f6
      page:ffff7e0000c4fd80 count:1 mapcount:0
    mapping:0000000000000000 index:0x0
    [   89.322983] flags: 0xfffe00000001000(reserved)
      raw: 0fffe00000001000 ffff7e0000c4fd88 ffff7e0000c4fd88
    0000000000000000
      raw: 0000000000000000 0000000000000000 00000001ffffffff
    0000000000000000
    
    The crash occurs for the same reason.
    
    In this case, on the really_probe() failure path, we are still clearing
    the DMA ops prior to releasing the device's managed memories.
    
    This patch fixes this issue by reordering the DMA ops teardown and the
    call to devres_release_all() on the failure path.
    
    Reported-by: Xiang Chen <chenxiang66@hisilicon.com>
    Tested-by: Xiang Chen <chenxiang66@hisilicon.com>
    Signed-off-by: John Garry <john.garry@huawei.com>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a823f469e53f..0df9b4461766 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -490,7 +490,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	if (dev->bus->dma_configure) {
 		ret = dev->bus->dma_configure(dev);
 		if (ret)
-			goto dma_failed;
+			goto probe_failed;
 	}
 
 	if (driver_sysfs_add(dev)) {
@@ -546,14 +546,13 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	goto done;
 
 probe_failed:
-	arch_teardown_dma_ops(dev);
-dma_failed:
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);
 pinctrl_bind_failed:
 	device_links_no_driver(dev);
 	devres_release_all(dev);
+	arch_teardown_dma_ops(dev);
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
 	dev_set_drvdata(dev, NULL);

commit 1ea61b68d0f8685775c897c2de040c73b8d1c56a
Author: Feng Tang <feng.tang@intel.com>
Date:   Wed Feb 13 15:47:36 2019 +0800

    async: Add cmdline option to specify drivers to be async probed
    
    Asynchronous driver probing can help much on kernel fastboot, and
    this option can provide a flexible way to optimize and quickly verify
    async driver probe.
    
    Also it will help in below cases:
    * Some driver actually covers several families of HWs, some of which
      could use async probing while others don't. So we can't simply
      turn on the PROBE_PREFER_ASYNCHRONOUS flag in driver, but use this
      cmdline option, like igb driver async patch discussed at
      https://www.spinics.net/lists/netdev/msg545986.html
    
    * For SOC (System on Chip) with multiple spi or i2c controllers, most
      of the slave spi/i2c devices will be assigned with fixed controller
      number, while async probing may make those controllers get different
      index for each boot, which prevents those controller drivers to be
      async probed. For platforms not using these spi/i2c slave devices,
      they can use this cmdline option to benefit from the async probing.
    
    Suggested-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 348fc4695d4d..a823f469e53f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -57,6 +57,10 @@ static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 static struct dentry *deferred_devices;
 static bool initcalls_done;
 
+/* Save the async probe drivers' name from kernel cmdline */
+#define ASYNC_DRV_NAMES_MAX_LEN	256
+static char async_probe_drv_names[ASYNC_DRV_NAMES_MAX_LEN];
+
 /*
  * In some cases, like suspend to RAM or hibernation, It might be reasonable
  * to prohibit probing of devices as it could be unsafe.
@@ -674,6 +678,23 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	return ret;
 }
 
+static inline bool cmdline_requested_async_probing(const char *drv_name)
+{
+	return parse_option_str(async_probe_drv_names, drv_name);
+}
+
+/* The option format is "driver_async_probe=drv_name1,drv_name2,..." */
+static int __init save_async_options(char *buf)
+{
+	if (strlen(buf) >= ASYNC_DRV_NAMES_MAX_LEN)
+		printk(KERN_WARNING
+			"Too long list of driver names for 'driver_async_probe'!\n");
+
+	strlcpy(async_probe_drv_names, buf, ASYNC_DRV_NAMES_MAX_LEN);
+	return 0;
+}
+__setup("driver_async_probe=", save_async_options);
+
 bool driver_allows_async_probing(struct device_driver *drv)
 {
 	switch (drv->probe_type) {
@@ -684,6 +705,9 @@ bool driver_allows_async_probing(struct device_driver *drv)
 		return false;
 
 	default:
+		if (cmdline_requested_async_probing(drv->name))
+			return true;
+
 		if (module_requested_async_probing(drv->owner))
 			return true;
 

commit 376991db4b6464e906d699ef07681e2ffa8ab08c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Feb 7 20:36:53 2019 +0100

    driver core: Postpone DMA tear-down until after devres release
    
    When unbinding the (IOMMU-enabled) R-Car SATA device on Salvator-XS
    (R-Car H3 ES2.0), in preparation of rebinding against vfio-platform for
    device pass-through for virtualization:
    
      echo ee300000.sata > /sys/bus/platform/drivers/sata_rcar/unbind
    
    the kernel crashes with:
    
      Unable to handle kernel paging request at virtual address ffffffbf029ffffc
      Mem abort info:
       ESR = 0x96000006
       Exception class = DABT (current EL), IL = 32 bits
       SET = 0, FnV = 0
       EA = 0, S1PTW = 0
      Data abort info:
       ISV = 0, ISS = 0x00000006
       CM = 0, WnR = 0
      swapper pgtable: 4k pages, 39-bit VAs, pgdp = 000000007e8c586c
      [ffffffbf029ffffc] pgd=000000073bfc6003, pud=000000073bfc6003, pmd=0000000000000000
      Internal error: Oops: 96000006 [#1] SMP
      Modules linked in:
      CPU: 0 PID: 1098 Comm: bash Not tainted 5.0.0-rc5-salvator-x-00452-g37596f884f4318ef #287
      Hardware name: Renesas Salvator-X 2nd version board based on r8a7795 ES2.0+ (DT)
      pstate: 60400005 (nZCv daif +PAN -UAO)
      pc : __free_pages+0x8/0x58
      lr : __dma_direct_free_pages+0x50/0x5c
      sp : ffffff801268baa0
      x29: ffffff801268baa0 x28: 0000000000000000
      x27: ffffffc6f9c60bf0 x26: ffffffc6f9c60bf0
      x25: ffffffc6f9c60810 x24: 0000000000000000
      x23: 00000000fffff000 x22: ffffff8012145000
      x21: 0000000000000800 x20: ffffffbf029fffc8
      x19: 0000000000000000 x18: ffffffc6f86c42c8
      x17: 0000000000000000 x16: 0000000000000070
      x15: 0000000000000003 x14: 0000000000000000
      x13: ffffff801103d7f8 x12: 0000000000000028
      x11: ffffff8011117604 x10: 0000000000009ad8
      x9 : ffffff80110126d0 x8 : ffffffc6f7563000
      x7 : 6b6b6b6b6b6b6b6b x6 : 0000000000000018
      x5 : ffffff8011cf3cc8 x4 : 0000000000004000
      x3 : 0000000000080000 x2 : 0000000000000001
      x1 : 0000000000000000 x0 : ffffffbf029fffc8
      Process bash (pid: 1098, stack limit = 0x00000000c38e3e32)
      Call trace:
      __free_pages+0x8/0x58
      __dma_direct_free_pages+0x50/0x5c
      arch_dma_free+0x1c/0x98
      dma_direct_free+0x14/0x24
      dma_free_attrs+0x9c/0xdc
      dmam_release+0x18/0x20
      release_nodes+0x25c/0x28c
      devres_release_all+0x48/0x4c
      device_release_driver_internal+0x184/0x1f0
      device_release_driver+0x14/0x1c
      unbind_store+0x70/0xb8
      drv_attr_store+0x24/0x34
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x154/0x1c4
      __vfs_write+0x34/0x164
      vfs_write+0xb4/0x16c
      ksys_write+0x5c/0xbc
      __arm64_sys_write+0x14/0x1c
      el0_svc_common+0x98/0x114
      el0_svc_handler+0x1c/0x24
      el0_svc+0x8/0xc
      Code: d51b4234 17fffffa a9bf7bfd 910003fd (b9403404)
      ---[ end trace 8c564cdd3a1a840f ]---
    
    While I've bisected this to commit e8e683ae9a736407 ("iommu/of: Fix
    probe-deferral"), and reverting that commit on post-v5.0-rc4 kernels
    does fix the problem, this turned out to be a red herring.
    
    On arm64, arch_teardown_dma_ops() resets dev->dma_ops to NULL.
    Hence if a driver has used a managed DMA allocation API, the allocated
    DMA memory will be freed using the direct DMA ops, while it may have
    been allocated using a custom DMA ops (iommu_dma_ops in this case).
    
    Fix this by reversing the order of the calls to devres_release_all() and
    arch_teardown_dma_ops().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 2e898cbba79b..348fc4695d4d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -1058,9 +1058,9 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 			drv->remove(dev);
 
 		device_links_driver_cleanup(dev);
-		arch_teardown_dma_ops(dev);
 
 		devres_release_all(dev);
+		arch_teardown_dma_ops(dev);
 		dev->driver = NULL;
 		dev_set_drvdata(dev, NULL);
 		if (dev->pm_domain && dev->pm_domain->dismiss)

commit e7dd40105aac9ba051e44ad711123bc53a5e4c71
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:59:42 2019 +0100

    driver core: Add device link flag DL_FLAG_AUTOPROBE_CONSUMER
    
    Add a new device link flag, DL_FLAG_AUTOPROBE_CONSUMER, to request the
    driver core to probe for a consumer driver automatically after binding
    a driver to the supplier device on a persistent managed device link.
    
    As unbinding the supplier driver on a managed device link causes the
    consumer driver to be detached from its device automatically, this
    flag provides a complementary mechanism which is needed to address
    some "composite device" use cases.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index aa6a9c613595..2e898cbba79b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -116,7 +116,7 @@ static void deferred_probe_work_func(struct work_struct *work)
 }
 static DECLARE_WORK(deferred_probe_work, deferred_probe_work_func);
 
-static void driver_deferred_probe_add(struct device *dev)
+void driver_deferred_probe_add(struct device *dev)
 {
 	mutex_lock(&deferred_probe_mutex);
 	if (list_empty(&dev->p->deferred_probe)) {

commit c37e20eaf4b21125898fd454f3ea6b212865d0a6
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:37 2019 -0800

    driver core: Attach devices on CPU local to device node
    
    Call the asynchronous probe routines on a CPU local to the device node. By
    doing this we should be able to improve our initialization time
    significantly as we can avoid having to access the device from a remote
    node which may introduce higher latency.
    
    For example, in the case of initializing memory for NVDIMM this can have a
    significant impact as initialing 3TB on remote node can take up to 39
    seconds while initialing it on a local node only takes 23 seconds. It is
    situations like this where we will see the biggest improvement.
    
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 627ad05064e0..aa6a9c613595 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -829,7 +829,7 @@ static int __device_attach(struct device *dev, bool allow_async)
 			 */
 			dev_dbg(dev, "scheduling asynchronous probe\n");
 			get_device(dev);
-			async_schedule(__device_attach_async_helper, dev);
+			async_schedule_dev(__device_attach_async_helper, dev);
 		} else {
 			pm_request_idle(dev);
 		}
@@ -989,7 +989,7 @@ static int __driver_attach(struct device *dev, void *data)
 		if (!dev->driver) {
 			get_device(dev);
 			dev->p->async_driver = drv;
-			async_schedule(__driver_attach_async_helper, dev);
+			async_schedule_dev(__driver_attach_async_helper, dev);
 		}
 		device_unlock(dev);
 		return 0;

commit ef0ff68351be4fd83bec2d797f0efdc0174a55a4
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:21 2019 -0800

    driver core: Probe devices asynchronously instead of the driver
    
    Probe devices asynchronously instead of the driver. This results in us
    seeing the same behavior if the device is registered before the driver or
    after. This way we can avoid serializing the initialization should the
    driver not be loaded until after the devices have already been added.
    
    The motivation behind this is that if we have a set of devices that
    take a significant amount of time to load we can greatly reduce the time to
    load by processing them in parallel instead of one at a time. In addition,
    each device can exist on a different node so placing a single thread on one
    CPU to initialize all of the devices for a given driver can result in poor
    performance on a system with multiple nodes.
    
    This approach can reduce the time needed to scan SCSI LUNs significantly.
    The only way to realize that speedup is by enabling more concurrency which
    is what is achieved with this patch.
    
    To achieve this it was necessary to add a new member "async_driver" to the
    device_private structure to store the driver pointer while we wait on the
    deferred probe call.
    
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 34556359c7da..627ad05064e0 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -925,6 +925,30 @@ int device_driver_attach(struct device_driver *drv, struct device *dev)
 	return ret;
 }
 
+static void __driver_attach_async_helper(void *_dev, async_cookie_t cookie)
+{
+	struct device *dev = _dev;
+	struct device_driver *drv;
+	int ret = 0;
+
+	__device_driver_lock(dev, dev->parent);
+
+	drv = dev->p->async_driver;
+
+	/*
+	 * If device has been removed or someone has already successfully
+	 * bound a driver before us just skip the driver probe call.
+	 */
+	if (!dev->p->dead && !dev->driver)
+		ret = driver_probe_device(drv, dev);
+
+	__device_driver_unlock(dev, dev->parent);
+
+	dev_dbg(dev, "driver %s async attach completed: %d\n", drv->name, ret);
+
+	put_device(dev);
+}
+
 static int __driver_attach(struct device *dev, void *data)
 {
 	struct device_driver *drv = data;
@@ -952,6 +976,25 @@ static int __driver_attach(struct device *dev, void *data)
 		return ret;
 	} /* ret > 0 means positive match */
 
+	if (driver_allows_async_probing(drv)) {
+		/*
+		 * Instead of probing the device synchronously we will
+		 * probe it asynchronously to allow for more parallelism.
+		 *
+		 * We only take the device lock here in order to guarantee
+		 * that the dev->driver and async_driver fields are protected
+		 */
+		dev_dbg(dev, "probing driver %s asynchronously\n", drv->name);
+		device_lock(dev);
+		if (!dev->driver) {
+			get_device(dev);
+			dev->p->async_driver = drv;
+			async_schedule(__driver_attach_async_helper, dev);
+		}
+		device_unlock(dev);
+		return 0;
+	}
+
 	device_driver_attach(drv, dev);
 
 	return 0;

commit ed88747c6c4a2fc2f961a36d4c50cb0868c30229
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:16 2019 -0800

    device core: Consolidate locking and unlocking of parent and device
    
    Try to consolidate all of the locking and unlocking of both the parent and
    device when attaching or removing a driver from a given device.
    
    To do that I first consolidated the lock pattern into two functions
    __device_driver_lock and __device_driver_unlock. After doing that I then
    created functions specific to attaching and detaching the driver while
    acquiring these locks. By doing this I was able to reduce the number of
    spots where we touch need_parent_lock from 12 down to 4.
    
    This patch should produce no functional changes, it is meant to be a code
    clean-up/consolidation only.
    
    Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 636cd16b1b62..34556359c7da 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -867,6 +867,64 @@ void device_initial_probe(struct device *dev)
 	__device_attach(dev, true);
 }
 
+/*
+ * __device_driver_lock - acquire locks needed to manipulate dev->drv
+ * @dev: Device we will update driver info for
+ * @parent: Parent device. Needed if the bus requires parent lock
+ *
+ * This function will take the required locks for manipulating dev->drv.
+ * Normally this will just be the @dev lock, but when called for a USB
+ * interface, @parent lock will be held as well.
+ */
+static void __device_driver_lock(struct device *dev, struct device *parent)
+{
+	if (parent && dev->bus->need_parent_lock)
+		device_lock(parent);
+	device_lock(dev);
+}
+
+/*
+ * __device_driver_unlock - release locks needed to manipulate dev->drv
+ * @dev: Device we will update driver info for
+ * @parent: Parent device. Needed if the bus requires parent lock
+ *
+ * This function will release the required locks for manipulating dev->drv.
+ * Normally this will just be the the @dev lock, but when called for a
+ * USB interface, @parent lock will be released as well.
+ */
+static void __device_driver_unlock(struct device *dev, struct device *parent)
+{
+	device_unlock(dev);
+	if (parent && dev->bus->need_parent_lock)
+		device_unlock(parent);
+}
+
+/**
+ * device_driver_attach - attach a specific driver to a specific device
+ * @drv: Driver to attach
+ * @dev: Device to attach it to
+ *
+ * Manually attach driver to a device. Will acquire both @dev lock and
+ * @dev->parent lock if needed.
+ */
+int device_driver_attach(struct device_driver *drv, struct device *dev)
+{
+	int ret = 0;
+
+	__device_driver_lock(dev, dev->parent);
+
+	/*
+	 * If device has been removed or someone has already successfully
+	 * bound a driver before us just skip the driver probe call.
+	 */
+	if (!dev->p->dead && !dev->driver)
+		ret = driver_probe_device(drv, dev);
+
+	__device_driver_unlock(dev, dev->parent);
+
+	return ret;
+}
+
 static int __driver_attach(struct device *dev, void *data)
 {
 	struct device_driver *drv = data;
@@ -894,14 +952,7 @@ static int __driver_attach(struct device *dev, void *data)
 		return ret;
 	} /* ret > 0 means positive match */
 
-	if (dev->parent && dev->bus->need_parent_lock)
-		device_lock(dev->parent);
-	device_lock(dev);
-	if (!dev->p->dead && !dev->driver)
-		driver_probe_device(drv, dev);
-	device_unlock(dev);
-	if (dev->parent && dev->bus->need_parent_lock)
-		device_unlock(dev->parent);
+	device_driver_attach(drv, dev);
 
 	return 0;
 }
@@ -932,15 +983,11 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 	drv = dev->driver;
 	if (drv) {
 		while (device_links_busy(dev)) {
-			device_unlock(dev);
-			if (parent && dev->bus->need_parent_lock)
-				device_unlock(parent);
+			__device_driver_unlock(dev, parent);
 
 			device_links_unbind_consumers(dev);
-			if (parent && dev->bus->need_parent_lock)
-				device_lock(parent);
 
-			device_lock(dev);
+			__device_driver_lock(dev, parent);
 			/*
 			 * A concurrent invocation of the same function might
 			 * have released the driver successfully while this one
@@ -993,16 +1040,12 @@ void device_release_driver_internal(struct device *dev,
 				    struct device_driver *drv,
 				    struct device *parent)
 {
-	if (parent && dev->bus->need_parent_lock)
-		device_lock(parent);
+	__device_driver_lock(dev, parent);
 
-	device_lock(dev);
 	if (!drv || drv == dev->driver)
 		__device_release_driver(dev, parent);
 
-	device_unlock(dev);
-	if (parent && dev->bus->need_parent_lock)
-		device_unlock(parent);
+	__device_driver_unlock(dev, parent);
 }
 
 /**
@@ -1027,6 +1070,18 @@ void device_release_driver(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(device_release_driver);
 
+/**
+ * device_driver_detach - detach driver from a specific device
+ * @dev: device to detach driver from
+ *
+ * Detach driver from device. Will acquire both @dev lock and @dev->parent
+ * lock if needed.
+ */
+void device_driver_detach(struct device *dev)
+{
+	device_release_driver_internal(dev, NULL, dev->parent);
+}
+
 /**
  * driver_detach - detach driver from all devices it controls.
  * @drv: driver.

commit 3451a495ef244a88ed6317a035299d835554d579
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:10 2019 -0800

    driver core: Establish order of operations for device_add and device_del via bitflag
    
    Add an additional bit flag to the device_private struct named "dead".
    
    This additional flag provides a guarantee that when a device_del is
    executed on a given interface an async worker will not attempt to attach
    the driver following the earlier device_del call. Previously this
    guarantee was not present and could result in the device_del call
    attempting to remove a driver from an interface only to have the async
    worker attempt to probe the driver later when it finally completes the
    asynchronous probe call.
    
    One additional change added was that I pulled the check for dev->driver
    out of the __device_attach_driver call and instead placed it in the
    __device_attach_async_helper call. This was motivated by the fact that the
    only other caller of this, __device_attach, had already taken the
    device_lock() and checked for dev->driver. Instead of testing for this
    twice in this path it makes more sense to just consolidate the dev->dead
    and dev->driver checks together into one set of checks.
    
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 8ac10af17c00..636cd16b1b62 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -731,15 +731,6 @@ static int __device_attach_driver(struct device_driver *drv, void *_data)
 	bool async_allowed;
 	int ret;
 
-	/*
-	 * Check if device has already been claimed. This may
-	 * happen with driver loading, device discovery/registration,
-	 * and deferred probe processing happens all at once with
-	 * multiple threads.
-	 */
-	if (dev->driver)
-		return -EBUSY;
-
 	ret = driver_match_device(drv, dev);
 	if (ret == 0) {
 		/* no match */
@@ -774,6 +765,15 @@ static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)
 
 	device_lock(dev);
 
+	/*
+	 * Check if device has already been removed or claimed. This may
+	 * happen with driver loading, device discovery/registration,
+	 * and deferred probe processing happens all at once with
+	 * multiple threads.
+	 */
+	if (dev->p->dead || dev->driver)
+		goto out_unlock;
+
 	if (dev->parent)
 		pm_runtime_get_sync(dev->parent);
 
@@ -784,7 +784,7 @@ static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)
 
 	if (dev->parent)
 		pm_runtime_put(dev->parent);
-
+out_unlock:
 	device_unlock(dev);
 
 	put_device(dev);
@@ -897,7 +897,7 @@ static int __driver_attach(struct device *dev, void *data)
 	if (dev->parent && dev->bus->need_parent_lock)
 		device_lock(dev->parent);
 	device_lock(dev);
-	if (!dev->driver)
+	if (!dev->p->dead && !dev->driver)
 		driver_probe_device(drv, dev);
 	device_unlock(dev);
 	if (dev->parent && dev->bus->need_parent_lock)

commit e121a833745b4708b660e3fe6776129c2956b041
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 13 19:27:47 2018 +0100

    driver core: Add missing dev->bus->need_parent_lock checks
    
    __device_release_driver() has to check dev->bus->need_parent_lock
    before dropping the parent lock and acquiring it again as it may
    attempt to drop a lock that hasn't been acquired or lock a device
    that shouldn't be locked and create a lock imbalance.
    
    Fixes: 8c97a46af04b (driver core: hold dev's parent lock when needed)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 88713f182086..8ac10af17c00 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -933,11 +933,11 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 	if (drv) {
 		while (device_links_busy(dev)) {
 			device_unlock(dev);
-			if (parent)
+			if (parent && dev->bus->need_parent_lock)
 				device_unlock(parent);
 
 			device_links_unbind_consumers(dev);
-			if (parent)
+			if (parent && dev->bus->need_parent_lock)
 				device_lock(parent);
 
 			device_lock(dev);

commit c37d721c68ad88925ba0e72f6e14acb829a8c6bb
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Wed Nov 28 16:32:11 2018 -0800

    driver core: Move async_synchronize_full call
    
    Move the async_synchronize_full call out of __device_release_driver and
    into driver_detach.
    
    The idea behind this is that the async_synchronize_full call will only
    guarantee that any existing async operations are flushed. This doesn't do
    anything to guarantee that a hotplug event that may occur while we are
    doing the release of the driver will not be asynchronously scheduled.
    
    By moving this into the driver_detach path we can avoid potential deadlocks
    as we aren't holding the device lock at this point and we should not have
    the driver we want to flush loaded so the flush will take care of any
    asynchronous events the driver we are detaching might have scheduled.
    
    Fixes: 765230b5f084 ("driver-core: add asynchronous probing support for drivers")
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 689ac9dc6d81..88713f182086 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -931,9 +931,6 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 
 	drv = dev->driver;
 	if (drv) {
-		if (driver_allows_async_probing(drv))
-			async_synchronize_full();
-
 		while (device_links_busy(dev)) {
 			device_unlock(dev);
 			if (parent)
@@ -1039,6 +1036,9 @@ void driver_detach(struct device_driver *drv)
 	struct device_private *dev_prv;
 	struct device *dev;
 
+	if (driver_allows_async_probing(drv))
+		async_synchronize_full();
+
 	for (;;) {
 		spin_lock(&drv->p->klist_devices.k_lock);
 		if (list_empty(&drv->p->klist_devices.k_list)) {

commit dbf03d6569d76e74bb7b3253396ddd192f1c7b51
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon Nov 5 23:41:27 2018 -0800

    driver core: fix comments for device_block_probing()
    
    Correct function name and spelling/typo for device_block_probing()
    in drivers/base/dd.c.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 940abad069c0..689ac9dc6d81 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -179,7 +179,7 @@ static void driver_deferred_probe_trigger(void)
 }
 
 /**
- * device_block_probing() - Block/defere device's probes
+ * device_block_probing() - Block/defer device's probes
  *
  *	It will disable probing of devices and defer their probes instead.
  */
@@ -456,7 +456,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	if (defer_all_probes) {
 		/*
 		 * Value of defer_all_probes can be set only by
-		 * device_defer_all_probes_enable() which, in turn, will call
+		 * device_block_probing() which, in turn, will call
 		 * wait_for_device_probe() right after that to avoid any races.
 		 */
 		dev_dbg(dev, "Driver %s force probe deferral\n", drv->name);

commit 63c980470526842f2e5219ffdfeca7c3051c110c
Author: Muchun Song <smuchun@gmail.com>
Date:   Sun Oct 28 14:39:11 2018 +0800

    driver core: Replace simple_strtol by kstrtoint
    
    The simple_strtol() function is deprecated, use kstrtoint() instead.
    
    Signed-off-by: Muchun Song <smuchun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 169412ee4ae8..940abad069c0 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -223,7 +223,10 @@ DEFINE_SHOW_ATTRIBUTE(deferred_devs);
 static int deferred_probe_timeout = -1;
 static int __init deferred_probe_timeout_setup(char *str)
 {
-	deferred_probe_timeout = simple_strtol(str, NULL, 10);
+	int timeout;
+
+	if (!kstrtoint(str, 10, &timeout))
+		deferred_probe_timeout = timeout;
 	return 1;
 }
 __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);

commit dc3c05504d38849f77149cb962caeaedd1efa127
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 24 10:28:18 2018 +0200

    dma-mapping: remove dma_deconfigure
    
    This goes through a lot of hooks just to call arch_teardown_dma_ops.
    Replace it with a direct call instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 65128cf8427c..169412ee4ae8 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -539,7 +539,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	goto done;
 
 probe_failed:
-	dma_deconfigure(dev);
+	arch_teardown_dma_ops(dev);
 dma_failed:
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
@@ -968,7 +968,7 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 			drv->remove(dev);
 
 		device_links_driver_cleanup(dev);
-		dma_deconfigure(dev);
+		arch_teardown_dma_ops(dev);
 
 		devres_release_all(dev);
 		dev->driver = NULL;

commit ccf640f4c9988653ef884672381b03b9be247bec
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 24 09:40:24 2018 +0200

    dma-mapping: remove dma_configure
    
    There is no good reason for this indirection given that the method
    always exists.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index edfc9f0b1180..65128cf8427c 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -480,9 +480,11 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	if (ret)
 		goto pinctrl_bind_failed;
 
-	ret = dma_configure(dev);
-	if (ret)
-		goto dma_failed;
+	if (dev->bus->dma_configure) {
+		ret = dev->bus->dma_configure(dev);
+		if (ret)
+			goto dma_failed;
+	}
 
 	if (driver_sysfs_add(dev)) {
 		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",

commit d2fc88a61b4ea99f574bde16e92718e22f312136
Merge: e16f4f3e0b7d acb1872577b3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 30 10:08:09 2018 +0200

    Merge 4.18-rc7 into driver-core-next
    
    We need the driver core changes in here as well for testing.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 722e5f2b1eec7de61117b7c0a7914761e3da2eda
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 10 14:51:33 2018 +0200

    driver core: Partially revert "driver core: correct device's shutdown order"
    
    Commit 52cdbdd49853 (driver core: correct device's shutdown order)
    introduced a regression by breaking device shutdown on some systems.
    
    Namely, the devices_kset_move_last() call in really_probe() added by
    that commit is a mistake as it may cause parents to follow children
    in the devices_kset list which then causes shutdown to fail.  For
    example, if a device has children before really_probe() is called
    for it (which is not uncommon), that call will cause it to be
    reordered after the children in the devices_kset list and the
    ordering of that list will not reflect the correct device shutdown
    order any more.
    
    Also it causes the devices_kset list to be constantly reordered
    until all drivers have been probed which is totally pointless
    overhead in the majority of cases and it only covered an issue
    with system shutdown, while system-wide suspend/resume potentially
    had the same issue on the affected platforms (which was not covered).
    
    Moreover, the shutdown issue originally addressed by the change in
    really_probe() made by commit 52cdbdd49853 is not present in 4.18-rc
    any more, since dra7 started to use the sdhci-omap driver which
    doesn't disable any regulators during shutdown, so the really_probe()
    part of commit 52cdbdd49853 can be safely reverted.  [The original
    issue was related to the omap_hsmmc driver used by dra7 previously.]
    
    For the above reasons, revert the really_probe() modifications made
    by commit 52cdbdd49853.
    
    The other code changes made by commit 52cdbdd49853 are useful and
    they need not be reverted.
    
    Fixes: 52cdbdd49853 (driver core: correct device's shutdown order)
    Link: https://lore.kernel.org/lkml/CAFgQCTt7VfqM=UyCnvNFxrSw8Z6cUtAi3HUwR4_xPAc03SgHjQ@mail.gmail.com/
    Reported-by: Pingfan Liu <kernelfans@gmail.com>
    Tested-by: Pingfan Liu <kernelfans@gmail.com>
    Reviewed-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 1435d7281c66..6ebcd65d64b6 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -434,14 +434,6 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 			goto probe_failed;
 	}
 
-	/*
-	 * Ensure devices are listed in devices_kset in correct order
-	 * It's important to move Dev to the end of devices_kset before
-	 * calling .probe, because it could be recursive and parent Dev
-	 * should always go first
-	 */
-	devices_kset_move_last(dev);
-
 	if (dev->bus->probe) {
 		ret = dev->bus->probe(dev);
 		if (ret)

commit 25b4e70dcce92168eab4d8113817bb4dd130ebd2
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 9 09:41:48 2018 -0600

    driver core: allow stopping deferred probe after init
    
    Deferred probe will currently wait forever on dependent devices to probe,
    but sometimes a driver will never exist. It's also not always critical for
    a driver to exist. Platforms can rely on default configuration from the
    bootloader or reset defaults for things such as pinctrl and power domains.
    This is often the case with initial platform support until various drivers
    get enabled. There's at least 2 scenarios where deferred probe can render
    a platform broken. Both involve using a DT which has more devices and
    dependencies than the kernel supports. The 1st case is a driver may be
    disabled in the kernel config. The 2nd case is the kernel version may
    simply not have the dependent driver. This can happen if using a newer DT
    (provided by firmware perhaps) with a stable kernel version. Deferred
    probe issues can be difficult to debug especially if the console has
    dependencies or userspace fails to boot to a shell.
    
    There are also cases like IOMMUs where only built-in drivers are
    supported, so deferring probe after initcalls is not needed. The IOMMU
    subsystem implemented its own mechanism to handle this using OF_DECLARE
    linker sections.
    
    This commit adds makes ending deferred probe conditional on initcalls
    being completed or a debug timeout. Subsystems or drivers may opt-in by
    calling driver_deferred_probe_check_init_done() instead of
    unconditionally returning -EPROBE_DEFER. They may use additional
    information from DT or kernel's config to decide whether to continue to
    defer probe or not.
    
    The timeout mechanism is intended for debug purposes and WARNs loudly.
    The remaining deferred probe pending list will also be dumped after the
    timeout. Not that this timeout won't work for the console which needs
    to be enabled before userspace starts. However, if the console's
    dependencies are resolved, then the kernel log will be printed (as
    opposed to no output).
    
    Cc: Alexander Graf <agraf@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index e85705e84407..fb62f1be40d3 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -55,6 +55,7 @@ static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 static struct dentry *deferred_devices;
+static bool initcalls_done;
 
 /*
  * In some cases, like suspend to RAM or hibernation, It might be reasonable
@@ -219,6 +220,51 @@ static int deferred_devs_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(deferred_devs);
 
+static int deferred_probe_timeout = -1;
+static int __init deferred_probe_timeout_setup(char *str)
+{
+	deferred_probe_timeout = simple_strtol(str, NULL, 10);
+	return 1;
+}
+__setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
+
+/**
+ * driver_deferred_probe_check_state() - Check deferred probe state
+ * @dev: device to check
+ *
+ * Returns -ENODEV if init is done and all built-in drivers have had a chance
+ * to probe (i.e. initcalls are done), -ETIMEDOUT if deferred probe debug
+ * timeout has expired, or -EPROBE_DEFER if none of those conditions are met.
+ *
+ * Drivers or subsystems can opt-in to calling this function instead of directly
+ * returning -EPROBE_DEFER.
+ */
+int driver_deferred_probe_check_state(struct device *dev)
+{
+	if (initcalls_done) {
+		if (!deferred_probe_timeout) {
+			dev_WARN(dev, "deferred probe timeout, ignoring dependency");
+			return -ETIMEDOUT;
+		}
+		dev_warn(dev, "ignoring dependency for device, assuming no driver");
+		return -ENODEV;
+	}
+	return -EPROBE_DEFER;
+}
+
+static void deferred_probe_timeout_work_func(struct work_struct *work)
+{
+	struct device_private *private, *p;
+
+	deferred_probe_timeout = 0;
+	driver_deferred_probe_trigger();
+	flush_work(&deferred_probe_work);
+
+	list_for_each_entry_safe(private, p, &deferred_probe_pending_list, deferred_probe)
+		dev_info(private->device, "deferred probe pending");
+}
+static DECLARE_DELAYED_WORK(deferred_probe_timeout_work, deferred_probe_timeout_work_func);
+
 /**
  * deferred_probe_initcall() - Enable probing of deferred devices
  *
@@ -235,6 +281,19 @@ static int deferred_probe_initcall(void)
 	driver_deferred_probe_trigger();
 	/* Sort as many dependencies as possible before exiting initcalls */
 	flush_work(&deferred_probe_work);
+	initcalls_done = true;
+
+	/*
+	 * Trigger deferred probe again, this time we won't defer anything
+	 * that is optional
+	 */
+	driver_deferred_probe_trigger();
+	flush_work(&deferred_probe_work);
+
+	if (deferred_probe_timeout > 0) {
+		schedule_delayed_work(&deferred_probe_timeout_work,
+			deferred_probe_timeout * HZ);
+	}
 	return 0;
 }
 late_initcall(deferred_probe_initcall);

commit 28af109a57d14211e5e8ba1551f00428be2fd508
Author: Javier Martinez Canillas <javierm@redhat.com>
Date:   Sun Jul 8 15:34:59 2018 +0200

    driver core: add a debugfs entry to show deferred devices
    
    With Device Trees (DT), the dependencies of the devices are defined in the
    DT, then the drivers parse that information to lookup the needed resources
    that have as dependencies.
    
    Since drivers and devices are registered in a non-deterministic way, it is
    possible that a device that is a dependency has not been registered yet by
    the time that is looked up.
    
    In this case the driver that requires this dependency cannot probe and has
    to defer it. So the driver core adds it to a list of deferred devices that
    is iterated again every time that a new driver is probed successfully.
    
    For debugging purposes it may be useful to know what are the devices whose
    probe function was deferred. Add a debugfs entry showing that information.
    
      $ cat /sys/kernel/debug/devices_deferred
      48070000.i2c:twl@48:bci
      musb-hdrc.0.auto
      omapdrm.0
    
    This information could be obtained partially by enabling debugging, but it
    means that the kernel log has to be parsed and the probe deferral balanced
    with the successes. This can be error probe and has to be done in a ad-hoc
    manner by everyone who needs to debug these kind of issues.
    
    Since the information is already known by the kernel, just show it to make
    it easier to debug.
    
    Signed-off-by: Javier Martinez Canillas <javierm@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 6ea9c5cece71..e85705e84407 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -16,6 +16,7 @@
  * Copyright (c) 2007-2009 Novell Inc.
  */
 
+#include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
@@ -53,6 +54,7 @@ static DEFINE_MUTEX(deferred_probe_mutex);
 static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
+static struct dentry *deferred_devices;
 
 /*
  * In some cases, like suspend to RAM or hibernation, It might be reasonable
@@ -199,6 +201,24 @@ void device_unblock_probing(void)
 	driver_deferred_probe_trigger();
 }
 
+/*
+ * deferred_devs_show() - Show the devices in the deferred probe pending list.
+ */
+static int deferred_devs_show(struct seq_file *s, void *data)
+{
+	struct device_private *curr;
+
+	mutex_lock(&deferred_probe_mutex);
+
+	list_for_each_entry(curr, &deferred_probe_pending_list, deferred_probe)
+		seq_printf(s, "%s\n", dev_name(curr->device));
+
+	mutex_unlock(&deferred_probe_mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(deferred_devs);
+
 /**
  * deferred_probe_initcall() - Enable probing of deferred devices
  *
@@ -208,6 +228,9 @@ void device_unblock_probing(void)
  */
 static int deferred_probe_initcall(void)
 {
+	deferred_devices = debugfs_create_file("devices_deferred", 0444, NULL,
+					       NULL, &deferred_devs_fops);
+
 	driver_deferred_probe_enable = true;
 	driver_deferred_probe_trigger();
 	/* Sort as many dependencies as possible before exiting initcalls */
@@ -216,6 +239,12 @@ static int deferred_probe_initcall(void)
 }
 late_initcall(deferred_probe_initcall);
 
+static void __exit deferred_probe_exit(void)
+{
+	debugfs_remove_recursive(deferred_devices);
+}
+__exitcall(deferred_probe_exit);
+
 /**
  * device_is_bound() - Check if device is bound to a driver
  * @dev: device to check

commit 0a50f61c4fbd7840cdaf783c312e42b8ccde9ab3
Author: Todd Poynor <toddpoynor@google.com>
Date:   Wed Jun 20 17:35:56 2018 -0700

    drivers: base: initcall_debug logs for driver probe times
    
    Add initcall_debug logs for each driver device probe call, for example:
    
       probe of a3800000.ramoops returned 1 after 3007 usecs
    
    This replaces the previous code added to report times for deferred
    probes.  It also reports OF platform bus device creates that were
    formerly lumped together in a single entry for function
    of_platform_default_populate_init, as well as helping to annotate other
    initcalls that involve device probing.
    
    Remove restriction on printing probe times only during initcalls, since
    initcall_debug now continues to show driver timing info past the boot
    phase.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 1435d7281c66..6ea9c5cece71 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -53,7 +53,6 @@ static DEFINE_MUTEX(deferred_probe_mutex);
 static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
-static bool initcalls_done;
 
 /*
  * In some cases, like suspend to RAM or hibernation, It might be reasonable
@@ -62,26 +61,6 @@ static bool initcalls_done;
  */
 static bool defer_all_probes;
 
-/*
- * For initcall_debug, show the deferred probes executed in late_initcall
- * processing.
- */
-static void deferred_probe_debug(struct device *dev)
-{
-	ktime_t calltime, delta, rettime;
-	unsigned long long duration;
-
-	printk(KERN_DEBUG "deferred probe %s @ %i\n", dev_name(dev),
-	       task_pid_nr(current));
-	calltime = ktime_get();
-	bus_probe_device(dev);
-	rettime = ktime_get();
-	delta = ktime_sub(rettime, calltime);
-	duration = (unsigned long long) ktime_to_ns(delta) >> 10;
-	printk(KERN_DEBUG "deferred probe %s returned after %lld usecs\n",
-	       dev_name(dev), duration);
-}
-
 /*
  * deferred_probe_work_func() - Retry probing devices in the active list.
  */
@@ -125,11 +104,7 @@ static void deferred_probe_work_func(struct work_struct *work)
 		device_pm_move_to_tail(dev);
 
 		dev_dbg(dev, "Retrying from deferred list\n");
-		if (initcall_debug && !initcalls_done)
-			deferred_probe_debug(dev);
-		else
-			bus_probe_device(dev);
-
+		bus_probe_device(dev);
 		mutex_lock(&deferred_probe_mutex);
 
 		put_device(dev);
@@ -237,7 +212,6 @@ static int deferred_probe_initcall(void)
 	driver_deferred_probe_trigger();
 	/* Sort as many dependencies as possible before exiting initcalls */
 	flush_work(&deferred_probe_work);
-	initcalls_done = true;
 	return 0;
 }
 late_initcall(deferred_probe_initcall);
@@ -527,6 +501,23 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	return ret;
 }
 
+/*
+ * For initcall_debug, show the driver probe time.
+ */
+static int really_probe_debug(struct device *dev, struct device_driver *drv)
+{
+	ktime_t calltime, delta, rettime;
+	int ret;
+
+	calltime = ktime_get();
+	ret = really_probe(dev, drv);
+	rettime = ktime_get();
+	delta = ktime_sub(rettime, calltime);
+	printk(KERN_DEBUG "probe of %s returned %d after %lld usecs\n",
+	       dev_name(dev), ret, (s64) ktime_to_us(delta));
+	return ret;
+}
+
 /**
  * driver_probe_done
  * Determine if the probe sequence is finished or not.
@@ -585,7 +576,10 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 		pm_runtime_get_sync(dev->parent);
 
 	pm_runtime_barrier(dev);
-	ret = really_probe(dev, drv);
+	if (initcall_debug)
+		ret = really_probe_debug(dev, drv);
+	else
+		ret = really_probe(dev, drv);
 	pm_request_idle(dev);
 
 	if (dev->parent)

commit d09fcecb0c797b884ce65daa37c121a2786bb17b
Merge: f5b7769eb040 6a900f884e3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 13 07:24:18 2018 -0700

    Merge tag 'pm-4.18-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management updates from Rafael Wysocki:
     "These revert a recent PM core change that introduced a regression, fix
      the build when the recently added Kryo cpufreq driver is selected, add
      support for devices attached to multiple power domains to the generic
      power domains (genpd) framework, add support for iowait boosting on
      systens with hardware-managed P-states (HWP) enabled to the
      intel_pstate driver, modify the behavior of the wakeup_count device
      attribute in sysfs, fix a few issues and clean up some ugliness,
      mostly in cpufreq (core and drivers) and in the cpupower utility.
    
      Specifics:
    
       - Revert a recent PM core change that attempted to fix an issue
         related to device links, but introduced a regression (Rafael
         Wysocki)
    
       - Fix build when the recently added cpufreq driver for Kryo
         processors is selected by making it possible to build that driver
         as a module (Arnd Bergmann)
    
       - Fix the long idle detection mechanism in the out-of-band (ondemand
         and conservative) cpufreq governors (Chen Yu)
    
       - Add support for devices in multiple power domains to the generic
         power domains (genpd) framework (Ulf Hansson)
    
       - Add support for iowait boosting on systems with hardware-managed
         P-states (HWP) enabled to the intel_pstate driver and make it use
         that feature on systems with Skylake Xeon processors as it is
         reported to improve performance significantly on those systems
         (Srinivas Pandruvada)
    
       - Fix and update the acpi_cpufreq, ti-cpufreq and imx6q cpufreq
         drivers (Colin Ian King, Suman Anna, Sbastien Szymanski)
    
       - Change the behavior of the wakeup_count device attribute in sysfs
         to expose the number of events when the device might have aborted
         system suspend in progress (Ravi Chandra Sadineni)
    
       - Fix two minor issues in the cpupower utility (Abhishek Goel, Colin
         Ian King)"
    
    * tag 'pm-4.18-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      Revert "PM / runtime: Fixup reference counting of device link suppliers at probe"
      cpufreq: imx6q: check speed grades for i.MX6ULL
      cpufreq: governors: Fix long idle detection logic in load calculation
      cpufreq: intel_pstate: enable boost for Skylake Xeon
      PM / wakeup: Export wakeup_count instead of event_count via sysfs
      PM / Domains: Add dev_pm_domain_attach_by_id() to manage multi PM domains
      PM / Domains: Add support for multi PM domains per device to genpd
      PM / Domains: Split genpd_dev_pm_attach()
      PM / Domains: Don't attach devices in genpd with multi PM domains
      PM / Domains: dt: Allow power-domain property to be a list of specifiers
      cpufreq: intel_pstate: New sysfs entry to control HWP boost
      cpufreq: intel_pstate: HWP boost performance on IO wakeup
      cpufreq: intel_pstate: Add HWP boost utility and sched util hooks
      cpufreq: ti-cpufreq: Use devres managed API in probe()
      cpufreq: ti-cpufreq: Fix an incorrect error return value
      cpufreq: ACPI: make function acpi_cpufreq_fast_switch() static
      cpufreq: kryo: allow building as a loadable module
      cpupower : Fix header name to read idle state name
      cpupower: fix spelling mistake: "logilename" -> "logfilename"

commit b06c0b2f087ab498d51d50f5ae353133b602f614
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 12 10:24:13 2018 +0200

    Revert "PM / runtime: Fixup reference counting of device link suppliers at probe"
    
    Revert commit 1e8378619841 (PM / runtime: Fixup reference counting of
    device link suppliers at probe), as it has introduced a regression
    and the condition it was designed to address should be covered by the
    existing code.
    
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a41c91bfac0e..10454fe54482 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -580,7 +580,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
-	pm_runtime_resume_suppliers(dev);
+	pm_runtime_get_suppliers(dev);
 	if (dev->parent)
 		pm_runtime_get_sync(dev->parent);
 
@@ -591,6 +591,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	if (dev->parent)
 		pm_runtime_put(dev->parent);
 
+	pm_runtime_put_suppliers(dev);
 	return ret;
 }
 

commit ec064d3c6b40697fd72f4b1eeabbf293b7947a04
Merge: abf7dba7c4f7 8c97a46af04b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 16:29:19 2018 -0700

    Merge tag 'driver-core-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the driver core patchset for 4.18-rc1.
    
      The large chunk of these are firmware core documentation and api
      updates. Nothing major there, just better descriptions for others to
      be able to understand the firmware code better. There's also a user
      for a new firmware api call.
    
      Other than that, there are some minor updates for debugfs, kernfs, and
      the driver core itself.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (23 commits)
      driver core: hold dev's parent lock when needed
      driver-core: return EINVAL error instead of BUG_ON()
      driver core: add __printf verification to device_create_groups_vargs
      mm: memory_hotplug: use put_device() if device_register fail
      base: core: fix typo 'can by' to 'can be'
      debugfs: inode: debugfs_create_dir uses mode permission from parent
      debugfs: Re-use kstrtobool_from_user()
      Documentation: clarify firmware_class provenance and why we can't rename the module
      Documentation: remove stale firmware API reference
      Documentation: fix few typos and clarifications for the firmware loader
      ath10k: re-enable the firmware fallback mechanism for testmode
      ath10k: use firmware_request_nowarn() to load firmware
      firmware: add firmware_request_nowarn() - load firmware without warnings
      firmware_loader: make firmware_fallback_sysfs() print more useful
      firmware_loader: move kconfig FW_LOADER entries to its own file
      firmware_loader: replace ---help--- with help
      firmware_loader: enhance Kconfig documentation over FW_LOADER
      firmware_loader: document firmware_sysfs_fallback()
      firmware: rename fw_sysfs_fallback to firmware_fallback_sysfs()
      firmware: use () to terminate kernel-doc function names
      ...

commit 8c97a46af04b4f7c0a0dded031fef1806872e648
Author: Martin Liu <liumartin@google.com>
Date:   Thu May 31 00:31:36 2018 +0800

    driver core: hold dev's parent lock when needed
    
    SoC have internal I/O buses that can't be proved for devices. The
    devices on the buses can be accessed directly without additinal
    configuration required. This type of bus is represented as
    "simple-bus". In some platforms, we name "soc" with "simple-bus"
    attribute and many devices are hooked under it described in DT
    (device tree).
    
    In commit bf74ad5bc417 ("Hold the device's parent's lock during
    probe and remove") to solve USB subsystem lock sequence since
    USB device's characteristic. Thus "soc" needs to be locked
    whenever a device and driver's probing happen under "soc" bus.
    During this period, an async driver tries to probe a device which
    is under the "soc" bus would be blocked until previous driver
    finish the probing and release "soc" lock. And the next probing
    under the "soc" bus need to wait for async finish. Because of
    that, driver's async probe for init time improvement will be
    shadowed.
    
    Since many devices don't have USB devices' characteristic, they
    actually don't need parent's lock. Thus, we introduce a lock flag
    in bus_type struct and driver core would lock the parent lock base
    on the flag. For USB, we set this flag in usb_bus_type to keep
    original lock behavior in driver core.
    
    Async probe could have more benefit after this patch.
    
    Signed-off-by: Martin Liu <liumartin@google.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index c9f54089429b..7c09f73b96f3 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -817,13 +817,13 @@ static int __driver_attach(struct device *dev, void *data)
 		return ret;
 	} /* ret > 0 means positive match */
 
-	if (dev->parent)	/* Needed for USB */
+	if (dev->parent && dev->bus->need_parent_lock)
 		device_lock(dev->parent);
 	device_lock(dev);
 	if (!dev->driver)
 		driver_probe_device(drv, dev);
 	device_unlock(dev);
-	if (dev->parent)
+	if (dev->parent && dev->bus->need_parent_lock)
 		device_unlock(dev->parent);
 
 	return 0;
@@ -919,7 +919,7 @@ void device_release_driver_internal(struct device *dev,
 				    struct device_driver *drv,
 				    struct device *parent)
 {
-	if (parent)
+	if (parent && dev->bus->need_parent_lock)
 		device_lock(parent);
 
 	device_lock(dev);
@@ -927,7 +927,7 @@ void device_release_driver_internal(struct device *dev,
 		__device_release_driver(dev, parent);
 
 	device_unlock(dev);
-	if (parent)
+	if (parent && dev->bus->need_parent_lock)
 		device_unlock(parent);
 }
 

commit 1e8378619841ef1d621b130bbd3fc3b7e6739b50
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 18 10:48:49 2018 +0200

    PM / runtime: Fixup reference counting of device link suppliers at probe
    
    In the driver core, before it invokes really_probe() it runtime resumes the
    suppliers for the device via calling pm_runtime_get_suppliers(), which also
    increases the runtime PM usage count for each of the available supplier.
    
    This makes sense, as to be able to allow the consumer device to be probed
    by its driver. However, if the driver decides to add a new supplier link
    during ->probe(), hence updating the list of suppliers, the following call
    to pm_runtime_put_suppliers(), invoked after really_probe() in the driver
    core, we get into trouble.
    
    More precisely, pm_runtime_put() gets called also for the new supplier(s),
    which is wrong as the driver core, didn't trigger pm_runtime_get_sync() to
    be called for it in the first place. In other words, the new supplier may
    be runtime suspended even in cases when it shouldn't.
    
    Fix this behaviour, by runtime resume suppliers according to the same
    conditions as managed by the runtime PM core, when runtime resume callbacks
    are being invoked.
    
    Additionally, don't try to runtime suspend any of the suppliers after
    really_probe(), but instead rely on that to happen via the consumer device,
    when it becomes runtime suspended.
    
    Fixes: 21d5c57b3726 (PM / runtime: Use device links)
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 10454fe54482..a41c91bfac0e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -580,7 +580,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
-	pm_runtime_get_suppliers(dev);
+	pm_runtime_resume_suppliers(dev);
 	if (dev->parent)
 		pm_runtime_get_sync(dev->parent);
 
@@ -591,7 +591,6 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	if (dev->parent)
 		pm_runtime_put(dev->parent);
 
-	pm_runtime_put_suppliers(dev);
 	return ret;
 }
 

commit 494fd7b7ad10c33d3a7ff7d10b71b3ecad10474a
Author: Feng Kan <fkan@apm.com>
Date:   Tue Apr 10 16:57:06 2018 -0700

    PM / core: fix deferred probe breaking suspend resume order
    
    When bridge and its endpoint is enumerated the devices are added to the
    dpm list. Afterward, the bridge defers probe when IOMMU is not ready.
    This causes the bridge to be moved to the end of the dpm list when
    deferred probe kicks in. The order of the dpm list for bridge and
    endpoint is reversed.
    
    Add reordering code to move the bridge and its children and consumers to
    the end of the pm list so the order for suspend and resume is not altered.
    The code also move device and its children and consumers to the tail of
    device_kset list if it is registered.
    
    Signed-off-by: Toan Le <toanle@apm.com>
    Signed-off-by: Feng Kan <fkan@apm.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index c9f54089429b..10454fe54482 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -122,9 +122,7 @@ static void deferred_probe_work_func(struct work_struct *work)
 		 * the list is a good order for suspend but deferred
 		 * probe makes that very unsafe.
 		 */
-		device_pm_lock();
-		device_pm_move_last(dev);
-		device_pm_unlock();
+		device_pm_move_to_tail(dev);
 
 		dev_dbg(dev, "Retrying from deferred list\n");
 		if (initcall_debug && !initcalls_done)

commit 1fe56e0cafd7e4cf26f3582aad0c7705fceff498
Author: Arend van Spriel <aspriel@gmail.com>
Date:   Thu Mar 15 10:55:25 2018 +0100

    drivers: base: remove check for callback in coredump_store()
    
    The check for the .coredump() callback in coredump_store() is
    redundant. It is already assured the device driver implements
    the callback upon creating the coredump sysfs entry.
    
    Signed-off-by: Arend van Spriel <aspriel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index de6fd092bf2f..c9f54089429b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -292,8 +292,7 @@ static ssize_t coredump_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
 	device_lock(dev);
-	if (dev->driver->coredump)
-		dev->driver->coredump(dev);
+	dev->driver->coredump(dev);
 	device_unlock(dev);
 
 	return count;

commit 3c47d19ff4dccf1500c33bcbe3b5bc804907a0da
Author: Arend van Spriel <aspriel@gmail.com>
Date:   Thu Jan 11 09:36:38 2018 +0100

    drivers: base: add coredump driver ops
    
    This adds the coredump driver operation. When the driver defines it
    a coredump file is added in the sysfs folder of the device upon
    driver binding. The file is removed when the driver is unbound.
    User-space can trigger a coredump for this device by echo'ing to
    the coredump file.
    
    Signed-off-by: Arend van Spriel <aspriel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 533c82f55cea..de6fd092bf2f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -288,6 +288,18 @@ static void driver_bound(struct device *dev)
 	kobject_uevent(&dev->kobj, KOBJ_BIND);
 }
 
+static ssize_t coredump_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	device_lock(dev);
+	if (dev->driver->coredump)
+		dev->driver->coredump(dev);
+	device_unlock(dev);
+
+	return count;
+}
+static DEVICE_ATTR_WO(coredump);
+
 static int driver_sysfs_add(struct device *dev)
 {
 	int ret;
@@ -297,14 +309,26 @@ static int driver_sysfs_add(struct device *dev)
 					     BUS_NOTIFY_BIND_DRIVER, dev);
 
 	ret = sysfs_create_link(&dev->driver->p->kobj, &dev->kobj,
+				kobject_name(&dev->kobj));
+	if (ret)
+		goto fail;
+
+	ret = sysfs_create_link(&dev->kobj, &dev->driver->p->kobj,
+				"driver");
+	if (ret)
+		goto rm_dev;
+
+	if (!IS_ENABLED(CONFIG_DEV_COREDUMP) || !dev->driver->coredump ||
+	    !device_create_file(dev, &dev_attr_coredump))
+		return 0;
+
+	sysfs_remove_link(&dev->kobj, "driver");
+
+rm_dev:
+	sysfs_remove_link(&dev->driver->p->kobj,
 			  kobject_name(&dev->kobj));
-	if (ret == 0) {
-		ret = sysfs_create_link(&dev->kobj, &dev->driver->p->kobj,
-					"driver");
-		if (ret)
-			sysfs_remove_link(&dev->driver->p->kobj,
-					kobject_name(&dev->kobj));
-	}
+
+fail:
 	return ret;
 }
 
@@ -313,6 +337,8 @@ static void driver_sysfs_remove(struct device *dev)
 	struct device_driver *drv = dev->driver;
 
 	if (drv) {
+		if (drv->coredump)
+			device_remove_file(dev, &dev_attr_coredump);
 		sysfs_remove_link(&drv->p->kobj, kobject_name(&dev->kobj));
 		sysfs_remove_link(&dev->kobj, "driver");
 	}

commit 328257099077e8affd438c179d8a938948de2e7f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:09 2017 +0100

    driver core: Remove redundant license text
    
    Now that the SPDX tag is in all driver core files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 47ac37838399..533c82f55cea 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -14,8 +14,6 @@
  * Copyright (c) 2002-3 Open Source Development Labs
  * Copyright (c) 2007-2009 Greg Kroah-Hartman <gregkh@suse.de>
  * Copyright (c) 2007-2009 Novell Inc.
- *
- * This file is released under the GPLv2
  */
 
 #include <linux/device.h>

commit 989d42e85dc2f6823f39b8e9d080fd04bae0645d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:07 2017 +0100

    driver core: add SPDX identifiers to all driver core files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the driver core files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 2c964f56dafe..47ac37838399 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/base/dd.c - The core device/driver interactions.
  *

commit b9743042b3d31fed271ae19aee79dd86817904f0
Merge: e60e1ee60630 0ff26c662d5f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 16 08:55:30 2017 -0800

    Merge tag 'driver-core-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of driver core / debugfs patches for 4.15-rc1.
    
      Not many here, mostly all are debugfs fixes to resolve some
      long-reported problems with files going away with references to them
      in userspace. There's also some SPDX cleanups for the debugfs code, as
      well as a few other minor driver core changes for issues reported by
      people.
    
      All of these have been in linux-next for a week or more with no
      reported issues"
    
    * tag 'driver-core-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:
      driver core: Fix device link deferred probe
      debugfs: Remove redundant license text
      debugfs: add SPDX identifiers to all debugfs files
      debugfs: defer debugfs_fsdata allocation to first usage
      debugfs: call debugfs_real_fops() only after debugfs_file_get()
      debugfs: purge obsolete SRCU based removal protection
      IB/hfi1: convert to debugfs_file_get() and -put()
      debugfs: convert to debugfs_file_get() and -put()
      debugfs: debugfs_real_fops(): drop __must_hold sparse annotation
      debugfs: implement per-file removal protection
      debugfs: add support for more elaborate ->d_fsdata
      driver core: Move device_links_purge() after bus_remove_device()
      arch_topology: Fix section miss match warning due to free_raw_capacity()
      driver-core: pr_err() strings should end with newlines

commit 0ff26c662d5f3b26674d5205c8899d901f766acb
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Nov 2 11:22:53 2017 +0200

    driver core: Fix device link deferred probe
    
    A device probe deferred because of a device link is never probed again
    because it is not added to the deferred_probe_pending_list. Add it, taking
    care of the race with driver_deferred_probe_trigger().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index ad44b40fe284..e4a5bef93344 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -350,6 +350,15 @@ EXPORT_SYMBOL_GPL(device_bind_driver);
 static atomic_t probe_count = ATOMIC_INIT(0);
 static DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);
 
+static void driver_deferred_probe_add_trigger(struct device *dev,
+					      int local_trigger_count)
+{
+	driver_deferred_probe_add(dev);
+	/* Did a trigger occur while probing? Need to re-trigger if yes */
+	if (local_trigger_count != atomic_read(&deferred_trigger_count))
+		driver_deferred_probe_trigger();
+}
+
 static int really_probe(struct device *dev, struct device_driver *drv)
 {
 	int ret = -EPROBE_DEFER;
@@ -369,6 +378,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	}
 
 	ret = device_links_check_suppliers(dev);
+	if (ret == -EPROBE_DEFER)
+		driver_deferred_probe_add_trigger(dev, local_trigger_count);
 	if (ret)
 		return ret;
 
@@ -469,10 +480,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	case -EPROBE_DEFER:
 		/* Driver requested deferred probing */
 		dev_dbg(dev, "Driver %s requests probe deferral\n", drv->name);
-		driver_deferred_probe_add(dev);
-		/* Did a trigger occur while probing? Need to re-trigger if yes */
-		if (local_trigger_count != atomic_read(&deferred_trigger_count))
-			driver_deferred_probe_trigger();
+		driver_deferred_probe_add_trigger(dev, local_trigger_count);
 		break;
 	case -ENODEV:
 	case -ENXIO:

commit 08810a4119aaebf6318f209ec5dd9828e969cba4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 25 14:12:29 2017 +0200

    PM / core: Add NEVER_SKIP and SMART_PREPARE driver flags
    
    The motivation for this change is to provide a way to work around
    a problem with the direct-complete mechanism used for avoiding
    system suspend/resume handling for devices in runtime suspend.
    
    The problem is that some middle layer code (the PCI bus type and
    the ACPI PM domain in particular) returns positive values from its
    system suspend ->prepare callbacks regardless of whether the driver's
    ->prepare returns a positive value or 0, which effectively prevents
    drivers from being able to control the direct-complete feature.
    Some drivers need that control, however, and the PCI bus type has
    grown its own flag to deal with this issue, but since it is not
    limited to PCI, it is better to address it by adding driver flags at
    the core level.
    
    To that end, add a driver_flags field to struct dev_pm_info for flags
    that can be set by device drivers at the probe time to inform the PM
    core and/or bus types, PM domains and so on on the capabilities and/or
    preferences of device drivers.  Also add two static inline helpers
    for setting that field and testing it against a given set of flags
    and make the driver core clear it automatically on driver remove
    and probe failures.
    
    Define and document two PM driver flags related to the direct-
    complete feature: NEVER_SKIP and SMART_PREPARE that can be used,
    respectively, to indicate to the PM core that the direct-complete
    mechanism should never be used for the device and to inform the
    middle layer code (bus types, PM domains etc) that it can only
    request the PM core to use the direct-complete mechanism for
    the device (by returning a positive value from its ->prepare
    callback) if it also has been requested by the driver.
    
    While at it, make the core check pm_runtime_suspended() when
    setting power.direct_complete so that it doesn't need to be
    checked by ->prepare callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index ad44b40fe284..45575e134696 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -464,6 +464,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	if (dev->pm_domain && dev->pm_domain->dismiss)
 		dev->pm_domain->dismiss(dev);
 	pm_runtime_reinit(dev);
+	dev_pm_set_driver_flags(dev, 0);
 
 	switch (ret) {
 	case -EPROBE_DEFER:
@@ -869,6 +870,7 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 		if (dev->pm_domain && dev->pm_domain->dismiss)
 			dev->pm_domain->dismiss(dev);
 		pm_runtime_reinit(dev);
+		dev_pm_set_driver_flags(dev, 0);
 
 		klist_remove(&dev->p->knode_driver);
 		device_pm_check_callbacks(dev);

commit 1f5000bd8afab0ceed58c67f673250b864e5a9c9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 25 16:31:59 2017 -0700

    initcall_debug: add deferred probe times
    
    initcall_debug attributes all deferred device probe retries for the
    late_initcall level to function deferred_probe_initcall.  Add logs of
    the individual device probe routines called, to identify which drivers
    are executing for how long during the initcall path.  Deferred probes
    that occur after initcall processing are not shown.
    
    Example log messages added:
    
    [    0.505119] deferred probe my-sound-device @ 6
    [    0.517656] deferred probe my-sound-device returned after 1227 usecs
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index c17fefc77345..ad44b40fe284 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -20,6 +20,7 @@
 #include <linux/device.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
+#include <linux/init.h>
 #include <linux/module.h>
 #include <linux/kthread.h>
 #include <linux/wait.h>
@@ -53,6 +54,7 @@ static DEFINE_MUTEX(deferred_probe_mutex);
 static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
+static bool initcalls_done;
 
 /*
  * In some cases, like suspend to RAM or hibernation, It might be reasonable
@@ -61,6 +63,26 @@ static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
  */
 static bool defer_all_probes;
 
+/*
+ * For initcall_debug, show the deferred probes executed in late_initcall
+ * processing.
+ */
+static void deferred_probe_debug(struct device *dev)
+{
+	ktime_t calltime, delta, rettime;
+	unsigned long long duration;
+
+	printk(KERN_DEBUG "deferred probe %s @ %i\n", dev_name(dev),
+	       task_pid_nr(current));
+	calltime = ktime_get();
+	bus_probe_device(dev);
+	rettime = ktime_get();
+	delta = ktime_sub(rettime, calltime);
+	duration = (unsigned long long) ktime_to_ns(delta) >> 10;
+	printk(KERN_DEBUG "deferred probe %s returned after %lld usecs\n",
+	       dev_name(dev), duration);
+}
+
 /*
  * deferred_probe_work_func() - Retry probing devices in the active list.
  */
@@ -106,7 +128,10 @@ static void deferred_probe_work_func(struct work_struct *work)
 		device_pm_unlock();
 
 		dev_dbg(dev, "Retrying from deferred list\n");
-		bus_probe_device(dev);
+		if (initcall_debug && !initcalls_done)
+			deferred_probe_debug(dev);
+		else
+			bus_probe_device(dev);
 
 		mutex_lock(&deferred_probe_mutex);
 
@@ -215,6 +240,7 @@ static int deferred_probe_initcall(void)
 	driver_deferred_probe_trigger();
 	/* Sort as many dependencies as possible before exiting initcalls */
 	flush_work(&deferred_probe_work);
+	initcalls_done = true;
 	return 0;
 }
 late_initcall(deferred_probe_initcall);

commit 1455cf8dbfd06aa7651dcfccbadb7a093944ca65
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Jul 19 17:24:30 2017 -0700

    driver core: emit uevents when device is bound to a driver
    
    There are certain touch controllers that may come up in either normal
    (application) or boot mode, depending on whether firmware/configuration is
    corrupted when they are powered on. In boot mode the kernel does not create
    input device instance (because it does not necessarily know the
    characteristics of the input device in question).
    
    Another number of controllers does not store firmware in a non-volatile
    memory, and they similarly need to have firmware loaded before input device
    instance is created. There are also other types of devices with similar
    behavior.
    
    There is a desire to be able to trigger firmware loading via udev, but it
    has to happen only when driver is bound to a physical device (i2c or spi).
    These udev actions can not use ADD events, as those happen too early, so we
    are introducing BIND and UNBIND events that are emitted at the right
    moment.
    
    Also, many drivers create additional driver-specific device attributes
    when binding to the device, to provide userspace with additional controls.
    The new events allow userspace to adjust these driver-specific attributes
    without worrying that they are not there yet.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 4882f06d12df..c17fefc77345 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -259,6 +259,8 @@ static void driver_bound(struct device *dev)
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
+
+	kobject_uevent(&dev->kobj, KOBJ_BIND);
 }
 
 static int driver_sysfs_add(struct device *dev)
@@ -848,6 +850,8 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 						     BUS_NOTIFY_UNBOUND_DRIVER,
 						     dev);
+
+		kobject_uevent(&dev->kobj, KOBJ_UNBIND);
 	}
 }
 

commit 09515ef5ddad71c7820e5e428da418b709feeb26
Author: Sricharan R <sricharan@codeaurora.org>
Date:   Mon Apr 10 16:51:01 2017 +0530

    of/acpi: Configure dma operations at probe time for platform/amba/pci bus devices
    
    Configuring DMA ops at probe time will allow deferring device probe when
    the IOMMU isn't available yet. The dma_configure for the device is
    now called from the generic device_attach callback just before the
    bus/driver probe is called. This way, configuring the DMA ops for the
    device would be called at the same place for all bus_types, hence the
    deferred probing mechanism should work for all buses as well.
    
    pci_bus_add_devices    (platform/amba)(_device_create/driver_register)
           |                         |
    pci_bus_add_device     (device_add/driver_register)
           |                         |
    device_attach           device_initial_probe
           |                         |
    __device_attach_driver    __device_attach_driver
           |
    driver_probe_device
           |
    really_probe
           |
    dma_configure
    
    Similarly on the device/driver_unregister path __device_release_driver is
    called which inturn calls dma_deconfigure.
    
    This patch changes the dma ops configuration to probe time for
    both OF and ACPI based platform/amba/pci bus devices.
    
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci part)
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a1fbf55c4d3a..4882f06d12df 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -19,6 +19,7 @@
 
 #include <linux/device.h>
 #include <linux/delay.h>
+#include <linux/dma-mapping.h>
 #include <linux/module.h>
 #include <linux/kthread.h>
 #include <linux/wait.h>
@@ -356,6 +357,10 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	if (ret)
 		goto pinctrl_bind_failed;
 
+	ret = dma_configure(dev);
+	if (ret)
+		goto dma_failed;
+
 	if (driver_sysfs_add(dev)) {
 		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
 			__func__, dev_name(dev));
@@ -417,6 +422,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	goto done;
 
 probe_failed:
+	dma_deconfigure(dev);
+dma_failed:
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);
@@ -826,6 +833,8 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 			drv->remove(dev);
 
 		device_links_driver_cleanup(dev);
+		dma_deconfigure(dev);
+
 		devres_release_all(dev);
 		dev->driver = NULL;
 		dev_set_drvdata(dev, NULL);

commit c7334ce814f7e5d8fc1f9b3126cda0640c2f81b3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Jan 14 14:09:03 2017 +0100

    Revert "driver core: Add deferred_probe attribute to devices in sysfs"
    
    This reverts commit 6751667a29d6fd64afb9ce30567ad616b68ed789.
    
    Rob Herring objected to it, and a replacement for it will be added using
    debugfs in the future.
    
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Reported-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a8b258e5407b..a1fbf55c4d3a 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -53,19 +53,6 @@ static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 
-static ssize_t deferred_probe_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	bool value;
-
-	mutex_lock(&deferred_probe_mutex);
-	value = !list_empty(&dev->p->deferred_probe);
-	mutex_unlock(&deferred_probe_mutex);
-
-	return sprintf(buf, "%d\n", value);
-}
-DEVICE_ATTR_RO(deferred_probe);
-
 /*
  * In some cases, like suspend to RAM or hibernation, It might be reasonable
  * to prohibit probing of devices as it could be unsafe.

commit 098c30557a9a19827240aaadc137e4668157dc6b
Merge: 72cca7baf4fb 5d47ec02c37e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 11:42:18 2016 -0800

    Merge tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here's the new driver core patches for 4.10-rc1.
    
      Big thing here is the nice addition of "functional dependencies" to
      the driver core. The idea has been talked about for a very long time,
      great job to Rafael for stepping up and implementing it. It's been
      tested for longer than the 4.9-rc1 date, we held off on merging it
      earlier in order to feel more comfortable about it.
    
      Other than that, it's just a handful of small other patches, some good
      cleanups to the mess that is the firmware class code, and we have a
      test driver for the deferred probe logic.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (30 commits)
      firmware: Correct handling of fw_state_wait() return value
      driver core: Silence device links sphinx warning
      firmware: remove warning at documentation generation time
      drivers: base: dma-mapping: Fix typo in dmam_alloc_non_coherent comments
      driver core: test_async: fix up typo found by 0-day
      firmware: move fw_state_is_done() into UHM section
      firmware: do not use fw_lock for fw_state protection
      firmware: drop bit ops in favor of simple state machine
      firmware: refactor loading status
      firmware: fix usermode helper fallback loading
      driver core: firmware_class: convert to use class_groups
      driver core: devcoredump: convert to use class_groups
      driver core: class: add class_groups support
      kernfs: Declare two local data structures static
      driver-core: fix platform_no_drv_owner.cocci warnings
      drivers/base/memory.c: Remove unused 'first_page' variable
      driver core: add CLASS_ATTR_WO()
      drivers: base: cacheinfo: support DT overrides for cache properties
      drivers: base: cacheinfo: add pr_fmt logging
      drivers: base: cacheinfo: fix boot error message when acpi is enabled
      ...

commit 6751667a29d6fd64afb9ce30567ad616b68ed789
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Tue Aug 16 14:34:18 2016 +0100

    driver core: Add deferred_probe attribute to devices in sysfs
    
    It is sometimes useful to know that a device is on the deferred probe
    list rather than, say, not having a driver available.  Expose this
    information to user-space.
    
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 43be1cc751a4..a48cf444eca5 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -53,6 +53,19 @@ static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 
+static ssize_t deferred_probe_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	bool value;
+
+	mutex_lock(&deferred_probe_mutex);
+	value = !list_empty(&dev->p->deferred_probe);
+	mutex_unlock(&deferred_probe_mutex);
+
+	return sprintf(buf, "%d\n", value);
+}
+DEVICE_ATTR_RO(deferred_probe);
+
 /*
  * In some cases, like suspend to RAM or hibernation, It might be reasonable
  * to prohibit probing of devices as it could be unsafe.

commit 21d5c57b3726166421251e94dabab047baaf8ce4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:31 2016 +0100

    PM / runtime: Use device links
    
    Modify the runtime PM framework to use device links to ensure that
    supplier devices will not be suspended if any of their consumer
    devices are active.
    
    The idea is to reference count suppliers on the consumer's resume
    and drop references to them on its suspend.  The information on
    whether or not the supplier has been reference counted by the
    consumer's (runtime) resume is stored in a new field (rpm_active)
    in the link object for each link.
    
    It may be necessary to clean up those references when the
    supplier is unbinding and that's why the links whose status is
    DEVICE_LINK_SUPPLIER_UNBIND are skipped by the runtime suspend
    and resume code.
    
    The above means that if the consumer device is probed in the
    runtime-active state, the supplier has to be resumed and reference
    counted by device_link_add() so the code works as expected on its
    (runtime) suspend.  There is a new flag, DEVICE_LINK_RPM_ACTIVE,
    to tell device_link_add() about that (in which case the caller
    is responsible for making sure that the consumer really will
    be runtime-active when runtime PM is enabled for it).
    
    The other new link flag, DEVICE_LINK_PM_RUNTIME, tells the core
    whether or not the link should be used for runtime PM at all.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index b2bca3cf0dd2..43be1cc751a4 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -513,6 +513,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
+	pm_runtime_get_suppliers(dev);
 	if (dev->parent)
 		pm_runtime_get_sync(dev->parent);
 
@@ -523,6 +524,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	if (dev->parent)
 		pm_runtime_put(dev->parent);
 
+	pm_runtime_put_suppliers(dev);
 	return ret;
 }
 
@@ -806,6 +808,7 @@ static void __device_release_driver(struct device *dev, struct device *parent)
 		}
 
 		pm_runtime_get_sync(dev);
+		pm_runtime_clean_up_links(dev);
 
 		driver_sysfs_remove(dev);
 

commit 9ed9895370aedd6032af2a9181c62c394d08223b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:16 2016 +0100

    driver core: Functional dependencies tracking support
    
    Currently, there is a problem with taking functional dependencies
    between devices into account.
    
    What I mean by a "functional dependency" is when the driver of device
    B needs device A to be functional and (generally) its driver to be
    present in order to work properly.  This has certain consequences
    for power management (suspend/resume and runtime PM ordering) and
    shutdown ordering of these devices.  In general, it also implies that
    the driver of A needs to be working for B to be probed successfully
    and it cannot be unbound from the device before the B's driver.
    
    Support for representing those functional dependencies between
    devices is added here to allow the driver core to track them and act
    on them in certain cases where applicable.
    
    The argument for doing that in the driver core is that there are
    quite a few distinct use cases involving device dependencies, they
    are relatively hard to get right in a driver (if one wants to
    address all of them properly) and it only gets worse if multiplied
    by the number of drivers potentially needing to do it.  Morever, at
    least one case (asynchronous system suspend/resume) cannot be handled
    in a single driver at all, because it requires the driver of A to
    wait for B to suspend (during system suspend) and the driver of B to
    wait for A to resume (during system resume).
    
    For this reason, represent dependencies between devices as "links",
    with the help of struct device_link objects each containing pointers
    to the "linked" devices, a list node for each of them, status
    information, flags, and an RCU head for synchronization.
    
    Also add two new list heads, representing the lists of links to the
    devices that depend on the given one (consumers) and to the devices
    depended on by it (suppliers), and a "driver presence status" field
    (needed for figuring out initial states of device links) to struct
    device.
    
    The entire data structure consisting of all of the lists of link
    objects for all devices is protected by a mutex (for link object
    addition/removal and for list walks during device driver probing
    and removal) and by SRCU (for list walking in other case that will
    be introduced by subsequent change sets).  If CONFIG_SRCU is not
    selected, however, an rwsem is used for protecting the entire data
    structure.
    
    In addition, each link object has an internal status field whose
    value reflects whether or not drivers are bound to the devices
    pointed to by the link or probing/removal of their drivers is in
    progress etc.  That field is only modified under the device links
    mutex, but it may be read outside of it in some cases (introduced by
    subsequent change sets), so modifications of it are annotated with
    WRITE_ONCE().
    
    New links are added by calling device_link_add() which takes three
    arguments: pointers to the devices in question and flags.  In
    particular, if DL_FLAG_STATELESS is set in the flags, the link status
    is not to be taken into account for this link and the driver core
    will not manage it.  In turn, if DL_FLAG_AUTOREMOVE is set in the
    flags, the driver core will remove the link automatically when the
    consumer device driver unbinds from it.
    
    One of the actions carried out by device_link_add() is to reorder
    the lists used for device shutdown and system suspend/resume to
    put the consumer device along with all of its children and all of
    its consumers (and so on, recursively) to the ends of those lists
    in order to ensure the right ordering between all of the supplier
    and consumer devices.
    
    For this reason, it is not possible to create a link between two
    devices if the would-be supplier device already depends on the
    would-be consumer device as either a direct descendant of it or a
    consumer of one of its direct descendants or one of its consumers
    and so on.
    
    There are two types of link objects, persistent and non-persistent.
    The persistent ones stay around until one of the target devices is
    deleted, while the non-persistent ones are removed automatically when
    the consumer driver unbinds from its device (ie. they are assumed to
    be valid only as long as the consumer device has a driver bound to
    it).  Persistent links are created by default and non-persistent
    links are created when the DL_FLAG_AUTOREMOVE flag is passed
    to device_link_add().
    
    Both persistent and non-persistent device links can be deleted
    with an explicit call to device_link_del().
    
    Links created without the DL_FLAG_STATELESS flag set are managed
    by the driver core using a simple state machine.  There are 5 states
    each link can be in: DORMANT (unused), AVAILABLE (the supplier driver
    is present and functional), CONSUMER_PROBE (the consumer driver is
    probing), ACTIVE (both supplier and consumer drivers are present and
    functional), and SUPPLIER_UNBIND (the supplier driver is unbinding).
    The driver core updates the link state automatically depending on
    what happens to the linked devices and for each link state specific
    actions are taken in addition to that.
    
    For example, if the supplier driver unbinds from its device, the
    driver core will also unbind the drivers of all of its consumers
    automatically under the assumption that they cannot function
    properly without the supplier.  Analogously, the driver core will
    only allow the consumer driver to bind to its device if the
    supplier driver is present and functional (ie. the link is in
    the AVAILABLE state).  If that's not the case, it will rely on
    the existing deferred probing mechanism to wait for the supplier
    driver to become available.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index df4ab5509c04..b2bca3cf0dd2 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -244,6 +244,7 @@ static void driver_bound(struct device *dev)
 		 __func__, dev_name(dev));
 
 	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
+	device_links_driver_bound(dev);
 
 	device_pm_check_callbacks(dev);
 
@@ -337,6 +338,10 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		return ret;
 	}
 
+	ret = device_links_check_suppliers(dev);
+	if (ret)
+		return ret;
+
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
 		 drv->bus->name, __func__, drv->name, dev_name(dev));
@@ -415,6 +420,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);
 pinctrl_bind_failed:
+	device_links_no_driver(dev);
 	devres_release_all(dev);
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
@@ -771,7 +777,7 @@ EXPORT_SYMBOL_GPL(driver_attach);
  * __device_release_driver() must be called with @dev lock held.
  * When called for a USB interface, @dev->parent lock must be held as well.
  */
-static void __device_release_driver(struct device *dev)
+static void __device_release_driver(struct device *dev, struct device *parent)
 {
 	struct device_driver *drv;
 
@@ -780,6 +786,25 @@ static void __device_release_driver(struct device *dev)
 		if (driver_allows_async_probing(drv))
 			async_synchronize_full();
 
+		while (device_links_busy(dev)) {
+			device_unlock(dev);
+			if (parent)
+				device_unlock(parent);
+
+			device_links_unbind_consumers(dev);
+			if (parent)
+				device_lock(parent);
+
+			device_lock(dev);
+			/*
+			 * A concurrent invocation of the same function might
+			 * have released the driver successfully while this one
+			 * was waiting, so check for that.
+			 */
+			if (dev->driver != drv)
+				return;
+		}
+
 		pm_runtime_get_sync(dev);
 
 		driver_sysfs_remove(dev);
@@ -795,6 +820,8 @@ static void __device_release_driver(struct device *dev)
 			dev->bus->remove(dev);
 		else if (drv->remove)
 			drv->remove(dev);
+
+		device_links_driver_cleanup(dev);
 		devres_release_all(dev);
 		dev->driver = NULL;
 		dev_set_drvdata(dev, NULL);
@@ -811,16 +838,16 @@ static void __device_release_driver(struct device *dev)
 	}
 }
 
-static void device_release_driver_internal(struct device *dev,
-					   struct device_driver *drv,
-					   struct device *parent)
+void device_release_driver_internal(struct device *dev,
+				    struct device_driver *drv,
+				    struct device *parent)
 {
 	if (parent)
 		device_lock(parent);
 
 	device_lock(dev);
 	if (!drv || drv == dev->driver)
-		__device_release_driver(dev);
+		__device_release_driver(dev, parent);
 
 	device_unlock(dev);
 	if (parent)
@@ -833,6 +860,10 @@ static void device_release_driver_internal(struct device *dev,
  *
  * Manually detach device from driver.
  * When called for a USB interface, @dev->parent lock must be held.
+ *
+ * If this function is to be called with @dev->parent lock held, ensure that
+ * the device's consumers are unbound in advance or that their locks can be
+ * acquired under the @dev->parent lock.
  */
 void device_release_driver(struct device *dev)
 {

commit bdacd1b426db83ac8ecf21aef1848120ffe53c07
Author: Rob Herring <robh@kernel.org>
Date:   Tue Oct 11 13:41:03 2016 -0500

    driver core: fix smatch warning on dev->bus check
    
    Commit d42a09802174 (driver core: skip removal test for non-removable
    drivers) introduced a smatch warning:
    
    drivers/base/dd.c:386 really_probe()
             warn: variable dereferenced before check 'dev->bus' (see line 373)
    
    Fix the warning by removing the dev->bus NULL check. dev->bus will never
    be NULL, so the check was unnecessary.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 8937a7ad7165..d76cd97a98b6 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -384,7 +384,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	if (test_remove) {
 		test_remove = false;
 
-		if (dev->bus && dev->bus->remove)
+		if (dev->bus->remove)
 			dev->bus->remove(dev);
 		else if (drv->remove)
 			drv->remove(dev);

commit c5f0627488be996e833038bdba01e45698ddaa26
Author: Rob Herring <robh@kernel.org>
Date:   Tue Oct 11 13:41:02 2016 -0500

    driver core: skip removal test for non-removable drivers
    
    Some drivers do not support removal/unbinding. These drivers should have
    drv->suppress_bind_attrs set to true, so use that to skip the removal
    test.
    
    This doesn't fix anything reported so far, but should prevent some other
    cases. Some drivers will need fixes to set suppress_bind_attrs to avoid
    this test.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=177021
    Fixes: bea5b158ff0d ("driver core: add test of driver remove calls during probe")
    Reported-by: Laszlo Ersek <lersek@redhat.com>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index d22a7260f42b..8937a7ad7165 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -324,7 +324,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 {
 	int ret = -EPROBE_DEFER;
 	int local_trigger_count = atomic_read(&deferred_trigger_count);
-	bool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE);
+	bool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &&
+			   !drv->suppress_bind_attrs;
 
 	if (defer_all_probes) {
 		/*

commit 4bdb35506b89cbbd150c1baa284e7c191698241f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 10 14:37:56 2016 +0200

    driver core: Add a wrapper around __device_release_driver()
    
    Add an internal wrapper around __device_release_driver() that will
    acquire device locks and do the necessary checks before calling it.
    
    The next patch will make use of it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index d22a7260f42b..df4ab5509c04 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -811,6 +811,22 @@ static void __device_release_driver(struct device *dev)
 	}
 }
 
+static void device_release_driver_internal(struct device *dev,
+					   struct device_driver *drv,
+					   struct device *parent)
+{
+	if (parent)
+		device_lock(parent);
+
+	device_lock(dev);
+	if (!drv || drv == dev->driver)
+		__device_release_driver(dev);
+
+	device_unlock(dev);
+	if (parent)
+		device_unlock(parent);
+}
+
 /**
  * device_release_driver - manually detach device from driver.
  * @dev: device.
@@ -825,9 +841,7 @@ void device_release_driver(struct device *dev)
 	 * within their ->remove callback for the same device, they
 	 * will deadlock right here.
 	 */
-	device_lock(dev);
-	__device_release_driver(dev);
-	device_unlock(dev);
+	device_release_driver_internal(dev, NULL, NULL);
 }
 EXPORT_SYMBOL_GPL(device_release_driver);
 
@@ -852,15 +866,7 @@ void driver_detach(struct device_driver *drv)
 		dev = dev_prv->device;
 		get_device(dev);
 		spin_unlock(&drv->p->klist_devices.k_lock);
-
-		if (dev->parent)	/* Needed for USB */
-			device_lock(dev->parent);
-		device_lock(dev);
-		if (dev->driver == drv)
-			__device_release_driver(dev);
-		device_unlock(dev);
-		if (dev->parent)
-			device_unlock(dev->parent);
+		device_release_driver_internal(dev, drv, dev->parent);
 		put_device(dev);
 	}
 }

commit 2c507e464f791327c94d17a0137f00b4717744fc
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Tue Aug 30 22:45:34 2016 +0530

    device core: Remove deprecated create_singlethread_workqueue
    
    The workqueue "deferred_wq" queues a single work item
    &deferred_probe_work and hence doesn't require ordering.
    It is involved in probing devices and is not being used on a memory
    reclaim path. Hence, it has been converted to use system_wq.
    
    System workqueues have been able to handle high level of concurrency
    for a long time now and hence it's not required to have a singlethreaded
    workqueue just to gain concurrency. Unlike a dedicated per-cpu workqueue
    created with create_singlethread_workqueue(), system_wq allows multiple
    work items to overlap executions even on the same CPU; however, a
    per-cpu workqueue doesn't have any CPU locality or global ordering
    guarantee unless the target CPU is explicitly specified and thus the
    increase of local concurrency shouldn't make any difference.
    
    The work item has been flushed in driver_probe_done() to ensure that
    there are no pending tasks while disconnecting the driver.
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 4910e6db2a34..d22a7260f42b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -51,7 +51,6 @@
 static DEFINE_MUTEX(deferred_probe_mutex);
 static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
-static struct workqueue_struct *deferred_wq;
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 
 /*
@@ -175,7 +174,7 @@ static void driver_deferred_probe_trigger(void)
 	 * Kick the re-probe thread.  It may already be scheduled, but it is
 	 * safe to kick it again.
 	 */
-	queue_work(deferred_wq, &deferred_probe_work);
+	schedule_work(&deferred_probe_work);
 }
 
 /**
@@ -211,14 +210,10 @@ void device_unblock_probing(void)
  */
 static int deferred_probe_initcall(void)
 {
-	deferred_wq = create_singlethread_workqueue("deferwq");
-	if (WARN_ON(!deferred_wq))
-		return -ENOMEM;
-
 	driver_deferred_probe_enable = true;
 	driver_deferred_probe_trigger();
 	/* Sort as many dependencies as possible before exiting initcalls */
-	flush_workqueue(deferred_wq);
+	flush_work(&deferred_probe_work);
 	return 0;
 }
 late_initcall(deferred_probe_initcall);
@@ -481,8 +476,7 @@ int driver_probe_done(void)
 void wait_for_device_probe(void)
 {
 	/* wait for the deferred probe workqueue to finish */
-	if (driver_deferred_probe_enable)
-		flush_workqueue(deferred_wq);
+	flush_work(&deferred_probe_work);
 
 	/* wait for the known devices to complete their probing */
 	wait_event(probe_waitqueue, atomic_read(&probe_count) == 0);

commit bea5b158ff0da9c7246ff391f754f5f38e34577a
Author: Rob Herring <robh@kernel.org>
Date:   Thu Aug 11 10:20:58 2016 -0500

    driver core: add test of driver remove calls during probe
    
    In recent discussions on ksummit-discuss[1], it was suggested to do a
    sequence of probe, remove, probe for testing driver remove paths. This
    adds a kconfig option for said test.
    
    [1] https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2016-August/003459.html
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 16688f50729c..4910e6db2a34 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -329,6 +329,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 {
 	int ret = -EPROBE_DEFER;
 	int local_trigger_count = atomic_read(&deferred_trigger_count);
+	bool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE);
 
 	if (defer_all_probes) {
 		/*
@@ -346,6 +347,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		 drv->bus->name, __func__, drv->name, dev_name(dev));
 	WARN_ON(!list_empty(&dev->devres_head));
 
+re_probe:
 	dev->driver = drv;
 
 	/* If using pinctrl, bind pins now before probing */
@@ -383,6 +385,25 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 			goto probe_failed;
 	}
 
+	if (test_remove) {
+		test_remove = false;
+
+		if (dev->bus && dev->bus->remove)
+			dev->bus->remove(dev);
+		else if (drv->remove)
+			drv->remove(dev);
+
+		devres_release_all(dev);
+		driver_sysfs_remove(dev);
+		dev->driver = NULL;
+		dev_set_drvdata(dev, NULL);
+		if (dev->pm_domain && dev->pm_domain->dismiss)
+			dev->pm_domain->dismiss(dev);
+		pm_runtime_reinit(dev);
+
+		goto re_probe;
+	}
+
 	pinctrl_init_done(dev);
 
 	if (dev->pm_domain && dev->pm_domain->sync)

commit 656b8035b0eebcac0172b24ca04e448c70dd047f
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Mon Feb 15 09:25:06 2016 +0100

    ARM: 8524/1: driver cohandle -EPROBE_DEFER from bus_type.match()
    
    Allow implementations of the match() callback in struct bus_type to
    return errors and if it's -EPROBE_DEFER then queue the device for
    deferred probing.
    
    This is useful to buses such as AMBA in which devices are registered
    before their matching information can be retrieved from the HW
    (typically because a clock driver hasn't probed yet).
    
    [changed if-else code structure, adjusted documentation to match the code,
    extended comments]
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index c4da2df62e02..16688f50729c 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -560,6 +560,7 @@ static int __device_attach_driver(struct device_driver *drv, void *_data)
 	struct device_attach_data *data = _data;
 	struct device *dev = data->dev;
 	bool async_allowed;
+	int ret;
 
 	/*
 	 * Check if device has already been claimed. This may
@@ -570,8 +571,17 @@ static int __device_attach_driver(struct device_driver *drv, void *_data)
 	if (dev->driver)
 		return -EBUSY;
 
-	if (!driver_match_device(drv, dev))
+	ret = driver_match_device(drv, dev);
+	if (ret == 0) {
+		/* no match */
 		return 0;
+	} else if (ret == -EPROBE_DEFER) {
+		dev_dbg(dev, "Device match requests probe deferral\n");
+		driver_deferred_probe_add(dev);
+	} else if (ret < 0) {
+		dev_dbg(dev, "Bus failed to match device: %d", ret);
+		return ret;
+	} /* ret > 0 means positive match */
 
 	async_allowed = driver_allows_async_probing(drv);
 
@@ -691,6 +701,7 @@ void device_initial_probe(struct device *dev)
 static int __driver_attach(struct device *dev, void *data)
 {
 	struct device_driver *drv = data;
+	int ret;
 
 	/*
 	 * Lock device and try to bind to it. We drop the error
@@ -702,8 +713,17 @@ static int __driver_attach(struct device *dev, void *data)
 	 * is an error.
 	 */
 
-	if (!driver_match_device(drv, dev))
+	ret = driver_match_device(drv, dev);
+	if (ret == 0) {
+		/* no match */
 		return 0;
+	} else if (ret == -EPROBE_DEFER) {
+		dev_dbg(dev, "Device match requests probe deferral\n");
+		driver_deferred_probe_add(dev);
+	} else if (ret < 0) {
+		dev_dbg(dev, "Bus failed to match device: %d", ret);
+		return ret;
+	} /* ret > 0 means positive match */
 
 	if (dev->parent)	/* Needed for USB */
 		device_lock(dev->parent);

commit 3ded91041a762423bd49bb932ae2e36b65c6ae4b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 12 01:51:44 2016 +0100

    driver core: Avoid NULL pointer dereferences in device_is_bound()
    
    If device_is_bound() is called on a device that's not been registered
    yet, it will attepmt to dereference dev->p which is NULL, so avoid
    that by checking dev->p in there against NULL.
    
    Fixes: 6b9cb42752da "device core: add device_is_bound()"
    Reported-and-tested-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 049942176b00..c4da2df62e02 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -234,7 +234,7 @@ late_initcall(deferred_probe_initcall);
  */
 bool device_is_bound(struct device *dev)
 {
-	return klist_node_attached(&dev->p->knode_driver);
+	return dev->p && klist_node_attached(&dev->p->knode_driver);
 }
 
 static void driver_bound(struct device *dev)

commit aa8e54b559479d0cb7eb632ba443b8cacd20cd4b
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:14 2016 +0100

    PM / sleep: Go direct_complete if driver has no callbacks
    
    If a suitable prepare callback cannot be found for a given device and
    its driver has no PM callbacks at all, assume that it can go direct to
    complete when the system goes to sleep.
    
    The reason for this is that there's lots of devices in a system that do
    no PM at all and there's no reason for them to prevent their ancestors
    to do direct_complete if they can support it.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 13a0d66e5782..049942176b00 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -250,6 +250,8 @@ static void driver_bound(struct device *dev)
 
 	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
 
+	device_pm_check_callbacks(dev);
+
 	/*
 	 * Make sure the device is no longer in one of the deferred lists and
 	 * kick off retrying all pending devices
@@ -766,6 +768,7 @@ static void __device_release_driver(struct device *dev)
 		pm_runtime_reinit(dev);
 
 		klist_remove(&dev->p->knode_driver);
+		device_pm_check_callbacks(dev);
 		if (dev->bus)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 						     BUS_NOTIFY_UNBOUND_DRIVER,

commit 6b9cb42752dafba3761dde0002ca58ca518b6311
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:12 2016 +0100

    device core: add device_is_bound()
    
    Adds a function that tells whether a device is already bound to a
    driver.
    
    This is needed to warn when there is an attempt to change the PM domain
    of a device that has finished probing already. The reason why we want to
    enforce that is because in the general case that can cause problems and
    also that we can simplify code quite a bit if we can always assume that.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 7399be790b5d..13a0d66e5782 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -223,9 +223,23 @@ static int deferred_probe_initcall(void)
 }
 late_initcall(deferred_probe_initcall);
 
+/**
+ * device_is_bound() - Check if device is bound to a driver
+ * @dev: device to check
+ *
+ * Returns true if passed device has already finished probing successfully
+ * against a driver.
+ *
+ * This function must be called with the device lock held.
+ */
+bool device_is_bound(struct device *dev)
+{
+	return klist_node_attached(&dev->p->knode_driver);
+}
+
 static void driver_bound(struct device *dev)
 {
-	if (klist_node_attached(&dev->p->knode_driver)) {
+	if (device_is_bound(dev)) {
 		printk(KERN_WARNING "%s: device %s already bound\n",
 			__func__, kobject_name(&dev->kobj));
 		return;
@@ -601,7 +615,7 @@ static int __device_attach(struct device *dev, bool allow_async)
 
 	device_lock(dev);
 	if (dev->driver) {
-		if (klist_node_attached(&dev->p->knode_driver)) {
+		if (device_is_bound(dev)) {
 			ret = 1;
 			goto out_unlock;
 		}

commit c4e4d631feb3be4ddf885e647127fddebb450334
Merge: 4295733eee4e d35818a9153e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 8 01:11:49 2016 +0100

    Merge branch 'acpi-soc' into pm-core

commit 14b6257a5f3dca3817b0826cb32967e3c2b935c8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 4 23:49:17 2015 +0200

    device core: add BUS_NOTIFY_DRIVER_NOT_BOUND notification
    
    The users of BUS_NOTIFY_BIND_DRIVER have no chance to do any cleanup in case of
    a probe failure. In the result there might be problems, such as some resources
    that had been allocated will continue to be allocated and therefore lead to a
    resource leak.
    
    Introduce a new notification to inform the subscriber that ->probe() failed. Do
    the same in case of failed device_bind_driver() call.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a641cf3ccad6..03697043344a 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -268,6 +268,9 @@ int device_bind_driver(struct device *dev)
 	ret = driver_sysfs_add(dev);
 	if (!ret)
 		driver_bound(dev);
+	else if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
+					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(device_bind_driver);
@@ -290,7 +293,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	/* If using pinctrl, bind pins now before probing */
 	ret = pinctrl_bind_pins(dev);
 	if (ret)
-		goto probe_failed;
+		goto pinctrl_bind_failed;
 
 	if (driver_sysfs_add(dev)) {
 		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
@@ -334,6 +337,10 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	goto done;
 
 probe_failed:
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
+					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);
+pinctrl_bind_failed:
 	devres_release_all(dev);
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
@@ -701,7 +708,6 @@ static void __device_release_driver(struct device *dev)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 						     BUS_NOTIFY_UNBOUND_DRIVER,
 						     dev);
-
 	}
 }
 

commit d89d7ff9edf58cbf8ad0f490694b2edea8eb3a39
Merge: 7b06a6d7bff5 013c074f8642 5de85b9d57ab
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 7 02:17:17 2015 +0100

    Merge branches 'pm-sleep' and 'pm-runtime' into pm-core

commit 5de85b9d57aba3ed2e04759e6db3b9e826dd0b06
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Nov 18 11:48:39 2015 +0100

    PM / runtime: Re-init runtime PM states at probe error and driver unbind
    
    There are two common expectations among several subsystems/drivers that
    deploys runtime PM support, but which isn't met by the driver core.
    
    Expectation 1)
    At ->probe() the subsystem/driver expects the runtime PM status of the
    device to be RPM_SUSPENDED, which is the initial status being assigned at
    device registration.
    
    This expectation is especially common among some of those subsystems/
    drivers that manages devices with an attached PM domain, as those requires
    the ->runtime_resume() callback at the PM domain level to be invoked
    during ->probe().
    
    Moreover these subsystems/drivers entirely relies on runtime PM resources
    being managed at the PM domain level, thus don't implement their own set
    of runtime PM callbacks.
    
    These are two scenarios that suffers from this unmet expectation.
    
    i) A failed ->probe() sequence requests probe deferral:
    
    ->probe()
      ...
      pm_runtime_enable()
      pm_runtime_get_sync()
      ...
    
    err:
      pm_runtime_put()
      pm_runtime_disable()
      ...
    
    As there are no guarantees that such sequence turns the runtime PM status
    of the device into RPM_SUSPENDED, the re-trying ->probe() may start with
    the status in RPM_ACTIVE.
    
    In such case the runtime PM core won't invoke the ->runtime_resume()
    callback because of a pm_runtime_get_sync(), as it considers the device to
    be already runtime resumed.
    
    ii) A driver re-bind sequence:
    
    At driver unbind, the subsystem/driver's >remove() callback invokes a
    sequence of runtime PM APIs, to undo actions during ->probe() and to put
    the device into low power state.
    
    ->remove()
      ...
      pm_runtime_put()
      pm_runtime_disable()
      ...
    
    Similar as in the failing ->probe() case, this sequence don't guarantee
    the runtime PM status of the device to turn into RPM_SUSPENDED.
    
    Trying to re-bind the driver thus causes the same issue as when re-trying
    ->probe(), in the probe deferral scenario.
    
    Expectation 2)
    Drivers that invokes the pm_runtime_irq_safe() API during ->probe(),
    triggers the runtime PM core to increase the usage count for the device's
    parent and permanently make it runtime resumed.
    
    The usage count is only dropped at device removal, which also allows it to
    be runtime suspended again.
    
    A re-trying ->probe() repeats the call to pm_runtime_irq_safe() and thus
    once more triggers the usage count of the device's parent to be increased.
    
    This leads to not only an imbalance issue of the usage count of the
    device's parent, but also to keep it runtime resumed permanently even if
    ->probe() fails.
    
    To address these issues, let's change the policy of the driver core to
    meet these expectations. More precisely, at ->probe() failures and driver
    unbind, restore the initial states of runtime PM.
    
    Although to still allow subsystem's to control PM for devices that doesn't
    ->probe() successfully, don't restore the initial states unless runtime PM
    is disabled.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a641cf3ccad6..cd2d79b1bf01 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -340,6 +340,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	dev_set_drvdata(dev, NULL);
 	if (dev->pm_domain && dev->pm_domain->dismiss)
 		dev->pm_domain->dismiss(dev);
+	pm_runtime_reinit(dev);
 
 	switch (ret) {
 	case -EPROBE_DEFER:
@@ -695,6 +696,7 @@ static void __device_release_driver(struct device *dev)
 		dev_set_drvdata(dev, NULL);
 		if (dev->pm_domain && dev->pm_domain->dismiss)
 			dev->pm_domain->dismiss(dev);
+		pm_runtime_reinit(dev);
 
 		klist_remove(&dev->p->knode_driver);
 		if (dev->bus)

commit 013c074f8642d8e815ad670601f8e27155a74b57
Author: Strashko, Grygorii <grygorii.strashko@ti.com>
Date:   Tue Nov 10 11:42:34 2015 +0200

    PM / sleep: prohibit devices probing during suspend/hibernation
    
    It is unsafe [1] if probing of devices will happen during suspend or
    hibernation and system behavior will be unpredictable in this case.
    So, let's prohibit device's probing in dpm_prepare() and defer their
    probing instead. The normal behavior will be restored in
    dpm_complete().
    
    This patch introduces new DD core APIs:
     device_block_probing()
       It will disable probing of devices and defer their probes instead.
     device_unblock_probing()
       It will restore normal behavior and trigger re-probing of deferred
       devices.
    
    [1] https://lkml.org/lkml/2015/9/11/554
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a641cf3ccad6..b605f734b882 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -54,6 +54,13 @@ static LIST_HEAD(deferred_probe_active_list);
 static struct workqueue_struct *deferred_wq;
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 
+/*
+ * In some cases, like suspend to RAM or hibernation, It might be reasonable
+ * to prohibit probing of devices as it could be unsafe.
+ * Once defer_all_probes is true all drivers probes will be forcibly deferred.
+ */
+static bool defer_all_probes;
+
 /*
  * deferred_probe_work_func() - Retry probing devices in the active list.
  */
@@ -171,6 +178,30 @@ static void driver_deferred_probe_trigger(void)
 	queue_work(deferred_wq, &deferred_probe_work);
 }
 
+/**
+ * device_block_probing() - Block/defere device's probes
+ *
+ *	It will disable probing of devices and defer their probes instead.
+ */
+void device_block_probing(void)
+{
+	defer_all_probes = true;
+	/* sync with probes to avoid races. */
+	wait_for_device_probe();
+}
+
+/**
+ * device_unblock_probing() - Unblock/enable device's probes
+ *
+ *	It will restore normal behavior and trigger re-probing of deferred
+ * devices.
+ */
+void device_unblock_probing(void)
+{
+	defer_all_probes = false;
+	driver_deferred_probe_trigger();
+}
+
 /**
  * deferred_probe_initcall() - Enable probing of deferred devices
  *
@@ -277,9 +308,20 @@ static DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);
 
 static int really_probe(struct device *dev, struct device_driver *drv)
 {
-	int ret = 0;
+	int ret = -EPROBE_DEFER;
 	int local_trigger_count = atomic_read(&deferred_trigger_count);
 
+	if (defer_all_probes) {
+		/*
+		 * Value of defer_all_probes can be set only by
+		 * device_defer_all_probes_enable() which, in turn, will call
+		 * wait_for_device_probe() right after that to avoid any races.
+		 */
+		dev_dbg(dev, "Driver %s force probe deferral\n", drv->name);
+		driver_deferred_probe_add(dev);
+		return ret;
+	}
+
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
 		 drv->bus->name, __func__, drv->name, dev_name(dev));
@@ -393,6 +435,10 @@ int driver_probe_done(void)
  */
 void wait_for_device_probe(void)
 {
+	/* wait for the deferred probe workqueue to finish */
+	if (driver_deferred_probe_enable)
+		flush_workqueue(deferred_wq);
+
 	/* wait for the known devices to complete their probing */
 	wait_event(probe_waitqueue, atomic_read(&probe_count) == 0);
 	async_synchronize_full();

commit ef0eebc05130b0d22b0ea65c0cd014ee16fc89c7
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Oct 20 21:15:06 2015 -0700

    drivers/pinctrl: Add the concept of an "init" state
    
    For pinctrl the "default" state is applied to pins before the driver's
    probe function is called.  This is normally a sensible thing to do,
    but in some cases can cause problems.  That's because the pins will
    change state before the driver is given a chance to program how those
    pins should behave.
    
    As an example you might have a regulator that is controlled by a PWM
    (output high = high voltage, output low = low voltage).  The firmware
    might leave this pin as driven high.  If we allow the driver core to
    reconfigure this pin as a PWM pin before the PWM's probe function runs
    then you might end up running at too low of a voltage while we probe.
    
    Let's introudce a new "init" state.  If this is defined we'll set
    pinctrl to this state before probe and then "default" after probe
    (unless the driver explicitly changed states already).
    
    An alternative idea that was thought of was to use the pre-existing
    "sleep" or "idle" states and add a boolean property that we should
    start in that mode.  This was not done because the "init" state is
    needed for correctness and those other states are only present (and
    only transitioned in to and out of) when (optional) power management
    is enabled.
    
    Changes in v3:
    - Moved declarations to pinctrl/devinfo.h
    - Fixed author/SoB
    
    Changes in v2:
    - Added comment to pinctrl_init_done() as per Linus W.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index be0eb4639128..a641cf3ccad6 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -322,6 +322,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 			goto probe_failed;
 	}
 
+	pinctrl_init_done(dev);
+
 	if (dev->pm_domain && dev->pm_domain->sync)
 		dev->pm_domain->sync(dev);
 

commit ae982073095a44f004d7ffb9f271077abef9dbcf
Merge: f1a3c0b933e7 e625ccec1fa6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 19:45:46 2015 -0700

    Merge tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "From the number of commits perspective, the biggest items are ACPICA
      and cpufreq changes with the latter taking the lead (over 50 commits).
    
      On the cpufreq front, there are many cleanups and minor fixes in the
      core and governors, driver updates etc.  We also have a new cpufreq
      driver for Mediatek MT8173 chips.
    
      ACPICA mostly updates its debug infrastructure and adds a number of
      fixes and cleanups for a good measure.
    
      The Operating Performance Points (OPP) framework is updated with new
      DT bindings and support for them among other things.
    
      We have a few updates of the generic power domains framework and a
      reorganization of the ACPI device enumeration code and bus type
      operations.
    
      And a lot of fixes and cleanups all over.
    
      Included is one branch from the MFD tree as it contains some
      PM-related driver core and ACPI PM changes a few other commits are
      based on.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150818 including method
         tracing extensions to allow more in-depth AML debugging in the
         kernel and a number of assorted fixes and cleanups (Bob Moore, Lv
         Zheng, Markus Elfring).
    
       - ACPI sysfs code updates and a documentation update related to AML
         method tracing (Lv Zheng).
    
       - ACPI EC driver fix related to serialized evaluations of _Qxx
         methods and ACPI tools updates allowing the EC userspace tool to be
         built from the kernel source (Lv Zheng).
    
       - ACPI processor driver updates preparing it for future introduction
         of CPPC support and ACPI PCC mailbox driver updates (Ashwin
         Chaugule).
    
       - ACPI interrupts enumeration fix for a regression related to the
         handling of IRQ attribute conflicts between MADT and the ACPI
         namespace (Jiang Liu).
    
       - Fixes related to ACPI device PM (Mika Westerberg, Srinidhi
         Kasagar).
    
       - ACPI device registration code reorganization to separate the
         sysfs-related code and bus type operations from the rest (Rafael J
         Wysocki).
    
       - Assorted cleanups in the ACPI core (Jarkko Nikula, Mathias Krause,
         Andy Shevchenko, Rafael J Wysocki, Nicolas Iooss).
    
       - ACPI cpufreq driver and ia64 cpufreq driver fixes and cleanups (Pan
         Xinhui, Rafael J Wysocki).
    
       - cpufreq core cleanups on top of the previous changes allowing it to
         preseve its sysfs directories over system suspend/resume (Viresh
         Kumar, Rafael J Wysocki, Sebastian Andrzej Siewior).
    
       - cpufreq fixes and cleanups related to governors (Viresh Kumar).
    
       - cpufreq updates (core and the cpufreq-dt driver) related to the
         turbo/boost mode support (Viresh Kumar, Bartlomiej Zolnierkiewicz).
    
       - New DT bindings for Operating Performance Points (OPP), support for
         them in the OPP framework and in the cpufreq-dt driver plus related
         OPP framework fixes and cleanups (Viresh Kumar).
    
       - cpufreq powernv driver updates (Shilpasri G Bhat).
    
       - New cpufreq driver for Mediatek MT8173 (Pi-Cheng Chen).
    
       - Assorted cpufreq driver (speedstep-lib, sfi, integrator) cleanups
         and fixes (Abhilash Jindal, Andrzej Hajda, Cristian Ardelean).
    
       - intel_pstate driver updates including Skylake-S support, support
         for enabling HW P-states per CPU and an additional vendor bypass
         list entry (Kristen Carlson Accardi, Chen Yu, Ethan Zhao).
    
       - cpuidle core fixes related to the handling of coupled idle states
         (Xunlei Pang).
    
       - intel_idle driver updates including Skylake Client support and
         support for freeze-mode-specific idle states (Len Brown).
    
       - Driver core updates related to power management (Andy Shevchenko,
         Rafael J Wysocki).
    
       - Generic power domains framework fixes and cleanups (Jon Hunter,
         Geert Uytterhoeven, Rajendra Nayak, Ulf Hansson).
    
       - Device PM QoS framework update to allow the latency tolerance
         setting to be exposed to user space via sysfs (Mika Westerberg).
    
       - devfreq support for PPMUv2 in Exynos5433 and a fix for an incorrect
         exynos-ppmu DT binding (Chanwoo Choi, Javier Martinez Canillas).
    
       - System sleep support updates (Alan Stern, Len Brown, SungEun Kim).
    
       - rockchip-io AVS support updates (Heiko Stuebner).
    
       - PM core clocks support fixup (Colin Ian King).
    
       - Power capping RAPL driver update including support for Skylake H/S
         and Broadwell-H (Radivoje Jovanovic, Seiichi Ikarashi).
    
       - Generic device properties framework fixes related to the handling
         of static (driver-provided) property sets (Andy Shevchenko).
    
       - turbostat and cpupower updates (Len Brown, Shilpasri G Bhat,
         Shreyas B Prabhu)"
    
    * tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (180 commits)
      cpufreq: speedstep-lib: Use monotonic clock
      cpufreq: powernv: Increase the verbosity of OCC console messages
      cpufreq: sfi: use kmemdup rather than duplicating its implementation
      cpufreq: drop !cpufreq_driver check from cpufreq_parse_governor()
      cpufreq: rename cpufreq_real_policy as cpufreq_user_policy
      cpufreq: remove redundant 'policy' field from user_policy
      cpufreq: remove redundant 'governor' field from user_policy
      cpufreq: update user_policy.* on success
      cpufreq: use memcpy() to copy policy
      cpufreq: remove redundant CPUFREQ_INCOMPATIBLE notifier event
      cpufreq: mediatek: Add MT8173 cpufreq driver
      dt-bindings: mediatek: Add MT8173 CPU DVFS clock bindings
      PM / Domains: Fix typo in description of genpd_dev_pm_detach()
      PM / Domains: Remove unusable governor dummies
      PM / Domains: Make pm_genpd_init() available to modules
      PM / domains: Align column headers and data in pm_genpd_summary output
      powercap / RAPL: disable the 2nd power limit properly
      tools: cpupower: Fix error when running cpupower monitor
      PM / OPP: Drop unlikely before IS_ERR(_OR_NULL)
      PM / OPP: Fix static checker warning (broken 64bit big endian systems)
      ...

commit 52cdbdd49853dfa856082edb0f4c4c0249d9df07
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Jul 27 20:43:01 2015 +0300

    driver core: correct device's shutdown order
    
    Now device's shutdown sequence is performed in reverse order of their
    registration in devices_kset list and this sequence corresponds to the
    reverse device's creation order. So, devices_kset data tracks
    "parent<-child" device's dependencies only.
    
    Unfortunately, that's not enough and causes problems in case of
    implementing board's specific shutdown procedures. For example [1]:
    "DRA7XX_evm uses PCF8575 and one of the PCF output lines feeds to
    MMC/SD and this line should be driven high in order for the MMC/SD to
    be detected. This line is modelled as regulator and the hsmmc driver
    takes care of enabling and disabling it. In the case of 'reboot',
    during shutdown path as part of it's cleanup process the hsmmc driver
    disables this regulator. This makes MMC boot not functional."
    
    To handle this issue the .shutdown() callback could be implemented
    for PCF8575 device where corresponding GPIO pins will be configured to
    states, required for correct warm/cold reset. This can be achieved
    only when all .shutdown() callbacks have been called already for all
    PCF8575's consumers. But devices_kset is not filled correctly now:
    
    devices_kset: Device61 4e000000.dmm
    devices_kset: Device62 48070000.i2c
    devices_kset: Device63 48072000.i2c
    devices_kset: Device64 48060000.i2c
    devices_kset: Device65 4809c000.mmc
    ...
    devices_kset: Device102 fixedregulator-sd
    ...
    devices_kset: Device181 0-0020 // PCF8575
    devices_kset: Device182 gpiochip496
    devices_kset: Device183 0-0021 // PCF8575
    devices_kset: Device184 gpiochip480
    
    As can be seen from above .shutdown() callback for PCF8575 will be called
    before its consumers, which, in turn means, that any changes of PCF8575
    GPIO's pins will be or unsafe or overwritten later by GPIO's consumers.
    The problem can be solved if devices_kset list will be filled not only
    according device creation order, but also according device's probing
    order to track "supplier<-consumer" dependencies also.
    
    Hence, as a fix, lets add devices_kset_move_last(),
    devices_kset_move_before(), devices_kset_move_after() and call them
    from device_move() and also add call of devices_kset_move_last() in
    really_probe(). After this change all entries in devices_kset will
    be sorted according to device's creation ("parent<-child") and
    probing ("supplier<-consumer") order.
    
    devices_kset after:
    devices_kset: Device121 48070000.i2c
    devices_kset: Device122 i2c-0
    ...
    devices_kset: Device147 regulator.24
    devices_kset: Device148 0-0020
    devices_kset: Device149 gpiochip496
    devices_kset: Device150 0-0021
    devices_kset: Device151 gpiochip480
    devices_kset: Device152 0-0019
    ...
    devices_kset: Device372 fixedregulator-sd
    devices_kset: Device373 regulator.29
    devices_kset: Device374 4809c000.mmc
    devices_kset: Device375 mmc0
    
    [1] http://www.spinics.net/lists/linux-mmc/msg29825.html
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a638bbb1a27a..cc2b1d4801fd 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -304,6 +304,14 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 			goto probe_failed;
 	}
 
+	/*
+	 * Ensure devices are listed in devices_kset in correct order
+	 * It's important to move Dev to the end of devices_kset before
+	 * calling .probe, because it could be recursive and parent Dev
+	 * should always go first
+	 */
+	devices_kset_move_last(dev);
+
 	if (dev->bus->probe) {
 		ret = dev->bus->probe(dev);
 		if (ret)

commit ddef08dd00f5548f943422c86e4ffe67dd040b6c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 27 18:03:58 2015 +0300

    Driver core: wakeup the parent device before trying probe
    
    If the parent is still suspended when driver probe is
    attempted, the result may be failure.
    
    For example, if the parent is a PCI MFD device that has been
    suspended when we try to probe our device, any register
    reads will return 0xffffffff.
    
    To fix the problem, making sure the parent is always awake
    before attempting driver probe.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a638bbb1a27a..2d6df1dd3852 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -399,6 +399,8 @@ EXPORT_SYMBOL_GPL(wait_for_device_probe);
  *
  * This function must be called with @dev lock held.  When called for a
  * USB interface, @dev->parent lock must be held as well.
+ *
+ * If the device has a parent, runtime-resume the parent before driver probing.
  */
 int driver_probe_device(struct device_driver *drv, struct device *dev)
 {
@@ -410,10 +412,16 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
+	if (dev->parent)
+		pm_runtime_get_sync(dev->parent);
+
 	pm_runtime_barrier(dev);
 	ret = really_probe(dev, drv);
 	pm_request_idle(dev);
 
+	if (dev->parent)
+		pm_runtime_put(dev->parent);
+
 	return ret;
 }
 
@@ -507,11 +515,17 @@ static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)
 
 	device_lock(dev);
 
+	if (dev->parent)
+		pm_runtime_get_sync(dev->parent);
+
 	bus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver);
 	dev_dbg(dev, "async probe completed\n");
 
 	pm_request_idle(dev);
 
+	if (dev->parent)
+		pm_runtime_put(dev->parent);
+
 	device_unlock(dev);
 
 	put_device(dev);
@@ -541,6 +555,9 @@ static int __device_attach(struct device *dev, bool allow_async)
 			.want_async = false,
 		};
 
+		if (dev->parent)
+			pm_runtime_get_sync(dev->parent);
+
 		ret = bus_for_each_drv(dev->bus, NULL, &data,
 					__device_attach_driver);
 		if (!ret && allow_async && data.have_async) {
@@ -557,6 +574,9 @@ static int __device_attach(struct device *dev, bool allow_async)
 		} else {
 			pm_request_idle(dev);
 		}
+
+		if (dev->parent)
+			pm_runtime_put(dev->parent);
 	}
 out_unlock:
 	device_unlock(dev);

commit 9ba8af66432cb8e82553f2e273eb11db0cec7d2d
Author: Shailendra Verma <shailendra.capricorn@gmail.com>
Date:   Mon May 25 23:46:11 2015 +0530

    base:dd - Fix for typo in comment to function driver_deferred_probe_trigger().
    
    Signed-off-by: Shailendra Verma <shailendra.capricorn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 8da8e071f01d..a638bbb1a27a 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -141,7 +141,7 @@ static bool driver_deferred_probe_enable = false;
  * more than one device is probing at the same time, it is possible for one
  * probe to complete successfully while another is about to defer. If the second
  * depends on the first, then it will get put on the pending list after the
- * trigger event has already occured and will be stuck there.
+ * trigger event has already occurred and will be stuck there.
  *
  * The atomic 'deferred_trigger_count' is used to determine if a successful
  * trigger has occurred in the midst of probing a driver. If the trigger count

commit 80c6e1465948c2e91214f01764f427d31ebedb26
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu May 21 15:49:37 2015 -0700

    driver-core: fix build for !CONFIG_MODULES
    
    Commit f2411da74698 ("driver-core: add driver module asynchronous probe
    support") broke build in case modules are disabled, because in this case
    "struct module" is not defined and we can't dereference it. Let's define
    module_requested_async_probing() helper and stub it out if modules are
    disabled.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 42e97d90a59a..8da8e071f01d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -427,7 +427,7 @@ bool driver_allows_async_probing(struct device_driver *drv)
 		return false;
 
 	default:
-		if (drv->owner && drv->owner->async_probe_requested)
+		if (module_requested_async_probing(drv->owner))
 			return true;
 
 		return false;

commit 802a87fd5be9cac1d05879bcdae2620e46b0dbe6
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed May 20 16:36:31 2015 -0700

    driver-core: make __device_attach() static
    
    It is only used within dd.c and thus need not be global.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 39292535c74e..42e97d90a59a 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -517,7 +517,7 @@ static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)
 	put_device(dev);
 }
 
-int __device_attach(struct device *dev, bool allow_async)
+static int __device_attach(struct device *dev, bool allow_async)
 {
 	int ret = 0;
 

commit d173a137c5bd95ee29d02705e5fa8890ef149718
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Mon Mar 30 16:20:06 2015 -0700

    driver-core: enable drivers to opt-out of async probe
    
    There are drivers that can not be probed asynchronously. One such group
    is platform drivers registered with platform_driver_probe(), which
    expects driver's probe routine be discarded after the driver has been
    registered and initial binding attempt executed. Also
    platform_driver_probe() an error when no devices were bound to the
    driver, allowing failing to load such driver module altogether.
    
    Other drivers do not work well with asynchronous probing because of
    driver bug or not optimal driver organization.
    
    To allow using such drivers even when user requests asynchronous probing
    as default boot strategy, let's allow them to opt out.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 7a2fa5dcead7..39292535c74e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -419,13 +419,19 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 
 bool driver_allows_async_probing(struct device_driver *drv)
 {
-	if (drv->probe_type == PROBE_PREFER_ASYNCHRONOUS)
+	switch (drv->probe_type) {
+	case PROBE_PREFER_ASYNCHRONOUS:
 		return true;
 
-	if (drv->owner && drv->owner->async_probe_requested)
-		return true;
+	case PROBE_FORCE_SYNCHRONOUS:
+		return false;
+
+	default:
+		if (drv->owner && drv->owner->async_probe_requested)
+			return true;
 
-	return false;
+		return false;
+	}
 }
 
 struct device_attach_data {

commit f2411da746985e60d4d087f3a43e271c61785927
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Mon Mar 30 16:20:05 2015 -0700

    driver-core: add driver module asynchronous probe support
    
    Some init systems may wish to express the desire to have device drivers
    run their probe() code asynchronously. This implements support for this
    and allows userspace to request async probe as a preference through a
    generic shared device driver module parameter, async_probe.
    
    Implementation for async probe is supported through a module parameter
    given that since synchronous probe has been prevalent for years some
    userspace might exist which relies on the fact that the device driver
    will probe synchronously and the assumption that devices it provides
    will be immediately available after this.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 2ad33b21888c..7a2fa5dcead7 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -419,7 +419,13 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 
 bool driver_allows_async_probing(struct device_driver *drv)
 {
-	return drv->probe_type == PROBE_PREFER_ASYNCHRONOUS;
+	if (drv->probe_type == PROBE_PREFER_ASYNCHRONOUS)
+		return true;
+
+	if (drv->owner && drv->owner->async_probe_requested)
+		return true;
+
+	return false;
 }
 
 struct device_attach_data {

commit 765230b5f084863183aa8adb3405ab3f32c0b16e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Mar 30 16:20:04 2015 -0700

    driver-core: add asynchronous probing support for drivers
    
    Some devices take a long time when initializing, and not all drivers are
    suited to initialize their devices when they are open. For example,
    input drivers need to interrogate their devices in order to publish
    device's capabilities before userspace will open them. When such drivers
    are compiled into kernel they may stall entire kernel initialization.
    
    This change allows drivers request for their probe functions to be
    called asynchronously during driver and device registration (manual
    binding is still synchronous). Because async_schedule is used to perform
    asynchronous calls module loading will still wait for the probing to
    complete.
    
    Note that the end goal is to make the probing asynchronous by default,
    so annotating drivers with PROBE_PREFER_ASYNCHRONOUS is a temporary
    measure that allows us to speed up boot process while we validating and
    fixing the rest of the drivers and preparing userspace.
    
    This change is based on earlier patch by "Luis R. Rodriguez"
    <mcgrof@suse.com>
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index e843fdbe4925..2ad33b21888c 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -417,31 +417,95 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	return ret;
 }
 
-static int __device_attach(struct device_driver *drv, void *data)
+bool driver_allows_async_probing(struct device_driver *drv)
 {
-	struct device *dev = data;
+	return drv->probe_type == PROBE_PREFER_ASYNCHRONOUS;
+}
+
+struct device_attach_data {
+	struct device *dev;
+
+	/*
+	 * Indicates whether we are are considering asynchronous probing or
+	 * not. Only initial binding after device or driver registration
+	 * (including deferral processing) may be done asynchronously, the
+	 * rest is always synchronous, as we expect it is being done by
+	 * request from userspace.
+	 */
+	bool check_async;
+
+	/*
+	 * Indicates if we are binding synchronous or asynchronous drivers.
+	 * When asynchronous probing is enabled we'll execute 2 passes
+	 * over drivers: first pass doing synchronous probing and second
+	 * doing asynchronous probing (if synchronous did not succeed -
+	 * most likely because there was no driver requiring synchronous
+	 * probing - and we found asynchronous driver during first pass).
+	 * The 2 passes are done because we can't shoot asynchronous
+	 * probe for given device and driver from bus_for_each_drv() since
+	 * driver pointer is not guaranteed to stay valid once
+	 * bus_for_each_drv() iterates to the next driver on the bus.
+	 */
+	bool want_async;
+
+	/*
+	 * We'll set have_async to 'true' if, while scanning for matching
+	 * driver, we'll encounter one that requests asynchronous probing.
+	 */
+	bool have_async;
+};
+
+static int __device_attach_driver(struct device_driver *drv, void *_data)
+{
+	struct device_attach_data *data = _data;
+	struct device *dev = data->dev;
+	bool async_allowed;
+
+	/*
+	 * Check if device has already been claimed. This may
+	 * happen with driver loading, device discovery/registration,
+	 * and deferred probe processing happens all at once with
+	 * multiple threads.
+	 */
+	if (dev->driver)
+		return -EBUSY;
 
 	if (!driver_match_device(drv, dev))
 		return 0;
 
+	async_allowed = driver_allows_async_probing(drv);
+
+	if (async_allowed)
+		data->have_async = true;
+
+	if (data->check_async && async_allowed != data->want_async)
+		return 0;
+
 	return driver_probe_device(drv, dev);
 }
 
-/**
- * device_attach - try to attach device to a driver.
- * @dev: device.
- *
- * Walk the list of drivers that the bus has and call
- * driver_probe_device() for each pair. If a compatible
- * pair is found, break out and return.
- *
- * Returns 1 if the device was bound to a driver;
- * 0 if no matching driver was found;
- * -ENODEV if the device is not registered.
- *
- * When called for a USB interface, @dev->parent lock must be held.
- */
-int device_attach(struct device *dev)
+static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)
+{
+	struct device *dev = _dev;
+	struct device_attach_data data = {
+		.dev		= dev,
+		.check_async	= true,
+		.want_async	= true,
+	};
+
+	device_lock(dev);
+
+	bus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver);
+	dev_dbg(dev, "async probe completed\n");
+
+	pm_request_idle(dev);
+
+	device_unlock(dev);
+
+	put_device(dev);
+}
+
+int __device_attach(struct device *dev, bool allow_async)
 {
 	int ret = 0;
 
@@ -459,15 +523,59 @@ int device_attach(struct device *dev)
 			ret = 0;
 		}
 	} else {
-		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
-		pm_request_idle(dev);
+		struct device_attach_data data = {
+			.dev = dev,
+			.check_async = allow_async,
+			.want_async = false,
+		};
+
+		ret = bus_for_each_drv(dev->bus, NULL, &data,
+					__device_attach_driver);
+		if (!ret && allow_async && data.have_async) {
+			/*
+			 * If we could not find appropriate driver
+			 * synchronously and we are allowed to do
+			 * async probes and there are drivers that
+			 * want to probe asynchronously, we'll
+			 * try them.
+			 */
+			dev_dbg(dev, "scheduling asynchronous probe\n");
+			get_device(dev);
+			async_schedule(__device_attach_async_helper, dev);
+		} else {
+			pm_request_idle(dev);
+		}
 	}
 out_unlock:
 	device_unlock(dev);
 	return ret;
 }
+
+/**
+ * device_attach - try to attach device to a driver.
+ * @dev: device.
+ *
+ * Walk the list of drivers that the bus has and call
+ * driver_probe_device() for each pair. If a compatible
+ * pair is found, break out and return.
+ *
+ * Returns 1 if the device was bound to a driver;
+ * 0 if no matching driver was found;
+ * -ENODEV if the device is not registered.
+ *
+ * When called for a USB interface, @dev->parent lock must be held.
+ */
+int device_attach(struct device *dev)
+{
+	return __device_attach(dev, false);
+}
 EXPORT_SYMBOL_GPL(device_attach);
 
+void device_initial_probe(struct device *dev)
+{
+	__device_attach(dev, true);
+}
+
 static int __driver_attach(struct device *dev, void *data)
 {
 	struct device_driver *drv = data;
@@ -522,6 +630,9 @@ static void __device_release_driver(struct device *dev)
 
 	drv = dev->driver;
 	if (drv) {
+		if (driver_allows_async_probing(drv))
+			async_synchronize_full();
+
 		pm_runtime_get_sync(dev);
 
 		driver_sysfs_remove(dev);

commit 2481bc75283ea10e75d5fb1a8b42af363fc4b45c
Merge: 8691c130fae1 518b4e272d99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 20:21:54 2015 -0700

    Merge tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups all over, although there are a few
      items that sort of fall into the new feature category.
    
      First off, we have new callbacks for PM domains that should help us to
      handle some issues related to device initialization in a better way.
    
      There also is some consolidation in the unified device properties API
      area allowing us to use that inferface for accessing data coming from
      platform initialization code in addition to firmware-provided data.
    
      We have some new device/CPU IDs in a few drivers, support for new
      chips and a new cpufreq driver too.
    
      Specifics:
    
       - Generic PM domains support update including new PM domain callbacks
         to handle device initialization better (Russell King, Rafael J
         Wysocki, Kevin Hilman)
    
       - Unified device properties API update including a new mechanism for
         accessing data provided by platform initialization code (Rafael J
         Wysocki, Adrian Hunter)
    
       - ARM cpuidle update including ARM32/ARM64 handling consolidation
         (Daniel Lezcano)
    
       - intel_idle update including support for the Silvermont Core in the
         Baytrail SOC and for the Airmont Core in the Cherrytrail and
         Braswell SOCs (Len Brown, Mathias Krause)
    
       - New cpufreq driver for Hisilicon ACPU (Leo Yan)
    
       - intel_pstate update including support for the Knights Landing chip
         (Dasaratharaman Chandramouli, Kristen Carlson Accardi)
    
       - QorIQ cpufreq driver update (Tang Yuantian, Arnd Bergmann)
    
       - powernv cpufreq driver update (Shilpasri G Bhat)
    
       - devfreq update including Tegra support changes (Tomeu Vizoso,
         MyungJoo Ham, Chanwoo Choi)
    
       - powercap RAPL (Running-Average Power Limit) driver update including
         support for Intel Broadwell server chips (Jacob Pan, Mathias Krause)
    
       - ACPI device enumeration update related to the handling of the
         special PRP0001 device ID allowing DT-style 'compatible' property
         to be used for ACPI device identification (Rafael J Wysocki)
    
       - ACPI EC driver update including limited _DEP support (Lan Tianyu,
         Lv Zheng)
    
       - ACPI backlight driver update including a new mechanism to allow
         native backlight handling to be forced on non-Windows 8 systems and
         a new quirk for Lenovo Ideapad Z570 (Aaron Lu, Hans de Goede)
    
       - New Windows Vista compatibility quirk for Sony VGN-SR19XN (Chen Yu)
    
       - Assorted ACPI fixes and cleanups (Aaron Lu, Martin Kepplinger,
         Masanari Iida, Mika Westerberg, Nan Li, Rafael J Wysocki)
    
       - Fixes related to suspend-to-idle for the iTCO watchdog driver and
         the ACPI core system suspend/resume code (Rafael J Wysocki, Chen Yu)
    
       - PM tracing support for the suspend phase of system suspend/resume
         transitions (Zhonghui Fu)
    
       - Configurable delay for the system suspend/resume testing facility
         (Brian Norris)
    
       - PNP subsystem cleanups (Peter Huewe, Rafael J Wysocki)"
    
    * tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (74 commits)
      ACPI / scan: Fix NULL pointer dereference in acpi_companion_match()
      ACPI / scan: Rework modalias creation when "compatible" is present
      intel_idle: mark cpu id array as __initconst
      powercap / RAPL: mark rapl_ids array as __initconst
      powercap / RAPL: add ID for Broadwell server
      intel_pstate: Knights Landing support
      intel_pstate: remove MSR test
      cpufreq: fix qoriq uniprocessor build
      ACPI / scan: Take the PRP0001 position in the list of IDs into account
      ACPI / scan: Simplify acpi_match_device()
      ACPI / scan: Generalize of_compatible matching
      device property: Introduce firmware node type for platform data
      device property: Make it possible to use secondary firmware nodes
      PM / watchdog: iTCO: stop watchdog during system suspend
      cpufreq: hisilicon: add acpu driver
      ACPI / EC: Call acpi_walk_dep_device_list() after installing EC opregion handler
      cpufreq: powernv: Report cpu frequency throttling
      intel_idle: Add support for the Airmont Core in the Cherrytrail and Braswell SOCs
      intel_idle: Update support for Silvermont Core in Baytrail SOC
      PM / devfreq: tegra: Register governor on module init
      ...

commit 13fcffbbdec4e4863a9a9c7792b821cd6d363a8f
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Mar 10 11:55:49 2015 +0000

    driver core: Make probe deferral more quiet
    
    Currently probe deferral prints a message every time a device requests
    deferral at info severity (which is displayed by default). This can have
    an impact on system boot times with serial consoles and is generally quite
    noisy.
    
    Since subsystems and drivers should already be logging the specific reason
    for probe deferral in order to aid users in understanding problems the
    messages from the driver core should be redundant lower the severity of
    the messages printed, cutting down on the volume of output on the console.
    
    This does mean that if the drivers and subsystems aren't doing a good job
    we get no output on the console by default. Ideally we'd be able to arrange
    to print if nothing else printed, though that's a little fun. Even better
    would be to come up with a mechanism that explicitly does dependencies so
    we don't have to keep polling and erroring.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index bfece0c0dba3..49a4a12fafef 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -323,7 +323,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	switch (ret) {
 	case -EPROBE_DEFER:
 		/* Driver requested deferred probing */
-		dev_info(dev, "Driver %s requests probe deferral\n", drv->name);
+		dev_dbg(dev, "Driver %s requests probe deferral\n", drv->name);
 		driver_deferred_probe_add(dev);
 		/* Did a trigger occur while probing? Need to re-trigger if yes */
 		if (local_trigger_count != atomic_read(&deferred_trigger_count))

commit bb2b40754ff4b2fffd8015ac96c45269cb54ee79
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Jan 17 22:14:41 2015 +0300

    driver core: use *switch* statement in really_probe()
    
    There are series of comparisons of the 'ret' variable on the failure path of
    really_probe(),  so the  *switch* statement  seems  more appropriate there.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index cdc779cf79a3..bfece0c0dba3 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -320,21 +320,25 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	dev->driver = NULL;
 	dev_set_drvdata(dev, NULL);
 
-	if (ret == -EPROBE_DEFER) {
+	switch (ret) {
+	case -EPROBE_DEFER:
 		/* Driver requested deferred probing */
 		dev_info(dev, "Driver %s requests probe deferral\n", drv->name);
 		driver_deferred_probe_add(dev);
 		/* Did a trigger occur while probing? Need to re-trigger if yes */
 		if (local_trigger_count != atomic_read(&deferred_trigger_count))
 			driver_deferred_probe_trigger();
-	} else if (ret != -ENODEV && ret != -ENXIO) {
+		break;
+	case -ENODEV:
+	case -ENXIO:
+		pr_debug("%s: probe of %s rejects match %d\n",
+			 drv->name, dev_name(dev), ret);
+		break;
+	default:
 		/* driver matched but the probe failed */
 		printk(KERN_WARNING
 		       "%s: probe of %s failed with error %d\n",
 		       drv->name, dev_name(dev), ret);
-	} else {
-		pr_debug("%s: probe of %s rejects match %d\n",
-		       drv->name, dev_name(dev), ret);
 	}
 	/*
 	 * Ignore errors returned by ->probe so that the next driver can try

commit e90d5532773e2bcccc538dd346b9fc3482cd700c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 20 13:59:27 2015 +0100

    driver core / PM: Add PM domain callbacks for device setup/cleanup
    
    If PM domains are in use, it may be necessary to prepare the code
    handling a PM domain for driver probing.  For example, in some
    cases device drivers rely on the ability to power on the devices
    with the help of the IO runtime PM framework and the PM domain
    code needs to be ready for that.  Also, if that code has not been
    fully initialized yet, the driver probing should be deferred.
    
    Moreover, after the probing is complete, it may be necessary to
    put the PM domain in question into the state reflecting the current
    needs of the devices in it, for example, so that power is not drawn
    in vain.  The same should be done after removing a driver from
    a device, as the PM domain state may need to be changed to reflect
    the new situation.
    
    For these reasons, introduce new PM domain callbacks, ->activate,
    ->sync and ->dismiss called, respectively, before probing for a
    device driver, after the probing has completed successfully and
    if the probing has failed or the driver has been removed.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index cdc779cf79a3..aeb744891e44 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -298,6 +298,12 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		goto probe_failed;
 	}
 
+	if (dev->pm_domain && dev->pm_domain->activate) {
+		ret = dev->pm_domain->activate(dev);
+		if (ret)
+			goto probe_failed;
+	}
+
 	if (dev->bus->probe) {
 		ret = dev->bus->probe(dev);
 		if (ret)
@@ -308,6 +314,9 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 			goto probe_failed;
 	}
 
+	if (dev->pm_domain && dev->pm_domain->sync)
+		dev->pm_domain->sync(dev);
+
 	driver_bound(dev);
 	ret = 1;
 	pr_debug("bus: '%s': %s: bound device %s to driver %s\n",
@@ -319,6 +328,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
 	dev_set_drvdata(dev, NULL);
+	if (dev->pm_domain && dev->pm_domain->dismiss)
+		dev->pm_domain->dismiss(dev);
 
 	if (ret == -EPROBE_DEFER) {
 		/* Driver requested deferred probing */
@@ -525,6 +536,9 @@ static void __device_release_driver(struct device *dev)
 		devres_release_all(dev);
 		dev->driver = NULL;
 		dev_set_drvdata(dev, NULL);
+		if (dev->pm_domain && dev->pm_domain->dismiss)
+			dev->pm_domain->dismiss(dev);
+
 		klist_remove(&dev->p->knode_driver);
 		if (dev->bus)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,

commit 41575335ed026339e07f265ede3a21e995bee8e6
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Aug 8 15:56:36 2014 +0200

    driver core: Remove kerneldoc from local function
    
    The deferred_probe_work_func() function is locally scoped, therefore an
    associated kerneldoc comment isn't very useful. Replace the kerneldoc
    opening marker (/**) with a regular block comment marker (/*) to avoid
    the comment from being parsed by kerneldoc. This gets rid of a warning
    caused by a missing description for the "work" argument.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index e4ffbcf2f519..cdc779cf79a3 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -54,7 +54,7 @@ static LIST_HEAD(deferred_probe_active_list);
 static struct workqueue_struct *deferred_wq;
 static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 
-/**
+/*
  * deferred_probe_work_func() - Retry probing devices in the active list.
  */
 static void deferred_probe_work_func(struct work_struct *work)

commit a996d010b648788b615938f6a26be6cf08d96aaf
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Apr 14 12:58:53 2014 +0200

    driver core: Inline dev_set/get_drvdata
    
    dev_set_drvdata and dev_get_drvdata are now simple enough again that
    we can inline them as they used to be before commit b40284378.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index ba03353ff243..e4ffbcf2f519 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -587,19 +587,3 @@ void driver_detach(struct device_driver *drv)
 		put_device(dev);
 	}
 }
-
-/*
- * These exports can't be _GPL due to .h files using this within them, and it
- * might break something that was previously working...
- */
-void *dev_get_drvdata(const struct device *dev)
-{
-	return dev->driver_data;
-}
-EXPORT_SYMBOL(dev_get_drvdata);
-
-void dev_set_drvdata(struct device *dev, void *data)
-{
-	dev->driver_data = data;
-}
-EXPORT_SYMBOL(dev_set_drvdata);

commit d4332013919aa87dbdede67d677e4cf2cd32e898
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Apr 14 12:57:43 2014 +0200

    driver core: dev_get_drvdata: Don't check for NULL dev
    
    There is no point in calling dev_get_drvdata without a valid device.
    So checking for dev == NULL is pointless. If such a check is ever
    needed - which I doubt - the driver should do it before calling
    dev_get_drvdata.
    
    We were returning NULL if dev was NULL, which the caller certainly did
    not expect anyway, so that was only delaying the crash if the caller
    is not paying attention.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index d21f4b8dc37b..ba03353ff243 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -594,9 +594,7 @@ void driver_detach(struct device_driver *drv)
  */
 void *dev_get_drvdata(const struct device *dev)
 {
-	if (dev)
-		return dev->driver_data;
-	return NULL;
+	return dev->driver_data;
 }
 EXPORT_SYMBOL(dev_get_drvdata);
 

commit 2c1f1ff0f0d9e0df8c9b6d3697ac250900091541
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Apr 14 12:56:34 2014 +0200

    driver core: dev_set_drvdata returns void
    
    dev_set_drvdata can no longer fail, so it could return void.
    
    All callers have hopefully been updated to no longer check for the
    return value.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index d14b6e895896..d21f4b8dc37b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -600,9 +600,8 @@ void *dev_get_drvdata(const struct device *dev)
 }
 EXPORT_SYMBOL(dev_get_drvdata);
 
-int dev_set_drvdata(struct device *dev, void *data)
+void dev_set_drvdata(struct device *dev, void *data)
 {
 	dev->driver_data = data;
-	return 0;
 }
 EXPORT_SYMBOL(dev_set_drvdata);

commit 1bb6c08abfb653ce6e65d8ab4ddef403227afedf
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Apr 14 12:54:47 2014 +0200

    driver core: Move driver_data back to struct device
    
    Having to allocate memory as part of dev_set_drvdata() is a problem
    because that memory may never get freed if the device itself is not
    created. So move driver_data back to struct device.
    
    This is a partial revert of commit b4028437.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 62ec61e8f84a..d14b6e895896 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -594,22 +594,15 @@ void driver_detach(struct device_driver *drv)
  */
 void *dev_get_drvdata(const struct device *dev)
 {
-	if (dev && dev->p)
-		return dev->p->driver_data;
+	if (dev)
+		return dev->driver_data;
 	return NULL;
 }
 EXPORT_SYMBOL(dev_get_drvdata);
 
 int dev_set_drvdata(struct device *dev, void *data)
 {
-	int error;
-
-	if (!dev->p) {
-		error = device_private_init(dev);
-		if (error)
-			return error;
-	}
-	dev->p->driver_data = data;
+	dev->driver_data = data;
 	return 0;
 }
 EXPORT_SYMBOL(dev_set_drvdata);

commit 58b116bce13612e5aa6fcd49ecbd4cf8bb59e835
Author: Grant Likely <grant.likely@linaro.org>
Date:   Tue Apr 29 12:05:22 2014 +0100

    drivercore: deferral race condition fix
    
    When the kernel is built with CONFIG_PREEMPT it is possible to reach a state
    when all modules loaded but some driver still stuck in the deferred list
    and there is a need for external event to kick the deferred queue to probe
    these drivers.
    
    The issue has been observed on embedded systems with CONFIG_PREEMPT enabled,
    audio support built as modules and using nfsroot for root filesystem.
    
    The following log fragment shows such sequence when all audio modules
    were loaded but the sound card is not present since the machine driver has
    failed to probe due to missing dependency during it's probe.
    The board is am335x-evmsk (McASP<->tlv320aic3106 codec) with davinci-evm
    machine driver:
    
    ...
    [   12.615118] davinci-mcasp 4803c000.mcasp: davinci_mcasp_probe: ENTER
    [   12.719969] davinci_evm sound.3: davinci_evm_probe: ENTER
    [   12.725753] davinci_evm sound.3: davinci_evm_probe: snd_soc_register_card
    [   12.753846] davinci-mcasp 4803c000.mcasp: davinci_mcasp_probe: snd_soc_register_component
    [   12.922051] davinci-mcasp 4803c000.mcasp: davinci_mcasp_probe: snd_soc_register_component DONE
    [   12.950839] davinci_evm sound.3: ASoC: platform (null) not registered
    [   12.957898] davinci_evm sound.3: davinci_evm_probe: snd_soc_register_card DONE (-517)
    [   13.099026] davinci-mcasp 4803c000.mcasp: Kicking the deferred list
    [   13.177838] davinci-mcasp 4803c000.mcasp: really_probe: probe_count = 2
    [   13.194130] davinci_evm sound.3: snd_soc_register_card failed (-517)
    [   13.346755] davinci_mcasp_driver_init: LEAVE
    [   13.377446] platform sound.3: Driver davinci_evm requests probe deferral
    [   13.592527] platform sound.3: really_probe: probe_count = 0
    
    In the log the machine driver enters it's probe at 12.719969 (this point it
    has been removed from the deferred lists). McASP driver already executing
    it's probing (since 12.615118).
    The machine driver tries to construct the sound card (12.950839) but did
    not found one of the components so it fails. After this McASP driver
    registers all the ASoC components (the machine driver still in it's probe
    function after it failed to construct the card) and the deferred work is
    prepared at 13.099026 (note that this time the machine driver is not in the
    lists so it is not going to be handled when the work is executing).
    Lastly the machine driver exit from it's probe and the core places it to
    the deferred list but there will be no other driver going to load and the
    deferred queue is not going to be kicked again - till we have external event
    like connecting USB stick, etc.
    
    The proposed solution is to try the deferred queue once more when the last
    driver is asking for deferring and we had drivers loaded while this last
    driver was probing.
    
    This way we can avoid drivers stuck in the deferred queue.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Reviewed-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Stable <stable@vger.kernel.org> # v3.4+

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 8986b9f22781..62ec61e8f84a 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -52,6 +52,7 @@ static DEFINE_MUTEX(deferred_probe_mutex);
 static LIST_HEAD(deferred_probe_pending_list);
 static LIST_HEAD(deferred_probe_active_list);
 static struct workqueue_struct *deferred_wq;
+static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
 
 /**
  * deferred_probe_work_func() - Retry probing devices in the active list.
@@ -135,6 +136,17 @@ static bool driver_deferred_probe_enable = false;
  * This functions moves all devices from the pending list to the active
  * list and schedules the deferred probe workqueue to process them.  It
  * should be called anytime a driver is successfully bound to a device.
+ *
+ * Note, there is a race condition in multi-threaded probe. In the case where
+ * more than one device is probing at the same time, it is possible for one
+ * probe to complete successfully while another is about to defer. If the second
+ * depends on the first, then it will get put on the pending list after the
+ * trigger event has already occured and will be stuck there.
+ *
+ * The atomic 'deferred_trigger_count' is used to determine if a successful
+ * trigger has occurred in the midst of probing a driver. If the trigger count
+ * changes in the midst of a probe, then deferred processing should be triggered
+ * again.
  */
 static void driver_deferred_probe_trigger(void)
 {
@@ -147,6 +159,7 @@ static void driver_deferred_probe_trigger(void)
 	 * into the active list so they can be retried by the workqueue
 	 */
 	mutex_lock(&deferred_probe_mutex);
+	atomic_inc(&deferred_trigger_count);
 	list_splice_tail_init(&deferred_probe_pending_list,
 			      &deferred_probe_active_list);
 	mutex_unlock(&deferred_probe_mutex);
@@ -265,6 +278,7 @@ static DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);
 static int really_probe(struct device *dev, struct device_driver *drv)
 {
 	int ret = 0;
+	int local_trigger_count = atomic_read(&deferred_trigger_count);
 
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
@@ -310,6 +324,9 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		/* Driver requested deferred probing */
 		dev_info(dev, "Driver %s requests probe deferral\n", drv->name);
 		driver_deferred_probe_add(dev);
+		/* Did a trigger occur while probing? Need to re-trigger if yes */
+		if (local_trigger_count != atomic_read(&deferred_trigger_count))
+			driver_deferred_probe_trigger();
 	} else if (ret != -ENODEV && ret != -ENXIO) {
 		/* driver matched but the probe failed */
 		printk(KERN_WARNING

commit 94f8cc0eea03648e5cc5de1a4e7dc464de92cc74
Author: Frank Rowand <frowand.list@gmail.com>
Date:   Wed Apr 16 17:12:30 2014 -0700

    drivers/base/dd.c incorrect pr_debug() parameters
    
    pr_debug() parameters are reverse order of format string
    
    Signed-off-by: Frank Rowand <frank.rowand@sonymobile.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 06051767393f..8986b9f22781 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -187,8 +187,8 @@ static void driver_bound(struct device *dev)
 		return;
 	}
 
-	pr_debug("driver: '%s': %s: bound to device '%s'\n", dev_name(dev),
-		 __func__, dev->driver->name);
+	pr_debug("driver: '%s': %s: bound to device '%s'\n", dev->driver->name,
+		 __func__, dev_name(dev));
 
 	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
 

commit baab52ded242c35a2290e1fa82e0cc147d0d8c1a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:51:15 2013 +0100

    PM / runtime: Use pm_runtime_put_sync() in __device_release_driver()
    
    Commit fa180eb448fa (PM / Runtime: Idle devices asynchronously after
    probe|release) modified __device_release_driver() to call
    pm_runtime_put(dev) instead of pm_runtime_put_sync(dev) before
    detaching the driver from the device.  However, that was a mistake,
    because pm_runtime_put(dev) causes rpm_idle() to be queued up and
    the driver may be gone already when that function is executed.
    That breaks the assumptions the drivers have the right to make
    about the core's behavior on the basis of the existing documentation
    and actually causes problems to happen, so revert that part of
    commit fa180eb448fa and restore the previous behavior of
    __device_release_driver().
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Fixes: fa180eb448fa (PM / Runtime: Idle devices asynchronously after probe|release)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 35fa36898916..06051767393f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -499,7 +499,7 @@ static void __device_release_driver(struct device *dev)
 						     BUS_NOTIFY_UNBIND_DRIVER,
 						     dev);
 
-		pm_runtime_put(dev);
+		pm_runtime_put_sync(dev);
 
 		if (dev->bus && dev->bus->remove)
 			dev->bus->remove(dev);

commit fa180eb448fa263cf18dd930143b515d27d70d7b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Apr 10 17:00:48 2013 +0200

    PM / Runtime: Idle devices asynchronously after probe|release
    
    Putting devices into idle|suspend in a synchronous manner means we are
    waiting for each device to become idle|suspended before the probe|release
    is fully done.
    
    This patch switch to use the asynchronous runtime PM API:s instead and
    thus improves the parallelism since we can move on and handle the next
    device in queue in an earlier phase.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index bb5645ea0282..35fa36898916 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -380,7 +380,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 
 	pm_runtime_barrier(dev);
 	ret = really_probe(dev, drv);
-	pm_runtime_idle(dev);
+	pm_request_idle(dev);
 
 	return ret;
 }
@@ -428,7 +428,7 @@ int device_attach(struct device *dev)
 		}
 	} else {
 		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
-		pm_runtime_idle(dev);
+		pm_request_idle(dev);
 	}
 out_unlock:
 	device_unlock(dev);
@@ -499,7 +499,7 @@ static void __device_release_driver(struct device *dev)
 						     BUS_NOTIFY_UNBIND_DRIVER,
 						     dev);
 
-		pm_runtime_put_sync(dev);
+		pm_runtime_put(dev);
 
 		if (dev->bus && dev->bus->remove)
 			dev->bus->remove(dev);

commit 06991c28f37ad68e5c03777f5c3b679b56e3dac1
Merge: 460dc1eecf37 74fef7a8fd1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 12:05:51 2013 -0800

    Merge tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core patches from Greg Kroah-Hartman:
     "Here is the big driver core merge for 3.9-rc1
    
      There are two major series here, both of which touch lots of drivers
      all over the kernel, and will cause you some merge conflicts:
    
       - add a new function called devm_ioremap_resource() to properly be
         able to check return values.
    
       - remove CONFIG_EXPERIMENTAL
    
      Other than those patches, there's not much here, some minor fixes and
      updates"
    
    Fix up trivial conflicts
    
    * tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (221 commits)
      base: memory: fix soft/hard_offline_page permissions
      drivercore: Fix ordering between deferred_probe and exiting initcalls
      backlight: fix class_find_device() arguments
      TTY: mark tty_get_device call with the proper const values
      driver-core: constify data for class_find_device()
      firmware: Ignore abort check when no user-helper is used
      firmware: Reduce ifdef CONFIG_FW_LOADER_USER_HELPER
      firmware: Make user-mode helper optional
      firmware: Refactoring for splitting user-mode helper code
      Driver core: treat unregistered bus_types as having no devices
      watchdog: Convert to devm_ioremap_resource()
      thermal: Convert to devm_ioremap_resource()
      spi: Convert to devm_ioremap_resource()
      power: Convert to devm_ioremap_resource()
      mtd: Convert to devm_ioremap_resource()
      mmc: Convert to devm_ioremap_resource()
      mfd: Convert to devm_ioremap_resource()
      media: Convert to devm_ioremap_resource()
      iommu: Convert to devm_ioremap_resource()
      drm: Convert to devm_ioremap_resource()
      ...

commit d72cca1eee5b26e313da2a380d4862924e271031
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Feb 14 18:14:27 2013 +0000

    drivercore: Fix ordering between deferred_probe and exiting initcalls
    
    One of the side effects of deferred probe is that some drivers which
    used to be probed before initcalls completed are now happening slightly
    later. This causes two problems.
    - If a console driver gets deferred, then it may not be ready when
      userspace starts. For example, if a uart depends on pinctrl, then the
      uart will get deferred and /dev/console will not be available
    - __init sections will be discarded before built-in drivers are probed.
      Strictly speaking, __init functions should not be called in a drivers
      __probe path, but there are a lot of drivers (console stuff again)
      that do anyway. In the past it was perfectly safe to do so because all
      built-in drivers got probed before the end of initcalls.
    
    This patch fixes the problem by forcing the first pass of the deferred
    list to complete at late_initcall time. This is late enough to catch the
    drivers that are known to have the above issues.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Haojian Zhuang <haojian.zhuang@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: stable <stable@vger.kernel.org> # 3.4+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index e3bbed8a617c..61d3e1b40694 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -172,6 +172,8 @@ static int deferred_probe_initcall(void)
 
 	driver_deferred_probe_enable = true;
 	driver_deferred_probe_trigger();
+	/* Sort as many dependencies as possible before exiting initcalls */
+	flush_workqueue(deferred_wq);
 	return 0;
 }
 late_initcall(deferred_probe_initcall);

commit ab78029ecc347debbd737f06688d788bd9d60c1d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 22 10:56:14 2013 -0700

    drivers/pinctrl: grab default handles from device core
    
    This makes the device core auto-grab the pinctrl handle and set
    the "default" (PINCTRL_STATE_DEFAULT) state for every device
    that is present in the device model right before probe. This will
    account for the lion's share of embedded silicon devcies.
    
    A modification of the semantics for pinctrl_get() is also done:
    previously if the pinctrl handle for a certain device was already
    taken, the pinctrl core would return an error. Now, since the
    core may have already default-grabbed the handle and set its
    state to "default", if the handle was already taken, this will
    be disregarded and the located, previously instanitated handle
    will be returned to the caller.
    
    This way all code in drivers explicitly requesting their pinctrl
    handlers will still be functional, and drivers that want to
    explicitly retrieve and switch their handles can still do that.
    But if the desired functionality is just boilerplate of this
    type in the probe() function:
    
    struct pinctrl  *p;
    
    p = devm_pinctrl_get_select_default(&dev);
    if (IS_ERR(p)) {
       if (PTR_ERR(p) == -EPROBE_DEFER)
            return -EPROBE_DEFER;
            dev_warn(&dev, "no pinctrl handle\n");
    }
    
    The discussion began with the addition of such boilerplate
    to the omap4 keypad driver:
    http://marc.info/?l=linux-input&m=135091157719300&w=2
    
    A previous approach using notifiers was discussed:
    http://marc.info/?l=linux-kernel&m=135263661110528&w=2
    This failed because it could not handle deferred probes.
    
    This patch alone does not solve the entire dilemma faced:
    whether code should be distributed into the drivers or
    if it should be centralized to e.g. a PM domain. But it
    solves the immediate issue of the addition of boilerplate
    to a lot of drivers that just want to grab the default
    state. As mentioned, they can later explicitly retrieve
    the handle and set different states, and this could as
    well be done by e.g. PM domains as it is only related
    to a certain struct device * pointer.
    
    ChangeLog v4->v5 (Stephen):
    - Simplified the devicecore grab code.
    - Deleted a piece of documentation recommending that pins
      be mapped to a device rather than hogged.
    ChangeLog v3->v4 (Linus):
    - Drop overzealous NULL checks.
    - Move kref initialization to pinctrl_create().
    - Seeking Tested-by from Stephen Warren so we do not disturb
      the Tegra platform.
    - Seeking ACK on this from Greg (and others who like it) so I
      can merge it through the pinctrl subsystem.
    ChangeLog v2->v3 (Linus):
    - Abstain from using IS_ERR_OR_NULL() in the driver core,
      Russell recently sent a patch to remove it. Handle the
      NULL case explicitly even though it's a bogus case.
    - Make sure we handle probe deferral correctly in the device
      core file. devm_kfree() the container on error so we don't
      waste memory for devices without pinctrl handles.
    - Introduce reference counting into the pinctrl core using
      <linux/kref.h> so that we don't release pinctrl handles
      that have been obtained for two or more places.
    ChangeLog v1->v2 (Linus):
    - Only store a pointer in the device struct, and only allocate
      this if it's really used by the device.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Mitch Bradley <wmb@firmworks.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Rickard Andersson <rickard.andersson@stericsson.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [swarren: fixed and simplified error-handling in pinctrl_bind_pins(), to
    correctly handle deferred probe. Removed admonition from docs not to use
    pinctrl hogs for devices]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index e3bbed8a617c..656310156dde 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -24,6 +24,7 @@
 #include <linux/wait.h>
 #include <linux/async.h>
 #include <linux/pm_runtime.h>
+#include <linux/pinctrl/devinfo.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -269,6 +270,12 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	WARN_ON(!list_empty(&dev->devres_head));
 
 	dev->driver = drv;
+
+	/* If using pinctrl, bind pins now before probing */
+	ret = pinctrl_bind_pins(dev);
+	if (ret)
+		goto probe_failed;
+
 	if (driver_sysfs_add(dev)) {
 		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
 			__func__, dev_name(dev));

commit eed5d2150752bd08b22333d739f3120151773d28
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 12 11:51:48 2012 +0200

    PM / Runtime: Do not increment device usage counts before probing
    
    The pm_runtime_get_noresume() calls before really_probe() and
    before executing __device_attach() for each driver on the
    device's bus cause problems to happen if probing fails and if the
    driver has enabled runtime PM for the device in its .probe()
    callback.  Namely, in that case, if the device has been resumed
    by the driver after enabling its runtime PM and if it turns out that
    .probe() should return an error, the driver is supposed to suspend
    the device and disable its runtime PM before exiting .probe().
    However, because the device's runtime PM usage counter was
    incremented by the core before calling .probe(), the driver's attempt
    to suspend the device will not succeed and the device will remain in
    the full-power state after the failing .probe() has returned.
    
    To fix this issue, remove the pm_runtime_get_noresume() calls from
    driver_probe_device() and from device_attach() and replace the
    corresponding pm_runtime_put_sync() calls with pm_runtime_idle()
    to preserve the existing behavior (which is to check if the device
    is idle and to suspend it eventually in that case after probing).
    
    Reported-and-tested-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 9b0aca479580..e3bbed8a617c 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -369,10 +369,9 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
-	pm_runtime_get_noresume(dev);
 	pm_runtime_barrier(dev);
 	ret = really_probe(dev, drv);
-	pm_runtime_put_sync(dev);
+	pm_runtime_idle(dev);
 
 	return ret;
 }
@@ -419,9 +418,8 @@ int device_attach(struct device *dev)
 			ret = 0;
 		}
 	} else {
-		pm_runtime_get_noresume(dev);
 		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
-		pm_runtime_put_sync(dev);
+		pm_runtime_idle(dev);
 	}
 out_unlock:
 	device_unlock(dev);

commit 8153584e3fdf78753bf653d5f583b6ecb86e5e70
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 5 14:04:44 2012 +0100

    driver core: Move deferred devices to the end of dpm_list before probing
    
    When deferred probe was originally added the idea was that devices which
    defer their probes would move themselves to the end of dpm_list in order
    to try to keep the assumptions that we're making about the list being in
    roughly the order things should be suspended correct. However this hasn't
    been what's been happening and doing it requires a lot of duplicated code
    to do the moves.
    
    Instead take a simple, brute force solution and have the deferred probe
    code push devices to the end of dpm_list before it retries the probe. This
    does mean we lock the dpm_list a bit more often but it's very simple and
    the code shouldn't be a fast path. We do the move with the deferred mutex
    dropped since doing things with fewer locks held simultaneously seems like
    a good idea.
    
    This approach was most recently suggested by Grant Likely.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Grant Likely <grant.likely@secretlab.ca>,
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 6cd2c6ca9b0d..9b0aca479580 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -85,8 +85,20 @@ static void deferred_probe_work_func(struct work_struct *work)
 		 * manipulate the deferred list
 		 */
 		mutex_unlock(&deferred_probe_mutex);
+
+		/*
+		 * Force the device to the end of the dpm_list since
+		 * the PM code assumes that the order we add things to
+		 * the list is a good order for suspend but deferred
+		 * probe makes that very unsafe.
+		 */
+		device_pm_lock();
+		device_pm_move_last(dev);
+		device_pm_unlock();
+
 		dev_dbg(dev, "Retrying from deferred list\n");
 		bus_probe_device(dev);
+
 		mutex_lock(&deferred_probe_mutex);
 
 		put_device(dev);

commit 6fbfd0592ef88ba29cdce84ef92757351f1fa9c9
Merge: f2c32a882d2c 6887a4131da3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jul 5 08:25:34 2012 -0700

    Merge v3.5-rc5 into driver-core-next
    
    This picks up the big printk fixes, and resolves a merge issue with:
            drivers/extcon/extcon_gpio.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0998d0631001288a5974afc0b2a5f568bcdecb4d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed May 23 00:09:34 2012 +0200

    device-core: Ensure drvdata = NULL when no driver is bound
    
    1) drvdata is for a driver to store a pointer to driver specific data
    2) If no driver is bound, there is no driver specific data associated with
       the device
    3) Thus logically drvdata should be NULL if no driver is bound.
    
    But many drivers don't clear drvdata on device_release, or set drvdata
    early on in probe and leave it set on probe error. Both of which results
    in a dangling pointer in drvdata.
    
    This patch enforce for drvdata to be NULL after device_release or on probe
    failure.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 1b1cbb571d38..9a1e9704d782 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -283,6 +283,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	devres_release_all(dev);
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
+	dev_set_drvdata(dev, NULL);
 
 	if (ret == -EPROBE_DEFER) {
 		/* Driver requested deferred probing */
@@ -487,6 +488,7 @@ static void __device_release_driver(struct device *dev)
 			drv->remove(dev);
 		devres_release_all(dev);
 		dev->driver = NULL;
+		dev_set_drvdata(dev, NULL);
 		klist_remove(&dev->p->knode_driver);
 		if (dev->bus)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,

commit 1d29cfa57471a5e4b8a7c2a7433eeba170d3ad92
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 29 18:46:06 2012 -0700

    driver core: fixup reversed deferred probe order
    
    If driver requests probe deferral,
    it will be added to deferred_probe_pending_list
    by driver_deferred_probe_add(), but, it used list_add().
    Because of that, deferred probe will be run as reversed order.
    This patch uses list_add_tail(), and solved this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 1b1cbb571d38..dcb8a6e48692 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -100,7 +100,7 @@ static void driver_deferred_probe_add(struct device *dev)
 	mutex_lock(&deferred_probe_mutex);
 	if (list_empty(&dev->p->deferred_probe)) {
 		dev_dbg(dev, "Added to deferred list\n");
-		list_add(&dev->p->deferred_probe, &deferred_probe_pending_list);
+		list_add_tail(&dev->p->deferred_probe, &deferred_probe_pending_list);
 	}
 	mutex_unlock(&deferred_probe_mutex);
 }

commit 8b0372a258e6bd0e9e5ea3f3d5f05a6bf3972fee
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 8 12:20:37 2012 -0800

    driver core: minor comment formatting cleanups
    
    Came in in the deferred probe patch, quick, clean them up before a
    kernel janitor finds them and sends me 4 individual patches to fix them
    up...
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 9fa888e08059..1b1cbb571d38 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -80,8 +80,10 @@ static void deferred_probe_work_func(struct work_struct *work)
 
 		get_device(dev);
 
-		/* Drop the mutex while probing each device; the probe path
-		 * may manipulate the deferred list */
+		/*
+		 * Drop the mutex while probing each device; the probe path may
+		 * manipulate the deferred list
+		 */
 		mutex_unlock(&deferred_probe_mutex);
 		dev_dbg(dev, "Retrying from deferred list\n");
 		bus_probe_device(dev);
@@ -126,16 +128,20 @@ static void driver_deferred_probe_trigger(void)
 	if (!driver_deferred_probe_enable)
 		return;
 
-	/* A successful probe means that all the devices in the pending list
+	/*
+	 * A successful probe means that all the devices in the pending list
 	 * should be triggered to be reprobed.  Move all the deferred devices
-	 * into the active list so they can be retried by the workqueue */
+	 * into the active list so they can be retried by the workqueue
+	 */
 	mutex_lock(&deferred_probe_mutex);
 	list_splice_tail_init(&deferred_probe_pending_list,
 			      &deferred_probe_active_list);
 	mutex_unlock(&deferred_probe_mutex);
 
-	/* Kick the re-probe thread.  It may already be scheduled, but
-	 * it is safe to kick it again. */
+	/*
+	 * Kick the re-probe thread.  It may already be scheduled, but it is
+	 * safe to kick it again.
+	 */
 	queue_work(deferred_wq, &deferred_probe_work);
 }
 
@@ -171,8 +177,10 @@ static void driver_bound(struct device *dev)
 
 	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
 
-	/* Make sure the device is no longer in one of the deferred lists
-	 * and kick off retrying all pending devices */
+	/*
+	 * Make sure the device is no longer in one of the deferred lists and
+	 * kick off retrying all pending devices
+	 */
 	driver_deferred_probe_del(dev);
 	driver_deferred_probe_trigger();
 

commit ef8a3fd6e5e12e8989dae97ba5491c2e39369af9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 8 12:17:22 2012 -0800

    driver core: move the deferred probe pointer into the private area
    
    Nothing outside of the driver core needs to get to the deferred probe
    pointer, so move it inside the private area of 'struct device' so no one
    tries to mess around with it.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 442b7641a086..9fa888e08059 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -45,7 +45,7 @@
  * retry them.
  *
  * The deferred_probe_mutex must be held any time the deferred_probe_*_list
- * of the (struct device*)->deferred_probe pointers are manipulated
+ * of the (struct device*)->p->deferred_probe pointers are manipulated
  */
 static DEFINE_MUTEX(deferred_probe_mutex);
 static LIST_HEAD(deferred_probe_pending_list);
@@ -58,6 +58,7 @@ static struct workqueue_struct *deferred_wq;
 static void deferred_probe_work_func(struct work_struct *work)
 {
 	struct device *dev;
+	struct device_private *private;
 	/*
 	 * This block processes every device in the deferred 'active' list.
 	 * Each device is removed from the active list and passed to
@@ -72,9 +73,10 @@ static void deferred_probe_work_func(struct work_struct *work)
 	 */
 	mutex_lock(&deferred_probe_mutex);
 	while (!list_empty(&deferred_probe_active_list)) {
-		dev = list_first_entry(&deferred_probe_active_list,
-					typeof(*dev), deferred_probe);
-		list_del_init(&dev->deferred_probe);
+		private = list_first_entry(&deferred_probe_active_list,
+					typeof(*dev->p), deferred_probe);
+		dev = private->device;
+		list_del_init(&private->deferred_probe);
 
 		get_device(dev);
 
@@ -94,9 +96,9 @@ static DECLARE_WORK(deferred_probe_work, deferred_probe_work_func);
 static void driver_deferred_probe_add(struct device *dev)
 {
 	mutex_lock(&deferred_probe_mutex);
-	if (list_empty(&dev->deferred_probe)) {
+	if (list_empty(&dev->p->deferred_probe)) {
 		dev_dbg(dev, "Added to deferred list\n");
-		list_add(&dev->deferred_probe, &deferred_probe_pending_list);
+		list_add(&dev->p->deferred_probe, &deferred_probe_pending_list);
 	}
 	mutex_unlock(&deferred_probe_mutex);
 }
@@ -104,9 +106,9 @@ static void driver_deferred_probe_add(struct device *dev)
 void driver_deferred_probe_del(struct device *dev)
 {
 	mutex_lock(&deferred_probe_mutex);
-	if (!list_empty(&dev->deferred_probe)) {
+	if (!list_empty(&dev->p->deferred_probe)) {
 		dev_dbg(dev, "Removed from deferred list\n");
-		list_del_init(&dev->deferred_probe);
+		list_del_init(&dev->p->deferred_probe);
 	}
 	mutex_unlock(&deferred_probe_mutex);
 }

commit d1c3414c2a9d10ef7f0f7665f5d2947cd088c093
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Mar 5 08:47:41 2012 -0700

    drivercore: Add driver probe deferral mechanism
    
    Allow drivers to report at probe time that they cannot get all the resources
    required by the device, and should be retried at a later time.
    
    This should completely solve the problem of getting devices
    initialized in the right order.  Right now this is mostly handled by
    mucking about with initcall ordering which is a complete hack, and
    doesn't even remotely handle the case where device drivers are in
    modules.  This approach completely sidesteps the issues by allowing
    driver registration to occur in any order, and any driver can request
    to be retried after a few more other drivers get probed.
    
    v4: - Integrate Manjunath's addition of a separate workqueue
        - Change -EAGAIN to -EPROBE_DEFER for drivers to trigger deferral
        - Update comment blocks to reflect how the code really works
    v3: - Hold off workqueue scheduling until late_initcall so that the bulk
          of driver probes are complete before we start retrying deferred devices.
        - Tested with simple use cases.  Still needs more testing though.
          Using it to get rid of the gpio early_initcall madness, or to replace
          the ASoC internal probe deferral code would be ideal.
    v2: - added locking so it should no longer be utterly broken in that regard
        - remove device from deferred list at device_del time.
        - Still completely untested with any real use case, but has been
          boot tested.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Dilan Lee <dilee@nvidia.com>
    Cc: Manjunath GKondaiah <manjunath.gkondaiah@linaro.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 142e3d600f14..442b7641a086 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -28,6 +28,133 @@
 #include "base.h"
 #include "power/power.h"
 
+/*
+ * Deferred Probe infrastructure.
+ *
+ * Sometimes driver probe order matters, but the kernel doesn't always have
+ * dependency information which means some drivers will get probed before a
+ * resource it depends on is available.  For example, an SDHCI driver may
+ * first need a GPIO line from an i2c GPIO controller before it can be
+ * initialized.  If a required resource is not available yet, a driver can
+ * request probing to be deferred by returning -EPROBE_DEFER from its probe hook
+ *
+ * Deferred probe maintains two lists of devices, a pending list and an active
+ * list.  A driver returning -EPROBE_DEFER causes the device to be added to the
+ * pending list.  A successful driver probe will trigger moving all devices
+ * from the pending to the active list so that the workqueue will eventually
+ * retry them.
+ *
+ * The deferred_probe_mutex must be held any time the deferred_probe_*_list
+ * of the (struct device*)->deferred_probe pointers are manipulated
+ */
+static DEFINE_MUTEX(deferred_probe_mutex);
+static LIST_HEAD(deferred_probe_pending_list);
+static LIST_HEAD(deferred_probe_active_list);
+static struct workqueue_struct *deferred_wq;
+
+/**
+ * deferred_probe_work_func() - Retry probing devices in the active list.
+ */
+static void deferred_probe_work_func(struct work_struct *work)
+{
+	struct device *dev;
+	/*
+	 * This block processes every device in the deferred 'active' list.
+	 * Each device is removed from the active list and passed to
+	 * bus_probe_device() to re-attempt the probe.  The loop continues
+	 * until every device in the active list is removed and retried.
+	 *
+	 * Note: Once the device is removed from the list and the mutex is
+	 * released, it is possible for the device get freed by another thread
+	 * and cause a illegal pointer dereference.  This code uses
+	 * get/put_device() to ensure the device structure cannot disappear
+	 * from under our feet.
+	 */
+	mutex_lock(&deferred_probe_mutex);
+	while (!list_empty(&deferred_probe_active_list)) {
+		dev = list_first_entry(&deferred_probe_active_list,
+					typeof(*dev), deferred_probe);
+		list_del_init(&dev->deferred_probe);
+
+		get_device(dev);
+
+		/* Drop the mutex while probing each device; the probe path
+		 * may manipulate the deferred list */
+		mutex_unlock(&deferred_probe_mutex);
+		dev_dbg(dev, "Retrying from deferred list\n");
+		bus_probe_device(dev);
+		mutex_lock(&deferred_probe_mutex);
+
+		put_device(dev);
+	}
+	mutex_unlock(&deferred_probe_mutex);
+}
+static DECLARE_WORK(deferred_probe_work, deferred_probe_work_func);
+
+static void driver_deferred_probe_add(struct device *dev)
+{
+	mutex_lock(&deferred_probe_mutex);
+	if (list_empty(&dev->deferred_probe)) {
+		dev_dbg(dev, "Added to deferred list\n");
+		list_add(&dev->deferred_probe, &deferred_probe_pending_list);
+	}
+	mutex_unlock(&deferred_probe_mutex);
+}
+
+void driver_deferred_probe_del(struct device *dev)
+{
+	mutex_lock(&deferred_probe_mutex);
+	if (!list_empty(&dev->deferred_probe)) {
+		dev_dbg(dev, "Removed from deferred list\n");
+		list_del_init(&dev->deferred_probe);
+	}
+	mutex_unlock(&deferred_probe_mutex);
+}
+
+static bool driver_deferred_probe_enable = false;
+/**
+ * driver_deferred_probe_trigger() - Kick off re-probing deferred devices
+ *
+ * This functions moves all devices from the pending list to the active
+ * list and schedules the deferred probe workqueue to process them.  It
+ * should be called anytime a driver is successfully bound to a device.
+ */
+static void driver_deferred_probe_trigger(void)
+{
+	if (!driver_deferred_probe_enable)
+		return;
+
+	/* A successful probe means that all the devices in the pending list
+	 * should be triggered to be reprobed.  Move all the deferred devices
+	 * into the active list so they can be retried by the workqueue */
+	mutex_lock(&deferred_probe_mutex);
+	list_splice_tail_init(&deferred_probe_pending_list,
+			      &deferred_probe_active_list);
+	mutex_unlock(&deferred_probe_mutex);
+
+	/* Kick the re-probe thread.  It may already be scheduled, but
+	 * it is safe to kick it again. */
+	queue_work(deferred_wq, &deferred_probe_work);
+}
+
+/**
+ * deferred_probe_initcall() - Enable probing of deferred devices
+ *
+ * We don't want to get in the way when the bulk of drivers are getting probed.
+ * Instead, this initcall makes sure that deferred probing is delayed until
+ * late_initcall time.
+ */
+static int deferred_probe_initcall(void)
+{
+	deferred_wq = create_singlethread_workqueue("deferwq");
+	if (WARN_ON(!deferred_wq))
+		return -ENOMEM;
+
+	driver_deferred_probe_enable = true;
+	driver_deferred_probe_trigger();
+	return 0;
+}
+late_initcall(deferred_probe_initcall);
 
 static void driver_bound(struct device *dev)
 {
@@ -42,6 +169,11 @@ static void driver_bound(struct device *dev)
 
 	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
 
+	/* Make sure the device is no longer in one of the deferred lists
+	 * and kick off retrying all pending devices */
+	driver_deferred_probe_del(dev);
+	driver_deferred_probe_trigger();
+
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
@@ -142,7 +274,11 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
 
-	if (ret != -ENODEV && ret != -ENXIO) {
+	if (ret == -EPROBE_DEFER) {
+		/* Driver requested deferred probing */
+		dev_info(dev, "Driver %s requests probe deferral\n", drv->name);
+		driver_deferred_probe_add(dev);
+	} else if (ret != -ENODEV && ret != -ENXIO) {
 		/* driver matched but the probe failed */
 		printk(KERN_WARNING
 		       "%s: probe of %s failed with error %d\n",

commit bcbe4f94d15ae1c985336bb3c35605e595fdde0d
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Tue Sep 20 19:41:17 2011 +0200

    drivers: base: print rejected matches with DEBUG_DRIVER
    
    When DEBUG_DRIVER is activated, be verbose and explicitly state when a
    device<->driver match was rejected by the probe-function of the driver.
    Now all code-paths report what is currently happening which helps
    debugging, because you don't have to remember that no printout means
    the match is rejected (and then you still don't know if it was because
    of ENODEV or ENXIO).
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 6658da743c3a..142e3d600f14 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -147,6 +147,9 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		printk(KERN_WARNING
 		       "%s: probe of %s failed with error %d\n",
 		       drv->name, dev_name(dev), ret);
+	} else {
+		pr_debug("%s: probe of %s rejects match %d\n",
+		       drv->name, dev_name(dev), ret);
 	}
 	/*
 	 * Ignore errors returned by ->probe so that the next driver can try

commit 39ab05c8e0b519ff0a04a869f065746e6e8c3d95
Merge: 1477fcc290b3 c42d2237143f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 18:24:11 2011 -0700

    Merge branch 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6
    
    * 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6: (44 commits)
      debugfs: Silence DEBUG_STRICT_USER_COPY_CHECKS=y warning
      sysfs: remove "last sysfs file:" line from the oops messages
      drivers/base/memory.c: fix warning due to "memory hotplug: Speed up add/remove when blocks are larger than PAGES_PER_SECTION"
      memory hotplug: Speed up add/remove when blocks are larger than PAGES_PER_SECTION
      SYSFS: Fix erroneous comments for sysfs_update_group().
      driver core: remove the driver-model structures from the documentation
      driver core: Add the device driver-model structures to kerneldoc
      Translated Documentation/email-clients.txt
      RAW driver: Remove call to kobject_put().
      reboot: disable usermodehelper to prevent fs access
      efivars: prevent oops on unload when efi is not enabled
      Allow setting of number of raw devices as a module parameter
      Introduce CONFIG_GOOGLE_FIRMWARE
      driver: Google Memory Console
      driver: Google EFI SMI
      x86: Better comments for get_bios_ebda()
      x86: get_bios_ebda_length()
      misc: fix ti-st build issues
      params.c: Use new strtobool function to process boolean inputs
      debugfs: move to new strtobool
      ...
    
    Fix up trivial conflicts in fs/debugfs/file.c due to the same patch
    being applied twice, and an unrelated cleanup nearby.

commit e1866b33b1e89f077b7132daae3dfd9a594e9a1a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 29 00:33:45 2011 +0200

    PM / Runtime: Rework runtime PM handling during driver removal
    
    The driver core tries to prevent race conditions between runtime PM
    and driver removal from happening by incrementing the runtime PM
    usage counter of the device and executing pm_runtime_barrier() before
    running the bus notifier and the ->remove() callbacks provided by the
    device's subsystem or driver.  This guarantees that, if a future
    runtime suspend of the device has been scheduled or a runtime resume
    or idle request has been queued up right before the driver removal,
    it will be canceled or waited for to complete and no other
    asynchronous runtime suspend or idle requests for the device will be
    put into the PM workqueue until the ->remove() callback returns.
    However, it doesn't prevent resume requests from being queued up
    after pm_runtime_barrier() has been called and it doesn't prevent
    pm_runtime_resume() from executing the device subsystem's runtime
    resume callback.  Morever, it prevents the device's subsystem or
    driver from putting the device into the suspended state by calling
    pm_runtime_suspend() from its ->remove() routine.  This turns out to
    be a major inconvenience for some subsystems and drivers that want to
    leave the devices they handle in the suspended state.
    
    To really prevent runtime PM callbacks from racing with the bus
    notifier callback in __device_release_driver(), which is necessary,
    because the notifier is used by some subsystems to carry out
    operations affecting the runtime PM functionality, use
    pm_runtime_get_sync() instead of the combination of
    pm_runtime_get_noresume() and pm_runtime_barrier().  This will resume
    the device if it's in the suspended state and will prevent it from
    being suspended again until pm_runtime_put_*() is called.
    
    To allow subsystems and drivers to put devices into the suspended
    state by calling pm_runtime_suspend() from their ->remove() routines,
    execute pm_runtime_put_sync() after running the bus notifier in
    __device_release_driver().  This will require subsystems and drivers
    to make their ->remove() callbacks avoid races with runtime PM
    directly, but it will allow of more flexibility in the handling of
    devices during the removal of their drivers.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index da57ee9d63fe..29917c7506cb 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -316,8 +316,7 @@ static void __device_release_driver(struct device *dev)
 
 	drv = dev->driver;
 	if (drv) {
-		pm_runtime_get_noresume(dev);
-		pm_runtime_barrier(dev);
+		pm_runtime_get_sync(dev);
 
 		driver_sysfs_remove(dev);
 
@@ -326,6 +325,8 @@ static void __device_release_driver(struct device *dev)
 						     BUS_NOTIFY_UNBIND_DRIVER,
 						     dev);
 
+		pm_runtime_put_sync(dev);
+
 		if (dev->bus && dev->bus->remove)
 			dev->bus->remove(dev);
 		else if (drv->remove)
@@ -338,7 +339,6 @@ static void __device_release_driver(struct device *dev)
 						     BUS_NOTIFY_UNBOUND_DRIVER,
 						     dev);
 
-		pm_runtime_put_sync(dev);
 	}
 }
 

commit c8705082404823a5bb3e02a32ba0764399b9e6f2
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Wed Apr 20 09:44:46 2011 +0200

    driver core: let dev_set_drvdata return int instead of void as it can fail
    
    Before commit
    
            b402843 (Driver core: move dev_get/set_drvdata to drivers/base/dd.c)
    
    calling dev_set_drvdata with dev=NULL was an unchecked error. After some
    discussion about what to return in this case removing the check (and so
    producing a null pointer exception) seems fine.
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 7e9219b02796..e3a3eff1dacc 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -413,17 +413,16 @@ void *dev_get_drvdata(const struct device *dev)
 }
 EXPORT_SYMBOL(dev_get_drvdata);
 
-void dev_set_drvdata(struct device *dev, void *data)
+int dev_set_drvdata(struct device *dev, void *data)
 {
 	int error;
 
-	if (!dev)
-		return;
 	if (!dev->p) {
 		error = device_private_init(dev);
 		if (error)
-			return;
+			return error;
 	}
 	dev->p->driver_data = data;
+	return 0;
 }
 EXPORT_SYMBOL(dev_set_drvdata);

commit 8497d6a21c4b17052e868bd53a74c82b557a6c46
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Tue Apr 12 19:05:37 2011 +0200

    driver-core: fix race between device_register and driver_register
    
    When a device is registered to a bus it will be a) added to the list
    of devices of the bus and b) bind to a driver (if one matches). As a
    result of a driver being registered at this bus between a) and b) this
    device could already be bound to a driver. This leads to a warning
    and incorrect refcounting.
    To fix this add a check to device_attach to identify an already bound
    device.
    
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index da57ee9d63fe..7e9219b02796 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -245,6 +245,10 @@ int device_attach(struct device *dev)
 
 	device_lock(dev);
 	if (dev->driver) {
+		if (klist_node_attached(&dev->p->knode_driver)) {
+			ret = 1;
+			goto out_unlock;
+		}
 		ret = device_bind_driver(dev);
 		if (ret == 0)
 			ret = 1;
@@ -257,6 +261,7 @@ int device_attach(struct device *dev)
 		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
 		pm_runtime_put_sync(dev);
 	}
+out_unlock:
 	device_unlock(dev);
 	return ret;
 }

commit 45daef0fdcc44f6af86fdebc4fc7eb7c79375398
Author: Magnus Damm <damm@opensource.se>
Date:   Fri Jul 23 19:56:18 2010 +0900

    Driver core: Add BUS_NOTIFY_BIND_DRIVER
    
    Add BUS_NOTIFY_BIND_DRIVER as a bus notifier event.
    
    For driver binding/unbinding we with this in
    place have the following bus notifier events:
     - BUS_NOTIFY_BIND_DRIVER - before ->probe()
     - BUS_NOTIFY_BOUND_DRIVER - after ->probe()
     - BUS_NOTIFY_UNBIND_DRIVER - before ->remove()
     - BUS_NOTIFY_UNBOUND_DRIVER - after ->remove()
    
    The event BUS_NOTIFY_BIND_DRIVER allows bus code
    to be notified that ->probe() is about to be called.
    
    Useful for bus code that needs to setup hardware before
    the driver gets to run. With this in place platform
    drivers can be loaded and unloaded as modules and the
    new BIND event allows bus code to control for instance
    device clocks that must be enabled before the driver
    can be executed.
    
    Without this patch there is no way for the bus code to
    get notified that a modular driver is about to be probed.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 503c2620bbcc..da57ee9d63fe 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -51,6 +51,10 @@ static int driver_sysfs_add(struct device *dev)
 {
 	int ret;
 
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
+					     BUS_NOTIFY_BIND_DRIVER, dev);
+
 	ret = sysfs_create_link(&dev->driver->p->kobj, &dev->kobj,
 			  kobject_name(&dev->kobj));
 	if (ret == 0) {

commit fbb88fadf7dc2dd6d0d1aa88ff521b2f8552996a
Author: Stefani Seibold <stefani@seibold.net>
Date:   Sat Mar 6 17:50:14 2010 +0100

    driver-core: fix potential race condition in drivers/base/dd.c
    
    This patch fix a potential race condition in the driver_bound() function
    in the file driver/base/dd.c.
    
    The broadcast of the BUS_NOTIFY_BOUND_DRIVER notifier should be done
    after adding the new device to the driver list. Otherwise notifier
    listener will fail if they use functions like usb_find_interface().
    
    The patch is against kernel 2.6.33. Please merge it.
    
    Signed-off-by: Stefani Seibold <stefani@seibold.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index c89291f8a16b..503c2620bbcc 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -40,11 +40,11 @@ static void driver_bound(struct device *dev)
 	pr_debug("driver: '%s': %s: bound to device '%s'\n", dev_name(dev),
 		 __func__, dev->driver->name);
 
+	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
+
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
-
-	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
 }
 
 static int driver_sysfs_add(struct device *dev)

commit 8e9394ce2412254ec69fd2a4f3e44a66eade2297
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Feb 17 10:57:05 2010 -0800

    Driver core: create lock/unlock functions for struct device
    
    In the future, we are going to be changing the lock type for struct
    device (once we get the lockdep infrastructure properly worked out)  To
    make that changeover easier, and to possibly burry the lock in a
    different part of struct device, let's create some functions to lock and
    unlock a device so that no out-of-core code needs to be changed in the
    future.
    
    This patch creates the device_lock/unlock/trylock() functions, and
    converts all in-tree users to them.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Magnus Damm <damm@igel.co.jp>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Vegard Nossum <vegard.nossum@gmail.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Alex Chiang <achiang@hp.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Patterson <andrew.patterson@hp.com>
    Cc: Yu Zhao <yu.zhao@intel.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Cc: CHENG Renquan <rqcheng@smu.edu.sg>
    Cc: Oliver Neukum <oliver@neukum.org>
    Cc: Frans Pop <elendil@planet.nl>
    Cc: David Vrabel <david.vrabel@csr.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index ee95c76bfd3d..c89291f8a16b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -85,7 +85,7 @@ static void driver_sysfs_remove(struct device *dev)
  * for before calling this. (It is ok to call with no other effort
  * from a driver's probe() method.)
  *
- * This function must be called with @dev->sem held.
+ * This function must be called with the device lock held.
  */
 int device_bind_driver(struct device *dev)
 {
@@ -190,8 +190,8 @@ EXPORT_SYMBOL_GPL(wait_for_device_probe);
  * This function returns -ENODEV if the device is not registered,
  * 1 if the device is bound successfully and 0 otherwise.
  *
- * This function must be called with @dev->sem held.  When called for a
- * USB interface, @dev->parent->sem must be held as well.
+ * This function must be called with @dev lock held.  When called for a
+ * USB interface, @dev->parent lock must be held as well.
  */
 int driver_probe_device(struct device_driver *drv, struct device *dev)
 {
@@ -233,13 +233,13 @@ static int __device_attach(struct device_driver *drv, void *data)
  * 0 if no matching driver was found;
  * -ENODEV if the device is not registered.
  *
- * When called for a USB interface, @dev->parent->sem must be held.
+ * When called for a USB interface, @dev->parent lock must be held.
  */
 int device_attach(struct device *dev)
 {
 	int ret = 0;
 
-	down(&dev->sem);
+	device_lock(dev);
 	if (dev->driver) {
 		ret = device_bind_driver(dev);
 		if (ret == 0)
@@ -253,7 +253,7 @@ int device_attach(struct device *dev)
 		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
 		pm_runtime_put_sync(dev);
 	}
-	up(&dev->sem);
+	device_unlock(dev);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(device_attach);
@@ -276,13 +276,13 @@ static int __driver_attach(struct device *dev, void *data)
 		return 0;
 
 	if (dev->parent)	/* Needed for USB */
-		down(&dev->parent->sem);
-	down(&dev->sem);
+		device_lock(dev->parent);
+	device_lock(dev);
 	if (!dev->driver)
 		driver_probe_device(drv, dev);
-	up(&dev->sem);
+	device_unlock(dev);
 	if (dev->parent)
-		up(&dev->parent->sem);
+		device_unlock(dev->parent);
 
 	return 0;
 }
@@ -303,8 +303,8 @@ int driver_attach(struct device_driver *drv)
 EXPORT_SYMBOL_GPL(driver_attach);
 
 /*
- * __device_release_driver() must be called with @dev->sem held.
- * When called for a USB interface, @dev->parent->sem must be held as well.
+ * __device_release_driver() must be called with @dev lock held.
+ * When called for a USB interface, @dev->parent lock must be held as well.
  */
 static void __device_release_driver(struct device *dev)
 {
@@ -343,7 +343,7 @@ static void __device_release_driver(struct device *dev)
  * @dev: device.
  *
  * Manually detach device from driver.
- * When called for a USB interface, @dev->parent->sem must be held.
+ * When called for a USB interface, @dev->parent lock must be held.
  */
 void device_release_driver(struct device *dev)
 {
@@ -352,9 +352,9 @@ void device_release_driver(struct device *dev)
 	 * within their ->remove callback for the same device, they
 	 * will deadlock right here.
 	 */
-	down(&dev->sem);
+	device_lock(dev);
 	__device_release_driver(dev);
-	up(&dev->sem);
+	device_unlock(dev);
 }
 EXPORT_SYMBOL_GPL(device_release_driver);
 
@@ -381,13 +381,13 @@ void driver_detach(struct device_driver *drv)
 		spin_unlock(&drv->p->klist_devices.k_lock);
 
 		if (dev->parent)	/* Needed for USB */
-			down(&dev->parent->sem);
-		down(&dev->sem);
+			device_lock(dev->parent);
+		device_lock(dev);
 		if (dev->driver == drv)
 			__device_release_driver(dev);
-		up(&dev->sem);
+		device_unlock(dev);
 		if (dev->parent)
-			up(&dev->parent->sem);
+			device_unlock(dev->parent);
 		put_device(dev);
 	}
 }

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 979d159b5cd1..ee95c76bfd3d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -188,7 +188,7 @@ EXPORT_SYMBOL_GPL(wait_for_device_probe);
  * @dev: device to try to bind to the driver
  *
  * This function returns -ENODEV if the device is not registered,
- * 1 if the device is bound sucessfully and 0 otherwise.
+ * 1 if the device is bound successfully and 0 otherwise.
  *
  * This function must be called with @dev->sem held.  When called for a
  * USB interface, @dev->parent->sem must be held as well.

commit b4028437876866aba4747a655ede00f892089e14
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 11 14:16:57 2009 -0700

    Driver core: move dev_get/set_drvdata to drivers/base/dd.c
    
    No one should directly access the driver_data field, so remove the field
    and make it private.  We dynamically create the private field now if it
    is needed, to handle drivers that call get/set before they are
    registered with the driver core.
    
    Also update the copyright notices on these files while we are there.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 7b34b3a48f67..979d159b5cd1 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -11,8 +11,8 @@
  *
  * Copyright (c) 2002-5 Patrick Mochel
  * Copyright (c) 2002-3 Open Source Development Labs
- * Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
- * Copyright (c) 2007 Novell Inc.
+ * Copyright (c) 2007-2009 Greg Kroah-Hartman <gregkh@suse.de>
+ * Copyright (c) 2007-2009 Novell Inc.
  *
  * This file is released under the GPLv2
  */
@@ -391,3 +391,30 @@ void driver_detach(struct device_driver *drv)
 		put_device(dev);
 	}
 }
+
+/*
+ * These exports can't be _GPL due to .h files using this within them, and it
+ * might break something that was previously working...
+ */
+void *dev_get_drvdata(const struct device *dev)
+{
+	if (dev && dev->p)
+		return dev->p->driver_data;
+	return NULL;
+}
+EXPORT_SYMBOL(dev_get_drvdata);
+
+void dev_set_drvdata(struct device *dev, void *data)
+{
+	int error;
+
+	if (!dev)
+		return;
+	if (!dev->p) {
+		error = device_private_init(dev);
+		if (error)
+			return;
+	}
+	dev->p->driver_data = data;
+}
+EXPORT_SYMBOL(dev_set_drvdata);

commit 5e928f77a09a07f9dd595bb8a489965d69a83458
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Aug 18 23:38:32 2009 +0200

    PM: Introduce core framework for run-time PM of I/O devices (rev. 17)
    
    Introduce a core framework for run-time power management of I/O
    devices.  Add device run-time PM fields to 'struct dev_pm_info'
    and device run-time PM callbacks to 'struct dev_pm_ops'.  Introduce
    a run-time PM workqueue and define some device run-time PM helper
    functions at the core level.  Document all these things.
    
    Special thanks to Alan Stern for his help with the design and
    multiple detailed reviews of the pereceding versions of this patch
    and to Magnus Damm for testing feedback.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Magnus Damm <damm@igel.co.jp>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index f0106875f01d..7b34b3a48f67 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -23,6 +23,7 @@
 #include <linux/kthread.h>
 #include <linux/wait.h>
 #include <linux/async.h>
+#include <linux/pm_runtime.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -202,7 +203,10 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
+	pm_runtime_get_noresume(dev);
+	pm_runtime_barrier(dev);
 	ret = really_probe(dev, drv);
+	pm_runtime_put_sync(dev);
 
 	return ret;
 }
@@ -245,7 +249,9 @@ int device_attach(struct device *dev)
 			ret = 0;
 		}
 	} else {
+		pm_runtime_get_noresume(dev);
 		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
+		pm_runtime_put_sync(dev);
 	}
 	up(&dev->sem);
 	return ret;
@@ -306,6 +312,9 @@ static void __device_release_driver(struct device *dev)
 
 	drv = dev->driver;
 	if (drv) {
+		pm_runtime_get_noresume(dev);
+		pm_runtime_barrier(dev);
+
 		driver_sysfs_remove(dev);
 
 		if (dev->bus)
@@ -324,6 +333,8 @@ static void __device_release_driver(struct device *dev)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 						     BUS_NOTIFY_UNBOUND_DRIVER,
 						     dev);
+
+		pm_runtime_put_sync(dev);
 	}
 }
 

commit 59a3cd7f9da60ac4ba8ae5a4cddc48fe4a450129
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue May 5 20:38:28 2009 -0700

    Driver core: fix comment for device_attach()
    
    We are looking for matching drivers, not devices.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index efd00de183b1..f0106875f01d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -226,7 +226,7 @@ static int __device_attach(struct device_driver *drv, void *data)
  * pair is found, break out and return.
  *
  * Returns 1 if the device was bound to a driver;
- * 0 if no matching device was found;
+ * 0 if no matching driver was found;
  * -ENODEV if the device is not registered.
  *
  * When called for a USB interface, @dev->parent->sem must be held.

commit 309b7d60a345f402bec3cf9caadb53de4028e2aa
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Apr 24 14:57:00 2009 +0200

    driver core: add BUS_NOTIFY_UNBOUND_DRIVER event
    
    This patch adds a new bus notifier event which is emitted _after_ a
    device is removed from its driver. This event will be used by the
    dma-api debug code to check if a driver has released all dma allocations
    for that device.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 742cbe6b042b..efd00de183b1 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -320,6 +320,10 @@ static void __device_release_driver(struct device *dev)
 		devres_release_all(dev);
 		dev->driver = NULL;
 		klist_remove(&dev->p->knode_driver);
+		if (dev->bus)
+			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
+						     BUS_NOTIFY_UNBOUND_DRIVER,
+						     dev);
 	}
 }
 

commit d4d5291c8cd499b1b590336059d5cc3e24c1ced6
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Tue Apr 21 13:32:54 2009 -0700

    driver synchronization: make scsi_wait_scan more advanced
    
    There is currently only one way for userspace to say "wait for my storage
    device to get ready for the modules I just loaded": to load the
    scsi_wait_scan module. Expectations of userspace are that once this
    module is loaded, all the (storage) devices for which the drivers
    were loaded before the module load are present.
    
    Now, there are some issues with the implementation, and the async
    stuff got caught in the middle of this: The existing code only
    waits for the scsy async probing to finish, but it did not take
    into account at all that probing might not have begun yet.
    (Russell ran into this problem on his computer and the fix works for him)
    
    This patch fixes this more thoroughly than the previous "fix", which
    had some bad side effects (namely, for kernel code that wanted to wait for
    the scsi scan it would also do an async sync, which would deadlock if you did
    it from async context already.. there's a report about that on lkml):
    The patch makes the module first wait for all device driver probes, and then it
    will wait for the scsi parallel scan to finish.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index f17c3266a0e0..742cbe6b042b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -179,6 +179,7 @@ void wait_for_device_probe(void)
 	wait_event(probe_waitqueue, atomic_read(&probe_count) == 0);
 	async_synchronize_full();
 }
+EXPORT_SYMBOL_GPL(wait_for_device_probe);
 
 /**
  * driver_probe_device - attempt to bind device & driver together

commit 8940b4f312dced51b45004819b776ec3aa7fcd5d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:25:49 2008 -0800

    driver core: move knode_driver into private structure
    
    Nothing outside of the driver core should ever touch knode_driver, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 0dfd08c15921..f17c3266a0e0 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -30,7 +30,7 @@
 
 static void driver_bound(struct device *dev)
 {
-	if (klist_node_attached(&dev->knode_driver)) {
+	if (klist_node_attached(&dev->p->knode_driver)) {
 		printk(KERN_WARNING "%s: device %s already bound\n",
 			__func__, kobject_name(&dev->kobj));
 		return;
@@ -43,7 +43,7 @@ static void driver_bound(struct device *dev)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
 
-	klist_add_tail(&dev->knode_driver, &dev->driver->p->klist_devices);
+	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
 }
 
 static int driver_sysfs_add(struct device *dev)
@@ -318,7 +318,7 @@ static void __device_release_driver(struct device *dev)
 			drv->remove(dev);
 		devres_release_all(dev);
 		dev->driver = NULL;
-		klist_remove(&dev->knode_driver);
+		klist_remove(&dev->p->knode_driver);
 	}
 }
 
@@ -348,6 +348,7 @@ EXPORT_SYMBOL_GPL(device_release_driver);
  */
 void driver_detach(struct device_driver *drv)
 {
+	struct device_private *dev_prv;
 	struct device *dev;
 
 	for (;;) {
@@ -356,8 +357,10 @@ void driver_detach(struct device_driver *drv)
 			spin_unlock(&drv->p->klist_devices.k_lock);
 			break;
 		}
-		dev = list_entry(drv->p->klist_devices.k_list.prev,
-				struct device, knode_driver.n_node);
+		dev_prv = list_entry(drv->p->klist_devices.k_list.prev,
+				     struct device_private,
+				     knode_driver.n_node);
+		dev = dev_prv->device;
 		get_device(dev);
 		spin_unlock(&drv->p->klist_devices.k_lock);
 

commit b23530ebc339c4092ae2c9f37341a5398fea8b89
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sat Feb 21 16:45:07 2009 +0800

    driver core: remove polling for driver_probe_done(v5)
    
    This patch removes 100ms polling for driver_probe_done in
    wait_for_device_probe(), and uses wait_event() instead.
    Removing polling in fs initialization may lead to
    a faster boot.
    
    This patch also changes the return type of wait_for_device_done()
    from int to void.
    
    This patch is against Arjan's patch in linux-next tree.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Reviewed-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3f32df7ed373..0dfd08c15921 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -172,16 +172,12 @@ int driver_probe_done(void)
 /**
  * wait_for_device_probe
  * Wait for device probing to be completed.
- *
- * Note: this function polls at 100 msec intervals.
  */
-int wait_for_device_probe(void)
+void wait_for_device_probe(void)
 {
 	/* wait for the known devices to complete their probing */
-	while (driver_probe_done() != 0)
-		msleep(100);
+	wait_event(probe_waitqueue, atomic_read(&probe_count) == 0);
 	async_synchronize_full();
-	return 0;
 }
 
 /**

commit 49b420a13ff95b449947181190b08367348e3e1b
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed Jan 21 23:27:47 2009 +0800

    driver core: check bus->match without holding device lock
    
    This patch moves bus->match out from driver_probe_device and
    does not hold device lock to check the match between a device
    and a driver.
    
    The idea has been verified by the commit 6cd495860901,
    which leads to a faster boot. But the commit 6cd495860901 has
    the following drawbacks: 1),only does the quick check in
    the path of __driver_attach->driver_probe_device, not in other
    paths; 2),for a matched device and driver, check the same match
    twice. It is a waste of cpu ,especially for some drivers with long
    device id table (eg. usb-storage driver).
    
    This patch adds a helper of driver_match_device to check the match
    in all paths, and testes the match only once.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 135231239103..3f32df7ed373 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -189,14 +189,8 @@ int wait_for_device_probe(void)
  * @drv: driver to bind a device to
  * @dev: device to try to bind to the driver
  *
- * First, we call the bus's match function, if one present, which should
- * compare the device IDs the driver supports with the device IDs of the
- * device. Note we don't do this ourselves because we don't know the
- * format of the ID structures, nor what is to be considered a match and
- * what is not.
- *
- * This function returns 1 if a match is found, -ENODEV if the device is
- * not registered, and 0 otherwise.
+ * This function returns -ENODEV if the device is not registered,
+ * 1 if the device is bound sucessfully and 0 otherwise.
  *
  * This function must be called with @dev->sem held.  When called for a
  * USB interface, @dev->parent->sem must be held as well.
@@ -207,21 +201,22 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 
 	if (!device_is_registered(dev))
 		return -ENODEV;
-	if (drv->bus->match && !drv->bus->match(dev, drv))
-		goto done;
 
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
 		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
 	ret = really_probe(dev, drv);
 
-done:
 	return ret;
 }
 
 static int __device_attach(struct device_driver *drv, void *data)
 {
 	struct device *dev = data;
+
+	if (!driver_match_device(drv, dev))
+		return 0;
+
 	return driver_probe_device(drv, dev);
 }
 
@@ -274,7 +269,7 @@ static int __driver_attach(struct device *dev, void *data)
 	 * is an error.
 	 */
 
-	if (drv->bus->match && !drv->bus->match(dev, drv))
+	if (!driver_match_device(drv, dev))
 		return 0;
 
 	if (dev->parent)	/* Needed for USB */

commit 216773a787c3c46ef26bf1742c1fdba37d26be45
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sat Feb 14 01:59:06 2009 +0100

    Consolidate driver_probe_done() loops into one place
    
    there's a few places that currently loop over driver_probe_done(), and
    I'm about to add another one. This patch abstracts it into a helper
    to reduce duplication.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Greg KH <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 315bed8d5e7f..135231239103 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -18,9 +18,11 @@
  */
 
 #include <linux/device.h>
+#include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/kthread.h>
 #include <linux/wait.h>
+#include <linux/async.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -167,6 +169,21 @@ int driver_probe_done(void)
 	return 0;
 }
 
+/**
+ * wait_for_device_probe
+ * Wait for device probing to be completed.
+ *
+ * Note: this function polls at 100 msec intervals.
+ */
+int wait_for_device_probe(void)
+{
+	/* wait for the known devices to complete their probing */
+	while (driver_probe_done() != 0)
+		msleep(100);
+	async_synchronize_full();
+	return 0;
+}
+
 /**
  * driver_probe_device - attempt to bind device & driver together
  * @drv: driver to bind a device to

commit cda5e83fdea476dce9c0a9b1152cd6ca46832cc4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 14:44:18 2009 -0800

    Revert "driver core: move knode_driver into private structure"
    
    This reverts commit 93e746db183b3bdbbda67900f79b5835f9cb388f.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 6fdaf76f033f..315bed8d5e7f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -28,7 +28,7 @@
 
 static void driver_bound(struct device *dev)
 {
-	if (klist_node_attached(&dev->p->knode_driver)) {
+	if (klist_node_attached(&dev->knode_driver)) {
 		printk(KERN_WARNING "%s: device %s already bound\n",
 			__func__, kobject_name(&dev->kobj));
 		return;
@@ -41,7 +41,7 @@ static void driver_bound(struct device *dev)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
 
-	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
+	klist_add_tail(&dev->knode_driver, &dev->driver->p->klist_devices);
 }
 
 static int driver_sysfs_add(struct device *dev)
@@ -310,7 +310,7 @@ static void __device_release_driver(struct device *dev)
 			drv->remove(dev);
 		devres_release_all(dev);
 		dev->driver = NULL;
-		klist_remove(&dev->p->knode_driver);
+		klist_remove(&dev->knode_driver);
 	}
 }
 
@@ -340,7 +340,6 @@ EXPORT_SYMBOL_GPL(device_release_driver);
  */
 void driver_detach(struct device_driver *drv)
 {
-	struct device_private *dev_prv;
 	struct device *dev;
 
 	for (;;) {
@@ -349,10 +348,8 @@ void driver_detach(struct device_driver *drv)
 			spin_unlock(&drv->p->klist_devices.k_lock);
 			break;
 		}
-		dev_prv = list_entry(drv->p->klist_devices.k_list.prev,
-				     struct device_private,
-				     knode_driver.n_node);
-		dev = dev_prv->device;
+		dev = list_entry(drv->p->klist_devices.k_list.prev,
+				struct device, knode_driver.n_node);
 		get_device(dev);
 		spin_unlock(&drv->p->klist_devices.k_lock);
 

commit 7232800ba8aca1c070d43a81cc49991f230b5da1
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed Dec 17 23:15:35 2008 +0800

    driver core:fix duplicate removing driver link in __device_release_driver
    
    In __device_release_driver(),driver_sysfs_remove() has removed the
    driver link under device dir in sysfs, but sysfs_remove_link() is
    called again to do such thing. Remove the duplicate call to
    sys_remove_link().
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index bb5f1eb83c03..6fdaf76f033f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -298,7 +298,6 @@ static void __device_release_driver(struct device *dev)
 	drv = dev->driver;
 	if (drv) {
 		driver_sysfs_remove(dev);
-		sysfs_remove_link(&dev->kobj, "driver");
 
 		if (dev->bus)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,

commit 93e746db183b3bdbbda67900f79b5835f9cb388f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:25:49 2008 -0800

    driver core: move knode_driver into private structure
    
    Nothing outside of the driver core should ever touch knode_driver, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 17a8e45cf9c6..bb5f1eb83c03 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -28,7 +28,7 @@
 
 static void driver_bound(struct device *dev)
 {
-	if (klist_node_attached(&dev->knode_driver)) {
+	if (klist_node_attached(&dev->p->knode_driver)) {
 		printk(KERN_WARNING "%s: device %s already bound\n",
 			__func__, kobject_name(&dev->kobj));
 		return;
@@ -41,7 +41,7 @@ static void driver_bound(struct device *dev)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
 
-	klist_add_tail(&dev->knode_driver, &dev->driver->p->klist_devices);
+	klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
 }
 
 static int driver_sysfs_add(struct device *dev)
@@ -311,7 +311,7 @@ static void __device_release_driver(struct device *dev)
 			drv->remove(dev);
 		devres_release_all(dev);
 		dev->driver = NULL;
-		klist_remove(&dev->knode_driver);
+		klist_remove(&dev->p->knode_driver);
 	}
 }
 
@@ -341,6 +341,7 @@ EXPORT_SYMBOL_GPL(device_release_driver);
  */
 void driver_detach(struct device_driver *drv)
 {
+	struct device_private *dev_prv;
 	struct device *dev;
 
 	for (;;) {
@@ -349,8 +350,10 @@ void driver_detach(struct device_driver *drv)
 			spin_unlock(&drv->p->klist_devices.k_lock);
 			break;
 		}
-		dev = list_entry(drv->p->klist_devices.k_list.prev,
-				struct device, knode_driver.n_node);
+		dev_prv = list_entry(drv->p->klist_devices.k_list.prev,
+				     struct device_private,
+				     knode_driver.n_node);
+		dev = dev_prv->device;
 		get_device(dev);
 		spin_unlock(&drv->p->klist_devices.k_lock);
 

commit 1e0b2cf933ebf32494eba3f668859ba57f06a951
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:36:48 2008 +0100

    driver core: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 20febc00a525..17a8e45cf9c6 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -34,7 +34,7 @@ static void driver_bound(struct device *dev)
 		return;
 	}
 
-	pr_debug("driver: '%s': %s: bound to device '%s'\n", dev->bus_id,
+	pr_debug("driver: '%s': %s: bound to device '%s'\n", dev_name(dev),
 		 __func__, dev->driver->name);
 
 	if (dev->bus)
@@ -104,13 +104,13 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
-		 drv->bus->name, __func__, drv->name, dev->bus_id);
+		 drv->bus->name, __func__, drv->name, dev_name(dev));
 	WARN_ON(!list_empty(&dev->devres_head));
 
 	dev->driver = drv;
 	if (driver_sysfs_add(dev)) {
 		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
-			__func__, dev->bus_id);
+			__func__, dev_name(dev));
 		goto probe_failed;
 	}
 
@@ -127,7 +127,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	driver_bound(dev);
 	ret = 1;
 	pr_debug("bus: '%s': %s: bound device %s to driver %s\n",
-		 drv->bus->name, __func__, dev->bus_id, drv->name);
+		 drv->bus->name, __func__, dev_name(dev), drv->name);
 	goto done;
 
 probe_failed:
@@ -139,7 +139,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 		/* driver matched but the probe failed */
 		printk(KERN_WARNING
 		       "%s: probe of %s failed with error %d\n",
-		       drv->name, dev->bus_id, ret);
+		       drv->name, dev_name(dev), ret);
 	}
 	/*
 	 * Ignore errors returned by ->probe so that the next driver can try
@@ -194,7 +194,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 		goto done;
 
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
-		 drv->bus->name, __func__, dev->bus_id, drv->name);
+		 drv->bus->name, __func__, dev_name(dev), drv->name);
 
 	ret = really_probe(dev, drv);
 

commit 6cd49586090187a2a145bb6570fb2392f121aa22
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sun Sep 14 08:32:06 2008 -0700

    device model: Do a quickcheck for driver binding before doing an expensive check
    
    This patch adds a quick check for the driver<->device match before
    taking the locks and doin gthe expensive checks. Taking the lock hurts
    in asynchronous boot context where the device lock gets hit; one of the
    init functions takes the lock and goes to do an expensive hardware init;
    the other init functions walk the same PCI list and get stuck on the
    lock as a result.
    
    For the common case, we can know there's no chance whatsoever of a match
    if the device isn't in the drivers ID table... so this patch does that
    check as a best-effort-avoid-the-lock approach.
    
    Bootcharts for before and after can be seen at
    http://www.fenrus.org/before.svg
    http://www.fenrus.org/after.svg
    
    Note the long time "agp_ali_init" takes in the first graph; my laptop
    doesn't even have an ALI chip in it!  (the bootgraphs look a bit
    dissimilar, but that's the point, the first one has a bunch of arbitrary
    delays in it that cause it to look very different)
    
    This reduces my kernel boot time by about 20%
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3ac443b2ac08..20febc00a525 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -257,6 +257,9 @@ static int __driver_attach(struct device *dev, void *data)
 	 * is an error.
 	 */
 
+	if (drv->bus->match && !drv->bus->match(dev, drv))
+		return 0;
+
 	if (dev->parent)	/* Needed for USB */
 		down(&dev->parent->sem);
 	down(&dev->sem);

commit 2b3a302a09735276e13421db56c20045a48eb06d
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Tue Mar 4 16:41:05 2008 -0800

    driver core: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a5cde94bb982..3ac443b2ac08 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -30,12 +30,12 @@ static void driver_bound(struct device *dev)
 {
 	if (klist_node_attached(&dev->knode_driver)) {
 		printk(KERN_WARNING "%s: device %s already bound\n",
-			__FUNCTION__, kobject_name(&dev->kobj));
+			__func__, kobject_name(&dev->kobj));
 		return;
 	}
 
 	pr_debug("driver: '%s': %s: bound to device '%s'\n", dev->bus_id,
-		 __FUNCTION__, dev->driver->name);
+		 __func__, dev->driver->name);
 
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
@@ -104,13 +104,13 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
-		 drv->bus->name, __FUNCTION__, drv->name, dev->bus_id);
+		 drv->bus->name, __func__, drv->name, dev->bus_id);
 	WARN_ON(!list_empty(&dev->devres_head));
 
 	dev->driver = drv;
 	if (driver_sysfs_add(dev)) {
 		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
-			__FUNCTION__, dev->bus_id);
+			__func__, dev->bus_id);
 		goto probe_failed;
 	}
 
@@ -127,7 +127,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	driver_bound(dev);
 	ret = 1;
 	pr_debug("bus: '%s': %s: bound device %s to driver %s\n",
-		 drv->bus->name, __FUNCTION__, dev->bus_id, drv->name);
+		 drv->bus->name, __func__, dev->bus_id, drv->name);
 	goto done;
 
 probe_failed:
@@ -160,7 +160,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
  */
 int driver_probe_done(void)
 {
-	pr_debug("%s: probe_count = %d\n", __FUNCTION__,
+	pr_debug("%s: probe_count = %d\n", __func__,
 		 atomic_read(&probe_count));
 	if (atomic_read(&probe_count))
 		return -EBUSY;
@@ -194,7 +194,7 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 		goto done;
 
 	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
-		 drv->bus->name, __FUNCTION__, dev->bus_id, drv->name);
+		 drv->bus->name, __func__, dev->bus_id, drv->name);
 
 	ret = really_probe(dev, drv);
 

commit 4a3ad20ccd8f4d2a0535cf98fa83f7b561ba59a9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 24 22:50:12 2008 -0800

    Driver core: coding style fixes
    
    Fix up a number of coding style issues in the drivers/base/ directory
    that have annoyed me over the years.  checkpatch.pl is now very happy.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index b0726eb6405e..a5cde94bb982 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -1,20 +1,20 @@
 /*
- *	drivers/base/dd.c - The core device/driver interactions.
+ * drivers/base/dd.c - The core device/driver interactions.
  *
- * 	This file contains the (sometimes tricky) code that controls the
- *	interactions between devices and drivers, which primarily includes
- *	driver binding and unbinding.
+ * This file contains the (sometimes tricky) code that controls the
+ * interactions between devices and drivers, which primarily includes
+ * driver binding and unbinding.
  *
- *	All of this code used to exist in drivers/base/bus.c, but was
- *	relocated to here in the name of compartmentalization (since it wasn't
- *	strictly code just for the 'struct bus_type'.
+ * All of this code used to exist in drivers/base/bus.c, but was
+ * relocated to here in the name of compartmentalization (since it wasn't
+ * strictly code just for the 'struct bus_type'.
  *
- *	Copyright (c) 2002-5 Patrick Mochel
- *	Copyright (c) 2002-3 Open Source Development Labs
- *	Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
- *	Copyright (c) 2007 Novell Inc.
+ * Copyright (c) 2002-5 Patrick Mochel
+ * Copyright (c) 2002-3 Open Source Development Labs
+ * Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
+ * Copyright (c) 2007 Novell Inc.
  *
- *	This file is released under the GPLv2
+ * This file is released under the GPLv2
  */
 
 #include <linux/device.h>
@@ -71,18 +71,18 @@ static void driver_sysfs_remove(struct device *dev)
 }
 
 /**
- *	device_bind_driver - bind a driver to one device.
- *	@dev:	device.
+ * device_bind_driver - bind a driver to one device.
+ * @dev: device.
  *
- *	Allow manual attachment of a driver to a device.
- *	Caller must have already set @dev->driver.
+ * Allow manual attachment of a driver to a device.
+ * Caller must have already set @dev->driver.
  *
- *	Note that this does not modify the bus reference count
- *	nor take the bus's rwsem. Please verify those are accounted
- *	for before calling this. (It is ok to call with no other effort
- *	from a driver's probe() method.)
+ * Note that this does not modify the bus reference count
+ * nor take the bus's rwsem. Please verify those are accounted
+ * for before calling this. (It is ok to call with no other effort
+ * from a driver's probe() method.)
  *
- *	This function must be called with @dev->sem held.
+ * This function must be called with @dev->sem held.
  */
 int device_bind_driver(struct device *dev)
 {
@@ -93,6 +93,7 @@ int device_bind_driver(struct device *dev)
 		driver_bound(dev);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(device_bind_driver);
 
 static atomic_t probe_count = ATOMIC_INIT(0);
 static DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);
@@ -183,7 +184,7 @@ int driver_probe_done(void)
  * This function must be called with @dev->sem held.  When called for a
  * USB interface, @dev->parent->sem must be held as well.
  */
-int driver_probe_device(struct device_driver * drv, struct device * dev)
+int driver_probe_device(struct device_driver *drv, struct device *dev)
 {
 	int ret = 0;
 
@@ -201,27 +202,27 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	return ret;
 }
 
-static int __device_attach(struct device_driver * drv, void * data)
+static int __device_attach(struct device_driver *drv, void *data)
 {
-	struct device * dev = data;
+	struct device *dev = data;
 	return driver_probe_device(drv, dev);
 }
 
 /**
- *	device_attach - try to attach device to a driver.
- *	@dev:	device.
+ * device_attach - try to attach device to a driver.
+ * @dev: device.
  *
- *	Walk the list of drivers that the bus has and call
- *	driver_probe_device() for each pair. If a compatible
- *	pair is found, break out and return.
+ * Walk the list of drivers that the bus has and call
+ * driver_probe_device() for each pair. If a compatible
+ * pair is found, break out and return.
  *
- *	Returns 1 if the device was bound to a driver;
- *	0 if no matching device was found;
- *	-ENODEV if the device is not registered.
+ * Returns 1 if the device was bound to a driver;
+ * 0 if no matching device was found;
+ * -ENODEV if the device is not registered.
  *
- *	When called for a USB interface, @dev->parent->sem must be held.
+ * When called for a USB interface, @dev->parent->sem must be held.
  */
-int device_attach(struct device * dev)
+int device_attach(struct device *dev)
 {
 	int ret = 0;
 
@@ -240,10 +241,11 @@ int device_attach(struct device * dev)
 	up(&dev->sem);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(device_attach);
 
-static int __driver_attach(struct device * dev, void * data)
+static int __driver_attach(struct device *dev, void *data)
 {
-	struct device_driver * drv = data;
+	struct device_driver *drv = data;
 
 	/*
 	 * Lock device and try to bind to it. We drop the error
@@ -268,26 +270,27 @@ static int __driver_attach(struct device * dev, void * data)
 }
 
 /**
- *	driver_attach - try to bind driver to devices.
- *	@drv:	driver.
+ * driver_attach - try to bind driver to devices.
+ * @drv: driver.
  *
- *	Walk the list of devices that the bus has on it and try to
- *	match the driver with each one.  If driver_probe_device()
- *	returns 0 and the @dev->driver is set, we've found a
- *	compatible pair.
+ * Walk the list of devices that the bus has on it and try to
+ * match the driver with each one.  If driver_probe_device()
+ * returns 0 and the @dev->driver is set, we've found a
+ * compatible pair.
  */
-int driver_attach(struct device_driver * drv)
+int driver_attach(struct device_driver *drv)
 {
 	return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
 }
+EXPORT_SYMBOL_GPL(driver_attach);
 
 /*
- *	__device_release_driver() must be called with @dev->sem held.
- *	When called for a USB interface, @dev->parent->sem must be held as well.
+ * __device_release_driver() must be called with @dev->sem held.
+ * When called for a USB interface, @dev->parent->sem must be held as well.
  */
-static void __device_release_driver(struct device * dev)
+static void __device_release_driver(struct device *dev)
 {
-	struct device_driver * drv;
+	struct device_driver *drv;
 
 	drv = dev->driver;
 	if (drv) {
@@ -310,13 +313,13 @@ static void __device_release_driver(struct device * dev)
 }
 
 /**
- *	device_release_driver - manually detach device from driver.
- *	@dev:	device.
+ * device_release_driver - manually detach device from driver.
+ * @dev: device.
  *
- *	Manually detach device from driver.
- *	When called for a USB interface, @dev->parent->sem must be held.
+ * Manually detach device from driver.
+ * When called for a USB interface, @dev->parent->sem must be held.
  */
-void device_release_driver(struct device * dev)
+void device_release_driver(struct device *dev)
 {
 	/*
 	 * If anyone calls device_release_driver() recursively from
@@ -327,15 +330,15 @@ void device_release_driver(struct device * dev)
 	__device_release_driver(dev);
 	up(&dev->sem);
 }
-
+EXPORT_SYMBOL_GPL(device_release_driver);
 
 /**
  * driver_detach - detach driver from all devices it controls.
  * @drv: driver.
  */
-void driver_detach(struct device_driver * drv)
+void driver_detach(struct device_driver *drv)
 {
-	struct device * dev;
+	struct device *dev;
 
 	for (;;) {
 		spin_lock(&drv->p->klist_devices.k_lock);
@@ -359,9 +362,3 @@ void driver_detach(struct device_driver * drv)
 		put_device(dev);
 	}
 }
-
-EXPORT_SYMBOL_GPL(device_bind_driver);
-EXPORT_SYMBOL_GPL(device_release_driver);
-EXPORT_SYMBOL_GPL(device_attach);
-EXPORT_SYMBOL_GPL(driver_attach);
-

commit ef2c51746dc89c2326ce522f8fb8a57695780e75
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Nov 16 11:57:28 2007 -0500

    Driver core: fix race in __device_release_driver
    
    This patch (as1013) was suggested by David Woodhouse; it fixes a race
    in the driver core.  If a device is unregistered at the same time as
    its driver is unloaded, the driver's code pages may be unmapped while
    the remove method is still running.  The calls to get_driver() and
    put_driver() were intended to prevent this, but they don't work if the
    driver's module count has already dropped to 0.
    
    Instead, the patch keeps the device on the driver's list until after
    the remove method has returned.  This forces the necessary
    synchronization to occur.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 54922647522d..b0726eb6405e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -289,11 +289,10 @@ static void __device_release_driver(struct device * dev)
 {
 	struct device_driver * drv;
 
-	drv = get_driver(dev->driver);
+	drv = dev->driver;
 	if (drv) {
 		driver_sysfs_remove(dev);
 		sysfs_remove_link(&dev->kobj, "driver");
-		klist_remove(&dev->knode_driver);
 
 		if (dev->bus)
 			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
@@ -306,7 +305,7 @@ static void __device_release_driver(struct device * dev)
 			drv->remove(dev);
 		devres_release_all(dev);
 		dev->driver = NULL;
-		put_driver(drv);
+		klist_remove(&dev->knode_driver);
 	}
 }
 

commit 7dc72b2842381684b864750af31a5fb168dec764
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 23:49:41 2007 -0800

    Driver core: clean up debugging messages
    
    The driver core debugging messages are a mess.  This provides a unified
    message that makes them actually useful.
    
    The format for new kobject debug messages should be:
            driver/bus/class: 'OBJECT_NAME': FUNCTION_NAME: message.\n
    
    Note, the class code is not changed in this patch due to pending patches
    in my queue that this would conflict with.  A later patch will clean
    them up.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 87a348ce818c..54922647522d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -34,8 +34,8 @@ static void driver_bound(struct device *dev)
 		return;
 	}
 
-	pr_debug("bound device '%s' to driver '%s'\n",
-		 dev->bus_id, dev->driver->name);
+	pr_debug("driver: '%s': %s: bound to device '%s'\n", dev->bus_id,
+		 __FUNCTION__, dev->driver->name);
 
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
@@ -102,8 +102,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	int ret = 0;
 
 	atomic_inc(&probe_count);
-	pr_debug("%s: Probing driver %s with device %s\n",
-		 drv->bus->name, drv->name, dev->bus_id);
+	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
+		 drv->bus->name, __FUNCTION__, drv->name, dev->bus_id);
 	WARN_ON(!list_empty(&dev->devres_head));
 
 	dev->driver = drv;
@@ -125,8 +125,8 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 
 	driver_bound(dev);
 	ret = 1;
-	pr_debug("%s: Bound Device %s to Driver %s\n",
-		 drv->bus->name, dev->bus_id, drv->name);
+	pr_debug("bus: '%s': %s: bound device %s to driver %s\n",
+		 drv->bus->name, __FUNCTION__, dev->bus_id, drv->name);
 	goto done;
 
 probe_failed:
@@ -192,8 +192,8 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	if (drv->bus->match && !drv->bus->match(dev, drv))
 		goto done;
 
-	pr_debug("%s: Matched Device %s with Driver %s\n",
-		 drv->bus->name, dev->bus_id, drv->name);
+	pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
+		 drv->bus->name, __FUNCTION__, dev->bus_id, drv->name);
 
 	ret = really_probe(dev, drv);
 

commit e5dd12784617f0f1fae5f96a7fac1ec4c49fadbe
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 15:59:15 2007 -0800

    Driver core: move the static kobject out of struct driver
    
    This patch removes the kobject, and a few other driver-core-only fields
    out of struct driver and into the driver core only.  Now drivers can be
    safely create on the stack or statically (like they currently are.)
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 7bf0e674c975..87a348ce818c 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -11,6 +11,8 @@
  *
  *	Copyright (c) 2002-5 Patrick Mochel
  *	Copyright (c) 2002-3 Open Source Development Labs
+ *	Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
+ *	Copyright (c) 2007 Novell Inc.
  *
  *	This file is released under the GPLv2
  */
@@ -23,8 +25,6 @@
 #include "base.h"
 #include "power/power.h"
 
-#define to_drv(node) container_of(node, struct device_driver, kobj.entry)
-
 
 static void driver_bound(struct device *dev)
 {
@@ -41,20 +41,20 @@ static void driver_bound(struct device *dev)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
 
-	klist_add_tail(&dev->knode_driver, &dev->driver->klist_devices);
+	klist_add_tail(&dev->knode_driver, &dev->driver->p->klist_devices);
 }
 
 static int driver_sysfs_add(struct device *dev)
 {
 	int ret;
 
-	ret = sysfs_create_link(&dev->driver->kobj, &dev->kobj,
+	ret = sysfs_create_link(&dev->driver->p->kobj, &dev->kobj,
 			  kobject_name(&dev->kobj));
 	if (ret == 0) {
-		ret = sysfs_create_link(&dev->kobj, &dev->driver->kobj,
+		ret = sysfs_create_link(&dev->kobj, &dev->driver->p->kobj,
 					"driver");
 		if (ret)
-			sysfs_remove_link(&dev->driver->kobj,
+			sysfs_remove_link(&dev->driver->p->kobj,
 					kobject_name(&dev->kobj));
 	}
 	return ret;
@@ -65,7 +65,7 @@ static void driver_sysfs_remove(struct device *dev)
 	struct device_driver *drv = dev->driver;
 
 	if (drv) {
-		sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
+		sysfs_remove_link(&drv->p->kobj, kobject_name(&dev->kobj));
 		sysfs_remove_link(&dev->kobj, "driver");
 	}
 }
@@ -339,15 +339,15 @@ void driver_detach(struct device_driver * drv)
 	struct device * dev;
 
 	for (;;) {
-		spin_lock(&drv->klist_devices.k_lock);
-		if (list_empty(&drv->klist_devices.k_list)) {
-			spin_unlock(&drv->klist_devices.k_lock);
+		spin_lock(&drv->p->klist_devices.k_lock);
+		if (list_empty(&drv->p->klist_devices.k_list)) {
+			spin_unlock(&drv->p->klist_devices.k_lock);
 			break;
 		}
-		dev = list_entry(drv->klist_devices.k_list.prev,
+		dev = list_entry(drv->p->klist_devices.k_list.prev,
 				struct device, knode_driver.n_node);
 		get_device(dev);
-		spin_unlock(&drv->klist_devices.k_lock);
+		spin_unlock(&drv->p->klist_devices.k_lock);
 
 		if (dev->parent)	/* Needed for USB */
 			down(&dev->parent->sem);

commit c6f7e72a3f4641095ade9ded287d910c980c6148
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 19:41:16 2007 -0700

    driver core: remove fields from struct bus_type
    
    struct bus_type is static everywhere in the kernel.  This moves the
    kobject in the structure out of it, and a bunch of other private only to
    the driver core fields are now moved to a private structure.  This lets
    us dynamically create the backing kobject properly and gives us the
    chance to be able to document to users exactly how to use the struct
    bus_type as there are no fields they can improperly access.
    
    Thanks to Kay for the build fixes on this patch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 7ac474db88c5..7bf0e674c975 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -38,7 +38,7 @@ static void driver_bound(struct device *dev)
 		 dev->bus_id, dev->driver->name);
 
 	if (dev->bus)
-		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
 
 	klist_add_tail(&dev->knode_driver, &dev->driver->klist_devices);
@@ -296,7 +296,7 @@ static void __device_release_driver(struct device * dev)
 		klist_remove(&dev->knode_driver);
 
 		if (dev->bus)
-			blocking_notifier_call_chain(&dev->bus->bus_notifier,
+			blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 						     BUS_NOTIFY_UNBIND_DRIVER,
 						     dev);
 

commit ab71c6f0767bcbc618f3db51f668d5b951c00b60
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 17 11:02:12 2007 +0200

    driver core: fix kernel doc of device_release_driver
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3c503e1f69a2..7ac474db88c5 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -281,17 +281,10 @@ int driver_attach(struct device_driver * drv)
 	return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
 }
 
-/**
- *	device_release_driver - manually detach device from driver.
- *	@dev:	device.
- *
- *	Manually detach device from driver.
- *
+/*
  *	__device_release_driver() must be called with @dev->sem held.
- *	When called for a USB interface, @dev->parent->sem must be held
- *	as well.
+ *	When called for a USB interface, @dev->parent->sem must be held as well.
  */
-
 static void __device_release_driver(struct device * dev)
 {
 	struct device_driver * drv;
@@ -317,6 +310,13 @@ static void __device_release_driver(struct device * dev)
 	}
 }
 
+/**
+ *	device_release_driver - manually detach device from driver.
+ *	@dev:	device.
+ *
+ *	Manually detach device from driver.
+ *	When called for a USB interface, @dev->parent->sem must be held.
+ */
 void device_release_driver(struct device * dev)
 {
 	/*

commit 1f5681aae8feadd113644c9e077152416c12b75c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 17 11:01:18 2007 +0200

    driver core: properly get driver in device_release_driver
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index b0088b0efecd..3c503e1f69a2 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -296,9 +296,8 @@ static void __device_release_driver(struct device * dev)
 {
 	struct device_driver * drv;
 
-	drv = dev->driver;
+	drv = get_driver(dev->driver);
 	if (drv) {
-		get_driver(drv);
 		driver_sysfs_remove(dev);
 		sysfs_remove_link(&dev->kobj, "driver");
 		klist_remove(&dev->knode_driver);

commit 475c5a1518477f0301fc50dc59e690032fad1fef
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Tue May 8 13:41:49 2007 -0700

    Driver core: kill unused code
    
      CC      drivers/base/dd.o
    drivers/base/dd.c:211: warning: =E2=80=98device_probe_drivers=E2=80=99 defi=
    ned but not used
    
    Looks like the following is dead.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 92428e55b0c2..b0088b0efecd 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -207,19 +207,6 @@ static int __device_attach(struct device_driver * drv, void * data)
 	return driver_probe_device(drv, dev);
 }
 
-static int device_probe_drivers(void *data)
-{
-	struct device *dev = data;
-	int ret = 0;
-
-	if (dev->bus) {
-		down(&dev->sem);
-		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
-		up(&dev->sem);
-	}
-	return ret;
-}
-
 /**
  *	device_attach - try to attach device to a driver.
  *	@dev:	device.

commit 5adc55da4a7758021bcc374904b0f8b076508a11
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Mar 27 03:02:51 2007 +0200

    PCI: remove the broken PCI_MULTITHREAD_PROBE option
    
    This patch removes the PCI_MULTITHREAD_PROBE option that had already
    been marked as broken.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 18dba8e78da7..92428e55b0c2 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -226,12 +226,10 @@ static int device_probe_drivers(void *data)
  *
  *	Walk the list of drivers that the bus has and call
  *	driver_probe_device() for each pair. If a compatible
- *	pair is found, break out and return. If the bus specifies
- *	multithreaded probing, walking the list of drivers is done
- *	on a probing thread.
+ *	pair is found, break out and return.
  *
  *	Returns 1 if the device was bound to a driver;
- *	0 if no matching device was found or multithreaded probing is done;
+ *	0 if no matching device was found;
  *	-ENODEV if the device is not registered.
  *
  *	When called for a USB interface, @dev->parent->sem must be held.
@@ -239,7 +237,6 @@ static int device_probe_drivers(void *data)
 int device_attach(struct device * dev)
 {
 	int ret = 0;
-	struct task_struct *probe_task = ERR_PTR(-ENOMEM);
 
 	down(&dev->sem);
 	if (dev->driver) {
@@ -251,12 +248,7 @@ int device_attach(struct device * dev)
 			ret = 0;
 		}
 	} else {
-		if (dev->bus->multithread_probe)
-			probe_task = kthread_run(device_probe_drivers, dev,
-						 "probe-%s", dev->bus_id);
-		if(IS_ERR(probe_task))
-			ret = bus_for_each_drv(dev->bus, NULL, dev,
-					       __device_attach);
+		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
 	}
 	up(&dev->sem);
 	return ret;
@@ -383,33 +375,6 @@ void driver_detach(struct device_driver * drv)
 	}
 }
 
-#ifdef CONFIG_PCI_MULTITHREAD_PROBE
-static int __init wait_for_probes(void)
-{
-	DEFINE_WAIT(wait);
-
-	printk(KERN_INFO "%s: waiting for %d threads\n", __FUNCTION__,
-			atomic_read(&probe_count));
-	if (!atomic_read(&probe_count))
-		return 0;
-	while (atomic_read(&probe_count)) {
-		prepare_to_wait(&probe_waitqueue, &wait, TASK_UNINTERRUPTIBLE);
-		if (atomic_read(&probe_count))
-			schedule();
-	}
-	finish_wait(&probe_waitqueue, &wait);
-	return 0;
-}
-
-core_initcall_sync(wait_for_probes);
-postcore_initcall_sync(wait_for_probes);
-arch_initcall_sync(wait_for_probes);
-subsys_initcall_sync(wait_for_probes);
-fs_initcall_sync(wait_for_probes);
-device_initcall_sync(wait_for_probes);
-late_initcall_sync(wait_for_probes);
-#endif
-
 EXPORT_SYMBOL_GPL(device_bind_driver);
 EXPORT_SYMBOL_GPL(device_release_driver);
 EXPORT_SYMBOL_GPL(device_attach);

commit c6a46696f97ff260a4ecce5e287f8de4b9d7fe14
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Feb 5 16:15:26 2007 -0800

    driver core: don't fail attaching the device if it cannot be bound
    
    Don't fail bus_attach_device() if the device cannot be bound.
    
    If dev->driver has been specified, reset it to NULL if device_bind_driver()
    failed and add the device as an unbound device.  As a result,
    bus_attach_device() now cannot fail, and we can remove some checking from
    device_add().
    
    Also remove an unneeded check in bus_rescan_devices_helper().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 616b4bbacf1b..18dba8e78da7 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -232,7 +232,7 @@ static int device_probe_drivers(void *data)
  *
  *	Returns 1 if the device was bound to a driver;
  *	0 if no matching device was found or multithreaded probing is done;
- *	error code otherwise.
+ *	-ENODEV if the device is not registered.
  *
  *	When called for a USB interface, @dev->parent->sem must be held.
  */
@@ -246,6 +246,10 @@ int device_attach(struct device * dev)
 		ret = device_bind_driver(dev);
 		if (ret == 0)
 			ret = 1;
+		else {
+			dev->driver = NULL;
+			ret = 0;
+		}
 	} else {
 		if (dev->bus->multithread_probe)
 			probe_task = kthread_run(device_probe_drivers, dev,

commit 21c7f30b1d3f8a3de3128478daca3ce203fc8733
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Feb 5 16:15:25 2007 -0800

    driver core: per-subsystem multithreaded probing
    
    Make multithreaded probing work per subsystem instead of per driver.
    
    It doesn't make much sense to probe the same device for multiple drivers in
    parallel (after all, only one driver can bind to the device).  Instead, create
    a probing thread for each device that probes the drivers one after another.
    Also make the decision to use multi-threaded probe per bus instead of per
    device and adapt the pci code.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 6a48824e43ff..616b4bbacf1b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -94,19 +94,11 @@ int device_bind_driver(struct device *dev)
 	return ret;
 }
 
-struct stupid_thread_structure {
-	struct device_driver *drv;
-	struct device *dev;
-};
-
 static atomic_t probe_count = ATOMIC_INIT(0);
 static DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);
 
-static int really_probe(void *void_data)
+static int really_probe(struct device *dev, struct device_driver *drv)
 {
-	struct stupid_thread_structure *data = void_data;
-	struct device_driver *drv = data->drv;
-	struct device *dev = data->dev;
 	int ret = 0;
 
 	atomic_inc(&probe_count);
@@ -154,7 +146,6 @@ static int really_probe(void *void_data)
 	 */
 	ret = 0;
 done:
-	kfree(data);
 	atomic_dec(&probe_count);
 	wake_up(&probe_waitqueue);
 	return ret;
@@ -186,16 +177,14 @@ int driver_probe_done(void)
  * format of the ID structures, nor what is to be considered a match and
  * what is not.
  *
- * This function returns 1 if a match is found, an error if one occurs
- * (that is not -ENODEV or -ENXIO), and 0 otherwise.
+ * This function returns 1 if a match is found, -ENODEV if the device is
+ * not registered, and 0 otherwise.
  *
  * This function must be called with @dev->sem held.  When called for a
  * USB interface, @dev->parent->sem must be held as well.
  */
 int driver_probe_device(struct device_driver * drv, struct device * dev)
 {
-	struct stupid_thread_structure *data;
-	struct task_struct *probe_task;
 	int ret = 0;
 
 	if (!device_is_registered(dev))
@@ -206,19 +195,7 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	pr_debug("%s: Matched Device %s with Driver %s\n",
 		 drv->bus->name, dev->bus_id, drv->name);
 
-	data = kmalloc(sizeof(*data), GFP_KERNEL);
-	if (!data)
-		return -ENOMEM;
-	data->drv = drv;
-	data->dev = dev;
-
-	if (drv->multithread_probe) {
-		probe_task = kthread_run(really_probe, data,
-					 "probe-%s", dev->bus_id);
-		if (IS_ERR(probe_task))
-			ret = really_probe(data);
-	} else
-		ret = really_probe(data);
+	ret = really_probe(dev, drv);
 
 done:
 	return ret;
@@ -230,30 +207,53 @@ static int __device_attach(struct device_driver * drv, void * data)
 	return driver_probe_device(drv, dev);
 }
 
+static int device_probe_drivers(void *data)
+{
+	struct device *dev = data;
+	int ret = 0;
+
+	if (dev->bus) {
+		down(&dev->sem);
+		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
+		up(&dev->sem);
+	}
+	return ret;
+}
+
 /**
  *	device_attach - try to attach device to a driver.
  *	@dev:	device.
  *
  *	Walk the list of drivers that the bus has and call
  *	driver_probe_device() for each pair. If a compatible
- *	pair is found, break out and return.
+ *	pair is found, break out and return. If the bus specifies
+ *	multithreaded probing, walking the list of drivers is done
+ *	on a probing thread.
  *
  *	Returns 1 if the device was bound to a driver;
- *	0 if no matching device was found; error code otherwise.
+ *	0 if no matching device was found or multithreaded probing is done;
+ *	error code otherwise.
  *
  *	When called for a USB interface, @dev->parent->sem must be held.
  */
 int device_attach(struct device * dev)
 {
 	int ret = 0;
+	struct task_struct *probe_task = ERR_PTR(-ENOMEM);
 
 	down(&dev->sem);
 	if (dev->driver) {
 		ret = device_bind_driver(dev);
 		if (ret == 0)
 			ret = 1;
-	} else
-		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
+	} else {
+		if (dev->bus->multithread_probe)
+			probe_task = kthread_run(device_probe_drivers, dev,
+						 "probe-%s", dev->bus_id);
+		if(IS_ERR(probe_task))
+			ret = bus_for_each_drv(dev->bus, NULL, dev,
+					       __device_attach);
+	}
 	up(&dev->sem);
 	return ret;
 }

commit 9ac7849e35f705830f7b016ff272b0ff1f7ff759
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:26 2007 +0900

    devres: device resource management
    
    Implement device resource management, in short, devres.  A device
    driver can allocate arbirary size of devres data which is associated
    with a release function.  On driver detach, release function is
    invoked on the devres data, then, devres data is freed.
    
    devreses are typed by associated release functions.  Some devreses are
    better represented by single instance of the type while others need
    multiple instances sharing the same release function.  Both usages are
    supported.
    
    devreses can be grouped using devres group such that a device driver
    can easily release acquired resources halfway through initialization
    or selectively release resources (e.g. resources for port 1 out of 4
    ports).
    
    This patch adds devres core including documentation and the following
    managed interfaces.
    
    * alloc/free    : devm_kzalloc(), devm_kzfree()
    * IO region     : devm_request_region(), devm_release_region()
    * IRQ           : devm_request_irq(), devm_free_irq()
    * DMA           : dmam_alloc_coherent(), dmam_free_coherent(),
                      dmam_declare_coherent_memory(), dmam_pool_create(),
                      dmam_pool_destroy()
    * PCI           : pcim_enable_device(), pcim_pin_device(), pci_is_managed()
    * iomap         : devm_ioport_map(), devm_ioport_unmap(), devm_ioremap(),
                      devm_ioremap_nocache(), devm_iounmap(), pcim_iomap_table(),
                      pcim_iomap(), pcim_iounmap()
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index b5bf243d9cd6..6a48824e43ff 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -112,6 +112,7 @@ static int really_probe(void *void_data)
 	atomic_inc(&probe_count);
 	pr_debug("%s: Probing driver %s with device %s\n",
 		 drv->bus->name, drv->name, dev->bus_id);
+	WARN_ON(!list_empty(&dev->devres_head));
 
 	dev->driver = drv;
 	if (driver_sysfs_add(dev)) {
@@ -137,6 +138,7 @@ static int really_probe(void *void_data)
 	goto done;
 
 probe_failed:
+	devres_release_all(dev);
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
 
@@ -327,6 +329,7 @@ static void __device_release_driver(struct device * dev)
 			dev->bus->remove(dev);
 		else if (drv->remove)
 			drv->remove(dev);
+		devres_release_all(dev);
 		dev->driver = NULL;
 		put_driver(drv);
 	}

commit cb986b749c7178422bfbc982cd30e04d5db54bbc
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Nov 27 10:35:12 2006 +0100

    driver core: Change function call order in device_bind_driver().
    
    Change function call order in device_bind_driver().
    
    If we create symlinks (which might fail) before adding the device to the list
    we don't have to clean up afterwards (which we didn't).
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index f70513748947..b5bf243d9cd6 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -86,8 +86,12 @@ static void driver_sysfs_remove(struct device *dev)
  */
 int device_bind_driver(struct device *dev)
 {
-	driver_bound(dev);
-	return driver_sysfs_add(dev);
+	int ret;
+
+	ret = driver_sysfs_add(dev);
+	if (!ret)
+		driver_bound(dev);
+	return ret;
 }
 
 struct stupid_thread_structure {

commit c578abbc20762aa58e390e55252959853eeea17e
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Nov 27 10:35:10 2006 +0100

    driver core: Don't stop probing on ->probe errors.
    
    Don't stop on the first ->probe error that is not -ENODEV/-ENXIO.
    
    There might be a driver registered returning an unresonable return code, and
    this stops probing completely even though it may make sense to try the next
    possible driver. At worst, we may end up with an unbound device.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 510e7884975f..f70513748947 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -136,18 +136,17 @@ static int really_probe(void *void_data)
 	driver_sysfs_remove(dev);
 	dev->driver = NULL;
 
-	if (ret == -ENODEV || ret == -ENXIO) {
-		/* Driver matched, but didn't support device
-		 * or device not found.
-		 * Not an error; keep going.
-		 */
-		ret = 0;
-	} else {
+	if (ret != -ENODEV && ret != -ENXIO) {
 		/* driver matched but the probe failed */
 		printk(KERN_WARNING
 		       "%s: probe of %s failed with error %d\n",
 		       drv->name, dev->bus_id, ret);
 	}
+	/*
+	 * Ignore errors returned by ->probe so that the next driver can try
+	 * its luck.
+	 */
+	ret = 0;
 done:
 	kfree(data);
 	atomic_dec(&probe_count);

commit 1901fb2604fbcd53201f38725182ea807581159e
Author: Kay Sievers <kay.sievers@novell.com>
Date:   Sat Oct 7 21:55:55 2006 +0200

    Driver core: fix "driver" symlink timing
    
    Create the "driver" link before the child device may be created by
    the probing logic. This makes it possible for userspace (udev), to
    determine the driver property of the parent device, at the time the
    child device is created.
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 9c88b1e34bc3..510e7884975f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -26,28 +26,12 @@
 #define to_drv(node) container_of(node, struct device_driver, kobj.entry)
 
 
-/**
- *	device_bind_driver - bind a driver to one device.
- *	@dev:	device.
- *
- *	Allow manual attachment of a driver to a device.
- *	Caller must have already set @dev->driver.
- *
- *	Note that this does not modify the bus reference count
- *	nor take the bus's rwsem. Please verify those are accounted
- *	for before calling this. (It is ok to call with no other effort
- *	from a driver's probe() method.)
- *
- *	This function must be called with @dev->sem held.
- */
-int device_bind_driver(struct device *dev)
+static void driver_bound(struct device *dev)
 {
-	int ret;
-
 	if (klist_node_attached(&dev->knode_driver)) {
 		printk(KERN_WARNING "%s: device %s already bound\n",
 			__FUNCTION__, kobject_name(&dev->kobj));
-		return 0;
+		return;
 	}
 
 	pr_debug("bound device '%s' to driver '%s'\n",
@@ -58,6 +42,12 @@ int device_bind_driver(struct device *dev)
 					     BUS_NOTIFY_BOUND_DRIVER, dev);
 
 	klist_add_tail(&dev->knode_driver, &dev->driver->klist_devices);
+}
+
+static int driver_sysfs_add(struct device *dev)
+{
+	int ret;
+
 	ret = sysfs_create_link(&dev->driver->kobj, &dev->kobj,
 			  kobject_name(&dev->kobj));
 	if (ret == 0) {
@@ -70,6 +60,36 @@ int device_bind_driver(struct device *dev)
 	return ret;
 }
 
+static void driver_sysfs_remove(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	if (drv) {
+		sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
+		sysfs_remove_link(&dev->kobj, "driver");
+	}
+}
+
+/**
+ *	device_bind_driver - bind a driver to one device.
+ *	@dev:	device.
+ *
+ *	Allow manual attachment of a driver to a device.
+ *	Caller must have already set @dev->driver.
+ *
+ *	Note that this does not modify the bus reference count
+ *	nor take the bus's rwsem. Please verify those are accounted
+ *	for before calling this. (It is ok to call with no other effort
+ *	from a driver's probe() method.)
+ *
+ *	This function must be called with @dev->sem held.
+ */
+int device_bind_driver(struct device *dev)
+{
+	driver_bound(dev);
+	return driver_sysfs_add(dev);
+}
+
 struct stupid_thread_structure {
 	struct device_driver *drv;
 	struct device *dev;
@@ -90,30 +110,32 @@ static int really_probe(void *void_data)
 		 drv->bus->name, drv->name, dev->bus_id);
 
 	dev->driver = drv;
+	if (driver_sysfs_add(dev)) {
+		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
+			__FUNCTION__, dev->bus_id);
+		goto probe_failed;
+	}
+
 	if (dev->bus->probe) {
 		ret = dev->bus->probe(dev);
-		if (ret) {
-			dev->driver = NULL;
+		if (ret)
 			goto probe_failed;
-		}
 	} else if (drv->probe) {
 		ret = drv->probe(dev);
-		if (ret) {
-			dev->driver = NULL;
+		if (ret)
 			goto probe_failed;
-		}
-	}
-	if (device_bind_driver(dev)) {
-		printk(KERN_ERR "%s: device_bind_driver(%s) failed\n",
-			__FUNCTION__, dev->bus_id);
-		/* How does undo a ->probe?  We're screwed. */
 	}
+
+	driver_bound(dev);
 	ret = 1;
 	pr_debug("%s: Bound Device %s to Driver %s\n",
 		 drv->bus->name, dev->bus_id, drv->name);
 	goto done;
 
 probe_failed:
+	driver_sysfs_remove(dev);
+	dev->driver = NULL;
+
 	if (ret == -ENODEV || ret == -ENXIO) {
 		/* Driver matched, but didn't support device
 		 * or device not found.
@@ -289,7 +311,7 @@ static void __device_release_driver(struct device * dev)
 	drv = dev->driver;
 	if (drv) {
 		get_driver(drv);
-		sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
+		driver_sysfs_remove(dev);
 		sysfs_remove_link(&dev->kobj, "driver");
 		klist_remove(&dev->knode_driver);
 

commit 116af378201ef793424cd10508ccf18b06d8a021
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Oct 25 13:44:59 2006 +1000

    Driver core: add notification of bus events
    
    I finally did as you suggested and added the notifier to the struct
    bus_type itself. There are still problems to be expected is something
    attaches to a bus type where the code can hook in different struct
    device sub-classes (which is imho a big bogosity but I won't even try to
    argue that case now) but it will solve nicely a number of issues I've
    had so far.
    
    That also means that clients interested in registering for such
    notifications have to do it before devices are added and after bus types
    are registered. Fortunately, most bus types that matter for the various
    usage scenarios I have in mind are registerd at postcore_initcall time,
    which means I have a really nice spot at arch_initcall time to add my
    notifiers.
    
    There are 4 notifications provided. Device being added (before hooked to
    the bus) and removed (failure of previous case or after being unhooked
    from the bus), along with driver being bound to a device and about to be
    unbound.
    
    The usage I have for these are:
    
     - The 2 first ones are used to maintain a struct device_ext that is
    hooked to struct device.firmware_data. This structure contains for now a
    pointer to the Open Firmware node related to the device (if any), the
    NUMA node ID (for quick access to it) and the DMA operations pointers &
    iommu table instance for DMA to/from this device. For bus types I own
    (like IBM VIO or EBUS), I just maintain that structure directly from the
    bus code when creating the devices. But for bus types managed by generic
    code like PCI or platform (actually, of_platform which is a variation of
    platform linked to Open Firmware device-tree), I need this notifier.
    
     - The other two ones have a completely different usage scenario. I have
    cases where multiple devices and their drivers depend on each other. For
    example, the IBM EMAC network driver needs to attach to a MAL DMA engine
    which is a separate device, and a PHY interface which is also a separate
    device. They are all of_platform_device's (well, about to be with my
    upcoming patches) but there is no say in what precise order the core
    will "probe" them and instanciate the various modules. The solution I
    found for that is to have the drivers for emac to use multithread_probe,
    and wait for a driver to be bound to the target MAL and PHY control
    devices (the device-tree contains reference to the MAL and PHY interface
    nodes, which I can then match to of_platform_devices). Right now, I've
    been polling, but with that notifier, I can more cleanly wait (with a
    timeout of course).
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index c5d6bb4290ad..9c88b1e34bc3 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -52,6 +52,11 @@ int device_bind_driver(struct device *dev)
 
 	pr_debug("bound device '%s' to driver '%s'\n",
 		 dev->bus_id, dev->driver->name);
+
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+					     BUS_NOTIFY_BOUND_DRIVER, dev);
+
 	klist_add_tail(&dev->knode_driver, &dev->driver->klist_devices);
 	ret = sysfs_create_link(&dev->driver->kobj, &dev->kobj,
 			  kobject_name(&dev->kobj));
@@ -288,6 +293,11 @@ static void __device_release_driver(struct device * dev)
 		sysfs_remove_link(&dev->kobj, "driver");
 		klist_remove(&dev->knode_driver);
 
+		if (dev->bus)
+			blocking_notifier_call_chain(&dev->bus->bus_notifier,
+						     BUS_NOTIFY_UNBIND_DRIVER,
+						     dev);
+
 		if (dev->bus && dev->bus->remove)
 			dev->bus->remove(dev);
 		else if (drv->remove)

commit 735a7ffb739b6efeaeb1e720306ba308eaaeb20e
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Oct 27 11:42:37 2006 -0700

    [PATCH] drivers: wait for threaded probes between initcall levels
    
    The multithreaded-probing code has a problem: after one initcall level (eg,
    core_initcall) has been processed, we will then start processing the next
    level (postcore_initcall) while the kernel threads which are handling
    core_initcall are still executing.  This breaks the guarantees which the
    layered initcalls previously gave us.
    
    IOW, we want to be multithreaded _within_ an initcall level, but not between
    different levels.
    
    Fix that up by causing the probing code to wait for all outstanding probes at
    one level to complete before we start processing the next level.
    
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index db01b95a47a5..c5d6bb4290ad 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -18,6 +18,7 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/kthread.h>
+#include <linux/wait.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -70,6 +71,8 @@ struct stupid_thread_structure {
 };
 
 static atomic_t probe_count = ATOMIC_INIT(0);
+static DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);
+
 static int really_probe(void *void_data)
 {
 	struct stupid_thread_structure *data = void_data;
@@ -121,6 +124,7 @@ static int really_probe(void *void_data)
 done:
 	kfree(data);
 	atomic_dec(&probe_count);
+	wake_up(&probe_waitqueue);
 	return ret;
 }
 
@@ -337,6 +341,32 @@ void driver_detach(struct device_driver * drv)
 	}
 }
 
+#ifdef CONFIG_PCI_MULTITHREAD_PROBE
+static int __init wait_for_probes(void)
+{
+	DEFINE_WAIT(wait);
+
+	printk(KERN_INFO "%s: waiting for %d threads\n", __FUNCTION__,
+			atomic_read(&probe_count));
+	if (!atomic_read(&probe_count))
+		return 0;
+	while (atomic_read(&probe_count)) {
+		prepare_to_wait(&probe_waitqueue, &wait, TASK_UNINTERRUPTIBLE);
+		if (atomic_read(&probe_count))
+			schedule();
+	}
+	finish_wait(&probe_waitqueue, &wait);
+	return 0;
+}
+
+core_initcall_sync(wait_for_probes);
+postcore_initcall_sync(wait_for_probes);
+arch_initcall_sync(wait_for_probes);
+subsys_initcall_sync(wait_for_probes);
+fs_initcall_sync(wait_for_probes);
+device_initcall_sync(wait_for_probes);
+late_initcall_sync(wait_for_probes);
+#endif
 
 EXPORT_SYMBOL_GPL(device_bind_driver);
 EXPORT_SYMBOL_GPL(device_release_driver);

commit 4d664238207a82c4018757e2d87cf2a780462dcd
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Oct 9 18:04:30 2006 +0900

    driver core: kmalloc() failure check in driver_probe_device
    
    driver_probe_device() is missing kmalloc() failure check.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index ef7db6939cbf..db01b95a47a5 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -171,6 +171,8 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 		 drv->bus->name, dev->bus_id, drv->name);
 
 	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
 	data->drv = drv;
 	data->dev = dev;
 

commit 0fbf116d120a2dc5d808204c7d86ad35f7d7846f
Author: Duncan Sands <duncan.sands@free.fr>
Date:   Wed Sep 27 23:38:08 2006 +0200

    Driver core: plug device probe memory leak
    
    Make sure data is freed if the kthread fails to start.
    
    Signed-off-by: Duncan Sands <baldrick@free.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index b5f43c3e44fa..ef7db6939cbf 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -178,7 +178,7 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 		probe_task = kthread_run(really_probe, data,
 					 "probe-%s", dev->bus_id);
 		if (IS_ERR(probe_task))
-			ret = PTR_ERR(probe_task);
+			ret = really_probe(data);
 	} else
 		ret = really_probe(data);
 

commit f2eaae197f4590c4d96f31b09b0ee9067421a95c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Sep 18 16:22:34 2006 -0400

    Driver core: Fix potential deadlock in driver core
    
    There is a potential deadlock in the driver core.  It boils down to
    the fact that bus_remove_device() calls klist_remove() instead of
    klist_del(), thereby waiting until the reference count of the
    klist_node in the bus's klist of devices drops to 0.  The refcount
    can't reach 0 so long as a modprobe process is trying to bind a new
    driver to the device being removed, by calling __driver_attach().  The
    problem is that __driver_attach() tries to acquire the device's
    parent's semaphore, but the caller of bus_remove_device() is quite
    likely to own that semaphore already.
    
    It isn't sufficient just to replace klist_remove() with klist_del().
    Doing so runs the risk that the device would remain on the bus's klist
    of devices for some time, and so could be bound to another driver even
    after it was unregistered.  What's needed is a new way to distinguish
    whether or not a device is registered, based on a criterion other than
    whether its klist_node is linked into the bus's klist of devices.  That
    way driver binding can fail when the device is unregistered, even if
    it is still linked into the klist.
    
    This patch (as782) implements the solution, by adding a new bitflag to
    indiate when a struct device is registered, by testing the flag before
    allowing a driver to bind a device, and by changing the definition of
    the device_is_registered() inline.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 319a73be4180..b5f43c3e44fa 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -162,6 +162,8 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	struct task_struct *probe_task;
 	int ret = 0;
 
+	if (!device_is_registered(dev))
+		return -ENODEV;
 	if (drv->bus->match && !drv->bus->match(dev, drv))
 		goto done;
 

commit d779249ed4cb3b50690de6de8448829d65a1cd08
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 18 10:59:59 2006 -0700

    Driver Core: add ability for drivers to do a threaded probe
    
    This adds the infrastructure for drivers to do a threaded probe, and
    waits at init time for all currently outstanding probes to complete.
    
    A new kernel thread will be created when the probe() function for the
    driver is called, if the multithread_probe bit is set in the driver
    saying it can support this kind of operation.
    
    I have tested this with USB and PCI, and it works, and shaves off a lot
    of time in the boot process, but there are issues with finding root boot
    disks, and some USB drivers assume that this can never happen, so it is
    currently not enabled for any bus type.  Individual drivers can enable
    this right now if they wish, and bus authors can selectivly turn it on
    as well, once they determine that their subsystem will work properly
    with it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 9f6f11ca0ab6..319a73be4180 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -17,6 +17,7 @@
 
 #include <linux/device.h>
 #include <linux/module.h>
+#include <linux/kthread.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -63,44 +64,35 @@ int device_bind_driver(struct device *dev)
 	return ret;
 }
 
-/**
- *	driver_probe_device - attempt to bind device & driver.
- *	@drv:	driver.
- *	@dev:	device.
- *
- *	First, we call the bus's match function, if one present, which
- *	should compare the device IDs the driver supports with the
- *	device IDs of the device. Note we don't do this ourselves
- *	because we don't know the format of the ID structures, nor what
- *	is to be considered a match and what is not.
- *
- *	This function returns 1 if a match is found, an error if one
- *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
- *
- *	This function must be called with @dev->sem held.  When called
- *	for a USB interface, @dev->parent->sem must be held as well.
- */
-int driver_probe_device(struct device_driver * drv, struct device * dev)
+struct stupid_thread_structure {
+	struct device_driver *drv;
+	struct device *dev;
+};
+
+static atomic_t probe_count = ATOMIC_INIT(0);
+static int really_probe(void *void_data)
 {
+	struct stupid_thread_structure *data = void_data;
+	struct device_driver *drv = data->drv;
+	struct device *dev = data->dev;
 	int ret = 0;
 
-	if (drv->bus->match && !drv->bus->match(dev, drv))
-		goto Done;
+	atomic_inc(&probe_count);
+	pr_debug("%s: Probing driver %s with device %s\n",
+		 drv->bus->name, drv->name, dev->bus_id);
 
-	pr_debug("%s: Matched Device %s with Driver %s\n",
-		 drv->bus->name, dev->bus_id, drv->name);
 	dev->driver = drv;
 	if (dev->bus->probe) {
 		ret = dev->bus->probe(dev);
 		if (ret) {
 			dev->driver = NULL;
-			goto ProbeFailed;
+			goto probe_failed;
 		}
 	} else if (drv->probe) {
 		ret = drv->probe(dev);
 		if (ret) {
 			dev->driver = NULL;
-			goto ProbeFailed;
+			goto probe_failed;
 		}
 	}
 	if (device_bind_driver(dev)) {
@@ -111,9 +103,9 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	ret = 1;
 	pr_debug("%s: Bound Device %s to Driver %s\n",
 		 drv->bus->name, dev->bus_id, drv->name);
-	goto Done;
+	goto done;
 
- ProbeFailed:
+probe_failed:
 	if (ret == -ENODEV || ret == -ENXIO) {
 		/* Driver matched, but didn't support device
 		 * or device not found.
@@ -126,7 +118,69 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 		       "%s: probe of %s failed with error %d\n",
 		       drv->name, dev->bus_id, ret);
 	}
- Done:
+done:
+	kfree(data);
+	atomic_dec(&probe_count);
+	return ret;
+}
+
+/**
+ * driver_probe_done
+ * Determine if the probe sequence is finished or not.
+ *
+ * Should somehow figure out how to use a semaphore, not an atomic variable...
+ */
+int driver_probe_done(void)
+{
+	pr_debug("%s: probe_count = %d\n", __FUNCTION__,
+		 atomic_read(&probe_count));
+	if (atomic_read(&probe_count))
+		return -EBUSY;
+	return 0;
+}
+
+/**
+ * driver_probe_device - attempt to bind device & driver together
+ * @drv: driver to bind a device to
+ * @dev: device to try to bind to the driver
+ *
+ * First, we call the bus's match function, if one present, which should
+ * compare the device IDs the driver supports with the device IDs of the
+ * device. Note we don't do this ourselves because we don't know the
+ * format of the ID structures, nor what is to be considered a match and
+ * what is not.
+ *
+ * This function returns 1 if a match is found, an error if one occurs
+ * (that is not -ENODEV or -ENXIO), and 0 otherwise.
+ *
+ * This function must be called with @dev->sem held.  When called for a
+ * USB interface, @dev->parent->sem must be held as well.
+ */
+int driver_probe_device(struct device_driver * drv, struct device * dev)
+{
+	struct stupid_thread_structure *data;
+	struct task_struct *probe_task;
+	int ret = 0;
+
+	if (drv->bus->match && !drv->bus->match(dev, drv))
+		goto done;
+
+	pr_debug("%s: Matched Device %s with Driver %s\n",
+		 drv->bus->name, dev->bus_id, drv->name);
+
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	data->drv = drv;
+	data->dev = dev;
+
+	if (drv->multithread_probe) {
+		probe_task = kthread_run(really_probe, data,
+					 "probe-%s", dev->bus_id);
+		if (IS_ERR(probe_task))
+			ret = PTR_ERR(probe_task);
+	} else
+		ret = really_probe(data);
+
+done:
 	return ret;
 }
 

commit f86db396ff455ed586751d21816a1ebd431264e5
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Aug 14 22:43:20 2006 -0700

    drivers/base: check errors
    
    Add lots of return-value checking.
    
    <pcornelia.huck@de.ibm.com>: fix bus_rescan_devices()]
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 889c71111239..9f6f11ca0ab6 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -38,17 +38,29 @@
  *
  *	This function must be called with @dev->sem held.
  */
-void device_bind_driver(struct device * dev)
+int device_bind_driver(struct device *dev)
 {
-	if (klist_node_attached(&dev->knode_driver))
-		return;
+	int ret;
+
+	if (klist_node_attached(&dev->knode_driver)) {
+		printk(KERN_WARNING "%s: device %s already bound\n",
+			__FUNCTION__, kobject_name(&dev->kobj));
+		return 0;
+	}
 
 	pr_debug("bound device '%s' to driver '%s'\n",
 		 dev->bus_id, dev->driver->name);
 	klist_add_tail(&dev->knode_driver, &dev->driver->klist_devices);
-	sysfs_create_link(&dev->driver->kobj, &dev->kobj,
+	ret = sysfs_create_link(&dev->driver->kobj, &dev->kobj,
 			  kobject_name(&dev->kobj));
-	sysfs_create_link(&dev->kobj, &dev->driver->kobj, "driver");
+	if (ret == 0) {
+		ret = sysfs_create_link(&dev->kobj, &dev->driver->kobj,
+					"driver");
+		if (ret)
+			sysfs_remove_link(&dev->driver->kobj,
+					kobject_name(&dev->kobj));
+	}
+	return ret;
 }
 
 /**
@@ -91,7 +103,11 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 			goto ProbeFailed;
 		}
 	}
-	device_bind_driver(dev);
+	if (device_bind_driver(dev)) {
+		printk(KERN_ERR "%s: device_bind_driver(%s) failed\n",
+			__FUNCTION__, dev->bus_id);
+		/* How does undo a ->probe?  We're screwed. */
+	}
 	ret = 1;
 	pr_debug("%s: Bound Device %s to Driver %s\n",
 		 drv->bus->name, dev->bus_id, drv->name);
@@ -139,8 +155,9 @@ int device_attach(struct device * dev)
 
 	down(&dev->sem);
 	if (dev->driver) {
-		device_bind_driver(dev);
-		ret = 1;
+		ret = device_bind_driver(dev);
+		if (ret == 0)
+			ret = 1;
 	} else
 		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
 	up(&dev->sem);
@@ -182,9 +199,9 @@ static int __driver_attach(struct device * dev, void * data)
  *	returns 0 and the @dev->driver is set, we've found a
  *	compatible pair.
  */
-void driver_attach(struct device_driver * drv)
+int driver_attach(struct device_driver * drv)
 {
-	bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
+	return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
 }
 
 /**

commit 0f836ca4c122f4ef096110d652a6326fe34e6961
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 31 11:52:25 2006 -0500

    [PATCH] driver core: safely unbind drivers for devices not on a bus
    
    This patch (as667) changes the __device_release_driver() routine to
    prevent it from crashing when it runs across a device not on any bus.
    This seems logical, inasmuch as the corresponding bus_add_device()
    routine has an explicit check allowing it to accept such devices.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 730a9ce0a14a..889c71111239 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -209,7 +209,7 @@ static void __device_release_driver(struct device * dev)
 		sysfs_remove_link(&dev->kobj, "driver");
 		klist_remove(&dev->knode_driver);
 
-		if (dev->bus->remove)
+		if (dev->bus && dev->bus->remove)
 			dev->bus->remove(dev);
 		else if (drv->remove)
 			drv->remove(dev);

commit 594c8281f90560faf9632d91bb9d402cbe560e63
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Thu Jan 5 14:29:51 2006 +0000

    [PATCH] Add bus_type probe, remove, shutdown methods.
    
    Add bus_type probe, remove and shutdown methods to replace the
    corresponding methods in struct device_driver.  This matches
    the way we handle the suspend/resume methods.
    
    Since the bus methods override the device_driver methods, warn
    if a device driver is registered whose methods will not be
    called.
    
    The long-term idea is to remove the device_driver methods entirely.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 2b905016664d..730a9ce0a14a 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -78,7 +78,13 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	pr_debug("%s: Matched Device %s with Driver %s\n",
 		 drv->bus->name, dev->bus_id, drv->name);
 	dev->driver = drv;
-	if (drv->probe) {
+	if (dev->bus->probe) {
+		ret = dev->bus->probe(dev);
+		if (ret) {
+			dev->driver = NULL;
+			goto ProbeFailed;
+		}
+	} else if (drv->probe) {
 		ret = drv->probe(dev);
 		if (ret) {
 			dev->driver = NULL;
@@ -203,7 +209,9 @@ static void __device_release_driver(struct device * dev)
 		sysfs_remove_link(&dev->kobj, "driver");
 		klist_remove(&dev->knode_driver);
 
-		if (drv->remove)
+		if (dev->bus->remove)
+			dev->bus->remove(dev);
+		else if (drv->remove)
 			drv->remove(dev);
 		dev->driver = NULL;
 		put_driver(drv);

commit bf74ad5bc41727d5f2f1c6bedb2c1fac394de731
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 17 16:54:12 2005 -0500

    [PATCH] Hold the device's parent's lock during probe and remove
    
    This patch (as604) makes the driver core hold a device's parent's lock
    as well as the device's lock during calls to the probe and remove
    methods in a driver.  This facility is needed by USB device drivers,
    owing to the peculiar way USB devices work:
    
            A device provides multiple interfaces, and drivers are bound
            to interfaces rather than to devices;
    
            Nevertheless a reset, reset-configuration, suspend, or resume
            affects the entire device and requires the caller to hold the
            lock for the device, not just a lock for one of the interfaces.
    
    Since a USB driver's probe method is always called with the interface
    lock held, the locking order rules (always lock parent before child)
    prevent these methods from acquiring the device lock.  The solution
    provided here is to call all probe and remove methods, for all devices
    (not just USB), with the parent lock already acquired.
    
    Although currently only the USB subsystem requires these changes, people
    have mentioned in prior discussion that the overhead of acquiring an
    extra semaphore in all the prove/remove sequences is not overly large.
    
    Up to now, the USB core has been using its own set of private
    semaphores.  A followup patch will remove them, relying entirely on the
    device semaphores provided by the driver core.
    
    The code paths affected by this patch are:
    
            device_add and device_del: The USB core already holds the parent
            lock, so no actual change is needed.
    
            driver_register and driver_unregister: The driver core will now
            lock both the parent and the device before probing or removing.
    
            driver_bind and driver_unbind (in sysfs): These routines will
            now lock both the parent and the device before binding or
            unbinding.
    
            bus_rescan_devices: The helper routine will lock the parent
            before probing a device.
    
    I have not tested this patch for conflicts with other subsystems.  As
    far as I can see, the only possibility of conflict would lie in the
    bus_rescan_devices pathway, and it seems pretty remote.  Nevertheless,
    it would be good for this to get a lot of testing in -mm.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3b419c9a1e7e..2b905016664d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -65,7 +65,8 @@ void device_bind_driver(struct device * dev)
  *	This function returns 1 if a match is found, an error if one
  *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
  *
- *	This function must be called with @dev->sem held.
+ *	This function must be called with @dev->sem held.  When called
+ *	for a USB interface, @dev->parent->sem must be held as well.
  */
 int driver_probe_device(struct device_driver * drv, struct device * dev)
 {
@@ -123,6 +124,8 @@ static int __device_attach(struct device_driver * drv, void * data)
  *
  *	Returns 1 if the device was bound to a driver;
  *	0 if no matching device was found; error code otherwise.
+ *
+ *	When called for a USB interface, @dev->parent->sem must be held.
  */
 int device_attach(struct device * dev)
 {
@@ -152,10 +155,14 @@ static int __driver_attach(struct device * dev, void * data)
 	 * is an error.
 	 */
 
+	if (dev->parent)	/* Needed for USB */
+		down(&dev->parent->sem);
 	down(&dev->sem);
 	if (!dev->driver)
 		driver_probe_device(drv, dev);
 	up(&dev->sem);
+	if (dev->parent)
+		up(&dev->parent->sem);
 
 	return 0;
 }
@@ -181,6 +188,8 @@ void driver_attach(struct device_driver * drv)
  *	Manually detach device from driver.
  *
  *	__device_release_driver() must be called with @dev->sem held.
+ *	When called for a USB interface, @dev->parent->sem must be held
+ *	as well.
  */
 
 static void __device_release_driver(struct device * dev)
@@ -233,10 +242,14 @@ void driver_detach(struct device_driver * drv)
 		get_device(dev);
 		spin_unlock(&drv->klist_devices.k_lock);
 
+		if (dev->parent)	/* Needed for USB */
+			down(&dev->parent->sem);
 		down(&dev->sem);
 		if (dev->driver == drv)
 			__device_release_driver(dev);
 		up(&dev->sem);
+		if (dev->parent)
+			up(&dev->parent->sem);
 		put_device(dev);
 	}
 }

commit 2b08c8d0468866f86da97f836c6ac14338cb81a9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 23 15:43:50 2005 -0800

    [PATCH] Small fixes to driver core
    
    This patch (as603) makes a few small fixes to the driver core:
    
    Change spin_lock_irq for a klist lock to spin_lock;
    
    Fix reference count leaks;
    
    Minor spelling and formatting changes.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3565e9795301..3b419c9a1e7e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -62,7 +62,6 @@ void device_bind_driver(struct device * dev)
  *	because we don't know the format of the ID structures, nor what
  *	is to be considered a match and what is not.
  *
- *
  *	This function returns 1 if a match is found, an error if one
  *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
  *
@@ -158,7 +157,6 @@ static int __driver_attach(struct device * dev, void * data)
 		driver_probe_device(drv, dev);
 	up(&dev->sem);
 
-
 	return 0;
 }
 
@@ -225,15 +223,15 @@ void driver_detach(struct device_driver * drv)
 	struct device * dev;
 
 	for (;;) {
-		spin_lock_irq(&drv->klist_devices.k_lock);
+		spin_lock(&drv->klist_devices.k_lock);
 		if (list_empty(&drv->klist_devices.k_list)) {
-			spin_unlock_irq(&drv->klist_devices.k_lock);
+			spin_unlock(&drv->klist_devices.k_lock);
 			break;
 		}
 		dev = list_entry(drv->klist_devices.k_list.prev,
 				struct device, knode_driver.n_node);
 		get_device(dev);
-		spin_unlock_irq(&drv->klist_devices.k_lock);
+		spin_unlock(&drv->klist_devices.k_lock);
 
 		down(&dev->sem);
 		if (dev->driver == drv)

commit 4c898c7f2f286b204fefc5dddb568f755d195d0c
Author: Daniel Ritz <daniel.ritz@gmx.ch>
Date:   Thu Sep 22 00:47:11 2005 -0700

    [PATCH] Driver Core: fis bus rescan devices race
    
    bus_rescan_devices_helper() does not hold the dev->sem when it checks for
    !dev->driver().  device_attach() holds the sem, but calls again
    device_bind_driver() even when dev->driver is set.
    
    What happens is that a first device_attach() call (module insertion time)
    is on the way binding the device to a driver.  Another thread calls
    bus_rescan_devices().  Now when bus_rescan_devices_helper() checks for
    dev->driver it is still NULL 'cos the the prior device_attach() is not yet
    finished.  But as soon as the first one releases the dev->sem the second
    device_attach() tries to rebind the already bound device again.
    device_bind_driver() does this blindly which leads to a corrupt
    driver->klist_devices list (the device links itself, the head points to the
    device).  Later a call to device_release_driver() sets dev->driver to NULL
    and breaks the link it has to itself on knode_driver.  Rmmoding the driver
    later calls driver_detach() which leads to an endless loop 'cos the list
    head in klist_devices still points to the device.  And since dev->driver is
    NULL it's stuck with the same device forever.  Boom.  And rmmod hangs.
    
    Very easy to reproduce with new-style pcmcia and a 16bit card.  Just loop
    modprobe <pcmcia-modules> ;cardctl eject; rmmod <card driver, pcmcia
    modules>.
    
    Easiest fix is to check if the device is already bound to a driver in
    device_bind_driver().  This avoids the double binding.
    
    Signed-off-by: Daniel Ritz <daniel.ritz@gmx.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index d5bbce38282f..3565e9795301 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -40,6 +40,9 @@
  */
 void device_bind_driver(struct device * dev)
 {
+	if (klist_node_attached(&dev->knode_driver))
+		return;
+
 	pr_debug("bound device '%s' to driver '%s'\n",
 		 dev->bus_id, dev->driver->name);
 	klist_add_tail(&dev->knode_driver, &dev->driver->klist_devices);

commit d856f1e337782326c638c70c0b4df2b909350dec
Author: James Bottomley <James.Bottomley@SteelEye.com>
Date:   Fri Aug 19 09:14:01 2005 -0400

    [PATCH] klist: fix klist to have the same klist_add semantics as list_head
    
    at the moment, the list_head semantics are
    
    list_add(node, head)
    
    whereas current klist semantics are
    
    klist_add(head, node)
    
    This is bound to cause confusion, and since klist is the newcomer, it
    should follow the list_head semantics.
    
    I also added missing include guards to klist.h
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 16323f9cbff0..d5bbce38282f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -42,7 +42,7 @@ void device_bind_driver(struct device * dev)
 {
 	pr_debug("bound device '%s' to driver '%s'\n",
 		 dev->bus_id, dev->driver->name);
-	klist_add_tail(&dev->driver->klist_devices, &dev->knode_driver);
+	klist_add_tail(&dev->knode_driver, &dev->driver->klist_devices);
 	sysfs_create_link(&dev->driver->kobj, &dev->kobj,
 			  kobject_name(&dev->kobj));
 	sysfs_create_link(&dev->kobj, &dev->driver->kobj, "driver");

commit afdce75f1eaebcf358b7594ba7969aade105c3b0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 22 16:09:05 2005 -0700

    [PATCH] driver core: Add the ability to bind drivers to devices from userspace
    
    This adds a single file, "bind", to the sysfs directory of every driver
    registered with the driver core.  To bind a device to a driver, write
    the bus id of the device you wish to bind to that specific driver to the
    "bind" file (remember to not add a trailing \n).  If that bus id matches
    a device on that bus, and it does not currently have a driver bound to
    it, the probe sequence will be initiated with that driver and device.
    
    Note, this requires that the driver itself be willing and able to accept
    that device (usually through a device id type table).  This patch does
    not make it possible to override the driver's id table.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 6db3a789c54f..16323f9cbff0 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -65,7 +65,7 @@ void device_bind_driver(struct device * dev)
  *
  *	This function must be called with @dev->sem held.
  */
-static int driver_probe_device(struct device_driver * drv, struct device * dev)
+int driver_probe_device(struct device_driver * drv, struct device * dev)
 {
 	int ret = 0;
 

commit ca2b94ba12f3c36fd3d6ed9d38b3798d4dad0d8b
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed May 18 10:42:23 2005 +0200

    [PATCH] driver core: fix error handling in bus_add_device
    
    The error handling in bus_add_device() and device_attach() is simply
    non-existing. This patch propagates any error from device_attach to
    the upper layers to allow for a proper recovery.
    
    From: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index eab2030c506d..6db3a789c54f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -119,7 +119,8 @@ static int __device_attach(struct device_driver * drv, void * data)
  *	driver_probe_device() for each pair. If a compatible
  *	pair is found, break out and return.
  *
- *	Returns 1 if the device was bound to a driver; 0 otherwise.
+ *	Returns 1 if the device was bound to a driver;
+ *	0 if no matching device was found; error code otherwise.
  */
 int device_attach(struct device * dev)
 {

commit c95a6b057b108c2b7add35cba1354f9af921349e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 6 15:38:33 2005 -0400

    [PATCH] driver core: Fix races in driver_detach()
    
    This patch is intended for your "driver" tree.  It fixes several subtle
    races in driver_detach() and device_release_driver() in the driver-model
    core.
    
    The major change is to use klist_remove() rather than klist_del() when
    taking a device off its driver's list.  There's no other way to guarantee
    that the list pointers will be updated before some other driver binds to
    the device.  For this to work driver_detach() can't use a klist iterator,
    so the loop over the devices must be written out in full.  In addition the
    patch protects against the possibility that, when a driver and a device
    are unregistered at the same time, one may be unloaded from memory before
    the other is finished using it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 8510918109e0..eab2030c506d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -177,41 +177,66 @@ void driver_attach(struct device_driver * drv)
  *	@dev:	device.
  *
  *	Manually detach device from driver.
- *	Note that this is called without incrementing the bus
- *	reference count nor taking the bus's rwsem. Be sure that
- *	those are accounted for before calling this function.
+ *
+ *	__device_release_driver() must be called with @dev->sem held.
  */
-void device_release_driver(struct device * dev)
+
+static void __device_release_driver(struct device * dev)
 {
 	struct device_driver * drv;
 
-	down(&dev->sem);
-	if (dev->driver) {
-		drv = dev->driver;
+	drv = dev->driver;
+	if (drv) {
+		get_driver(drv);
 		sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
 		sysfs_remove_link(&dev->kobj, "driver");
-		klist_del(&dev->knode_driver);
+		klist_remove(&dev->knode_driver);
 
 		if (drv->remove)
 			drv->remove(dev);
 		dev->driver = NULL;
+		put_driver(drv);
 	}
-	up(&dev->sem);
 }
 
-static int __remove_driver(struct device * dev, void * unused)
+void device_release_driver(struct device * dev)
 {
-	device_release_driver(dev);
-	return 0;
+	/*
+	 * If anyone calls device_release_driver() recursively from
+	 * within their ->remove callback for the same device, they
+	 * will deadlock right here.
+	 */
+	down(&dev->sem);
+	__device_release_driver(dev);
+	up(&dev->sem);
 }
 
+
 /**
  * driver_detach - detach driver from all devices it controls.
  * @drv: driver.
  */
 void driver_detach(struct device_driver * drv)
 {
-	driver_for_each_device(drv, NULL, NULL, __remove_driver);
+	struct device * dev;
+
+	for (;;) {
+		spin_lock_irq(&drv->klist_devices.k_lock);
+		if (list_empty(&drv->klist_devices.k_list)) {
+			spin_unlock_irq(&drv->klist_devices.k_lock);
+			break;
+		}
+		dev = list_entry(drv->klist_devices.k_list.prev,
+				struct device, knode_driver.n_node);
+		get_device(dev);
+		spin_unlock_irq(&drv->klist_devices.k_lock);
+
+		down(&dev->sem);
+		if (dev->driver == drv)
+			__device_release_driver(dev);
+		up(&dev->sem);
+		put_device(dev);
+	}
 }
 
 

commit 0d3e5a2e39b6ba2974e9e7c2a429018c45de8e76
Author: Patrick Mochel <mochel@digitalimplant.org>
Date:   Tue Apr 5 23:46:33 2005 -0700

    [PATCH] Driver Core: fix bk-driver-core kills ppc64
    
    There's no check to see if the device is already bound to a driver, which
    could do bad things.  The first thing to go wrong is that it will try to match
    a driver with a device already bound to one.  In some cases (it appears with
    USB with drivers/usb/core/usb.c::usb_match_id()), some drivers will match a
    device based on the class type, so it would be common (especially for HID
    devices) to match a device that is already bound.
    
    The fun comes when ->probe() is called, it fails, then
    driver_probe_device() does this:
    
            dev->driver = NULL;
    
    Later on, that pointer could be be dereferenced without checking and cause
    hell to break loose.
    
    This problem could be nasty. It's very hardware dependent, since some
    devices could have a different set of matching qualifiers than others.
    
    Now, I don't quite see exactly where/how you were getting that crash.
    You're dereferencing bad memory, but I'm not sure which pointer was bad
    and where it came from, but it could have come from a couple of different
    places.
    
    The patch below will hopefully fix it all up for you. It's against
    2.6.12-rc2-mm1, and does the following:
    
    - Move logic to driver_probe_device() and comments uncommon returns:
      1 - If device is bound
      0 - If device not bound, and no error
      error - If there was an error.
    
    - Move locking to caller of that function, since we want to lock a
      device for the entire time we're trying to bind it to a driver (to
      prevent against a driver being loaded at the same time).
    
    - Update __device_attach() and __driver_attach() to do that locking.
    
    - Check if device is already bound in __driver_attach()
    
    - Update the converse device_release_driver() so it locks the device
      around all of the operations.
    
    - Mark driver_probe_device() as static and remove export. It's an
      internal function, it should stay that way, and there are no other
      callers. If there is ever a need to export it, we can audit it as
      necessary.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index dd2a8a79c121..8510918109e0 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -35,6 +35,8 @@
  *	nor take the bus's rwsem. Please verify those are accounted
  *	for before calling this. (It is ok to call with no other effort
  *	from a driver's probe() method.)
+ *
+ *	This function must be called with @dev->sem held.
  */
 void device_bind_driver(struct device * dev)
 {
@@ -57,54 +59,56 @@ void device_bind_driver(struct device * dev)
  *	because we don't know the format of the ID structures, nor what
  *	is to be considered a match and what is not.
  *
- *	If we find a match, we call @drv->probe(@dev) if it exists, and
- *	call device_bind_driver() above.
+ *
+ *	This function returns 1 if a match is found, an error if one
+ *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
+ *
+ *	This function must be called with @dev->sem held.
  */
-int driver_probe_device(struct device_driver * drv, struct device * dev)
+static int driver_probe_device(struct device_driver * drv, struct device * dev)
 {
-	int error = 0;
+	int ret = 0;
 
 	if (drv->bus->match && !drv->bus->match(dev, drv))
-		return -ENODEV;
+		goto Done;
 
-	down(&dev->sem);
+	pr_debug("%s: Matched Device %s with Driver %s\n",
+		 drv->bus->name, dev->bus_id, drv->name);
 	dev->driver = drv;
 	if (drv->probe) {
-		error = drv->probe(dev);
-		if (error) {
+		ret = drv->probe(dev);
+		if (ret) {
 			dev->driver = NULL;
-			up(&dev->sem);
-			return error;
+			goto ProbeFailed;
 		}
 	}
-	up(&dev->sem);
 	device_bind_driver(dev);
-	return 0;
+	ret = 1;
+	pr_debug("%s: Bound Device %s to Driver %s\n",
+		 drv->bus->name, dev->bus_id, drv->name);
+	goto Done;
+
+ ProbeFailed:
+	if (ret == -ENODEV || ret == -ENXIO) {
+		/* Driver matched, but didn't support device
+		 * or device not found.
+		 * Not an error; keep going.
+		 */
+		ret = 0;
+	} else {
+		/* driver matched but the probe failed */
+		printk(KERN_WARNING
+		       "%s: probe of %s failed with error %d\n",
+		       drv->name, dev->bus_id, ret);
+	}
+ Done:
+	return ret;
 }
 
 static int __device_attach(struct device_driver * drv, void * data)
 {
 	struct device * dev = data;
-	int error;
-
-	error = driver_probe_device(drv, dev);
-	if (error) {
-		if ((error == -ENODEV) || (error == -ENXIO)) {
-			/* Driver matched, but didn't support device
-			 * or device not found.
-			 * Not an error; keep going.
-			 */
-			error = 0;
-		} else {
-			/* driver matched but the probe failed */
-			printk(KERN_WARNING
-			       "%s: probe of %s failed with error %d\n",
-			       drv->name, dev->bus_id, error);
-		}
-		return error;
-	}
-	/* stop looking, this device is attached */
-	return 1;
+	return driver_probe_device(drv, dev);
 }
 
 /**
@@ -114,37 +118,43 @@ static int __device_attach(struct device_driver * drv, void * data)
  *	Walk the list of drivers that the bus has and call
  *	driver_probe_device() for each pair. If a compatible
  *	pair is found, break out and return.
+ *
+ *	Returns 1 if the device was bound to a driver; 0 otherwise.
  */
 int device_attach(struct device * dev)
 {
+	int ret = 0;
+
+	down(&dev->sem);
 	if (dev->driver) {
 		device_bind_driver(dev);
-		return 1;
-	}
-
-	return bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
+		ret = 1;
+	} else
+		ret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
+	up(&dev->sem);
+	return ret;
 }
 
 static int __driver_attach(struct device * dev, void * data)
 {
 	struct device_driver * drv = data;
-	int error = 0;
-
-	if (!dev->driver) {
-		error = driver_probe_device(drv, dev);
-		if (error) {
-			if (error != -ENODEV) {
-				/* driver matched but the probe failed */
-				printk(KERN_WARNING
-				       "%s: probe of %s failed with error %d\n",
-				       drv->name, dev->bus_id, error);
-			} else
-				error = 0;
-			return error;
-		}
-		/* stop looking, this driver is attached */
-		return 1;
-	}
+
+	/*
+	 * Lock device and try to bind to it. We drop the error
+	 * here and always return 0, because we need to keep trying
+	 * to bind to devices and some drivers will return an error
+	 * simply if it didn't support the device.
+	 *
+	 * driver_probe_device() will spit a warning if there
+	 * is an error.
+	 */
+
+	down(&dev->sem);
+	if (!dev->driver)
+		driver_probe_device(drv, dev);
+	up(&dev->sem);
+
+
 	return 0;
 }
 
@@ -156,9 +166,6 @@ static int __driver_attach(struct device * dev, void * data)
  *	match the driver with each one.  If driver_probe_device()
  *	returns 0 and the @dev->driver is set, we've found a
  *	compatible pair.
- *
- *	Note that we ignore the -ENODEV error from driver_probe_device(),
- *	since it's perfectly valid for a driver not to bind to any devices.
  */
 void driver_attach(struct device_driver * drv)
 {
@@ -176,19 +183,19 @@ void driver_attach(struct device_driver * drv)
  */
 void device_release_driver(struct device * dev)
 {
-	struct device_driver * drv = dev->driver;
-
-	if (!drv)
-		return;
-
-	sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
-	sysfs_remove_link(&dev->kobj, "driver");
-	klist_del(&dev->knode_driver);
+	struct device_driver * drv;
 
 	down(&dev->sem);
-	if (drv->remove)
-		drv->remove(dev);
-	dev->driver = NULL;
+	if (dev->driver) {
+		drv = dev->driver;
+		sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
+		sysfs_remove_link(&dev->kobj, "driver");
+		klist_del(&dev->knode_driver);
+
+		if (drv->remove)
+			drv->remove(dev);
+		dev->driver = NULL;
+	}
 	up(&dev->sem);
 }
 
@@ -208,7 +215,6 @@ void driver_detach(struct device_driver * drv)
 }
 
 
-EXPORT_SYMBOL_GPL(driver_probe_device);
 EXPORT_SYMBOL_GPL(device_bind_driver);
 EXPORT_SYMBOL_GPL(device_release_driver);
 EXPORT_SYMBOL_GPL(device_attach);

commit b86c1df1f98d16c999423a3907eb40a9423f481e
Author: gregkh@suse.de <gregkh@suse.de>
Date:   Thu Mar 31 12:53:00 2005 -0800

    [PATCH] Driver core: Fix up the driver and device iterators to be quieter
    
    Also stops looping over the lists when a match is found.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 159e0623a681..dd2a8a79c121 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -88,20 +88,23 @@ static int __device_attach(struct device_driver * drv, void * data)
 	int error;
 
 	error = driver_probe_device(drv, dev);
-
-	if (error == -ENODEV && error == -ENXIO) {
-		/* Driver matched, but didn't support device
-		 * or device not found.
-		 * Not an error; keep going.
-		 */
-		error = 0;
-	} else {
-		/* driver matched but the probe failed */
-		printk(KERN_WARNING
-		       "%s: probe of %s failed with error %d\n",
-		       drv->name, dev->bus_id, error);
+	if (error) {
+		if ((error == -ENODEV) || (error == -ENXIO)) {
+			/* Driver matched, but didn't support device
+			 * or device not found.
+			 * Not an error; keep going.
+			 */
+			error = 0;
+		} else {
+			/* driver matched but the probe failed */
+			printk(KERN_WARNING
+			       "%s: probe of %s failed with error %d\n",
+			       drv->name, dev->bus_id, error);
+		}
+		return error;
 	}
-	return 0;
+	/* stop looking, this device is attached */
+	return 1;
 }
 
 /**
@@ -137,7 +140,10 @@ static int __driver_attach(struct device * dev, void * data)
 				       drv->name, dev->bus_id, error);
 			} else
 				error = 0;
+			return error;
 		}
+		/* stop looking, this driver is attached */
+		return 1;
 	}
 	return 0;
 }

commit 0956af53afea290c5676c75249fc2c180d831375
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 18:58:45 2005 -0800

    [PATCH] Call klist_del() instead of klist_remove().
    
    - Can't wait on removing the current item in the list (the positive refcount *because*
      we are using it causes it to deadlock).
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 85042ada8a5b..159e0623a681 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -177,7 +177,7 @@ void device_release_driver(struct device * dev)
 
 	sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
 	sysfs_remove_link(&dev->kobj, "driver");
-	klist_remove(&dev->knode_driver);
+	klist_del(&dev->knode_driver);
 
 	down(&dev->sem);
 	if (drv->remove)

commit 2287c322b61fced7e0c326a1a9606aa73147e3df
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 10:50:24 2005 -0800

    [PATCH] Use bus_for_each_{dev,drv} for driver binding.
    
    - Now possible, since the lists are locked using the klist lock and not the
      global rwsem.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 47cbb5641235..85042ada8a5b 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -82,6 +82,28 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	return 0;
 }
 
+static int __device_attach(struct device_driver * drv, void * data)
+{
+	struct device * dev = data;
+	int error;
+
+	error = driver_probe_device(drv, dev);
+
+	if (error == -ENODEV && error == -ENXIO) {
+		/* Driver matched, but didn't support device
+		 * or device not found.
+		 * Not an error; keep going.
+		 */
+		error = 0;
+	} else {
+		/* driver matched but the probe failed */
+		printk(KERN_WARNING
+		       "%s: probe of %s failed with error %d\n",
+		       drv->name, dev->bus_id, error);
+	}
+	return 0;
+}
+
 /**
  *	device_attach - try to attach device to a driver.
  *	@dev:	device.
@@ -92,30 +114,31 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
  */
 int device_attach(struct device * dev)
 {
- 	struct bus_type * bus = dev->bus;
-	struct list_head * entry;
-	int error;
-
 	if (dev->driver) {
 		device_bind_driver(dev);
 		return 1;
 	}
 
-	if (bus->match) {
-		list_for_each(entry, &bus->drivers.list) {
-			struct device_driver * drv = to_drv(entry);
-			error = driver_probe_device(drv, dev);
-			if (!error)
-				/* success, driver matched */
-				return 1;
-			if (error != -ENODEV && error != -ENXIO)
+	return bus_for_each_drv(dev->bus, NULL, dev, __device_attach);
+}
+
+static int __driver_attach(struct device * dev, void * data)
+{
+	struct device_driver * drv = data;
+	int error = 0;
+
+	if (!dev->driver) {
+		error = driver_probe_device(drv, dev);
+		if (error) {
+			if (error != -ENODEV) {
 				/* driver matched but the probe failed */
 				printk(KERN_WARNING
-				    "%s: probe of %s failed with error %d\n",
-				    drv->name, dev->bus_id, error);
+				       "%s: probe of %s failed with error %d\n",
+				       drv->name, dev->bus_id, error);
+			} else
+				error = 0;
 		}
 	}
-
 	return 0;
 }
 
@@ -133,24 +156,7 @@ int device_attach(struct device * dev)
  */
 void driver_attach(struct device_driver * drv)
 {
-	struct bus_type * bus = drv->bus;
-	struct list_head * entry;
-	int error;
-
-	if (!bus->match)
-		return;
-
-	list_for_each(entry, &bus->devices.list) {
-		struct device * dev = container_of(entry, struct device, bus_list);
-		if (!dev->driver) {
-			error = driver_probe_device(drv, dev);
-			if (error && (error != -ENODEV))
-				/* driver matched but the probe failed */
-				printk(KERN_WARNING
-				    "%s: probe of %s failed with error %d\n",
-				    drv->name, dev->bus_id, error);
-		}
-	}
+	bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
 }
 
 /**

commit 94e7b1c5ff2055571703e38b059afffe17658432
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 12:25:36 2005 -0800

    [PATCH] Add a klist to struct device_driver for the devices bound to it.
    
    - Use it in driver_for_each_device() instead of the regular list_head and stop using
      the bus's rwsem for protection.
    - Use driver_for_each_device() in driver_detach() so we don't deadlock on the
      bus's rwsem.
    - Remove ->devices.
    - Move klist access and sysfs link access out from under device's semaphore, since
      they're synchronized through other means.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index b709b1e0cb2a..47cbb5641235 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -40,7 +40,7 @@ void device_bind_driver(struct device * dev)
 {
 	pr_debug("bound device '%s' to driver '%s'\n",
 		 dev->bus_id, dev->driver->name);
-	list_add_tail(&dev->driver_list, &dev->driver->devices);
+	klist_add_tail(&dev->driver->klist_devices, &dev->knode_driver);
 	sysfs_create_link(&dev->driver->kobj, &dev->kobj,
 			  kobject_name(&dev->kobj));
 	sysfs_create_link(&dev->kobj, &dev->driver->kobj, "driver");
@@ -164,31 +164,35 @@ void driver_attach(struct device_driver * drv)
  */
 void device_release_driver(struct device * dev)
 {
-	struct device_driver * drv;
+	struct device_driver * drv = dev->driver;
+
+	if (!drv)
+		return;
+
+	sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
+	sysfs_remove_link(&dev->kobj, "driver");
+	klist_remove(&dev->knode_driver);
 
 	down(&dev->sem);
-	drv = dev->driver;
-	if (drv) {
-		sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
-		sysfs_remove_link(&dev->kobj, "driver");
-		list_del_init(&dev->driver_list);
-		if (drv->remove)
-			drv->remove(dev);
-		dev->driver = NULL;
-	}
+	if (drv->remove)
+		drv->remove(dev);
+	dev->driver = NULL;
 	up(&dev->sem);
 }
 
+static int __remove_driver(struct device * dev, void * unused)
+{
+	device_release_driver(dev);
+	return 0;
+}
+
 /**
  * driver_detach - detach driver from all devices it controls.
  * @drv: driver.
  */
 void driver_detach(struct device_driver * drv)
 {
-	while (!list_empty(&drv->devices)) {
-		struct device * dev = container_of(drv->devices.next, struct device, driver_list);
-		device_release_driver(dev);
-	}
+	driver_for_each_device(drv, NULL, NULL, __remove_driver);
 }
 
 

commit 07e4a3e27fe414980ddc85a358e5a56abc48b363
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 10:52:54 2005 -0800

    [PATCH] Move device/driver code to drivers/base/dd.c
    
    This relocates the driver binding/unbinding code to drivers/base/dd.c. This is done
    for two reasons: One, it's not code related to the bus_type itself; it uses some from
    that, some from devices, and some from drivers. And Two, it will make it easier to do
    some of the upcoming lock removal on that code..
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
new file mode 100644
index 000000000000..b709b1e0cb2a
--- /dev/null
+++ b/drivers/base/dd.c
@@ -0,0 +1,200 @@
+/*
+ *	drivers/base/dd.c - The core device/driver interactions.
+ *
+ * 	This file contains the (sometimes tricky) code that controls the
+ *	interactions between devices and drivers, which primarily includes
+ *	driver binding and unbinding.
+ *
+ *	All of this code used to exist in drivers/base/bus.c, but was
+ *	relocated to here in the name of compartmentalization (since it wasn't
+ *	strictly code just for the 'struct bus_type'.
+ *
+ *	Copyright (c) 2002-5 Patrick Mochel
+ *	Copyright (c) 2002-3 Open Source Development Labs
+ *
+ *	This file is released under the GPLv2
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include "base.h"
+#include "power/power.h"
+
+#define to_drv(node) container_of(node, struct device_driver, kobj.entry)
+
+
+/**
+ *	device_bind_driver - bind a driver to one device.
+ *	@dev:	device.
+ *
+ *	Allow manual attachment of a driver to a device.
+ *	Caller must have already set @dev->driver.
+ *
+ *	Note that this does not modify the bus reference count
+ *	nor take the bus's rwsem. Please verify those are accounted
+ *	for before calling this. (It is ok to call with no other effort
+ *	from a driver's probe() method.)
+ */
+void device_bind_driver(struct device * dev)
+{
+	pr_debug("bound device '%s' to driver '%s'\n",
+		 dev->bus_id, dev->driver->name);
+	list_add_tail(&dev->driver_list, &dev->driver->devices);
+	sysfs_create_link(&dev->driver->kobj, &dev->kobj,
+			  kobject_name(&dev->kobj));
+	sysfs_create_link(&dev->kobj, &dev->driver->kobj, "driver");
+}
+
+/**
+ *	driver_probe_device - attempt to bind device & driver.
+ *	@drv:	driver.
+ *	@dev:	device.
+ *
+ *	First, we call the bus's match function, if one present, which
+ *	should compare the device IDs the driver supports with the
+ *	device IDs of the device. Note we don't do this ourselves
+ *	because we don't know the format of the ID structures, nor what
+ *	is to be considered a match and what is not.
+ *
+ *	If we find a match, we call @drv->probe(@dev) if it exists, and
+ *	call device_bind_driver() above.
+ */
+int driver_probe_device(struct device_driver * drv, struct device * dev)
+{
+	int error = 0;
+
+	if (drv->bus->match && !drv->bus->match(dev, drv))
+		return -ENODEV;
+
+	down(&dev->sem);
+	dev->driver = drv;
+	if (drv->probe) {
+		error = drv->probe(dev);
+		if (error) {
+			dev->driver = NULL;
+			up(&dev->sem);
+			return error;
+		}
+	}
+	up(&dev->sem);
+	device_bind_driver(dev);
+	return 0;
+}
+
+/**
+ *	device_attach - try to attach device to a driver.
+ *	@dev:	device.
+ *
+ *	Walk the list of drivers that the bus has and call
+ *	driver_probe_device() for each pair. If a compatible
+ *	pair is found, break out and return.
+ */
+int device_attach(struct device * dev)
+{
+ 	struct bus_type * bus = dev->bus;
+	struct list_head * entry;
+	int error;
+
+	if (dev->driver) {
+		device_bind_driver(dev);
+		return 1;
+	}
+
+	if (bus->match) {
+		list_for_each(entry, &bus->drivers.list) {
+			struct device_driver * drv = to_drv(entry);
+			error = driver_probe_device(drv, dev);
+			if (!error)
+				/* success, driver matched */
+				return 1;
+			if (error != -ENODEV && error != -ENXIO)
+				/* driver matched but the probe failed */
+				printk(KERN_WARNING
+				    "%s: probe of %s failed with error %d\n",
+				    drv->name, dev->bus_id, error);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ *	driver_attach - try to bind driver to devices.
+ *	@drv:	driver.
+ *
+ *	Walk the list of devices that the bus has on it and try to
+ *	match the driver with each one.  If driver_probe_device()
+ *	returns 0 and the @dev->driver is set, we've found a
+ *	compatible pair.
+ *
+ *	Note that we ignore the -ENODEV error from driver_probe_device(),
+ *	since it's perfectly valid for a driver not to bind to any devices.
+ */
+void driver_attach(struct device_driver * drv)
+{
+	struct bus_type * bus = drv->bus;
+	struct list_head * entry;
+	int error;
+
+	if (!bus->match)
+		return;
+
+	list_for_each(entry, &bus->devices.list) {
+		struct device * dev = container_of(entry, struct device, bus_list);
+		if (!dev->driver) {
+			error = driver_probe_device(drv, dev);
+			if (error && (error != -ENODEV))
+				/* driver matched but the probe failed */
+				printk(KERN_WARNING
+				    "%s: probe of %s failed with error %d\n",
+				    drv->name, dev->bus_id, error);
+		}
+	}
+}
+
+/**
+ *	device_release_driver - manually detach device from driver.
+ *	@dev:	device.
+ *
+ *	Manually detach device from driver.
+ *	Note that this is called without incrementing the bus
+ *	reference count nor taking the bus's rwsem. Be sure that
+ *	those are accounted for before calling this function.
+ */
+void device_release_driver(struct device * dev)
+{
+	struct device_driver * drv;
+
+	down(&dev->sem);
+	drv = dev->driver;
+	if (drv) {
+		sysfs_remove_link(&drv->kobj, kobject_name(&dev->kobj));
+		sysfs_remove_link(&dev->kobj, "driver");
+		list_del_init(&dev->driver_list);
+		if (drv->remove)
+			drv->remove(dev);
+		dev->driver = NULL;
+	}
+	up(&dev->sem);
+}
+
+/**
+ * driver_detach - detach driver from all devices it controls.
+ * @drv: driver.
+ */
+void driver_detach(struct device_driver * drv)
+{
+	while (!list_empty(&drv->devices)) {
+		struct device * dev = container_of(drv->devices.next, struct device, driver_list);
+		device_release_driver(dev);
+	}
+}
+
+
+EXPORT_SYMBOL_GPL(driver_probe_device);
+EXPORT_SYMBOL_GPL(device_bind_driver);
+EXPORT_SYMBOL_GPL(device_release_driver);
+EXPORT_SYMBOL_GPL(device_attach);
+EXPORT_SYMBOL_GPL(driver_attach);
+
