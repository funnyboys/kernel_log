commit 7c1ef338705fb5c53e6f574ae5eb19fdfacb3d26
Author: Gabriel Krisman Bertazi <krisman@collabora.com>
Date:   Mon Jan 6 13:58:15 2020 -0500

    scsi: drivers: base: Support atomic version of attribute_container_device_trigger
    
    attribute_container_device_trigger invokes callbacks that may fail for one
    or more classdevs, for instance, the transport_add_class_device callback,
    called during transport creation, does memory allocation.  This
    information, though, is not propagated to upper layers, and any driver
    using the attribute_container_device_trigger API will not know whether any,
    some, or all callbacks succeeded.
    
    This patch implements a safe version of this dispatcher, to either succeed
    all the callbacks or revert to the original state.
    
    Link: https://lore.kernel.org/r/20200106185817.640331-2-krisman@collabora.com
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 20736aaa0e69..f7bd0f4db13d 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -236,6 +236,109 @@ attribute_container_remove_device(struct device *dev,
 	mutex_unlock(&attribute_container_mutex);
 }
 
+static int
+do_attribute_container_device_trigger_safe(struct device *dev,
+					   struct attribute_container *cont,
+					   int (*fn)(struct attribute_container *,
+						     struct device *, struct device *),
+					   int (*undo)(struct attribute_container *,
+						       struct device *, struct device *))
+{
+	int ret;
+	struct internal_container *ic, *failed;
+	struct klist_iter iter;
+
+	if (attribute_container_no_classdevs(cont))
+		return fn(cont, dev, NULL);
+
+	klist_for_each_entry(ic, &cont->containers, node, &iter) {
+		if (dev == ic->classdev.parent) {
+			ret = fn(cont, dev, &ic->classdev);
+			if (ret) {
+				failed = ic;
+				klist_iter_exit(&iter);
+				goto fail;
+			}
+		}
+	}
+	return 0;
+
+fail:
+	if (!undo)
+		return ret;
+
+	/* Attempt to undo the work partially done. */
+	klist_for_each_entry(ic, &cont->containers, node, &iter) {
+		if (ic == failed) {
+			klist_iter_exit(&iter);
+			break;
+		}
+		if (dev == ic->classdev.parent)
+			undo(cont, dev, &ic->classdev);
+	}
+	return ret;
+}
+
+/**
+ * attribute_container_device_trigger_safe - execute a trigger for each
+ * matching classdev or fail all of them.
+ *
+ * @dev:  The generic device to run the trigger for
+ * @fn	  the function to execute for each classdev.
+ * @undo  A function to undo the work previously done in case of error
+ *
+ * This function is a safe version of
+ * attribute_container_device_trigger. It stops on the first error and
+ * undo the partial work that has been done, on previous classdev.  It
+ * is guaranteed that either they all succeeded, or none of them
+ * succeeded.
+ */
+int
+attribute_container_device_trigger_safe(struct device *dev,
+					int (*fn)(struct attribute_container *,
+						  struct device *,
+						  struct device *),
+					int (*undo)(struct attribute_container *,
+						    struct device *,
+						    struct device *))
+{
+	struct attribute_container *cont, *failed = NULL;
+	int ret = 0;
+
+	mutex_lock(&attribute_container_mutex);
+
+	list_for_each_entry(cont, &attribute_container_list, node) {
+
+		if (!cont->match(cont, dev))
+			continue;
+
+		ret = do_attribute_container_device_trigger_safe(dev, cont,
+								 fn, undo);
+		if (ret) {
+			failed = cont;
+			break;
+		}
+	}
+
+	if (ret && !WARN_ON(!undo)) {
+		list_for_each_entry(cont, &attribute_container_list, node) {
+
+			if (failed == cont)
+				break;
+
+			if (!cont->match(cont, dev))
+				continue;
+
+			do_attribute_container_device_trigger_safe(dev, cont,
+								   undo, NULL);
+		}
+	}
+
+	mutex_unlock(&attribute_container_mutex);
+	return ret;
+
+}
+
 /**
  * attribute_container_device_trigger - execute a trigger for each matching classdev
  *

commit 328257099077e8affd438c179d8a938948de2e7f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:09 2017 +0100

    driver core: Remove redundant license text
    
    Now that the SPDX tag is in all driver core files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 218b9deb4f0b..20736aaa0e69 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -4,8 +4,6 @@
  *
  * Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>
  *
- * This file is licensed under GPLv2
- *
  * The basic idea here is to enable a device to be attached to an
  * aritrary numer of classes without having to allocate storage for them.
  * Instead, the contained classes select the devices they need to attach

commit 989d42e85dc2f6823f39b8e9d080fd04bae0645d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:07 2017 +0100

    driver core: add SPDX identifiers to all driver core files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the driver core files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 95e3ef82f3b7..218b9deb4f0b 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * attribute_container.c - implementation of a simple container for classes
  *

commit 03aca7b260ea2aadf92596d2f57160e4aee8ffb0
Author: Xiubo Li <lixiubo@cmss.chinamobile.com>
Date:   Wed Jun 1 09:18:40 2016 +0800

    attribute_container: Fix typo
    
    The 't' in "function" was missing, this patch fixes this typo:
    s/funcion/function/g
    
    Signed-off-by: Xiubo Li <lixiubo@cmss.chinamobile.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 2ba4cac080c5..95e3ef82f3b7 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -243,7 +243,7 @@ attribute_container_remove_device(struct device *dev,
  * @dev:  The generic device to run the trigger for
  * @fn	  the function to execute for each classdev.
  *
- * This funcion is for executing a trigger when you need to know both
+ * This function is for executing a trigger when you need to know both
  * the container and the classdev.  If you only care about the
  * container, then use attribute_container_trigger() instead.
  */

commit 481026dbe88bd42cae88ade3289f26d16e5168aa
Author: Cosmin Dragomir <cosmin.gabriel.dragomir@gmail.com>
Date:   Sun Mar 8 12:30:14 2015 +0200

    attribute_container: fix missing blank lines after declarations
    
    Found with checkpatch.pl
    
    Signed-off-by: Cosmin Dragomir <cosmin.gabriel.dragomir@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 3ead3af4be61..2ba4cac080c5 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -94,6 +94,7 @@ int
 attribute_container_unregister(struct attribute_container *cont)
 {
 	int retval = -EBUSY;
+
 	mutex_lock(&attribute_container_mutex);
 	spin_lock(&cont->containers.k_lock);
 	if (!list_empty(&cont->containers.k_list))
@@ -349,6 +350,7 @@ int
 attribute_container_add_class_device(struct device *classdev)
 {
 	int error = device_add(classdev);
+
 	if (error)
 		return error;
 	return attribute_container_add_attrs(classdev);

commit 287f9bd9325b982ed19371697d4af7032c5a3b0b
Author: Tina Johnson <tinajohnson.1234@gmail.com>
Date:   Tue Aug 12 02:54:09 2014 +0530

    attribute_container: fix coding style issues
    
    Fix checkpatch.pl issues with coding style. Added and removed spaces
    accordingly.
    
    Signed-off-by: Tina Johnson <tinajohnson.1234@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 5917cc3d603a..3ead3af4be61 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -74,7 +74,7 @@ int
 attribute_container_register(struct attribute_container *cont)
 {
 	INIT_LIST_HEAD(&cont->node);
-	klist_init(&cont->containers,internal_container_klist_get,
+	klist_init(&cont->containers, internal_container_klist_get,
 		   internal_container_klist_put);
 
 	mutex_lock(&attribute_container_mutex);
@@ -184,7 +184,7 @@ attribute_container_add_device(struct device *dev,
 		struct klist_node *n = klist_next(iter); \
 		n ? container_of(n, typeof(*pos), member) : \
 			({ klist_iter_exit(iter) ; NULL; }); \
-	}) ) != NULL; )
+	})) != NULL;)
 
 
 /**

commit 24a7d36a7260a30b8477d1fe0335c87ad846ed56
Author: Tina Johnson <tinajohnson.1234@gmail.com>
Date:   Tue Aug 12 02:54:08 2014 +0530

    attribute_container: fix whitespace errors
    
    This is a clean-up patch to the attribute_container.c file to fix
    the whitespace errors.
    
    Signed-off-by: Tina Johnson <tinajohnson.1234@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index b84ca8f13f9e..5917cc3d603a 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -76,7 +76,7 @@ attribute_container_register(struct attribute_container *cont)
 	INIT_LIST_HEAD(&cont->node);
 	klist_init(&cont->containers,internal_container_klist_get,
 		   internal_container_klist_put);
-		
+
 	mutex_lock(&attribute_container_mutex);
 	list_add_tail(&cont->node, &attribute_container_list);
 	mutex_unlock(&attribute_container_mutex);
@@ -104,14 +104,14 @@ attribute_container_unregister(struct attribute_container *cont)
 	spin_unlock(&cont->containers.k_lock);
 	mutex_unlock(&attribute_container_mutex);
 	return retval;
-		
+
 }
 EXPORT_SYMBOL_GPL(attribute_container_unregister);
 
 /* private function used as class release */
 static void attribute_container_release(struct device *classdev)
 {
-	struct internal_container *ic 
+	struct internal_container *ic
 		= container_of(classdev, struct internal_container, classdev);
 	struct device *dev = classdev->parent;
 
@@ -185,7 +185,7 @@ attribute_container_add_device(struct device *dev,
 		n ? container_of(n, typeof(*pos), member) : \
 			({ klist_iter_exit(iter) ; NULL; }); \
 	}) ) != NULL; )
-			
+
 
 /**
  * attribute_container_remove_device - make device eligible for removal.
@@ -247,7 +247,7 @@ attribute_container_remove_device(struct device *dev,
  * container, then use attribute_container_trigger() instead.
  */
 void
-attribute_container_device_trigger(struct device *dev, 
+attribute_container_device_trigger(struct device *dev,
 				   int (*fn)(struct attribute_container *,
 					     struct device *,
 					     struct device *))

commit 4272b9611c30f99f51590085998129480f2fe45e
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:23:10 2014 -0500

    drivers/base: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: Len Brown <len.brown@intel.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index ecc1929d7f6a..b84ca8f13f9e 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -12,7 +12,6 @@
  */
 
 #include <linux/attribute_container.h>
-#include <linux/init.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>

commit 02aa2a37636c8fa4fb9322d91be46ff8225b7de0
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 3 15:04:56 2013 -0700

    drivers: avoid format string in dev_set_name
    
    Calling dev_set_name with a single paramter causes it to be handled as a
    format string.  Many callers are passing potentially dynamic string
    content, so use "%s" in those cases to avoid any potential accidents,
    including wrappers like device_create*() and bdi_register().
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index d78b204e65c1..ecc1929d7f6a 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -167,7 +167,7 @@ attribute_container_add_device(struct device *dev,
 		ic->classdev.parent = get_device(dev);
 		ic->classdev.class = cont->class;
 		cont->class->dev_release = attribute_container_release;
-		dev_set_name(&ic->classdev, dev_name(dev));
+		dev_set_name(&ic->classdev, "%s", dev_name(dev));
 		if (fn)
 			fn(cont, dev, &ic->classdev);
 		else

commit a369a7ebbfce5caa38e3d5645ea050f4590dea7a
Author: Joe Perches <joe@perches.com>
Date:   Sun Oct 28 01:05:41 2012 -0700

    drivers: base: Convert dev_printk(KERN_<LEVEL> to dev_<level>(
    
    dev_<level> calls take less code than dev_printk(KERN_<LEVEL>
    and reducing object size is good.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 8fc200b2e2c0..d78b204e65c1 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -158,7 +158,7 @@ attribute_container_add_device(struct device *dev,
 
 		ic = kzalloc(sizeof(*ic), GFP_KERNEL);
 		if (!ic) {
-			dev_printk(KERN_ERR, dev, "failed to allocate class container\n");
+			dev_err(dev, "failed to allocate class container\n");
 			continue;
 		}
 

commit ebd09ec93c90c8ec571d7e166832fb1fc705bf5e
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Sat Mar 20 12:44:12 2010 -0500

    [SCSI] attirbute_container: Initialize sysfs attributes with sysfs_attr_init
    
    All of the SCSI transport classes are suddenly spitting lockdep
    warnings.  According to Eric Biderman this is because lockdep needs
    static initialisers and the attribute container way of doing things
    end up with dynamic sysfs attributes.  Fix this by calling
    sysfs_attr_init which sets the lockdep key correctly.
    
    Tested-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index b9cda053d3c0..8fc200b2e2c0 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -328,6 +328,7 @@ attribute_container_add_attrs(struct device *classdev)
 		return sysfs_create_group(&classdev->kobj, cont->grp);
 
 	for (i = 0; attrs[i]; i++) {
+		sysfs_attr_init(&attrs[i]->attr);
 		error = device_create_file(classdev, attrs[i]);
 		if (error)
 			return error;

commit 1e0b2cf933ebf32494eba3f668859ba57f06a951
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:36:48 2008 +0100

    driver core: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index f57652db0a2a..b9cda053d3c0 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -167,7 +167,7 @@ attribute_container_add_device(struct device *dev,
 		ic->classdev.parent = get_device(dev);
 		ic->classdev.class = cont->class;
 		cont->class->dev_release = attribute_container_release;
-		strcpy(ic->classdev.bus_id, dev->bus_id);
+		dev_set_name(&ic->classdev, dev_name(dev));
 		if (fn)
 			fn(cont, dev, &ic->classdev);
 		else

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 3b43e8a9f87e..f57652db0a2a 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -27,21 +27,21 @@
 struct internal_container {
 	struct klist_node node;
 	struct attribute_container *cont;
-	struct class_device classdev;
+	struct device classdev;
 };
 
 static void internal_container_klist_get(struct klist_node *n)
 {
 	struct internal_container *ic =
 		container_of(n, struct internal_container, node);
-	class_device_get(&ic->classdev);
+	get_device(&ic->classdev);
 }
 
 static void internal_container_klist_put(struct klist_node *n)
 {
 	struct internal_container *ic =
 		container_of(n, struct internal_container, node);
-	class_device_put(&ic->classdev);
+	put_device(&ic->classdev);
 }
 
 
@@ -53,7 +53,7 @@ static void internal_container_klist_put(struct klist_node *n)
  * Returns the container associated with this classdev.
  */
 struct attribute_container *
-attribute_container_classdev_to_container(struct class_device *classdev)
+attribute_container_classdev_to_container(struct device *classdev)
 {
 	struct internal_container *ic =
 		container_of(classdev, struct internal_container, classdev);
@@ -110,11 +110,11 @@ attribute_container_unregister(struct attribute_container *cont)
 EXPORT_SYMBOL_GPL(attribute_container_unregister);
 
 /* private function used as class release */
-static void attribute_container_release(struct class_device *classdev)
+static void attribute_container_release(struct device *classdev)
 {
 	struct internal_container *ic 
 		= container_of(classdev, struct internal_container, classdev);
-	struct device *dev = classdev->dev;
+	struct device *dev = classdev->parent;
 
 	kfree(ic);
 	put_device(dev);
@@ -129,12 +129,12 @@ static void attribute_container_release(struct class_device *classdev)
  * This function allocates storage for the class device(s) to be
  * attached to dev (one for each matching attribute_container).  If no
  * fn is provided, the code will simply register the class device via
- * class_device_add.  If a function is provided, it is expected to add
+ * device_add.  If a function is provided, it is expected to add
  * the class device at the appropriate time.  One of the things that
  * might be necessary is to allocate and initialise the classdev and
  * then add it a later time.  To do this, call this routine for
  * allocation and initialisation and then use
- * attribute_container_device_trigger() to call class_device_add() on
+ * attribute_container_device_trigger() to call device_add() on
  * it.  Note: after this, the class device contains a reference to dev
  * which is not relinquished until the release of the classdev.
  */
@@ -142,7 +142,7 @@ void
 attribute_container_add_device(struct device *dev,
 			       int (*fn)(struct attribute_container *,
 					 struct device *,
-					 struct class_device *))
+					 struct device *))
 {
 	struct attribute_container *cont;
 
@@ -163,11 +163,11 @@ attribute_container_add_device(struct device *dev,
 		}
 
 		ic->cont = cont;
-		class_device_initialize(&ic->classdev);
-		ic->classdev.dev = get_device(dev);
+		device_initialize(&ic->classdev);
+		ic->classdev.parent = get_device(dev);
 		ic->classdev.class = cont->class;
-		cont->class->release = attribute_container_release;
-		strcpy(ic->classdev.class_id, dev->bus_id);
+		cont->class->dev_release = attribute_container_release;
+		strcpy(ic->classdev.bus_id, dev->bus_id);
 		if (fn)
 			fn(cont, dev, &ic->classdev);
 		else
@@ -195,20 +195,19 @@ attribute_container_add_device(struct device *dev,
  * @fn:	  A function to call to remove the device
  *
  * This routine triggers device removal.  If fn is NULL, then it is
- * simply done via class_device_unregister (note that if something
+ * simply done via device_unregister (note that if something
  * still has a reference to the classdev, then the memory occupied
  * will not be freed until the classdev is released).  If you want a
  * two phase release: remove from visibility and then delete the
  * device, then you should use this routine with a fn that calls
- * class_device_del() and then use
- * attribute_container_device_trigger() to do the final put on the
- * classdev.
+ * device_del() and then use attribute_container_device_trigger()
+ * to do the final put on the classdev.
  */
 void
 attribute_container_remove_device(struct device *dev,
 				  void (*fn)(struct attribute_container *,
 					     struct device *,
-					     struct class_device *))
+					     struct device *))
 {
 	struct attribute_container *cont;
 
@@ -224,14 +223,14 @@ attribute_container_remove_device(struct device *dev,
 			continue;
 
 		klist_for_each_entry(ic, &cont->containers, node, &iter) {
-			if (dev != ic->classdev.dev)
+			if (dev != ic->classdev.parent)
 				continue;
 			klist_del(&ic->node);
 			if (fn)
 				fn(cont, dev, &ic->classdev);
 			else {
 				attribute_container_remove_attrs(&ic->classdev);
-				class_device_unregister(&ic->classdev);
+				device_unregister(&ic->classdev);
 			}
 		}
 	}
@@ -252,7 +251,7 @@ void
 attribute_container_device_trigger(struct device *dev, 
 				   int (*fn)(struct attribute_container *,
 					     struct device *,
-					     struct class_device *))
+					     struct device *))
 {
 	struct attribute_container *cont;
 
@@ -270,7 +269,7 @@ attribute_container_device_trigger(struct device *dev,
 		}
 
 		klist_for_each_entry(ic, &cont->containers, node, &iter) {
-			if (dev == ic->classdev.dev)
+			if (dev == ic->classdev.parent)
 				fn(cont, dev, &ic->classdev);
 		}
 	}
@@ -313,11 +312,11 @@ attribute_container_trigger(struct device *dev,
  * attributes listed in the container
  */
 int
-attribute_container_add_attrs(struct class_device *classdev)
+attribute_container_add_attrs(struct device *classdev)
 {
 	struct attribute_container *cont =
 		attribute_container_classdev_to_container(classdev);
-	struct class_device_attribute **attrs =	cont->attrs;
+	struct device_attribute **attrs = cont->attrs;
 	int i, error;
 
 	BUG_ON(attrs && cont->grp);
@@ -329,7 +328,7 @@ attribute_container_add_attrs(struct class_device *classdev)
 		return sysfs_create_group(&classdev->kobj, cont->grp);
 
 	for (i = 0; attrs[i]; i++) {
-		error = class_device_create_file(classdev, attrs[i]);
+		error = device_create_file(classdev, attrs[i]);
 		if (error)
 			return error;
 	}
@@ -338,18 +337,18 @@ attribute_container_add_attrs(struct class_device *classdev)
 }
 
 /**
- * attribute_container_add_class_device - same function as class_device_add
+ * attribute_container_add_class_device - same function as device_add
  *
  * @classdev:	the class device to add
  *
- * This performs essentially the same function as class_device_add except for
+ * This performs essentially the same function as device_add except for
  * attribute containers, namely add the classdev to the system and then
  * create the attribute files
  */
 int
-attribute_container_add_class_device(struct class_device *classdev)
+attribute_container_add_class_device(struct device *classdev)
 {
-	int error = class_device_add(classdev);
+	int error = device_add(classdev);
 	if (error)
 		return error;
 	return attribute_container_add_attrs(classdev);
@@ -364,7 +363,7 @@ attribute_container_add_class_device(struct class_device *classdev)
 int
 attribute_container_add_class_device_adapter(struct attribute_container *cont,
 					     struct device *dev,
-					     struct class_device *classdev)
+					     struct device *classdev)
 {
 	return attribute_container_add_class_device(classdev);
 }
@@ -376,11 +375,11 @@ attribute_container_add_class_device_adapter(struct attribute_container *cont,
  *
  */
 void
-attribute_container_remove_attrs(struct class_device *classdev)
+attribute_container_remove_attrs(struct device *classdev)
 {
 	struct attribute_container *cont =
 		attribute_container_classdev_to_container(classdev);
-	struct class_device_attribute **attrs =	cont->attrs;
+	struct device_attribute **attrs = cont->attrs;
 	int i;
 
 	if (!attrs && !cont->grp)
@@ -392,7 +391,7 @@ attribute_container_remove_attrs(struct class_device *classdev)
 	}
 
 	for (i = 0; attrs[i]; i++)
-		class_device_remove_file(classdev, attrs[i]);
+		device_remove_file(classdev, attrs[i]);
 }
 
 /**
@@ -401,13 +400,13 @@ attribute_container_remove_attrs(struct class_device *classdev)
  * @classdev: the class device
  *
  * This function simply removes all the attribute files and then calls
- * class_device_del.
+ * device_del.
  */
 void
-attribute_container_class_device_del(struct class_device *classdev)
+attribute_container_class_device_del(struct device *classdev)
 {
 	attribute_container_remove_attrs(classdev);
-	class_device_del(classdev);
+	device_del(classdev);
 }
 
 /**
@@ -419,16 +418,16 @@ attribute_container_class_device_del(struct class_device *classdev)
  * Looks up the device in the container's list of class devices and returns
  * the corresponding class_device.
  */
-struct class_device *
+struct device *
 attribute_container_find_class_device(struct attribute_container *cont,
 				      struct device *dev)
 {
-	struct class_device *cdev = NULL;
+	struct device *cdev = NULL;
 	struct internal_container *ic;
 	struct klist_iter iter;
 
 	klist_for_each_entry(ic, &cont->containers, node, &iter) {
-		if (ic->classdev.dev == dev) {
+		if (ic->classdev.parent == dev) {
 			cdev = &ic->classdev;
 			/* FIXME: must exit iterator then break */
 			klist_iter_exit(&iter);

commit 9b73e76f3cf63379dcf45fcd4f112f5812418d0a
Merge: 50d9a126240f 23c3e290fb9c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 25 17:19:08 2008 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (200 commits)
      [SCSI] usbstorage: use last_sector_bug flag universally
      [SCSI] libsas: abstract STP task status into a function
      [SCSI] ultrastor: clean up inline asm warnings
      [SCSI] aic7xxx: fix firmware build
      [SCSI] aacraid: fib context lock for management ioctls
      [SCSI] ch: remove forward declarations
      [SCSI] ch: fix device minor number management bug
      [SCSI] ch: handle class_device_create failure properly
      [SCSI] NCR5380: fix section mismatch
      [SCSI] sg: fix /proc/scsi/sg/devices when no SCSI devices
      [SCSI] IB/iSER: add logical unit reset support
      [SCSI] don't use __GFP_DMA for sense buffers if not required
      [SCSI] use dynamically allocated sense buffer
      [SCSI] scsi.h: add macro for enclosure bit of inquiry data
      [SCSI] sd: add fix for devices with last sector access problems
      [SCSI] fix pcmcia compile problem
      [SCSI] aacraid: add Voodoo Lite class of cards.
      [SCSI] aacraid: add new driver features flags
      [SCSI] qla2xxx: Update version number to 8.02.00-k7.
      [SCSI] qla2xxx: Issue correct MBC_INITIALIZE_FIRMWARE command.
      ...

commit db1118a460c7bfd20278955cbf56c0b283a9701f
Author: Denis Cheng <crquan@gmail.com>
Date:   Thu Dec 6 02:24:40 2007 +0800

    Driver core: use LIST_HEAD instead of call to INIT_LIST_HEAD in __init
    
    LIST_HEAD has been widely used, so switch to this simpler method.
    
    Signed-off-by: Denis Cheng <crquan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 7370d7cf5988..d4dfb97de3b0 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -61,7 +61,7 @@ attribute_container_classdev_to_container(struct class_device *classdev)
 }
 EXPORT_SYMBOL_GPL(attribute_container_classdev_to_container);
 
-static struct list_head attribute_container_list;
+static LIST_HEAD(attribute_container_list);
 
 static DEFINE_MUTEX(attribute_container_mutex);
 
@@ -429,10 +429,3 @@ attribute_container_find_class_device(struct attribute_container *cont,
 	return cdev;
 }
 EXPORT_SYMBOL_GPL(attribute_container_find_class_device);
-
-int __init
-attribute_container_init(void)
-{
-	INIT_LIST_HEAD(&attribute_container_list);
-	return 0;
-}

commit fd1109711d7f76126e7cef947999f139b198dc15
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Jan 2 18:48:47 2008 -0600

    [SCSI] attribute_container: update to use the group interface
    
    This patch is the beginning of moving the attribute_containers to use
    attribute groups exclusively.  The attr element is now deprecated and
    will eventually be removed (along with all the hand rolled code for
    doing exactly what attribute groups do) when all the consumers are
    converted to attribute groups.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 7370d7cf5988..5bf25c6f966c 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -320,9 +320,14 @@ attribute_container_add_attrs(struct class_device *classdev)
 	struct class_device_attribute **attrs =	cont->attrs;
 	int i, error;
 
-	if (!attrs)
+	BUG_ON(attrs && cont->grp);
+
+	if (!attrs && !cont->grp)
 		return 0;
 
+	if (cont->grp)
+		return sysfs_create_group(&classdev->kobj, cont->grp);
+
 	for (i = 0; attrs[i]; i++) {
 		error = class_device_create_file(classdev, attrs[i]);
 		if (error)
@@ -378,9 +383,14 @@ attribute_container_remove_attrs(struct class_device *classdev)
 	struct class_device_attribute **attrs =	cont->attrs;
 	int i;
 
-	if (!attrs)
+	if (!attrs && !cont->grp)
 		return;
 
+	if (cont->grp) {
+		sysfs_remove_group(&classdev->kobj, cont->grp);
+		return ;
+	}
+
 	for (i = 0; attrs[i]; i++)
 		class_device_remove_file(classdev, attrs[i]);
 }

commit f8916c11a4dc4cb2367e9bee1788f4e0f1b4eabc
Author: Michael S. Tsirkin <mst@dev.mellanox.co.il>
Date:   Sun Jun 10 22:39:12 2007 +0300

    Driver core: include linux/mutex.h from attribute_container.c
    
    attribute_container.c uses DEFINE_MUTEX, so while
    linux/mutex.h seems to be pulled in indirectly
    by one of the headers it includes, the right thing
    is to include linux/mutex.h directly.
    
    Signed-off-by: Michael S. Tsirkin <mst@dev.mellanox.co.il>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 1ec0654665cf..7370d7cf5988 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 
 #include "base.h"
 

commit 61a2f59af6c8ffd9d6dd53f0da32563d4434e790
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Thu Apr 26 00:12:09 2007 -0700

    drivers/base/attribute_container.c: use mutex instead of binary semaphore
    
    use mutex instead of binary semaphore in
    drivers/base/attribute_container.c
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 22220733f76f..1ec0654665cf 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -62,7 +62,7 @@ EXPORT_SYMBOL_GPL(attribute_container_classdev_to_container);
 
 static struct list_head attribute_container_list;
 
-static DECLARE_MUTEX(attribute_container_mutex);
+static DEFINE_MUTEX(attribute_container_mutex);
 
 /**
  * attribute_container_register - register an attribute container
@@ -77,9 +77,9 @@ attribute_container_register(struct attribute_container *cont)
 	klist_init(&cont->containers,internal_container_klist_get,
 		   internal_container_klist_put);
 		
-	down(&attribute_container_mutex);
+	mutex_lock(&attribute_container_mutex);
 	list_add_tail(&cont->node, &attribute_container_list);
-	up(&attribute_container_mutex);
+	mutex_unlock(&attribute_container_mutex);
 
 	return 0;
 }
@@ -94,7 +94,7 @@ int
 attribute_container_unregister(struct attribute_container *cont)
 {
 	int retval = -EBUSY;
-	down(&attribute_container_mutex);
+	mutex_lock(&attribute_container_mutex);
 	spin_lock(&cont->containers.k_lock);
 	if (!list_empty(&cont->containers.k_list))
 		goto out;
@@ -102,7 +102,7 @@ attribute_container_unregister(struct attribute_container *cont)
 	list_del(&cont->node);
  out:
 	spin_unlock(&cont->containers.k_lock);
-	up(&attribute_container_mutex);
+	mutex_unlock(&attribute_container_mutex);
 	return retval;
 		
 }
@@ -145,7 +145,7 @@ attribute_container_add_device(struct device *dev,
 {
 	struct attribute_container *cont;
 
-	down(&attribute_container_mutex);
+	mutex_lock(&attribute_container_mutex);
 	list_for_each_entry(cont, &attribute_container_list, node) {
 		struct internal_container *ic;
 
@@ -173,7 +173,7 @@ attribute_container_add_device(struct device *dev,
 			attribute_container_add_class_device(&ic->classdev);
 		klist_add_tail(&ic->node, &cont->containers);
 	}
-	up(&attribute_container_mutex);
+	mutex_unlock(&attribute_container_mutex);
 }
 
 /* FIXME: can't break out of this unless klist_iter_exit is also
@@ -211,7 +211,7 @@ attribute_container_remove_device(struct device *dev,
 {
 	struct attribute_container *cont;
 
-	down(&attribute_container_mutex);
+	mutex_lock(&attribute_container_mutex);
 	list_for_each_entry(cont, &attribute_container_list, node) {
 		struct internal_container *ic;
 		struct klist_iter iter;
@@ -234,7 +234,7 @@ attribute_container_remove_device(struct device *dev,
 			}
 		}
 	}
-	up(&attribute_container_mutex);
+	mutex_unlock(&attribute_container_mutex);
 }
 
 /**
@@ -255,7 +255,7 @@ attribute_container_device_trigger(struct device *dev,
 {
 	struct attribute_container *cont;
 
-	down(&attribute_container_mutex);
+	mutex_lock(&attribute_container_mutex);
 	list_for_each_entry(cont, &attribute_container_list, node) {
 		struct internal_container *ic;
 		struct klist_iter iter;
@@ -273,7 +273,7 @@ attribute_container_device_trigger(struct device *dev,
 				fn(cont, dev, &ic->classdev);
 		}
 	}
-	up(&attribute_container_mutex);
+	mutex_unlock(&attribute_container_mutex);
 }
 
 /**
@@ -295,12 +295,12 @@ attribute_container_trigger(struct device *dev,
 {
 	struct attribute_container *cont;
 
-	down(&attribute_container_mutex);
+	mutex_lock(&attribute_container_mutex);
 	list_for_each_entry(cont, &attribute_container_list, node) {
 		if (cont->match(cont, dev))
 			fn(cont, dev);
 	}
-	up(&attribute_container_mutex);
+	mutex_unlock(&attribute_container_mutex);
 }
 
 /**

commit 1740757e8f94c6899705eb6f5434de9404992778
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 2 16:59:59 2006 +0200

    [PATCH] Driver Core: remove unused exports
    
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 2a7d7ae83e1e..22220733f76f 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -236,7 +236,6 @@ attribute_container_remove_device(struct device *dev,
 	}
 	up(&attribute_container_mutex);
 }
-EXPORT_SYMBOL_GPL(attribute_container_remove_device);
 
 /**
  * attribute_container_device_trigger - execute a trigger for each matching classdev
@@ -276,7 +275,6 @@ attribute_container_device_trigger(struct device *dev,
 	}
 	up(&attribute_container_mutex);
 }
-EXPORT_SYMBOL_GPL(attribute_container_device_trigger);
 
 /**
  * attribute_container_trigger - trigger a function for each matching container
@@ -304,7 +302,6 @@ attribute_container_trigger(struct device *dev,
 	}
 	up(&attribute_container_mutex);
 }
-EXPORT_SYMBOL_GPL(attribute_container_trigger);
 
 /**
  * attribute_container_add_attrs - add attributes
@@ -333,7 +330,6 @@ attribute_container_add_attrs(struct class_device *classdev)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(attribute_container_add_attrs);
 
 /**
  * attribute_container_add_class_device - same function as class_device_add
@@ -352,7 +348,6 @@ attribute_container_add_class_device(struct class_device *classdev)
 		return error;
 	return attribute_container_add_attrs(classdev);
 }
-EXPORT_SYMBOL_GPL(attribute_container_add_class_device);
 
 /**
  * attribute_container_add_class_device_adapter - simple adapter for triggers
@@ -367,7 +362,6 @@ attribute_container_add_class_device_adapter(struct attribute_container *cont,
 {
 	return attribute_container_add_class_device(classdev);
 }
-EXPORT_SYMBOL_GPL(attribute_container_add_class_device_adapter);
 
 /**
  * attribute_container_remove_attrs - remove any attribute files
@@ -389,7 +383,6 @@ attribute_container_remove_attrs(struct class_device *classdev)
 	for (i = 0; attrs[i]; i++)
 		class_device_remove_file(classdev, attrs[i]);
 }
-EXPORT_SYMBOL_GPL(attribute_container_remove_attrs);
 
 /**
  * attribute_container_class_device_del - equivalent of class_device_del
@@ -405,7 +398,6 @@ attribute_container_class_device_del(struct class_device *classdev)
 	attribute_container_remove_attrs(classdev);
 	class_device_del(classdev);
 }
-EXPORT_SYMBOL_GPL(attribute_container_class_device_del);
 
 /**
  * attribute_container_find_class_device - find the corresponding class_device

commit a1bdc7aad8b557176ccecff1da137ebe3090871e
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Thu Oct 13 17:54:41 2005 +0100

    [PATCH] drivers/base - fix sparse warnings
    
    There are a number of sparse warnings from the latest sparse
    snapshot being generated from the drivers/base build. The
    main culprits are due to the initialisation functions not
    being declared in a header file.
    
    Also, the firmware.c file should include <linux/device.h>
    to get the prototype of  firmware_register() and
    firmware_unregister().
    
    This patch moves the init function declerations from the
    init.c file to the base.h, and ensures it is included in
    all the relevant c sources. It also adds <linux/device.h>
    to the included headers for firmware.c.
    
    The patch does not solve all the sparse errors generated,
    but reduces the count significantly.
    
    drivers/base/core.c:161:1: warning: symbol 'devices_subsys' was not declared. Should it be static?
    drivers/base/core.c:417:12: warning: symbol 'devices_init' was not declared. Should it be static?
    drivers/base/sys.c:253:6: warning: symbol 'sysdev_shutdown' was not declared. Should it be static?
    drivers/base/sys.c:326:5: warning: symbol 'sysdev_suspend' was not declared. Should it be static?
    drivers/base/sys.c:428:5: warning: symbol 'sysdev_resume' was not declared. Should it be static?
    drivers/base/sys.c:450:12: warning: symbol 'system_bus_init' was not declared. Should it be static?
    drivers/base/bus.c:133:1: warning: symbol 'bus_subsys' was not declared. Should it be static?
    drivers/base/bus.c:667:12: warning: symbol 'buses_init' was not declared. Should it be static?
    drivers/base/class.c:759:12: warning: symbol 'classes_init' was not declared. Should it be static?
    drivers/base/platform.c:313:12: warning: symbol 'platform_bus_init' was not declared. Should it be static?
    drivers/base/cpu.c:110:12: warning: symbol 'cpu_dev_init' was not declared. Should it be static?
    drivers/base/firmware.c:17:5: warning: symbol 'firmware_register' was not declared. Should it be static?
    drivers/base/firmware.c:23:6: warning: symbol 'firmware_unregister' was not declared. Should it be static?
    drivers/base/firmware.c:28:12: warning: symbol 'firmware_init' was not declared. Should it be static?
    drivers/base/init.c:28:13: warning: symbol 'driver_init' was not declared. Should it be static?
    drivers/base/dmapool.c:174:10: warning: implicit cast from nocast type
    drivers/base/attribute_container.c:439:1: warning: symbol 'attribute_container_init' was not declared. Should it be static?
    drivers/base/power/runtime.c:76:6: warning: symbol 'dpm_set_power_state' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 6b2eb6f39b4d..2a7d7ae83e1e 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -19,6 +19,8 @@
 #include <linux/list.h>
 #include <linux/module.h>
 
+#include "base.h"
+
 /* This is a private structure used to tie the classdev and the
  * container .. it should never be visible outside this file */
 struct internal_container {

commit 4aed0644d684428e811bb6944f032b460a3ab165
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Tue Sep 13 01:25:01 2005 -0700

    [PATCH] drivers/base/*: use kzalloc instead of kmalloc+memset
    
    Fixes a bunch of memset bugs too.
    
    Signed-off-by: Lion Vollnhals <webmaster@schiggl.de>
    Signed-off-by: Jiri Slaby <xslaby@fi.muni.cz>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 373e7b728fa7..6b2eb6f39b4d 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -152,12 +152,13 @@ attribute_container_add_device(struct device *dev,
 
 		if (!cont->match(cont, dev))
 			continue;
-		ic = kmalloc(sizeof(struct internal_container), GFP_KERNEL);
+
+		ic = kzalloc(sizeof(*ic), GFP_KERNEL);
 		if (!ic) {
 			dev_printk(KERN_ERR, dev, "failed to allocate class container\n");
 			continue;
 		}
-		memset(ic, 0, sizeof(struct internal_container));
+
 		ic->cont = cont;
 		class_device_initialize(&ic->classdev);
 		ic->classdev.dev = get_device(dev);

commit caf39e87cc1182f7dae84eefc43ca14d54c78ef9
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Sep 7 18:44:33 2005 -0700

    [SCSI] Re-do "final klist fixes"
    
    With the previous commit that introduces the klist enhancements, we can
    now re-do 2b7d6a8cb9718fc1d9e826201b64909c44a915f4 again.

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 6c0f49340eb2..373e7b728fa7 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -27,6 +27,21 @@ struct internal_container {
 	struct class_device classdev;
 };
 
+static void internal_container_klist_get(struct klist_node *n)
+{
+	struct internal_container *ic =
+		container_of(n, struct internal_container, node);
+	class_device_get(&ic->classdev);
+}
+
+static void internal_container_klist_put(struct klist_node *n)
+{
+	struct internal_container *ic =
+		container_of(n, struct internal_container, node);
+	class_device_put(&ic->classdev);
+}
+
+
 /**
  * attribute_container_classdev_to_container - given a classdev, return the container
  *
@@ -57,7 +72,8 @@ int
 attribute_container_register(struct attribute_container *cont)
 {
 	INIT_LIST_HEAD(&cont->node);
-	klist_init(&cont->containers);
+	klist_init(&cont->containers,internal_container_klist_get,
+		   internal_container_klist_put);
 		
 	down(&attribute_container_mutex);
 	list_add_tail(&cont->node, &attribute_container_list);
@@ -163,8 +179,8 @@ attribute_container_add_device(struct device *dev,
 #define klist_for_each_entry(pos, head, member, iter) \
 	for (klist_iter_init(head, iter); (pos = ({ \
 		struct klist_node *n = klist_next(iter); \
-		n ? ({ klist_iter_exit(iter) ; NULL; }) : \
-			container_of(n, typeof(*pos), member);\
+		n ? container_of(n, typeof(*pos), member) : \
+			({ klist_iter_exit(iter) ; NULL; }); \
 	}) ) != NULL; )
 			
 
@@ -206,7 +222,7 @@ attribute_container_remove_device(struct device *dev,
 		klist_for_each_entry(ic, &cont->containers, node, &iter) {
 			if (dev != ic->classdev.dev)
 				continue;
-			klist_remove(&ic->node);
+			klist_del(&ic->node);
 			if (fn)
 				fn(cont, dev, &ic->classdev);
 			else {

commit df4edad1787bbfa3c9c10824e4f11e9f4a7ec5c6
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Sep 7 17:50:58 2005 -0700

    [SCSI] Revert "final klist fixes"
    
    Revert commit 2b7d6a8cb9718fc1d9e826201b64909c44a915f4.
    
    The "fix" was known to not even compile.  Duh.  That's not a fix.
    That's just stupid.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 373e7b728fa7..6c0f49340eb2 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -27,21 +27,6 @@ struct internal_container {
 	struct class_device classdev;
 };
 
-static void internal_container_klist_get(struct klist_node *n)
-{
-	struct internal_container *ic =
-		container_of(n, struct internal_container, node);
-	class_device_get(&ic->classdev);
-}
-
-static void internal_container_klist_put(struct klist_node *n)
-{
-	struct internal_container *ic =
-		container_of(n, struct internal_container, node);
-	class_device_put(&ic->classdev);
-}
-
-
 /**
  * attribute_container_classdev_to_container - given a classdev, return the container
  *
@@ -72,8 +57,7 @@ int
 attribute_container_register(struct attribute_container *cont)
 {
 	INIT_LIST_HEAD(&cont->node);
-	klist_init(&cont->containers,internal_container_klist_get,
-		   internal_container_klist_put);
+	klist_init(&cont->containers);
 		
 	down(&attribute_container_mutex);
 	list_add_tail(&cont->node, &attribute_container_list);
@@ -179,8 +163,8 @@ attribute_container_add_device(struct device *dev,
 #define klist_for_each_entry(pos, head, member, iter) \
 	for (klist_iter_init(head, iter); (pos = ({ \
 		struct klist_node *n = klist_next(iter); \
-		n ? container_of(n, typeof(*pos), member) : \
-			({ klist_iter_exit(iter) ; NULL; }); \
+		n ? ({ klist_iter_exit(iter) ; NULL; }) : \
+			container_of(n, typeof(*pos), member);\
 	}) ) != NULL; )
 			
 
@@ -222,7 +206,7 @@ attribute_container_remove_device(struct device *dev,
 		klist_for_each_entry(ic, &cont->containers, node, &iter) {
 			if (dev != ic->classdev.dev)
 				continue;
-			klist_del(&ic->node);
+			klist_remove(&ic->node);
 			if (fn)
 				fn(cont, dev, &ic->classdev);
 			else {

commit 2b7d6a8cb9718fc1d9e826201b64909c44a915f4
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Aug 28 09:13:17 2005 -0500

    [SCSI] attribute container final klist fixes
    
    Since the attribute container deletes from a klist while it's walking
    it, it is vulnerable to the problem (and fix) here:
    
    http://marc.theaimsgroup.com/?l=linux-scsi&m=112485448830217
    
    The attached fixes this (but won't compile without the above).
    
    It also fixes the logical reversal in the traversal loop which meant
    that we were never actually traversing the loop to hit this bug in the
    first place.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 6c0f49340eb2..373e7b728fa7 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -27,6 +27,21 @@ struct internal_container {
 	struct class_device classdev;
 };
 
+static void internal_container_klist_get(struct klist_node *n)
+{
+	struct internal_container *ic =
+		container_of(n, struct internal_container, node);
+	class_device_get(&ic->classdev);
+}
+
+static void internal_container_klist_put(struct klist_node *n)
+{
+	struct internal_container *ic =
+		container_of(n, struct internal_container, node);
+	class_device_put(&ic->classdev);
+}
+
+
 /**
  * attribute_container_classdev_to_container - given a classdev, return the container
  *
@@ -57,7 +72,8 @@ int
 attribute_container_register(struct attribute_container *cont)
 {
 	INIT_LIST_HEAD(&cont->node);
-	klist_init(&cont->containers);
+	klist_init(&cont->containers,internal_container_klist_get,
+		   internal_container_klist_put);
 		
 	down(&attribute_container_mutex);
 	list_add_tail(&cont->node, &attribute_container_list);
@@ -163,8 +179,8 @@ attribute_container_add_device(struct device *dev,
 #define klist_for_each_entry(pos, head, member, iter) \
 	for (klist_iter_init(head, iter); (pos = ({ \
 		struct klist_node *n = klist_next(iter); \
-		n ? ({ klist_iter_exit(iter) ; NULL; }) : \
-			container_of(n, typeof(*pos), member);\
+		n ? container_of(n, typeof(*pos), member) : \
+			({ klist_iter_exit(iter) ; NULL; }); \
 	}) ) != NULL; )
 			
 
@@ -206,7 +222,7 @@ attribute_container_remove_device(struct device *dev,
 		klist_for_each_entry(ic, &cont->containers, node, &iter) {
 			if (dev != ic->classdev.dev)
 				continue;
-			klist_remove(&ic->node);
+			klist_del(&ic->node);
 			if (fn)
 				fn(cont, dev, &ic->classdev);
 			else {

commit 53c165e0a6c8a4ff7df316557528fa7a52d20711
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Aug 22 10:06:19 2005 -0500

    [SCSI] correct attribute_container list usage
    
    One of the changes in the attribute_container code in the scsi-misc tree
    was to add a lock to protect the list of devices per container.  This,
    unfortunately, leads to potential scheduling while atomic problems if
    there's a sleep in the function called by a trigger.
    
    The correct solution is to use the kernel klist infrastructure instead
    which allows lockless traversal of a list.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index ebcae5c34133..6c0f49340eb2 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -22,7 +22,7 @@
 /* This is a private structure used to tie the classdev and the
  * container .. it should never be visible outside this file */
 struct internal_container {
-	struct list_head node;
+	struct klist_node node;
 	struct attribute_container *cont;
 	struct class_device classdev;
 };
@@ -57,8 +57,7 @@ int
 attribute_container_register(struct attribute_container *cont)
 {
 	INIT_LIST_HEAD(&cont->node);
-	INIT_LIST_HEAD(&cont->containers);
-	spin_lock_init(&cont->containers_lock);
+	klist_init(&cont->containers);
 		
 	down(&attribute_container_mutex);
 	list_add_tail(&cont->node, &attribute_container_list);
@@ -78,13 +77,13 @@ attribute_container_unregister(struct attribute_container *cont)
 {
 	int retval = -EBUSY;
 	down(&attribute_container_mutex);
-	spin_lock(&cont->containers_lock);
-	if (!list_empty(&cont->containers))
+	spin_lock(&cont->containers.k_lock);
+	if (!list_empty(&cont->containers.k_list))
 		goto out;
 	retval = 0;
 	list_del(&cont->node);
  out:
-	spin_unlock(&cont->containers_lock);
+	spin_unlock(&cont->containers.k_lock);
 	up(&attribute_container_mutex);
 	return retval;
 		
@@ -143,7 +142,6 @@ attribute_container_add_device(struct device *dev,
 			continue;
 		}
 		memset(ic, 0, sizeof(struct internal_container));
-		INIT_LIST_HEAD(&ic->node);
 		ic->cont = cont;
 		class_device_initialize(&ic->classdev);
 		ic->classdev.dev = get_device(dev);
@@ -154,13 +152,22 @@ attribute_container_add_device(struct device *dev,
 			fn(cont, dev, &ic->classdev);
 		else
 			attribute_container_add_class_device(&ic->classdev);
-		spin_lock(&cont->containers_lock);
-		list_add_tail(&ic->node, &cont->containers);
-		spin_unlock(&cont->containers_lock);
+		klist_add_tail(&ic->node, &cont->containers);
 	}
 	up(&attribute_container_mutex);
 }
 
+/* FIXME: can't break out of this unless klist_iter_exit is also
+ * called before doing the break
+ */
+#define klist_for_each_entry(pos, head, member, iter) \
+	for (klist_iter_init(head, iter); (pos = ({ \
+		struct klist_node *n = klist_next(iter); \
+		n ? ({ klist_iter_exit(iter) ; NULL; }) : \
+			container_of(n, typeof(*pos), member);\
+	}) ) != NULL; )
+			
+
 /**
  * attribute_container_remove_device - make device eligible for removal.
  *
@@ -187,18 +194,19 @@ attribute_container_remove_device(struct device *dev,
 
 	down(&attribute_container_mutex);
 	list_for_each_entry(cont, &attribute_container_list, node) {
-		struct internal_container *ic, *tmp;
+		struct internal_container *ic;
+		struct klist_iter iter;
 
 		if (attribute_container_no_classdevs(cont))
 			continue;
 
 		if (!cont->match(cont, dev))
 			continue;
-		spin_lock(&cont->containers_lock);
-		list_for_each_entry_safe(ic, tmp, &cont->containers, node) {
+
+		klist_for_each_entry(ic, &cont->containers, node, &iter) {
 			if (dev != ic->classdev.dev)
 				continue;
-			list_del(&ic->node);
+			klist_remove(&ic->node);
 			if (fn)
 				fn(cont, dev, &ic->classdev);
 			else {
@@ -206,7 +214,6 @@ attribute_container_remove_device(struct device *dev,
 				class_device_unregister(&ic->classdev);
 			}
 		}
-		spin_unlock(&cont->containers_lock);
 	}
 	up(&attribute_container_mutex);
 }
@@ -232,7 +239,8 @@ attribute_container_device_trigger(struct device *dev,
 
 	down(&attribute_container_mutex);
 	list_for_each_entry(cont, &attribute_container_list, node) {
-		struct internal_container *ic, *tmp;
+		struct internal_container *ic;
+		struct klist_iter iter;
 
 		if (!cont->match(cont, dev))
 			continue;
@@ -242,12 +250,10 @@ attribute_container_device_trigger(struct device *dev,
 			continue;
 		}
 
-		spin_lock(&cont->containers_lock);
-		list_for_each_entry_safe(ic, tmp, &cont->containers, node) {
+		klist_for_each_entry(ic, &cont->containers, node, &iter) {
 			if (dev == ic->classdev.dev)
 				fn(cont, dev, &ic->classdev);
 		}
-		spin_unlock(&cont->containers_lock);
 	}
 	up(&attribute_container_mutex);
 }
@@ -397,15 +403,16 @@ attribute_container_find_class_device(struct attribute_container *cont,
 {
 	struct class_device *cdev = NULL;
 	struct internal_container *ic;
+	struct klist_iter iter;
 
-	spin_lock(&cont->containers_lock);
-	list_for_each_entry(ic, &cont->containers, node) {
+	klist_for_each_entry(ic, &cont->containers, node, &iter) {
 		if (ic->classdev.dev == dev) {
 			cdev = &ic->classdev;
+			/* FIXME: must exit iterator then break */
+			klist_iter_exit(&iter);
 			break;
 		}
 	}
-	spin_unlock(&cont->containers_lock);
 
 	return cdev;
 }

commit ebd8bb7647e908e8654e565fa289b0300f9f8fa7
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Aug 15 16:13:19 2005 -0500

    [SCSI] fix transport class corner case after rework
    
    If your transport class sets the ATTRIBUTE_CONTAINER_NO_CLASSDEVS flag,
    then its configure method never gets called.  This patch fixes that so
    that the configure method is called with a NULL classdev.
    
    Also remove a spurious inverted comma in the transport_class comments.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index 62c093db11e6..ebcae5c34133 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -237,6 +237,11 @@ attribute_container_device_trigger(struct device *dev,
 		if (!cont->match(cont, dev))
 			continue;
 
+		if (attribute_container_no_classdevs(cont)) {
+			fn(cont, dev, NULL);
+			continue;
+		}
+
 		spin_lock(&cont->containers_lock);
 		list_for_each_entry_safe(ic, tmp, &cont->containers, node) {
 			if (dev == ic->classdev.dev)

commit d0a7e574007fd547d72ec693bfa35778623d0738
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Aug 14 17:09:01 2005 -0500

    [SCSI] correct transport class abstraction to work outside SCSI
    
    I recently tried to construct a totally generic transport class and
    found there were certain features missing from the current abstract
    transport class.  Most notable is that you have to hang the data on the
    class_device but most of the API is framed in terms of the generic
    device, not the class_device.
    
    These changes are two fold
    
    - Provide the class_device to all of the setup and configure APIs
    - Provide and extra API to take the device and the attribute class and
      return the corresponding class_device
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
index ec615d854be9..62c093db11e6 100644
--- a/drivers/base/attribute_container.c
+++ b/drivers/base/attribute_container.c
@@ -58,6 +58,7 @@ attribute_container_register(struct attribute_container *cont)
 {
 	INIT_LIST_HEAD(&cont->node);
 	INIT_LIST_HEAD(&cont->containers);
+	spin_lock_init(&cont->containers_lock);
 		
 	down(&attribute_container_mutex);
 	list_add_tail(&cont->node, &attribute_container_list);
@@ -77,11 +78,13 @@ attribute_container_unregister(struct attribute_container *cont)
 {
 	int retval = -EBUSY;
 	down(&attribute_container_mutex);
+	spin_lock(&cont->containers_lock);
 	if (!list_empty(&cont->containers))
 		goto out;
 	retval = 0;
 	list_del(&cont->node);
  out:
+	spin_unlock(&cont->containers_lock);
 	up(&attribute_container_mutex);
 	return retval;
 		
@@ -151,7 +154,9 @@ attribute_container_add_device(struct device *dev,
 			fn(cont, dev, &ic->classdev);
 		else
 			attribute_container_add_class_device(&ic->classdev);
+		spin_lock(&cont->containers_lock);
 		list_add_tail(&ic->node, &cont->containers);
+		spin_unlock(&cont->containers_lock);
 	}
 	up(&attribute_container_mutex);
 }
@@ -189,6 +194,7 @@ attribute_container_remove_device(struct device *dev,
 
 		if (!cont->match(cont, dev))
 			continue;
+		spin_lock(&cont->containers_lock);
 		list_for_each_entry_safe(ic, tmp, &cont->containers, node) {
 			if (dev != ic->classdev.dev)
 				continue;
@@ -200,6 +206,7 @@ attribute_container_remove_device(struct device *dev,
 				class_device_unregister(&ic->classdev);
 			}
 		}
+		spin_unlock(&cont->containers_lock);
 	}
 	up(&attribute_container_mutex);
 }
@@ -230,10 +237,12 @@ attribute_container_device_trigger(struct device *dev,
 		if (!cont->match(cont, dev))
 			continue;
 
+		spin_lock(&cont->containers_lock);
 		list_for_each_entry_safe(ic, tmp, &cont->containers, node) {
 			if (dev == ic->classdev.dev)
 				fn(cont, dev, &ic->classdev);
 		}
+		spin_unlock(&cont->containers_lock);
 	}
 	up(&attribute_container_mutex);
 }
@@ -368,6 +377,35 @@ attribute_container_class_device_del(struct class_device *classdev)
 }
 EXPORT_SYMBOL_GPL(attribute_container_class_device_del);
 
+/**
+ * attribute_container_find_class_device - find the corresponding class_device
+ *
+ * @cont:	the container
+ * @dev:	the generic device
+ *
+ * Looks up the device in the container's list of class devices and returns
+ * the corresponding class_device.
+ */
+struct class_device *
+attribute_container_find_class_device(struct attribute_container *cont,
+				      struct device *dev)
+{
+	struct class_device *cdev = NULL;
+	struct internal_container *ic;
+
+	spin_lock(&cont->containers_lock);
+	list_for_each_entry(ic, &cont->containers, node) {
+		if (ic->classdev.dev == dev) {
+			cdev = &ic->classdev;
+			break;
+		}
+	}
+	spin_unlock(&cont->containers_lock);
+
+	return cdev;
+}
+EXPORT_SYMBOL_GPL(attribute_container_find_class_device);
+
 int __init
 attribute_container_init(void)
 {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/base/attribute_container.c b/drivers/base/attribute_container.c
new file mode 100644
index 000000000000..ec615d854be9
--- /dev/null
+++ b/drivers/base/attribute_container.c
@@ -0,0 +1,376 @@
+/*
+ * attribute_container.c - implementation of a simple container for classes
+ *
+ * Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>
+ *
+ * This file is licensed under GPLv2
+ *
+ * The basic idea here is to enable a device to be attached to an
+ * aritrary numer of classes without having to allocate storage for them.
+ * Instead, the contained classes select the devices they need to attach
+ * to via a matching function.
+ */
+
+#include <linux/attribute_container.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/module.h>
+
+/* This is a private structure used to tie the classdev and the
+ * container .. it should never be visible outside this file */
+struct internal_container {
+	struct list_head node;
+	struct attribute_container *cont;
+	struct class_device classdev;
+};
+
+/**
+ * attribute_container_classdev_to_container - given a classdev, return the container
+ *
+ * @classdev: the class device created by attribute_container_add_device.
+ *
+ * Returns the container associated with this classdev.
+ */
+struct attribute_container *
+attribute_container_classdev_to_container(struct class_device *classdev)
+{
+	struct internal_container *ic =
+		container_of(classdev, struct internal_container, classdev);
+	return ic->cont;
+}
+EXPORT_SYMBOL_GPL(attribute_container_classdev_to_container);
+
+static struct list_head attribute_container_list;
+
+static DECLARE_MUTEX(attribute_container_mutex);
+
+/**
+ * attribute_container_register - register an attribute container
+ *
+ * @cont: The container to register.  This must be allocated by the
+ *        callee and should also be zeroed by it.
+ */
+int
+attribute_container_register(struct attribute_container *cont)
+{
+	INIT_LIST_HEAD(&cont->node);
+	INIT_LIST_HEAD(&cont->containers);
+		
+	down(&attribute_container_mutex);
+	list_add_tail(&cont->node, &attribute_container_list);
+	up(&attribute_container_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(attribute_container_register);
+
+/**
+ * attribute_container_unregister - remove a container registration
+ *
+ * @cont: previously registered container to remove
+ */
+int
+attribute_container_unregister(struct attribute_container *cont)
+{
+	int retval = -EBUSY;
+	down(&attribute_container_mutex);
+	if (!list_empty(&cont->containers))
+		goto out;
+	retval = 0;
+	list_del(&cont->node);
+ out:
+	up(&attribute_container_mutex);
+	return retval;
+		
+}
+EXPORT_SYMBOL_GPL(attribute_container_unregister);
+
+/* private function used as class release */
+static void attribute_container_release(struct class_device *classdev)
+{
+	struct internal_container *ic 
+		= container_of(classdev, struct internal_container, classdev);
+	struct device *dev = classdev->dev;
+
+	kfree(ic);
+	put_device(dev);
+}
+
+/**
+ * attribute_container_add_device - see if any container is interested in dev
+ *
+ * @dev: device to add attributes to
+ * @fn:	 function to trigger addition of class device.
+ *
+ * This function allocates storage for the class device(s) to be
+ * attached to dev (one for each matching attribute_container).  If no
+ * fn is provided, the code will simply register the class device via
+ * class_device_add.  If a function is provided, it is expected to add
+ * the class device at the appropriate time.  One of the things that
+ * might be necessary is to allocate and initialise the classdev and
+ * then add it a later time.  To do this, call this routine for
+ * allocation and initialisation and then use
+ * attribute_container_device_trigger() to call class_device_add() on
+ * it.  Note: after this, the class device contains a reference to dev
+ * which is not relinquished until the release of the classdev.
+ */
+void
+attribute_container_add_device(struct device *dev,
+			       int (*fn)(struct attribute_container *,
+					 struct device *,
+					 struct class_device *))
+{
+	struct attribute_container *cont;
+
+	down(&attribute_container_mutex);
+	list_for_each_entry(cont, &attribute_container_list, node) {
+		struct internal_container *ic;
+
+		if (attribute_container_no_classdevs(cont))
+			continue;
+
+		if (!cont->match(cont, dev))
+			continue;
+		ic = kmalloc(sizeof(struct internal_container), GFP_KERNEL);
+		if (!ic) {
+			dev_printk(KERN_ERR, dev, "failed to allocate class container\n");
+			continue;
+		}
+		memset(ic, 0, sizeof(struct internal_container));
+		INIT_LIST_HEAD(&ic->node);
+		ic->cont = cont;
+		class_device_initialize(&ic->classdev);
+		ic->classdev.dev = get_device(dev);
+		ic->classdev.class = cont->class;
+		cont->class->release = attribute_container_release;
+		strcpy(ic->classdev.class_id, dev->bus_id);
+		if (fn)
+			fn(cont, dev, &ic->classdev);
+		else
+			attribute_container_add_class_device(&ic->classdev);
+		list_add_tail(&ic->node, &cont->containers);
+	}
+	up(&attribute_container_mutex);
+}
+
+/**
+ * attribute_container_remove_device - make device eligible for removal.
+ *
+ * @dev:  The generic device
+ * @fn:	  A function to call to remove the device
+ *
+ * This routine triggers device removal.  If fn is NULL, then it is
+ * simply done via class_device_unregister (note that if something
+ * still has a reference to the classdev, then the memory occupied
+ * will not be freed until the classdev is released).  If you want a
+ * two phase release: remove from visibility and then delete the
+ * device, then you should use this routine with a fn that calls
+ * class_device_del() and then use
+ * attribute_container_device_trigger() to do the final put on the
+ * classdev.
+ */
+void
+attribute_container_remove_device(struct device *dev,
+				  void (*fn)(struct attribute_container *,
+					     struct device *,
+					     struct class_device *))
+{
+	struct attribute_container *cont;
+
+	down(&attribute_container_mutex);
+	list_for_each_entry(cont, &attribute_container_list, node) {
+		struct internal_container *ic, *tmp;
+
+		if (attribute_container_no_classdevs(cont))
+			continue;
+
+		if (!cont->match(cont, dev))
+			continue;
+		list_for_each_entry_safe(ic, tmp, &cont->containers, node) {
+			if (dev != ic->classdev.dev)
+				continue;
+			list_del(&ic->node);
+			if (fn)
+				fn(cont, dev, &ic->classdev);
+			else {
+				attribute_container_remove_attrs(&ic->classdev);
+				class_device_unregister(&ic->classdev);
+			}
+		}
+	}
+	up(&attribute_container_mutex);
+}
+EXPORT_SYMBOL_GPL(attribute_container_remove_device);
+
+/**
+ * attribute_container_device_trigger - execute a trigger for each matching classdev
+ *
+ * @dev:  The generic device to run the trigger for
+ * @fn	  the function to execute for each classdev.
+ *
+ * This funcion is for executing a trigger when you need to know both
+ * the container and the classdev.  If you only care about the
+ * container, then use attribute_container_trigger() instead.
+ */
+void
+attribute_container_device_trigger(struct device *dev, 
+				   int (*fn)(struct attribute_container *,
+					     struct device *,
+					     struct class_device *))
+{
+	struct attribute_container *cont;
+
+	down(&attribute_container_mutex);
+	list_for_each_entry(cont, &attribute_container_list, node) {
+		struct internal_container *ic, *tmp;
+
+		if (!cont->match(cont, dev))
+			continue;
+
+		list_for_each_entry_safe(ic, tmp, &cont->containers, node) {
+			if (dev == ic->classdev.dev)
+				fn(cont, dev, &ic->classdev);
+		}
+	}
+	up(&attribute_container_mutex);
+}
+EXPORT_SYMBOL_GPL(attribute_container_device_trigger);
+
+/**
+ * attribute_container_trigger - trigger a function for each matching container
+ *
+ * @dev:  The generic device to activate the trigger for
+ * @fn:	  the function to trigger
+ *
+ * This routine triggers a function that only needs to know the
+ * matching containers (not the classdev) associated with a device.
+ * It is more lightweight than attribute_container_device_trigger, so
+ * should be used in preference unless the triggering function
+ * actually needs to know the classdev.
+ */
+void
+attribute_container_trigger(struct device *dev,
+			    int (*fn)(struct attribute_container *,
+				      struct device *))
+{
+	struct attribute_container *cont;
+
+	down(&attribute_container_mutex);
+	list_for_each_entry(cont, &attribute_container_list, node) {
+		if (cont->match(cont, dev))
+			fn(cont, dev);
+	}
+	up(&attribute_container_mutex);
+}
+EXPORT_SYMBOL_GPL(attribute_container_trigger);
+
+/**
+ * attribute_container_add_attrs - add attributes
+ *
+ * @classdev: The class device
+ *
+ * This simply creates all the class device sysfs files from the
+ * attributes listed in the container
+ */
+int
+attribute_container_add_attrs(struct class_device *classdev)
+{
+	struct attribute_container *cont =
+		attribute_container_classdev_to_container(classdev);
+	struct class_device_attribute **attrs =	cont->attrs;
+	int i, error;
+
+	if (!attrs)
+		return 0;
+
+	for (i = 0; attrs[i]; i++) {
+		error = class_device_create_file(classdev, attrs[i]);
+		if (error)
+			return error;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(attribute_container_add_attrs);
+
+/**
+ * attribute_container_add_class_device - same function as class_device_add
+ *
+ * @classdev:	the class device to add
+ *
+ * This performs essentially the same function as class_device_add except for
+ * attribute containers, namely add the classdev to the system and then
+ * create the attribute files
+ */
+int
+attribute_container_add_class_device(struct class_device *classdev)
+{
+	int error = class_device_add(classdev);
+	if (error)
+		return error;
+	return attribute_container_add_attrs(classdev);
+}
+EXPORT_SYMBOL_GPL(attribute_container_add_class_device);
+
+/**
+ * attribute_container_add_class_device_adapter - simple adapter for triggers
+ *
+ * This function is identical to attribute_container_add_class_device except
+ * that it is designed to be called from the triggers
+ */
+int
+attribute_container_add_class_device_adapter(struct attribute_container *cont,
+					     struct device *dev,
+					     struct class_device *classdev)
+{
+	return attribute_container_add_class_device(classdev);
+}
+EXPORT_SYMBOL_GPL(attribute_container_add_class_device_adapter);
+
+/**
+ * attribute_container_remove_attrs - remove any attribute files
+ *
+ * @classdev: The class device to remove the files from
+ *
+ */
+void
+attribute_container_remove_attrs(struct class_device *classdev)
+{
+	struct attribute_container *cont =
+		attribute_container_classdev_to_container(classdev);
+	struct class_device_attribute **attrs =	cont->attrs;
+	int i;
+
+	if (!attrs)
+		return;
+
+	for (i = 0; attrs[i]; i++)
+		class_device_remove_file(classdev, attrs[i]);
+}
+EXPORT_SYMBOL_GPL(attribute_container_remove_attrs);
+
+/**
+ * attribute_container_class_device_del - equivalent of class_device_del
+ *
+ * @classdev: the class device
+ *
+ * This function simply removes all the attribute files and then calls
+ * class_device_del.
+ */
+void
+attribute_container_class_device_del(struct class_device *classdev)
+{
+	attribute_container_remove_attrs(classdev);
+	class_device_del(classdev);
+}
+EXPORT_SYMBOL_GPL(attribute_container_class_device_del);
+
+int __init
+attribute_container_init(void)
+{
+	INIT_LIST_HEAD(&attribute_container_list);
+	return 0;
+}
