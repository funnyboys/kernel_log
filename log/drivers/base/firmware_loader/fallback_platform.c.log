commit c2c076166b5880eabe068ce1cab30bf6edeeea1a
Author: Scott Branden <scott.branden@broadcom.com>
Date:   Fri May 22 16:12:02 2020 -0700

    firmware_loader: change enum fw_opt to u32
    
    "enum fw_opt" is not used as an enum.
    Change fw_opt to u32 as FW_OPT_* values are OR'd together.
    
    Signed-off-by: Scott Branden <scott.branden@broadcom.com>
    Acked-by: Luis Chamberlain <mcgrof@kernel.org>
    Link: https://lore.kernel.org/r/20200522231202.13681-1-scott.branden@broadcom.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/firmware_loader/fallback_platform.c b/drivers/base/firmware_loader/fallback_platform.c
index c88c745590fe..cdd2c9a9f38a 100644
--- a/drivers/base/firmware_loader/fallback_platform.c
+++ b/drivers/base/firmware_loader/fallback_platform.c
@@ -8,7 +8,7 @@
 #include "fallback.h"
 #include "firmware.h"
 
-int firmware_fallback_platform(struct fw_priv *fw_priv, enum fw_opt opt_flags)
+int firmware_fallback_platform(struct fw_priv *fw_priv, u32 opt_flags)
 {
 	const u8 *data;
 	size_t size;

commit e4c2c0ff00ecaf8e245455a199b86ce22143becf
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 15 17:35:48 2020 +0100

    firmware: Add new platform fallback mechanism and firmware_request_platform()
    
    In some cases the platform's main firmware (e.g. the UEFI fw) may contain
    an embedded copy of device firmware which needs to be (re)loaded into the
    peripheral. Normally such firmware would be part of linux-firmware, but in
    some cases this is not feasible, for 2 reasons:
    
    1) The firmware is customized for a specific use-case of the chipset / use
    with a specific hardware model, so we cannot have a single firmware file
    for the chipset. E.g. touchscreen controller firmwares are compiled
    specifically for the hardware model they are used with, as they are
    calibrated for a specific model digitizer.
    
    2) Despite repeated attempts we have failed to get permission to
    redistribute the firmware. This is especially a problem with customized
    firmwares, these get created by the chip vendor for a specific ODM and the
    copyright may partially belong with the ODM, so the chip vendor cannot
    give a blanket permission to distribute these.
    
    This commit adds a new platform fallback mechanism to the firmware loader
    which will try to lookup a device fw copy embedded in the platform's main
    firmware if direct filesystem lookup fails.
    
    Drivers which need such embedded fw copies can enable this fallback
    mechanism by using the new firmware_request_platform() function.
    
    Note that for now this is only supported on EFI platforms and even on
    these platforms firmware_fallback_platform() only works if
    CONFIG_EFI_EMBEDDED_FIRMWARE is enabled (this gets selected by drivers
    which need this), in all other cases firmware_fallback_platform() simply
    always returns -ENOENT.
    
    Reported-by: Dave Olsthoorn <dave@bewaar.me>
    Suggested-by: Peter Jones <pjones@redhat.com>
    Acked-by: Luis Chamberlain <mcgrof@kernel.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200115163554.101315-5-hdegoede@redhat.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/firmware_loader/fallback_platform.c b/drivers/base/firmware_loader/fallback_platform.c
new file mode 100644
index 000000000000..c88c745590fe
--- /dev/null
+++ b/drivers/base/firmware_loader/fallback_platform.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/efi_embedded_fw.h>
+#include <linux/property.h>
+#include <linux/security.h>
+#include <linux/vmalloc.h>
+
+#include "fallback.h"
+#include "firmware.h"
+
+int firmware_fallback_platform(struct fw_priv *fw_priv, enum fw_opt opt_flags)
+{
+	const u8 *data;
+	size_t size;
+	int rc;
+
+	if (!(opt_flags & FW_OPT_FALLBACK_PLATFORM))
+		return -ENOENT;
+
+	rc = security_kernel_load_data(LOADING_FIRMWARE_EFI_EMBEDDED);
+	if (rc)
+		return rc;
+
+	rc = efi_get_embedded_fw(fw_priv->fw_name, &data, &size);
+	if (rc)
+		return rc; /* rc == -ENOENT when the fw was not found */
+
+	fw_priv->data = vmalloc(size);
+	if (!fw_priv->data)
+		return -ENOMEM;
+
+	memcpy(fw_priv->data, data, size);
+	fw_priv->size = size;
+	fw_state_done(fw_priv);
+	return 0;
+}
