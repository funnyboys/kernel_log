commit 4c002c978b7f2f2306d53de051c054504af920a9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 9 20:33:03 2019 +0100

    device.h: move 'struct driver' stuff out to device/driver.h
    
    device.h has everything and the kitchen sink when it comes to struct
    device things, so split out the struct driver things things to a
    separate .h file to make things easier to maintain and manage over time.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Link: https://lore.kernel.org/r/20191209193303.1694546-7-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 4e5ca632f35e..57c68769e157 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -8,6 +8,7 @@
  * Copyright (c) 2007 Novell Inc.
  */
 
+#include <linux/device/driver.h>
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/errno.h>

commit 92ce7e83b4e5c86687d748ba53cb755acdce1256
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:54:00 2019 +0100

    driver_find_device: Unify the match function with class_find_device()
    
    The driver_find_device() accepts a match function pointer to
    filter the devices for lookup, similar to bus/class_find_device().
    However, there is a minor difference in the prototype for the
    match parameter for driver_find_device() with the now unified
    version accepted by {bus/class}_find_device(), where it doesn't
    accept a "const" qualifier for the data argument. This prevents
    us from reusing the generic match functions for driver_find_device().
    
    For this reason, change the prototype of the driver_find_device() to
    make the "match" parameter in line with {bus/class}_find_device()
    and adjust its callers to use the const qualifier. Also, we could
    now promote the "data" parameter to const as we pass it down
    as a const parameter to the match functions.
    
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Sebastian Ott <sebott@linux.ibm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Nehal Shah <nehal-bakulchandra.shah@amd.com>
    Cc: Shyam Sundar S K <shyam-sundar.s-k@amd.com>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 857c8f1b876e..4e5ca632f35e 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -73,8 +73,8 @@ EXPORT_SYMBOL_GPL(driver_for_each_device);
  * return to the caller and not iterate over any more devices.
  */
 struct device *driver_find_device(struct device_driver *drv,
-				  struct device *start, void *data,
-				  int (*match)(struct device *dev, void *data))
+				  struct device *start, const void *data,
+				  int (*match)(struct device *dev, const void *data))
 {
 	struct klist_iter i;
 	struct device *dev;

commit 0dda2bb6242361afd68332bf19bd67cd5981eb26
Author: Florian Schmaus <flo@geekplace.eu>
Date:   Wed May 23 17:59:11 2018 +0200

    driver-core: return EINVAL error instead of BUG_ON()
    
    I triggerd the BUG_ON() in driver_register() when booting a domU Xen
    domain. Since there was no contextual information logged, I needed to
    attach kgdb to determine the culprit (the wmi-bmof driver in my
    case). The BUG_ON() was added in commit f48f3febb2cb ("driver-core: do
    not register a driver with bus_type not registered").
    
    Instead of running into a BUG_ON() we print an error message
    identifying the, likely faulty, driver but continue booting.
    
    Signed-off-by: Florian Schmaus <flo@geekplace.eu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index ba912558a510..857c8f1b876e 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -148,7 +148,11 @@ int driver_register(struct device_driver *drv)
 	int ret;
 	struct device_driver *other;
 
-	BUG_ON(!drv->bus->p);
+	if (!drv->bus->p) {
+		pr_err("Driver '%s' was unable to register with bus_type '%s' because the bus was not initialized.\n",
+			   drv->name, drv->bus->name);
+		return -EINVAL;
+	}
 
 	if ((drv->bus->probe && drv->probe) ||
 	    (drv->bus->remove && drv->remove) ||

commit 93ead7c9483c6d7ae0f67ae6d0a5d3966d84bec8
Author: Gimcuan Hui <gimcuan@gmail.com>
Date:   Sat Nov 11 05:52:54 2017 +0000

    drivers: base: omit redundant interations
    
    When error happens, these interators return the error, no interation should
    be continued, so make the change for getting out of while immediately.
    
    Signed-off-by: Gimcuan Hui <gimcuan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 4e20d68edb0d..ba912558a510 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -50,7 +50,7 @@ int driver_for_each_device(struct device_driver *drv, struct device *start,
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,
 			     start ? &start->p->knode_driver : NULL);
-	while ((dev = next_device(&i)) && !error)
+	while (!error && (dev = next_device(&i)))
 		error = fn(dev, data);
 	klist_iter_exit(&i);
 	return error;

commit 328257099077e8affd438c179d8a938948de2e7f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:09 2017 +0100

    driver core: Remove redundant license text
    
    Now that the SPDX tag is in all driver core files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 6a93c7522dbe..4e20d68edb0d 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -6,9 +6,6 @@
  * Copyright (c) 2002-3 Open Source Development Labs
  * Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
  * Copyright (c) 2007 Novell Inc.
- *
- * This file is released under the GPLv2
- *
  */
 
 #include <linux/device.h>

commit 989d42e85dc2f6823f39b8e9d080fd04bae0645d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:07 2017 +0100

    driver core: add SPDX identifiers to all driver core files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the driver core files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 4eabfe28d2b3..6a93c7522dbe 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * driver.c - centralized device driver management
  *

commit 74642c6cd088e124c3cccbd5cb2f54984d6d4e1a
Author: Lavinia Tache <lavinia.tachee@gmail.com>
Date:   Sun Mar 8 12:48:55 2015 +0200

    driver core: add missing blank line after declaration
    
    Found using checkpatch.pl
    Signed-off-by: Lavinia Tache <lavinia.tachee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 9e29943e56ca..4eabfe28d2b3 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -103,6 +103,7 @@ int driver_create_file(struct device_driver *drv,
 		       const struct driver_attribute *attr)
 {
 	int error;
+
 	if (drv)
 		error = sysfs_create_file(&drv->p->kobj, &attr->attr);
 	else

commit 63967685605b3c73c078807cd498c4fbf62847c1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 27 10:24:15 2013 -0700

    driver core: add #include <linux/sysfs.h> to core files.
    
    This is needed to fix the build on sh systems.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index c7efccb6f3bb..9e29943e56ca 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -15,6 +15,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/sysfs.h>
 #include "base.h"
 
 static struct device *next_device(struct klist_iter *i)

commit 3e9b2bae8369661070622d05570cbcdfa01770e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 13:47:50 2013 -0700

    sysfs: add sysfs_create/remove_groups()
    
    These functions are being open-coded in 3 different places in the driver
    core, and other driver subsystems will want to start doing this as well,
    so move it to the sysfs core to keep it all in one place, where we know
    it is written properly.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 89db726ebb98..c7efccb6f3bb 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -126,31 +126,13 @@ EXPORT_SYMBOL_GPL(driver_remove_file);
 int driver_add_groups(struct device_driver *drv,
 		      const struct attribute_group **groups)
 {
-	int error = 0;
-	int i;
-
-	if (groups) {
-		for (i = 0; groups[i]; i++) {
-			error = sysfs_create_group(&drv->p->kobj, groups[i]);
-			if (error) {
-				while (--i >= 0)
-					sysfs_remove_group(&drv->p->kobj,
-							   groups[i]);
-				break;
-			}
-		}
-	}
-	return error;
+	return sysfs_create_groups(&drv->p->kobj, groups);
 }
 
 void driver_remove_groups(struct device_driver *drv,
 			  const struct attribute_group **groups)
 {
-	int i;
-
-	if (groups)
-		for (i = 0; groups[i]; i++)
-			sysfs_remove_group(&drv->p->kobj, groups[i]);
+	sysfs_remove_groups(&drv->p->kobj, groups);
 }
 
 /**

commit ed0617b5c0bcd7fd04053568aa0cc19a977a1f26
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 8 15:22:56 2013 -0700

    driver core: bus_type: add drv_groups
    
    attribute groups are much more flexible than just a list of attributes,
    due to their support for visibility of the attributes, and binary
    attributes. Add drv_groups to struct bus_type which should be used
    instead of drv_attrs.
    
    drv_attrs will be removed from the structure soon.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 974e301a1ef0..89db726ebb98 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -123,8 +123,8 @@ void driver_remove_file(struct device_driver *drv,
 }
 EXPORT_SYMBOL_GPL(driver_remove_file);
 
-static int driver_add_groups(struct device_driver *drv,
-			     const struct attribute_group **groups)
+int driver_add_groups(struct device_driver *drv,
+		      const struct attribute_group **groups)
 {
 	int error = 0;
 	int i;
@@ -143,8 +143,8 @@ static int driver_add_groups(struct device_driver *drv,
 	return error;
 }
 
-static void driver_remove_groups(struct device_driver *drv,
-				 const struct attribute_group **groups)
+void driver_remove_groups(struct device_driver *drv,
+			  const struct attribute_group **groups)
 {
 	int i;
 

commit a14af325641794d1ce8e676e9c4967342349195c
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Tue Jul 17 10:39:10 2012 +0200

    driver core: don't trigger uevent after failure
    
    Do not send the uevent if driver_add_groups failed.
    
    Reported-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 1b500d6fcc2e..974e301a1ef0 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -185,9 +185,10 @@ int driver_register(struct device_driver *drv)
 	if (ret)
 		return ret;
 	ret = driver_add_groups(drv, drv->groups);
-	if (ret)
+	if (ret) {
 		bus_remove_driver(drv);
-
+		return ret;
+	}
 	kobject_uevent(&drv->p->kobj, KOBJ_ADD);
 
 	return ret;

commit 5a7689fd5b4f2094e7a32beae67f290f8619b042
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Mon Jul 2 19:08:15 2012 +0200

    driver core: move uevent call to driver_register
    
    Device driver attribute groups are created after userspace is notified
    via an add event. Fix this by moving the kobject_uevent call to
    driver_register after the attribute groups are added.
    
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 207c27ddf828..1b500d6fcc2e 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -187,6 +187,9 @@ int driver_register(struct device_driver *drv)
 	ret = driver_add_groups(drv, drv->groups);
 	if (ret)
 		bus_remove_driver(drv);
+
+	kobject_uevent(&drv->p->kobj, KOBJ_ADD);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(driver_register);

commit 094e47e9fa79e28f0e51e37400ea6eea35a4ee1f
Author: Hiroshi DOYU <hdoyu@nvidia.com>
Date:   Fri May 11 11:03:09 2012 +0300

    Driver Core: don't oops with unregistered driver in driver_find_device()
    
    driver_find_device() can be called with an unregistered driver. Need
    to check driver_private to see if it's populated or not, especially
    under deferrable probe.
    
    In the case that there are 2 drivers, one depends on the other. With
    -EPROBE_DEFER, two drivers can use deferred probe to ensure that their
    relative probe order doesn't matter. If dependee driver is probed
    first, then the dependant's driver_find_device('dependee')
    succeeds. If the dependant is probed first, then the dependant's
    driver_find_device('dependee') should return NULL, and the dependant
    should get -EPROBE_DEFER. driver_find_device() needs to return NULL if
    it's not populated.
    
    In [PATCHv5 2/3] ARM: tegra: Add SMMU enabler in AHB:
      http://article.gmane.org/gmane.linux.ports.tegra/4658
    
    "tegra_ahb_driver" may not be populated when it's called.
    
    For more SMMU/AHB specific discussion, refer to the following thread:
      https://lkml.org/lkml/2012/5/10/21
    
    Signed-off-by: Hiroshi DOYU <hdoyu@nvidia.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 3ec3896c83a6..207c27ddf828 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -80,7 +80,7 @@ struct device *driver_find_device(struct device_driver *drv,
 	struct klist_iter i;
 	struct device *dev;
 
-	if (!drv)
+	if (!drv || !drv->p)
 		return NULL;
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,

commit 7cd9c9bb57476167e83b7780dbc06d1dd601789d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 19 19:17:30 2012 -0700

    Revert "driver core: check start node in klist_iter_init_node"
    
    This reverts commit a15d49fd3094cff90e5410ca454a870e0a722fe1 as that
    patch broke the build.
    
    Cc: Hannes Reinecke <hare@suse.de>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 16f6dd2c4403..3ec3896c83a6 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -49,13 +49,11 @@ int driver_for_each_device(struct device_driver *drv, struct device *start,
 	if (!drv)
 		return -EINVAL;
 
-	error = klist_iter_init_node(&drv->p->klist_devices, &i,
-				     start ? &start->p->knode_driver : NULL);
-	if (!error) {
-		while ((dev = next_device(&i)) && !error)
-			error = fn(dev, data);
-		klist_iter_exit(&i);
-	}
+	klist_iter_init_node(&drv->p->klist_devices, &i,
+			     start ? &start->p->knode_driver : NULL);
+	while ((dev = next_device(&i)) && !error)
+		error = fn(dev, data);
+	klist_iter_exit(&i);
 	return error;
 }
 EXPORT_SYMBOL_GPL(driver_for_each_device);
@@ -85,10 +83,8 @@ struct device *driver_find_device(struct device_driver *drv,
 	if (!drv)
 		return NULL;
 
-	if (klist_iter_init_node(&drv->p->klist_devices, &i,
-				 (start ? &start->p->knode_driver : NULL)) < 0)
-		return NULL;
-
+	klist_iter_init_node(&drv->p->klist_devices, &i,
+			     (start ? &start->p->knode_driver : NULL));
 	while ((dev = next_device(&i)))
 		if (match(dev, data) && get_device(dev))
 			break;

commit a15d49fd3094cff90e5410ca454a870e0a722fe1
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 16 15:06:25 2012 +0200

    driver core: check start node in klist_iter_init_node
    
    klist_iter_init_node() takes a node as a start argument.
    However, this node might not be valid anymore.
    This patch updates the klist_iter_init_node() and
    dependent functions to return an error if so.
    All calling functions have been audited to check
    for a return code here.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Cc: Greg Kroah-Hartmann <gregkh@linuxfoundation.org>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Stable Kernel <stable@kernel.org>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 3ec3896c83a6..16f6dd2c4403 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -49,11 +49,13 @@ int driver_for_each_device(struct device_driver *drv, struct device *start,
 	if (!drv)
 		return -EINVAL;
 
-	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     start ? &start->p->knode_driver : NULL);
-	while ((dev = next_device(&i)) && !error)
-		error = fn(dev, data);
-	klist_iter_exit(&i);
+	error = klist_iter_init_node(&drv->p->klist_devices, &i,
+				     start ? &start->p->knode_driver : NULL);
+	if (!error) {
+		while ((dev = next_device(&i)) && !error)
+			error = fn(dev, data);
+		klist_iter_exit(&i);
+	}
 	return error;
 }
 EXPORT_SYMBOL_GPL(driver_for_each_device);
@@ -83,8 +85,10 @@ struct device *driver_find_device(struct device_driver *drv,
 	if (!drv)
 		return NULL;
 
-	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     (start ? &start->p->knode_driver : NULL));
+	if (klist_iter_init_node(&drv->p->klist_devices, &i,
+				 (start ? &start->p->knode_driver : NULL)) < 0)
+		return NULL;
+
 	while ((dev = next_device(&i)))
 		if (match(dev, data) && get_device(dev))
 			break;

commit 5375871d432ae9fc581014ac117b96aaee3cd0c7
Merge: b57cb7231b2c dfbc2d75c1bd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 21 18:55:10 2012 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc merge from Benjamin Herrenschmidt:
     "Here's the powerpc batch for this merge window.  It is going to be a
      bit more nasty than usual as in touching things outside of
      arch/powerpc mostly due to the big iSeriesectomy :-) We finally got
      rid of the bugger (legacy iSeries support) which was a PITA to
      maintain and that nobody really used anymore.
    
      Here are some of the highlights:
    
       - Legacy iSeries is gone.  Thanks Stephen ! There's still some bits
         and pieces remaining if you do a grep -ir series arch/powerpc but
         they are harmless and will be removed in the next few weeks
         hopefully.
    
       - The 'fadump' functionality (Firmware Assisted Dump) replaces the
         previous (equivalent) "pHyp assisted dump"...  it's a rewrite of a
         mechanism to get the hypervisor to do crash dumps on pSeries, the
         new implementation hopefully being much more reliable.  Thanks
         Mahesh Salgaonkar.
    
       - The "EEH" code (pSeries PCI error handling & recovery) got a big
         spring cleaning, motivated by the need to be able to implement a
         new backend for it on top of some new different type of firwmare.
    
         The work isn't complete yet, but a good chunk of the cleanups is
         there.  Note that this adds a field to struct device_node which is
         not very nice and which Grant objects to.  I will have a patch soon
         that moves that to a powerpc private data structure (hopefully
         before rc1) and we'll improve things further later on (hopefully
         getting rid of the need for that pointer completely).  Thanks Gavin
         Shan.
    
       - I dug into our exception & interrupt handling code to improve the
         way we do lazy interrupt handling (and make it work properly with
         "edge" triggered interrupt sources), and while at it found & fixed
         a wagon of issues in those areas, including adding support for page
         fault retry & fatal signals on page faults.
    
       - Your usual random batch of small fixes & updates, including a bunch
         of new embedded boards, both Freescale and APM based ones, etc..."
    
    I fixed up some conflicts with the generalized irq-domain changes from
    Grant Likely, hopefully correctly.
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (141 commits)
      powerpc/ps3: Do not adjust the wrapper load address
      powerpc: Remove the rest of the legacy iSeries include files
      powerpc: Remove the remaining CONFIG_PPC_ISERIES pieces
      init: Remove CONFIG_PPC_ISERIES
      powerpc: Remove FW_FEATURE ISERIES from arch code
      tty/hvc_vio: FW_FEATURE_ISERIES is no longer selectable
      powerpc/spufs: Fix double unlocks
      powerpc/5200: convert mpc5200 to use of_platform_populate()
      powerpc/mpc5200: add options to mpc5200_defconfig
      powerpc/mpc52xx: add a4m072 board support
      powerpc/mpc5200: update mpc5200_defconfig to fit for charon board
      Documentation/powerpc/mpc52xx.txt: Checkpatch cleanup
      powerpc/44x: Add additional device support for APM821xx SoC and Bluestone board
      powerpc/44x: Add support PCI-E for APM821xx SoC and Bluestone board
      MAINTAINERS: Update PowerPC 4xx tree
      powerpc/44x: The bug fixed support for APM821xx SoC and Bluestone board
      powerpc: document the FSL MPIC message register binding
      powerpc: add support for MPIC message register API
      powerpc/fsl: Added aliased MSIIR register address to MSI node in dts
      powerpc/85xx: mpc8548cds - add 36-bit dts
      ...

commit fcd6f76202024763f2f4a348ab666240e4f7ac50
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Mar 7 18:41:09 2012 +0000

    driver-core: remove legacy iSeries hack
    
    The PowerPC legacy iSeries plateform is being removed along with the
    "one looney iseries driver", so this code can now be removed as well.
    
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index b631f7c59453..db4f54c313aa 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -123,36 +123,6 @@ void driver_remove_file(struct device_driver *drv,
 }
 EXPORT_SYMBOL_GPL(driver_remove_file);
 
-/**
- * driver_add_kobj - add a kobject below the specified driver
- * @drv: requesting device driver
- * @kobj: kobject to add below this driver
- * @fmt: format string that names the kobject
- *
- * You really don't want to do this, this is only here due to one looney
- * iseries driver, go poke those developers if you are annoyed about
- * this...
- */
-int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
-		    const char *fmt, ...)
-{
-	va_list args;
-	char *name;
-	int ret;
-
-	va_start(args, fmt);
-	name = kvasprintf(GFP_KERNEL, fmt, args);
-	va_end(args);
-
-	if (!name)
-		return -ENOMEM;
-
-	ret = kobject_add(kobj, &drv->p->kobj, "%s", name);
-	kfree(name);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(driver_add_kobj);
-
 /**
  * get_driver - increment driver reference count.
  * @drv: driver.

commit 9875bb480cc89d9b690f7028aadf7e58454f0dae
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 24 13:35:37 2012 -0500

    Eliminate get_driver() and put_driver()
    
    Now that there are no users of get_driver() or put_driver(), this
    patch (as1513) removes those routines completely.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index e979cad75c6e..60e4f77ca662 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -153,34 +153,6 @@ int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(driver_add_kobj);
 
-/**
- * get_driver - increment driver reference count.
- * @drv: driver.
- */
-struct device_driver *get_driver(struct device_driver *drv)
-{
-	if (drv) {
-		struct driver_private *priv;
-		struct kobject *kobj;
-
-		kobj = kobject_get(&drv->p->kobj);
-		priv = to_driver(kobj);
-		return priv->driver;
-	}
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(get_driver);
-
-/**
- * put_driver - decrement driver's refcount.
- * @drv: driver.
- */
-void put_driver(struct device_driver *drv)
-{
-	kobject_put(&drv->p->kobj);
-}
-EXPORT_SYMBOL_GPL(put_driver);
-
 static int driver_add_groups(struct device_driver *drv,
 			     const struct attribute_group **groups)
 {

commit fde25a9b63b9a3dc91365c394a426ebe64cfc2da
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 24 13:34:24 2012 -0500

    Driver core: driver_find() drops reference before returning
    
    As part of the removal of get_driver()/put_driver(), this patch
    (as1510) changes driver_find(); it now drops the reference it acquires
    before returning.  The patch also adjusts all the callers of
    driver_find() to remove the now unnecessary calls to put_driver().
    
    In addition, the patch adds a warning to driver_find(): Callers must
    make sure the driver they are searching for does not get unloaded
    while they are using it.  This has always been the case; driver_find()
    has never prevented a driver from being unregistered or unloaded.
    Hence the patch will not introduce any new bugs.  The existing callers
    all seem to be okay in this respect, however I don't understand the
    video drivers well enough to be certain about them.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    CC: Kyungmin Park <kyungmin.park@samsung.com>
    CC: Andy Walls <awalls@md.metrocast.net>
    CC: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index b631f7c59453..e979cad75c6e 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -234,7 +234,6 @@ int driver_register(struct device_driver *drv)
 
 	other = driver_find(drv->name, drv->bus);
 	if (other) {
-		put_driver(other);
 		printk(KERN_ERR "Error: Driver '%s' is already registered, "
 			"aborting...\n", drv->name);
 		return -EBUSY;
@@ -275,7 +274,9 @@ EXPORT_SYMBOL_GPL(driver_unregister);
  * Call kset_find_obj() to iterate over list of drivers on
  * a bus to find driver by name. Return driver if found.
  *
- * Note that kset_find_obj increments driver's reference count.
+ * This routine provides no locking to prevent the driver it returns
+ * from being unregistered or unloaded while the caller is using it.
+ * The caller is responsible for preventing this.
  */
 struct device_driver *driver_find(const char *name, struct bus_type *bus)
 {
@@ -283,6 +284,8 @@ struct device_driver *driver_find(const char *name, struct bus_type *bus)
 	struct driver_private *priv;
 
 	if (k) {
+		/* Drop reference added by kset_find_obj() */
+		kobject_put(k);
 		priv = to_driver(k);
 		return priv->driver;
 	}

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 90c9fff09ead..b631f7c59453 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -13,6 +13,7 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/errno.h>
+#include <linux/slab.h>
 #include <linux/string.h>
 #include "base.h"
 

commit 099c2f21d8cf0724b85abb2c589d6276953781b7
Author: Phil Carmody <ext-phil.2.carmody@nokia.com>
Date:   Fri Dec 18 15:34:21 2009 +0200

    Driver core: driver_attribute parameters can often be const*
    
    Many struct driver_attribute descriptors are purely read-only
    structures, and there's no need to change them. Therefore make
    the promise not to, which will let those descriptors be put in
    a ro section.
    
    Signed-off-by: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index f367885a7646..90c9fff09ead 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -98,7 +98,7 @@ EXPORT_SYMBOL_GPL(driver_find_device);
  * @attr: driver attribute descriptor.
  */
 int driver_create_file(struct device_driver *drv,
-		       struct driver_attribute *attr)
+		       const struct driver_attribute *attr)
 {
 	int error;
 	if (drv)
@@ -115,7 +115,7 @@ EXPORT_SYMBOL_GPL(driver_create_file);
  * @attr: driver attribute descriptor.
  */
 void driver_remove_file(struct device_driver *drv,
-			struct driver_attribute *attr)
+			const struct driver_attribute *attr)
 {
 	if (drv)
 		sysfs_remove_file(&drv->p->kobj, &attr->attr);

commit 39acbc12affcaa23ef1d887ba3d197baca8e6e47
Author: Stas Sergeev <stsp@aknet.ru>
Date:   Sun Oct 18 00:31:38 2009 +0400

    Driver core: fix driver_register() return value
    
    In this patch:
    http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=16dc42e018c2868211b4928f20a957c0c216126c
    the check was added for another driver to already claim the same device
    on the same bus. But the returned error code was wrong: to modprobe, the
    -EEXIST means that _this_ driver is already installed. It therefore
    doesn't produce the needed error message when _another_ driver is trying
    to register for the same device.  Returning -EBUSY fixes the problem.
    
    Signed-off-by: Stas Sergeev <stsp@aknet.ru>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index ed2ebd3c287d..f367885a7646 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -236,7 +236,7 @@ int driver_register(struct device_driver *drv)
 		put_driver(other);
 		printk(KERN_ERR "Error: Driver '%s' is already registered, "
 			"aborting...\n", drv->name);
-		return -EEXIST;
+		return -EBUSY;
 	}
 
 	ret = bus_add_driver(drv);

commit a4dbd6740df0872cdf0a86841f75beec8381964d
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 24 10:06:31 2009 -0700

    driver model: constify attribute groups
    
    Let attribute group vectors be declared "const".  We'd
    like to let most attribute metadata live in read-only
    sections... this is a start.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 8ae0f63602e0..ed2ebd3c287d 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -181,7 +181,7 @@ void put_driver(struct device_driver *drv)
 EXPORT_SYMBOL_GPL(put_driver);
 
 static int driver_add_groups(struct device_driver *drv,
-			     struct attribute_group **groups)
+			     const struct attribute_group **groups)
 {
 	int error = 0;
 	int i;
@@ -201,7 +201,7 @@ static int driver_add_groups(struct device_driver *drv,
 }
 
 static void driver_remove_groups(struct device_driver *drv,
-				 struct attribute_group **groups)
+				 const struct attribute_group **groups)
 {
 	int i;
 

commit 5c8563d773c0e9f0ac2a552e84806decd98ce732
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu May 28 14:24:07 2009 -0700

    Driver Core: do not oops when driver_unregister() is called for unregistered drivers
    
    We also fix a problem with cleaning up properly when initializing
    drivers and devices, so checks like this will work successfully.
    
    Portions of the patch by Linus and Greg and Ingo.
    
    Reported-by: Ozan Çağlayan <ozan@pardus.org.tr>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index c51f11bb29ae..8ae0f63602e0 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -257,6 +257,10 @@ EXPORT_SYMBOL_GPL(driver_register);
  */
 void driver_unregister(struct device_driver *drv)
 {
+	if (!drv || !drv->p) {
+		WARN(1, "Unexpected driver unregister!\n");
+		return;
+	}
 	driver_remove_groups(drv, drv->groups);
 	bus_remove_driver(drv);
 }

commit 8940b4f312dced51b45004819b776ec3aa7fcd5d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:25:49 2008 -0800

    driver core: move knode_driver into private structure
    
    Nothing outside of the driver core should ever touch knode_driver, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 2889ad57e48b..c51f11bb29ae 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -19,7 +19,14 @@
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);
-	return n ? container_of(n, struct device, knode_driver) : NULL;
+	struct device *dev = NULL;
+	struct device_private *dev_prv;
+
+	if (n) {
+		dev_prv = to_device_private_driver(n);
+		dev = dev_prv->device;
+	}
+	return dev;
 }
 
 /**
@@ -42,7 +49,7 @@ int driver_for_each_device(struct device_driver *drv, struct device *start,
 		return -EINVAL;
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     start ? &start->knode_driver : NULL);
+			     start ? &start->p->knode_driver : NULL);
 	while ((dev = next_device(&i)) && !error)
 		error = fn(dev, data);
 	klist_iter_exit(&i);
@@ -76,7 +83,7 @@ struct device *driver_find_device(struct device_driver *drv,
 		return NULL;
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     (start ? &start->knode_driver : NULL));
+			     (start ? &start->p->knode_driver : NULL));
 	while ((dev = next_device(&i)))
 		if (match(dev, data) && get_device(dev))
 			break;

commit f48f3febb2cbfd0f2ecee7690835ba745c1034a4
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Sat Feb 14 21:23:22 2009 +0800

    driver-core: do not register a driver with bus_type not registered
    
    If the bus_type is not registerd, driver_register to that bus will cause oops.
    
    I found this bug when test built-in usb serial drivers (ie. aircable driver)
    with 'nousb' cmdline params.
    
    In this patch:
    1. set the bus->p=NULL when bus_register failed and unregisterd.
    2. if bus->p is NULL, driver_register BUG_ON will be triggered.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 1e2bda780e48..2889ad57e48b 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -216,6 +216,8 @@ int driver_register(struct device_driver *drv)
 	int ret;
 	struct device_driver *other;
 
+	BUG_ON(!drv->bus->p);
+
 	if ((drv->bus->probe && drv->probe) ||
 	    (drv->bus->remove && drv->remove) ||
 	    (drv->bus->shutdown && drv->shutdown))

commit cda5e83fdea476dce9c0a9b1152cd6ca46832cc4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 14:44:18 2009 -0800

    Revert "driver core: move knode_driver into private structure"
    
    This reverts commit 93e746db183b3bdbbda67900f79b5835f9cb388f.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index b76cc69f1106..1e2bda780e48 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -19,14 +19,7 @@
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);
-	struct device *dev = NULL;
-	struct device_private *dev_prv;
-
-	if (n) {
-		dev_prv = to_device_private_driver(n);
-		dev = dev_prv->device;
-	}
-	return dev;
+	return n ? container_of(n, struct device, knode_driver) : NULL;
 }
 
 /**
@@ -49,7 +42,7 @@ int driver_for_each_device(struct device_driver *drv, struct device *start,
 		return -EINVAL;
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     start ? &start->p->knode_driver : NULL);
+			     start ? &start->knode_driver : NULL);
 	while ((dev = next_device(&i)) && !error)
 		error = fn(dev, data);
 	klist_iter_exit(&i);
@@ -83,7 +76,7 @@ struct device *driver_find_device(struct device_driver *drv,
 		return NULL;
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     (start ? &start->p->knode_driver : NULL));
+			     (start ? &start->knode_driver : NULL));
 	while ((dev = next_device(&i)))
 		if (match(dev, data) && get_device(dev))
 			break;

commit 93e746db183b3bdbbda67900f79b5835f9cb388f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:25:49 2008 -0800

    driver core: move knode_driver into private structure
    
    Nothing outside of the driver core should ever touch knode_driver, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 1e2bda780e48..b76cc69f1106 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -19,7 +19,14 @@
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);
-	return n ? container_of(n, struct device, knode_driver) : NULL;
+	struct device *dev = NULL;
+	struct device_private *dev_prv;
+
+	if (n) {
+		dev_prv = to_device_private_driver(n);
+		dev = dev_prv->device;
+	}
+	return dev;
 }
 
 /**
@@ -42,7 +49,7 @@ int driver_for_each_device(struct device_driver *drv, struct device *start,
 		return -EINVAL;
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     start ? &start->knode_driver : NULL);
+			     start ? &start->p->knode_driver : NULL);
 	while ((dev = next_device(&i)) && !error)
 		error = fn(dev, data);
 	klist_iter_exit(&i);
@@ -76,7 +83,7 @@ struct device *driver_find_device(struct device_driver *drv,
 		return NULL;
 
 	klist_iter_init_node(&drv->p->klist_devices, &i,
-			     (start ? &start->knode_driver : NULL));
+			     (start ? &start->p->knode_driver : NULL));
 	while ((dev = next_device(&i)))
 		if (match(dev, data) && get_device(dev))
 			break;

commit 26d02d1db7d84729b1e49789341e69a493c60ceb
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 30 12:29:20 2008 -0700

    drivers/base/driver.c: remove unused to_dev() macro
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 2ef5acf4368b..1e2bda780e48 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -16,9 +16,6 @@
 #include <linux/string.h>
 #include "base.h"
 
-#define to_dev(node) container_of(node, struct device, driver_list)
-
-
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);

commit 16dc42e018c2868211b4928f20a957c0c216126c
Author: Stas Sergeev <stsp@aknet.ru>
Date:   Sat Apr 26 19:52:35 2008 +0400

    driver core: warn about duplicate driver names on the same bus
    
    Currently an attempt to register multiple
    drivers with the same name causes the
    stack trace with some cryptic error message.
    The attached patch adds the necessary check
    and the clear error message.
    
    Signed-off-by: Stas Sergeev <stsp@aknet.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 9a6537f14401..2ef5acf4368b 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -217,12 +217,22 @@ static void driver_remove_groups(struct device_driver *drv,
 int driver_register(struct device_driver *drv)
 {
 	int ret;
+	struct device_driver *other;
 
 	if ((drv->bus->probe && drv->probe) ||
 	    (drv->bus->remove && drv->remove) ||
 	    (drv->bus->shutdown && drv->shutdown))
 		printk(KERN_WARNING "Driver '%s' needs updating - please use "
 			"bus_type methods\n", drv->name);
+
+	other = driver_find(drv->name, drv->bus);
+	if (other) {
+		put_driver(other);
+		printk(KERN_ERR "Error: Driver '%s' is already registered, "
+			"aborting...\n", drv->name);
+		return -EEXIST;
+	}
+
 	ret = bus_add_driver(drv);
 	if (ret)
 		return ret;

commit d478376cb0dc9ab16a2b6e02fd8cd1174e724c64
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Fri Mar 28 14:16:12 2008 -0700

    driver core: fix small mem leak in driver_add_kobj()
    
    The Coverity checker spotted that we leak the storage allocated to 'name' in
    int driver_add_kobj().  The leak looks legit to me - this is the code :
    
    int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
                        const char *fmt, ...)
    {
            va_list args;
            char *name;
            int ret;
    
            va_start(args, fmt);
            name = kvasprintf(GFP_KERNEL, fmt, args);
            ^^^^^^^^ This dynamically allocates space...
    
            va_end(args);
    
            if (!name)
                    return -ENOMEM;
    
            return kobject_add(kobj, &drv->p->kobj, "%s", name);
            ^^^^^^^^ This neglects to free the space allocated
    }
    
    Inside kobject_add() a copy of 'name' will be made and used.  As far as I can
    see, Coverity is correct in flagging this as a leak, but I'd like some
    configmation before the patch is applied.
    
    This should fix it.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index bf31a0170a48..9a6537f14401 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -133,6 +133,7 @@ int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
 {
 	va_list args;
 	char *name;
+	int ret;
 
 	va_start(args, fmt);
 	name = kvasprintf(GFP_KERNEL, fmt, args);
@@ -141,7 +142,9 @@ int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
 	if (!name)
 		return -ENOMEM;
 
-	return kobject_add(kobj, &drv->p->kobj, "%s", name);
+	ret = kobject_add(kobj, &drv->p->kobj, "%s", name);
+	kfree(name);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(driver_add_kobj);
 

commit 7199677d2e919edc75d1fb8856c98cd0c1bbcfc5
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Feb 18 13:09:03 2008 -0800

    driver-core: fix kernel-doc function parameters
    
    Fix drivers/base/ missing kernel-doc parameters:
    Warning(linux-2.6.24-git12//drivers/base/driver.c:133): No description found for parameter 'drv'
    Warning(linux-2.6.24-git12//drivers/base/driver.c:133): No description found for parameter 'kobj'
    Warning(linux-2.6.24-git12//drivers/base/driver.c:133): No description found for parameter 'fmt'
    Warning(linux-2.6.24-git12//drivers/base/power/main.c:530): No description found for parameter 'state'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index ba75184c653c..bf31a0170a48 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -120,6 +120,9 @@ EXPORT_SYMBOL_GPL(driver_remove_file);
 
 /**
  * driver_add_kobj - add a kobject below the specified driver
+ * @drv: requesting device driver
+ * @kobj: kobject to add below this driver
+ * @fmt: format string that names the kobject
  *
  * You really don't want to do this, this is only here due to one looney
  * iseries driver, go poke those developers if you are annoyed about

commit 0c98b19fe571ede1f14bd95b855bcbe2cca99bcf
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Thu Jan 31 10:39:38 2008 +0100

    Driver core: Remove unneeded get_{device,driver}() calls.
    
    Driver core: Remove unneeded get_{device,driver}() calls.
    
    Code trying to add/remove attributes must hold a reference to
    the device resp. driver anyway, so let's remove those reference
    count games.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index a35f04121a00..ba75184c653c 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -97,10 +97,9 @@ int driver_create_file(struct device_driver *drv,
 		       struct driver_attribute *attr)
 {
 	int error;
-	if (get_driver(drv)) {
+	if (drv)
 		error = sysfs_create_file(&drv->p->kobj, &attr->attr);
-		put_driver(drv);
-	} else
+	else
 		error = -EINVAL;
 	return error;
 }
@@ -114,10 +113,8 @@ EXPORT_SYMBOL_GPL(driver_create_file);
 void driver_remove_file(struct device_driver *drv,
 			struct driver_attribute *attr)
 {
-	if (get_driver(drv)) {
+	if (drv)
 		sysfs_remove_file(&drv->p->kobj, &attr->attr);
-		put_driver(drv);
-	}
 }
 EXPORT_SYMBOL_GPL(driver_remove_file);
 

commit 4a3ad20ccd8f4d2a0535cf98fa83f7b561ba59a9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 24 22:50:12 2008 -0800

    Driver core: coding style fixes
    
    Fix up a number of coding style issues in the drivers/base/ directory
    that have annoyed me over the years.  checkpatch.pl is now very happy.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 94b697a9b4e0..a35f04121a00 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -19,27 +19,26 @@
 #define to_dev(node) container_of(node, struct device, driver_list)
 
 
-static struct device * next_device(struct klist_iter * i)
+static struct device *next_device(struct klist_iter *i)
 {
-	struct klist_node * n = klist_next(i);
+	struct klist_node *n = klist_next(i);
 	return n ? container_of(n, struct device, knode_driver) : NULL;
 }
 
 /**
- *	driver_for_each_device - Iterator for devices bound to a driver.
- *	@drv:	Driver we're iterating.
- *	@start: Device to begin with
- *	@data:	Data to pass to the callback.
- *	@fn:	Function to call for each device.
+ * driver_for_each_device - Iterator for devices bound to a driver.
+ * @drv: Driver we're iterating.
+ * @start: Device to begin with
+ * @data: Data to pass to the callback.
+ * @fn: Function to call for each device.
  *
- *	Iterate over the @drv's list of devices calling @fn for each one.
+ * Iterate over the @drv's list of devices calling @fn for each one.
  */
-
-int driver_for_each_device(struct device_driver * drv, struct device * start, 
-			   void * data, int (*fn)(struct device *, void *))
+int driver_for_each_device(struct device_driver *drv, struct device *start,
+			   void *data, int (*fn)(struct device *, void *))
 {
 	struct klist_iter i;
-	struct device * dev;
+	struct device *dev;
 	int error = 0;
 
 	if (!drv)
@@ -52,10 +51,8 @@ int driver_for_each_device(struct device_driver * drv, struct device * start,
 	klist_iter_exit(&i);
 	return error;
 }
-
 EXPORT_SYMBOL_GPL(driver_for_each_device);
 
-
 /**
  * driver_find_device - device iterator for locating a particular device.
  * @drv: The device's driver
@@ -71,9 +68,9 @@ EXPORT_SYMBOL_GPL(driver_for_each_device);
  * if it does.  If the callback returns non-zero, this function will
  * return to the caller and not iterate over any more devices.
  */
-struct device * driver_find_device(struct device_driver *drv,
-				   struct device * start, void * data,
-				   int (*match)(struct device *, void *))
+struct device *driver_find_device(struct device_driver *drv,
+				  struct device *start, void *data,
+				  int (*match)(struct device *dev, void *data))
 {
 	struct klist_iter i;
 	struct device *dev;
@@ -92,12 +89,12 @@ struct device * driver_find_device(struct device_driver *drv,
 EXPORT_SYMBOL_GPL(driver_find_device);
 
 /**
- *	driver_create_file - create sysfs file for driver.
- *	@drv:	driver.
- *	@attr:	driver attribute descriptor.
+ * driver_create_file - create sysfs file for driver.
+ * @drv: driver.
+ * @attr: driver attribute descriptor.
  */
-
-int driver_create_file(struct device_driver * drv, struct driver_attribute * attr)
+int driver_create_file(struct device_driver *drv,
+		       struct driver_attribute *attr)
 {
 	int error;
 	if (get_driver(drv)) {
@@ -107,22 +104,22 @@ int driver_create_file(struct device_driver * drv, struct driver_attribute * att
 		error = -EINVAL;
 	return error;
 }
-
+EXPORT_SYMBOL_GPL(driver_create_file);
 
 /**
- *	driver_remove_file - remove sysfs file for driver.
- *	@drv:	driver.
- *	@attr:	driver attribute descriptor.
+ * driver_remove_file - remove sysfs file for driver.
+ * @drv: driver.
+ * @attr: driver attribute descriptor.
  */
-
-void driver_remove_file(struct device_driver * drv, struct driver_attribute * attr)
+void driver_remove_file(struct device_driver *drv,
+			struct driver_attribute *attr)
 {
 	if (get_driver(drv)) {
 		sysfs_remove_file(&drv->p->kobj, &attr->attr);
 		put_driver(drv);
 	}
 }
-
+EXPORT_SYMBOL_GPL(driver_remove_file);
 
 /**
  * driver_add_kobj - add a kobject below the specified driver
@@ -149,10 +146,10 @@ int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
 EXPORT_SYMBOL_GPL(driver_add_kobj);
 
 /**
- *	get_driver - increment driver reference count.
- *	@drv:	driver.
+ * get_driver - increment driver reference count.
+ * @drv: driver.
  */
-struct device_driver * get_driver(struct device_driver * drv)
+struct device_driver *get_driver(struct device_driver *drv)
 {
 	if (drv) {
 		struct driver_private *priv;
@@ -164,16 +161,17 @@ struct device_driver * get_driver(struct device_driver * drv)
 	}
 	return NULL;
 }
-
+EXPORT_SYMBOL_GPL(get_driver);
 
 /**
- *	put_driver - decrement driver's refcount.
- *	@drv:	driver.
+ * put_driver - decrement driver's refcount.
+ * @drv: driver.
  */
-void put_driver(struct device_driver * drv)
+void put_driver(struct device_driver *drv)
 {
 	kobject_put(&drv->p->kobj);
 }
+EXPORT_SYMBOL_GPL(put_driver);
 
 static int driver_add_groups(struct device_driver *drv,
 			     struct attribute_group **groups)
@@ -205,24 +203,23 @@ static void driver_remove_groups(struct device_driver *drv,
 			sysfs_remove_group(&drv->p->kobj, groups[i]);
 }
 
-
 /**
- *	driver_register - register driver with bus
- *	@drv:	driver to register
+ * driver_register - register driver with bus
+ * @drv: driver to register
  *
- *	We pass off most of the work to the bus_add_driver() call,
- *	since most of the things we have to do deal with the bus
- *	structures.
+ * We pass off most of the work to the bus_add_driver() call,
+ * since most of the things we have to do deal with the bus
+ * structures.
  */
-int driver_register(struct device_driver * drv)
+int driver_register(struct device_driver *drv)
 {
 	int ret;
 
 	if ((drv->bus->probe && drv->probe) ||
 	    (drv->bus->remove && drv->remove) ||
-	    (drv->bus->shutdown && drv->shutdown)) {
-		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv->name);
-	}
+	    (drv->bus->shutdown && drv->shutdown))
+		printk(KERN_WARNING "Driver '%s' needs updating - please use "
+			"bus_type methods\n", drv->name);
 	ret = bus_add_driver(drv);
 	if (ret)
 		return ret;
@@ -231,29 +228,30 @@ int driver_register(struct device_driver * drv)
 		bus_remove_driver(drv);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(driver_register);
 
 /**
- *	driver_unregister - remove driver from system.
- *	@drv:	driver.
+ * driver_unregister - remove driver from system.
+ * @drv: driver.
  *
- *	Again, we pass off most of the work to the bus-level call.
+ * Again, we pass off most of the work to the bus-level call.
  */
-
-void driver_unregister(struct device_driver * drv)
+void driver_unregister(struct device_driver *drv)
 {
 	driver_remove_groups(drv, drv->groups);
 	bus_remove_driver(drv);
 }
+EXPORT_SYMBOL_GPL(driver_unregister);
 
 /**
- *	driver_find - locate driver on a bus by its name.
- *	@name:	name of the driver.
- *	@bus:	bus to scan for the driver.
+ * driver_find - locate driver on a bus by its name.
+ * @name: name of the driver.
+ * @bus: bus to scan for the driver.
  *
- *	Call kset_find_obj() to iterate over list of drivers on
- *	a bus to find driver by name. Return driver if found.
+ * Call kset_find_obj() to iterate over list of drivers on
+ * a bus to find driver by name. Return driver if found.
  *
- *	Note that kset_find_obj increments driver's reference count.
+ * Note that kset_find_obj increments driver's reference count.
  */
 struct device_driver *driver_find(const char *name, struct bus_type *bus)
 {
@@ -266,12 +264,4 @@ struct device_driver *driver_find(const char *name, struct bus_type *bus)
 	}
 	return NULL;
 }
-
-EXPORT_SYMBOL_GPL(driver_register);
-EXPORT_SYMBOL_GPL(driver_unregister);
-EXPORT_SYMBOL_GPL(get_driver);
-EXPORT_SYMBOL_GPL(put_driver);
 EXPORT_SYMBOL_GPL(driver_find);
-
-EXPORT_SYMBOL_GPL(driver_create_file);
-EXPORT_SYMBOL_GPL(driver_remove_file);

commit b2d6db5878a0832659ed58476357eea2db915550
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: rename kobject_add_ng() to kobject_add()
    
    Now that the old kobject_add() function is gone, rename kobject_add_ng()
    to kobject_add() to clean up the namespace.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 5aacff208f21..94b697a9b4e0 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -144,7 +144,7 @@ int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
 	if (!name)
 		return -ENOMEM;
 
-	return kobject_add_ng(kobj, &drv->p->kobj, "%s", name);
+	return kobject_add(kobj, &drv->p->kobj, "%s", name);
 }
 EXPORT_SYMBOL_GPL(driver_add_kobj);
 

commit e5dd12784617f0f1fae5f96a7fac1ec4c49fadbe
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 15:59:15 2007 -0800

    Driver core: move the static kobject out of struct driver
    
    This patch removes the kobject, and a few other driver-core-only fields
    out of struct driver and into the driver core only.  Now drivers can be
    safely create on the stack or statically (like they currently are.)
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 633ae1d70e14..5aacff208f21 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -3,6 +3,8 @@
  *
  * Copyright (c) 2002-3 Patrick Mochel
  * Copyright (c) 2002-3 Open Source Development Labs
+ * Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
+ * Copyright (c) 2007 Novell Inc.
  *
  * This file is released under the GPLv2
  *
@@ -15,7 +17,6 @@
 #include "base.h"
 
 #define to_dev(node) container_of(node, struct device, driver_list)
-#define to_drv(obj) container_of(obj, struct device_driver, kobj)
 
 
 static struct device * next_device(struct klist_iter * i)
@@ -44,7 +45,7 @@ int driver_for_each_device(struct device_driver * drv, struct device * start,
 	if (!drv)
 		return -EINVAL;
 
-	klist_iter_init_node(&drv->klist_devices, &i,
+	klist_iter_init_node(&drv->p->klist_devices, &i,
 			     start ? &start->knode_driver : NULL);
 	while ((dev = next_device(&i)) && !error)
 		error = fn(dev, data);
@@ -80,7 +81,7 @@ struct device * driver_find_device(struct device_driver *drv,
 	if (!drv)
 		return NULL;
 
-	klist_iter_init_node(&drv->klist_devices, &i,
+	klist_iter_init_node(&drv->p->klist_devices, &i,
 			     (start ? &start->knode_driver : NULL));
 	while ((dev = next_device(&i)))
 		if (match(dev, data) && get_device(dev))
@@ -100,7 +101,7 @@ int driver_create_file(struct device_driver * drv, struct driver_attribute * att
 {
 	int error;
 	if (get_driver(drv)) {
-		error = sysfs_create_file(&drv->kobj, &attr->attr);
+		error = sysfs_create_file(&drv->p->kobj, &attr->attr);
 		put_driver(drv);
 	} else
 		error = -EINVAL;
@@ -117,7 +118,7 @@ int driver_create_file(struct device_driver * drv, struct driver_attribute * att
 void driver_remove_file(struct device_driver * drv, struct driver_attribute * attr)
 {
 	if (get_driver(drv)) {
-		sysfs_remove_file(&drv->kobj, &attr->attr);
+		sysfs_remove_file(&drv->p->kobj, &attr->attr);
 		put_driver(drv);
 	}
 }
@@ -143,7 +144,7 @@ int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
 	if (!name)
 		return -ENOMEM;
 
-	return kobject_add_ng(kobj, &drv->kobj, "%s", name);
+	return kobject_add_ng(kobj, &drv->p->kobj, "%s", name);
 }
 EXPORT_SYMBOL_GPL(driver_add_kobj);
 
@@ -153,7 +154,15 @@ EXPORT_SYMBOL_GPL(driver_add_kobj);
  */
 struct device_driver * get_driver(struct device_driver * drv)
 {
-	return drv ? to_drv(kobject_get(&drv->kobj)) : NULL;
+	if (drv) {
+		struct driver_private *priv;
+		struct kobject *kobj;
+
+		kobj = kobject_get(&drv->p->kobj);
+		priv = to_driver(kobj);
+		return priv->driver;
+	}
+	return NULL;
 }
 
 
@@ -163,7 +172,7 @@ struct device_driver * get_driver(struct device_driver * drv)
  */
 void put_driver(struct device_driver * drv)
 {
-	kobject_put(&drv->kobj);
+	kobject_put(&drv->p->kobj);
 }
 
 static int driver_add_groups(struct device_driver *drv,
@@ -174,10 +183,10 @@ static int driver_add_groups(struct device_driver *drv,
 
 	if (groups) {
 		for (i = 0; groups[i]; i++) {
-			error = sysfs_create_group(&drv->kobj, groups[i]);
+			error = sysfs_create_group(&drv->p->kobj, groups[i]);
 			if (error) {
 				while (--i >= 0)
-					sysfs_remove_group(&drv->kobj,
+					sysfs_remove_group(&drv->p->kobj,
 							   groups[i]);
 				break;
 			}
@@ -193,7 +202,7 @@ static void driver_remove_groups(struct device_driver *drv,
 
 	if (groups)
 		for (i = 0; groups[i]; i++)
-			sysfs_remove_group(&drv->kobj, groups[i]);
+			sysfs_remove_group(&drv->p->kobj, groups[i]);
 }
 
 
@@ -214,7 +223,6 @@ int driver_register(struct device_driver * drv)
 	    (drv->bus->shutdown && drv->shutdown)) {
 		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv->name);
 	}
-	klist_init(&drv->klist_devices, NULL, NULL);
 	ret = bus_add_driver(drv);
 	if (ret)
 		return ret;
@@ -250,8 +258,12 @@ void driver_unregister(struct device_driver * drv)
 struct device_driver *driver_find(const char *name, struct bus_type *bus)
 {
 	struct kobject *k = kset_find_obj(bus->p->drivers_kset, name);
-	if (k)
-		return to_drv(k);
+	struct driver_private *priv;
+
+	if (k) {
+		priv = to_driver(k);
+		return priv->driver;
+	}
 	return NULL;
 }
 

commit cbe9c595f1de2e2a98403be2c14bfbc2486e84c4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Dec 19 15:54:39 2007 -0400

    Driver: add driver_add_kobj for looney iseries_veth driver
    
    The iseries driver wants to hang kobjects off of its driver, so, to
    preserve backwards compatibility, we need to add a call to the driver
    core to allow future changes to work properly.
    
    Hopefully no one uses this function in the future and the iseries_veth
    driver authors come to their senses so I can remove this hack...
    
    Cc: Dave Larson <larson1@us.ibm.com>
    Cc: Santiago Leon <santil@us.ibm.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index e3b58407fedc..633ae1d70e14 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -123,6 +123,30 @@ void driver_remove_file(struct device_driver * drv, struct driver_attribute * at
 }
 
 
+/**
+ * driver_add_kobj - add a kobject below the specified driver
+ *
+ * You really don't want to do this, this is only here due to one looney
+ * iseries driver, go poke those developers if you are annoyed about
+ * this...
+ */
+int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
+		    const char *fmt, ...)
+{
+	va_list args;
+	char *name;
+
+	va_start(args, fmt);
+	name = kvasprintf(GFP_KERNEL, fmt, args);
+	va_end(args);
+
+	if (!name)
+		return -ENOMEM;
+
+	return kobject_add_ng(kobj, &drv->kobj, "%s", name);
+}
+EXPORT_SYMBOL_GPL(driver_add_kobj);
+
 /**
  *	get_driver - increment driver reference count.
  *	@drv:	driver.

commit 57c745340a60c51d2b9af3d4dcf7e0ede284855b
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Dec 5 12:50:23 2007 +0100

    driver core: Introduce default attribute groups.
    
    This is lot like default attributes for devices (and indeed,
    a lot of the code is lifted from there).
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index f94be40646d2..e3b58407fedc 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -142,6 +142,37 @@ void put_driver(struct device_driver * drv)
 	kobject_put(&drv->kobj);
 }
 
+static int driver_add_groups(struct device_driver *drv,
+			     struct attribute_group **groups)
+{
+	int error = 0;
+	int i;
+
+	if (groups) {
+		for (i = 0; groups[i]; i++) {
+			error = sysfs_create_group(&drv->kobj, groups[i]);
+			if (error) {
+				while (--i >= 0)
+					sysfs_remove_group(&drv->kobj,
+							   groups[i]);
+				break;
+			}
+		}
+	}
+	return error;
+}
+
+static void driver_remove_groups(struct device_driver *drv,
+				 struct attribute_group **groups)
+{
+	int i;
+
+	if (groups)
+		for (i = 0; groups[i]; i++)
+			sysfs_remove_group(&drv->kobj, groups[i]);
+}
+
+
 /**
  *	driver_register - register driver with bus
  *	@drv:	driver to register
@@ -152,13 +183,21 @@ void put_driver(struct device_driver * drv)
  */
 int driver_register(struct device_driver * drv)
 {
+	int ret;
+
 	if ((drv->bus->probe && drv->probe) ||
 	    (drv->bus->remove && drv->remove) ||
 	    (drv->bus->shutdown && drv->shutdown)) {
 		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv->name);
 	}
 	klist_init(&drv->klist_devices, NULL, NULL);
-	return bus_add_driver(drv);
+	ret = bus_add_driver(drv);
+	if (ret)
+		return ret;
+	ret = driver_add_groups(drv, drv->groups);
+	if (ret)
+		bus_remove_driver(drv);
+	return ret;
 }
 
 /**
@@ -170,6 +209,7 @@ int driver_register(struct device_driver * drv)
 
 void driver_unregister(struct device_driver * drv)
 {
+	driver_remove_groups(drv, drv->groups);
 	bus_remove_driver(drv);
 }
 

commit c6f7e72a3f4641095ade9ded287d910c980c6148
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 19:41:16 2007 -0700

    driver core: remove fields from struct bus_type
    
    struct bus_type is static everywhere in the kernel.  This moves the
    kobject in the structure out of it, and a bunch of other private only to
    the driver core fields are now moved to a private structure.  This lets
    us dynamically create the backing kobject properly and gives us the
    chance to be able to document to users exactly how to use the struct
    bus_type as there are no fields they can improperly access.
    
    Thanks to Kay for the build fixes on this patch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 1c9770dfb801..f94be40646d2 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -185,7 +185,7 @@ void driver_unregister(struct device_driver * drv)
  */
 struct device_driver *driver_find(const char *name, struct bus_type *bus)
 {
-	struct kobject *k = kset_find_obj(bus->drivers_kset, name);
+	struct kobject *k = kset_find_obj(bus->p->drivers_kset, name);
 	if (k)
 		return to_drv(k);
 	return NULL;

commit 6dcec2511ff55b4abaca7ad3433011a7c04c2430
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 13:31:26 2007 -0700

    kset: convert struct bus_device->drivers to use kset_create
    
    Dynamically create the kset instead of declaring it statically.
    
    Having 3 static kobjects in one structure is not only foolish, but ripe
    for nasty race conditions if handled improperly.  We also rename the
    field to catch any potential users of it (not that there should be
    outside of the driver core...)
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index eb11475293ed..1c9770dfb801 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -185,7 +185,7 @@ void driver_unregister(struct device_driver * drv)
  */
 struct device_driver *driver_find(const char *name, struct bus_type *bus)
 {
-	struct kobject *k = kset_find_obj(&bus->drivers, name);
+	struct kobject *k = kset_find_obj(bus->drivers_kset, name);
 	if (k)
 		return to_drv(k);
 	return NULL;

commit 74e9f5fa1570f956c96dd5d3f1053daedbbf01a0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Apr 9 12:14:34 2002 -0700

    Driver core: remove unneeded completion from driver release path
    
    The completion in the driver release path is due to ancient history in
    the _very_ early 2.5 days when we were not tracking the module reference
    count of attributes.  It is not needed at all and can be removed.
    
    Note, we now have an empty release function for the driver structure.
    This is due to the fact that drivers are statically allocated in the
    system at this point in time, something which I want to change in the
    future.  But remember, drivers are really code, which is reference
    counted by the module, unlike devices, which are data and _must_ be
    reference counted properly in order to work correctly.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 082bfded3854..eb11475293ed 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -149,10 +149,6 @@ void put_driver(struct device_driver * drv)
  *	We pass off most of the work to the bus_add_driver() call,
  *	since most of the things we have to do deal with the bus
  *	structures.
- *
- *	The one interesting aspect is that we setup @drv->unloaded
- *	as a completion that gets complete when the driver reference
- *	count reaches 0.
  */
 int driver_register(struct device_driver * drv)
 {
@@ -162,35 +158,19 @@ int driver_register(struct device_driver * drv)
 		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv->name);
 	}
 	klist_init(&drv->klist_devices, NULL, NULL);
-	init_completion(&drv->unloaded);
 	return bus_add_driver(drv);
 }
 
-
 /**
  *	driver_unregister - remove driver from system.
  *	@drv:	driver.
  *
  *	Again, we pass off most of the work to the bus-level call.
- *
- *	Though, once that is done, we wait until @drv->unloaded is completed.
- *	This will block until the driver refcount reaches 0, and it is
- *	released. Only modular drivers will call this function, and we
- *	have to guarantee that it won't complete, letting the driver
- *	unload until all references are gone.
  */
 
 void driver_unregister(struct device_driver * drv)
 {
 	bus_remove_driver(drv);
-	/*
-	 * If the driver is a module, we are probably in
-	 * the module unload path, and we want to wait
-	 * for everything to unload before we can actually
-	 * finish the unload.
-	 */
-	if (drv->owner)
-		wait_for_completion(&drv->unloaded);
 }
 
 /**

commit f5ef2abcbeb5b0be23f7cc610a024b2406e3d8e6
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sun Apr 1 10:54:13 2007 -0700

    driver core: do not wait unnecessarily in driver_unregister()
    
    Ingo reported that built-in drivers suffered bootup hangs with certain
    driver unregistry sequences, due to sysfs breakage.
    
    Do the minimal fix for v2.6.21: only wait if the driver is a module.
    
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 1214cbd17d86..082bfded3854 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -183,7 +183,14 @@ int driver_register(struct device_driver * drv)
 void driver_unregister(struct device_driver * drv)
 {
 	bus_remove_driver(drv);
-	wait_for_completion(&drv->unloaded);
+	/*
+	 * If the driver is a module, we are probably in
+	 * the module unload path, and we want to wait
+	 * for everything to unload before we can actually
+	 * finish the unload.
+	 */
+	if (drv->owner)
+		wait_for_completion(&drv->unloaded);
 }
 
 /**

commit 81107bf531d2524afbcd61f3b4ad57a71295d591
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Sep 18 16:24:28 2006 -0400

    Driver core: Remove unneeded routines from driver core
    
    This patch (as783) simplifies the driver core slightly by removing four
    unnecessary _get and _put methods.
    
    It is vital that when a driver is removed from its bus's klist of
    registered drivers, or when a device is removed from a driver's klist
    of bound devices, that the klist updates complete synchronously.
    Otherwise the kernel might try binding an unregistered driver to a
    newly-registered device, or adding a device to the klist for a new
    driver before it has been removed from the old driver's klist.
    
    Since the removals must be synchronous, they don't need to update any
    reference counts.  Hence the _get and _put methods can be dispensed
    with.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 562600dd540a..1214cbd17d86 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -142,20 +142,6 @@ void put_driver(struct device_driver * drv)
 	kobject_put(&drv->kobj);
 }
 
-static void klist_devices_get(struct klist_node *n)
-{
-	struct device *dev = container_of(n, struct device, knode_driver);
-
-	get_device(dev);
-}
-
-static void klist_devices_put(struct klist_node *n)
-{
-	struct device *dev = container_of(n, struct device, knode_driver);
-
-	put_device(dev);
-}
-
 /**
  *	driver_register - register driver with bus
  *	@drv:	driver to register
@@ -175,7 +161,7 @@ int driver_register(struct device_driver * drv)
 	    (drv->bus->shutdown && drv->shutdown)) {
 		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv->name);
 	}
-	klist_init(&drv->klist_devices, klist_devices_get, klist_devices_put);
+	klist_init(&drv->klist_devices, NULL, NULL);
 	init_completion(&drv->unloaded);
 	return bus_add_driver(drv);
 }

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index b400314e1c62..562600dd540a 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -8,7 +8,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/errno.h>

commit 594c8281f90560faf9632d91bb9d402cbe560e63
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Thu Jan 5 14:29:51 2006 +0000

    [PATCH] Add bus_type probe, remove, shutdown methods.
    
    Add bus_type probe, remove and shutdown methods to replace the
    corresponding methods in struct device_driver.  This matches
    the way we handle the suspend/resume methods.
    
    Since the bus methods override the device_driver methods, warn
    if a device driver is registered whose methods will not be
    called.
    
    The long-term idea is to remove the device_driver methods entirely.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 161f3a390d90..b400314e1c62 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -171,6 +171,11 @@ static void klist_devices_put(struct klist_node *n)
  */
 int driver_register(struct device_driver * drv)
 {
+	if ((drv->bus->probe && drv->probe) ||
+	    (drv->bus->remove && drv->remove) ||
+	    (drv->bus->shutdown && drv->shutdown)) {
+		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv->name);
+	}
 	klist_init(&drv->klist_devices, klist_devices_get, klist_devices_put);
 	init_completion(&drv->unloaded);
 	return bus_add_driver(drv);

commit c41455fbac06712992da491844449775cf9a8c80
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Oct 23 11:59:14 2005 -0700

    [PATCH] kernel-doc: drivers/base fixes
    
    driver/base: add missing function parameters; eliminate all warnings.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index ef3fe513e398..161f3a390d90 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -28,6 +28,7 @@ static struct device * next_device(struct klist_iter * i)
 /**
  *	driver_for_each_device - Iterator for devices bound to a driver.
  *	@drv:	Driver we're iterating.
+ *	@start: Device to begin with
  *	@data:	Data to pass to the callback.
  *	@fn:	Function to call for each device.
  *
@@ -57,7 +58,7 @@ EXPORT_SYMBOL_GPL(driver_for_each_device);
 
 /**
  * driver_find_device - device iterator for locating a particular device.
- * @driver: The device's driver
+ * @drv: The device's driver
  * @start: Device to begin with
  * @data: Data to pass to match function
  * @match: Callback function to check device

commit 34bb61f9ddabd7a7f909cbfb05592eb775f6662a
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Sep 6 16:56:51 2005 -0700

    [PATCH] fix klist semantics for lists which have elements removed on traversal
    
    The problem is that klists claim to provide semantics for safe traversal of
    lists which are being modified.  The failure case is when traversal of a
    list causes element removal (a fairly common case).  The issue is that
    although the list node is refcounted, if it is embedded in an object (which
    is universally the case), then the object will be freed regardless of the
    klist refcount leading to slab corruption because the klist iterator refers
    to the prior element to get the next.
    
    The solution is to make the klist take and release references to the
    embedding object meaning that the embedding object won't be released until
    the list relinquishes the reference to it.
    
    (akpm: fast-track this because it's needed for the 2.6.13 scsi merge)
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 291c5954a3af..ef3fe513e398 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -142,6 +142,19 @@ void put_driver(struct device_driver * drv)
 	kobject_put(&drv->kobj);
 }
 
+static void klist_devices_get(struct klist_node *n)
+{
+	struct device *dev = container_of(n, struct device, knode_driver);
+
+	get_device(dev);
+}
+
+static void klist_devices_put(struct klist_node *n)
+{
+	struct device *dev = container_of(n, struct device, knode_driver);
+
+	put_device(dev);
+}
 
 /**
  *	driver_register - register driver with bus
@@ -157,7 +170,7 @@ void put_driver(struct device_driver * drv)
  */
 int driver_register(struct device_driver * drv)
 {
-	klist_init(&drv->klist_devices);
+	klist_init(&drv->klist_devices, klist_devices_get, klist_devices_put);
 	init_completion(&drv->unloaded);
 	return bus_add_driver(drv);
 }

commit 0edb586049e57c56e625536476931117a57671e9
Author: Cornelia Huck <cohuck@de.ibm.com>
Date:   Wed Jun 22 16:59:51 2005 +0200

    [PATCH] driver core: add bus_find_device & driver_find_device functions
    
    Add bus_find_device() and driver_find_device() which allow searching for a
    device in the bus's resp. the driver's klist and obtain a reference on it.
    
    Signed-off-by: Cornelia Huck <cohuck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 1b645886e9eb..291c5954a3af 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -55,6 +55,41 @@ int driver_for_each_device(struct device_driver * drv, struct device * start,
 EXPORT_SYMBOL_GPL(driver_for_each_device);
 
 
+/**
+ * driver_find_device - device iterator for locating a particular device.
+ * @driver: The device's driver
+ * @start: Device to begin with
+ * @data: Data to pass to match function
+ * @match: Callback function to check device
+ *
+ * This is similar to the driver_for_each_device() function above, but
+ * it returns a reference to a device that is 'found' for later use, as
+ * determined by the @match callback.
+ *
+ * The callback should return 0 if the device doesn't match and non-zero
+ * if it does.  If the callback returns non-zero, this function will
+ * return to the caller and not iterate over any more devices.
+ */
+struct device * driver_find_device(struct device_driver *drv,
+				   struct device * start, void * data,
+				   int (*match)(struct device *, void *))
+{
+	struct klist_iter i;
+	struct device *dev;
+
+	if (!drv)
+		return NULL;
+
+	klist_iter_init_node(&drv->klist_devices, &i,
+			     (start ? &start->knode_driver : NULL));
+	while ((dev = next_device(&i)))
+		if (match(dev, data) && get_device(dev))
+			break;
+	klist_iter_exit(&i);
+	return dev;
+}
+EXPORT_SYMBOL_GPL(driver_find_device);
+
 /**
  *	driver_create_file - create sysfs file for driver.
  *	@drv:	driver.

commit 126eddfbf8cae8a20c22708192bffcbd77c8a889
Author: gregkh@suse.de <gregkh@suse.de>
Date:   Tue Mar 22 12:17:13 2005 -0800

    [PATCH] driver core: change export symbol for driver_for_each_device()
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    Index: linux-2.6.12-rc2/drivers/base/driver.c
    ===================================================================

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index f789b6cb4b56..1b645886e9eb 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -52,7 +52,7 @@ int driver_for_each_device(struct device_driver * drv, struct device * start,
 	return error;
 }
 
-EXPORT_SYMBOL(driver_for_each_device);
+EXPORT_SYMBOL_GPL(driver_for_each_device);
 
 
 /**

commit 4d12d2d953ca5e299de6a653f1d0478f670d7bc6
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 20:08:04 2005 -0800

    [PATCH] Fix up bogus comment.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -Nru a/drivers/base/driver.c b/drivers/base/driver.c

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 34bd38aa7eb8..f789b6cb4b56 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -31,8 +31,7 @@ static struct device * next_device(struct klist_iter * i)
  *	@data:	Data to pass to the callback.
  *	@fn:	Function to call for each device.
  *
- *	Take the bus's rwsem and iterate over the @drv's list of devices,
- *	calling @fn for each one.
+ *	Iterate over the @drv's list of devices calling @fn for each one.
  */
 
 int driver_for_each_device(struct device_driver * drv, struct device * start, 

commit 94e7b1c5ff2055571703e38b059afffe17658432
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 12:25:36 2005 -0800

    [PATCH] Add a klist to struct device_driver for the devices bound to it.
    
    - Use it in driver_for_each_device() instead of the regular list_head and stop using
      the bus's rwsem for protection.
    - Use driver_for_each_device() in driver_detach() so we don't deadlock on the
      bus's rwsem.
    - Remove ->devices.
    - Move klist access and sysfs link access out from under device's semaphore, since
      they're synchronized through other means.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 484fed1985aa..34bd38aa7eb8 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -19,6 +19,12 @@
 #define to_drv(obj) container_of(obj, struct device_driver, kobj)
 
 
+static struct device * next_device(struct klist_iter * i)
+{
+	struct klist_node * n = klist_next(i);
+	return n ? container_of(n, struct device, knode_driver) : NULL;
+}
+
 /**
  *	driver_for_each_device - Iterator for devices bound to a driver.
  *	@drv:	Driver we're iterating.
@@ -32,21 +38,18 @@
 int driver_for_each_device(struct device_driver * drv, struct device * start, 
 			   void * data, int (*fn)(struct device *, void *))
 {
-	struct list_head * head;
+	struct klist_iter i;
 	struct device * dev;
 	int error = 0;
 
-	down_read(&drv->bus->subsys.rwsem);
-	head = &drv->devices;
-	dev = list_prepare_entry(start, head, driver_list);
-	list_for_each_entry_continue(dev, head, driver_list) {
-		get_device(dev);
+	if (!drv)
+		return -EINVAL;
+
+	klist_iter_init_node(&drv->klist_devices, &i,
+			     start ? &start->knode_driver : NULL);
+	while ((dev = next_device(&i)) && !error)
 		error = fn(dev, data);
-		put_device(dev);
-		if (error)
-			break;
-	}
-	up_read(&drv->bus->subsys.rwsem);
+	klist_iter_exit(&i);
 	return error;
 }
 
@@ -120,7 +123,7 @@ void put_driver(struct device_driver * drv)
  */
 int driver_register(struct device_driver * drv)
 {
-	INIT_LIST_HEAD(&drv->devices);
+	klist_init(&drv->klist_devices);
 	init_completion(&drv->unloaded);
 	return bus_add_driver(drv);
 }

commit fae3cd00255e3e51ffd59fedb1bdb91ec96be395
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 10:59:56 2005 -0800

    [PATCH] Add driver_for_each_device().
    
    Now there's an iterator for accessing each device bound to a driver.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    Index: linux-2.6.12-rc2/drivers/base/driver.c
    ===================================================================

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 3b269f7e5213..484fed1985aa 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -18,6 +18,41 @@
 #define to_dev(node) container_of(node, struct device, driver_list)
 #define to_drv(obj) container_of(obj, struct device_driver, kobj)
 
+
+/**
+ *	driver_for_each_device - Iterator for devices bound to a driver.
+ *	@drv:	Driver we're iterating.
+ *	@data:	Data to pass to the callback.
+ *	@fn:	Function to call for each device.
+ *
+ *	Take the bus's rwsem and iterate over the @drv's list of devices,
+ *	calling @fn for each one.
+ */
+
+int driver_for_each_device(struct device_driver * drv, struct device * start, 
+			   void * data, int (*fn)(struct device *, void *))
+{
+	struct list_head * head;
+	struct device * dev;
+	int error = 0;
+
+	down_read(&drv->bus->subsys.rwsem);
+	head = &drv->devices;
+	dev = list_prepare_entry(start, head, driver_list);
+	list_for_each_entry_continue(dev, head, driver_list) {
+		get_device(dev);
+		error = fn(dev, data);
+		put_device(dev);
+		if (error)
+			break;
+	}
+	up_read(&drv->bus->subsys.rwsem);
+	return error;
+}
+
+EXPORT_SYMBOL(driver_for_each_device);
+
+
 /**
  *	driver_create_file - create sysfs file for driver.
  *	@drv:	driver.

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
new file mode 100644
index 000000000000..3b269f7e5213
--- /dev/null
+++ b/drivers/base/driver.c
@@ -0,0 +1,138 @@
+/*
+ * driver.c - centralized device driver management
+ *
+ * Copyright (c) 2002-3 Patrick Mochel
+ * Copyright (c) 2002-3 Open Source Development Labs
+ *
+ * This file is released under the GPLv2
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include "base.h"
+
+#define to_dev(node) container_of(node, struct device, driver_list)
+#define to_drv(obj) container_of(obj, struct device_driver, kobj)
+
+/**
+ *	driver_create_file - create sysfs file for driver.
+ *	@drv:	driver.
+ *	@attr:	driver attribute descriptor.
+ */
+
+int driver_create_file(struct device_driver * drv, struct driver_attribute * attr)
+{
+	int error;
+	if (get_driver(drv)) {
+		error = sysfs_create_file(&drv->kobj, &attr->attr);
+		put_driver(drv);
+	} else
+		error = -EINVAL;
+	return error;
+}
+
+
+/**
+ *	driver_remove_file - remove sysfs file for driver.
+ *	@drv:	driver.
+ *	@attr:	driver attribute descriptor.
+ */
+
+void driver_remove_file(struct device_driver * drv, struct driver_attribute * attr)
+{
+	if (get_driver(drv)) {
+		sysfs_remove_file(&drv->kobj, &attr->attr);
+		put_driver(drv);
+	}
+}
+
+
+/**
+ *	get_driver - increment driver reference count.
+ *	@drv:	driver.
+ */
+struct device_driver * get_driver(struct device_driver * drv)
+{
+	return drv ? to_drv(kobject_get(&drv->kobj)) : NULL;
+}
+
+
+/**
+ *	put_driver - decrement driver's refcount.
+ *	@drv:	driver.
+ */
+void put_driver(struct device_driver * drv)
+{
+	kobject_put(&drv->kobj);
+}
+
+
+/**
+ *	driver_register - register driver with bus
+ *	@drv:	driver to register
+ *
+ *	We pass off most of the work to the bus_add_driver() call,
+ *	since most of the things we have to do deal with the bus
+ *	structures.
+ *
+ *	The one interesting aspect is that we setup @drv->unloaded
+ *	as a completion that gets complete when the driver reference
+ *	count reaches 0.
+ */
+int driver_register(struct device_driver * drv)
+{
+	INIT_LIST_HEAD(&drv->devices);
+	init_completion(&drv->unloaded);
+	return bus_add_driver(drv);
+}
+
+
+/**
+ *	driver_unregister - remove driver from system.
+ *	@drv:	driver.
+ *
+ *	Again, we pass off most of the work to the bus-level call.
+ *
+ *	Though, once that is done, we wait until @drv->unloaded is completed.
+ *	This will block until the driver refcount reaches 0, and it is
+ *	released. Only modular drivers will call this function, and we
+ *	have to guarantee that it won't complete, letting the driver
+ *	unload until all references are gone.
+ */
+
+void driver_unregister(struct device_driver * drv)
+{
+	bus_remove_driver(drv);
+	wait_for_completion(&drv->unloaded);
+}
+
+/**
+ *	driver_find - locate driver on a bus by its name.
+ *	@name:	name of the driver.
+ *	@bus:	bus to scan for the driver.
+ *
+ *	Call kset_find_obj() to iterate over list of drivers on
+ *	a bus to find driver by name. Return driver if found.
+ *
+ *	Note that kset_find_obj increments driver's reference count.
+ */
+struct device_driver *driver_find(const char *name, struct bus_type *bus)
+{
+	struct kobject *k = kset_find_obj(&bus->drivers, name);
+	if (k)
+		return to_drv(k);
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(driver_register);
+EXPORT_SYMBOL_GPL(driver_unregister);
+EXPORT_SYMBOL_GPL(get_driver);
+EXPORT_SYMBOL_GPL(put_driver);
+EXPORT_SYMBOL_GPL(driver_find);
+
+EXPORT_SYMBOL_GPL(driver_create_file);
+EXPORT_SYMBOL_GPL(driver_remove_file);
