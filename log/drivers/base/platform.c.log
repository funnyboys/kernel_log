commit f558b8364e19f9222e7976c64e9367f66bab02cc
Merge: 80ef846e9909 8c3e315d4296
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 7 10:53:36 2020 -0700

    Merge tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of driver core patches for 5.8-rc1.
    
      Not all that huge this release, just a number of small fixes and
      updates:
    
       - software node fixes
    
       - kobject now sends KOBJ_REMOVE when it is removed from sysfs, not
         when it is removed from memory (which could come much later)
    
       - device link additions and fixes based on testing on more devices
    
       - firmware core cleanups
    
       - other minor changes, full details in the shortlog
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (23 commits)
      driver core: Update device link status correctly for SYNC_STATE_ONLY links
      firmware_loader: change enum fw_opt to u32
      software node: implement software_node_unregister()
      kobject: send KOBJ_REMOVE uevent when the object is removed from sysfs
      driver core: Remove unnecessary is_fwnode_dev variable in device_add()
      drivers property: When no children in primary, try secondary
      driver core: platform: Fix spelling errors in platform.c
      driver core: Remove check in driver_deferred_probe_force_trigger()
      of: platform: Batch fwnode parsing when adding all top level devices
      driver core: fw_devlink: Add support for batching fwnode parsing
      driver core: Look for waiting consumers only for a fwnode's primary device
      driver core: Move code to the right part of the file
      Revert "Revert "driver core: Set fw_devlink to "permissive" behavior by default""
      drivers: base: Fix NULL pointer exception in __platform_driver_probe() if a driver developer is foolish
      firmware_loader: move fw_fallback_config to a private kernel symbol namespace
      driver core: Add missing '\n' in log messages
      driver/base/soc: Use kobj_to_dev() API
      Add documentation on meaning of -EPROBE_DEFER
      driver core: platform: remove redundant assignment to variable ret
      debugfs: Use the correct style for SPDX License Identifier
      ...

commit 3925c3bbdf886f1ddf64461b9b380e1bb36f90c1
Merge: 9fa88c5d3f5e 2bd81cd04a3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 6 11:01:58 2020 -0700

    Merge tag 'pci-v5.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
    
       - Program MPS for RCiEP devices (Ashok Raj)
    
       - Fix pci_register_host_bridge() device_register() error handling
         (Rob Herring)
    
       - Fix pci_host_bridge struct device release/free handling (Rob
         Herring)
    
      Resource management:
    
       - Allow resizing BARs for devices on root bus (Ard Biesheuvel)
    
      Power management:
    
       - Reduce Thunderbolt resume time by working around devices that don't
         support DLL Link Active reporting (Mika Westerberg)
    
       - Work around a Pericom USB controller OHCI/EHCI PME# defect
         (Kai-Heng Feng)
    
      Virtualization:
    
       - Add ACS quirk for Intel Root Complex Integrated Endpoints (Ashok
         Raj)
    
       - Avoid FLR for AMD Starship USB 3.0 (Kevin Buettner)
    
       - Avoid FLR for AMD Matisse HD Audio & USB 3.0 (Marcos Scriven)
    
      Error handling:
    
       - Use only _OSC (not HEST FIRMWARE_FIRST) to determine AER ownership
         (Alexandru Gagniuc, Kuppuswamy Sathyanarayanan)
    
       - Reduce verbosity by logging only ACPI_NOTIFY_DISCONNECT_RECOVER
         events (Kuppuswamy Sathyanarayanan)
    
       - Don't enable AER by default in Kconfig (Bjorn Helgaas)
    
      Peer-to-peer DMA:
    
       - Add AMD Zen Raven and Renoir Root Ports to whitelist (Alex Deucher)
    
      ASPM:
    
       - Allow ASPM on links to PCIe-to-PCI/PCI-X Bridges (Kai-Heng Feng)
    
      Endpoint framework:
    
       - Fix DMA channel release in test (Kunihiko Hayashi)
    
       - Add page size as argument to pci_epc_mem_init() (Lad Prabhakar)
    
       - Add support to handle multiple base for mapping outbound memory
         (Lad Prabhakar)
    
      Generic host bridge driver:
    
       - Support building as module (Rob Herring)
    
       - Eliminate pci_host_common_probe wrappers (Rob Herring)
    
      Amlogic Meson PCIe controller driver:
    
       - Don't use FAST_LINK_MODE to set up link (Marc Zyngier)
    
      Broadcom STB PCIe controller driver:
    
       - Disable ASPM L0s if 'aspm-no-l0s' in DT (Jim Quinlan)
    
       - Fix clk_put() error (Jim Quinlan)
    
       - Fix window register offset (Jim Quinlan)
    
       - Assert fundamental reset on initialization (Nicolas Saenz Julienne)
    
       - Add notify xHCI reset property (Nicolas Saenz Julienne)
    
       - Add init routine for Raspberry Pi 4 VL805 USB controller (Nicolas
         Saenz Julienne)
    
       - Sync with Raspberry Pi 4 firmware for VL805 initialization (Nicolas
         Saenz Julienne)
    
      Cadence PCIe controller driver:
    
       - Remove "cdns,max-outbound-regions" DT property (replaced by
         "ranges") (Kishon Vijay Abraham I)
    
       - Read 32-bit (not 16-bit) Vendor ID/Device ID property from DT
         (Kishon Vijay Abraham I)
    
      Marvell Aardvark PCIe controller driver:
    
       - Improve link training (Marek Behún)
    
       - Add PHY support (Marek Behún)
    
       - Add "phys", "max-link-speed", "reset-gpios" to dt-binding (Marek
         Behún)
    
       - Train link immediately after enabling training to work around
         detection issues with some cards (Pali Rohár)
    
       - Issue PERST via GPIO to work around detection issues (Pali Rohár)
    
       - Don't blindly enable ASPM L0s (Pali Rohár)
    
       - Replace custom macros by standard linux/pci_regs.h macros (Pali
         Rohár)
    
      Microsoft Hyper-V host bridge driver:
    
       - Fix probe failure path to release resource (Wei Hu)
    
       - Retry PCI bus D0 entry on invalid device state for kdump (Wei Hu)
    
      Renesas R-Car PCIe controller driver:
    
       - Fix incorrect programming of OB windows (Andrew Murray)
    
       - Add suspend/resume (Kazufumi Ikeda)
    
       - Rename pcie-rcar.c to pcie-rcar-host.c (Lad Prabhakar)
    
       - Add endpoint controller driver (Lad Prabhakar)
    
       - Fix PCIEPAMR mask calculation (Lad Prabhakar)
    
       - Add r8a77961 to DT binding (Yoshihiro Shimoda)
    
      Socionext UniPhier Pro5 controller driver:
    
       - Add endpoint controller driver (Kunihiko Hayashi)
    
      Synopsys DesignWare PCIe controller driver:
    
       - Program outbound ATU upper limit register (Alan Mikhak)
    
       - Fix inner MSI IRQ domain registration (Marc Zyngier)
    
      Miscellaneous:
    
       - Check for platform_get_irq() failure consistently (negative return
         means failure) (Aman Sharma)
    
       - Fix several runtime PM get/put imbalances (Dinghao Liu)
    
       - Use flexible-array and struct_size() helpers for code cleanup
         (Gustavo A. R. Silva)
    
       - Update & fix issues in bridge emulation of PCIe registers (Jon
         Derrick)
    
       - Add macros for bridge window names (PCI_BRIDGE_IO_WINDOW, etc)
         (Krzysztof Wilczyński)
    
       - Work around Intel PCH MROMs that have invalid BARs (Xiaochun Lee)"
    
    * tag 'pci-v5.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (100 commits)
      PCI: uniphier: Add Socionext UniPhier Pro5 PCIe endpoint controller driver
      PCI: Add ACS quirk for Intel Root Complex Integrated Endpoints
      PCI/DPC: Print IRQ number used by port
      PCI/AER: Use "aer" variable for capability offset
      PCI/AER: Remove redundant dev->aer_cap checks
      PCI/AER: Remove redundant pci_is_pcie() checks
      PCI/AER: Remove HEST/FIRMWARE_FIRST parsing for AER ownership
      PCI: tegra: Fix runtime PM imbalance on error
      PCI: vmd: Filter resource type bits from shadow register
      PCI: tegra194: Fix runtime PM imbalance on error
      dt-bindings: PCI: Add UniPhier PCIe endpoint controller description
      PCI: hv: Use struct_size() helper
      PCI: Rename _DSM constants to align with spec
      PCI: Avoid FLR for AMD Starship USB 3.0
      PCI: Avoid FLR for AMD Matisse HD Audio & USB 3.0
      x86/PCI: Drop unused xen_register_pirq() gsi_override parameter
      PCI: dwc: Use private data pointer of "struct irq_domain" to get pcie_port
      PCI: amlogic: meson: Don't use FAST_LINK_MODE to set up link
      PCI: dwc: Fix inner MSI IRQ domain registration
      PCI: dwc: pci-dra7xx: Use devm_platform_ioremap_resource_byname()
      ...

commit b23c4771ff62de8ca9b5e4a2d64491b2fb6f8f69
Merge: c2b0fc847f31 e35b5a4c494a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 1 15:45:27 2020 -0700

    Merge tag 'docs-5.8' of git://git.lwn.net/linux
    
    Pull documentation updates from Jonathan Corbet:
     "A fair amount of stuff this time around, dominated by yet another
      massive set from Mauro toward the completion of the RST conversion. I
      *really* hope we are getting close to the end of this. Meanwhile,
      those patches reach pretty far afield to update document references
      around the tree; there should be no actual code changes there. There
      will be, alas, more of the usual trivial merge conflicts.
    
      Beyond that we have more translations, improvements to the sphinx
      scripting, a number of additions to the sysctl documentation, and lots
      of fixes"
    
    * tag 'docs-5.8' of git://git.lwn.net/linux: (130 commits)
      Documentation: fixes to the maintainer-entry-profile template
      zswap: docs/vm: Fix typo accept_threshold_percent in zswap.rst
      tracing: Fix events.rst section numbering
      docs: acpi: fix old http link and improve document format
      docs: filesystems: add info about efivars content
      Documentation: LSM: Correct the basic LSM description
      mailmap: change email for Ricardo Ribalda
      docs: sysctl/kernel: document unaligned controls
      Documentation: admin-guide: update bug-hunting.rst
      docs: sysctl/kernel: document ngroups_max
      nvdimm: fixes to maintainter-entry-profile
      Documentation/features: Correct RISC-V kprobes support entry
      Documentation/features: Refresh the arch support status files
      Revert "docs: sysctl/kernel: document ngroups_max"
      docs: move locking-specific documents to locking/
      docs: move digsig docs to the security book
      docs: move the kref doc into the core-api book
      docs: add IRQ documentation at the core-api book
      docs: debugging-via-ohci1394.txt: add it to the core-api book
      docs: fix references for ipmi.rst file
      ...

commit c82c83c330654c5639960ebc3dabbae53c43f79e
Author: Tang Bin <tangbin@cmss.chinamobile.com>
Date:   Wed May 20 22:12:02 2020 +0800

    driver core: platform: Fix spelling errors in platform.c
    
    There is a word spelling mistake of 'Unegisters', thus
    it should be fixed.
    
    Signed-off-by: Tang Bin <tangbin@cmss.chinamobile.com>
    Link: https://lore.kernel.org/r/20200520141202.19568-1-tangbin@cmss.chinamobile.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4ed3dc38f45c..fe08ef8ffd5c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -977,7 +977,7 @@ EXPORT_SYMBOL_GPL(__platform_register_drivers);
  * @drivers: an array of drivers to unregister
  * @count: the number of drivers to unregister
  *
- * Unegisters platform drivers specified by an array. This is typically used
+ * Unregisters platform drivers specified by an array. This is typically used
  * to complement an earlier call to platform_register_drivers(). Drivers are
  * unregistered in the reverse order in which they were registered.
  */

commit a85a6c86c25be2d2a5f9c31491f612ce0edc7869
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 16 16:43:38 2020 -0500

    driver core: platform: Clarify that IRQ 0 is invalid
    
    These interfaces return a negative error number or an IRQ:
    
      platform_get_irq()
      platform_get_irq_optional()
      platform_get_irq_byname()
      platform_get_irq_byname_optional()
    
    The function comments suggest checking for error like this:
    
      irq = platform_get_irq(...);
      if (irq < 0)
        return irq;
    
    which is what most callers (~900 of 1400) do, so it's implicit that IRQ 0
    is invalid.  But some callers check for "irq <= 0", and it's not obvious
    from the source that we never return an IRQ 0.
    
    Make this more explicit by updating the comments to say that an IRQ number
    is always non-zero and adding a WARN() if we ever do return zero.  If we do
    return IRQ 0, it likely indicates a bug in the arch-specific parts of
    platform_get_irq().
    
    Relevant prior discussion at [1, 2].
    
    [1] https://lore.kernel.org/r/Pine.LNX.4.64.0701250940220.25027@woody.linux-foundation.org/
    [2] https://lore.kernel.org/r/Pine.LNX.4.64.0701252029570.25027@woody.linux-foundation.org/
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 5255550b7c34..084cf1d23d3f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -152,23 +152,24 @@ EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource_byname);
  *		if (irq < 0)
  *			return irq;
  *
- * Return: IRQ number on success, negative error number on failure.
+ * Return: non-zero IRQ number on success, negative error number on failure.
  */
 int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 {
+	int ret;
 #ifdef CONFIG_SPARC
 	/* sparc does not have irqs represented as IORESOURCE_IRQ resources */
 	if (!dev || num >= dev->archdata.num_irqs)
 		return -ENXIO;
-	return dev->archdata.irqs[num];
+	ret = dev->archdata.irqs[num];
+	goto out;
 #else
 	struct resource *r;
-	int ret;
 
 	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {
 		ret = of_irq_get(dev->dev.of_node, num);
 		if (ret > 0 || ret == -EPROBE_DEFER)
-			return ret;
+			goto out;
 	}
 
 	r = platform_get_resource(dev, IORESOURCE_IRQ, num);
@@ -176,7 +177,7 @@ int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 		if (r && r->flags & IORESOURCE_DISABLED) {
 			ret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);
 			if (ret)
-				return ret;
+				goto out;
 		}
 	}
 
@@ -190,13 +191,17 @@ int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 		struct irq_data *irqd;
 
 		irqd = irq_get_irq_data(r->start);
-		if (!irqd)
-			return -ENXIO;
+		if (!irqd) {
+			ret = -ENXIO;
+			goto out;
+		}
 		irqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);
 	}
 
-	if (r)
-		return r->start;
+	if (r) {
+		ret = r->start;
+		goto out;
+	}
 
 	/*
 	 * For the index 0 interrupt, allow falling back to GpioInt
@@ -209,11 +214,14 @@ int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 		ret = acpi_dev_gpio_irq_get(ACPI_COMPANION(&dev->dev), num);
 		/* Our callers expect -ENXIO for missing IRQs. */
 		if (ret >= 0 || ret == -EPROBE_DEFER)
-			return ret;
+			goto out;
 	}
 
-	return -ENXIO;
+	ret = -ENXIO;
 #endif
+out:
+	WARN(ret == 0, "0 is an invalid IRQ number\n");
+	return ret;
 }
 EXPORT_SYMBOL_GPL(platform_get_irq_optional);
 
@@ -231,7 +239,7 @@ EXPORT_SYMBOL_GPL(platform_get_irq_optional);
  *		if (irq < 0)
  *			return irq;
  *
- * Return: IRQ number on success, negative error number on failure.
+ * Return: non-zero IRQ number on success, negative error number on failure.
  */
 int platform_get_irq(struct platform_device *dev, unsigned int num)
 {
@@ -303,8 +311,10 @@ static int __platform_get_irq_byname(struct platform_device *dev,
 	}
 
 	r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);
-	if (r)
+	if (r) {
+		WARN(r->start == 0, "0 is an invalid IRQ number\n");
 		return r->start;
+	}
 
 	return -ENXIO;
 }
@@ -316,7 +326,7 @@ static int __platform_get_irq_byname(struct platform_device *dev,
  *
  * Get an IRQ like platform_get_irq(), but then by name rather then by index.
  *
- * Return: IRQ number on success, negative error number on failure.
+ * Return: non-zero IRQ number on success, negative error number on failure.
  */
 int platform_get_irq_byname(struct platform_device *dev, const char *name)
 {
@@ -338,7 +348,7 @@ EXPORT_SYMBOL_GPL(platform_get_irq_byname);
  * Get an optional IRQ by name like platform_get_irq_byname(). Except that it
  * does not print an error message if an IRQ can not be obtained.
  *
- * Return: IRQ number on success, negative error number on failure.
+ * Return: non-zero IRQ number on success, negative error number on failure.
  */
 int platform_get_irq_byname_optional(struct platform_device *dev,
 				     const char *name)

commit c8be6af9ef16cf44d690fc227a0d2dd7a526ef05
Merge: c78c31b374a6 2ef96a5bb12b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 11 09:00:09 2020 +0200

    Merge v5.7-rc5 into driver-core-next
    
    We want the driver core fixes in here and this resolves a merge issue
    with drivers/base/dd.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 388bcc6ecc609fca1b4920de7dc3806c98ec535e
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Wed Apr 8 14:40:03 2020 -0700

    drivers: base: Fix NULL pointer exception in __platform_driver_probe() if a driver developer is foolish
    
    If platform bus driver registration is failed then, accessing
    platform bus spin lock (&drv->driver.bus->p->klist_drivers.k_lock)
    in __platform_driver_probe() without verifying the return value
    __platform_driver_register() can lead to NULL pointer exception.
    
    So check the return value before attempting the spin lock.
    
    One such example is below:
    
    For a custom usecase, I have intentionally failed the platform bus
    registration and I expected all the platform device/driver
    registrations to fail gracefully. But I came across this panic
    issue.
    
    [    1.331067] BUG: kernel NULL pointer dereference, address: 00000000000000c8
    [    1.331118] #PF: supervisor write access in kernel mode
    [    1.331163] #PF: error_code(0x0002) - not-present page
    [    1.331208] PGD 0 P4D 0
    [    1.331233] Oops: 0002 [#1] PREEMPT SMP
    [    1.331268] CPU: 3 PID: 1 Comm: swapper/0 Tainted: G        W         5.6.0-00049-g670d35fb0144 #165
    [    1.331341] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015
    [    1.331406] RIP: 0010:_raw_spin_lock+0x15/0x30
    [    1.331588] RSP: 0000:ffffc9000001be70 EFLAGS: 00010246
    [    1.331632] RAX: 0000000000000000 RBX: 00000000000000c8 RCX: 0000000000000001
    [    1.331696] RDX: 0000000000000001 RSI: 0000000000000092 RDI: 0000000000000000
    [    1.331754] RBP: 00000000ffffffed R08: 0000000000000501 R09: 0000000000000001
    [    1.331817] R10: ffff88817abcc520 R11: 0000000000000670 R12: 00000000ffffffed
    [    1.331881] R13: ffffffff82dbc268 R14: ffffffff832f070a R15: 0000000000000000
    [    1.331945] FS:  0000000000000000(0000) GS:ffff88817bd80000(0000) knlGS:0000000000000000
    [    1.332008] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [    1.332062] CR2: 00000000000000c8 CR3: 000000000681e001 CR4: 00000000003606e0
    [    1.332126] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [    1.332189] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [    1.332252] Call Trace:
    [    1.332281]  __platform_driver_probe+0x92/0xee
    [    1.332323]  ? rtc_dev_init+0x2b/0x2b
    [    1.332358]  cmos_init+0x37/0x67
    [    1.332396]  do_one_initcall+0x7d/0x168
    [    1.332428]  kernel_init_freeable+0x16c/0x1c9
    [    1.332473]  ? rest_init+0xc0/0xc0
    [    1.332508]  kernel_init+0x5/0x100
    [    1.332543]  ret_from_fork+0x1f/0x30
    [    1.332579] CR2: 00000000000000c8
    [    1.332616] ---[ end trace 3bd87f12e9010b87 ]---
    [    1.333549] note: swapper/0[1] exited with preempt_count 1
    [    1.333592] Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000009
    [    1.333736] Kernel Offset: disabled
    
    Note, this can only be triggered if a driver errors out from this call,
    which should never happen.  If it does, the driver needs to be fixed.
    
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Link: https://lore.kernel.org/r/20200408214003.3356-1-sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 2e454c18b3a9..2c1812d75762 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -849,6 +849,8 @@ int __init_or_module __platform_driver_probe(struct platform_driver *drv,
 	/* temporary section violation during probe() */
 	drv->probe = probe;
 	retval = code = __platform_driver_register(drv, module);
+	if (retval)
+		return retval;
 
 	/*
 	 * Fixup that section violation, being paranoid about code scanning

commit 9495b7e92f716ab2bd6814fab5e97ab4a39adfdd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Apr 22 12:09:54 2020 +0200

    driver core: platform: Initialize dma_parms for platform devices
    
    It's currently the platform driver's responsibility to initialize the
    pointer, dma_parms, for its corresponding struct device. The benefit with
    this approach allows us to avoid the initialization and to not waste memory
    for the struct device_dma_parameters, as this can be decided on a case by
    case basis.
    
    However, it has turned out that this approach is not very practical.  Not
    only does it lead to open coding, but also to real errors. In principle
    callers of dma_set_max_seg_size() doesn't check the error code, but just
    assumes it succeeds.
    
    For these reasons, let's do the initialization from the common platform bus
    at the device registration point. This also follows the way the PCI devices
    are being managed, see pci_device_add().
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Cc: <stable@vger.kernel.org>
    Tested-by: Haibo Chen <haibo.chen@nxp.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20200422100954.31211-1-ulf.hansson@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 5255550b7c34..b27d0f6c18c9 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -380,6 +380,8 @@ struct platform_object {
  */
 static void setup_pdev_dma_masks(struct platform_device *pdev)
 {
+	pdev->dev.dma_parms = &pdev->dma_parms;
+
 	if (!pdev->dev.coherent_dma_mask)
 		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 	if (!pdev->dev.dma_mask) {

commit 45bb08de65b418959313593f527c619e102c2d57
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Apr 2 12:13:41 2020 +0100

    driver core: platform: remove redundant assignment to variable ret
    
    The variable ret is being initialized with a value that is never read
    and it is being updated later with a new value. The initialization is
    redundant and can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Link: https://lore.kernel.org/r/20200402111341.511801-1-colin.king@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 5255550b7c34..2e454c18b3a9 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -668,7 +668,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
 struct platform_device *platform_device_register_full(
 		const struct platform_device_info *pdevinfo)
 {
-	int ret = -ENOMEM;
+	int ret;
 	struct platform_device *pdev;
 
 	pdev = platform_device_alloc(pdevinfo->name, pdevinfo->id);

commit f08252469ef5b10863424e502bb1ed049d18390c
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Tue Apr 14 18:48:45 2020 +0200

    docs: drivers: fix some warnings at base/platform.c when building docs
    
    Currrently, two warnings are generated when building docs:
    
            ./drivers/base/platform.c:136: WARNING: Unexpected indentation.
            ./drivers/base/platform.c:214: WARNING: Unexpected indentation.
    
    As examples are code blocks, they should use "::" markup. However,
    
            Example::
    
    Is currently interpreted as a new section.
    
    While we could fix kernel-doc to accept such new syntax, it is
    easier to just replace it with:
    
            For Example::
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Link: https://lore.kernel.org/r/564273815a76136fb5e453969b1012a786d99e28.1586881715.git.mchehab+huawei@kernel.org
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 5255550b7c34..a07e28eab7d7 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -147,7 +147,8 @@ EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource_byname);
  * request_irq() APIs. This is the same as platform_get_irq(), except that it
  * does not print an error message if an IRQ can not be obtained.
  *
- * Example:
+ * For example::
+ *
  *		int irq = platform_get_irq_optional(pdev, 0);
  *		if (irq < 0)
  *			return irq;
@@ -226,7 +227,8 @@ EXPORT_SYMBOL_GPL(platform_get_irq_optional);
  * IRQ fails. Device drivers should check the return value for errors so as to
  * not pass a negative integer value to the request_irq() APIs.
  *
- * Example:
+ * For example::
+ *
  *		int irq = platform_get_irq(pdev, 0);
  *		if (irq < 0)
  *			return irq;

commit fd78901c297ee1a3214f617d4afb83a467aa7ada
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Tue Mar 24 00:06:12 2020 +0800

    driver core: platform: Reimplement devm_platform_ioremap_resource
    
    Reimplement devm_platform_ioremap_resource() by calling
    devm_platform_ioremap_and_get_resource() with res = NULL to
    simplify the code.
    
    Suggested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Link: https://lore.kernel.org/r/20200323160612.17277-6-zhengdejin5@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8f0f62bdc58e..5255550b7c34 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -95,10 +95,7 @@ EXPORT_SYMBOL_GPL(devm_platform_get_and_ioremap_resource);
 void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
 					     unsigned int index)
 {
-	struct resource *res;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, index);
-	return devm_ioremap_resource(&pdev->dev, res);
+	return devm_platform_get_and_ioremap_resource(pdev, index, NULL);
 }
 EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource);
 

commit 890cc39a879906b63912482dfc41944579df2dc6
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Tue Mar 24 00:06:08 2020 +0800

    drivers: provide devm_platform_get_and_ioremap_resource()
    
    Since commit "drivers: provide devm_platform_ioremap_resource()",
    it was wrap platform_get_resource() and devm_ioremap_resource() as
    single helper devm_platform_ioremap_resource(). but now, many drivers
    still used platform_get_resource() and devm_ioremap_resource()
    together in the kernel tree. The reason can not be replaced is they
    still need use the resource variables obtained by platform_get_resource().
    so provide this helper.
    
    Suggested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Suggested-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Link: https://lore.kernel.org/r/20200323160612.17277-2-zhengdejin5@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index b5ce7b085795..8f0f62bdc58e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -62,6 +62,28 @@ struct resource *platform_get_resource(struct platform_device *dev,
 EXPORT_SYMBOL_GPL(platform_get_resource);
 
 #ifdef CONFIG_HAS_IOMEM
+/**
+ * devm_platform_get_and_ioremap_resource - call devm_ioremap_resource() for a
+ *					    platform device and get resource
+ *
+ * @pdev: platform device to use both for memory resource lookup as well as
+ *        resource management
+ * @index: resource index
+ * @res: optional output parameter to store a pointer to the obtained resource.
+ */
+void __iomem *
+devm_platform_get_and_ioremap_resource(struct platform_device *pdev,
+				unsigned int index, struct resource **res)
+{
+	struct resource *r;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, index);
+	if (res)
+		*res = r;
+	return devm_ioremap_resource(&pdev->dev, r);
+}
+EXPORT_SYMBOL_GPL(devm_platform_get_and_ioremap_resource);
+
 /**
  * devm_platform_ioremap_resource - call devm_ioremap_resource() for a platform
  *				    device

commit e3a36eb6dfaeea8175c05d5915dcf0b939be6dab
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 11 17:07:10 2020 +0100

    driver code: clarify and fix platform device DMA mask allocation
    
    This does three inter-related things to clarify the usage of the
    platform device dma_mask field. In the process, fix the bug introduced
    by cdfee5623290 ("driver core: initialize a default DMA mask for
    platform device") that caused Artem Tashkinov's laptop to not boot with
    newer Fedora kernels.
    
    This does:
    
     - First off, rename the field to "platform_dma_mask" to make it
       greppable.
    
       We have way too many different random fields called "dma_mask" in
       various data structures, where some of them are actual masks, and
       some of them are just pointers to the mask. And the structures all
       have pointers to each other, or embed each other inside themselves,
       and "pdev" sometimes means "platform device" and sometimes it means
       "PCI device".
    
       So to make it clear in the code when you actually use this new field,
       give it a unique name (it really should be something even more unique
       like "platform_device_dma_mask", since it's per platform device, not
       per platform, but that gets old really fast, and this is unique
       enough in context).
    
       To further clarify when the field gets used, initialize it when we
       actually start using it with the default value.
    
     - Then, use this field instead of the random one-off allocation in
       platform_device_register_full() that is now unnecessary since we now
       already have a perfectly fine allocation for it in the platform
       device structure.
    
     - The above then allows us to fix the actual bug, where the error path
       of platform_device_register_full() would unconditionally free the
       platform device DMA allocation with 'kfree()'.
    
       That kfree() was dont regardless of whether the allocation had been
       done earlier with the (now removed) kmalloc, or whether
       setup_pdev_dma_masks() had already been used and the dma_mask pointer
       pointed to the mask that was part of the platform device.
    
    It seems most people never triggered the error path, or only triggered
    it from a call chain that set an explicit pdevinfo->dma_mask value (and
    thus caused the unnecessary allocation that was "cleaned up" in the
    error path) before calling platform_device_register_full().
    
    Robin Murphy points out that in Artem's case the wdat_wdt driver failed
    in platform_device_add(), and that was the one that had called
    platform_device_register_full() with pdevinfo.dma_mask = 0, and would
    have caused that kfree() of pdev.dma_mask corrupting the heap.
    
    A later unrelated kmalloc() then oopsed due to the heap corruption.
    
    Fixes: cdfee5623290 ("driver core: initialize a default DMA mask for platform device")
    Reported-bisected-and-tested-by:  Artem S. Tashkinov <aros@gmx.com>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 7fa654f1288b..b5ce7b085795 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -363,10 +363,10 @@ static void setup_pdev_dma_masks(struct platform_device *pdev)
 {
 	if (!pdev->dev.coherent_dma_mask)
 		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
-	if (!pdev->dma_mask)
-		pdev->dma_mask = DMA_BIT_MASK(32);
-	if (!pdev->dev.dma_mask)
-		pdev->dev.dma_mask = &pdev->dma_mask;
+	if (!pdev->dev.dma_mask) {
+		pdev->platform_dma_mask = DMA_BIT_MASK(32);
+		pdev->dev.dma_mask = &pdev->platform_dma_mask;
+	}
 };
 
 /**
@@ -662,20 +662,8 @@ struct platform_device *platform_device_register_full(
 	pdev->dev.of_node_reused = pdevinfo->of_node_reused;
 
 	if (pdevinfo->dma_mask) {
-		/*
-		 * This memory isn't freed when the device is put,
-		 * I don't have a nice idea for that though.  Conceptually
-		 * dma_mask in struct device should not be a pointer.
-		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
-		 */
-		pdev->dev.dma_mask =
-			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
-		if (!pdev->dev.dma_mask)
-			goto err;
-
-		kmemleak_ignore(pdev->dev.dma_mask);
-
-		*pdev->dev.dma_mask = pdevinfo->dma_mask;
+		pdev->platform_dma_mask = pdevinfo->dma_mask;
+		pdev->dev.dma_mask = &pdev->platform_dma_mask;
 		pdev->dev.coherent_dma_mask = pdevinfo->dma_mask;
 	}
 
@@ -700,7 +688,6 @@ struct platform_device *platform_device_register_full(
 	if (ret) {
 err:
 		ACPI_COMPANION_SET(&pdev->dev, NULL);
-		kfree(pdev->dev.dma_mask);
 		platform_device_put(pdev);
 		return ERR_PTR(ret);
 	}

commit 0707cfa5c3ef58effb143db9db6d6e20503f9dec
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Jan 16 17:57:58 2020 +0000

    driver core: platform: fix u32 greater or equal to zero comparison
    
    Currently the check that a u32 variable i is >= 0 is always true because
    the unsigned variable will never be negative, causing the loop to run
    forever.  Fix this by changing the pre-decrement check to a zero check on
    i followed by a decrement of i.
    
    Addresses-Coverity: ("Unsigned compared against 0")
    Fixes: 39cc539f90d0 ("driver core: platform: Prevent resouce overflow from causing infinite loops")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20200116175758.88396-1-colin.king@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 864b53b3d598..7fa654f1288b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -571,7 +571,7 @@ int platform_device_add(struct platform_device *pdev)
 		pdev->id = PLATFORM_DEVID_AUTO;
 	}
 
-	while (--i >= 0) {
+	while (i--) {
 		struct resource *r = &pdev->resource[i];
 		if (r->parent)
 			release_resource(r);

commit 39cc539f90d035a293240c9443af50be55ee81b8
Author: Simon Schwartz <kern.simon@theschwartz.xyz>
Date:   Tue Dec 10 17:41:37 2019 -0500

    driver core: platform: Prevent resouce overflow from causing infinite loops
    
    num_resources in the platform_device struct is declared as a u32.  The
    for loops that iterate over num_resources use an int as the counter,
    which can cause infinite loops on architectures with smaller ints.
    Change the loop counters to u32.
    
    Signed-off-by: Simon Schwartz <kern.simon@theschwartz.xyz>
    Link: https://lore.kernel.org/r/2201ce63a2a171ffd2ed14e867875316efcf71db.camel@theschwartz.xyz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index cf6b6b722e5c..864b53b3d598 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -27,6 +27,7 @@
 #include <linux/limits.h>
 #include <linux/property.h>
 #include <linux/kmemleak.h>
+#include <linux/types.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -48,7 +49,7 @@ EXPORT_SYMBOL_GPL(platform_bus);
 struct resource *platform_get_resource(struct platform_device *dev,
 				       unsigned int type, unsigned int num)
 {
-	int i;
+	u32 i;
 
 	for (i = 0; i < dev->num_resources; i++) {
 		struct resource *r = &dev->resource[i];
@@ -255,7 +256,7 @@ struct resource *platform_get_resource_byname(struct platform_device *dev,
 					      unsigned int type,
 					      const char *name)
 {
-	int i;
+	u32 i;
 
 	for (i = 0; i < dev->num_resources; i++) {
 		struct resource *r = &dev->resource[i];
@@ -501,7 +502,8 @@ EXPORT_SYMBOL_GPL(platform_device_add_properties);
  */
 int platform_device_add(struct platform_device *pdev)
 {
-	int i, ret;
+	u32 i;
+	int ret;
 
 	if (!pdev)
 		return -EINVAL;
@@ -590,7 +592,7 @@ EXPORT_SYMBOL_GPL(platform_device_add);
  */
 void platform_device_del(struct platform_device *pdev)
 {
-	int i;
+	u32 i;
 
 	if (!IS_ERR_OR_NULL(pdev)) {
 		device_del(&pdev->dev);

commit eecd37e105f0137af0d1b726bf61ff35d1d7d2eb
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Dec 3 12:58:52 2019 -0800

    drivers: Fix boot problem on SuperH
    
    SuperH images crash too eearly to display any console output. Bisect
    points to commit 507fd01d5333 ("drivers: move the early platform device
    support to arch/sh"). An analysis of that patch suggests that
    early_platform_cleanup() is now called at the wrong time. Restoring its
    call point fixes the problem.
    
    Cc: Bartosz Golaszewski <brgl@bgdev.pl>
    Fixes: 507fd01d5333 ("drivers: move the early platform device support to arch/sh")
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Rob Landley <rob@landley.net>
    Link: https://lore.kernel.org/r/20191203205852.15659-1-linux@roeck-us.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 7c532548b0a6..cf6b6b722e5c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1325,10 +1325,14 @@ struct device *platform_find_device_by_driver(struct device *start,
 }
 EXPORT_SYMBOL_GPL(platform_find_device_by_driver);
 
+void __weak __init early_platform_cleanup(void) { }
+
 int __init platform_bus_init(void)
 {
 	int error;
 
+	early_platform_cleanup();
+
 	error = device_register(&platform_bus);
 	if (error) {
 		put_device(&platform_bus);

commit 71564a26e3e9d29d3d8901eb32647c2c3a807e1f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Oct 23 15:25:05 2019 +0300

    driver core: platform: Declare ret variable only once
    
    We may define ret variable only once and avoid adding it each time
    platform_get_irq_optional() get extended.
    
    For the sake of consistency do the same in __platform_get_irq_byname().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20191023122505.64684-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d51dc35749c6..7c532548b0a6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -143,9 +143,9 @@ int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 	return dev->archdata.irqs[num];
 #else
 	struct resource *r;
-	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {
-		int ret;
+	int ret;
 
+	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {
 		ret = of_irq_get(dev->dev.of_node, num);
 		if (ret > 0 || ret == -EPROBE_DEFER)
 			return ret;
@@ -154,8 +154,6 @@ int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 	r = platform_get_resource(dev, IORESOURCE_IRQ, num);
 	if (has_acpi_companion(&dev->dev)) {
 		if (r && r->flags & IORESOURCE_DISABLED) {
-			int ret;
-
 			ret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);
 			if (ret)
 				return ret;
@@ -188,8 +186,7 @@ int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 	 * allows a common code path across either kind of resource.
 	 */
 	if (num == 0 && has_acpi_companion(&dev->dev)) {
-		int ret = acpi_dev_gpio_irq_get(ACPI_COMPANION(&dev->dev), num);
-
+		ret = acpi_dev_gpio_irq_get(ACPI_COMPANION(&dev->dev), num);
 		/* Our callers expect -ENXIO for missing IRQs. */
 		if (ret >= 0 || ret == -EPROBE_DEFER)
 			return ret;
@@ -277,10 +274,9 @@ static int __platform_get_irq_byname(struct platform_device *dev,
 				     const char *name)
 {
 	struct resource *r;
+	int ret;
 
 	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {
-		int ret;
-
 		ret = of_irq_get_byname(dev->dev.of_node, name);
 		if (ret > 0 || ret == -EPROBE_DEFER)
 			return ret;

commit 492c88720d36eb662f9f10c1633f7726fbb07fc4
Author: Sami Tolvanen <samitolvanen@google.com>
Date:   Tue Nov 12 13:41:56 2019 -0800

    driver core: platform: use the correct callback type for bus_find_device
    
    platform_find_device_by_driver calls bus_find_device and passes
    platform_match as the callback function. Casting the function to a
    mismatching type trips indirect call Control-Flow Integrity (CFI) checking.
    
    This change adds a callback function with the correct type and instead
    of casting the function, explicitly casts the second parameter to struct
    device_driver* as expected by platform_match.
    
    Fixes: 36f3313d6bff9 ("platform: Add platform_find_device_by_driver() helper")
    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191112214156.3430-1-samitolvanen@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1b8a20466eef..d51dc35749c6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1310,6 +1310,11 @@ struct bus_type platform_bus_type = {
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 
+static inline int __platform_match(struct device *dev, const void *drv)
+{
+	return platform_match(dev, (struct device_driver *)drv);
+}
+
 /**
  * platform_find_device_by_driver - Find a platform device with a given
  * driver.
@@ -1320,7 +1325,7 @@ struct device *platform_find_device_by_driver(struct device *start,
 					      const struct device_driver *drv)
 {
 	return bus_find_device(&platform_bus_type, start, drv,
-			       (void *)platform_match);
+			       __platform_match);
 }
 EXPORT_SYMBOL_GPL(platform_find_device_by_driver);
 

commit c9c8641d3ebd79274af75f7df3e6a9c6cc8a66e9
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Tue Oct 22 10:43:16 2019 +0200

    drivers: provide devm_platform_ioremap_resource_byname()
    
    Provide a variant of devm_platform_ioremap_resource() that allows to
    lookup resources from platform devices by name rather than by index.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20191022084318.22256-7-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 28eb71967f17..1b8a20466eef 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -95,6 +95,26 @@ void __iomem *devm_platform_ioremap_resource_wc(struct platform_device *pdev,
 	res = platform_get_resource(pdev, IORESOURCE_MEM, index);
 	return devm_ioremap_resource_wc(&pdev->dev, res);
 }
+
+/**
+ * devm_platform_ioremap_resource_byname - call devm_ioremap_resource for
+ *					   a platform device, retrieve the
+ *					   resource by name
+ *
+ * @pdev: platform device to use both for memory resource lookup as well as
+ *	  resource management
+ * @name: name of the resource
+ */
+void __iomem *
+devm_platform_ioremap_resource_byname(struct platform_device *pdev,
+				      const char *name)
+{
+	struct resource *res;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
+	return devm_ioremap_resource(&pdev->dev, res);
+}
+EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource_byname);
 #endif /* CONFIG_HAS_IOMEM */
 
 /**

commit bb6243b4f73d29f8c8faf8f805a2042ac3973b71
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Tue Oct 22 10:43:14 2019 +0200

    drivers: platform: provide devm_platform_ioremap_resource_wc()
    
    Provide a write-combined variant of devm_platform_ioremap_resource().
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20191022084318.22256-5-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index e0ca682a756d..28eb71967f17 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -60,6 +60,7 @@ struct resource *platform_get_resource(struct platform_device *dev,
 }
 EXPORT_SYMBOL_GPL(platform_get_resource);
 
+#ifdef CONFIG_HAS_IOMEM
 /**
  * devm_platform_ioremap_resource - call devm_ioremap_resource() for a platform
  *				    device
@@ -68,7 +69,6 @@ EXPORT_SYMBOL_GPL(platform_get_resource);
  *        resource management
  * @index: resource index
  */
-#ifdef CONFIG_HAS_IOMEM
 void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
 					     unsigned int index)
 {
@@ -78,6 +78,23 @@ void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
 	return devm_ioremap_resource(&pdev->dev, res);
 }
 EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource);
+
+/**
+ * devm_platform_ioremap_resource_wc - write-combined variant of
+ *                                     devm_platform_ioremap_resource()
+ *
+ * @pdev: platform device to use both for memory resource lookup as well as
+ *        resource management
+ * @index: resource index
+ */
+void __iomem *devm_platform_ioremap_resource_wc(struct platform_device *pdev,
+						unsigned int index)
+{
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, index);
+	return devm_ioremap_resource_wc(&pdev->dev, res);
+}
 #endif /* CONFIG_HAS_IOMEM */
 
 /**

commit 8f677bc819e7a74cf10e30daf06e8b151d1e6a94
Merge: a3caeb8ffe5d d6d5df1db6e9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 27 18:54:13 2019 +0100

    Merge 5.4-rc5 into driver-core-next
    
    We want the sysfs fix in here as well to build on top of.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec4e29068839e00ff99ae94ccbb46123f0a0ba9d
Author: Uwe Kleine-König <uwe@kleine-koenig.org>
Date:   Wed Oct 9 11:37:46 2019 +0200

    driver core: simplify definitions of platform_get_irq*
    
    platform_get_irq_optional is just a wrapper for __platform_get_irq. So
    rename __platform_get_irq to platform_get_irq_optional and drop
    platform_get_irq_optional's previous implementation. This way there is
    one function and one indirection less without loss of functionality.
    
    Signed-off-by: Uwe Kleine-König <uwe@kleine-koenig.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20191009093746.12095-1-uwe@kleine-koenig.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index be1e67ee3af6..b0263dcf068f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -80,7 +80,24 @@ void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
 EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource);
 #endif /* CONFIG_HAS_IOMEM */
 
-static int __platform_get_irq(struct platform_device *dev, unsigned int num)
+/**
+ * platform_get_irq_optional - get an optional IRQ for a device
+ * @dev: platform device
+ * @num: IRQ number index
+ *
+ * Gets an IRQ for a platform device. Device drivers should check the return
+ * value for errors so as to not pass a negative integer value to the
+ * request_irq() APIs. This is the same as platform_get_irq(), except that it
+ * does not print an error message if an IRQ can not be obtained.
+ *
+ * Example:
+ *		int irq = platform_get_irq_optional(pdev, 0);
+ *		if (irq < 0)
+ *			return irq;
+ *
+ * Return: IRQ number on success, negative error number on failure.
+ */
+int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 {
 #ifdef CONFIG_SPARC
 	/* sparc does not have irqs represented as IORESOURCE_IRQ resources */
@@ -144,6 +161,7 @@ static int __platform_get_irq(struct platform_device *dev, unsigned int num)
 	return -ENXIO;
 #endif
 }
+EXPORT_SYMBOL_GPL(platform_get_irq_optional);
 
 /**
  * platform_get_irq - get an IRQ for a device
@@ -165,7 +183,7 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 {
 	int ret;
 
-	ret = __platform_get_irq(dev, num);
+	ret = platform_get_irq_optional(dev, num);
 	if (ret < 0 && ret != -EPROBE_DEFER)
 		dev_err(&dev->dev, "IRQ index %u not found\n", num);
 
@@ -173,29 +191,6 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 }
 EXPORT_SYMBOL_GPL(platform_get_irq);
 
-/**
- * platform_get_irq_optional - get an optional IRQ for a device
- * @dev: platform device
- * @num: IRQ number index
- *
- * Gets an IRQ for a platform device. Device drivers should check the return
- * value for errors so as to not pass a negative integer value to the
- * request_irq() APIs. This is the same as platform_get_irq(), except that it
- * does not print an error message if an IRQ can not be obtained.
- *
- * Example:
- *		int irq = platform_get_irq_optional(pdev, 0);
- *		if (irq < 0)
- *			return irq;
- *
- * Return: IRQ number on success, negative error number on failure.
- */
-int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
-{
-	return __platform_get_irq(dev, num);
-}
-EXPORT_SYMBOL_GPL(platform_get_irq_optional);
-
 /**
  * platform_irq_count - Count the number of IRQs a platform device uses
  * @dev: platform device
@@ -206,7 +201,7 @@ int platform_irq_count(struct platform_device *dev)
 {
 	int ret, nr = 0;
 
-	while ((ret = __platform_get_irq(dev, nr)) >= 0)
+	while ((ret = platform_get_irq_optional(dev, nr)) >= 0)
 		nr++;
 
 	if (ret == -EPROBE_DEFER)

commit 507fd01d5333338753a1cc26322dfc9f856c109f
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Oct 3 11:29:12 2019 +0200

    drivers: move the early platform device support to arch/sh
    
    SuperH is the only user of the current implementation of early platform
    device support. We want to introduce a more robust approach to early
    probing. As the first step - move all the current early platform code
    to arch/sh.
    
    In order not to export internal drivers/base functions to arch code for
    this temporary solution - copy the two needed routines for driver
    matching from drivers/base/platform.c to arch/sh/drivers/platform_early.c.
    
    Also: call early_platform_cleanup() from subsys_initcall() so that it's
    called after all early devices are probed.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Rich Felker <dalias@libc.org>
    Link: https://lore.kernel.org/r/20191003092913.10731-2-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index b6c6c7d97d5b..be1e67ee3af6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1264,8 +1264,6 @@ int __init platform_bus_init(void)
 {
 	int error;
 
-	early_platform_cleanup();
-
 	error = device_register(&platform_bus);
 	if (error) {
 		put_device(&platform_bus);
@@ -1277,289 +1275,3 @@ int __init platform_bus_init(void)
 	of_platform_register_reconfig_notifier();
 	return error;
 }
-
-static __initdata LIST_HEAD(early_platform_driver_list);
-static __initdata LIST_HEAD(early_platform_device_list);
-
-/**
- * early_platform_driver_register - register early platform driver
- * @epdrv: early_platform driver structure
- * @buf: string passed from early_param()
- *
- * Helper function for early_platform_init() / early_platform_init_buffer()
- */
-int __init early_platform_driver_register(struct early_platform_driver *epdrv,
-					  char *buf)
-{
-	char *tmp;
-	int n;
-
-	/* Simply add the driver to the end of the global list.
-	 * Drivers will by default be put on the list in compiled-in order.
-	 */
-	if (!epdrv->list.next) {
-		INIT_LIST_HEAD(&epdrv->list);
-		list_add_tail(&epdrv->list, &early_platform_driver_list);
-	}
-
-	/* If the user has specified device then make sure the driver
-	 * gets prioritized. The driver of the last device specified on
-	 * command line will be put first on the list.
-	 */
-	n = strlen(epdrv->pdrv->driver.name);
-	if (buf && !strncmp(buf, epdrv->pdrv->driver.name, n)) {
-		list_move(&epdrv->list, &early_platform_driver_list);
-
-		/* Allow passing parameters after device name */
-		if (buf[n] == '\0' || buf[n] == ',')
-			epdrv->requested_id = -1;
-		else {
-			epdrv->requested_id = simple_strtoul(&buf[n + 1],
-							     &tmp, 10);
-
-			if (buf[n] != '.' || (tmp == &buf[n + 1])) {
-				epdrv->requested_id = EARLY_PLATFORM_ID_ERROR;
-				n = 0;
-			} else
-				n += strcspn(&buf[n + 1], ",") + 1;
-		}
-
-		if (buf[n] == ',')
-			n++;
-
-		if (epdrv->bufsize) {
-			memcpy(epdrv->buffer, &buf[n],
-			       min_t(int, epdrv->bufsize, strlen(&buf[n]) + 1));
-			epdrv->buffer[epdrv->bufsize - 1] = '\0';
-		}
-	}
-
-	return 0;
-}
-
-/**
- * early_platform_add_devices - adds a number of early platform devices
- * @devs: array of early platform devices to add
- * @num: number of early platform devices in array
- *
- * Used by early architecture code to register early platform devices and
- * their platform data.
- */
-void __init early_platform_add_devices(struct platform_device **devs, int num)
-{
-	struct device *dev;
-	int i;
-
-	/* simply add the devices to list */
-	for (i = 0; i < num; i++) {
-		dev = &devs[i]->dev;
-
-		if (!dev->devres_head.next) {
-			pm_runtime_early_init(dev);
-			INIT_LIST_HEAD(&dev->devres_head);
-			list_add_tail(&dev->devres_head,
-				      &early_platform_device_list);
-		}
-	}
-}
-
-/**
- * early_platform_driver_register_all - register early platform drivers
- * @class_str: string to identify early platform driver class
- *
- * Used by architecture code to register all early platform drivers
- * for a certain class. If omitted then only early platform drivers
- * with matching kernel command line class parameters will be registered.
- */
-void __init early_platform_driver_register_all(char *class_str)
-{
-	/* The "class_str" parameter may or may not be present on the kernel
-	 * command line. If it is present then there may be more than one
-	 * matching parameter.
-	 *
-	 * Since we register our early platform drivers using early_param()
-	 * we need to make sure that they also get registered in the case
-	 * when the parameter is missing from the kernel command line.
-	 *
-	 * We use parse_early_options() to make sure the early_param() gets
-	 * called at least once. The early_param() may be called more than
-	 * once since the name of the preferred device may be specified on
-	 * the kernel command line. early_platform_driver_register() handles
-	 * this case for us.
-	 */
-	parse_early_options(class_str);
-}
-
-/**
- * early_platform_match - find early platform device matching driver
- * @epdrv: early platform driver structure
- * @id: id to match against
- */
-static struct platform_device * __init
-early_platform_match(struct early_platform_driver *epdrv, int id)
-{
-	struct platform_device *pd;
-
-	list_for_each_entry(pd, &early_platform_device_list, dev.devres_head)
-		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
-			if (pd->id == id)
-				return pd;
-
-	return NULL;
-}
-
-/**
- * early_platform_left - check if early platform driver has matching devices
- * @epdrv: early platform driver structure
- * @id: return true if id or above exists
- */
-static int __init early_platform_left(struct early_platform_driver *epdrv,
-				       int id)
-{
-	struct platform_device *pd;
-
-	list_for_each_entry(pd, &early_platform_device_list, dev.devres_head)
-		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
-			if (pd->id >= id)
-				return 1;
-
-	return 0;
-}
-
-/**
- * early_platform_driver_probe_id - probe drivers matching class_str and id
- * @class_str: string to identify early platform driver class
- * @id: id to match against
- * @nr_probe: number of platform devices to successfully probe before exiting
- */
-static int __init early_platform_driver_probe_id(char *class_str,
-						 int id,
-						 int nr_probe)
-{
-	struct early_platform_driver *epdrv;
-	struct platform_device *match;
-	int match_id;
-	int n = 0;
-	int left = 0;
-
-	list_for_each_entry(epdrv, &early_platform_driver_list, list) {
-		/* only use drivers matching our class_str */
-		if (strcmp(class_str, epdrv->class_str))
-			continue;
-
-		if (id == -2) {
-			match_id = epdrv->requested_id;
-			left = 1;
-
-		} else {
-			match_id = id;
-			left += early_platform_left(epdrv, id);
-
-			/* skip requested id */
-			switch (epdrv->requested_id) {
-			case EARLY_PLATFORM_ID_ERROR:
-			case EARLY_PLATFORM_ID_UNSET:
-				break;
-			default:
-				if (epdrv->requested_id == id)
-					match_id = EARLY_PLATFORM_ID_UNSET;
-			}
-		}
-
-		switch (match_id) {
-		case EARLY_PLATFORM_ID_ERROR:
-			pr_warn("%s: unable to parse %s parameter\n",
-				class_str, epdrv->pdrv->driver.name);
-			/* fall-through */
-		case EARLY_PLATFORM_ID_UNSET:
-			match = NULL;
-			break;
-		default:
-			match = early_platform_match(epdrv, match_id);
-		}
-
-		if (match) {
-			/*
-			 * Set up a sensible init_name to enable
-			 * dev_name() and others to be used before the
-			 * rest of the driver core is initialized.
-			 */
-			if (!match->dev.init_name && slab_is_available()) {
-				if (match->id != -1)
-					match->dev.init_name =
-						kasprintf(GFP_KERNEL, "%s.%d",
-							  match->name,
-							  match->id);
-				else
-					match->dev.init_name =
-						kasprintf(GFP_KERNEL, "%s",
-							  match->name);
-
-				if (!match->dev.init_name)
-					return -ENOMEM;
-			}
-
-			if (epdrv->pdrv->probe(match))
-				pr_warn("%s: unable to probe %s early.\n",
-					class_str, match->name);
-			else
-				n++;
-		}
-
-		if (n >= nr_probe)
-			break;
-	}
-
-	if (left)
-		return n;
-	else
-		return -ENODEV;
-}
-
-/**
- * early_platform_driver_probe - probe a class of registered drivers
- * @class_str: string to identify early platform driver class
- * @nr_probe: number of platform devices to successfully probe before exiting
- * @user_only: only probe user specified early platform devices
- *
- * Used by architecture code to probe registered early platform drivers
- * within a certain class. For probe to happen a registered early platform
- * device matching a registered early platform driver is needed.
- */
-int __init early_platform_driver_probe(char *class_str,
-				       int nr_probe,
-				       int user_only)
-{
-	int k, n, i;
-
-	n = 0;
-	for (i = -2; n < nr_probe; i++) {
-		k = early_platform_driver_probe_id(class_str, i, nr_probe - n);
-
-		if (k < 0)
-			break;
-
-		n += k;
-
-		if (user_only)
-			break;
-	}
-
-	return n;
-}
-
-/**
- * early_platform_cleanup - clean up early platform code
- */
-void __init early_platform_cleanup(void)
-{
-	struct platform_device *pd, *pd2;
-
-	/* clean up the devres list used to chain devices */
-	list_for_each_entry_safe(pd, pd2, &early_platform_device_list,
-				 dev.devres_head) {
-		list_del(&pd->dev.devres_head);
-		memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
-	}
-}
-

commit f1da567f1dc1b55d178b8f2d0cfe8353858aac19
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Oct 5 23:04:47 2019 +0200

    driver core: platform: Add platform_get_irq_byname_optional()
    
    Some drivers (e.g dwc3) first try to get an IRQ byname and then fall
    back to the one at index 0. In this case we do not want the error(s)
    printed by platform_get_irq_byname(). This commit adds a new
    platform_get_irq_byname_optional(), which does not print errors, for this.
    
    While at it also improve the kdoc text for platform_get_irq_byname() a bit.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=205037
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20191005210449.3926-2-hdegoede@redhat.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index b6c6c7d97d5b..b230beb6ccb4 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -241,12 +241,8 @@ struct resource *platform_get_resource_byname(struct platform_device *dev,
 }
 EXPORT_SYMBOL_GPL(platform_get_resource_byname);
 
-/**
- * platform_get_irq_byname - get an IRQ for a device by name
- * @dev: platform device
- * @name: IRQ name
- */
-int platform_get_irq_byname(struct platform_device *dev, const char *name)
+static int __platform_get_irq_byname(struct platform_device *dev,
+				     const char *name)
 {
 	struct resource *r;
 
@@ -262,11 +258,47 @@ int platform_get_irq_byname(struct platform_device *dev, const char *name)
 	if (r)
 		return r->start;
 
-	dev_err(&dev->dev, "IRQ %s not found\n", name);
 	return -ENXIO;
 }
+
+/**
+ * platform_get_irq_byname - get an IRQ for a device by name
+ * @dev: platform device
+ * @name: IRQ name
+ *
+ * Get an IRQ like platform_get_irq(), but then by name rather then by index.
+ *
+ * Return: IRQ number on success, negative error number on failure.
+ */
+int platform_get_irq_byname(struct platform_device *dev, const char *name)
+{
+	int ret;
+
+	ret = __platform_get_irq_byname(dev, name);
+	if (ret < 0 && ret != -EPROBE_DEFER)
+		dev_err(&dev->dev, "IRQ %s not found\n", name);
+
+	return ret;
+}
 EXPORT_SYMBOL_GPL(platform_get_irq_byname);
 
+/**
+ * platform_get_irq_byname_optional - get an optional IRQ for a device by name
+ * @dev: platform device
+ * @name: IRQ name
+ *
+ * Get an optional IRQ by name like platform_get_irq_byname(). Except that it
+ * does not print an error message if an IRQ can not be obtained.
+ *
+ * Return: IRQ number on success, negative error number on failure.
+ */
+int platform_get_irq_byname_optional(struct platform_device *dev,
+				     const char *name)
+{
+	return __platform_get_irq_byname(dev, name);
+}
+EXPORT_SYMBOL_GPL(platform_get_irq_byname_optional);
+
 /**
  * platform_add_devices - add a numbers of platform devices
  * @devs: array of platform devices to add

commit c6b48dad92aedaa9bdc013ee495cb5b1bbdf1f11
Merge: 1f7d290a7275 fb9617edf6c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 18 10:33:46 2019 -0700

    Merge tag 'usb-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB updates from Greg KH:
     "Here is the big set of USB patches for 5.4-rc1.
    
      Two major chunks of code are moving out of the tree and into the
      staging directory, uwb and wusb (wireless USB support), because there
      are no devices that actually use this protocol anymore, and what we
      have today probably doesn't work at all given that the maintainers
      left many many years ago. So move it to staging where it will be
      removed in a few releases if no one screams.
    
      Other than that, lots of little things. The usual gadget and xhci and
      usb serial driver updates, along with a bunch of sysfs file cleanups
      due to the driver core changes to support that. Nothing really major,
      just constant forward progress.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'usb-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (159 commits)
      USB: usbcore: Fix slab-out-of-bounds bug during device reset
      usb: cdns3: Remove redundant dev_err call in cdns3_probe()
      USB: rio500: Fix lockdep violation
      USB: rio500: simplify locking
      usb: mtu3: register a USB Role Switch for dual role mode
      usb: common: add USB GPIO based connection detection driver
      usb: common: create Kconfig file
      usb: roles: get usb-role-switch from parent
      usb: roles: Add fwnode_usb_role_switch_get() function
      device connection: Add fwnode_connection_find_match()
      usb: roles: Introduce stubs for the exiting functions in role.h
      dt-bindings: usb: mtu3: add properties about USB Role Switch
      dt-bindings: usb: add binding for USB GPIO based connection detection driver
      dt-bindings: connector: add optional properties for Type-B
      dt-binding: usb: add usb-role-switch property
      usbip: Implement SG support to vhci-hcd and stub driver
      usb: roles: intel: Enable static DRD mode for role switch
      xhci-ext-caps.c: Add property to disable Intel SW switch
      usb: dwc3: remove generic PHY calibrate() calls
      usb: core: phy: add support for PHY calibration
      ...

commit c5c0283a9db1c7ba5881f956a1faf2ebc3dfe70e
Merge: a31f01777bc5 36f3313d6bff
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 3 17:11:07 2019 +0200

    Merge generic_lookup_helpers into usb-next
    
    The lookup helpers are needed here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9430f96c051ede4e4a3d5a20e68518181e9cd3c
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Aug 29 09:29:32 2019 +0200

    driver core: platform: Export platform_get_irq_optional()
    
    This function can be used by modules, so it needs to be exported.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 0dda6ade50fd..11c6e56ccc22 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -213,6 +213,7 @@ int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
 {
 	return __platform_get_irq(dev, num);
 }
+EXPORT_SYMBOL_GPL(platform_get_irq_optional);
 
 /**
  * platform_irq_count - Count the number of IRQs a platform device uses

commit 8973ea47901c81a1912bd05f1577bed9b5b52506
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Aug 28 10:34:10 2019 +0200

    driver core: platform: Introduce platform_get_irq_optional()
    
    In some cases the interrupt line of a device is optional. Introduce a
    new platform_get_irq_optional() that works much like platform_get_irq()
    but does not output an error on failure to find the interrupt.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190828083411.2496-1-thierry.reding@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8ad701068c11..0dda6ade50fd 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -192,6 +192,28 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 }
 EXPORT_SYMBOL_GPL(platform_get_irq);
 
+/**
+ * platform_get_irq_optional - get an optional IRQ for a device
+ * @dev: platform device
+ * @num: IRQ number index
+ *
+ * Gets an IRQ for a platform device. Device drivers should check the return
+ * value for errors so as to not pass a negative integer value to the
+ * request_irq() APIs. This is the same as platform_get_irq(), except that it
+ * does not print an error message if an IRQ can not be obtained.
+ *
+ * Example:
+ *		int irq = platform_get_irq_optional(pdev, 0);
+ *		if (irq < 0)
+ *			return irq;
+ *
+ * Return: IRQ number on success, negative error number on failure.
+ */
+int platform_get_irq_optional(struct platform_device *dev, unsigned int num)
+{
+	return __platform_get_irq(dev, num);
+}
+
 /**
  * platform_irq_count - Count the number of IRQs a platform device uses
  * @dev: platform device

commit cdfee5623290bc893f595636b44fa28e8207c5b3
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 16 08:24:35 2019 +0200

    driver core: initialize a default DMA mask for platform device
    
    We still treat devices without a DMA mask as defaulting to 32-bits for
    both mask, but a few releases ago we've started warning about such
    cases, as they require special cases to work around this sloppyness.
    Add a dma_mask field to struct platform_device so that we can initialize
    the dma_mask pointer in struct device and initialize both masks to
    32-bits by default, replacing similar functionality in m68k and
    powerpc.  The arch_setup_pdev_archdata hooks is now unused and removed.
    
    Note that the code looks a little odd with the various conditionals
    because we have to support platform_device structures that are
    statically allocated.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Link: https://lore.kernel.org/r/20190816062435.881-7-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ec974ba9c0c4..600913aea73b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -39,25 +39,6 @@ struct device platform_bus = {
 };
 EXPORT_SYMBOL_GPL(platform_bus);
 
-/**
- * arch_setup_pdev_archdata - Allow manipulation of archdata before its used
- * @pdev: platform device
- *
- * This is called before platform_device_add() such that any pdev_archdata may
- * be setup before the platform_notifier is called.  So if a user needs to
- * manipulate any relevant information in the pdev_archdata they can do:
- *
- *	platform_device_alloc()
- *	... manipulate ...
- *	platform_device_add()
- *
- * And if they don't care they can just call platform_device_register() and
- * everything will just work out.
- */
-void __weak arch_setup_pdev_archdata(struct platform_device *pdev)
-{
-}
-
 /**
  * platform_get_resource - get a resource for a device
  * @dev: platform device
@@ -264,6 +245,20 @@ struct platform_object {
 	char name[];
 };
 
+/*
+ * Set up default DMA mask for platform devices if the they weren't
+ * previously set by the architecture / DT.
+ */
+static void setup_pdev_dma_masks(struct platform_device *pdev)
+{
+	if (!pdev->dev.coherent_dma_mask)
+		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	if (!pdev->dma_mask)
+		pdev->dma_mask = DMA_BIT_MASK(32);
+	if (!pdev->dev.dma_mask)
+		pdev->dev.dma_mask = &pdev->dma_mask;
+};
+
 /**
  * platform_device_put - destroy a platform device
  * @pdev: platform device to free
@@ -310,7 +305,7 @@ struct platform_device *platform_device_alloc(const char *name, int id)
 		pa->pdev.id = id;
 		device_initialize(&pa->pdev.dev);
 		pa->pdev.dev.release = platform_device_release;
-		arch_setup_pdev_archdata(&pa->pdev);
+		setup_pdev_dma_masks(&pa->pdev);
 	}
 
 	return pa ? &pa->pdev : NULL;
@@ -512,7 +507,7 @@ EXPORT_SYMBOL_GPL(platform_device_del);
 int platform_device_register(struct platform_device *pdev)
 {
 	device_initialize(&pdev->dev);
-	arch_setup_pdev_archdata(pdev);
+	setup_pdev_dma_masks(pdev);
 	return platform_device_add(pdev);
 }
 EXPORT_SYMBOL_GPL(platform_device_register);

commit e6aa640eb2f68920cb849aec0cab44f05d843238
Merge: 1f573cce48a2 d45331b00ddb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 12 07:37:39 2019 +0200

    Merge 5.3-rc4 into driver-core-next
    
    We need the driver core fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7723f4c5ecdb8d832f049f8483beb0d1081cedf6
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Mon Jul 29 22:38:43 2019 -0700

    driver core: platform: Add an error message to platform_get_irq*()
    
    A grep of the kernel shows that many drivers print an error message if
    they fail to get the irq they're looking for. Furthermore, those drivers
    all decide to print the device name, or not, and the irq they were
    requesting, or not, etc. Let's consolidate all these error messages into
    the API itself, allowing us to get rid of the error messages in each
    driver.
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Javier Martinez Canillas <javierm@redhat.com>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Russell King - ARM Linux <linux@armlinux.org.uk>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Markus Elfring <Markus.Elfring@web.de>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190730053845.126834-2-swboyd@chromium.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a174ce5ea17c..9426736551b5 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -99,12 +99,7 @@ void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
 EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource);
 #endif /* CONFIG_HAS_IOMEM */
 
-/**
- * platform_get_irq - get an IRQ for a device
- * @dev: platform device
- * @num: IRQ number index
- */
-int platform_get_irq(struct platform_device *dev, unsigned int num)
+static int __platform_get_irq(struct platform_device *dev, unsigned int num)
 {
 #ifdef CONFIG_SPARC
 	/* sparc does not have irqs represented as IORESOURCE_IRQ resources */
@@ -163,6 +158,33 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 	return -ENXIO;
 #endif
 }
+
+/**
+ * platform_get_irq - get an IRQ for a device
+ * @dev: platform device
+ * @num: IRQ number index
+ *
+ * Gets an IRQ for a platform device and prints an error message if finding the
+ * IRQ fails. Device drivers should check the return value for errors so as to
+ * not pass a negative integer value to the request_irq() APIs.
+ *
+ * Example:
+ *		int irq = platform_get_irq(pdev, 0);
+ *		if (irq < 0)
+ *			return irq;
+ *
+ * Return: IRQ number on success, negative error number on failure.
+ */
+int platform_get_irq(struct platform_device *dev, unsigned int num)
+{
+	int ret;
+
+	ret = __platform_get_irq(dev, num);
+	if (ret < 0 && ret != -EPROBE_DEFER)
+		dev_err(&dev->dev, "IRQ index %u not found\n", num);
+
+	return ret;
+}
 EXPORT_SYMBOL_GPL(platform_get_irq);
 
 /**
@@ -175,7 +197,7 @@ int platform_irq_count(struct platform_device *dev)
 {
 	int ret, nr = 0;
 
-	while ((ret = platform_get_irq(dev, nr)) >= 0)
+	while ((ret = __platform_get_irq(dev, nr)) >= 0)
 		nr++;
 
 	if (ret == -EPROBE_DEFER)
@@ -228,7 +250,11 @@ int platform_get_irq_byname(struct platform_device *dev, const char *name)
 	}
 
 	r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);
-	return r ? r->start : -ENXIO;
+	if (r)
+		return r->start;
+
+	dev_err(&dev->dev, "IRQ %s not found\n", name);
+	return -ENXIO;
 }
 EXPORT_SYMBOL_GPL(platform_get_irq_byname);
 

commit 46c42d844211ef5902e32aa507beac0817c585e9
Author: Brian Norris <briannorris@chromium.org>
Date:   Mon Jul 29 13:49:54 2019 -0700

    driver core: platform: return -ENXIO for missing GpioInt
    
    Commit daaef255dc96 ("driver: platform: Support parsing GpioInt 0 in
    platform_get_irq()") broke the Embedded Controller driver on most LPC
    Chromebooks (i.e., most x86 Chromebooks), because cros_ec_lpc expects
    platform_get_irq() to return -ENXIO for non-existent IRQs.
    Unfortunately, acpi_dev_gpio_irq_get() doesn't follow this convention
    and returns -ENOENT instead. So we get this error from cros_ec_lpc:
    
       couldn't retrieve IRQ number (-2)
    
    I see a variety of drivers that treat -ENXIO specially, so rather than
    fix all of them, let's fix up the API to restore its previous behavior.
    
    I reported this on v2 of this patch:
    
    https://lore.kernel.org/lkml/20190220180538.GA42642@google.com/
    
    but apparently the patch had already been merged before v3 got sent out:
    
    https://lore.kernel.org/lkml/20190221193429.161300-1-egranata@chromium.org/
    
    and the result is that the bug landed and remains unfixed.
    
    I differ from the v3 patch by:
     * allowing for ret==0, even though acpi_dev_gpio_irq_get() specifically
       documents (and enforces) that 0 is not a valid return value (noted on
       the v3 review)
     * adding a small comment
    
    Reported-by: Brian Norris <briannorris@chromium.org>
    Reported-by: Salvatore Bellizzi <salvatore.bellizzi@linux.seppia.net>
    Cc: Enrico Granata <egranata@chromium.org>
    Cc: <stable@vger.kernel.org>
    Fixes: daaef255dc96 ("driver: platform: Support parsing GpioInt 0 in platform_get_irq()")
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Enrico Granata <egranata@google.com>
    Link: https://lore.kernel.org/r/20190729204954.25510-1-briannorris@chromium.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 506a0175a5a7..ec974ba9c0c4 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -157,8 +157,13 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 	 * the device will only expose one IRQ, and this fallback
 	 * allows a common code path across either kind of resource.
 	 */
-	if (num == 0 && has_acpi_companion(&dev->dev))
-		return acpi_dev_gpio_irq_get(ACPI_COMPANION(&dev->dev), num);
+	if (num == 0 && has_acpi_companion(&dev->dev)) {
+		int ret = acpi_dev_gpio_irq_get(ACPI_COMPANION(&dev->dev), num);
+
+		/* Our callers expect -ENXIO for missing IRQs. */
+		if (ret >= 0 || ret == -EPROBE_DEFER)
+			return ret;
+	}
 
 	return -ENXIO;
 #endif

commit 36f3313d6bff91ab2a9e47698c27d15363640a4e
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:38 2019 +0100

    platform: Add platform_find_device_by_driver() helper
    
    Provide a helper to lookup platform devices by matching device
    driver in order to avoid drivers trying to use platform bus
    internals.
    
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Heiko Stübner" <heiko@sntech.de>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Sandy Huang <hjc@rock-chips.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Link: https://lore.kernel.org/r/20190723221838.12024-8-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 506a0175a5a7..a174ce5ea17c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1197,6 +1197,20 @@ struct bus_type platform_bus_type = {
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 
+/**
+ * platform_find_device_by_driver - Find a platform device with a given
+ * driver.
+ * @start: The device to start the search from.
+ * @drv: The device driver to look for.
+ */
+struct device *platform_find_device_by_driver(struct device *start,
+					      const struct device_driver *drv)
+{
+	return bus_find_device(&platform_bus_type, start, drv,
+			       (void *)platform_match);
+}
+EXPORT_SYMBOL_GPL(platform_find_device_by_driver);
+
 int __init platform_bus_init(void)
 {
 	int error;

commit fe34c89d25429e079ba67416529514120dd715f8
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue Jun 18 12:34:59 2019 -0300

    docs: driver-model: move it to the driver-api book
    
    The audience for the Kernel driver-model is clearly Kernel hackers.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com> # ice driver changes

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 713903290385..506a0175a5a7 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -5,7 +5,7 @@
  * Copyright (c) 2002-3 Patrick Mochel
  * Copyright (c) 2002-3 Open Source Development Labs
  *
- * Please see Documentation/driver-model/platform.rst for more
+ * Please see Documentation/driver-api/driver-model/platform.rst for more
  * information.
  */
 

commit 4489f161b739f01ab60a58784f6ef7de9d7a1352
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue Jun 18 17:53:27 2019 -0300

    docs: driver-model: convert docs to ReST and rename to *.rst
    
    Convert the various documents at the driver-model, preparing
    them to be part of the driver-api book.
    
    The conversion is actually:
      - add blank lines and identation in order to identify paragraphs;
      - fix tables markups;
      - add some lists markups;
      - mark literal blocks;
      - adjust title markups.
    
    At its new index.rst, let's add a :orphan: while this is not linked to
    the main index.rst file, in order to avoid build warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com> # ice
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4d1729853d1a..713903290385 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -5,7 +5,7 @@
  * Copyright (c) 2002-3 Patrick Mochel
  * Copyright (c) 2002-3 Open Source Development Labs
  *
- * Please see Documentation/driver-model/platform.txt for more
+ * Please see Documentation/driver-model/platform.rst for more
  * information.
  */
 

commit 391c0325cc5f9e2daf9117825714d777b3595a42
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 29 19:49:21 2019 +0200

    Revert "driver core: platform: Fix the usage of platform device name(pdev->name)"
    
    This reverts commit edb16da34b084c66763f29bee42b4e6bb33c3d66 as it
    breaks existing systems as reported by Krzysztof.
    
    Reported-by: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Venkata Narendra Kumar Gutta <vnkgutta@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index df76e40c1a83..4d1729853d1a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -890,7 +890,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 	if (len != -ENODEV)
 		return len;
 
-	len = snprintf(buf, PAGE_SIZE, "platform:%s\n", dev_name(&pdev->dev));
+	len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -966,7 +966,7 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return rc;
 
 	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
-			dev_name(&pdev->dev));
+			pdev->name);
 	return 0;
 }
 
@@ -975,7 +975,7 @@ static const struct platform_device_id *platform_match_id(
 			struct platform_device *pdev)
 {
 	while (id->name[0]) {
-		if (strcmp(dev_name(&pdev->dev), id->name) == 0) {
+		if (strcmp(pdev->name, id->name) == 0) {
 			pdev->id_entry = id;
 			return id;
 		}
@@ -1019,7 +1019,7 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 		return platform_match_id(pdrv->id_table, pdev) != NULL;
 
 	/* fall-back to driver name match */
-	return (strcmp(dev_name(&pdev->dev), drv->name) == 0);
+	return (strcmp(pdev->name, drv->name) == 0);
 }
 
 #ifdef CONFIG_PM_SLEEP

commit edb16da34b084c66763f29bee42b4e6bb33c3d66
Author: Venkata Narendra Kumar Gutta <vnkgutta@codeaurora.org>
Date:   Mon Apr 22 17:16:29 2019 -0700

    driver core: platform: Fix the usage of platform device name(pdev->name)
    
    Platform core is using pdev->name as the platform device name to do
    the binding of the devices with the drivers. But, when the platform
    driver overrides the platform device name with dev_set_name(),
    the pdev->name is pointing to a location which is freed and becomes
    an invalid parameter to do the binding match.
    
    use-after-free instance:
    
    [   33.325013] BUG: KASAN: use-after-free in strcmp+0x8c/0xb0
    [   33.330646] Read of size 1 at addr ffffffc10beae600 by task modprobe
    [   33.339068] CPU: 5 PID: 518 Comm: modprobe Tainted:
                            G S      W  O      4.19.30+ #3
    [   33.346835] Hardware name: MTP (DT)
    [   33.350419] Call trace:
    [   33.352941]  dump_backtrace+0x0/0x3b8
    [   33.356713]  show_stack+0x24/0x30
    [   33.360119]  dump_stack+0x160/0x1d8
    [   33.363709]  print_address_description+0x84/0x2e0
    [   33.368549]  kasan_report+0x26c/0x2d0
    [   33.372322]  __asan_report_load1_noabort+0x2c/0x38
    [   33.377248]  strcmp+0x8c/0xb0
    [   33.380306]  platform_match+0x70/0x1f8
    [   33.384168]  __driver_attach+0x78/0x3a0
    [   33.388111]  bus_for_each_dev+0x13c/0x1b8
    [   33.392237]  driver_attach+0x4c/0x58
    [   33.395910]  bus_add_driver+0x350/0x560
    [   33.399854]  driver_register+0x23c/0x328
    [   33.403886]  __platform_driver_register+0xd0/0xe0
    
    So, use dev_name(&pdev->dev), which fetches the platform device name from
    the kobject(dev->kobj->name) of the device instead of the pdev->name.
    
    Signed-off-by: Venkata Narendra Kumar Gutta <vnkgutta@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4d1729853d1a..df76e40c1a83 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -890,7 +890,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 	if (len != -ENODEV)
 		return len;
 
-	len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
+	len = snprintf(buf, PAGE_SIZE, "platform:%s\n", dev_name(&pdev->dev));
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -966,7 +966,7 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return rc;
 
 	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
-			pdev->name);
+			dev_name(&pdev->dev));
 	return 0;
 }
 
@@ -975,7 +975,7 @@ static const struct platform_device_id *platform_match_id(
 			struct platform_device *pdev)
 {
 	while (id->name[0]) {
-		if (strcmp(pdev->name, id->name) == 0) {
+		if (strcmp(dev_name(&pdev->dev), id->name) == 0) {
 			pdev->id_entry = id;
 			return id;
 		}
@@ -1019,7 +1019,7 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 		return platform_match_id(pdrv->id_table, pdev) != NULL;
 
 	/* fall-back to driver name match */
-	return (strcmp(pdev->name, drv->name) == 0);
+	return (strcmp(dev_name(&pdev->dev), drv->name) == 0);
 }
 
 #ifdef CONFIG_PM_SLEEP

commit 25ebcb7dc84db59514b7409ad009d8d67833e091
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Apr 4 11:11:58 2019 +0300

    driver core: platform: Propagate error from insert_resource()
    
    Since insert_resource() might return an error we don't need
    to shadow its error code and would safely propagate to the user.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 09c00d91094c..4d1729853d1a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -438,10 +438,12 @@ int platform_device_add(struct platform_device *pdev)
 				p = &ioport_resource;
 		}
 
-		if (p && insert_resource(p, r)) {
-			dev_err(&pdev->dev, "failed to claim resource %d: %pR\n", i, r);
-			ret = -EBUSY;
-			goto failed;
+		if (p) {
+			ret = insert_resource(p, r);
+			if (ret) {
+				dev_err(&pdev->dev, "failed to claim resource %d: %pR\n", i, r);
+				goto failed;
+			}
 		}
 	}
 

commit 7067c96ee8d2d77039aeb49670acfe160f484ef9
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Apr 1 10:16:35 2019 +0200

    drivers: fix a typo in the kernel doc for devm_platform_ioremap_resource()
    
    It should have been 'management' not 'managemend'.
    
    Fixes: 7945f929f1a7 ("drivers: provide devm_platform_ioremap_resource()")
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index dab0a5abc391..09c00d91094c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -84,7 +84,7 @@ EXPORT_SYMBOL_GPL(platform_get_resource);
  *				    device
  *
  * @pdev: platform device to use both for memory resource lookup as well as
- *        resource managemend
+ *        resource management
  * @index: resource index
  */
 #ifdef CONFIG_HAS_IOMEM

commit 3601fe43e8164f67a8de3de8e988bfcb3a94af46
Merge: cf2e8c544cd3 d01849f7deba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 8 10:09:53 2019 -0800

    Merge tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v5.1 cycle:
    
      Core changes:
    
       - The big change this time around is the irqchip handling in the
         qualcomm pin controllers, closely coupled with the gpiochip. This
         rework, in a classic fall-between-the-chairs fashion has been
         sidestepped for too long.
    
         The Qualcomm IRQchips using the SPMI and SSBI transport mechanisms
         have been rewritten to use hierarchical irqchip. This creates the
         base from which I intend to gradually pull support for hierarchical
         irqchips into the gpiolib irqchip helpers to cut down on duplicate
         code.
    
         We have too many hacks in the kernel because people have been
         working around the missing hierarchical irqchip for years, and once
         it was there, noone understood it for a while. We are now slowly
         adapting to using it.
    
         This is why this pull requests include changes to MFD, SPMI,
         IRQchip core and some ARM Device Trees pertaining to the Qualcomm
         chip family. Since Qualcomm have so many chips and such large
         deployments it is paramount that this platform gets this right, and
         now it (hopefully) does.
    
       - Core support for pull-up and pull-down configuration, also from the
         device tree. When a simple GPIO chip supports an "off or on" pull-up
         or pull-down resistor, we provide a way to set this up using
         machine descriptors or device tree.
    
         If more elaborate control of pull up/down (such as resistance shunt
         setting) is required, drivers should be phased over to use pin
         control. We do not yet provide a userspace ABI for this pull
         up-down setting but I suspect the makers are going to ask for it
         soon enough. PCA953x is the first user of this new API.
    
       - The GPIO mockup driver has been revamped after some discussion
         improving the IRQ simulator in the process.
    
         The idea is to make it possible to use the mockup for both testing
         and virtual prototyping, e.g. when you do not yet have a GPIO
         expander to play with but really want to get something to develop
         code around before hardware is available. It's neat. The blackbox
         testing usecase is currently making its way into kernelci.
    
       - ACPI GPIO core preserves non direction flags when updating flags.
    
       - A new device core helper for devm_platform_ioremap_resource() is
         funneled through the GPIO tree with Greg's ACK.
    
      New drivers:
    
       - TQ-Systems QTMX86 GPIO controllers (using port-mapped I/O)
    
       - Gateworks PLD GPIO driver (vaccumed up from OpenWrt)
    
       - AMD G-Series PCH (Platform Controller Hub) GPIO driver.
    
       - Fintek F81804 & F81966 subvariants.
    
       - PCA953x now supports NXP PCAL6416.
    
      Driver improvements:
    
       - IRQ support on the Nintendo Wii (Hollywood) GPIO.
    
       - get_direction() support for the MVEBU driver.
    
       - Set the right output level on SAMA5D2.
    
       - Drop the unused irq trigger setting on the Spreadtrum driver.
    
       - Wakeup support for PCA953x.
    
       - A slew of cleanups in the various Intel drivers"
    
    * tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (110 commits)
      gpio: gpio-omap: fix level interrupt idling
      gpio: amd-fch: Set proper output level for direction_output
      x86: apuv2: remove unused variable
      gpio: pca953x: Use PCA_LATCH_INT
      platform/x86: fix PCENGINES_APU2 Kconfig warning
      gpio: pca953x: Fix dereference of irq data in shutdown
      gpio: amd-fch: Fix type error found by sparse
      gpio: amd-fch: Drop const from resource
      gpio: mxc: add check to return defer probe if clock tree NOT ready
      gpio: ftgpio: Register per-instance irqchip
      gpio: ixp4xx: Add DT bindings
      x86: pcengines apuv2 gpio/leds/keys platform driver
      gpio: AMD G-Series PCH gpio driver
      drivers: depend on HAS_IOMEM for devm_platform_ioremap_resource()
      gpio: tqmx86: Set proper output level for direction_output
      gpio: sprd: Change to use SoC compatible string
      gpio: sprd: Use SoC compatible string instead of wildcard string
      gpio: of: Handle both enable-gpio{,s}
      gpio: of: Restrict enable-gpio quirk to regulator-gpio
      gpio: davinci: use devm_platform_ioremap_resource()
      ...

commit 36cf3b1363f464c40f6ce647d3ac0ae9617d5fbc
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Mar 1 13:24:47 2019 +0100

    driver core: platform: remove misleading err_alloc label
    
    In platform_device_register_full() the err_alloc label is
    misleading, we only ever jump to it if the pdev is NULL,
    but it then proceeds to free it, which is a no-op.
    
    Remove the label and simply exit the function immediately.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index fc67a325beaa..4e45ac21d672 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -521,7 +521,7 @@ struct platform_device *platform_device_register_full(
 
 	pdev = platform_device_alloc(pdevinfo->name, pdevinfo->id);
 	if (!pdev)
-		goto err_alloc;
+		return ERR_PTR(-ENOMEM);
 
 	pdev->dev.parent = pdevinfo->parent;
 	pdev->dev.fwnode = pdevinfo->fwnode;
@@ -568,8 +568,6 @@ struct platform_device *platform_device_register_full(
 err:
 		ACPI_COMPANION_SET(&pdev->dev, NULL);
 		kfree(pdev->dev.dma_mask);
-
-err_alloc:
 		platform_device_put(pdev);
 		return ERR_PTR(ret);
 	}

commit 2c1ea6abde8884208a9b94254740ae4597c62000
Author: Mans Rullgard <mans@mansr.com>
Date:   Thu Feb 21 11:29:35 2019 +0000

    platform: set of_node in platform_device_register_full()
    
    If the provided fwnode is an OF node, set dev.of_node as well.
    
    Also add an of_node_reused flag to struct platform_device_info and copy
    this to the new device.  This is needed to avoid pinctrl settings being
    requested twice.  See 4e75e1d7dac9 ("driver core: add helper to reuse a
    device-tree node") for a longer explanation.
    
    Some drivers are just shims that create extra "glue" devices with the
    DT device as parent and have the real driver bind to these.  In these
    cases, the glue device needs to get a reference to the original DT node
    in order for the main driver to access properties and child nodes.
    
    For example, the sunxi-musb driver creates such a glue device using
    platform_device_register_full().  Consequently, devices attached to
    this USB interface don't get associated with DT nodes, if present,
    the way they do with EHCI.
    
    This change will allow sunxi-musb and similar drivers to easily
    propagate the DT node to child devices as required.
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 0d3611cd1b3b..fc67a325beaa 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -525,6 +525,8 @@ struct platform_device *platform_device_register_full(
 
 	pdev->dev.parent = pdevinfo->parent;
 	pdev->dev.fwnode = pdevinfo->fwnode;
+	pdev->dev.of_node = of_node_get(to_of_node(pdev->dev.fwnode));
+	pdev->dev.of_node_reused = pdevinfo->of_node_reused;
 
 	if (pdevinfo->dma_mask) {
 		/*

commit 837ccda3480d2861c09aabc5fa014be18df9dd3c
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 21 17:26:27 2019 +0100

    drivers: depend on HAS_IOMEM for devm_platform_ioremap_resource()
    
    We only build devm_ioremap_resource() if HAS_IOMEM is selected, so this
    dependency must cascade down to devm_platform_ioremap_resource().
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f82691e1c26c..5f837f2e4f41 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -87,6 +87,7 @@ EXPORT_SYMBOL_GPL(platform_get_resource);
  *        resource managemend
  * @index: resource index
  */
+#ifdef CONFIG_HAS_IOMEM
 void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
 					     unsigned int index)
 {
@@ -96,6 +97,7 @@ void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
 	return devm_ioremap_resource(&pdev->dev, res);
 }
 EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource);
+#endif /* CONFIG_HAS_IOMEM */
 
 /**
  * platform_get_irq - get an IRQ for a device

commit 7945f929f1a77a1c8887a97ca07f87626858ff42
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Feb 20 11:12:39 2019 +0000

    drivers: provide devm_platform_ioremap_resource()
    
    There are currently 1200+ instances of using platform_get_resource()
    and devm_ioremap_resource() together in the kernel tree.
    
    This patch wraps these two calls in a single helper. Thanks to that
    we don't have to declare a local variable for struct resource * and can
    omit the redundant argument for resource type. We also have one
    function call less.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1c958eb33ef4..f82691e1c26c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -79,6 +79,24 @@ struct resource *platform_get_resource(struct platform_device *dev,
 }
 EXPORT_SYMBOL_GPL(platform_get_resource);
 
+/**
+ * devm_platform_ioremap_resource - call devm_ioremap_resource() for a platform
+ *				    device
+ *
+ * @pdev: platform device to use both for memory resource lookup as well as
+ *        resource managemend
+ * @index: resource index
+ */
+void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,
+					     unsigned int index)
+{
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, index);
+	return devm_ioremap_resource(&pdev->dev, res);
+}
+EXPORT_SYMBOL_GPL(devm_platform_ioremap_resource);
+
 /**
  * platform_get_irq - get an IRQ for a device
  * @dev: platform device

commit daaef255dc96834aaaad627d3271504cba3ac2dc
Author: Enrico Granata <egranata@chromium.org>
Date:   Mon Feb 11 11:01:12 2019 -0800

    driver: platform: Support parsing GpioInt 0 in platform_get_irq()
    
    ACPI 5 added support for GpioInt resources as a way to provide
    information about interrupts mediated via a GPIO controller.
    
    Several device buses (e.g. SPI, I2C) have support for retrieving
    an IRQ specified via this type of resource, and providing it
    directly to the driver as an IRQ number.
    
    This is not currently done for the platform drivers, as platform_get_irq()
    does not try to parse GpioInt() resources. This requires drivers to
    either have to support only one possible IRQ resource, or to have code
    in place to try both as a failsafe.
    
    While there is a possibility of ambiguity for devices that exposes
    multiple IRQs, it is easy and feasible to support the common case
    of devices that only expose one IRQ which would be of either type
    depending on the underlying system's architecture.
    
    This commit adds support for parsing a GpioInt resource in order
    to fulfill a request for the index 0 IRQ for a platform device.
    
    Signed-off-by: Enrico Granata <egranata@chromium.org>
    Reviewed-by: Dmitry Torokhov <dtor@chromium.org>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1c958eb33ef4..0d3611cd1b3b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -127,7 +127,20 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 		irqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);
 	}
 
-	return r ? r->start : -ENXIO;
+	if (r)
+		return r->start;
+
+	/*
+	 * For the index 0 interrupt, allow falling back to GpioInt
+	 * resources. While a device could have both Interrupt and GpioInt
+	 * resources, making this fallback ambiguous, in many common cases
+	 * the device will only expose one IRQ, and this fallback
+	 * allows a common code path across either kind of resource.
+	 */
+	if (num == 0 && has_acpi_companion(&dev->dev))
+		return acpi_dev_gpio_irq_get(ACPI_COMPANION(&dev->dev), num);
+
+	return -ENXIO;
 #endif
 }
 EXPORT_SYMBOL_GPL(platform_get_irq);

commit 967d3010df8b6f6f9aa95c198edc5fe3646ebf36
Author: Qian Cai <cai@gmx.us>
Date:   Thu Jan 3 15:29:05 2019 -0800

    drivers/base/platform.c: kmemleak ignore a known leak
    
    unreferenced object 0xffff808ec6dc5a80 (size 128):
      comm "swapper/0", pid 1, jiffies 4294938063 (age 2560.530s)
      hex dump (first 32 bytes):
        ff ff ff ff 00 00 00 00 6b 6b 6b 6b 6b 6b 6b 6b  ........kkkkkkkk
        6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
      backtrace:
        [<00000000476dcf8c>] kmem_cache_alloc_trace+0x430/0x500
        [<000000004f708d37>] platform_device_register_full+0xbc/0x1e8
        [<000000006c2a7ec7>] acpi_create_platform_device+0x370/0x450
        [<00000000ef135642>] acpi_default_enumeration+0x34/0x78
        [<000000003bd9a052>] acpi_bus_attach+0x2dc/0x3e0
        [<000000003cf4f7f2>] acpi_bus_attach+0x108/0x3e0
        [<000000003cf4f7f2>] acpi_bus_attach+0x108/0x3e0
        [<000000002968643e>] acpi_bus_scan+0xb0/0x110
        [<0000000010dd0bd7>] acpi_scan_init+0x1a8/0x410
        [<00000000965b3c5a>] acpi_init+0x408/0x49c
        [<00000000ed4b9fe2>] do_one_initcall+0x178/0x7f4
        [<00000000a5ac5a74>] kernel_init_freeable+0x9d4/0xa9c
        [<0000000070ea6c15>] kernel_init+0x18/0x138
        [<00000000fb8fff06>] ret_from_fork+0x10/0x1c
        [<0000000041273a0d>] 0xffffffffffffffff
    
    Then, faddr2line pointed out this line,
    
    /*
     * This memory isn't freed when the device is put,
     * I don't have a nice idea for that though.  Conceptually
     * dma_mask in struct device should not be a pointer.
     * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
     */
    pdev->dev.dma_mask =
            kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
    
    Since this leak has existed for more than 8 years and it does not
    reference other parts of the memory, let kmemleak ignore it, so users
    don't need to waste time reporting this in the future.
    
    Link: http://lkml.kernel.org/r/20181206160751.36211-1-cai@gmx.us
    Signed-off-by: Qian Cai <cai@gmx.us>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J . Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index be6c1eb3cbe2..1c958eb33ef4 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -26,6 +26,7 @@
 #include <linux/clk/clk-conf.h>
 #include <linux/limits.h>
 #include <linux/property.h>
+#include <linux/kmemleak.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -524,6 +525,8 @@ struct platform_device *platform_device_register_full(
 		if (!pdev->dev.dma_mask)
 			goto err;
 
+		kmemleak_ignore(pdev->dev.dma_mask);
+
 		*pdev->dev.dma_mask = pdevinfo->dma_mask;
 		pdev->dev.coherent_dma_mask = pdevinfo->dma_mask;
 	}

commit b07039b79c9ea64c1eacda1e01d645082e4a0d5d
Merge: 02061181d3a9 16df1456aa85
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 20:44:29 2018 -0800

    Merge tag 'driver-core-4.21-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the "big" set of driver core patches for 4.21-rc1.
    
      It's not really big, just a number of small changes for some reported
      issues, some documentation updates to hopefully make it harder for
      people to abuse the driver model, and some other minor cleanups.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.21-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:
      mm, memory_hotplug: update a comment in unregister_memory()
      component: convert to DEFINE_SHOW_ATTRIBUTE
      sysfs: Disable lockdep for driver bind/unbind files
      driver core: Add missing dev->bus->need_parent_lock checks
      kobject: return error code if writing /sys/.../uevent fails
      driver core: Move async_synchronize_full call
      driver core: platform: Respect return code of platform_device_register_full()
      kref/kobject: Improve documentation
      drivers/base/memory.c: Use DEVICE_ATTR_RO and friends
      driver core: Replace simple_strto{l,ul} by kstrtou{l,ul}
      kernfs: Improve kernfs_notify() poll notification latency
      kobject: Fix warnings in lib/kobject_uevent.c
      kobject: drop unnecessary cast "%llu" for u64
      driver core: fix comments for device_block_probing()
      driver core: Replace simple_strtol by kstrtoint

commit af7ddd8a627c62a835524b3f5b471edbbbcce025
Merge: fe2b0cdabcd9 8b1cce9f5832
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 14:12:21 2018 -0800

    Merge tag 'dma-mapping-4.21' of git://git.infradead.org/users/hch/dma-mapping
    
    Pull DMA mapping updates from Christoph Hellwig:
     "A huge update this time, but a lot of that is just consolidating or
      removing code:
    
       - provide a common DMA_MAPPING_ERROR definition and avoid indirect
         calls for dma_map_* error checking
    
       - use direct calls for the DMA direct mapping case, avoiding huge
         retpoline overhead for high performance workloads
    
       - merge the swiotlb dma_map_ops into dma-direct
    
       - provide a generic remapping DMA consistent allocator for
         architectures that have devices that perform DMA that is not cache
         coherent. Based on the existing arm64 implementation and also used
         for csky now.
    
       - improve the dma-debug infrastructure, including dynamic allocation
         of entries (Robin Murphy)
    
       - default to providing chaining scatterlist everywhere, with opt-outs
         for the few architectures (alpha, parisc, most arm32 variants) that
         can't cope with it
    
       - misc sparc32 dma-related cleanups
    
       - remove the dma_mark_clean arch hook used by swiotlb on ia64 and
         replace it with the generic noncoherent infrastructure
    
       - fix the return type of dma_set_max_seg_size (Niklas Söderlund)
    
       - move the dummy dma ops for not DMA capable devices from arm64 to
         common code (Robin Murphy)
    
       - ensure dma_alloc_coherent returns zeroed memory to avoid kernel
         data leaks through userspace. We already did this for most common
         architectures, but this ensures we do it everywhere.
         dma_zalloc_coherent has been deprecated and can hopefully be
         removed after -rc1 with a coccinelle script"
    
    * tag 'dma-mapping-4.21' of git://git.infradead.org/users/hch/dma-mapping: (73 commits)
      dma-mapping: fix inverted logic in dma_supported
      dma-mapping: deprecate dma_zalloc_coherent
      dma-mapping: zero memory returned from dma_alloc_*
      sparc/iommu: fix ->map_sg return value
      sparc/io-unit: fix ->map_sg return value
      arm64: default to the direct mapping in get_arch_dma_ops
      PCI: Remove unused attr variable in pci_dma_configure
      ia64: only select ARCH_HAS_DMA_COHERENT_TO_PFN if swiotlb is enabled
      dma-mapping: bypass indirect calls for dma-direct
      vmd: use the proper dma_* APIs instead of direct methods calls
      dma-direct: merge swiotlb_dma_ops into the dma_direct code
      dma-direct: use dma_direct_map_page to implement dma_direct_map_sg
      dma-direct: improve addressability error reporting
      swiotlb: remove dma_mark_clean
      swiotlb: remove SWIOTLB_MAP_ERROR
      ACPI / scan: Refactor _CCA enforcement
      dma-mapping: factor out dummy DMA ops
      dma-mapping: always build the direct mapping code
      dma-mapping: move dma_cache_sync out of line
      dma-mapping: move various slow path functions out of line
      ...

commit e5361ca29f2fea345c08d2b5cb5e3b1840cbafb8
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Dec 6 13:20:49 2018 -0800

    ACPI / scan: Refactor _CCA enforcement
    
    Rather than checking the DMA attribute at each callsite, just pass it
    through for acpi_dma_configure() to handle directly. That can then deal
    with the relatively exceptional DEV_DMA_NOT_SUPPORTED case by explicitly
    installing dummy DMA ops instead of just skipping setup entirely. This
    will then free up the dev->dma_ops == NULL case for some valuable
    fastpath optimisations.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Tested-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index eae841935a45..c1ddf191711e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1138,8 +1138,7 @@ int platform_dma_configure(struct device *dev)
 		ret = of_dma_configure(dev, dev->of_node, true);
 	} else if (has_acpi_companion(dev)) {
 		attr = acpi_get_dma_attr(to_acpi_device_node(dev->fwnode));
-		if (attr != DEV_DMA_NOT_SUPPORTED)
-			ret = acpi_dma_configure(dev, attr);
+		ret = acpi_dma_configure(dev, attr);
 	}
 
 	return ret;

commit 05887cb610a54bf568de7f0bc07c4a64e45ac6f9
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 6 12:25:54 2018 -0800

    dma-mapping: move dma_get_required_mask to kernel/dma
    
    dma_get_required_mask should really be with the rest of the DMA mapping
    implementation instead of in drivers/base as a lone outlier.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Tested-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Tested-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 41b91af95afb..eae841935a45 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1179,37 +1179,6 @@ int __init platform_bus_init(void)
 	return error;
 }
 
-#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK
-static u64 dma_default_get_required_mask(struct device *dev)
-{
-	u32 low_totalram = ((max_pfn - 1) << PAGE_SHIFT);
-	u32 high_totalram = ((max_pfn - 1) >> (32 - PAGE_SHIFT));
-	u64 mask;
-
-	if (!high_totalram) {
-		/* convert to mask just covering totalram */
-		low_totalram = (1 << (fls(low_totalram) - 1));
-		low_totalram += low_totalram - 1;
-		mask = low_totalram;
-	} else {
-		high_totalram = (1 << (fls(high_totalram) - 1));
-		high_totalram += high_totalram - 1;
-		mask = (((u64)high_totalram) << 32) + 0xffffffff;
-	}
-	return mask;
-}
-
-u64 dma_get_required_mask(struct device *dev)
-{
-	const struct dma_map_ops *ops = get_dma_ops(dev);
-
-	if (ops->get_required_mask)
-		return ops->get_required_mask(dev);
-	return dma_default_get_required_mask(dev);
-}
-EXPORT_SYMBOL_GPL(dma_get_required_mask);
-#endif
-
 static __initdata LIST_HEAD(early_platform_driver_list);
 static __initdata LIST_HEAD(early_platform_device_list);
 

commit 99fef587ff98894426d9bf1f5b7336345052d4b3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 3 20:21:41 2018 +0200

    driver core: platform: Respect return code of platform_device_register_full()
    
    The platform_device_register_full() might return an error pointer. If we
    instantiate platform device which is optional we may simplify the routine at
    removal stage by simply calling platform_device_unregister(). For now it
    requires to check parameter for being an error pointer in each caller.
    
    To make users' life easier, check for an error pointer inside driver core.
    
    Reported-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 41b91af95afb..e1ba610482c0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -234,7 +234,7 @@ struct platform_object {
  */
 void platform_device_put(struct platform_device *pdev)
 {
-	if (pdev)
+	if (!IS_ERR_OR_NULL(pdev))
 		put_device(&pdev->dev);
 }
 EXPORT_SYMBOL_GPL(platform_device_put);
@@ -447,7 +447,7 @@ void platform_device_del(struct platform_device *pdev)
 {
 	int i;
 
-	if (pdev) {
+	if (!IS_ERR_OR_NULL(pdev)) {
 		device_remove_properties(&pdev->dev);
 		device_del(&pdev->dev);
 

commit 2d51ac9086fd4852c1e43d615bd8dd99f2a616eb
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri Nov 9 17:21:33 2018 +0300

    driver core: platform: Remove duplicated device_remove_properties() call
    
    device_remove_properties() is called for every device in device_del().
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 41b91af95afb..0fb5f140f1b0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -448,7 +448,6 @@ void platform_device_del(struct platform_device *pdev)
 	int i;
 
 	if (pdev) {
-		device_remove_properties(&pdev->dev);
 		device_del(&pdev->dev);
 
 		if (pdev->id_auto) {

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 23cf4427f425..41b91af95afb 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>

commit 6db37ad7c27bda2f62d1ef6ad0496e359c562c1a
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Oct 2 07:21:31 2018 -0700

    dma-mapping: move dma_default_get_required_mask under ifdef
    
    This avoids a warning on powerpc.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index cfe22fded980..23cf4427f425 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1179,6 +1179,7 @@ int __init platform_bus_init(void)
 	return error;
 }
 
+#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK
 static u64 dma_default_get_required_mask(struct device *dev)
 {
 	u32 low_totalram = ((max_pfn - 1) << PAGE_SHIFT);
@@ -1198,7 +1199,6 @@ static u64 dma_default_get_required_mask(struct device *dev)
 	return mask;
 }
 
-#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK
 u64 dma_get_required_mask(struct device *dev)
 {
 	const struct dma_map_ops *ops = get_dma_ops(dev);

commit c6d4381220a0087ce19dbf6984d92c451bd6b364
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 6 19:27:24 2018 -0400

    dma-mapping: make the get_required_mask method available unconditionally
    
    This save some duplication for ia64, and makes the interface more
    general.  In the long run we want each dma_map_ops instance to fill this
    out, but this will take a little more prep work.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index dff82a3c2caa..cfe22fded980 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1179,8 +1179,7 @@ int __init platform_bus_init(void)
 	return error;
 }
 
-#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK
-u64 dma_get_required_mask(struct device *dev)
+static u64 dma_default_get_required_mask(struct device *dev)
 {
 	u32 low_totalram = ((max_pfn - 1) << PAGE_SHIFT);
 	u32 high_totalram = ((max_pfn - 1) >> (32 - PAGE_SHIFT));
@@ -1198,6 +1197,16 @@ u64 dma_get_required_mask(struct device *dev)
 	}
 	return mask;
 }
+
+#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK
+u64 dma_get_required_mask(struct device *dev)
+{
+	const struct dma_map_ops *ops = get_dma_ops(dev);
+
+	if (ops->get_required_mask)
+		return ops->get_required_mask(dev);
+	return dma_default_get_required_mask(dev);
+}
 EXPORT_SYMBOL_GPL(dma_get_required_mask);
 #endif
 

commit 3c89adb0d11117f64d5b501730be7fb2bf53a479
Merge: 11e7c2188061 a24e16b1310c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 09:38:39 2018 -0700

    Merge tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These include a significant update of the generic power domains
      (genpd) and Operating Performance Points (OPP) frameworks, mostly
      related to the introduction of power domain performance levels,
      cpufreq updates (new driver for Qualcomm Kryo processors, updates of
      the existing drivers, some core fixes, schedutil governor
      improvements), PCI power management fixes, ACPI workaround for
      EC-based wakeup events handling on resume from suspend-to-idle, and
      major updates of the turbostat and pm-graph utilities.
    
      Specifics:
    
       - Introduce power domain performance levels into the the generic
         power domains (genpd) and Operating Performance Points (OPP)
         frameworks (Viresh Kumar, Rajendra Nayak, Dan Carpenter).
    
       - Fix two issues in the runtime PM framework related to the
         initialization and removal of devices using device links (Ulf
         Hansson).
    
       - Clean up the initialization of drivers for devices in PM domains
         (Ulf Hansson, Geert Uytterhoeven).
    
       - Fix a cpufreq core issue related to the policy sysfs interface
         causing CPU online to fail for CPUs sharing one cpufreq policy in
         some situations (Tao Wang).
    
       - Make it possible to use platform-specific suspend/resume hooks in
         the cpufreq-dt driver and make the Armada 37xx DVFS use that
         feature (Viresh Kumar, Miquel Raynal).
    
       - Optimize policy transition notifications in cpufreq (Viresh Kumar).
    
       - Improve the iowait boost mechanism in the schedutil cpufreq
         governor (Patrick Bellasi).
    
       - Improve the handling of deferred frequency updates in the schedutil
         cpufreq governor (Joel Fernandes, Dietmar Eggemann, Rafael Wysocki,
         Viresh Kumar).
    
       - Add a new cpufreq driver for Qualcomm Kryo (Ilia Lin).
    
       - Fix and clean up some cpufreq drivers (Colin Ian King, Dmitry
         Osipenko, Doug Smythies, Luc Van Oostenryck, Simon Horman, Viresh
         Kumar).
    
       - Fix the handling of PCI devices with the DPM_SMART_SUSPEND flag set
         and update stale comments in the PCI core PM code (Rafael Wysocki).
    
       - Work around an issue related to the handling of EC-based wakeup
         events in the ACPI PM core during resume from suspend-to-idle if
         the EC has been put into the low-power mode (Rafael Wysocki).
    
       - Improve the handling of wakeup source objects in the PM core (Doug
         Berger, Mahendran Ganesh, Rafael Wysocki).
    
       - Update the driver core to prevent deferred probe from breaking
         suspend/resume ordering (Feng Kan).
    
       - Clean up the PM core somewhat (Bjorn Helgaas, Ulf Hansson, Rafael
         Wysocki).
    
       - Make the core suspend/resume code and cpufreq support the RT patch
         (Sebastian Andrzej Siewior, Thomas Gleixner).
    
       - Consolidate the PM QoS handling in cpuidle governors (Rafael
         Wysocki).
    
       - Fix a possible crash in the hibernation core (Tetsuo Handa).
    
       - Update the rockchip-io Adaptive Voltage Scaling (AVS) driver (David
         Wu).
    
       - Update the turbostat utility (fixes, cleanups, new CPU IDs, new
         command line options, built-in "Low Power Idle" counters support,
         new POLL and POLL% columns) and add an entry for it to MAINTAINERS
         (Len Brown, Artem Bityutskiy, Chen Yu, Laura Abbott, Matt Turner,
         Prarit Bhargava, Srinivas Pandruvada).
    
       - Update the pm-graph to version 5.1 (Todd Brandt).
    
       - Update the intel_pstate_tracer utility (Doug Smythies)"
    
    * tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (128 commits)
      tools/power turbostat: update version number
      tools/power turbostat: Add Node in output
      tools/power turbostat: add node information into turbostat calculations
      tools/power turbostat: remove num_ from cpu_topology struct
      tools/power turbostat: rename num_cores_per_pkg to num_cores_per_node
      tools/power turbostat: track thread ID in cpu_topology
      tools/power turbostat: Calculate additional node information for a package
      tools/power turbostat: Fix node and siblings lookup data
      tools/power turbostat: set max_num_cpus equal to the cpumask length
      tools/power turbostat: if --num_iterations, print for specific number of iterations
      tools/power turbostat: Add Cannon Lake support
      tools/power turbostat: delete duplicate #defines
      x86: msr-index.h: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: add POLL and POLL% column
      tools/power turbostat: Fix --hide Pk%pc10
      tools/power turbostat: Build-in "Low Power Idle" counters support
      tools/power turbostat: Don't make man pages executable
      tools/power turbostat: remove blank lines
      tools/power turbostat: a small C-states dump readability immprovement
      ...

commit 88a9769e609a7f3b762a2fe88555c5602758346b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 26 10:53:06 2018 +0200

    driver core: Respect all error codes from dev_pm_domain_attach()
    
    The limitation of being able to check only for -EPROBE_DEFER from
    dev_pm_domain_attach() has been removed. Hence let's respect all error
    codes and bail out accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8075ddc70a17..9460139d9b02 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -572,17 +572,16 @@ static int platform_drv_probe(struct device *_dev)
 		return ret;
 
 	ret = dev_pm_domain_attach(_dev, true);
-	if (ret != -EPROBE_DEFER) {
-		if (drv->probe) {
-			ret = drv->probe(dev);
-			if (ret)
-				dev_pm_domain_detach(_dev, true);
-		} else {
-			/* don't fail if just dev_pm_domain_attach failed */
-			ret = 0;
-		}
+	if (ret)
+		goto out;
+
+	if (drv->probe) {
+		ret = drv->probe(dev);
+		if (ret)
+			dev_pm_domain_detach(_dev, true);
 	}
 
+out:
 	if (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {
 		dev_warn(_dev, "probe deferral not supported\n");
 		ret = -ENXIO;

commit 3d6ce86ee79465e1b1b6e287f8ea26b553fc768e
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 3 16:25:08 2018 +0200

    drivers: remove force dma flag from buses
    
    With each bus implementing its own DMA configuration callback, there is no
    need for bus to explicitly set the force_dma flag.  Modify the
    of_dma_configure function to accept an input parameter which specifies if
    implicit DMA configuration is required when it is not described by the
    firmware.
    
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>  # PCI parts
    Reviewed-by: Rob Herring <robh@kernel.org>
    [hch: tweaked the changelog a bit]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 638d42e93772..c0ff1e73a634 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1136,7 +1136,7 @@ int platform_dma_configure(struct device *dev)
 	int ret = 0;
 
 	if (dev->of_node) {
-		ret = of_dma_configure(dev, dev->of_node);
+		ret = of_dma_configure(dev, dev->of_node, true);
 	} else if (has_acpi_companion(dev)) {
 		attr = acpi_get_dma_attr(to_acpi_device_node(dev->fwnode));
 		if (attr != DEV_DMA_NOT_SUPPORTED)
@@ -1159,7 +1159,6 @@ struct bus_type platform_bus_type = {
 	.uevent		= platform_uevent,
 	.dma_configure	= platform_dma_configure,
 	.pm		= &platform_dev_pm_ops,
-	.force_dma	= true,
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 

commit 07397df29e57cde5799af16e8f148ae10ed75285
Author: Nipun Gupta <nipun.gupta@nxp.com>
Date:   Sat Apr 28 08:21:58 2018 +0530

    dma-mapping: move dma configuration to bus infrastructure
    
    ACPI/OF support for configuration of DMA is a bus specific aspect, and
    thus should be configured by the bus.  Introduces a 'dma_configure' bus
    method so that busses can control their DMA capabilities.
    
    Also update the PCI, Platform, ACPI and host1x buses to use the new
    method.
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>  # PCI parts
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    [hch: simplified host1x_dma_configure based on a comment from Thierry,
          rewrote changelog]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8075ddc70a17..638d42e93772 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1130,6 +1130,22 @@ int platform_pm_restore(struct device *dev)
 
 #endif /* CONFIG_HIBERNATE_CALLBACKS */
 
+int platform_dma_configure(struct device *dev)
+{
+	enum dev_dma_attr attr;
+	int ret = 0;
+
+	if (dev->of_node) {
+		ret = of_dma_configure(dev, dev->of_node);
+	} else if (has_acpi_companion(dev)) {
+		attr = acpi_get_dma_attr(to_acpi_device_node(dev->fwnode));
+		if (attr != DEV_DMA_NOT_SUPPORTED)
+			ret = acpi_dma_configure(dev, attr);
+	}
+
+	return ret;
+}
+
 static const struct dev_pm_ops platform_dev_pm_ops = {
 	.runtime_suspend = pm_generic_runtime_suspend,
 	.runtime_resume = pm_generic_runtime_resume,
@@ -1141,6 +1157,7 @@ struct bus_type platform_bus_type = {
 	.dev_groups	= platform_dev_groups,
 	.match		= platform_match,
 	.uevent		= platform_uevent,
+	.dma_configure	= platform_dma_configure,
 	.pm		= &platform_dev_pm_ops,
 	.force_dma	= true,
 };

commit c8ae1674cd0d688661a8b85b8b2d940516933322
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sun Mar 11 11:25:49 2018 +0530

    driver core: platform: use put_device() if device_register fail
    
    if device_register() returned an error! Always use put_device()
    to give up the reference initialized.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f1bf7b38d91c..8075ddc70a17 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1153,8 +1153,10 @@ int __init platform_bus_init(void)
 	early_platform_cleanup();
 
 	error = device_register(&platform_bus);
-	if (error)
+	if (error) {
+		put_device(&platform_bus);
 		return error;
+	}
 	error =  bus_register(&platform_bus_type);
 	if (error)
 		device_unregister(&platform_bus);

commit 328257099077e8affd438c179d8a938948de2e7f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:09 2017 +0100

    driver core: Remove redundant license text
    
    Now that the SPDX tag is in all driver core files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index be287c7f5a6a..f1bf7b38d91c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -5,8 +5,6 @@
  * Copyright (c) 2002-3 Patrick Mochel
  * Copyright (c) 2002-3 Open Source Development Labs
  *
- * This file is released under the GPLv2
- *
  * Please see Documentation/driver-model/platform.txt for more
  * information.
  */

commit 989d42e85dc2f6823f39b8e9d080fd04bae0645d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:07 2017 +0100

    driver core: add SPDX identifiers to all driver core files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the driver core files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c203fb90c1a0..be287c7f5a6a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * platform.c - platform 'pseudo' bus for legacy devices
  *

commit d89e2378a97fafdc74cbf997e7c88af75b81610a
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Oct 12 16:56:14 2017 +0100

    drivers: flag buses which demand DMA configuration
    
    We do not want the common dma_configure() pathway to apply
    indiscriminately to all devices, since there are plenty of buses which
    do not have DMA capability, and if their child devices were used for
    DMA API calls it would only be indicative of a driver bug. However,
    there are a number of buses for which DMA is implicitly expected even
    when not described by firmware - those we whitelist with an automatic
    opt-in to dma_configure(), assuming that the DMA address space and the
    physical address space are equivalent if not otherwise specified.
    
    Commit 723288836628 ("of: restrict DMA configuration") introduced a
    short-term fix by comparing explicit bus types, but this approach is far
    from pretty, doesn't scale well, and fails to cope at all with bus
    drivers which may be built as modules, like host1x. Let's refine things
    by making that opt-in a property of the bus type, which neatly addresses
    those problems and lets the decision of whether firmware description of
    DMA capability should be optional or mandatory stay internal to the bus
    drivers themselves.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9045c5f3734e..c203fb90c1a0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1143,6 +1143,7 @@ struct bus_type platform_bus_type = {
 	.match		= platform_match,
 	.uevent		= platform_uevent,
 	.pm		= &platform_dev_pm_ops,
+	.force_dma	= true,
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 

commit bf563b01c2895a4bfd1a29cc5abc67fe706ecffd
Author: Nicolai Stange <nstange@suse.de>
Date:   Mon Sep 11 09:45:42 2017 +0200

    driver core: platform: Don't read past the end of "driver_override" buffer
    
    When printing the driver_override parameter when it is 4095 and 4094 bytes
    long, the printing code would access invalid memory because we need count+1
    bytes for printing.
    
    Reject driver_override values of these lengths in driver_override_store().
    
    This is in close analogy to commit 4efe874aace5 ("PCI: Don't read past the
    end of sysfs "driver_override" buffer") from Sasha Levin.
    
    Fixes: 3d713e0e382e ("driver core: platform: add device binding path 'driver_override'")
    Cc: stable@vger.kernel.org      # v3.17+
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d1bd99271066..9045c5f3734e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -868,7 +868,8 @@ static ssize_t driver_override_store(struct device *dev,
 	struct platform_device *pdev = to_platform_device(dev);
 	char *driver_override, *old, *cp;
 
-	if (count > PATH_MAX)
+	/* We need to keep extra room for a newline */
+	if (count >= (PAGE_SIZE - 1))
 		return -EINVAL;
 
 	driver_override = kstrndup(buf, count, GFP_KERNEL);

commit c7d28eca1d58d335ff8de6f33559b221bdd029f9
Merge: dddd564dbb59 413058df4331
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 12:40:27 2017 -0700

    Merge tag 'gpio-v4.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.13 series.
    
      Some administrativa:
    
      I have a slew of 8250 serial patches and the new IOT2040 serial+GPIO
      driver coming in through this tree, along with a whole bunch of Exar
      8250 fixes. These are ACKed by Greg and also hit drivers/platform/*
      where they are ACKed by Andy Shevchenko.
    
      Speaking about drivers/platform/* there is also a bunch of ACPI stuff
      coming through that route, again ACKed by Andy.
    
      The MCP23S08 changes are coming in here as well. You already have the
      commits in your tree, so this is just a result of sharing an immutable
      branch between pin control and GPIO.
    
      Core:
       - Export add/remove for lookup tables so that modules can export GPIO
         descriptor tables.
       - Handle GPIO sleep states: it is now possible to flag that a GPIO
         line may loose its state during suspend/resume of the system to
         save power. This is used in the Wolfson Micro Arizona driver.
       - ACPI-based GPIO was tightened up a lot around the edges.
       - Use bitmap_fill() to speed up a loop.
    
      New drivers:
       - Exar XRA1403 SPI-based GPIO.
       - MVEBU driver now supports Armada 7K and 8K.
       - LP87565 PMIC GPIO.
       - Renesas R-CAR R8A7743 (RZ/G1M).
       - The new IOT2040 8250 serial/GPIO also comes in through this
         changeset.
    
      Substantial driver changes:
       - Seriously fix the Exar 8250 GPIO portions to work.
       - The MCP23S08 was moved out to a pin control driver.
       - Convert MEVEBU to use regmap for register access.
       - Drop Vulcan support from the Broadcom driver.
       - Serious cleanup and improvement of the mockup driver, giving us a
         better test coverage.
    
      Misc:
       - Lots of janitorial clean up.
       - A bunch of documentation fixes"
    
    * tag 'gpio-v4.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (70 commits)
      serial: exar: Add support for IOT2040 device
      gpio-exar/8250-exar: Make set of exported GPIOs configurable
      platform: Accept const properties
      serial: exar: Factor out platform hooks
      gpio-exar/8250-exar: Rearrange gpiochip parenthood
      gpio: exar: Fix iomap request
      gpio-exar/8250-exar: Do not even instantiate a GPIO device for Commtech cards
      serial: uapi: Add support for bus termination
      gpio: rcar: Add R8A7743 (RZ/G1M) support
      gpio: gpio-wcove: Fix GPIO control register offset calculation
      gpio: lp87565: Add support for GPIO
      gpio: dwapb: fix missing first irq for edgeboth irq type
      MAINTAINERS: Take maintainership for GPIO ACPI support
      gpio: exar: Fix reading of directions and values
      gpio: exar: Allocate resources on behalf of the platform device
      gpio-exar/8250-exar: Fix passing in of parent PCI device
      gpio: mockup: use devm_kcalloc() where applicable
      gpio: mockup: add myself as author
      gpio: mockup: improve the error message
      gpio: mockup: don't return magic numbers from probe()
      ...

commit 277036f05be242540b7bfe75f226107d04f51b06
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Fri Jun 2 07:43:27 2017 +0200

    platform: Accept const properties
    
    Aligns us with device_add_properties, the function we call.
    
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a102152301c8..71ea6f4d33c2 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -344,7 +344,7 @@ EXPORT_SYMBOL_GPL(platform_device_add_data);
  * platform device is released.
  */
 int platform_device_add_properties(struct platform_device *pdev,
-				   struct property_entry *properties)
+				   const struct property_entry *properties)
 {
 	return device_add_properties(&pdev->dev, properties);
 }

commit 6265539776a0810b7ce6398c27866ddb9c6bd154
Author: Adrian Salido <salidoa@google.com>
Date:   Tue Apr 25 16:55:26 2017 -0700

    driver core: platform: fix race condition with driver_override
    
    The driver_override implementation is susceptible to race condition when
    different threads are reading vs storing a different driver override.
    Add locking to avoid race condition.
    
    Fixes: 3d713e0e382e ("driver core: platform: add device binding path 'driver_override'")
    Cc: stable@vger.kernel.org
    Signed-off-by: Adrian Salido <salidoa@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a102152301c8..97332d094fe2 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -866,7 +866,7 @@ static ssize_t driver_override_store(struct device *dev,
 				     const char *buf, size_t count)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	char *driver_override, *old = pdev->driver_override, *cp;
+	char *driver_override, *old, *cp;
 
 	if (count > PATH_MAX)
 		return -EINVAL;
@@ -879,12 +879,15 @@ static ssize_t driver_override_store(struct device *dev,
 	if (cp)
 		*cp = '\0';
 
+	device_lock(dev);
+	old = pdev->driver_override;
 	if (strlen(driver_override)) {
 		pdev->driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev->driver_override = NULL;
 	}
+	device_unlock(dev);
 
 	kfree(old);
 
@@ -895,8 +898,12 @@ static ssize_t driver_override_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	ssize_t len;
 
-	return sprintf(buf, "%s\n", pdev->driver_override);
+	device_lock(dev);
+	len = sprintf(buf, "%s\n", pdev->driver_override);
+	device_unlock(dev);
+	return len;
 }
 static DEVICE_ATTR_RW(driver_override);
 

commit 0634c2958927198797bf9e55d26fb51cce4c22b4
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 22 09:16:27 2017 -0500

    of: Add function for generating a DT modalias with a newline
    
    The modalias sysfs attr is lacking a newline for DT aliases on platform
    devices. The macio and ibmebus correctly add the newline, but open code it.
    Introduce a new function, of_device_modalias(), that fills the buffer with
    the modalias including the newline and update users of the old
    of_device_get_modalias function.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c2456839214a..a102152301c8 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -847,7 +847,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 	struct platform_device	*pdev = to_platform_device(dev);
 	int len;
 
-	len = of_device_get_modalias(dev, buf, PAGE_SIZE -1);
+	len = of_device_modalias(dev, buf, PAGE_SIZE);
 	if (len != -ENODEV)
 		return len;
 

commit b2064617c74f301dab1448f1f9c8dbb3c8021058
Merge: e30aee9e10bb 17627157cda1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 22 11:44:32 2017 -0800

    Merge tag 'driver-core-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the "small" driver core patches for 4.11-rc1.
    
      Not much here, some firmware documentation and self-test updates, a
      debugfs code formatting issue, and a new feature for call_usermodehelper
      to make it more robust on systems that want to lock it down in a more
      secure way.
    
      All of these have been linux-next for a while now with no reported
      issues"
    
    * tag 'driver-core-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:
      kernfs: handle null pointers while printing node name and path
      Introduce STATIC_USERMODEHELPER to mediate call_usermodehelper()
      Make static usermode helper binaries constant
      kmod: make usermodehelper path a const string
      firmware: revamp firmware documentation
      selftests: firmware: send expected errors to /dev/null
      selftests: firmware: only modprobe if driver is missing
      platform: Print the resource range if device failed to claim
      kref: prefer atomic_inc_not_zero to atomic_add_unless
      debugfs: improve formatting of debugfs_real_fops()

commit d44fa3d46079dc095c1346fa6e5bc96dca1ead41
Author: Agustin Vega-Frias <agustinv@codeaurora.org>
Date:   Thu Feb 2 18:23:58 2017 -0500

    ACPI: Add support for ResourceSource/IRQ domain mapping
    
    ACPI extended IRQ resources may contain a ResourceSource to specify
    an alternate interrupt controller. Introduce acpi_irq_get and use it
    to implement ResourceSource/IRQ domain mapping.
    
    The new API is similar to of_irq_get and allows re-initialization
    of a platform resource from the ACPI extended IRQ resource, and
    provides proper behavior for probe deferral when the domain is not
    yet present when called.
    
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Agustin Vega-Frias <agustinv@codeaurora.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c4af00385502..647e4761dbf3 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -102,6 +102,16 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 	}
 
 	r = platform_get_resource(dev, IORESOURCE_IRQ, num);
+	if (has_acpi_companion(&dev->dev)) {
+		if (r && r->flags & IORESOURCE_DISABLED) {
+			int ret;
+
+			ret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);
+			if (ret)
+				return ret;
+		}
+	}
+
 	/*
 	 * The resources may pass trigger flags to the irqs that need
 	 * to be set up. It so happens that the trigger flags for

commit 8a18f4284ec94ec56189e7f14495359d3b892a52
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Wed Dec 21 17:24:55 2016 +0800

    platform: Print the resource range if device failed to claim
    
    Sometimes we have the following error message:
     platform MSFT0101:00: failed to claim resource 1
     acpi MSFT0101:00: platform device creation failed: -16
    But there is not enough information to figure out which resource range
    failed to claim.
    
    Thus print the resource range at first-place thus /proc/iomem or
    ioports should tell us who already claimed this resource, then
    the driver bug or incorrect resource assignment which is running
    into this conflict can be diagnosed:
     platform MSFT0101:00: failed to claim resource 1: [mem 0xfed40000-0xfed40fff]
     acpi MSFT0101:00: platform device creation failed: -16
    
    Suggested-by: Len Brown <lenb@kernel.org>
    Reported-by: Wendy Wang <wendy.wang@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c4af00385502..22a6430aadc3 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -396,7 +396,7 @@ int platform_device_add(struct platform_device *pdev)
 		}
 
 		if (p && insert_resource(p, r)) {
-			dev_err(&pdev->dev, "failed to claim resource %d\n", i);
+			dev_err(&pdev->dev, "failed to claim resource %d: %pR\n", i, r);
 			ret = -EBUSY;
 			goto failed;
 		}

commit 60ca5e0d280b1a51df55c5fc2e5bfe010b344c5a
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Sep 13 20:32:44 2016 -0700

    driver-core: platform: Catch errors from calls to irq_get_irq_data
    
    irq_get_irq_data() can return NULL, which results in a nasty crash.
    Check its return value before passing it on to irqd_set_trigger_type().
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 44c9d4daf510..c4af00385502 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -108,9 +108,14 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 	 * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*
 	 * settings.
 	 */
-	if (r && r->flags & IORESOURCE_BITS)
-		irqd_set_trigger_type(irq_get_irq_data(r->start),
-				      r->flags & IORESOURCE_BITS);
+	if (r && r->flags & IORESOURCE_BITS) {
+		struct irq_data *irqd;
+
+		irqd = irq_get_irq_data(r->start);
+		if (!irqd)
+			return -ENXIO;
+		irqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);
+	}
 
 	return r ? r->start : -ENXIO;
 #endif

commit e330b9a6bb35dc7097a4f02cb1ae7b6f96df92af
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Mon Jul 4 01:04:24 2016 +0300

    platform: don't return 0 from platform_get_irq[_byname]() on error
    
    of_irq_get[_byname]() return 0 iff  irq_create_of_mapping() call fails.
    Returning both  error code and 0 on failure is a sign of a misdesigned API,
    it makes the failure check unnecessarily complex and error prone. We should
    rely  on the platform IRQ resource in this case, not return 0,  especially
    as 0 can be  a valid  IRQ resource too...
    
    Fixes: aff008ad813c ("platform_get_irq: Revert to platform_get_resource if of_irq_get fails")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f57fff3f268b..44c9d4daf510 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -97,7 +97,7 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 		int ret;
 
 		ret = of_irq_get(dev->dev.of_node, num);
-		if (ret >= 0 || ret == -EPROBE_DEFER)
+		if (ret > 0 || ret == -EPROBE_DEFER)
 			return ret;
 	}
 
@@ -175,7 +175,7 @@ int platform_get_irq_byname(struct platform_device *dev, const char *name)
 		int ret;
 
 		ret = of_irq_get_byname(dev->dev.of_node, name);
-		if (ret >= 0 || ret == -EPROBE_DEFER)
+		if (ret > 0 || ret == -EPROBE_DEFER)
 			return ret;
 	}
 

commit c90aab9c96c2a7f7bf3f7a54167dc5c0ba2b178c
Author: Jerome Marchand <jmarchan@redhat.com>
Date:   Mon Jul 25 16:13:32 2016 +0200

    platform driver: fix use-after-free in platform_device_del()
    
    In platform_device_del(), the device is still used after a call to
    device_del(). At this point there is no guarantee that the device is
    still there and there could be a use-after-free access. Move the
    call to device_remove_properties() before device_del() to fix that.
    
    Signed-off-by: Jerome Marchand <jmarchan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 6482d47deb50..f57fff3f268b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -434,6 +434,7 @@ void platform_device_del(struct platform_device *pdev)
 	int i;
 
 	if (pdev) {
+		device_remove_properties(&pdev->dev);
 		device_del(&pdev->dev);
 
 		if (pdev->id_auto) {
@@ -446,8 +447,6 @@ void platform_device_del(struct platform_device *pdev)
 			if (r->parent)
 				release_resource(r);
 		}
-
-		device_remove_properties(&pdev->dev);
 	}
 }
 EXPORT_SYMBOL_GPL(platform_device_del);

commit f4d05266032346531b9f889e26aa31a0cf2a9822
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Mar 29 14:52:23 2016 +0300

    device property: don't bother the drivers with struct property_set
    
    Since device_add_property_set() now always takes a copy of
    the property_set, and also since the fwnode type is always
    hard coded to be FWNODE_PDATA, there is no need for the
    drivers to deliver the entire struct property_set. The
    function can just create the instance of it on its own and
    bind the properties from the drivers to it on the spot.
    
    This renames device_add_property_set() to
    device_add_properties(). The function now takes struct
    property_entry as its parameter instead of struct
    property_set.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f437afa17f2b..6482d47deb50 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -322,16 +322,16 @@ EXPORT_SYMBOL_GPL(platform_device_add_data);
 /**
  * platform_device_add_properties - add built-in properties to a platform device
  * @pdev: platform device to add properties to
- * @pset: properties to add
+ * @properties: null terminated array of properties to add
  *
- * The function will take deep copy of the properties in @pset and attach
- * the copy to the platform device. The memory associated with properties
- * will be freed when the platform device is released.
+ * The function will take deep copy of @properties and attach the copy to the
+ * platform device. The memory associated with properties will be freed when the
+ * platform device is released.
  */
 int platform_device_add_properties(struct platform_device *pdev,
-				   const struct property_set *pset)
+				   struct property_entry *properties)
 {
-	return device_add_property_set(&pdev->dev, pset);
+	return device_add_properties(&pdev->dev, properties);
 }
 EXPORT_SYMBOL_GPL(platform_device_add_properties);
 
@@ -447,7 +447,7 @@ void platform_device_del(struct platform_device *pdev)
 				release_resource(r);
 		}
 
-		device_remove_property_set(&pdev->dev);
+		device_remove_properties(&pdev->dev);
 	}
 }
 EXPORT_SYMBOL_GPL(platform_device_del);
@@ -526,8 +526,9 @@ struct platform_device *platform_device_register_full(
 	if (ret)
 		goto err;
 
-	if (pdevinfo->pset) {
-		ret = platform_device_add_properties(pdev, pdevinfo->pset);
+	if (pdevinfo->properties) {
+		ret = platform_device_add_properties(pdev,
+						     pdevinfo->properties);
 		if (ret)
 			goto err;
 	}

commit 25cad69f21f5532d99e2ee73c8ab6512bcab614c
Author: Martin Wilck <Martin.Wilck@ts.fujitsu.com>
Date:   Mon Nov 30 12:50:05 2015 +0100

    base/platform: Fix platform drivers with no probe callback
    
    Since b8b2c7d845d5, platform_drv_probe() is called for all platform
    devices. If drv->probe is NULL, and dev_pm_domain_attach() fails,
    platform_drv_probe() will return the error code from dev_pm_domain_attach().
    
    This causes real_probe() to enter the "probe_failed" path and set
    dev->driver to NULL. Before b8b2c7d845d5, real_probe() would assume
    success if both dev->bus->probe and drv->probe were missing. As a result,
    a device and driver could be "bound" together just by matching their names;
    this doesn't work any more after b8b2c7d845d5.
    
    This may cause problems later for certain usage of platform_driver_register()
    and platform_device_register_simple(). I observed a panic while loading
    the tpm_tis driver with parameter "force=1" (i.e. registering tpm_tis as
    a platform driver), because tpm_tis_init's assumption that the device
    returned by platform_device_register_simple() was bound didn't hold any more
    (tpmm_chip_alloc() dereferences chip->pdev->driver, causing panic).
    
    This patch restores the previous (4.3.0 and earlier) behavior of
    platform_drv_probe() in the case when the associated platform driver has
    no "probe" function.
    
    Fixes: b8b2c7d845d5 ("base/platform: assert that dev_pm_domain callbacks are called unconditionally")
    Signed-off-by: Martin Wilck <Martin.Wilck@ts.fujitsu.com>
    Cc: stable <stable@vger.kernel.org> # 4.4
    Cc: Martin Fuzzey <mfuzzey@parkeon.com>
    Acked-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 73d6e5d39e33..f437afa17f2b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -558,10 +558,15 @@ static int platform_drv_probe(struct device *_dev)
 		return ret;
 
 	ret = dev_pm_domain_attach(_dev, true);
-	if (ret != -EPROBE_DEFER && drv->probe) {
-		ret = drv->probe(dev);
-		if (ret)
-			dev_pm_domain_detach(_dev, true);
+	if (ret != -EPROBE_DEFER) {
+		if (drv->probe) {
+			ret = drv->probe(dev);
+			if (ret)
+				dev_pm_domain_detach(_dev, true);
+		} else {
+			/* don't fail if just dev_pm_domain_attach failed */
+			ret = 0;
+		}
 	}
 
 	if (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {

commit 6efd3f8cde1d6acc20a715ac6ea17e01421742df
Merge: a72aea722f1b 3ded91041a76
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 21 00:42:59 2016 +0100

    Merge branch 'pm-core'
    
    * pm-core:
      driver core: Avoid NULL pointer dereferences in device_is_bound()
      platform: Do not detach from PM domains on shutdown
      USB / PM: Allow USB devices to remain runtime-suspended when sleeping
      PM / sleep: Go direct_complete if driver has no callbacks
      PM / Domains: add setter for dev.pm_domain
      device core: add device_is_bound()

commit 67990608c8b95d2b8ccc29932376ae73d5818727
Merge: c17488d06666 a889f766dbb7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 12 20:25:09 2016 -0800

    Merge tag 'pm+acpi-4.5-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull oower management and ACPI updates from Rafael Wysocki:
     "As far as the number of commits goes, ACPICA takes the lead this time,
      followed by cpufreq and the device properties framework changes.
    
      The most significant new feature is the debugfs-based interface to the
      ACPICA's AML debugger added in the previous cycle and a new user space
      tool for accessing it.
    
      On the cpufreq front, the core is updated to handle governors more
      efficiently, particularly on systems where a single cpufreq policy
      object is shared between multiple CPUs, and there are quite a few
      changes in drivers (intel_pstate, cpufreq-dt etc).
    
      The device properties framework is updated to handle built-in (ie
      included in the kernel itself) device properties better, among other
      things by adding a fallback mechanism that will allow drivers to
      provide default properties to be used in case the plaform firmware
      doesn't provide the properties expected by them.
    
      The Operating Performance Points (OPP) framework gets new DT bindings
      and debugfs support.
    
      A new cpufreq driver for ST platforms is added and the ACPI driver for
      AMD SoCs will now support the APM X-Gene ACPI I2C device.
    
      The rest is mostly fixes and cleanups all over.
    
      Specifics:
    
       - Add a debugfs-based interface for interacting with the ACPICA's AML
         debugger introduced in the previous cycle and a new user space tool
         for that, fix some bugs related to the AML debugger and clean up
         the code in question (Lv Zheng, Dan Carpenter, Colin Ian King,
         Markus Elfring).
    
       - Update ACPICA to upstream revision 20151218 including a number of
         fixes and cleanups in the ACPICA core (Bob Moore, Lv Zheng, Labbe
         Corentin, Prarit Bhargava, Colin Ian King, David E Box, Rafael
         Wysocki).
    
         In particular, the previously added erroneous support for the _SUB
         object is dropped, the concatenate operator will support all ACPI
         objects now, the Debug Object handling is improved, the SuperName
         handling of parameters being control methods is fixed, the
         ObjectType operator handling is updated to follow ACPI 5.0A and the
         handling of CondRefOf and RefOf is updated accordingly, module-
         level code will be executed after loading each ACPI table now
         (instead of being run once after all tables containing AML have
         been loaded), the Operation Region handlers management is updated
         to fix some reported problems and a the ACPICA code in the kernel
         is more in line with the upstream now.
    
       - Update the ACPI backlight driver to provide information on whether
         or not it will generate key-presses for brightness change hotkeys
         and update some platform drivers (dell-wmi, thinkpad_acpi) to use
         that information to avoid sending double key-events to users pace
         for these, add new ACPI backlight quirks (Hans de Goede, Aaron Lu,
         Adrien Schildknecht).
    
       - Improve the ACPI handling of interrupt GPIOs (Christophe Ricard).
    
       - Fix the handling of the list of device IDs of device objects found
         in the ACPI namespace and add a helper for checking if there is a
         device object for a given device ID (Lukas Wunner).
    
       - Change the logic in the ACPI namespace scanning code to create
         struct acpi_device objects for all ACPI device objects found in the
         namespace even if _STA fails for them which helps to avoid device
         enumeration problems on Microsoft Surface 3 (Aaron Lu).
    
       - Add support for the APM X-Gene ACPI I2C device to the ACPI driver
         for AMD SoCs (Loc Ho).
    
       - Fix the long-standing issue with the DMA controller on Intel SoCs
         where ACPI tables have no power management support for the DMA
         controller itself, but it can be powered off automatically when the
         last (other) device on the SoC is powered off via ACPI and clean up
         the ACPI driver for Intel SoCs (acpi-lpss) after previous attempts
         to fix that problem (Andy Shevchenko).
    
       - Assorted ACPI fixes and cleanups (Andy Lutomirski, Colin Ian King,
         Javier Martinez Canillas, Ken Xue, Mathias Krause, Rafael Wysocki,
         Sinan Kaya).
    
       - Update the device properties framework for better handling of
         built-in properties, add support for built-in properties to the
         platform bus type, update the MFD subsystem's handling of device
         properties and add support for passing default configuration data
         as device properties to the intel-lpss MFD drivers, convert the
         designware I2C driver to use the unified device properties API and
         add a fallback mechanism for using default built-in properties if
         the platform firmware fails to provide the properties as expected
         by drivers (Andy Shevchenko, Mika Westerberg, Heikki Krogerus,
         Andrew Morton).
    
       - Add new Device Tree bindings to the Operating Performance Points
         (OPP) framework and update the exynos4412 DT binding accordingly,
         introduce debugfs support for the OPP framework (Viresh Kumar,
         Bartlomiej Zolnierkiewicz).
    
       - Migrate the mt8173 cpufreq driver to the new OPP bindings (Pi-Cheng
         Chen).
    
       - Update the cpufreq core to make the handling of governors more
         efficient, especially on systems where policy objects are shared
         between multiple CPUs (Viresh Kumar, Rafael Wysocki).
    
       - Fix cpufreq governor handling on configurations with
         CONFIG_HZ_PERIODIC set (Chen Yu).
    
       - Clean up the cpufreq core code related to the boost sysfs knob
         support and update the ACPI cpufreq driver accordingly (Rafael
         Wysocki).
    
       - Add a new cpufreq driver for ST platforms and corresponding Device
         Tree bindings (Lee Jones).
    
       - Update the intel_pstate driver to allow the P-state selection
         algorithm used by it to depend on the CPU ID of the processor it is
         running on, make it use a special P-state selection algorithm (with
         an IO wait time compensation tweak) on Atom CPUs based on the
         Airmont and Silvermont cores so as to reduce their energy
         consumption and improve intel_pstate documentation (Philippe
         Longepe, Srinivas Pandruvada).
    
       - Update the cpufreq-dt driver to support registering cooling devices
         that use the (P * V^2 * f) dynamic power draw formula where V is
         the voltage, f is the frequency and P is a constant coefficient
         provided by Device Tree and update the arm_big_little cpufreq
         driver to use that support (Punit Agrawal).
    
       - Assorted cpufreq driver (cpufreq-dt, qoriq, pcc-cpufreq,
         blackfin-cpufreq) updates (Andrzej Hajda, Hongtao Jia, Jacob
         Tanenbaum, Markus Elfring).
    
       - cpuidle core tweaks related to polling and measured_us calculation
         (Rik van Riel).
    
       - Removal of modularity from a few cpuidle drivers (clps711x, ux500,
         exynos) that cannot be built as modules in practice (Paul
         Gortmaker).
    
       - PM core update to prevent devices from being probed during system
         suspend/resume which is generally problematic and may lead to
         inconsistent behavior (Grygorii Strashko).
    
       - Assorted updates of the PM core and related code (Julia Lawall,
         Manuel Pégourié-Gonnard, Maruthi Bayyavarapu, Rafael Wysocki, Ulf
         Hansson).
    
       - PNP bus type updates (Christophe Le Roy, Heiner Kallweit).
    
       - PCI PM code cleanups (Jarkko Nikula, Julia Lawall).
    
       - cpupower tool updates (Jacob Tanenbaum, Thomas Renninger)"
    
    * tag 'pm+acpi-4.5-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (177 commits)
      PM / clk: don't leave clocks enabled when driver not bound
      i2c: dw: Add APM X-Gene ACPI I2C device support
      ACPI / APD: Add APM X-Gene ACPI I2C device support
      ACPI / LPSS: change 'does not have' to 'has' in comment
      Revert "dmaengine: dw: platform: provide platform data for Intel"
      dmaengine: dw: return immediately from IRQ when DMA isn't in use
      dmaengine: dw: platform: power on device on shutdown
      ACPI / LPSS: override power state for LPSS DMA device
      PM / OPP: Use snprintf() instead of sprintf()
      Documentation: cpufreq: intel_pstate: enhance documentation
      ACPI, PCI, irq: remove redundant check for null string pointer
      ACPI / video: driver must be registered before checking for keypresses
      cpufreq-dt: fix handling regulator_get_voltage() result
      cpufreq: governor: Fix negative idle_time when configured with CONFIG_HZ_PERIODIC
      PM / sleep: Add support for read-only sysfs attributes
      ACPI: Fix white space in a structure definition
      ACPI / SBS: fix inconsistent indenting inside if statement
      PNP: respect PNP_DRIVER_RES_DO_NOT_CHANGE when detaching
      ACPI / PNP: constify device IDs
      ACPI / PCI: Simplify acpi_penalize_isa_irq()
      ...

commit 2d30bb0b3889adf09b342722b2ce596c0763bc93
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 12 00:12:19 2016 +0100

    platform: Do not detach from PM domains on shutdown
    
    Shutdown is carried out when the driver is still bound to the
    device, so it is incorrect to detach it from a PM domain (if any)
    at this point.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reported-and-tested-by: Fabio Estevam <fabio.estevam@nxp.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1dd6d3bf1098..484255c7bc47 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -552,7 +552,6 @@ static void platform_drv_shutdown(struct device *_dev)
 
 	if (drv->shutdown)
 		drv->shutdown(dev);
-	dev_pm_domain_detach(_dev, true);
 }
 
 /**

commit 4b83555d5098e73cf2c5ca7f86c17ca0ba3b968e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jan 6 17:12:47 2016 -0800

    driver-core: platform: Add platform_irq_count()
    
    A recent patch added calls to of_irq_count() in the qcom pinctrl
    drivers and that caused module build failures because
    of_irq_count() is not an exported symbol. We shouldn't export
    of_irq_count() to modules because it's an internal OF API that
    shouldn't be used by drivers. Platform drivers should use
    platform device APIs instead. Therefore, add a platform_irq_count()
    API that mirrors the of_irq_count() API so that platform drivers
    can stay DT agnostic.
    
    Cc: Andy Gross <andy.gross@linaro.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1dd6d3bf1098..73e399466c6e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -116,6 +116,26 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 }
 EXPORT_SYMBOL_GPL(platform_get_irq);
 
+/**
+ * platform_irq_count - Count the number of IRQs a platform device uses
+ * @dev: platform device
+ *
+ * Return: Number of IRQs a platform device uses or EPROBE_DEFER
+ */
+int platform_irq_count(struct platform_device *dev)
+{
+	int ret, nr = 0;
+
+	while ((ret = platform_get_irq(dev, nr)) >= 0)
+		nr++;
+
+	if (ret == -EPROBE_DEFER)
+		return ret;
+
+	return nr;
+}
+EXPORT_SYMBOL_GPL(platform_irq_count);
+
 /**
  * platform_get_resource_byname - get a resource for a device by name
  * @dev: platform device

commit 00bbc1d8e46a92ce7bd80622cf4b09c3b727a741
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Nov 30 17:11:38 2015 +0200

    driver core: platform: Add support for built-in device properties
    
    Make it possible to pass built-in device properties to platform device
    drivers. This is useful if the system does not have any firmware interface
    like Device Tree or ACPI which provides these.
    
    Properties associated with the platform device will be automatically
    released when the corresponding device is removed.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1dd6d3bf1098..d77ed0c946dd 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -26,6 +26,7 @@
 #include <linux/acpi.h>
 #include <linux/clk/clk-conf.h>
 #include <linux/limits.h>
+#include <linux/property.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -298,6 +299,22 @@ int platform_device_add_data(struct platform_device *pdev, const void *data,
 }
 EXPORT_SYMBOL_GPL(platform_device_add_data);
 
+/**
+ * platform_device_add_properties - add built-in properties to a platform device
+ * @pdev: platform device to add properties to
+ * @pset: properties to add
+ *
+ * The function will take deep copy of the properties in @pset and attach
+ * the copy to the platform device. The memory associated with properties
+ * will be freed when the platform device is released.
+ */
+int platform_device_add_properties(struct platform_device *pdev,
+				   const struct property_set *pset)
+{
+	return device_add_property_set(&pdev->dev, pset);
+}
+EXPORT_SYMBOL_GPL(platform_device_add_properties);
+
 /**
  * platform_device_add - add a platform device to device hierarchy
  * @pdev: platform device we're adding
@@ -409,6 +426,8 @@ void platform_device_del(struct platform_device *pdev)
 			if (r->parent)
 				release_resource(r);
 		}
+
+		device_remove_property_set(&pdev->dev);
 	}
 }
 EXPORT_SYMBOL_GPL(platform_device_del);
@@ -487,6 +506,12 @@ struct platform_device *platform_device_register_full(
 	if (ret)
 		goto err;
 
+	if (pdevinfo->pset) {
+		ret = platform_device_add_properties(pdev, pdevinfo->pset);
+		if (ret)
+			goto err;
+	}
+
 	ret = platform_device_add(pdev);
 	if (ret) {
 err:

commit dbe2256ddd8e8420c254c79f4045c41cb5f4bd6b
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Sep 25 17:29:04 2015 +0200

    driver-core: platform: Provide helpers for multi-driver modules
    
    Some modules register several sub-drivers. Provide a helper that makes
    it easy to register and unregister a list of sub-drivers, as well as
    unwind properly on error.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 07cec9ba5e70..1dd6d3bf1098 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -710,6 +710,67 @@ struct platform_device * __init_or_module __platform_create_bundle(
 }
 EXPORT_SYMBOL_GPL(__platform_create_bundle);
 
+/**
+ * __platform_register_drivers - register an array of platform drivers
+ * @drivers: an array of drivers to register
+ * @count: the number of drivers to register
+ * @owner: module owning the drivers
+ *
+ * Registers platform drivers specified by an array. On failure to register a
+ * driver, all previously registered drivers will be unregistered. Callers of
+ * this API should use platform_unregister_drivers() to unregister drivers in
+ * the reverse order.
+ *
+ * Returns: 0 on success or a negative error code on failure.
+ */
+int __platform_register_drivers(struct platform_driver * const *drivers,
+				unsigned int count, struct module *owner)
+{
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < count; i++) {
+		pr_debug("registering platform driver %ps\n", drivers[i]);
+
+		err = __platform_driver_register(drivers[i], owner);
+		if (err < 0) {
+			pr_err("failed to register platform driver %ps: %d\n",
+			       drivers[i], err);
+			goto error;
+		}
+	}
+
+	return 0;
+
+error:
+	while (i--) {
+		pr_debug("unregistering platform driver %ps\n", drivers[i]);
+		platform_driver_unregister(drivers[i]);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(__platform_register_drivers);
+
+/**
+ * platform_unregister_drivers - unregister an array of platform drivers
+ * @drivers: an array of drivers to unregister
+ * @count: the number of drivers to unregister
+ *
+ * Unegisters platform drivers specified by an array. This is typically used
+ * to complement an earlier call to platform_register_drivers(). Drivers are
+ * unregistered in the reverse order in which they were registered.
+ */
+void platform_unregister_drivers(struct platform_driver * const *drivers,
+				 unsigned int count)
+{
+	while (count--) {
+		pr_debug("unregistering platform driver %ps\n", drivers[count]);
+		platform_driver_unregister(drivers[count]);
+	}
+}
+EXPORT_SYMBOL_GPL(platform_unregister_drivers);
+
 /* modalias support enables more hands-off userspace setup:
  * (a) environment variable lets new-style hotplug events work once system is
  *     fully running:  "modprobe $MODALIAS"

commit b8b2c7d845d57f7a4b9f1f941f24728165e27626
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Aug 7 07:19:22 2015 +0200

    base/platform: assert that dev_pm_domain callbacks are called unconditionally
    
    When a platform driver doesn't provide a .remove callback the function
    platform_drv_remove isn't called and so the call to dev_pm_domain_attach
    called at probe time isn't paired by dev_pm_domain_detach at remove
    time.
    
    To fix this (and similar issues if different callbacks are missing) hook
    up the driver callbacks unconditionally and make them aware that the
    platform callbacks might be missing.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f80aaaf9f610..07cec9ba5e70 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -513,7 +513,7 @@ static int platform_drv_probe(struct device *_dev)
 		return ret;
 
 	ret = dev_pm_domain_attach(_dev, true);
-	if (ret != -EPROBE_DEFER) {
+	if (ret != -EPROBE_DEFER && drv->probe) {
 		ret = drv->probe(dev);
 		if (ret)
 			dev_pm_domain_detach(_dev, true);
@@ -536,9 +536,10 @@ static int platform_drv_remove(struct device *_dev)
 {
 	struct platform_driver *drv = to_platform_driver(_dev->driver);
 	struct platform_device *dev = to_platform_device(_dev);
-	int ret;
+	int ret = 0;
 
-	ret = drv->remove(dev);
+	if (drv->remove)
+		ret = drv->remove(dev);
 	dev_pm_domain_detach(_dev, true);
 
 	return ret;
@@ -549,7 +550,8 @@ static void platform_drv_shutdown(struct device *_dev)
 	struct platform_driver *drv = to_platform_driver(_dev->driver);
 	struct platform_device *dev = to_platform_device(_dev);
 
-	drv->shutdown(dev);
+	if (drv->shutdown)
+		drv->shutdown(dev);
 	dev_pm_domain_detach(_dev, true);
 }
 
@@ -563,12 +565,9 @@ int __platform_driver_register(struct platform_driver *drv,
 {
 	drv->driver.owner = owner;
 	drv->driver.bus = &platform_bus_type;
-	if (drv->probe)
-		drv->driver.probe = platform_drv_probe;
-	if (drv->remove)
-		drv->driver.remove = platform_drv_remove;
-	if (drv->shutdown)
-		drv->driver.shutdown = platform_drv_shutdown;
+	drv->driver.probe = platform_drv_probe;
+	drv->driver.remove = platform_drv_remove;
+	drv->driver.shutdown = platform_drv_shutdown;
 
 	return driver_register(&drv->driver);
 }

commit 7f5dcaf1fdf289767a126a0a5cc3ef39b5254b06
Author: Grant Likely <grant.likely@linaro.org>
Date:   Sun Jun 7 15:20:11 2015 +0100

    drivercore: Fix unregistration path of platform devices
    
    The unregister path of platform_device is broken. On registration, it
    will register all resources with either a parent already set, or
    type==IORESOURCE_{IO,MEM}. However, on unregister it will release
    everything with type==IORESOURCE_{IO,MEM}, but ignore the others. There
    are also cases where resources don't get registered in the first place,
    like with devices created by of_platform_populate()*.
    
    Fix the unregister path to be symmetrical with the register path by
    checking the parent pointer instead of the type field to decide which
    resources to unregister. This is safe because the upshot of the
    registration path algorithm is that registered resources have a parent
    pointer, and non-registered resources do not.
    
    * It can be argued that of_platform_populate() should be registering
      it's resources, and they argument has some merit. However, there are
      quite a few platforms that end up broken if we try to do that due to
      overlapping resources in the device tree. Until that is fixed, we need
      to solve the immediate problem.
    
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Cc: Wolfram Sang <wsa@the-dreams.de>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 063f0ab15259..f80aaaf9f610 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -375,9 +375,7 @@ int platform_device_add(struct platform_device *pdev)
 
 	while (--i >= 0) {
 		struct resource *r = &pdev->resource[i];
-		unsigned long type = resource_type(r);
-
-		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
+		if (r->parent)
 			release_resource(r);
 	}
 
@@ -408,9 +406,7 @@ void platform_device_del(struct platform_device *pdev)
 
 		for (i = 0; i < pdev->num_resources; i++) {
 			struct resource *r = &pdev->resource[i];
-			unsigned long type = resource_type(r);
-
-			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
+			if (r->parent)
 				release_resource(r);
 		}
 	}

commit 0e6c861f73ec42ab5c89fda9892f2173c7aaf6cf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jun 10 08:38:29 2015 -0700

    Revert "base/platform: Only insert MEM and IO resources"
    
    This reverts commit 36d4b29260753ad78b1ce4363145332c02519adc as it
    breaks working machines.
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 46a56f694cec..063f0ab15259 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -341,23 +341,19 @@ int platform_device_add(struct platform_device *pdev)
 
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];
-		unsigned long type = resource_type(r);
 
 		if (r->name == NULL)
 			r->name = dev_name(&pdev->dev);
 
-		if (!(type == IORESOURCE_MEM || type == IORESOURCE_IO))
-			continue;
-
 		p = r->parent;
 		if (!p) {
-			if (type == IORESOURCE_MEM)
+			if (resource_type(r) == IORESOURCE_MEM)
 				p = &iomem_resource;
-			else if (type == IORESOURCE_IO)
+			else if (resource_type(r) == IORESOURCE_IO)
 				p = &ioport_resource;
 		}
 
-		if (insert_resource(p, r)) {
+		if (p && insert_resource(p, r)) {
 			dev_err(&pdev->dev, "failed to claim resource %d\n", i);
 			ret = -EBUSY;
 			goto failed;

commit 5da7f70997f772d7605c11d9e00018ffac463d92
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jun 10 08:38:02 2015 -0700

    Revert "base/platform: Continue on insert_resource() error"
    
    This reverts commit e50e69d1ac4232af0b6890f16929bf5ceee81538 as it
    breaks working machines.
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 5a29387e5ff6..46a56f694cec 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -332,7 +332,7 @@ int platform_device_add(struct platform_device *pdev)
 		 */
 		ret = ida_simple_get(&platform_devid_ida, 0, 0, GFP_KERNEL);
 		if (ret < 0)
-			return ret;
+			goto err_out;
 		pdev->id = ret;
 		pdev->id_auto = true;
 		dev_set_name(&pdev->dev, "%s.%d.auto", pdev->name, pdev->id);
@@ -340,7 +340,7 @@ int platform_device_add(struct platform_device *pdev)
 	}
 
 	for (i = 0; i < pdev->num_resources; i++) {
-		struct resource *conflict, *p, *r = &pdev->resource[i];
+		struct resource *p, *r = &pdev->resource[i];
 		unsigned long type = resource_type(r);
 
 		if (r->name == NULL)
@@ -357,14 +357,11 @@ int platform_device_add(struct platform_device *pdev)
 				p = &ioport_resource;
 		}
 
-		conflict = insert_resource_conflict(p, r);
-		if (!conflict)
-			continue;
-
-		dev_err(&pdev->dev,
-			"ignoring resource %pR (conflicts with %s %pR)\n",
-			r, conflict->name, conflict);
-		p->parent = NULL;
+		if (insert_resource(p, r)) {
+			dev_err(&pdev->dev, "failed to claim resource %d\n", i);
+			ret = -EBUSY;
+			goto failed;
+		}
 	}
 
 	pr_debug("Registering platform device '%s'. Parent at %s\n",
@@ -374,7 +371,7 @@ int platform_device_add(struct platform_device *pdev)
 	if (ret == 0)
 		return ret;
 
-	/* Failure path */
+ failed:
 	if (pdev->id_auto) {
 		ida_simple_remove(&platform_devid_ida, pdev->id);
 		pdev->id = PLATFORM_DEVID_AUTO;
@@ -384,11 +381,11 @@ int platform_device_add(struct platform_device *pdev)
 		struct resource *r = &pdev->resource[i];
 		unsigned long type = resource_type(r);
 
-		if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
-				r->parent)
+		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
 			release_resource(r);
 	}
 
+ err_out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(platform_device_add);
@@ -417,8 +414,7 @@ void platform_device_del(struct platform_device *pdev)
 			struct resource *r = &pdev->resource[i];
 			unsigned long type = resource_type(r);
 
-			if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
-					r->parent)
+			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
 				release_resource(r);
 		}
 	}

commit 8b2dcebae330fb6dffc7717b740aa4b2c4d00451
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jun 10 08:36:50 2015 -0700

    Revert "base/platform: Remove code duplication"
    
    This reverts commit 6d9d4b1469b0d9748145e168fc9ec585e1f3f4b0 as it
    breaks working machines.
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index cba8e0e83bfc..5a29387e5ff6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -298,25 +298,6 @@ int platform_device_add_data(struct platform_device *pdev, const void *data,
 }
 EXPORT_SYMBOL_GPL(platform_device_add_data);
 
-static void platform_device_cleanout(struct platform_device *pdev, int n_res)
-{
-	int i;
-
-	if (pdev->id_auto) {
-		ida_simple_remove(&platform_devid_ida, pdev->id);
-		pdev->id = PLATFORM_DEVID_AUTO;
-	}
-
-	for (i = 0; i < n_res; i++) {
-		struct resource *r = &pdev->resource[i];
-		unsigned long type = resource_type(r);
-
-		if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
-				r->parent)
-			release_resource(r);
-	}
-}
-
 /**
  * platform_device_add - add a platform device to device hierarchy
  * @pdev: platform device we're adding
@@ -390,8 +371,23 @@ int platform_device_add(struct platform_device *pdev)
 		 dev_name(&pdev->dev), dev_name(pdev->dev.parent));
 
 	ret = device_add(&pdev->dev);
-	if (ret)
-		platform_device_cleanout(pdev, i);
+	if (ret == 0)
+		return ret;
+
+	/* Failure path */
+	if (pdev->id_auto) {
+		ida_simple_remove(&platform_devid_ida, pdev->id);
+		pdev->id = PLATFORM_DEVID_AUTO;
+	}
+
+	while (--i >= 0) {
+		struct resource *r = &pdev->resource[i];
+		unsigned long type = resource_type(r);
+
+		if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
+				r->parent)
+			release_resource(r);
+	}
 
 	return ret;
 }
@@ -407,11 +403,25 @@ EXPORT_SYMBOL_GPL(platform_device_add);
  */
 void platform_device_del(struct platform_device *pdev)
 {
-	if (!pdev)
-		return;
+	int i;
+
+	if (pdev) {
+		device_del(&pdev->dev);
 
-	device_del(&pdev->dev);
-	platform_device_cleanout(pdev, pdev->num_resources);
+		if (pdev->id_auto) {
+			ida_simple_remove(&platform_devid_ida, pdev->id);
+			pdev->id = PLATFORM_DEVID_AUTO;
+		}
+
+		for (i = 0; i < pdev->num_resources; i++) {
+			struct resource *r = &pdev->resource[i];
+			unsigned long type = resource_type(r);
+
+			if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
+					r->parent)
+				release_resource(r);
+		}
+	}
 }
 EXPORT_SYMBOL_GPL(platform_device_del);
 

commit 6d9d4b1469b0d9748145e168fc9ec585e1f3f4b0
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue May 26 09:31:26 2015 +0200

    base/platform: Remove code duplication
    
    Failure path of platform_device_add was almost the same as
    platform_device_del. Refactor same code in a function.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 5a29387e5ff6..cba8e0e83bfc 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -298,6 +298,25 @@ int platform_device_add_data(struct platform_device *pdev, const void *data,
 }
 EXPORT_SYMBOL_GPL(platform_device_add_data);
 
+static void platform_device_cleanout(struct platform_device *pdev, int n_res)
+{
+	int i;
+
+	if (pdev->id_auto) {
+		ida_simple_remove(&platform_devid_ida, pdev->id);
+		pdev->id = PLATFORM_DEVID_AUTO;
+	}
+
+	for (i = 0; i < n_res; i++) {
+		struct resource *r = &pdev->resource[i];
+		unsigned long type = resource_type(r);
+
+		if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
+				r->parent)
+			release_resource(r);
+	}
+}
+
 /**
  * platform_device_add - add a platform device to device hierarchy
  * @pdev: platform device we're adding
@@ -371,23 +390,8 @@ int platform_device_add(struct platform_device *pdev)
 		 dev_name(&pdev->dev), dev_name(pdev->dev.parent));
 
 	ret = device_add(&pdev->dev);
-	if (ret == 0)
-		return ret;
-
-	/* Failure path */
-	if (pdev->id_auto) {
-		ida_simple_remove(&platform_devid_ida, pdev->id);
-		pdev->id = PLATFORM_DEVID_AUTO;
-	}
-
-	while (--i >= 0) {
-		struct resource *r = &pdev->resource[i];
-		unsigned long type = resource_type(r);
-
-		if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
-				r->parent)
-			release_resource(r);
-	}
+	if (ret)
+		platform_device_cleanout(pdev, i);
 
 	return ret;
 }
@@ -403,25 +407,11 @@ EXPORT_SYMBOL_GPL(platform_device_add);
  */
 void platform_device_del(struct platform_device *pdev)
 {
-	int i;
-
-	if (pdev) {
-		device_del(&pdev->dev);
-
-		if (pdev->id_auto) {
-			ida_simple_remove(&platform_devid_ida, pdev->id);
-			pdev->id = PLATFORM_DEVID_AUTO;
-		}
-
-		for (i = 0; i < pdev->num_resources; i++) {
-			struct resource *r = &pdev->resource[i];
-			unsigned long type = resource_type(r);
+	if (!pdev)
+		return;
 
-			if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
-					r->parent)
-				release_resource(r);
-		}
-	}
+	device_del(&pdev->dev);
+	platform_device_cleanout(pdev, pdev->num_resources);
 }
 EXPORT_SYMBOL_GPL(platform_device_del);
 

commit e50e69d1ac4232af0b6890f16929bf5ceee81538
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue May 26 09:31:24 2015 +0200

    base/platform: Continue on insert_resource() error
    
    insert_resource() can fail when the resource added  overlaps
    (partially or fully) with another.
    
    Device tree and AMBA devices may contain resources that overlap, so they
    could not call platform_device_add (see 02bbde7849e6 ('Revert "of:
    use platform_device_add"'))"
    
    On the other hand, device trees are released using
    platform_device_unregister(). This function calls platform_device_del(),
    which calls release_resource(), that crashes when the resource has not
    been added with with insert_resource. This was not an issue when the
    device tree could not be modified online, but this is not the case
    anymore.
    
    This patch let the flow continue when there is an insert error, after
    notifying the user with a dev_err(). r->parent is set to NULL, so
    platform_device_del() knows that the resource was not added, and
    therefore it should not be released.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 46a56f694cec..5a29387e5ff6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -332,7 +332,7 @@ int platform_device_add(struct platform_device *pdev)
 		 */
 		ret = ida_simple_get(&platform_devid_ida, 0, 0, GFP_KERNEL);
 		if (ret < 0)
-			goto err_out;
+			return ret;
 		pdev->id = ret;
 		pdev->id_auto = true;
 		dev_set_name(&pdev->dev, "%s.%d.auto", pdev->name, pdev->id);
@@ -340,7 +340,7 @@ int platform_device_add(struct platform_device *pdev)
 	}
 
 	for (i = 0; i < pdev->num_resources; i++) {
-		struct resource *p, *r = &pdev->resource[i];
+		struct resource *conflict, *p, *r = &pdev->resource[i];
 		unsigned long type = resource_type(r);
 
 		if (r->name == NULL)
@@ -357,11 +357,14 @@ int platform_device_add(struct platform_device *pdev)
 				p = &ioport_resource;
 		}
 
-		if (insert_resource(p, r)) {
-			dev_err(&pdev->dev, "failed to claim resource %d\n", i);
-			ret = -EBUSY;
-			goto failed;
-		}
+		conflict = insert_resource_conflict(p, r);
+		if (!conflict)
+			continue;
+
+		dev_err(&pdev->dev,
+			"ignoring resource %pR (conflicts with %s %pR)\n",
+			r, conflict->name, conflict);
+		p->parent = NULL;
 	}
 
 	pr_debug("Registering platform device '%s'. Parent at %s\n",
@@ -371,7 +374,7 @@ int platform_device_add(struct platform_device *pdev)
 	if (ret == 0)
 		return ret;
 
- failed:
+	/* Failure path */
 	if (pdev->id_auto) {
 		ida_simple_remove(&platform_devid_ida, pdev->id);
 		pdev->id = PLATFORM_DEVID_AUTO;
@@ -381,11 +384,11 @@ int platform_device_add(struct platform_device *pdev)
 		struct resource *r = &pdev->resource[i];
 		unsigned long type = resource_type(r);
 
-		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
+		if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
+				r->parent)
 			release_resource(r);
 	}
 
- err_out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(platform_device_add);
@@ -414,7 +417,8 @@ void platform_device_del(struct platform_device *pdev)
 			struct resource *r = &pdev->resource[i];
 			unsigned long type = resource_type(r);
 
-			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
+			if ((type == IORESOURCE_MEM || type == IORESOURCE_IO) &&
+					r->parent)
 				release_resource(r);
 		}
 	}

commit 36d4b29260753ad78b1ce4363145332c02519adc
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue May 26 09:31:23 2015 +0200

    base/platform: Only insert MEM and IO resources
    
    platform_device_del only checks the type of the resource in order to
    call release_resource.
    
    On the other hand, platform_device_add calls insert_resource for any
    resource that has a parent.
    
    Make both code branches balanced.
    
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 063f0ab15259..46a56f694cec 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -341,19 +341,23 @@ int platform_device_add(struct platform_device *pdev)
 
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];
+		unsigned long type = resource_type(r);
 
 		if (r->name == NULL)
 			r->name = dev_name(&pdev->dev);
 
+		if (!(type == IORESOURCE_MEM || type == IORESOURCE_IO))
+			continue;
+
 		p = r->parent;
 		if (!p) {
-			if (resource_type(r) == IORESOURCE_MEM)
+			if (type == IORESOURCE_MEM)
 				p = &iomem_resource;
-			else if (resource_type(r) == IORESOURCE_IO)
+			else if (type == IORESOURCE_IO)
 				p = &ioport_resource;
 		}
 
-		if (p && insert_resource(p, r)) {
+		if (insert_resource(p, r)) {
 			dev_err(&pdev->dev, "failed to claim resource %d\n", i);
 			ret = -EBUSY;
 			goto failed;

commit 5c36eb2a9ecc0bc5228451b1eeb83e70b6bb7473
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Mar 30 16:20:07 2015 -0700

    driver-core: platform_driver_probe() must probe synchronously
    
    Because platform_driver_probe() checks, after trying to register driver,
    if there are any devices that driver successfully bound to, driver's
    probe routine must be run synchronously.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ebf034b97278..063f0ab15259 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -613,6 +613,19 @@ int __init_or_module __platform_driver_probe(struct platform_driver *drv,
 {
 	int retval, code;
 
+	if (drv->driver.probe_type == PROBE_PREFER_ASYNCHRONOUS) {
+		pr_err("%s: drivers registered with %s can not be probed asynchronously\n",
+			 drv->driver.name, __func__);
+		return -EINVAL;
+	}
+
+	/*
+	 * We have to run our probes synchronously because we check if
+	 * we find any devices to bind to and exit with error if there
+	 * are any.
+	 */
+	drv->driver.probe_type = PROBE_FORCE_SYNCHRONOUS;
+
 	/*
 	 * Prevent driver from requesting probe deferral to avoid further
 	 * futile probe attempts.

commit 2481bc75283ea10e75d5fb1a8b42af363fc4b45c
Merge: 8691c130fae1 518b4e272d99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 20:21:54 2015 -0700

    Merge tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups all over, although there are a few
      items that sort of fall into the new feature category.
    
      First off, we have new callbacks for PM domains that should help us to
      handle some issues related to device initialization in a better way.
    
      There also is some consolidation in the unified device properties API
      area allowing us to use that inferface for accessing data coming from
      platform initialization code in addition to firmware-provided data.
    
      We have some new device/CPU IDs in a few drivers, support for new
      chips and a new cpufreq driver too.
    
      Specifics:
    
       - Generic PM domains support update including new PM domain callbacks
         to handle device initialization better (Russell King, Rafael J
         Wysocki, Kevin Hilman)
    
       - Unified device properties API update including a new mechanism for
         accessing data provided by platform initialization code (Rafael J
         Wysocki, Adrian Hunter)
    
       - ARM cpuidle update including ARM32/ARM64 handling consolidation
         (Daniel Lezcano)
    
       - intel_idle update including support for the Silvermont Core in the
         Baytrail SOC and for the Airmont Core in the Cherrytrail and
         Braswell SOCs (Len Brown, Mathias Krause)
    
       - New cpufreq driver for Hisilicon ACPU (Leo Yan)
    
       - intel_pstate update including support for the Knights Landing chip
         (Dasaratharaman Chandramouli, Kristen Carlson Accardi)
    
       - QorIQ cpufreq driver update (Tang Yuantian, Arnd Bergmann)
    
       - powernv cpufreq driver update (Shilpasri G Bhat)
    
       - devfreq update including Tegra support changes (Tomeu Vizoso,
         MyungJoo Ham, Chanwoo Choi)
    
       - powercap RAPL (Running-Average Power Limit) driver update including
         support for Intel Broadwell server chips (Jacob Pan, Mathias Krause)
    
       - ACPI device enumeration update related to the handling of the
         special PRP0001 device ID allowing DT-style 'compatible' property
         to be used for ACPI device identification (Rafael J Wysocki)
    
       - ACPI EC driver update including limited _DEP support (Lan Tianyu,
         Lv Zheng)
    
       - ACPI backlight driver update including a new mechanism to allow
         native backlight handling to be forced on non-Windows 8 systems and
         a new quirk for Lenovo Ideapad Z570 (Aaron Lu, Hans de Goede)
    
       - New Windows Vista compatibility quirk for Sony VGN-SR19XN (Chen Yu)
    
       - Assorted ACPI fixes and cleanups (Aaron Lu, Martin Kepplinger,
         Masanari Iida, Mika Westerberg, Nan Li, Rafael J Wysocki)
    
       - Fixes related to suspend-to-idle for the iTCO watchdog driver and
         the ACPI core system suspend/resume code (Rafael J Wysocki, Chen Yu)
    
       - PM tracing support for the suspend phase of system suspend/resume
         transitions (Zhonghui Fu)
    
       - Configurable delay for the system suspend/resume testing facility
         (Brian Norris)
    
       - PNP subsystem cleanups (Peter Huewe, Rafael J Wysocki)"
    
    * tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (74 commits)
      ACPI / scan: Fix NULL pointer dereference in acpi_companion_match()
      ACPI / scan: Rework modalias creation when "compatible" is present
      intel_idle: mark cpu id array as __initconst
      powercap / RAPL: mark rapl_ids array as __initconst
      powercap / RAPL: add ID for Broadwell server
      intel_pstate: Knights Landing support
      intel_pstate: remove MSR test
      cpufreq: fix qoriq uniprocessor build
      ACPI / scan: Take the PRP0001 position in the list of IDs into account
      ACPI / scan: Simplify acpi_match_device()
      ACPI / scan: Generalize of_compatible matching
      device property: Introduce firmware node type for platform data
      device property: Make it possible to use secondary firmware nodes
      PM / watchdog: iTCO: stop watchdog during system suspend
      cpufreq: hisilicon: add acpu driver
      ACPI / EC: Call acpi_walk_dep_device_list() after installing EC opregion handler
      cpufreq: powernv: Report cpu frequency throttling
      intel_idle: Add support for the Airmont Core in the Cherrytrail and Braswell SOCs
      intel_idle: Update support for Silvermont Core in Baytrail SOC
      PM / devfreq: tegra: Register governor on module init
      ...

commit 7085a7401ba54e92bbb5aa24d6f428071e18e509
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 18 17:12:18 2015 +0100

    drivers: platform: parse IRQ flags from resources
    
    This fixes a regression from the net subsystem:
    After commit d52fdbb735c36a209f36a628d40ca9185b349ba7
    "smc91x: retrieve IRQ and trigger flags in a modern way"
    a regression would appear on some legacy platforms such
    as the ARM PXA Zylonite that specify IRQ resources like
    this:
    
    static struct resource r = {
           .start  = X,
           .end    = X,
           .flags  = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
    };
    
    The previous code would retrieve the resource and parse
    the high edge setting in the SMC91x driver, a use pattern
    that means every driver specifying an IRQ flag from a
    static resource need to parse resource flags and apply
    them at runtime.
    
    As we switched the code to use IRQ descriptors to retrieve
    the the trigger type like this:
    
      irqd_get_trigger_type(irq_get_irq_data(...));
    
    the code would work for new platforms using e.g. device
    tree as the backing irq descriptor would have its flags
    properly set, whereas this kind of oldstyle static
    resources at no point assign the trigger flags to the
    corresponding IRQ descriptor.
    
    To make the behaviour identical on modern device tree
    and legacy static platform data platforms, modify
    platform_get_irq() to assign the trigger flags to the
    irq descriptor when a client looks up an IRQ from static
    resources.
    
    Fixes: d52fdbb735c3 ("smc91x: retrieve IRQ and trigger flags in a modern way")
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9421fed40905..e68ab79df28b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -101,6 +101,15 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 	}
 
 	r = platform_get_resource(dev, IORESOURCE_IRQ, num);
+	/*
+	 * The resources may pass trigger flags to the irqs that need
+	 * to be set up. It so happens that the trigger flags for
+	 * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*
+	 * settings.
+	 */
+	if (r && r->flags & IORESOURCE_BITS)
+		irqd_set_trigger_type(irq_get_irq_data(r->start),
+				      r->flags & IORESOURCE_BITS);
 
 	return r ? r->start : -ENXIO;
 #endif

commit ce793486e23e0162a732c605189c8028e0910e86
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 16 23:49:03 2015 +0100

    driver core / ACPI: Represent ACPI companions using fwnode_handle
    
    Now that we have struct fwnode_handle, we can use that to point to
    ACPI companions from struct device objects instead of pointing to
    struct acpi_device directly.
    
    There are two benefits from that.  First, the somewhat ugly and
    hackish struct acpi_dev_node can be dropped and, second, the same
    struct fwnode_handle pointer can be used in the future to point
    to other (non-ACPI) firmware device node types.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9421fed40905..17f0204fabef 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -454,7 +454,7 @@ struct platform_device *platform_device_register_full(
 		goto err_alloc;
 
 	pdev->dev.parent = pdevinfo->parent;
-	ACPI_COMPANION_SET(&pdev->dev, pdevinfo->acpi_node.companion);
+	pdev->dev.fwnode = pdevinfo->fwnode;
 
 	if (pdevinfo->dma_mask) {
 		/*

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 801d728c10db4b28e01590b46bf1f0df930760cc
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Tue Oct 28 22:36:01 2014 +0200

    of/reconfig: Add OF_DYNAMIC notifier for platform_bus_type
    
    Add OF notifier handler needed for creating/destroying platform devices
    according to dynamic runtime changes in the DT live tree.
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index b2afc29403f9..233ececd15a3 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1006,6 +1006,7 @@ int __init platform_bus_init(void)
 	error =  bus_register(&platform_bus_type);
 	if (error)
 		device_unregister(&platform_bus);
+	of_platform_register_reconfig_notifier();
 	return error;
 }
 

commit 291f653a140ad880426125e5e9dbb70f4c184683
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Oct 28 17:40:42 2014 +0100

    core: platform: let platform_create_bundle initialize module owner
    
    Since commit 9447057eaff8 ("platform_device: use a macro instead of
    platform_driver_register"), platform_driver_register() always overwrites
    the .owner field of a platform_driver with THIS_MODULE. This breaks
    platform_create_bundle() which uses it via platform_driver_probe() from
    within the platform core instead of the module init. Fix it by using a
    similar #define construct to obtain THIS_MODULE and pass it on later.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c87a63326871..cdb6c076c3f7 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -637,24 +637,25 @@ int __init_or_module __platform_driver_probe(struct platform_driver *drv,
 EXPORT_SYMBOL_GPL(__platform_driver_probe);
 
 /**
- * platform_create_bundle - register driver and create corresponding device
+ * __platform_create_bundle - register driver and create corresponding device
  * @driver: platform driver structure
  * @probe: the driver probe routine, probably from an __init section
  * @res: set of resources that needs to be allocated for the device
  * @n_res: number of resources
  * @data: platform specific data for this platform device
  * @size: size of platform specific data
+ * @module: module which will be the owner of the driver
  *
  * Use this in legacy-style modules that probe hardware directly and
  * register a single platform device and corresponding platform driver.
  *
  * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
-struct platform_device * __init_or_module platform_create_bundle(
+struct platform_device * __init_or_module __platform_create_bundle(
 			struct platform_driver *driver,
 			int (*probe)(struct platform_device *),
 			struct resource *res, unsigned int n_res,
-			const void *data, size_t size)
+			const void *data, size_t size, struct module *module)
 {
 	struct platform_device *pdev;
 	int error;
@@ -677,7 +678,7 @@ struct platform_device * __init_or_module platform_create_bundle(
 	if (error)
 		goto err_pdev_put;
 
-	error = platform_driver_probe(driver, probe);
+	error = __platform_driver_probe(driver, probe, module);
 	if (error)
 		goto err_pdev_del;
 
@@ -690,7 +691,7 @@ struct platform_device * __init_or_module platform_create_bundle(
 err_out:
 	return ERR_PTR(error);
 }
-EXPORT_SYMBOL_GPL(platform_create_bundle);
+EXPORT_SYMBOL_GPL(__platform_create_bundle);
 
 /* modalias support enables more hands-off userspace setup:
  * (a) environment variable lets new-style hotplug events work once system is

commit c3b50dc219e1437e4dcb6a1639b004648dc29faa
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Oct 28 17:40:41 2014 +0100

    core: platform: let platform_driver_probe initialize module owner
    
    Since commit 9447057eaff8 ("platform_device: use a macro instead of
    platform_driver_register"), platform_driver_register() always overwrites
    the .owner field of a platform_driver with THIS_MODULE. This breaks
    platform_driver_probe() which uses it from within the platform core
    instead of the module init. Fix it by using a similar #define construct
    to obtain THIS_MODULE and pass it on later.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index b2afc29403f9..c87a63326871 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -580,9 +580,10 @@ void platform_driver_unregister(struct platform_driver *drv)
 EXPORT_SYMBOL_GPL(platform_driver_unregister);
 
 /**
- * platform_driver_probe - register driver for non-hotpluggable device
+ * __platform_driver_probe - register driver for non-hotpluggable device
  * @drv: platform driver structure
  * @probe: the driver probe routine, probably from an __init section
+ * @module: module which will be the owner of the driver
  *
  * Use this instead of platform_driver_register() when you know the device
  * is not hotpluggable and has already been registered, and you want to
@@ -598,8 +599,8 @@ EXPORT_SYMBOL_GPL(platform_driver_unregister);
  * Returns zero if the driver registered and bound to a device, else returns
  * a negative error code and with the driver not registered.
  */
-int __init_or_module platform_driver_probe(struct platform_driver *drv,
-		int (*probe)(struct platform_device *))
+int __init_or_module __platform_driver_probe(struct platform_driver *drv,
+		int (*probe)(struct platform_device *), struct module *module)
 {
 	int retval, code;
 
@@ -614,7 +615,7 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 
 	/* temporary section violation during probe() */
 	drv->probe = probe;
-	retval = code = platform_driver_register(drv);
+	retval = code = __platform_driver_register(drv, module);
 
 	/*
 	 * Fixup that section violation, being paranoid about code scanning
@@ -633,7 +634,7 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 		platform_driver_unregister(drv);
 	return retval;
 }
-EXPORT_SYMBOL_GPL(platform_driver_probe);
+EXPORT_SYMBOL_GPL(__platform_driver_probe);
 
 /**
  * platform_create_bundle - register driver and create corresponding device

commit f48c767ce8951e30eb716b8ef69142d21aacbd1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 29 13:58:47 2014 +0200

    PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
    
    The commit 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM
    domain for a device) started using errno values in pm.h header file.
    It also failed to include the header for these, thus it caused
    compiler errors.
    
    Instead of including the errno header to pm.h, let's move the functions
    to pm_domain.h, since it's a better match.
    
    Fixes: 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM domain for a device)
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 904be3dc0908..b2afc29403f9 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -21,6 +21,7 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
 #include <linux/idr.h>
 #include <linux/acpi.h>
 #include <linux/clk/clk-conf.h>

commit cb51841397e8e5714cf82a7f91053f6e1fb80d1f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:38 2014 +0200

    drivercore / platform: Convert to dev_pm_domain_attach|detach()
    
    Previously only the ACPI PM domain was supported by the platform bus.
    
    Let's convert to the common attach/detach functions for PM domains,
    which currently means we are extending the support to include the
    generic PM domain as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ab4f4ce02722..904be3dc0908 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -506,11 +506,12 @@ static int platform_drv_probe(struct device *_dev)
 	if (ret < 0)
 		return ret;
 
-	acpi_dev_pm_attach(_dev, true);
-
-	ret = drv->probe(dev);
-	if (ret)
-		acpi_dev_pm_detach(_dev, true);
+	ret = dev_pm_domain_attach(_dev, true);
+	if (ret != -EPROBE_DEFER) {
+		ret = drv->probe(dev);
+		if (ret)
+			dev_pm_domain_detach(_dev, true);
+	}
 
 	if (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {
 		dev_warn(_dev, "probe deferral not supported\n");
@@ -532,7 +533,7 @@ static int platform_drv_remove(struct device *_dev)
 	int ret;
 
 	ret = drv->remove(dev);
-	acpi_dev_pm_detach(_dev, true);
+	dev_pm_domain_detach(_dev, true);
 
 	return ret;
 }
@@ -543,7 +544,7 @@ static void platform_drv_shutdown(struct device *_dev)
 	struct platform_device *dev = to_platform_device(_dev);
 
 	drv->shutdown(dev);
-	acpi_dev_pm_detach(_dev, true);
+	dev_pm_domain_detach(_dev, true);
 }
 
 /**

commit 29b88e23a9212136d39b0161a39afe587d0170a5
Merge: 2521129a6d2f 4e3a25b0274b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 4 18:34:04 2014 -0700

    Merge tag 'driver-core-3.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here's the big driver-core pull request for 3.17-rc1.
    
      Largest thing in here is the dma-buf rework and fence code, that
      touched many different subsystems so it was agreed it should go
      through this tree to handle merge issues.  There's also some firmware
      loading updates, as well as tests added, and a few other tiny changes,
      the changelog has the details.
    
      All have been in linux-next for a long time"
    
    * tag 'driver-core-3.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (32 commits)
      ARM: imx: Remove references to platform_bus in mxc code
      firmware loader: Fix _request_firmware_load() return val for fw load abort
      platform: Remove most references to platform_bus device
      test: add firmware_class loader test
      doc: fix minor typos in firmware_class README
      staging: android: Cleanup style issues
      Documentation: devres: Sort managed interfaces
      Documentation: devres: Add devm_kmalloc() et al
      fs: debugfs: remove trailing whitespace
      kernfs: kernel-doc warning fix
      debugfs: Fix corrupted loop in debugfs_remove_recursive
      stable_kernel_rules: Add pointer to netdev-FAQ for network patches
      driver core: platform: add device binding path 'driver_override'
      driver core/platform: remove unused implicit padding in platform_object
      firmware loader: inform direct failure when udev loader is disabled
      firmware: replace ALIGN(PAGE_SIZE) by PAGE_ALIGN
      firmware: read firmware size using i_size_read()
      firmware loader: allow disabling of udev as firmware loader
      reservation: add suppport for read-only access using rcu
      reservation: update api and add some helpers
      ...
    
    Conflicts:
            drivers/base/platform.c

commit e4ca4308c055c7bfb82f6756297346760d697953
Merge: e17acfdc83b8 b11a6face1b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 4 11:44:20 2014 -0700

    Merge tag 'clk-for-linus-3.17' of git://git.linaro.org/people/mike.turquette/linux
    
    Pull clock framework updates from Mike Turquette:
     "The clock framework changes for 3.17 are mostly additions of new clock
      drivers and fixes/enhancements to existing clock drivers.  There are
      also some non-critical fixes and improvements to the framework core.
    
      Changes to the clock framework core include:
       - improvements to printks on errors
       - flattening the previously hierarchal structure of per-clock entries
         in debugfs
       - allow per-clock debugfs entries that are specific to a particular
         clock driver
       - configure initial clock parent and/or initial clock rate from
         Device Tree
       - several feature enhancements to the composite clock type
       - misc fixes
    
      New clock drivers added include:
       - TI Palmas PMIC
       - Allwinner A23 SoC
       - Qualcomm APQ8084 and IPQ8064 SoCs
       - Rockchip rk3188, rk3066 and rk3288 SoCs
       - STMicroelectronics STiH407 SoC
       - Cirrus Logic CLPS711X SoC
    
      Many fixes, feature enhancements and further clock tree support for
      existing clock drivers also were merged, such as Samsung's "ARMCLK
      down" power saving feature for their Exynos4 & Exynos5 SoCs"
    
    * tag 'clk-for-linus-3.17' of git://git.linaro.org/people/mike.turquette/linux: (86 commits)
      clk: Add missing of_clk_set_defaults export
      clk: checking wrong variable in __set_clk_parents()
      clk: Propagate any error return from debug_init()
      clk: clps711x: Add DT bindings documentation
      clk: Add CLPS711X clk driver
      clk: st: Use round to closest divider flag
      clk: st: Update frequency tables for fs660c32 and fs432c65
      clk: st: STiH407: Support for clockgenA9
      clk: st: STiH407: Support for clockgenD0/D2/D3
      clk: st: STiH407: Support for clockgenC0
      clk: st: Add quadfs reset handling
      clk: st: Add polarity bit indication
      clk: st: STiH407: Support for clockgenA0
      clk: st: STiH407: Support for A9 MUX Clocks
      clk: st: STiH407: Support for Flexgen Clocks
      clk: st: Adds Flexgen clock binding
      clk: st: Remove uncessary (void *) cast
      clk: st: use static const for clkgen_pll_data tables
      clk: st: use static const for stm_fs tables
      clk: st: Update ST clock binding documentation
      ...

commit 86be408bfbd846fab3c4ac21d6f9298bd2e4b790
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Wed Jun 18 17:29:32 2014 +0200

    clk: Support for clock parents and rates assigned from device tree
    
    This patch adds helper functions to configure clock parents and rates
    as specified through 'assigned-clock-parents', 'assigned-clock-rates'
    DT properties for a clock provider or clock consumer device.
    The helpers are now being called by the bus code for the platform, I2C
    and SPI busses, before the driver probing and also in the clock core
    after registration of a clock provider.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9e9227e1762d..ac47643b1b69 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -23,6 +23,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/idr.h>
 #include <linux/acpi.h>
+#include <linux/clk/clk-conf.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -489,6 +490,10 @@ static int platform_drv_probe(struct device *_dev)
 	struct platform_device *dev = to_platform_device(_dev);
 	int ret;
 
+	ret = of_clk_set_defaults(_dev->of_node, false);
+	if (ret < 0)
+		return ret;
+
 	acpi_dev_pm_attach(_dev, true);
 
 	ret = drv->probe(dev);

commit 90125edbc49ec58b9101c4271bb1d87b04a4620f
Merge: 0a8adf584759 9a3c4145af32
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 21 10:07:25 2014 -0700

    Merge 3.16-rc6 into driver-core-next
    
    We want the platform changes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit aff008ad813c7cf3cfe7b532e7ba2c526c136f22
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Jun 17 15:51:02 2014 -0700

    platform_get_irq: Revert to platform_get_resource if of_irq_get fails
    
    Commits 9ec36ca (of/irq: do irq resolution in platform_get_irq)
    and ad69674 (of/irq: do irq resolution in platform_get_irq_byname)
    change the semantics of platform_get_irq and platform_get_irq_byname
    to always rely on devicetree information if devicetree is enabled
    and if a devicetree node is attached to the device. The functions
    now return an error if the devicetree data does not include interrupt
    information, even if the information is available as platform resource
    data.
    
    This causes mfd client drivers to fail if the interrupt number is
    passed via platform resources. Therefore, if of_irq_get fails, try
    platform_get_resource as method of last resort. This restores the
    original functionality for drivers depending on platform resources
    to get irq information.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9e9227e1762d..eee48c49f5de 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -89,8 +89,13 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 	return dev->archdata.irqs[num];
 #else
 	struct resource *r;
-	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node)
-		return of_irq_get(dev->dev.of_node, num);
+	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {
+		int ret;
+
+		ret = of_irq_get(dev->dev.of_node, num);
+		if (ret >= 0 || ret == -EPROBE_DEFER)
+			return ret;
+	}
 
 	r = platform_get_resource(dev, IORESOURCE_IRQ, num);
 
@@ -133,8 +138,13 @@ int platform_get_irq_byname(struct platform_device *dev, const char *name)
 {
 	struct resource *r;
 
-	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node)
-		return of_irq_get_byname(dev->dev.of_node, name);
+	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {
+		int ret;
+
+		ret = of_irq_get_byname(dev->dev.of_node, name);
+		if (ret >= 0 || ret == -EPROBE_DEFER)
+			return ret;
+	}
 
 	r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);
 	return r ? r->start : -ENXIO;

commit 3d713e0e382e6fcfb4bba1501645b66c129ad60b
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Mon Jun 2 19:42:58 2014 -0500

    driver core: platform: add device binding path 'driver_override'
    
    Needed by platform device drivers, such as the upcoming
    vfio-platform driver, in order to bypass the existing OF, ACPI,
    id_table and name string matches, and successfully be able to be
    bound to any device, like so:
    
    echo vfio-platform > /sys/bus/platform/devices/fff51000.ethernet/driver_override
    echo fff51000.ethernet > /sys/bus/platform/devices/fff51000.ethernet/driver/unbind
    echo fff51000.ethernet > /sys/bus/platform/drivers_probe
    
    This mimics "PCI: Introduce new device binding path using
    pci_dev.driver_override", which is an interface enhancement
    for more deterministic PCI device binding, e.g., when in the
    presence of hotplug.
    
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Reviewed-by: Alexander Graf <agraf@suse.de>
    Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c48c4acb9b87..148f66a1d49a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -23,6 +23,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/idr.h>
 #include <linux/acpi.h>
+#include <linux/limits.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -191,6 +192,7 @@ static void platform_device_release(struct device *dev)
 	kfree(pa->pdev.dev.platform_data);
 	kfree(pa->pdev.mfd_cell);
 	kfree(pa->pdev.resource);
+	kfree(pa->pdev.driver_override);
 	kfree(pa);
 }
 
@@ -698,8 +700,49 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 }
 static DEVICE_ATTR_RO(modalias);
 
+static ssize_t driver_override_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	char *driver_override, *old = pdev->driver_override, *cp;
+
+	if (count > PATH_MAX)
+		return -EINVAL;
+
+	driver_override = kstrndup(buf, count, GFP_KERNEL);
+	if (!driver_override)
+		return -ENOMEM;
+
+	cp = strchr(driver_override, '\n');
+	if (cp)
+		*cp = '\0';
+
+	if (strlen(driver_override)) {
+		pdev->driver_override = driver_override;
+	} else {
+		kfree(driver_override);
+		pdev->driver_override = NULL;
+	}
+
+	kfree(old);
+
+	return count;
+}
+
+static ssize_t driver_override_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return sprintf(buf, "%s\n", pdev->driver_override);
+}
+static DEVICE_ATTR_RW(driver_override);
+
+
 static struct attribute *platform_dev_attrs[] = {
 	&dev_attr_modalias.attr,
+	&dev_attr_driver_override.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(platform_dev);
@@ -755,6 +798,10 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct platform_driver *pdrv = to_platform_driver(drv);
 
+	/* When driver_override is set, only bind to the matching driver */
+	if (pdev->driver_override)
+		return !strcmp(pdev->driver_override, drv->name);
+
 	/* Attempt an OF style match first */
 	if (of_driver_match_device(dev, drv))
 		return 1;

commit 1cec24c59b4a133fc9c83912996168f511075485
Author: Yann Droneaud <ydroneaud@opteya.com>
Date:   Fri May 30 22:02:47 2014 +0200

    driver core/platform: remove unused implicit padding in platform_object
    
    Up to 7 bytes are wasted at the end of struct platform_object
    in the form of padding after name field: unfortunately this
    padding is not used when allocating the memory to hold the
    name.
    
    This patch converts name array from name[1] to C99 flexible
    array name[] (equivalent to name[0]) so that no padding is
    required by the presence of this field. Memory allocation
    is updated to take care of allocating an additional byte for
    the NUL terminating character.
    
    Built on Fedora 20, using GCC 4.8, for ARM, i386, SPARC64 and
    x86_64 architectures, the data structure layout can be reported
    with following command:
    
      $ pahole drivers/base/platform.o \
               --recursive             \
               --class_name device,pdev_archdata,platform_device,platform_object
    
    Please find below some comparisons of structure layout for arm,
    i386, sparc64 and x86_64 architecture before and after the patch.
    
      --- obj-arm/drivers/base/platform.o.pahole.v3.15-rc7-79-gfe45736f4134 2014-05-30 10:32:06.290960701 +0200
      +++ obj-arm/drivers/base/platform.o.pahole.v3.15-rc7-80-g2cdb06858d71 2014-05-30 11:26:20.851988347 +0200
      @@ -81,10 +81,9 @@
         /* XXX last struct has 4 bytes of padding */
    
            /* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
      -     char                       name[1];              /*   392     1 */
      +     char                       name[0];              /*   392     0 */
    
      -     /* size: 400, cachelines: 7, members: 2 */
      -     /* padding: 7 */
      +     /* size: 392, cachelines: 7, members: 2 */
            /* paddings: 1, sum paddings: 4 */
      -     /* last cacheline: 16 bytes */
      +     /* last cacheline: 8 bytes */
       };
    
      --- obj-i386/drivers/base/platform.o.pahole.v3.15-rc7-79-gfe45736f4134 2014-05-30 10:32:06.305960691 +0200
      +++ obj-i386/drivers/base/platform.o.pahole.v3.15-rc7-80-g2cdb06858d71 2014-05-30 11:26:20.875988332 +0200
      @@ -73,9 +73,8 @@
       struct platform_object {
            struct platform_device     pdev;                 /*     0   396 */
            /* --- cacheline 6 boundary (384 bytes) was 12 bytes ago --- */
      -     char                       name[1];              /*   396     1 */
      +     char                       name[0];              /*   396     0 */
    
      -     /* size: 400, cachelines: 7, members: 2 */
      -     /* padding: 3 */
      -     /* last cacheline: 16 bytes */
      +     /* size: 396, cachelines: 7, members: 2 */
      +     /* last cacheline: 12 bytes */
       };
    
      --- obj-sparc64/drivers/base/platform.o.pahole.v3.15-rc7-79-gfe45736f4134 2014-05-30 10:32:06.406960625 +0200
      +++ obj-sparc64/drivers/base/platform.o.pahole.v3.15-rc7-80-g2cdb06858d71 2014-05-30 11:26:20.971988269 +0200
      @@ -94,9 +94,8 @@
       struct platform_object {
            struct platform_device     pdev;                 /*     0  2208 */
            /* --- cacheline 34 boundary (2176 bytes) was 32 bytes ago --- */
      -     char                       name[1];              /*  2208     1 */
      +     char                       name[0];              /*  2208     0 */
    
      -     /* size: 2216, cachelines: 35, members: 2 */
      -     /* padding: 7 */
      -     /* last cacheline: 40 bytes */
      +     /* size: 2208, cachelines: 35, members: 2 */
      +     /* last cacheline: 32 bytes */
       };
    
      --- obj-x86_64/drivers/base/platform.o.pahole.v3.15-rc7-79-gfe45736f4134 2014-05-30 10:32:06.432960608 +0200
      +++ obj-x86_64/drivers/base/platform.o.pahole.v3.15-rc7-80-g2cdb06858d71 2014-05-30 11:26:21.000988250 +0200
      @@ -84,9 +84,8 @@
       struct platform_object {
            struct platform_device     pdev;                 /*     0   720 */
            /* --- cacheline 11 boundary (704 bytes) was 16 bytes ago --- */
      -     char                       name[1];              /*   720     1 */
      +     char                       name[0];              /*   720     0 */
    
      -     /* size: 728, cachelines: 12, members: 2 */
      -     /* padding: 7 */
      -     /* last cacheline: 24 bytes */
      +     /* size: 720, cachelines: 12, members: 2 */
      +     /* last cacheline: 16 bytes */
       };
    
    Changes from v5 [1]:
    - dropped dma_mask allocation changes and only kept padding
      removal changes (name array length set to 0).
    
    Changes from v4 [2]:
    [by Emil Goode <emilgoode@gmail.com>:]
    - Split v4 of the patch into two separate patches.
    - Generated new object file size and data structure layout info.
    - Updated the changelog message.
    
    Changes from v3 [3]:
    - fixed commit message so that git am doesn't fail.
    
    Changes from v2 [4]:
    - move 'dma_mask' to platform_object so that it's always
      allocated and won't leak on release; remove all previously
      added support functions.
    - use C99 flexible array member for 'name' to remove padding
      at the end of platform_object.
    
    Changes from v1 [5]:
    - remove unneeded kfree() from error path
    - add reference to author/commit adding allocation of dmamask
    
    Changes from v0 [6]:
    - small rewrite to squeeze the patch to a bare minimal
    
    [1] http://lkml.kernel.org/r/1401122483-31603-2-git-send-email-emilgoode@gmail.com
        http://lkml.kernel.org/r/1401122483-31603-1-git-send-email-emilgoode@gmail.com
        http://lkml.kernel.org/r/1401122483-31603-3-git-send-email-emilgoode@gmail.com
    
    [2] http://lkml.kernel.org/r/1390817152-30898-1-git-send-email-ydroneaud@opteya.com
        https://patchwork.kernel.org/patch/3541871/
    
    [3] http://lkml.kernel.org/r/1390771138-28348-1-git-send-email-ydroneaud@opteya.com
        https://patchwork.kernel.org/patch/3540081/
    
    [4] http://lkml.kernel.org/r/1389683909-17495-1-git-send-email-ydroneaud@opteya.com
        https://patchwork.kernel.org/patch/3484411/
    
    [5] http://lkml.kernel.org/r/1389649085-7365-1-git-send-email-ydroneaud@opteya.com
        https://patchwork.kernel.org/patch/3480961/
    
    [6] http://lkml.kernel.org/r/1386886207-2735-1-git-send-email-ydroneaud@opteya.com
    
    Cc: Emil Goode <emilgoode@gmail.com>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Shawn Guo <shawn.guo@freescale.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Yann Droneaud <ydroneaud@opteya.com>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9e9227e1762d..c48c4acb9b87 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -165,7 +165,7 @@ EXPORT_SYMBOL_GPL(platform_add_devices);
 
 struct platform_object {
 	struct platform_device pdev;
-	char name[1];
+	char name[];
 };
 
 /**
@@ -206,7 +206,7 @@ struct platform_device *platform_device_alloc(const char *name, int id)
 {
 	struct platform_object *pa;
 
-	pa = kzalloc(sizeof(struct platform_object) + strlen(name), GFP_KERNEL);
+	pa = kzalloc(sizeof(*pa) + strlen(name) + 1, GFP_KERNEL);
 	if (pa) {
 		strcpy(pa->name, name);
 		pa->pdev.name = pa->name;

commit ad69674e73a18dc3a8da557f4059ccf9389531a5
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue May 20 13:42:02 2014 +0300

    of/irq: do irq resolution in platform_get_irq_byname()
    
    The commit 9ec36cafe43bf835f8f29273597a5b0cbc8267ef
    "of/irq: do irq resolution in platform_get_irq" from Rob Herring -
    moves resolving of the interrupt resources in platform_get_irq().
    But this solution isn't complete because platform_get_irq_byname()
    need to be modified the same way.
    
    Hence, fix it by adding interrupt resolution code at the
    platform_get_irq_byname() function too.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 5b47210889e0..9e9227e1762d 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -131,9 +131,12 @@ EXPORT_SYMBOL_GPL(platform_get_resource_byname);
  */
 int platform_get_irq_byname(struct platform_device *dev, const char *name)
 {
-	struct resource *r = platform_get_resource_byname(dev, IORESOURCE_IRQ,
-							  name);
+	struct resource *r;
+
+	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node)
+		return of_irq_get_byname(dev->dev.of_node, name);
 
+	r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);
 	return r ? r->start : -ENXIO;
 }
 EXPORT_SYMBOL_GPL(platform_get_irq_byname);

commit 9ec36cafe43bf835f8f29273597a5b0cbc8267ef
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 23 17:57:41 2014 -0500

    of/irq: do irq resolution in platform_get_irq
    
    Currently we get the following kind of errors if we try to use interrupt
    phandles to irqchips that have not yet initialized:
    
    irq: no irq domain found for /ocp/pinmux@48002030 !
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at drivers/of/platform.c:171 of_device_alloc+0x144/0x184()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.12.0-00038-g42a9708 #1012
    (show_stack+0x14/0x1c)
    (dump_stack+0x6c/0xa0)
    (warn_slowpath_common+0x64/0x84)
    (warn_slowpath_null+0x1c/0x24)
    (of_device_alloc+0x144/0x184)
    (of_platform_device_create_pdata+0x44/0x9c)
    (of_platform_bus_create+0xd0/0x170)
    (of_platform_bus_create+0x12c/0x170)
    (of_platform_populate+0x60/0x98)
    
    This is because we're wrongly trying to populate resources that are not
    yet available. It's perfectly valid to create irqchips dynamically, so
    let's fix up the issue by resolving the interrupt resources when
    platform_get_irq is called.
    
    And then we also need to accept the fact that some irqdomains do not
    exist that early on, and only get initialized later on. So we can
    make the current WARN_ON into just into a pr_debug().
    
    We still attempt to populate irq resources when we create the devices.
    This allows current drivers which don't use platform_get_irq to continue
    to function. Once all drivers are fixed, this code can be removed.
    
    Suggested-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Cc: stable@vger.kernel.org # v3.10+
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index e714709704e4..5b47210889e0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -13,6 +13,7 @@
 #include <linux/string.h>
 #include <linux/platform_device.h>
 #include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
@@ -87,7 +88,11 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 		return -ENXIO;
 	return dev->archdata.irqs[num];
 #else
-	struct resource *r = platform_get_resource(dev, IORESOURCE_IRQ, num);
+	struct resource *r;
+	if (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node)
+		return of_irq_get(dev->dev.of_node, num);
+
+	r = platform_get_resource(dev, IORESOURCE_IRQ, num);
 
 	return r ? r->start : -ENXIO;
 #endif

commit 9383f4c6b66256c039c65ddc141f0caeeae51847
Author: Josh Cartwright <joshc@codeaurora.org>
Date:   Thu Feb 13 22:00:43 2014 -0600

    ACPI / platform: drop redundant ACPI_HANDLE check
    
    The acpi_dev_pm_attach/_detach functions perform their own checks to
    ensure the device has an ACPI companion.  It is not necessary for the
    caller to do so.
    
    This mirrors what other busses with ACPI dev PM support do (i2c, spi,
    sdio).
    
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Josh Cartwright <joshc@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index bc78848dd59a..e714709704e4 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -481,11 +481,10 @@ static int platform_drv_probe(struct device *_dev)
 	struct platform_device *dev = to_platform_device(_dev);
 	int ret;
 
-	if (ACPI_HANDLE(_dev))
-		acpi_dev_pm_attach(_dev, true);
+	acpi_dev_pm_attach(_dev, true);
 
 	ret = drv->probe(dev);
-	if (ret && ACPI_HANDLE(_dev))
+	if (ret)
 		acpi_dev_pm_detach(_dev, true);
 
 	if (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {
@@ -508,8 +507,7 @@ static int platform_drv_remove(struct device *_dev)
 	int ret;
 
 	ret = drv->remove(dev);
-	if (ACPI_HANDLE(_dev))
-		acpi_dev_pm_detach(_dev, true);
+	acpi_dev_pm_detach(_dev, true);
 
 	return ret;
 }
@@ -520,8 +518,7 @@ static void platform_drv_shutdown(struct device *_dev)
 	struct platform_device *dev = to_platform_device(_dev);
 
 	drv->shutdown(dev);
-	if (ACPI_HANDLE(_dev))
-		acpi_dev_pm_detach(_dev, true);
+	acpi_dev_pm_detach(_dev, true);
 }
 
 /**

commit b9f73067f32531db608e469a9ad20ce631e34550
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jan 14 16:46:38 2014 +0800

    platform: introduce OF style 'modalias' support for platform bus
    
    Fix a problem that, the platform bus supports the OF style modalias
    in .uevent() call, but not in its device 'modalias' sysfs attribute.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 2f4aea2428b2..bc78848dd59a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -679,6 +679,10 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 	struct platform_device	*pdev = to_platform_device(dev);
 	int len;
 
+	len = of_device_get_modalias(dev, buf, PAGE_SIZE -1);
+	if (len != -ENODEV)
+		return len;
+
 	len = acpi_device_modalias(dev, buf, PAGE_SIZE -1);
 	if (len != -ENODEV)
 		return len;

commit 8c4ff6d0094a16809a7ecdd49d71cf06b0a51326
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jan 14 16:46:37 2014 +0800

    ACPI: fix module autoloading for ACPI enumerated devices
    
    ACPI enumerated devices has ACPI style _HID and _CID strings,
    all of these strings can be used for both driver loading and matching.
    
    Currently, in Platform, I2C and SPI bus, the ACPI style driver matching
    is supported by invoking acpi_driver_match_device() in bus .match() callback.
    But, the module autoloading is still broken.
    
    For example, there is any ACPI device with _HID "INTABCD" that is
    enumerated to platform bus, and we have a driver that can probe it.
    
    The driver exports its module_alias as "acpi:INTABCD" use the following code
    static const struct acpi_device_id xxx_acpi_match[] = {
            { "INTABCD", 0 },
            { }
    };
    MODULE_DEVICE_TABLE(acpi, xxx_acpi_match);
    
    But, unfortunately, the device' modalias is shown as "platform:INTABCD:00",
    please refer to modalias_show() and platform_uevent() in
    drivers/base/platform.c.
    This results in that the driver will not be loaded automatically when the
    device node is created, because their modalias do not match.
    
    This also applies to I2C and SPI bus.
    
    With this patch, the device' modalias will be shown as "acpi:INTABCD" as well.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 3a94b799f166..2f4aea2428b2 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -677,7 +677,13 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
-	int len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
+	int len;
+
+	len = acpi_device_modalias(dev, buf, PAGE_SIZE -1);
+	if (len != -ENODEV)
+		return len;
+
+	len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -699,6 +705,10 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (rc != -ENODEV)
 		return rc;
 
+	rc = acpi_device_uevent_modalias(dev, env);
+	if (rc != -ENODEV)
+		return rc;
+
 	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
 			pdev->name);
 	return 0;

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 47051cd25113..3a94b799f166 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -432,7 +432,7 @@ struct platform_device *platform_device_register_full(
 		goto err_alloc;
 
 	pdev->dev.parent = pdevinfo->parent;
-	ACPI_HANDLE_SET(&pdev->dev, pdevinfo->acpi_node.handle);
+	ACPI_COMPANION_SET(&pdev->dev, pdevinfo->acpi_node.companion);
 
 	if (pdevinfo->dma_mask) {
 		/*
@@ -463,7 +463,7 @@ struct platform_device *platform_device_register_full(
 	ret = platform_device_add(pdev);
 	if (ret) {
 err:
-		ACPI_HANDLE_SET(&pdev->dev, NULL);
+		ACPI_COMPANION_SET(&pdev->dev, NULL);
 		kfree(pdev->dev.dma_mask);
 
 err_alloc:

commit 3f9120b0424f3e03c75518cb751f9e2bfa73c32a
Author: Johan Hovold <jhovold@gmail.com>
Date:   Mon Sep 23 16:27:26 2013 +0200

    driver core: prevent deferred probe with platform_driver_probe
    
    Prevent drivers relying on platform_driver_probe from requesting
    deferred probing in order to avoid further futile probe attempts (either
    the driver has been unregistered or its probe function has been set to
    platform_drv_probe_fail when probing is retried).
    
    Note that several platform drivers currently return subsystem errors
    from probe and that these can include -EPROBE_DEFER (e.g. if a gpio
    request fails).
    
    Add a warning to platform_drv_probe that can be used to catch drivers
    that inadvertently request probe deferral while using
    platform_driver_probe.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4f8bef3eb5a8..47051cd25113 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -488,6 +488,11 @@ static int platform_drv_probe(struct device *_dev)
 	if (ret && ACPI_HANDLE(_dev))
 		acpi_dev_pm_detach(_dev, true);
 
+	if (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {
+		dev_warn(_dev, "probe deferral not supported\n");
+		ret = -ENXIO;
+	}
+
 	return ret;
 }
 
@@ -553,8 +558,7 @@ EXPORT_SYMBOL_GPL(platform_driver_unregister);
 /**
  * platform_driver_probe - register driver for non-hotpluggable device
  * @drv: platform driver structure
- * @probe: the driver probe routine, probably from an __init section,
- *         must not return -EPROBE_DEFER.
+ * @probe: the driver probe routine, probably from an __init section
  *
  * Use this instead of platform_driver_register() when you know the device
  * is not hotpluggable and has already been registered, and you want to
@@ -565,8 +569,7 @@ EXPORT_SYMBOL_GPL(platform_driver_unregister);
  * into system-on-chip processors, where the controller devices have been
  * configured as part of board setup.
  *
- * This is incompatible with deferred probing so probe() must not
- * return -EPROBE_DEFER.
+ * Note that this is incompatible with deferred probing.
  *
  * Returns zero if the driver registered and bound to a device, else returns
  * a negative error code and with the driver not registered.
@@ -576,6 +579,12 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 {
 	int retval, code;
 
+	/*
+	 * Prevent driver from requesting probe deferral to avoid further
+	 * futile probe attempts.
+	 */
+	drv->prevent_deferred_probe = true;
+
 	/* make sure driver won't have bind/unbind attributes */
 	drv->driver.suppress_bind_attrs = true;
 

commit d06262e58546e5bf5669ef185fb913cca4637bd6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 23 14:24:37 2013 -0700

    driver-core: platform: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the platform bus code to use
    the correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9d538cf9204a..4f8bef3eb5a8 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -672,11 +672,13 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
+static DEVICE_ATTR_RO(modalias);
 
-static struct device_attribute platform_dev_attrs[] = {
-	__ATTR_RO(modalias),
-	__ATTR_NULL,
+static struct attribute *platform_dev_attrs[] = {
+	&dev_attr_modalias.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(platform_dev);
 
 static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
@@ -893,7 +895,7 @@ static const struct dev_pm_ops platform_dev_pm_ops = {
 
 struct bus_type platform_bus_type = {
 	.name		= "platform",
-	.dev_attrs	= platform_dev_attrs,
+	.dev_groups	= platform_dev_groups,
 	.match		= platform_match,
 	.uevent		= platform_uevent,
 	.pm		= &platform_dev_pm_ops,

commit a82579106c79484a5ea0c4c424c8860648c2e389
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Sat Aug 17 20:42:25 2013 +0800

    drivers / platform: Fix __init attribute location
    
    __init belongs after the return type on functions, not before it.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 3c3197a8de41..9d538cf9204a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1054,7 +1054,7 @@ void __init early_platform_driver_register_all(char *class_str)
  * @epdrv: early platform driver structure
  * @id: id to match against
  */
-static  __init struct platform_device *
+static struct platform_device * __init
 early_platform_match(struct early_platform_driver *epdrv, int id)
 {
 	struct platform_device *pd;
@@ -1072,7 +1072,7 @@ early_platform_match(struct early_platform_driver *epdrv, int id)
  * @epdrv: early platform driver structure
  * @id: return true if id or above exists
  */
-static  __init int early_platform_left(struct early_platform_driver *epdrv,
+static int __init early_platform_left(struct early_platform_driver *epdrv,
 				       int id)
 {
 	struct platform_device *pd;

commit 08801f966571b522f0581de0fd400abdf295b16b
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Jul 14 17:43:06 2013 -0700

    driver-core: fix new kernel-doc warning in base/platform.c
    
    Fix new kernel-doc warning in drivers/base/platform.c:
    
    Warning(drivers/base/platform.c:528): No description found for parameter 'owner'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 15789875128e..3c3197a8de41 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -522,6 +522,7 @@ static void platform_drv_shutdown(struct device *_dev)
 /**
  * __platform_driver_register - register a driver for platform-level devices
  * @drv: platform driver structure
+ * @owner: owning module/driver
  */
 int __platform_driver_register(struct platform_driver *drv,
 				struct module *owner)

commit 74b9272bbedf45cb01a048217830d64d59aaa73b
Merge: f5b63ac0f77e 6dd18e4684f3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 4 15:51:45 2013 -0700

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree updates from Grant Likely:
     "This branch contains the following changes:
       - Removal of CONFIG_OF_DEVICE, it is always enabled by CONFIG_OF
       - Remove #ifdef from linux/of_platform.h to increase compiler syntax
         coverage
       - Bug fix for address decoding on Bimini and js2x powerpc platforms.
       - miscellaneous binding changes
    
      One note on the above.  The binding changes going in from all kinds of
      different trees has gotten rather out of hand.  I picked up some
      during this cycle, but even going though my tree isn't a great fit.
    
      Ian Campbell has prototyped splitting the bindings and .dtb files into
      a separate repository.  The plan is to migrate to using that sometime
      in the next few kernel releases which should get rid of a lot of the
      churn on binding docs and .dts files"
    
    * tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux:
      of: Fix address decoding on Bimini and js2x machines
      of: remove CONFIG_OF_DEVICE
      usb: chipidea: depend on CONFIG_OF instead of CONFIG_OF_DEVICE
      of: remove of_platform_driver
      ibmebus: convert of_platform_driver to platform_driver
      driver core: move to_platform_driver to platform_device.h
      mfd: DT bindings for the palmas family MFD
      ARM: dts: omap3-devkit8000: fix NAND memory binding
      of/base: fix typos
      of: remove #ifdef from linux/of_platform.h

commit f991fae5c6d42dfc5029150b05a78cf3f6c18cc9
Merge: d4141531f63a 2c843bd92ec2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 14:35:40 2013 -0700

    Merge tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "This time the total number of ACPI commits is slightly greater than
      the number of cpufreq commits, but Viresh Kumar (who works on cpufreq)
      remains the most active patch submitter.
    
      To me, the most significant change is the addition of offline/online
      device operations to the driver core (with the Greg's blessing) and
      the related modifications of the ACPI core hotplug code.  Next are the
      freezer updates from Colin Cross that should make the freezing of
      tasks a bit less heavy weight.
    
      We also have a couple of regression fixes, a number of fixes for
      issues that have not been identified as regressions, two new drivers
      and a bunch of cleanups all over.
    
      Highlights:
    
       - Hotplug changes to support graceful hot-removal failures.
    
         It sometimes is necessary to fail device hot-removal operations
         gracefully if they cannot be carried out completely.  For example,
         if memory from a memory module being hot-removed has been allocated
         for the kernel's own use and cannot be moved elsewhere, it's
         desirable to fail the hot-removal operation in a graceful way
         rather than to crash the kernel, but currenty a success or a kernel
         crash are the only possible outcomes of an attempted memory
         hot-removal.  Needless to say, that is not a very attractive
         alternative and it had to be addressed.
    
         However, in order to make it work for memory, I first had to make
         it work for CPUs and for this purpose I needed to modify the ACPI
         processor driver.  It's been split into two parts, a resident one
         handling the low-level initialization/cleanup and a modular one
         playing the actual driver's role (but it binds to the CPU system
         device objects rather than to the ACPI device objects representing
         processors).  That's been sort of like a live brain surgery on a
         patient who's riding a bike.
    
         So this is a little scary, but since we found and fixed a couple of
         regressions it caused to happen during the early linux-next testing
         (a month ago), nobody has complained.
    
         As a bonus we remove some duplicated ACPI hotplug code, because the
         ACPI-based CPU hotplug is now going to use the common ACPI hotplug
         code.
    
       - Lighter weight freezing of tasks.
    
         These changes from Colin Cross and Mandeep Singh Baines are
         targeted at making the freezing of tasks a bit less heavy weight
         operation.  They reduce the number of tasks woken up every time
         during the freezing, by using the observation that the freezer
         simply doesn't need to wake up some of them and wait for them all
         to call refrigerator().  The time needed for the freezer to decide
         to report a failure is reduced too.
    
         Also reintroduced is the check causing a lockdep warining to
         trigger when try_to_freeze() is called with locks held (which is
         generally unsafe and shouldn't happen).
    
       - cpufreq updates
    
         First off, a commit from Srivatsa S Bhat fixes a resume regression
         introduced during the 3.10 cycle causing some cpufreq sysfs
         attributes to return wrong values to user space after resume.  The
         fix is kind of fresh, but also it's pretty obvious once Srivatsa
         has identified the root cause.
    
         Second, we have a new freqdomain_cpus sysfs attribute for the
         acpi-cpufreq driver to provide information previously available via
         related_cpus.  From Lan Tianyu.
    
         Finally, we fix a number of issues, mostly related to the
         CPUFREQ_POSTCHANGE notifier and cpufreq Kconfig options and clean
         up some code.  The majority of changes from Viresh Kumar with bits
         from Jacob Shin, Heiko Stübner, Xiaoguang Chen, Ezequiel Garcia,
         Arnd Bergmann, and Tang Yuantian.
    
       - ACPICA update
    
         A usual bunch of updates from the ACPICA upstream.
    
         During the 3.4 cycle we introduced support for ACPI 5 extended
         sleep registers, but they are only supposed to be used if the
         HW-reduced mode bit is set in the FADT flags and the code attempted
         to use them without checking that bit.  That caused suspend/resume
         regressions to happen on some systems.  Fix from Lv Zheng causes
         those registers to be used only if the HW-reduced mode bit is set.
    
         Apart from this some other ACPICA bugs are fixed and code cleanups
         are made by Bob Moore, Tomasz Nowicki, Lv Zheng, Chao Guan, and
         Zhang Rui.
    
       - cpuidle updates
    
         New driver for Xilinx Zynq processors is added by Michal Simek.
    
         Multidriver support simplification, addition of some missing
         kerneldoc comments and Kconfig-related fixes come from Daniel
         Lezcano.
    
       - ACPI power management updates
    
         Changes to make suspend/resume work correctly in Xen guests from
         Konrad Rzeszutek Wilk, sparse warning fix from Fengguang Wu and
         cleanups and fixes of the ACPI device power state selection
         routine.
    
       - ACPI documentation updates
    
         Some previously missing pieces of ACPI documentation are added by
         Lv Zheng and Aaron Lu (hopefully, that will help people to
         uderstand how the ACPI subsystem works) and one outdated doc is
         updated by Hanjun Guo.
    
       - Assorted ACPI updates
    
         We finally nailed down the IA-64 issue that was the reason for
         reverting commit 9f29ab11ddbf ("ACPI / scan: do not match drivers
         against objects having scan handlers"), so we can fix it and move
         the ACPI scan handler check added to the ACPI video driver back to
         the core.
    
         A mechanism for adding CMOS RTC address space handlers is
         introduced by Lan Tianyu to allow some EC-related breakage to be
         fixed on some systems.
    
         A spec-compliant implementation of acpi_os_get_timer() is added by
         Mika Westerberg.
    
         The evaluation of _STA is added to do_acpi_find_child() to avoid
         situations in which a pointer to a disabled device object is
         returned instead of an enabled one with the same _ADR value.  From
         Jeff Wu.
    
         Intel BayTrail PCH (Platform Controller Hub) support is added to
         the ACPI driver for Intel Low-Power Subsystems (LPSS) and that
         driver is modified to work around a couple of known BIOS issues.
         Changes from Mika Westerberg and Heikki Krogerus.
    
         The EC driver is fixed by Vasiliy Kulikov to use get_user() and
         put_user() instead of dereferencing user space pointers blindly.
    
         Code cleanups are made by Bjorn Helgaas, Nicholas Mazzuca and Toshi
         Kani.
    
       - Assorted power management updates
    
         The "runtime idle" helper routine is changed to take the return
         values of the callbacks executed by it into account and to call
         rpm_suspend() if they return 0, which allows us to reduce the
         overall code bloat a bit (by dropping some code that's not
         necessary any more after that modification).
    
         The runtime PM documentation is updated by Alan Stern (to reflect
         the "runtime idle" behavior change).
    
         New trace points for PM QoS are added by Sahara
         (<keun-o.park@windriver.com>).
    
         PM QoS documentation is updated by Lan Tianyu.
    
         Code cleanups are made and minor issues are addressed by Bernie
         Thompson, Bjorn Helgaas, Julius Werner, and Shuah Khan.
    
       - devfreq updates
    
         New driver for the Exynos5-bus device from Abhilash Kesavan.
    
         Minor cleanups, fixes and MAINTAINERS update from MyungJoo Ham,
         Abhilash Kesavan, Paul Bolle, Rajagopal Venkat, and Wei Yongjun.
    
       - OMAP power management updates
    
         Adaptive Voltage Scaling (AVS) SmartReflex voltage control driver
         updates from Andrii Tseglytskyi and Nishanth Menon."
    
    * tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (162 commits)
      cpufreq: Fix cpufreq regression after suspend/resume
      ACPI / PM: Fix possible NULL pointer deref in acpi_pm_device_sleep_state()
      PM / Sleep: Warn about system time after resume with pm_trace
      cpufreq: don't leave stale policy pointer in cdbs->cur_policy
      acpi-cpufreq: Add new sysfs attribute freqdomain_cpus
      cpufreq: make sure frequency transitions are serialized
      ACPI: implement acpi_os_get_timer() according the spec
      ACPI / EC: Add HP Folio 13 to ec_dmi_table in order to skip DSDT scan
      ACPI: Add CMOS RTC Operation Region handler support
      ACPI / processor: Drop unused variable from processor_perflib.c
      cpufreq: tegra: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: s3c64xx: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: omap: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: imx6q: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: exynos: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: dbx500: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: davinci: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: arm-big-little: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: powernow-k8: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: pcc: call CPUFREQ_POSTCHANGE notfier in error cases
      ...

commit 10dbc5e39a60944536f3ca59bc9a8a8896355714
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Sun Apr 21 16:38:31 2013 -0500

    driver core: move to_platform_driver to platform_device.h
    
    In converting the last remaining of_platform_driver (ibmebus) to a regular
    platform driver, to_platform_driver is needed to replace
    to_of_platform_driver.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9eda84246ffd..1bcb2a792e95 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -29,9 +29,6 @@
 /* For automatically allocated device IDs */
 static DEFINE_IDA(platform_devid_ida);
 
-#define to_platform_driver(drv)	(container_of((drv), struct platform_driver, \
-				 driver))
-
 struct device platform_bus = {
 	.init_name	= "platform",
 };

commit 9447057eaff871dd7c63c808de761b8732407169
Author: Libo Chen <clbchenlibo.chen@huawei.com>
Date:   Sat May 25 12:40:50 2013 +0800

    platform_device: use a macro instead of platform_driver_register
    
    I found a lot of mistakes using struct platform_driver without owner
    so I make a macro instead of the function platform_driver_register.
    It can set owner in it, then guys don`t care about module owner again.
    
    Signed-off-by: Libo Chen <libo.chen@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9eda84246ffd..ed75cf6ef9c9 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -523,11 +523,13 @@ static void platform_drv_shutdown(struct device *_dev)
 }
 
 /**
- * platform_driver_register - register a driver for platform-level devices
+ * __platform_driver_register - register a driver for platform-level devices
  * @drv: platform driver structure
  */
-int platform_driver_register(struct platform_driver *drv)
+int __platform_driver_register(struct platform_driver *drv,
+				struct module *owner)
 {
+	drv->driver.owner = owner;
 	drv->driver.bus = &platform_bus_type;
 	if (drv->probe)
 		drv->driver.probe = platform_drv_probe;
@@ -538,7 +540,7 @@ int platform_driver_register(struct platform_driver *drv)
 
 	return driver_register(&drv->driver);
 }
-EXPORT_SYMBOL_GPL(platform_driver_register);
+EXPORT_SYMBOL_GPL(__platform_driver_register);
 
 /**
  * platform_driver_unregister - unregister a driver for platform-level devices

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9eda84246ffd..96a930387ebc 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -888,7 +888,6 @@ int platform_pm_restore(struct device *dev)
 static const struct dev_pm_ops platform_dev_pm_ops = {
 	.runtime_suspend = pm_generic_runtime_suspend,
 	.runtime_resume = pm_generic_runtime_resume,
-	.runtime_idle = pm_generic_runtime_idle,
 	USE_PLATFORM_PM_SLEEP_OPS
 };
 

commit 0258e182e7a8db812817918f1417d31527a5f89b
Author: Fabio Porcedda <fabio.porcedda@gmail.com>
Date:   Tue Mar 26 10:35:16 2013 +0100

    driver core: platform.c: fix checkpatch errors and warnings
    
    Signed-off-by: Fabio Porcedda <fabio.porcedda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ef2afb1e33e6..9eda84246ffd 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -46,8 +46,8 @@ EXPORT_SYMBOL_GPL(platform_bus);
  * manipulate any relevant information in the pdev_archdata they can do:
  *
  *	platform_device_alloc()
- * 	... manipulate ...
- * 	platform_device_add()
+ *	... manipulate ...
+ *	platform_device_add()
  *
  * And if they don't care they can just call platform_device_register() and
  * everything will just work out.
@@ -326,9 +326,7 @@ int platform_device_add(struct platform_device *pdev)
 		}
 
 		if (p && insert_resource(p, r)) {
-			printk(KERN_ERR
-			       "%s: failed to claim resource %d\n",
-			       dev_name(&pdev->dev), i);
+			dev_err(&pdev->dev, "failed to claim resource %d\n", i);
 			ret = -EBUSY;
 			goto failed;
 		}
@@ -686,7 +684,7 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 	int rc;
 
 	/* Some devices have extra OF data and an OF-style MODALIAS */
-	rc = of_device_uevent_modalias(dev,env);
+	rc = of_device_uevent_modalias(dev, env);
 	if (rc != -ENODEV)
 		return rc;
 
@@ -1130,8 +1128,8 @@ static int __init early_platform_driver_probe_id(char *class_str,
 
 		switch (match_id) {
 		case EARLY_PLATFORM_ID_ERROR:
-			pr_warning("%s: unable to parse %s parameter\n",
-				   class_str, epdrv->pdrv->driver.name);
+			pr_warn("%s: unable to parse %s parameter\n",
+				class_str, epdrv->pdrv->driver.name);
 			/* fall-through */
 		case EARLY_PLATFORM_ID_UNSET:
 			match = NULL;
@@ -1162,8 +1160,8 @@ static int __init early_platform_driver_probe_id(char *class_str,
 			}
 
 			if (epdrv->pdrv->probe(match))
-				pr_warning("%s: unable to probe %s early.\n",
-					   class_str, match->name);
+				pr_warn("%s: unable to probe %s early.\n",
+					class_str, match->name);
 			else
 				n++;
 		}

commit 647c86d0a2d1131dd9412361958d8e0aae949523
Author: Fabio Porcedda <fabio.porcedda@gmail.com>
Date:   Tue Mar 26 10:35:15 2013 +0100

    driver core: warn that platform_driver_probe can not use deferred probing
    
    Add documentation that platform_driver_probe() is incompatible with
    deferred probing.
    
    Signed-off-by: Fabio Porcedda <fabio.porcedda@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c0b8df38402b..ef2afb1e33e6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -555,7 +555,8 @@ EXPORT_SYMBOL_GPL(platform_driver_unregister);
 /**
  * platform_driver_probe - register driver for non-hotpluggable device
  * @drv: platform driver structure
- * @probe: the driver probe routine, probably from an __init section
+ * @probe: the driver probe routine, probably from an __init section,
+ *         must not return -EPROBE_DEFER.
  *
  * Use this instead of platform_driver_register() when you know the device
  * is not hotpluggable and has already been registered, and you want to
@@ -566,6 +567,9 @@ EXPORT_SYMBOL_GPL(platform_driver_unregister);
  * into system-on-chip processors, where the controller devices have been
  * configured as part of board setup.
  *
+ * This is incompatible with deferred probing so probe() must not
+ * return -EPROBE_DEFER.
+ *
  * Returns zero if the driver registered and bound to a device, else returns
  * a negative error code and with the driver not registered.
  */

commit cff2f741b8ee8a70b208830e330de053efd4fc45
Merge: b0885d01f9ab 92e9e6d1f984
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 11 13:13:55 2012 -0800

    Merge tag 'driver-core-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg Kroah-Hartman:
     "Here's the large driver core updates for 3.8-rc1.
    
      The biggest thing here is the various __dev* marking removals.  This
      is going to be a pain for the merge with different subsystem trees, I
      know, but all of the patches included here have been ACKed by their
      various subsystem maintainers, as they wanted them to go through here.
    
      If this is too much of a pain, I can pull all of them out of this tree
      and just send you one with the other fixes/updates and then, after
      3.8-rc1 is out, do the rest of the removals to ensure we catch them
      all, it's up to you.  The merges should all be trivial, and Stephen
      has been doing them all in linux-next for a few weeks now quite
      easily.
    
      Other than the __dev* marking removals, there's nothing major here,
      some firmware loading updates and other minor things in the driver
      core.
    
      All of these have (much to Stephen's annoyance), been in linux-next
      for a while.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fixed up trivial conflicts in drivers/gpio/gpio-{em,stmpe}.c due to gpio
    update.
    
    * tag 'driver-core-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (93 commits)
      modpost.c: Stop checking __dev* section mismatches
      init.h: Remove __dev* sections from the kernel
      acpi: remove use of __devinit
      PCI: Remove __dev* markings
      PCI: Always build setup-bus when PCI is enabled
      PCI: Move pci_uevent into pci-driver.c
      PCI: Remove CONFIG_HOTPLUG ifdefs
      unicore32/PCI: Remove CONFIG_HOTPLUG ifdefs
      sh/PCI: Remove CONFIG_HOTPLUG ifdefs
      powerpc/PCI: Remove CONFIG_HOTPLUG ifdefs
      mips/PCI: Remove CONFIG_HOTPLUG ifdefs
      microblaze/PCI: Remove CONFIG_HOTPLUG ifdefs
      dma: remove use of __devinit
      dma: remove use of __devexit_p
      firewire: remove use of __devinitdata
      firewire: remove use of __devinit
      leds: remove use of __devexit
      leds: remove use of __devinit
      leds: remove use of __devexit_p
      mmc: remove use of __devexit
      ...

commit 94d76d5de38d7502c3e78fcd6bf50da95e3e0361
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 26 10:04:53 2012 +0100

    platform / ACPI: Attach/detach ACPI PM during probe/remove/shutdown
    
    Drivers usually expect that the devices they are supposed to handle
    will be operational when their .probe() routines are called, but that
    need not be the case on some ACPI-based systems with ACPI-based
    device enumeration where the BIOSes don't put devices into D0 by
    default.  To work around this problem it is sufficient to change
    bus type .probe() routines to ensure that devices will be powered
    on before the drivers' .probe() routines run (and their .remove()
    and .shutdown() routines accordingly).
    
    Modify platform_drv_probe() to run acpi_dev_pm_attach() for devices
    whose ACPI handles are present, so that ACPI power management is used
    to change their power states.  Analogously, modify
    platform_drv_remove() and platform_drv_shutdown() to call
    acpi_dev_pm_detach() for those devices, so that they are not subject
    to ACPI PM any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 49fd96e23460..b2ee3bcd5a41 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -484,8 +484,16 @@ static int platform_drv_probe(struct device *_dev)
 {
 	struct platform_driver *drv = to_platform_driver(_dev->driver);
 	struct platform_device *dev = to_platform_device(_dev);
+	int ret;
 
-	return drv->probe(dev);
+	if (ACPI_HANDLE(_dev))
+		acpi_dev_pm_attach(_dev, true);
+
+	ret = drv->probe(dev);
+	if (ret && ACPI_HANDLE(_dev))
+		acpi_dev_pm_detach(_dev, true);
+
+	return ret;
 }
 
 static int platform_drv_probe_fail(struct device *_dev)
@@ -497,8 +505,13 @@ static int platform_drv_remove(struct device *_dev)
 {
 	struct platform_driver *drv = to_platform_driver(_dev->driver);
 	struct platform_device *dev = to_platform_device(_dev);
+	int ret;
 
-	return drv->remove(dev);
+	ret = drv->remove(dev);
+	if (ACPI_HANDLE(_dev))
+		acpi_dev_pm_detach(_dev, true);
+
+	return ret;
 }
 
 static void platform_drv_shutdown(struct device *_dev)
@@ -507,6 +520,8 @@ static void platform_drv_shutdown(struct device *_dev)
 	struct platform_device *dev = to_platform_device(_dev);
 
 	drv->shutdown(dev);
+	if (ACPI_HANDLE(_dev))
+		acpi_dev_pm_detach(_dev, true);
 }
 
 /**

commit 863f9f30e6c1e30cb19a0cd17c5cf8879257dfd7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 21 00:21:59 2012 +0100

    ACPI / platform: Initialize ACPI handles of platform devices in advance
    
    The current platform device creation and registration code in
    acpi_create_platform_device() is quite convoluted.  This function
    takes an ACPI device node as an argument and eventually calls
    platform_device_register_resndata() to create and register a
    platform device object on the basis of the information contained
    in that code.  However, it doesn't associate the new platform
    device with the ACPI node directly, but instead it relies on
    acpi_platform_notify(), called from within device_add(), to find
    that ACPI node again with the help of acpi_platform_find_device()
    and acpi_platform_match() and then attach the new platform device
    to it.  This causes an additional ACPI namespace walk to happen and
    is clearly suboptimal.
    
    Use the observation that it is now possible to initialize the ACPI
    handle of a device before calling device_add() for it to make this
    code more straightforward.  Namely, add a new field to struct
    platform_device_info allowing us to pass the ACPI handle of interest
    to platform_device_register_full(), which will then use it to
    initialize the new device's ACPI handle before registering it.
    This will cause acpi_platform_notify() to use the ACPI handle from
    the device structure directly instead of using the .find_device()
    routine provided by the device's bus type.  In consequence,
    acpi_platform_bus, acpi_platform_find_device(), and
    acpi_platform_match() are not necessary any more, so remove them.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 7de29ebfce7f..49fd96e23460 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -437,6 +437,7 @@ struct platform_device *platform_device_register_full(
 		goto err_alloc;
 
 	pdev->dev.parent = pdevinfo->parent;
+	ACPI_HANDLE_SET(&pdev->dev, pdevinfo->acpi_node.handle);
 
 	if (pdevinfo->dma_mask) {
 		/*
@@ -467,6 +468,7 @@ struct platform_device *platform_device_register_full(
 	ret = platform_device_add(pdev);
 	if (ret) {
 err:
+		ACPI_HANDLE_SET(&pdev->dev, NULL);
 		kfree(pdev->dev.dma_mask);
 
 err_alloc:

commit d6ff85513d523551177b1564b62d64c864b97d68
Author: Wolfram Sang <wolfram@the-dreams.de>
Date:   Tue Nov 13 17:47:13 2012 +0100

    driver: platform: fix documentation for platform_get_irq_byname
    
    Probably due to copy&paste, some stuff was simply forgotten.
    
    Signed-off-by: Wolfram Sang <wolfram@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1e8f65420db7..d5e3b45a81f9 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -122,7 +122,7 @@ struct resource *platform_get_resource_byname(struct platform_device *dev,
 EXPORT_SYMBOL_GPL(platform_get_resource_byname);
 
 /**
- * platform_get_irq - get an IRQ for a device
+ * platform_get_irq_byname - get an IRQ for a device by name
  * @dev: platform device
  * @name: IRQ name
  */

commit 91e5687805885f9fceb60b95e950a3d3bdcf4764
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Oct 31 22:45:02 2012 +0100

    ACPI: Add support for platform bus type
    
    With ACPI 5 it is now possible to enumerate traditional SoC
    peripherals, like serial bus controllers and slave devices behind
    them.  These devices are typically based on IP-blocks used in many
    existing SoC platforms and platform drivers for them may already
    be present in the kernel tree.
    
    To make driver "porting" more straightforward, add ACPI support to
    the platform bus type.  Instead of writing ACPI "glue" drivers for
    the existing platform drivers, register the platform bus type with
    ACPI to create platform device objects for the drivers and bind the
    corresponding ACPI handles to those platform devices.
    
    This should allow us to reuse the existing platform drivers for the
    devices in question with the minimum amount of modifications.
    
    This changeset is based on Mika Westerberg's and Mathias Nyman's
    work.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 72c776f2a1f5..7de29ebfce7f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -21,6 +21,7 @@
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
 #include <linux/idr.h>
+#include <linux/acpi.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -709,6 +710,10 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 	if (of_driver_match_device(dev, drv))
 		return 1;
 
+	/* Then try ACPI style match */
+	if (acpi_driver_match_device(dev, drv))
+		return 1;
+
 	/* Then try to match against the id table */
 	if (pdrv->id_table)
 		return platform_match_id(pdrv->id_table, pdev) != NULL;

commit ecdca043ebe8e3172e0400d0966831e2e60870a0
Merge: bb3215e97bb1 77b67063bb6b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 14 15:01:02 2012 -0800

    Merge 3.7-rc5 into driver-core-next

commit 5cf8f7db8274f68b180ad277dbb0308e72b66efd
Author: Andreas Larsson <andreas@gaisler.com>
Date:   Mon Oct 29 23:26:56 2012 +0000

    sparc: Add sparc support for platform_get_irq()
    
    This adds sparc support for platform_get_irq that in the normal case use
    platform_get_resource() to get an irq. This standard approach fails for sparc as
    there are no resources of type IORESOURCE_IRQ for irqs for sparc.
    
    Cross platform drivers can then use this standard platform function and work on
    sparc instead of having to have a special case for sparc.
    
    Signed-off-by: Andreas Larsson <andreas@gaisler.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8727e9c5eea4..72c776f2a1f5 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -83,9 +83,16 @@ EXPORT_SYMBOL_GPL(platform_get_resource);
  */
 int platform_get_irq(struct platform_device *dev, unsigned int num)
 {
+#ifdef CONFIG_SPARC
+	/* sparc does not have irqs represented as IORESOURCE_IRQ resources */
+	if (!dev || num >= dev->archdata.num_irqs)
+		return -ENXIO;
+	return dev->archdata.irqs[num];
+#else
 	struct resource *r = platform_get_resource(dev, IORESOURCE_IRQ, num);
 
 	return r ? r->start : -ENXIO;
+#endif
 }
 EXPORT_SYMBOL_GPL(platform_get_irq);
 

commit b1d6d822550ee4e71ab9d55e65f8e096fb11e62b
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Oct 29 18:04:53 2012 +0100

    drivers/base: fix typo in comment for arch_setup_pdev_archdata()
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8727e9c5eea4..af1d47f0e99d 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -44,7 +44,7 @@ EXPORT_SYMBOL_GPL(platform_bus);
  * be setup before the platform_notifier is called.  So if a user needs to
  * manipulate any relevant information in the pdev_archdata they can do:
  *
- * 	platform_devic_alloc()
+ *	platform_device_alloc()
  * 	... manipulate ...
  * 	platform_device_add()
  *

commit 16642a2e7be23bbda013fc32d8f6c68982eab603
Merge: 51562cba9893 b9142167a2bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 18:32:35 2012 -0700

    Merge tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael J Wysocki:
    
     - Improved system suspend/resume and runtime PM handling for the SH
       TMU, CMT and MTU2 clock event devices (also used by ARM/shmobile).
    
     - Generic PM domains framework extensions related to cpuidle support
       and domain objects lookup using names.
    
     - ARM/shmobile power management updates including improved support for
       the SH7372's A4S power domain containing the CPU core.
    
     - cpufreq changes related to AMD CPUs support from Matthew Garrett,
       Andre Przywara and Borislav Petkov.
    
     - cpu0 cpufreq driver from Shawn Guo.
    
     - cpufreq governor fixes related to the relaxing of limit from Michal
       Pecio.
    
     - OMAP cpufreq updates from Axel Lin and Richard Zhao.
    
     - cpuidle ladder governor fixes related to the disabling of states from
       Carsten Emde and me.
    
     - Runtime PM core updates related to the interactions with the system
       suspend core from Alan Stern and Kevin Hilman.
    
     - Wakeup sources modification allowing more helper functions to be
       called from interrupt context from John Stultz and additional
       diagnostic code from Todd Poynor.
    
     - System suspend error code path fix from Feng Hong.
    
    Fixed up conflicts in cpufreq/powernow-k8 that stemmed from the
    workqueue fixes conflicting fairly badly with the removal of support for
    hardware P-state chips.  The changes were independent but somewhat
    intertwined.
    
    * tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (76 commits)
      Revert "PM QoS: Use spinlock in the per-device PM QoS constraints code"
      PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE, even when disabled, v2
      cpuidle: rename function name "__cpuidle_register_driver", v2
      cpufreq: OMAP: Check IS_ERR() instead of NULL for omap_device_get_by_hwmod_name
      cpuidle: remove some empty lines
      PM: Prevent runtime suspend during system resume
      PM QoS: Use spinlock in the per-device PM QoS constraints code
      PM / Sleep: use resume event when call dpm_resume_early
      cpuidle / ACPI : move cpuidle_device field out of the acpi_processor_power structure
      ACPI / processor: remove pointless variable initialization
      ACPI / processor: remove unused function parameter
      cpufreq: OMAP: remove loops_per_jiffy recalculate for smp
      sections: fix section conflicts in drivers/cpufreq
      cpufreq: conservative: update frequency when limits are relaxed
      cpufreq / ondemand: update frequency when limits are relaxed
      properly __init-annotate pm_sysrq_init()
      cpufreq: Add a generic cpufreq-cpu0 driver
      PM / OPP: Initialize OPP table from device tree
      ARM: add cpufreq transiton notifier to adjust loops_per_jiffy for smp
      cpufreq: Remove support for hardware P-state chips from powernow-k8
      ...

commit 1b8cb9290671a4c025c16a51d316031f9ec04976
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Aug 23 17:10:00 2012 +0300

    driver core: Check if r->name is valid in platform_get_resource_byname()
    
    Safety check for the validity of the resource name before calling strcmp().
    If the resource name is NULL do not compare it, just skip it.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 3f8077ce585c..ddeca142293c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -103,6 +103,9 @@ struct resource *platform_get_resource_byname(struct platform_device *dev,
 	for (i = 0; i < dev->num_resources; i++) {
 		struct resource *r = &dev->resource[i];
 
+		if (unlikely(!r->name))
+			continue;
+
 		if (type == resource_type(r) && !strcmp(r->name, name))
 			return r;
 	}

commit bed2b42d9f0b411f384c5619870ab0fea5dd116b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 6 01:45:11 2012 +0200

    PM / Runtime: Allow helpers to be called by early platform drivers
    
    Runtime PM helper functions, like pm_runtime_get_sync(), cannot be
    called by early platform device drivers, because the devices' power
    management locks are not initialized at that time.  This is quite
    inconvenient, so modify early_platform_add_devices() to initialize
    the devices power management locks as appropriate and make sure that
    they won't be initialized more than once if an early platform
    device is going to be used as a regular one later.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a1a722502587..d51514b79efe 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -22,6 +22,7 @@
 #include <linux/pm_runtime.h>
 
 #include "base.h"
+#include "power/power.h"
 
 #define to_platform_driver(drv)	(container_of((drv), struct platform_driver, \
 				 driver))
@@ -948,6 +949,7 @@ void __init early_platform_add_devices(struct platform_device **devs, int num)
 		dev = &devs[i]->dev;
 
 		if (!dev->devres_head.next) {
+			pm_runtime_early_init(dev);
 			INIT_LIST_HEAD(&dev->devres_head);
 			list_add_tail(&dev->devres_head,
 				      &early_platform_device_list);

commit 689ae231afbac8979f96100b372a5a73458baaa9
Author: Jean Delvare <khali@linux-fr.org>
Date:   Fri Jul 27 22:14:59 2012 +0200

    platform: Add support for automatic device IDs
    
    Right now we have support for explicit platform device IDs, as well as
    ID-less platform devices when a given device type can only have one
    instance. However there are cases where multiple instances of a device
    type can exist, and their IDs aren't (and can't be) known in advance
    and do not matter. In that case we need automatic device IDs to avoid
    device name collisions.
    
    I am using magic ID value -2 (PLATFORM_DEVID_AUTO) for this, similar
    to -1 for ID-less devices. The automatically allocated device IDs are
    global (to avoid an additional per-driver cost.) We keep note that the
    ID was automatically allocated so that it can be freed later.
    
    Note that we also restore the ID to PLATFORM_DEVID_AUTO on error and
    device deletion, to avoid avoid unexpected behavior on retry. I don't
    really expect retries on platform device addition, but better safe
    than sorry.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a1a722502587..3f8077ce585c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -20,9 +20,13 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
+#include <linux/idr.h>
 
 #include "base.h"
 
+/* For automatically allocated device IDs */
+static DEFINE_IDA(platform_devid_ida);
+
 #define to_platform_driver(drv)	(container_of((drv), struct platform_driver, \
 				 driver))
 
@@ -263,7 +267,7 @@ EXPORT_SYMBOL_GPL(platform_device_add_data);
  */
 int platform_device_add(struct platform_device *pdev)
 {
-	int i, ret = 0;
+	int i, ret;
 
 	if (!pdev)
 		return -EINVAL;
@@ -273,10 +277,27 @@ int platform_device_add(struct platform_device *pdev)
 
 	pdev->dev.bus = &platform_bus_type;
 
-	if (pdev->id != -1)
+	switch (pdev->id) {
+	default:
 		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
-	else
+		break;
+	case PLATFORM_DEVID_NONE:
 		dev_set_name(&pdev->dev, "%s", pdev->name);
+		break;
+	case PLATFORM_DEVID_AUTO:
+		/*
+		 * Automatically allocated device ID. We mark it as such so
+		 * that we remember it must be freed, and we append a suffix
+		 * to avoid namespace collision with explicit IDs.
+		 */
+		ret = ida_simple_get(&platform_devid_ida, 0, 0, GFP_KERNEL);
+		if (ret < 0)
+			goto err_out;
+		pdev->id = ret;
+		pdev->id_auto = true;
+		dev_set_name(&pdev->dev, "%s.%d.auto", pdev->name, pdev->id);
+		break;
+	}
 
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];
@@ -309,6 +330,11 @@ int platform_device_add(struct platform_device *pdev)
 		return ret;
 
  failed:
+	if (pdev->id_auto) {
+		ida_simple_remove(&platform_devid_ida, pdev->id);
+		pdev->id = PLATFORM_DEVID_AUTO;
+	}
+
 	while (--i >= 0) {
 		struct resource *r = &pdev->resource[i];
 		unsigned long type = resource_type(r);
@@ -317,6 +343,7 @@ int platform_device_add(struct platform_device *pdev)
 			release_resource(r);
 	}
 
+ err_out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(platform_device_add);
@@ -336,6 +363,11 @@ void platform_device_del(struct platform_device *pdev)
 	if (pdev) {
 		device_del(&pdev->dev);
 
+		if (pdev->id_auto) {
+			ida_simple_remove(&platform_devid_ida, pdev->id);
+			pdev->id = PLATFORM_DEVID_AUTO;
+		}
+
 		for (i = 0; i < pdev->num_resources; i++) {
 			struct resource *r = &pdev->resource[i];
 			unsigned long type = resource_type(r);

commit 07d57a32fb6eb2da017796e038682f817a4f685e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Feb 1 11:22:22 2012 -0700

    drivercore: Output common devicetree information in uevent
    
    When userspace needs to find a specific device, it currently isn't easy to
    resolve a /sys/devices/ path from a specific device tree node.  Nor is it
    easy to obtain the compatible list for devices.
    
    This patch generalizes the code that inserts OF_* values into the uevent
    device attribute so that any device that is attached to an OF node will
    have that information exported to userspace.  Without this patch only
    platform devices and some powerpc-specific busses have access to this
    data.
    
    The original function also creates a MODALIAS property for the compatible
    list, but that code has not been generalized into the common case because
    it has the potential to break module loading on a lot of bus types.  Bus
    types are still responsible for their own MODALIAS properties.
    
    Boot tested on ARM and compile tested on PowerPC and SPARC.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Frederic Lambert <frdrc66@gmail.com>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Mark Brown <broonie@sirena.org.uk>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f0c605e99ade..a1a722502587 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -621,7 +621,7 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 	int rc;
 
 	/* Some devices have extra OF data and an OF-style MODALIAS */
-	rc = of_device_uevent(dev,env);
+	rc = of_device_uevent_modalias(dev,env);
 	if (rc != -ENODEV)
 		return rc;
 

commit eb59c505f8a5906ad2e053d14fab50eb8574fd6f
Merge: 1619ed8f6095 c233523b3d39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 8 13:10:57 2012 -0800

    Merge branch 'pm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    * 'pm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (76 commits)
      PM / Hibernate: Implement compat_ioctl for /dev/snapshot
      PM / Freezer: fix return value of freezable_schedule_timeout_killable()
      PM / shmobile: Allow the A4R domain to be turned off at run time
      PM / input / touchscreen: Make st1232 use device PM QoS constraints
      PM / QoS: Introduce dev_pm_qos_add_ancestor_request()
      PM / shmobile: Remove the stay_on flag from SH7372's PM domains
      PM / shmobile: Don't include SH7372's INTCS in syscore suspend/resume
      PM / shmobile: Add support for the sh7372 A4S power domain / sleep mode
      PM: Drop generic_subsys_pm_ops
      PM / Sleep: Remove forward-only callbacks from AMBA bus type
      PM / Sleep: Remove forward-only callbacks from platform bus type
      PM: Run the driver callback directly if the subsystem one is not there
      PM / Sleep: Make pm_op() and pm_noirq_op() return callback pointers
      PM/Devfreq: Add Exynos4-bus device DVFS driver for Exynos4210/4212/4412.
      PM / Sleep: Merge internal functions in generic_ops.c
      PM / Sleep: Simplify generic system suspend callbacks
      PM / Hibernate: Remove deprecated hibernation snapshot ioctls
      PM / Sleep: Fix freezer failures due to racy usermodehelper_is_disabled()
      ARM: S3C64XX: Implement basic power domain support
      PM / shmobile: Use common always on power domain governor
      ...
    
    Fix up trivial conflict in fs/xfs/xfs_buf.c due to removal of unused
    XBT_FORCE_SLEEP bit

commit 9b39e73d0c2b265a7f8748b0e9a9f09be84079a8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 18 00:34:24 2011 +0100

    PM / Sleep: Remove forward-only callbacks from platform bus type
    
    The forward-only PM callbacks provided by the platform bus type are
    not necessary any more, because the PM core executes driver callbacks
    when the corresponding subsystem callbacks are not present, so drop
    them.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 7a24895543e7..7d912d5675d8 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -700,25 +700,6 @@ static int platform_legacy_resume(struct device *dev)
 	return ret;
 }
 
-int platform_pm_prepare(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (drv && drv->pm && drv->pm->prepare)
-		ret = drv->pm->prepare(dev);
-
-	return ret;
-}
-
-void platform_pm_complete(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-
-	if (drv && drv->pm && drv->pm->complete)
-		drv->pm->complete(dev);
-}
-
 #endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_SUSPEND
@@ -741,22 +722,6 @@ int platform_pm_suspend(struct device *dev)
 	return ret;
 }
 
-int platform_pm_suspend_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->suspend_noirq)
-			ret = drv->pm->suspend_noirq(dev);
-	}
-
-	return ret;
-}
-
 int platform_pm_resume(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -775,22 +740,6 @@ int platform_pm_resume(struct device *dev)
 	return ret;
 }
 
-int platform_pm_resume_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->resume_noirq)
-			ret = drv->pm->resume_noirq(dev);
-	}
-
-	return ret;
-}
-
 #endif /* CONFIG_SUSPEND */
 
 #ifdef CONFIG_HIBERNATE_CALLBACKS
@@ -813,22 +762,6 @@ int platform_pm_freeze(struct device *dev)
 	return ret;
 }
 
-int platform_pm_freeze_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->freeze_noirq)
-			ret = drv->pm->freeze_noirq(dev);
-	}
-
-	return ret;
-}
-
 int platform_pm_thaw(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -847,22 +780,6 @@ int platform_pm_thaw(struct device *dev)
 	return ret;
 }
 
-int platform_pm_thaw_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->thaw_noirq)
-			ret = drv->pm->thaw_noirq(dev);
-	}
-
-	return ret;
-}
-
 int platform_pm_poweroff(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -881,22 +798,6 @@ int platform_pm_poweroff(struct device *dev)
 	return ret;
 }
 
-int platform_pm_poweroff_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->poweroff_noirq)
-			ret = drv->pm->poweroff_noirq(dev);
-	}
-
-	return ret;
-}
-
 int platform_pm_restore(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -915,22 +816,6 @@ int platform_pm_restore(struct device *dev)
 	return ret;
 }
 
-int platform_pm_restore_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->restore_noirq)
-			ret = drv->pm->restore_noirq(dev);
-	}
-
-	return ret;
-}
-
 #endif /* CONFIG_HIBERNATE_CALLBACKS */
 
 static const struct dev_pm_ops platform_dev_pm_ops = {

commit 5a3072be6ce00b10565c78da05ad78df41310045
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Dec 8 22:53:29 2011 +0100

    drivers_base: make argument to platform_device_register_full const
    
    platform_device_register_full doesn't modify *pdevinfo so it can be
    marked as const without further adaptions.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 7a24895543e7..a7c06374062e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -383,7 +383,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
 struct platform_device *platform_device_register_full(
-		struct platform_device_info *pdevinfo)
+		const struct platform_device_info *pdevinfo)
 {
 	int ret = -ENOMEM;
 	struct platform_device *pdev;

commit 2d03423b2319cc854adeb28a03f65de5b5e0ab63
Merge: 59e52534172d 2bbcb8788311
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 12:13:59 2011 +0200

    Merge branch 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    * 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (38 commits)
      mm: memory hotplug: Check if pages are correctly reserved on a per-section basis
      Revert "memory hotplug: Correct page reservation checking"
      Update email address for stable patch submission
      dynamic_debug: fix undefined reference to `__netdev_printk'
      dynamic_debug: use a single printk() to emit messages
      dynamic_debug: remove num_enabled accounting
      dynamic_debug: consolidate repetitive struct _ddebug descriptor definitions
      uio: Support physical addresses >32 bits on 32-bit systems
      sysfs: add unsigned long cast to prevent compile warning
      drivers: base: print rejected matches with DEBUG_DRIVER
      memory hotplug: Correct page reservation checking
      memory hotplug: Refuse to add unaligned memory regions
      remove the messy code file Documentation/zh_CN/SubmitChecklist
      ARM: mxc: convert device creation to use platform_device_register_full
      new helper to create platform devices with dma mask
      docs/driver-model: Update device class docs
      docs/driver-model: Document device.groups
      kobj_uevent: Ignore if some listeners cannot handle message
      dynamic_debug: make netif_dbg() call __netdev_printk()
      dynamic_debug: make netdev_dbg() call __netdev_printk()
      ...

commit 01dcc60a7cb8cd5193676554b94a90d349bdfd15
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Aug 25 11:16:00 2011 +0200

    new helper to create platform devices with dma mask
    
    compared to the most powerful and already existing helper (namely
    platform_device_register_resndata) this allows to specify a dma_mask.
    To make eventual extensions later more easy, a struct holding the used
    information is created instead of passing the information by function
    parameters.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index cd7157575e58..4573f5ec9367 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -375,52 +375,64 @@ void platform_device_unregister(struct platform_device *pdev)
 EXPORT_SYMBOL_GPL(platform_device_unregister);
 
 /**
- * platform_device_register_resndata - add a platform-level device with
+ * platform_device_register_full - add a platform-level device with
  * resources and platform-specific data
  *
- * @parent: parent device for the device we're adding
- * @name: base name of the device we're adding
- * @id: instance id
- * @res: set of resources that needs to be allocated for the device
- * @num: number of resources
- * @data: platform specific data for this platform device
- * @size: size of platform specific data
+ * @pdevinfo: data used to create device
  *
  * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
-struct platform_device *platform_device_register_resndata(
-		struct device *parent,
-		const char *name, int id,
-		const struct resource *res, unsigned int num,
-		const void *data, size_t size)
+struct platform_device *platform_device_register_full(
+		struct platform_device_info *pdevinfo)
 {
 	int ret = -ENOMEM;
 	struct platform_device *pdev;
 
-	pdev = platform_device_alloc(name, id);
+	pdev = platform_device_alloc(pdevinfo->name, pdevinfo->id);
 	if (!pdev)
-		goto err;
-
-	pdev->dev.parent = parent;
+		goto err_alloc;
+
+	pdev->dev.parent = pdevinfo->parent;
+
+	if (pdevinfo->dma_mask) {
+		/*
+		 * This memory isn't freed when the device is put,
+		 * I don't have a nice idea for that though.  Conceptually
+		 * dma_mask in struct device should not be a pointer.
+		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
+		 */
+		pdev->dev.dma_mask =
+			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
+		if (!pdev->dev.dma_mask)
+			goto err;
+
+		*pdev->dev.dma_mask = pdevinfo->dma_mask;
+		pdev->dev.coherent_dma_mask = pdevinfo->dma_mask;
+	}
 
-	ret = platform_device_add_resources(pdev, res, num);
+	ret = platform_device_add_resources(pdev,
+			pdevinfo->res, pdevinfo->num_res);
 	if (ret)
 		goto err;
 
-	ret = platform_device_add_data(pdev, data, size);
+	ret = platform_device_add_data(pdev,
+			pdevinfo->data, pdevinfo->size_data);
 	if (ret)
 		goto err;
 
 	ret = platform_device_add(pdev);
 	if (ret) {
 err:
+		kfree(pdev->dev.dma_mask);
+
+err_alloc:
 		platform_device_put(pdev);
 		return ERR_PTR(ret);
 	}
 
 	return pdev;
 }
-EXPORT_SYMBOL_GPL(platform_device_register_resndata);
+EXPORT_SYMBOL_GPL(platform_device_register_full);
 
 static int platform_drv_probe(struct device *_dev)
 {

commit 0a26813c9f528f17901b2f2394fba8557d2c9485
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Aug 15 16:51:22 2011 +0200

    drivers_base: platform: use always ->name for uevent
    
    If id_entry is available then it is used. However if we remove first the
    driver followed by the device, then the id_entry is pointing to driver's
    memory which is long gone.
    Since id->name and plat->name are equal there is no point in
    distinguishing them.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 0cad9c7f6bb5..cd7157575e58 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -614,7 +614,7 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return rc;
 
 	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
-		(pdev->id_entry) ? pdev->id_entry->name : pdev->name);
+			pdev->name);
 	return 0;
 }
 

commit 7de636fa25c19fc4187f85f8325c50b1b21a6d8b
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jul 27 12:11:25 2011 -0700

    driver core: fix kernel-doc warning in platform.c
    
    Warning(drivers/base/platform.c:50): No description found for parameter 'pdev'
    Warning(drivers/base/platform.c:50): Excess function parameter 'dev' description in 'arch_setup_pdev_archdata'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 0cad9c7f6bb5..99a5272d7c2f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -33,7 +33,7 @@ EXPORT_SYMBOL_GPL(platform_bus);
 
 /**
  * arch_setup_pdev_archdata - Allow manipulation of archdata before its used
- * @dev: platform device
+ * @pdev: platform device
  *
  * This is called before platform_device_add() such that any pdev_archdata may
  * be setup before the platform_notifier is called.  So if a user needs to

commit a77ce8167cc1d0370fcb1d79b367d62e050cb2b0
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Fri Jun 10 01:52:57 2011 -0500

    driver core: Add ability for arch code to setup pdev_archdata
    
    On some architectures we need to setup pdev_archdata before we add the
    device.  Waiting til a bus_notifier is too late since we might need the
    pdev_archdata in the bus notifier.  One example is setting up of dma_mask
    pointers such that it can be used in a bus_notifier.
    
    We add weak noop version of arch_setup_pdev_archdata() and allow the arch
    code to override with access the full definitions of struct device,
    struct platform_device, and struct pdev_archdata.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 6040717b62bb..0cad9c7f6bb5 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -31,6 +31,25 @@ struct device platform_bus = {
 };
 EXPORT_SYMBOL_GPL(platform_bus);
 
+/**
+ * arch_setup_pdev_archdata - Allow manipulation of archdata before its used
+ * @dev: platform device
+ *
+ * This is called before platform_device_add() such that any pdev_archdata may
+ * be setup before the platform_notifier is called.  So if a user needs to
+ * manipulate any relevant information in the pdev_archdata they can do:
+ *
+ * 	platform_devic_alloc()
+ * 	... manipulate ...
+ * 	platform_device_add()
+ *
+ * And if they don't care they can just call platform_device_register() and
+ * everything will just work out.
+ */
+void __weak arch_setup_pdev_archdata(struct platform_device *pdev)
+{
+}
+
 /**
  * platform_get_resource - get a resource for a device
  * @dev: platform device
@@ -173,6 +192,7 @@ struct platform_device *platform_device_alloc(const char *name, int id)
 		pa->pdev.id = id;
 		device_initialize(&pa->pdev.dev);
 		pa->pdev.dev.release = platform_device_release;
+		arch_setup_pdev_archdata(&pa->pdev);
 	}
 
 	return pa ? &pa->pdev : NULL;
@@ -334,6 +354,7 @@ EXPORT_SYMBOL_GPL(platform_device_del);
 int platform_device_register(struct platform_device *pdev)
 {
 	device_initialize(&pdev->dev);
+	arch_setup_pdev_archdata(pdev);
 	return platform_device_add(pdev);
 }
 EXPORT_SYMBOL_GPL(platform_device_register);

commit bb2b43fefab723f4a0760146e7bed59d41a50e53
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon May 23 14:44:19 2011 -0700

    drivers/base/platform.c: don't mark platform_device_register_resndata() as __init_or_module
    
    This reverts 737a3bb9416ce2a7c7a4 ("Driver core: move platform device
    creation helpers to .init.text (if MODULE=n)").  That patch assumed that
    platform_device_register_resndata() is only ever called from __init code
    but that isn't true in the case ioctl->drm_ioctl->radeon_cp_init().
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=35192
    
    Cc: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Reported-by: Anthony Basile <blueness@gentoo.org>
    Cc: Greg KH <gregkh@suse.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1c291af637b3..6040717b62bb 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -367,7 +367,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  *
  * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
-struct platform_device *__init_or_module platform_device_register_resndata(
+struct platform_device *platform_device_register_resndata(
 		struct device *parent,
 		const char *name, int id,
 		const struct resource *res, unsigned int num,

commit 39ab05c8e0b519ff0a04a869f065746e6e8c3d95
Merge: 1477fcc290b3 c42d2237143f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 18:24:11 2011 -0700

    Merge branch 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6
    
    * 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6: (44 commits)
      debugfs: Silence DEBUG_STRICT_USER_COPY_CHECKS=y warning
      sysfs: remove "last sysfs file:" line from the oops messages
      drivers/base/memory.c: fix warning due to "memory hotplug: Speed up add/remove when blocks are larger than PAGES_PER_SECTION"
      memory hotplug: Speed up add/remove when blocks are larger than PAGES_PER_SECTION
      SYSFS: Fix erroneous comments for sysfs_update_group().
      driver core: remove the driver-model structures from the documentation
      driver core: Add the device driver-model structures to kerneldoc
      Translated Documentation/email-clients.txt
      RAW driver: Remove call to kobject_put().
      reboot: disable usermodehelper to prevent fs access
      efivars: prevent oops on unload when efi is not enabled
      Allow setting of number of raw devices as a module parameter
      Introduce CONFIG_GOOGLE_FIRMWARE
      driver: Google Memory Console
      driver: Google EFI SMI
      x86: Better comments for get_bios_ebda()
      x86: get_bios_ebda_length()
      misc: fix ti-st build issues
      params.c: Use new strtobool function to process boolean inputs
      debugfs: move to new strtobool
      ...
    
    Fix up trivial conflicts in fs/debugfs/file.c due to the same patch
    being applied twice, and an unrelated cleanup nearby.

commit 2064af917b3ba7589070064ca4ed12cecd99a63c
Author: Kevin Hilman <khilman@ti.com>
Date:   Fri Apr 29 00:37:26 2011 +0200

    PM: Revert "driver core: platform_bus: allow runtime override of dev_pm_ops"
    
    The platform_bus_set_pm_ops() operation is deprecated in favor of the
    new device power domain infrastructre implemented in commit
    7538e3db6e015e890825fbd9f8659952896ddd5b (PM: add support for device
    power domains)
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 079c18a5e471..48425f183029 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -916,41 +916,6 @@ struct bus_type platform_bus_type = {
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 
-/**
- * platform_bus_get_pm_ops() - return pointer to busses dev_pm_ops
- *
- * This function can be used by platform code to get the current
- * set of dev_pm_ops functions used by the platform_bus_type.
- */
-const struct dev_pm_ops * __init platform_bus_get_pm_ops(void)
-{
-	return platform_bus_type.pm;
-}
-
-/**
- * platform_bus_set_pm_ops() - update dev_pm_ops for the platform_bus_type
- *
- * @pm: pointer to new dev_pm_ops struct to be used for platform_bus_type
- *
- * Platform code can override the dev_pm_ops methods of
- * platform_bus_type by using this function.  It is expected that
- * platform code will first do a platform_bus_get_pm_ops(), then
- * kmemdup it, then customize selected methods and pass a pointer to
- * the new struct dev_pm_ops to this function.
- *
- * Since platform-specific code is customizing methods for *all*
- * devices (not just platform-specific devices) it is expected that
- * any custom overrides of these functions will keep existing behavior
- * and simply extend it.  For example, any customization of the
- * runtime PM methods should continue to call the pm_generic_*
- * functions as the default ones do in addition to the
- * platform-specific behavior.
- */
-void __init platform_bus_set_pm_ops(const struct dev_pm_ops *pm)
-{
-	platform_bus_type.pm = pm;
-}
-
 int __init platform_bus_init(void)
 {
 	int error;

commit 8b313a38ecffc0ff0b4c5115f0a461f73b7dfdb6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 29 00:36:32 2011 +0200

    PM / Platform: Use generic runtime PM callbacks directly
    
    Once shmobile platforms have been converted to using power domains
    for overriding the platform bus type's PM callbacks, it isn't
    necessary to use the __weakly defined wrappers around the generinc
    runtime PM callbacks in the platform bus type any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 313556f28c9e..079c18a5e471 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -900,35 +900,10 @@ int platform_pm_restore_noirq(struct device *dev)
 
 #endif /* CONFIG_HIBERNATE_CALLBACKS */
 
-#ifdef CONFIG_PM_RUNTIME
-
-int __weak platform_pm_runtime_suspend(struct device *dev)
-{
-	return pm_generic_runtime_suspend(dev);
-};
-
-int __weak platform_pm_runtime_resume(struct device *dev)
-{
-	return pm_generic_runtime_resume(dev);
-};
-
-int __weak platform_pm_runtime_idle(struct device *dev)
-{
-	return pm_generic_runtime_idle(dev);
-};
-
-#else /* !CONFIG_PM_RUNTIME */
-
-#define platform_pm_runtime_suspend NULL
-#define platform_pm_runtime_resume NULL
-#define platform_pm_runtime_idle NULL
-
-#endif /* !CONFIG_PM_RUNTIME */
-
 static const struct dev_pm_ops platform_dev_pm_ops = {
-	.runtime_suspend = platform_pm_runtime_suspend,
-	.runtime_resume = platform_pm_runtime_resume,
-	.runtime_idle = platform_pm_runtime_idle,
+	.runtime_suspend = pm_generic_runtime_suspend,
+	.runtime_resume = pm_generic_runtime_resume,
+	.runtime_idle = pm_generic_runtime_idle,
 	USE_PLATFORM_PM_SLEEP_OPS
 };
 

commit 69c9dd1ecf446ad8a830e4afc539a2a1adc85b78
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 29 00:36:05 2011 +0200

    PM: Export platform bus type's default PM callbacks
    
    Export the default PM callbacks defined for the platform bus type so
    that they can be used by power domains for suspending and resuming
    platform devices in the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9e0e4fc24c46..313556f28c9e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -667,7 +667,7 @@ static int platform_legacy_resume(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_prepare(struct device *dev)
+int platform_pm_prepare(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -678,7 +678,7 @@ static int platform_pm_prepare(struct device *dev)
 	return ret;
 }
 
-static void platform_pm_complete(struct device *dev)
+void platform_pm_complete(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 
@@ -686,16 +686,11 @@ static void platform_pm_complete(struct device *dev)
 		drv->pm->complete(dev);
 }
 
-#else /* !CONFIG_PM_SLEEP */
-
-#define platform_pm_prepare		NULL
-#define platform_pm_complete		NULL
-
-#endif /* !CONFIG_PM_SLEEP */
+#endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_SUSPEND
 
-int __weak platform_pm_suspend(struct device *dev)
+int platform_pm_suspend(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -713,7 +708,7 @@ int __weak platform_pm_suspend(struct device *dev)
 	return ret;
 }
 
-int __weak platform_pm_suspend_noirq(struct device *dev)
+int platform_pm_suspend_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -729,7 +724,7 @@ int __weak platform_pm_suspend_noirq(struct device *dev)
 	return ret;
 }
 
-int __weak platform_pm_resume(struct device *dev)
+int platform_pm_resume(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -747,7 +742,7 @@ int __weak platform_pm_resume(struct device *dev)
 	return ret;
 }
 
-int __weak platform_pm_resume_noirq(struct device *dev)
+int platform_pm_resume_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -763,18 +758,11 @@ int __weak platform_pm_resume_noirq(struct device *dev)
 	return ret;
 }
 
-#else /* !CONFIG_SUSPEND */
-
-#define platform_pm_suspend		NULL
-#define platform_pm_resume		NULL
-#define platform_pm_suspend_noirq	NULL
-#define platform_pm_resume_noirq	NULL
-
-#endif /* !CONFIG_SUSPEND */
+#endif /* CONFIG_SUSPEND */
 
 #ifdef CONFIG_HIBERNATE_CALLBACKS
 
-static int platform_pm_freeze(struct device *dev)
+int platform_pm_freeze(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -792,7 +780,7 @@ static int platform_pm_freeze(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_freeze_noirq(struct device *dev)
+int platform_pm_freeze_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -808,7 +796,7 @@ static int platform_pm_freeze_noirq(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_thaw(struct device *dev)
+int platform_pm_thaw(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -826,7 +814,7 @@ static int platform_pm_thaw(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_thaw_noirq(struct device *dev)
+int platform_pm_thaw_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -842,7 +830,7 @@ static int platform_pm_thaw_noirq(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_poweroff(struct device *dev)
+int platform_pm_poweroff(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -860,7 +848,7 @@ static int platform_pm_poweroff(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_poweroff_noirq(struct device *dev)
+int platform_pm_poweroff_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -876,7 +864,7 @@ static int platform_pm_poweroff_noirq(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_restore(struct device *dev)
+int platform_pm_restore(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -894,7 +882,7 @@ static int platform_pm_restore(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_restore_noirq(struct device *dev)
+int platform_pm_restore_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -910,18 +898,7 @@ static int platform_pm_restore_noirq(struct device *dev)
 	return ret;
 }
 
-#else /* !CONFIG_HIBERNATE_CALLBACKS */
-
-#define platform_pm_freeze		NULL
-#define platform_pm_thaw		NULL
-#define platform_pm_poweroff		NULL
-#define platform_pm_restore		NULL
-#define platform_pm_freeze_noirq	NULL
-#define platform_pm_thaw_noirq		NULL
-#define platform_pm_poweroff_noirq	NULL
-#define platform_pm_restore_noirq	NULL
-
-#endif /* !CONFIG_HIBERNATE_CALLBACKS */
+#endif /* CONFIG_HIBERNATE_CALLBACKS */
 
 #ifdef CONFIG_PM_RUNTIME
 
@@ -949,23 +926,10 @@ int __weak platform_pm_runtime_idle(struct device *dev)
 #endif /* !CONFIG_PM_RUNTIME */
 
 static const struct dev_pm_ops platform_dev_pm_ops = {
-	.prepare = platform_pm_prepare,
-	.complete = platform_pm_complete,
-	.suspend = platform_pm_suspend,
-	.resume = platform_pm_resume,
-	.freeze = platform_pm_freeze,
-	.thaw = platform_pm_thaw,
-	.poweroff = platform_pm_poweroff,
-	.restore = platform_pm_restore,
-	.suspend_noirq = platform_pm_suspend_noirq,
-	.resume_noirq = platform_pm_resume_noirq,
-	.freeze_noirq = platform_pm_freeze_noirq,
-	.thaw_noirq = platform_pm_thaw_noirq,
-	.poweroff_noirq = platform_pm_poweroff_noirq,
-	.restore_noirq = platform_pm_restore_noirq,
 	.runtime_suspend = platform_pm_runtime_suspend,
 	.runtime_resume = platform_pm_runtime_resume,
 	.runtime_idle = platform_pm_runtime_idle,
+	USE_PLATFORM_PM_SLEEP_OPS
 };
 
 struct bus_type platform_bus_type = {

commit 4a03d6f7c863a039b937649a93341615f531358e
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Apr 20 09:44:45 2011 +0200

    driver core/platform_device_add_resources: free resource before overwriting
    
    Reviewed-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 667f282f8b7b..7d4bdaf557cf 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -200,6 +200,7 @@ int platform_device_add_resources(struct platform_device *pdev,
 			return -ENOMEM;
 	}
 
+	kfree(pdev->resource);
 	pdev->resource = r;
 	pdev->num_resources = num;
 	return 0;

commit cea896238fbfdbce254f51fc8fd78c59df50081f
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Apr 20 09:44:44 2011 +0200

    driver core/platform_device_add_resources: set resource to NULL if !res
    
    This makes the res = NULL case more consistant to the res != NULL case
    as now both overwrite pdev->resource.
    
    Reviewed-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 58ad8e8ad7a3..667f282f8b7b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -192,18 +192,17 @@ EXPORT_SYMBOL_GPL(platform_device_alloc);
 int platform_device_add_resources(struct platform_device *pdev,
 				  const struct resource *res, unsigned int num)
 {
-	struct resource *r;
+	struct resource *r = NULL;
 
-	if (!res)
-		return 0;
-
-	r = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);
-	if (r) {
-		pdev->resource = r;
-		pdev->num_resources = num;
-		return 0;
+	if (res) {
+		r = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);
+		if (!r)
+			return -ENOMEM;
 	}
-	return -ENOMEM;
+
+	pdev->resource = r;
+	pdev->num_resources = num;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(platform_device_add_resources);
 

commit 251e031d132ea3d03e0a32f2240c67f449979c5d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Apr 20 09:44:43 2011 +0200

    driver core/platform_device_add_data: free platform data before overwriting
    
    Reviewed-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 65cb4c397603..58ad8e8ad7a3 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -228,6 +228,7 @@ int platform_device_add_data(struct platform_device *pdev, const void *data,
 			return -ENOMEM;
 	}
 
+	kfree(pdev->dev.platform_data);
 	pdev->dev.platform_data = d;
 	return 0;
 }

commit 27a33f9e8fb203e71925257cf039fe6ec623c5d1
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Apr 20 09:44:42 2011 +0200

    driver core/platform_device_add_data: set platform_data to NULL if !data
    
    This makes the data = NULL case more consistent to the data != NULL case.
    The functional change is that now
    
            platform_device_add_data(somepdev, NULL, somesize)
    
    sets pdev->dev.platform_data to NULL instead of not touching it.
    
    Reviewed-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9e0e4fc24c46..65cb4c397603 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -220,17 +220,16 @@ EXPORT_SYMBOL_GPL(platform_device_add_resources);
 int platform_device_add_data(struct platform_device *pdev, const void *data,
 			     size_t size)
 {
-	void *d;
+	void *d = NULL;
 
-	if (!data)
-		return 0;
-
-	d = kmemdup(data, size, GFP_KERNEL);
-	if (d) {
-		pdev->dev.platform_data = d;
-		return 0;
+	if (data) {
+		d = kmemdup(data, size, GFP_KERNEL);
+		if (!d)
+			return -ENOMEM;
 	}
-	return -ENOMEM;
+
+	pdev->dev.platform_data = d;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(platform_device_add_data);
 

commit aaa119a3d4e0b7421c82ae3fbe288e65d0f3485f
Merge: 6faf9a54156f d419e4c0f758
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 12 17:18:05 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6:
      fix XEN_SAVE_RESTORE Kconfig dependencies
      PM / Hibernate: Introduce CONFIG_HIBERNATE_CALLBACKS

commit e710d7d5a9cab1041b7a3cf9e655b75d92786857
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Fri Apr 8 00:43:01 2011 +0200

    mfd: Fetch cell pointer from platform_device->mfd_cell
    
    In order for MFD drivers to fetch their cell pointer but also their
    platform data one, an mfd cell pointer is added to the platform_device
    structure.
    That allows all MFD sub devices drivers to be MFD agnostic, unless
    they really need to access their MFD cell data. Most of them don't,
    especially the ones for IPs used by both MFD and non MFD SoCs.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg KH <gregkh@suse.de>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f051cfff18af..6c3a2bdc527a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -149,6 +149,7 @@ static void platform_device_release(struct device *dev)
 
 	of_device_node_put(&pa->pdev.dev);
 	kfree(pa->pdev.dev.platform_data);
+	kfree(pa->pdev.mfd_cell);
 	kfree(pa->pdev.resource);
 	kfree(pa);
 }

commit 1f112cee07b314e244ee9e71d9c1e6950dc13327
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Apr 11 22:54:42 2011 +0200

    PM / Hibernate: Introduce CONFIG_HIBERNATE_CALLBACKS
    
    Xen save/restore is going to use hibernate device callbacks for
    quiescing devices and putting them back to normal operations and it
    would need to select CONFIG_HIBERNATION for this purpose.  However,
    that also would cause the hibernate interfaces for user space to be
    enabled, which might confuse user space, because the Xen kernels
    don't support hibernation.  Moreover, it would be wasteful, as it
    would make the Xen kernels include a substantial amount of code that
    they would never use.
    
    To address this issue introduce new power management Kconfig option
    CONFIG_HIBERNATE_CALLBACKS, such that it will only select the code
    that is necessary for the hibernate device callbacks to work and make
    CONFIG_HIBERNATION select it.  Then, Xen save/restore will be able to
    select CONFIG_HIBERNATE_CALLBACKS without dragging the entire
    hibernate code along with it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f051cfff18af..92792313d24a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -771,7 +771,7 @@ int __weak platform_pm_resume_noirq(struct device *dev)
 
 #endif /* !CONFIG_SUSPEND */
 
-#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_HIBERNATE_CALLBACKS
 
 static int platform_pm_freeze(struct device *dev)
 {
@@ -909,7 +909,7 @@ static int platform_pm_restore_noirq(struct device *dev)
 	return ret;
 }
 
-#else /* !CONFIG_HIBERNATION */
+#else /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #define platform_pm_freeze		NULL
 #define platform_pm_thaw		NULL
@@ -920,7 +920,7 @@ static int platform_pm_restore_noirq(struct device *dev)
 #define platform_pm_poweroff_noirq	NULL
 #define platform_pm_restore_noirq	NULL
 
-#endif /* !CONFIG_HIBERNATION */
+#endif /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #ifdef CONFIG_PM_RUNTIME
 

commit 51f00a471ce8f359627dd99aeac322947a0e491b
Merge: a7f505c6b15f 97ff46cb69da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 25 08:19:14 2010 -0700

    Merge branch 'next-devicetree' of git://git.secretlab.ca/git/linux-2.6
    
    * 'next-devicetree' of git://git.secretlab.ca/git/linux-2.6:
      mtd/m25p80: add support to parse the partitions by OF node
      of/irq: of_irq.c needs to include linux/irq.h
      of/mips: Cleanup some include directives/files.
      of/mips: Add device tree support to MIPS
      of/flattree: Eliminate need to provide early_init_dt_scan_chosen_arch
      of/device: Rework to use common platform_device_alloc() for allocating devices
      of/xsysace: Fix OF probing on little-endian systems
      of: use __be32 types for big-endian device tree data
      of/irq: remove references to NO_IRQ in drivers/of/platform.c
      of/promtree: add package-to-path support to pdt
      of/promtree: add of_pdt namespace to pdt code
      of/promtree: no longer call prom_ functions directly; use an ops structure
      of/promtree: make drivers/of/pdt.c no longer sparc-only
      sparc: break out some PROM device-tree building code out into drivers/of
      of/sparc: convert various prom_* functions to use phandle
      sparc: stop exporting openprom.h header
      powerpc, of_serial: Endianness issues setting up the serial ports
      of: MTD: Fix OF probing on little-endian systems
      of: GPIO: Fix OF probing on little-endian systems

commit 807508c8ff9af6ce8f25c5ca5f3eb06a8e7d3286
Author: Anton Vorontsov <cbouatmailru@gmail.com>
Date:   Tue Sep 7 17:31:54 2010 +0400

    base/platform: Simplifications for NULL platform data/resources handling
    
    There's no need to explicitly check for data and resources being NULL,
    as platform_device_add_{data,resources}() do this internally nowadays.
    
    This makes the code more linear and less indented.
    
    Signed-off-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c794fec1c435..3966e62ad019 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -380,17 +380,13 @@ struct platform_device *__init_or_module platform_device_register_resndata(
 
 	pdev->dev.parent = parent;
 
-	if (res) {
-		ret = platform_device_add_resources(pdev, res, num);
-		if (ret)
-			goto err;
-	}
+	ret = platform_device_add_resources(pdev, res, num);
+	if (ret)
+		goto err;
 
-	if (data) {
-		ret = platform_device_add_data(pdev, data, size);
-		if (ret)
-			goto err;
-	}
+	ret = platform_device_add_data(pdev, data, size);
+	if (ret)
+		goto err;
 
 	ret = platform_device_add(pdev);
 	if (ret) {
@@ -537,17 +533,13 @@ struct platform_device * __init_or_module platform_create_bundle(
 		goto err_out;
 	}
 
-	if (res) {
-		error = platform_device_add_resources(pdev, res, n_res);
-		if (error)
-			goto err_pdev_put;
-	}
+	error = platform_device_add_resources(pdev, res, n_res);
+	if (error)
+		goto err_pdev_put;
 
-	if (data) {
-		error = platform_device_add_data(pdev, data, size);
-		if (error)
-			goto err_pdev_put;
-	}
+	error = platform_device_add_data(pdev, data, size);
+	if (error)
+		goto err_pdev_put;
 
 	error = platform_device_add(pdev);
 	if (error)

commit 5cfc64ceb6222aabec640ba76e89529a8fc2c1f0
Author: Anton Vorontsov <cbouatmailru@gmail.com>
Date:   Tue Sep 7 17:31:49 2010 +0400

    base/platform: Safe handling for NULL platform data and resources
    
    Some users of platform_device_add_{data,resources}() assume that
    NULL data and resources will be handled specially, i.e. just ignored.
    
    But the platform core ends up calling kmemdup(NULL, 0, ...), which
    returns a non-NULL result (i.e. ZERO_SIZE_PTR), which causes drivers
    to oops on a valid code, something like:
    
      if (platform_data)
            stuff = platform_data->stuff;
    
    This patch makes the platform core a bit more safe for such cases.
    
    Signed-off-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a01abf9ebf7b..c794fec1c435 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -192,6 +192,9 @@ int platform_device_add_resources(struct platform_device *pdev,
 {
 	struct resource *r;
 
+	if (!res)
+		return 0;
+
 	r = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);
 	if (r) {
 		pdev->resource = r;
@@ -215,8 +218,12 @@ EXPORT_SYMBOL_GPL(platform_device_add_resources);
 int platform_device_add_data(struct platform_device *pdev, const void *data,
 			     size_t size)
 {
-	void *d = kmemdup(data, size, GFP_KERNEL);
+	void *d;
+
+	if (!data)
+		return 0;
 
+	d = kmemdup(data, size, GFP_KERNEL);
 	if (d) {
 		pdev->dev.platform_data = d;
 		return 0;

commit c64a0926710153b9d44c979d2942f4a8648fd74e
Author: Kevin Hilman <khilman@ti.com>
Date:   Wed Aug 25 12:50:00 2010 -0700

    driver core: platform_bus: allow runtime override of dev_pm_ops
    
    Currently, the platform_bus allows customization of several of the
    busses dev_pm_ops methods by using weak symbols so that platform code
    can override them.  The weak-symbol approach is not scalable when
    wanting to support multiple platforms in a single kernel binary.
    
    Instead, provide __init methods for platform code to customize the
    dev_pm_ops methods at runtime.
    
    NOTE: after these dynamic methods are merged, the weak symbols should
          be removed from drivers/base/platform.c.  AFAIK, this will only
          affect SH and sh-mobile which should be converted to use this
          runtime approach instead of the weak symbols.  After SH &
          sh-mobile are converted, the weak symobols could be removed.
    
    Tested on OMAP3.
    
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 579906f88b09..a01abf9ebf7b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -976,6 +976,41 @@ struct bus_type platform_bus_type = {
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 
+/**
+ * platform_bus_get_pm_ops() - return pointer to busses dev_pm_ops
+ *
+ * This function can be used by platform code to get the current
+ * set of dev_pm_ops functions used by the platform_bus_type.
+ */
+const struct dev_pm_ops * __init platform_bus_get_pm_ops(void)
+{
+	return platform_bus_type.pm;
+}
+
+/**
+ * platform_bus_set_pm_ops() - update dev_pm_ops for the platform_bus_type
+ *
+ * @pm: pointer to new dev_pm_ops struct to be used for platform_bus_type
+ *
+ * Platform code can override the dev_pm_ops methods of
+ * platform_bus_type by using this function.  It is expected that
+ * platform code will first do a platform_bus_get_pm_ops(), then
+ * kmemdup it, then customize selected methods and pass a pointer to
+ * the new struct dev_pm_ops to this function.
+ *
+ * Since platform-specific code is customizing methods for *all*
+ * devices (not just platform-specific devices) it is expected that
+ * any custom overrides of these functions will keep existing behavior
+ * and simply extend it.  For example, any customization of the
+ * runtime PM methods should continue to call the pm_generic_*
+ * functions as the default ones do in addition to the
+ * platform-specific behavior.
+ */
+void __init platform_bus_set_pm_ops(const struct dev_pm_ops *pm)
+{
+	platform_bus_type.pm = pm;
+}
+
 int __init platform_bus_init(void)
 {
 	int error;

commit d79d32440c33cf60f1e0efbeb8144b1647be0b50
Author: Patrick Pannuto <ppannuto@codeaurora.org>
Date:   Fri Aug 6 17:12:41 2010 -0700

    driver core: platform: Use drv->driver.bus instead of assuming platform_bus_type
    
    In theory (although not *yet* in practice), a driver being passed
    to platform_driver_probe might have driver.bus set to something
    other than platform_bus_type. Locking drv->driver.bus is always
    correct.
    
    Signed-off-by: Patrick Pannuto <ppannuto@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c6c933f58102..579906f88b09 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -488,12 +488,12 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 	 * if the probe was successful, and make sure any forced probes of
 	 * new devices fail.
 	 */
-	spin_lock(&platform_bus_type.p->klist_drivers.k_lock);
+	spin_lock(&drv->driver.bus->p->klist_drivers.k_lock);
 	drv->probe = NULL;
 	if (code == 0 && list_empty(&drv->driver.p->klist_devices.k_list))
 		retval = -ENODEV;
 	drv->driver.probe = platform_drv_probe_fail;
-	spin_unlock(&platform_bus_type.p->klist_drivers.k_lock);
+	spin_unlock(&drv->driver.bus->p->klist_drivers.k_lock);
 
 	if (code != retval)
 		platform_driver_unregister(drv);

commit 7096d0422153ffcc2264eef652fc3a7bca3e6d3c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Oct 20 11:45:13 2010 -0600

    of/device: Rework to use common platform_device_alloc() for allocating devices
    
    The current code allocates and manages platform_devices created from
    the device tree manually.  It also uses an unsafe shortcut for
    allocating the platform_device and the resource table at the same
    time. (which I added in the last rework; sorry).
    
    This patch refactors the code to use platform_device_alloc() for
    allocating new devices.  This reduces the amount of custom code
    implemented by of_platform, eliminates the unsafe alloc trick, and has
    the side benefit of letting the platform_bus code manage freeing the
    device data and resources when the device is freed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c6c933f58102..2fff59cef505 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -147,6 +147,7 @@ static void platform_device_release(struct device *dev)
 	struct platform_object *pa = container_of(dev, struct platform_object,
 						  pdev.dev);
 
+	of_device_node_put(&pa->pdev.dev);
 	kfree(pa->pdev.dev.platform_data);
 	kfree(pa->pdev.resource);
 	kfree(pa);

commit ab69bcd66fb4be64edfc767365cb9eb084961246
Merge: c513b67e6878 6937e8f8c013
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 6 11:36:30 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6: (28 commits)
      driver core: device_rename's new_name can be const
      sysfs: Remove owner field from sysfs struct attribute
      powerpc/pci: Remove owner field from attribute initialization in PCI bridge init
      regulator: Remove owner field from attribute initialization in regulator core driver
      leds: Remove owner field from attribute initialization in bd2802 driver
      scsi: Remove owner field from attribute initialization in ARCMSR driver
      scsi: Remove owner field from attribute initialization in LPFC driver
      cgroupfs: create /sys/fs/cgroup to mount cgroupfs on
      Driver core: Add BUS_NOTIFY_BIND_DRIVER
      driver core: fix memory leak on one error path in bus_register()
      debugfs: no longer needs to depend on SYSFS
      sysfs: Fix one more signature discrepancy between sysfs implementation and docs.
      sysfs: fix discrepancies between implementation and documentation
      dcdbas: remove a redundant smi_data_buf_free in dcdbas_exit
      dmi-id: fix a memory leak in dmi_id_init error path
      sysfs: sysfs_chmod_file's attr can be const
      firmware: Update hotplug script
      Driver core: move platform device creation helpers to .init.text (if MODULE=n)
      Driver core: reduce duplicated code for platform_device creation
      Driver core: use kmemdup in platform_device_add_resources
      ...

commit 737a3bb9416ce2a7c7a4170852473a4fcc9c67e8
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jun 21 16:11:45 2010 +0200

    Driver core: move platform device creation helpers to .init.text (if MODULE=n)
    
    Platform devices should only be called by init code, so it should be
    possible to move creation helpers to .init.text -- at least if modules
    are disabled.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ffcfd73fe8a6..1bb8faaa443f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -357,7 +357,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  *
  * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
-struct platform_device *platform_device_register_resndata(
+struct platform_device *__init_or_module platform_device_register_resndata(
 		struct device *parent,
 		const char *name, int id,
 		const struct resource *res, unsigned int num,

commit 44f28bdea09415d40b4d73a7668db5961362ec53
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jun 21 16:11:44 2010 +0200

    Driver core: reduce duplicated code for platform_device creation
    
    This makes the two similar functions platform_device_register_simple
    and platform_device_register_data one line inline functions using a new
    generic function platform_device_register_resndata.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 26eb69d88eb6..ffcfd73fe8a6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -344,108 +344,56 @@ void platform_device_unregister(struct platform_device *pdev)
 EXPORT_SYMBOL_GPL(platform_device_unregister);
 
 /**
- * platform_device_register_simple - add a platform-level device and its resources
- * @name: base name of the device we're adding
- * @id: instance id
- * @res: set of resources that needs to be allocated for the device
- * @num: number of resources
- *
- * This function creates a simple platform device that requires minimal
- * resource and memory management. Canned release function freeing memory
- * allocated for the device allows drivers using such devices to be
- * unloaded without waiting for the last reference to the device to be
- * dropped.
+ * platform_device_register_resndata - add a platform-level device with
+ * resources and platform-specific data
  *
- * This interface is primarily intended for use with legacy drivers which
- * probe hardware directly.  Because such drivers create sysfs device nodes
- * themselves, rather than letting system infrastructure handle such device
- * enumeration tasks, they don't fully conform to the Linux driver model.
- * In particular, when such drivers are built as modules, they can't be
- * "hotplugged".
- *
- * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
- */
-struct platform_device *platform_device_register_simple(const char *name,
-							int id,
-							const struct resource *res,
-							unsigned int num)
-{
-	struct platform_device *pdev;
-	int retval;
-
-	pdev = platform_device_alloc(name, id);
-	if (!pdev) {
-		retval = -ENOMEM;
-		goto error;
-	}
-
-	if (num) {
-		retval = platform_device_add_resources(pdev, res, num);
-		if (retval)
-			goto error;
-	}
-
-	retval = platform_device_add(pdev);
-	if (retval)
-		goto error;
-
-	return pdev;
-
-error:
-	platform_device_put(pdev);
-	return ERR_PTR(retval);
-}
-EXPORT_SYMBOL_GPL(platform_device_register_simple);
-
-/**
- * platform_device_register_data - add a platform-level device with platform-specific data
  * @parent: parent device for the device we're adding
  * @name: base name of the device we're adding
  * @id: instance id
+ * @res: set of resources that needs to be allocated for the device
+ * @num: number of resources
  * @data: platform specific data for this platform device
  * @size: size of platform specific data
  *
- * This function creates a simple platform device that requires minimal
- * resource and memory management. Canned release function freeing memory
- * allocated for the device allows drivers using such devices to be
- * unloaded without waiting for the last reference to the device to be
- * dropped.
- *
  * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
-struct platform_device *platform_device_register_data(
+struct platform_device *platform_device_register_resndata(
 		struct device *parent,
 		const char *name, int id,
+		const struct resource *res, unsigned int num,
 		const void *data, size_t size)
 {
+	int ret = -ENOMEM;
 	struct platform_device *pdev;
-	int retval;
 
 	pdev = platform_device_alloc(name, id);
-	if (!pdev) {
-		retval = -ENOMEM;
-		goto error;
-	}
+	if (!pdev)
+		goto err;
 
 	pdev->dev.parent = parent;
 
-	if (size) {
-		retval = platform_device_add_data(pdev, data, size);
-		if (retval)
-			goto error;
+	if (res) {
+		ret = platform_device_add_resources(pdev, res, num);
+		if (ret)
+			goto err;
 	}
 
-	retval = platform_device_add(pdev);
-	if (retval)
-		goto error;
+	if (data) {
+		ret = platform_device_add_data(pdev, data, size);
+		if (ret)
+			goto err;
+	}
 
-	return pdev;
+	ret = platform_device_add(pdev);
+	if (ret) {
+err:
+		platform_device_put(pdev);
+		return ERR_PTR(ret);
+	}
 
-error:
-	platform_device_put(pdev);
-	return ERR_PTR(retval);
+	return pdev;
 }
-EXPORT_SYMBOL_GPL(platform_device_register_data);
+EXPORT_SYMBOL_GPL(platform_device_register_resndata);
 
 static int platform_drv_probe(struct device *_dev)
 {

commit 3e61dfd8509a52d165726831c57b4c8a015d626c
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Jun 15 10:47:55 2010 +0200

    Driver core: use kmemdup in platform_device_add_resources
    
    This makes platform_device_add_resources look like
    platform_device_add_data.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4d99c8bdfedc..26eb69d88eb6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -191,13 +191,13 @@ int platform_device_add_resources(struct platform_device *pdev,
 {
 	struct resource *r;
 
-	r = kmalloc(sizeof(struct resource) * num, GFP_KERNEL);
+	r = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);
 	if (r) {
-		memcpy(r, res, sizeof(struct resource) * num);
 		pdev->resource = r;
 		pdev->num_resources = num;
+		return 0;
 	}
-	return r ? 0 : -ENOMEM;
+	return -ENOMEM;
 }
 EXPORT_SYMBOL_GPL(platform_device_add_resources);
 

commit eca3930163ba8884060ce9d9ff5ef0d9b7c7b00f
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jun 8 07:48:21 2010 -0600

    of: Merge of_platform_bus_type with platform_bus_type
    
    of_platform_bus was being used in the same manner as the platform_bus.
    The only difference being that of_platform_bus devices are generated
    from data in the device tree, and platform_bus devices are usually
    statically allocated in platform code.  Having them separate causes
    the problem of device drivers having to be registered twice if it
    was possible for the same device to appear on either bus.
    
    This patch removes of_platform_bus_type and registers all of_platform
    bus devices and drivers on the platform bus instead.  A previous patch
    made the of_device structure an alias for the platform_device structure,
    and a shim is used to adapt of_platform_drivers to the platform bus.
    
    After all of of_platform_bus drivers are converted to be normal platform
    drivers, the shim code can be removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index fac3633c7223..f699fabf403b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -636,6 +636,12 @@ static struct device_attribute platform_dev_attrs[] = {
 static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
+	int rc;
+
+	/* Some devices have extra OF data and an OF-style MODALIAS */
+	rc = of_device_uevent(dev,env);
+	if (rc != -ENODEV)
+		return rc;
 
 	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
 		(pdev->id_entry) ? pdev->id_entry->name : pdev->name);

commit 05212157e94ccf4cf458413bbba509cfa95ff92b
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jun 8 07:48:20 2010 -0600

    drivercore/of: Add OF style matching to platform bus
    
    As part of the merge between platform bus and of_platform bus, add the
    ability to do of-style matching to the platform bus.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Grant Likely <grant.likely@secretlab.ca>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: Stephen Rothwell <sfr@canb.auug.org.au>
    CC: linux-kernel@vger.kernel.org
    CC: microblaze-uclinux@itee.uq.edu.au
    CC: linuxppc-dev@ozlabs.org
    CC: devicetree-discuss@lists.ozlabs.org

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4d99c8bdfedc..fac3633c7223 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -12,6 +12,7 @@
 
 #include <linux/string.h>
 #include <linux/platform_device.h>
+#include <linux/of_device.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
@@ -673,7 +674,11 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct platform_driver *pdrv = to_platform_driver(drv);
 
-	/* match against the id table first */
+	/* Attempt an OF style match first */
+	if (of_driver_match_device(dev, drv))
+		return 1;
+
+	/* Then try to match against the id table */
 	if (pdrv->id_table)
 		return platform_match_id(pdrv->id_table, pdev) != NULL;
 

commit 190e8370b8033f746db5289e9324174564a6f5a7
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Mar 17 16:18:15 2010 -0700

    platform_bus: allow custom extensions to system PM methods
    
    When runtime PM for platform_bus was added, it allowed for platforms
    to customize the runtime PM methods since they are defined as weak
    symbols.
    
    This patch allows platforms to also extend the system PM methods with
    custom hooks so runtime PM and system PM extensions can be managed
    together by custom platform-specific code.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Magnus Damm <damm@opensource.se>
    Cc: Rafael Wysocki <rjw@sisk.pl>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ada6397c23a5..4d99c8bdfedc 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -735,7 +735,7 @@ static void platform_pm_complete(struct device *dev)
 
 #ifdef CONFIG_SUSPEND
 
-static int platform_pm_suspend(struct device *dev)
+int __weak platform_pm_suspend(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -753,7 +753,7 @@ static int platform_pm_suspend(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_suspend_noirq(struct device *dev)
+int __weak platform_pm_suspend_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -769,7 +769,7 @@ static int platform_pm_suspend_noirq(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_resume(struct device *dev)
+int __weak platform_pm_resume(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
@@ -787,7 +787,7 @@ static int platform_pm_resume(struct device *dev)
 	return ret;
 }
 
-static int platform_pm_resume_noirq(struct device *dev)
+int __weak platform_pm_resume_noirq(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 	int ret = 0;

commit 46ee9645094ad1eb5b4888882ecaa1fb87dcd2a3
Merge: fa5312d9e87e 25f3a5a2854d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 20 09:03:55 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6:
      PM: PM QOS update fix
      Freezer / cgroup freezer: Update stale locking comments
      PM / platform_bus: Allow runtime PM by default
      i2c: Fix bus-level power management callbacks
      PM QOS update
      PM / Hibernate: Fix block_io.c printk warning
      PM / Hibernate: Group swap ops
      PM / Hibernate: Move the first_sector out of swsusp_write
      PM / Hibernate: Separate block_io
      PM / Hibernate: Snapshot cleanup
      FS / libfs: Implement simple_write_to_buffer
      PM / Hibernate: document open(/dev/snapshot) side effects
      PM / Runtime: Add sysfs debug files
      PM: Improve device power management document
      PM: Update device power management document
      PM: Allow runtime_suspend methods to call pm_schedule_suspend()
      PM: pm_wakeup - switch to using bool

commit 7c7cbaf5b82c418cd3b1dcf718f71d0e6057e639
Merge: ba0234ec3512 4d0956b8f597
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 19 11:36:03 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6: (127 commits)
      sh: update defconfigs.
      sh: Fix up the NUMA build for recent LMB changes.
      sh64: provide a stub per_cpu_trap_init() definition.
      sh: fix up CONFIG_KEXEC=n build.
      sh: fixup the docbook paths for clock framework shuffling.
      driver core: Early dev_name() depends on slab_is_available().
      sh: simplify WARN usage in SH clock driver
      sh: Check return value of clk_get on ms7724
      sh: Check return value of clk_get on ecovec24
      sh: move sh clock-cpg.c contents to drivers/sh/clk-cpg.c
      sh: move sh clock.c contents to drivers/sh/clk.
      sh: move sh asm/clock.h contents to linux/sh_clk.h V2
      sh: remove unused clock lookup
      sh: switch boards to clkdev
      sh: switch sh4-202 to clkdev
      sh: switch shx3 to clkdev
      sh: switch sh7757 to clkdev
      sh: switch sh7763 to clkdev
      sh: switch sh7780 to clkdev
      sh: switch sh7786 to clkdev
      ...

commit 0b7f1a7efb38b551f5948a13d0b36e876ba536db
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jan 28 21:01:02 2009 +0100

    platform: Make platform resource input parameters const
    
    Make the platform resource input parameters of platform_device_add_resources()
    and platform_device_register_simple() const, as the resources are copied and
    never modified.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4b4b565c835f..c5fbe198fbdb 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -187,7 +187,7 @@ EXPORT_SYMBOL_GPL(platform_device_alloc);
  * released.
  */
 int platform_device_add_resources(struct platform_device *pdev,
-				  struct resource *res, unsigned int num)
+				  const struct resource *res, unsigned int num)
 {
 	struct resource *r;
 
@@ -367,7 +367,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  */
 struct platform_device *platform_device_register_simple(const char *name,
 							int id,
-							struct resource *res,
+							const struct resource *res,
 							unsigned int num)
 {
 	struct platform_device *pdev;

commit b9e3fc29c08a6dcbe19606cfba19c1fcc0551ed7
Merge: 209791b2cc3c 06fe53beb636
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu May 13 18:02:28 2010 +0900

    Merge branch 'sh/driver-core'

commit 06fe53beb636294587d8e94ef83c06cef07c21fd
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu May 13 17:56:56 2010 +0900

    driver core: Early dev_name() depends on slab_is_available().
    
    The early dev_name() setup needs to do an allocation which can only be
    satisfied under slab_is_available() conditions. Some of the early
    platform drivers may be initialized before this point, and those still
    need to contend themselves with an empty dev_name.
    
    This fixes up a regression with the SH earlyprintk which was bailing out
    prior to hitting the early probe path due to not being able to satisfy
    the early allocation. Other early platform drivers (such as the early
    timers) that need to match the dev name are sufficiently late that
    allocations are already possible.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f2377f3d95e5..ef51b0083840 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1244,7 +1244,7 @@ static int __init early_platform_driver_probe_id(char *class_str,
 			 * dev_name() and others to be used before the
 			 * rest of the driver core is initialized.
 			 */
-			if (!match->dev.init_name) {
+			if (!match->dev.init_name && slab_is_available()) {
 				if (match->id != -1)
 					match->dev.init_name =
 						kasprintf(GFP_KERNEL, "%s.%d",

commit 543f2503a956601dd490c6cde0ebf6adb4653e50
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 10 23:10:13 2010 +0200

    PM / platform_bus: Allow runtime PM by default
    
    Currently the default runtime PM callbacks for platform devices return
    -ENOSYS, preventing the use of runtime PM platforms until they have
    provided at least a default implementation. This hinders the use of
    runtime PM by devices which work with many platforms such as memory
    mapped devices, MFDs and on chip IPs shared by multiple architectures.
    
    Change the default implementation to the standard pm_generic_runtime
    one, allowing drivers to use runtime PM without per-architecture
    changes.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4b4b565c835f..a6c07797c88e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -967,17 +967,17 @@ static int platform_pm_restore_noirq(struct device *dev)
 
 int __weak platform_pm_runtime_suspend(struct device *dev)
 {
-	return -ENOSYS;
+	return pm_generic_runtime_suspend(dev);
 };
 
 int __weak platform_pm_runtime_resume(struct device *dev)
 {
-	return -ENOSYS;
+	return pm_generic_runtime_resume(dev);
 };
 
 int __weak platform_pm_runtime_idle(struct device *dev)
 {
-	return -ENOSYS;
+	return pm_generic_runtime_idle(dev);
 };
 
 #else /* !CONFIG_PM_RUNTIME */

commit 720fcb36ac1aa2df2c54c170253b6b29600cbefc
Merge: 6ae6650232dd dec710b77c2c 3089f381fbaf f4cff0d0ffc0
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 30 11:26:43 2010 +0900

    Merge branches 'sh/intc-extension', 'sh/dmaengine', 'sh/serial-dma' and 'sh/clkfwk'
    
    Conflicts:
            arch/sh/kernel/cpu/clock.c
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit bd05086bbe3f241cd552068f9ceba9e19c6ce427
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Mar 29 15:51:35 2010 +0900

    driver core: Convert to kasprintf() for early dev_name().
    
    This is just a simple refactoring patch on top of the early dev_name()
    support, converting from kstrdup() to kasprintf() as suggested by Kay.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d2d4926c5c4c..f2377f3d95e5 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1245,19 +1245,20 @@ static int __init early_platform_driver_probe_id(char *class_str,
 			 * rest of the driver core is initialized.
 			 */
 			if (!match->dev.init_name) {
-				char buf[32];
-
 				if (match->id != -1)
-					snprintf(buf, sizeof(buf), "%s.%d",
-						 match->name, match->id);
+					match->dev.init_name =
+						kasprintf(GFP_KERNEL, "%s.%d",
+							  match->name,
+							  match->id);
 				else
-					snprintf(buf, sizeof(buf), "%s",
-						 match->name);
+					match->dev.init_name =
+						kasprintf(GFP_KERNEL, "%s",
+							  match->name);
 
-				match->dev.init_name = kstrdup(buf, GFP_KERNEL);
 				if (!match->dev.init_name)
 					return -ENOMEM;
 			}
+
 			if (epdrv->pdrv->probe(match))
 				pr_warning("%s: unable to probe %s early.\n",
 					   class_str, match->name);

commit f0eae0ed3b7d4182a6b4dd03540a738518ea3163
Author: Jani Nikula <ext-jani.1.nikula@nokia.com>
Date:   Thu Mar 11 18:11:45 2010 +0200

    driver-core: document ERR_PTR() return values
    
    A number of functions in the driver core return ERR_PTR() values on
    error. Document this in the kernel-doc of the functions.
    
    Signed-off-by: Jani Nikula <ext-jani.1.nikula@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f6bcf22e6bd1..4b4b565c835f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -362,6 +362,8 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  * enumeration tasks, they don't fully conform to the Linux driver model.
  * In particular, when such drivers are built as modules, they can't be
  * "hotplugged".
+ *
+ * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
 struct platform_device *platform_device_register_simple(const char *name,
 							int id,
@@ -408,6 +410,8 @@ EXPORT_SYMBOL_GPL(platform_device_register_simple);
  * allocated for the device allows drivers using such devices to be
  * unloaded without waiting for the last reference to the device to be
  * dropped.
+ *
+ * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
 struct platform_device *platform_device_register_data(
 		struct device *parent,
@@ -559,6 +563,8 @@ EXPORT_SYMBOL_GPL(platform_driver_probe);
  *
  * Use this in legacy-style modules that probe hardware directly and
  * register a single platform device and corresponding platform driver.
+ *
+ * Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  */
 struct platform_device * __init_or_module platform_create_bundle(
 			struct platform_driver *driver,

commit 4d26e139f0b7d4c0700d6993506f1f60e2f2caa5
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Mar 10 20:50:38 2010 +0900

    Driver core: Early platform kernel-doc update
    
    This patch updates the kernel-doc notation for early
    platform functions.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1ba9d617d241..f6bcf22e6bd1 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1052,9 +1052,11 @@ static __initdata LIST_HEAD(early_platform_driver_list);
 static __initdata LIST_HEAD(early_platform_device_list);
 
 /**
- * early_platform_driver_register
+ * early_platform_driver_register - register early platform driver
  * @epdrv: early_platform driver structure
  * @buf: string passed from early_param()
+ *
+ * Helper function for early_platform_init() / early_platform_init_buffer()
  */
 int __init early_platform_driver_register(struct early_platform_driver *epdrv,
 					  char *buf)
@@ -1106,9 +1108,12 @@ int __init early_platform_driver_register(struct early_platform_driver *epdrv,
 }
 
 /**
- * early_platform_add_devices - add a numbers of early platform devices
+ * early_platform_add_devices - adds a number of early platform devices
  * @devs: array of early platform devices to add
  * @num: number of early platform devices in array
+ *
+ * Used by early architecture code to register early platform devices and
+ * their platform data.
  */
 void __init early_platform_add_devices(struct platform_device **devs, int num)
 {
@@ -1128,8 +1133,12 @@ void __init early_platform_add_devices(struct platform_device **devs, int num)
 }
 
 /**
- * early_platform_driver_register_all
+ * early_platform_driver_register_all - register early platform drivers
  * @class_str: string to identify early platform driver class
+ *
+ * Used by architecture code to register all early platform drivers
+ * for a certain class. If omitted then only early platform drivers
+ * with matching kernel command line class parameters will be registered.
  */
 void __init early_platform_driver_register_all(char *class_str)
 {
@@ -1151,7 +1160,7 @@ void __init early_platform_driver_register_all(char *class_str)
 }
 
 /**
- * early_platform_match
+ * early_platform_match - find early platform device matching driver
  * @epdrv: early platform driver structure
  * @id: id to match against
  */
@@ -1169,7 +1178,7 @@ early_platform_match(struct early_platform_driver *epdrv, int id)
 }
 
 /**
- * early_platform_left
+ * early_platform_left - check if early platform driver has matching devices
  * @epdrv: early platform driver structure
  * @id: return true if id or above exists
  */
@@ -1187,7 +1196,7 @@ static  __init int early_platform_left(struct early_platform_driver *epdrv,
 }
 
 /**
- * early_platform_driver_probe_id
+ * early_platform_driver_probe_id - probe drivers matching class_str and id
  * @class_str: string to identify early platform driver class
  * @id: id to match against
  * @nr_probe: number of platform devices to successfully probe before exiting
@@ -1257,10 +1266,14 @@ static int __init early_platform_driver_probe_id(char *class_str,
 }
 
 /**
- * early_platform_driver_probe
+ * early_platform_driver_probe - probe a class of registered drivers
  * @class_str: string to identify early platform driver class
  * @nr_probe: number of platform devices to successfully probe before exiting
  * @user_only: only probe user specified early platform devices
+ *
+ * Used by architecture code to probe registered early platform drivers
+ * within a certain class. For probe to happen a registered early platform
+ * device matching a registered early platform driver is needed.
  */
 int __init early_platform_driver_probe(char *class_str,
 				       int nr_probe,

commit a636ee7fb35b731ba2b331f6294e809bb6be09c8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 9 06:57:53 2010 +0000

    driver core: Early dev_name() support.
    
    Presently early platform devices suffer from the fact they are unable to
    use dev_xxx() calls early on due to dev_name() and others being
    unavailable at the time ->probe() is called.
    
    This implements early init_name construction from the matched name/id
    pair following the semantics of the late device/driver match. As a
    result, matched IDs (inclusive of requested ones) are preserved when the
    handoff from the early platform code happens at kobject initialization
    time.
    
    Since we still require kmalloc slabs to be available at this point, using
    kstrdup() for establishing the init_name works fine. This subsequently
    needs to be tested from dev_name() prior to the init_name being cleared
    by the driver core. We don't kfree() since others will already have a
    handle on the string long before the kobject initialization takes place.
    
    This is also needed to permit drivers to use the clock framework early,
    without having to manually construct their own device IDs from the match
    id/name pair locally (needed by the early console and timer code on sh
    and arm).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1ba9d617d241..d2d4926c5c4c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1239,6 +1239,25 @@ static int __init early_platform_driver_probe_id(char *class_str,
 		}
 
 		if (match) {
+			/*
+			 * Set up a sensible init_name to enable
+			 * dev_name() and others to be used before the
+			 * rest of the driver core is initialized.
+			 */
+			if (!match->dev.init_name) {
+				char buf[32];
+
+				if (match->id != -1)
+					snprintf(buf, sizeof(buf), "%s.%d",
+						 match->name, match->id);
+				else
+					snprintf(buf, sizeof(buf), "%s",
+						 match->name);
+
+				match->dev.init_name = kstrdup(buf, GFP_KERNEL);
+				if (!match->dev.init_name)
+					return -ENOMEM;
+			}
 			if (epdrv->pdrv->probe(match))
 				pr_warning("%s: unable to probe %s early.\n",
 					   class_str, match->name);

commit 3c31f07ad0dab02fe17195d32a965d57fd947707
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Feb 14 14:18:53 2010 +0000

    Driver core: Fix first line of kernel-doc for a few functions
    
    The function name must be followed by a space, hypen, space, and a
    short description.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 575e08bc6630..1ba9d617d241 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -128,7 +128,7 @@ struct platform_object {
 };
 
 /**
- * platform_device_put
+ * platform_device_put - destroy a platform device
  * @pdev: platform device to free
  *
  * Free all memory associated with a platform device.  This function must
@@ -152,7 +152,7 @@ static void platform_device_release(struct device *dev)
 }
 
 /**
- * platform_device_alloc
+ * platform_device_alloc - create a platform device
  * @name: base name of the device we're adding
  * @id: instance id
  *
@@ -177,7 +177,7 @@ struct platform_device *platform_device_alloc(const char *name, int id)
 EXPORT_SYMBOL_GPL(platform_device_alloc);
 
 /**
- * platform_device_add_resources
+ * platform_device_add_resources - add resources to a platform device
  * @pdev: platform device allocated by platform_device_alloc to add resources to
  * @res: set of resources that needs to be allocated for the device
  * @num: number of resources
@@ -202,7 +202,7 @@ int platform_device_add_resources(struct platform_device *pdev,
 EXPORT_SYMBOL_GPL(platform_device_add_resources);
 
 /**
- * platform_device_add_data
+ * platform_device_add_data - add platform-specific data to a platform device
  * @pdev: platform device allocated by platform_device_alloc to add resources to
  * @data: platform specific data for this platform device
  * @size: size of platform specific data
@@ -344,7 +344,7 @@ void platform_device_unregister(struct platform_device *pdev)
 EXPORT_SYMBOL_GPL(platform_device_unregister);
 
 /**
- * platform_device_register_simple
+ * platform_device_register_simple - add a platform-level device and its resources
  * @name: base name of the device we're adding
  * @id: instance id
  * @res: set of resources that needs to be allocated for the device
@@ -396,7 +396,7 @@ struct platform_device *platform_device_register_simple(const char *name,
 EXPORT_SYMBOL_GPL(platform_device_register_simple);
 
 /**
- * platform_device_register_data
+ * platform_device_register_data - add a platform-level device with platform-specific data
  * @parent: parent device for the device we're adding
  * @name: base name of the device we're adding
  * @id: instance id
@@ -473,7 +473,7 @@ static void platform_drv_shutdown(struct device *_dev)
 }
 
 /**
- * platform_driver_register
+ * platform_driver_register - register a driver for platform-level devices
  * @drv: platform driver structure
  */
 int platform_driver_register(struct platform_driver *drv)
@@ -491,7 +491,7 @@ int platform_driver_register(struct platform_driver *drv)
 EXPORT_SYMBOL_GPL(platform_driver_register);
 
 /**
- * platform_driver_unregister
+ * platform_driver_unregister - unregister a driver for platform-level devices
  * @drv: platform driver structure
  */
 void platform_driver_unregister(struct platform_driver *drv)

commit 831fad2f75f0d7bfc339de81173e7068a3c72276
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Jan 26 09:35:00 2010 +0100

    Driver core: make struct platform_driver.id_table const
    
    This fixes a warning on several pxa based machines:
    
            arch/arm/mach-pxa/ssp.c:475: warning: initialization discards qualifiers from pointer target type
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Vikram Dhillon <dhillonv10@gmail.com>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 937d58021d1b..575e08bc6630 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -636,7 +636,7 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 }
 
 static const struct platform_device_id *platform_match_id(
-			struct platform_device_id *id,
+			const struct platform_device_id *id,
 			struct platform_device *pdev)
 {
 	while (id->name[0]) {

commit ecdf6ceb8cf4756bd4214bf9755755752b6015f5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Dec 29 20:11:20 2009 -0800

    Driver core: add platform_create_bundle() helper
    
    Many legacy-style module create singleton platform devices themselves,
    along with corresponding platform driver. Instead of replicating error
    handling code in all such drivers, provide a helper that allocates and
    registers a single platform device and a driver and binds them together.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 58efaf2f1259..937d58021d1b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -548,6 +548,64 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 }
 EXPORT_SYMBOL_GPL(platform_driver_probe);
 
+/**
+ * platform_create_bundle - register driver and create corresponding device
+ * @driver: platform driver structure
+ * @probe: the driver probe routine, probably from an __init section
+ * @res: set of resources that needs to be allocated for the device
+ * @n_res: number of resources
+ * @data: platform specific data for this platform device
+ * @size: size of platform specific data
+ *
+ * Use this in legacy-style modules that probe hardware directly and
+ * register a single platform device and corresponding platform driver.
+ */
+struct platform_device * __init_or_module platform_create_bundle(
+			struct platform_driver *driver,
+			int (*probe)(struct platform_device *),
+			struct resource *res, unsigned int n_res,
+			const void *data, size_t size)
+{
+	struct platform_device *pdev;
+	int error;
+
+	pdev = platform_device_alloc(driver->driver.name, -1);
+	if (!pdev) {
+		error = -ENOMEM;
+		goto err_out;
+	}
+
+	if (res) {
+		error = platform_device_add_resources(pdev, res, n_res);
+		if (error)
+			goto err_pdev_put;
+	}
+
+	if (data) {
+		error = platform_device_add_data(pdev, data, size);
+		if (error)
+			goto err_pdev_put;
+	}
+
+	error = platform_device_add(pdev);
+	if (error)
+		goto err_pdev_put;
+
+	error = platform_driver_probe(driver, probe);
+	if (error)
+		goto err_pdev_del;
+
+	return pdev;
+
+err_pdev_del:
+	platform_device_del(pdev);
+err_pdev_put:
+	platform_device_put(pdev);
+err_out:
+	return ERR_PTR(error);
+}
+EXPORT_SYMBOL_GPL(platform_create_bundle);
+
 /* modalias support enables more hands-off userspace setup:
  * (a) environment variable lets new-style hotplug events work once system is
  *     fully running:  "modprobe $MODALIAS"

commit 0787fdf70ba4c41a3350096ebaa347a17e900385
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon Dec 21 11:41:08 2009 -0500

    Driver core: export platform_device_register_data as a GPL symbol
    
    This allows MFD's to register/bind drivers for their sub devices while
    still being compiled as a module.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9d2ee25deaf5..58efaf2f1259 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -441,6 +441,7 @@ struct platform_device *platform_device_register_data(
 	platform_device_put(pdev);
 	return ERR_PTR(retval);
 }
+EXPORT_SYMBOL_GPL(platform_device_register_data);
 
 static int platform_drv_probe(struct device *_dev)
 {

commit c60e0504c8e4fa14179d0687d80ef25148dd6dd4
Author: Magnus Damm <damm@opensource.se>
Date:   Fri Nov 27 17:38:51 2009 +0900

    Driver Core: Early platform driver buffer
    
    Add early_platform_init_buffer() support and update the
    early platform driver code to allow passing parameters
    to the driver on the kernel command line.
    
    early_platform_init_buffer() simply allows early platform
    drivers to provide a pointer and length to a memory area
    where the remaining part of the kernel command line option
    will be stored.
    
    Needed to pass baud rate and other serial port options
    to the reworked early serial console code on SuperH.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 4fa954b07ac4..9d2ee25deaf5 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1000,7 +1000,7 @@ static __initdata LIST_HEAD(early_platform_device_list);
 int __init early_platform_driver_register(struct early_platform_driver *epdrv,
 					  char *buf)
 {
-	unsigned long index;
+	char *tmp;
 	int n;
 
 	/* Simply add the driver to the end of the global list.
@@ -1019,13 +1019,28 @@ int __init early_platform_driver_register(struct early_platform_driver *epdrv,
 	if (buf && !strncmp(buf, epdrv->pdrv->driver.name, n)) {
 		list_move(&epdrv->list, &early_platform_driver_list);
 
-		if (!strcmp(buf, epdrv->pdrv->driver.name))
+		/* Allow passing parameters after device name */
+		if (buf[n] == '\0' || buf[n] == ',')
 			epdrv->requested_id = -1;
-		else if (buf[n] == '.' && strict_strtoul(&buf[n + 1], 10,
-							 &index) == 0)
-			epdrv->requested_id = index;
-		else
-			epdrv->requested_id = EARLY_PLATFORM_ID_ERROR;
+		else {
+			epdrv->requested_id = simple_strtoul(&buf[n + 1],
+							     &tmp, 10);
+
+			if (buf[n] != '.' || (tmp == &buf[n + 1])) {
+				epdrv->requested_id = EARLY_PLATFORM_ID_ERROR;
+				n = 0;
+			} else
+				n += strcspn(&buf[n + 1], ",") + 1;
+		}
+
+		if (buf[n] == ',')
+			n++;
+
+		if (epdrv->bufsize) {
+			memcpy(epdrv->buffer, &buf[n],
+			       min_t(int, epdrv->bufsize, strlen(&buf[n]) + 1));
+			epdrv->buffer[epdrv->bufsize - 1] = '\0';
+		}
 	}
 
 	return 0;

commit 1a6f2a7512021ceae3c4201c7aab07f032e9ce91
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Oct 12 20:17:41 2009 -0700

    Driver core: allow certain drivers prohibit bind/unbind via sysfs
    
    Platform drivers registered via platform_driver_probe() can be bound
    to devices only once, upon registration, because discard their probe()
    routines to save memory. Unbinding the driver through sysfs 'unbind'
    leaves the device stranded and confuses users so let's not create
    bind and unbind attributes for such drivers.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Éric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ed156a13aa40..4fa954b07ac4 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -521,11 +521,15 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 {
 	int retval, code;
 
+	/* make sure driver won't have bind/unbind attributes */
+	drv->driver.suppress_bind_attrs = true;
+
 	/* temporary section violation during probe() */
 	drv->probe = probe;
 	retval = code = platform_driver_register(drv);
 
-	/* Fixup that section violation, being paranoid about code scanning
+	/*
+	 * Fixup that section violation, being paranoid about code scanning
 	 * the list of drivers in order to probe new devices.  Check to see
 	 * if the probe was successful, and make sure any forced probes of
 	 * new devices fail.

commit daa4122673f002911122cac2b996bd36b6c01b32
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Aug 6 16:00:44 2009 -0700

    driver core: platform_device_add_data(): use kmemdup()
    
    Instead of open-coding it.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 0f7d434ce983..ed156a13aa40 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -10,6 +10,7 @@
  * information.
  */
 
+#include <linux/string.h>
 #include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -213,14 +214,13 @@ EXPORT_SYMBOL_GPL(platform_device_add_resources);
 int platform_device_add_data(struct platform_device *pdev, const void *data,
 			     size_t size)
 {
-	void *d;
+	void *d = kmemdup(data, size, GFP_KERNEL);
 
-	d = kmalloc(size, GFP_KERNEL);
 	if (d) {
-		memcpy(d, data, size);
 		pdev->dev.platform_data = d;
+		return 0;
 	}
-	return d ? 0 : -ENOMEM;
+	return -ENOMEM;
 }
 EXPORT_SYMBOL_GPL(platform_device_add_data);
 

commit 9d7302299ee96ca954fe4ab8ca640333b6e19ad0
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Aug 20 20:25:32 2009 +0200

    PM: Run-time PM platform device bus support
    
    This patch adds default Runtime PM callbacks to the dev_pm_ops
    belonging to the platform bus. The callbacks are weak symbols
    that architecture specific code can override.
    
    Allows Runtime PM even though CONFIG_PM_SLEEP=n.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d28c289e4a3f..0f7d434ce983 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -17,6 +17,7 @@
 #include <linux/bootmem.h>
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/pm_runtime.h>
 
 #include "base.h"
 
@@ -656,6 +657,13 @@ static void platform_pm_complete(struct device *dev)
 		drv->pm->complete(dev);
 }
 
+#else /* !CONFIG_PM_SLEEP */
+
+#define platform_pm_prepare		NULL
+#define platform_pm_complete		NULL
+
+#endif /* !CONFIG_PM_SLEEP */
+
 #ifdef CONFIG_SUSPEND
 
 static int platform_pm_suspend(struct device *dev)
@@ -886,6 +894,31 @@ static int platform_pm_restore_noirq(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATION */
 
+#ifdef CONFIG_PM_RUNTIME
+
+int __weak platform_pm_runtime_suspend(struct device *dev)
+{
+	return -ENOSYS;
+};
+
+int __weak platform_pm_runtime_resume(struct device *dev)
+{
+	return -ENOSYS;
+};
+
+int __weak platform_pm_runtime_idle(struct device *dev)
+{
+	return -ENOSYS;
+};
+
+#else /* !CONFIG_PM_RUNTIME */
+
+#define platform_pm_runtime_suspend NULL
+#define platform_pm_runtime_resume NULL
+#define platform_pm_runtime_idle NULL
+
+#endif /* !CONFIG_PM_RUNTIME */
+
 static const struct dev_pm_ops platform_dev_pm_ops = {
 	.prepare = platform_pm_prepare,
 	.complete = platform_pm_complete,
@@ -901,22 +934,17 @@ static const struct dev_pm_ops platform_dev_pm_ops = {
 	.thaw_noirq = platform_pm_thaw_noirq,
 	.poweroff_noirq = platform_pm_poweroff_noirq,
 	.restore_noirq = platform_pm_restore_noirq,
+	.runtime_suspend = platform_pm_runtime_suspend,
+	.runtime_resume = platform_pm_runtime_resume,
+	.runtime_idle = platform_pm_runtime_idle,
 };
 
-#define PLATFORM_PM_OPS_PTR	(&platform_dev_pm_ops)
-
-#else /* !CONFIG_PM_SLEEP */
-
-#define PLATFORM_PM_OPS_PTR	NULL
-
-#endif /* !CONFIG_PM_SLEEP */
-
 struct bus_type platform_bus_type = {
 	.name		= "platform",
 	.dev_attrs	= platform_dev_attrs,
 	.match		= platform_match,
 	.uevent		= platform_uevent,
-	.pm		= PLATFORM_PM_OPS_PTR,
+	.pm		= &platform_dev_pm_ops,
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 

commit 3e2bcad89814030ad6a369a97ad1481fd35938d3
Merge: dcbf77cac640 b2add73dbf93
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Aug 16 11:50:10 2009 +0200

    Merge branch 'master' into for-linus

commit 651b1f125c7e3806bbd635739d009433dc07372d
Author: Magnus Damm <damm@igel.co.jp>
Date:   Mon Aug 10 23:41:18 2009 +0200

    PM / Driver Core: Kill dev_pm_ops platform warning for now
    
    Commit 783ea7d4eeefe895f2731fe73ac951e94418927b
    (Driver Core: Rework platform suspend/resume, print warning)
    added a warning message printed for platform drivers that use the
    legacy PM callbacks rather than struct dev_pm_ops.  Unfortunately,
    this resulted in some confusion and made some people try to convert
    drivers by replacing the old callbacks with struct dev_pm_ops in
    automatic way, which generally is not a good idea.
    
    Remove the platform device runtime dev_pm_ops warning for now,
    because it's annoying to users and it's not really necessary right
    now.
    
    [rjw: Modified the changelog to be more informative.]
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 81cb01bfc356..456594bd97bc 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -483,9 +483,6 @@ int platform_driver_register(struct platform_driver *drv)
 		drv->driver.remove = platform_drv_remove;
 	if (drv->shutdown)
 		drv->driver.shutdown = platform_drv_shutdown;
-	if (drv->suspend || drv->resume)
-		pr_warning("Platform driver '%s' needs updating - please use "
-			"dev_pm_ops\n", drv->driver.name);
 
 	return driver_register(&drv->driver);
 }

commit d9ab77161d811ffb0bccf396f7155cc905c1b9e1
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Jul 22 00:37:25 2009 +0200

    Driver Core: Make PM operations a const pointer
    
    They are not supposed to be modified by drivers, so make them const.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 455e55971d0e..ae5c4aa6d269 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -889,7 +889,7 @@ static int platform_pm_restore_noirq(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATION */
 
-static struct dev_pm_ops platform_dev_pm_ops = {
+static const struct dev_pm_ops platform_dev_pm_ops = {
 	.prepare = platform_pm_prepare,
 	.complete = platform_pm_complete,
 	.suspend = platform_pm_suspend,

commit 511647ff58fd0f1c1f415d2c757d841650edac91
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Jul 8 13:23:07 2009 +0200

    PM: Remove platform device suspend_late()/resume_early() V2
    
    This is V2 of the platform driver power management late/early
    callback removal patch. The callbacks ->suspend_late() and
    ->resume_early() are removed since all in-tree users now have
    been migrated to dev_pm_ops.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 81cb01bfc356..455e55971d0e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -628,30 +628,6 @@ static int platform_legacy_suspend(struct device *dev, pm_message_t mesg)
 	return ret;
 }
 
-static int platform_legacy_suspend_late(struct device *dev, pm_message_t mesg)
-{
-	struct platform_driver *pdrv = to_platform_driver(dev->driver);
-	struct platform_device *pdev = to_platform_device(dev);
-	int ret = 0;
-
-	if (dev->driver && pdrv->suspend_late)
-		ret = pdrv->suspend_late(pdev, mesg);
-
-	return ret;
-}
-
-static int platform_legacy_resume_early(struct device *dev)
-{
-	struct platform_driver *pdrv = to_platform_driver(dev->driver);
-	struct platform_device *pdev = to_platform_device(dev);
-	int ret = 0;
-
-	if (dev->driver && pdrv->resume_early)
-		ret = pdrv->resume_early(pdev);
-
-	return ret;
-}
-
 static int platform_legacy_resume(struct device *dev)
 {
 	struct platform_driver *pdrv = to_platform_driver(dev->driver);
@@ -714,8 +690,6 @@ static int platform_pm_suspend_noirq(struct device *dev)
 	if (drv->pm) {
 		if (drv->pm->suspend_noirq)
 			ret = drv->pm->suspend_noirq(dev);
-	} else {
-		ret = platform_legacy_suspend_late(dev, PMSG_SUSPEND);
 	}
 
 	return ret;
@@ -750,8 +724,6 @@ static int platform_pm_resume_noirq(struct device *dev)
 	if (drv->pm) {
 		if (drv->pm->resume_noirq)
 			ret = drv->pm->resume_noirq(dev);
-	} else {
-		ret = platform_legacy_resume_early(dev);
 	}
 
 	return ret;
@@ -797,8 +769,6 @@ static int platform_pm_freeze_noirq(struct device *dev)
 	if (drv->pm) {
 		if (drv->pm->freeze_noirq)
 			ret = drv->pm->freeze_noirq(dev);
-	} else {
-		ret = platform_legacy_suspend_late(dev, PMSG_FREEZE);
 	}
 
 	return ret;
@@ -833,8 +803,6 @@ static int platform_pm_thaw_noirq(struct device *dev)
 	if (drv->pm) {
 		if (drv->pm->thaw_noirq)
 			ret = drv->pm->thaw_noirq(dev);
-	} else {
-		ret = platform_legacy_resume_early(dev);
 	}
 
 	return ret;
@@ -869,8 +837,6 @@ static int platform_pm_poweroff_noirq(struct device *dev)
 	if (drv->pm) {
 		if (drv->pm->poweroff_noirq)
 			ret = drv->pm->poweroff_noirq(dev);
-	} else {
-		ret = platform_legacy_suspend_late(dev, PMSG_HIBERNATE);
 	}
 
 	return ret;
@@ -905,8 +871,6 @@ static int platform_pm_restore_noirq(struct device *dev)
 	if (drv->pm) {
 		if (drv->pm->restore_noirq)
 			ret = drv->pm->restore_noirq(dev);
-	} else {
-		ret = platform_legacy_resume_early(dev);
 	}
 
 	return ret;

commit acc0e90fbccbc6e4d48184cba0983ea044e131af
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 2 15:39:55 2009 -0700

    driver core: fix gcc 4.3.3 warnings about string literals
    
    This removes the
            warning: format not a string literal and no format arguments
    warnings in the driver core that gcc 4.3.3 complains about.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 59df6290951b..81cb01bfc356 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -245,7 +245,7 @@ int platform_device_add(struct platform_device *pdev)
 	if (pdev->id != -1)
 		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
 	else
-		dev_set_name(&pdev->dev, pdev->name);
+		dev_set_name(&pdev->dev, "%s", pdev->name);
 
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];

commit c0afe7ba5e71d8ab66bc42f90b3e237581d3c509
Author: Linus Walleij <linus.ml.walleij@gmail.com>
Date:   Mon Apr 27 02:38:16 2009 +0200

    driver core: Const-correct platform getbyname functions
    
    This converts resource and IRQ getbyname functions for the platform
    bus to use const char *, I ran into compiler moanings when I tried
    using a const char * for looking up a certain resource.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ead3f64c41d0..59df6290951b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -69,7 +69,8 @@ EXPORT_SYMBOL_GPL(platform_get_irq);
  * @name: resource name
  */
 struct resource *platform_get_resource_byname(struct platform_device *dev,
-					      unsigned int type, char *name)
+					      unsigned int type,
+					      const char *name)
 {
 	int i;
 
@@ -88,7 +89,7 @@ EXPORT_SYMBOL_GPL(platform_get_resource_byname);
  * @dev: platform device
  * @name: IRQ name
  */
-int platform_get_irq_byname(struct platform_device *dev, char *name)
+int platform_get_irq_byname(struct platform_device *dev, const char *name)
 {
 	struct resource *r = platform_get_resource_byname(dev, IORESOURCE_IRQ,
 							  name);

commit 783ea7d4eeefe895f2731fe73ac951e94418927b
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Jun 4 22:13:33 2009 +0200

    Driver Core: Rework platform suspend/resume, print warning
    
    This patch reworks the platform driver code for legacy
    suspend and resume to avoid installing callbacks in
    struct device_driver. A warning is also added telling
    users to update the platform driver to use dev_pm_ops.
    
    The functions platform_legacy_suspend()/resume() directly
    call suspend and resume callbacks in struct platform_driver
    instead of wrapping things in platform_drv_suspend()/resume().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8b4708e06244..ead3f64c41d0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -469,22 +469,6 @@ static void platform_drv_shutdown(struct device *_dev)
 	drv->shutdown(dev);
 }
 
-static int platform_drv_suspend(struct device *_dev, pm_message_t state)
-{
-	struct platform_driver *drv = to_platform_driver(_dev->driver);
-	struct platform_device *dev = to_platform_device(_dev);
-
-	return drv->suspend(dev, state);
-}
-
-static int platform_drv_resume(struct device *_dev)
-{
-	struct platform_driver *drv = to_platform_driver(_dev->driver);
-	struct platform_device *dev = to_platform_device(_dev);
-
-	return drv->resume(dev);
-}
-
 /**
  * platform_driver_register
  * @drv: platform driver structure
@@ -498,10 +482,10 @@ int platform_driver_register(struct platform_driver *drv)
 		drv->driver.remove = platform_drv_remove;
 	if (drv->shutdown)
 		drv->driver.shutdown = platform_drv_shutdown;
-	if (drv->suspend)
-		drv->driver.suspend = platform_drv_suspend;
-	if (drv->resume)
-		drv->driver.resume = platform_drv_resume;
+	if (drv->suspend || drv->resume)
+		pr_warning("Platform driver '%s' needs updating - please use "
+			"dev_pm_ops\n", drv->driver.name);
+
 	return driver_register(&drv->driver);
 }
 EXPORT_SYMBOL_GPL(platform_driver_register);
@@ -633,10 +617,12 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 
 static int platform_legacy_suspend(struct device *dev, pm_message_t mesg)
 {
+	struct platform_driver *pdrv = to_platform_driver(dev->driver);
+	struct platform_device *pdev = to_platform_device(dev);
 	int ret = 0;
 
-	if (dev->driver && dev->driver->suspend)
-		ret = dev->driver->suspend(dev, mesg);
+	if (dev->driver && pdrv->suspend)
+		ret = pdrv->suspend(pdev, mesg);
 
 	return ret;
 }
@@ -667,10 +653,12 @@ static int platform_legacy_resume_early(struct device *dev)
 
 static int platform_legacy_resume(struct device *dev)
 {
+	struct platform_driver *pdrv = to_platform_driver(dev->driver);
+	struct platform_device *pdev = to_platform_device(dev);
 	int ret = 0;
 
-	if (dev->driver && dev->driver->resume)
-		ret = dev->driver->resume(dev);
+	if (dev->driver && pdrv->resume)
+		ret = pdrv->resume(pdev);
 
 	return ret;
 }

commit e67c85626cd02e306da1b4195bfaf68d61050796
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sun Mar 8 23:13:32 2009 +0800

    Revert driver core: move platform_data into platform_device
    
    This reverts commit 006f4571a15fae3a0575f2a0f9e9b63b3d1012f8:
    
            This patch moves platform_data from struct device into
            struct platform_device, based on the two ideas:
    
            1. Now all platform_driver is registered by platform_driver_register,
               which makes probe()/release()/... of platform_driver passed parameter
               of platform_device *, so platform driver can get platform_data from
               platform_device;
    
            2. Other kind of devices do not need to use platform_data, we can
               decrease size of device if moving it to platform_device.
    
            Taking into consideration of thousands of files to be fixed and they
            can't be finished in one night(maybe it will take a long time), so we
            keep platform_data in device to allow two kind of cases coexist until
            all platform devices pass its platfrom data from
            platform_device->platform_data.
    
            All patches to do this kind of conversion are welcome.
    
    As we don't really want to do it, it was a bad idea.
    
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d1d0ee431926..8b4708e06244 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -217,7 +217,6 @@ int platform_device_add_data(struct platform_device *pdev, const void *data,
 	if (d) {
 		memcpy(d, data, size);
 		pdev->dev.platform_data = d;
-		pdev->platform_data = d;
 	}
 	return d ? 0 : -ENOMEM;
 }
@@ -247,8 +246,6 @@ int platform_device_add(struct platform_device *pdev)
 	else
 		dev_set_name(&pdev->dev, pdev->name);
 
-	pdev->platform_data = pdev->dev.platform_data;
-
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];
 

commit bee86321b7b2312fbb62f4cb903eba1cca45e8ad
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Fri Mar 13 23:06:59 2009 +0800

    Revert driver core: fix passing platform_data
    
    This reverts commit ce21c7bcd796fc4f45d48781b7e85f493cc55ee5:
            We will remove platform_data field from struct device until
            all platform devices pass its specific data from platfom_device
            and all platform drivers use platform specific data passed by
            platform_device->platform_data. This kind of conversion will
            need a long time, for thousands of files is affected.
    
            To make the conversion easily, we allow platform specific data
            passed by struct device or struct platform_device and platform
            driver may use it from struct device or struct platform_device.
    
    As we really don't want to do this at all.
    
    
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ec5400c32021..d1d0ee431926 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -247,20 +247,7 @@ int platform_device_add(struct platform_device *pdev)
 	else
 		dev_set_name(&pdev->dev, pdev->name);
 
-	/* We will remove platform_data field from struct device
-	* if all platform devices pass its platform specific data
-	* from platform_device. The conversion is going to be a
-	* long time, so we allow the two cases coexist to make
-	* this kind of fix more easily*/
-	if (pdev->platform_data && pdev->dev.platform_data) {
-		printk(KERN_ERR
-			       "%s: use which platform_data?\n",
-			       dev_name(&pdev->dev));
-	} else if (pdev->platform_data) {
-		pdev->dev.platform_data = pdev->platform_data;
-	} else if (pdev->dev.platform_data) {
-		pdev->platform_data = pdev->dev.platform_data;
-	}
+	pdev->platform_data = pdev->dev.platform_data;
 
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];

commit d86c1302c58e4d4ebd99d459c2daff13613ac7f4
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Apr 21 07:22:53 2009 -0700

    Driver core: platform: fix kernel-doc warnings
    
    Fix function parameter notation in platform.c;
    fixes kernel-doc warnings.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index b5b6c973a2e0..ec5400c32021 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1028,7 +1028,7 @@ static __initdata LIST_HEAD(early_platform_device_list);
 
 /**
  * early_platform_driver_register
- * @edrv: early_platform driver structure
+ * @epdrv: early_platform driver structure
  * @buf: string passed from early_param()
  */
 int __init early_platform_driver_register(struct early_platform_driver *epdrv,
@@ -1112,7 +1112,7 @@ void __init early_platform_driver_register_all(char *class_str)
 
 /**
  * early_platform_match
- * @edrv: early platform driver structure
+ * @epdrv: early platform driver structure
  * @id: id to match against
  */
 static  __init struct platform_device *
@@ -1130,7 +1130,7 @@ early_platform_match(struct early_platform_driver *epdrv, int id)
 
 /**
  * early_platform_left
- * @edrv: early platform driver structure
+ * @epdrv: early platform driver structure
  * @id: return true if id or above exists
  */
 static  __init int early_platform_left(struct early_platform_driver *epdrv,

commit 13977091a988fb0d21821c2221ddc920eba36b79
Author: Magnus Damm <damm@igel.co.jp>
Date:   Mon Mar 30 14:37:25 2009 -0700

    Driver Core: early platform driver
    
    V3 of the early platform driver implementation.
    
    Platform drivers are great for embedded platforms because we can separate
    driver configuration from the actual driver.  So base addresses,
    interrupts and other configuration can be kept with the processor or board
    code, and the platform driver can be reused by many different platforms.
    
    For early devices we have nothing today.  For instance, to configure early
    timers and early serial ports we cannot use platform devices.  This
    because the setup order during boot.  Timers are needed before the
    platform driver core code is available.  The same goes for early printk
    support.  Early in this case means before initcalls.
    
    These early drivers today have their configuration either hard coded or
    they receive it using some special configuration method.  This is working
    quite well, but if we want to support both regular kernel modules and
    early devices then we need to have two ways of configuring the same
    driver.  A single way would be better.
    
    The early platform driver patch is basically a set of functions that allow
    drivers to register themselves and architecture code to locate them and
    probe.  Registration happens through early_param().  The time for the
    probe is decided by the architecture code.
    
    See Documentation/driver-model/platform.txt for more details.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d2198f64ad4e..b5b6c973a2e0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -990,6 +990,8 @@ int __init platform_bus_init(void)
 {
 	int error;
 
+	early_platform_cleanup();
+
 	error = device_register(&platform_bus);
 	if (error)
 		return error;
@@ -1020,3 +1022,240 @@ u64 dma_get_required_mask(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(dma_get_required_mask);
 #endif
+
+static __initdata LIST_HEAD(early_platform_driver_list);
+static __initdata LIST_HEAD(early_platform_device_list);
+
+/**
+ * early_platform_driver_register
+ * @edrv: early_platform driver structure
+ * @buf: string passed from early_param()
+ */
+int __init early_platform_driver_register(struct early_platform_driver *epdrv,
+					  char *buf)
+{
+	unsigned long index;
+	int n;
+
+	/* Simply add the driver to the end of the global list.
+	 * Drivers will by default be put on the list in compiled-in order.
+	 */
+	if (!epdrv->list.next) {
+		INIT_LIST_HEAD(&epdrv->list);
+		list_add_tail(&epdrv->list, &early_platform_driver_list);
+	}
+
+	/* If the user has specified device then make sure the driver
+	 * gets prioritized. The driver of the last device specified on
+	 * command line will be put first on the list.
+	 */
+	n = strlen(epdrv->pdrv->driver.name);
+	if (buf && !strncmp(buf, epdrv->pdrv->driver.name, n)) {
+		list_move(&epdrv->list, &early_platform_driver_list);
+
+		if (!strcmp(buf, epdrv->pdrv->driver.name))
+			epdrv->requested_id = -1;
+		else if (buf[n] == '.' && strict_strtoul(&buf[n + 1], 10,
+							 &index) == 0)
+			epdrv->requested_id = index;
+		else
+			epdrv->requested_id = EARLY_PLATFORM_ID_ERROR;
+	}
+
+	return 0;
+}
+
+/**
+ * early_platform_add_devices - add a numbers of early platform devices
+ * @devs: array of early platform devices to add
+ * @num: number of early platform devices in array
+ */
+void __init early_platform_add_devices(struct platform_device **devs, int num)
+{
+	struct device *dev;
+	int i;
+
+	/* simply add the devices to list */
+	for (i = 0; i < num; i++) {
+		dev = &devs[i]->dev;
+
+		if (!dev->devres_head.next) {
+			INIT_LIST_HEAD(&dev->devres_head);
+			list_add_tail(&dev->devres_head,
+				      &early_platform_device_list);
+		}
+	}
+}
+
+/**
+ * early_platform_driver_register_all
+ * @class_str: string to identify early platform driver class
+ */
+void __init early_platform_driver_register_all(char *class_str)
+{
+	/* The "class_str" parameter may or may not be present on the kernel
+	 * command line. If it is present then there may be more than one
+	 * matching parameter.
+	 *
+	 * Since we register our early platform drivers using early_param()
+	 * we need to make sure that they also get registered in the case
+	 * when the parameter is missing from the kernel command line.
+	 *
+	 * We use parse_early_options() to make sure the early_param() gets
+	 * called at least once. The early_param() may be called more than
+	 * once since the name of the preferred device may be specified on
+	 * the kernel command line. early_platform_driver_register() handles
+	 * this case for us.
+	 */
+	parse_early_options(class_str);
+}
+
+/**
+ * early_platform_match
+ * @edrv: early platform driver structure
+ * @id: id to match against
+ */
+static  __init struct platform_device *
+early_platform_match(struct early_platform_driver *epdrv, int id)
+{
+	struct platform_device *pd;
+
+	list_for_each_entry(pd, &early_platform_device_list, dev.devres_head)
+		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
+			if (pd->id == id)
+				return pd;
+
+	return NULL;
+}
+
+/**
+ * early_platform_left
+ * @edrv: early platform driver structure
+ * @id: return true if id or above exists
+ */
+static  __init int early_platform_left(struct early_platform_driver *epdrv,
+				       int id)
+{
+	struct platform_device *pd;
+
+	list_for_each_entry(pd, &early_platform_device_list, dev.devres_head)
+		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
+			if (pd->id >= id)
+				return 1;
+
+	return 0;
+}
+
+/**
+ * early_platform_driver_probe_id
+ * @class_str: string to identify early platform driver class
+ * @id: id to match against
+ * @nr_probe: number of platform devices to successfully probe before exiting
+ */
+static int __init early_platform_driver_probe_id(char *class_str,
+						 int id,
+						 int nr_probe)
+{
+	struct early_platform_driver *epdrv;
+	struct platform_device *match;
+	int match_id;
+	int n = 0;
+	int left = 0;
+
+	list_for_each_entry(epdrv, &early_platform_driver_list, list) {
+		/* only use drivers matching our class_str */
+		if (strcmp(class_str, epdrv->class_str))
+			continue;
+
+		if (id == -2) {
+			match_id = epdrv->requested_id;
+			left = 1;
+
+		} else {
+			match_id = id;
+			left += early_platform_left(epdrv, id);
+
+			/* skip requested id */
+			switch (epdrv->requested_id) {
+			case EARLY_PLATFORM_ID_ERROR:
+			case EARLY_PLATFORM_ID_UNSET:
+				break;
+			default:
+				if (epdrv->requested_id == id)
+					match_id = EARLY_PLATFORM_ID_UNSET;
+			}
+		}
+
+		switch (match_id) {
+		case EARLY_PLATFORM_ID_ERROR:
+			pr_warning("%s: unable to parse %s parameter\n",
+				   class_str, epdrv->pdrv->driver.name);
+			/* fall-through */
+		case EARLY_PLATFORM_ID_UNSET:
+			match = NULL;
+			break;
+		default:
+			match = early_platform_match(epdrv, match_id);
+		}
+
+		if (match) {
+			if (epdrv->pdrv->probe(match))
+				pr_warning("%s: unable to probe %s early.\n",
+					   class_str, match->name);
+			else
+				n++;
+		}
+
+		if (n >= nr_probe)
+			break;
+	}
+
+	if (left)
+		return n;
+	else
+		return -ENODEV;
+}
+
+/**
+ * early_platform_driver_probe
+ * @class_str: string to identify early platform driver class
+ * @nr_probe: number of platform devices to successfully probe before exiting
+ * @user_only: only probe user specified early platform devices
+ */
+int __init early_platform_driver_probe(char *class_str,
+				       int nr_probe,
+				       int user_only)
+{
+	int k, n, i;
+
+	n = 0;
+	for (i = -2; n < nr_probe; i++) {
+		k = early_platform_driver_probe_id(class_str, i, nr_probe - n);
+
+		if (k < 0)
+			break;
+
+		n += k;
+
+		if (user_only)
+			break;
+	}
+
+	return n;
+}
+
+/**
+ * early_platform_cleanup - clean up early platform code
+ */
+void __init early_platform_cleanup(void)
+{
+	struct platform_device *pd, *pd2;
+
+	/* clean up the devres list used to chain devices */
+	list_for_each_entry_safe(pd, pd2, &early_platform_device_list,
+				 dev.devres_head) {
+		list_del(&pd->dev.devres_head);
+		memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
+	}
+}
+

commit ce21c7bcd796fc4f45d48781b7e85f493cc55ee5
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Fri Mar 13 23:06:59 2009 +0800

    driver core: fix passing platform_data
    
    We will remove platform_data field from struct device until
    all platform devices pass its specific data from platfom_device
    and all platform drivers use platform specific data passed by
    platform_device->platform_data. This kind of conversion will
    need a long time, for thousands of files is affected.
    
    To make the conversion easily, we allow platform specific data
    passed by struct device or struct platform_device and platform
    driver may use it from struct device or struct platform_device.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index c5ac81d22303..d2198f64ad4e 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -247,7 +247,20 @@ int platform_device_add(struct platform_device *pdev)
 	else
 		dev_set_name(&pdev->dev, pdev->name);
 
-	pdev->platform_data = pdev->dev.platform_data;
+	/* We will remove platform_data field from struct device
+	* if all platform devices pass its platform specific data
+	* from platform_device. The conversion is going to be a
+	* long time, so we allow the two cases coexist to make
+	* this kind of fix more easily*/
+	if (pdev->platform_data && pdev->dev.platform_data) {
+		printk(KERN_ERR
+			       "%s: use which platform_data?\n",
+			       dev_name(&pdev->dev));
+	} else if (pdev->platform_data) {
+		pdev->dev.platform_data = pdev->platform_data;
+	} else if (pdev->dev.platform_data) {
+		pdev->platform_data = pdev->dev.platform_data;
+	}
 
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];

commit 006f4571a15fae3a0575f2a0f9e9b63b3d1012f8
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sun Mar 8 23:13:32 2009 +0800

    driver core: move platform_data into platform_device
    
    This patch moves platform_data from struct device into
    struct platform_device, based on the two ideas:
    
    1. Now all platform_driver is registered by platform_driver_register,
       which makes probe()/release()/... of platform_driver passed parameter
       of platform_device *, so platform driver can get platform_data from
       platform_device;
    
    2. Other kind of devices do not need to use platform_data, we can
       decrease size of device if moving it to platform_device.
    
    Taking into consideration of thousands of files to be fixed and they
    can't be finished in one night(maybe it will take a long time), so we
    keep platform_data in device to allow two kind of cases coexist until
    all platform devices pass its platfrom data from
    platform_device->platform_data.
    
    All patches to do this kind of conversion are welcome.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index ec993aa6a2ca..c5ac81d22303 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -217,6 +217,7 @@ int platform_device_add_data(struct platform_device *pdev, const void *data,
 	if (d) {
 		memcpy(d, data, size);
 		pdev->dev.platform_data = d;
+		pdev->platform_data = d;
 	}
 	return d ? 0 : -ENOMEM;
 }
@@ -246,6 +247,8 @@ int platform_device_add(struct platform_device *pdev)
 	else
 		dev_set_name(&pdev->dev, pdev->name);
 
+	pdev->platform_data = pdev->dev.platform_data;
+
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];
 

commit 57fee4a58fe802272742caae248872c392a60670
Author: Eric Miao <eric.miao@marvell.com>
Date:   Wed Feb 4 11:52:40 2009 +0800

    platform: introduce module id table for platform devices
    
    Now platform_device is being widely used on SoC processors where the
    peripherals are attached to the system bus, which is simple enough.
    
    However, silicon IPs for these SoCs are usually shared heavily across
    a family of processors, even products from different companies.  This
    makes the original simple driver name based matching insufficient, or
    simply not straight-forward.
    
    Introduce a module id table for platform devices, and makes it clear
    that a platform driver is able to support some shared IP and handle
    slight differences across different platforms (by 'driver_data').
    Module alias is handled automatically when a MODULE_DEVICE_TABLE()
    is defined.
    
    To not disturb the current platform drivers too much, the matched id
    entry is recorded and can be retrieved by platform_get_device_id().
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 62a8768d96b3..ec993aa6a2ca 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -584,10 +584,25 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
 
-	add_uevent_var(env, "MODALIAS=platform:%s", pdev->name);
+	add_uevent_var(env, "MODALIAS=%s%s", PLATFORM_MODULE_PREFIX,
+		(pdev->id_entry) ? pdev->id_entry->name : pdev->name);
 	return 0;
 }
 
+static const struct platform_device_id *platform_match_id(
+			struct platform_device_id *id,
+			struct platform_device *pdev)
+{
+	while (id->name[0]) {
+		if (strcmp(pdev->name, id->name) == 0) {
+			pdev->id_entry = id;
+			return id;
+		}
+		id++;
+	}
+	return NULL;
+}
+
 /**
  * platform_match - bind platform device to platform driver.
  * @dev: device.
@@ -604,7 +619,13 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 static int platform_match(struct device *dev, struct device_driver *drv)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	struct platform_driver *pdrv = to_platform_driver(drv);
+
+	/* match against the id table first */
+	if (pdrv->id_table)
+		return platform_match_id(pdrv->id_table, pdev) != NULL;
 
+	/* fall-back to driver name match */
 	return (strcmp(pdev->name, drv->name) == 0);
 }
 

commit 71b3e0c1ad90f28e34c105069175cbd4edb43dfa
Author: Eric Miao <eric.miao@marvell.com>
Date:   Sat Jan 31 22:47:44 2009 +0800

    platform: make better use of to_platform_{device,driver}() macros
    
    This helps the code look more consistent and cleaner.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 349a1013603f..62a8768d96b3 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -603,9 +603,8 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
  */
 static int platform_match(struct device *dev, struct device_driver *drv)
 {
-	struct platform_device *pdev;
+	struct platform_device *pdev = to_platform_device(dev);
 
-	pdev = container_of(dev, struct platform_device, dev);
 	return (strcmp(pdev->name, drv->name) == 0);
 }
 
@@ -623,26 +622,24 @@ static int platform_legacy_suspend(struct device *dev, pm_message_t mesg)
 
 static int platform_legacy_suspend_late(struct device *dev, pm_message_t mesg)
 {
-	struct platform_driver *drv = to_platform_driver(dev->driver);
-	struct platform_device *pdev;
+	struct platform_driver *pdrv = to_platform_driver(dev->driver);
+	struct platform_device *pdev = to_platform_device(dev);
 	int ret = 0;
 
-	pdev = container_of(dev, struct platform_device, dev);
-	if (dev->driver && drv->suspend_late)
-		ret = drv->suspend_late(pdev, mesg);
+	if (dev->driver && pdrv->suspend_late)
+		ret = pdrv->suspend_late(pdev, mesg);
 
 	return ret;
 }
 
 static int platform_legacy_resume_early(struct device *dev)
 {
-	struct platform_driver *drv = to_platform_driver(dev->driver);
-	struct platform_device *pdev;
+	struct platform_driver *pdrv = to_platform_driver(dev->driver);
+	struct platform_device *pdev = to_platform_device(dev);
 	int ret = 0;
 
-	pdev = container_of(dev, struct platform_device, dev);
-	if (dev->driver && drv->resume_early)
-		ret = drv->resume_early(pdev);
+	if (dev->driver && pdrv->resume_early)
+		ret = pdrv->resume_early(pdev);
 
 	return ret;
 }

commit 1e0b2cf933ebf32494eba3f668859ba57f06a951
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:36:48 2008 +0100

    driver core: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 6c743b6008d9..349a1013603f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -24,7 +24,7 @@
 				 driver))
 
 struct device platform_bus = {
-	.bus_id		= "platform",
+	.init_name	= "platform",
 };
 EXPORT_SYMBOL_GPL(platform_bus);
 
@@ -242,16 +242,15 @@ int platform_device_add(struct platform_device *pdev)
 	pdev->dev.bus = &platform_bus_type;
 
 	if (pdev->id != -1)
-		snprintf(pdev->dev.bus_id, BUS_ID_SIZE, "%s.%d", pdev->name,
-			 pdev->id);
+		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
 	else
-		strlcpy(pdev->dev.bus_id, pdev->name, BUS_ID_SIZE);
+		dev_set_name(&pdev->dev, pdev->name);
 
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];
 
 		if (r->name == NULL)
-			r->name = pdev->dev.bus_id;
+			r->name = dev_name(&pdev->dev);
 
 		p = r->parent;
 		if (!p) {
@@ -264,14 +263,14 @@ int platform_device_add(struct platform_device *pdev)
 		if (p && insert_resource(p, r)) {
 			printk(KERN_ERR
 			       "%s: failed to claim resource %d\n",
-			       pdev->dev.bus_id, i);
+			       dev_name(&pdev->dev), i);
 			ret = -EBUSY;
 			goto failed;
 		}
 	}
 
 	pr_debug("Registering platform device '%s'. Parent at %s\n",
-		 pdev->dev.bus_id, pdev->dev.parent->bus_id);
+		 dev_name(&pdev->dev), dev_name(pdev->dev.parent));
 
 	ret = device_add(&pdev->dev);
 	if (ret == 0)
@@ -607,7 +606,7 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 	struct platform_device *pdev;
 
 	pdev = container_of(dev, struct platform_device, dev);
-	return (strncmp(pdev->name, drv->name, BUS_ID_SIZE) == 0);
+	return (strcmp(pdev->name, drv->name) == 0);
 }
 
 #ifdef CONFIG_PM_SLEEP

commit adf094931ffb25ef4b381559918f1a34181a5273
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 6 22:46:05 2008 +0200

    PM: Simplify the new suspend/hibernation framework for devices
    
    PM: Simplify the new suspend/hibernation framework for devices
    
    Following the discussion at the Kernel Summit, simplify the new
    device PM framework by merging 'struct pm_ops' and
    'struct pm_ext_ops' and removing pointers to 'struct pm_ext_ops'
    from 'struct platform_driver' and 'struct pci_driver'.
    
    After this change, the suspend/hibernation callbacks will only
    reside in 'struct device_driver' as well as at the bus type/
    device class/device type level.  Accordingly, PCI and platform
    device drivers are now expected to put their suspend/hibernation
    callbacks into the 'struct device_driver' embedded in
    'struct pci_driver' or 'struct platform_driver', respectively.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index dfcbfe504867..6c743b6008d9 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -503,8 +503,6 @@ int platform_driver_register(struct platform_driver *drv)
 		drv->driver.suspend = platform_drv_suspend;
 	if (drv->resume)
 		drv->driver.resume = platform_drv_resume;
-	if (drv->pm)
-		drv->driver.pm = &drv->pm->base;
 	return driver_register(&drv->driver);
 }
 EXPORT_SYMBOL_GPL(platform_driver_register);
@@ -686,7 +684,10 @@ static int platform_pm_suspend(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (drv && drv->pm) {
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
 		if (drv->pm->suspend)
 			ret = drv->pm->suspend(dev);
 	} else {
@@ -698,16 +699,15 @@ static int platform_pm_suspend(struct device *dev)
 
 static int platform_pm_suspend_noirq(struct device *dev)
 {
-	struct platform_driver *pdrv;
+	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (!dev->driver)
+	if (!drv)
 		return 0;
 
-	pdrv = to_platform_driver(dev->driver);
-	if (pdrv->pm) {
-		if (pdrv->pm->suspend_noirq)
-			ret = pdrv->pm->suspend_noirq(dev);
+	if (drv->pm) {
+		if (drv->pm->suspend_noirq)
+			ret = drv->pm->suspend_noirq(dev);
 	} else {
 		ret = platform_legacy_suspend_late(dev, PMSG_SUSPEND);
 	}
@@ -720,7 +720,10 @@ static int platform_pm_resume(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (drv && drv->pm) {
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
 		if (drv->pm->resume)
 			ret = drv->pm->resume(dev);
 	} else {
@@ -732,16 +735,15 @@ static int platform_pm_resume(struct device *dev)
 
 static int platform_pm_resume_noirq(struct device *dev)
 {
-	struct platform_driver *pdrv;
+	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (!dev->driver)
+	if (!drv)
 		return 0;
 
-	pdrv = to_platform_driver(dev->driver);
-	if (pdrv->pm) {
-		if (pdrv->pm->resume_noirq)
-			ret = pdrv->pm->resume_noirq(dev);
+	if (drv->pm) {
+		if (drv->pm->resume_noirq)
+			ret = drv->pm->resume_noirq(dev);
 	} else {
 		ret = platform_legacy_resume_early(dev);
 	}
@@ -780,16 +782,15 @@ static int platform_pm_freeze(struct device *dev)
 
 static int platform_pm_freeze_noirq(struct device *dev)
 {
-	struct platform_driver *pdrv;
+	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (!dev->driver)
+	if (!drv)
 		return 0;
 
-	pdrv = to_platform_driver(dev->driver);
-	if (pdrv->pm) {
-		if (pdrv->pm->freeze_noirq)
-			ret = pdrv->pm->freeze_noirq(dev);
+	if (drv->pm) {
+		if (drv->pm->freeze_noirq)
+			ret = drv->pm->freeze_noirq(dev);
 	} else {
 		ret = platform_legacy_suspend_late(dev, PMSG_FREEZE);
 	}
@@ -802,7 +803,10 @@ static int platform_pm_thaw(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (drv && drv->pm) {
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
 		if (drv->pm->thaw)
 			ret = drv->pm->thaw(dev);
 	} else {
@@ -814,16 +818,15 @@ static int platform_pm_thaw(struct device *dev)
 
 static int platform_pm_thaw_noirq(struct device *dev)
 {
-	struct platform_driver *pdrv;
+	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (!dev->driver)
+	if (!drv)
 		return 0;
 
-	pdrv = to_platform_driver(dev->driver);
-	if (pdrv->pm) {
-		if (pdrv->pm->thaw_noirq)
-			ret = pdrv->pm->thaw_noirq(dev);
+	if (drv->pm) {
+		if (drv->pm->thaw_noirq)
+			ret = drv->pm->thaw_noirq(dev);
 	} else {
 		ret = platform_legacy_resume_early(dev);
 	}
@@ -836,7 +839,10 @@ static int platform_pm_poweroff(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (drv && drv->pm) {
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
 		if (drv->pm->poweroff)
 			ret = drv->pm->poweroff(dev);
 	} else {
@@ -848,16 +854,15 @@ static int platform_pm_poweroff(struct device *dev)
 
 static int platform_pm_poweroff_noirq(struct device *dev)
 {
-	struct platform_driver *pdrv;
+	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (!dev->driver)
+	if (!drv)
 		return 0;
 
-	pdrv = to_platform_driver(dev->driver);
-	if (pdrv->pm) {
-		if (pdrv->pm->poweroff_noirq)
-			ret = pdrv->pm->poweroff_noirq(dev);
+	if (drv->pm) {
+		if (drv->pm->poweroff_noirq)
+			ret = drv->pm->poweroff_noirq(dev);
 	} else {
 		ret = platform_legacy_suspend_late(dev, PMSG_HIBERNATE);
 	}
@@ -870,7 +875,10 @@ static int platform_pm_restore(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (drv && drv->pm) {
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
 		if (drv->pm->restore)
 			ret = drv->pm->restore(dev);
 	} else {
@@ -882,16 +890,15 @@ static int platform_pm_restore(struct device *dev)
 
 static int platform_pm_restore_noirq(struct device *dev)
 {
-	struct platform_driver *pdrv;
+	struct device_driver *drv = dev->driver;
 	int ret = 0;
 
-	if (!dev->driver)
+	if (!drv)
 		return 0;
 
-	pdrv = to_platform_driver(dev->driver);
-	if (pdrv->pm) {
-		if (pdrv->pm->restore_noirq)
-			ret = pdrv->pm->restore_noirq(dev);
+	if (drv->pm) {
+		if (drv->pm->restore_noirq)
+			ret = drv->pm->restore_noirq(dev);
 	} else {
 		ret = platform_legacy_resume_early(dev);
 	}
@@ -912,17 +919,15 @@ static int platform_pm_restore_noirq(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATION */
 
-static struct pm_ext_ops platform_pm_ops = {
-	.base = {
-		.prepare = platform_pm_prepare,
-		.complete = platform_pm_complete,
-		.suspend = platform_pm_suspend,
-		.resume = platform_pm_resume,
-		.freeze = platform_pm_freeze,
-		.thaw = platform_pm_thaw,
-		.poweroff = platform_pm_poweroff,
-		.restore = platform_pm_restore,
-	},
+static struct dev_pm_ops platform_dev_pm_ops = {
+	.prepare = platform_pm_prepare,
+	.complete = platform_pm_complete,
+	.suspend = platform_pm_suspend,
+	.resume = platform_pm_resume,
+	.freeze = platform_pm_freeze,
+	.thaw = platform_pm_thaw,
+	.poweroff = platform_pm_poweroff,
+	.restore = platform_pm_restore,
 	.suspend_noirq = platform_pm_suspend_noirq,
 	.resume_noirq = platform_pm_resume_noirq,
 	.freeze_noirq = platform_pm_freeze_noirq,
@@ -931,7 +936,7 @@ static struct pm_ext_ops platform_pm_ops = {
 	.restore_noirq = platform_pm_restore_noirq,
 };
 
-#define PLATFORM_PM_OPS_PTR	&platform_pm_ops
+#define PLATFORM_PM_OPS_PTR	(&platform_dev_pm_ops)
 
 #else /* !CONFIG_PM_SLEEP */
 

commit c813b4e16ead3c3df98ac84419d4df2adf33fe01
Merge: c8d8a2321f9c 02683ffdf655
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 16 12:40:26 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6: (46 commits)
      UIO: Fix mapping of logical and virtual memory
      UIO: add automata sercos3 pci card support
      UIO: Change driver name of uio_pdrv
      UIO: Add alignment warnings for uio-mem
      Driver core: add bus_sort_breadthfirst() function
      NET: convert the phy_device file to use bus_find_device_by_name
      kobject: Cleanup kobject_rename and !CONFIG_SYSFS
      kobject: Fix kobject_rename and !CONFIG_SYSFS
      sysfs: Make dir and name args to sysfs_notify() const
      platform: add new device registration helper
      sysfs: use ilookup5() instead of ilookup5_nowait()
      PNP: create device attributes via default device attributes
      Driver core: make bus_find_device_by_name() more robust
      usb: turn dev_warn+WARN_ON combos into dev_WARN
      debug: use dev_WARN() rather than WARN_ON() in device_pm_add()
      debug: Introduce a dev_WARN() function
      sysfs: fix deadlock
      device model: Do a quickcheck for driver binding before doing an expensive check
      Driver core: Fix cleanup in device_create_vargs().
      Driver core: Clarify device cleanup.
      ...

commit c9f66169f1c696f9489503d7de92daff135c1efd
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Oct 15 22:05:15 2008 -0700

    resource: add resource_type() and IORESOURCE_TYPE_BITS
    
    Add resource_type() and IORESOURCE_TYPE_BITS.  They make it easier to add
    more resource types without having to rewrite tons of code.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 3f940393d6c7..66b710c28812 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -42,10 +42,8 @@ struct resource *platform_get_resource(struct platform_device *dev,
 	for (i = 0; i < dev->num_resources; i++) {
 		struct resource *r = &dev->resource[i];
 
-		if ((r->flags & (IORESOURCE_IO|IORESOURCE_MEM|
-				 IORESOURCE_IRQ|IORESOURCE_DMA)) == type)
-			if (num-- == 0)
-				return r;
+		if (type == resource_type(r) && num-- == 0)
+			return r;
 	}
 	return NULL;
 }
@@ -78,10 +76,8 @@ struct resource *platform_get_resource_byname(struct platform_device *dev,
 	for (i = 0; i < dev->num_resources; i++) {
 		struct resource *r = &dev->resource[i];
 
-		if ((r->flags & (IORESOURCE_IO|IORESOURCE_MEM|
-				 IORESOURCE_IRQ|IORESOURCE_DMA)) == type)
-			if (!strcmp(r->name, name))
-				return r;
+		if (type == resource_type(r) && !strcmp(r->name, name))
+			return r;
 	}
 	return NULL;
 }
@@ -259,9 +255,9 @@ int platform_device_add(struct platform_device *pdev)
 
 		p = r->parent;
 		if (!p) {
-			if (r->flags & IORESOURCE_MEM)
+			if (resource_type(r) == IORESOURCE_MEM)
 				p = &iomem_resource;
-			else if (r->flags & IORESOURCE_IO)
+			else if (resource_type(r) == IORESOURCE_IO)
 				p = &ioport_resource;
 		}
 
@@ -282,9 +278,14 @@ int platform_device_add(struct platform_device *pdev)
 		return ret;
 
  failed:
-	while (--i >= 0)
-		if (pdev->resource[i].flags & (IORESOURCE_MEM|IORESOURCE_IO))
-			release_resource(&pdev->resource[i]);
+	while (--i >= 0) {
+		struct resource *r = &pdev->resource[i];
+		unsigned long type = resource_type(r);
+
+		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
+			release_resource(r);
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(platform_device_add);
@@ -306,7 +307,9 @@ void platform_device_del(struct platform_device *pdev)
 
 		for (i = 0; i < pdev->num_resources; i++) {
 			struct resource *r = &pdev->resource[i];
-			if (r->flags & (IORESOURCE_MEM|IORESOURCE_IO))
+			unsigned long type = resource_type(r);
+
+			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
 				release_resource(r);
 		}
 	}

commit d8bf254089a6c31d7d01a4d1d2f1861662900855
Author: Dmitry Baryshkov <dbaryshkov@gmail.com>
Date:   Mon Sep 22 14:41:40 2008 -0700

    platform: add new device registration helper
    
    Add a helper that registers simple platform_device w/o resources but with
    parent and device data.
    
    This is usefull to cleanup platform code from code that registers such
    simple devices as leds-gpio, generic-bl, etc.
    
    Signed-off-by: Dmitry Baryshkov <dbaryshkov@gmail.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index e621dade7eaa..9e60f7c739c6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -391,6 +391,53 @@ struct platform_device *platform_device_register_simple(const char *name,
 }
 EXPORT_SYMBOL_GPL(platform_device_register_simple);
 
+/**
+ * platform_device_register_data
+ * @parent: parent device for the device we're adding
+ * @name: base name of the device we're adding
+ * @id: instance id
+ * @data: platform specific data for this platform device
+ * @size: size of platform specific data
+ *
+ * This function creates a simple platform device that requires minimal
+ * resource and memory management. Canned release function freeing memory
+ * allocated for the device allows drivers using such devices to be
+ * unloaded without waiting for the last reference to the device to be
+ * dropped.
+ */
+struct platform_device *platform_device_register_data(
+		struct device *parent,
+		const char *name, int id,
+		const void *data, size_t size)
+{
+	struct platform_device *pdev;
+	int retval;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	pdev->dev.parent = parent;
+
+	if (size) {
+		retval = platform_device_add_data(pdev, data, size);
+		if (retval)
+			goto error;
+	}
+
+	retval = platform_device_add(pdev);
+	if (retval)
+		goto error;
+
+	return pdev;
+
+error:
+	platform_device_put(pdev);
+	return ERR_PTR(retval);
+}
+
 static int platform_drv_probe(struct device *_dev)
 {
 	struct platform_driver *drv = to_platform_driver(_dev->driver);

commit ec748fa9ed3fec44aeebbf86ae050b0cc7a978d9
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Jul 21 22:33:36 2008 +0300

    driver core: make struct platform_pm_ops static
    
    This patch makes the needlessly global struct platform_pm_ops static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 3f940393d6c7..e621dade7eaa 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -862,7 +862,7 @@ static int platform_pm_restore_noirq(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATION */
 
-struct pm_ext_ops platform_pm_ops = {
+static struct pm_ext_ops platform_pm_ops = {
 	.base = {
 		.prepare = platform_pm_prepare,
 		.complete = platform_pm_complete,

commit 25e18499e08cb097cbbfeab5de25d094d5312ee5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 21 01:40:43 2008 +0200

    Implement new suspend and hibernation callbacks for platform busses
    
    Implement new suspend and hibernation callbacks for the platform bus
    type.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg KH <greg@kroah.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 911ec600fe71..3f940393d6c7 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -453,6 +453,8 @@ int platform_driver_register(struct platform_driver *drv)
 		drv->driver.suspend = platform_drv_suspend;
 	if (drv->resume)
 		drv->driver.resume = platform_drv_resume;
+	if (drv->pm)
+		drv->driver.pm = &drv->pm->base;
 	return driver_register(&drv->driver);
 }
 EXPORT_SYMBOL_GPL(platform_driver_register);
@@ -560,7 +562,9 @@ static int platform_match(struct device *dev, struct device_driver *drv)
 	return (strncmp(pdev->name, drv->name, BUS_ID_SIZE) == 0);
 }
 
-static int platform_suspend(struct device *dev, pm_message_t mesg)
+#ifdef CONFIG_PM_SLEEP
+
+static int platform_legacy_suspend(struct device *dev, pm_message_t mesg)
 {
 	int ret = 0;
 
@@ -570,7 +574,7 @@ static int platform_suspend(struct device *dev, pm_message_t mesg)
 	return ret;
 }
 
-static int platform_suspend_late(struct device *dev, pm_message_t mesg)
+static int platform_legacy_suspend_late(struct device *dev, pm_message_t mesg)
 {
 	struct platform_driver *drv = to_platform_driver(dev->driver);
 	struct platform_device *pdev;
@@ -583,7 +587,7 @@ static int platform_suspend_late(struct device *dev, pm_message_t mesg)
 	return ret;
 }
 
-static int platform_resume_early(struct device *dev)
+static int platform_legacy_resume_early(struct device *dev)
 {
 	struct platform_driver *drv = to_platform_driver(dev->driver);
 	struct platform_device *pdev;
@@ -596,7 +600,7 @@ static int platform_resume_early(struct device *dev)
 	return ret;
 }
 
-static int platform_resume(struct device *dev)
+static int platform_legacy_resume(struct device *dev)
 {
 	int ret = 0;
 
@@ -606,15 +610,291 @@ static int platform_resume(struct device *dev)
 	return ret;
 }
 
+static int platform_pm_prepare(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm && drv->pm->prepare)
+		ret = drv->pm->prepare(dev);
+
+	return ret;
+}
+
+static void platform_pm_complete(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	if (drv && drv->pm && drv->pm->complete)
+		drv->pm->complete(dev);
+}
+
+#ifdef CONFIG_SUSPEND
+
+static int platform_pm_suspend(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->suspend)
+			ret = drv->pm->suspend(dev);
+	} else {
+		ret = platform_legacy_suspend(dev, PMSG_SUSPEND);
+	}
+
+	return ret;
+}
+
+static int platform_pm_suspend_noirq(struct device *dev)
+{
+	struct platform_driver *pdrv;
+	int ret = 0;
+
+	if (!dev->driver)
+		return 0;
+
+	pdrv = to_platform_driver(dev->driver);
+	if (pdrv->pm) {
+		if (pdrv->pm->suspend_noirq)
+			ret = pdrv->pm->suspend_noirq(dev);
+	} else {
+		ret = platform_legacy_suspend_late(dev, PMSG_SUSPEND);
+	}
+
+	return ret;
+}
+
+static int platform_pm_resume(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->resume)
+			ret = drv->pm->resume(dev);
+	} else {
+		ret = platform_legacy_resume(dev);
+	}
+
+	return ret;
+}
+
+static int platform_pm_resume_noirq(struct device *dev)
+{
+	struct platform_driver *pdrv;
+	int ret = 0;
+
+	if (!dev->driver)
+		return 0;
+
+	pdrv = to_platform_driver(dev->driver);
+	if (pdrv->pm) {
+		if (pdrv->pm->resume_noirq)
+			ret = pdrv->pm->resume_noirq(dev);
+	} else {
+		ret = platform_legacy_resume_early(dev);
+	}
+
+	return ret;
+}
+
+#else /* !CONFIG_SUSPEND */
+
+#define platform_pm_suspend		NULL
+#define platform_pm_resume		NULL
+#define platform_pm_suspend_noirq	NULL
+#define platform_pm_resume_noirq	NULL
+
+#endif /* !CONFIG_SUSPEND */
+
+#ifdef CONFIG_HIBERNATION
+
+static int platform_pm_freeze(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->freeze)
+			ret = drv->pm->freeze(dev);
+	} else {
+		ret = platform_legacy_suspend(dev, PMSG_FREEZE);
+	}
+
+	return ret;
+}
+
+static int platform_pm_freeze_noirq(struct device *dev)
+{
+	struct platform_driver *pdrv;
+	int ret = 0;
+
+	if (!dev->driver)
+		return 0;
+
+	pdrv = to_platform_driver(dev->driver);
+	if (pdrv->pm) {
+		if (pdrv->pm->freeze_noirq)
+			ret = pdrv->pm->freeze_noirq(dev);
+	} else {
+		ret = platform_legacy_suspend_late(dev, PMSG_FREEZE);
+	}
+
+	return ret;
+}
+
+static int platform_pm_thaw(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->thaw)
+			ret = drv->pm->thaw(dev);
+	} else {
+		ret = platform_legacy_resume(dev);
+	}
+
+	return ret;
+}
+
+static int platform_pm_thaw_noirq(struct device *dev)
+{
+	struct platform_driver *pdrv;
+	int ret = 0;
+
+	if (!dev->driver)
+		return 0;
+
+	pdrv = to_platform_driver(dev->driver);
+	if (pdrv->pm) {
+		if (pdrv->pm->thaw_noirq)
+			ret = pdrv->pm->thaw_noirq(dev);
+	} else {
+		ret = platform_legacy_resume_early(dev);
+	}
+
+	return ret;
+}
+
+static int platform_pm_poweroff(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->poweroff)
+			ret = drv->pm->poweroff(dev);
+	} else {
+		ret = platform_legacy_suspend(dev, PMSG_HIBERNATE);
+	}
+
+	return ret;
+}
+
+static int platform_pm_poweroff_noirq(struct device *dev)
+{
+	struct platform_driver *pdrv;
+	int ret = 0;
+
+	if (!dev->driver)
+		return 0;
+
+	pdrv = to_platform_driver(dev->driver);
+	if (pdrv->pm) {
+		if (pdrv->pm->poweroff_noirq)
+			ret = pdrv->pm->poweroff_noirq(dev);
+	} else {
+		ret = platform_legacy_suspend_late(dev, PMSG_HIBERNATE);
+	}
+
+	return ret;
+}
+
+static int platform_pm_restore(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->restore)
+			ret = drv->pm->restore(dev);
+	} else {
+		ret = platform_legacy_resume(dev);
+	}
+
+	return ret;
+}
+
+static int platform_pm_restore_noirq(struct device *dev)
+{
+	struct platform_driver *pdrv;
+	int ret = 0;
+
+	if (!dev->driver)
+		return 0;
+
+	pdrv = to_platform_driver(dev->driver);
+	if (pdrv->pm) {
+		if (pdrv->pm->restore_noirq)
+			ret = pdrv->pm->restore_noirq(dev);
+	} else {
+		ret = platform_legacy_resume_early(dev);
+	}
+
+	return ret;
+}
+
+#else /* !CONFIG_HIBERNATION */
+
+#define platform_pm_freeze		NULL
+#define platform_pm_thaw		NULL
+#define platform_pm_poweroff		NULL
+#define platform_pm_restore		NULL
+#define platform_pm_freeze_noirq	NULL
+#define platform_pm_thaw_noirq		NULL
+#define platform_pm_poweroff_noirq	NULL
+#define platform_pm_restore_noirq	NULL
+
+#endif /* !CONFIG_HIBERNATION */
+
+struct pm_ext_ops platform_pm_ops = {
+	.base = {
+		.prepare = platform_pm_prepare,
+		.complete = platform_pm_complete,
+		.suspend = platform_pm_suspend,
+		.resume = platform_pm_resume,
+		.freeze = platform_pm_freeze,
+		.thaw = platform_pm_thaw,
+		.poweroff = platform_pm_poweroff,
+		.restore = platform_pm_restore,
+	},
+	.suspend_noirq = platform_pm_suspend_noirq,
+	.resume_noirq = platform_pm_resume_noirq,
+	.freeze_noirq = platform_pm_freeze_noirq,
+	.thaw_noirq = platform_pm_thaw_noirq,
+	.poweroff_noirq = platform_pm_poweroff_noirq,
+	.restore_noirq = platform_pm_restore_noirq,
+};
+
+#define PLATFORM_PM_OPS_PTR	&platform_pm_ops
+
+#else /* !CONFIG_PM_SLEEP */
+
+#define PLATFORM_PM_OPS_PTR	NULL
+
+#endif /* !CONFIG_PM_SLEEP */
+
 struct bus_type platform_bus_type = {
 	.name		= "platform",
 	.dev_attrs	= platform_dev_attrs,
 	.match		= platform_match,
 	.uevent		= platform_uevent,
-	.suspend	= platform_suspend,
-	.suspend_late	= platform_suspend_late,
-	.resume_early	= platform_resume_early,
-	.resume		= platform_resume,
+	.pm		= PLATFORM_PM_OPS_PTR,
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 

commit e88a0c2ca81207a75afe5bbb8020541dabf606ac
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sun Mar 9 11:57:56 2008 -0500

    drivers: fix dma_get_required_mask
    
    There's a bug in the current implementation of dma_get_required_mask()
    where it ands the returned mask with the current device mask.  This
    rather defeats the purpose if you're using the call to determine what
    your mask should be (since you will at that time have the default
    DMA_32BIT_MASK).  This bug results in any driver that uses this function
    *always* getting a 32 bit mask, which is wrong.
    
    Fix by removing the and with dev->dma_mask.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index efaf282c438c..911ec600fe71 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -648,7 +648,7 @@ u64 dma_get_required_mask(struct device *dev)
 		high_totalram += high_totalram - 1;
 		mask = (((u64)high_totalram) << 32) + 0xffffffff;
 	}
-	return mask & *dev->dma_mask;
+	return mask;
 }
 EXPORT_SYMBOL_GPL(dma_get_required_mask);
 #endif

commit 4a3ad20ccd8f4d2a0535cf98fa83f7b561ba59a9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 24 22:50:12 2008 -0800

    Driver core: coding style fixes
    
    Fix up a number of coding style issues in the drivers/base/ directory
    that have annoyed me over the years.  checkpatch.pl is now very happy.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 48d5db4f92ee..efaf282c438c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -20,7 +20,8 @@
 
 #include "base.h"
 
-#define to_platform_driver(drv)	(container_of((drv), struct platform_driver, driver))
+#define to_platform_driver(drv)	(container_of((drv), struct platform_driver, \
+				 driver))
 
 struct device platform_bus = {
 	.bus_id		= "platform",
@@ -28,14 +29,13 @@ struct device platform_bus = {
 EXPORT_SYMBOL_GPL(platform_bus);
 
 /**
- *	platform_get_resource - get a resource for a device
- *	@dev: platform device
- *	@type: resource type
- *	@num: resource index
+ * platform_get_resource - get a resource for a device
+ * @dev: platform device
+ * @type: resource type
+ * @num: resource index
  */
-struct resource *
-platform_get_resource(struct platform_device *dev, unsigned int type,
-		      unsigned int num)
+struct resource *platform_get_resource(struct platform_device *dev,
+				       unsigned int type, unsigned int num)
 {
 	int i;
 
@@ -43,8 +43,7 @@ platform_get_resource(struct platform_device *dev, unsigned int type,
 		struct resource *r = &dev->resource[i];
 
 		if ((r->flags & (IORESOURCE_IO|IORESOURCE_MEM|
-				 IORESOURCE_IRQ|IORESOURCE_DMA))
-		    == type)
+				 IORESOURCE_IRQ|IORESOURCE_DMA)) == type)
 			if (num-- == 0)
 				return r;
 	}
@@ -53,9 +52,9 @@ platform_get_resource(struct platform_device *dev, unsigned int type,
 EXPORT_SYMBOL_GPL(platform_get_resource);
 
 /**
- *	platform_get_irq - get an IRQ for a device
- *	@dev: platform device
- *	@num: IRQ number index
+ * platform_get_irq - get an IRQ for a device
+ * @dev: platform device
+ * @num: IRQ number index
  */
 int platform_get_irq(struct platform_device *dev, unsigned int num)
 {
@@ -66,14 +65,13 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 EXPORT_SYMBOL_GPL(platform_get_irq);
 
 /**
- *	platform_get_resource_byname - get a resource for a device by name
- *	@dev: platform device
- *	@type: resource type
- *	@name: resource name
+ * platform_get_resource_byname - get a resource for a device by name
+ * @dev: platform device
+ * @type: resource type
+ * @name: resource name
  */
-struct resource *
-platform_get_resource_byname(struct platform_device *dev, unsigned int type,
-		      char *name)
+struct resource *platform_get_resource_byname(struct platform_device *dev,
+					      unsigned int type, char *name)
 {
 	int i;
 
@@ -90,22 +88,23 @@ platform_get_resource_byname(struct platform_device *dev, unsigned int type,
 EXPORT_SYMBOL_GPL(platform_get_resource_byname);
 
 /**
- *	platform_get_irq - get an IRQ for a device
- *	@dev: platform device
- *	@name: IRQ name
+ * platform_get_irq - get an IRQ for a device
+ * @dev: platform device
+ * @name: IRQ name
  */
 int platform_get_irq_byname(struct platform_device *dev, char *name)
 {
-	struct resource *r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);
+	struct resource *r = platform_get_resource_byname(dev, IORESOURCE_IRQ,
+							  name);
 
 	return r ? r->start : -ENXIO;
 }
 EXPORT_SYMBOL_GPL(platform_get_irq_byname);
 
 /**
- *	platform_add_devices - add a numbers of platform devices
- *	@devs: array of platform devices to add
- *	@num: number of platform devices in array
+ * platform_add_devices - add a numbers of platform devices
+ * @devs: array of platform devices to add
+ * @num: number of platform devices in array
  */
 int platform_add_devices(struct platform_device **devs, int num)
 {
@@ -130,12 +129,11 @@ struct platform_object {
 };
 
 /**
- *	platform_device_put
- *	@pdev:	platform device to free
+ * platform_device_put
+ * @pdev: platform device to free
  *
- *	Free all memory associated with a platform device.  This function
- *	must _only_ be externally called in error cases.  All other usage
- *	is a bug.
+ * Free all memory associated with a platform device.  This function must
+ * _only_ be externally called in error cases.  All other usage is a bug.
  */
 void platform_device_put(struct platform_device *pdev)
 {
@@ -146,7 +144,8 @@ EXPORT_SYMBOL_GPL(platform_device_put);
 
 static void platform_device_release(struct device *dev)
 {
-	struct platform_object *pa = container_of(dev, struct platform_object, pdev.dev);
+	struct platform_object *pa = container_of(dev, struct platform_object,
+						  pdev.dev);
 
 	kfree(pa->pdev.dev.platform_data);
 	kfree(pa->pdev.resource);
@@ -154,12 +153,12 @@ static void platform_device_release(struct device *dev)
 }
 
 /**
- *	platform_device_alloc
- *	@name:	base name of the device we're adding
- *	@id:    instance id
+ * platform_device_alloc
+ * @name: base name of the device we're adding
+ * @id: instance id
  *
- *	Create a platform device object which can have other objects attached
- *	to it, and which will have attached objects freed when it is released.
+ * Create a platform device object which can have other objects attached
+ * to it, and which will have attached objects freed when it is released.
  */
 struct platform_device *platform_device_alloc(const char *name, int id)
 {
@@ -179,16 +178,17 @@ struct platform_device *platform_device_alloc(const char *name, int id)
 EXPORT_SYMBOL_GPL(platform_device_alloc);
 
 /**
- *	platform_device_add_resources
- *	@pdev:	platform device allocated by platform_device_alloc to add resources to
- *	@res:   set of resources that needs to be allocated for the device
- *	@num:	number of resources
+ * platform_device_add_resources
+ * @pdev: platform device allocated by platform_device_alloc to add resources to
+ * @res: set of resources that needs to be allocated for the device
+ * @num: number of resources
  *
- *	Add a copy of the resources to the platform device.  The memory
- *	associated with the resources will be freed when the platform
- *	device is released.
+ * Add a copy of the resources to the platform device.  The memory
+ * associated with the resources will be freed when the platform device is
+ * released.
  */
-int platform_device_add_resources(struct platform_device *pdev, struct resource *res, unsigned int num)
+int platform_device_add_resources(struct platform_device *pdev,
+				  struct resource *res, unsigned int num)
 {
 	struct resource *r;
 
@@ -203,16 +203,17 @@ int platform_device_add_resources(struct platform_device *pdev, struct resource
 EXPORT_SYMBOL_GPL(platform_device_add_resources);
 
 /**
- *	platform_device_add_data
- *	@pdev:	platform device allocated by platform_device_alloc to add resources to
- *	@data:	platform specific data for this platform device
- *	@size:	size of platform specific data
+ * platform_device_add_data
+ * @pdev: platform device allocated by platform_device_alloc to add resources to
+ * @data: platform specific data for this platform device
+ * @size: size of platform specific data
  *
- *	Add a copy of platform specific data to the platform device's platform_data
- *	pointer.  The memory associated with the platform data will be freed
- *	when the platform device is released.
+ * Add a copy of platform specific data to the platform device's
+ * platform_data pointer.  The memory associated with the platform data
+ * will be freed when the platform device is released.
  */
-int platform_device_add_data(struct platform_device *pdev, const void *data, size_t size)
+int platform_device_add_data(struct platform_device *pdev, const void *data,
+			     size_t size)
 {
 	void *d;
 
@@ -226,11 +227,11 @@ int platform_device_add_data(struct platform_device *pdev, const void *data, siz
 EXPORT_SYMBOL_GPL(platform_device_add_data);
 
 /**
- *	platform_device_add - add a platform device to device hierarchy
- *	@pdev:	platform device we're adding
+ * platform_device_add - add a platform device to device hierarchy
+ * @pdev: platform device we're adding
  *
- *	This is part 2 of platform_device_register(), though may be called
- *	separately _iff_ pdev was allocated by platform_device_alloc().
+ * This is part 2 of platform_device_register(), though may be called
+ * separately _iff_ pdev was allocated by platform_device_alloc().
  */
 int platform_device_add(struct platform_device *pdev)
 {
@@ -289,13 +290,12 @@ int platform_device_add(struct platform_device *pdev)
 EXPORT_SYMBOL_GPL(platform_device_add);
 
 /**
- *	platform_device_del - remove a platform-level device
- *	@pdev:	platform device we're removing
+ * platform_device_del - remove a platform-level device
+ * @pdev: platform device we're removing
  *
- *	Note that this function will also release all memory- and port-based
- *	resources owned by the device (@dev->resource).  This function
- *	must _only_ be externally called in error cases.  All other usage
- *	is a bug.
+ * Note that this function will also release all memory- and port-based
+ * resources owned by the device (@dev->resource).  This function must
+ * _only_ be externally called in error cases.  All other usage is a bug.
  */
 void platform_device_del(struct platform_device *pdev)
 {
@@ -314,11 +314,10 @@ void platform_device_del(struct platform_device *pdev)
 EXPORT_SYMBOL_GPL(platform_device_del);
 
 /**
- *	platform_device_register - add a platform-level device
- *	@pdev:	platform device we're adding
- *
+ * platform_device_register - add a platform-level device
+ * @pdev: platform device we're adding
  */
-int platform_device_register(struct platform_device * pdev)
+int platform_device_register(struct platform_device *pdev)
 {
 	device_initialize(&pdev->dev);
 	return platform_device_add(pdev);
@@ -326,14 +325,14 @@ int platform_device_register(struct platform_device * pdev)
 EXPORT_SYMBOL_GPL(platform_device_register);
 
 /**
- *	platform_device_unregister - unregister a platform-level device
- *	@pdev:	platform device we're unregistering
+ * platform_device_unregister - unregister a platform-level device
+ * @pdev: platform device we're unregistering
  *
- *	Unregistration is done in 2 steps. First we release all resources
- *	and remove it from the subsystem, then we drop reference count by
- *	calling platform_device_put().
+ * Unregistration is done in 2 steps. First we release all resources
+ * and remove it from the subsystem, then we drop reference count by
+ * calling platform_device_put().
  */
-void platform_device_unregister(struct platform_device * pdev)
+void platform_device_unregister(struct platform_device *pdev)
 {
 	platform_device_del(pdev);
 	platform_device_put(pdev);
@@ -341,27 +340,29 @@ void platform_device_unregister(struct platform_device * pdev)
 EXPORT_SYMBOL_GPL(platform_device_unregister);
 
 /**
- *	platform_device_register_simple
- *	@name:  base name of the device we're adding
- *	@id:    instance id
- *	@res:   set of resources that needs to be allocated for the device
- *	@num:	number of resources
+ * platform_device_register_simple
+ * @name: base name of the device we're adding
+ * @id: instance id
+ * @res: set of resources that needs to be allocated for the device
+ * @num: number of resources
  *
- *	This function creates a simple platform device that requires minimal
- *	resource and memory management. Canned release function freeing
- *	memory allocated for the device allows drivers using such devices
- *	to be unloaded without waiting for the last reference to the device
- *	to be dropped.
+ * This function creates a simple platform device that requires minimal
+ * resource and memory management. Canned release function freeing memory
+ * allocated for the device allows drivers using such devices to be
+ * unloaded without waiting for the last reference to the device to be
+ * dropped.
  *
- *	This interface is primarily intended for use with legacy drivers
- *	which probe hardware directly.  Because such drivers create sysfs
- *	device nodes themselves, rather than letting system infrastructure
- *	handle such device enumeration tasks, they don't fully conform to
- *	the Linux driver model.  In particular, when such drivers are built
- *	as modules, they can't be "hotplugged".
+ * This interface is primarily intended for use with legacy drivers which
+ * probe hardware directly.  Because such drivers create sysfs device nodes
+ * themselves, rather than letting system infrastructure handle such device
+ * enumeration tasks, they don't fully conform to the Linux driver model.
+ * In particular, when such drivers are built as modules, they can't be
+ * "hotplugged".
  */
-struct platform_device *platform_device_register_simple(const char *name, int id,
-							struct resource *res, unsigned int num)
+struct platform_device *platform_device_register_simple(const char *name,
+							int id,
+							struct resource *res,
+							unsigned int num)
 {
 	struct platform_device *pdev;
 	int retval;
@@ -436,8 +437,8 @@ static int platform_drv_resume(struct device *_dev)
 }
 
 /**
- *	platform_driver_register
- *	@drv: platform driver structure
+ * platform_driver_register
+ * @drv: platform driver structure
  */
 int platform_driver_register(struct platform_driver *drv)
 {
@@ -457,8 +458,8 @@ int platform_driver_register(struct platform_driver *drv)
 EXPORT_SYMBOL_GPL(platform_driver_register);
 
 /**
- *	platform_driver_unregister
- *	@drv: platform driver structure
+ * platform_driver_unregister
+ * @drv: platform driver structure
  */
 void platform_driver_unregister(struct platform_driver *drv)
 {
@@ -516,8 +517,8 @@ EXPORT_SYMBOL_GPL(platform_driver_probe);
  * (b) sysfs attribute lets new-style coldplug recover from hotplug events
  *     mishandled before system is fully running:  "modprobe $(cat modalias)"
  */
-static ssize_t
-modalias_show(struct device *dev, struct device_attribute *a, char *buf)
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
 	int len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
@@ -538,26 +539,24 @@ static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
-
 /**
- *	platform_match - bind platform device to platform driver.
- *	@dev:	device.
- *	@drv:	driver.
+ * platform_match - bind platform device to platform driver.
+ * @dev: device.
+ * @drv: driver.
  *
- *	Platform device IDs are assumed to be encoded like this:
- *	"<name><instance>", where <name> is a short description of the
- *	type of device, like "pci" or "floppy", and <instance> is the
- *	enumerated instance of the device, like '0' or '42'.
- *	Driver IDs are simply "<name>".
- *	So, extract the <name> from the platform_device structure,
- *	and compare it against the name of the driver. Return whether
- *	they match or not.
+ * Platform device IDs are assumed to be encoded like this:
+ * "<name><instance>", where <name> is a short description of the type of
+ * device, like "pci" or "floppy", and <instance> is the enumerated
+ * instance of the device, like '0' or '42'.  Driver IDs are simply
+ * "<name>".  So, extract the <name> from the platform_device structure,
+ * and compare it against the name of the driver. Return whether they match
+ * or not.
  */
-
-static int platform_match(struct device * dev, struct device_driver * drv)
+static int platform_match(struct device *dev, struct device_driver *drv)
 {
-	struct platform_device *pdev = container_of(dev, struct platform_device, dev);
+	struct platform_device *pdev;
 
+	pdev = container_of(dev, struct platform_device, dev);
 	return (strncmp(pdev->name, drv->name, BUS_ID_SIZE) == 0);
 }
 
@@ -574,9 +573,10 @@ static int platform_suspend(struct device *dev, pm_message_t mesg)
 static int platform_suspend_late(struct device *dev, pm_message_t mesg)
 {
 	struct platform_driver *drv = to_platform_driver(dev->driver);
-	struct platform_device *pdev = container_of(dev, struct platform_device, dev);
+	struct platform_device *pdev;
 	int ret = 0;
 
+	pdev = container_of(dev, struct platform_device, dev);
 	if (dev->driver && drv->suspend_late)
 		ret = drv->suspend_late(pdev, mesg);
 
@@ -586,16 +586,17 @@ static int platform_suspend_late(struct device *dev, pm_message_t mesg)
 static int platform_resume_early(struct device *dev)
 {
 	struct platform_driver *drv = to_platform_driver(dev->driver);
-	struct platform_device *pdev = container_of(dev, struct platform_device, dev);
+	struct platform_device *pdev;
 	int ret = 0;
 
+	pdev = container_of(dev, struct platform_device, dev);
 	if (dev->driver && drv->resume_early)
 		ret = drv->resume_early(pdev);
 
 	return ret;
 }
 
-static int platform_resume(struct device * dev)
+static int platform_resume(struct device *dev)
 {
 	int ret = 0;
 

commit ae72cddb2338bc36b991674a56a7bf70ae104d9e
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Jan 11 17:24:53 2008 +1100

    Driver Core: constify the name passed to platform_device_register_simple
    
    This name is just passed to platform_device_alloc which has its parameter
    declared const.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index bdd59e8358f0..48d5db4f92ee 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -360,7 +360,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  *	the Linux driver model.  In particular, when such drivers are built
  *	as modules, they can't be "hotplugged".
  */
-struct platform_device *platform_device_register_simple(char *name, int id,
+struct platform_device *platform_device_register_simple(const char *name, int id,
 							struct resource *res, unsigned int num)
 {
 	struct platform_device *pdev;

commit e5dd12784617f0f1fae5f96a7fac1ec4c49fadbe
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 15:59:15 2007 -0800

    Driver core: move the static kobject out of struct driver
    
    This patch removes the kobject, and a few other driver-core-only fields
    out of struct driver and into the driver core only.  Now drivers can be
    safely create on the stack or statically (like they currently are.)
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d56a05f94f67..bdd59e8358f0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -499,7 +499,7 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 	 */
 	spin_lock(&platform_bus_type.p->klist_drivers.k_lock);
 	drv->probe = NULL;
-	if (code == 0 && list_empty(&drv->driver.klist_devices.k_list))
+	if (code == 0 && list_empty(&drv->driver.p->klist_devices.k_list))
 		retval = -ENODEV;
 	drv->driver.probe = platform_drv_probe_fail;
 	spin_unlock(&platform_bus_type.p->klist_drivers.k_lock);

commit c6f7e72a3f4641095ade9ded287d910c980c6148
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 19:41:16 2007 -0700

    driver core: remove fields from struct bus_type
    
    struct bus_type is static everywhere in the kernel.  This moves the
    kobject in the structure out of it, and a bunch of other private only to
    the driver core fields are now moved to a private structure.  This lets
    us dynamically create the backing kobject properly and gives us the
    chance to be able to document to users exactly how to use the struct
    bus_type as there are no fields they can improperly access.
    
    Thanks to Kay for the build fixes on this patch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index fb5609241482..d56a05f94f67 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -497,12 +497,12 @@ int __init_or_module platform_driver_probe(struct platform_driver *drv,
 	 * if the probe was successful, and make sure any forced probes of
 	 * new devices fail.
 	 */
-	spin_lock(&platform_bus_type.klist_drivers.k_lock);
+	spin_lock(&platform_bus_type.p->klist_drivers.k_lock);
 	drv->probe = NULL;
 	if (code == 0 && list_empty(&drv->driver.klist_devices.k_list))
 		retval = -ENODEV;
 	drv->driver.probe = platform_drv_probe_fail;
-	spin_unlock(&platform_bus_type.klist_drivers.k_lock);
+	spin_unlock(&platform_bus_type.p->klist_drivers.k_lock);
 
 	if (code != retval)
 		platform_driver_unregister(drv);

commit 1359555eb77d240b7c1d7ee75bb07e89e89770e4
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Sep 9 12:54:16 2007 +0200

    Driver core: Make platform_device.id an int
    
    While platform_device.id is a u32, platform_device_add() handles "-1"
    as a special id value. This has potential for confusion and bugs.
    Making it an int instead should prevent problems from happening in
    the future.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a2e3910196e0..fb5609241482 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -161,7 +161,7 @@ static void platform_device_release(struct device *dev)
  *	Create a platform device object which can have other objects attached
  *	to it, and which will have attached objects freed when it is released.
  */
-struct platform_device *platform_device_alloc(const char *name, unsigned int id)
+struct platform_device *platform_device_alloc(const char *name, int id)
 {
 	struct platform_object *pa;
 
@@ -245,7 +245,8 @@ int platform_device_add(struct platform_device *pdev)
 	pdev->dev.bus = &platform_bus_type;
 
 	if (pdev->id != -1)
-		snprintf(pdev->dev.bus_id, BUS_ID_SIZE, "%s.%u", pdev->name, pdev->id);
+		snprintf(pdev->dev.bus_id, BUS_ID_SIZE, "%s.%d", pdev->name,
+			 pdev->id);
 	else
 		strlcpy(pdev->dev.bus_id, pdev->name, BUS_ID_SIZE);
 
@@ -359,7 +360,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  *	the Linux driver model.  In particular, when such drivers are built
  *	as modules, they can't be "hotplugged".
  */
-struct platform_device *platform_device_register_simple(char *name, unsigned int id,
+struct platform_device *platform_device_register_simple(char *name, int id,
 							struct resource *res, unsigned int num)
 {
 	struct platform_device *pdev;

commit 7eff2e7a8b65c25920207324e56611150eb1cd9a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 15:15:12 2007 +0200

    Driver core: change add_uevent_var to use a struct
    
    This changes the uevent buffer functions to use a struct instead of a
    long list of parameters. It does no longer require the caller to do the
    proper buffer termination and size accounting, which is currently wrong
    in some places. It fixes a known bug where parts of the uevent
    environment are overwritten because of wrong index calculations.
    
    Many thanks to Mathieu Desnoyers for finding bugs and improving the
    error handling.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9bfc434d1327..a2e3910196e0 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -529,13 +529,11 @@ static struct device_attribute platform_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
-static int platform_uevent(struct device *dev, char **envp, int num_envp,
-		char *buffer, int buffer_size)
+static int platform_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
 
-	envp[0] = buffer;
-	snprintf(buffer, buffer_size, "MODALIAS=platform:%s", pdev->name);
+	add_uevent_var(env, "MODALIAS=platform:%s", pdev->name);
 	return 0;
 }
 

commit 43cc71eed1250755986da4c0f9898f9a635cb3bf
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Aug 18 04:40:39 2007 +0200

    platform: prefix MODALIAS with "platform:"
    
    Prefix platform modalias strings with "platform:", which
    modprobe config to blacklist alias resolving if userspace
    configures it.
    
    Send uevents for all platform devices.
    
    Add MODULE_ALIAS's to: pxa2xx_pcmcia, ds1742 and pcspkr to trigger
    module autoloading by userspace.
    
      $ modinfo pcspkr
      alias:          platform:pcspkr
      license:        GPL
      description:    PC Speaker beeper driver
      ...
    
      $ modprobe -n -v platform:pcspkr
      insmod /lib/modules/2.6.23-rc3-g28e8351a-dirty/kernel/drivers/input/misc/pcspkr.ko
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 869ff8c00146..9bfc434d1327 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -160,11 +160,6 @@ static void platform_device_release(struct device *dev)
  *
  *	Create a platform device object which can have other objects attached
  *	to it, and which will have attached objects freed when it is released.
- *
- *	This device will be marked as not supporting hotpluggable drivers; no
- *	device add/remove uevents will be generated.  In the unusual case that
- *	the device isn't being dynamically allocated as a legacy "probe the
- *	hardware" driver, infrastructure code should reverse this marking.
  */
 struct platform_device *platform_device_alloc(const char *name, unsigned int id)
 {
@@ -177,12 +172,6 @@ struct platform_device *platform_device_alloc(const char *name, unsigned int id)
 		pa->pdev.id = id;
 		device_initialize(&pa->pdev.dev);
 		pa->pdev.dev.release = platform_device_release;
-
-		/* prevent hotplug "modprobe $(MODALIAS)" from causing trouble in
-		 * legacy probe-the-hardware drivers, which don't properly split
-		 * out device enumeration logic from drivers.
-		 */
-		pa->pdev.dev.uevent_suppress = 1;
 	}
 
 	return pa ? &pa->pdev : NULL;
@@ -530,7 +519,7 @@ static ssize_t
 modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
-	int len = snprintf(buf, PAGE_SIZE, "%s\n", pdev->name);
+	int len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -546,7 +535,7 @@ static int platform_uevent(struct device *dev, char **envp, int num_envp,
 	struct platform_device	*pdev = to_platform_device(dev);
 
 	envp[0] = buffer;
-	snprintf(buffer, buffer_size, "MODALIAS=%s", pdev->name);
+	snprintf(buffer, buffer_size, "MODALIAS=platform:%s", pdev->name);
 	return 0;
 }
 

commit 01afd80626e98c2347bc25be92ee4a3faf314514
Author: Márton Németh <nm127@freemail.hu>
Date:   Wed May 9 07:48:05 2007 +0200

    drivers/base/platform.c: fix small typo in doc
    
    Typo: iwithout -> without.
    
    Signed-off-by: Márton Németh <nm127@freemail.hu>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index eb84d9d44645..869ff8c00146 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -360,7 +360,7 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  *	This function creates a simple platform device that requires minimal
  *	resource and memory management. Canned release function freeing
  *	memory allocated for the device allows drivers using such devices
- *	to be unloaded iwithout waiting for the last reference to the device
+ *	to be unloaded without waiting for the last reference to the device
  *	to be dropped.
  *
  *	This interface is primarily intended for use with legacy drivers

commit 49a4ec188f9a96c9a5567956718213d38a456a19
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:29:39 2007 -0700

    fix hotplug for legacy platform drivers
    
    We've had various reports of some legacy "probe the hardware" style
    platform drivers having nasty problems with hotplug support.
    
    The core issue is that those legacy drivers don't fully conform to the
    driver model.  They assume a role that should be the responsibility of
    infrastructure code: creating device nodes.
    
    The "modprobe" step in hotplugging relies on drivers to have split those
    roles into different modules.  The lack of this split causes the problems.
    When a driver creates nodes for devices that don't exist (sending a hotplug
    event), then exits (aborting one modprobe) before the "modprobe $MODALIAS"
    step completes (by failing, since it's in the middle of a modprobe), the
    result can be an endless loop of modprobe invocations ...  badness.
    
    This fix uses the newish per-device flag controlling issuance of "add"
    events.  (A previous version of this patch used a per-device "driver can
    hotplug" flag, which only scrubbed $MODALIAS from the environment rather
    than suppressing the entire hotplug event.) It also shrinks that flag to
    one bit, saving a word in "struct device".
    
    So the net of this patch is removing some nasty failures with legacy
    drivers, while retaining hotplug capability for the majority of platform
    drivers.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Greg KH <gregkh@suse.de>
    Cc: Andres Salomon <dilinger@debian.org>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 17b5ece8f82c..eb84d9d44645 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -160,6 +160,11 @@ static void platform_device_release(struct device *dev)
  *
  *	Create a platform device object which can have other objects attached
  *	to it, and which will have attached objects freed when it is released.
+ *
+ *	This device will be marked as not supporting hotpluggable drivers; no
+ *	device add/remove uevents will be generated.  In the unusual case that
+ *	the device isn't being dynamically allocated as a legacy "probe the
+ *	hardware" driver, infrastructure code should reverse this marking.
  */
 struct platform_device *platform_device_alloc(const char *name, unsigned int id)
 {
@@ -172,6 +177,12 @@ struct platform_device *platform_device_alloc(const char *name, unsigned int id)
 		pa->pdev.id = id;
 		device_initialize(&pa->pdev.dev);
 		pa->pdev.dev.release = platform_device_release;
+
+		/* prevent hotplug "modprobe $(MODALIAS)" from causing trouble in
+		 * legacy probe-the-hardware drivers, which don't properly split
+		 * out device enumeration logic from drivers.
+		 */
+		pa->pdev.dev.uevent_suppress = 1;
 	}
 
 	return pa ? &pa->pdev : NULL;
@@ -351,6 +362,13 @@ EXPORT_SYMBOL_GPL(platform_device_unregister);
  *	memory allocated for the device allows drivers using such devices
  *	to be unloaded iwithout waiting for the last reference to the device
  *	to be dropped.
+ *
+ *	This interface is primarily intended for use with legacy drivers
+ *	which probe hardware directly.  Because such drivers create sysfs
+ *	device nodes themselves, rather than letting system infrastructure
+ *	handle such device enumeration tasks, they don't fully conform to
+ *	the Linux driver model.  In particular, when such drivers are built
+ *	as modules, they can't be "hotplugged".
  */
 struct platform_device *platform_device_register_simple(char *name, unsigned int id,
 							struct resource *res, unsigned int num)

commit dc4c15d44b2b43279b2667baa7645c65c2ff960e
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed May 2 20:55:54 2007 +0200

    platform: reorder platform_device_del
    
    In platform_device_del(), we currently delete the device resources
    first, then we delete the device itself. This causes a (minor) bug to
    occur when one unregisters a platform device before unregistering its
    platform driver, and the driver is requesting (in .probe()) and
    releasing (in .remove()) a resource of the device. The device
    resources are already gone by the time the driver gets the chance to
    release the resources it had been requesting, causing an error like:
    Trying to free nonexistent resource <0000000000000295-0000000000000296>
    
    If the platform driver is unregistered first, the problem doesn't
    occur, as the driver will have the opportunity to release the
    resources it had requested before the device resources themselves are
    released. It's a bit odd that unregistering the driver first or the
    device first doesn't lead to the same result.
    
    So I believe that we should delete the device first in
    platform_device_del(). I've searched the git history and found that it
    used to be the case before 2.6.8, but was changed here:
    
    http://www.kernel.org/git/?p=linux/kernel/git/torvalds/old-2.6-bkcvs.git;a=commitdiff;h=96ef7b3689936ee1e64b711511342026a8ce459c
    
    > 2004/07/14 16:09:44-07:00 dtor_core
    > [PATCH] Driver core: Fix OOPS in device_platform_unregister
    >
    > Driver core: platform_device_unregister should release resources first
    >              and only then call device_unregister, otherwise if there
    >              are no more references to the device it will be freed and
    >              the fucntion will try to access freed memory.
    
    However we now have an explicit call to put_device() at the end of
    platform_device_unregister() so I guess the original problem no longer
    exists and it is safe to revert that change.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 30480f6f2af2..17b5ece8f82c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -292,20 +292,22 @@ EXPORT_SYMBOL_GPL(platform_device_add);
  *	@pdev:	platform device we're removing
  *
  *	Note that this function will also release all memory- and port-based
- *	resources owned by the device (@dev->resource).
+ *	resources owned by the device (@dev->resource).  This function
+ *	must _only_ be externally called in error cases.  All other usage
+ *	is a bug.
  */
 void platform_device_del(struct platform_device *pdev)
 {
 	int i;
 
 	if (pdev) {
+		device_del(&pdev->dev);
+
 		for (i = 0; i < pdev->num_resources; i++) {
 			struct resource *r = &pdev->resource[i];
 			if (r->flags & (IORESOURCE_MEM|IORESOURCE_IO))
 				release_resource(r);
 		}
-
-		device_del(&pdev->dev);
 	}
 }
 EXPORT_SYMBOL_GPL(platform_device_del);

commit fbfb14455391b89edcf37327526988dea7849532
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Nov 27 10:35:08 2006 +0100

    driver core fixes: device_register() retval check in platform.c
    
    Check the return value of device_register() in platform_bus_init().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f9c903ba9fcd..30480f6f2af2 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -611,8 +611,15 @@ EXPORT_SYMBOL_GPL(platform_bus_type);
 
 int __init platform_bus_init(void)
 {
-	device_register(&platform_bus);
-	return bus_register(&platform_bus_type);
+	int error;
+
+	error = device_register(&platform_bus);
+	if (error)
+		return error;
+	error =  bus_register(&platform_bus_type);
+	if (error)
+		device_unregister(&platform_bus);
+	return error;
 }
 
 #ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK

commit 6eefd34fdcbd34e2cddb8b7da26d838367591954
Author: Scott Wood <scottwood@freescale.com>
Date:   Mon Dec 4 14:57:19 2006 -0800

    Driver core: Make platform_device_add_data accept a const pointer
    
    platform_device_add_data() makes a copy of the data that is given to it,
    and thus the parameter can be const.  This removes a warning when data
    from get_property() on powerpc is handed to platform_device_add_data(),
    as get_property() returns a const pointer.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 0338289f9b5c..f9c903ba9fcd 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -212,7 +212,7 @@ EXPORT_SYMBOL_GPL(platform_device_add_resources);
  *	pointer.  The memory associated with the platform data will be freed
  *	when the platform device is released.
  */
-int platform_device_add_data(struct platform_device *pdev, void *data, size_t size)
+int platform_device_add_data(struct platform_device *pdev, const void *data, size_t size)
 {
 	void *d;
 

commit c63e07834bb12910bea41da15b8902150f5217c2
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Dec 4 14:56:36 2006 -0800

    Driver core: "platform_driver_probe() can save codespace": save codespace
    
    This function can be __init
    
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d1df4a087924..0338289f9b5c 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -473,7 +473,7 @@ EXPORT_SYMBOL_GPL(platform_driver_unregister);
  * Returns zero if the driver registered and bound to a device, else returns
  * a negative error code and with the driver not registered.
  */
-int platform_driver_probe(struct platform_driver *drv,
+int __init_or_module platform_driver_probe(struct platform_driver *drv,
 		int (*probe)(struct platform_device *))
 {
 	int retval, code;

commit c67334fbdfbba533af767610cf3fde8a49710e62
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Nov 16 23:28:47 2006 -0800

    Driver core: platform_driver_probe(), can save codespace
    
    This defines a new platform_driver_probe() method allowing the driver's
    probe() method, and its support code+data, to safely live in __init
    sections for typical system configurations.
    
    Many system-on-chip processors could benefit from this API, to the tune
    of recovering hundreds to thousands of bytes per driver.  That's memory
    which is currently wasted holding code which can never be called after
    system startup, yet can not be removed.   It can't be removed because of
    the linkage requirement that pointers to init section code (like, ideally,
    probe support) must not live in other sections (like driver method tables)
    after those pointers would be invalid.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 940ce41f1887..d1df4a087924 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -388,6 +388,11 @@ static int platform_drv_probe(struct device *_dev)
 	return drv->probe(dev);
 }
 
+static int platform_drv_probe_fail(struct device *_dev)
+{
+	return -ENXIO;
+}
+
 static int platform_drv_remove(struct device *_dev)
 {
 	struct platform_driver *drv = to_platform_driver(_dev->driver);
@@ -451,6 +456,49 @@ void platform_driver_unregister(struct platform_driver *drv)
 }
 EXPORT_SYMBOL_GPL(platform_driver_unregister);
 
+/**
+ * platform_driver_probe - register driver for non-hotpluggable device
+ * @drv: platform driver structure
+ * @probe: the driver probe routine, probably from an __init section
+ *
+ * Use this instead of platform_driver_register() when you know the device
+ * is not hotpluggable and has already been registered, and you want to
+ * remove its run-once probe() infrastructure from memory after the driver
+ * has bound to the device.
+ *
+ * One typical use for this would be with drivers for controllers integrated
+ * into system-on-chip processors, where the controller devices have been
+ * configured as part of board setup.
+ *
+ * Returns zero if the driver registered and bound to a device, else returns
+ * a negative error code and with the driver not registered.
+ */
+int platform_driver_probe(struct platform_driver *drv,
+		int (*probe)(struct platform_device *))
+{
+	int retval, code;
+
+	/* temporary section violation during probe() */
+	drv->probe = probe;
+	retval = code = platform_driver_register(drv);
+
+	/* Fixup that section violation, being paranoid about code scanning
+	 * the list of drivers in order to probe new devices.  Check to see
+	 * if the probe was successful, and make sure any forced probes of
+	 * new devices fail.
+	 */
+	spin_lock(&platform_bus_type.klist_drivers.k_lock);
+	drv->probe = NULL;
+	if (code == 0 && list_empty(&drv->driver.klist_devices.k_list))
+		retval = -ENODEV;
+	drv->driver.probe = platform_drv_probe_fail;
+	spin_unlock(&platform_bus_type.klist_drivers.k_lock);
+
+	if (code != retval)
+		platform_driver_unregister(drv);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(platform_driver_probe);
 
 /* modalias support enables more hands-off userspace setup:
  * (a) environment variable lets new-style hotplug events work once system is

commit 386415d88b1ae50304f9c61aa3e0db082fa90428
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Sep 3 13:16:45 2006 -0700

    PM: platform_bus and late_suspend/early_resume
    
    Teach platform_bus about the new suspend_late/resume_early PM calls,
    issued with IRQs off.  Do we really need sysdev and friends any more,
    or can janitors start switching its users over to platform_device so
    we can do a minor code-ectomy?
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 2b8755db76c6..940ce41f1887 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -505,12 +505,36 @@ static int platform_match(struct device * dev, struct device_driver * drv)
 	return (strncmp(pdev->name, drv->name, BUS_ID_SIZE) == 0);
 }
 
-static int platform_suspend(struct device * dev, pm_message_t state)
+static int platform_suspend(struct device *dev, pm_message_t mesg)
 {
 	int ret = 0;
 
 	if (dev->driver && dev->driver->suspend)
-		ret = dev->driver->suspend(dev, state);
+		ret = dev->driver->suspend(dev, mesg);
+
+	return ret;
+}
+
+static int platform_suspend_late(struct device *dev, pm_message_t mesg)
+{
+	struct platform_driver *drv = to_platform_driver(dev->driver);
+	struct platform_device *pdev = container_of(dev, struct platform_device, dev);
+	int ret = 0;
+
+	if (dev->driver && drv->suspend_late)
+		ret = drv->suspend_late(pdev, mesg);
+
+	return ret;
+}
+
+static int platform_resume_early(struct device *dev)
+{
+	struct platform_driver *drv = to_platform_driver(dev->driver);
+	struct platform_device *pdev = container_of(dev, struct platform_device, dev);
+	int ret = 0;
+
+	if (dev->driver && drv->resume_early)
+		ret = drv->resume_early(pdev);
 
 	return ret;
 }
@@ -531,6 +555,8 @@ struct bus_type platform_bus_type = {
 	.match		= platform_match,
 	.uevent		= platform_uevent,
 	.suspend	= platform_suspend,
+	.suspend_late	= platform_suspend_late,
+	.resume_early	= platform_resume_early,
 	.resume		= platform_resume,
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);

commit e391553222211e07dfbe2f01c413b4e6d0ae32aa
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Sat May 6 08:15:26 2006 +0100

    [PATCH] Driver Core: Fix platform_device_add to use device_add
    
    platform_device_add() should be using device_add() rather
    than device_register() - any platform device passed to
    platform_device_add() should have already been initialised,
    either by platform_device_alloc() or platform_device_register().
    
    Signed-off-by: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f8071976fe07..2b8755db76c6 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -275,7 +275,7 @@ int platform_device_add(struct platform_device *pdev)
 	pr_debug("Registering platform device '%s'. Parent at %s\n",
 		 pdev->dev.bus_id, pdev->dev.parent->bus_id);
 
-	ret = device_register(&pdev->dev);
+	ret = device_add(&pdev->dev);
 	if (ret == 0)
 		return ret;
 

commit a0245f7ad5214cb00131d7cd176446e067c913dc
Author: David Brownell <david-b@pacbell.net>
Date:   Mon May 29 10:37:33 2006 -0700

    [PATCH] platform_bus learns about modalias
    
    This patch adds modalias support to platform devices, for simpler
    hotplug/coldplug driven driver setup.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 83f5c5984d1a..f8071976fe07 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -452,6 +452,37 @@ void platform_driver_unregister(struct platform_driver *drv)
 EXPORT_SYMBOL_GPL(platform_driver_unregister);
 
 
+/* modalias support enables more hands-off userspace setup:
+ * (a) environment variable lets new-style hotplug events work once system is
+ *     fully running:  "modprobe $MODALIAS"
+ * (b) sysfs attribute lets new-style coldplug recover from hotplug events
+ *     mishandled before system is fully running:  "modprobe $(cat modalias)"
+ */
+static ssize_t
+modalias_show(struct device *dev, struct device_attribute *a, char *buf)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+	int len = snprintf(buf, PAGE_SIZE, "%s\n", pdev->name);
+
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute platform_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+static int platform_uevent(struct device *dev, char **envp, int num_envp,
+		char *buffer, int buffer_size)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+
+	envp[0] = buffer;
+	snprintf(buffer, buffer_size, "MODALIAS=%s", pdev->name);
+	return 0;
+}
+
+
 /**
  *	platform_match - bind platform device to platform driver.
  *	@dev:	device.
@@ -496,7 +527,9 @@ static int platform_resume(struct device * dev)
 
 struct bus_type platform_bus_type = {
 	.name		= "platform",
+	.dev_attrs	= platform_dev_attrs,
 	.match		= platform_match,
+	.uevent		= platform_uevent,
 	.suspend	= platform_suspend,
 	.resume		= platform_resume,
 };

commit 80682fa9f70932950c913fd10411c004c4c2e8b0
Author: Uwe Zeisberger <Uwe_Zeisberger@digi.com>
Date:   Wed Mar 22 00:21:33 2006 +0100

    Fix "frist", "fisrt", typos
    
    Signed-off-by: Uwe Zeisberger <Uwe_Zeisberger@digi.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 89b268321321..83f5c5984d1a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -326,7 +326,7 @@ EXPORT_SYMBOL_GPL(platform_device_register);
  *	platform_device_unregister - unregister a platform-level device
  *	@pdev:	platform device we're unregistering
  *
- *	Unregistration is done in 2 steps. Fisrt we release all resources
+ *	Unregistration is done in 2 steps. First we release all resources
  *	and remove it from the subsystem, then we drop reference count by
  *	calling platform_device_put().
  */

commit 305b3228f9ff4d59f49e6d34a7034d44ee8ce2f0
Author: David Vrabel <dvrabel@arcom.com>
Date:   Thu Jan 19 17:52:27 2006 +0000

    [PATCH] driver core: platform_get_irq*(): return -ENXIO on error
    
    platform_get_irq*() cannot return 0 on error as 0 is a valid IRQ on some
    platforms, return -ENXIO instead.
    
    Signed-off-by: David Vrabel <dvrabel@arcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 461554a02517..89b268321321 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -61,7 +61,7 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 {
 	struct resource *r = platform_get_resource(dev, IORESOURCE_IRQ, num);
 
-	return r ? r->start : 0;
+	return r ? r->start : -ENXIO;
 }
 EXPORT_SYMBOL_GPL(platform_get_irq);
 
@@ -98,7 +98,7 @@ int platform_get_irq_byname(struct platform_device *dev, char *name)
 {
 	struct resource *r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);
 
-	return r ? r->start : 0;
+	return r ? r->start : -ENXIO;
 }
 EXPORT_SYMBOL_GPL(platform_get_irq_byname);
 

commit 2d7b5a70e01ff8b1b054d8313362e454e3057c5a
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Dec 27 19:45:58 2005 +0100

    [PATCH] platform-device-del typo fix
    
    Please fold this typo fix into platform-device-del.patch, as was
    discussed earlier on LKML:
      http://lkml.org/lkml/2005/12/10/76
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 0f81731bdfa8..461554a02517 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -327,7 +327,7 @@ EXPORT_SYMBOL_GPL(platform_device_register);
  *	@pdev:	platform device we're unregistering
  *
  *	Unregistration is done in 2 steps. Fisrt we release all resources
- *	and remove it from the sybsystem, then we drop reference count by
+ *	and remove it from the subsystem, then we drop reference count by
  *	calling platform_device_put().
  */
 void platform_device_unregister(struct platform_device * pdev)

commit a96b204208443ab7e23c681f7ddabe807a741d0c
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Sat Dec 10 01:36:28 2005 -0500

    [PATCH] Driver Core: Rearrange exports in platform.c
    
    Driver core: rearrange exports in platform.c
    
    The new way is to specify export right after symbol definition.
    Rearrange exports to follow new style to avoid mixing two styles
    in one file.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 95ecfc490d54..0f81731bdfa8 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -25,6 +25,7 @@
 struct device platform_bus = {
 	.bus_id		= "platform",
 };
+EXPORT_SYMBOL_GPL(platform_bus);
 
 /**
  *	platform_get_resource - get a resource for a device
@@ -49,6 +50,7 @@ platform_get_resource(struct platform_device *dev, unsigned int type,
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(platform_get_resource);
 
 /**
  *	platform_get_irq - get an IRQ for a device
@@ -61,6 +63,7 @@ int platform_get_irq(struct platform_device *dev, unsigned int num)
 
 	return r ? r->start : 0;
 }
+EXPORT_SYMBOL_GPL(platform_get_irq);
 
 /**
  *	platform_get_resource_byname - get a resource for a device by name
@@ -84,6 +87,7 @@ platform_get_resource_byname(struct platform_device *dev, unsigned int type,
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(platform_get_resource_byname);
 
 /**
  *	platform_get_irq - get an IRQ for a device
@@ -96,6 +100,7 @@ int platform_get_irq_byname(struct platform_device *dev, char *name)
 
 	return r ? r->start : 0;
 }
+EXPORT_SYMBOL_GPL(platform_get_irq_byname);
 
 /**
  *	platform_add_devices - add a numbers of platform devices
@@ -117,6 +122,7 @@ int platform_add_devices(struct platform_device **devs, int num)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(platform_add_devices);
 
 struct platform_object {
 	struct platform_device pdev;
@@ -314,6 +320,7 @@ int platform_device_register(struct platform_device * pdev)
 	device_initialize(&pdev->dev);
 	return platform_device_add(pdev);
 }
+EXPORT_SYMBOL_GPL(platform_device_register);
 
 /**
  *	platform_device_unregister - unregister a platform-level device
@@ -328,6 +335,7 @@ void platform_device_unregister(struct platform_device * pdev)
 	platform_device_del(pdev);
 	platform_device_put(pdev);
 }
+EXPORT_SYMBOL_GPL(platform_device_unregister);
 
 /**
  *	platform_device_register_simple
@@ -370,6 +378,7 @@ struct platform_device *platform_device_register_simple(char *name, unsigned int
 	platform_device_put(pdev);
 	return ERR_PTR(retval);
 }
+EXPORT_SYMBOL_GPL(platform_device_register_simple);
 
 static int platform_drv_probe(struct device *_dev)
 {
@@ -491,6 +500,7 @@ struct bus_type platform_bus_type = {
 	.suspend	= platform_suspend,
 	.resume		= platform_resume,
 };
+EXPORT_SYMBOL_GPL(platform_bus_type);
 
 int __init platform_bus_init(void)
 {
@@ -519,14 +529,3 @@ u64 dma_get_required_mask(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(dma_get_required_mask);
 #endif
-
-EXPORT_SYMBOL_GPL(platform_bus);
-EXPORT_SYMBOL_GPL(platform_bus_type);
-EXPORT_SYMBOL_GPL(platform_add_devices);
-EXPORT_SYMBOL_GPL(platform_device_register);
-EXPORT_SYMBOL_GPL(platform_device_register_simple);
-EXPORT_SYMBOL_GPL(platform_device_unregister);
-EXPORT_SYMBOL_GPL(platform_get_irq);
-EXPORT_SYMBOL_GPL(platform_get_resource);
-EXPORT_SYMBOL_GPL(platform_get_irq_byname);
-EXPORT_SYMBOL_GPL(platform_get_resource_byname);

commit 93ce3061be212f6280e7ccafa9a7f698a95c6d75
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Sat Dec 10 01:36:27 2005 -0500

    [PATCH] Driver Core: Add platform_device_del()
    
    Driver core: add platform_device_del function
    
    Having platform_device_del90 allows more straightforward error
    handling code in drivers registering platform devices.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 1091af1cbb58..95ecfc490d54 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -168,7 +168,7 @@ struct platform_device *platform_device_alloc(const char *name, unsigned int id)
 		pa->pdev.dev.release = platform_device_release;
 	}
 
-	return pa ? &pa->pdev : NULL;	
+	return pa ? &pa->pdev : NULL;
 }
 EXPORT_SYMBOL_GPL(platform_device_alloc);
 
@@ -282,24 +282,13 @@ int platform_device_add(struct platform_device *pdev)
 EXPORT_SYMBOL_GPL(platform_device_add);
 
 /**
- *	platform_device_register - add a platform-level device
- *	@pdev:	platform device we're adding
- *
- */
-int platform_device_register(struct platform_device * pdev)
-{
-	device_initialize(&pdev->dev);
-	return platform_device_add(pdev);
-}
-
-/**
- *	platform_device_unregister - remove a platform-level device
+ *	platform_device_del - remove a platform-level device
  *	@pdev:	platform device we're removing
  *
  *	Note that this function will also release all memory- and port-based
  *	resources owned by the device (@dev->resource).
  */
-void platform_device_unregister(struct platform_device * pdev)
+void platform_device_del(struct platform_device *pdev)
 {
 	int i;
 
@@ -310,9 +299,35 @@ void platform_device_unregister(struct platform_device * pdev)
 				release_resource(r);
 		}
 
-		device_unregister(&pdev->dev);
+		device_del(&pdev->dev);
 	}
 }
+EXPORT_SYMBOL_GPL(platform_device_del);
+
+/**
+ *	platform_device_register - add a platform-level device
+ *	@pdev:	platform device we're adding
+ *
+ */
+int platform_device_register(struct platform_device * pdev)
+{
+	device_initialize(&pdev->dev);
+	return platform_device_add(pdev);
+}
+
+/**
+ *	platform_device_unregister - unregister a platform-level device
+ *	@pdev:	platform device we're unregistering
+ *
+ *	Unregistration is done in 2 steps. Fisrt we release all resources
+ *	and remove it from the sybsystem, then we drop reference count by
+ *	calling platform_device_put().
+ */
+void platform_device_unregister(struct platform_device * pdev)
+{
+	platform_device_del(pdev);
+	platform_device_put(pdev);
+}
 
 /**
  *	platform_device_register_simple

commit d960bb4db9f422b5c3c82e0dfd6c8213a4fc430d
Author: Kumar Gala <galak@gate.crashing.org>
Date:   Mon Nov 28 10:15:39 2005 -0600

    [PATCH] Allow overlapping resources for platform devices
    
    There are cases in which a device's memory mapped registers overlap
    with another device's memory mapped registers.  On several PowerPC
    devices this occurs for the MDIO bus, whose registers tended to overlap
    with one of the ethernet controllers.
    
    By switching from request_resource to insert_resource we can register
    the MDIO bus as a proper platform device and not hack around how we
    handle its memory mapped registers.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8827dafba945..1091af1cbb58 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -257,7 +257,7 @@ int platform_device_add(struct platform_device *pdev)
 				p = &ioport_resource;
 		}
 
-		if (p && request_resource(p, r)) {
+		if (p && insert_resource(p, r)) {
 			printk(KERN_ERR
 			       "%s: failed to claim resource %d\n",
 			       pdev->dev.bus_id, i);

commit 00d3dcdd96646be6059cc21f2efa94c4edc1eda5
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Nov 9 17:23:39 2005 +0000

    [DRIVER MODEL] Add platform_driver
    
    Introduce struct platform_driver.  This allows the platform device
    driver methods to be passed a platform_device structure instead of
    instead of a plain device structure, and therefore requiring casting
    in every platform driver.
    
    We introduce this in such a way that any existing platform drivers
    registered directly via driver_register continue to work as before,
    thereby allowing a gradual conversion to the new platform_driver
    methods.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 6d4736e89f1a..8827dafba945 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -20,6 +20,8 @@
 
 #include "base.h"
 
+#define to_platform_driver(drv)	(container_of((drv), struct platform_driver, driver))
+
 struct device platform_bus = {
 	.bus_id		= "platform",
 };
@@ -354,6 +356,77 @@ struct platform_device *platform_device_register_simple(char *name, unsigned int
 	return ERR_PTR(retval);
 }
 
+static int platform_drv_probe(struct device *_dev)
+{
+	struct platform_driver *drv = to_platform_driver(_dev->driver);
+	struct platform_device *dev = to_platform_device(_dev);
+
+	return drv->probe(dev);
+}
+
+static int platform_drv_remove(struct device *_dev)
+{
+	struct platform_driver *drv = to_platform_driver(_dev->driver);
+	struct platform_device *dev = to_platform_device(_dev);
+
+	return drv->remove(dev);
+}
+
+static void platform_drv_shutdown(struct device *_dev)
+{
+	struct platform_driver *drv = to_platform_driver(_dev->driver);
+	struct platform_device *dev = to_platform_device(_dev);
+
+	drv->shutdown(dev);
+}
+
+static int platform_drv_suspend(struct device *_dev, pm_message_t state)
+{
+	struct platform_driver *drv = to_platform_driver(_dev->driver);
+	struct platform_device *dev = to_platform_device(_dev);
+
+	return drv->suspend(dev, state);
+}
+
+static int platform_drv_resume(struct device *_dev)
+{
+	struct platform_driver *drv = to_platform_driver(_dev->driver);
+	struct platform_device *dev = to_platform_device(_dev);
+
+	return drv->resume(dev);
+}
+
+/**
+ *	platform_driver_register
+ *	@drv: platform driver structure
+ */
+int platform_driver_register(struct platform_driver *drv)
+{
+	drv->driver.bus = &platform_bus_type;
+	if (drv->probe)
+		drv->driver.probe = platform_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = platform_drv_remove;
+	if (drv->shutdown)
+		drv->driver.shutdown = platform_drv_shutdown;
+	if (drv->suspend)
+		drv->driver.suspend = platform_drv_suspend;
+	if (drv->resume)
+		drv->driver.resume = platform_drv_resume;
+	return driver_register(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(platform_driver_register);
+
+/**
+ *	platform_driver_unregister
+ *	@drv: platform driver structure
+ */
+void platform_driver_unregister(struct platform_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(platform_driver_unregister);
+
 
 /**
  *	platform_match - bind platform device to platform driver.

commit 37c12e7497b6fe2b6a890814f0ff4edce696d862
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Nov 5 21:19:33 2005 +0000

    [DRIVER MODEL] Improved dynamically allocated platform_device interface
    
    Re-jig the simple platform device support to allow private data
    to be attached to a platform device, as well as allowing the
    parent device to be set.
    
    Example usage:
    
            pdev = platform_device_alloc("mydev", id);
            if (pdev) {
                    err = platform_device_add_resources(pdev, &resources,
                                                        ARRAY_SIZE(resources));
                    if (err == 0)
                            err = platform_device_add_data(pdev, &platform_data,
                                                           sizeof(platform_data));
                    if (err == 0)
                            err = platform_device_add(pdev);
            } else {
                    err = -ENOMEM;
            }
            if (err)
                    platform_device_put(pdev);
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index d597c922af11..6d4736e89f1a 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -116,12 +116,115 @@ int platform_add_devices(struct platform_device **devs, int num)
 	return ret;
 }
 
+struct platform_object {
+	struct platform_device pdev;
+	char name[1];
+};
+
 /**
- *	platform_device_register - add a platform-level device
+ *	platform_device_put
+ *	@pdev:	platform device to free
+ *
+ *	Free all memory associated with a platform device.  This function
+ *	must _only_ be externally called in error cases.  All other usage
+ *	is a bug.
+ */
+void platform_device_put(struct platform_device *pdev)
+{
+	if (pdev)
+		put_device(&pdev->dev);
+}
+EXPORT_SYMBOL_GPL(platform_device_put);
+
+static void platform_device_release(struct device *dev)
+{
+	struct platform_object *pa = container_of(dev, struct platform_object, pdev.dev);
+
+	kfree(pa->pdev.dev.platform_data);
+	kfree(pa->pdev.resource);
+	kfree(pa);
+}
+
+/**
+ *	platform_device_alloc
+ *	@name:	base name of the device we're adding
+ *	@id:    instance id
+ *
+ *	Create a platform device object which can have other objects attached
+ *	to it, and which will have attached objects freed when it is released.
+ */
+struct platform_device *platform_device_alloc(const char *name, unsigned int id)
+{
+	struct platform_object *pa;
+
+	pa = kzalloc(sizeof(struct platform_object) + strlen(name), GFP_KERNEL);
+	if (pa) {
+		strcpy(pa->name, name);
+		pa->pdev.name = pa->name;
+		pa->pdev.id = id;
+		device_initialize(&pa->pdev.dev);
+		pa->pdev.dev.release = platform_device_release;
+	}
+
+	return pa ? &pa->pdev : NULL;	
+}
+EXPORT_SYMBOL_GPL(platform_device_alloc);
+
+/**
+ *	platform_device_add_resources
+ *	@pdev:	platform device allocated by platform_device_alloc to add resources to
+ *	@res:   set of resources that needs to be allocated for the device
+ *	@num:	number of resources
+ *
+ *	Add a copy of the resources to the platform device.  The memory
+ *	associated with the resources will be freed when the platform
+ *	device is released.
+ */
+int platform_device_add_resources(struct platform_device *pdev, struct resource *res, unsigned int num)
+{
+	struct resource *r;
+
+	r = kmalloc(sizeof(struct resource) * num, GFP_KERNEL);
+	if (r) {
+		memcpy(r, res, sizeof(struct resource) * num);
+		pdev->resource = r;
+		pdev->num_resources = num;
+	}
+	return r ? 0 : -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(platform_device_add_resources);
+
+/**
+ *	platform_device_add_data
+ *	@pdev:	platform device allocated by platform_device_alloc to add resources to
+ *	@data:	platform specific data for this platform device
+ *	@size:	size of platform specific data
+ *
+ *	Add a copy of platform specific data to the platform device's platform_data
+ *	pointer.  The memory associated with the platform data will be freed
+ *	when the platform device is released.
+ */
+int platform_device_add_data(struct platform_device *pdev, void *data, size_t size)
+{
+	void *d;
+
+	d = kmalloc(size, GFP_KERNEL);
+	if (d) {
+		memcpy(d, data, size);
+		pdev->dev.platform_data = d;
+	}
+	return d ? 0 : -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(platform_device_add_data);
+
+/**
+ *	platform_device_add - add a platform device to device hierarchy
  *	@pdev:	platform device we're adding
  *
+ *	This is part 2 of platform_device_register(), though may be called
+ *	separately _iff_ pdev was allocated by platform_device_alloc().
  */
-int platform_device_register(struct platform_device * pdev)
+int platform_device_add(struct platform_device *pdev)
 {
 	int i, ret = 0;
 
@@ -174,6 +277,18 @@ int platform_device_register(struct platform_device * pdev)
 			release_resource(&pdev->resource[i]);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(platform_device_add);
+
+/**
+ *	platform_device_register - add a platform-level device
+ *	@pdev:	platform device we're adding
+ *
+ */
+int platform_device_register(struct platform_device * pdev)
+{
+	device_initialize(&pdev->dev);
+	return platform_device_add(pdev);
+}
 
 /**
  *	platform_device_unregister - remove a platform-level device
@@ -197,18 +312,6 @@ void platform_device_unregister(struct platform_device * pdev)
 	}
 }
 
-struct platform_object {
-        struct platform_device pdev;
-        struct resource resources[0];
-};
-
-static void platform_device_release_simple(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-
-	kfree(container_of(pdev, struct platform_object, pdev));
-}
-
 /**
  *	platform_device_register_simple
  *	@name:  base name of the device we're adding
@@ -225,33 +328,29 @@ static void platform_device_release_simple(struct device *dev)
 struct platform_device *platform_device_register_simple(char *name, unsigned int id,
 							struct resource *res, unsigned int num)
 {
-	struct platform_object *pobj;
+	struct platform_device *pdev;
 	int retval;
 
-	pobj = kzalloc(sizeof(*pobj) + sizeof(struct resource) * num, GFP_KERNEL);
-	if (!pobj) {
+	pdev = platform_device_alloc(name, id);
+	if (!pdev) {
 		retval = -ENOMEM;
 		goto error;
 	}
 
-	pobj->pdev.name = name;
-	pobj->pdev.id = id;
-	pobj->pdev.dev.release = platform_device_release_simple;
-
 	if (num) {
-		memcpy(pobj->resources, res, sizeof(struct resource) * num);
-		pobj->pdev.resource = pobj->resources;
-		pobj->pdev.num_resources = num;
+		retval = platform_device_add_resources(pdev, res, num);
+		if (retval)
+			goto error;
 	}
 
-	retval = platform_device_register(&pobj->pdev);
+	retval = platform_device_add(pdev);
 	if (retval)
 		goto error;
 
-	return &pobj->pdev;
+	return pdev;
 
 error:
-	kfree(pobj);
+	platform_device_put(pdev);
 	return ERR_PTR(retval);
 }
 

commit 4fd5f8267dd37aaebadfabe71d9c808821eea05a
Merge: eb16292ba8a6 8576762ff5d1
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Oct 31 07:32:56 2005 -0800

    Merge master.kernel.org:/home/rmk/linux-2.6-drvmodel
    
    Manual #include fixups for clashes - there may be some unnecessary

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 75ce8711bca5..08d9cc99c7de 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -16,6 +16,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/bootmem.h>
 #include <linux/err.h>
+#include <linux/slab.h>
 
 #include "base.h"
 

commit d052d1beff706920e82c5d55006b08e256b5df09
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Oct 29 19:07:23 2005 +0100

    Create platform_device.h to contain all the platform device details.
    Convert everyone who uses platform_bus_type to include
    linux/platform_device.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 75ce8711bca5..95f2af322c8f 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -10,7 +10,7 @@
  * information.
  */
 
-#include <linux/device.h>
+#include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>

commit 9480e307cd88ef09ec9294c7d97ebec18e6d2221
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Fri Oct 28 09:52:56 2005 -0700

    [PATCH] DRIVER MODEL: Get rid of the obsolete tri-level suspend/resume callbacks
    
    In PM v1, all devices were called at SUSPEND_DISABLE level.  Then
    all devices were called at SUSPEND_SAVE_STATE level, and finally
    SUSPEND_POWER_DOWN level.  However, with PM v2, to maintain
    compatibility for platform devices, I arranged for the PM v2
    suspend/resume callbacks to call the old PM v1 suspend/resume
    callbacks three times with each level in order so that existing
    drivers continued to work.
    
    Since this is obsolete infrastructure which is no longer necessary,
    we can remove it.  Here's an (untested) patch to do exactly that.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index a1a56ff65b76..75ce8711bca5 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -281,13 +281,9 @@ static int platform_suspend(struct device * dev, pm_message_t state)
 {
 	int ret = 0;
 
-	if (dev->driver && dev->driver->suspend) {
-		ret = dev->driver->suspend(dev, state, SUSPEND_DISABLE);
-		if (ret == 0)
-			ret = dev->driver->suspend(dev, state, SUSPEND_SAVE_STATE);
-		if (ret == 0)
-			ret = dev->driver->suspend(dev, state, SUSPEND_POWER_DOWN);
-	}
+	if (dev->driver && dev->driver->suspend)
+		ret = dev->driver->suspend(dev, state);
+
 	return ret;
 }
 
@@ -295,13 +291,9 @@ static int platform_resume(struct device * dev)
 {
 	int ret = 0;
 
-	if (dev->driver && dev->driver->resume) {
-		ret = dev->driver->resume(dev, RESUME_POWER_ON);
-		if (ret == 0)
-			ret = dev->driver->resume(dev, RESUME_RESTORE_STATE);
-		if (ret == 0)
-			ret = dev->driver->resume(dev, RESUME_ENABLE);
-	}
+	if (dev->driver && dev->driver->resume)
+		ret = dev->driver->resume(dev);
+
 	return ret;
 }
 

commit a1bdc7aad8b557176ccecff1da137ebe3090871e
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Thu Oct 13 17:54:41 2005 +0100

    [PATCH] drivers/base - fix sparse warnings
    
    There are a number of sparse warnings from the latest sparse
    snapshot being generated from the drivers/base build. The
    main culprits are due to the initialisation functions not
    being declared in a header file.
    
    Also, the firmware.c file should include <linux/device.h>
    to get the prototype of  firmware_register() and
    firmware_unregister().
    
    This patch moves the init function declerations from the
    init.c file to the base.h, and ensures it is included in
    all the relevant c sources. It also adds <linux/device.h>
    to the included headers for firmware.c.
    
    The patch does not solve all the sparse errors generated,
    but reduces the count significantly.
    
    drivers/base/core.c:161:1: warning: symbol 'devices_subsys' was not declared. Should it be static?
    drivers/base/core.c:417:12: warning: symbol 'devices_init' was not declared. Should it be static?
    drivers/base/sys.c:253:6: warning: symbol 'sysdev_shutdown' was not declared. Should it be static?
    drivers/base/sys.c:326:5: warning: symbol 'sysdev_suspend' was not declared. Should it be static?
    drivers/base/sys.c:428:5: warning: symbol 'sysdev_resume' was not declared. Should it be static?
    drivers/base/sys.c:450:12: warning: symbol 'system_bus_init' was not declared. Should it be static?
    drivers/base/bus.c:133:1: warning: symbol 'bus_subsys' was not declared. Should it be static?
    drivers/base/bus.c:667:12: warning: symbol 'buses_init' was not declared. Should it be static?
    drivers/base/class.c:759:12: warning: symbol 'classes_init' was not declared. Should it be static?
    drivers/base/platform.c:313:12: warning: symbol 'platform_bus_init' was not declared. Should it be static?
    drivers/base/cpu.c:110:12: warning: symbol 'cpu_dev_init' was not declared. Should it be static?
    drivers/base/firmware.c:17:5: warning: symbol 'firmware_register' was not declared. Should it be static?
    drivers/base/firmware.c:23:6: warning: symbol 'firmware_unregister' was not declared. Should it be static?
    drivers/base/firmware.c:28:12: warning: symbol 'firmware_init' was not declared. Should it be static?
    drivers/base/init.c:28:13: warning: symbol 'driver_init' was not declared. Should it be static?
    drivers/base/dmapool.c:174:10: warning: implicit cast from nocast type
    drivers/base/attribute_container.c:439:1: warning: symbol 'attribute_container_init' was not declared. Should it be static?
    drivers/base/power/runtime.c:76:6: warning: symbol 'dpm_set_power_state' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 361e204209eb..a1a56ff65b76 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -17,6 +17,8 @@
 #include <linux/bootmem.h>
 #include <linux/err.h>
 
+#include "base.h"
+
 struct device platform_bus = {
 	.bus_id		= "platform",
 };

commit 4aed0644d684428e811bb6944f032b460a3ab165
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Tue Sep 13 01:25:01 2005 -0700

    [PATCH] drivers/base/*: use kzalloc instead of kmalloc+memset
    
    Fixes a bunch of memset bugs too.
    
    Signed-off-by: Lion Vollnhals <webmaster@schiggl.de>
    Signed-off-by: Jiri Slaby <xslaby@fi.muni.cz>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 3a5f4c991797..361e204209eb 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -225,13 +225,12 @@ struct platform_device *platform_device_register_simple(char *name, unsigned int
 	struct platform_object *pobj;
 	int retval;
 
-	pobj = kmalloc(sizeof(struct platform_object) + sizeof(struct resource) * num, GFP_KERNEL);
+	pobj = kzalloc(sizeof(*pobj) + sizeof(struct resource) * num, GFP_KERNEL);
 	if (!pobj) {
 		retval = -ENOMEM;
 		goto error;
 	}
 
-	memset(pobj, 0, sizeof(*pobj));
 	pobj->pdev.name = name;
 	pobj->pdev.id = id;
 	pobj->pdev.dev.release = platform_device_release_simple;

commit 67be2dd1bace0ec7ce2dbc1bba3f8df3d7be597e
Author: Martin Waitz <tali@admingilde.org>
Date:   Sun May 1 08:59:26 2005 -0700

    [PATCH] DocBook: fix some descriptions
    
    Some KernelDoc descriptions are updated to match the current code.
    No code changes.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index cd6453905a9b..3a5f4c991797 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -115,7 +115,7 @@ int platform_add_devices(struct platform_device **devs, int num)
 
 /**
  *	platform_device_register - add a platform-level device
- *	@dev:	platform device we're adding
+ *	@pdev:	platform device we're adding
  *
  */
 int platform_device_register(struct platform_device * pdev)
@@ -174,7 +174,7 @@ int platform_device_register(struct platform_device * pdev)
 
 /**
  *	platform_device_unregister - remove a platform-level device
- *	@dev:	platform device we're removing
+ *	@pdev:	platform device we're removing
  *
  *	Note that this function will also release all memory- and port-based
  *	resources owned by the device (@dev->resource).

commit 46ea0d6c26de431a39c744f7ad63b30bfc800c1e
Author: Robert Schwebel <r.schwebel@pengutronix.de>
Date:   Mon Apr 18 21:57:32 2005 -0700

    [PATCH] export platform_add_devices
    
    platform_add_devices can be used from within modules, so it should be
    exported.  This can for example happen if you have hotpluggable firmware in
    an FPGA on a system on chip processor; in our case the FPGA is probed for
    devices and the FPGA base code registers the devices it has found with the
    kernel.
    
    (akpm: I think this is reasonable from a licensing POV: it's unlikely that
    anyone would be interested in merging such specialised modules into mainline,
    and it's a GPL export).
    
    Signed-off-by: Robert Schwebel <r.schwebel@pengutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 996cbb4d5087..cd6453905a9b 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -341,6 +341,7 @@ EXPORT_SYMBOL_GPL(dma_get_required_mask);
 
 EXPORT_SYMBOL_GPL(platform_bus);
 EXPORT_SYMBOL_GPL(platform_bus_type);
+EXPORT_SYMBOL_GPL(platform_add_devices);
 EXPORT_SYMBOL_GPL(platform_device_register);
 EXPORT_SYMBOL_GPL(platform_device_register_simple);
 EXPORT_SYMBOL_GPL(platform_device_unregister);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/base/platform.c b/drivers/base/platform.c
new file mode 100644
index 000000000000..996cbb4d5087
--- /dev/null
+++ b/drivers/base/platform.c
@@ -0,0 +1,350 @@
+/*
+ * platform.c - platform 'pseudo' bus for legacy devices
+ *
+ * Copyright (c) 2002-3 Patrick Mochel
+ * Copyright (c) 2002-3 Open Source Development Labs
+ *
+ * This file is released under the GPLv2
+ *
+ * Please see Documentation/driver-model/platform.txt for more
+ * information.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/bootmem.h>
+#include <linux/err.h>
+
+struct device platform_bus = {
+	.bus_id		= "platform",
+};
+
+/**
+ *	platform_get_resource - get a resource for a device
+ *	@dev: platform device
+ *	@type: resource type
+ *	@num: resource index
+ */
+struct resource *
+platform_get_resource(struct platform_device *dev, unsigned int type,
+		      unsigned int num)
+{
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++) {
+		struct resource *r = &dev->resource[i];
+
+		if ((r->flags & (IORESOURCE_IO|IORESOURCE_MEM|
+				 IORESOURCE_IRQ|IORESOURCE_DMA))
+		    == type)
+			if (num-- == 0)
+				return r;
+	}
+	return NULL;
+}
+
+/**
+ *	platform_get_irq - get an IRQ for a device
+ *	@dev: platform device
+ *	@num: IRQ number index
+ */
+int platform_get_irq(struct platform_device *dev, unsigned int num)
+{
+	struct resource *r = platform_get_resource(dev, IORESOURCE_IRQ, num);
+
+	return r ? r->start : 0;
+}
+
+/**
+ *	platform_get_resource_byname - get a resource for a device by name
+ *	@dev: platform device
+ *	@type: resource type
+ *	@name: resource name
+ */
+struct resource *
+platform_get_resource_byname(struct platform_device *dev, unsigned int type,
+		      char *name)
+{
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++) {
+		struct resource *r = &dev->resource[i];
+
+		if ((r->flags & (IORESOURCE_IO|IORESOURCE_MEM|
+				 IORESOURCE_IRQ|IORESOURCE_DMA)) == type)
+			if (!strcmp(r->name, name))
+				return r;
+	}
+	return NULL;
+}
+
+/**
+ *	platform_get_irq - get an IRQ for a device
+ *	@dev: platform device
+ *	@name: IRQ name
+ */
+int platform_get_irq_byname(struct platform_device *dev, char *name)
+{
+	struct resource *r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);
+
+	return r ? r->start : 0;
+}
+
+/**
+ *	platform_add_devices - add a numbers of platform devices
+ *	@devs: array of platform devices to add
+ *	@num: number of platform devices in array
+ */
+int platform_add_devices(struct platform_device **devs, int num)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < num; i++) {
+		ret = platform_device_register(devs[i]);
+		if (ret) {
+			while (--i >= 0)
+				platform_device_unregister(devs[i]);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ *	platform_device_register - add a platform-level device
+ *	@dev:	platform device we're adding
+ *
+ */
+int platform_device_register(struct platform_device * pdev)
+{
+	int i, ret = 0;
+
+	if (!pdev)
+		return -EINVAL;
+
+	if (!pdev->dev.parent)
+		pdev->dev.parent = &platform_bus;
+
+	pdev->dev.bus = &platform_bus_type;
+
+	if (pdev->id != -1)
+		snprintf(pdev->dev.bus_id, BUS_ID_SIZE, "%s.%u", pdev->name, pdev->id);
+	else
+		strlcpy(pdev->dev.bus_id, pdev->name, BUS_ID_SIZE);
+
+	for (i = 0; i < pdev->num_resources; i++) {
+		struct resource *p, *r = &pdev->resource[i];
+
+		if (r->name == NULL)
+			r->name = pdev->dev.bus_id;
+
+		p = r->parent;
+		if (!p) {
+			if (r->flags & IORESOURCE_MEM)
+				p = &iomem_resource;
+			else if (r->flags & IORESOURCE_IO)
+				p = &ioport_resource;
+		}
+
+		if (p && request_resource(p, r)) {
+			printk(KERN_ERR
+			       "%s: failed to claim resource %d\n",
+			       pdev->dev.bus_id, i);
+			ret = -EBUSY;
+			goto failed;
+		}
+	}
+
+	pr_debug("Registering platform device '%s'. Parent at %s\n",
+		 pdev->dev.bus_id, pdev->dev.parent->bus_id);
+
+	ret = device_register(&pdev->dev);
+	if (ret == 0)
+		return ret;
+
+ failed:
+	while (--i >= 0)
+		if (pdev->resource[i].flags & (IORESOURCE_MEM|IORESOURCE_IO))
+			release_resource(&pdev->resource[i]);
+	return ret;
+}
+
+/**
+ *	platform_device_unregister - remove a platform-level device
+ *	@dev:	platform device we're removing
+ *
+ *	Note that this function will also release all memory- and port-based
+ *	resources owned by the device (@dev->resource).
+ */
+void platform_device_unregister(struct platform_device * pdev)
+{
+	int i;
+
+	if (pdev) {
+		for (i = 0; i < pdev->num_resources; i++) {
+			struct resource *r = &pdev->resource[i];
+			if (r->flags & (IORESOURCE_MEM|IORESOURCE_IO))
+				release_resource(r);
+		}
+
+		device_unregister(&pdev->dev);
+	}
+}
+
+struct platform_object {
+        struct platform_device pdev;
+        struct resource resources[0];
+};
+
+static void platform_device_release_simple(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	kfree(container_of(pdev, struct platform_object, pdev));
+}
+
+/**
+ *	platform_device_register_simple
+ *	@name:  base name of the device we're adding
+ *	@id:    instance id
+ *	@res:   set of resources that needs to be allocated for the device
+ *	@num:	number of resources
+ *
+ *	This function creates a simple platform device that requires minimal
+ *	resource and memory management. Canned release function freeing
+ *	memory allocated for the device allows drivers using such devices
+ *	to be unloaded iwithout waiting for the last reference to the device
+ *	to be dropped.
+ */
+struct platform_device *platform_device_register_simple(char *name, unsigned int id,
+							struct resource *res, unsigned int num)
+{
+	struct platform_object *pobj;
+	int retval;
+
+	pobj = kmalloc(sizeof(struct platform_object) + sizeof(struct resource) * num, GFP_KERNEL);
+	if (!pobj) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	memset(pobj, 0, sizeof(*pobj));
+	pobj->pdev.name = name;
+	pobj->pdev.id = id;
+	pobj->pdev.dev.release = platform_device_release_simple;
+
+	if (num) {
+		memcpy(pobj->resources, res, sizeof(struct resource) * num);
+		pobj->pdev.resource = pobj->resources;
+		pobj->pdev.num_resources = num;
+	}
+
+	retval = platform_device_register(&pobj->pdev);
+	if (retval)
+		goto error;
+
+	return &pobj->pdev;
+
+error:
+	kfree(pobj);
+	return ERR_PTR(retval);
+}
+
+
+/**
+ *	platform_match - bind platform device to platform driver.
+ *	@dev:	device.
+ *	@drv:	driver.
+ *
+ *	Platform device IDs are assumed to be encoded like this:
+ *	"<name><instance>", where <name> is a short description of the
+ *	type of device, like "pci" or "floppy", and <instance> is the
+ *	enumerated instance of the device, like '0' or '42'.
+ *	Driver IDs are simply "<name>".
+ *	So, extract the <name> from the platform_device structure,
+ *	and compare it against the name of the driver. Return whether
+ *	they match or not.
+ */
+
+static int platform_match(struct device * dev, struct device_driver * drv)
+{
+	struct platform_device *pdev = container_of(dev, struct platform_device, dev);
+
+	return (strncmp(pdev->name, drv->name, BUS_ID_SIZE) == 0);
+}
+
+static int platform_suspend(struct device * dev, pm_message_t state)
+{
+	int ret = 0;
+
+	if (dev->driver && dev->driver->suspend) {
+		ret = dev->driver->suspend(dev, state, SUSPEND_DISABLE);
+		if (ret == 0)
+			ret = dev->driver->suspend(dev, state, SUSPEND_SAVE_STATE);
+		if (ret == 0)
+			ret = dev->driver->suspend(dev, state, SUSPEND_POWER_DOWN);
+	}
+	return ret;
+}
+
+static int platform_resume(struct device * dev)
+{
+	int ret = 0;
+
+	if (dev->driver && dev->driver->resume) {
+		ret = dev->driver->resume(dev, RESUME_POWER_ON);
+		if (ret == 0)
+			ret = dev->driver->resume(dev, RESUME_RESTORE_STATE);
+		if (ret == 0)
+			ret = dev->driver->resume(dev, RESUME_ENABLE);
+	}
+	return ret;
+}
+
+struct bus_type platform_bus_type = {
+	.name		= "platform",
+	.match		= platform_match,
+	.suspend	= platform_suspend,
+	.resume		= platform_resume,
+};
+
+int __init platform_bus_init(void)
+{
+	device_register(&platform_bus);
+	return bus_register(&platform_bus_type);
+}
+
+#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK
+u64 dma_get_required_mask(struct device *dev)
+{
+	u32 low_totalram = ((max_pfn - 1) << PAGE_SHIFT);
+	u32 high_totalram = ((max_pfn - 1) >> (32 - PAGE_SHIFT));
+	u64 mask;
+
+	if (!high_totalram) {
+		/* convert to mask just covering totalram */
+		low_totalram = (1 << (fls(low_totalram) - 1));
+		low_totalram += low_totalram - 1;
+		mask = low_totalram;
+	} else {
+		high_totalram = (1 << (fls(high_totalram) - 1));
+		high_totalram += high_totalram - 1;
+		mask = (((u64)high_totalram) << 32) + 0xffffffff;
+	}
+	return mask & *dev->dma_mask;
+}
+EXPORT_SYMBOL_GPL(dma_get_required_mask);
+#endif
+
+EXPORT_SYMBOL_GPL(platform_bus);
+EXPORT_SYMBOL_GPL(platform_bus_type);
+EXPORT_SYMBOL_GPL(platform_device_register);
+EXPORT_SYMBOL_GPL(platform_device_register_simple);
+EXPORT_SYMBOL_GPL(platform_device_unregister);
+EXPORT_SYMBOL_GPL(platform_get_irq);
+EXPORT_SYMBOL_GPL(platform_get_resource);
+EXPORT_SYMBOL_GPL(platform_get_irq_byname);
+EXPORT_SYMBOL_GPL(platform_get_resource_byname);
