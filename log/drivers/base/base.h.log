commit cec72f3efc6272420c2c2c699607f03d09b93e41
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 1 12:42:57 2020 -0700

    driver core: Don't do deferred probe in parallel with kernel_init thread
    
    The current deferred probe implementation can mess up suspend/resume
    ordering if deferred probe thread is kicked off in parallel with the
    main initcall thread (kernel_init thread) [1].
    
    For example:
    
    Say device-B is a consumer of device-A.
    
    Initcall thread                                 Deferred probe thread
    ===============                                 =====================
    1. device-A is added.
    2. device-B is added.
    3. dpm_list is now [device-A, device-B].
    4. driver-A defers probe of device-A.
                                                    5. device-A is moved to
                                                       end of dpm_list
                                                    6. dpm_list is now
                                                       [device-B, device-A]
    7. driver-B is registereed and probes device-B.
    8. dpm_list stays as [device-B, device-A].
    
    The reverse order of dpm_list is used for suspend. So in this case
    device-A would incorrectly get suspended before device-B.
    
    Commit 716a7a259690 ("driver core: fw_devlink: Add support for batching
    fwnode parsing") kicked off the deferred probe thread early during boot
    to run in parallel with the initcall thread and caused suspend/resume
    regressions.  This patch removes the parallel run of the deferred probe
    thread to avoid the suspend/resume regressions.
    
    [1] - https://lore.kernel.org/lkml/CAGETcx8W96KAw-d_siTX4qHB_-7ddk0miYRDQeHE6E0_8qx-6Q@mail.gmail.com/
    
    Fixes: 716a7a259690 ("driver core: fw_devlink: Add support for batching fwnode parsing")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20200701194259.3337652-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 95c22c0f9036..40fb069a8a7e 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -153,7 +153,6 @@ extern char *make_class_name(const char *name, struct kobject *kobj);
 extern int devres_release_all(struct device *dev);
 extern void device_block_probing(void);
 extern void device_unblock_probing(void);
-extern void driver_deferred_probe_force_trigger(void);
 
 /* /sys/devices directory */
 extern struct kset *devices_kset;

commit 716a7a25969003d82ab738179c3f1068a120ed11
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu May 14 22:34:59 2020 -0700

    driver core: fw_devlink: Add support for batching fwnode parsing
    
    The amount of time spent parsing fwnodes of devices can become really
    high if the devices are added in an non-ideal order. Worst case can be
    O(N^2) when N devices are added. But this can be optimized to O(N) by
    adding all the devices and then parsing all their fwnodes in one batch.
    
    This commit adds fw_devlink_pause() and fw_devlink_resume() to allow
    doing this.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200515053500.215929-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 40fb069a8a7e..95c22c0f9036 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -153,6 +153,7 @@ extern char *make_class_name(const char *name, struct kobject *kobj);
 extern int devres_release_all(struct device *dev);
 extern void device_block_probing(void);
 extern void device_unblock_probing(void);
+extern void driver_deferred_probe_force_trigger(void);
 
 /* /sys/devices directory */
 extern struct kset *devices_kset;

commit cf901a1c5dd8df18d2308188d094a01e1e7c2143
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 9 20:32:59 2019 +0100

    device.h: move devtmpfs prototypes out of the file
    
    The devtmpfs functions do not need to be in device.h as only the driver
    core uses them, so move them to the private .h file for the driver core.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Link: https://lore.kernel.org/r/20191209193303.1694546-3-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 80598b312940..40fb069a8a7e 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -186,3 +186,11 @@ extern void device_links_unbind_consumers(struct device *dev);
 
 /* device pm support */
 void device_pm_move_to_tail(struct device *dev);
+
+#ifdef CONFIG_DEVTMPFS
+int devtmpfs_create_node(struct device *dev);
+int devtmpfs_delete_node(struct device *dev);
+#else
+static inline int devtmpfs_create_node(struct device *dev) { return 0; }
+static inline int devtmpfs_delete_node(struct device *dev) { return 0; }
+#endif

commit 5367601b52696004f363e4f6c0b228b5bbf7d8b7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 9 20:32:58 2019 +0100

    drivers/base: base.h: add proper copyright and header info
    
    base.h didn't have any copyright information in it, so update it with
    the correct information.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Link: https://lore.kernel.org/r/20191209193303.1694546-2-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 0d32544b6f91..80598b312940 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -1,4 +1,15 @@
 /* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2001-2003 Patrick Mochel <mochel@osdl.org>
+ * Copyright (c) 2004-2009 Greg Kroah-Hartman <gregkh@suse.de>
+ * Copyright (c) 2008-2012 Novell Inc.
+ * Copyright (c) 2012-2019 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (c) 2012-2019 Linux Foundation
+ *
+ * Core driver model functions and structures that should not be
+ * shared outside of the drivers/base/ directory.
+ *
+ */
 #include <linux/notifier.h>
 
 /**

commit c2fa1e1bfa5b74558854a70b8afd797d43eb2743
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Tue Jul 16 18:12:25 2019 -0400

    driver/core: Convert to use built-in RCU list checking
    
    This commit applies the consolidated hlist_for_each_entry_rcu() support
    for lockdep conditions.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b405436ee28e..0d32544b6f91 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -165,6 +165,7 @@ static inline int devtmpfs_init(void) { return 0; }
 /* Device links support */
 extern int device_links_read_lock(void);
 extern void device_links_read_unlock(int idx);
+extern int device_links_read_lock_held(void);
 extern int device_links_check_suppliers(struct device *dev);
 extern void device_links_driver_bound(struct device *dev);
 extern void device_links_driver_cleanup(struct device *dev);

commit ef0ff68351be4fd83bec2d797f0efdc0174a55a4
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:21 2019 -0800

    driver core: Probe devices asynchronously instead of the driver
    
    Probe devices asynchronously instead of the driver. This results in us
    seeing the same behavior if the device is registered before the driver or
    after. This way we can avoid serializing the initialization should the
    driver not be loaded until after the devices have already been added.
    
    The motivation behind this is that if we have a set of devices that
    take a significant amount of time to load we can greatly reduce the time to
    load by processing them in parallel instead of one at a time. In addition,
    each device can exist on a different node so placing a single thread on one
    CPU to initialize all of the devices for a given driver can result in poor
    performance on a system with multiple nodes.
    
    This approach can reduce the time needed to scan SCSI LUNs significantly.
    The only way to realize that speedup is by enabling more concurrency which
    is what is achieved with this patch.
    
    To achieve this it was necessary to add a new member "async_driver" to the
    device_private structure to store the driver pointer while we wait on the
    deferred probe call.
    
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b6966511b0ca..b405436ee28e 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -65,6 +65,7 @@ struct driver_private {
  *	binding of drivers which were unable to get all the resources needed by
  *	the device; typically because it depends on another driver getting
  *	probed first.
+ * @async_driver - pointer to device driver awaiting probe via async_probe
  * @device - pointer back to the struct device that this structure is
  * associated with.
  * @dead - This device is currently either in the process of or has been
@@ -80,6 +81,7 @@ struct device_private {
 	struct klist_node knode_bus;
 	struct klist_node knode_class;
 	struct list_head deferred_probe;
+	struct device_driver *async_driver;
 	struct device *device;
 	u8 dead:1;
 };

commit ed88747c6c4a2fc2f961a36d4c50cb0868c30229
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:16 2019 -0800

    device core: Consolidate locking and unlocking of parent and device
    
    Try to consolidate all of the locking and unlocking of both the parent and
    device when attaching or removing a driver from a given device.
    
    To do that I first consolidated the lock pattern into two functions
    __device_driver_lock and __device_driver_unlock. After doing that I then
    created functions specific to attaching and detaching the driver while
    acquiring these locks. By doing this I was able to reduce the number of
    spots where we touch need_parent_lock from 12 down to 4.
    
    This patch should produce no functional changes, it is meant to be a code
    clean-up/consolidation only.
    
    Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 7ca475af8953..b6966511b0ca 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -132,6 +132,8 @@ extern int driver_add_groups(struct device_driver *drv,
 			     const struct attribute_group **groups);
 extern void driver_remove_groups(struct device_driver *drv,
 				 const struct attribute_group **groups);
+int device_driver_attach(struct device_driver *drv, struct device *dev);
+void device_driver_detach(struct device *dev);
 
 extern char *make_class_name(const char *name, struct kobject *kobj);
 

commit 3451a495ef244a88ed6317a035299d835554d579
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:10 2019 -0800

    driver core: Establish order of operations for device_add and device_del via bitflag
    
    Add an additional bit flag to the device_private struct named "dead".
    
    This additional flag provides a guarantee that when a device_del is
    executed on a given interface an async worker will not attempt to attach
    the driver following the earlier device_del call. Previously this
    guarantee was not present and could result in the device_del call
    attempting to remove a driver from an interface only to have the async
    worker attempt to probe the driver later when it finally completes the
    asynchronous probe call.
    
    One additional change added was that I pulled the check for dev->driver
    out of the __device_attach_driver call and instead placed it in the
    __device_attach_async_helper call. This was motivated by the fact that the
    only other caller of this, __device_attach, had already taken the
    device_lock() and checked for dev->driver. Instead of testing for this
    twice in this path it makes more sense to just consolidate the dev->dead
    and dev->driver checks together into one set of checks.
    
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 37329a668935..7ca475af8953 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -67,6 +67,9 @@ struct driver_private {
  *	probed first.
  * @device - pointer back to the struct device that this structure is
  * associated with.
+ * @dead - This device is currently either in the process of or has been
+ *	removed from the system. Any asynchronous events scheduled for this
+ *	device should exit without taking any action.
  *
  * Nothing outside of the driver core should ever touch these fields.
  */
@@ -78,6 +81,7 @@ struct device_private {
 	struct klist_node knode_class;
 	struct list_head deferred_probe;
 	struct device *device;
+	u8 dead:1;
 };
 #define to_device_private_parent(obj)	\
 	container_of(obj, struct device_private, knode_parent)

commit 570d0200123fb4f809aa2f6226e93a458d664d70
Author: Wei Yang <richardw.yang@linux.intel.com>
Date:   Fri Jan 18 10:34:59 2019 +0800

    driver core: move device->knode_class to device_private
    
    As the description of struct device_private says, it stores data which
    is private to driver core. And it already has similar fields like:
    knode_parent, knode_driver, knode_driver and knode_bus. This look it is
    more proper to put knode_class together with those fields to make it
    private to driver core.
    
    This patch move device->knode_class to device_private to make it comply
    with code convention.
    
    Signed-off-by: Wei Yang <richardw.yang@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 7a419a7a6235..37329a668935 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -60,6 +60,7 @@ struct driver_private {
  * @knode_parent - node in sibling list
  * @knode_driver - node in driver list
  * @knode_bus - node in bus list
+ * @knode_class - node in class list
  * @deferred_probe - entry in deferred_probe_list which is used to retry the
  *	binding of drivers which were unable to get all the resources needed by
  *	the device; typically because it depends on another driver getting
@@ -74,6 +75,7 @@ struct device_private {
 	struct klist_node knode_parent;
 	struct klist_node knode_driver;
 	struct klist_node knode_bus;
+	struct klist_node knode_class;
 	struct list_head deferred_probe;
 	struct device *device;
 };
@@ -83,6 +85,8 @@ struct device_private {
 	container_of(obj, struct device_private, knode_driver)
 #define to_device_private_bus(obj)	\
 	container_of(obj, struct device_private, knode_bus)
+#define to_device_private_class(obj)	\
+	container_of(obj, struct device_private, knode_class)
 
 /* initialisation functions */
 extern int devices_init(void);

commit 46d3a03781ea70e25360660ac53bbb838de11c97
Author: Shaokun Zhang <zhangshaokun@hisilicon.com>
Date:   Sun Jul 15 18:08:56 2018 +0800

    driver core: remove unnecessary function extern declare
    
    device_private_init is called only in core.c, extern declare is
    unnecessary and make it static.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Shaokun Zhang <zhangshaokun@hisilicon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index a75c3025fb78..7a419a7a6235 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -84,8 +84,6 @@ struct device_private {
 #define to_device_private_bus(obj)	\
 	container_of(obj, struct device_private, knode_bus)
 
-extern int device_private_init(struct device *dev);
-
 /* initialisation functions */
 extern int devices_init(void);
 extern int buses_init(void);

commit 494fd7b7ad10c33d3a7ff7d10b71b3ecad10474a
Author: Feng Kan <fkan@apm.com>
Date:   Tue Apr 10 16:57:06 2018 -0700

    PM / core: fix deferred probe breaking suspend resume order
    
    When bridge and its endpoint is enumerated the devices are added to the
    dpm list. Afterward, the bridge defers probe when IOMMU is not ready.
    This causes the bridge to be moved to the end of the dpm list when
    deferred probe kicks in. The order of the dpm list for bridge and
    endpoint is reversed.
    
    Add reordering code to move the bridge and its children and consumers to
    the end of the pm list so the order for suspend and resume is not altered.
    The code also move device and its children and consumers to the tail of
    device_kset list if it is registered.
    
    Signed-off-by: Toan Le <toanle@apm.com>
    Signed-off-by: Feng Kan <fkan@apm.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index d800de650fa5..a75c3025fb78 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -161,3 +161,6 @@ extern void device_links_driver_cleanup(struct device *dev);
 extern void device_links_no_driver(struct device *dev);
 extern bool device_links_busy(struct device *dev);
 extern void device_links_unbind_consumers(struct device *dev);
+
+/* device pm support */
+void device_pm_move_to_tail(struct device *dev);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 539432a14b5c..d800de650fa5 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/notifier.h>
 
 /**

commit a7670d425b75f9e44b7d4d0aea04f4a6d5f34291
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Jul 19 17:24:31 2017 -0700

    driver core: make device_{add|remove}_groups() public
    
    Many drivers create additional driver-specific device attributes when
    binding to the device. To avoid them calling SYSFS API directly, let's
    export these helpers.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index e19b1008e5fb..539432a14b5c 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -126,11 +126,6 @@ extern int driver_add_groups(struct device_driver *drv,
 extern void driver_remove_groups(struct device_driver *drv,
 				 const struct attribute_group **groups);
 
-extern int device_add_groups(struct device *dev,
-			     const struct attribute_group **groups);
-extern void device_remove_groups(struct device *dev,
-				 const struct attribute_group **groups);
-
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);

commit c7334ce814f7e5d8fc1f9b3126cda0640c2f81b3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Jan 14 14:09:03 2017 +0100

    Revert "driver core: Add deferred_probe attribute to devices in sysfs"
    
    This reverts commit 6751667a29d6fd64afb9ce30567ad616b68ed789.
    
    Rob Herring objected to it, and a replacement for it will be added using
    debugfs in the future.
    
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Reported-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index ada9dce34e6d..e19b1008e5fb 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -141,8 +141,6 @@ extern void device_unblock_probing(void);
 extern struct kset *devices_kset;
 extern void devices_kset_move_last(struct device *dev);
 
-extern struct device_attribute dev_attr_deferred_probe;
-
 #if defined(CONFIG_MODULES) && defined(CONFIG_SYSFS)
 extern void module_add_driver(struct module *mod, struct device_driver *drv);
 extern void module_remove_driver(struct device_driver *drv);

commit 6751667a29d6fd64afb9ce30567ad616b68ed789
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Tue Aug 16 14:34:18 2016 +0100

    driver core: Add deferred_probe attribute to devices in sysfs
    
    It is sometimes useful to know that a device is on the deferred probe
    list rather than, say, not having a driver available.  Expose this
    information to user-space.
    
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index e19b1008e5fb..ada9dce34e6d 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -141,6 +141,8 @@ extern void device_unblock_probing(void);
 extern struct kset *devices_kset;
 extern void devices_kset_move_last(struct device *dev);
 
+extern struct device_attribute dev_attr_deferred_probe;
+
 #if defined(CONFIG_MODULES) && defined(CONFIG_SYSFS)
 extern void module_add_driver(struct module *mod, struct device_driver *drv);
 extern void module_remove_driver(struct device_driver *drv);

commit 9ed9895370aedd6032af2a9181c62c394d08223b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:16 2016 +0100

    driver core: Functional dependencies tracking support
    
    Currently, there is a problem with taking functional dependencies
    between devices into account.
    
    What I mean by a "functional dependency" is when the driver of device
    B needs device A to be functional and (generally) its driver to be
    present in order to work properly.  This has certain consequences
    for power management (suspend/resume and runtime PM ordering) and
    shutdown ordering of these devices.  In general, it also implies that
    the driver of A needs to be working for B to be probed successfully
    and it cannot be unbound from the device before the B's driver.
    
    Support for representing those functional dependencies between
    devices is added here to allow the driver core to track them and act
    on them in certain cases where applicable.
    
    The argument for doing that in the driver core is that there are
    quite a few distinct use cases involving device dependencies, they
    are relatively hard to get right in a driver (if one wants to
    address all of them properly) and it only gets worse if multiplied
    by the number of drivers potentially needing to do it.  Morever, at
    least one case (asynchronous system suspend/resume) cannot be handled
    in a single driver at all, because it requires the driver of A to
    wait for B to suspend (during system suspend) and the driver of B to
    wait for A to resume (during system resume).
    
    For this reason, represent dependencies between devices as "links",
    with the help of struct device_link objects each containing pointers
    to the "linked" devices, a list node for each of them, status
    information, flags, and an RCU head for synchronization.
    
    Also add two new list heads, representing the lists of links to the
    devices that depend on the given one (consumers) and to the devices
    depended on by it (suppliers), and a "driver presence status" field
    (needed for figuring out initial states of device links) to struct
    device.
    
    The entire data structure consisting of all of the lists of link
    objects for all devices is protected by a mutex (for link object
    addition/removal and for list walks during device driver probing
    and removal) and by SRCU (for list walking in other case that will
    be introduced by subsequent change sets).  If CONFIG_SRCU is not
    selected, however, an rwsem is used for protecting the entire data
    structure.
    
    In addition, each link object has an internal status field whose
    value reflects whether or not drivers are bound to the devices
    pointed to by the link or probing/removal of their drivers is in
    progress etc.  That field is only modified under the device links
    mutex, but it may be read outside of it in some cases (introduced by
    subsequent change sets), so modifications of it are annotated with
    WRITE_ONCE().
    
    New links are added by calling device_link_add() which takes three
    arguments: pointers to the devices in question and flags.  In
    particular, if DL_FLAG_STATELESS is set in the flags, the link status
    is not to be taken into account for this link and the driver core
    will not manage it.  In turn, if DL_FLAG_AUTOREMOVE is set in the
    flags, the driver core will remove the link automatically when the
    consumer device driver unbinds from it.
    
    One of the actions carried out by device_link_add() is to reorder
    the lists used for device shutdown and system suspend/resume to
    put the consumer device along with all of its children and all of
    its consumers (and so on, recursively) to the ends of those lists
    in order to ensure the right ordering between all of the supplier
    and consumer devices.
    
    For this reason, it is not possible to create a link between two
    devices if the would-be supplier device already depends on the
    would-be consumer device as either a direct descendant of it or a
    consumer of one of its direct descendants or one of its consumers
    and so on.
    
    There are two types of link objects, persistent and non-persistent.
    The persistent ones stay around until one of the target devices is
    deleted, while the non-persistent ones are removed automatically when
    the consumer driver unbinds from its device (ie. they are assumed to
    be valid only as long as the consumer device has a driver bound to
    it).  Persistent links are created by default and non-persistent
    links are created when the DL_FLAG_AUTOREMOVE flag is passed
    to device_link_add().
    
    Both persistent and non-persistent device links can be deleted
    with an explicit call to device_link_del().
    
    Links created without the DL_FLAG_STATELESS flag set are managed
    by the driver core using a simple state machine.  There are 5 states
    each link can be in: DORMANT (unused), AVAILABLE (the supplier driver
    is present and functional), CONSUMER_PROBE (the consumer driver is
    probing), ACTIVE (both supplier and consumer drivers are present and
    functional), and SUPPLIER_UNBIND (the supplier driver is unbinding).
    The driver core updates the link state automatically depending on
    what happens to the linked devices and for each link state specific
    actions are taken in addition to that.
    
    For example, if the supplier driver unbinds from its device, the
    driver core will also unbind the drivers of all of its consumers
    automatically under the assumption that they cannot function
    properly without the supplier.  Analogously, the driver core will
    only allow the consumer driver to bind to its device if the
    supplier driver is present and functional (ie. the link is in
    the AVAILABLE state).  If that's not the case, it will rely on
    the existing deferred probing mechanism to wait for the supplier
    driver to become available.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index e05db388bd1c..e19b1008e5fb 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -107,6 +107,9 @@ extern void bus_remove_device(struct device *dev);
 
 extern int bus_add_driver(struct device_driver *drv);
 extern void bus_remove_driver(struct device_driver *drv);
+extern void device_release_driver_internal(struct device *dev,
+					   struct device_driver *drv,
+					   struct device *parent);
 
 extern void driver_detach(struct device_driver *drv);
 extern int driver_probe_device(struct device_driver *drv, struct device *dev);
@@ -152,3 +155,13 @@ extern int devtmpfs_init(void);
 #else
 static inline int devtmpfs_init(void) { return 0; }
 #endif
+
+/* Device links support */
+extern int device_links_read_lock(void);
+extern void device_links_read_unlock(int idx);
+extern int device_links_check_suppliers(struct device *dev);
+extern void device_links_driver_bound(struct device *dev);
+extern void device_links_driver_cleanup(struct device *dev);
+extern void device_links_no_driver(struct device *dev);
+extern bool device_links_busy(struct device *dev);
+extern void device_links_unbind_consumers(struct device *dev);

commit 013c074f8642d8e815ad670601f8e27155a74b57
Author: Strashko, Grygorii <grygorii.strashko@ti.com>
Date:   Tue Nov 10 11:42:34 2015 +0200

    PM / sleep: prohibit devices probing during suspend/hibernation
    
    It is unsafe [1] if probing of devices will happen during suspend or
    hibernation and system behavior will be unpredictable in this case.
    So, let's prohibit device's probing in dpm_prepare() and defer their
    probing instead. The normal behavior will be restored in
    dpm_complete().
    
    This patch introduces new DD core APIs:
     device_block_probing()
       It will disable probing of devices and defer their probes instead.
     device_unblock_probing()
       It will restore normal behavior and trigger re-probing of deferred
       devices.
    
    [1] https://lkml.org/lkml/2015/9/11/554
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 1782f3aa386e..e05db388bd1c 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -131,6 +131,8 @@ extern void device_remove_groups(struct device *dev,
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);
+extern void device_block_probing(void);
+extern void device_unblock_probing(void);
 
 /* /sys/devices directory */
 extern struct kset *devices_kset;

commit 52cdbdd49853dfa856082edb0f4c4c0249d9df07
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Jul 27 20:43:01 2015 +0300

    driver core: correct device's shutdown order
    
    Now device's shutdown sequence is performed in reverse order of their
    registration in devices_kset list and this sequence corresponds to the
    reverse device's creation order. So, devices_kset data tracks
    "parent<-child" device's dependencies only.
    
    Unfortunately, that's not enough and causes problems in case of
    implementing board's specific shutdown procedures. For example [1]:
    "DRA7XX_evm uses PCF8575 and one of the PCF output lines feeds to
    MMC/SD and this line should be driven high in order for the MMC/SD to
    be detected. This line is modelled as regulator and the hsmmc driver
    takes care of enabling and disabling it. In the case of 'reboot',
    during shutdown path as part of it's cleanup process the hsmmc driver
    disables this regulator. This makes MMC boot not functional."
    
    To handle this issue the .shutdown() callback could be implemented
    for PCF8575 device where corresponding GPIO pins will be configured to
    states, required for correct warm/cold reset. This can be achieved
    only when all .shutdown() callbacks have been called already for all
    PCF8575's consumers. But devices_kset is not filled correctly now:
    
    devices_kset: Device61 4e000000.dmm
    devices_kset: Device62 48070000.i2c
    devices_kset: Device63 48072000.i2c
    devices_kset: Device64 48060000.i2c
    devices_kset: Device65 4809c000.mmc
    ...
    devices_kset: Device102 fixedregulator-sd
    ...
    devices_kset: Device181 0-0020 // PCF8575
    devices_kset: Device182 gpiochip496
    devices_kset: Device183 0-0021 // PCF8575
    devices_kset: Device184 gpiochip480
    
    As can be seen from above .shutdown() callback for PCF8575 will be called
    before its consumers, which, in turn means, that any changes of PCF8575
    GPIO's pins will be or unsafe or overwritten later by GPIO's consumers.
    The problem can be solved if devices_kset list will be filled not only
    according device creation order, but also according device's probing
    order to track "supplier<-consumer" dependencies also.
    
    Hence, as a fix, lets add devices_kset_move_last(),
    devices_kset_move_before(), devices_kset_move_after() and call them
    from device_move() and also add call of devices_kset_move_last() in
    really_probe(). After this change all entries in devices_kset will
    be sorted according to device's creation ("parent<-child") and
    probing ("supplier<-consumer") order.
    
    devices_kset after:
    devices_kset: Device121 48070000.i2c
    devices_kset: Device122 i2c-0
    ...
    devices_kset: Device147 regulator.24
    devices_kset: Device148 0-0020
    devices_kset: Device149 gpiochip496
    devices_kset: Device150 0-0021
    devices_kset: Device151 gpiochip480
    devices_kset: Device152 0-0019
    ...
    devices_kset: Device372 fixedregulator-sd
    devices_kset: Device373 regulator.29
    devices_kset: Device374 4809c000.mmc
    devices_kset: Device375 mmc0
    
    [1] http://www.spinics.net/lists/linux-mmc/msg29825.html
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 29c985eb9f4c..1782f3aa386e 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -134,6 +134,7 @@ extern int devres_release_all(struct device *dev);
 
 /* /sys/devices directory */
 extern struct kset *devices_kset;
+extern void devices_kset_move_last(struct device *dev);
 
 #if defined(CONFIG_MODULES) && defined(CONFIG_SYSFS)
 extern void module_add_driver(struct module *mod, struct device_driver *drv);

commit 82b2c3c5b838b4fac9471eab320670aff5a822e0
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Mon Jun 29 16:59:02 2015 +0200

    driver core: fix docbook for device_private.device
    
    This field refers to the public device struct, not to classes.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index fd3347d9f153..29c985eb9f4c 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -63,7 +63,7 @@ struct driver_private {
  *	binding of drivers which were unable to get all the resources needed by
  *	the device; typically because it depends on another driver getting
  *	probed first.
- * @device - pointer back to the struct class that this structure is
+ * @device - pointer back to the struct device that this structure is
  * associated with.
  *
  * Nothing outside of the driver core should ever touch these fields.

commit 765230b5f084863183aa8adb3405ab3f32c0b16e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Mar 30 16:20:04 2015 -0700

    driver-core: add asynchronous probing support for drivers
    
    Some devices take a long time when initializing, and not all drivers are
    suited to initialize their devices when they are open. For example,
    input drivers need to interrogate their devices in order to publish
    device's capabilities before userspace will open them. When such drivers
    are compiled into kernel they may stall entire kernel initialization.
    
    This change allows drivers request for their probe functions to be
    called asynchronously during driver and device registration (manual
    binding is still synchronous). Because async_schedule is used to perform
    asynchronous calls module loading will still wait for the probing to
    complete.
    
    Note that the end goal is to make the probing asynchronous by default,
    so annotating drivers with PROBE_PREFER_ASYNCHRONOUS is a temporary
    measure that allows us to speed up boot process while we validating and
    fixing the rest of the drivers and preparing userspace.
    
    This change is based on earlier patch by "Luis R. Rodriguez"
    <mcgrof@suse.com>
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 251c5d30f963..fd3347d9f153 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -116,6 +116,7 @@ static inline int driver_match_device(struct device_driver *drv,
 {
 	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
 }
+extern bool driver_allows_async_probing(struct device_driver *drv);
 
 extern int driver_add_groups(struct device_driver *drv,
 			     const struct attribute_group **groups);

commit 1bb6c08abfb653ce6e65d8ab4ddef403227afedf
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Apr 14 12:54:47 2014 +0200

    driver core: Move driver_data back to struct device
    
    Having to allocate memory as part of dev_set_drvdata() is a problem
    because that memory may never get freed if the device itself is not
    created. So move driver_data back to struct device.
    
    This is a partial revert of commit b4028437.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 24f424249d9b..251c5d30f963 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -63,8 +63,6 @@ struct driver_private {
  *	binding of drivers which were unable to get all the resources needed by
  *	the device; typically because it depends on another driver getting
  *	probed first.
- * @driver_data - private pointer for driver specific info.  Will turn into a
- * list soon.
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -76,7 +74,6 @@ struct device_private {
 	struct klist_node knode_driver;
 	struct klist_node knode_bus;
 	struct list_head deferred_probe;
-	void *driver_data;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\

commit caa73ea158de9419f08e456f2716c71d1f06012a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 29 15:25:48 2013 +0100

    ACPI / hotplug / driver core: Handle containers in a special way
    
    ACPI container devices require special hotplug handling, at least
    on some systems, since generally user space needs to carry out
    system-specific cleanup before it makes sense to offline devices in
    the container.  However, the current ACPI hotplug code for containers
    first attempts to offline devices in the container and only then it
    notifies user space of the container offline.
    
    Moreover, after commit 202317a573b2 (ACPI / scan: Add acpi_device
    objects for all device nodes in the namespace), ACPI device objects
    representing containers are present as long as the ACPI namespace
    nodes corresponding to them are present, which may be forever, even
    if the container devices are physically detached from the system (the
    return values of the corresponding _STA methods change in those
    cases, but generally the namespace nodes themselves are still there).
    Thus it is useful to introduce entities representing containers that
    will go away during container hot-unplug.
    
    The goal of this change is to address both the above issues.
    
    The idea is to create a "companion" container system device for each
    of the ACPI container device objects during the initial namespace
    scan or on a hotplug event making the container present.  That system
    device will be unregistered on container removal.  A new bus type
    for container devices is added for this purpose, because device
    offline and online operations need to be defined for them.  The
    online operation is a trivial function that is always successful
    and the offline uses a callback pointed to by the container device's
    offline member.
    
    For ACPI containers that callback simply walks the list of ACPI
    device objects right below the container object (its children) and
    checks if all of their physical companion devices are offline.  If
    that's not the case, it returns -EBUSY and the container system
    devivce cannot be put offline.  Consequently, to put the container
    system device offline, it is necessary to put all of the physical
    devices depending on its ACPI companion object offline beforehand.
    
    Container system devices created for ACPI container objects are
    initially online.  They are created by the container ACPI scan
    handler whose hotplug.demand_offline flag is set.  That causes
    acpi_scan_hot_remove() to check if the companion container system
    device is offline before attempting to remove an ACPI container or
    any devices below it.  If the check fails, a KOBJ_CHANGE uevent is
    emitted for the container system device in question and user space
    is expected to offline all devices below the container and the
    container itself in response to it.  Then, user space can finalize
    the removal of the container with the help of its ACPI device
    object's eject attribute in sysfs.
    
    Tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 2cbc6774f4cd..24f424249d9b 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -100,6 +100,7 @@ static inline int hypervisor_init(void) { return 0; }
 #endif
 extern int platform_bus_init(void);
 extern void cpu_dev_init(void);
+extern void container_dev_init(void);
 
 struct kobject *virtual_device_parent(struct device *dev);
 

commit ed0617b5c0bcd7fd04053568aa0cc19a977a1f26
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 8 15:22:56 2013 -0700

    driver core: bus_type: add drv_groups
    
    attribute groups are much more flexible than just a list of attributes,
    due to their support for visibility of the attributes, and binary
    attributes. Add drv_groups to struct bus_type which should be used
    instead of drv_attrs.
    
    drv_attrs will be removed from the structure soon.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index fccf954f82fd..2cbc6774f4cd 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -119,6 +119,11 @@ static inline int driver_match_device(struct device_driver *drv,
 	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
 }
 
+extern int driver_add_groups(struct device_driver *drv,
+			     const struct attribute_group **groups);
+extern void driver_remove_groups(struct device_driver *drv,
+				 const struct attribute_group **groups);
+
 extern int device_add_groups(struct device *dev,
 			     const struct attribute_group **groups);
 extern void device_remove_groups(struct device *dev,

commit fa6fdb33b486a8afc5439c504da8d581e142c77d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 8 15:22:55 2013 -0700

    driver core: bus_type: add dev_groups
    
    attribute groups are much more flexible than just a list of attributes,
    due to their support for visibility of the attributes, and binary
    attributes. Add dev_groups to struct bus_type which should be used
    instead of dev_attrs.
    
    dev_attrs will be removed from the structure soon.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b8bdfe61daa6..fccf954f82fd 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -119,6 +119,11 @@ static inline int driver_match_device(struct device_driver *drv,
 	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
 }
 
+extern int device_add_groups(struct device *dev,
+			     const struct attribute_group **groups);
+extern void device_remove_groups(struct device *dev,
+				 const struct attribute_group **groups);
+
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);

commit d73ce004225a7b2ed75f4340bb63721d55552265
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 12 11:30:05 2013 -0700

    driver/base: implement subsys_virtual_register()
    
    Kay tells me the most appropriate place to expose workqueues to
    userland would be /sys/devices/virtual/workqueues/WQ_NAME which is
    symlinked to /sys/bus/workqueue/devices/WQ_NAME and that we're lacking
    a way to do that outside of driver core as virtual_device_parent()
    isn't exported and there's no inteface to conveniently create a
    virtual subsystem.
    
    This patch implements subsys_virtual_register() by factoring out
    subsys_register() from subsys_system_register() and using it with
    virtual_device_parent() as the origin directory.  It's identical to
    subsys_system_register() other than the origin directory but we aren't
    gonna restrict the device names which should be used under it.
    
    This will be used to expose workqueue attributes to userland.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 6ee17bb391a9..b8bdfe61daa6 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -101,6 +101,8 @@ static inline int hypervisor_init(void) { return 0; }
 extern int platform_bus_init(void);
 extern void cpu_dev_init(void);
 
+struct kobject *virtual_device_parent(struct device *dev);
+
 extern int bus_add_device(struct device *dev);
 extern void bus_probe_device(struct device *dev);
 extern void bus_remove_device(struct device *dev);

commit ef8a3fd6e5e12e8989dae97ba5491c2e39369af9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 8 12:17:22 2012 -0800

    driver core: move the deferred probe pointer into the private area
    
    Nothing outside of the driver core needs to get to the deferred probe
    pointer, so move it inside the private area of 'struct device' so no one
    tries to mess around with it.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 2c13deae5f82..6ee17bb391a9 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -59,6 +59,10 @@ struct driver_private {
  * @knode_parent - node in sibling list
  * @knode_driver - node in driver list
  * @knode_bus - node in bus list
+ * @deferred_probe - entry in deferred_probe_list which is used to retry the
+ *	binding of drivers which were unable to get all the resources needed by
+ *	the device; typically because it depends on another driver getting
+ *	probed first.
  * @driver_data - private pointer for driver specific info.  Will turn into a
  * list soon.
  * @device - pointer back to the struct class that this structure is
@@ -71,6 +75,7 @@ struct device_private {
 	struct klist_node knode_parent;
 	struct klist_node knode_driver;
 	struct klist_node knode_bus;
+	struct list_head deferred_probe;
 	void *driver_data;
 	struct device *device;
 };

commit d1c3414c2a9d10ef7f0f7665f5d2947cd088c093
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Mar 5 08:47:41 2012 -0700

    drivercore: Add driver probe deferral mechanism
    
    Allow drivers to report at probe time that they cannot get all the resources
    required by the device, and should be retried at a later time.
    
    This should completely solve the problem of getting devices
    initialized in the right order.  Right now this is mostly handled by
    mucking about with initcall ordering which is a complete hack, and
    doesn't even remotely handle the case where device drivers are in
    modules.  This approach completely sidesteps the issues by allowing
    driver registration to occur in any order, and any driver can request
    to be retried after a few more other drivers get probed.
    
    v4: - Integrate Manjunath's addition of a separate workqueue
        - Change -EAGAIN to -EPROBE_DEFER for drivers to trigger deferral
        - Update comment blocks to reflect how the code really works
    v3: - Hold off workqueue scheduling until late_initcall so that the bulk
          of driver probes are complete before we start retrying deferred devices.
        - Tested with simple use cases.  Still needs more testing though.
          Using it to get rid of the gpio early_initcall madness, or to replace
          the ASoC internal probe deferral code would be ideal.
    v2: - added locking so it should no longer be utterly broken in that regard
        - remove device from deferred list at device_del time.
        - Still completely untested with any real use case, but has been
          boot tested.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Dilan Lee <dilee@nvidia.com>
    Cc: Manjunath GKondaiah <manjunath.gkondaiah@linaro.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b858dfd9a37c..2c13deae5f82 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -105,6 +105,7 @@ extern void bus_remove_driver(struct device_driver *drv);
 
 extern void driver_detach(struct device_driver *drv);
 extern int driver_probe_device(struct device_driver *drv, struct device *dev);
+extern void driver_deferred_probe_del(struct device *dev);
 static inline int driver_match_device(struct device_driver *drv,
 				      struct device *dev)
 {

commit 024f78462c3da710642a54939888a92e28704653
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Tue Jan 10 02:59:49 2012 +0000

    cpu: Do not return errors from cpu_dev_init() which will be ignored
    
    cpu_dev_init() is only called from driver_init(), which does not check
    its return value.  Therefore make cpu_dev_init() return void.
    
    We must register the CPU subsystem, so panic if this fails.
    
    If sched_create_sysfs_power_savings_entries() fails, the damage is
    contained, so ignore this (as before).
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 7a6ae4228761..b858dfd9a37c 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -94,7 +94,7 @@ extern int hypervisor_init(void);
 static inline int hypervisor_init(void) { return 0; }
 #endif
 extern int platform_bus_init(void);
-extern int cpu_dev_init(void);
+extern void cpu_dev_init(void);
 
 extern int bus_add_device(struct device *dev);
 extern void bus_probe_device(struct device *dev);

commit ca22e56debc57b47c422b749c93217ba62644be2
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 14 14:29:38 2011 -0800

    driver-core: implement 'sysdev' functionality for regular devices and buses
    
    All sysdev classes and sysdev devices will converted to regular devices
    and buses to properly hook userspace into the event processing.
    
    There is no interesting difference between a 'sysdev' and 'device' which
    would justify to roll an entire own subsystem with different userspace
    export semantics. Userspace relies on events and generic sysfs subsystem
    infrastructure from sysdev devices, which are currently not properly
    available.
    
    Every converted sysdev class will create a regular device with the class
    name in /sys/devices/system and all registered devices will becom a children
    of theses devices.
    
    For compatibility reasons, the sysdev class-wide attributes are created
    at this parent device. (Do not copy that logic for anything new, subsystem-
    wide properties belong to the subsystem, not to some fake parent device
    created in /sys/devices.)
    
    Every sysdev driver is implemented as a simple subsystem interface now,
    and no longer called a driver.
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 21c1b96c34c6..7a6ae4228761 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -4,7 +4,9 @@
  * struct subsys_private - structure to hold the private to the driver core portions of the bus_type/class structure.
  *
  * @subsys - the struct kset that defines this subsystem
- * @devices_kset - the list of devices associated
+ * @devices_kset - the subsystem's 'devices' directory
+ * @interfaces - list of subsystem interfaces associated
+ * @mutex - protect the devices, and interfaces lists.
  *
  * @drivers_kset - the list of drivers associated
  * @klist_devices - the klist to iterate over the @devices_kset
@@ -14,10 +16,8 @@
  * @bus - pointer back to the struct bus_type that this structure is associated
  *        with.
  *
- * @class_interfaces - list of class_interfaces associated
  * @glue_dirs - "glue" directory to put in-between the parent device to
  *              avoid namespace conflicts
- * @class_mutex - mutex to protect the children, devices, and interfaces lists.
  * @class - pointer back to the struct class that this structure is associated
  *          with.
  *
@@ -28,6 +28,8 @@
 struct subsys_private {
 	struct kset subsys;
 	struct kset *devices_kset;
+	struct list_head interfaces;
+	struct mutex mutex;
 
 	struct kset *drivers_kset;
 	struct klist klist_devices;
@@ -36,9 +38,7 @@ struct subsys_private {
 	unsigned int drivers_autoprobe:1;
 	struct bus_type *bus;
 
-	struct list_head class_interfaces;
 	struct kset glue_dirs;
-	struct mutex class_mutex;
 	struct class *class;
 };
 #define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)
@@ -94,7 +94,6 @@ extern int hypervisor_init(void);
 static inline int hypervisor_init(void) { return 0; }
 #endif
 extern int platform_bus_init(void);
-extern int system_bus_init(void);
 extern int cpu_dev_init(void);
 
 extern int bus_add_device(struct device *dev);
@@ -116,6 +115,7 @@ extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);
 
+/* /sys/devices directory */
 extern struct kset *devices_kset;
 
 #if defined(CONFIG_MODULES) && defined(CONFIG_SYSFS)

commit ba33162a2c3c847c02e42b9193b250217fdbbd9d
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu May 26 18:08:35 2011 -0400

    drivers/base: base.h implicitly depends on <linux/notifier.h>
    
    This file is currently relying on <linux/module.h> sneaking it in
    through the implicit include paths from device.h.  Once that
    is cleaned up, this will happen:
    
    In file included from drivers/base/init.c:12:
    drivers/base/base.h:34: error: field bus_notifier has incomplete type
    make[3]: *** [drivers/base/init.o] Error 1
    
    Fix it up in advance, so the cleanup can continue.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index a34dca0ad041..21c1b96c34c6 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -1,3 +1,4 @@
+#include <linux/notifier.h>
 
 /**
  * struct subsys_private - structure to hold the private to the driver core portions of the bus_type/class structure.

commit 2e711c04dbbf7a7732a3f7073b1fc285d12b369d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Apr 26 19:15:07 2011 +0200

    PM: Remove sysdev suspend, resume and shutdown operations
    
    Since suspend, resume and shutdown operations in struct sysdev_class
    and struct sysdev_driver are not used any more, remove them.  Also
    drop sysdev_suspend(), sysdev_resume() and sysdev_shutdown() used
    for executing those operations and modify all of their users
    accordingly.  This reduces kernel code size quite a bit and reduces
    its complexity.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 19f49e41ce5d..a34dca0ad041 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -111,8 +111,6 @@ static inline int driver_match_device(struct device_driver *drv,
 	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
 }
 
-extern void sysdev_shutdown(void);
-
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);

commit 6b6e39a6a8da7234c538d14c43d3583da8875f9c
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon Nov 15 23:13:18 2010 +0100

    driver-core: merge private parts of class and bus
    
    As classes and busses are pretty much the same thing, and we want to
    merge them together into a 'subsystem' in the future, let us share the
    same private data parts to make that merge easier.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 2ca7f5b7b824..19f49e41ce5d 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -1,31 +1,46 @@
 
 /**
- * struct bus_type_private - structure to hold the private to the driver core portions of the bus_type structure.
+ * struct subsys_private - structure to hold the private to the driver core portions of the bus_type/class structure.
  *
- * @subsys - the struct kset that defines this bus.  This is the main kobject
- * @drivers_kset - the list of drivers associated with this bus
- * @devices_kset - the list of devices associated with this bus
+ * @subsys - the struct kset that defines this subsystem
+ * @devices_kset - the list of devices associated
+ *
+ * @drivers_kset - the list of drivers associated
  * @klist_devices - the klist to iterate over the @devices_kset
  * @klist_drivers - the klist to iterate over the @drivers_kset
  * @bus_notifier - the bus notifier list for anything that cares about things
- * on this bus.
+ *                 on this bus.
  * @bus - pointer back to the struct bus_type that this structure is associated
- * with.
+ *        with.
+ *
+ * @class_interfaces - list of class_interfaces associated
+ * @glue_dirs - "glue" directory to put in-between the parent device to
+ *              avoid namespace conflicts
+ * @class_mutex - mutex to protect the children, devices, and interfaces lists.
+ * @class - pointer back to the struct class that this structure is associated
+ *          with.
  *
  * This structure is the one that is the actual kobject allowing struct
- * bus_type to be statically allocated safely.  Nothing outside of the driver
- * core should ever touch these fields.
+ * bus_type/class to be statically allocated safely.  Nothing outside of the
+ * driver core should ever touch these fields.
  */
-struct bus_type_private {
+struct subsys_private {
 	struct kset subsys;
-	struct kset *drivers_kset;
 	struct kset *devices_kset;
+
+	struct kset *drivers_kset;
 	struct klist klist_devices;
 	struct klist klist_drivers;
 	struct blocking_notifier_head bus_notifier;
 	unsigned int drivers_autoprobe:1;
 	struct bus_type *bus;
+
+	struct list_head class_interfaces;
+	struct kset glue_dirs;
+	struct mutex class_mutex;
+	struct class *class;
 };
+#define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)
 
 struct driver_private {
 	struct kobject kobj;
@@ -36,33 +51,6 @@ struct driver_private {
 };
 #define to_driver(obj) container_of(obj, struct driver_private, kobj)
 
-
-/**
- * struct class_private - structure to hold the private to the driver core portions of the class structure.
- *
- * @class_subsys - the struct kset that defines this class.  This is the main kobject
- * @class_devices - list of devices associated with this class
- * @class_interfaces - list of class_interfaces associated with this class
- * @class_dirs - "glue" directory for virtual devices associated with this class
- * @class_mutex - mutex to protect the children, devices, and interfaces lists.
- * @class - pointer back to the struct class that this structure is associated
- * with.
- *
- * This structure is the one that is the actual kobject allowing struct
- * class to be statically allocated safely.  Nothing outside of the driver
- * core should ever touch these fields.
- */
-struct class_private {
-	struct kset class_subsys;
-	struct klist class_devices;
-	struct list_head class_interfaces;
-	struct kset class_dirs;
-	struct mutex class_mutex;
-	struct class *class;
-};
-#define to_class(obj)	\
-	container_of(obj, struct class_private, class_subsys.kobj)
-
 /**
  * struct device_private - structure to hold the private to the driver core portions of the device structure.
  *

commit 2b2af54a5bb6f7e80ccf78f20084b93c398c3a8b
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Apr 30 15:23:42 2009 +0200

    Driver Core: devtmpfs - kernel-maintained tmpfs-based /dev
    
    Devtmpfs lets the kernel create a tmpfs instance called devtmpfs
    very early at kernel initialization, before any driver-core device
    is registered. Every device with a major/minor will provide a
    device node in devtmpfs.
    
    Devtmpfs can be changed and altered by userspace at any time,
    and in any way needed - just like today's udev-mounted tmpfs.
    Unmodified udev versions will run just fine on top of it, and will
    recognize an already existing kernel-created device node and use it.
    The default node permissions are root:root 0600. Proper permissions
    and user/group ownership, meaningful symlinks, all other policy still
    needs to be applied by userspace.
    
    If a node is created by devtmps, devtmpfs will remove the device node
    when the device goes away. If the device node was created by
    userspace, or the devtmpfs created node was replaced by userspace, it
    will no longer be removed by devtmpfs.
    
    If it is requested to auto-mount it, it makes init=/bin/sh work
    without any further userspace support. /dev will be fully populated
    and dynamic, and always reflect the current device state of the kernel.
    With the commonly used dynamic device numbers, it solves the problem
    where static devices nodes may point to the wrong devices.
    
    It is intended to make the initial bootup logic simpler and more robust,
    by de-coupling the creation of the inital environment, to reliably run
    userspace processes, from a complex userspace bootstrap logic to provide
    a working /dev.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Tested-By: Harald Hoyer <harald@redhat.com>
    Tested-By: Scott James Remnant <scott@ubuntu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 503d59c57501..2ca7f5b7b824 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -139,3 +139,9 @@ static inline void module_add_driver(struct module *mod,
 				     struct device_driver *drv) { }
 static inline void module_remove_driver(struct device_driver *drv) { }
 #endif
+
+#ifdef CONFIG_DEVTMPFS
+extern int devtmpfs_init(void);
+#else
+static inline int devtmpfs_init(void) { return 0; }
+#endif

commit b4028437876866aba4747a655ede00f892089e14
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 11 14:16:57 2009 -0700

    Driver core: move dev_get/set_drvdata to drivers/base/dd.c
    
    No one should directly access the driver_data field, so remove the field
    and make it private.  We dynamically create the private field now if it
    is needed, to handle drivers that call get/set before they are
    registered with the driver core.
    
    Also update the copyright notices on these files while we are there.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 1e52c125f437..503d59c57501 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -70,6 +70,8 @@ struct class_private {
  * @knode_parent - node in sibling list
  * @knode_driver - node in driver list
  * @knode_bus - node in bus list
+ * @driver_data - private pointer for driver specific info.  Will turn into a
+ * list soon.
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -80,6 +82,7 @@ struct device_private {
 	struct klist_node knode_parent;
 	struct klist_node knode_driver;
 	struct klist_node knode_bus;
+	void *driver_data;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\
@@ -89,6 +92,8 @@ struct device_private {
 #define to_device_private_bus(obj)	\
 	container_of(obj, struct device_private, knode_bus)
 
+extern int device_private_init(struct device *dev);
+
 /* initialisation functions */
 extern int devices_init(void);
 extern int buses_init(void);

commit 2023c610dc54a4f4130b0494309a9bd668ca3df8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jul 30 15:27:18 2009 -0400

    Driver core: add new device to bus's list before probing
    
    This patch (as1271) affects when new devices get linked into their
    bus's list of devices.  Currently this happens after probing, and it
    doesn't happen at all if probing fails.  Clearly this is wrong,
    because at that point quite a few symbolic links have already been
    created in sysfs.  We are committed to adding the device, so it should
    be linked into the bus's list regardless.
    
    In addition, this needs to happen before the uevent announcing the new
    device gets issued.  Otherwise user programs might try to access the
    device before it has been added to the bus.
    
    To fix both these problems, the patch moves the call to
    klist_add_tail() forward from bus_attach_device() to bus_add_device().
    Since bus_attach_device() now does nothing but probe for drivers, it
    has been renamed to bus_probe_device().  And lastly, the kerneldoc is
    updated.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b528145a078f..1e52c125f437 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -104,7 +104,7 @@ extern int system_bus_init(void);
 extern int cpu_dev_init(void);
 
 extern int bus_add_device(struct device *dev);
-extern void bus_attach_device(struct device *dev);
+extern void bus_probe_device(struct device *dev);
 extern void bus_remove_device(struct device *dev);
 
 extern int bus_add_driver(struct device_driver *drv);

commit 5247aecfe62266ffdedf2fc9e4243638554455b6
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Fri Mar 27 21:50:00 2009 +0800

    driver core: fix driver_match_device
    
    This patch fixes a bug introduced in commit
    49b420a13ff95b449947181190b08367348e3e1b.
    
    If a instance of bus_type doesn't have  .match method,
    all .probe of drivers in the bus should be called, or else
    the .probe have not a chance to be called.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Reported-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index ddc97496db4a..b528145a078f 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -115,7 +115,7 @@ extern int driver_probe_device(struct device_driver *drv, struct device *dev);
 static inline int driver_match_device(struct device_driver *drv,
 				      struct device *dev)
 {
-	return drv->bus->match && drv->bus->match(dev, drv);
+	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
 }
 
 extern void sysdev_shutdown(void);

commit ae1b41715ee2aae356fbcca032838b71d70b855f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:26:21 2008 -0800

    driver core: move knode_bus into private structure
    
    Nothing outside of the driver core should ever touch knode_bus, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 4fc5fd3984cc..ddc97496db4a 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -69,6 +69,7 @@ struct class_private {
  * @klist_children - klist containing all children of this device
  * @knode_parent - node in sibling list
  * @knode_driver - node in driver list
+ * @knode_bus - node in bus list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -78,12 +79,15 @@ struct device_private {
 	struct klist klist_children;
 	struct klist_node knode_parent;
 	struct klist_node knode_driver;
+	struct klist_node knode_bus;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\
 	container_of(obj, struct device_private, knode_parent)
 #define to_device_private_driver(obj)	\
 	container_of(obj, struct device_private, knode_driver)
+#define to_device_private_bus(obj)	\
+	container_of(obj, struct device_private, knode_bus)
 
 /* initialisation functions */
 extern int devices_init(void);

commit 8940b4f312dced51b45004819b776ec3aa7fcd5d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:25:49 2008 -0800

    driver core: move knode_driver into private structure
    
    Nothing outside of the driver core should ever touch knode_driver, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 7c4fafc314c4..4fc5fd3984cc 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -68,6 +68,7 @@ struct class_private {
  *
  * @klist_children - klist containing all children of this device
  * @knode_parent - node in sibling list
+ * @knode_driver - node in driver list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -76,10 +77,13 @@ struct class_private {
 struct device_private {
 	struct klist klist_children;
 	struct klist_node knode_parent;
+	struct klist_node knode_driver;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\
 	container_of(obj, struct device_private, knode_parent)
+#define to_device_private_driver(obj)	\
+	container_of(obj, struct device_private, knode_driver)
 
 /* initialisation functions */
 extern int devices_init(void);

commit f791b8c836307b58cbf62133a6a772ed1a92fb33
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:24:56 2008 -0800

    driver core: move klist_children into private structure
    
    Nothing outside of the driver core should ever touch klist_children, or
    knode_parent, so move them out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 62a2cb5e1780..7c4fafc314c4 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -66,14 +66,20 @@ struct class_private {
 /**
  * struct device_private - structure to hold the private to the driver core portions of the device structure.
  *
+ * @klist_children - klist containing all children of this device
+ * @knode_parent - node in sibling list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
  * Nothing outside of the driver core should ever touch these fields.
  */
 struct device_private {
+	struct klist klist_children;
+	struct klist_node knode_parent;
 	struct device *device;
 };
+#define to_device_private_parent(obj)	\
+	container_of(obj, struct device_private, knode_parent)
 
 /* initialisation functions */
 extern int devices_init(void);

commit fb069a5d132fb926ed17af3211a114ac7cf27d7a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:23:36 2008 -0800

    driver core: create a private portion of struct device
    
    This is to be used to move things out of struct device that no code
    outside of the driver core should ever touch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index ca2b0376685b..62a2cb5e1780 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -63,6 +63,18 @@ struct class_private {
 #define to_class(obj)	\
 	container_of(obj, struct class_private, class_subsys.kobj)
 
+/**
+ * struct device_private - structure to hold the private to the driver core portions of the device structure.
+ *
+ * @device - pointer back to the struct class that this structure is
+ * associated with.
+ *
+ * Nothing outside of the driver core should ever touch these fields.
+ */
+struct device_private {
+	struct device *device;
+};
+
 /* initialisation functions */
 extern int devices_init(void);
 extern int buses_init(void);

commit 49b420a13ff95b449947181190b08367348e3e1b
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed Jan 21 23:27:47 2009 +0800

    driver core: check bus->match without holding device lock
    
    This patch moves bus->match out from driver_probe_device and
    does not hold device lock to check the match between a device
    and a driver.
    
    The idea has been verified by the commit 6cd495860901,
    which leads to a faster boot. But the commit 6cd495860901 has
    the following drawbacks: 1),only does the quick check in
    the path of __driver_attach->driver_probe_device, not in other
    paths; 2),for a matched device and driver, check the same match
    twice. It is a waste of cpu ,especially for some drivers with long
    device id table (eg. usb-storage driver).
    
    This patch adds a helper of driver_match_device to check the match
    in all paths, and testes the match only once.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 9f50f1b545dc..ca2b0376685b 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -86,6 +86,11 @@ extern void bus_remove_driver(struct device_driver *drv);
 
 extern void driver_detach(struct device_driver *drv);
 extern int driver_probe_device(struct device_driver *drv, struct device *dev);
+static inline int driver_match_device(struct device_driver *drv,
+				      struct device *dev)
+{
+	return drv->bus->match && drv->bus->match(dev, drv);
+}
 
 extern void sysdev_shutdown(void);
 

commit 770824bdc421ff58a64db608294323571c949f4c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 22 18:38:50 2009 +0100

    PM: Split up sysdev_[suspend|resume] from device_power_[down|up]
    
    Move the sysdev_suspend/resume from the callee to the callers, with
    no real change in semantics, so that we can rework the disabling of
    interrupts during suspend/hibernation.
    
    This is based on an earlier patch from Linus.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 0a5f055dffba..9f50f1b545dc 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -88,8 +88,6 @@ extern void driver_detach(struct device_driver *drv);
 extern int driver_probe_device(struct device_driver *drv, struct device *dev);
 
 extern void sysdev_shutdown(void);
-extern int sysdev_suspend(pm_message_t state);
-extern int sysdev_resume(void);
 
 extern char *make_class_name(const char *name, struct kobject *kobj);
 

commit 926beadb3dfaddccb3348a5b9e6c2a1f8290a220
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 15:06:12 2009 -0800

    Revert "driver core: create a private portion of struct device"
    
    This reverts commit 2831fe6f9cc4e16c103504ee09a47a084297c0f3.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 6b20809b5fd4..0a5f055dffba 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -63,18 +63,6 @@ struct class_private {
 #define to_class(obj)	\
 	container_of(obj, struct class_private, class_subsys.kobj)
 
-/**
- * struct device_private - structure to hold the private to the driver core portions of the device structure.
- *
- * @device - pointer back to the struct class that this structure is
- * associated with.
- *
- * Nothing outside of the driver core should ever touch these fields.
- */
-struct device_private {
-	struct device *device;
-};
-
 /* initialisation functions */
 extern int devices_init(void);
 extern int buses_init(void);

commit e2d4077678c7ec7661003c268120582adc544897
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 14:55:37 2009 -0800

    Revert "driver core: move klist_children into private structure"
    
    This reverts commit 11c3b5c3e08f4d855cbef52883c266b9ab9df879.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index f5cf31c664d7..6b20809b5fd4 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -66,20 +66,14 @@ struct class_private {
 /**
  * struct device_private - structure to hold the private to the driver core portions of the device structure.
  *
- * @klist_children - klist containing all children of this device
- * @knode_parent - node in sibling list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
  * Nothing outside of the driver core should ever touch these fields.
  */
 struct device_private {
-	struct klist klist_children;
-	struct klist_node knode_parent;
 	struct device *device;
 };
-#define to_device_private_parent(obj)	\
-	container_of(obj, struct device_private, knode_parent)
 
 /* initialisation functions */
 extern int devices_init(void);

commit cda5e83fdea476dce9c0a9b1152cd6ca46832cc4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 14:44:18 2009 -0800

    Revert "driver core: move knode_driver into private structure"
    
    This reverts commit 93e746db183b3bdbbda67900f79b5835f9cb388f.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 8af0bb2c0aa8..f5cf31c664d7 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -68,7 +68,6 @@ struct class_private {
  *
  * @klist_children - klist containing all children of this device
  * @knode_parent - node in sibling list
- * @knode_driver - node in driver list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -77,13 +76,10 @@ struct class_private {
 struct device_private {
 	struct klist klist_children;
 	struct klist_node knode_parent;
-	struct klist_node knode_driver;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\
 	container_of(obj, struct device_private, knode_parent)
-#define to_device_private_driver(obj)	\
-	container_of(obj, struct device_private, knode_driver)
 
 /* initialisation functions */
 extern int devices_init(void);

commit 4db8e282f2d1dfa43d51ce2a4817901312c9134d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 14:32:46 2009 -0800

    Revert "driver core: move knode_bus into private structure"
    
    This reverts commit b9daa99ee533578e3f88231e7a16784dcb44ec42.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b676f8f801f8..8af0bb2c0aa8 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -69,7 +69,6 @@ struct class_private {
  * @klist_children - klist containing all children of this device
  * @knode_parent - node in sibling list
  * @knode_driver - node in driver list
- * @knode_bus - node in bus list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -79,15 +78,12 @@ struct device_private {
 	struct klist klist_children;
 	struct klist_node knode_parent;
 	struct klist_node knode_driver;
-	struct klist_node knode_bus;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\
 	container_of(obj, struct device_private, knode_parent)
 #define to_device_private_driver(obj)	\
 	container_of(obj, struct device_private, knode_driver)
-#define to_device_private_bus(obj)	\
-	container_of(obj, struct device_private, knode_bus)
 
 /* initialisation functions */
 extern int devices_init(void);

commit b9daa99ee533578e3f88231e7a16784dcb44ec42
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:26:21 2008 -0800

    driver core: move knode_bus into private structure
    
    Nothing outside of the driver core should ever touch knode_bus, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 8af0bb2c0aa8..b676f8f801f8 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -69,6 +69,7 @@ struct class_private {
  * @klist_children - klist containing all children of this device
  * @knode_parent - node in sibling list
  * @knode_driver - node in driver list
+ * @knode_bus - node in bus list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -78,12 +79,15 @@ struct device_private {
 	struct klist klist_children;
 	struct klist_node knode_parent;
 	struct klist_node knode_driver;
+	struct klist_node knode_bus;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\
 	container_of(obj, struct device_private, knode_parent)
 #define to_device_private_driver(obj)	\
 	container_of(obj, struct device_private, knode_driver)
+#define to_device_private_bus(obj)	\
+	container_of(obj, struct device_private, knode_bus)
 
 /* initialisation functions */
 extern int devices_init(void);

commit 93e746db183b3bdbbda67900f79b5835f9cb388f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:25:49 2008 -0800

    driver core: move knode_driver into private structure
    
    Nothing outside of the driver core should ever touch knode_driver, so
    move it out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index f5cf31c664d7..8af0bb2c0aa8 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -68,6 +68,7 @@ struct class_private {
  *
  * @klist_children - klist containing all children of this device
  * @knode_parent - node in sibling list
+ * @knode_driver - node in driver list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
@@ -76,10 +77,13 @@ struct class_private {
 struct device_private {
 	struct klist klist_children;
 	struct klist_node knode_parent;
+	struct klist_node knode_driver;
 	struct device *device;
 };
 #define to_device_private_parent(obj)	\
 	container_of(obj, struct device_private, knode_parent)
+#define to_device_private_driver(obj)	\
+	container_of(obj, struct device_private, knode_driver)
 
 /* initialisation functions */
 extern int devices_init(void);

commit 11c3b5c3e08f4d855cbef52883c266b9ab9df879
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:24:56 2008 -0800

    driver core: move klist_children into private structure
    
    Nothing outside of the driver core should ever touch klist_children, or
    knode_parent, so move them out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 6b20809b5fd4..f5cf31c664d7 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -66,14 +66,20 @@ struct class_private {
 /**
  * struct device_private - structure to hold the private to the driver core portions of the device structure.
  *
+ * @klist_children - klist containing all children of this device
+ * @knode_parent - node in sibling list
  * @device - pointer back to the struct class that this structure is
  * associated with.
  *
  * Nothing outside of the driver core should ever touch these fields.
  */
 struct device_private {
+	struct klist klist_children;
+	struct klist_node knode_parent;
 	struct device *device;
 };
+#define to_device_private_parent(obj)	\
+	container_of(obj, struct device_private, knode_parent)
 
 /* initialisation functions */
 extern int devices_init(void);

commit 2831fe6f9cc4e16c103504ee09a47a084297c0f3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:23:36 2008 -0800

    driver core: create a private portion of struct device
    
    This is to be used to move things out of struct device that no code
    outside of the driver core should ever touch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 0a5f055dffba..6b20809b5fd4 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -63,6 +63,18 @@ struct class_private {
 #define to_class(obj)	\
 	container_of(obj, struct class_private, class_subsys.kobj)
 
+/**
+ * struct device_private - structure to hold the private to the driver core portions of the device structure.
+ *
+ * @device - pointer back to the struct class that this structure is
+ * associated with.
+ *
+ * Nothing outside of the driver core should ever touch these fields.
+ */
+struct device_private {
+	struct device *device;
+};
+
 /* initialisation functions */
 extern int devices_init(void);
 extern int buses_init(void);

commit 5a3ceb861663040f9ef0176df4aaa494bba5e352
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 25 19:50:19 2008 +0200

    driver-core: use klist for class device list and implement iterator
    
    Iterating over entries using callback usually isn't too fun especially
    when the entry being iterated over can't be manipulated freely.  This
    patch converts class->p->class_devices to klist and implements class
    device iterator so that the users can freely build their own control
    structure.  The users are also free to call back into class code
    without worrying about locking.
    
    class_for_each_device() and class_find_device() are converted to use
    the new iterators, so their users don't have to worry about locking
    anymore either.
    
    Note: This depends on klist-dont-iterate-over-deleted-entries patch
    because class_intf->add/remove_dev() depends on proper synchronization
    with device removal.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 31dc0cd84afa..0a5f055dffba 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -54,7 +54,7 @@ struct driver_private {
  */
 struct class_private {
 	struct kset class_subsys;
-	struct list_head class_devices;
+	struct klist class_devices;
 	struct list_head class_interfaces;
 	struct kset class_dirs;
 	struct mutex class_mutex;

commit f75b1c60fc1e53c4004a79ea0be071aa3318cdcc
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Wed May 28 09:28:39 2008 -0700

    class: change internal semaphore to a mutex
    
    Now that the lockdep infrastructure in the class core is in place, we
    should be able to properly change the internal class semaphore to be a
    mutex.
    
    David wrote the original patch, and Greg fixed it up to apply properly
    due to all of the recent changes in this area.
    
    From: Dave Young <hidave.darkstar@gmail.com>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index c035dc23266a..31dc0cd84afa 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -44,7 +44,7 @@ struct driver_private {
  * @class_devices - list of devices associated with this class
  * @class_interfaces - list of class_interfaces associated with this class
  * @class_dirs - "glue" directory for virtual devices associated with this class
- * @class_sem - semaphore to protect the children, devices, and interfaces lists.
+ * @class_mutex - mutex to protect the children, devices, and interfaces lists.
  * @class - pointer back to the struct class that this structure is associated
  * with.
  *
@@ -57,7 +57,7 @@ struct class_private {
 	struct list_head class_devices;
 	struct list_head class_interfaces;
 	struct kset class_dirs;
-	struct semaphore class_sem;
+	struct mutex class_mutex;
 	struct class *class;
 };
 #define to_class(obj)	\

commit 1e41250863cd4de5ffa0678c405d001ca5b62796
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: fix docbook comments for class_private structure
    
    Removes a field that has been deleted, and adds a description fo the
    class_dirs field which was previously undocumented.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 4435732437a5..c035dc23266a 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -41,10 +41,9 @@ struct driver_private {
  * struct class_private - structure to hold the private to the driver core portions of the class structure.
  *
  * @class_subsys - the struct kset that defines this class.  This is the main kobject
- * @children - list of class_devices associated with this class
  * @class_devices - list of devices associated with this class
  * @class_interfaces - list of class_interfaces associated with this class
- * @class_dirs -
+ * @class_dirs - "glue" directory for virtual devices associated with this class
  * @class_sem - semaphore to protect the children, devices, and interfaces lists.
  * @class - pointer back to the struct class that this structure is associated
  * with.

commit d9a0157328507c5f563e16a583cd0a063854aebb
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "sem" to "class_sem" in internal class structure
    
    This renames the struct class "sem" field to be "class_sem" to make
    things easier when struct bus_type and struct class merge in the future.
    It also makes grepping for fields easier as well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index a77d4bd2ea63..4435732437a5 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -45,7 +45,7 @@ struct driver_private {
  * @class_devices - list of devices associated with this class
  * @class_interfaces - list of class_interfaces associated with this class
  * @class_dirs -
- * @sem - semaphore to protect the children, devices, and interfaces lists.
+ * @class_sem - semaphore to protect the children, devices, and interfaces lists.
  * @class - pointer back to the struct class that this structure is associated
  * with.
  *
@@ -58,7 +58,7 @@ struct class_private {
 	struct list_head class_devices;
 	struct list_head class_interfaces;
 	struct kset class_dirs;
-	struct semaphore sem;
+	struct semaphore class_sem;
 	struct class *class;
 };
 #define to_class(obj)	\

commit 1fbfee6c6dc0f4a4c587b6b163ee79643fc9aaa7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "subsys" to "class_subsys" in internal class structure
    
    This renames the struct class "subsys" field to be "class_subsys" to
    make things easier when struct bus_type and struct class merge in the
    future.  It also makes grepping for fields easier as well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 670b95a1a510..a77d4bd2ea63 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -40,7 +40,7 @@ struct driver_private {
 /**
  * struct class_private - structure to hold the private to the driver core portions of the class structure.
  *
- * @subsys - the struct kset that defines this class.  This is the main kobject
+ * @class_subsys - the struct kset that defines this class.  This is the main kobject
  * @children - list of class_devices associated with this class
  * @class_devices - list of devices associated with this class
  * @class_interfaces - list of class_interfaces associated with this class
@@ -54,14 +54,15 @@ struct driver_private {
  * core should ever touch these fields.
  */
 struct class_private {
-	struct kset subsys;
+	struct kset class_subsys;
 	struct list_head class_devices;
 	struct list_head class_interfaces;
 	struct kset class_dirs;
 	struct semaphore sem;
 	struct class *class;
 };
-#define to_class(obj) container_of(obj, struct class_private, subsys.kobj)
+#define to_class(obj)	\
+	container_of(obj, struct class_private, class_subsys.kobj)
 
 /* initialisation functions */
 extern int devices_init(void);

commit 184f1f779d5a2e62de4a0b34842ddf8546beca8f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "interfaces" to "class_interfaces" in internal class structure
    
    This renames the struct class "interfaces" field to be
    "class_interfaces" to make things easier when struct bus_type and struct
    class merge in the future.  It also makes grepping for fields easier as
    well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 586c4ca70252..670b95a1a510 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -43,7 +43,7 @@ struct driver_private {
  * @subsys - the struct kset that defines this class.  This is the main kobject
  * @children - list of class_devices associated with this class
  * @class_devices - list of devices associated with this class
- * @interfaces - list of class_interfaces associated with this class
+ * @class_interfaces - list of class_interfaces associated with this class
  * @class_dirs -
  * @sem - semaphore to protect the children, devices, and interfaces lists.
  * @class - pointer back to the struct class that this structure is associated
@@ -56,7 +56,7 @@ struct driver_private {
 struct class_private {
 	struct kset subsys;
 	struct list_head class_devices;
-	struct list_head interfaces;
+	struct list_head class_interfaces;
 	struct kset class_dirs;
 	struct semaphore sem;
 	struct class *class;

commit 97ae69fdbaa71a8f7dbc20bf10fb349d1759152f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "devices" to "class_devices" in internal class structure
    
    This renames the struct class "devices" field to be "class_devices" to
    make things easier when struct bus_type and struct class merge in the
    future.  It also makes grepping for fields easier as well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 0ec372a67762..586c4ca70252 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -42,7 +42,7 @@ struct driver_private {
  *
  * @subsys - the struct kset that defines this class.  This is the main kobject
  * @children - list of class_devices associated with this class
- * @devices - list of devices associated with this class
+ * @class_devices - list of devices associated with this class
  * @interfaces - list of class_interfaces associated with this class
  * @class_dirs -
  * @sem - semaphore to protect the children, devices, and interfaces lists.
@@ -55,7 +55,7 @@ struct driver_private {
  */
 struct class_private {
 	struct kset subsys;
-	struct list_head devices;
+	struct list_head class_devices;
 	struct list_head interfaces;
 	struct kset class_dirs;
 	struct semaphore sem;

commit 7c71448b8aa80123fc521563d5f7c63a099d97ab
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jan 22 18:17:41 2008 -0500

    class: move driver core specific parts to a private structure
    
    This moves the portions of struct class that are dynamic (kobject and
    lock and lists) out of the main structure and into a dynamic, private,
    structure.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 2c9ae43e2219..0ec372a67762 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -36,6 +36,33 @@ struct driver_private {
 };
 #define to_driver(obj) container_of(obj, struct driver_private, kobj)
 
+
+/**
+ * struct class_private - structure to hold the private to the driver core portions of the class structure.
+ *
+ * @subsys - the struct kset that defines this class.  This is the main kobject
+ * @children - list of class_devices associated with this class
+ * @devices - list of devices associated with this class
+ * @interfaces - list of class_interfaces associated with this class
+ * @class_dirs -
+ * @sem - semaphore to protect the children, devices, and interfaces lists.
+ * @class - pointer back to the struct class that this structure is associated
+ * with.
+ *
+ * This structure is the one that is the actual kobject allowing struct
+ * class to be statically allocated safely.  Nothing outside of the driver
+ * core should ever touch these fields.
+ */
+struct class_private {
+	struct kset subsys;
+	struct list_head devices;
+	struct list_head interfaces;
+	struct kset class_dirs;
+	struct semaphore sem;
+	struct class *class;
+};
+#define to_class(obj) container_of(obj, struct class_private, subsys.kobj)
+
 /* initialisation functions */
 extern int devices_init(void);
 extern int buses_init(void);

commit c3b19ff06e0808555403491d61e8f0cbbb53e933
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Mar 12 20:47:35 2008 +0100

    driver core: remove no longer used "struct class_device"
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index c0444146c09a..2c9ae43e2219 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -64,17 +64,6 @@ extern void sysdev_shutdown(void);
 extern int sysdev_suspend(pm_message_t state);
 extern int sysdev_resume(void);
 
-static inline struct class_device *to_class_dev(struct kobject *obj)
-{
-	return container_of(obj, struct class_device, kobj);
-}
-
-static inline
-struct class_device_attribute *to_class_dev_attr(struct attribute *_attr)
-{
-	return container_of(_attr, struct class_device_attribute, attr);
-}
-
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);

commit 4a3ad20ccd8f4d2a0535cf98fa83f7b561ba59a9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 24 22:50:12 2008 -0800

    Driver core: coding style fixes
    
    Fix up a number of coding style issues in the drivers/base/ directory
    that have annoyed me over the years.  checkpatch.pl is now very happy.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index f7ad65a249cb..c0444146c09a 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -50,15 +50,15 @@ extern int platform_bus_init(void);
 extern int system_bus_init(void);
 extern int cpu_dev_init(void);
 
-extern int bus_add_device(struct device * dev);
-extern void bus_attach_device(struct device * dev);
-extern void bus_remove_device(struct device * dev);
+extern int bus_add_device(struct device *dev);
+extern void bus_attach_device(struct device *dev);
+extern void bus_remove_device(struct device *dev);
 
-extern int bus_add_driver(struct device_driver *);
-extern void bus_remove_driver(struct device_driver *);
+extern int bus_add_driver(struct device_driver *drv);
+extern void bus_remove_driver(struct device_driver *drv);
 
-extern void driver_detach(struct device_driver * drv);
-extern int driver_probe_device(struct device_driver *, struct device *);
+extern void driver_detach(struct device_driver *drv);
+extern int driver_probe_device(struct device_driver *drv, struct device *dev);
 
 extern void sysdev_shutdown(void);
 extern int sysdev_suspend(pm_message_t state);

commit 92b421416f8194aec87b1439487b5544e9ac8187
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Dec 31 10:05:43 2007 -0800

    driver core: fix build with SYSFS=n
    
    When SYSFS=n and MODULES=y, build ends with:
    
    linux-2.6.24-rc6-mm1/drivers/base/module.c: In function 'module_add_driver':
    linux-2.6.24-rc6-mm1/drivers/base/module.c:49: error: 'module_kset' undeclared (first use in this function)
    make[3]: *** [drivers/base/module.o] Error 1
    
    Below is one possible fix.
    Build-tested with all 4 config combinations of SYSFS & MODULES.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index a74ceda34e19..f7ad65a249cb 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -81,7 +81,7 @@ extern int devres_release_all(struct device *dev);
 
 extern struct kset *devices_kset;
 
-#ifdef CONFIG_MODULES
+#if defined(CONFIG_MODULES) && defined(CONFIG_SYSFS)
 extern void module_add_driver(struct module *mod, struct device_driver *drv);
 extern void module_remove_driver(struct device_driver *drv);
 #else

commit db1118a460c7bfd20278955cbf56c0b283a9701f
Author: Denis Cheng <crquan@gmail.com>
Date:   Thu Dec 6 02:24:40 2007 +0800

    Driver core: use LIST_HEAD instead of call to INIT_LIST_HEAD in __init
    
    LIST_HEAD has been widely used, so switch to this simpler method.
    
    Signed-off-by: Denis Cheng <crquan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 3b0f395552db..a74ceda34e19 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -49,7 +49,6 @@ static inline int hypervisor_init(void) { return 0; }
 extern int platform_bus_init(void);
 extern int system_bus_init(void);
 extern int cpu_dev_init(void);
-extern int attribute_container_init(void);
 
 extern int bus_add_device(struct device * dev);
 extern void bus_attach_device(struct device * dev);

commit e5dd12784617f0f1fae5f96a7fac1ec4c49fadbe
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 15:59:15 2007 -0800

    Driver core: move the static kobject out of struct driver
    
    This patch removes the kobject, and a few other driver-core-only fields
    out of struct driver and into the driver core only.  Now drivers can be
    safely create on the stack or statically (like they currently are.)
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 05472360f6a2..3b0f395552db 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -27,6 +27,14 @@ struct bus_type_private {
 	struct bus_type *bus;
 };
 
+struct driver_private {
+	struct kobject kobj;
+	struct klist klist_devices;
+	struct klist_node knode_bus;
+	struct module_kobject *mkobj;
+	struct device_driver *driver;
+};
+#define to_driver(obj) container_of(obj, struct driver_private, kobj)
 
 /* initialisation functions */
 extern int devices_init(void);

commit c63469a3985a9771c18a916b8d42845d044ea0b1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 12:23:18 2007 -0800

    Driver core: move the driver specific module code into the driver core
    
    The module driver specific code should belong in the driver core, not in
    the kernel/ directory.  So move this code.  This is done in preparation
    for some struct device_driver rework that should be confined to the
    driver core code only.
    
    This also lets us keep from exporting these functions, as no external
    code should ever be calling it.
    
    Thanks to Andrew Morton for the !CONFIG_MODULES fix.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index ca6d273064f8..05472360f6a2 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -73,3 +73,12 @@ extern char *make_class_name(const char *name, struct kobject *kobj);
 extern int devres_release_all(struct device *dev);
 
 extern struct kset *devices_kset;
+
+#ifdef CONFIG_MODULES
+extern void module_add_driver(struct module *mod, struct device_driver *drv);
+extern void module_remove_driver(struct device_driver *drv);
+#else
+static inline void module_add_driver(struct module *mod,
+				     struct device_driver *drv) { }
+static inline void module_remove_driver(struct device_driver *drv) { }
+#endif

commit c6f7e72a3f4641095ade9ded287d910c980c6148
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 19:41:16 2007 -0700

    driver core: remove fields from struct bus_type
    
    struct bus_type is static everywhere in the kernel.  This moves the
    kobject in the structure out of it, and a bunch of other private only to
    the driver core fields are now moved to a private structure.  This lets
    us dynamically create the backing kobject properly and gives us the
    chance to be able to document to users exactly how to use the struct
    bus_type as there are no fields they can improperly access.
    
    Thanks to Kay for the build fixes on this patch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 7e309a49a711..ca6d273064f8 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -1,6 +1,34 @@
 
-/* initialisation functions */
+/**
+ * struct bus_type_private - structure to hold the private to the driver core portions of the bus_type structure.
+ *
+ * @subsys - the struct kset that defines this bus.  This is the main kobject
+ * @drivers_kset - the list of drivers associated with this bus
+ * @devices_kset - the list of devices associated with this bus
+ * @klist_devices - the klist to iterate over the @devices_kset
+ * @klist_drivers - the klist to iterate over the @drivers_kset
+ * @bus_notifier - the bus notifier list for anything that cares about things
+ * on this bus.
+ * @bus - pointer back to the struct bus_type that this structure is associated
+ * with.
+ *
+ * This structure is the one that is the actual kobject allowing struct
+ * bus_type to be statically allocated safely.  Nothing outside of the driver
+ * core should ever touch these fields.
+ */
+struct bus_type_private {
+	struct kset subsys;
+	struct kset *drivers_kset;
+	struct kset *devices_kset;
+	struct klist klist_devices;
+	struct klist klist_drivers;
+	struct blocking_notifier_head bus_notifier;
+	unsigned int drivers_autoprobe:1;
+	struct bus_type *bus;
+};
+
 
+/* initialisation functions */
 extern int devices_init(void);
 extern int buses_init(void);
 extern int classes_init(void);

commit 881c6cfd7c5edfe6129006e2404654bfe5911050
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 09:29:06 2007 -0600

    kset: convert /sys/devices to use kset_create
    
    Dynamically create the kset instead of declaring it statically.  We also
    rename devices_subsys to devices_kset to catch all users of the
    variable.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 10b2fb6c9ce6..7e309a49a711 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -44,4 +44,4 @@ extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);
 
-extern struct kset devices_subsys;
+extern struct kset *devices_kset;

commit 5901d0145c6b9e791bacd049eea11c9db9a3006e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 13 02:53:13 2007 -0700

    Driver core: remove get_bus()
    
    get_bus() should not be globally visable as it is not used by anything
    other than drivers/base/bus.c.  This patch removes the visability of it,
    and renames it to match all of the other *_get() functions in the
    kernel.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index cebc7e754574..10b2fb6c9ce6 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -18,7 +18,6 @@ extern int attribute_container_init(void);
 extern int bus_add_device(struct device * dev);
 extern void bus_attach_device(struct device * dev);
 extern void bus_remove_device(struct device * dev);
-extern struct bus_type *get_bus(struct bus_type * bus);
 
 extern int bus_add_driver(struct device_driver *);
 extern void bus_remove_driver(struct device_driver *);

commit fc1ede5888ab8a9b3e7f8567b945beed35222885
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 13 02:53:13 2007 -0700

    Driver core: remove put_bus()
    
    put_bus() should not be globally visable as it is not used by anything
    other than drivers/base/bus.c.  This patch removes the visability of it,
    and renames it to match all of the other *_put() functions in the
    kernel.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 47eb02d9f1af..cebc7e754574 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -19,7 +19,6 @@ extern int bus_add_device(struct device * dev);
 extern void bus_attach_device(struct device * dev);
 extern void bus_remove_device(struct device * dev);
 extern struct bus_type *get_bus(struct bus_type * bus);
-extern void put_bus(struct bus_type * bus);
 
 extern int bus_add_driver(struct device_driver *);
 extern void bus_remove_driver(struct device_driver *);

commit 2a0134554e12f530c6eccb1dab3f0f8954f855c9
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Jun 18 01:42:54 2007 +0200

    Driver core: fix devres_release_all() return value
    
    Every file should include the headers containing the prototypes for
    it's global functions.
    
    Since the GNU C compiler is now able to detect that the function
    prototype of devres_release_all() in the header and the actual function
    disagree regarding the return value, this patch also fixes this bug.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 5512d84452f2..47eb02d9f1af 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -44,6 +44,6 @@ struct class_device_attribute *to_class_dev_attr(struct attribute *_attr)
 
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
-extern void devres_release_all(struct device *dev);
+extern int devres_release_all(struct device *dev);
 
 extern struct kset devices_subsys;

commit 823bccfc4002296ba88c3ad0f049e1abd8108d30
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 13 13:15:19 2007 -0700

    remove "struct subsystem" as it is no longer needed
    
    We need to work on cleaning up the relationship between kobjects, ksets and
    ktypes.  The removal of 'struct subsystem' is the first step of this,
    especially as it is not really needed at all.
    
    Thanks to Kay for fixing the bugs in this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index d597f2659b23..5512d84452f2 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -45,3 +45,5 @@ struct class_device_attribute *to_class_dev_attr(struct attribute *_attr)
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern void devres_release_all(struct device *dev);
+
+extern struct kset devices_subsys;

commit c6a46696f97ff260a4ecce5e287f8de4b9d7fe14
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Feb 5 16:15:26 2007 -0800

    driver core: don't fail attaching the device if it cannot be bound
    
    Don't fail bus_attach_device() if the device cannot be bound.
    
    If dev->driver has been specified, reset it to NULL if device_bind_driver()
    failed and add the device as an unbound device.  As a result,
    bus_attach_device() now cannot fail, and we can remove some checking from
    device_add().
    
    Also remove an unneeded check in bus_rescan_devices_helper().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index de7e1442ce60..d597f2659b23 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -16,7 +16,7 @@ extern int cpu_dev_init(void);
 extern int attribute_container_init(void);
 
 extern int bus_add_device(struct device * dev);
-extern int bus_attach_device(struct device * dev);
+extern void bus_attach_device(struct device * dev);
 extern void bus_remove_device(struct device * dev);
 extern struct bus_type *get_bus(struct bus_type * bus);
 extern void put_bus(struct bus_type * bus);

commit 9ac7849e35f705830f7b016ff272b0ff1f7ff759
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:26 2007 +0900

    devres: device resource management
    
    Implement device resource management, in short, devres.  A device
    driver can allocate arbirary size of devres data which is associated
    with a release function.  On driver detach, release function is
    invoked on the devres data, then, devres data is freed.
    
    devreses are typed by associated release functions.  Some devreses are
    better represented by single instance of the type while others need
    multiple instances sharing the same release function.  Both usages are
    supported.
    
    devreses can be grouped using devres group such that a device driver
    can easily release acquired resources halfway through initialization
    or selectively release resources (e.g. resources for port 1 out of 4
    ports).
    
    This patch adds devres core including documentation and the following
    managed interfaces.
    
    * alloc/free    : devm_kzalloc(), devm_kzfree()
    * IO region     : devm_request_region(), devm_release_region()
    * IRQ           : devm_request_irq(), devm_free_irq()
    * DMA           : dmam_alloc_coherent(), dmam_free_coherent(),
                      dmam_declare_coherent_memory(), dmam_pool_create(),
                      dmam_pool_destroy()
    * PCI           : pcim_enable_device(), pcim_pin_device(), pci_is_managed()
    * iomap         : devm_ioport_map(), devm_ioport_unmap(), devm_ioremap(),
                      devm_ioremap_nocache(), devm_iounmap(), pcim_iomap_table(),
                      pcim_iomap(), pcim_iounmap()
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index d26644a59537..de7e1442ce60 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -44,3 +44,4 @@ struct class_device_attribute *to_class_dev_attr(struct attribute *_attr)
 
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
+extern void devres_release_all(struct device *dev);

commit f86db396ff455ed586751d21816a1ebd431264e5
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Aug 14 22:43:20 2006 -0700

    drivers/base: check errors
    
    Add lots of return-value checking.
    
    <pcornelia.huck@de.ibm.com>: fix bus_rescan_devices()]
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index c3b8dc98b8a7..d26644a59537 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -16,7 +16,7 @@ extern int cpu_dev_init(void);
 extern int attribute_container_init(void);
 
 extern int bus_add_device(struct device * dev);
-extern void bus_attach_device(struct device * dev);
+extern int bus_attach_device(struct device * dev);
 extern void bus_remove_device(struct device * dev);
 extern struct bus_type *get_bus(struct bus_type * bus);
 extern void put_bus(struct bus_type * bus);

commit aa49b9136e3d44cc264811d77eef4ded88456717
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 20 13:59:20 2006 -0700

    [PATCH] Driver core: change make_class_name() to take kobjects
    
    This is needed for a future patch for the device code to create the
    proper symlinks for devices that are "class devices".
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 79115eff6e94..c3b8dc98b8a7 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -42,4 +42,5 @@ struct class_device_attribute *to_class_dev_attr(struct attribute *_attr)
 	return container_of(_attr, struct class_device_attribute, attr);
 }
 
+extern char *make_class_name(const char *name, struct kobject *kobj);
 

commit 4039483fd3065920f035eed39ec59085421c0a4f
Author: Michael Holzheu <holzheu@de.ibm.com>
Date:   Tue May 9 12:53:49 2006 +0200

    [PATCH] Driver Core: Add /sys/hypervisor when needed
    
    To have a home for all hypervisors, this patch creates /sys/hypervisor.
    A new config option SYS_HYPERVISOR is introduced, which should to be set
    by architecture dependent hypervisors (e.g. s390 or Xen).
    
    Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Michael Holzheu <holzheu@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 122498aef50b..79115eff6e94 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -5,6 +5,11 @@ extern int devices_init(void);
 extern int buses_init(void);
 extern int classes_init(void);
 extern int firmware_init(void);
+#ifdef CONFIG_SYS_HYPERVISOR
+extern int hypervisor_init(void);
+#else
+static inline int hypervisor_init(void) { return 0; }
+#endif
 extern int platform_bus_init(void);
 extern int system_bus_init(void);
 extern int cpu_dev_init(void);

commit 1740757e8f94c6899705eb6f5434de9404992778
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 2 16:59:59 2006 +0200

    [PATCH] Driver Core: remove unused exports
    
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index bbbc2acd921c..122498aef50b 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -13,6 +13,8 @@ extern int attribute_container_init(void);
 extern int bus_add_device(struct device * dev);
 extern void bus_attach_device(struct device * dev);
 extern void bus_remove_device(struct device * dev);
+extern struct bus_type *get_bus(struct bus_type * bus);
+extern void put_bus(struct bus_type * bus);
 
 extern int bus_add_driver(struct device_driver *);
 extern void bus_remove_driver(struct device_driver *);

commit 53877d06d53a412d901bb323f080296c363d8b51
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Tue Apr 4 20:42:26 2006 +0200

    [PATCH] Driver core: bus device event delay
    
    split bus_add_device() and send device uevents after sysfs population
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 5735b38582d0..bbbc2acd921c 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -11,6 +11,7 @@ extern int cpu_dev_init(void);
 extern int attribute_container_init(void);
 
 extern int bus_add_device(struct device * dev);
+extern void bus_attach_device(struct device * dev);
 extern void bus_remove_device(struct device * dev);
 
 extern int bus_add_driver(struct device_driver *);

commit f67d115fe48f494d4b7f4f2024217fe52578915f
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jan 19 17:30:17 2006 +0100

    [PATCH] drivers/base/: proper prototypes
    
    This patch contains the following changes:
    - move prototypes to base.h
    - sys.c should #include "base.h" for getting the prototype of it's
      global function system_bus_init()
    
    Note that hidden in this patch there's a bugfix:
    
    Caller and callee disagreed regarding the return type of
    sysdev_shutdown().
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index e3b548d46cff..5735b38582d0 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -19,6 +19,10 @@ extern void bus_remove_driver(struct device_driver *);
 extern void driver_detach(struct device_driver * drv);
 extern int driver_probe_device(struct device_driver *, struct device *);
 
+extern void sysdev_shutdown(void);
+extern int sysdev_suspend(pm_message_t state);
+extern int sysdev_resume(void);
+
 static inline struct class_device *to_class_dev(struct kobject *obj)
 {
 	return container_of(obj, struct class_device, kobj);

commit a1bdc7aad8b557176ccecff1da137ebe3090871e
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Thu Oct 13 17:54:41 2005 +0100

    [PATCH] drivers/base - fix sparse warnings
    
    There are a number of sparse warnings from the latest sparse
    snapshot being generated from the drivers/base build. The
    main culprits are due to the initialisation functions not
    being declared in a header file.
    
    Also, the firmware.c file should include <linux/device.h>
    to get the prototype of  firmware_register() and
    firmware_unregister().
    
    This patch moves the init function declerations from the
    init.c file to the base.h, and ensures it is included in
    all the relevant c sources. It also adds <linux/device.h>
    to the included headers for firmware.c.
    
    The patch does not solve all the sparse errors generated,
    but reduces the count significantly.
    
    drivers/base/core.c:161:1: warning: symbol 'devices_subsys' was not declared. Should it be static?
    drivers/base/core.c:417:12: warning: symbol 'devices_init' was not declared. Should it be static?
    drivers/base/sys.c:253:6: warning: symbol 'sysdev_shutdown' was not declared. Should it be static?
    drivers/base/sys.c:326:5: warning: symbol 'sysdev_suspend' was not declared. Should it be static?
    drivers/base/sys.c:428:5: warning: symbol 'sysdev_resume' was not declared. Should it be static?
    drivers/base/sys.c:450:12: warning: symbol 'system_bus_init' was not declared. Should it be static?
    drivers/base/bus.c:133:1: warning: symbol 'bus_subsys' was not declared. Should it be static?
    drivers/base/bus.c:667:12: warning: symbol 'buses_init' was not declared. Should it be static?
    drivers/base/class.c:759:12: warning: symbol 'classes_init' was not declared. Should it be static?
    drivers/base/platform.c:313:12: warning: symbol 'platform_bus_init' was not declared. Should it be static?
    drivers/base/cpu.c:110:12: warning: symbol 'cpu_dev_init' was not declared. Should it be static?
    drivers/base/firmware.c:17:5: warning: symbol 'firmware_register' was not declared. Should it be static?
    drivers/base/firmware.c:23:6: warning: symbol 'firmware_unregister' was not declared. Should it be static?
    drivers/base/firmware.c:28:12: warning: symbol 'firmware_init' was not declared. Should it be static?
    drivers/base/init.c:28:13: warning: symbol 'driver_init' was not declared. Should it be static?
    drivers/base/dmapool.c:174:10: warning: implicit cast from nocast type
    drivers/base/attribute_container.c:439:1: warning: symbol 'attribute_container_init' was not declared. Should it be static?
    drivers/base/power/runtime.c:76:6: warning: symbol 'dpm_set_power_state' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 783752b68a9a..e3b548d46cff 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -1,3 +1,15 @@
+
+/* initialisation functions */
+
+extern int devices_init(void);
+extern int buses_init(void);
+extern int classes_init(void);
+extern int firmware_init(void);
+extern int platform_bus_init(void);
+extern int system_bus_init(void);
+extern int cpu_dev_init(void);
+extern int attribute_container_init(void);
+
 extern int bus_add_device(struct device * dev);
 extern void bus_remove_device(struct device * dev);
 

commit afdce75f1eaebcf358b7594ba7969aade105c3b0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 22 16:09:05 2005 -0700

    [PATCH] driver core: Add the ability to bind drivers to devices from userspace
    
    This adds a single file, "bind", to the sysfs directory of every driver
    registered with the driver core.  To bind a device to a driver, write
    the bus id of the device you wish to bind to that specific driver to the
    "bind" file (remember to not add a trailing \n).  If that bus id matches
    a device on that bus, and it does not currently have a driver bound to
    it, the probe sequence will be initiated with that driver and device.
    
    Note, this requires that the driver itself be willing and able to accept
    that device (usually through a device id type table).  This patch does
    not make it possible to override the driver's id table.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 645f62692920..783752b68a9a 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -5,6 +5,7 @@ extern int bus_add_driver(struct device_driver *);
 extern void bus_remove_driver(struct device_driver *);
 
 extern void driver_detach(struct device_driver * drv);
+extern int driver_probe_device(struct device_driver *, struct device *);
 
 static inline struct class_device *to_class_dev(struct kobject *obj)
 {

commit 07e4a3e27fe414980ddc85a358e5a56abc48b363
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 10:52:54 2005 -0800

    [PATCH] Move device/driver code to drivers/base/dd.c
    
    This relocates the driver binding/unbinding code to drivers/base/dd.c. This is done
    for two reasons: One, it's not code related to the bus_type itself; it uses some from
    that, some from devices, and some from drivers. And Two, it will make it easier to do
    some of the upcoming lock removal on that code..
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/base.h b/drivers/base/base.h
index 8d1e8bd48632..645f62692920 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -4,6 +4,8 @@ extern void bus_remove_device(struct device * dev);
 extern int bus_add_driver(struct device_driver *);
 extern void bus_remove_driver(struct device_driver *);
 
+extern void driver_detach(struct device_driver * drv);
+
 static inline struct class_device *to_class_dev(struct kobject *obj)
 {
 	return container_of(obj, struct class_device, kobj);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/base/base.h b/drivers/base/base.h
new file mode 100644
index 000000000000..8d1e8bd48632
--- /dev/null
+++ b/drivers/base/base.h
@@ -0,0 +1,18 @@
+extern int bus_add_device(struct device * dev);
+extern void bus_remove_device(struct device * dev);
+
+extern int bus_add_driver(struct device_driver *);
+extern void bus_remove_driver(struct device_driver *);
+
+static inline struct class_device *to_class_dev(struct kobject *obj)
+{
+	return container_of(obj, struct class_device, kobj);
+}
+
+static inline
+struct class_device_attribute *to_class_dev_attr(struct attribute *_attr)
+{
+	return container_of(_attr, struct class_device_attribute, attr);
+}
+
+
