commit 87de6594dc45dbf6819f3e0ef92f9331c5a9444c
Author: Neeraj Upadhyay <neeraju@codeaurora.org>
Date:   Mon Mar 23 10:38:51 2020 +0530

    PM: sleep: wakeup: Skip wakeup_source_sysfs_remove() if device is not there
    
    Skip wakeup_source_sysfs_remove() to fix a NULL pinter dereference via
    ws->dev, if the wakeup source is unregistered before registering the
    wakeup class from device_add().
    
    Fixes: 2ca3d1ecb8c4 ("PM / wakeup: Register wakeup class kobj after device is added")
    Signed-off-by: Neeraj Upadhyay <neeraju@codeaurora.org>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    [ rjw: Subject & changelog, white space ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 7e33a8d829dc..92073ac68473 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -244,7 +244,9 @@ void wakeup_source_unregister(struct wakeup_source *ws)
 {
 	if (ws) {
 		wakeup_source_remove(ws);
-		wakeup_source_sysfs_remove(ws);
+		if (ws->dev)
+			wakeup_source_sysfs_remove(ws);
+
 		wakeup_source_destroy(ws);
 	}
 }

commit 2591e7b17c0d3f1472f9ddb2dd5922f24fc5e4d9
Author: Madhuparna Bhowmik <madhuparnabhowmik10@gmail.com>
Date:   Wed Mar 4 01:12:09 2020 +0530

    PM: sleep: wakeup: Use built-in RCU list checking
    
    Pass cond argument to list_for_each_entry_rcu() to fix the
    following false positive lockdep warning and other uses of
    list_for_each_entry_rcu() in wakeup.c.
    (CONFIG_PROVE_RCU_LIST = y)
    
    [  331.934648] =============================
    [  331.934650] WARNING: suspicious RCU usage
    [  331.934653] 5.6.0-rc1+ #5 Not tainted
    [  331.934655] -----------------------------
    [  331.934657] drivers/base/power/wakeup.c:408 RCU-list traversed in non-reader section!!
    
    [  333.025156] =============================
    [  333.025161] WARNING: suspicious RCU usage
    [  333.025168] 5.6.0-rc1+ #5 Not tainted
    [  333.025173] -----------------------------
    [  333.025180] drivers/base/power/wakeup.c:424 RCU-list traversed in non-reader section!!
    
    Signed-off-by: Madhuparna Bhowmik <madhuparnabhowmik10@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 27f3e60608e5..7e33a8d829dc 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -24,6 +24,9 @@ suspend_state_t pm_suspend_target_state;
 #define pm_suspend_target_state	(PM_SUSPEND_ON)
 #endif
 
+#define list_for_each_entry_rcu_locked(pos, head, member) \
+	list_for_each_entry_rcu(pos, head, member, \
+		srcu_read_lock_held(&wakeup_srcu))
 /*
  * If set, the suspend/hibernate code will abort transitions to a sleep state
  * if wakeup events are registered during or immediately before the transition.
@@ -405,7 +408,7 @@ void device_wakeup_arm_wake_irqs(void)
 	int srcuidx;
 
 	srcuidx = srcu_read_lock(&wakeup_srcu);
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+	list_for_each_entry_rcu_locked(ws, &wakeup_sources, entry)
 		dev_pm_arm_wake_irq(ws->wakeirq);
 	srcu_read_unlock(&wakeup_srcu, srcuidx);
 }
@@ -421,7 +424,7 @@ void device_wakeup_disarm_wake_irqs(void)
 	int srcuidx;
 
 	srcuidx = srcu_read_lock(&wakeup_srcu);
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+	list_for_each_entry_rcu_locked(ws, &wakeup_sources, entry)
 		dev_pm_disarm_wake_irq(ws->wakeirq);
 	srcu_read_unlock(&wakeup_srcu, srcuidx);
 }
@@ -874,7 +877,7 @@ void pm_print_active_wakeup_sources(void)
 	struct wakeup_source *last_activity_ws = NULL;
 
 	srcuidx = srcu_read_lock(&wakeup_srcu);
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+	list_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {
 		if (ws->active) {
 			pm_pr_dbg("active wakeup source: %s\n", ws->name);
 			active = 1;
@@ -1025,7 +1028,7 @@ void pm_wakep_autosleep_enabled(bool set)
 	int srcuidx;
 
 	srcuidx = srcu_read_lock(&wakeup_srcu);
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+	list_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {
 		spin_lock_irq(&ws->lock);
 		if (ws->autosleep_enabled != set) {
 			ws->autosleep_enabled = set;
@@ -1104,7 +1107,7 @@ static void *wakeup_sources_stats_seq_start(struct seq_file *m,
 	}
 
 	*srcuidx = srcu_read_lock(&wakeup_srcu);
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+	list_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {
 		if (n-- <= 0)
 			return ws;
 	}

commit e976eb4b91e906f20ec25b20c152d53c472fc3fd
Author: zhuguangqing <zhuguangqing@xiaomi.com>
Date:   Mon Dec 9 17:35:23 2019 +0800

    PM: wakeup: Show statistics for deleted wakeup sources again
    
    After commit 00ee22c28915 (PM / wakeup: Use seq_open() to show wakeup
    stats), print_wakeup_source_stats(m, &deleted_ws) is not called from
    wakeup_sources_stats_seq_show() any more.
    
    Because deleted_ws is one of the wakeup sources, it should be shown
    too, so add it to the end of all other wakeup sources.
    
    Signed-off-by: zhuguangqing <zhuguangqing@xiaomi.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 70a9edb5f525..27f3e60608e5 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -1125,6 +1125,9 @@ static void *wakeup_sources_stats_seq_next(struct seq_file *m,
 		break;
 	}
 
+	if (!next_ws)
+		print_wakeup_source_stats(m, &deleted_ws);
+
 	return next_ws;
 }
 

commit b4941adb24c0676f77ddc25e6d7836b8245c47fc
Author: Ran Wang <ran.wang_1@nxp.com>
Date:   Thu Oct 24 17:26:42 2019 +0800

    PM: wakeup: Add routine to help fetch wakeup source object.
    
    Some user might want to go through all registered wakeup sources
    and doing things accordingly. For example, SoC PM driver might need to
    do HW programming to prevent powering down specific IP which wakeup
    source depending on. So add this API to help walk through all registered
    wakeup source objects on that list and return them one by one.
    
    Signed-off-by: Ran Wang <ran.wang_1@nxp.com>
    Tested-by: Leonard Crestez <leonard.crestez@nxp.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Li Yang <leoyang.li@nxp.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 5817b51d2b15..70a9edb5f525 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -247,6 +247,60 @@ void wakeup_source_unregister(struct wakeup_source *ws)
 }
 EXPORT_SYMBOL_GPL(wakeup_source_unregister);
 
+/**
+ * wakeup_sources_read_lock - Lock wakeup source list for read.
+ *
+ * Returns an index of srcu lock for struct wakeup_srcu.
+ * This index must be passed to the matching wakeup_sources_read_unlock().
+ */
+int wakeup_sources_read_lock(void)
+{
+	return srcu_read_lock(&wakeup_srcu);
+}
+EXPORT_SYMBOL_GPL(wakeup_sources_read_lock);
+
+/**
+ * wakeup_sources_read_unlock - Unlock wakeup source list.
+ * @idx: return value from corresponding wakeup_sources_read_lock()
+ */
+void wakeup_sources_read_unlock(int idx)
+{
+	srcu_read_unlock(&wakeup_srcu, idx);
+}
+EXPORT_SYMBOL_GPL(wakeup_sources_read_unlock);
+
+/**
+ * wakeup_sources_walk_start - Begin a walk on wakeup source list
+ *
+ * Returns first object of the list of wakeup sources.
+ *
+ * Note that to be safe, wakeup sources list needs to be locked by calling
+ * wakeup_source_read_lock() for this.
+ */
+struct wakeup_source *wakeup_sources_walk_start(void)
+{
+	struct list_head *ws_head = &wakeup_sources;
+
+	return list_entry_rcu(ws_head->next, struct wakeup_source, entry);
+}
+EXPORT_SYMBOL_GPL(wakeup_sources_walk_start);
+
+/**
+ * wakeup_sources_walk_next - Get next wakeup source from the list
+ * @ws: Previous wakeup source object
+ *
+ * Note that to be safe, wakeup sources list needs to be locked by calling
+ * wakeup_source_read_lock() for this.
+ */
+struct wakeup_source *wakeup_sources_walk_next(struct wakeup_source *ws)
+{
+	struct list_head *ws_head = &wakeup_sources;
+
+	return list_next_or_null_rcu(ws_head, &ws->entry,
+				struct wakeup_source, entry);
+}
+EXPORT_SYMBOL_GPL(wakeup_sources_walk_next);
+
 /**
  * device_wakeup_attach - Attach a wakeup source object to a device object.
  * @dev: Device to handle.

commit 1b531e55c52bbe2927e2c3490d47c82113d303e7
Merge: 78c0f050847c b90ff3554aa3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 17 09:35:35 2019 +0200

    Merge suspend-to-idle rework material for v5.4.
    
    * pm-s2idle-rework: (21 commits)
      ACPI: PM: s2idle: Always set up EC GPE for system wakeup
      ACPI: PM: s2idle: Avoid rearming SCI for wakeup unnecessarily
      PM: suspend: Fix platform_suspend_prepare_noirq()
      intel-hid: Disable button array during suspend-to-idle
      intel-hid: intel-vbtn: Avoid leaking wakeup_mode set
      ACPI: PM: s2idle: Execute LPS0 _DSM functions with suspended devices
      ACPI: EC: PM: Make acpi_ec_dispatch_gpe() print debug message
      ACPI: EC: PM: Consolidate some code depending on PM_SLEEP
      ACPI: PM: s2idle: Eliminate acpi_sleep_no_ec_events()
      ACPI: PM: s2idle: Switch EC over to polling during "noirq" suspend
      ACPI: PM: s2idle: Add acpi.sleep_no_lps0 module parameter
      ACPI: PM: s2idle: Rearrange lps0_device_attach()
      ACPI: PM: Set up EC GPE for system wakeup from drivers that need it
      PM: sleep: Drop dpm_noirq_begin() and dpm_noirq_end()
      PM: sleep: Integrate suspend-to-idle with generig suspend flow
      PM: sleep: Simplify suspend-to-idle control flow
      ACPI: PM: Set s2idle_wakeup earlier and clear it later
      PM: sleep: Fix possible overflow in pm_system_cancel_wakeup()
      ACPI: EC: Return bool from acpi_ec_dispatch_gpe()
      ACPICA: Return u32 from acpi_dispatch_gpe()
      ...

commit 2ca3d1ecb8c432ee212d80fa7615cdd5d1df62e3
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Mon Aug 19 15:41:57 2019 -0700

    PM / wakeup: Register wakeup class kobj after device is added
    
    The device_set_wakeup_enable() function can be called on a device that
    hasn't been registered with device_add() yet. This allows the device to
    be in a state where wakeup is enabled for it but the device isn't
    published to userspace in sysfs yet.
    
    After commit c8377adfa781 ("PM / wakeup: Show wakeup sources stats in
    sysfs"), calling device_set_wakeup_enable() will fail for a device that
    hasn't been registered with the driver core via device_add(). This is
    because we try to create sysfs entries for the device and associate a
    wakeup class kobject with it before the device has been registered.
    Let's follow a similar approach that device_set_wakeup_capable() takes
    here and register the wakeup class either from
    device_set_wakeup_enable() when the device is already registered, or
    from dpm_sysfs_add() when the device is being registered with the driver
    core via device_add().
    
    Fixes: c8377adfa781 ("PM / wakeup: Show wakeup sources stats in sysfs")
    Reported-by: Qian Cai <cai@lca.pw>
    Reviewed-by: Tri Vo <trong@android.com>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 036469528f88..e58b070985b1 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -220,10 +220,12 @@ struct wakeup_source *wakeup_source_register(struct device *dev,
 
 	ws = wakeup_source_create(name);
 	if (ws) {
-		ret = wakeup_source_sysfs_add(dev, ws);
-		if (ret) {
-			wakeup_source_free(ws);
-			return NULL;
+		if (!dev || device_is_registered(dev)) {
+			ret = wakeup_source_sysfs_add(dev, ws);
+			if (ret) {
+				wakeup_source_free(ws);
+				return NULL;
+			}
 		}
 		wakeup_source_add(ws);
 	}

commit ae367b7936408444afc76a8a3e141abede9ccbe4
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Aug 13 17:40:53 2019 -0700

    PM / wakeup: Fix sysfs registration error path
    
    We shouldn't call wakeup_source_destroy() from the error path in
    wakeup_source_register() because that calls __pm_relax() which takes a
    lock that isn't initialized until wakeup_source_add() is called. Add a
    new function, wakeup_source_free(), that just does the bare minimum to
    free a wakeup source that was created but hasn't been added yet and use
    it from the two places it's needed. This fixes the following problem
    seen on various x86 server boxes:
    
     INFO: trying to register non-static key.
     the code is fine but needs lockdep annotation.
     turning off the locking correctness validator.
     CPU: 12 PID: 1 Comm: swapper/0 Not tainted 5.3.0-rc4-
     Hardware name: HP ProLiant XL420 Gen9/ProLiant XL420 Gen9, BIOS U19 12/27/2015
     Call Trace:
      dump_stack+0x62/0x9a
      register_lock_class+0x95a/0x960
      ? __platform_driver_probe+0xcd/0x230
      ? __platform_create_bundle+0xc0/0xe0
      ? i8042_init+0x4ec/0x578
      ? do_one_initcall+0xfe/0x45a
      ? kernel_init_freeable+0x614/0x6a7
      ? kernel_init+0x11/0x138
      ? ret_from_fork+0x35/0x40
      ? is_dynamic_key+0xf0/0xf0
      ? rwlock_bug.part.0+0x60/0x60
      ? __debug_check_no_obj_freed+0x8e/0x250
      __lock_acquire.isra.13+0x5f/0x830
      ? __debug_check_no_obj_freed+0x152/0x250
      lock_acquire+0x107/0x220
      ? __pm_relax.part.2+0x21/0xa0
      _raw_spin_lock_irqsave+0x35/0x50
      ? __pm_relax.part.2+0x21/0xa0
      __pm_relax.part.2+0x21/0xa0
      wakeup_source_destroy.part.3+0x18/0x190
      wakeup_source_register+0x43/0x50
    
    Fixes: c8377adfa781 ("PM / wakeup: Show wakeup sources stats in sysfs")
    Reported-by: Qian Cai <cai@lca.pw>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 973675f24314..036469528f88 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -137,6 +137,13 @@ static void wakeup_source_record(struct wakeup_source *ws)
 	spin_unlock_irqrestore(&deleted_ws.lock, flags);
 }
 
+static void wakeup_source_free(struct wakeup_source *ws)
+{
+	ida_free(&wakeup_ida, ws->id);
+	kfree_const(ws->name);
+	kfree(ws);
+}
+
 /**
  * wakeup_source_destroy - Destroy a struct wakeup_source object.
  * @ws: Wakeup source to destroy.
@@ -150,9 +157,7 @@ void wakeup_source_destroy(struct wakeup_source *ws)
 
 	__pm_relax(ws);
 	wakeup_source_record(ws);
-	ida_free(&wakeup_ida, ws->id);
-	kfree_const(ws->name);
-	kfree(ws);
+	wakeup_source_free(ws);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_destroy);
 
@@ -217,7 +222,7 @@ struct wakeup_source *wakeup_source_register(struct device *dev,
 	if (ws) {
 		ret = wakeup_source_sysfs_add(dev, ws);
 		if (ret) {
-			wakeup_source_destroy(ws);
+			wakeup_source_free(ws);
 			return NULL;
 		}
 		wakeup_source_add(ws);

commit c8377adfa78103be5380200eb9dab764d7ca890e
Author: Tri Vo <trong@android.com>
Date:   Tue Aug 6 18:48:46 2019 -0700

    PM / wakeup: Show wakeup sources stats in sysfs
    
    Add an ID and a device pointer to 'struct wakeup_source'. Use them to to
    expose wakeup sources statistics in sysfs under
    /sys/class/wakeup/wakeup<ID>/*.
    
    Co-developed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Co-developed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Tri Vo <trong@android.com>
    Tested-by: Kalesh Singh <kaleshsingh@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 3938892c8903..973675f24314 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -72,6 +72,8 @@ static struct wakeup_source deleted_ws = {
 	.lock =  __SPIN_LOCK_UNLOCKED(deleted_ws.lock),
 };
 
+static DEFINE_IDA(wakeup_ida);
+
 /**
  * wakeup_source_create - Create a struct wakeup_source object.
  * @name: Name of the new wakeup source.
@@ -80,6 +82,7 @@ struct wakeup_source *wakeup_source_create(const char *name)
 {
 	struct wakeup_source *ws;
 	const char *ws_name;
+	int id;
 
 	ws = kzalloc(sizeof(*ws), GFP_KERNEL);
 	if (!ws)
@@ -90,8 +93,15 @@ struct wakeup_source *wakeup_source_create(const char *name)
 		goto err_name;
 	ws->name = ws_name;
 
+	id = ida_alloc(&wakeup_ida, GFP_KERNEL);
+	if (id < 0)
+		goto err_id;
+	ws->id = id;
+
 	return ws;
 
+err_id:
+	kfree_const(ws->name);
 err_name:
 	kfree(ws);
 err_ws:
@@ -140,6 +150,7 @@ void wakeup_source_destroy(struct wakeup_source *ws)
 
 	__pm_relax(ws);
 	wakeup_source_record(ws);
+	ida_free(&wakeup_ida, ws->id);
 	kfree_const(ws->name);
 	kfree(ws);
 }
@@ -193,16 +204,24 @@ EXPORT_SYMBOL_GPL(wakeup_source_remove);
 
 /**
  * wakeup_source_register - Create wakeup source and add it to the list.
+ * @dev: Device this wakeup source is associated with (or NULL if virtual).
  * @name: Name of the wakeup source to register.
  */
-struct wakeup_source *wakeup_source_register(const char *name)
+struct wakeup_source *wakeup_source_register(struct device *dev,
+					     const char *name)
 {
 	struct wakeup_source *ws;
+	int ret;
 
 	ws = wakeup_source_create(name);
-	if (ws)
+	if (ws) {
+		ret = wakeup_source_sysfs_add(dev, ws);
+		if (ret) {
+			wakeup_source_destroy(ws);
+			return NULL;
+		}
 		wakeup_source_add(ws);
-
+	}
 	return ws;
 }
 EXPORT_SYMBOL_GPL(wakeup_source_register);
@@ -215,6 +234,7 @@ void wakeup_source_unregister(struct wakeup_source *ws)
 {
 	if (ws) {
 		wakeup_source_remove(ws);
+		wakeup_source_sysfs_remove(ws);
 		wakeup_source_destroy(ws);
 	}
 }
@@ -258,7 +278,7 @@ int device_wakeup_enable(struct device *dev)
 	if (pm_suspend_target_state != PM_SUSPEND_ON)
 		dev_dbg(dev, "Suspicious %s() during system transition!\n", __func__);
 
-	ws = wakeup_source_register(dev_name(dev));
+	ws = wakeup_source_register(dev, dev_name(dev));
 	if (!ws)
 		return -ENOMEM;
 

commit 0d105d0f25386ee5b74603db6d249ebed7590cbc
Author: Tri Vo <trong@android.com>
Date:   Tue Aug 6 18:48:44 2019 -0700

    PM / wakeup: Drop wakeup_source_init(), wakeup_source_prepare()
    
    wakeup_source_init() has no users. Remove it.
    
    As a result, wakeup_source_prepare() is only called from
    wakeup_source_create(). Merge wakeup_source_prepare() into
    wakeup_source_create() and remove it.
    
    Change wakeup_source_create() behavior so that assigning NULL to wakeup
    source's name throws an error.
    
    Signed-off-by: Tri Vo <trong@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index ee31d4f8d856..3938892c8903 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -72,23 +72,6 @@ static struct wakeup_source deleted_ws = {
 	.lock =  __SPIN_LOCK_UNLOCKED(deleted_ws.lock),
 };
 
-/**
- * wakeup_source_prepare - Prepare a new wakeup source for initialization.
- * @ws: Wakeup source to prepare.
- * @name: Pointer to the name of the new wakeup source.
- *
- * Callers must ensure that the @name string won't be freed when @ws is still in
- * use.
- */
-void wakeup_source_prepare(struct wakeup_source *ws, const char *name)
-{
-	if (ws) {
-		memset(ws, 0, sizeof(*ws));
-		ws->name = name;
-	}
-}
-EXPORT_SYMBOL_GPL(wakeup_source_prepare);
-
 /**
  * wakeup_source_create - Create a struct wakeup_source object.
  * @name: Name of the new wakeup source.
@@ -96,13 +79,23 @@ EXPORT_SYMBOL_GPL(wakeup_source_prepare);
 struct wakeup_source *wakeup_source_create(const char *name)
 {
 	struct wakeup_source *ws;
+	const char *ws_name;
 
-	ws = kmalloc(sizeof(*ws), GFP_KERNEL);
+	ws = kzalloc(sizeof(*ws), GFP_KERNEL);
 	if (!ws)
-		return NULL;
+		goto err_ws;
+
+	ws_name = kstrdup_const(name, GFP_KERNEL);
+	if (!ws_name)
+		goto err_name;
+	ws->name = ws_name;
 
-	wakeup_source_prepare(ws, name ? kstrdup_const(name, GFP_KERNEL) : NULL);
 	return ws;
+
+err_name:
+	kfree(ws);
+err_ws:
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(wakeup_source_create);
 

commit 2933954b71f10d392764f95eec0f0aa2d103054b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 15 13:03:48 2019 +0200

    PM: sleep: Fix possible overflow in pm_system_cancel_wakeup()
    
    It is not actually guaranteed that pm_abort_suspend will be
    nonzero when pm_system_cancel_wakeup() is called which may lead to
    subtle issues, so make it use atomic_dec_if_positive() instead of
    atomic_dec() for the safety sake.
    
    Fixes: 33e4f80ee69b ("ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index ee31d4f8d856..b30c45aad10f 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -859,7 +859,7 @@ EXPORT_SYMBOL_GPL(pm_system_wakeup);
 
 void pm_system_cancel_wakeup(void)
 {
-	atomic_dec(&pm_abort_suspend);
+	atomic_dec_if_positive(&pm_abort_suspend);
 }
 
 void pm_wakeup_clear(bool reset)

commit 25fa4d9d4ca62dbf8fd1eeef413421c94183da3c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jun 18 17:34:16 2019 +0200

    drivers: base: power: remove wakeup_sources_stats_dentry variable
    
    wakeup_sources_stats_dentry is assigned when the debugfs file is
    created, but then never used ever again.  So no need for it at all, just
    remove it and call debugfs_create_file() on its own.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 5b2b6a05a4f3..ee31d4f8d856 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -968,8 +968,6 @@ void pm_wakep_autosleep_enabled(bool set)
 }
 #endif /* CONFIG_PM_AUTOSLEEP */
 
-static struct dentry *wakeup_sources_stats_dentry;
-
 /**
  * print_wakeup_source_stats - Print wakeup source statistics information.
  * @m: seq_file to print the statistics into.
@@ -1099,8 +1097,8 @@ static const struct file_operations wakeup_sources_stats_fops = {
 
 static int __init wakeup_sources_debugfs_init(void)
 {
-	wakeup_sources_stats_dentry = debugfs_create_file("wakeup_sources",
-			S_IRUGO, NULL, NULL, &wakeup_sources_stats_fops);
+	debugfs_create_file("wakeup_sources", S_IRUGO, NULL, NULL,
+			    &wakeup_sources_stats_fops);
 	return 0;
 }
 

commit cf482a49af564a3044de3178ea28f10ad5921b38
Merge: 01e5d1830cf5 70e16a620e07
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 13:01:40 2019 -0700

    Merge tag 'driver-core-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core/kobject updates from Greg KH:
     "Here is the "big" set of driver core patches for 5.2-rc1
    
      There are a number of ACPI patches in here as well, as Rafael said
      they should go through this tree due to the driver core changes they
      required. They have all been acked by the ACPI developers.
    
      There are also a number of small subsystem-specific changes in here,
      due to some changes to the kobject core code. Those too have all been
      acked by the various subsystem maintainers.
    
      As for content, it's pretty boring outside of the ACPI changes:
       - spdx cleanups
       - kobject documentation updates
       - default attribute groups for kobjects
       - other minor kobject/driver core fixes
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (47 commits)
      kobject: clean up the kobject add documentation a bit more
      kobject: Fix kernel-doc comment first line
      kobject: Remove docstring reference to kset
      firmware_loader: Fix a typo ("syfs" -> "sysfs")
      kobject: fix dereference before null check on kobj
      Revert "driver core: platform: Fix the usage of platform device name(pdev->name)"
      init/config: Do not select BUILD_BIN2C for IKCONFIG
      Provide in-kernel headers to make extending kernel easier
      kobject: Improve doc clarity kobject_init_and_add()
      kobject: Improve docs for kobject_add/del
      driver core: platform: Fix the usage of platform device name(pdev->name)
      livepatch: Replace klp_ktype_patch's default_attrs with groups
      cpufreq: schedutil: Replace default_attrs field with groups
      padata: Replace padata_attr_type default_attrs field with groups
      irqdesc: Replace irq_kobj_type's default_attrs field with groups
      net-sysfs: Replace ktype default_attrs field with groups
      block: Replace all ktype default_attrs with groups
      samples/kobject: Replace foo_ktype's default_attrs field with groups
      kobject: Add support for default attribute groups to kobj_type
      driver core: Postpone DMA tear-down until after devres release for probe failure
      ...

commit 5de363b66a37a0193e28a2de64fa4996159bd5ee
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 15:32:01 2019 +0200

    drivers: base: power: add proper SPDX identifiers on files that did not have them.
    
    There were a few files in the driver core power code that did not have
    SPDX identifiers on them, so fix that up.  At the same time, remove the
    "free form" text that specified the license of the file, as that is
    impossible for any tool to properly parse.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index bb1ae175fae1..9066b2dfc3e1 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -1,11 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/base/power/wakeup.c - System wakeup events framework
  *
  * Copyright (c) 2010 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
- *
- * This file is released under the GPLv2.
  */
-
 #define pr_fmt(fmt) "PM: " fmt
 
 #include <linux/device.h>

commit 74a1dd86d1739eae2015a3832f62c1d6546893a7
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Mon Mar 25 10:24:56 2019 -0700

    PM / wakeup: Use pm_pr_dbg() instead of pr_debug()
    
    These prints are useful if we're doing PM suspend debugging. Having them
    at pr_debug() level means that we need to either enable DEBUG in this
    file, or compile the kernel with dynamic debug capabilities. Both of
    these options have drawbacks like custom compilation or opting into all
    debug statements being included into the kernel image. Given that we
    already have infrastructure to collect PM debugging information with
    CONFIG_PM_DEBUG and friends, let's change the pr_debug usage here to be
    pm_pr_dbg() instead so we can collect the wakeup information in the
    kernel logs.
    
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index bb1ae175fae1..23c243a4c675 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -804,7 +804,7 @@ void pm_print_active_wakeup_sources(void)
 	srcuidx = srcu_read_lock(&wakeup_srcu);
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
 		if (ws->active) {
-			pr_debug("active wakeup source: %s\n", ws->name);
+			pm_pr_dbg("active wakeup source: %s\n", ws->name);
 			active = 1;
 		} else if (!active &&
 			   (!last_activity_ws ||
@@ -815,7 +815,7 @@ void pm_print_active_wakeup_sources(void)
 	}
 
 	if (!active && last_activity_ws)
-		pr_debug("last active wakeup source: %s\n",
+		pm_pr_dbg("last active wakeup source: %s\n",
 			last_activity_ws->name);
 	srcu_read_unlock(&wakeup_srcu, srcuidx);
 }
@@ -845,7 +845,7 @@ bool pm_wakeup_pending(void)
 	raw_spin_unlock_irqrestore(&events_lock, flags);
 
 	if (ret) {
-		pr_debug("Wakeup pending, aborting suspend\n");
+		pm_pr_dbg("Wakeup pending, aborting suspend\n");
 		pm_print_active_wakeup_sources();
 	}
 

commit e6035258dbf9804b8e22878d3932e418c8875963
Merge: 7a5bd1279bce 0996584b3026 623217a0cc45 07a6c71bbd4a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 14 10:51:38 2019 +0100

    Merge branches 'pm-core', 'pm-sleep' and 'pm-qos'
    
    * pm-core:
      PM-runtime: Call pm_runtime_active|suspended_time() from sysfs
      PM-runtime: Consolidate code to get active/suspended time
    
    * pm-sleep:
      PM / wakeup: Drop wakeup_source_drop()
      PM / wakeup: Rework wakeup source timer cancellation
    
    * pm-qos:
      PM / QoS: Fix typo in file description

commit 623217a0cc45a6c179303b3bbfdc594806a464cc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 11 12:53:59 2019 +0100

    PM / wakeup: Drop wakeup_source_drop()
    
    After commit d856f39ac1cc ("PM / wakeup: Rework wakeup source timer
    cancellation") wakeup_source_drop() is a trivial wrapper around
    __pm_relax() and it has no users except for wakeup_source_destroy()
    and wakeup_source_trash() which also has no users, so drop it along
    with the latter and make wakeup_source_destroy() call __pm_relax()
    directly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index a25d2d82f44d..ecbe152d151f 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -106,22 +106,6 @@ struct wakeup_source *wakeup_source_create(const char *name)
 }
 EXPORT_SYMBOL_GPL(wakeup_source_create);
 
-/**
- * wakeup_source_drop - Prepare a struct wakeup_source object for destruction.
- * @ws: Wakeup source to prepare for destruction.
- *
- * Callers must ensure that __pm_stay_awake() or __pm_wakeup_event() will never
- * be run in parallel with this function for the same wakeup source object.
- */
-void wakeup_source_drop(struct wakeup_source *ws)
-{
-	if (!ws)
-		return;
-
-	__pm_relax(ws);
-}
-EXPORT_SYMBOL_GPL(wakeup_source_drop);
-
 /*
  * Record wakeup_source statistics being deleted into a dummy wakeup_source.
  */
@@ -161,7 +145,7 @@ void wakeup_source_destroy(struct wakeup_source *ws)
 	if (!ws)
 		return;
 
-	wakeup_source_drop(ws);
+	__pm_relax(ws);
 	wakeup_source_record(ws);
 	kfree_const(ws->name);
 	kfree(ws);

commit 1fad17fb1bbcd73159c2b992668a6957ecc5af8a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Mar 8 15:23:11 2019 +0530

    PM / wakeup: Rework wakeup source timer cancellation
    
    If wakeup_source_add() is called right after wakeup_source_remove()
    for the same wakeup source, timer_setup() may be called for a
    potentially scheduled timer which is incorrect.
    
    To avoid that, move the wakeup source timer cancellation from
    wakeup_source_drop() to wakeup_source_remove().
    
    Moreover, make wakeup_source_remove() clear the timer function after
    canceling the timer to let wakeup_source_not_registered() treat
    unregistered wakeup sources in the same way as the ones that have
    never been registered.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 4.4+ <stable@vger.kernel.org> # 4.4+
    [ rjw: Subject, changelog, merged two patches together ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index f1fee72ed970..a25d2d82f44d 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -118,7 +118,6 @@ void wakeup_source_drop(struct wakeup_source *ws)
 	if (!ws)
 		return;
 
-	del_timer_sync(&ws->timer);
 	__pm_relax(ws);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_drop);
@@ -205,6 +204,13 @@ void wakeup_source_remove(struct wakeup_source *ws)
 	list_del_rcu(&ws->entry);
 	raw_spin_unlock_irqrestore(&events_lock, flags);
 	synchronize_srcu(&wakeup_srcu);
+
+	del_timer_sync(&ws->timer);
+	/*
+	 * Clear timer.function to make wakeup_source_not_registered() treat
+	 * this wakeup source as not registered.
+	 */
+	ws->timer.function = NULL;
 }
 EXPORT_SYMBOL_GPL(wakeup_source_remove);
 

commit 7a5bd1279bce2116af67979bea311a0ccc4b8bb9
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 4 09:14:38 2019 -0800

    PM: Add and use pr_fmt()
    
    Prefix all printk/pr_<level> messages with "PM: " to make the
    logging a bit more consistent.
    
    Miscellanea:
    
     o Convert a few printks to pr_<level>
     o Whitespace to align to open parentheses
     o Remove embedded "PM: " from pr_debugs as pr_fmt adds it
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index f1fee72ed970..d0e77d56c1d9 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -6,6 +6,8 @@
  * This file is released under the GPLv2.
  */
 
+#define pr_fmt(fmt) "PM: " fmt
+
 #include <linux/device.h>
 #include <linux/slab.h>
 #include <linux/sched/signal.h>
@@ -853,7 +855,7 @@ bool pm_wakeup_pending(void)
 	raw_spin_unlock_irqrestore(&events_lock, flags);
 
 	if (ret) {
-		pr_debug("PM: Wakeup pending, aborting suspend\n");
+		pr_debug("Wakeup pending, aborting suspend\n");
 		pm_print_active_wakeup_sources();
 	}
 

commit d1c6b41b0f65d4c3933505f598b9f69873744404
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Wed Jan 23 11:22:01 2019 -0500

    PM / wakeup: fix kerneldoc comment for pm_wakeup_dev_event()
    
    This brings the kernel doc in line with the function signature.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 5fa1898755a3..f1fee72ed970 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -783,7 +783,7 @@ void pm_wakeup_ws_event(struct wakeup_source *ws, unsigned int msec, bool hard)
 EXPORT_SYMBOL_GPL(pm_wakeup_ws_event);
 
 /**
- * pm_wakeup_event - Notify the PM core of a wakeup event.
+ * pm_wakeup_dev_event - Notify the PM core of a wakeup event.
  * @dev: Device the wakeup event is related to.
  * @msec: Anticipated event processing time (in milliseconds).
  * @hard: If set, abort suspends in progress and wake up from suspend-to-idle.

commit a24e16b1310ce7f474aa0caca0e66f0f174c022f
Merge: 601ef1f3c0df 60ee031aabbe 68e22011856f fc14eebfc208 b8281fa71de2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 4 10:41:53 2018 +0200

    Merge branches 'pm-pci', 'acpi-pm', 'pm-sleep' and 'pm-avs'
    
    * pm-pci:
      PCI / PM: Clean up outdated comments in pci_target_state()
      PCI / PM: Do not clear state_saved for devices that remain suspended
    
    * acpi-pm:
      ACPI: EC: Dispatch the EC GPE directly on s2idle wake
      ACPICA: Introduce acpi_dispatch_gpe()
    
    * pm-sleep:
      PM / hibernate: Fix oops at snapshot_write()
      PM / wakeup: Make s2idle_lock a RAW_SPINLOCK
      PM / s2idle: Make s2idle_wait_head swait based
      PM / wakeup: Make events_lock a RAW_SPINLOCK
      PM / suspend: Prevent might sleep splats
    
    * pm-avs:
      PM / AVS: rockchip-io: add io selectors and supplies for PX30

commit bccaadab5c17ae20077bd93c44e2005b505791ba
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri May 25 11:46:46 2018 +0200

    PM / wakeup: Make events_lock a RAW_SPINLOCK
    
    The `events_lock' is acquired during suspend while interrupts are
    disabled even on RT. The lock is taken only for a very brief moment.
    Make it a RAW lock which avoids "sleeping while atomic" warnings on RT.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index ea01621ed769..2e76fbcba76e 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -57,7 +57,7 @@ static void split_counters(unsigned int *cnt, unsigned int *inpr)
 /* A preserved old value of the events counter. */
 static unsigned int saved_count;
 
-static DEFINE_SPINLOCK(events_lock);
+static DEFINE_RAW_SPINLOCK(events_lock);
 
 static void pm_wakeup_timer_fn(struct timer_list *t);
 
@@ -185,9 +185,9 @@ void wakeup_source_add(struct wakeup_source *ws)
 	ws->active = false;
 	ws->last_time = ktime_get();
 
-	spin_lock_irqsave(&events_lock, flags);
+	raw_spin_lock_irqsave(&events_lock, flags);
 	list_add_rcu(&ws->entry, &wakeup_sources);
-	spin_unlock_irqrestore(&events_lock, flags);
+	raw_spin_unlock_irqrestore(&events_lock, flags);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_add);
 
@@ -202,9 +202,9 @@ void wakeup_source_remove(struct wakeup_source *ws)
 	if (WARN_ON(!ws))
 		return;
 
-	spin_lock_irqsave(&events_lock, flags);
+	raw_spin_lock_irqsave(&events_lock, flags);
 	list_del_rcu(&ws->entry);
-	spin_unlock_irqrestore(&events_lock, flags);
+	raw_spin_unlock_irqrestore(&events_lock, flags);
 	synchronize_srcu(&wakeup_srcu);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_remove);
@@ -843,7 +843,7 @@ bool pm_wakeup_pending(void)
 	unsigned long flags;
 	bool ret = false;
 
-	spin_lock_irqsave(&events_lock, flags);
+	raw_spin_lock_irqsave(&events_lock, flags);
 	if (events_check_enabled) {
 		unsigned int cnt, inpr;
 
@@ -851,7 +851,7 @@ bool pm_wakeup_pending(void)
 		ret = (cnt != saved_count || inpr > 0);
 		events_check_enabled = !ret;
 	}
-	spin_unlock_irqrestore(&events_lock, flags);
+	raw_spin_unlock_irqrestore(&events_lock, flags);
 
 	if (ret) {
 		pr_info("PM: Wakeup pending, aborting suspend\n");
@@ -940,13 +940,13 @@ bool pm_save_wakeup_count(unsigned int count)
 	unsigned long flags;
 
 	events_check_enabled = false;
-	spin_lock_irqsave(&events_lock, flags);
+	raw_spin_lock_irqsave(&events_lock, flags);
 	split_counters(&cnt, &inpr);
 	if (cnt == count && inpr == 0) {
 		saved_count = count;
 		events_check_enabled = true;
 	}
-	spin_unlock_irqrestore(&events_lock, flags);
+	raw_spin_unlock_irqrestore(&events_lock, flags);
 	return events_check_enabled;
 }
 

commit 1d6442263400709f12586b4b23a75b6aad549140
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 21 13:12:12 2018 +0200

    PM: wakeup: Use pr_debug() for the "aborting suspend" message
    
    The message printed by pm_wakeup_pending() on wakeup detection is
    not very useful if someone is not interested specifically in
    debugging wakeup, so turn it into a pm_debug() one.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 36bad46c7c68..e1322788eaee 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -853,7 +853,7 @@ bool pm_wakeup_pending(void)
 	spin_unlock_irqrestore(&events_lock, flags);
 
 	if (ret) {
-		pr_info("PM: Wakeup pending, aborting suspend\n");
+		pr_debug("PM: Wakeup pending, aborting suspend\n");
 		pm_print_active_wakeup_sources();
 	}
 

commit 2ef7c01c0cdb170142058c6d8fe0697aee4e4d7d
Author: Doug Berger <opendmb@gmail.com>
Date:   Wed Apr 25 16:40:30 2018 -0700

    PM / wakeup: Only update last time for active wakeup sources
    
    When wakelock support was added, the wakeup_source_add() function
    was updated to set the last_time value of the wakeup source. This
    has the unintended side effect of producing confusing output from
    pm_print_active_wakeup_sources() when a wakeup source is added
    prior to a sleep that is blocked by a different wakeup source.
    
    The function pm_print_active_wakeup_sources() will search for the
    most recently active wakeup source when no active source is found.
    If a wakeup source is added after a different wakeup source blocks
    the system from going to sleep it may have a later last_time value
    than the blocking source and be output as the last active wakeup
    source even if it has never actually been active.
    
    It looks to me like the change to wakeup_source_add() was made to
    prevent the wakelock garbage collection from accidentally dropping
    a wakelock during the narrow window between adding the wakelock to
    the wakelock list in wakelock_lookup_add() and the activation of
    the wakeup source in pm_wake_lock().
    
    This commit changes the behavior so that only the last_time of the
    wakeup source used by a wakelock is initialized prior to adding it
    to the wakeup source list. This preserves the meaning of the
    last_time value as the last time the wakeup source was active and
    allows a wakeup source that has never been active to have a
    last_time value of 0.
    
    Fixes: b86ff9820fd5 (PM / Sleep: Add user space interface for manipulating wakeup sources, v3)
    Signed-off-by: Doug Berger <opendmb@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 5872705432f8..36bad46c7c68 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -183,7 +183,6 @@ void wakeup_source_add(struct wakeup_source *ws)
 	spin_lock_init(&ws->lock);
 	timer_setup(&ws->timer, pm_wakeup_timer_fn, 0);
 	ws->active = false;
-	ws->last_time = ktime_get();
 
 	spin_lock_irqsave(&events_lock, flags);
 	list_add_rcu(&ws->entry, &wakeup_sources);

commit 00ee22c28915d111ba415750a3311d7678fd1206
Author: Mahendran Ganesh <opensource.ganesh@gmail.com>
Date:   Wed Apr 25 18:59:31 2018 +0800

    PM / wakeup: Use seq_open() to show wakeup stats
    
    single_open() interface requires that the whole output must
    fit into a single buffer. This will lead to timeout when
    system memory is not in a good situation.
    
    This patch use seq_open() to show wakeup stats. This method
    need only one page, so timeout will not be observed.
    
    Signed-off-by: Ganesh Mahendran <opensource.ganesh@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index ea01621ed769..5872705432f8 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -1029,32 +1029,75 @@ static int print_wakeup_source_stats(struct seq_file *m,
 	return 0;
 }
 
-/**
- * wakeup_sources_stats_show - Print wakeup sources statistics information.
- * @m: seq_file to print the statistics into.
- */
-static int wakeup_sources_stats_show(struct seq_file *m, void *unused)
+static void *wakeup_sources_stats_seq_start(struct seq_file *m,
+					loff_t *pos)
 {
 	struct wakeup_source *ws;
-	int srcuidx;
+	loff_t n = *pos;
+	int *srcuidx = m->private;
 
-	seq_puts(m, "name\t\tactive_count\tevent_count\twakeup_count\t"
-		"expire_count\tactive_since\ttotal_time\tmax_time\t"
-		"last_change\tprevent_suspend_time\n");
+	if (n == 0) {
+		seq_puts(m, "name\t\tactive_count\tevent_count\twakeup_count\t"
+			"expire_count\tactive_since\ttotal_time\tmax_time\t"
+			"last_change\tprevent_suspend_time\n");
+	}
 
-	srcuidx = srcu_read_lock(&wakeup_srcu);
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
-		print_wakeup_source_stats(m, ws);
-	srcu_read_unlock(&wakeup_srcu, srcuidx);
+	*srcuidx = srcu_read_lock(&wakeup_srcu);
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		if (n-- <= 0)
+			return ws;
+	}
+
+	return NULL;
+}
+
+static void *wakeup_sources_stats_seq_next(struct seq_file *m,
+					void *v, loff_t *pos)
+{
+	struct wakeup_source *ws = v;
+	struct wakeup_source *next_ws = NULL;
+
+	++(*pos);
 
-	print_wakeup_source_stats(m, &deleted_ws);
+	list_for_each_entry_continue_rcu(ws, &wakeup_sources, entry) {
+		next_ws = ws;
+		break;
+	}
+
+	return next_ws;
+}
+
+static void wakeup_sources_stats_seq_stop(struct seq_file *m, void *v)
+{
+	int *srcuidx = m->private;
+
+	srcu_read_unlock(&wakeup_srcu, *srcuidx);
+}
+
+/**
+ * wakeup_sources_stats_seq_show - Print wakeup sources statistics information.
+ * @m: seq_file to print the statistics into.
+ * @v: wakeup_source of each iteration
+ */
+static int wakeup_sources_stats_seq_show(struct seq_file *m, void *v)
+{
+	struct wakeup_source *ws = v;
+
+	print_wakeup_source_stats(m, ws);
 
 	return 0;
 }
 
+static const struct seq_operations wakeup_sources_stats_seq_ops = {
+	.start = wakeup_sources_stats_seq_start,
+	.next  = wakeup_sources_stats_seq_next,
+	.stop  = wakeup_sources_stats_seq_stop,
+	.show  = wakeup_sources_stats_seq_show,
+};
+
 static int wakeup_sources_stats_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, wakeup_sources_stats_show, NULL);
+	return seq_open_private(file, &wakeup_sources_stats_seq_ops, sizeof(int));
 }
 
 static const struct file_operations wakeup_sources_stats_fops = {
@@ -1062,7 +1105,7 @@ static const struct file_operations wakeup_sources_stats_fops = {
 	.open = wakeup_sources_stats_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
-	.release = single_release,
+	.release = seq_release_private,
 };
 
 static int __init wakeup_sources_debugfs_init(void)

commit 0026cef067d2962ed064b974e07f017233d5bd5a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jan 11 09:18:59 2018 +0100

    PM / wakeup: Print warn if device gets enabled as wakeup source during sleep
    
    In general, wakeup settings are not supposed to be changed during any of
    the system wide PM phases. The reason is simply that it would break
    guarantees provided by the PM core, to properly act on active wakeup
    sources.
    
    However, there are exceptions to when, in particular, disabling a device as
    wakeup source makes sense. For example, in cases when a driver realizes
    that its device is dead during system suspend. For these scenarios, we
    don't need to care about acting on the wakeup source correctly, because a
    dead device shouldn't deliver wakeup signals.
    
    To this reasoning and to help users to properly manage wakeup settings,
    let's print a warning in cases someone calls device_wakeup_enable() during
    system sleep.
    
    Suggested-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    [ rjw: Message to be printed ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index e73a081c6397..ea01621ed769 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -19,6 +19,11 @@
 
 #include "power.h"
 
+#ifndef CONFIG_SUSPEND
+suspend_state_t pm_suspend_target_state;
+#define pm_suspend_target_state	(PM_SUSPEND_ON)
+#endif
+
 /*
  * If set, the suspend/hibernate code will abort transitions to a sleep state
  * if wakeup events are registered during or immediately before the transition.
@@ -268,6 +273,9 @@ int device_wakeup_enable(struct device *dev)
 	if (!dev || !dev->power.can_wakeup)
 		return -EINVAL;
 
+	if (pm_suspend_target_state != PM_SUSPEND_ON)
+		dev_dbg(dev, "Suspicious %s() during system transition!\n", __func__);
+
 	ws = wakeup_source_register(dev_name(dev));
 	if (!ws)
 		return -ENOMEM;

commit 7bf4e594c28afc67bc120a380ca774e43ca496d8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 5 02:18:42 2018 +0100

    PM / wakeup: Do not fail dev_pm_attach_wake_irq() unnecessarily
    
    Returning an error code from dev_pm_attach_wake_irq() if
    device_wakeup_attach_irq() called by it returns an error is
    pointless, because the wakeup source used by it may be deleted
    by user space via sysfs at any time and in particular right after
    dev_pm_attach_wake_irq() has returned.  Moreover, it requires
    the callers of dev_pm_attach_wake_irq() to create that wakeup
    source via device_wakeup_enable() upfront, but that obviously is
    racy with respect to the sysfs-based manipulations of it.
    
    To avoid the race, modify device_wakeup_attach_irq() to check
    that the wakeup source it is going to use is there (and return
    early otherwise), make it void (as it cannot fail after that
    change) and make dev_pm_attach_wake_irq() simply call it for
    the device unconditionally.
    
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index b7b8b2fe89c6..e73a081c6397 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -291,22 +291,19 @@ EXPORT_SYMBOL_GPL(device_wakeup_enable);
  *
  * Call under the device's power.lock lock.
  */
-int device_wakeup_attach_irq(struct device *dev,
+void device_wakeup_attach_irq(struct device *dev,
 			     struct wake_irq *wakeirq)
 {
 	struct wakeup_source *ws;
 
 	ws = dev->power.wakeup;
-	if (!ws) {
-		dev_err(dev, "forgot to call device_init_wakeup?\n");
-		return -EINVAL;
-	}
+	if (!ws)
+		return;
 
 	if (ws->wakeirq)
-		return -EEXIST;
+		dev_err(dev, "Leftover wakeup IRQ found, overriding\n");
 
 	ws->wakeirq = wakeirq;
-	return 0;
 }
 
 /**

commit 9dbc64a5d5938b990a045509ff5356fc53e4abd4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 2 01:42:56 2018 +0100

    PM / wakeup: Drop redundant check from device_init_wakeup()
    
    Since device_wakeup_disable() checks the device's power.can_wakeup
    flag, device_init_wakeup() doesn't need to do that before calling it,
    so drop that redundant check from device_init_wakeup().
    
    No intentional changes in functionality.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 90c7212de087..b7b8b2fe89c6 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -448,9 +448,7 @@ int device_init_wakeup(struct device *dev, bool enable)
 		device_set_wakeup_capable(dev, true);
 		ret = device_wakeup_enable(dev);
 	} else {
-		if (dev->power.can_wakeup)
-			device_wakeup_disable(dev);
-
+		device_wakeup_disable(dev);
 		device_set_wakeup_capable(dev, false);
 	}
 

commit d97c2e0d635e39b5b63784deb3212e846ebf76dc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 26 01:50:20 2017 +0100

    PM / wakeup: Drop redundant check from device_set_wakeup_enable()
    
    Since both device_wakeup_enable() and device_wakeup_disable() check
    if dev is not NULL and whether or not power.can_wakeup is set for it,
    device_set_wakeup_enable() doesn't have to do that, so drop that
    check from it.
    
    No intentional changes in functionality.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index cb72965b3281..90c7212de087 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -464,9 +464,6 @@ EXPORT_SYMBOL_GPL(device_init_wakeup);
  */
 int device_set_wakeup_enable(struct device *dev, bool enable)
 {
-	if (!dev || !dev->power.can_wakeup)
-		return -EINVAL;
-
 	return enable ? device_wakeup_enable(dev) : device_wakeup_disable(dev);
 }
 EXPORT_SYMBOL_GPL(device_set_wakeup_enable);

commit 86ddd2db1f75a30f21a4c4de7a29249ee8c37ed8
Author: Brian Norris <briannorris@chromium.org>
Date:   Mon Dec 18 15:30:48 2017 -0800

    PM / wakeup: only recommend "call"ing device_init_wakeup() once
    
    I'll admit admit it: I've written bad driver code that tries to
    configure a device's wake IRQ without having called device_init_wakeup()
    first. But do you really have to ask ask me twice?
    
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 38559f04db2c..cb72965b3281 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -298,7 +298,7 @@ int device_wakeup_attach_irq(struct device *dev,
 
 	ws = dev->power.wakeup;
 	if (!ws) {
-		dev_err(dev, "forgot to call call device_init_wakeup?\n");
+		dev_err(dev, "forgot to call device_init_wakeup?\n");
 		return -EINVAL;
 	}
 

commit 841b86f3289dbe858daeceec36423d4ea286fac2
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 23 09:40:42 2017 +0200

    treewide: Remove TIMER_FUNC_TYPE and TIMER_DATA_TYPE casts
    
    With all callbacks converted, and the timer callback prototype
    switched over, the TIMER_FUNC_TYPE cast is no longer needed,
    so remove it. Conversion was done with the following scripts:
    
        perl -pi -e 's|\(TIMER_FUNC_TYPE\)||g' \
            $(git grep TIMER_FUNC_TYPE | cut -d: -f1 | sort -u)
    
        perl -pi -e 's|\(TIMER_DATA_TYPE\)||g' \
            $(git grep TIMER_DATA_TYPE | cut -d: -f1 | sort -u)
    
    The now unused macros are also dropped from include/linux/timer.h.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 680ee1d36ac9..38559f04db2c 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -481,7 +481,7 @@ static bool wakeup_source_not_registered(struct wakeup_source *ws)
 	 * Use timer struct to check if the given source is initialized
 	 * by wakeup_source_add.
 	 */
-	return ws->timer.function != (TIMER_FUNC_TYPE)pm_wakeup_timer_fn;
+	return ws->timer.function != pm_wakeup_timer_fn;
 }
 
 /*

commit 96428e98aebe5db8a164711f102808651c7f518d
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 16:20:55 2017 -0700

    PM / core: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly. Removes test of .data field, since
    that will be going away.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index cdd6f256da59..680ee1d36ac9 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -54,7 +54,7 @@ static unsigned int saved_count;
 
 static DEFINE_SPINLOCK(events_lock);
 
-static void pm_wakeup_timer_fn(unsigned long data);
+static void pm_wakeup_timer_fn(struct timer_list *t);
 
 static LIST_HEAD(wakeup_sources);
 
@@ -176,7 +176,7 @@ void wakeup_source_add(struct wakeup_source *ws)
 		return;
 
 	spin_lock_init(&ws->lock);
-	setup_timer(&ws->timer, pm_wakeup_timer_fn, (unsigned long)ws);
+	timer_setup(&ws->timer, pm_wakeup_timer_fn, 0);
 	ws->active = false;
 	ws->last_time = ktime_get();
 
@@ -481,8 +481,7 @@ static bool wakeup_source_not_registered(struct wakeup_source *ws)
 	 * Use timer struct to check if the given source is initialized
 	 * by wakeup_source_add.
 	 */
-	return ws->timer.function != pm_wakeup_timer_fn ||
-		   ws->timer.data != (unsigned long)ws;
+	return ws->timer.function != (TIMER_FUNC_TYPE)pm_wakeup_timer_fn;
 }
 
 /*
@@ -724,9 +723,9 @@ EXPORT_SYMBOL_GPL(pm_relax);
  * in @data if it is currently active and its timer has not been canceled and
  * the expiration time of the timer is not in future.
  */
-static void pm_wakeup_timer_fn(unsigned long data)
+static void pm_wakeup_timer_fn(struct timer_list *t)
 {
-	struct wakeup_source *ws = (struct wakeup_source *)data;
+	struct wakeup_source *ws = from_timer(ws, t, timer);
 	unsigned long flags;
 
 	spin_lock_irqsave(&ws->lock, flags);

commit 7b01463e51f6849d0787b24d06a62efcb243dd44
Merge: a1b5fd8fa29f 726fb6b4f2a8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 4 00:06:02 2017 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      ACPI / PM: Check low power idle constraints for debug only
      PM / s2idle: Rename platform operations structure
      PM / s2idle: Rename ->enter_freeze to ->enter_s2idle
      PM / s2idle: Rename freeze_state enum and related items
      PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
      ACPI / PM: Prefer suspend-to-idle over S3 on some systems
      platform/x86: intel-hid: Wake up Dell Latitude 7275 from suspend-to-idle
      PM / suspend: Define pr_fmt() in suspend.c
      PM / suspend: Use mem_sleep_labels[] strings in messages
      PM / sleep: Put pm_test under CONFIG_PM_SLEEP_DEBUG
      PM / sleep: Check pm_wakeup_pending() in __device_suspend_noirq()
      PM / core: Add error argument to dpm_show_time()
      PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
      PM / s2idle: Rearrange the main suspend-to-idle loop
      PM / timekeeping: Print debug messages when requested
      PM / sleep: Mark suspend/hibernation start and finish
      PM / sleep: Do not print debug messages by default
      PM / suspend: Export pm_suspend_target_state

commit f02f4f9d826590f1ef1b087374d3e3cfb7949eac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:13:56 2017 +0200

    PM / s2idle: Rename freeze_state enum and related items
    
    Rename the freeze_state enum representing the suspend-to-idle state
    machine states to s2idle_states and rename the related variables and
    functions accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 144e6d8fafc8..34aebf3e460b 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -863,7 +863,7 @@ bool pm_wakeup_pending(void)
 void pm_system_wakeup(void)
 {
 	atomic_inc(&pm_abort_suspend);
-	freeze_wake();
+	s2idle_wake();
 }
 EXPORT_SYMBOL_GPL(pm_system_wakeup);
 

commit 820b9b0c093ebd40c4b8e44c0e84613c877f4948
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 2 01:32:44 2017 +0200

    PM / wakeup: Set power.can_wakeup if wakeup_sysfs_add() fails
    
    Currently, an error from wakeup_sysfs_add() in
    device_set_wakeup_capable() causes the device's power.can_wakeup
    flag to remain unset even though the device technically is capable
    of signaling wakeup.
    
    If wakeup_sysfs_add() fails user space may not be able to enable
    the device to wake up the system from sleep states, but at least
    for some devices that does not matter.
    
    For this reason, set or clear power.can_wakeup upfront and if
    wakeup_sysfs_add() returns an error, print a message to the log.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 144e6d8fafc8..b49efe33099e 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -412,15 +412,17 @@ void device_set_wakeup_capable(struct device *dev, bool capable)
 	if (!!dev->power.can_wakeup == !!capable)
 		return;
 
+	dev->power.can_wakeup = capable;
 	if (device_is_registered(dev) && !list_empty(&dev->power.entry)) {
 		if (capable) {
-			if (wakeup_sysfs_add(dev))
-				return;
+			int ret = wakeup_sysfs_add(dev);
+
+			if (ret)
+				dev_info(dev, "Wakeup sysfs attributes not added\n");
 		} else {
 			wakeup_sysfs_remove(dev);
 		}
 	}
-	dev->power.can_wakeup = capable;
 }
 EXPORT_SYMBOL_GPL(device_set_wakeup_capable);
 

commit 8f8e5c3e2796eaf150d6262115af12707c2616dd
Merge: 9a5f2c871af4 de3ef1eb1cd0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 3 14:23:09 2017 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      PM / core: Drop run_wake flag from struct dev_pm_info
      PCI / PM: Simplify device wakeup settings code
      PCI / PM: Drop pme_interrupt flag from struct pci_dev
      ACPI / PM: Consolidate device wakeup settings code
      ACPI / PM: Drop run_wake from struct acpi_device_wakeup_flags
      ACPI / sleep: EC-based wakeup from suspend-to-idle on recent systems
      platform: x86: intel-hid: Wake up the system from suspend-to-idle
      platform: x86: intel-vbtn: Wake up the system from suspend-to-idle
      ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
      platform/x86: Add driver for ACPI INT0002 Virtual GPIO device
      PCI / PM: Restore PME Enable if skipping wakeup setup
      PM / sleep: Print timing information if debug is enabled
      ACPI / PM: Clean up device wakeup enable/disable code
      ACPI / PM: Change log level of wakeup-related message
      USB / PCI / PM: Allow the PCI core to do the resume cleanup
      ACPI / PM: Run wakeup notify handlers synchronously
    
    Conflicts:
            drivers/base/power/main.c

commit ea0212f40c6bc0594c8eff79266759e3ecd4bacc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 25 19:31:13 2017 +0200

    PM / wakeirq: Convert to SRCU
    
    The wakeirq infrastructure uses RCU to protect the list of wakeirqs. That
    breaks the irq bus locking infrastructure, which is allows sleeping
    functions to be called so interrupt controllers behind slow busses,
    e.g. i2c, can be handled.
    
    The wakeirq functions hold rcu_read_lock and call into irq functions, which
    in case of interrupts using the irq bus locking will trigger a
    might_sleep() splat.
    
    Convert the wakeirq infrastructure to Sleepable RCU and unbreak it.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Reported-by: Brian Norris <briannorris@chromium.org>
    Suggested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Brian Norris <briannorris@chromium.org>
    Cc: 4.2+ <stable@vger.kernel.org> # 4.2+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index c313b600d356..994bbf8b1476 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -60,6 +60,8 @@ static LIST_HEAD(wakeup_sources);
 
 static DECLARE_WAIT_QUEUE_HEAD(wakeup_count_wait_queue);
 
+DEFINE_STATIC_SRCU(wakeup_srcu);
+
 static struct wakeup_source deleted_ws = {
 	.name = "deleted",
 	.lock =  __SPIN_LOCK_UNLOCKED(deleted_ws.lock),
@@ -198,7 +200,7 @@ void wakeup_source_remove(struct wakeup_source *ws)
 	spin_lock_irqsave(&events_lock, flags);
 	list_del_rcu(&ws->entry);
 	spin_unlock_irqrestore(&events_lock, flags);
-	synchronize_rcu();
+	synchronize_srcu(&wakeup_srcu);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_remove);
 
@@ -332,12 +334,12 @@ void device_wakeup_detach_irq(struct device *dev)
 void device_wakeup_arm_wake_irqs(void)
 {
 	struct wakeup_source *ws;
+	int srcuidx;
 
-	rcu_read_lock();
+	srcuidx = srcu_read_lock(&wakeup_srcu);
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
 		dev_pm_arm_wake_irq(ws->wakeirq);
-
-	rcu_read_unlock();
+	srcu_read_unlock(&wakeup_srcu, srcuidx);
 }
 
 /**
@@ -348,12 +350,12 @@ void device_wakeup_arm_wake_irqs(void)
 void device_wakeup_disarm_wake_irqs(void)
 {
 	struct wakeup_source *ws;
+	int srcuidx;
 
-	rcu_read_lock();
+	srcuidx = srcu_read_lock(&wakeup_srcu);
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
 		dev_pm_disarm_wake_irq(ws->wakeirq);
-
-	rcu_read_unlock();
+	srcu_read_unlock(&wakeup_srcu, srcuidx);
 }
 
 /**
@@ -804,10 +806,10 @@ EXPORT_SYMBOL_GPL(pm_wakeup_dev_event);
 void pm_print_active_wakeup_sources(void)
 {
 	struct wakeup_source *ws;
-	int active = 0;
+	int srcuidx, active = 0;
 	struct wakeup_source *last_activity_ws = NULL;
 
-	rcu_read_lock();
+	srcuidx = srcu_read_lock(&wakeup_srcu);
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
 		if (ws->active) {
 			pr_debug("active wakeup source: %s\n", ws->name);
@@ -823,7 +825,7 @@ void pm_print_active_wakeup_sources(void)
 	if (!active && last_activity_ws)
 		pr_debug("last active wakeup source: %s\n",
 			last_activity_ws->name);
-	rcu_read_unlock();
+	srcu_read_unlock(&wakeup_srcu, srcuidx);
 }
 EXPORT_SYMBOL_GPL(pm_print_active_wakeup_sources);
 
@@ -950,8 +952,9 @@ void pm_wakep_autosleep_enabled(bool set)
 {
 	struct wakeup_source *ws;
 	ktime_t now = ktime_get();
+	int srcuidx;
 
-	rcu_read_lock();
+	srcuidx = srcu_read_lock(&wakeup_srcu);
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
 		spin_lock_irq(&ws->lock);
 		if (ws->autosleep_enabled != set) {
@@ -965,7 +968,7 @@ void pm_wakep_autosleep_enabled(bool set)
 		}
 		spin_unlock_irq(&ws->lock);
 	}
-	rcu_read_unlock();
+	srcu_read_unlock(&wakeup_srcu, srcuidx);
 }
 #endif /* CONFIG_PM_AUTOSLEEP */
 
@@ -1026,15 +1029,16 @@ static int print_wakeup_source_stats(struct seq_file *m,
 static int wakeup_sources_stats_show(struct seq_file *m, void *unused)
 {
 	struct wakeup_source *ws;
+	int srcuidx;
 
 	seq_puts(m, "name\t\tactive_count\tevent_count\twakeup_count\t"
 		"expire_count\tactive_since\ttotal_time\tmax_time\t"
 		"last_change\tprevent_suspend_time\n");
 
-	rcu_read_lock();
+	srcuidx = srcu_read_lock(&wakeup_srcu);
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
 		print_wakeup_source_stats(m, ws);
-	rcu_read_unlock();
+	srcu_read_unlock(&wakeup_srcu, srcuidx);
 
 	print_wakeup_source_stats(m, &deleted_ws);
 

commit 33e4f80ee69b5168badf37edbfed796eb48434b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:56:34 2017 +0200

    ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled.  However, to preserve the existing
    behavior with respect to suspend-to-RAM, this only is done in
    the suspend-to-idle case and only if an SCI has occurred while
    suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index c313b600d356..9c36b27996fc 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -28,8 +28,8 @@ bool events_check_enabled __read_mostly;
 /* First wakeup IRQ seen by the kernel in the last cycle. */
 unsigned int pm_wakeup_irq __read_mostly;
 
-/* If set and the system is suspending, terminate the suspend. */
-static bool pm_abort_suspend __read_mostly;
+/* If greater than 0 and the system is suspending, terminate the suspend. */
+static atomic_t pm_abort_suspend __read_mostly;
 
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
@@ -855,20 +855,26 @@ bool pm_wakeup_pending(void)
 		pm_print_active_wakeup_sources();
 	}
 
-	return ret || pm_abort_suspend;
+	return ret || atomic_read(&pm_abort_suspend) > 0;
 }
 
 void pm_system_wakeup(void)
 {
-	pm_abort_suspend = true;
+	atomic_inc(&pm_abort_suspend);
 	freeze_wake();
 }
 EXPORT_SYMBOL_GPL(pm_system_wakeup);
 
-void pm_wakeup_clear(void)
+void pm_system_cancel_wakeup(void)
+{
+	atomic_dec(&pm_abort_suspend);
+}
+
+void pm_wakeup_clear(bool reset)
 {
-	pm_abort_suspend = false;
 	pm_wakeup_irq = 0;
+	if (reset)
+		atomic_set(&pm_abort_suspend, 0);
 }
 
 void pm_system_irq_wakeup(unsigned int irq_number)

commit f3b7eaae1b35eb8077610eb7c7db042c9b0645e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 7 00:57:37 2017 +0200

    Revert "ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle"
    
    Revert commit eed4d47efe95 (ACPI / sleep: Ignore spurious SCI wakeups
    from suspend-to-idle) as it turned out to be premature and triggered
    a number of different issues on various systems.
    
    That includes, but is not limited to, premature suspend-to-RAM aborts
    on Dell XPS 13 (9343) reported by Dominik.
    
    The issue the commit in question attempted to address is real and
    will need to be taken care of going forward, but evidently more work
    is needed for this purpose.
    
    Reported-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 9c36b27996fc..c313b600d356 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -28,8 +28,8 @@ bool events_check_enabled __read_mostly;
 /* First wakeup IRQ seen by the kernel in the last cycle. */
 unsigned int pm_wakeup_irq __read_mostly;
 
-/* If greater than 0 and the system is suspending, terminate the suspend. */
-static atomic_t pm_abort_suspend __read_mostly;
+/* If set and the system is suspending, terminate the suspend. */
+static bool pm_abort_suspend __read_mostly;
 
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
@@ -855,26 +855,20 @@ bool pm_wakeup_pending(void)
 		pm_print_active_wakeup_sources();
 	}
 
-	return ret || atomic_read(&pm_abort_suspend) > 0;
+	return ret || pm_abort_suspend;
 }
 
 void pm_system_wakeup(void)
 {
-	atomic_inc(&pm_abort_suspend);
+	pm_abort_suspend = true;
 	freeze_wake();
 }
 EXPORT_SYMBOL_GPL(pm_system_wakeup);
 
-void pm_system_cancel_wakeup(void)
-{
-	atomic_dec(&pm_abort_suspend);
-}
-
-void pm_wakeup_clear(bool reset)
+void pm_wakeup_clear(void)
 {
+	pm_abort_suspend = false;
 	pm_wakeup_irq = 0;
-	if (reset)
-		atomic_set(&pm_abort_suspend, 0);
 }
 
 void pm_system_irq_wakeup(unsigned int irq_number)

commit 60d4553bdc1a0099adb544e12cafd7bbc7f1d484
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun May 14 02:23:04 2017 +0200

    PM / wakeup: Fix up wakeup_source_report_event()
    
    Commit 8a537ece3d94 (PM / wakeup: Integrate mechanism to abort
    transitions in progress) modified wakeup_source_report_event()
    and wakeup_source_activate() to make it possible to call
    pm_system_wakeup() from the latter if so indicated by the
    caller of the former (via a new function argument added by that
    commit), but it overlooked the fact that in some situations
    wakeup_source_report_event() is called to signal a "hard" event
    (ie. such that should abort a system suspend in progress) after
    pm_stay_awake() has been called for the same wakeup source object,
    in which case the pm_system_wakeup() will not trigger.
    
    To work around this issue, modify wakeup_source_activate() and
    wakeup_source_report_event() again so that pm_system_wakeup() is
    called by the latter directly (if its last argument is true), in
    which case the additional argument does not need to be passed
    to wakeup_source_activate() any more, so drop it from there.
    
    Fixes: 8a537ece3d94 (PM / wakeup: Integrate mechanism to abort transitions in progress)
    Reported-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index f62082fdd670..9c36b27996fc 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -512,13 +512,12 @@ static bool wakeup_source_not_registered(struct wakeup_source *ws)
 /**
  * wakup_source_activate - Mark given wakeup source as active.
  * @ws: Wakeup source to handle.
- * @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
  *
  * Update the @ws' statistics and, if @ws has just been activated, notify the PM
  * core of the event by incrementing the counter of of wakeup events being
  * processed.
  */
-static void wakeup_source_activate(struct wakeup_source *ws, bool hard)
+static void wakeup_source_activate(struct wakeup_source *ws)
 {
 	unsigned int cec;
 
@@ -526,9 +525,6 @@ static void wakeup_source_activate(struct wakeup_source *ws, bool hard)
 			"unregistered wakeup source\n"))
 		return;
 
-	if (hard)
-		pm_system_wakeup();
-
 	ws->active = true;
 	ws->active_count++;
 	ws->last_time = ktime_get();
@@ -554,7 +550,10 @@ static void wakeup_source_report_event(struct wakeup_source *ws, bool hard)
 		ws->wakeup_count++;
 
 	if (!ws->active)
-		wakeup_source_activate(ws, hard);
+		wakeup_source_activate(ws);
+
+	if (hard)
+		pm_system_wakeup();
 }
 
 /**

commit eed4d47efe9508b855b09754cf6de4325d8a2f0d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:23:03 2017 +0200

    ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled (that also helps to catch device-induced
    wakeup events occurring during suspend transitions in progress).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 84c41c98d6fc..f62082fdd670 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -28,8 +28,8 @@ bool events_check_enabled __read_mostly;
 /* First wakeup IRQ seen by the kernel in the last cycle. */
 unsigned int pm_wakeup_irq __read_mostly;
 
-/* If set and the system is suspending, terminate the suspend. */
-static bool pm_abort_suspend __read_mostly;
+/* If greater than 0 and the system is suspending, terminate the suspend. */
+static atomic_t pm_abort_suspend __read_mostly;
 
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
@@ -856,20 +856,26 @@ bool pm_wakeup_pending(void)
 		pm_print_active_wakeup_sources();
 	}
 
-	return ret || pm_abort_suspend;
+	return ret || atomic_read(&pm_abort_suspend) > 0;
 }
 
 void pm_system_wakeup(void)
 {
-	pm_abort_suspend = true;
+	atomic_inc(&pm_abort_suspend);
 	freeze_wake();
 }
 EXPORT_SYMBOL_GPL(pm_system_wakeup);
 
-void pm_wakeup_clear(void)
+void pm_system_cancel_wakeup(void)
+{
+	atomic_dec(&pm_abort_suspend);
+}
+
+void pm_wakeup_clear(bool reset)
 {
-	pm_abort_suspend = false;
 	pm_wakeup_irq = 0;
+	if (reset)
+		atomic_set(&pm_abort_suspend, 0);
 }
 
 void pm_system_irq_wakeup(unsigned int irq_number)

commit 8a537ece3d946227e4afa81eae0e43fa47439c7d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:22:09 2017 +0200

    PM / wakeup: Integrate mechanism to abort transitions in progress
    
    The system wakeup framework is not very consistent with respect to
    the way it handles suspend-to-idle and generally wakeup events
    occurring during transitions to system low-power states.
    
    First off, system transitions in progress are aborted by the event
    reporting helpers like pm_wakeup_event() only if the wakeup_count
    sysfs attribute is in use (as documented), but there are cases in
    which system-wide transitions should be aborted even if that is
    not the case.  For example, a wakeup signal from a designated
    wakeup device during system-wide PM transition, it should cause
    the transition to be aborted right away.
    
    Moreover, there is a freeze_wake() call in wakeup_source_activate(),
    but that really is only effective after suspend_freeze_state has
    been set to FREEZE_STATE_ENTER by freeze_enter().  However, it
    is very unlikely that wakeup_source_activate() will ever be called
    at that time, as it could only be triggered by a IRQF_NO_SUSPEND
    interrupt handler, so wakeups from suspend-to-idle don't really
    occur in wakeup_source_activate().
    
    At the same time there is a way to abort a system suspend in
    progress (or wake up the system from suspend-to-idle), which is by
    calling pm_system_wakeup(), but in turn that doesn't cause any
    wakeup source objects to be activated, so it will not be covered
    by wakeup source statistics and will not prevent the system from
    suspending again immediately (in case autosleep is used, for
    example).  Consequently, if anyone wants to abort system transitions
    in progress and allow the wakeup_count mechanism to work, they need
    to use both pm_system_wakeup() and pm_wakeup_event(), say, at the
    same time which is awkward.
    
    For the above reasons, make it possible to trigger
    pm_system_wakeup() from within wakeup_source_activate() and
    provide a new pm_wakeup_hard_event() helper to do so within the
    wakeup framework.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 136854970489..84c41c98d6fc 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -512,12 +512,13 @@ static bool wakeup_source_not_registered(struct wakeup_source *ws)
 /**
  * wakup_source_activate - Mark given wakeup source as active.
  * @ws: Wakeup source to handle.
+ * @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
  *
  * Update the @ws' statistics and, if @ws has just been activated, notify the PM
  * core of the event by incrementing the counter of of wakeup events being
  * processed.
  */
-static void wakeup_source_activate(struct wakeup_source *ws)
+static void wakeup_source_activate(struct wakeup_source *ws, bool hard)
 {
 	unsigned int cec;
 
@@ -525,11 +526,8 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 			"unregistered wakeup source\n"))
 		return;
 
-	/*
-	 * active wakeup source should bring the system
-	 * out of PM_SUSPEND_FREEZE state
-	 */
-	freeze_wake();
+	if (hard)
+		pm_system_wakeup();
 
 	ws->active = true;
 	ws->active_count++;
@@ -546,8 +544,9 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 /**
  * wakeup_source_report_event - Report wakeup event using the given source.
  * @ws: Wakeup source to report the event for.
+ * @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
  */
-static void wakeup_source_report_event(struct wakeup_source *ws)
+static void wakeup_source_report_event(struct wakeup_source *ws, bool hard)
 {
 	ws->event_count++;
 	/* This is racy, but the counter is approximate anyway. */
@@ -555,7 +554,7 @@ static void wakeup_source_report_event(struct wakeup_source *ws)
 		ws->wakeup_count++;
 
 	if (!ws->active)
-		wakeup_source_activate(ws);
+		wakeup_source_activate(ws, hard);
 }
 
 /**
@@ -573,7 +572,7 @@ void __pm_stay_awake(struct wakeup_source *ws)
 
 	spin_lock_irqsave(&ws->lock, flags);
 
-	wakeup_source_report_event(ws);
+	wakeup_source_report_event(ws, false);
 	del_timer(&ws->timer);
 	ws->timer_expires = 0;
 
@@ -739,9 +738,10 @@ static void pm_wakeup_timer_fn(unsigned long data)
 }
 
 /**
- * __pm_wakeup_event - Notify the PM core of a wakeup event.
+ * pm_wakeup_ws_event - Notify the PM core of a wakeup event.
  * @ws: Wakeup source object associated with the event source.
  * @msec: Anticipated event processing time (in milliseconds).
+ * @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
  *
  * Notify the PM core of a wakeup event whose source is @ws that will take
  * approximately @msec milliseconds to be processed by the kernel.  If @ws is
@@ -750,7 +750,7 @@ static void pm_wakeup_timer_fn(unsigned long data)
  *
  * It is safe to call this function from interrupt context.
  */
-void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
+void pm_wakeup_ws_event(struct wakeup_source *ws, unsigned int msec, bool hard)
 {
 	unsigned long flags;
 	unsigned long expires;
@@ -760,7 +760,7 @@ void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
 
 	spin_lock_irqsave(&ws->lock, flags);
 
-	wakeup_source_report_event(ws);
+	wakeup_source_report_event(ws, hard);
 
 	if (!msec) {
 		wakeup_source_deactivate(ws);
@@ -779,17 +779,17 @@ void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
  unlock:
 	spin_unlock_irqrestore(&ws->lock, flags);
 }
-EXPORT_SYMBOL_GPL(__pm_wakeup_event);
-
+EXPORT_SYMBOL_GPL(pm_wakeup_ws_event);
 
 /**
  * pm_wakeup_event - Notify the PM core of a wakeup event.
  * @dev: Device the wakeup event is related to.
  * @msec: Anticipated event processing time (in milliseconds).
+ * @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
  *
- * Call __pm_wakeup_event() for the @dev's wakeup source object.
+ * Call pm_wakeup_ws_event() for the @dev's wakeup source object.
  */
-void pm_wakeup_event(struct device *dev, unsigned int msec)
+void pm_wakeup_dev_event(struct device *dev, unsigned int msec, bool hard)
 {
 	unsigned long flags;
 
@@ -797,10 +797,10 @@ void pm_wakeup_event(struct device *dev, unsigned int msec)
 		return;
 
 	spin_lock_irqsave(&dev->power.lock, flags);
-	__pm_wakeup_event(dev->power.wakeup, msec);
+	pm_wakeup_ws_event(dev->power.wakeup, msec, hard);
 	spin_unlock_irqrestore(&dev->power.lock, flags);
 }
-EXPORT_SYMBOL_GPL(pm_wakeup_event);
+EXPORT_SYMBOL_GPL(pm_wakeup_dev_event);
 
 void pm_print_active_wakeup_sources(void)
 {

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index f546f8f107b0..136854970489 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -8,7 +8,7 @@
 
 #include <linux/device.h>
 #include <linux/slab.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/capability.h>
 #include <linux/export.h>
 #include <linux/suspend.h>

commit 8b0e195314fabd58a331c4f7b6db75a1565535d7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 25 12:30:41 2016 +0100

    ktime: Cleanup ktime_set() usage
    
    ktime_set(S,N) was required for the timespec storage type and is still
    useful for situations where a Seconds and Nanoseconds part of a time value
    needs to be converted. For anything where the Seconds argument is 0, this
    is pointless and can be replaced with a simple assignment.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 94332902a1cf..f546f8f107b0 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -1005,7 +1005,7 @@ static int print_wakeup_source_stats(struct seq_file *m,
 			prevent_sleep_time = ktime_add(prevent_sleep_time,
 				ktime_sub(now, ws->start_prevent_time));
 	} else {
-		active_time = ktime_set(0, 0);
+		active_time = 0;
 	}
 
 	seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t%lu\t\t%lld\t\t%lld\t\t%lld\t\t%lld\t\t%lld\n",

commit 2456e855354415bfaeb7badaa14e11b3e02c8466
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 25 11:38:40 2016 +0100

    ktime: Get rid of the union
    
    ktime is a union because the initial implementation stored the time in
    scalar nanoseconds on 64 bit machine and in a endianess optimized timespec
    variant for 32bit machines. The Y2038 cleanup removed the timespec variant
    and switched everything to scalar nanoseconds. The union remained, but
    become completely pointless.
    
    Get rid of the union and just keep ktime_t as simple typedef of type s64.
    
    The conversion was done with coccinelle and some manual mopping up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index bf9ba26981a5..94332902a1cf 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -998,7 +998,7 @@ static int print_wakeup_source_stats(struct seq_file *m,
 
 		active_time = ktime_sub(now, ws->last_time);
 		total_time = ktime_add(total_time, active_time);
-		if (active_time.tv64 > max_time.tv64)
+		if (active_time > max_time)
 			max_time = active_time;
 
 		if (ws->autosleep_enabled)

commit 9320f95c0b8f1d074f570385e6855d4554f693e4
Author: xing wei <xing.wei@intel.com>
Date:   Wed Dec 7 19:31:16 2016 +0800

    PM / sleep: Print active wakeup sources when blocking on wakeup_count reads
    
    If there are any wakeup events being processed, read operation
    on /sys/power/wakeup_count will be blocked, so print the names
    of all active wakeup sources to help to find out who is preventing
    system suspend from triggering.
    
    While at it change pr_info() in pm_print_active_wakeup_sources()
    to pr_debug() to avoid excessive log noise.
    
    Signed-off-by: xing wei <xing.wei@intel.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 62e4de2aa8d1..bf9ba26981a5 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -811,7 +811,7 @@ void pm_print_active_wakeup_sources(void)
 	rcu_read_lock();
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
 		if (ws->active) {
-			pr_info("active wakeup source: %s\n", ws->name);
+			pr_debug("active wakeup source: %s\n", ws->name);
 			active = 1;
 		} else if (!active &&
 			   (!last_activity_ws ||
@@ -822,7 +822,7 @@ void pm_print_active_wakeup_sources(void)
 	}
 
 	if (!active && last_activity_ws)
-		pr_info("last active wakeup source: %s\n",
+		pr_debug("last active wakeup source: %s\n",
 			last_activity_ws->name);
 	rcu_read_unlock();
 }
@@ -905,7 +905,7 @@ bool pm_get_wakeup_count(unsigned int *count, bool block)
 			split_counters(&cnt, &inpr);
 			if (inpr == 0 || signal_pending(current))
 				break;
-
+			pm_print_active_wakeup_sources();
 			schedule();
 		}
 		finish_wait(&wakeup_count_wait_queue, &wait);

commit 4f48ec8a1c070f00c3d675b664e8b3879e5286e5
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jul 23 17:04:00 2016 +0200

    PM-wakeup: Delete unnecessary checks before three function calls
    
    The following functions test whether their argument is NULL
    and then return immediately.
     * dev_pm_arm_wake_irq
     * dev_pm_disarm_wake_irq
     * wakeup_source_unregister
    
    Thus the test around the calls is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    [ rjw: Minor whitespace adjustments ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 5fb7718f256c..62e4de2aa8d1 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -334,10 +334,9 @@ void device_wakeup_arm_wake_irqs(void)
 	struct wakeup_source *ws;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
-		if (ws->wakeirq)
-			dev_pm_arm_wake_irq(ws->wakeirq);
-	}
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+		dev_pm_arm_wake_irq(ws->wakeirq);
+
 	rcu_read_unlock();
 }
 
@@ -351,10 +350,9 @@ void device_wakeup_disarm_wake_irqs(void)
 	struct wakeup_source *ws;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
-		if (ws->wakeirq)
-			dev_pm_disarm_wake_irq(ws->wakeirq);
-	}
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+		dev_pm_disarm_wake_irq(ws->wakeirq);
+
 	rcu_read_unlock();
 }
 
@@ -390,9 +388,7 @@ int device_wakeup_disable(struct device *dev)
 		return -EINVAL;
 
 	ws = device_wakeup_detach(dev);
-	if (ws)
-		wakeup_source_unregister(ws);
-
+	wakeup_source_unregister(ws);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(device_wakeup_disable);

commit 16669befb0772eac6a76057b7010ba5b419c0e78
Author: Strashko, Grygorii <grygorii.strashko@ti.com>
Date:   Wed Apr 6 14:45:53 2016 +0300

    PM / wakeirq: fix wakeirq setting after wakup re-configuration from sysfs
    
    Now wakeirq stops working for device if wakeup option for
    this device will be reconfigured through sysfs, like:
    
    echo disabled > /sys/devices/platform/extcon_usb1/power/wakeup
    echo enabled > /sys/devices/platform/extcon_usb1/power/wakeup
    
    Once above set of commands is executed the device's wakeup_source
    opject will be recreated and dev->power.wakeup->wakeirq field will
    contain NULL. As result, device_wakeup_arm_wake_irqs() will not arm
    wakeirq for the affected device.
    
    Hece, lets try to fix it in the following way:
      check for dev->wakeirq field when device_wakeup_attach() is called
      and if !NULL re-attach wakeirq to the device
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index a1e0b9ab847a..5fb7718f256c 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -246,6 +246,8 @@ static int device_wakeup_attach(struct device *dev, struct wakeup_source *ws)
 		return -EEXIST;
 	}
 	dev->power.wakeup = ws;
+	if (dev->power.wakeirq)
+		device_wakeup_attach_irq(dev, dev->power.wakeirq);
 	spin_unlock_irq(&dev->power.lock);
 	return 0;
 }

commit 7236214c88454d96de7633e07a8314644d529f26
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 9 23:42:06 2015 +0200

    PM / wakeup: wakeup_source_create: use kstrdup_const
    
    Using kstrdup_const allows us to save a little runtime memory (and a
    string copy) in the common case where name is a string literal.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 3b361ecfaffc..a1e0b9ab847a 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -94,7 +94,7 @@ struct wakeup_source *wakeup_source_create(const char *name)
 	if (!ws)
 		return NULL;
 
-	wakeup_source_prepare(ws, name ? kstrdup(name, GFP_KERNEL) : NULL);
+	wakeup_source_prepare(ws, name ? kstrdup_const(name, GFP_KERNEL) : NULL);
 	return ws;
 }
 EXPORT_SYMBOL_GPL(wakeup_source_create);
@@ -157,7 +157,7 @@ void wakeup_source_destroy(struct wakeup_source *ws)
 
 	wakeup_source_drop(ws);
 	wakeup_source_record(ws);
-	kfree(ws->name);
+	kfree_const(ws->name);
 	kfree(ws);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_destroy);

commit a6f5f0dd4e21191ce35030dd4d6421e1cca10ee4
Author: Alexandra Yates <alexandra.yates@linux.intel.com>
Date:   Tue Sep 15 10:32:46 2015 -0700

    PM / sleep: Report interrupt that caused system wakeup
    
    Add a sysfs attribute, /sys/power/pm_wakeup_irq, reporting the IRQ
    number of the first wakeup interrupt (that is, the first interrupt
    from an IRQ line armed for system wakeup) seen by the kernel during
    the most recent system suspend/resume cycle.
    
    This feature will be useful for system wakeup diagnostics of
    spurious wakeup interrupts.
    
    Signed-off-by: Alexandra Yates <alexandra.yates@linux.intel.com>
    [ rjw: Fixed up pm_wakeup_irq definition ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 51f15bc15774..3b361ecfaffc 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -25,6 +25,9 @@
  */
 bool events_check_enabled __read_mostly;
 
+/* First wakeup IRQ seen by the kernel in the last cycle. */
+unsigned int pm_wakeup_irq __read_mostly;
+
 /* If set and the system is suspending, terminate the suspend. */
 static bool pm_abort_suspend __read_mostly;
 
@@ -868,6 +871,15 @@ EXPORT_SYMBOL_GPL(pm_system_wakeup);
 void pm_wakeup_clear(void)
 {
 	pm_abort_suspend = false;
+	pm_wakeup_irq = 0;
+}
+
+void pm_system_irq_wakeup(unsigned int irq_number)
+{
+	if (pm_wakeup_irq == 0) {
+		pm_wakeup_irq = irq_number;
+		pm_system_wakeup();
+	}
 }
 
 /**

commit 3fc7aeeb08bfde59877e7f9a4eea3c5ebcae72be
Merge: d770e558e219 6d3dab7d8417
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 7 22:47:43 2015 +0200

    Merge branch 'pm-wakeirq'
    
    * pm-wakeirq:
      PM / wakeirq: Avoid setting power.wakeirq too hastily

commit 6d3dab7d84177f836b14961b4d252d0959d66768
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 7 13:08:39 2015 +0200

    PM / wakeirq: Avoid setting power.wakeirq too hastily
    
    If dev_pm_attach_wake_irq() fails, the device's power.wakeirq field
    should not be set to point to the struct wake_irq passed to that
    function, as that object will be freed going forward.
    
    For this reason, make dev_pm_attach_wake_irq() first call
    device_wakeup_attach_irq() and only set the device's power.wakeirq
    field if that's successful.
    
    That requires device_wakeup_attach_irq() to be called under the
    device's power.lock lock, but since dev_pm_attach_wake_irq() is
    the only caller of it, the requisite changes are easy to make.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Reported-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 7332ebc9cab0..15d27d782dc1 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -247,32 +247,25 @@ EXPORT_SYMBOL_GPL(device_wakeup_enable);
  * Attach a device wakeirq to the wakeup source so the device
  * wake IRQ can be configured automatically for suspend and
  * resume.
+ *
+ * Call under the device's power.lock lock.
  */
 int device_wakeup_attach_irq(struct device *dev,
 			     struct wake_irq *wakeirq)
 {
 	struct wakeup_source *ws;
-	int ret = 0;
 
-	spin_lock_irq(&dev->power.lock);
 	ws = dev->power.wakeup;
 	if (!ws) {
 		dev_err(dev, "forgot to call call device_init_wakeup?\n");
-		ret = -EINVAL;
-		goto unlock;
+		return -EINVAL;
 	}
 
-	if (ws->wakeirq) {
-		ret = -EEXIST;
-		goto unlock;
-	}
+	if (ws->wakeirq)
+		return -EEXIST;
 
 	ws->wakeirq = wakeirq;
-
-unlock:
-	spin_unlock_irq(&dev->power.lock);
-
-	return ret;
+	return 0;
 }
 
 /**
@@ -280,20 +273,16 @@ int device_wakeup_attach_irq(struct device *dev,
  * @dev: Device to handle
  *
  * Removes a device wakeirq from the wakeup source.
+ *
+ * Call under the device's power.lock lock.
  */
 void device_wakeup_detach_irq(struct device *dev)
 {
 	struct wakeup_source *ws;
 
-	spin_lock_irq(&dev->power.lock);
 	ws = dev->power.wakeup;
-	if (!ws)
-		goto unlock;
-
-	ws->wakeirq = NULL;
-
-unlock:
-	spin_unlock_irq(&dev->power.lock);
+	if (ws)
+		ws->wakeirq = NULL;
 }
 
 /**

commit 0d85fd42114ce97f209f3deb91ea0ac992c56013
Merge: ab232ba57043 db874c7e1055
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:18:14 2015 +0200

    Merge branch 'pm-wakeirq'
    
    * pm-wakeirq:
      PM / wakeirq: Fix typo in prototype for dev_pm_set_dedicated_wake_irq
      PM / Wakeirq: Add automated device wake IRQ handling

commit 4990d4fe327b9d9a7a3be7103a82699406fdde69
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 18 15:40:29 2015 -0700

    PM / Wakeirq: Add automated device wake IRQ handling
    
    Turns out we can automate the handling for the device_may_wakeup()
    quite a bit by using the kernel wakeup source list as suggested
    by Rafael J. Wysocki <rjw@rjwysocki.net>.
    
    And as some hardware has separate dedicated wake-up interrupt
    in addition to the IO interrupt, we can automate the handling by
    adding a generic threaded interrupt handler that just calls the
    device PM runtime to wake up the device.
    
    This allows dropping code from device drivers as we currently
    are doing it in multiple ways, and often wrong.
    
    For most drivers, we should be able to drop the following
    boilerplate code from runtime_suspend and runtime_resume
    functions:
    
            ...
            device_init_wakeup(dev, true);
            ...
            if (device_may_wakeup(dev))
                    enable_irq_wake(irq);
            ...
            if (device_may_wakeup(dev))
                    disable_irq_wake(irq);
            ...
            device_init_wakeup(dev, false);
            ...
    
    We can replace it with just the following init and exit
    time code:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    And for hardware with dedicated wake-up interrupts:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_dedicated_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 77262009f89d..7332ebc9cab0 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -14,6 +14,7 @@
 #include <linux/suspend.h>
 #include <linux/seq_file.h>
 #include <linux/debugfs.h>
+#include <linux/pm_wakeirq.h>
 #include <trace/events/power.h>
 
 #include "power.h"
@@ -238,6 +239,97 @@ int device_wakeup_enable(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(device_wakeup_enable);
 
+/**
+ * device_wakeup_attach_irq - Attach a wakeirq to a wakeup source
+ * @dev: Device to handle
+ * @wakeirq: Device specific wakeirq entry
+ *
+ * Attach a device wakeirq to the wakeup source so the device
+ * wake IRQ can be configured automatically for suspend and
+ * resume.
+ */
+int device_wakeup_attach_irq(struct device *dev,
+			     struct wake_irq *wakeirq)
+{
+	struct wakeup_source *ws;
+	int ret = 0;
+
+	spin_lock_irq(&dev->power.lock);
+	ws = dev->power.wakeup;
+	if (!ws) {
+		dev_err(dev, "forgot to call call device_init_wakeup?\n");
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	if (ws->wakeirq) {
+		ret = -EEXIST;
+		goto unlock;
+	}
+
+	ws->wakeirq = wakeirq;
+
+unlock:
+	spin_unlock_irq(&dev->power.lock);
+
+	return ret;
+}
+
+/**
+ * device_wakeup_detach_irq - Detach a wakeirq from a wakeup source
+ * @dev: Device to handle
+ *
+ * Removes a device wakeirq from the wakeup source.
+ */
+void device_wakeup_detach_irq(struct device *dev)
+{
+	struct wakeup_source *ws;
+
+	spin_lock_irq(&dev->power.lock);
+	ws = dev->power.wakeup;
+	if (!ws)
+		goto unlock;
+
+	ws->wakeirq = NULL;
+
+unlock:
+	spin_unlock_irq(&dev->power.lock);
+}
+
+/**
+ * device_wakeup_arm_wake_irqs(void)
+ *
+ * Itereates over the list of device wakeirqs to arm them.
+ */
+void device_wakeup_arm_wake_irqs(void)
+{
+	struct wakeup_source *ws;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		if (ws->wakeirq)
+			dev_pm_arm_wake_irq(ws->wakeirq);
+	}
+	rcu_read_unlock();
+}
+
+/**
+ * device_wakeup_disarm_wake_irqs(void)
+ *
+ * Itereates over the list of device wakeirqs to disarm them.
+ */
+void device_wakeup_disarm_wake_irqs(void)
+{
+	struct wakeup_source *ws;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		if (ws->wakeirq)
+			dev_pm_disarm_wake_irq(ws->wakeirq);
+	}
+	rcu_read_unlock();
+}
+
 /**
  * device_wakeup_detach - Detach a device's wakeup source object from it.
  * @dev: Device to detach the wakeup source object from.

commit 7f436055cb0c0e17c430fb81197b42e20c2e812c
Author: Jin Qian <jinqian@android.com>
Date:   Fri May 15 18:10:37 2015 -0700

    PM / wakeup: add a dummy wakeup_source to record statistics
    
    After a wakeup_source is destroyed, we lost all information such as how
    long this wakeup_source has been active. Add a dummy wakeup_source to
    record such info.
    
    Signed-off-by: Jin Qian <jinqian@android.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 7b5ad9a5a6b6..87c2603b9327 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -56,6 +56,11 @@ static LIST_HEAD(wakeup_sources);
 
 static DECLARE_WAIT_QUEUE_HEAD(wakeup_count_wait_queue);
 
+static struct wakeup_source deleted_ws = {
+	.name = "deleted",
+	.lock =  __SPIN_LOCK_UNLOCKED(deleted_ws.lock),
+};
+
 /**
  * wakeup_source_prepare - Prepare a new wakeup source for initialization.
  * @ws: Wakeup source to prepare.
@@ -107,6 +112,34 @@ void wakeup_source_drop(struct wakeup_source *ws)
 }
 EXPORT_SYMBOL_GPL(wakeup_source_drop);
 
+/*
+ * Record wakeup_source statistics being deleted into a dummy wakeup_source.
+ */
+static void wakeup_source_record(struct wakeup_source *ws)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&deleted_ws.lock, flags);
+
+	if (ws->event_count) {
+		deleted_ws.total_time =
+			ktime_add(deleted_ws.total_time, ws->total_time);
+		deleted_ws.prevent_sleep_time =
+			ktime_add(deleted_ws.prevent_sleep_time,
+				  ws->prevent_sleep_time);
+		deleted_ws.max_time =
+			ktime_compare(deleted_ws.max_time, ws->max_time) > 0 ?
+				deleted_ws.max_time : ws->max_time;
+		deleted_ws.event_count += ws->event_count;
+		deleted_ws.active_count += ws->active_count;
+		deleted_ws.relax_count += ws->relax_count;
+		deleted_ws.expire_count += ws->expire_count;
+		deleted_ws.wakeup_count += ws->wakeup_count;
+	}
+
+	spin_unlock_irqrestore(&deleted_ws.lock, flags);
+}
+
 /**
  * wakeup_source_destroy - Destroy a struct wakeup_source object.
  * @ws: Wakeup source to destroy.
@@ -119,6 +152,7 @@ void wakeup_source_destroy(struct wakeup_source *ws)
 		return;
 
 	wakeup_source_drop(ws);
+	wakeup_source_record(ws);
 	kfree(ws->name);
 	kfree(ws);
 }
@@ -912,6 +946,8 @@ static int wakeup_sources_stats_show(struct seq_file *m, void *unused)
 		print_wakeup_source_stats(m, ws);
 	rcu_read_unlock();
 
+	print_wakeup_source_stats(m, &deleted_ws);
+
 	return 0;
 }
 

commit b6ec94520c5b944da9e045e173ddb453ecf42da3
Author: Jin Qian <jinqian@android.com>
Date:   Wed May 6 15:26:56 2015 -0700

    PM / wakeup: validate wakeup source before activating it.
    
    A rogue wakeup source not registered in wakeup_sources list is not visible
    from wakeup_sources_stats_show. Check if the wakeup source is registered
    properly by looking at the timer struct.
    
    Signed-off-by: Jin Qian <jinqian@android.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 77262009f89d..7b5ad9a5a6b6 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -351,6 +351,20 @@ int device_set_wakeup_enable(struct device *dev, bool enable)
 }
 EXPORT_SYMBOL_GPL(device_set_wakeup_enable);
 
+/**
+ * wakeup_source_not_registered - validate the given wakeup source.
+ * @ws: Wakeup source to be validated.
+ */
+static bool wakeup_source_not_registered(struct wakeup_source *ws)
+{
+	/*
+	 * Use timer struct to check if the given source is initialized
+	 * by wakeup_source_add.
+	 */
+	return ws->timer.function != pm_wakeup_timer_fn ||
+		   ws->timer.data != (unsigned long)ws;
+}
+
 /*
  * The functions below use the observation that each wakeup event starts a
  * period in which the system should not be suspended.  The moment this period
@@ -391,6 +405,10 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 {
 	unsigned int cec;
 
+	if (WARN_ONCE(wakeup_source_not_registered(ws),
+			"unregistered wakeup source\n"))
+		return;
+
 	/*
 	 * active wakeup source should bring the system
 	 * out of PM_SUSPEND_FREEZE state

commit 9f6a240e8b08d3fa711c2b615e7ea901cf59e590
Author: Joe Perches <joe@perches.com>
Date:   Wed Apr 15 16:17:48 2015 -0700

    power: wakeup: remove use of seq_printf return value
    
    The seq_printf return value, because it's frequently misused,
    will eventually be converted to void.
    
    See: commit 1f33c41c03da ("seq_file: Rename seq_overflow() to
         seq_has_overflowed() and make public")
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index aab7158d2afe..77262009f89d 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -843,7 +843,6 @@ static int print_wakeup_source_stats(struct seq_file *m,
 	unsigned long active_count;
 	ktime_t active_time;
 	ktime_t prevent_sleep_time;
-	int ret;
 
 	spin_lock_irqsave(&ws->lock, flags);
 
@@ -866,17 +865,16 @@ static int print_wakeup_source_stats(struct seq_file *m,
 		active_time = ktime_set(0, 0);
 	}
 
-	ret = seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t%lu\t\t"
-			"%lld\t\t%lld\t\t%lld\t\t%lld\t\t%lld\n",
-			ws->name, active_count, ws->event_count,
-			ws->wakeup_count, ws->expire_count,
-			ktime_to_ms(active_time), ktime_to_ms(total_time),
-			ktime_to_ms(max_time), ktime_to_ms(ws->last_time),
-			ktime_to_ms(prevent_sleep_time));
+	seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t%lu\t\t%lld\t\t%lld\t\t%lld\t\t%lld\t\t%lld\n",
+		   ws->name, active_count, ws->event_count,
+		   ws->wakeup_count, ws->expire_count,
+		   ktime_to_ms(active_time), ktime_to_ms(total_time),
+		   ktime_to_ms(max_time), ktime_to_ms(ws->last_time),
+		   ktime_to_ms(prevent_sleep_time));
 
 	spin_unlock_irqrestore(&ws->lock, flags);
 
-	return ret;
+	return 0;
 }
 
 /**

commit 432ec92b299e4bcbb0d9a116789563d53b2798e1
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Mar 2 10:18:13 2015 +0100

    PM / wakeup: export pm_system_wakeup symbol
    
    Export pm_system_wakeup function to allow irq handlers to deal with system
    wakeup.
    
    This is needed for shared IRQ lines where one of the handler is registered
    with IRQF_NO_SUSPEND, while the other ones want to configure it as a wakeup
    source.
    
    In this specific case, irq core does not handle the wakeup process and
    leave the decision to each irq handler.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index c2744b30d5d9..aab7158d2afe 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -730,6 +730,7 @@ void pm_system_wakeup(void)
 	pm_abort_suspend = true;
 	freeze_wake();
 }
+EXPORT_SYMBOL_GPL(pm_system_wakeup);
 
 void pm_wakeup_clear(void)
 {

commit 068765ba7987e73d4381edfe47b70aa121c7155c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 1 13:47:49 2014 +0200

    PM / sleep: Mechanism for aborting system suspends unconditionally
    
    It sometimes may be necessary to abort a system suspend in
    progress or wake up the system from suspend-to-idle even if the
    pm_wakeup_event()/pm_stay_awake() mechanism is not enabled.
    
    For this purpose, introduce a new global variable pm_abort_suspend
    and make pm_wakeup_pending() check its value.  Also add routines
    for manipulating that variable.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index eb1bd2ecad8b..c2744b30d5d9 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -24,6 +24,9 @@
  */
 bool events_check_enabled __read_mostly;
 
+/* If set and the system is suspending, terminate the suspend. */
+static bool pm_abort_suspend __read_mostly;
+
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
  * They need to be modified together atomically, so it's better to use one
@@ -719,7 +722,18 @@ bool pm_wakeup_pending(void)
 		pm_print_active_wakeup_sources();
 	}
 
-	return ret;
+	return ret || pm_abort_suspend;
+}
+
+void pm_system_wakeup(void)
+{
+	pm_abort_suspend = true;
+	freeze_wake();
+}
+
+void pm_wakeup_clear(void)
+{
+	pm_abort_suspend = false;
 }
 
 /**

commit 0c5ff0ef80c2561ef20721299ecfc39c5a42f694
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed May 28 15:23:35 2014 +0800

    PM / sleep: unregister wakeup source when disabling device wakeup
    
    When enabling a device' wakeup capability, a wakeup source
    is created for the device automatically. But the wakeup source
    is not unregistered when disabling the device' wakeup capability.
    
    This results in zombie wakeup sources, after devices/drivers are unregistered.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 2d56f4113ae7..eb1bd2ecad8b 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -318,10 +318,16 @@ int device_init_wakeup(struct device *dev, bool enable)
 {
 	int ret = 0;
 
+	if (!dev)
+		return -EINVAL;
+
 	if (enable) {
 		device_set_wakeup_capable(dev, true);
 		ret = device_wakeup_enable(dev);
 	} else {
+		if (dev->power.can_wakeup)
+			device_wakeup_disable(dev);
+
 		device_set_wakeup_capable(dev, false);
 	}
 

commit bb177fedd348c92c2bea6adc9a2163ebff15272e
Author: Julius Werner <jwerner@chromium.org>
Date:   Wed Jun 12 12:55:22 2013 -0700

    PM / Sleep: Print last wakeup source on failed wakeup_count write
    
    Commit a938da06 introduced a useful little log message to tell
    users/debuggers which wakeup source aborted a suspend.  However,
    this message is only printed if the abort happens during the
    in-kernel suspend path (after writing /sys/power/state).
    
    The full specification of the /sys/power/wakeup_count facility
    allows user-space power managers to double-check if wakeups have
    already happened before it actually tries to suspend (e.g. while it
    was running user-space pre-suspend hooks), by writing the last known
    wakeup_count value to /sys/power/wakeup_count.  This patch changes
    the sysfs handler for that node to also print said log message if
    that write fails, so that we can figure out the offending wakeup
    source for both kinds of suspend aborts.
    
    Signed-off-by: Julius Werner <jwerner@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 407a2efa10bb..2d56f4113ae7 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -659,7 +659,7 @@ void pm_wakeup_event(struct device *dev, unsigned int msec)
 }
 EXPORT_SYMBOL_GPL(pm_wakeup_event);
 
-static void print_active_wakeup_sources(void)
+void pm_print_active_wakeup_sources(void)
 {
 	struct wakeup_source *ws;
 	int active = 0;
@@ -683,6 +683,7 @@ static void print_active_wakeup_sources(void)
 			last_activity_ws->name);
 	rcu_read_unlock();
 }
+EXPORT_SYMBOL_GPL(pm_print_active_wakeup_sources);
 
 /**
  * pm_wakeup_pending - Check if power transition in progress should be aborted.
@@ -709,7 +710,7 @@ bool pm_wakeup_pending(void)
 
 	if (ret) {
 		pr_info("PM: Wakeup pending, aborting suspend\n");
-		print_active_wakeup_sources();
+		pm_print_active_wakeup_sources();
 	}
 
 	return ret;

commit 9350de06be45a5a8b927ac6577c9d35de61c90ca
Author: Bernie Thompson <bhthompson@chromium.org>
Date:   Sat Jun 1 00:47:43 2013 +0000

    PM / wakeup: Adjust messaging for wake events during suspend
    
    This adds in a new message to the wakeup code which adds an
    indication to the log that suspend was cancelled due to a wake event
    occouring during the suspend sequence. It also adjusts the message
    printed in suspend.c to reflect the potential that a suspend was
    aborted, as opposed to a device failing to suspend.
    
    Without these message adjustments one can end up with a kernel log
    that says that a device failed to suspend with no actual device
    suspend failures, which can be confusing to the log examiner.
    
    Signed-off-by: Bernie Thompson <bhthompson@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 79715e7fa43e..407a2efa10bb 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -707,8 +707,10 @@ bool pm_wakeup_pending(void)
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
 
-	if (ret)
+	if (ret) {
+		pr_info("PM: Wakeup pending, aborting suspend\n");
 		print_active_wakeup_sources();
+	}
 
 	return ret;
 }

commit 7e73c5ae6e7991a6c01f6d096ff8afaef4458c36
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Feb 6 13:00:36 2013 +0100

    PM: Introduce suspend state PM_SUSPEND_FREEZE
    
    PM_SUSPEND_FREEZE state is a general state that
    does not need any platform specific support, it equals
    frozen processes + suspended devices + idle processors.
    
    Compared with PM_SUSPEND_MEMORY,
    PM_SUSPEND_FREEZE saves less power
    because the system is still in a running state.
    PM_SUSPEND_FREEZE has less resume latency because it does not
    touch BIOS, and the processors are in idle state.
    
    Compared with RTPM/idle,
    PM_SUSPEND_FREEZE saves more power as
    1. the processor has longer sleep time because processes are frozen.
       The deeper c-state the processor supports, more power saving we can get.
    2. PM_SUSPEND_FREEZE uses system suspend code path, thus we can get
       more power saving from the devices that does not have good RTPM support.
    
    This state is useful for
    1) platforms that do not have STR, or have a broken STR.
    2) platforms that have an extremely low power idle state,
       which can be used to replace STR.
    
    The following describes how PM_SUSPEND_FREEZE state works.
    1. echo freeze > /sys/power/state
    2. the processes are frozen.
    3. all the devices are suspended.
    4. all the processors are blocked by a wait queue
    5. all the processors idles and enters (Deep) c-state.
    6. an interrupt fires.
    7. a processor is woken up and handles the irq.
    8. if it is a general event,
       a) the irq handler runs and quites.
       b) goto step 4.
    9. if it is a real wake event, say, power button pressing, keyboard touch, mouse moving,
       a) the irq handler runs and activate the wakeup source
       b) wakeup_source_activate() notifies the wait queue.
       c) system starts resuming from PM_SUSPEND_FREEZE
    10. all the devices are resumed.
    11. all the processes are unfrozen.
    12. system is back to working.
    
    Known Issue:
    The wakeup of this new PM_SUSPEND_FREEZE state may behave differently
    from the previous suspend state.
    Take ACPI platform for example, there are some GPEs that only enabled
    when the system is in sleep state, to wake the system backk from S3/S4.
    But we are not touching these GPEs during transition to PM_SUSPEND_FREEZE.
    This means we may lose some wake event.
    But on the other hand, as we do not disable all the Interrupts during
    PM_SUSPEND_FREEZE, we may get some extra "wakeup" Interrupts, that are
    not available for S3/S4.
    
    The patches has been tested on an old Sony laptop, and here are the results:
    
    Average Power:
    1. RPTM/idle for half an hour:
       14.8W, 12.6W, 14.1W, 12.5W, 14.4W, 13.2W, 12.9W
    2. Freeze for half an hour:
       11W, 10.4W, 9.4W, 11.3W 10.5W
    3. RTPM/idle for three hours:
       11.6W
    4. Freeze for three hours:
       10W
    5. Suspend to Memory:
       0.5~0.9W
    
    Average Resume Latency:
    1. RTPM/idle with a black screen: (From pressing keyboard to screen back)
       Less than 0.2s
    2. Freeze: (From pressing power button to screen back)
       2.50s
    3. Suspend to Memory: (From pressing power button to screen back)
       4.33s
    
    >From the results, we can see that all the platforms should benefit from
    this patch, even if it does not have Low Power S0.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index e6ee5e80e546..79715e7fa43e 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -382,6 +382,12 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 {
 	unsigned int cec;
 
+	/*
+	 * active wakeup source should bring the system
+	 * out of PM_SUSPEND_FREEZE state
+	 */
+	freeze_wake();
+
 	ws->active = true;
 	ws->active_count++;
 	ws->last_time = ktime_get();

commit 4955070974ecfa0b1ae9d2506f529460fd3a4b0b
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Sep 6 23:19:06 2012 +0200

    PM / wakeup: Use irqsave/irqrestore for events_lock
    
    Jon Medhurst (Tixy) recently noticed a problem with the
    events_lock usage. One of the Android patches that uses
    wakeup_sources calls wakeup_source_add() with irqs disabled.
    However, the event_lock usage in wakeup_source_add() uses
    spin_lock_irq()/spin_unlock_irq(), which reenables interrupts.
    This results in lockdep warnings.
    
    The fix is to use spin_lock_irqsave()/spin_lock_irqrestore()
    instead for the events_lock.
    
    References: https://bugs.launchpad.net/linaro-landing-team-arm/+bug/1037565
    Reported-and-debugged-by: Jon Medhurst (Tixy) <tixy@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 8a0a9ca6ad65..e6ee5e80e546 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -127,6 +127,8 @@ EXPORT_SYMBOL_GPL(wakeup_source_destroy);
  */
 void wakeup_source_add(struct wakeup_source *ws)
 {
+	unsigned long flags;
+
 	if (WARN_ON(!ws))
 		return;
 
@@ -135,9 +137,9 @@ void wakeup_source_add(struct wakeup_source *ws)
 	ws->active = false;
 	ws->last_time = ktime_get();
 
-	spin_lock_irq(&events_lock);
+	spin_lock_irqsave(&events_lock, flags);
 	list_add_rcu(&ws->entry, &wakeup_sources);
-	spin_unlock_irq(&events_lock);
+	spin_unlock_irqrestore(&events_lock, flags);
 }
 EXPORT_SYMBOL_GPL(wakeup_source_add);
 
@@ -147,12 +149,14 @@ EXPORT_SYMBOL_GPL(wakeup_source_add);
  */
 void wakeup_source_remove(struct wakeup_source *ws)
 {
+	unsigned long flags;
+
 	if (WARN_ON(!ws))
 		return;
 
-	spin_lock_irq(&events_lock);
+	spin_lock_irqsave(&events_lock, flags);
 	list_del_rcu(&ws->entry);
-	spin_unlock_irq(&events_lock);
+	spin_unlock_irqrestore(&events_lock, flags);
 	synchronize_rcu();
 }
 EXPORT_SYMBOL_GPL(wakeup_source_remove);
@@ -752,15 +756,16 @@ bool pm_get_wakeup_count(unsigned int *count, bool block)
 bool pm_save_wakeup_count(unsigned int count)
 {
 	unsigned int cnt, inpr;
+	unsigned long flags;
 
 	events_check_enabled = false;
-	spin_lock_irq(&events_lock);
+	spin_lock_irqsave(&events_lock, flags);
 	split_counters(&cnt, &inpr);
 	if (cnt == count && inpr == 0) {
 		saved_count = count;
 		events_check_enabled = true;
 	}
-	spin_unlock_irq(&events_lock);
+	spin_unlock_irqrestore(&events_lock, flags);
 	return events_check_enabled;
 }
 

commit a938da0682c2487f6aafc9a7c3caa8d675acdb38
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 12 00:17:02 2012 +0200

    PM / Sleep: Print name of wakeup source that aborts suspend
    
    A driver or app may repeatedly request a wakeup source while the system
    is attempting to enter suspend, which may indicate a bug or at least
    point out a highly active system component that is responsible for
    decreased battery life on a mobile device.  Even when the incidence
    of suspend abort is not severe, identifying wakeup sources that
    frequently abort suspend can be a useful clue for power management
    analysis.
    
    In some cases the existing stats can point out the offender where there is
    an unexpectedly high activation count that stands out from the others, but
    in other cases the wakeup source frequently taken just after the rest of
    the system thinks its time to suspend might not stand out in the overall
    stats.
    
    It is also often useful to have information about what's been happening
    recently, rather than totals of all activity for the system boot.
    
    It's suggested to dump a line about which wakeup source
    aborted suspend to aid analysis of these situations.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index cbb463b3a750..8a0a9ca6ad65 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -649,6 +649,31 @@ void pm_wakeup_event(struct device *dev, unsigned int msec)
 }
 EXPORT_SYMBOL_GPL(pm_wakeup_event);
 
+static void print_active_wakeup_sources(void)
+{
+	struct wakeup_source *ws;
+	int active = 0;
+	struct wakeup_source *last_activity_ws = NULL;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		if (ws->active) {
+			pr_info("active wakeup source: %s\n", ws->name);
+			active = 1;
+		} else if (!active &&
+			   (!last_activity_ws ||
+			    ktime_to_ns(ws->last_time) >
+			    ktime_to_ns(last_activity_ws->last_time))) {
+			last_activity_ws = ws;
+		}
+	}
+
+	if (!active && last_activity_ws)
+		pr_info("last active wakeup source: %s\n",
+			last_activity_ws->name);
+	rcu_read_unlock();
+}
+
 /**
  * pm_wakeup_pending - Check if power transition in progress should be aborted.
  *
@@ -671,6 +696,10 @@ bool pm_wakeup_pending(void)
 		events_check_enabled = !ret;
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
+
+	if (ret)
+		print_active_wakeup_sources();
+
 	return ret;
 }
 

commit b86ff9820fd5df69295273b9aa68e58786ffc23f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:42 2012 +0200

    PM / Sleep: Add user space interface for manipulating wakeup sources, v3
    
    Android allows user space to manipulate wakelocks using two
    sysfs file located in /sys/power/, wake_lock and wake_unlock.
    Writing a wakelock name and optionally a timeout to the wake_lock
    file causes the wakelock whose name was written to be acquired (it
    is created before is necessary), optionally with the given timeout.
    Writing the name of a wakelock to wake_unlock causes that wakelock
    to be released.
    
    Implement an analogous interface for user space using wakeup sources.
    Add the /sys/power/wake_lock and /sys/power/wake_unlock files
    allowing user space to create, activate and deactivate wakeup
    sources, such that writing a name and optionally a timeout to
    wake_lock causes the wakeup source of that name to be activated,
    optionally with the given timeout.  If that wakeup source doesn't
    exist, it will be created and then activated.  Writing a name to
    wake_unlock causes the wakeup source of that name, if there is one,
    to be deactivated.  Wakeup sources created with the help of
    wake_lock that haven't been used for more than 5 minutes are garbage
    collected and destroyed.  Moreover, there can be only WL_NUMBER_LIMIT
    wakeup sources created with the help of wake_lock present at a time.
    
    The data type used to track wakeup sources created by user space is
    called "struct wakelock" to indicate the origins of this feature.
    
    This version of the patch includes an rbtree manipulation fix from John Stultz.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 2595b8d8fe1f..cbb463b3a750 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -133,6 +133,7 @@ void wakeup_source_add(struct wakeup_source *ws)
 	spin_lock_init(&ws->lock);
 	setup_timer(&ws->timer, pm_wakeup_timer_fn, (unsigned long)ws);
 	ws->active = false;
+	ws->last_time = ktime_get();
 
 	spin_lock_irq(&events_lock);
 	list_add_rcu(&ws->entry, &wakeup_sources);

commit 55850945e872531644f31fefd217d61dd15dcab8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:32 2012 +0200

    PM / Sleep: Add "prevent autosleep time" statistics to wakeup sources
    
    Android uses one wakelock statistics that is only necessary for
    opportunistic sleep.  Namely, the prevent_suspend_time field
    accumulates the total time the given wakelock has been locked
    while "automatic suspend" was enabled.  Add an analogous field,
    prevent_sleep_time, to wakeup sources and make it behave in a similar
    way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index cf1706df7610..2595b8d8fe1f 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -380,6 +380,8 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 	ws->active = true;
 	ws->active_count++;
 	ws->last_time = ktime_get();
+	if (ws->autosleep_enabled)
+		ws->start_prevent_time = ws->last_time;
 
 	/* Increment the counter of events in progress. */
 	cec = atomic_inc_return(&combined_event_count);
@@ -449,6 +451,17 @@ void pm_stay_awake(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(pm_stay_awake);
 
+#ifdef CONFIG_PM_AUTOSLEEP
+static void update_prevent_sleep_time(struct wakeup_source *ws, ktime_t now)
+{
+	ktime_t delta = ktime_sub(now, ws->start_prevent_time);
+	ws->prevent_sleep_time = ktime_add(ws->prevent_sleep_time, delta);
+}
+#else
+static inline void update_prevent_sleep_time(struct wakeup_source *ws,
+					     ktime_t now) {}
+#endif
+
 /**
  * wakup_source_deactivate - Mark given wakeup source as inactive.
  * @ws: Wakeup source to handle.
@@ -490,6 +503,9 @@ static void wakeup_source_deactivate(struct wakeup_source *ws)
 	del_timer(&ws->timer);
 	ws->timer_expires = 0;
 
+	if (ws->autosleep_enabled)
+		update_prevent_sleep_time(ws, now);
+
 	/*
 	 * Increment the counter of registered wakeup events and decrement the
 	 * couter of wakeup events in progress simultaneously.
@@ -718,6 +734,34 @@ bool pm_save_wakeup_count(unsigned int count)
 	return events_check_enabled;
 }
 
+#ifdef CONFIG_PM_AUTOSLEEP
+/**
+ * pm_wakep_autosleep_enabled - Modify autosleep_enabled for all wakeup sources.
+ * @enabled: Whether to set or to clear the autosleep_enabled flags.
+ */
+void pm_wakep_autosleep_enabled(bool set)
+{
+	struct wakeup_source *ws;
+	ktime_t now = ktime_get();
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		spin_lock_irq(&ws->lock);
+		if (ws->autosleep_enabled != set) {
+			ws->autosleep_enabled = set;
+			if (ws->active) {
+				if (set)
+					ws->start_prevent_time = now;
+				else
+					update_prevent_sleep_time(ws, now);
+			}
+		}
+		spin_unlock_irq(&ws->lock);
+	}
+	rcu_read_unlock();
+}
+#endif /* CONFIG_PM_AUTOSLEEP */
+
 static struct dentry *wakeup_sources_stats_dentry;
 
 /**
@@ -733,28 +777,37 @@ static int print_wakeup_source_stats(struct seq_file *m,
 	ktime_t max_time;
 	unsigned long active_count;
 	ktime_t active_time;
+	ktime_t prevent_sleep_time;
 	int ret;
 
 	spin_lock_irqsave(&ws->lock, flags);
 
 	total_time = ws->total_time;
 	max_time = ws->max_time;
+	prevent_sleep_time = ws->prevent_sleep_time;
 	active_count = ws->active_count;
 	if (ws->active) {
-		active_time = ktime_sub(ktime_get(), ws->last_time);
+		ktime_t now = ktime_get();
+
+		active_time = ktime_sub(now, ws->last_time);
 		total_time = ktime_add(total_time, active_time);
 		if (active_time.tv64 > max_time.tv64)
 			max_time = active_time;
+
+		if (ws->autosleep_enabled)
+			prevent_sleep_time = ktime_add(prevent_sleep_time,
+				ktime_sub(now, ws->start_prevent_time));
 	} else {
 		active_time = ktime_set(0, 0);
 	}
 
 	ret = seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t%lu\t\t"
-			"%lld\t\t%lld\t\t%lld\t\t%lld\n",
+			"%lld\t\t%lld\t\t%lld\t\t%lld\t\t%lld\n",
 			ws->name, active_count, ws->event_count,
 			ws->wakeup_count, ws->expire_count,
 			ktime_to_ms(active_time), ktime_to_ms(total_time),
-			ktime_to_ms(max_time), ktime_to_ms(ws->last_time));
+			ktime_to_ms(max_time), ktime_to_ms(ws->last_time),
+			ktime_to_ms(prevent_sleep_time));
 
 	spin_unlock_irqrestore(&ws->lock, flags);
 
@@ -771,7 +824,7 @@ static int wakeup_sources_stats_show(struct seq_file *m, void *unused)
 
 	seq_puts(m, "name\t\tactive_count\tevent_count\twakeup_count\t"
 		"expire_count\tactive_since\ttotal_time\tmax_time\t"
-		"last_change\n");
+		"last_change\tprevent_suspend_time\n");
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry)

commit 7483b4a4d9abf9dcf1ffe6e805ead2847ec3264e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:22 2012 +0200

    PM / Sleep: Implement opportunistic sleep, v2
    
    Introduce a mechanism by which the kernel can trigger global
    transitions to a sleep state chosen by user space if there are no
    active wakeup sources.
    
    It consists of a new sysfs attribute, /sys/power/autosleep, that
    can be written one of the strings returned by reads from
    /sys/power/state, an ordered workqueue and a work item carrying out
    the "suspend" operations.  If a string representing the system's
    sleep state is written to /sys/power/autosleep, the work item
    triggering transitions to that state is queued up and it requeues
    itself after every execution until user space writes "off" to
    /sys/power/autosleep.
    
    That work item enables the detection of wakeup events using the
    functions already defined in drivers/base/power/wakeup.c (with one
    small modification) and calls either pm_suspend(), or hibernate() to
    put the system into a sleep state.  If a wakeup event is reported
    while the transition is in progress, it will abort the transition and
    the "system suspend" work item will be queued up again.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 1132799421cd..cf1706df7610 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -660,29 +660,33 @@ bool pm_wakeup_pending(void)
 /**
  * pm_get_wakeup_count - Read the number of registered wakeup events.
  * @count: Address to store the value at.
+ * @block: Whether or not to block.
  *
- * Store the number of registered wakeup events at the address in @count.  Block
- * if the current number of wakeup events being processed is nonzero.
+ * Store the number of registered wakeup events at the address in @count.  If
+ * @block is set, block until the current number of wakeup events being
+ * processed is zero.
  *
- * Return 'false' if the wait for the number of wakeup events being processed to
- * drop down to zero has been interrupted by a signal (and the current number
- * of wakeup events being processed is still nonzero).  Otherwise return 'true'.
+ * Return 'false' if the current number of wakeup events being processed is
+ * nonzero.  Otherwise return 'true'.
  */
-bool pm_get_wakeup_count(unsigned int *count)
+bool pm_get_wakeup_count(unsigned int *count, bool block)
 {
 	unsigned int cnt, inpr;
-	DEFINE_WAIT(wait);
 
-	for (;;) {
-		prepare_to_wait(&wakeup_count_wait_queue, &wait,
-				TASK_INTERRUPTIBLE);
-		split_counters(&cnt, &inpr);
-		if (inpr == 0 || signal_pending(current))
-			break;
+	if (block) {
+		DEFINE_WAIT(wait);
+
+		for (;;) {
+			prepare_to_wait(&wakeup_count_wait_queue, &wait,
+					TASK_INTERRUPTIBLE);
+			split_counters(&cnt, &inpr);
+			if (inpr == 0 || signal_pending(current))
+				break;
 
-		schedule();
+			schedule();
+		}
+		finish_wait(&wakeup_count_wait_queue, &wait);
 	}
-	finish_wait(&wakeup_count_wait_queue, &wait);
 
 	split_counters(&cnt, &inpr);
 	*count = cnt;

commit 6791e36c4a40e8930e08669e60077eea6770c429
Author: Arve Hjønnevåg <arve@android.com>
Date:   Sun Apr 29 22:53:02 2012 +0200

    PM / Sleep: Add wakeup_source_activate and wakeup_source_deactivate tracepoints
    
    Add tracepoints to wakeup_source_activate and wakeup_source_deactivate.
    Useful for checking that specific wakeup sources overlap as expected.
    
    Signed-off-by: Arve Hjønnevåg <arve@android.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 7a6eada4534d..1132799421cd 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -14,6 +14,7 @@
 #include <linux/suspend.h>
 #include <linux/seq_file.h>
 #include <linux/debugfs.h>
+#include <trace/events/power.h>
 
 #include "power.h"
 
@@ -374,12 +375,16 @@ EXPORT_SYMBOL_GPL(device_set_wakeup_enable);
  */
 static void wakeup_source_activate(struct wakeup_source *ws)
 {
+	unsigned int cec;
+
 	ws->active = true;
 	ws->active_count++;
 	ws->last_time = ktime_get();
 
 	/* Increment the counter of events in progress. */
-	atomic_inc(&combined_event_count);
+	cec = atomic_inc_return(&combined_event_count);
+
+	trace_wakeup_source_activate(ws->name, cec);
 }
 
 /**
@@ -454,7 +459,7 @@ EXPORT_SYMBOL_GPL(pm_stay_awake);
  */
 static void wakeup_source_deactivate(struct wakeup_source *ws)
 {
-	unsigned int cnt, inpr;
+	unsigned int cnt, inpr, cec;
 	ktime_t duration;
 	ktime_t now;
 
@@ -489,7 +494,8 @@ static void wakeup_source_deactivate(struct wakeup_source *ws)
 	 * Increment the counter of registered wakeup events and decrement the
 	 * couter of wakeup events in progress simultaneously.
 	 */
-	atomic_add(MAX_IN_PROGRESS, &combined_event_count);
+	cec = atomic_add_return(MAX_IN_PROGRESS, &combined_event_count);
+	trace_wakeup_source_deactivate(ws->name, cec);
 
 	split_counters(&cnt, &inpr);
 	if (!inpr && waitqueue_active(&wakeup_count_wait_queue))

commit 30e3ce6dcbe3fc29c343b17e768b07d4a795de21
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:52:52 2012 +0200

    PM / Sleep: Change wakeup source statistics to follow Android
    
    Wakeup statistics used by Android are slightly different from what we
    have in wakeup sources at the moment and there aren't any known
    users of those statistics other than Android, so modify them to make
    it easier for Android to switch to wakeup sources.
    
    This removes the struct wakeup_source's hit_cout field, which is very
    rough and therefore not very useful, and adds two new fields,
    wakeup_count and expire_count.  The first one tracks how many times
    the wakeup source is activated with events_check_enabled set (which
    roughly corresponds to the situations when a system power transition
    to a sleep state is in progress and would be aborted by this wakeup
    source if it were the only active one at that time) and the second
    one is the number of times the wakeup source has been activated with
    a timeout that expired.
    
    Additionally, the last_time field is now updated when the wakeup
    source is deactivated too (previously it was only updated during
    the wakeup source's activation), which seems to be what Android does
    with the analogous counter for wakelocks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 92f220d89d35..7a6eada4534d 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -21,7 +21,7 @@
  * If set, the suspend/hibernate code will abort transitions to a sleep state
  * if wakeup events are registered during or immediately before the transition.
  */
-bool events_check_enabled;
+bool events_check_enabled __read_mostly;
 
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
@@ -382,6 +382,21 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 	atomic_inc(&combined_event_count);
 }
 
+/**
+ * wakeup_source_report_event - Report wakeup event using the given source.
+ * @ws: Wakeup source to report the event for.
+ */
+static void wakeup_source_report_event(struct wakeup_source *ws)
+{
+	ws->event_count++;
+	/* This is racy, but the counter is approximate anyway. */
+	if (events_check_enabled)
+		ws->wakeup_count++;
+
+	if (!ws->active)
+		wakeup_source_activate(ws);
+}
+
 /**
  * __pm_stay_awake - Notify the PM core of a wakeup event.
  * @ws: Wakeup source object associated with the source of the event.
@@ -397,10 +412,7 @@ void __pm_stay_awake(struct wakeup_source *ws)
 
 	spin_lock_irqsave(&ws->lock, flags);
 
-	ws->event_count++;
-	if (!ws->active)
-		wakeup_source_activate(ws);
-
+	wakeup_source_report_event(ws);
 	del_timer(&ws->timer);
 	ws->timer_expires = 0;
 
@@ -469,6 +481,7 @@ static void wakeup_source_deactivate(struct wakeup_source *ws)
 	if (ktime_to_ns(duration) > ktime_to_ns(ws->max_time))
 		ws->max_time = duration;
 
+	ws->last_time = now;
 	del_timer(&ws->timer);
 	ws->timer_expires = 0;
 
@@ -541,8 +554,10 @@ static void pm_wakeup_timer_fn(unsigned long data)
 	spin_lock_irqsave(&ws->lock, flags);
 
 	if (ws->active && ws->timer_expires
-	    && time_after_eq(jiffies, ws->timer_expires))
+	    && time_after_eq(jiffies, ws->timer_expires)) {
 		wakeup_source_deactivate(ws);
+		ws->expire_count++;
+	}
 
 	spin_unlock_irqrestore(&ws->lock, flags);
 }
@@ -569,9 +584,7 @@ void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
 
 	spin_lock_irqsave(&ws->lock, flags);
 
-	ws->event_count++;
-	if (!ws->active)
-		wakeup_source_activate(ws);
+	wakeup_source_report_event(ws);
 
 	if (!msec) {
 		wakeup_source_deactivate(ws);
@@ -613,24 +626,6 @@ void pm_wakeup_event(struct device *dev, unsigned int msec)
 }
 EXPORT_SYMBOL_GPL(pm_wakeup_event);
 
-/**
- * pm_wakeup_update_hit_counts - Update hit counts of all active wakeup sources.
- */
-static void pm_wakeup_update_hit_counts(void)
-{
-	unsigned long flags;
-	struct wakeup_source *ws;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
-		spin_lock_irqsave(&ws->lock, flags);
-		if (ws->active)
-			ws->hit_count++;
-		spin_unlock_irqrestore(&ws->lock, flags);
-	}
-	rcu_read_unlock();
-}
-
 /**
  * pm_wakeup_pending - Check if power transition in progress should be aborted.
  *
@@ -653,8 +648,6 @@ bool pm_wakeup_pending(void)
 		events_check_enabled = !ret;
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
-	if (ret)
-		pm_wakeup_update_hit_counts();
 	return ret;
 }
 
@@ -680,7 +673,6 @@ bool pm_get_wakeup_count(unsigned int *count)
 		split_counters(&cnt, &inpr);
 		if (inpr == 0 || signal_pending(current))
 			break;
-		pm_wakeup_update_hit_counts();
 
 		schedule();
 	}
@@ -713,8 +705,6 @@ bool pm_save_wakeup_count(unsigned int count)
 		events_check_enabled = true;
 	}
 	spin_unlock_irq(&events_lock);
-	if (!events_check_enabled)
-		pm_wakeup_update_hit_counts();
 	return events_check_enabled;
 }
 
@@ -749,9 +739,10 @@ static int print_wakeup_source_stats(struct seq_file *m,
 		active_time = ktime_set(0, 0);
 	}
 
-	ret = seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t"
+	ret = seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t%lu\t\t"
 			"%lld\t\t%lld\t\t%lld\t\t%lld\n",
-			ws->name, active_count, ws->event_count, ws->hit_count,
+			ws->name, active_count, ws->event_count,
+			ws->wakeup_count, ws->expire_count,
 			ktime_to_ms(active_time), ktime_to_ms(total_time),
 			ktime_to_ms(max_time), ktime_to_ms(ws->last_time));
 
@@ -768,8 +759,9 @@ static int wakeup_sources_stats_show(struct seq_file *m, void *unused)
 {
 	struct wakeup_source *ws;
 
-	seq_puts(m, "name\t\tactive_count\tevent_count\thit_count\t"
-		"active_since\ttotal_time\tmax_time\tlast_change\n");
+	seq_puts(m, "name\t\tactive_count\tevent_count\twakeup_count\t"
+		"expire_count\tactive_since\ttotal_time\tmax_time\t"
+		"last_change\n");
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(ws, &wakeup_sources, entry)

commit 60af1066913162c5dd13fad3b872a67b1eb7da0f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:52:34 2012 +0200

    PM / Sleep: Use wait queue to signal "no wakeup events in progress"
    
    The current wakeup source deactivation code doesn't do anything when
    the counter of wakeup events in progress goes down to zero, which
    requires pm_get_wakeup_count() to poll that counter periodically.
    Although this reduces the average time it takes to deactivate a
    wakeup source, it also may lead to a substantial amount of unnecessary
    polling if there are extended periods of wakeup activity.  Thus it
    seems reasonable to use a wait queue for signaling the "no wakeup
    events in progress" condition and remove the polling.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: mark gross <markgross@thegnar.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 2a3e581b8dcd..92f220d89d35 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -17,8 +17,6 @@
 
 #include "power.h"
 
-#define TIMEOUT		100
-
 /*
  * If set, the suspend/hibernate code will abort transitions to a sleep state
  * if wakeup events are registered during or immediately before the transition.
@@ -52,6 +50,8 @@ static void pm_wakeup_timer_fn(unsigned long data);
 
 static LIST_HEAD(wakeup_sources);
 
+static DECLARE_WAIT_QUEUE_HEAD(wakeup_count_wait_queue);
+
 /**
  * wakeup_source_prepare - Prepare a new wakeup source for initialization.
  * @ws: Wakeup source to prepare.
@@ -442,6 +442,7 @@ EXPORT_SYMBOL_GPL(pm_stay_awake);
  */
 static void wakeup_source_deactivate(struct wakeup_source *ws)
 {
+	unsigned int cnt, inpr;
 	ktime_t duration;
 	ktime_t now;
 
@@ -476,6 +477,10 @@ static void wakeup_source_deactivate(struct wakeup_source *ws)
 	 * couter of wakeup events in progress simultaneously.
 	 */
 	atomic_add(MAX_IN_PROGRESS, &combined_event_count);
+
+	split_counters(&cnt, &inpr);
+	if (!inpr && waitqueue_active(&wakeup_count_wait_queue))
+		wake_up(&wakeup_count_wait_queue);
 }
 
 /**
@@ -667,14 +672,19 @@ bool pm_wakeup_pending(void)
 bool pm_get_wakeup_count(unsigned int *count)
 {
 	unsigned int cnt, inpr;
+	DEFINE_WAIT(wait);
 
 	for (;;) {
+		prepare_to_wait(&wakeup_count_wait_queue, &wait,
+				TASK_INTERRUPTIBLE);
 		split_counters(&cnt, &inpr);
 		if (inpr == 0 || signal_pending(current))
 			break;
 		pm_wakeup_update_hit_counts();
-		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
+
+		schedule();
 	}
+	finish_wait(&wakeup_count_wait_queue, &wait);
 
 	split_counters(&cnt, &inpr);
 	*count = cnt;

commit 8671bbc1bd0442ef0eab27f7d56216431c490820
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 21 23:47:56 2012 +0100

    PM / Sleep: Add more wakeup source initialization routines
    
    The existing wakeup source initialization routines are not
    particularly useful for wakeup sources that aren't created by
    wakeup_source_create(), because their users have to open code
    filling the objects with zeros and setting their names.  For this
    reason, introduce routines that can be used for initializing, for
    example, static wakeup source objects.
    
    Requested-by: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 7c5ab70b9ef3..2a3e581b8dcd 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -52,6 +52,23 @@ static void pm_wakeup_timer_fn(unsigned long data);
 
 static LIST_HEAD(wakeup_sources);
 
+/**
+ * wakeup_source_prepare - Prepare a new wakeup source for initialization.
+ * @ws: Wakeup source to prepare.
+ * @name: Pointer to the name of the new wakeup source.
+ *
+ * Callers must ensure that the @name string won't be freed when @ws is still in
+ * use.
+ */
+void wakeup_source_prepare(struct wakeup_source *ws, const char *name)
+{
+	if (ws) {
+		memset(ws, 0, sizeof(*ws));
+		ws->name = name;
+	}
+}
+EXPORT_SYMBOL_GPL(wakeup_source_prepare);
+
 /**
  * wakeup_source_create - Create a struct wakeup_source object.
  * @name: Name of the new wakeup source.
@@ -60,31 +77,44 @@ struct wakeup_source *wakeup_source_create(const char *name)
 {
 	struct wakeup_source *ws;
 
-	ws = kzalloc(sizeof(*ws), GFP_KERNEL);
+	ws = kmalloc(sizeof(*ws), GFP_KERNEL);
 	if (!ws)
 		return NULL;
 
-	if (name)
-		ws->name = kstrdup(name, GFP_KERNEL);
-
+	wakeup_source_prepare(ws, name ? kstrdup(name, GFP_KERNEL) : NULL);
 	return ws;
 }
 EXPORT_SYMBOL_GPL(wakeup_source_create);
 
 /**
- * wakeup_source_destroy - Destroy a struct wakeup_source object.
- * @ws: Wakeup source to destroy.
+ * wakeup_source_drop - Prepare a struct wakeup_source object for destruction.
+ * @ws: Wakeup source to prepare for destruction.
  *
  * Callers must ensure that __pm_stay_awake() or __pm_wakeup_event() will never
  * be run in parallel with this function for the same wakeup source object.
  */
-void wakeup_source_destroy(struct wakeup_source *ws)
+void wakeup_source_drop(struct wakeup_source *ws)
 {
 	if (!ws)
 		return;
 
 	del_timer_sync(&ws->timer);
 	__pm_relax(ws);
+}
+EXPORT_SYMBOL_GPL(wakeup_source_drop);
+
+/**
+ * wakeup_source_destroy - Destroy a struct wakeup_source object.
+ * @ws: Wakeup source to destroy.
+ *
+ * Use only for wakeup source objects created with wakeup_source_create().
+ */
+void wakeup_source_destroy(struct wakeup_source *ws)
+{
+	if (!ws)
+		return;
+
+	wakeup_source_drop(ws);
 	kfree(ws->name);
 	kfree(ws);
 }
@@ -147,8 +177,10 @@ EXPORT_SYMBOL_GPL(wakeup_source_register);
  */
 void wakeup_source_unregister(struct wakeup_source *ws)
 {
-	wakeup_source_remove(ws);
-	wakeup_source_destroy(ws);
+	if (ws) {
+		wakeup_source_remove(ws);
+		wakeup_source_destroy(ws);
+	}
 }
 EXPORT_SYMBOL_GPL(wakeup_source_unregister);
 

commit 4782e1654bdbd30cf307da090b3c4f70157477cb
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 17 23:39:39 2012 +0100

    PM / Sleep: Make __pm_stay_awake() delete wakeup source timers
    
    If __pm_stay_awake() is called after __pm_wakeup_event() for the same
    wakep source object before its timer expires, it won't cancel the
    timer, so the wakeup source will be deactivated from the timer
    function as scheduled by __pm_wakeup_event().  In that case
    __pm_stay_awake() doesn't have any effect beyond incrementing
    the wakeup source's event_count field, although it should cancel
    the timer and make the wakeup source stay active until __pm_relax()
    is called for it.
    
    To fix this problem make __pm_stay_awake() delete the wakeup source's
    timer and ensure that it won't be deactivated from the timer funtion
    afterwards by clearing its timer_expires field.
    
    Reported-by: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index b38bb9afb719..7c5ab70b9ef3 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -344,7 +344,6 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 {
 	ws->active = true;
 	ws->active_count++;
-	ws->timer_expires = jiffies;
 	ws->last_time = ktime_get();
 
 	/* Increment the counter of events in progress. */
@@ -365,9 +364,14 @@ void __pm_stay_awake(struct wakeup_source *ws)
 		return;
 
 	spin_lock_irqsave(&ws->lock, flags);
+
 	ws->event_count++;
 	if (!ws->active)
 		wakeup_source_activate(ws);
+
+	del_timer(&ws->timer);
+	ws->timer_expires = 0;
+
 	spin_unlock_irqrestore(&ws->lock, flags);
 }
 EXPORT_SYMBOL_GPL(__pm_stay_awake);
@@ -541,7 +545,7 @@ void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
 	if (!expires)
 		expires = 1;
 
-	if (time_after(expires, ws->timer_expires)) {
+	if (!ws->timer_expires || time_after(expires, ws->timer_expires)) {
 		mod_timer(&ws->timer, expires);
 		ws->timer_expires = expires;
 	}

commit da863cddd831b0f4bf2d067f8b75254f1be94590
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 17 23:39:33 2012 +0100

    PM / Sleep: Fix race conditions related to wakeup source timer function
    
    If __pm_wakeup_event() has been used (with a nonzero timeout) to
    report a wakeup event and then __pm_relax() immediately followed by
    __pm_stay_awake() is called or __pm_wakeup_event() is called once
    again for the same wakeup source object before its timer expires, the
    timer function pm_wakeup_timer_fn() may still be run as a result of
    the previous __pm_wakeup_event() call.  In either of those cases it
    may mistakenly deactivate the wakeup source that has just been
    activated.
    
    To prevent that from happening, make wakeup_source_deactivate()
    clear the wakeup source's timer_expires field and make
    pm_wakeup_timer_fn() check if timer_expires is different from zero
    and if it's not in future before calling wakeup_source_deactivate()
    (if timer_expires is 0, it means that the timer has just been
    deleted and if timer_expires is in future, it means that the timer
    has just been rescheduled to a different time).
    
    Reported-by: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index d279f462d624..b38bb9afb719 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -433,6 +433,7 @@ static void wakeup_source_deactivate(struct wakeup_source *ws)
 		ws->max_time = duration;
 
 	del_timer(&ws->timer);
+	ws->timer_expires = 0;
 
 	/*
 	 * Increment the counter of registered wakeup events and decrement the
@@ -487,11 +488,22 @@ EXPORT_SYMBOL_GPL(pm_relax);
  * pm_wakeup_timer_fn - Delayed finalization of a wakeup event.
  * @data: Address of the wakeup source object associated with the event source.
  *
- * Call __pm_relax() for the wakeup source whose address is stored in @data.
+ * Call wakeup_source_deactivate() for the wakeup source whose address is stored
+ * in @data if it is currently active and its timer has not been canceled and
+ * the expiration time of the timer is not in future.
  */
 static void pm_wakeup_timer_fn(unsigned long data)
 {
-	__pm_relax((struct wakeup_source *)data);
+	struct wakeup_source *ws = (struct wakeup_source *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ws->lock, flags);
+
+	if (ws->active && ws->timer_expires
+	    && time_after_eq(jiffies, ws->timer_expires))
+		wakeup_source_deactivate(ws);
+
+	spin_unlock_irqrestore(&ws->lock, flags);
 }
 
 /**

commit d94aff87826ee6aa43032f4c0263482913f4e2c8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 17 23:39:20 2012 +0100

    PM / Sleep: Fix possible infinite loop during wakeup source destruction
    
    If wakeup_source_destroy() is called for an active wakeup source that
    is never deactivated, it will spin forever.  To prevent that from
    happening, make wakeup_source_destroy() call __pm_relax() for the
    wakeup source object it is about to free instead of waiting until
    it will be deactivated by someone else.  However, for this to work
    it also needs to make sure that the timer function will not be
    executed after the final __pm_relax(), so make it run
    del_timer_sync() on the wakeup source's timer beforehand.
    
    Additionally, update the kerneldoc comment to document the
    requirement that __pm_stay_awake() and __pm_wakeup_event() must not
    be run in parallel with wakeup_source_destroy().
    
    Reported-by: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 6e591a8a49da..d279f462d624 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -74,22 +74,17 @@ EXPORT_SYMBOL_GPL(wakeup_source_create);
 /**
  * wakeup_source_destroy - Destroy a struct wakeup_source object.
  * @ws: Wakeup source to destroy.
+ *
+ * Callers must ensure that __pm_stay_awake() or __pm_wakeup_event() will never
+ * be run in parallel with this function for the same wakeup source object.
  */
 void wakeup_source_destroy(struct wakeup_source *ws)
 {
 	if (!ws)
 		return;
 
-	spin_lock_irq(&ws->lock);
-	while (ws->active) {
-		spin_unlock_irq(&ws->lock);
-
-		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
-
-		spin_lock_irq(&ws->lock);
-	}
-	spin_unlock_irq(&ws->lock);
-
+	del_timer_sync(&ws->timer);
+	__pm_relax(ws);
 	kfree(ws->name);
 	kfree(ws);
 }

commit 7c95149b7f1f61201b12c73c4862a41bf2428961
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Feb 11 00:00:11 2012 +0100

    PM / Sleep: Initialize wakeup source locks in wakeup_source_add()
    
    Initialize wakeup source locks in wakeup_source_add() instead of
    wakeup_source_create(), because otherwise the locks of the wakeup
    sources that haven't been allocated with wakeup_source_create()
    aren't initialized and handled properly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index caf995fb774b..6e591a8a49da 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -64,7 +64,6 @@ struct wakeup_source *wakeup_source_create(const char *name)
 	if (!ws)
 		return NULL;
 
-	spin_lock_init(&ws->lock);
 	if (name)
 		ws->name = kstrdup(name, GFP_KERNEL);
 
@@ -105,6 +104,7 @@ void wakeup_source_add(struct wakeup_source *ws)
 	if (WARN_ON(!ws))
 		return;
 
+	spin_lock_init(&ws->lock);
 	setup_timer(&ws->timer, pm_wakeup_timer_fn, (unsigned long)ws);
 	ws->active = false;
 

commit 1b6bc32f0a7380102499deb6aa99a59e789efb33
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 07:12:15 2011 -0400

    drivers/base: Add export.h for EXPORT_SYMBOL/THIS_MODULE as required.
    
    Most of these files were implicitly getting EXPORT_SYMBOL via
    device.h which was including module.h, but that path will be broken
    soon.
    
    [ with input from Stephen Rothwell <sfr@canb.auug.org.au> ]
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 14ee07e9cc43..caf995fb774b 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -10,6 +10,7 @@
 #include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/capability.h>
+#include <linux/export.h>
 #include <linux/suspend.h>
 #include <linux/seq_file.h>
 #include <linux/debugfs.h>

commit 8f88893c05f2f677f18f2ce5591b4bed5d4a7535
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Sep 26 17:38:50 2011 +0200

    PM: Update the policy on default wakeup settings
    
    This patch (as1485) documents a change to the kernel's default wakeup
    policy.  Devices that forward wakeup requests between buses should be
    enabled for wakeup by default.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 84f7c7d5a098..14ee07e9cc43 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -276,7 +276,9 @@ EXPORT_SYMBOL_GPL(device_set_wakeup_capable);
  *
  * By default, most devices should leave wakeup disabled.  The exceptions are
  * devices that everyone expects to be wakeup sources: keyboards, power buttons,
- * possibly network interfaces, etc.
+ * possibly network interfaces, etc.  Also, devices that don't generate their
+ * own wakeup requests but merely forward requests from one bus to another
+ * (like PCI bridges) should have wakeup enabled by default.
  */
 int device_init_wakeup(struct device *dev, bool enable)
 {

commit 13e381365614855bf14c8ad68f9b65e3afd3dd2c
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed May 11 22:40:45 2011 +0200

    PM / Wakeup: Remove useless synchronize_rcu() call
    
    wakeup_source_add() adds an item into wakeup_sources list.
    
    There is no need to call synchronize_rcu() at this point.
    
    Its only needed in wakeup_source_remove()
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index abbbd33e8d8a..84f7c7d5a098 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -110,7 +110,6 @@ void wakeup_source_add(struct wakeup_source *ws)
 	spin_lock_irq(&events_lock);
 	list_add_rcu(&ws->entry, &wakeup_sources);
 	spin_unlock_irq(&events_lock);
-	synchronize_rcu();
 }
 EXPORT_SYMBOL_GPL(wakeup_source_add);
 

commit 22110faf8c8e980013790e6a5214de32b3303730
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Apr 26 11:33:09 2011 +0200

    PM / Wakeup: Fix initialization of wakeup-related device sysfs files
    
    It turns out that some PCI devices are only found to be
    wakeup-capable during registration, in which case, when
    device_set_wakeup_capable() is called, device_is_registered() already
    returns 'true' for the given device, but dpm_sysfs_add() hasn't been
    called for it yet.  This leads to situations in which the device's
    power.can_wakeup flag is not set as requested because of failing
    wakeup_sysfs_add() and its wakeup-related sysfs files are not
    created, although they should be present.  This is a post-2.6.38
    regression introduced by commit cb8f51bdadb7969139c2e39c2defd4cde98c1
    (PM: Do not create wakeup sysfs files for devices that cannot wake
    up).
    
    To work around this problem initialize the device's power.entry
    field to an empty list head and make device_set_wakeup_capable()
    check if it is still empty before attempting to add the devices
    wakeup-related sysfs files with wakeup_sysfs_add().  Namely, if
    power.entry is still empty at this point, device_pm_add() hasn't been
    called yet for the device and its wakeup-related files will be
    created later, so device_set_wakeup_capable() doesn't have to create
    them.
    
    Reported-and-tested-by: Tino Keitel <tino.keitel@tikei.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 4573c83df6dd..abbbd33e8d8a 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -258,7 +258,7 @@ void device_set_wakeup_capable(struct device *dev, bool capable)
 	if (!!dev->power.can_wakeup == !!capable)
 		return;
 
-	if (device_is_registered(dev)) {
+	if (device_is_registered(dev) && !list_empty(&dev->power.entry)) {
 		if (capable) {
 			if (wakeup_sysfs_add(dev))
 				return;

commit cb8f51bdadb7969139c2e39c2defd4cde98c1ea8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:26:02 2011 +0100

    PM: Do not create wakeup sysfs files for devices that cannot wake up
    
    Currently, wakeup sysfs attributes are created for all devices,
    regardless of whether or not they are wakeup-capable.  This is
    excessive and complicates wakeup device identification from user
    space (i.e. to identify wakeup-capable devices user space has to read
    /sys/devices/.../power/wakeup for all devices and see if they are not
    empty).
    
    Fix this issue by avoiding to create wakeup sysfs files for devices
    that cannot wake up the system from sleep states (i.e. whose
    power.can_wakeup flags are unset during registration) and modify
    device_set_wakeup_capable() so that it adds (or removes) the relevant
    sysfs attributes if a device's wakeup capability status is changed.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 82836383997f..4573c83df6dd 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -241,6 +241,35 @@ int device_wakeup_disable(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(device_wakeup_disable);
 
+/**
+ * device_set_wakeup_capable - Set/reset device wakeup capability flag.
+ * @dev: Device to handle.
+ * @capable: Whether or not @dev is capable of waking up the system from sleep.
+ *
+ * If @capable is set, set the @dev's power.can_wakeup flag and add its
+ * wakeup-related attributes to sysfs.  Otherwise, unset the @dev's
+ * power.can_wakeup flag and remove its wakeup-related attributes from sysfs.
+ *
+ * This function may sleep and it can't be called from any context where
+ * sleeping is not allowed.
+ */
+void device_set_wakeup_capable(struct device *dev, bool capable)
+{
+	if (!!dev->power.can_wakeup == !!capable)
+		return;
+
+	if (device_is_registered(dev)) {
+		if (capable) {
+			if (wakeup_sysfs_add(dev))
+				return;
+		} else {
+			wakeup_sysfs_remove(dev);
+		}
+	}
+	dev->power.can_wakeup = capable;
+}
+EXPORT_SYMBOL_GPL(device_set_wakeup_capable);
+
 /**
  * device_init_wakeup - Device wakeup initialization.
  * @dev: Device to handle.

commit 790c7885a4b2105e41f7a80b035fdb78e406154f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 31 11:07:01 2011 +0100

    PM / Wakeup: Don't update events_check_enabled in pm_get_wakeup_count()
    
    Since pm_save_wakeup_count() has just been changed to clear
    events_check_enabled unconditionally before checking if there are
    any new wakeup events registered since the last read from
    /sys/power/wakeup_count, the detection of wakeup events during
    suspend may be disabled, after it's been enabled, by writing a
    "wrong" value back to /sys/power/wakeup_count.  For this reason,
    it is not necessary to update events_check_enabled in
    pm_get_wakeup_count() any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 07e08c3aece4..82836383997f 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -586,17 +586,14 @@ bool pm_wakeup_pending(void)
  * Store the number of registered wakeup events at the address in @count.  Block
  * if the current number of wakeup events being processed is nonzero.
  *
- * Return false if the wait for the number of wakeup events being processed to
+ * Return 'false' if the wait for the number of wakeup events being processed to
  * drop down to zero has been interrupted by a signal (and the current number
- * of wakeup events being processed is still nonzero).  Otherwise return true.
+ * of wakeup events being processed is still nonzero).  Otherwise return 'true'.
  */
 bool pm_get_wakeup_count(unsigned int *count)
 {
 	unsigned int cnt, inpr;
 
-	if (capable(CAP_SYS_ADMIN))
-		events_check_enabled = false;
-
 	for (;;) {
 		split_counters(&cnt, &inpr);
 		if (inpr == 0 || signal_pending(current))

commit 378eef99ad45700aabfba2bd962516e5608b259a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 31 11:06:50 2011 +0100

    PM / Wakeup: Make pm_save_wakeup_count() work as documented
    
    According to Documentation/ABI/testing/sysfs-power, the
    /sys/power/wakeup_count interface should only make the kernel react
    to wakeup events during suspend if the last write to it has been
    successful.  However, if /sys/power/wakeup_count is written to two
    times in a row, where the first write is successful and the second
    is not, the kernel will still react to wakeup events during suspend
    due to a bug in pm_save_wakeup_count().
    
    Fix the bug by making pm_save_wakeup_count() clear
    events_check_enabled unconditionally before checking if there are
    any new wakeup events registered since the previous read from
    /sys/power/wakeup_count.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index e5e73b5efc80..07e08c3aece4 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -616,25 +616,25 @@ bool pm_get_wakeup_count(unsigned int *count)
  *
  * If @count is equal to the current number of registered wakeup events and the
  * current number of wakeup events being processed is zero, store @count as the
- * old number of registered wakeup events to be used by pm_check_wakeup_events()
- * and return true.  Otherwise return false.
+ * old number of registered wakeup events for pm_check_wakeup_events(), enable
+ * wakeup events detection and return 'true'.  Otherwise disable wakeup events
+ * detection and return 'false'.
  */
 bool pm_save_wakeup_count(unsigned int count)
 {
 	unsigned int cnt, inpr;
-	bool ret = false;
 
+	events_check_enabled = false;
 	spin_lock_irq(&events_lock);
 	split_counters(&cnt, &inpr);
 	if (cnt == count && inpr == 0) {
 		saved_count = count;
 		events_check_enabled = true;
-		ret = true;
 	}
 	spin_unlock_irq(&events_lock);
-	if (!ret)
+	if (!events_check_enabled)
 		pm_wakeup_update_hit_counts();
-	return ret;
+	return events_check_enabled;
 }
 
 static struct dentry *wakeup_sources_stats_dentry;

commit 023d3779145ec6b7a0f38f19672a347b92feb74e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 31 11:06:39 2011 +0100

    PM / Wakeup: Combine atomic counters to avoid reordering issues
    
    The memory barrier in wakeup_source_deactivate() is supposed to
    prevent the callers of pm_wakeup_pending() and pm_get_wakeup_count()
    from seeing the new value of events_in_progress (0, in particular)
    and the old value of event_count at the same time.  However, if
    wakeup_source_deactivate() is executed by CPU0 and, for instance,
    pm_wakeup_pending() is executed by CPU1, where both processors can
    reorder operations, the memory barrier in wakeup_source_deactivate()
    doesn't affect CPU1 which can reorder reads.  In that case CPU1 may
    very well decide to fetch event_count before it's modified and
    events_in_progress after it's been updated, so pm_wakeup_pending()
    may fail to detect a wakeup event.  This issue can be addressed by
    using a single atomic variable to store both events_in_progress
    and event_count, so that they can be updated together in a single
    atomic operation.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 8ec406d8f548..e5e73b5efc80 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -24,12 +24,26 @@
  */
 bool events_check_enabled;
 
-/* The counter of registered wakeup events. */
-static atomic_t event_count = ATOMIC_INIT(0);
-/* A preserved old value of event_count. */
+/*
+ * Combined counters of registered wakeup events and wakeup events in progress.
+ * They need to be modified together atomically, so it's better to use one
+ * atomic variable to hold them both.
+ */
+static atomic_t combined_event_count = ATOMIC_INIT(0);
+
+#define IN_PROGRESS_BITS	(sizeof(int) * 4)
+#define MAX_IN_PROGRESS		((1 << IN_PROGRESS_BITS) - 1)
+
+static void split_counters(unsigned int *cnt, unsigned int *inpr)
+{
+	unsigned int comb = atomic_read(&combined_event_count);
+
+	*cnt = (comb >> IN_PROGRESS_BITS);
+	*inpr = comb & MAX_IN_PROGRESS;
+}
+
+/* A preserved old value of the events counter. */
 static unsigned int saved_count;
-/* The counter of wakeup events being processed. */
-static atomic_t events_in_progress = ATOMIC_INIT(0);
 
 static DEFINE_SPINLOCK(events_lock);
 
@@ -307,7 +321,8 @@ static void wakeup_source_activate(struct wakeup_source *ws)
 	ws->timer_expires = jiffies;
 	ws->last_time = ktime_get();
 
-	atomic_inc(&events_in_progress);
+	/* Increment the counter of events in progress. */
+	atomic_inc(&combined_event_count);
 }
 
 /**
@@ -394,14 +409,10 @@ static void wakeup_source_deactivate(struct wakeup_source *ws)
 	del_timer(&ws->timer);
 
 	/*
-	 * event_count has to be incremented before events_in_progress is
-	 * modified, so that the callers of pm_check_wakeup_events() and
-	 * pm_save_wakeup_count() don't see the old value of event_count and
-	 * events_in_progress equal to zero at the same time.
+	 * Increment the counter of registered wakeup events and decrement the
+	 * couter of wakeup events in progress simultaneously.
 	 */
-	atomic_inc(&event_count);
-	smp_mb__before_atomic_dec();
-	atomic_dec(&events_in_progress);
+	atomic_add(MAX_IN_PROGRESS, &combined_event_count);
 }
 
 /**
@@ -556,8 +567,10 @@ bool pm_wakeup_pending(void)
 
 	spin_lock_irqsave(&events_lock, flags);
 	if (events_check_enabled) {
-		ret = ((unsigned int)atomic_read(&event_count) != saved_count)
-			|| atomic_read(&events_in_progress);
+		unsigned int cnt, inpr;
+
+		split_counters(&cnt, &inpr);
+		ret = (cnt != saved_count || inpr > 0);
 		events_check_enabled = !ret;
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
@@ -579,19 +592,22 @@ bool pm_wakeup_pending(void)
  */
 bool pm_get_wakeup_count(unsigned int *count)
 {
-	bool ret;
+	unsigned int cnt, inpr;
 
 	if (capable(CAP_SYS_ADMIN))
 		events_check_enabled = false;
 
-	while (atomic_read(&events_in_progress) && !signal_pending(current)) {
+	for (;;) {
+		split_counters(&cnt, &inpr);
+		if (inpr == 0 || signal_pending(current))
+			break;
 		pm_wakeup_update_hit_counts();
 		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
 	}
 
-	ret = !atomic_read(&events_in_progress);
-	*count = atomic_read(&event_count);
-	return ret;
+	split_counters(&cnt, &inpr);
+	*count = cnt;
+	return !inpr;
 }
 
 /**
@@ -605,11 +621,12 @@ bool pm_get_wakeup_count(unsigned int *count)
  */
 bool pm_save_wakeup_count(unsigned int count)
 {
+	unsigned int cnt, inpr;
 	bool ret = false;
 
 	spin_lock_irq(&events_lock);
-	if (count == (unsigned int)atomic_read(&event_count)
-	    && !atomic_read(&events_in_progress)) {
+	split_counters(&cnt, &inpr);
+	if (cnt == count && inpr == 0) {
 		saved_count = count;
 		events_check_enabled = true;
 		ret = true;

commit a2867e08c8e3bdbc00caf56bc3bdde19ccc058e3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Dec 3 22:58:31 2010 +0100

    PM / Wakeup: Replace pm_check_wakeup_events() with pm_wakeup_pending()
    
    To avoid confusion with the meaning and return value of
    pm_check_wakeup_events() replace it with pm_wakeup_pending() that
    will work the other way around (ie. return true when system-wide
    power transition should be aborted).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 71c5528e1c35..8ec406d8f548 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -542,26 +542,26 @@ static void pm_wakeup_update_hit_counts(void)
 }
 
 /**
- * pm_check_wakeup_events - Check for new wakeup events.
+ * pm_wakeup_pending - Check if power transition in progress should be aborted.
  *
  * Compare the current number of registered wakeup events with its preserved
- * value from the past to check if new wakeup events have been registered since
- * the old value was stored.  Check if the current number of wakeup events being
- * processed is zero.
+ * value from the past and return true if new wakeup events have been registered
+ * since the old value was stored.  Also return true if the current number of
+ * wakeup events being processed is different from zero.
  */
-bool pm_check_wakeup_events(void)
+bool pm_wakeup_pending(void)
 {
 	unsigned long flags;
-	bool ret = true;
+	bool ret = false;
 
 	spin_lock_irqsave(&events_lock, flags);
 	if (events_check_enabled) {
-		ret = ((unsigned int)atomic_read(&event_count) == saved_count)
-			&& !atomic_read(&events_in_progress);
-		events_check_enabled = ret;
+		ret = ((unsigned int)atomic_read(&event_count) != saved_count)
+			|| atomic_read(&events_in_progress);
+		events_check_enabled = !ret;
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
-	if (!ret)
+	if (ret)
 		pm_wakeup_update_hit_counts();
 	return ret;
 }

commit 9c034392533f3e9f00656d5c58478cff2560ef81
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Oct 19 23:42:49 2010 +0200

    PM / Wakeup: Show wakeup sources statistics in debugfs
    
    There may be wakeup sources that aren't associated with any devices
    and their statistics information won't be available from sysfs. Also,
    for debugging purposes it is convenient to have all of the wakeup
    sources statistics available from one place.  For these reasons,
    introduce new file "wakeup_sources" in debugfs containing those
    statistics.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 03751a01dbad..71c5528e1c35 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -11,6 +11,8 @@
 #include <linux/sched.h>
 #include <linux/capability.h>
 #include <linux/suspend.h>
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
 
 #include "power.h"
 
@@ -617,3 +619,86 @@ bool pm_save_wakeup_count(unsigned int count)
 		pm_wakeup_update_hit_counts();
 	return ret;
 }
+
+static struct dentry *wakeup_sources_stats_dentry;
+
+/**
+ * print_wakeup_source_stats - Print wakeup source statistics information.
+ * @m: seq_file to print the statistics into.
+ * @ws: Wakeup source object to print the statistics for.
+ */
+static int print_wakeup_source_stats(struct seq_file *m,
+				     struct wakeup_source *ws)
+{
+	unsigned long flags;
+	ktime_t total_time;
+	ktime_t max_time;
+	unsigned long active_count;
+	ktime_t active_time;
+	int ret;
+
+	spin_lock_irqsave(&ws->lock, flags);
+
+	total_time = ws->total_time;
+	max_time = ws->max_time;
+	active_count = ws->active_count;
+	if (ws->active) {
+		active_time = ktime_sub(ktime_get(), ws->last_time);
+		total_time = ktime_add(total_time, active_time);
+		if (active_time.tv64 > max_time.tv64)
+			max_time = active_time;
+	} else {
+		active_time = ktime_set(0, 0);
+	}
+
+	ret = seq_printf(m, "%-12s\t%lu\t\t%lu\t\t%lu\t\t"
+			"%lld\t\t%lld\t\t%lld\t\t%lld\n",
+			ws->name, active_count, ws->event_count, ws->hit_count,
+			ktime_to_ms(active_time), ktime_to_ms(total_time),
+			ktime_to_ms(max_time), ktime_to_ms(ws->last_time));
+
+	spin_unlock_irqrestore(&ws->lock, flags);
+
+	return ret;
+}
+
+/**
+ * wakeup_sources_stats_show - Print wakeup sources statistics information.
+ * @m: seq_file to print the statistics into.
+ */
+static int wakeup_sources_stats_show(struct seq_file *m, void *unused)
+{
+	struct wakeup_source *ws;
+
+	seq_puts(m, "name\t\tactive_count\tevent_count\thit_count\t"
+		"active_since\ttotal_time\tmax_time\tlast_change\n");
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+		print_wakeup_source_stats(m, ws);
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int wakeup_sources_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, wakeup_sources_stats_show, NULL);
+}
+
+static const struct file_operations wakeup_sources_stats_fops = {
+	.owner = THIS_MODULE,
+	.open = wakeup_sources_stats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int __init wakeup_sources_debugfs_init(void)
+{
+	wakeup_sources_stats_dentry = debugfs_create_file("wakeup_sources",
+			S_IRUGO, NULL, NULL, &wakeup_sources_stats_fops);
+	return 0;
+}
+
+postcore_initcall(wakeup_sources_debugfs_init);

commit 074037ec79bea73edf1b1ec72fef1010e83e3cc5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 22 22:09:10 2010 +0200

    PM / Wakeup: Introduce wakeup source objects and event statistics (v3)
    
    Introduce struct wakeup_source for representing system wakeup sources
    within the kernel and for collecting statistics related to them.
    Make the recently introduced helper functions pm_wakeup_event(),
    pm_stay_awake() and pm_relax() use struct wakeup_source objects
    internally, so that wakeup statistics associated with wakeup devices
    can be collected and reported in a consistent way (the definition of
    pm_relax() is changed, which is harmless, because this function is
    not called directly by anyone yet).  Introduce new wakeup-related
    sysfs device attributes in /sys/devices/.../power for reporting the
    device wakeup statistics.
    
    Change the global wakeup events counters event_count and
    events_in_progress into atomic variables, so that it is not necessary
    to acquire a global spinlock in pm_wakeup_event(), pm_stay_awake()
    and pm_relax(), which should allow us to avoid lock contention in
    these functions on SMP systems with many wakeup devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index eb594facfc3f..03751a01dbad 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -11,7 +11,10 @@
 #include <linux/sched.h>
 #include <linux/capability.h>
 #include <linux/suspend.h>
-#include <linux/pm.h>
+
+#include "power.h"
+
+#define TIMEOUT		100
 
 /*
  * If set, the suspend/hibernate code will abort transitions to a sleep state
@@ -20,18 +23,244 @@
 bool events_check_enabled;
 
 /* The counter of registered wakeup events. */
-static unsigned long event_count;
+static atomic_t event_count = ATOMIC_INIT(0);
 /* A preserved old value of event_count. */
-static unsigned long saved_event_count;
+static unsigned int saved_count;
 /* The counter of wakeup events being processed. */
-static unsigned long events_in_progress;
+static atomic_t events_in_progress = ATOMIC_INIT(0);
 
 static DEFINE_SPINLOCK(events_lock);
 
 static void pm_wakeup_timer_fn(unsigned long data);
 
-static DEFINE_TIMER(events_timer, pm_wakeup_timer_fn, 0, 0);
-static unsigned long events_timer_expires;
+static LIST_HEAD(wakeup_sources);
+
+/**
+ * wakeup_source_create - Create a struct wakeup_source object.
+ * @name: Name of the new wakeup source.
+ */
+struct wakeup_source *wakeup_source_create(const char *name)
+{
+	struct wakeup_source *ws;
+
+	ws = kzalloc(sizeof(*ws), GFP_KERNEL);
+	if (!ws)
+		return NULL;
+
+	spin_lock_init(&ws->lock);
+	if (name)
+		ws->name = kstrdup(name, GFP_KERNEL);
+
+	return ws;
+}
+EXPORT_SYMBOL_GPL(wakeup_source_create);
+
+/**
+ * wakeup_source_destroy - Destroy a struct wakeup_source object.
+ * @ws: Wakeup source to destroy.
+ */
+void wakeup_source_destroy(struct wakeup_source *ws)
+{
+	if (!ws)
+		return;
+
+	spin_lock_irq(&ws->lock);
+	while (ws->active) {
+		spin_unlock_irq(&ws->lock);
+
+		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
+
+		spin_lock_irq(&ws->lock);
+	}
+	spin_unlock_irq(&ws->lock);
+
+	kfree(ws->name);
+	kfree(ws);
+}
+EXPORT_SYMBOL_GPL(wakeup_source_destroy);
+
+/**
+ * wakeup_source_add - Add given object to the list of wakeup sources.
+ * @ws: Wakeup source object to add to the list.
+ */
+void wakeup_source_add(struct wakeup_source *ws)
+{
+	if (WARN_ON(!ws))
+		return;
+
+	setup_timer(&ws->timer, pm_wakeup_timer_fn, (unsigned long)ws);
+	ws->active = false;
+
+	spin_lock_irq(&events_lock);
+	list_add_rcu(&ws->entry, &wakeup_sources);
+	spin_unlock_irq(&events_lock);
+	synchronize_rcu();
+}
+EXPORT_SYMBOL_GPL(wakeup_source_add);
+
+/**
+ * wakeup_source_remove - Remove given object from the wakeup sources list.
+ * @ws: Wakeup source object to remove from the list.
+ */
+void wakeup_source_remove(struct wakeup_source *ws)
+{
+	if (WARN_ON(!ws))
+		return;
+
+	spin_lock_irq(&events_lock);
+	list_del_rcu(&ws->entry);
+	spin_unlock_irq(&events_lock);
+	synchronize_rcu();
+}
+EXPORT_SYMBOL_GPL(wakeup_source_remove);
+
+/**
+ * wakeup_source_register - Create wakeup source and add it to the list.
+ * @name: Name of the wakeup source to register.
+ */
+struct wakeup_source *wakeup_source_register(const char *name)
+{
+	struct wakeup_source *ws;
+
+	ws = wakeup_source_create(name);
+	if (ws)
+		wakeup_source_add(ws);
+
+	return ws;
+}
+EXPORT_SYMBOL_GPL(wakeup_source_register);
+
+/**
+ * wakeup_source_unregister - Remove wakeup source from the list and remove it.
+ * @ws: Wakeup source object to unregister.
+ */
+void wakeup_source_unregister(struct wakeup_source *ws)
+{
+	wakeup_source_remove(ws);
+	wakeup_source_destroy(ws);
+}
+EXPORT_SYMBOL_GPL(wakeup_source_unregister);
+
+/**
+ * device_wakeup_attach - Attach a wakeup source object to a device object.
+ * @dev: Device to handle.
+ * @ws: Wakeup source object to attach to @dev.
+ *
+ * This causes @dev to be treated as a wakeup device.
+ */
+static int device_wakeup_attach(struct device *dev, struct wakeup_source *ws)
+{
+	spin_lock_irq(&dev->power.lock);
+	if (dev->power.wakeup) {
+		spin_unlock_irq(&dev->power.lock);
+		return -EEXIST;
+	}
+	dev->power.wakeup = ws;
+	spin_unlock_irq(&dev->power.lock);
+	return 0;
+}
+
+/**
+ * device_wakeup_enable - Enable given device to be a wakeup source.
+ * @dev: Device to handle.
+ *
+ * Create a wakeup source object, register it and attach it to @dev.
+ */
+int device_wakeup_enable(struct device *dev)
+{
+	struct wakeup_source *ws;
+	int ret;
+
+	if (!dev || !dev->power.can_wakeup)
+		return -EINVAL;
+
+	ws = wakeup_source_register(dev_name(dev));
+	if (!ws)
+		return -ENOMEM;
+
+	ret = device_wakeup_attach(dev, ws);
+	if (ret)
+		wakeup_source_unregister(ws);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(device_wakeup_enable);
+
+/**
+ * device_wakeup_detach - Detach a device's wakeup source object from it.
+ * @dev: Device to detach the wakeup source object from.
+ *
+ * After it returns, @dev will not be treated as a wakeup device any more.
+ */
+static struct wakeup_source *device_wakeup_detach(struct device *dev)
+{
+	struct wakeup_source *ws;
+
+	spin_lock_irq(&dev->power.lock);
+	ws = dev->power.wakeup;
+	dev->power.wakeup = NULL;
+	spin_unlock_irq(&dev->power.lock);
+	return ws;
+}
+
+/**
+ * device_wakeup_disable - Do not regard a device as a wakeup source any more.
+ * @dev: Device to handle.
+ *
+ * Detach the @dev's wakeup source object from it, unregister this wakeup source
+ * object and destroy it.
+ */
+int device_wakeup_disable(struct device *dev)
+{
+	struct wakeup_source *ws;
+
+	if (!dev || !dev->power.can_wakeup)
+		return -EINVAL;
+
+	ws = device_wakeup_detach(dev);
+	if (ws)
+		wakeup_source_unregister(ws);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(device_wakeup_disable);
+
+/**
+ * device_init_wakeup - Device wakeup initialization.
+ * @dev: Device to handle.
+ * @enable: Whether or not to enable @dev as a wakeup device.
+ *
+ * By default, most devices should leave wakeup disabled.  The exceptions are
+ * devices that everyone expects to be wakeup sources: keyboards, power buttons,
+ * possibly network interfaces, etc.
+ */
+int device_init_wakeup(struct device *dev, bool enable)
+{
+	int ret = 0;
+
+	if (enable) {
+		device_set_wakeup_capable(dev, true);
+		ret = device_wakeup_enable(dev);
+	} else {
+		device_set_wakeup_capable(dev, false);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(device_init_wakeup);
+
+/**
+ * device_set_wakeup_enable - Enable or disable a device to wake up the system.
+ * @dev: Device to handle.
+ */
+int device_set_wakeup_enable(struct device *dev, bool enable)
+{
+	if (!dev || !dev->power.can_wakeup)
+		return -EINVAL;
+
+	return enable ? device_wakeup_enable(dev) : device_wakeup_disable(dev);
+}
+EXPORT_SYMBOL_GPL(device_set_wakeup_enable);
 
 /*
  * The functions below use the observation that each wakeup event starts a
@@ -55,118 +284,259 @@ static unsigned long events_timer_expires;
  * knowledge, however, may not be available to it, so it can simply specify time
  * to wait before the system can be suspended and pass it as the second
  * argument of pm_wakeup_event().
+ *
+ * It is valid to call pm_relax() after pm_wakeup_event(), in which case the
+ * "no suspend" period will be ended either by the pm_relax(), or by the timer
+ * function executed when the timer expires, whichever comes first.
  */
 
+/**
+ * wakup_source_activate - Mark given wakeup source as active.
+ * @ws: Wakeup source to handle.
+ *
+ * Update the @ws' statistics and, if @ws has just been activated, notify the PM
+ * core of the event by incrementing the counter of of wakeup events being
+ * processed.
+ */
+static void wakeup_source_activate(struct wakeup_source *ws)
+{
+	ws->active = true;
+	ws->active_count++;
+	ws->timer_expires = jiffies;
+	ws->last_time = ktime_get();
+
+	atomic_inc(&events_in_progress);
+}
+
+/**
+ * __pm_stay_awake - Notify the PM core of a wakeup event.
+ * @ws: Wakeup source object associated with the source of the event.
+ *
+ * It is safe to call this function from interrupt context.
+ */
+void __pm_stay_awake(struct wakeup_source *ws)
+{
+	unsigned long flags;
+
+	if (!ws)
+		return;
+
+	spin_lock_irqsave(&ws->lock, flags);
+	ws->event_count++;
+	if (!ws->active)
+		wakeup_source_activate(ws);
+	spin_unlock_irqrestore(&ws->lock, flags);
+}
+EXPORT_SYMBOL_GPL(__pm_stay_awake);
+
 /**
  * pm_stay_awake - Notify the PM core that a wakeup event is being processed.
  * @dev: Device the wakeup event is related to.
  *
- * Notify the PM core of a wakeup event (signaled by @dev) by incrementing the
- * counter of wakeup events being processed.  If @dev is not NULL, the counter
- * of wakeup events related to @dev is incremented too.
+ * Notify the PM core of a wakeup event (signaled by @dev) by calling
+ * __pm_stay_awake for the @dev's wakeup source object.
  *
  * Call this function after detecting of a wakeup event if pm_relax() is going
  * to be called directly after processing the event (and possibly passing it to
  * user space for further processing).
- *
- * It is safe to call this function from interrupt context.
  */
 void pm_stay_awake(struct device *dev)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&events_lock, flags);
-	if (dev)
-		dev->power.wakeup_count++;
+	if (!dev)
+		return;
 
-	events_in_progress++;
-	spin_unlock_irqrestore(&events_lock, flags);
+	spin_lock_irqsave(&dev->power.lock, flags);
+	__pm_stay_awake(dev->power.wakeup);
+	spin_unlock_irqrestore(&dev->power.lock, flags);
 }
+EXPORT_SYMBOL_GPL(pm_stay_awake);
 
 /**
- * pm_relax - Notify the PM core that processing of a wakeup event has ended.
+ * wakup_source_deactivate - Mark given wakeup source as inactive.
+ * @ws: Wakeup source to handle.
  *
- * Notify the PM core that a wakeup event has been processed by decrementing
- * the counter of wakeup events being processed and incrementing the counter
- * of registered wakeup events.
+ * Update the @ws' statistics and notify the PM core that the wakeup source has
+ * become inactive by decrementing the counter of wakeup events being processed
+ * and incrementing the counter of registered wakeup events.
+ */
+static void wakeup_source_deactivate(struct wakeup_source *ws)
+{
+	ktime_t duration;
+	ktime_t now;
+
+	ws->relax_count++;
+	/*
+	 * __pm_relax() may be called directly or from a timer function.
+	 * If it is called directly right after the timer function has been
+	 * started, but before the timer function calls __pm_relax(), it is
+	 * possible that __pm_stay_awake() will be called in the meantime and
+	 * will set ws->active.  Then, ws->active may be cleared immediately
+	 * by the __pm_relax() called from the timer function, but in such a
+	 * case ws->relax_count will be different from ws->active_count.
+	 */
+	if (ws->relax_count != ws->active_count) {
+		ws->relax_count--;
+		return;
+	}
+
+	ws->active = false;
+
+	now = ktime_get();
+	duration = ktime_sub(now, ws->last_time);
+	ws->total_time = ktime_add(ws->total_time, duration);
+	if (ktime_to_ns(duration) > ktime_to_ns(ws->max_time))
+		ws->max_time = duration;
+
+	del_timer(&ws->timer);
+
+	/*
+	 * event_count has to be incremented before events_in_progress is
+	 * modified, so that the callers of pm_check_wakeup_events() and
+	 * pm_save_wakeup_count() don't see the old value of event_count and
+	 * events_in_progress equal to zero at the same time.
+	 */
+	atomic_inc(&event_count);
+	smp_mb__before_atomic_dec();
+	atomic_dec(&events_in_progress);
+}
+
+/**
+ * __pm_relax - Notify the PM core that processing of a wakeup event has ended.
+ * @ws: Wakeup source object associated with the source of the event.
  *
  * Call this function for wakeup events whose processing started with calling
- * pm_stay_awake().
+ * __pm_stay_awake().
  *
  * It is safe to call it from interrupt context.
  */
-void pm_relax(void)
+void __pm_relax(struct wakeup_source *ws)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&events_lock, flags);
-	if (events_in_progress) {
-		events_in_progress--;
-		event_count++;
-	}
-	spin_unlock_irqrestore(&events_lock, flags);
+	if (!ws)
+		return;
+
+	spin_lock_irqsave(&ws->lock, flags);
+	if (ws->active)
+		wakeup_source_deactivate(ws);
+	spin_unlock_irqrestore(&ws->lock, flags);
+}
+EXPORT_SYMBOL_GPL(__pm_relax);
+
+/**
+ * pm_relax - Notify the PM core that processing of a wakeup event has ended.
+ * @dev: Device that signaled the event.
+ *
+ * Execute __pm_relax() for the @dev's wakeup source object.
+ */
+void pm_relax(struct device *dev)
+{
+	unsigned long flags;
+
+	if (!dev)
+		return;
+
+	spin_lock_irqsave(&dev->power.lock, flags);
+	__pm_relax(dev->power.wakeup);
+	spin_unlock_irqrestore(&dev->power.lock, flags);
 }
+EXPORT_SYMBOL_GPL(pm_relax);
 
 /**
  * pm_wakeup_timer_fn - Delayed finalization of a wakeup event.
+ * @data: Address of the wakeup source object associated with the event source.
  *
- * Decrease the counter of wakeup events being processed after it was increased
- * by pm_wakeup_event().
+ * Call __pm_relax() for the wakeup source whose address is stored in @data.
  */
 static void pm_wakeup_timer_fn(unsigned long data)
+{
+	__pm_relax((struct wakeup_source *)data);
+}
+
+/**
+ * __pm_wakeup_event - Notify the PM core of a wakeup event.
+ * @ws: Wakeup source object associated with the event source.
+ * @msec: Anticipated event processing time (in milliseconds).
+ *
+ * Notify the PM core of a wakeup event whose source is @ws that will take
+ * approximately @msec milliseconds to be processed by the kernel.  If @ws is
+ * not active, activate it.  If @msec is nonzero, set up the @ws' timer to
+ * execute pm_wakeup_timer_fn() in future.
+ *
+ * It is safe to call this function from interrupt context.
+ */
+void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
 {
 	unsigned long flags;
+	unsigned long expires;
 
-	spin_lock_irqsave(&events_lock, flags);
-	if (events_timer_expires
-	    && time_before_eq(events_timer_expires, jiffies)) {
-		events_in_progress--;
-		events_timer_expires = 0;
+	if (!ws)
+		return;
+
+	spin_lock_irqsave(&ws->lock, flags);
+
+	ws->event_count++;
+	if (!ws->active)
+		wakeup_source_activate(ws);
+
+	if (!msec) {
+		wakeup_source_deactivate(ws);
+		goto unlock;
 	}
-	spin_unlock_irqrestore(&events_lock, flags);
+
+	expires = jiffies + msecs_to_jiffies(msec);
+	if (!expires)
+		expires = 1;
+
+	if (time_after(expires, ws->timer_expires)) {
+		mod_timer(&ws->timer, expires);
+		ws->timer_expires = expires;
+	}
+
+ unlock:
+	spin_unlock_irqrestore(&ws->lock, flags);
 }
+EXPORT_SYMBOL_GPL(__pm_wakeup_event);
+
 
 /**
  * pm_wakeup_event - Notify the PM core of a wakeup event.
  * @dev: Device the wakeup event is related to.
  * @msec: Anticipated event processing time (in milliseconds).
  *
- * Notify the PM core of a wakeup event (signaled by @dev) that will take
- * approximately @msec milliseconds to be processed by the kernel.  Increment
- * the counter of registered wakeup events and (if @msec is nonzero) set up
- * the wakeup events timer to execute pm_wakeup_timer_fn() in future (if the
- * timer has not been set up already, increment the counter of wakeup events
- * being processed).  If @dev is not NULL, the counter of wakeup events related
- * to @dev is incremented too.
- *
- * It is safe to call this function from interrupt context.
+ * Call __pm_wakeup_event() for the @dev's wakeup source object.
  */
 void pm_wakeup_event(struct device *dev, unsigned int msec)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&events_lock, flags);
-	event_count++;
-	if (dev)
-		dev->power.wakeup_count++;
-
-	if (msec) {
-		unsigned long expires;
+	if (!dev)
+		return;
 
-		expires = jiffies + msecs_to_jiffies(msec);
-		if (!expires)
-			expires = 1;
+	spin_lock_irqsave(&dev->power.lock, flags);
+	__pm_wakeup_event(dev->power.wakeup, msec);
+	spin_unlock_irqrestore(&dev->power.lock, flags);
+}
+EXPORT_SYMBOL_GPL(pm_wakeup_event);
 
-		if (!events_timer_expires
-		    || time_after(expires, events_timer_expires)) {
-			if (!events_timer_expires)
-				events_in_progress++;
+/**
+ * pm_wakeup_update_hit_counts - Update hit counts of all active wakeup sources.
+ */
+static void pm_wakeup_update_hit_counts(void)
+{
+	unsigned long flags;
+	struct wakeup_source *ws;
 
-			mod_timer(&events_timer, expires);
-			events_timer_expires = expires;
-		}
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		spin_lock_irqsave(&ws->lock, flags);
+		if (ws->active)
+			ws->hit_count++;
+		spin_unlock_irqrestore(&ws->lock, flags);
 	}
-	spin_unlock_irqrestore(&events_lock, flags);
+	rcu_read_unlock();
 }
 
 /**
@@ -184,10 +554,13 @@ bool pm_check_wakeup_events(void)
 
 	spin_lock_irqsave(&events_lock, flags);
 	if (events_check_enabled) {
-		ret = (event_count == saved_event_count) && !events_in_progress;
+		ret = ((unsigned int)atomic_read(&event_count) == saved_count)
+			&& !atomic_read(&events_in_progress);
 		events_check_enabled = ret;
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
+	if (!ret)
+		pm_wakeup_update_hit_counts();
 	return ret;
 }
 
@@ -202,24 +575,20 @@ bool pm_check_wakeup_events(void)
  * drop down to zero has been interrupted by a signal (and the current number
  * of wakeup events being processed is still nonzero).  Otherwise return true.
  */
-bool pm_get_wakeup_count(unsigned long *count)
+bool pm_get_wakeup_count(unsigned int *count)
 {
 	bool ret;
 
-	spin_lock_irq(&events_lock);
 	if (capable(CAP_SYS_ADMIN))
 		events_check_enabled = false;
 
-	while (events_in_progress && !signal_pending(current)) {
-		spin_unlock_irq(&events_lock);
-
-		schedule_timeout_interruptible(msecs_to_jiffies(100));
-
-		spin_lock_irq(&events_lock);
+	while (atomic_read(&events_in_progress) && !signal_pending(current)) {
+		pm_wakeup_update_hit_counts();
+		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
 	}
-	*count = event_count;
-	ret = !events_in_progress;
-	spin_unlock_irq(&events_lock);
+
+	ret = !atomic_read(&events_in_progress);
+	*count = atomic_read(&event_count);
 	return ret;
 }
 
@@ -232,16 +601,19 @@ bool pm_get_wakeup_count(unsigned long *count)
  * old number of registered wakeup events to be used by pm_check_wakeup_events()
  * and return true.  Otherwise return false.
  */
-bool pm_save_wakeup_count(unsigned long count)
+bool pm_save_wakeup_count(unsigned int count)
 {
 	bool ret = false;
 
 	spin_lock_irq(&events_lock);
-	if (count == event_count && !events_in_progress) {
-		saved_event_count = count;
+	if (count == (unsigned int)atomic_read(&event_count)
+	    && !atomic_read(&events_in_progress)) {
+		saved_count = count;
 		events_check_enabled = true;
 		ret = true;
 	}
 	spin_unlock_irq(&events_lock);
+	if (!ret)
+		pm_wakeup_update_hit_counts();
 	return ret;
 }

commit 4eb241e5691363c391aac8a5051d0d013188ec84
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 7 23:43:51 2010 +0200

    PM: Do not use dynamically allocated objects in pm_wakeup_event()
    
    Originally, pm_wakeup_event() uses struct delayed_work objects,
    allocated with GFP_ATOMIC, to schedule the execution of pm_relax()
    in future.  However, as noted by Alan Stern, it is not necessary to
    do that, because all pm_wakeup_event() calls can use one static timer
    that will always be set to expire at the latest time passed to
    pm_wakeup_event().
    
    The modifications are based on the example code posted by Alan.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 25599077c39c..eb594facfc3f 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -28,6 +28,11 @@ static unsigned long events_in_progress;
 
 static DEFINE_SPINLOCK(events_lock);
 
+static void pm_wakeup_timer_fn(unsigned long data);
+
+static DEFINE_TIMER(events_timer, pm_wakeup_timer_fn, 0, 0);
+static unsigned long events_timer_expires;
+
 /*
  * The functions below use the observation that each wakeup event starts a
  * period in which the system should not be suspended.  The moment this period
@@ -103,17 +108,22 @@ void pm_relax(void)
 }
 
 /**
- * pm_wakeup_work_fn - Deferred closing of a wakeup event.
+ * pm_wakeup_timer_fn - Delayed finalization of a wakeup event.
  *
- * Execute pm_relax() for a wakeup event detected in the past and free the
- * work item object used for queuing up the work.
+ * Decrease the counter of wakeup events being processed after it was increased
+ * by pm_wakeup_event().
  */
-static void pm_wakeup_work_fn(struct work_struct *work)
+static void pm_wakeup_timer_fn(unsigned long data)
 {
-	struct delayed_work *dwork = to_delayed_work(work);
+	unsigned long flags;
 
-	pm_relax();
-	kfree(dwork);
+	spin_lock_irqsave(&events_lock, flags);
+	if (events_timer_expires
+	    && time_before_eq(events_timer_expires, jiffies)) {
+		events_in_progress--;
+		events_timer_expires = 0;
+	}
+	spin_unlock_irqrestore(&events_lock, flags);
 }
 
 /**
@@ -123,30 +133,38 @@ static void pm_wakeup_work_fn(struct work_struct *work)
  *
  * Notify the PM core of a wakeup event (signaled by @dev) that will take
  * approximately @msec milliseconds to be processed by the kernel.  Increment
- * the counter of wakeup events being processed and queue up a work item
- * that will execute pm_relax() for the event after @msec milliseconds.  If @dev
- * is not NULL, the counter of wakeup events related to @dev is incremented too.
+ * the counter of registered wakeup events and (if @msec is nonzero) set up
+ * the wakeup events timer to execute pm_wakeup_timer_fn() in future (if the
+ * timer has not been set up already, increment the counter of wakeup events
+ * being processed).  If @dev is not NULL, the counter of wakeup events related
+ * to @dev is incremented too.
  *
  * It is safe to call this function from interrupt context.
  */
 void pm_wakeup_event(struct device *dev, unsigned int msec)
 {
 	unsigned long flags;
-	struct delayed_work *dwork;
-
-	dwork = msec ? kzalloc(sizeof(*dwork), GFP_ATOMIC) : NULL;
 
 	spin_lock_irqsave(&events_lock, flags);
+	event_count++;
 	if (dev)
 		dev->power.wakeup_count++;
 
-	if (dwork) {
-		INIT_DELAYED_WORK(dwork, pm_wakeup_work_fn);
-		schedule_delayed_work(dwork, msecs_to_jiffies(msec));
+	if (msec) {
+		unsigned long expires;
 
-		events_in_progress++;
-	} else {
-		event_count++;
+		expires = jiffies + msecs_to_jiffies(msec);
+		if (!expires)
+			expires = 1;
+
+		if (!events_timer_expires
+		    || time_after(expires, events_timer_expires)) {
+			if (!events_timer_expires)
+				events_in_progress++;
+
+			mod_timer(&events_timer, expires);
+			events_timer_expires = expires;
+		}
 	}
 	spin_unlock_irqrestore(&events_lock, flags);
 }

commit c125e96f044427f38d106fab7bc5e4a5e6a18262
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 5 22:43:53 2010 +0200

    PM: Make it possible to avoid races between wakeup and system sleep
    
    One of the arguments during the suspend blockers discussion was that
    the mainline kernel didn't contain any mechanisms making it possible
    to avoid races between wakeup and system suspend.
    
    Generally, there are two problems in that area.  First, if a wakeup
    event occurs exactly when /sys/power/state is being written to, it
    may be delivered to user space right before the freezer kicks in, so
    the user space consumer of the event may not be able to process it
    before the system is suspended.  Second, if a wakeup event occurs
    after user space has been frozen, it is not generally guaranteed that
    the ongoing transition of the system into a sleep state will be
    aborted.
    
    To address these issues introduce a new global sysfs attribute,
    /sys/power/wakeup_count, associated with a running counter of wakeup
    events and three helper functions, pm_stay_awake(), pm_relax(), and
    pm_wakeup_event(), that may be used by kernel subsystems to control
    the behavior of this attribute and to request the PM core to abort
    system transitions into a sleep state already in progress.
    
    The /sys/power/wakeup_count file may be read from or written to by
    user space.  Reads will always succeed (unless interrupted by a
    signal) and return the current value of the wakeup events counter.
    Writes, however, will only succeed if the written number is equal to
    the current value of the wakeup events counter.  If a write is
    successful, it will cause the kernel to save the current value of the
    wakeup events counter and to abort the subsequent system transition
    into a sleep state if any wakeup events are reported after the write
    has returned.
    
    [The assumption is that before writing to /sys/power/state user space
    will first read from /sys/power/wakeup_count.  Next, user space
    consumers of wakeup events will have a chance to acknowledge or
    veto the upcoming system transition to a sleep state.  Finally, if
    the transition is allowed to proceed, /sys/power/wakeup_count will
    be written to and if that succeeds, /sys/power/state will be written
    to as well.  Still, if any wakeup events are reported to the PM core
    by kernel subsystems after that point, the transition will be
    aborted.]
    
    Additionally, put a wakeup events counter into struct dev_pm_info and
    make these per-device wakeup event counters available via sysfs,
    so that it's possible to check the activity of various wakeup event
    sources within the kernel.
    
    To illustrate how subsystems can use pm_wakeup_event(), make the
    low-level PCI runtime PM wakeup-handling code use it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
new file mode 100644
index 000000000000..25599077c39c
--- /dev/null
+++ b/drivers/base/power/wakeup.c
@@ -0,0 +1,229 @@
+/*
+ * drivers/base/power/wakeup.c - System wakeup events framework
+ *
+ * Copyright (c) 2010 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
+ *
+ * This file is released under the GPLv2.
+ */
+
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/capability.h>
+#include <linux/suspend.h>
+#include <linux/pm.h>
+
+/*
+ * If set, the suspend/hibernate code will abort transitions to a sleep state
+ * if wakeup events are registered during or immediately before the transition.
+ */
+bool events_check_enabled;
+
+/* The counter of registered wakeup events. */
+static unsigned long event_count;
+/* A preserved old value of event_count. */
+static unsigned long saved_event_count;
+/* The counter of wakeup events being processed. */
+static unsigned long events_in_progress;
+
+static DEFINE_SPINLOCK(events_lock);
+
+/*
+ * The functions below use the observation that each wakeup event starts a
+ * period in which the system should not be suspended.  The moment this period
+ * will end depends on how the wakeup event is going to be processed after being
+ * detected and all of the possible cases can be divided into two distinct
+ * groups.
+ *
+ * First, a wakeup event may be detected by the same functional unit that will
+ * carry out the entire processing of it and possibly will pass it to user space
+ * for further processing.  In that case the functional unit that has detected
+ * the event may later "close" the "no suspend" period associated with it
+ * directly as soon as it has been dealt with.  The pair of pm_stay_awake() and
+ * pm_relax(), balanced with each other, is supposed to be used in such
+ * situations.
+ *
+ * Second, a wakeup event may be detected by one functional unit and processed
+ * by another one.  In that case the unit that has detected it cannot really
+ * "close" the "no suspend" period associated with it, unless it knows in
+ * advance what's going to happen to the event during processing.  This
+ * knowledge, however, may not be available to it, so it can simply specify time
+ * to wait before the system can be suspended and pass it as the second
+ * argument of pm_wakeup_event().
+ */
+
+/**
+ * pm_stay_awake - Notify the PM core that a wakeup event is being processed.
+ * @dev: Device the wakeup event is related to.
+ *
+ * Notify the PM core of a wakeup event (signaled by @dev) by incrementing the
+ * counter of wakeup events being processed.  If @dev is not NULL, the counter
+ * of wakeup events related to @dev is incremented too.
+ *
+ * Call this function after detecting of a wakeup event if pm_relax() is going
+ * to be called directly after processing the event (and possibly passing it to
+ * user space for further processing).
+ *
+ * It is safe to call this function from interrupt context.
+ */
+void pm_stay_awake(struct device *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&events_lock, flags);
+	if (dev)
+		dev->power.wakeup_count++;
+
+	events_in_progress++;
+	spin_unlock_irqrestore(&events_lock, flags);
+}
+
+/**
+ * pm_relax - Notify the PM core that processing of a wakeup event has ended.
+ *
+ * Notify the PM core that a wakeup event has been processed by decrementing
+ * the counter of wakeup events being processed and incrementing the counter
+ * of registered wakeup events.
+ *
+ * Call this function for wakeup events whose processing started with calling
+ * pm_stay_awake().
+ *
+ * It is safe to call it from interrupt context.
+ */
+void pm_relax(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&events_lock, flags);
+	if (events_in_progress) {
+		events_in_progress--;
+		event_count++;
+	}
+	spin_unlock_irqrestore(&events_lock, flags);
+}
+
+/**
+ * pm_wakeup_work_fn - Deferred closing of a wakeup event.
+ *
+ * Execute pm_relax() for a wakeup event detected in the past and free the
+ * work item object used for queuing up the work.
+ */
+static void pm_wakeup_work_fn(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+
+	pm_relax();
+	kfree(dwork);
+}
+
+/**
+ * pm_wakeup_event - Notify the PM core of a wakeup event.
+ * @dev: Device the wakeup event is related to.
+ * @msec: Anticipated event processing time (in milliseconds).
+ *
+ * Notify the PM core of a wakeup event (signaled by @dev) that will take
+ * approximately @msec milliseconds to be processed by the kernel.  Increment
+ * the counter of wakeup events being processed and queue up a work item
+ * that will execute pm_relax() for the event after @msec milliseconds.  If @dev
+ * is not NULL, the counter of wakeup events related to @dev is incremented too.
+ *
+ * It is safe to call this function from interrupt context.
+ */
+void pm_wakeup_event(struct device *dev, unsigned int msec)
+{
+	unsigned long flags;
+	struct delayed_work *dwork;
+
+	dwork = msec ? kzalloc(sizeof(*dwork), GFP_ATOMIC) : NULL;
+
+	spin_lock_irqsave(&events_lock, flags);
+	if (dev)
+		dev->power.wakeup_count++;
+
+	if (dwork) {
+		INIT_DELAYED_WORK(dwork, pm_wakeup_work_fn);
+		schedule_delayed_work(dwork, msecs_to_jiffies(msec));
+
+		events_in_progress++;
+	} else {
+		event_count++;
+	}
+	spin_unlock_irqrestore(&events_lock, flags);
+}
+
+/**
+ * pm_check_wakeup_events - Check for new wakeup events.
+ *
+ * Compare the current number of registered wakeup events with its preserved
+ * value from the past to check if new wakeup events have been registered since
+ * the old value was stored.  Check if the current number of wakeup events being
+ * processed is zero.
+ */
+bool pm_check_wakeup_events(void)
+{
+	unsigned long flags;
+	bool ret = true;
+
+	spin_lock_irqsave(&events_lock, flags);
+	if (events_check_enabled) {
+		ret = (event_count == saved_event_count) && !events_in_progress;
+		events_check_enabled = ret;
+	}
+	spin_unlock_irqrestore(&events_lock, flags);
+	return ret;
+}
+
+/**
+ * pm_get_wakeup_count - Read the number of registered wakeup events.
+ * @count: Address to store the value at.
+ *
+ * Store the number of registered wakeup events at the address in @count.  Block
+ * if the current number of wakeup events being processed is nonzero.
+ *
+ * Return false if the wait for the number of wakeup events being processed to
+ * drop down to zero has been interrupted by a signal (and the current number
+ * of wakeup events being processed is still nonzero).  Otherwise return true.
+ */
+bool pm_get_wakeup_count(unsigned long *count)
+{
+	bool ret;
+
+	spin_lock_irq(&events_lock);
+	if (capable(CAP_SYS_ADMIN))
+		events_check_enabled = false;
+
+	while (events_in_progress && !signal_pending(current)) {
+		spin_unlock_irq(&events_lock);
+
+		schedule_timeout_interruptible(msecs_to_jiffies(100));
+
+		spin_lock_irq(&events_lock);
+	}
+	*count = event_count;
+	ret = !events_in_progress;
+	spin_unlock_irq(&events_lock);
+	return ret;
+}
+
+/**
+ * pm_save_wakeup_count - Save the current number of registered wakeup events.
+ * @count: Value to compare with the current number of registered wakeup events.
+ *
+ * If @count is equal to the current number of registered wakeup events and the
+ * current number of wakeup events being processed is zero, store @count as the
+ * old number of registered wakeup events to be used by pm_check_wakeup_events()
+ * and return true.  Otherwise return false.
+ */
+bool pm_save_wakeup_count(unsigned long count)
+{
+	bool ret = false;
+
+	spin_lock_irq(&events_lock);
+	if (count == event_count && !events_in_progress) {
+		saved_event_count = count;
+		events_check_enabled = true;
+		ret = true;
+	}
+	spin_unlock_irq(&events_lock);
+	return ret;
+}
