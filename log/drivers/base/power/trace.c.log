commit 0659d4205db4d0225efd8f83291cbacfcdea030c
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jun 21 10:18:54 2020 +0200

    PM: sleep: core: mark 2 functions as __init to save some memory
    
    'early_resume_init()' and 'late_resume_init() 'are only called respectively
    via 'early_resume_init' and 'late_resume_init'.
    
    They can be marked as __init to save a few bytes of memory.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    [ rjw: Subject edits ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 977d27bd1a22..a97f33d0c59f 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -265,14 +265,14 @@ static struct notifier_block pm_trace_nb = {
 	.notifier_call = pm_trace_notify,
 };
 
-static int early_resume_init(void)
+static int __init early_resume_init(void)
 {
 	hash_value_early_read = read_magic_time();
 	register_pm_notifier(&pm_trace_nb);
 	return 0;
 }
 
-static int late_resume_init(void)
+static int __init late_resume_init(void)
 {
 	unsigned int val = hash_value_early_read;
 	unsigned int user, file, dev;

commit 5de363b66a37a0193e28a2de64fa4996159bd5ee
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 15:32:01 2019 +0200

    drivers: base: power: add proper SPDX identifiers on files that did not have them.
    
    There were a few files in the driver core power code that did not have
    SPDX identifiers on them, so fix that up.  At the same time, remove the
    "free form" text that specified the license of the file, as that is
    impossible for any tool to properly parse.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 2bd9d2c744ca..977d27bd1a22 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/base/power/trace.c
  *
@@ -6,7 +7,6 @@
  * Trace facility for suspend/resume problems, when none of the
  * devices may be working.
  */
-
 #define pr_fmt(fmt) "PM: " fmt
 
 #include <linux/pm-trace.h>

commit 7a5bd1279bce2116af67979bea311a0ccc4b8bb9
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 4 09:14:38 2019 -0800

    PM: Add and use pr_fmt()
    
    Prefix all printk/pr_<level> messages with "PM: " to make the
    logging a bit more consistent.
    
    Miscellanea:
    
     o Convert a few printks to pr_<level>
     o Whitespace to align to open parentheses
     o Remove embedded "PM: " from pr_debugs as pr_fmt adds it
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index b11f47a1e819..2bd9d2c744ca 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -7,6 +7,8 @@
  * devices may be working.
  */
 
+#define pr_fmt(fmt) "PM: " fmt
+
 #include <linux/pm-trace.h>
 #include <linux/export.h>
 #include <linux/rtc.h>

commit a07995be61e18a504f37db0169b50de4036fc02d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Dec 4 23:23:30 2018 +0200

    PM: Switch to use %ptR
    
    Use %ptR instead of open coded variant to print content of
    struct rtc_time in human readable format.
    
    Cc: linux-pm@vger.kernel.org
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 1cda505d6a85..b11f47a1e819 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -118,9 +118,7 @@ static unsigned int read_magic_time(void)
 	unsigned int val;
 
 	mc146818_get_time(&time);
-	pr_info("RTC time: %2d:%02d:%02d, date: %02d/%02d/%02d\n",
-		time.tm_hour, time.tm_min, time.tm_sec,
-		time.tm_mon + 1, time.tm_mday, time.tm_year % 100);
+	pr_info("RTC time: %ptRt, date: %ptRd\n", &time, &time);
 	val = time.tm_year;				/* 100 years */
 	if (val > 100)
 		val -= 100;

commit ba58d1020a54933c6b087a3107661c8513556cb8
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Nov 28 14:35:19 2016 -0800

    timekeeping: Ignore the bogus sleep time if pm_trace is enabled
    
    Power management suspend/resume tracing (ab)uses the RTC to store
    suspend/resume information persistently. As a consequence the RTC value is
    clobbered when timekeeping is resumed and tries to inject the sleep time.
    
    Commit a4f8f6667f09 ("timekeeping: Cap array access in timekeeping_debug")
    plugged a out of bounds array access in the timekeeping debug code which
    was caused by the clobbered RTC value, but we still use the clobbered RTC
    value for sleep time injection into kernel timekeeping, which will result
    in random adjustments depending on the stored "hash" value.
    
    To prevent this keep track of the RTC clobbering and ignore the invalid RTC
    timestamp at resume. If the system resumed successfully clear the flag,
    which marks the RTC as unusable, warn the user about the RTC clobber and
    recommend to adjust the RTC with 'ntpdate' or 'rdate'.
    
    [jstultz: Fixed up pr_warn formating, and implemented suggestions from Ingo]
    [ tglx: Rewrote changelog ]
    
    Originally-from: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Xunlei Pang <xlpang@redhat.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: http://lkml.kernel.org/r/1480372524-15181-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index efec10b49d59..1cda505d6a85 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -10,6 +10,7 @@
 #include <linux/pm-trace.h>
 #include <linux/export.h>
 #include <linux/rtc.h>
+#include <linux/suspend.h>
 
 #include <linux/mc146818rtc.h>
 
@@ -74,6 +75,9 @@
 
 #define DEVSEED (7919)
 
+bool pm_trace_rtc_abused __read_mostly;
+EXPORT_SYMBOL_GPL(pm_trace_rtc_abused);
+
 static unsigned int dev_hash_value;
 
 static int set_magic_time(unsigned int user, unsigned int file, unsigned int device)
@@ -104,6 +108,7 @@ static int set_magic_time(unsigned int user, unsigned int file, unsigned int dev
 	time.tm_min = (n % 20) * 3;
 	n /= 20;
 	mc146818_set_time(&time);
+	pm_trace_rtc_abused = true;
 	return n ? -1 : 0;
 }
 
@@ -239,9 +244,31 @@ int show_trace_dev_match(char *buf, size_t size)
 	return ret;
 }
 
+static int
+pm_trace_notify(struct notifier_block *nb, unsigned long mode, void *_unused)
+{
+	switch (mode) {
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		if (pm_trace_rtc_abused) {
+			pm_trace_rtc_abused = false;
+			pr_warn("Possible incorrect RTC due to pm_trace, please use 'ntpdate' or 'rdate' to reset it.\n");
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block pm_trace_nb = {
+	.notifier_call = pm_trace_notify,
+};
+
 static int early_resume_init(void)
 {
 	hash_value_early_read = read_magic_time();
+	register_pm_notifier(&pm_trace_nb);
 	return 0;
 }
 

commit 463a86304cae92e10277b47180ac59cf93982e5b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 30 20:57:51 2016 +0200

    char/genrtc: x86: remove remnants of asm/rtc.h
    
    Commit 3195ef59cb42 ("x86: Do full rtc synchronization with ntp") had
    the side-effect of unconditionally enabling the RTC_LIB symbol on x86,
    which in turn disables the selection of the CONFIG_RTC and
    CONFIG_GEN_RTC drivers that contain a two older implementations of
    the CONFIG_RTC_DRV_CMOS driver.
    
    This removes x86 from the list for genrtc, and changes all references
    to the asm/rtc.h header to instead point to the interfaces
    from linux/mc146818rtc.h.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index a6975795e7f3..efec10b49d59 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -11,7 +11,7 @@
 #include <linux/export.h>
 #include <linux/rtc.h>
 
-#include <asm/rtc.h>
+#include <linux/mc146818rtc.h>
 
 #include "power.h"
 
@@ -103,7 +103,7 @@ static int set_magic_time(unsigned int user, unsigned int file, unsigned int dev
 	n /= 24;
 	time.tm_min = (n % 20) * 3;
 	n /= 20;
-	set_rtc_time(&time);
+	mc146818_set_time(&time);
 	return n ? -1 : 0;
 }
 
@@ -112,7 +112,7 @@ static unsigned int read_magic_time(void)
 	struct rtc_time time;
 	unsigned int val;
 
-	get_rtc_time(&time);
+	mc146818_get_time(&time);
 	pr_info("RTC time: %2d:%02d:%02d, date: %02d/%02d/%02d\n",
 		time.tm_hour, time.tm_min, time.tm_sec,
 		time.tm_mon + 1, time.tm_mday, time.tm_year % 100);

commit f97238373b8662a6d580e204df2e7bcbfa43e27a
Author: Eric Biggers <ebiggers3@gmail.com>
Date:   Sun Jan 24 20:08:52 2016 -0600

    PM / sleep: declare __tracedata symbols as char[] rather than char
    
    Accessing more than one byte from a symbol declared simply 'char' is undefined
    behavior, as reported by UBSAN:
    
            UBSAN: Undefined behaviour in drivers/base/power/trace.c:178:18
            load of address ffffffff8203fc78 with insufficient space
            for an object of type 'char'
    
    Avoid this by declaring the symbols as arrays.
    
    Signed-off-by: Eric Biggers <ebiggers3@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index a311cfa4c5bd..a6975795e7f3 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -166,14 +166,14 @@ void generate_pm_trace(const void *tracedata, unsigned int user)
 }
 EXPORT_SYMBOL(generate_pm_trace);
 
-extern char __tracedata_start, __tracedata_end;
+extern char __tracedata_start[], __tracedata_end[];
 static int show_file_hash(unsigned int value)
 {
 	int match;
 	char *tracedata;
 
 	match = 0;
-	for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ;
+	for (tracedata = __tracedata_start ; tracedata < __tracedata_end ;
 			tracedata += 2 + sizeof(unsigned long)) {
 		unsigned short lineno = *(unsigned short *)tracedata;
 		const char *file = *(const char **)(tracedata + 2);

commit 431d452af13720463dda498999b2e9a08729c03a
Author: Zhonghui Fu <zhonghui.fu@linux.intel.com>
Date:   Wed Mar 18 15:54:27 2015 +0100

    PM / sleep: add pm-trace support for suspending phase
    
    Occasionally, the system can't come back up after suspend/resume
    due to problems of device suspending phase. This patch make
    PM_TRACE infrastructure cover device suspending phase of
    suspend/resume process, and the information in RTC can tell
    developers which device suspending function make system hang.
    
    Signed-off-by: Zhonghui Fu <zhonghui.fu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index d94a1f5121cf..a311cfa4c5bd 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -7,7 +7,7 @@
  * devices may be working.
  */
 
-#include <linux/resume-trace.h>
+#include <linux/pm-trace.h>
 #include <linux/export.h>
 #include <linux/rtc.h>
 
@@ -154,7 +154,7 @@ EXPORT_SYMBOL(set_trace_device);
  * it's not any guarantee, but it's a high _likelihood_ that
  * the match is valid).
  */
-void generate_resume_trace(const void *tracedata, unsigned int user)
+void generate_pm_trace(const void *tracedata, unsigned int user)
 {
 	unsigned short lineno = *(unsigned short *)tracedata;
 	const char *file = *(const char **)(tracedata + 2);
@@ -164,7 +164,7 @@ void generate_resume_trace(const void *tracedata, unsigned int user)
 	file_hash_value = hash_string(lineno, file, FILEHASH);
 	set_magic_time(user_hash_value, file_hash_value, dev_hash_value);
 }
-EXPORT_SYMBOL(generate_resume_trace);
+EXPORT_SYMBOL(generate_pm_trace);
 
 extern char __tracedata_start, __tracedata_end;
 static int show_file_hash(unsigned int value)

commit 1b6bc32f0a7380102499deb6aa99a59e789efb33
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 07:12:15 2011 -0400

    drivers/base: Add export.h for EXPORT_SYMBOL/THIS_MODULE as required.
    
    Most of these files were implicitly getting EXPORT_SYMBOL via
    device.h which was including module.h, but that path will be broken
    soon.
    
    [ with input from Stephen Rothwell <sfr@canb.auug.org.au> ]
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index af10abecb99b..d94a1f5121cf 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/resume-trace.h>
+#include <linux/export.h>
 #include <linux/rtc.h>
 
 #include <asm/rtc.h>

commit 1d8047a6f7973470bb1de4606a6e00c0bbee3cc6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jun 27 01:01:16 2011 +0200

    PM: Add "RTC" to PM trace time stamps to avoid confusion
    
    Some users are apparently confused by dmesg output from
    read_magic_time(), which looks like "real" time and date.
    Add the "RTC" string to time stamps printed by read_magic_time() to
    avoid that confusion.
    
    Reported-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index c80e138b62fe..af10abecb99b 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -112,7 +112,7 @@ static unsigned int read_magic_time(void)
 	unsigned int val;
 
 	get_rtc_time(&time);
-	pr_info("Time: %2d:%02d:%02d  Date: %02d/%02d/%02d\n",
+	pr_info("RTC time: %2d:%02d:%02d, date: %02d/%02d/%02d\n",
 		time.tm_hour, time.tm_min, time.tm_sec,
 		time.tm_mon + 1, time.tm_mday, time.tm_year % 100);
 	val = time.tm_year;				/* 100 years */

commit 0295a34d61f14522fddb26856191520d2e1d7e77
Author: Mandeep Singh Baines <msb@chromium.org>
Date:   Mon Jan 31 11:07:14 2011 +0100

    PM: Use appropriate printk() priority level in trace.c
    
    printk()s without a priority level default to KERN_WARNING. To reduce
    noise at KERN_WARNING, this patch sets the priority level appriopriately
    for unleveled printks()s. This should be useful to folks that look at
    dmesg warnings closely.
    
    Changed these messages to pr_info().
    
    Signed-off-by: Mandeep Singh Baines <msb@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 9f4258df4cfd..c80e138b62fe 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -112,7 +112,7 @@ static unsigned int read_magic_time(void)
 	unsigned int val;
 
 	get_rtc_time(&time);
-	printk("Time: %2d:%02d:%02d  Date: %02d/%02d/%02d\n",
+	pr_info("Time: %2d:%02d:%02d  Date: %02d/%02d/%02d\n",
 		time.tm_hour, time.tm_min, time.tm_sec,
 		time.tm_mon + 1, time.tm_mday, time.tm_year % 100);
 	val = time.tm_year;				/* 100 years */
@@ -179,7 +179,7 @@ static int show_file_hash(unsigned int value)
 		unsigned int hash = hash_string(lineno, file, FILEHASH);
 		if (hash != value)
 			continue;
-		printk("  hash matches %s:%u\n", file, lineno);
+		pr_info("  hash matches %s:%u\n", file, lineno);
 		match++;
 	}
 	return match;
@@ -255,7 +255,7 @@ static int late_resume_init(void)
 	val = val / FILEHASH;
 	dev = val /* % DEVHASH */;
 
-	printk("  Magic number: %d:%d:%d\n", user, file, dev);
+	pr_info("  Magic number: %d:%d:%d\n", user, file, dev);
 	show_file_hash(file);
 	show_dev_hash(dev);
 	return 0;

commit d33ac60beaf2c7dee5cd90aba7c1eb385dd70937
Author: James Hogan <james@albanarts.com>
Date:   Tue Oct 12 00:00:25 2010 +0200

    PM: Add sysfs attr for rechecking dev hash from PM trace
    
    If the device which fails to resume is part of a loadable kernel module
    it won't be checked at startup against the magic number stored in the
    RTC.
    
    Add a read-only sysfs attribute /sys/power/pm_trace_dev_match which
    contains a list of newline separated devices (usually just the one)
    which currently match the last magic number. This allows the device
    which is failing to resume to be found after the modules are loaded
    again.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 17e24e3f4422..9f4258df4cfd 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -207,6 +207,37 @@ static int show_dev_hash(unsigned int value)
 
 static unsigned int hash_value_early_read;
 
+int show_trace_dev_match(char *buf, size_t size)
+{
+	unsigned int value = hash_value_early_read / (USERHASH * FILEHASH);
+	int ret = 0;
+	struct list_head *entry;
+
+	/*
+	 * It's possible that multiple devices will match the hash and we can't
+	 * tell which is the culprit, so it's best to output them all.
+	 */
+	device_pm_lock();
+	entry = dpm_list.prev;
+	while (size && entry != &dpm_list) {
+		struct device *dev = to_device(entry);
+		unsigned int hash = hash_string(DEVSEED, dev_name(dev),
+						DEVHASH);
+		if (hash == value) {
+			int len = snprintf(buf, size, "%s\n",
+					    dev_driver_string(dev));
+			if (len > size)
+				len = size;
+			buf += len;
+			ret += len;
+			size -= len;
+		}
+		entry = entry->prev;
+	}
+	device_pm_unlock();
+	return ret;
+}
+
 static int early_resume_init(void)
 {
 	hash_value_early_read = read_magic_time();

commit 2ac21c6bc4249ee6d922f18dbec7266377592c32
Author: James Hogan <james@albanarts.com>
Date:   Mon Oct 11 23:59:58 2010 +0200

    PM: Lock PM device list mutex in show_dev_hash()
    
    Lock the PM device list mutex using device_pm_lock() and
    device_pm_unlock() around the list iteration in show_dev_hash().
    
    show_dev_hash() was reverse iterating dpm_list without first locking the
    mutex that the functions in drivers/base/power/main.c lock. I assume
    this was unintentional since there is no comment suggesting why the lock
    might not be necessary.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 0a1a2c4dbc6e..17e24e3f4422 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -188,8 +188,10 @@ static int show_file_hash(unsigned int value)
 static int show_dev_hash(unsigned int value)
 {
 	int match = 0;
-	struct list_head *entry = dpm_list.prev;
+	struct list_head *entry;
 
+	device_pm_lock();
+	entry = dpm_list.prev;
 	while (entry != &dpm_list) {
 		struct device * dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev_name(dev), DEVHASH);
@@ -199,6 +201,7 @@ static int show_dev_hash(unsigned int value)
 		}
 		entry = entry->prev;
 	}
+	device_pm_unlock();
 	return match;
 }
 

commit 1e0b2cf933ebf32494eba3f668859ba57f06a951
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:36:48 2008 +0100

    driver core: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 2aa6e8fc4def..0a1a2c4dbc6e 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -140,7 +140,7 @@ static unsigned int hash_string(unsigned int seed, const char *data, unsigned in
 
 void set_trace_device(struct device *dev)
 {
-	dev_hash_value = hash_string(DEVSEED, dev->bus_id, DEVHASH);
+	dev_hash_value = hash_string(DEVSEED, dev_name(dev), DEVHASH);
 }
 EXPORT_SYMBOL(set_trace_device);
 
@@ -192,7 +192,7 @@ static int show_dev_hash(unsigned int value)
 
 	while (entry != &dpm_list) {
 		struct device * dev = to_device(entry);
-		unsigned int hash = hash_string(DEVSEED, dev->bus_id, DEVHASH);
+		unsigned int hash = hash_string(DEVSEED, dev_name(dev), DEVHASH);
 		if (hash == value) {
 			dev_info(dev, "hash matches\n");
 			match++;

commit fc3a8828b139c24aade3f9d608775e36c248f8f5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 2 06:02:41 2008 +0200

    driver core: fix a lot of printk usages of bus_id
    
    We have the dev_printk() variants for this kind of thing, use them
    instead of directly trying to access the bus_id field of struct device.
    
    This is done in order to remove bus_id entirely.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 9b1b20b59e0a..2aa6e8fc4def 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -194,7 +194,7 @@ static int show_dev_hash(unsigned int value)
 		struct device * dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev->bus_id, DEVHASH);
 		if (hash == value) {
-			printk("  hash matches device %s\n", dev->bus_id);
+			dev_info(dev, "hash matches\n");
 			match++;
 		}
 		entry = entry->prev;

commit dc7c65db2845a8d17432d89252c4227a9a7cb15f
Merge: 8a0ca91e1db5 58b6e5538460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 16 17:25:46 2008 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (72 commits)
      Revert "x86/PCI: ACPI based PCI gap calculation"
      PCI: remove unnecessary volatile in PCIe hotplug struct controller
      x86/PCI: ACPI based PCI gap calculation
      PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
      PCI PM: Fix pci_prepare_to_sleep
      x86/PCI: Fix PCI config space for domains > 0
      Fix acpi_pm_device_sleep_wake() by providing a stub for CONFIG_PM_SLEEP=n
      PCI: Simplify PCI device PM code
      PCI PM: Introduce pci_prepare_to_sleep and pci_back_from_sleep
      PCI ACPI: Rework PCI handling of wake-up
      ACPI: Introduce new device wakeup flag 'prepared'
      ACPI: Introduce acpi_device_sleep_wake function
      PCI: rework pci_set_power_state function to call platform first
      PCI: Introduce platform_pci_power_manageable function
      ACPI: Introduce acpi_bus_power_manageable function
      PCI: make pci_name use dev_name
      PCI: handle pci_name() being const
      PCI: add stub for pci_set_consistent_dma_mask()
      PCI: remove unused arch pcibios_update_resource() functions
      PCI: fix pci_setup_device()'s sprinting into a const buffer
      ...
    
    Fixed up conflicts in various files (arch/x86/kernel/setup_64.c,
    arch/x86/pci/irq.c, arch/x86/pci/pci.h, drivers/acpi/sleep/main.c,
    drivers/pci/pci.c, drivers/pci/pci.h, include/acpi/acpi_bus.h) from x86
    and ACPI updates manually.

commit 1eede070a59e1cc73da51e1aaa00d9ab86572cfc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 20 23:00:01 2008 +0200

    Introduce new top level suspend and hibernation callbacks
    
    Introduce 'struct pm_ops' and 'struct pm_ext_ops' ('ext' meaning
    'extended') representing suspend and hibernation operations for bus
    types, device classes, device types and device drivers.
    
    Modify the PM core to use 'struct pm_ops' and 'struct pm_ext_ops'
    objects, if defined, instead of the ->suspend(), ->resume(),
    ->suspend_late(), and ->resume_early() callbacks (the old callbacks
    will be considered as legacy and gradually phased out).
    
    The main purpose of doing this is to separate suspend (aka S2RAM and
    standby) callbacks from hibernation callbacks in such a way that the
    new callbacks won't take arguments and the semantics of each of them
    will be clearly specified.  This has been requested for multiple
    times by many people, including Linus himself, and the reason is that
    within the current scheme if ->resume() is called, for example, it's
    difficult to say why it's been called (ie. is it a resume from RAM or
    from hibernation or a suspend/hibernation failure etc.?).
    
    The second purpose is to make the suspend/hibernation callbacks more
    flexible so that device drivers can handle more than they can within
    the current scheme.  For example, some drivers may need to prevent
    new children of the device from being registered before their
    ->suspend() callbacks are executed or they may want to carry out some
    operations requiring the availability of some other devices, not
    directly bound via the parent-child relationship, in order to prepare
    for the execution of ->suspend(), etc.
    
    Ultimately, we'd like to stop using the freezing of tasks for suspend
    and therefore the drivers' suspend/hibernation code will have to take
    care of the handling of the user space during suspend/hibernation.
    That, in turn, would be difficult within the current scheme, without
    the new ->prepare() and ->complete() callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 2b4b392dcbc1..8c1e656b5f8b 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -188,9 +188,9 @@ static int show_file_hash(unsigned int value)
 static int show_dev_hash(unsigned int value)
 {
 	int match = 0;
-	struct list_head * entry = dpm_active.prev;
+	struct list_head *entry = dpm_list.prev;
 
-	while (entry != &dpm_active) {
+	while (entry != &dpm_list) {
 		struct device * dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev->bus_id, DEVHASH);
 		if (hash == value) {

commit 63687a528c39a67c1a213cdffa09feb0e6af9dbe
Author: Jan Beulich <jbeulich@novell.com>
Date:   Mon May 12 15:44:41 2008 +0200

    x86: move tracedata to RODATA
    
    .. allowing it to be write-protected just as other read-only data
    under CONFIG_DEBUG_RODATA.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 2b4b392dcbc1..87a7f1d02578 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -153,7 +153,7 @@ EXPORT_SYMBOL(set_trace_device);
  * it's not any guarantee, but it's a high _likelihood_ that
  * the match is valid).
  */
-void generate_resume_trace(void *tracedata, unsigned int user)
+void generate_resume_trace(const void *tracedata, unsigned int user)
 {
 	unsigned short lineno = *(unsigned short *)tracedata;
 	const char *file = *(const char **)(tracedata + 2);

commit f059bca1c57f665211dc23de1fb31c1849b65c7b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:48 2007 -0700

    pm_trace displays the wrong time from the RTC
    
    The way in which read_magic_time() displays the date read from the RTC is
    apparently confusing to the users (cf.
    https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=250238).  Make it
    print dates in the standard way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index 2b0c601e422e..2b4b392dcbc1 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -114,7 +114,7 @@ static unsigned int read_magic_time(void)
 	get_rtc_time(&time);
 	printk("Time: %2d:%02d:%02d  Date: %02d/%02d/%02d\n",
 		time.tm_hour, time.tm_min, time.tm_sec,
-		time.tm_mon, time.tm_mday, time.tm_year);
+		time.tm_mon + 1, time.tm_mday, time.tm_year % 100);
 	val = time.tm_year;				/* 100 years */
 	if (val > 100)
 		val -= 100;

commit 44bf4cea43816d43deab73c1c16361e899996eaa
Author: Nigel Cunningham <nigel@nigel.suspend2.net>
Date:   Sat Jul 21 17:10:41 2007 +0200

    x86: PM_TRACE support
    
    Signed-off-by: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
index a9ab30fefffc..2b0c601e422e 100644
--- a/drivers/base/power/trace.c
+++ b/drivers/base/power/trace.c
@@ -142,6 +142,7 @@ void set_trace_device(struct device *dev)
 {
 	dev_hash_value = hash_string(DEVSEED, dev->bus_id, DEVHASH);
 }
+EXPORT_SYMBOL(set_trace_device);
 
 /*
  * We could just take the "tracedata" index into the .tracedata
@@ -162,6 +163,7 @@ void generate_resume_trace(void *tracedata, unsigned int user)
 	file_hash_value = hash_string(lineno, file, FILEHASH);
 	set_magic_time(user_hash_value, file_hash_value, dev_hash_value);
 }
+EXPORT_SYMBOL(generate_resume_trace);
 
 extern char __tracedata_start, __tracedata_end;
 static int show_file_hash(unsigned int value)
@@ -170,7 +172,8 @@ static int show_file_hash(unsigned int value)
 	char *tracedata;
 
 	match = 0;
-	for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ; tracedata += 6) {
+	for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ;
+			tracedata += 2 + sizeof(unsigned long)) {
 		unsigned short lineno = *(unsigned short *)tracedata;
 		const char *file = *(const char **)(tracedata + 2);
 		unsigned int hash = hash_string(lineno, file, FILEHASH);

commit eb71c87a492b7090ff9e8ac46912c480a1687e38
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sat Jun 24 14:27:42 2006 -0700

    Add some basic resume trace facilities
    
    Considering that there isn't a lot of hw we can depend on during resume,
    this is about as good as it gets.
    
    This is x86-only for now, although the basic concept (and most of the
    code) will certainly work on almost any platform.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/power/trace.c b/drivers/base/power/trace.c
new file mode 100644
index 000000000000..a9ab30fefffc
--- /dev/null
+++ b/drivers/base/power/trace.c
@@ -0,0 +1,228 @@
+/*
+ * drivers/base/power/trace.c
+ *
+ * Copyright (C) 2006 Linus Torvalds
+ *
+ * Trace facility for suspend/resume problems, when none of the
+ * devices may be working.
+ */
+
+#include <linux/resume-trace.h>
+#include <linux/rtc.h>
+
+#include <asm/rtc.h>
+
+#include "power.h"
+
+/*
+ * Horrid, horrid, horrid.
+ *
+ * It turns out that the _only_ piece of hardware that actually
+ * keeps its value across a hard boot (and, more importantly, the
+ * POST init sequence) is literally the realtime clock.
+ *
+ * Never mind that an RTC chip has 114 bytes (and often a whole
+ * other bank of an additional 128 bytes) of nice SRAM that is
+ * _designed_ to keep data - the POST will clear it. So we literally
+ * can just use the few bytes of actual time data, which means that
+ * we're really limited.
+ *
+ * It means, for example, that we can't use the seconds at all
+ * (since the time between the hang and the boot might be more
+ * than a minute), and we'd better not depend on the low bits of
+ * the minutes either.
+ *
+ * There are the wday fields etc, but I wouldn't guarantee those
+ * are dependable either. And if the date isn't valid, either the
+ * hw or POST will do strange things.
+ *
+ * So we're left with:
+ *  - year: 0-99
+ *  - month: 0-11
+ *  - day-of-month: 1-28
+ *  - hour: 0-23
+ *  - min: (0-30)*2
+ *
+ * Giving us a total range of 0-16128000 (0xf61800), ie less
+ * than 24 bits of actual data we can save across reboots.
+ *
+ * And if your box can't boot in less than three minutes,
+ * you're screwed.
+ *
+ * Now, almost 24 bits of data is pitifully small, so we need
+ * to be pretty dense if we want to use it for anything nice.
+ * What we do is that instead of saving off nice readable info,
+ * we save off _hashes_ of information that we can hopefully
+ * regenerate after the reboot.
+ *
+ * In particular, this means that we might be unlucky, and hit
+ * a case where we have a hash collision, and we end up not
+ * being able to tell for certain exactly which case happened.
+ * But that's hopefully unlikely.
+ *
+ * What we do is to take the bits we can fit, and split them
+ * into three parts (16*997*1009 = 16095568), and use the values
+ * for:
+ *  - 0-15: user-settable
+ *  - 0-996: file + line number
+ *  - 0-1008: device
+ */
+#define USERHASH (16)
+#define FILEHASH (997)
+#define DEVHASH (1009)
+
+#define DEVSEED (7919)
+
+static unsigned int dev_hash_value;
+
+static int set_magic_time(unsigned int user, unsigned int file, unsigned int device)
+{
+	unsigned int n = user + USERHASH*(file + FILEHASH*device);
+
+	// June 7th, 2006
+	static struct rtc_time time = {
+		.tm_sec = 0,
+		.tm_min = 0,
+		.tm_hour = 0,
+		.tm_mday = 7,
+		.tm_mon = 5,	// June - counting from zero
+		.tm_year = 106,
+		.tm_wday = 3,
+		.tm_yday = 160,
+		.tm_isdst = 1
+	};
+
+	time.tm_year = (n % 100);
+	n /= 100;
+	time.tm_mon = (n % 12);
+	n /= 12;
+	time.tm_mday = (n % 28) + 1;
+	n /= 28;
+	time.tm_hour = (n % 24);
+	n /= 24;
+	time.tm_min = (n % 20) * 3;
+	n /= 20;
+	set_rtc_time(&time);
+	return n ? -1 : 0;
+}
+
+static unsigned int read_magic_time(void)
+{
+	struct rtc_time time;
+	unsigned int val;
+
+	get_rtc_time(&time);
+	printk("Time: %2d:%02d:%02d  Date: %02d/%02d/%02d\n",
+		time.tm_hour, time.tm_min, time.tm_sec,
+		time.tm_mon, time.tm_mday, time.tm_year);
+	val = time.tm_year;				/* 100 years */
+	if (val > 100)
+		val -= 100;
+	val += time.tm_mon * 100;			/* 12 months */
+	val += (time.tm_mday-1) * 100 * 12;		/* 28 month-days */
+	val += time.tm_hour * 100 * 12 * 28;		/* 24 hours */
+	val += (time.tm_min / 3) * 100 * 12 * 28 * 24;	/* 20 3-minute intervals */
+	return val;
+}
+
+/*
+ * This is just the sdbm hash function with a user-supplied
+ * seed and final size parameter.
+ */
+static unsigned int hash_string(unsigned int seed, const char *data, unsigned int mod)
+{
+	unsigned char c;
+	while ((c = *data++) != 0) {
+		seed = (seed << 16) + (seed << 6) - seed + c;
+	}
+	return seed % mod;
+}
+
+void set_trace_device(struct device *dev)
+{
+	dev_hash_value = hash_string(DEVSEED, dev->bus_id, DEVHASH);
+}
+
+/*
+ * We could just take the "tracedata" index into the .tracedata
+ * section instead. Generating a hash of the data gives us a
+ * chance to work across kernel versions, and perhaps more
+ * importantly it also gives us valid/invalid check (ie we will
+ * likely not give totally bogus reports - if the hash matches,
+ * it's not any guarantee, but it's a high _likelihood_ that
+ * the match is valid).
+ */
+void generate_resume_trace(void *tracedata, unsigned int user)
+{
+	unsigned short lineno = *(unsigned short *)tracedata;
+	const char *file = *(const char **)(tracedata + 2);
+	unsigned int user_hash_value, file_hash_value;
+
+	user_hash_value = user % USERHASH;
+	file_hash_value = hash_string(lineno, file, FILEHASH);
+	set_magic_time(user_hash_value, file_hash_value, dev_hash_value);
+}
+
+extern char __tracedata_start, __tracedata_end;
+static int show_file_hash(unsigned int value)
+{
+	int match;
+	char *tracedata;
+
+	match = 0;
+	for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ; tracedata += 6) {
+		unsigned short lineno = *(unsigned short *)tracedata;
+		const char *file = *(const char **)(tracedata + 2);
+		unsigned int hash = hash_string(lineno, file, FILEHASH);
+		if (hash != value)
+			continue;
+		printk("  hash matches %s:%u\n", file, lineno);
+		match++;
+	}
+	return match;
+}
+
+static int show_dev_hash(unsigned int value)
+{
+	int match = 0;
+	struct list_head * entry = dpm_active.prev;
+
+	while (entry != &dpm_active) {
+		struct device * dev = to_device(entry);
+		unsigned int hash = hash_string(DEVSEED, dev->bus_id, DEVHASH);
+		if (hash == value) {
+			printk("  hash matches device %s\n", dev->bus_id);
+			match++;
+		}
+		entry = entry->prev;
+	}
+	return match;
+}
+
+static unsigned int hash_value_early_read;
+
+static int early_resume_init(void)
+{
+	hash_value_early_read = read_magic_time();
+	return 0;
+}
+
+static int late_resume_init(void)
+{
+	unsigned int val = hash_value_early_read;
+	unsigned int user, file, dev;
+
+	user = val % USERHASH;
+	val = val / USERHASH;
+	file = val % FILEHASH;
+	val = val / FILEHASH;
+	dev = val /* % DEVHASH */;
+
+	printk("  Magic number: %d:%d:%d\n", user, file, dev);
+	show_file_hash(file);
+	show_dev_hash(dev);
+	return 0;
+}
+
+core_initcall(early_resume_init);
+late_initcall(late_resume_init);
