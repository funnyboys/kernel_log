commit ca765a8cfe0c78bfa47b9d67121f4e342d4b4512
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 16 15:16:03 2019 +0200

    PM / Domains: Introduce dev_pm_domain_start()
    
    For a subsystem/driver that either doesn't support runtime PM or makes use
    of pm_runtime_set_active() during ->probe(), may try to access its device
    when probing, even if it may not be fully powered on from the PM domain's
    point of view. This may be the case when the used PM domain is a genpd
    provider, that implements genpd's ->start|stop() device callbacks.
    
    There are cases where the subsystem/driver managed to avoid the above
    problem, simply by calling pm_runtime_enable() and pm_runtime_get_sync()
    during ->probe(). However, this approach comes with a drawback, especially
    if the subsystem/driver implements a ->runtime_resume() callback.
    
    More precisely, the subsystem/driver then needs to use a device flag, which
    is checked in its ->runtime_resume() callback, as to avoid powering on its
    resources the first time the callback is invoked. This is needed because
    the subsystem/driver has already powered on the resources for the device,
    during ->probe() and before it called pm_runtime_get_sync().
    
    In a way to avoid this boilerplate code and the inefficient check for "if
    (first_time_suspend)" in the ->runtime_resume() callback for these
    subsystems/drivers, let's introduce and export a dev_pm_domain_start()
    function, that may be called during ->probe() instead.
    
    Moreover, let the dev_pm_domain_start() invoke an optional ->start()
    callback, added to the struct dev_pm_domain, as to allow a PM domain
    specific implementation.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 8db98a1f83dc..bbddb267c2e6 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -187,6 +187,26 @@ void dev_pm_domain_detach(struct device *dev, bool power_off)
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_detach);
 
+/**
+ * dev_pm_domain_start - Start the device through its PM domain.
+ * @dev: Device to start.
+ *
+ * This function should typically be called during probe by a subsystem/driver,
+ * when it needs to start its device from the PM domain's perspective. Note
+ * that, it's assumed that the PM domain is already powered on when this
+ * function is called.
+ *
+ * Returns 0 on success and negative error values on failures.
+ */
+int dev_pm_domain_start(struct device *dev)
+{
+	if (dev->pm_domain && dev->pm_domain->start)
+		return dev->pm_domain->start(dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_start);
+
 /**
  * dev_pm_domain_set - Set PM domain of a device.
  * @dev: Device whose PM domain is to be set.

commit 5de363b66a37a0193e28a2de64fa4996159bd5ee
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 15:32:01 2019 +0200

    drivers: base: power: add proper SPDX identifiers on files that did not have them.
    
    There were a few files in the driver core power code that did not have
    SPDX identifiers on them, so fix that up.  At the same time, remove the
    "free form" text that specified the license of the file, as that is
    impossible for any tool to properly parse.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 22aedb28aad7..8db98a1f83dc 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -1,11 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/base/power/common.c - Common device power management code.
  *
  * Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
- *
- * This file is released under the GPLv2.
  */
-
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/export.h>

commit eeb35df05244c268cd69b425edf6dc6a49ee7ab4
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Feb 14 10:12:49 2019 -0800

    PM / Domains: Mark "name" const in dev_pm_domain_attach_by_name()
    
    As of the patch ("PM / Domains: Mark "name" const in
    genpd_dev_pm_attach_by_name()") it's clear that the name in
    dev_pm_domain_attach_by_name() can be const.  Mark it as so.  This
    allows drivers to pass in a name that was declared "const" in a
    driver.
    
    Fixes: 27dceb81f445 ("PM / Domains: Introduce dev_pm_domain_attach_by_name()")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index b413951c6abc..22aedb28aad7 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -160,7 +160,7 @@ EXPORT_SYMBOL_GPL(dev_pm_domain_attach_by_id);
  * For a detailed function description, see dev_pm_domain_attach_by_id().
  */
 struct device *dev_pm_domain_attach_by_name(struct device *dev,
-					    char *name)
+					    const char *name)
 {
 	if (dev->pm_domain)
 		return ERR_PTR(-EEXIST);

commit 27dceb81f445c58b1d10d27d26eaf4ac2e9e0b00
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jun 29 13:04:32 2018 +0200

    PM / Domains: Introduce dev_pm_domain_attach_by_name()
    
    For the multiple PM domain case, let's introduce a new API called
    dev_pm_domain_attach_by_name(). This allows a consumer driver to associate
    its device with one of its PM domains, by using a name based lookup.
    
    Do note that, currently it's only genpd that supports multiple PM domains
    per device, but dev_pm_domain_attach_by_name() can easily by extended to
    cover other PM domain types, if/when needed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Rajendra Nayak <rnayak@codeaurora.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index df41b4780b3b..b413951c6abc 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -152,6 +152,23 @@ struct device *dev_pm_domain_attach_by_id(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_attach_by_id);
 
+/**
+ * dev_pm_domain_attach_by_name - Associate a device with one of its PM domains.
+ * @dev: The device used to lookup the PM domain.
+ * @name: The name of the PM domain.
+ *
+ * For a detailed function description, see dev_pm_domain_attach_by_id().
+ */
+struct device *dev_pm_domain_attach_by_name(struct device *dev,
+					    char *name)
+{
+	if (dev->pm_domain)
+		return ERR_PTR(-EEXIST);
+
+	return genpd_dev_pm_attach_by_name(dev, name);
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_attach_by_name);
+
 /**
  * dev_pm_domain_detach - Detach a device from its PM domain.
  * @dev: Device to detach.

commit 82e12d9e0bd59f3d24be9c735258e2e98e4f54f6
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 31 12:59:59 2018 +0200

    PM / Domains: Add dev_pm_domain_attach_by_id() to manage multi PM domains
    
    The existing dev_pm_domain_attach() function, allows a single PM domain to
    be attached per device. To be able to support devices that are partitioned
    across multiple PM domains, let's introduce a new interface,
    dev_pm_domain_attach_by_id().
    
    The dev_pm_domain_attach_by_id() returns a new allocated struct device with
    the corresponding attached PM domain. This enables for example a driver to
    operate on the new device from a power management point of view. The driver
    may then also benefit from using the received device, to set up so called
    device-links towards its original device. Depending on the situation, these
    links may then be dynamically changed.
    
    The new interface is typically called by drivers during their probe phase,
    in case they manages devices which uses multiple PM domains. If that is the
    case, the driver also becomes responsible of managing the detaching of the
    PM domains, which typically should be done at the remove phase. Detaching
    is done by calling the existing dev_pm_domain_detach() function and for
    each of the received devices from dev_pm_domain_attach_by_id().
    
    Note, currently its only genpd that supports multiple PM domains per
    device, but dev_pm_domain_attach_by_id() can easily by extended to cover
    other PM domain types, if/when needed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 7ae62b6355b8..df41b4780b3b 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -116,14 +116,51 @@ int dev_pm_domain_attach(struct device *dev, bool power_on)
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_attach);
 
+/**
+ * dev_pm_domain_attach_by_id - Associate a device with one of its PM domains.
+ * @dev: The device used to lookup the PM domain.
+ * @index: The index of the PM domain.
+ *
+ * As @dev may only be attached to a single PM domain, the backend PM domain
+ * provider creates a virtual device to attach instead. If attachment succeeds,
+ * the ->detach() callback in the struct dev_pm_domain are assigned by the
+ * corresponding backend attach function, as to deal with detaching of the
+ * created virtual device.
+ *
+ * This function should typically be invoked by a driver during the probe phase,
+ * in case its device requires power management through multiple PM domains. The
+ * driver may benefit from using the received device, to configure device-links
+ * towards its original device. Depending on the use-case and if needed, the
+ * links may be dynamically changed by the driver, which allows it to control
+ * the power to the PM domains independently from each other.
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ *
+ * Returns the virtual created device when successfully attached to its PM
+ * domain, NULL in case @dev don't need a PM domain, else an ERR_PTR().
+ * Note that, to detach the returned virtual device, the driver shall call
+ * dev_pm_domain_detach() on it, typically during the remove phase.
+ */
+struct device *dev_pm_domain_attach_by_id(struct device *dev,
+					  unsigned int index)
+{
+	if (dev->pm_domain)
+		return ERR_PTR(-EEXIST);
+
+	return genpd_dev_pm_attach_by_id(dev, index);
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_attach_by_id);
+
 /**
  * dev_pm_domain_detach - Detach a device from its PM domain.
  * @dev: Device to detach.
  * @power_off: Used to indicate whether we should power off the device.
  *
- * This functions will reverse the actions from dev_pm_domain_attach() and thus
- * try to detach the @dev from its PM domain. Typically it should be invoked
- * from subsystem level code during the remove phase.
+ * This functions will reverse the actions from dev_pm_domain_attach() and
+ * dev_pm_domain_attach_by_id(), thus it detaches @dev from its PM domain.
+ * Typically it should be invoked during the remove phase, either from
+ * subsystem level code or from drivers.
  *
  * Callers must ensure proper synchronization of this function with power
  * management callbacks.

commit 49072f97d4a3f8f44fe9677e3df94082b29b7e6f
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue May 15 15:21:43 2018 +0200

    PM / domains: Improve wording of dev_pm_domain_attach() comment
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 390868c2b392..7ae62b6355b8 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -98,8 +98,8 @@ EXPORT_SYMBOL_GPL(dev_pm_put_subsys_data);
  * Callers must ensure proper synchronization of this function with power
  * management callbacks.
  *
- * Returns 0 on successfully attached PM domain and when it found that the
- * device don't need a PM domain, else a negative error code.
+ * Returns 0 on successfully attached PM domain, or when it is found that the
+ * device doesn't need a PM domain, else a negative error code.
  */
 int dev_pm_domain_attach(struct device *dev, bool power_on)
 {

commit 94ef9b8e2b941ab7e7ce88fa48ce626fa529bf2f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon May 14 16:52:37 2018 +0200

    PM / Domains: Don't return -EEXIST at attach when PM domain exists
    
    As dev_pm_domain_attach() isn't the only way to assign PM domain pointers
    to devices, clearly we must allow a device to have the pointer already
    being assigned. For this reason, return 0 instead of -EEXIST.
    
    Reported-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tested-by: Krzysztof Kozlowski <krzk@kernel.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 5e4b481595bd..390868c2b392 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -106,7 +106,7 @@ int dev_pm_domain_attach(struct device *dev, bool power_on)
 	int ret;
 
 	if (dev->pm_domain)
-		return -EEXIST;
+		return 0;
 
 	ret = acpi_dev_pm_attach(dev, power_on);
 	if (!ret)

commit 919b7308fcc452cd4e282bab389c33384a9f3790
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 9 12:17:52 2018 +0200

    PM / Domains: Allow a better error handling of dev_pm_domain_attach()
    
    The callers of dev_pm_domain_attach() currently checks the returned error
    code for -EPROBE_DEFER and needs to ignore other error codes. This is an
    unnecessary limitation, which also leads to a rather strange behaviour in
    the error path.
    
    Address this limitation, by changing the return codes from
    acpi_dev_pm_attach() and genpd_dev_pm_attach(). More precisely, let them
    return 0, when no PM domain is needed for the device and then return 1, in
    case the device was successfully attached to its PM domain. In this way,
    dev_pm_domain_attach(), gets a better understanding of what happens in the
    attach attempts and also allowing its caller to better act on real errors
    codes.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index f3cf61f58f25..5e4b481595bd 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -98,7 +98,8 @@ EXPORT_SYMBOL_GPL(dev_pm_put_subsys_data);
  * Callers must ensure proper synchronization of this function with power
  * management callbacks.
  *
- * Returns 0 on successfully attached PM domain or negative error code.
+ * Returns 0 on successfully attached PM domain and when it found that the
+ * device don't need a PM domain, else a negative error code.
  */
 int dev_pm_domain_attach(struct device *dev, bool power_on)
 {
@@ -108,10 +109,10 @@ int dev_pm_domain_attach(struct device *dev, bool power_on)
 		return -EEXIST;
 
 	ret = acpi_dev_pm_attach(dev, power_on);
-	if (ret)
+	if (!ret)
 		ret = genpd_dev_pm_attach(dev);
 
-	return ret;
+	return ret < 0 ? ret : 0;
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_attach);
 

commit 4f688748c958deb947759773be6dffe6b44d084d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 26 10:53:03 2018 +0200

    PM / Domains: Check for existing PM domain in dev_pm_domain_attach()
    
    Instead of checking if an existing PM domain pointer has been assigned in
    genpd_dev_pm_attach() and acpi_dev_pm_attach(), move the check to the
    common path in dev_pm_domain_attach(), thus potentially avoid one
    unnecessary check.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index f6a9ad52cbbf..f3cf61f58f25 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -104,6 +104,9 @@ int dev_pm_domain_attach(struct device *dev, bool power_on)
 {
 	int ret;
 
+	if (dev->pm_domain)
+		return -EEXIST;
+
 	ret = acpi_dev_pm_attach(dev, power_on);
 	if (ret)
 		ret = genpd_dev_pm_attach(dev);

commit e79aee49bcf9ad005b3f2f4cf68b17dc2c22d9c2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 30 12:54:29 2016 +0100

    PM: Avoid false-positive warnings in dev_pm_domain_set()
    
    There is a WARN_ON() in dev_pm_domain_set() that triggers on attempts
    to set the pm_domain pointer for devices with a driver bound.
    
    However, that WARN_ON() triggers on attempts to clear the pointer
    too and the test it uses is based on checking the device's
    p->knode_driver pointer which still is set when the device bus
    type's/driver's ->remove callback has been executed.  This
    leads to false-positive warnings when bus type code calls
    dev_pm_domain_set() to clear the pm_domain pointer after
    invoking the driver's ->remove() callback.
    
    To avoid those false-positives, make dev_pm_domain_set() check
    if the pointer passed to it is NULL and skip the warning in
    that case.
    
    Fixes: 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Sinan Kaya <okaya@codeaurora.org>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 93ed14cc2252..f6a9ad52cbbf 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -146,7 +146,7 @@ void dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd)
 	if (dev->pm_domain == pd)
 		return;
 
-	WARN(device_is_bound(dev),
+	WARN(pd && device_is_bound(dev),
 	     "PM domains can only be changed for unbound devices\n");
 	dev->pm_domain = pd;
 	device_pm_check_callbacks(dev);

commit aa8e54b559479d0cb7eb632ba443b8cacd20cd4b
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:14 2016 +0100

    PM / sleep: Go direct_complete if driver has no callbacks
    
    If a suitable prepare callback cannot be found for a given device and
    its driver has no PM callbacks at all, assume that it can go direct to
    complete when the system goes to sleep.
    
    The reason for this is that there's lots of devices in a system that do
    no PM at all and there's no reason for them to prevent their ancestors
    to do direct_complete if they can support it.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 02812bcabcac..93ed14cc2252 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -14,6 +14,8 @@
 #include <linux/acpi.h>
 #include <linux/pm_domain.h>
 
+#include "power.h"
+
 /**
  * dev_pm_get_subsys_data - Create or refcount power.subsys_data for device.
  * @dev: Device to handle.
@@ -147,5 +149,6 @@ void dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd)
 	WARN(device_is_bound(dev),
 	     "PM domains can only be changed for unbound devices\n");
 	dev->pm_domain = pd;
+	device_pm_check_callbacks(dev);
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_set);

commit 989561de9b5112999475b406557d9c7e9e59c041
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:13 2016 +0100

    PM / Domains: add setter for dev.pm_domain
    
    Adds a function that sets the pointer to dev_pm_domain in struct device
    and that warns if the device has already finished probing. The reason
    why we want to enforce that is because in the general case that can
    cause problems and also that we can simplify code quite a bit if we can
    always assume that.
    
    This patch also changes all current code that directly sets the
    dev.pm_domain pointer.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index f48e33385b3e..02812bcabcac 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -128,3 +128,24 @@ void dev_pm_domain_detach(struct device *dev, bool power_off)
 		dev->pm_domain->detach(dev, power_off);
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_detach);
+
+/**
+ * dev_pm_domain_set - Set PM domain of a device.
+ * @dev: Device whose PM domain is to be set.
+ * @pd: PM domain to be set, or NULL.
+ *
+ * Sets the PM domain the device belongs to. The PM domain of a device needs
+ * to be set before its probe finishes (it's bound to a driver).
+ *
+ * This function must be called with the device lock held.
+ */
+void dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd)
+{
+	if (dev->pm_domain == pd)
+		return;
+
+	WARN(device_is_bound(dev),
+	     "PM domains can only be changed for unbound devices\n");
+	dev->pm_domain = pd;
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_set);

commit 4295733eee4e69eda432d95765b7762dc6013271
Author: Manuel Pégourié-Gonnard <mpg@elzevir.fr>
Date:   Tue Dec 29 11:03:21 2015 +0100

    PM / core: fix typo in documentation
    
    The documentation for detach() said attach.
    
    Signed-off-by: Manuel Pégourié-Gonnard <mpg@elzevir.fr>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index f32b802b98f4..f48e33385b3e 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -112,7 +112,7 @@ EXPORT_SYMBOL_GPL(dev_pm_domain_attach);
 
 /**
  * dev_pm_domain_detach - Detach a device from its PM domain.
- * @dev: Device to attach.
+ * @dev: Device to detach.
  * @power_off: Used to indicate whether we should power off the device.
  *
  * This functions will reverse the actions from dev_pm_domain_attach() and thus

commit 1e95e3b2da424db68d0a465273f1901a990c6277
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jan 29 18:39:05 2015 +0100

    PM: Convert dev_pm_put_subsys_data() into a void function
    
    Clients using the dev_pm_put_subsys_data() API isn't interested of a
    return value. They care only of decreasing a reference to the device's
    pm_subsys_data. So, let's convert the API to a void function, which
    anyway seems like reasonable thing to do.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index a1ee51d43da1..f32b802b98f4 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -56,13 +56,11 @@ EXPORT_SYMBOL_GPL(dev_pm_get_subsys_data);
  * @dev: Device to handle.
  *
  * If the reference counter of power.subsys_data is zero after dropping the
- * reference, power.subsys_data is removed.  Return 1 if that happens or 0
- * otherwise.
+ * reference, power.subsys_data is removed.
  */
-int dev_pm_put_subsys_data(struct device *dev)
+void dev_pm_put_subsys_data(struct device *dev)
 {
 	struct pm_subsys_data *psd;
-	int ret = 1;
 
 	spin_lock_irq(&dev->power.lock);
 
@@ -70,18 +68,14 @@ int dev_pm_put_subsys_data(struct device *dev)
 	if (!psd)
 		goto out;
 
-	if (--psd->refcount == 0) {
+	if (--psd->refcount == 0)
 		dev->power.subsys_data = NULL;
-	} else {
+	else
 		psd = NULL;
-		ret = 0;
-	}
 
  out:
 	spin_unlock_irq(&dev->power.lock);
 	kfree(psd);
-
-	return ret;
 }
 EXPORT_SYMBOL_GPL(dev_pm_put_subsys_data);
 

commit 766bb53c015bcc28dbd5ceb7c004581af7ab51b2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jan 29 18:39:04 2015 +0100

    PM: Update function header for dev_pm_get_subsys_data()
    
    The commit "PM: Make dev_pm_get_subsys_data() always return 0 on success"
    changed the return value from dev_pm_get_subsys_data(). Let's update the
    comment in the function header to reflect this change as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index b0f138806bbc..a1ee51d43da1 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -19,8 +19,8 @@
  * @dev: Device to handle.
  *
  * If power.subsys_data is NULL, point it to a new object, otherwise increment
- * its reference counter.  Return 1 if a new object has been created, otherwise
- * return 0 or error code.
+ * its reference counter.  Return 0 if new object has been created or refcount
+ * increased, otherwise negative error code.
  */
 int dev_pm_get_subsys_data(struct device *dev)
 {

commit 46420dd73b800f87a19af13af5883855cf38cb08
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:37 2014 +0200

    PM / Domains: Add APIs to attach/detach a PM domain for a device
    
    To maintain scalability let's add common methods to attach and detach
    a PM domain for a device, dev_pm_domain_attach|detach().
    
    Typically dev_pm_domain_attach() shall be invoked from subsystem level
    code at the probe phase to try to attach a device to its PM domain.
    The reversed actions may be done a the remove phase and then by
    invoking dev_pm_domain_detach().
    
    When attachment succeeds, the attach function should assign its
    corresponding detach function to a new ->detach() callback added in the
    struct dev_pm_domain.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index df2e5eeaeb05..b0f138806bbc 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -11,6 +11,8 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/pm_clock.h>
+#include <linux/acpi.h>
+#include <linux/pm_domain.h>
 
 /**
  * dev_pm_get_subsys_data - Create or refcount power.subsys_data for device.
@@ -82,3 +84,53 @@ int dev_pm_put_subsys_data(struct device *dev)
 	return ret;
 }
 EXPORT_SYMBOL_GPL(dev_pm_put_subsys_data);
+
+/**
+ * dev_pm_domain_attach - Attach a device to its PM domain.
+ * @dev: Device to attach.
+ * @power_on: Used to indicate whether we should power on the device.
+ *
+ * The @dev may only be attached to a single PM domain. By iterating through
+ * the available alternatives we try to find a valid PM domain for the device.
+ * As attachment succeeds, the ->detach() callback in the struct dev_pm_domain
+ * should be assigned by the corresponding attach function.
+ *
+ * This function should typically be invoked from subsystem level code during
+ * the probe phase. Especially for those that holds devices which requires
+ * power management through PM domains.
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ *
+ * Returns 0 on successfully attached PM domain or negative error code.
+ */
+int dev_pm_domain_attach(struct device *dev, bool power_on)
+{
+	int ret;
+
+	ret = acpi_dev_pm_attach(dev, power_on);
+	if (ret)
+		ret = genpd_dev_pm_attach(dev);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_attach);
+
+/**
+ * dev_pm_domain_detach - Detach a device from its PM domain.
+ * @dev: Device to attach.
+ * @power_off: Used to indicate whether we should power off the device.
+ *
+ * This functions will reverse the actions from dev_pm_domain_attach() and thus
+ * try to detach the @dev from its PM domain. Typically it should be invoked
+ * from subsystem level code during the remove phase.
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ */
+void dev_pm_domain_detach(struct device *dev, bool power_off)
+{
+	if (dev->pm_domain && dev->pm_domain->detach)
+		dev->pm_domain->detach(dev, power_off);
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_detach);

commit 4272b9611c30f99f51590085998129480f2fe45e
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:23:10 2014 -0500

    drivers/base: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: Len Brown <len.brown@intel.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 5da914041305..df2e5eeaeb05 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -6,7 +6,6 @@
  * This file is released under the GPLv2.
  */
 
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/export.h>

commit d5e1670afe0c886d6dd92afb7a1f085f88294dc8
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Wed May 8 01:14:32 2013 +0200

    PM: Avoid calling kfree() under spinlock in dev_pm_put_subsys_data()
    
    Fix dev_pm_put_subsys_data() so that it doesn't call kfree() under
    a spinlock and make it return 1 whenever it leaves NULL
    power.subsys_data (regardless of the reason).
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Reviewed-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 39c32529b833..5da914041305 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -61,24 +61,24 @@ EXPORT_SYMBOL_GPL(dev_pm_get_subsys_data);
 int dev_pm_put_subsys_data(struct device *dev)
 {
 	struct pm_subsys_data *psd;
-	int ret = 0;
+	int ret = 1;
 
 	spin_lock_irq(&dev->power.lock);
 
 	psd = dev_to_psd(dev);
-	if (!psd) {
-		ret = -EINVAL;
+	if (!psd)
 		goto out;
-	}
 
 	if (--psd->refcount == 0) {
 		dev->power.subsys_data = NULL;
-		kfree(psd);
-		ret = 1;
+	} else {
+		psd = NULL;
+		ret = 0;
 	}
 
  out:
 	spin_unlock_irq(&dev->power.lock);
+	kfree(psd);
 
 	return ret;
 }

commit 77254950bb174d637cd88d1a74e137ecf3185a65
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Aug 7 13:50:14 2012 +0200

    PM: Make dev_pm_get_subsys_data() always return 0 on success
    
    Commits 1d5fcfec22 (PM / Domains: Add device domain data reference
    counter) and 62d4490294 (PM / Domains: Allow device callbacks to be
    added at any time) added checks for the return value of
    dev_pm_get_subsys_data(), but those checks were incorrect, because
    that function returned 1 on success in some cases.
    
    Since all of the existing users of dev_pm_get_subsys_data() don't use
    the positive value returned by it on success, change its definition
    so that it always returns 0 when successful.
    
    Reported-by: Heiko Stübner <heiko@sntech.de>
    Reported-by: Tushar Behera <tushar.behera@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index a14085cc613f..39c32529b833 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -24,7 +24,6 @@
 int dev_pm_get_subsys_data(struct device *dev)
 {
 	struct pm_subsys_data *psd;
-	int ret = 0;
 
 	psd = kzalloc(sizeof(*psd), GFP_KERNEL);
 	if (!psd)
@@ -40,7 +39,6 @@ int dev_pm_get_subsys_data(struct device *dev)
 		dev->power.subsys_data = psd;
 		pm_clk_init(dev);
 		psd = NULL;
-		ret = 1;
 	}
 
 	spin_unlock_irq(&dev->power.lock);
@@ -48,7 +46,7 @@ int dev_pm_get_subsys_data(struct device *dev)
 	/* kfree() verifies that its argument is nonzero. */
 	kfree(psd);
 
-	return ret;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(dev_pm_get_subsys_data);
 

commit 51990e825431089747f8896244b5c17d3a6423f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jan 22 11:23:42 2012 -0500

    device.h: cleanup users outside of linux/include (C files)
    
    For files that are actively using linux/device.h, make sure
    that they call it out.  This will allow us to clean up some
    of the implicit uses of linux/device.h within include/*
    without introducing build regressions.
    
    Yes, this was created by "cheating" -- i.e. the headers were
    cleaned up, and then the fallout was found and fixed, and then
    the two commits were reordered.  This ensures we don't introduce
    build regressions into the git history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 4af7c1cbf909..a14085cc613f 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -8,6 +8,7 @@
 
 #include <linux/init.h>
 #include <linux/kernel.h>
+#include <linux/device.h>
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/pm_clock.h>

commit aaf195444be47aa3d3776825b3b384a61f40dca4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Sep 28 18:23:03 2011 -0400

    drivers/base: change module.h -> export.h in power/common.c
    
    This file isn't using full modular functionality, and hence
    can be "downgraded" to just using export.h
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 29820c396182..4af7c1cbf909 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -8,7 +8,7 @@
 
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/pm_clock.h>
 

commit b5e8d269d814763d597ccc0108d1fa6639ad35a1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:34:19 2011 +0200

    PM: Move clock-related definitions and headers to separate file
    
    Since the PM clock management code in drivers/base/power/clock_ops.c
    is used for both runtime PM and system suspend/hibernation, the
    definitions of data structures and headers related to it should not
    be located in include/linux/pm_rumtime.h.  Move them to a separate
    header file.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index d398cf029b32..29820c396182 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -10,8 +10,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/pm_runtime.h>
+#include <linux/pm_clock.h>
 
 /**
  * dev_pm_get_subsys_data - Create or refcount power.subsys_data for device.

commit ef27bed1870dbd5fd363ff5ec51eebd5a695e277
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:34:01 2011 +0200

    PM: Reference counting of power.subsys_data
    
    Since the power.subsys_data device field will be used by multiple
    filesystems, introduce a reference counting mechanism for it to avoid
    freeing it prematurely or changing its value at a wrong time.
    
    Make the PM clocks management code that currently is the only user of
    power.subsys_data use the new reference counting.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
new file mode 100644
index 000000000000..d398cf029b32
--- /dev/null
+++ b/drivers/base/power/common.c
@@ -0,0 +1,87 @@
+/*
+ * drivers/base/power/common.c - Common device power management code.
+ *
+ * Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
+ *
+ * This file is released under the GPLv2.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/pm_runtime.h>
+
+/**
+ * dev_pm_get_subsys_data - Create or refcount power.subsys_data for device.
+ * @dev: Device to handle.
+ *
+ * If power.subsys_data is NULL, point it to a new object, otherwise increment
+ * its reference counter.  Return 1 if a new object has been created, otherwise
+ * return 0 or error code.
+ */
+int dev_pm_get_subsys_data(struct device *dev)
+{
+	struct pm_subsys_data *psd;
+	int ret = 0;
+
+	psd = kzalloc(sizeof(*psd), GFP_KERNEL);
+	if (!psd)
+		return -ENOMEM;
+
+	spin_lock_irq(&dev->power.lock);
+
+	if (dev->power.subsys_data) {
+		dev->power.subsys_data->refcount++;
+	} else {
+		spin_lock_init(&psd->lock);
+		psd->refcount = 1;
+		dev->power.subsys_data = psd;
+		pm_clk_init(dev);
+		psd = NULL;
+		ret = 1;
+	}
+
+	spin_unlock_irq(&dev->power.lock);
+
+	/* kfree() verifies that its argument is nonzero. */
+	kfree(psd);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(dev_pm_get_subsys_data);
+
+/**
+ * dev_pm_put_subsys_data - Drop reference to power.subsys_data.
+ * @dev: Device to handle.
+ *
+ * If the reference counter of power.subsys_data is zero after dropping the
+ * reference, power.subsys_data is removed.  Return 1 if that happens or 0
+ * otherwise.
+ */
+int dev_pm_put_subsys_data(struct device *dev)
+{
+	struct pm_subsys_data *psd;
+	int ret = 0;
+
+	spin_lock_irq(&dev->power.lock);
+
+	psd = dev_to_psd(dev);
+	if (!psd) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (--psd->refcount == 0) {
+		dev->power.subsys_data = NULL;
+		kfree(psd);
+		ret = 1;
+	}
+
+ out:
+	spin_unlock_irq(&dev->power.lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(dev_pm_put_subsys_data);
