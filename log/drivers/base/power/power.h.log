commit 3b52fc5d7876a312e6a964d7e626ba05ab1ea6b2
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Thu Feb 27 04:37:16 2020 +0100

    drivers/base/power: add dpm_sysfs_change_owner()
    
    Add a helper to change the owner of a device's power entries. This
    needs to happen when the ownership of a device is changed, e.g. when
    moving network devices between network namespaces.
    This function will be used to correctly account for ownership changes,
    e.g. when moving network devices between network namespaces.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 444f5c169a0b..54292cdd7808 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -74,6 +74,7 @@ extern int pm_qos_sysfs_add_flags(struct device *dev);
 extern void pm_qos_sysfs_remove_flags(struct device *dev);
 extern int pm_qos_sysfs_add_latency_tolerance(struct device *dev);
 extern void pm_qos_sysfs_remove_latency_tolerance(struct device *dev);
+extern int dpm_sysfs_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);
 
 #else /* CONFIG_PM */
 
@@ -88,6 +89,8 @@ static inline void pm_runtime_remove(struct device *dev) {}
 
 static inline int dpm_sysfs_add(struct device *dev) { return 0; }
 static inline void dpm_sysfs_remove(struct device *dev) {}
+static inline int dpm_sysfs_change_owner(struct device *dev, kuid_t kuid,
+					 kgid_t kgid) { return 0; }
 
 #endif
 

commit ea0d11c9dd95d685fe94299847446e6ad9594c39
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 16 16:16:27 2019 +0200

    PM / core: Clean up some function headers in power.h
    
    The power.h is a bit messy due to the various existing CONFIG_PM* Kconfig
    combinations. However the final section for wakeup_source_sysfs*() can be
    moved inside one of the existing sections rather than adding yet another
    one, so let's do that to clean up the code a little bit.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 39a06a0cfdaa..444f5c169a0b 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -117,6 +117,13 @@ static inline bool device_pm_initialized(struct device *dev)
 	return dev->power.in_dpm_list;
 }
 
+/* drivers/base/power/wakeup_stats.c */
+extern int wakeup_source_sysfs_add(struct device *parent,
+				   struct wakeup_source *ws);
+extern void wakeup_source_sysfs_remove(struct wakeup_source *ws);
+
+extern int pm_wakeup_source_sysfs_add(struct device *parent);
+
 #else /* !CONFIG_PM_SLEEP */
 
 static inline void device_pm_sleep_init(struct device *dev) {}
@@ -141,6 +148,11 @@ static inline bool device_pm_initialized(struct device *dev)
 	return device_is_registered(dev);
 }
 
+static inline int pm_wakeup_source_sysfs_add(struct device *parent)
+{
+	return 0;
+}
+
 #endif /* !CONFIG_PM_SLEEP */
 
 static inline void device_pm_init(struct device *dev)
@@ -149,21 +161,3 @@ static inline void device_pm_init(struct device *dev)
 	device_pm_sleep_init(dev);
 	pm_runtime_init(dev);
 }
-
-#ifdef CONFIG_PM_SLEEP
-
-/* drivers/base/power/wakeup_stats.c */
-extern int wakeup_source_sysfs_add(struct device *parent,
-				   struct wakeup_source *ws);
-extern void wakeup_source_sysfs_remove(struct wakeup_source *ws);
-
-extern int pm_wakeup_source_sysfs_add(struct device *parent);
-
-#else /* !CONFIG_PM_SLEEP */
-
-static inline int pm_wakeup_source_sysfs_add(struct device *parent)
-{
-	return 0;
-}
-
-#endif /* CONFIG_PM_SLEEP */

commit 2ca3d1ecb8c432ee212d80fa7615cdd5d1df62e3
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Mon Aug 19 15:41:57 2019 -0700

    PM / wakeup: Register wakeup class kobj after device is added
    
    The device_set_wakeup_enable() function can be called on a device that
    hasn't been registered with device_add() yet. This allows the device to
    be in a state where wakeup is enabled for it but the device isn't
    published to userspace in sysfs yet.
    
    After commit c8377adfa781 ("PM / wakeup: Show wakeup sources stats in
    sysfs"), calling device_set_wakeup_enable() will fail for a device that
    hasn't been registered with the driver core via device_add(). This is
    because we try to create sysfs entries for the device and associate a
    wakeup class kobject with it before the device has been registered.
    Let's follow a similar approach that device_set_wakeup_capable() takes
    here and register the wakeup class either from
    device_set_wakeup_enable() when the device is already registered, or
    from dpm_sysfs_add() when the device is being registered with the driver
    core via device_add().
    
    Fixes: c8377adfa781 ("PM / wakeup: Show wakeup sources stats in sysfs")
    Reported-by: Qian Cai <cai@lca.pw>
    Reviewed-by: Tri Vo <trong@android.com>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 57b1d1d88c8e..39a06a0cfdaa 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -157,4 +157,13 @@ extern int wakeup_source_sysfs_add(struct device *parent,
 				   struct wakeup_source *ws);
 extern void wakeup_source_sysfs_remove(struct wakeup_source *ws);
 
+extern int pm_wakeup_source_sysfs_add(struct device *parent);
+
+#else /* !CONFIG_PM_SLEEP */
+
+static inline int pm_wakeup_source_sysfs_add(struct device *parent)
+{
+	return 0;
+}
+
 #endif /* CONFIG_PM_SLEEP */

commit c8377adfa78103be5380200eb9dab764d7ca890e
Author: Tri Vo <trong@android.com>
Date:   Tue Aug 6 18:48:46 2019 -0700

    PM / wakeup: Show wakeup sources stats in sysfs
    
    Add an ID and a device pointer to 'struct wakeup_source'. Use them to to
    expose wakeup sources statistics in sysfs under
    /sys/class/wakeup/wakeup<ID>/*.
    
    Co-developed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Co-developed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Tri Vo <trong@android.com>
    Tested-by: Kalesh Singh <kaleshsingh@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index ec33fbdb919b..57b1d1d88c8e 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -149,3 +149,12 @@ static inline void device_pm_init(struct device *dev)
 	device_pm_sleep_init(dev);
 	pm_runtime_init(dev);
 }
+
+#ifdef CONFIG_PM_SLEEP
+
+/* drivers/base/power/wakeup_stats.c */
+extern int wakeup_source_sysfs_add(struct device *parent,
+				   struct wakeup_source *ws);
+extern void wakeup_source_sysfs_remove(struct wakeup_source *ws);
+
+#endif /* CONFIG_PM_SLEEP */

commit fdc56c073270af2f4d223c96a5fff3048352fc03
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 5 13:55:26 2019 +0100

    PM-runtime: Consolidate code to get active/suspended time
    
    In a step to consolidate the code for fetching the PM-runtime
    active/suspended time for a device, add a common function for that
    and make the existing pm_runtime_suspended_time() call it.
    
    Also add a corresponding pm_runtime_active_time() calling the new
    common function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    [ rjw: Changelog, function rename ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index c511def48b48..ec33fbdb919b 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -21,6 +21,7 @@ static inline void pm_runtime_early_init(struct device *dev)
 extern void pm_runtime_init(struct device *dev);
 extern void pm_runtime_reinit(struct device *dev);
 extern void pm_runtime_remove(struct device *dev);
+extern u64 pm_runtime_active_time(struct device *dev);
 
 #define WAKE_IRQ_DEDICATED_ALLOCATED	BIT(0)
 #define WAKE_IRQ_DEDICATED_MANAGED	BIT(1)

commit 91eb88b027ecec00110f3c496899d389d2ab9850
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 9 10:46:36 2018 +0200

    PM / core: Drop unused internal inline functions for sysfs
    
    The inline versions of rpm_sysfs_remove() and wakeup_sysfs_add|remove(),
    are not being used while CONFIG_PM is unset, hence let's drop them.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 78bbb5da70af..c511def48b48 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -87,9 +87,6 @@ static inline void pm_runtime_remove(struct device *dev) {}
 
 static inline int dpm_sysfs_add(struct device *dev) { return 0; }
 static inline void dpm_sysfs_remove(struct device *dev) {}
-static inline void rpm_sysfs_remove(struct device *dev) {}
-static inline int wakeup_sysfs_add(struct device *dev) { return 0; }
-static inline void wakeup_sysfs_remove(struct device *dev) {}
 
 #endif
 

commit b8e7ca205f32cf0a6a3ea56d807c938527f55269
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 9 10:46:35 2018 +0200

    PM / core: Drop unused internal functions for pm_qos sysfs
    
    The functions pm_qos_sysfs_add|remove() are available as inline functions
    only while CONFIG_PM is unset, but are not being used. Likely they are a
    leftover from an earlier cleanup in the past, anyway let's drop them.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index be409103fb62..78bbb5da70af 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -90,8 +90,6 @@ static inline void dpm_sysfs_remove(struct device *dev) {}
 static inline void rpm_sysfs_remove(struct device *dev) {}
 static inline int wakeup_sysfs_add(struct device *dev) { return 0; }
 static inline void wakeup_sysfs_remove(struct device *dev) {}
-static inline int pm_qos_sysfs_add(struct device *dev) { return 0; }
-static inline void pm_qos_sysfs_remove(struct device *dev) {}
 
 #endif
 

commit ff5f078e20dc67811b94a3bce5dee23f668068d1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 9 10:46:34 2018 +0200

    PM / core: Drop unused internal inline functions for wakeirqs
    
    The inline versions of dev_pm_arm|disarm_wake_irq() and
    dev_pm_enable|disable_wake_irq_check() are not being used while CONFIG_PM
    is unset, hence let's drop them.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index f38d178ca395..be409103fb62 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -93,23 +93,6 @@ static inline void wakeup_sysfs_remove(struct device *dev) {}
 static inline int pm_qos_sysfs_add(struct device *dev) { return 0; }
 static inline void pm_qos_sysfs_remove(struct device *dev) {}
 
-static inline void dev_pm_arm_wake_irq(struct wake_irq *wirq)
-{
-}
-
-static inline void dev_pm_disarm_wake_irq(struct wake_irq *wirq)
-{
-}
-
-static inline void dev_pm_enable_wake_irq_check(struct device *dev,
-						bool can_change_status)
-{
-}
-
-static inline void dev_pm_disable_wake_irq_check(struct device *dev)
-{
-}
-
 #endif
 
 #ifdef CONFIG_PM_SLEEP

commit abcab87587cc4d04647eb9aaa11b26eacb3f0c13
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 9 10:46:33 2018 +0200

    PM / core: Drop internal unused inline functions for wakeups
    
    The inline versions of device_wakeup_arm|disarm_wake_irqs(), which are
    available while when CONFIG_PM is set and CONFIG_PM_SLEEP unset, are not
    being used, hence let's drop them.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 86e67e70b509..f38d178ca395 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -56,14 +56,6 @@ static inline void device_wakeup_detach_irq(struct device *dev)
 {
 }
 
-static inline void device_wakeup_arm_wake_irqs(void)
-{
-}
-
-static inline void device_wakeup_disarm_wake_irqs(void)
-{
-}
-
 #endif /* CONFIG_PM_SLEEP */
 
 /*

commit da997b22c40473b7db60bde6ea188d35565d10c8
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Feb 8 08:30:10 2018 -0800

    PM / wakeirq: Add wakeup name to dedicated wake irqs
    
    This makes it easy to grep :wakeup /proc/interrupts.
    
    Suggested-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 21244c53e377..86e67e70b509 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -31,6 +31,7 @@ struct wake_irq {
 	struct device *dev;
 	unsigned int status;
 	int irq;
+	const char *name;
 };
 
 extern void dev_pm_arm_wake_irq(struct wake_irq *wirq);

commit 7bf4e594c28afc67bc120a380ca774e43ca496d8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 5 02:18:42 2018 +0100

    PM / wakeup: Do not fail dev_pm_attach_wake_irq() unnecessarily
    
    Returning an error code from dev_pm_attach_wake_irq() if
    device_wakeup_attach_irq() called by it returns an error is
    pointless, because the wakeup source used by it may be deleted
    by user space via sysfs at any time and in particular right after
    dev_pm_attach_wake_irq() has returned.  Moreover, it requires
    the callers of dev_pm_attach_wake_irq() to create that wakeup
    source via device_wakeup_enable() upfront, but that obviously is
    racy with respect to the sysfs-based manipulations of it.
    
    To avoid the race, modify device_wakeup_attach_irq() to check
    that the wakeup source it is going to use is there (and return
    early otherwise), make it void (as it cannot fail after that
    change) and make dev_pm_attach_wake_irq() simply call it for
    the device unconditionally.
    
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 7beee75399d4..21244c53e377 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -41,20 +41,15 @@ extern void dev_pm_disable_wake_irq_check(struct device *dev);
 
 #ifdef CONFIG_PM_SLEEP
 
-extern int device_wakeup_attach_irq(struct device *dev,
-				    struct wake_irq *wakeirq);
+extern void device_wakeup_attach_irq(struct device *dev, struct wake_irq *wakeirq);
 extern void device_wakeup_detach_irq(struct device *dev);
 extern void device_wakeup_arm_wake_irqs(void);
 extern void device_wakeup_disarm_wake_irqs(void);
 
 #else
 
-static inline int
-device_wakeup_attach_irq(struct device *dev,
-			 struct wake_irq *wakeirq)
-{
-	return 0;
-}
+static inline void device_wakeup_attach_irq(struct device *dev,
+					    struct wake_irq *wakeirq) {}
 
 static inline void device_wakeup_detach_irq(struct device *dev)
 {

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index a46e97e515c5..7beee75399d4 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/pm_qos.h>
 
 static inline void device_pm_init_common(struct device *dev)

commit 098c30557a9a19827240aaadc137e4668157dc6b
Merge: 72cca7baf4fb 5d47ec02c37e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 11:42:18 2016 -0800

    Merge tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here's the new driver core patches for 4.10-rc1.
    
      Big thing here is the nice addition of "functional dependencies" to
      the driver core. The idea has been talked about for a very long time,
      great job to Rafael for stepping up and implementing it. It's been
      tested for longer than the 4.9-rc1 date, we held off on merging it
      earlier in order to feel more comfortable about it.
    
      Other than that, it's just a handful of small other patches, some good
      cleanups to the mess that is the firmware class code, and we have a
      test driver for the deferred probe logic.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (30 commits)
      firmware: Correct handling of fw_state_wait() return value
      driver core: Silence device links sphinx warning
      firmware: remove warning at documentation generation time
      drivers: base: dma-mapping: Fix typo in dmam_alloc_non_coherent comments
      driver core: test_async: fix up typo found by 0-day
      firmware: move fw_state_is_done() into UHM section
      firmware: do not use fw_lock for fw_state protection
      firmware: drop bit ops in favor of simple state machine
      firmware: refactor loading status
      firmware: fix usermode helper fallback loading
      driver core: firmware_class: convert to use class_groups
      driver core: devcoredump: convert to use class_groups
      driver core: class: add class_groups support
      kernfs: Declare two local data structures static
      driver-core: fix platform_no_drv_owner.cocci warnings
      drivers/base/memory.c: Remove unused 'first_page' variable
      driver core: add CLASS_ATTR_WO()
      drivers: base: cacheinfo: support DT overrides for cache properties
      drivers: base: cacheinfo: add pr_fmt logging
      drivers: base: cacheinfo: fix boot error message when acpi is enabled
      ...

commit bed570307ed78f21b77cb04a1df781dee4a8f05a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 5 16:38:16 2016 -0800

    PM / wakeirq: Fix dedicated wakeirq for drivers not using autosuspend
    
    I noticed some wakeirq flakeyness with consumer drivers not using
    autosuspend. For drivers not using autosuspend, the wakeirq may never
    get unmasked in rpm_suspend() because of irq desc->depth.
    
    We are configuring dedicated wakeirqs to start with IRQ_NOAUTOEN as we
    naturally don't want them running until rpm_suspend() is called.
    
    However, when a consumer driver initially calls pm_runtime_get(), we
    now wrongly start with disable_irq_nosync() call on the dedicated
    wakeirq that is disabled to start with.
    
    This causes desc->depth to toggle between 1 and 2 instead of the usual
    0 and 1. This can prevent enable_irq() from unmasking the wakeirq as
    that only happens at desc->depth 1.
    
    This does not necessarily show up with drivers using autosuspend as
    there is time for disable_irq_nosync() before rpm_suspend() gets called
    after the autosuspend timeout.
    
    Let's fix the issue by adding wirq->status that lazily gets set on
    the first rpm_suspend(). We also need PM runtime core private functions
    for dev_pm_enable_wake_irq_check() and dev_pm_disable_wake_irq_check()
    so we can enable the dedicated wakeirq on the first rpm_suspend().
    
    While at it, let's also fix the comments for dev_pm_enable_wake_irq()
    and dev_pm_disable_wake_irq(). Those can still be used by the consumer
    drivers as needed because the IRQ core manages the interrupt usecount
    for us.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 50e30e7b059d..a84332aefc2d 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -21,14 +21,22 @@ extern void pm_runtime_init(struct device *dev);
 extern void pm_runtime_reinit(struct device *dev);
 extern void pm_runtime_remove(struct device *dev);
 
+#define WAKE_IRQ_DEDICATED_ALLOCATED	BIT(0)
+#define WAKE_IRQ_DEDICATED_MANAGED	BIT(1)
+#define WAKE_IRQ_DEDICATED_MASK		(WAKE_IRQ_DEDICATED_ALLOCATED | \
+					 WAKE_IRQ_DEDICATED_MANAGED)
+
 struct wake_irq {
 	struct device *dev;
+	unsigned int status;
 	int irq;
-	bool dedicated_irq:1;
 };
 
 extern void dev_pm_arm_wake_irq(struct wake_irq *wirq);
 extern void dev_pm_disarm_wake_irq(struct wake_irq *wirq);
+extern void dev_pm_enable_wake_irq_check(struct device *dev,
+					 bool can_change_status);
+extern void dev_pm_disable_wake_irq_check(struct device *dev);
 
 #ifdef CONFIG_PM_SLEEP
 
@@ -104,6 +112,15 @@ static inline void dev_pm_disarm_wake_irq(struct wake_irq *wirq)
 {
 }
 
+static inline void dev_pm_enable_wake_irq_check(struct device *dev,
+						bool can_change_status)
+{
+}
+
+static inline void dev_pm_disable_wake_irq_check(struct device *dev)
+{
+}
+
 #endif
 
 #ifdef CONFIG_PM_SLEEP

commit 9ed9895370aedd6032af2a9181c62c394d08223b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:16 2016 +0100

    driver core: Functional dependencies tracking support
    
    Currently, there is a problem with taking functional dependencies
    between devices into account.
    
    What I mean by a "functional dependency" is when the driver of device
    B needs device A to be functional and (generally) its driver to be
    present in order to work properly.  This has certain consequences
    for power management (suspend/resume and runtime PM ordering) and
    shutdown ordering of these devices.  In general, it also implies that
    the driver of A needs to be working for B to be probed successfully
    and it cannot be unbound from the device before the B's driver.
    
    Support for representing those functional dependencies between
    devices is added here to allow the driver core to track them and act
    on them in certain cases where applicable.
    
    The argument for doing that in the driver core is that there are
    quite a few distinct use cases involving device dependencies, they
    are relatively hard to get right in a driver (if one wants to
    address all of them properly) and it only gets worse if multiplied
    by the number of drivers potentially needing to do it.  Morever, at
    least one case (asynchronous system suspend/resume) cannot be handled
    in a single driver at all, because it requires the driver of A to
    wait for B to suspend (during system suspend) and the driver of B to
    wait for A to resume (during system resume).
    
    For this reason, represent dependencies between devices as "links",
    with the help of struct device_link objects each containing pointers
    to the "linked" devices, a list node for each of them, status
    information, flags, and an RCU head for synchronization.
    
    Also add two new list heads, representing the lists of links to the
    devices that depend on the given one (consumers) and to the devices
    depended on by it (suppliers), and a "driver presence status" field
    (needed for figuring out initial states of device links) to struct
    device.
    
    The entire data structure consisting of all of the lists of link
    objects for all devices is protected by a mutex (for link object
    addition/removal and for list walks during device driver probing
    and removal) and by SRCU (for list walking in other case that will
    be introduced by subsequent change sets).  If CONFIG_SRCU is not
    selected, however, an rwsem is used for protecting the entire data
    structure.
    
    In addition, each link object has an internal status field whose
    value reflects whether or not drivers are bound to the devices
    pointed to by the link or probing/removal of their drivers is in
    progress etc.  That field is only modified under the device links
    mutex, but it may be read outside of it in some cases (introduced by
    subsequent change sets), so modifications of it are annotated with
    WRITE_ONCE().
    
    New links are added by calling device_link_add() which takes three
    arguments: pointers to the devices in question and flags.  In
    particular, if DL_FLAG_STATELESS is set in the flags, the link status
    is not to be taken into account for this link and the driver core
    will not manage it.  In turn, if DL_FLAG_AUTOREMOVE is set in the
    flags, the driver core will remove the link automatically when the
    consumer device driver unbinds from it.
    
    One of the actions carried out by device_link_add() is to reorder
    the lists used for device shutdown and system suspend/resume to
    put the consumer device along with all of its children and all of
    its consumers (and so on, recursively) to the ends of those lists
    in order to ensure the right ordering between all of the supplier
    and consumer devices.
    
    For this reason, it is not possible to create a link between two
    devices if the would-be supplier device already depends on the
    would-be consumer device as either a direct descendant of it or a
    consumer of one of its direct descendants or one of its consumers
    and so on.
    
    There are two types of link objects, persistent and non-persistent.
    The persistent ones stay around until one of the target devices is
    deleted, while the non-persistent ones are removed automatically when
    the consumer driver unbinds from its device (ie. they are assumed to
    be valid only as long as the consumer device has a driver bound to
    it).  Persistent links are created by default and non-persistent
    links are created when the DL_FLAG_AUTOREMOVE flag is passed
    to device_link_add().
    
    Both persistent and non-persistent device links can be deleted
    with an explicit call to device_link_del().
    
    Links created without the DL_FLAG_STATELESS flag set are managed
    by the driver core using a simple state machine.  There are 5 states
    each link can be in: DORMANT (unused), AVAILABLE (the supplier driver
    is present and functional), CONSUMER_PROBE (the consumer driver is
    probing), ACTIVE (both supplier and consumer drivers are present and
    functional), and SUPPLIER_UNBIND (the supplier driver is unbinding).
    The driver core updates the link state automatically depending on
    what happens to the linked devices and for each link state specific
    actions are taken in addition to that.
    
    For example, if the supplier driver unbinds from its device, the
    driver core will also unbind the drivers of all of its consumers
    automatically under the assumption that they cannot function
    properly without the supplier.  Analogously, the driver core will
    only allow the consumer driver to bind to its device if the
    supplier driver is present and functional (ie. the link is in
    the AVAILABLE state).  If that's not the case, it will rely on
    the existing deferred probing mechanism to wait for the supplier
    driver to become available.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 50e30e7b059d..0ba7842d665b 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -127,6 +127,11 @@ extern void device_pm_move_after(struct device *, struct device *);
 extern void device_pm_move_last(struct device *);
 extern void device_pm_check_callbacks(struct device *dev);
 
+static inline bool device_pm_initialized(struct device *dev)
+{
+	return dev->power.in_dpm_list;
+}
+
 #else /* !CONFIG_PM_SLEEP */
 
 static inline void device_pm_sleep_init(struct device *dev) {}
@@ -146,6 +151,11 @@ static inline void device_pm_move_last(struct device *dev) {}
 
 static inline void device_pm_check_callbacks(struct device *dev) {}
 
+static inline bool device_pm_initialized(struct device *dev)
+{
+	return device_is_registered(dev);
+}
+
 #endif /* !CONFIG_PM_SLEEP */
 
 static inline void device_pm_init(struct device *dev)

commit aa8e54b559479d0cb7eb632ba443b8cacd20cd4b
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:14 2016 +0100

    PM / sleep: Go direct_complete if driver has no callbacks
    
    If a suitable prepare callback cannot be found for a given device and
    its driver has no PM callbacks at all, assume that it can go direct to
    complete when the system goes to sleep.
    
    The reason for this is that there's lots of devices in a system that do
    no PM at all and there's no reason for them to prevent their ancestors
    to do direct_complete if they can support it.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 8b06193d4a5e..50e30e7b059d 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -125,6 +125,7 @@ extern void device_pm_remove(struct device *);
 extern void device_pm_move_before(struct device *, struct device *);
 extern void device_pm_move_after(struct device *, struct device *);
 extern void device_pm_move_last(struct device *);
+extern void device_pm_check_callbacks(struct device *dev);
 
 #else /* !CONFIG_PM_SLEEP */
 
@@ -143,6 +144,8 @@ static inline void device_pm_move_after(struct device *deva,
 					struct device *devb) {}
 static inline void device_pm_move_last(struct device *dev) {}
 
+static inline void device_pm_check_callbacks(struct device *dev) {}
+
 #endif /* !CONFIG_PM_SLEEP */
 
 static inline void device_pm_init(struct device *dev)

commit 5de85b9d57aba3ed2e04759e6db3b9e826dd0b06
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Nov 18 11:48:39 2015 +0100

    PM / runtime: Re-init runtime PM states at probe error and driver unbind
    
    There are two common expectations among several subsystems/drivers that
    deploys runtime PM support, but which isn't met by the driver core.
    
    Expectation 1)
    At ->probe() the subsystem/driver expects the runtime PM status of the
    device to be RPM_SUSPENDED, which is the initial status being assigned at
    device registration.
    
    This expectation is especially common among some of those subsystems/
    drivers that manages devices with an attached PM domain, as those requires
    the ->runtime_resume() callback at the PM domain level to be invoked
    during ->probe().
    
    Moreover these subsystems/drivers entirely relies on runtime PM resources
    being managed at the PM domain level, thus don't implement their own set
    of runtime PM callbacks.
    
    These are two scenarios that suffers from this unmet expectation.
    
    i) A failed ->probe() sequence requests probe deferral:
    
    ->probe()
      ...
      pm_runtime_enable()
      pm_runtime_get_sync()
      ...
    
    err:
      pm_runtime_put()
      pm_runtime_disable()
      ...
    
    As there are no guarantees that such sequence turns the runtime PM status
    of the device into RPM_SUSPENDED, the re-trying ->probe() may start with
    the status in RPM_ACTIVE.
    
    In such case the runtime PM core won't invoke the ->runtime_resume()
    callback because of a pm_runtime_get_sync(), as it considers the device to
    be already runtime resumed.
    
    ii) A driver re-bind sequence:
    
    At driver unbind, the subsystem/driver's >remove() callback invokes a
    sequence of runtime PM APIs, to undo actions during ->probe() and to put
    the device into low power state.
    
    ->remove()
      ...
      pm_runtime_put()
      pm_runtime_disable()
      ...
    
    Similar as in the failing ->probe() case, this sequence don't guarantee
    the runtime PM status of the device to turn into RPM_SUSPENDED.
    
    Trying to re-bind the driver thus causes the same issue as when re-trying
    ->probe(), in the probe deferral scenario.
    
    Expectation 2)
    Drivers that invokes the pm_runtime_irq_safe() API during ->probe(),
    triggers the runtime PM core to increase the usage count for the device's
    parent and permanently make it runtime resumed.
    
    The usage count is only dropped at device removal, which also allows it to
    be runtime suspended again.
    
    A re-trying ->probe() repeats the call to pm_runtime_irq_safe() and thus
    once more triggers the usage count of the device's parent to be increased.
    
    This leads to not only an imbalance issue of the usage count of the
    device's parent, but also to keep it runtime resumed permanently even if
    ->probe() fails.
    
    To address these issues, let's change the policy of the driver core to
    meet these expectations. More precisely, at ->probe() failures and driver
    unbind, restore the initial states of runtime PM.
    
    Although to still allow subsystem's to control PM for devices that doesn't
    ->probe() successfully, don't restore the initial states unless runtime PM
    is disabled.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 998fa6b23084..8b06193d4a5e 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -18,6 +18,7 @@ static inline void pm_runtime_early_init(struct device *dev)
 }
 
 extern void pm_runtime_init(struct device *dev);
+extern void pm_runtime_reinit(struct device *dev);
 extern void pm_runtime_remove(struct device *dev);
 
 struct wake_irq {
@@ -84,6 +85,7 @@ static inline void pm_runtime_early_init(struct device *dev)
 }
 
 static inline void pm_runtime_init(struct device *dev) {}
+static inline void pm_runtime_reinit(struct device *dev) {}
 static inline void pm_runtime_remove(struct device *dev) {}
 
 static inline int dpm_sysfs_add(struct device *dev) { return 0; }

commit 13b2c4a0c3b1cd37ee6bcfbb5b6e2b94e9a75364
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Jul 27 18:03:56 2015 +0300

    PM / QoS: Make it possible to expose device latency tolerance to userspace
    
    Typically when a device is created the bus core it belongs to (for example
    PCI) does not know if the device supports things like latency tolerance.
    This is left to the driver that binds to the device in question. However,
    at that time the device has already been created and there is no way to set
    its dev->power.set_latency_tolerance anymore.
    
    So follow what has been done for other PM QoS attributes as well and allow
    drivers to expose and hide latency tolerance from userspace, if the device
    supports it.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index f1a5d95e7b20..998fa6b23084 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -73,6 +73,8 @@ extern int pm_qos_sysfs_add_resume_latency(struct device *dev);
 extern void pm_qos_sysfs_remove_resume_latency(struct device *dev);
 extern int pm_qos_sysfs_add_flags(struct device *dev);
 extern void pm_qos_sysfs_remove_flags(struct device *dev);
+extern int pm_qos_sysfs_add_latency_tolerance(struct device *dev);
+extern void pm_qos_sysfs_remove_latency_tolerance(struct device *dev);
 
 #else /* CONFIG_PM */
 

commit 4990d4fe327b9d9a7a3be7103a82699406fdde69
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 18 15:40:29 2015 -0700

    PM / Wakeirq: Add automated device wake IRQ handling
    
    Turns out we can automate the handling for the device_may_wakeup()
    quite a bit by using the kernel wakeup source list as suggested
    by Rafael J. Wysocki <rjw@rjwysocki.net>.
    
    And as some hardware has separate dedicated wake-up interrupt
    in addition to the IO interrupt, we can automate the handling by
    adding a generic threaded interrupt handler that just calls the
    device PM runtime to wake up the device.
    
    This allows dropping code from device drivers as we currently
    are doing it in multiple ways, and often wrong.
    
    For most drivers, we should be able to drop the following
    boilerplate code from runtime_suspend and runtime_resume
    functions:
    
            ...
            device_init_wakeup(dev, true);
            ...
            if (device_may_wakeup(dev))
                    enable_irq_wake(irq);
            ...
            if (device_may_wakeup(dev))
                    disable_irq_wake(irq);
            ...
            device_init_wakeup(dev, false);
            ...
    
    We can replace it with just the following init and exit
    time code:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    And for hardware with dedicated wake-up interrupts:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_dedicated_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index b6b8a273c5da..f1a5d95e7b20 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -20,6 +20,46 @@ static inline void pm_runtime_early_init(struct device *dev)
 extern void pm_runtime_init(struct device *dev);
 extern void pm_runtime_remove(struct device *dev);
 
+struct wake_irq {
+	struct device *dev;
+	int irq;
+	bool dedicated_irq:1;
+};
+
+extern void dev_pm_arm_wake_irq(struct wake_irq *wirq);
+extern void dev_pm_disarm_wake_irq(struct wake_irq *wirq);
+
+#ifdef CONFIG_PM_SLEEP
+
+extern int device_wakeup_attach_irq(struct device *dev,
+				    struct wake_irq *wakeirq);
+extern void device_wakeup_detach_irq(struct device *dev);
+extern void device_wakeup_arm_wake_irqs(void);
+extern void device_wakeup_disarm_wake_irqs(void);
+
+#else
+
+static inline int
+device_wakeup_attach_irq(struct device *dev,
+			 struct wake_irq *wakeirq)
+{
+	return 0;
+}
+
+static inline void device_wakeup_detach_irq(struct device *dev)
+{
+}
+
+static inline void device_wakeup_arm_wake_irqs(void)
+{
+}
+
+static inline void device_wakeup_disarm_wake_irqs(void)
+{
+}
+
+#endif /* CONFIG_PM_SLEEP */
+
 /*
  * sysfs.c
  */
@@ -52,6 +92,14 @@ static inline void wakeup_sysfs_remove(struct device *dev) {}
 static inline int pm_qos_sysfs_add(struct device *dev) { return 0; }
 static inline void pm_qos_sysfs_remove(struct device *dev) {}
 
+static inline void dev_pm_arm_wake_irq(struct wake_irq *wirq)
+{
+}
+
+static inline void dev_pm_disarm_wake_irq(struct wake_irq *wirq)
+{
+}
+
 #endif
 
 #ifdef CONFIG_PM_SLEEP

commit d30d819dc83107812d9b2876e5e7194e511ed6af
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 22:38:05 2014 +0100

    PM: Drop CONFIG_PM_RUNTIME from the driver core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM or even may be dropped entirely in some cases.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the PM core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index a21223d95926..b6b8a273c5da 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -9,7 +9,7 @@ static inline void device_pm_init_common(struct device *dev)
 	}
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 
 static inline void pm_runtime_early_init(struct device *dev)
 {
@@ -20,7 +20,21 @@ static inline void pm_runtime_early_init(struct device *dev)
 extern void pm_runtime_init(struct device *dev);
 extern void pm_runtime_remove(struct device *dev);
 
-#else /* !CONFIG_PM_RUNTIME */
+/*
+ * sysfs.c
+ */
+
+extern int dpm_sysfs_add(struct device *dev);
+extern void dpm_sysfs_remove(struct device *dev);
+extern void rpm_sysfs_remove(struct device *dev);
+extern int wakeup_sysfs_add(struct device *dev);
+extern void wakeup_sysfs_remove(struct device *dev);
+extern int pm_qos_sysfs_add_resume_latency(struct device *dev);
+extern void pm_qos_sysfs_remove_resume_latency(struct device *dev);
+extern int pm_qos_sysfs_add_flags(struct device *dev);
+extern void pm_qos_sysfs_remove_flags(struct device *dev);
+
+#else /* CONFIG_PM */
 
 static inline void pm_runtime_early_init(struct device *dev)
 {
@@ -30,7 +44,15 @@ static inline void pm_runtime_early_init(struct device *dev)
 static inline void pm_runtime_init(struct device *dev) {}
 static inline void pm_runtime_remove(struct device *dev) {}
 
-#endif /* !CONFIG_PM_RUNTIME */
+static inline int dpm_sysfs_add(struct device *dev) { return 0; }
+static inline void dpm_sysfs_remove(struct device *dev) {}
+static inline void rpm_sysfs_remove(struct device *dev) {}
+static inline int wakeup_sysfs_add(struct device *dev) { return 0; }
+static inline void wakeup_sysfs_remove(struct device *dev) {}
+static inline int pm_qos_sysfs_add(struct device *dev) { return 0; }
+static inline void pm_qos_sysfs_remove(struct device *dev) {}
+
+#endif
 
 #ifdef CONFIG_PM_SLEEP
 
@@ -77,31 +99,3 @@ static inline void device_pm_init(struct device *dev)
 	device_pm_sleep_init(dev);
 	pm_runtime_init(dev);
 }
-
-#ifdef CONFIG_PM
-
-/*
- * sysfs.c
- */
-
-extern int dpm_sysfs_add(struct device *dev);
-extern void dpm_sysfs_remove(struct device *dev);
-extern void rpm_sysfs_remove(struct device *dev);
-extern int wakeup_sysfs_add(struct device *dev);
-extern void wakeup_sysfs_remove(struct device *dev);
-extern int pm_qos_sysfs_add_resume_latency(struct device *dev);
-extern void pm_qos_sysfs_remove_resume_latency(struct device *dev);
-extern int pm_qos_sysfs_add_flags(struct device *dev);
-extern void pm_qos_sysfs_remove_flags(struct device *dev);
-
-#else /* CONFIG_PM */
-
-static inline int dpm_sysfs_add(struct device *dev) { return 0; }
-static inline void dpm_sysfs_remove(struct device *dev) {}
-static inline void rpm_sysfs_remove(struct device *dev) {}
-static inline int wakeup_sysfs_add(struct device *dev) { return 0; }
-static inline void wakeup_sysfs_remove(struct device *dev) {}
-static inline int pm_qos_sysfs_add(struct device *dev) { return 0; }
-static inline void pm_qos_sysfs_remove(struct device *dev) {}
-
-#endif

commit b02f6695f7601c4f8442b9cf4636802e7fa8d550
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 00:35:23 2014 +0100

    PM / QoS: Rename device resume latency QoS items
    
    Rename symbols, variables, functions and structure fields related do
    the resume latency device PM QoS type so that it is clear where they
    belong (in particular, to avoid confusion with the latency tolerance
    device PM QoS type introduced by a subsequent changeset).
    
    Update the PM QoS documentation to better reflect its current state.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index cfc3226ec492..a21223d95926 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -89,8 +89,8 @@ extern void dpm_sysfs_remove(struct device *dev);
 extern void rpm_sysfs_remove(struct device *dev);
 extern int wakeup_sysfs_add(struct device *dev);
 extern void wakeup_sysfs_remove(struct device *dev);
-extern int pm_qos_sysfs_add_latency(struct device *dev);
-extern void pm_qos_sysfs_remove_latency(struct device *dev);
+extern int pm_qos_sysfs_add_resume_latency(struct device *dev);
+extern void pm_qos_sysfs_remove_resume_latency(struct device *dev);
 extern int pm_qos_sysfs_add_flags(struct device *dev);
 extern void pm_qos_sysfs_remove_flags(struct device *dev);
 

commit 37530f2bda039774bd65aea14cc1d1dd26a82b9e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 4 14:22:57 2013 +0100

    PM / QoS: Remove device PM QoS sysfs attributes at the right place
    
    Device PM QoS sysfs attributes, if present during device removal,
    are removed from within device_pm_remove(), which is too late,
    since dpm_sysfs_remove() has already removed the whole attribute
    group they belonged to.  However, moving the removal of those
    attributes to dpm_sysfs_remove() alone is not sufficient, because
    in theory they still can be re-added right after being removed by it
    (the device's driver is still bound to it at that point).
    
    For this reason, move the entire desctruction of device PM QoS
    constraints to dpm_sysfs_remove() and make it prevent any new
    constraints from being added after it has run.  Also, move the
    initialization of the power.qos field in struct device to
    device_pm_init_common() and drop the no longer needed
    dev_pm_qos_constraints_init().
    
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index b16686a0a5a2..cfc3226ec492 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -4,7 +4,7 @@ static inline void device_pm_init_common(struct device *dev)
 {
 	if (!dev->power.early_init) {
 		spin_lock_init(&dev->power.lock);
-		dev->power.power_state = PMSG_INVALID;
+		dev->power.qos = NULL;
 		dev->power.early_init = true;
 	}
 }
@@ -56,14 +56,10 @@ extern void device_pm_move_last(struct device *);
 
 static inline void device_pm_sleep_init(struct device *dev) {}
 
-static inline void device_pm_add(struct device *dev)
-{
-	dev_pm_qos_constraints_init(dev);
-}
+static inline void device_pm_add(struct device *dev) {}
 
 static inline void device_pm_remove(struct device *dev)
 {
-	dev_pm_qos_constraints_destroy(dev);
 	pm_runtime_remove(dev);
 }
 

commit e39473d0b9448e770f49b0b15e514be884264438
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 24 02:08:18 2012 +0200

    PM / QoS: Make it possible to expose PM QoS device flags to user space
    
    Define two device PM QoS flags, PM_QOS_FLAG_NO_POWER_OFF
    and PM_QOS_FLAG_REMOTE_WAKEUP, and introduce routines
    dev_pm_qos_expose_flags() and dev_pm_qos_hide_flags() allowing the
    caller to expose those two flags to user space or to hide them
    from it, respectively.
    
    After the flags have been exposed, user space will see two
    additional sysfs attributes, pm_qos_no_power_off and
    pm_qos_remote_wakeup, under the device's /sys/devices/.../power/
    directory.  Then, writing 1 to one of them will update the
    PM QoS flags request owned by user space so that the corresponding
    flag is requested to be set.  In turn, writing 0 to one of them
    will cause the corresponding flag in the user space's request to
    be cleared (however, the owners of the other PM QoS flags requests
    for the same device may still request the flag to be set and it
    may be effectively set even if user space doesn't request that).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: mark gross <markgross@thegnar.org>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 0dbfdf4419af..b16686a0a5a2 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -93,8 +93,10 @@ extern void dpm_sysfs_remove(struct device *dev);
 extern void rpm_sysfs_remove(struct device *dev);
 extern int wakeup_sysfs_add(struct device *dev);
 extern void wakeup_sysfs_remove(struct device *dev);
-extern int pm_qos_sysfs_add(struct device *dev);
-extern void pm_qos_sysfs_remove(struct device *dev);
+extern int pm_qos_sysfs_add_latency(struct device *dev);
+extern void pm_qos_sysfs_remove_latency(struct device *dev);
+extern int pm_qos_sysfs_add_flags(struct device *dev);
+extern void pm_qos_sysfs_remove_flags(struct device *dev);
 
 #else /* CONFIG_PM */
 

commit bed2b42d9f0b411f384c5619870ab0fea5dd116b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 6 01:45:11 2012 +0200

    PM / Runtime: Allow helpers to be called by early platform drivers
    
    Runtime PM helper functions, like pm_runtime_get_sync(), cannot be
    called by early platform device drivers, because the devices' power
    management locks are not initialized at that time.  This is quite
    inconvenient, so modify early_platform_add_devices() to initialize
    the devices power management locks as appropriate and make sure that
    they won't be initialized more than once if an early platform
    device is going to be used as a regular one later.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 8a0dcc7f98f9..0dbfdf4419af 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -2,17 +2,31 @@
 
 static inline void device_pm_init_common(struct device *dev)
 {
-	spin_lock_init(&dev->power.lock);
-	dev->power.power_state = PMSG_INVALID;
+	if (!dev->power.early_init) {
+		spin_lock_init(&dev->power.lock);
+		dev->power.power_state = PMSG_INVALID;
+		dev->power.early_init = true;
+	}
 }
 
 #ifdef CONFIG_PM_RUNTIME
 
+static inline void pm_runtime_early_init(struct device *dev)
+{
+	dev->power.disable_depth = 1;
+	device_pm_init_common(dev);
+}
+
 extern void pm_runtime_init(struct device *dev);
 extern void pm_runtime_remove(struct device *dev);
 
 #else /* !CONFIG_PM_RUNTIME */
 
+static inline void pm_runtime_early_init(struct device *dev)
+{
+	device_pm_init_common(dev);
+}
+
 static inline void pm_runtime_init(struct device *dev) {}
 static inline void pm_runtime_remove(struct device *dev) {}
 

commit e91c11b1a7f876c6f056d872eb210734150a1795
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 6 01:44:28 2012 +0200

    PM: Reorganize device PM initialization
    
    Make the device power management initialization more straightforward
    by moving the initialization of common (i.e. used by both runtime PM
    and system suspend) fields to a separate routine.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index eeb4bff9505c..8a0dcc7f98f9 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -1,5 +1,11 @@
 #include <linux/pm_qos.h>
 
+static inline void device_pm_init_common(struct device *dev)
+{
+	spin_lock_init(&dev->power.lock);
+	dev->power.power_state = PMSG_INVALID;
+}
+
 #ifdef CONFIG_PM_RUNTIME
 
 extern void pm_runtime_init(struct device *dev);
@@ -25,7 +31,7 @@ static inline struct device *to_device(struct list_head *entry)
 	return container_of(entry, struct device, power.entry);
 }
 
-extern void device_pm_init(struct device *dev);
+extern void device_pm_sleep_init(struct device *dev);
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
 extern void device_pm_move_before(struct device *, struct device *);
@@ -34,12 +40,7 @@ extern void device_pm_move_last(struct device *);
 
 #else /* !CONFIG_PM_SLEEP */
 
-static inline void device_pm_init(struct device *dev)
-{
-	spin_lock_init(&dev->power.lock);
-	dev->power.power_state = PMSG_INVALID;
-	pm_runtime_init(dev);
-}
+static inline void device_pm_sleep_init(struct device *dev) {}
 
 static inline void device_pm_add(struct device *dev)
 {
@@ -60,6 +61,13 @@ static inline void device_pm_move_last(struct device *dev) {}
 
 #endif /* !CONFIG_PM_SLEEP */
 
+static inline void device_pm_init(struct device *dev)
+{
+	device_pm_init_common(dev);
+	device_pm_sleep_init(dev);
+	pm_runtime_init(dev);
+}
+
 #ifdef CONFIG_PM
 
 /*

commit 85dc0b8a4019e38ad4fd0c008f89a5c241805ac2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Mar 13 01:01:39 2012 +0100

    PM / QoS: Make it possible to expose PM QoS latency constraints
    
    A runtime suspend of a device (e.g. an MMC controller) belonging to
    a power domain or, in a more complicated scenario, a runtime suspend
    of another device in the same power domain, may cause power to be
    removed from the entire domain.  In that case, the amount of time
    necessary to runtime-resume the given device (e.g. the MMC
    controller) is often substantially greater than the time needed to
    run its driver's runtime resume callback.  That may hurt performance
    in some situations, because user data may need to wait for the
    device to become operational, so we should make it possible to
    prevent that from happening.
    
    For this reason, introduce a new sysfs attribute for devices,
    power/pm_qos_resume_latency_us, allowing user space to specify the
    upper bound of the time necessary to bring the (runtime-suspended)
    device up after the resume of it has been requested.  However, make
    that attribute appear only for the devices whose drivers declare
    support for it by calling the (new) dev_pm_qos_expose_latency_limit()
    helper function with the appropriate initial value of the attribute.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 9bf62323aaf3..eeb4bff9505c 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -71,6 +71,8 @@ extern void dpm_sysfs_remove(struct device *dev);
 extern void rpm_sysfs_remove(struct device *dev);
 extern int wakeup_sysfs_add(struct device *dev);
 extern void wakeup_sysfs_remove(struct device *dev);
+extern int pm_qos_sysfs_add(struct device *dev);
+extern void pm_qos_sysfs_remove(struct device *dev);
 
 #else /* CONFIG_PM */
 
@@ -79,5 +81,7 @@ static inline void dpm_sysfs_remove(struct device *dev) {}
 static inline void rpm_sysfs_remove(struct device *dev) {}
 static inline int wakeup_sysfs_add(struct device *dev) { return 0; }
 static inline void wakeup_sysfs_remove(struct device *dev) {}
+static inline int pm_qos_sysfs_add(struct device *dev) { return 0; }
+static inline void pm_qos_sysfs_remove(struct device *dev) {}
 
 #endif

commit 1a9a91525d806f2b3bd8b57b963755a96fd36ce2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Sep 29 22:29:44 2011 +0200

    PM / QoS: Add function dev_pm_qos_read_value() (v3)
    
    To read the current PM QoS value for a given device we need to
    make sure that the device's power.constraints object won't be
    removed while we're doing that.  For this reason, put the
    operation under dev->power.lock and acquire the lock
    around the initialization and removal of power.constraints.
    
    Moreover, since we're using the value of power.constraints to
    determine whether or not the object is present, the
    power.constraints_state field isn't necessary any more and may be
    removed.  However, dev_pm_qos_add_request() needs to check if the
    device is being removed from the system before allocating a new
    PM QoS constraints object for it, so make it use the
    power.power_state field of struct device for this purpose.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index f2a25f18fde7..9bf62323aaf3 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -1,3 +1,5 @@
+#include <linux/pm_qos.h>
+
 #ifdef CONFIG_PM_RUNTIME
 
 extern void pm_runtime_init(struct device *dev);
@@ -35,15 +37,21 @@ extern void device_pm_move_last(struct device *);
 static inline void device_pm_init(struct device *dev)
 {
 	spin_lock_init(&dev->power.lock);
+	dev->power.power_state = PMSG_INVALID;
 	pm_runtime_init(dev);
 }
 
+static inline void device_pm_add(struct device *dev)
+{
+	dev_pm_qos_constraints_init(dev);
+}
+
 static inline void device_pm_remove(struct device *dev)
 {
+	dev_pm_qos_constraints_destroy(dev);
 	pm_runtime_remove(dev);
 }
 
-static inline void device_pm_add(struct device *dev) {}
 static inline void device_pm_move_before(struct device *deva,
 					 struct device *devb) {}
 static inline void device_pm_move_after(struct device *deva,

commit cb8f51bdadb7969139c2e39c2defd4cde98c1ea8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:26:02 2011 +0100

    PM: Do not create wakeup sysfs files for devices that cannot wake up
    
    Currently, wakeup sysfs attributes are created for all devices,
    regardless of whether or not they are wakeup-capable.  This is
    excessive and complicates wakeup device identification from user
    space (i.e. to identify wakeup-capable devices user space has to read
    /sys/devices/.../power/wakeup for all devices and see if they are not
    empty).
    
    Fix this issue by avoiding to create wakeup sysfs files for devices
    that cannot wake up the system from sleep states (i.e. whose
    power.can_wakeup flags are unset during registration) and modify
    device_set_wakeup_capable() so that it adds (or removes) the relevant
    sysfs attributes if a device's wakeup capability status is changed.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 698dde742587..f2a25f18fde7 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -58,19 +58,18 @@ static inline void device_pm_move_last(struct device *dev) {}
  * sysfs.c
  */
 
-extern int dpm_sysfs_add(struct device *);
-extern void dpm_sysfs_remove(struct device *);
-extern void rpm_sysfs_remove(struct device *);
+extern int dpm_sysfs_add(struct device *dev);
+extern void dpm_sysfs_remove(struct device *dev);
+extern void rpm_sysfs_remove(struct device *dev);
+extern int wakeup_sysfs_add(struct device *dev);
+extern void wakeup_sysfs_remove(struct device *dev);
 
 #else /* CONFIG_PM */
 
-static inline int dpm_sysfs_add(struct device *dev)
-{
-	return 0;
-}
-
-static inline void dpm_sysfs_remove(struct device *dev)
-{
-}
+static inline int dpm_sysfs_add(struct device *dev) { return 0; }
+static inline void dpm_sysfs_remove(struct device *dev) {}
+static inline void rpm_sysfs_remove(struct device *dev) {}
+static inline int wakeup_sysfs_add(struct device *dev) { return 0; }
+static inline void wakeup_sysfs_remove(struct device *dev) {}
 
 #endif

commit 7490e44239e60293bca0c2663229050c36c660c2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:15 2010 +0200

    PM / Runtime: Add no_callbacks flag
    
    Some devices, such as USB interfaces, cannot be power-managed
    independently of their parents, i.e., they cannot be put in low power
    while the parent remains at full power.  This patch (as1425) creates a
    new "no_callbacks" flag, which tells the PM core not to invoke the
    runtime-PM callback routines for the such devices but instead to
    assume that the callbacks always succeed.  In addition, the
    non-debugging runtime-PM sysfs attributes for the devices are removed,
    since they are pretty much meaningless.
    
    The advantage of this scheme comes not so much from avoiding the
    callbacks themselves, but rather from the fact that without the need
    for a process context in which to run the callbacks, more work can be
    done in interrupt context.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 8b2745c69e2a..698dde742587 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -60,6 +60,7 @@ static inline void device_pm_move_last(struct device *dev) {}
 
 extern int dpm_sysfs_add(struct device *);
 extern void dpm_sysfs_remove(struct device *);
+extern void rpm_sysfs_remove(struct device *);
 
 #else /* CONFIG_PM */
 

commit 074037ec79bea73edf1b1ec72fef1010e83e3cc5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 22 22:09:10 2010 +0200

    PM / Wakeup: Introduce wakeup source objects and event statistics (v3)
    
    Introduce struct wakeup_source for representing system wakeup sources
    within the kernel and for collecting statistics related to them.
    Make the recently introduced helper functions pm_wakeup_event(),
    pm_stay_awake() and pm_relax() use struct wakeup_source objects
    internally, so that wakeup statistics associated with wakeup devices
    can be collected and reported in a consistent way (the definition of
    pm_relax() is changed, which is harmless, because this function is
    not called directly by anyone yet).  Introduce new wakeup-related
    sysfs device attributes in /sys/devices/.../power for reporting the
    device wakeup statistics.
    
    Change the global wakeup events counters event_count and
    events_in_progress into atomic variables, so that it is not necessary
    to acquire a global spinlock in pm_wakeup_event(), pm_stay_awake()
    and pm_relax(), which should allow us to avoid lock contention in
    these functions on SMP systems with many wakeup devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index c0bd03c83b9c..8b2745c69e2a 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -34,6 +34,7 @@ extern void device_pm_move_last(struct device *);
 
 static inline void device_pm_init(struct device *dev)
 {
+	spin_lock_init(&dev->power.lock);
 	pm_runtime_init(dev);
 }
 

commit 0e06b4a891c6a108412fe24b4500f499da2cf8a1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 23 22:25:15 2010 +0100

    PM: Add a switch for disabling/enabling asynchronous suspend/resume
    
    Add sysfs attribute /sys/power/pm_async allowing the user space to
    disable/enable asynchronous suspend/resume of devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index b8fa1aa5225a..c0bd03c83b9c 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -12,10 +12,10 @@ static inline void pm_runtime_remove(struct device *dev) {}
 
 #ifdef CONFIG_PM_SLEEP
 
-/*
- * main.c
- */
+/* kernel/power/main.c */
+extern int pm_async_enabled;
 
+/* drivers/base/power/main.c */
 extern struct list_head dpm_list;	/* The active device list */
 
 static inline struct device *to_device(struct list_head *entry)

commit 5e928f77a09a07f9dd595bb8a489965d69a83458
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Aug 18 23:38:32 2009 +0200

    PM: Introduce core framework for run-time PM of I/O devices (rev. 17)
    
    Introduce a core framework for run-time power management of I/O
    devices.  Add device run-time PM fields to 'struct dev_pm_info'
    and device run-time PM callbacks to 'struct dev_pm_ops'.  Introduce
    a run-time PM workqueue and define some device run-time PM helper
    functions at the core level.  Document all these things.
    
    Special thanks to Alan Stern for his help with the design and
    multiple detailed reviews of the pereceding versions of this patch
    and to Magnus Damm for testing feedback.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Magnus Damm <damm@igel.co.jp>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index c7cb4fc3735c..b8fa1aa5225a 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -1,7 +1,14 @@
-static inline void device_pm_init(struct device *dev)
-{
-	dev->power.status = DPM_ON;
-}
+#ifdef CONFIG_PM_RUNTIME
+
+extern void pm_runtime_init(struct device *dev);
+extern void pm_runtime_remove(struct device *dev);
+
+#else /* !CONFIG_PM_RUNTIME */
+
+static inline void pm_runtime_init(struct device *dev) {}
+static inline void pm_runtime_remove(struct device *dev) {}
+
+#endif /* !CONFIG_PM_RUNTIME */
 
 #ifdef CONFIG_PM_SLEEP
 
@@ -16,23 +23,33 @@ static inline struct device *to_device(struct list_head *entry)
 	return container_of(entry, struct device, power.entry);
 }
 
+extern void device_pm_init(struct device *dev);
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
 extern void device_pm_move_before(struct device *, struct device *);
 extern void device_pm_move_after(struct device *, struct device *);
 extern void device_pm_move_last(struct device *);
 
-#else /* CONFIG_PM_SLEEP */
+#else /* !CONFIG_PM_SLEEP */
+
+static inline void device_pm_init(struct device *dev)
+{
+	pm_runtime_init(dev);
+}
+
+static inline void device_pm_remove(struct device *dev)
+{
+	pm_runtime_remove(dev);
+}
 
 static inline void device_pm_add(struct device *dev) {}
-static inline void device_pm_remove(struct device *dev) {}
 static inline void device_pm_move_before(struct device *deva,
 					 struct device *devb) {}
 static inline void device_pm_move_after(struct device *deva,
 					struct device *devb) {}
 static inline void device_pm_move_last(struct device *dev) {}
 
-#endif
+#endif /* !CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_PM
 

commit ffa6a7054d172a2f57248dff2de600ca795c5656
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Mar 4 12:44:00 2009 +0100

    Driver core: Fix device_move() vs. dpm list ordering, v2
    
    dpm_list currently relies on the fact that child devices will
    be registered after their parents to get a correct suspend
    order. Using device_move() however destroys this assumption, as
    an already registered device may be moved under a newly registered
    one.
    
    This patch adds a new argument to device_move(), allowing callers
    to specify how dpm_list should be adapted.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 41f51fae042f..c7cb4fc3735c 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -18,11 +18,19 @@ static inline struct device *to_device(struct list_head *entry)
 
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
+extern void device_pm_move_before(struct device *, struct device *);
+extern void device_pm_move_after(struct device *, struct device *);
+extern void device_pm_move_last(struct device *);
 
 #else /* CONFIG_PM_SLEEP */
 
 static inline void device_pm_add(struct device *dev) {}
 static inline void device_pm_remove(struct device *dev) {}
+static inline void device_pm_move_before(struct device *deva,
+					 struct device *devb) {}
+static inline void device_pm_move_after(struct device *deva,
+					struct device *devb) {}
+static inline void device_pm_move_last(struct device *dev) {}
 
 #endif
 

commit 3b98aeaf3a75f544dc945694f4fcf6e1c4bab89d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Aug 7 13:06:12 2008 -0400

    PM: don't skip device PM init when CONFIG_PM_SLEEP isn't set and CONFIG_PM is set
    
    This patch (as1124) fixes a couple of bugs in the PM core.  The new
    dev->power.status field should be initialized regardless of whether
    CONFIG_PM_SLEEP is enabled, and similarly dpm_sysfs_add() should be
    called whenever CONFIG_PM is enabled.
    
    The patch separates out the call to dpm_sysfs_add() from the call to
    device_pm_add().  As a result device_pm_add() can no longer return an
    error, so its return type is changed to void.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Romit Dasgupta <romit@ti.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index a3252c0e2887..41f51fae042f 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -1,3 +1,8 @@
+static inline void device_pm_init(struct device *dev)
+{
+	dev->power.status = DPM_ON;
+}
+
 #ifdef CONFIG_PM_SLEEP
 
 /*
@@ -11,12 +16,12 @@ static inline struct device *to_device(struct list_head *entry)
 	return container_of(entry, struct device, power.entry);
 }
 
-extern int device_pm_add(struct device *);
+extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
 
 #else /* CONFIG_PM_SLEEP */
 
-static inline int device_pm_add(struct device *dev) { return 0; }
+static inline void device_pm_add(struct device *dev) {}
 static inline void device_pm_remove(struct device *dev) {}
 
 #endif

commit 1eede070a59e1cc73da51e1aaa00d9ab86572cfc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 20 23:00:01 2008 +0200

    Introduce new top level suspend and hibernation callbacks
    
    Introduce 'struct pm_ops' and 'struct pm_ext_ops' ('ext' meaning
    'extended') representing suspend and hibernation operations for bus
    types, device classes, device types and device drivers.
    
    Modify the PM core to use 'struct pm_ops' and 'struct pm_ext_ops'
    objects, if defined, instead of the ->suspend(), ->resume(),
    ->suspend_late(), and ->resume_early() callbacks (the old callbacks
    will be considered as legacy and gradually phased out).
    
    The main purpose of doing this is to separate suspend (aka S2RAM and
    standby) callbacks from hibernation callbacks in such a way that the
    new callbacks won't take arguments and the semantics of each of them
    will be clearly specified.  This has been requested for multiple
    times by many people, including Linus himself, and the reason is that
    within the current scheme if ->resume() is called, for example, it's
    difficult to say why it's been called (ie. is it a resume from RAM or
    from hibernation or a suspend/hibernation failure etc.?).
    
    The second purpose is to make the suspend/hibernation callbacks more
    flexible so that device drivers can handle more than they can within
    the current scheme.  For example, some drivers may need to prevent
    new children of the device from being registered before their
    ->suspend() callbacks are executed or they may want to carry out some
    operations requiring the availability of some other devices, not
    directly bound via the parent-child relationship, in order to prepare
    for the execution of ->suspend(), etc.
    
    Ultimately, we'd like to stop using the freezing of tasks for suspend
    and therefore the drivers' suspend/hibernation code will have to take
    care of the handling of the user space during suspend/hibernation.
    That, in turn, would be difficult within the current scheme, without
    the new ->prepare() and ->complete() callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index a6894f2a4b99..a3252c0e2887 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -4,7 +4,7 @@
  * main.c
  */
 
-extern struct list_head dpm_active;	/* The active device list */
+extern struct list_head dpm_list;	/* The active device list */
 
 static inline struct device *to_device(struct list_head *entry)
 {

commit 58aca23226a19983571bd3b65167521fc64f5869
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Mar 12 00:57:22 2008 +0100

    PM: Handle device registrations during suspend/resume
    
    Modify the PM core to protect its data structures, specifically the
    dpm_active list, from being corrupted if a child of the currently
    suspending device is registered concurrently with its ->suspend()
    callback.  In that case, since the new device (the child) is added
    to dpm_active after its parent, the PM core will attempt to
    suspend it after the parent, which is wrong.
    
    Introduce a new member of struct dev_pm_info, called 'sleeping',
    and use it to check if the parent of the device being added to
    dpm_active has been suspended, in which case the device registration
    fails.  Also, use 'sleeping' for checking if the ordering of devices
    on dpm_active is correct.
    
    Introduce variable 'all_sleeping' that will be set to 'true' once all
    devices have been suspended and make new device registrations fail
    until 'all_sleeping' is reset to 'false', in order to avoid having
    unsuspended devices around while the system is going into a sleep state.
    
    Remove pm_sleep_rwsem which is not necessary any more.
    
    Special thanks to Alan Stern for discussions and suggestions that
    lead to the creation of this patch.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index e32d3bdb92c1..a6894f2a4b99 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -11,30 +11,13 @@ static inline struct device *to_device(struct list_head *entry)
 	return container_of(entry, struct device, power.entry);
 }
 
-extern void device_pm_add(struct device *);
+extern int device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
-extern int pm_sleep_lock(void);
-extern void pm_sleep_unlock(void);
 
 #else /* CONFIG_PM_SLEEP */
 
-
-static inline void device_pm_add(struct device *dev)
-{
-}
-
-static inline void device_pm_remove(struct device *dev)
-{
-}
-
-static inline int pm_sleep_lock(void)
-{
-	return 0;
-}
-
-static inline void pm_sleep_unlock(void)
-{
-}
+static inline int device_pm_add(struct device *dev) { return 0; }
+static inline void device_pm_remove(struct device *dev) {}
 
 #endif
 

commit 9617c3e460bbccb6d9496a1f1e6903eb81f336e9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 25 01:30:25 2008 +0100

    PM: Export device_pm_schedule_removal
    
    Move the declaration of device_pm_schedule_removal() to device.h
    and make it exported, as it will be used directly by some drivers
    for unregistering device objects during suspend/resume cycles in a
    safe way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 6f0dfca8ebdd..e32d3bdb92c1 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -13,7 +13,6 @@ static inline struct device *to_device(struct list_head *entry)
 
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
-extern void device_pm_schedule_removal(struct device *);
 extern int pm_sleep_lock(void);
 extern void pm_sleep_unlock(void);
 

commit 822a89ed1ea0f7a2d8079307426fbeeac0370138
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 20 13:56:21 2007 -0800

    driver core: clean up shutdown.c
    
    shutdown.c had some stuff it did not need, including a duplicate extern
    in the power.h file.  This cleans up all of that.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 10c20840395e..6f0dfca8ebdd 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -1,10 +1,3 @@
-/*
- * shutdown.c
- */
-
-extern void device_shutdown(void);
-
-
 #ifdef CONFIG_PM_SLEEP
 
 /*

commit 775b64d2b6ca37697de925f70799c710aab5849a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 12 20:40:46 2008 +0100

    PM: Acquire device locks on suspend
    
    This patch reorganizes the way suspend and resume notifications are
    sent to drivers.  The major changes are that now the PM core acquires
    every device semaphore before calling the methods, and calls to
    device_add() during suspends will fail, while calls to device_del()
    during suspends will block.
    
    It also provides a way to safely remove a suspended device with the
    help of the PM core, by using the device_pm_schedule_removal() callback
    introduced specifically for this purpose, and updates two drivers (msr
    and cpuid) that need to use it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 379da4e958e0..10c20840395e 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -20,6 +20,9 @@ static inline struct device *to_device(struct list_head *entry)
 
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
+extern void device_pm_schedule_removal(struct device *);
+extern int pm_sleep_lock(void);
+extern void pm_sleep_unlock(void);
 
 #else /* CONFIG_PM_SLEEP */
 
@@ -32,6 +35,15 @@ static inline void device_pm_remove(struct device *dev)
 {
 }
 
+static inline int pm_sleep_lock(void)
+{
+	return 0;
+}
+
+static inline void pm_sleep_unlock(void)
+{
+}
+
 #endif
 
 #ifdef CONFIG_PM

commit dec13c15445fec29ca9087890895718450e80b95
Author: Daniel Drake <dsd@gentoo.org>
Date:   Wed Nov 21 14:55:18 2007 -0800

    create /sys/.../power when CONFIG_PM is set
    
    The CONFIG_SUSPEND changes in 2.6.23 caused a regression under certain
    configuration conditions (SUSPEND=n, USB_AUTOSUSPEND=y) where all USB
    device attributes in sysfs (idVendor, idProduct, ...) silently disappeared,
    causing udev breakage and more.
    
    The cause of this is that the /sys/.../power subdirectory is now only
    created when CONFIG_PM_SLEEP is set, however, it should be created whenever
    CONFIG_PM is set to handle the above situation.  The following patch fixes
    the regression.
    
    Signed-off-by: Daniel Drake <dsd@gentoo.org>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 5c4efd493fa5..379da4e958e0 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -13,14 +13,29 @@ extern void device_shutdown(void);
 
 extern struct list_head dpm_active;	/* The active device list */
 
-static inline struct device * to_device(struct list_head * entry)
+static inline struct device *to_device(struct list_head *entry)
 {
 	return container_of(entry, struct device, power.entry);
 }
 
-extern int device_pm_add(struct device *);
+extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
 
+#else /* CONFIG_PM_SLEEP */
+
+
+static inline void device_pm_add(struct device *dev)
+{
+}
+
+static inline void device_pm_remove(struct device *dev)
+{
+}
+
+#endif
+
+#ifdef CONFIG_PM
+
 /*
  * sysfs.c
  */
@@ -28,16 +43,15 @@ extern void device_pm_remove(struct device *);
 extern int dpm_sysfs_add(struct device *);
 extern void dpm_sysfs_remove(struct device *);
 
-#else /* CONFIG_PM_SLEEP */
-
+#else /* CONFIG_PM */
 
-static inline int device_pm_add(struct device * dev)
+static inline int dpm_sysfs_add(struct device *dev)
 {
 	return 0;
 }
-static inline void device_pm_remove(struct device * dev)
-{
 
+static inline void dpm_sysfs_remove(struct device *dev)
+{
 }
 
 #endif

commit cd59abfcc441b2abb4cf2cd62c1eb0f02a60e8dd
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Sep 21 15:36:56 2007 -0400

    PM: merge device power-management source files
    
    This patch (as993) merges the suspend.c and resume.c files in
    drivers/base/power into main.c, making some public symbols private.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 49e64dbcce96..5c4efd493fa5 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -11,32 +11,11 @@ extern void device_shutdown(void);
  * main.c
  */
 
-/*
- * Used to synchronize global power management operations.
- */
-extern struct mutex dpm_mtx;
-
-/*
- * Used to serialize changes to the dpm_* lists.
- */
-extern struct mutex dpm_list_mtx;
-
-/*
- * The PM lists.
- */
-extern struct list_head dpm_active;
-extern struct list_head dpm_off;
-extern struct list_head dpm_off_irq;
-
-
-static inline struct dev_pm_info * to_pm_info(struct list_head * entry)
-{
-	return container_of(entry, struct dev_pm_info, entry);
-}
+extern struct list_head dpm_active;	/* The active device list */
 
 static inline struct device * to_device(struct list_head * entry)
 {
-	return container_of(to_pm_info(entry), struct device, power);
+	return container_of(entry, struct device, power.entry);
 }
 
 extern int device_pm_add(struct device *);
@@ -49,13 +28,6 @@ extern void device_pm_remove(struct device *);
 extern int dpm_sysfs_add(struct device *);
 extern void dpm_sysfs_remove(struct device *);
 
-/*
- * resume.c
- */
-
-extern void dpm_resume(void);
-extern void dpm_power_up(void);
-
 #else /* CONFIG_PM_SLEEP */
 
 

commit b4d1eb2ccecb76bce4c2125c5a3e77753fcfaeb0
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Aug 10 13:51:09 2007 -0700

    drivers/base/power/: make 2 functions static
    
    suspend_device() and resume_device() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 8ba0830cbc03..49e64dbcce96 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -55,12 +55,6 @@ extern void dpm_sysfs_remove(struct device *);
 
 extern void dpm_resume(void);
 extern void dpm_power_up(void);
-extern int resume_device(struct device *);
-
-/*
- * suspend.c
- */
-extern int suspend_device(struct device *, pm_message_t);
 
 #else /* CONFIG_PM_SLEEP */
 

commit 296699de6bdc717189a331ab6bbe90e05c94db06
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:27:18 2007 +0200

    Introduce CONFIG_SUSPEND for suspend-to-Ram and standby
    
    Introduce CONFIG_SUSPEND representing the ability to enter system sleep
    states, such as the ACPI S3 state, and allow the user to choose SUSPEND
    and HIBERNATION independently of each other.
    
    Make HOTPLUG_CPU be selected automatically if SUSPEND or HIBERNATION has
    been chosen and the kernel is intended for SMP systems.
    
    Also, introduce CONFIG_PM_SLEEP which is automatically selected if
    CONFIG_SUSPEND or CONFIG_HIBERNATION is set and use it to select the
    code needed for both suspend and hibernation.
    
    The top-level power management headers and the ACPI code related to
    suspend and hibernation are modified to use the new definitions (the
    changes in drivers/acpi/sleep/main.c are, mostly, moving code to reduce
    the number of ifdefs).
    
    There are many other files in which CONFIG_PM can be replaced with
    CONFIG_PM_SLEEP or even with CONFIG_SUSPEND, but they can be updated in
    the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 591a0dd5deee..8ba0830cbc03 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -5,7 +5,7 @@
 extern void device_shutdown(void);
 
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 
 /*
  * main.c
@@ -62,7 +62,7 @@ extern int resume_device(struct device *);
  */
 extern int suspend_device(struct device *, pm_message_t);
 
-#else /* CONFIG_PM */
+#else /* CONFIG_PM_SLEEP */
 
 
 static inline int device_pm_add(struct device * dev)

commit 3f8df781fc5f9ee5253a54ba669e1c8872844b86
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jul 12 16:57:22 2007 -0400

    PM: remove deprecated dpm_runtime_* routines
    
    This patch (as933) removes the deprecated dpm_runtime_suspend() and
    dpm_runtime_resume() routines from the PM core.  The only user of
    those routines is the PCMCIA ds driver; local replacements are added.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 2760f25b3ac5..591a0dd5deee 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -62,11 +62,6 @@ extern int resume_device(struct device *);
  */
 extern int suspend_device(struct device *, pm_message_t);
 
-
-/*
- * runtime.c
- */
-
 #else /* CONFIG_PM */
 
 

commit 11048dcf333c414f237bb713c422e68f67b115a3
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Wed May 23 14:19:41 2007 -0700

    Power Management: use mutexes instead of semaphores
    
    The Power Management code uses semaphores as mutexes.  Use the mutex API
    instead of the (binary) semaphores.
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index fb3d35a9e101..2760f25b3ac5 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -14,12 +14,12 @@ extern void device_shutdown(void);
 /*
  * Used to synchronize global power management operations.
  */
-extern struct semaphore dpm_sem;
+extern struct mutex dpm_mtx;
 
 /*
  * Used to serialize changes to the dpm_* lists.
  */
-extern struct semaphore dpm_list_sem;
+extern struct mutex dpm_list_mtx;
 
 /*
  * The PM lists.

commit 9a7834d06d553d02cc6e659e94772f69a8b5367f
Author: Andrew Morton <akpm@osdl.org>
Date:   Sun Oct 23 23:02:20 2005 -0700

    [PATCH] USB: fix pm patches with CONFIG_PM off part 2
    
    With CONFIG_PM=n:
    
    drivers/built-in.o(.text+0x1098c): In function `hub_thread':
    drivers/usb/core/hub.c:2673: undefined reference to `.dpm_runtime_resume'
    drivers/built-in.o(.text+0x10998):drivers/usb/core/hub.c:2674: undefined reference to `.dpm_runtime_resume'
    
    Please, never ever ever put extern decls into .c files.  Use the darn header
    files :(
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 2e700d795cf1..fb3d35a9e101 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -67,9 +67,6 @@ extern int suspend_device(struct device *, pm_message_t);
  * runtime.c
  */
 
-extern int dpm_runtime_suspend(struct device *, pm_message_t);
-extern void dpm_runtime_resume(struct device *);
-
 #else /* CONFIG_PM */
 
 
@@ -82,14 +79,4 @@ static inline void device_pm_remove(struct device * dev)
 
 }
 
-static inline int dpm_runtime_suspend(struct device * dev, pm_message_t state)
-{
-	return 0;
-}
-
-static inline void dpm_runtime_resume(struct device * dev)
-{
-
-}
-
 #endif

commit 0b405a0f7e4d4d18fd1fe46ddf5ff465443036ab
Author: David Brownell <david-b@pacbell.net>
Date:   Thu May 12 12:06:27 2005 -0700

    [PATCH] Driver Core: remove driver model detach_state
    
    The driver model has a "detach_state" mechanism that:
    
     - Has never been used by any in-kernel drive;
     - Is superfluous, since driver remove() methods can do the same thing;
     - Became buggy when the suspend() parameter changed semantics and type;
     - Could self-deadlock when called from certain suspend contexts;
     - Is effectively wasted documentation, object code, and headspace.
    
    This removes that "detach_state" mechanism; net code shrink, as well
    as a per-device saving in the driver model and sysfs.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index e5eda746f2a6..2e700d795cf1 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -1,18 +1,7 @@
-
-
-enum {
-	DEVICE_PM_ON,
-	DEVICE_PM1,
-	DEVICE_PM2,
-	DEVICE_PM3,
-	DEVICE_PM_OFF,
-};
-
 /*
  * shutdown.c
  */
 
-extern int device_detach_shutdown(struct device *);
 extern void device_shutdown(void);
 
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
new file mode 100644
index 000000000000..e5eda746f2a6
--- /dev/null
+++ b/drivers/base/power/power.h
@@ -0,0 +1,106 @@
+
+
+enum {
+	DEVICE_PM_ON,
+	DEVICE_PM1,
+	DEVICE_PM2,
+	DEVICE_PM3,
+	DEVICE_PM_OFF,
+};
+
+/*
+ * shutdown.c
+ */
+
+extern int device_detach_shutdown(struct device *);
+extern void device_shutdown(void);
+
+
+#ifdef CONFIG_PM
+
+/*
+ * main.c
+ */
+
+/*
+ * Used to synchronize global power management operations.
+ */
+extern struct semaphore dpm_sem;
+
+/*
+ * Used to serialize changes to the dpm_* lists.
+ */
+extern struct semaphore dpm_list_sem;
+
+/*
+ * The PM lists.
+ */
+extern struct list_head dpm_active;
+extern struct list_head dpm_off;
+extern struct list_head dpm_off_irq;
+
+
+static inline struct dev_pm_info * to_pm_info(struct list_head * entry)
+{
+	return container_of(entry, struct dev_pm_info, entry);
+}
+
+static inline struct device * to_device(struct list_head * entry)
+{
+	return container_of(to_pm_info(entry), struct device, power);
+}
+
+extern int device_pm_add(struct device *);
+extern void device_pm_remove(struct device *);
+
+/*
+ * sysfs.c
+ */
+
+extern int dpm_sysfs_add(struct device *);
+extern void dpm_sysfs_remove(struct device *);
+
+/*
+ * resume.c
+ */
+
+extern void dpm_resume(void);
+extern void dpm_power_up(void);
+extern int resume_device(struct device *);
+
+/*
+ * suspend.c
+ */
+extern int suspend_device(struct device *, pm_message_t);
+
+
+/*
+ * runtime.c
+ */
+
+extern int dpm_runtime_suspend(struct device *, pm_message_t);
+extern void dpm_runtime_resume(struct device *);
+
+#else /* CONFIG_PM */
+
+
+static inline int device_pm_add(struct device * dev)
+{
+	return 0;
+}
+static inline void device_pm_remove(struct device * dev)
+{
+
+}
+
+static inline int dpm_runtime_suspend(struct device * dev, pm_message_t state)
+{
+	return 0;
+}
+
+static inline void dpm_runtime_resume(struct device * dev)
+{
+
+}
+
+#endif
