commit 2451e746478a6a6e981cfa66b62b791ca93b90c8
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 1 12:42:59 2020 -0700

    driver core: Avoid deferred probe due to fw_devlink_pause/resume()
    
    With the earlier patch in this series, all devices that deferred probe
    due to fw_devlink_pause() will have their probes delayed till the
    deferred probe thread is kicked off during late_initcall. This will also
    affect all their consumers.
    
    This delayed probing in unnecessary. So this patch just keeps track of
    the devices that had their probe deferred due to fw_devlink_pause() and
    attempts to probe them once during fw_devlink_resume().
    
    Fixes: 716a7a259690 ("driver core: fw_devlink: Add support for batching fwnode parsing")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20200701194259.3337652-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d1d2cdc3a8d8..05d414e9e8a4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -50,6 +50,7 @@ static DEFINE_MUTEX(wfs_lock);
 static LIST_HEAD(deferred_sync);
 static unsigned int defer_sync_state_count = 1;
 static unsigned int defer_fw_devlink_count;
+static LIST_HEAD(deferred_fw_devlink);
 static DEFINE_MUTEX(defer_fw_devlink_lock);
 static bool fw_devlink_is_permissive(void);
 
@@ -1244,6 +1245,12 @@ static void fw_devlink_link_device(struct device *dev)
 			fw_ret = -EAGAIN;
 	} else {
 		fw_ret = -ENODEV;
+		/*
+		 * defer_hook is not used to add device to deferred_sync list
+		 * until device is bound. Since deferred fw devlink also blocks
+		 * probing, same list hook can be used for deferred_fw_devlink.
+		 */
+		list_add_tail(&dev->links.defer_hook, &deferred_fw_devlink);
 	}
 
 	if (fw_ret == -ENODEV)
@@ -1312,6 +1319,9 @@ void fw_devlink_pause(void)
  */
 void fw_devlink_resume(void)
 {
+	struct device *dev, *tmp;
+	LIST_HEAD(probe_list);
+
 	mutex_lock(&defer_fw_devlink_lock);
 	if (!defer_fw_devlink_count) {
 		WARN(true, "Unmatched fw_devlink pause/resume!");
@@ -1323,8 +1333,19 @@ void fw_devlink_resume(void)
 		goto out;
 
 	device_link_add_missing_supplier_links();
+	list_splice_tail_init(&deferred_fw_devlink, &probe_list);
 out:
 	mutex_unlock(&defer_fw_devlink_lock);
+
+	/*
+	 * bus_probe_device() can cause new devices to get added and they'll
+	 * try to grab defer_fw_devlink_lock. So, this needs to be done outside
+	 * the defer_fw_devlink_lock.
+	 */
+	list_for_each_entry_safe(dev, tmp, &probe_list, links.defer_hook) {
+		list_del_init(&dev->links.defer_hook);
+		bus_probe_device(dev);
+	}
 }
 /* Device links support end. */
 

commit ec7bd78498f29680f536451fbdf9464e851273ed
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 1 12:42:58 2020 -0700

    driver core: Rename dev_links_info.defer_sync to defer_hook
    
    The defer_sync field is used as a hook to add the device to the
    deferred_sync list. Rename it so that it's more meaningful for the next
    patch that'll also use this field as a hook to a deferred_fw_devlink
    list.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael@kernel.org>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20200701194259.3337652-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 35cc9896eb9e..d1d2cdc3a8d8 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -754,11 +754,11 @@ static void __device_links_queue_sync_state(struct device *dev,
 	 */
 	dev->state_synced = true;
 
-	if (WARN_ON(!list_empty(&dev->links.defer_sync)))
+	if (WARN_ON(!list_empty(&dev->links.defer_hook)))
 		return;
 
 	get_device(dev);
-	list_add_tail(&dev->links.defer_sync, list);
+	list_add_tail(&dev->links.defer_hook, list);
 }
 
 /**
@@ -776,8 +776,8 @@ static void device_links_flush_sync_list(struct list_head *list,
 {
 	struct device *dev, *tmp;
 
-	list_for_each_entry_safe(dev, tmp, list, links.defer_sync) {
-		list_del_init(&dev->links.defer_sync);
+	list_for_each_entry_safe(dev, tmp, list, links.defer_hook) {
+		list_del_init(&dev->links.defer_hook);
 
 		if (dev != dont_lock_dev)
 			device_lock(dev);
@@ -815,12 +815,12 @@ void device_links_supplier_sync_state_resume(void)
 	if (defer_sync_state_count)
 		goto out;
 
-	list_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_sync) {
+	list_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_hook) {
 		/*
 		 * Delete from deferred_sync list before queuing it to
-		 * sync_list because defer_sync is used for both lists.
+		 * sync_list because defer_hook is used for both lists.
 		 */
-		list_del_init(&dev->links.defer_sync);
+		list_del_init(&dev->links.defer_hook);
 		__device_links_queue_sync_state(dev, &sync_list);
 	}
 out:
@@ -838,8 +838,8 @@ late_initcall(sync_state_resume_initcall);
 
 static void __device_links_supplier_defer_sync(struct device *sup)
 {
-	if (list_empty(&sup->links.defer_sync) && dev_has_sync_state(sup))
-		list_add_tail(&sup->links.defer_sync, &deferred_sync);
+	if (list_empty(&sup->links.defer_hook) && dev_has_sync_state(sup))
+		list_add_tail(&sup->links.defer_hook, &deferred_sync);
 }
 
 static void device_link_drop_managed(struct device_link *link)
@@ -1052,7 +1052,7 @@ void device_links_driver_cleanup(struct device *dev)
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}
 
-	list_del_init(&dev->links.defer_sync);
+	list_del_init(&dev->links.defer_hook);
 	__device_links_no_driver(dev);
 
 	device_links_write_unlock();
@@ -2171,7 +2171,7 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->links.consumers);
 	INIT_LIST_HEAD(&dev->links.suppliers);
 	INIT_LIST_HEAD(&dev->links.needs_suppliers);
-	INIT_LIST_HEAD(&dev->links.defer_sync);
+	INIT_LIST_HEAD(&dev->links.defer_hook);
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);

commit cec72f3efc6272420c2c2c699607f03d09b93e41
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 1 12:42:57 2020 -0700

    driver core: Don't do deferred probe in parallel with kernel_init thread
    
    The current deferred probe implementation can mess up suspend/resume
    ordering if deferred probe thread is kicked off in parallel with the
    main initcall thread (kernel_init thread) [1].
    
    For example:
    
    Say device-B is a consumer of device-A.
    
    Initcall thread                                 Deferred probe thread
    ===============                                 =====================
    1. device-A is added.
    2. device-B is added.
    3. dpm_list is now [device-A, device-B].
    4. driver-A defers probe of device-A.
                                                    5. device-A is moved to
                                                       end of dpm_list
                                                    6. dpm_list is now
                                                       [device-B, device-A]
    7. driver-B is registereed and probes device-B.
    8. dpm_list stays as [device-B, device-A].
    
    The reverse order of dpm_list is used for suspend. So in this case
    device-A would incorrectly get suspended before device-B.
    
    Commit 716a7a259690 ("driver core: fw_devlink: Add support for batching
    fwnode parsing") kicked off the deferred probe thread early during boot
    to run in parallel with the initcall thread and caused suspend/resume
    regressions.  This patch removes the parallel run of the deferred probe
    thread to avoid the suspend/resume regressions.
    
    [1] - https://lore.kernel.org/lkml/CAGETcx8W96KAw-d_siTX4qHB_-7ddk0miYRDQeHE6E0_8qx-6Q@mail.gmail.com/
    
    Fixes: 716a7a259690 ("driver core: fw_devlink: Add support for batching fwnode parsing")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20200701194259.3337652-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 67d39a90b45c..35cc9896eb9e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1323,7 +1323,6 @@ void fw_devlink_resume(void)
 		goto out;
 
 	device_link_add_missing_supplier_links();
-	driver_deferred_probe_force_trigger();
 out:
 	mutex_unlock(&defer_fw_devlink_lock);
 }

commit f558b8364e19f9222e7976c64e9367f66bab02cc
Merge: 80ef846e9909 8c3e315d4296
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 7 10:53:36 2020 -0700

    Merge tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of driver core patches for 5.8-rc1.
    
      Not all that huge this release, just a number of small fixes and
      updates:
    
       - software node fixes
    
       - kobject now sends KOBJ_REMOVE when it is removed from sysfs, not
         when it is removed from memory (which could come much later)
    
       - device link additions and fixes based on testing on more devices
    
       - firmware core cleanups
    
       - other minor changes, full details in the shortlog
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (23 commits)
      driver core: Update device link status correctly for SYNC_STATE_ONLY links
      firmware_loader: change enum fw_opt to u32
      software node: implement software_node_unregister()
      kobject: send KOBJ_REMOVE uevent when the object is removed from sysfs
      driver core: Remove unnecessary is_fwnode_dev variable in device_add()
      drivers property: When no children in primary, try secondary
      driver core: platform: Fix spelling errors in platform.c
      driver core: Remove check in driver_deferred_probe_force_trigger()
      of: platform: Batch fwnode parsing when adding all top level devices
      driver core: fw_devlink: Add support for batching fwnode parsing
      driver core: Look for waiting consumers only for a fwnode's primary device
      driver core: Move code to the right part of the file
      Revert "Revert "driver core: Set fw_devlink to "permissive" behavior by default""
      drivers: base: Fix NULL pointer exception in __platform_driver_probe() if a driver developer is foolish
      firmware_loader: move fw_fallback_config to a private kernel symbol namespace
      driver core: Add missing '\n' in log messages
      driver/base/soc: Use kobj_to_dev() API
      Add documentation on meaning of -EPROBE_DEFER
      driver core: platform: remove redundant assignment to variable ret
      debugfs: Use the correct style for SPDX License Identifier
      ...

commit 750a02ab8d3c49ca7d23102be90d3d1db19e2827
Merge: 1966391fa576 abb30460bda2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 15:29:19 2020 -0700

    Merge tag 'for-5.8/block-2020-06-01' of git://git.kernel.dk/linux-block
    
    Pull block updates from Jens Axboe:
     "Core block changes that have been queued up for this release:
    
       - Remove dead blk-throttle and blk-wbt code (Guoqing)
    
       - Include pid in blktrace note traces (Jan)
    
       - Don't spew I/O errors on wouldblock termination (me)
    
       - Zone append addition (Johannes, Keith, Damien)
    
       - IO accounting improvements (Konstantin, Christoph)
    
       - blk-mq hardware map update improvements (Ming)
    
       - Scheduler dispatch improvement (Salman)
    
       - Inline block encryption support (Satya)
    
       - Request map fixes and improvements (Weiping)
    
       - blk-iocost tweaks (Tejun)
    
       - Fix for timeout failing with error injection (Keith)
    
       - Queue re-run fixes (Douglas)
    
       - CPU hotplug improvements (Christoph)
    
       - Queue entry/exit improvements (Christoph)
    
       - Move DMA drain handling to the few drivers that use it (Christoph)
    
       - Partition handling cleanups (Christoph)"
    
    * tag 'for-5.8/block-2020-06-01' of git://git.kernel.dk/linux-block: (127 commits)
      block: mark bio_wouldblock_error() bio with BIO_QUIET
      blk-wbt: rename __wbt_update_limits to wbt_update_limits
      blk-wbt: remove wbt_update_limits
      blk-throttle: remove tg_drain_bios
      blk-throttle: remove blk_throtl_drain
      null_blk: force complete for timeout request
      blk-mq: drain I/O when all CPUs in a hctx are offline
      blk-mq: add blk_mq_all_tag_iter
      blk-mq: open code __blk_mq_alloc_request in blk_mq_alloc_request_hctx
      blk-mq: use BLK_MQ_NO_TAG in more places
      blk-mq: rename BLK_MQ_TAG_FAIL to BLK_MQ_NO_TAG
      blk-mq: move more request initialization to blk_mq_rq_ctx_init
      blk-mq: simplify the blk_mq_get_request calling convention
      blk-mq: remove the bio argument to ->prepare_request
      nvme: force complete cancelled requests
      blk-mq: blk-mq: provide forced completion method
      block: fix a warning when blkdev.h is included for !CONFIG_BLOCK builds
      block: blk-crypto-fallback: remove redundant initialization of variable err
      block: reduce part_stat_lock() scope
      block: use __this_cpu_add() instead of access by smp_processor_id()
      ...

commit a5a82e0a5918fb2ae27b80d3b9c954b16ae6a7b7
Merge: c5d6c1384388 47a94c551a74
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 12:56:58 2020 -0700

    Merge tag 'platform-drivers-x86-v5.8-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Andy Shevchenko:
    
     - Add a support of the media keys on the ASUS laptop UX325JA/UX425JA
    
     - ASUS WMI driver can now handle 2-in-1 models T100TA, T100CHI, T100HA,
       T200TA
    
     - Big refactoring of Intel SCU driver with Elkhart Lake support has
       been added
    
     - Slim Bootloarder firmware update signaling WMI driver has been added
    
     - Thinkpad ACPI driver can handle dual fan configuration on new P and X
       models
    
     - Touchscreen DMI driver has been extended to support
        - MP-man MPWIN895CL tablet
        - ONDA V891 v5 tablet
        - techBite Arc 11.6
        - Trekstor Twin 10.1
        - Trekstor Yourbook C11B
        - Vinga J116
    
     - Virtual Button driver got a few fixes to detect mode of 2-in-1 tablet
       models
    
     - Intel Speed Select tools update
    
     - Plenty of small cleanups here and there
    
    * tag 'platform-drivers-x86-v5.8-1' of git://git.infradead.org/linux-platform-drivers-x86: (89 commits)
      platform/x86: dcdbas: Check SMBIOS for protected buffer address
      platform/x86: asus_wmi: Reserve more space for struct bias_args
      platform/x86: intel-vbtn: Only blacklist SW_TABLET_MODE on the 9 / "Laptop" chasis-type
      platform/x86: intel-hid: Add a quirk to support HP Spectre X2 (2015)
      platform/x86: touchscreen_dmi: Update Trekstor Twin 10.1 entry
      platform/x86: touchscreen_dmi: Add info for the Trekstor Yourbook C11B
      platform/x86: hp-wmi: Introduce HPWMI_POWER_FW_OR_HW as convenient shortcut
      platform/x86: hp-wmi: Convert simple_strtoul() to kstrtou32()
      platform/x86: hp-wmi: Refactor postcode_store() to follow standard patterns
      platform/x86: acerhdf: replace space by * in modalias
      platform/x86: ISST: Increase timeout
      tools/power/x86/intel-speed-select: Fix invalid core mask
      tools/power/x86/intel-speed-select: Increase CPU count
      tools/power/x86/intel-speed-select: Fix json perf-profile output output
      platform/x86: dell-wmi: Ignore keyboard attached / detached events
      platform/x86: dell-laptop: don't register micmute LED if there is no token
      platform/x86: thinkpad_acpi: Replace custom approach by kstrtoint()
      platform/x86: thinkpad_acpi: Use strndup_user() in dispatch_proc_write()
      platform/x86: thinkpad_acpi: Replace next_cmd(&buf) with strsep(&buf, ",")
      platform/x86: intel-vbtn: Detect switch position before registering the input-device
      ...

commit b23c4771ff62de8ca9b5e4a2d64491b2fb6f8f69
Merge: c2b0fc847f31 e35b5a4c494a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 1 15:45:27 2020 -0700

    Merge tag 'docs-5.8' of git://git.lwn.net/linux
    
    Pull documentation updates from Jonathan Corbet:
     "A fair amount of stuff this time around, dominated by yet another
      massive set from Mauro toward the completion of the RST conversion. I
      *really* hope we are getting close to the end of this. Meanwhile,
      those patches reach pretty far afield to update document references
      around the tree; there should be no actual code changes there. There
      will be, alas, more of the usual trivial merge conflicts.
    
      Beyond that we have more translations, improvements to the sphinx
      scripting, a number of additions to the sysctl documentation, and lots
      of fixes"
    
    * tag 'docs-5.8' of git://git.lwn.net/linux: (130 commits)
      Documentation: fixes to the maintainer-entry-profile template
      zswap: docs/vm: Fix typo accept_threshold_percent in zswap.rst
      tracing: Fix events.rst section numbering
      docs: acpi: fix old http link and improve document format
      docs: filesystems: add info about efivars content
      Documentation: LSM: Correct the basic LSM description
      mailmap: change email for Ricardo Ribalda
      docs: sysctl/kernel: document unaligned controls
      Documentation: admin-guide: update bug-hunting.rst
      docs: sysctl/kernel: document ngroups_max
      nvdimm: fixes to maintainter-entry-profile
      Documentation/features: Correct RISC-V kprobes support entry
      Documentation/features: Refresh the arch support status files
      Revert "docs: sysctl/kernel: document ngroups_max"
      docs: move locking-specific documents to locking/
      docs: move digsig docs to the security book
      docs: move the kref doc into the core-api book
      docs: add IRQ documentation at the core-api book
      docs: debugging-via-ohci1394.txt: add it to the core-api book
      docs: fix references for ipmi.rst file
      ...

commit 8c3e315d4296421cd26b3300ee0ac117f0877f20
Author: Saravana Kannan <saravanak@google.com>
Date:   Tue May 26 15:09:27 2020 -0700

    driver core: Update device link status correctly for SYNC_STATE_ONLY links
    
    When SYNC_STATE_ONLY support was added in commit 05ef983e0d65 ("driver
    core: Add device link support for SYNC_STATE_ONLY flag"),
    SYNC_STATE_ONLY links were treated similar to STATELESS links in terms
    of not blocking consumer probe if the supplier hasn't probed yet.
    
    That caused a SYNC_STATE_ONLY device link's status to not get updated.
    Since SYNC_STATE_ONLY device link is no longer useful once the
    consumer probes, commit 21c27f06587d ("driver core: Fix
    SYNC_STATE_ONLY device link implementation") addresses the status
    update issue by deleting the SYNC_STATE_ONLY device link instead of
    complicating the status update code.
    
    However, there are still some cases where we need to update the status
    of a SYNC_STATE_ONLY device link. This is because a SYNC_STATE_ONLY
    device link can later get converted into a normal MANAGED device link
    when a normal MANAGED device link is created between a supplier and
    consumer that already have a SYNC_STATE_ONLY device link between them.
    
    If a SYNC_STATE_ONLY device link's status isn't maintained correctly
    till it's converted to a normal MANAGED device link, then the normal
    MANAGED device link will end up with a wrong link status. This can cause
    a warning stack trace[1] when the consumer device probes successfully.
    
    This commit fixes the SYNC_STATE_ONLY device link status update issue
    where it wouldn't transition correctly from DL_STATE_DORMANT or
    DL_STATE_AVAILABLE to DL_STATE_CONSUMER_PROBE. It also resets the status
    back to DL_STATE_DORMANT or DL_STATE_AVAILABLE if the consumer probe
    fails.
    
    [1] - https://lore.kernel.org/lkml/20200522204120.3b3c9ed6@apollo/
    Fixes: 05ef983e0d65 ("driver core: Add device link support for SYNC_STATE_ONLY flag")
    Fixes: 21c27f06587d ("driver core: Fix SYNC_STATE_ONLY device link implementation")
    Reported-by: Michael Walle <michael@walle.cc>
    Tested-by: Michael Walle <michael@walle.cc>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rafael J. Wysocki <rrafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20200526220928.49939-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 791b7530599f..9a76dd44cb37 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -646,9 +646,17 @@ static void device_links_missing_supplier(struct device *dev)
 {
 	struct device_link *link;
 
-	list_for_each_entry(link, &dev->links.suppliers, c_node)
-		if (link->status == DL_STATE_CONSUMER_PROBE)
+	list_for_each_entry(link, &dev->links.suppliers, c_node) {
+		if (link->status != DL_STATE_CONSUMER_PROBE)
+			continue;
+
+		if (link->supplier->links.status == DL_DEV_DRIVER_BOUND) {
 			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
+		} else {
+			WARN_ON(!(link->flags & DL_FLAG_SYNC_STATE_ONLY));
+			WRITE_ONCE(link->status, DL_STATE_DORMANT);
+		}
+	}
 }
 
 /**
@@ -687,11 +695,11 @@ int device_links_check_suppliers(struct device *dev)
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
-		if (!(link->flags & DL_FLAG_MANAGED) ||
-		    link->flags & DL_FLAG_SYNC_STATE_ONLY)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
-		if (link->status != DL_STATE_AVAILABLE) {
+		if (link->status != DL_STATE_AVAILABLE &&
+		    !(link->flags & DL_FLAG_SYNC_STATE_ONLY)) {
 			device_links_missing_supplier(dev);
 			ret = -EPROBE_DEFER;
 			break;
@@ -952,11 +960,21 @@ static void __device_links_no_driver(struct device *dev)
 		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
-		if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER)
+		if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER) {
 			device_link_drop_managed(link);
-		else if (link->status == DL_STATE_CONSUMER_PROBE ||
-			 link->status == DL_STATE_ACTIVE)
+			continue;
+		}
+
+		if (link->status != DL_STATE_CONSUMER_PROBE &&
+		    link->status != DL_STATE_ACTIVE)
+			continue;
+
+		if (link->supplier->links.status == DL_DEV_DRIVER_BOUND) {
 			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
+		} else {
+			WARN_ON(!(link->flags & DL_FLAG_SYNC_STATE_ONLY));
+			WRITE_ONCE(link->status, DL_STATE_DORMANT);
+		}
 	}
 
 	dev->links.status = DL_DEV_NO_DRIVER;

commit f7d8f3f092d001f8d91552d2697643e727694942
Merge: 2cd38fd15e4e 9cb1fd0efd19
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 25 08:55:12 2020 +0200

    Merge 5.7-rc7 into driver-core-next
    
    We need the driver core fixes in here as well
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2cd38fd15e4ebcfe917a443734820269f8b5ba2b
Author: Saravana Kannan <saravanak@google.com>
Date:   Tue May 19 20:48:21 2020 -0700

    driver core: Remove unnecessary is_fwnode_dev variable in device_add()
    
    That variable is no longer necessary. Remove it and also fix a minor
    typo in comments.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200520034824.79049-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 84c569726d75..55310c97a8b7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2526,7 +2526,6 @@ int device_add(struct device *dev)
 	struct class_interface *class_intf;
 	int error = -EINVAL;
 	struct kobject *glue_dir = NULL;
-	bool is_fwnode_dev = false;
 
 	dev = get_device(dev);
 	if (!dev)
@@ -2624,11 +2623,6 @@ int device_add(struct device *dev)
 
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 
-	if (dev->fwnode && !dev->fwnode->dev) {
-		dev->fwnode->dev = dev;
-		is_fwnode_dev = true;
-	}
-
 	/*
 	 * Check if any of the other devices (consumers) have been waiting for
 	 * this device (supplier) to be added so that they can create a device
@@ -2637,12 +2631,14 @@ int device_add(struct device *dev)
 	 * This needs to happen after device_pm_add() because device_link_add()
 	 * requires the supplier be registered before it's called.
 	 *
-	 * But this also needs to happe before bus_probe_device() to make sure
+	 * But this also needs to happen before bus_probe_device() to make sure
 	 * waiting consumers can link to it before the driver is bound to the
 	 * device and the driver sync_state callback is called for this device.
 	 */
-	if (is_fwnode_dev)
+	if (dev->fwnode && !dev->fwnode->dev) {
+		dev->fwnode->dev = dev;
 		fw_devlink_link_device(dev);
+	}
 
 	bus_probe_device(dev);
 	if (parent)

commit 44e960490ddf868fc9135151c4a658936e771dc2
Author: Saravana Kannan <saravanak@google.com>
Date:   Tue May 19 21:36:26 2020 -0700

    driver core: Fix handling of SYNC_STATE_ONLY + STATELESS device links
    
    Commit 21c27f06587d ("driver core: Fix SYNC_STATE_ONLY device link
    implementation") didn't completely fix STATELESS + SYNC_STATE_ONLY
    handling.
    
    What looks like an optimization in that commit is actually a bug that
    causes an if condition to always take the else path. This prevents
    reordering of devices in the dpm_list when a DL_FLAG_STATELESS device
    link is create on top of an existing DL_FLAG_SYNC_STATE_ONLY device
    link.
    
    Fixes: 21c27f06587d ("driver core: Fix SYNC_STATE_ONLY device link implementation")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20200520043626.181820-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4e0e430315d9..0cad34f1eede 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -360,12 +360,14 @@ struct device_link *device_link_add(struct device *consumer,
 
 		if (flags & DL_FLAG_STATELESS) {
 			kref_get(&link->kref);
-			link->flags |= DL_FLAG_STATELESS;
 			if (link->flags & DL_FLAG_SYNC_STATE_ONLY &&
-			    !(link->flags & DL_FLAG_STATELESS))
+			    !(link->flags & DL_FLAG_STATELESS)) {
+				link->flags |= DL_FLAG_STATELESS;
 				goto reorder;
-			else
+			} else {
+				link->flags |= DL_FLAG_STATELESS;
 				goto out;
+			}
 		}
 
 		/*

commit 21c27f06587d2c18150d27ca2382a509ec55c482
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon May 18 23:30:00 2020 -0700

    driver core: Fix SYNC_STATE_ONLY device link implementation
    
    When SYNC_STATE_ONLY support was added in commit 05ef983e0d65 ("driver
    core: Add device link support for SYNC_STATE_ONLY flag"),
    device_link_add() incorrectly skipped adding the new SYNC_STATE_ONLY
    device link to the supplier's and consumer's "device link" list.
    
    This causes multiple issues:
    - The device link is lost forever from driver core if the caller
      didn't keep track of it (caller typically isn't expected to). This is
      a memory leak.
    - The device link is also never visible to any other code path after
      device_link_add() returns.
    
    If we fix the "device link" list handling, that exposes a bunch of
    issues.
    
    1. The device link "status" state management code rightfully doesn't
    handle the case where a DL_FLAG_MANAGED device link exists between a
    supplier and consumer, but the consumer manages to probe successfully
    before the supplier. The addition of DL_FLAG_SYNC_STATE_ONLY links break
    this assumption. This causes device_links_driver_bound() to throw a
    warning when this happens.
    
    Since DL_FLAG_SYNC_STATE_ONLY device links are mainly used for creating
    proxy device links for child device dependencies and aren't useful once
    the consumer device probes successfully, this patch just deletes
    DL_FLAG_SYNC_STATE_ONLY device links once its consumer device probes.
    This way, we avoid the warning, free up some memory and avoid
    complicating the device links "status" state management code.
    
    2. Creating a DL_FLAG_STATELESS device link between two devices that
    already have a DL_FLAG_SYNC_STATE_ONLY device link will result in the
    DL_FLAG_STATELESS flag not getting set correctly. This patch also fixes
    this.
    
    Lastly, this patch also fixes minor whitespace issues.
    
    Cc: stable@vger.kernel.org
    Fixes: 05ef983e0d65 ("driver core: Add device link support for SYNC_STATE_ONLY flag")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20200519063000.128819-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 073045cb214e..4e0e430315d9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -360,13 +360,12 @@ struct device_link *device_link_add(struct device *consumer,
 
 		if (flags & DL_FLAG_STATELESS) {
 			kref_get(&link->kref);
+			link->flags |= DL_FLAG_STATELESS;
 			if (link->flags & DL_FLAG_SYNC_STATE_ONLY &&
-			    !(link->flags & DL_FLAG_STATELESS)) {
-				link->flags |= DL_FLAG_STATELESS;
+			    !(link->flags & DL_FLAG_STATELESS))
 				goto reorder;
-			} else {
+			else
 				goto out;
-			}
 		}
 
 		/*
@@ -433,12 +432,16 @@ struct device_link *device_link_add(struct device *consumer,
 	    flags & DL_FLAG_PM_RUNTIME)
 		pm_runtime_resume(supplier);
 
+	list_add_tail_rcu(&link->s_node, &supplier->links.consumers);
+	list_add_tail_rcu(&link->c_node, &consumer->links.suppliers);
+
 	if (flags & DL_FLAG_SYNC_STATE_ONLY) {
 		dev_dbg(consumer,
 			"Linked as a sync state only consumer to %s\n",
 			dev_name(supplier));
 		goto out;
 	}
+
 reorder:
 	/*
 	 * Move the consumer and all of the devices depending on it to the end
@@ -449,12 +452,9 @@ struct device_link *device_link_add(struct device *consumer,
 	 */
 	device_reorder_to_tail(consumer, NULL);
 
-	list_add_tail_rcu(&link->s_node, &supplier->links.consumers);
-	list_add_tail_rcu(&link->c_node, &consumer->links.suppliers);
-
 	dev_dbg(consumer, "Linked as a consumer to %s\n", dev_name(supplier));
 
- out:
+out:
 	device_pm_unlock();
 	device_links_write_unlock();
 
@@ -829,6 +829,13 @@ static void __device_links_supplier_defer_sync(struct device *sup)
 		list_add_tail(&sup->links.defer_sync, &deferred_sync);
 }
 
+static void device_link_drop_managed(struct device_link *link)
+{
+	link->flags &= ~DL_FLAG_MANAGED;
+	WRITE_ONCE(link->status, DL_STATE_NONE);
+	kref_put(&link->kref, __device_link_del);
+}
+
 /**
  * device_links_driver_bound - Update device links after probing its driver.
  * @dev: Device to update the links for.
@@ -842,7 +849,7 @@ static void __device_links_supplier_defer_sync(struct device *sup)
  */
 void device_links_driver_bound(struct device *dev)
 {
-	struct device_link *link;
+	struct device_link *link, *ln;
 	LIST_HEAD(sync_list);
 
 	/*
@@ -882,18 +889,35 @@ void device_links_driver_bound(struct device *dev)
 	else
 		__device_links_queue_sync_state(dev, &sync_list);
 
-	list_for_each_entry(link, &dev->links.suppliers, c_node) {
+	list_for_each_entry_safe(link, ln, &dev->links.suppliers, c_node) {
+		struct device *supplier;
+
 		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
-		WARN_ON(link->status != DL_STATE_CONSUMER_PROBE);
-		WRITE_ONCE(link->status, DL_STATE_ACTIVE);
+		supplier = link->supplier;
+		if (link->flags & DL_FLAG_SYNC_STATE_ONLY) {
+			/*
+			 * When DL_FLAG_SYNC_STATE_ONLY is set, it means no
+			 * other DL_MANAGED_LINK_FLAGS have been set. So, it's
+			 * save to drop the managed link completely.
+			 */
+			device_link_drop_managed(link);
+		} else {
+			WARN_ON(link->status != DL_STATE_CONSUMER_PROBE);
+			WRITE_ONCE(link->status, DL_STATE_ACTIVE);
+		}
 
+		/*
+		 * This needs to be done even for the deleted
+		 * DL_FLAG_SYNC_STATE_ONLY device link in case it was the last
+		 * device link that was preventing the supplier from getting a
+		 * sync_state() call.
+		 */
 		if (defer_sync_state_count)
-			__device_links_supplier_defer_sync(link->supplier);
+			__device_links_supplier_defer_sync(supplier);
 		else
-			__device_links_queue_sync_state(link->supplier,
-							&sync_list);
+			__device_links_queue_sync_state(supplier, &sync_list);
 	}
 
 	dev->links.status = DL_DEV_DRIVER_BOUND;
@@ -903,13 +927,6 @@ void device_links_driver_bound(struct device *dev)
 	device_links_flush_sync_list(&sync_list, dev);
 }
 
-static void device_link_drop_managed(struct device_link *link)
-{
-	link->flags &= ~DL_FLAG_MANAGED;
-	WRITE_ONCE(link->status, DL_STATE_NONE);
-	kref_put(&link->kref, __device_link_del);
-}
-
 /**
  * __device_links_no_driver - Update links of a device without a driver.
  * @dev: Device without a drvier.

commit 716a7a25969003d82ab738179c3f1068a120ed11
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu May 14 22:34:59 2020 -0700

    driver core: fw_devlink: Add support for batching fwnode parsing
    
    The amount of time spent parsing fwnodes of devices can become really
    high if the devices are added in an non-ideal order. Worst case can be
    O(N^2) when N devices are added. But this can be optimized to O(N) by
    adding all the devices and then parsing all their fwnodes in one batch.
    
    This commit adds fw_devlink_pause() and fw_devlink_resume() to allow
    doing this.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200515053500.215929-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f585d92e09d0..84c569726d75 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -49,6 +49,9 @@ static LIST_HEAD(wait_for_suppliers);
 static DEFINE_MUTEX(wfs_lock);
 static LIST_HEAD(deferred_sync);
 static unsigned int defer_sync_state_count = 1;
+static unsigned int defer_fw_devlink_count;
+static DEFINE_MUTEX(defer_fw_devlink_lock);
+static bool fw_devlink_is_permissive(void);
 
 #ifdef CONFIG_SRCU
 static DEFINE_MUTEX(device_links_lock);
@@ -527,7 +530,7 @@ static void device_link_add_missing_supplier_links(void)
 		int ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
 		if (!ret)
 			list_del_init(&dev->links.needs_suppliers);
-		else if (ret != -ENODEV)
+		else if (ret != -ENODEV || fw_devlink_is_permissive())
 			dev->links.need_for_probe = false;
 	}
 	mutex_unlock(&wfs_lock);
@@ -1177,17 +1180,116 @@ static void fw_devlink_link_device(struct device *dev)
 {
 	int fw_ret;
 
-	device_link_add_missing_supplier_links();
+	if (!fw_devlink_flags)
+		return;
+
+	mutex_lock(&defer_fw_devlink_lock);
+	if (!defer_fw_devlink_count)
+		device_link_add_missing_supplier_links();
+
+	/*
+	 * The device's fwnode not having add_links() doesn't affect if other
+	 * consumers can find this device as a supplier.  So, this check is
+	 * intentionally placed after device_link_add_missing_supplier_links().
+	 */
+	if (!fwnode_has_op(dev->fwnode, add_links))
+		goto out;
 
-	if (fw_devlink_flags && fwnode_has_op(dev->fwnode, add_links)) {
+	/*
+	 * If fw_devlink is being deferred, assume all devices have mandatory
+	 * suppliers they need to link to later. Then, when the fw_devlink is
+	 * resumed, all these devices will get a chance to try and link to any
+	 * suppliers they have.
+	 */
+	if (!defer_fw_devlink_count) {
 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
-		if (fw_ret == -ENODEV && !fw_devlink_is_permissive())
-			device_link_wait_for_mandatory_supplier(dev);
-		else if (fw_ret)
-			device_link_wait_for_optional_supplier(dev);
+		if (fw_ret == -ENODEV && fw_devlink_is_permissive())
+			fw_ret = -EAGAIN;
+	} else {
+		fw_ret = -ENODEV;
 	}
+
+	if (fw_ret == -ENODEV)
+		device_link_wait_for_mandatory_supplier(dev);
+	else if (fw_ret)
+		device_link_wait_for_optional_supplier(dev);
+
+out:
+	mutex_unlock(&defer_fw_devlink_lock);
 }
 
+/**
+ * fw_devlink_pause - Pause parsing of fwnode to create device links
+ *
+ * Calling this function defers any fwnode parsing to create device links until
+ * fw_devlink_resume() is called. Both these functions are ref counted and the
+ * caller needs to match the calls.
+ *
+ * While fw_devlink is paused:
+ * - Any device that is added won't have its fwnode parsed to create device
+ *   links.
+ * - The probe of the device will also be deferred during this period.
+ * - Any devices that were already added, but waiting for suppliers won't be
+ *   able to link to newly added devices.
+ *
+ * Once fw_devlink_resume():
+ * - All the fwnodes that was not parsed will be parsed.
+ * - All the devices that were deferred probing will be reattempted if they
+ *   aren't waiting for any more suppliers.
+ *
+ * This pair of functions, is mainly meant to optimize the parsing of fwnodes
+ * when a lot of devices that need to link to each other are added in a short
+ * interval of time. For example, adding all the top level devices in a system.
+ *
+ * For example, if N devices are added and:
+ * - All the consumers are added before their suppliers
+ * - All the suppliers of the N devices are part of the N devices
+ *
+ * Then:
+ *
+ * - With the use of fw_devlink_pause() and fw_devlink_resume(), each device
+ *   will only need one parsing of its fwnode because it is guaranteed to find
+ *   all the supplier devices already registered and ready to link to. It won't
+ *   have to do another pass later to find one or more suppliers it couldn't
+ *   find in the first parse of the fwnode. So, we'll only need O(N) fwnode
+ *   parses.
+ *
+ * - Without the use of fw_devlink_pause() and fw_devlink_resume(), we would
+ *   end up doing O(N^2) parses of fwnodes because every device that's added is
+ *   guaranteed to trigger a parse of the fwnode of every device added before
+ *   it. This O(N^2) parse is made worse by the fact that when a fwnode of a
+ *   device is parsed, all it descendant devices might need to have their
+ *   fwnodes parsed too (even if the devices themselves aren't added).
+ */
+void fw_devlink_pause(void)
+{
+	mutex_lock(&defer_fw_devlink_lock);
+	defer_fw_devlink_count++;
+	mutex_unlock(&defer_fw_devlink_lock);
+}
+
+/** fw_devlink_resume - Resume parsing of fwnode to create device links
+ *
+ * This function is used in conjunction with fw_devlink_pause() and is ref
+ * counted. See documentation for fw_devlink_pause() for more details.
+ */
+void fw_devlink_resume(void)
+{
+	mutex_lock(&defer_fw_devlink_lock);
+	if (!defer_fw_devlink_count) {
+		WARN(true, "Unmatched fw_devlink pause/resume!");
+		goto out;
+	}
+
+	defer_fw_devlink_count--;
+	if (defer_fw_devlink_count)
+		goto out;
+
+	device_link_add_missing_supplier_links();
+	driver_deferred_probe_force_trigger();
+out:
+	mutex_unlock(&defer_fw_devlink_lock);
+}
 /* Device links support end. */
 
 int (*platform_notify)(struct device *dev) = NULL;

commit 5f5377eaddfc24e5d7562e588d0ff84f9264d7c1
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu May 14 22:34:58 2020 -0700

    driver core: Look for waiting consumers only for a fwnode's primary device
    
    Commit 4dbe191c046e ("driver core: Add device links from fwnode only for
    the primary device") skipped linking a fwnode's secondary device to
    the suppliers listed in its fwnode.
    
    However, a fwnode's secondary device can't be found using
    get_dev_from_fwnode(). So, there's no point in trying to see if devices
    waiting for suppliers might want to link to a fwnode's secondary device.
    
    This commit removes that unnecessary step for devices that aren't a
    fwnode's primary device and also moves the code to a more appropriate
    part of the file.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200515053500.215929-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2b454aae64b5..f585d92e09d0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1173,6 +1173,21 @@ static bool fw_devlink_is_permissive(void)
 	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
 }
 
+static void fw_devlink_link_device(struct device *dev)
+{
+	int fw_ret;
+
+	device_link_add_missing_supplier_links();
+
+	if (fw_devlink_flags && fwnode_has_op(dev->fwnode, add_links)) {
+		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+		if (fw_ret == -ENODEV && !fw_devlink_is_permissive())
+			device_link_wait_for_mandatory_supplier(dev);
+		else if (fw_ret)
+			device_link_wait_for_optional_supplier(dev);
+	}
+}
+
 /* Device links support end. */
 
 int (*platform_notify)(struct device *dev) = NULL;
@@ -2407,7 +2422,7 @@ int device_add(struct device *dev)
 	struct device *parent;
 	struct kobject *kobj;
 	struct class_interface *class_intf;
-	int error = -EINVAL, fw_ret;
+	int error = -EINVAL;
 	struct kobject *glue_dir = NULL;
 	bool is_fwnode_dev = false;
 
@@ -2524,16 +2539,8 @@ int device_add(struct device *dev)
 	 * waiting consumers can link to it before the driver is bound to the
 	 * device and the driver sync_state callback is called for this device.
 	 */
-	device_link_add_missing_supplier_links();
-
-	if (fw_devlink_flags && is_fwnode_dev &&
-	    fwnode_has_op(dev->fwnode, add_links)) {
-		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
-		if (fw_ret == -ENODEV && !fw_devlink_is_permissive())
-			device_link_wait_for_mandatory_supplier(dev);
-		else if (fw_ret)
-			device_link_wait_for_optional_supplier(dev);
-	}
+	if (is_fwnode_dev)
+		fw_devlink_link_device(dev);
 
 	bus_probe_device(dev);
 	if (parent)

commit 42926ac3cd50937346c23c0005817264af4357a7
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu May 14 22:34:57 2020 -0700

    driver core: Move code to the right part of the file
    
    This commit just moves around code to match the general organization of
    the file.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200515053500.215929-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c9045521596f..2b454aae64b5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1143,6 +1143,36 @@ static void device_links_purge(struct device *dev)
 	device_links_write_unlock();
 }
 
+static u32 fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
+static int __init fw_devlink_setup(char *arg)
+{
+	if (!arg)
+		return -EINVAL;
+
+	if (strcmp(arg, "off") == 0) {
+		fw_devlink_flags = 0;
+	} else if (strcmp(arg, "permissive") == 0) {
+		fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
+	} else if (strcmp(arg, "on") == 0) {
+		fw_devlink_flags = DL_FLAG_AUTOPROBE_CONSUMER;
+	} else if (strcmp(arg, "rpm") == 0) {
+		fw_devlink_flags = DL_FLAG_AUTOPROBE_CONSUMER |
+				   DL_FLAG_PM_RUNTIME;
+	}
+	return 0;
+}
+early_param("fw_devlink", fw_devlink_setup);
+
+u32 fw_devlink_get_flags(void)
+{
+	return fw_devlink_flags;
+}
+
+static bool fw_devlink_is_permissive(void)
+{
+	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
+}
+
 /* Device links support end. */
 
 int (*platform_notify)(struct device *dev) = NULL;
@@ -2345,36 +2375,6 @@ static int device_private_init(struct device *dev)
 	return 0;
 }
 
-static u32 fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
-static int __init fw_devlink_setup(char *arg)
-{
-	if (!arg)
-		return -EINVAL;
-
-	if (strcmp(arg, "off") == 0) {
-		fw_devlink_flags = 0;
-	} else if (strcmp(arg, "permissive") == 0) {
-		fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
-	} else if (strcmp(arg, "on") == 0) {
-		fw_devlink_flags = DL_FLAG_AUTOPROBE_CONSUMER;
-	} else if (strcmp(arg, "rpm") == 0) {
-		fw_devlink_flags = DL_FLAG_AUTOPROBE_CONSUMER |
-				   DL_FLAG_PM_RUNTIME;
-	}
-	return 0;
-}
-early_param("fw_devlink", fw_devlink_setup);
-
-u32 fw_devlink_get_flags(void)
-{
-	return fw_devlink_flags;
-}
-
-static bool fw_devlink_is_permissive(void)
-{
-	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
-}
-
 /**
  * device_add - add device to device hierarchy.
  * @dev: device.

commit c8be6af9ef16cf44d690fc227a0d2dd7a526ef05
Merge: c78c31b374a6 2ef96a5bb12b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 11 09:00:09 2020 +0200

    Merge v5.7-rc5 into driver-core-next
    
    We want the driver core fixes in here and this resolves a merge issue
    with drivers/base/dd.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4c74746625dedb62ce00ac86ac4faedb640536d0
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 4 14:47:57 2020 +0200

    driver core: remove device_create_vargs
    
    All external users of device_create_vargs are gone, so remove it and
    open code it in the only caller.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 139cdf7e7327..fb8ae248e5aa 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3188,40 +3188,6 @@ device_create_groups_vargs(struct class *class, struct device *parent,
 	return ERR_PTR(retval);
 }
 
-/**
- * device_create_vargs - creates a device and registers it with sysfs
- * @class: pointer to the struct class that this device should be registered to
- * @parent: pointer to the parent struct device of this new device, if any
- * @devt: the dev_t for the char device to be added
- * @drvdata: the data to be added to the device for callbacks
- * @fmt: string for the device's name
- * @args: va_list for the device's name
- *
- * This function can be used by char device classes.  A struct device
- * will be created in sysfs, registered to the specified class.
- *
- * A "dev" file will be created, showing the dev_t for the device, if
- * the dev_t is not 0,0.
- * If a pointer to a parent struct device is passed in, the newly created
- * struct device will be a child of that device in sysfs.
- * The pointer to the struct device will be returned from the call.
- * Any further sysfs files that might be required can be created using this
- * pointer.
- *
- * Returns &struct device pointer on success, or ERR_PTR() on error.
- *
- * Note: the struct class passed to this function must have previously
- * been created with a call to class_create().
- */
-struct device *device_create_vargs(struct class *class, struct device *parent,
-				   dev_t devt, void *drvdata, const char *fmt,
-				   va_list args)
-{
-	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
-					  fmt, args);
-}
-EXPORT_SYMBOL_GPL(device_create_vargs);
-
 /**
  * device_create - creates a device and registers it with sysfs
  * @class: pointer to the struct class that this device should be registered to
@@ -3253,7 +3219,8 @@ struct device *device_create(struct class *class, struct device *parent,
 	struct device *dev;
 
 	va_start(vargs, fmt);
-	dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);
+	dev = device_create_groups_vargs(class, parent, devt, drvdata, NULL,
+					  fmt, vargs);
 	va_end(vargs);
 	return dev;
 }

commit c78c31b374a68be79cb4a03ef5b6c187f034e903
Author: Saravana Kannan <saravanak@google.com>
Date:   Tue Apr 28 12:20:05 2020 -0700

    Revert "Revert "driver core: Set fw_devlink to "permissive" behavior by default""
    
    This reverts commit 18555cb6db2373b9a5ec1f7572773fd58c77f9ba.
    
    The reason[1] for the original revert has now been fixed by
    commit 00b247557858 ("driver core: Fix handling of
    fw_devlink=permissive"). So, this patch reverts the revert. Marek has
    also tested this patch with the fix mentioned above and confirmed that
    the issue has been fixed.
    
    [1] - https://lore.kernel.org/lkml/CAGETcx8nbz-J1gLvoEKE_HgCcVGyV2o8rZeq_USFKM6=s7WmNg@mail.gmail.com/T/#m12dfb5dfd23805b84c49f4bb2238a8cce436c2f7
    [2] - https://lore.kernel.org/lkml/CAGETcx8nbz-J1gLvoEKE_HgCcVGyV2o8rZeq_USFKM6=s7WmNg@mail.gmail.com/T/#m2408a6ce098b2ebf583ca8534329695923ae57fe
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200428192006.109006-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 139cdf7e7327..db103e32489b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2345,7 +2345,7 @@ static int device_private_init(struct device *dev)
 	return 0;
 }
 
-static u32 fw_devlink_flags;
+static u32 fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
 static int __init fw_devlink_setup(char *arg)
 {
 	if (!arg)

commit 00b247557858bc0651a646710d90aba186bfeed4
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Mar 30 19:28:32 2020 -0700

    driver core: Fix handling of fw_devlink=permissive
    
    When commit 8375e74f2bca ("driver core: Add fw_devlink kernel
    commandline option") added fw_devlink, it didn't implement "permissive"
    mode correctly.
    
    That commit got the device links flags correct to make sure unprobed
    suppliers don't block the probing of a consumer. However, if a consumer
    is waiting for mandatory suppliers to register, that could still block a
    consumer from probing.
    
    This commit fixes that by making sure in permissive mode, all suppliers
    to a consumer are treated as a optional suppliers. So, even if a
    consumer is waiting for suppliers to register and link itself (using the
    DL_FLAG_SYNC_STATE_ONLY flag) to the supplier, the consumer is never
    blocked from probing.
    
    Fixes: 8375e74f2bca ("driver core: Add fw_devlink kernel commandline option")
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200331022832.209618-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 139cdf7e7327..073045cb214e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2370,6 +2370,11 @@ u32 fw_devlink_get_flags(void)
 	return fw_devlink_flags;
 }
 
+static bool fw_devlink_is_permissive(void)
+{
+	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
+}
+
 /**
  * device_add - add device to device hierarchy.
  * @dev: device.
@@ -2524,7 +2529,7 @@ int device_add(struct device *dev)
 	if (fw_devlink_flags && is_fwnode_dev &&
 	    fwnode_has_op(dev->fwnode, add_links)) {
 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
-		if (fw_ret == -ENODEV)
+		if (fw_ret == -ENODEV && !fw_devlink_is_permissive())
 			device_link_wait_for_mandatory_supplier(dev);
 		else if (fw_ret)
 			device_link_wait_for_optional_supplier(dev);

commit 0c1bc6b84525b96aa9fb8f6fbe8c5cb26a5c0ead
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Tue Apr 14 18:48:37 2020 +0200

    docs: filesystems: fix renamed references
    
    Some filesystem references got broken by a previous patch
    series I submitted. Address those.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Acked-by: David Sterba <dsterba@suse.com> # fs/affs/Kconfig
    Link: https://lore.kernel.org/r/57318c53008dbda7f6f4a5a9e5787f4d37e8565a.1586881715.git.mchehab+huawei@kernel.org
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 139cdf7e7327..89fcc0a09f94 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1374,7 +1374,7 @@ static void device_release(struct kobject *kobj)
 	else if (dev->class && dev->class->dev_release)
 		dev->class->dev_release(dev);
 	else
-		WARN(1, KERN_ERR "Device '%s' does not have a release() function, it is broken and must be fixed. See Documentation/kobject.txt.\n",
+		WARN(1, KERN_ERR "Device '%s' does not have a release() function, it is broken and must be fixed. See Documentation/core-api/kobject.rst.\n",
 			dev_name(dev));
 	kfree(p);
 }

commit 96489ae170fb30b62f817c86c8e64b150b55a7ff
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 8 19:09:01 2020 +0300

    device property: export set_secondary_fwnode() to modules
    
    Some drivers when compiled as modules may need to set secondary firmware node.
    Export set_secondary_fwnode() to make it possible without code duplication.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 139cdf7e7327..ada037b3be45 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3891,6 +3891,7 @@ void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode)
 	else
 		dev->fwnode = fwnode;
 }
+EXPORT_SYMBOL_GPL(set_secondary_fwnode);
 
 /**
  * device_set_of_node_from_dev - reuse device-tree node of another device

commit 29d9f30d4ce6c7a38745a54a8cddface10013490
Merge: 56a451b78067 7f80ccfe9968
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 31 17:29:33 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next
    
    Pull networking updates from David Miller:
     "Highlights:
    
       1) Fix the iwlwifi regression, from Johannes Berg.
    
       2) Support BSS coloring and 802.11 encapsulation offloading in
          hardware, from John Crispin.
    
       3) Fix some potential Spectre issues in qtnfmac, from Sergey
          Matyukevich.
    
       4) Add TTL decrement action to openvswitch, from Matteo Croce.
    
       5) Allow paralleization through flow_action setup by not taking the
          RTNL mutex, from Vlad Buslov.
    
       6) A lot of zero-length array to flexible-array conversions, from
          Gustavo A. R. Silva.
    
       7) Align XDP statistics names across several drivers for consistency,
          from Lorenzo Bianconi.
    
       8) Add various pieces of infrastructure for offloading conntrack, and
          make use of it in mlx5 driver, from Paul Blakey.
    
       9) Allow using listening sockets in BPF sockmap, from Jakub Sitnicki.
    
      10) Lots of parallelization improvements during configuration changes
          in mlxsw driver, from Ido Schimmel.
    
      11) Add support to devlink for generic packet traps, which report
          packets dropped during ACL processing. And use them in mlxsw
          driver. From Jiri Pirko.
    
      12) Support bcmgenet on ACPI, from Jeremy Linton.
    
      13) Make BPF compatible with RT, from Thomas Gleixnet, Alexei
          Starovoitov, and your's truly.
    
      14) Support XDP meta-data in virtio_net, from Yuya Kusakabe.
    
      15) Fix sysfs permissions when network devices change namespaces, from
          Christian Brauner.
    
      16) Add a flags element to ethtool_ops so that drivers can more simply
          indicate which coalescing parameters they actually support, and
          therefore the generic layer can validate the user's ethtool
          request. Use this in all drivers, from Jakub Kicinski.
    
      17) Offload FIFO qdisc in mlxsw, from Petr Machata.
    
      18) Support UDP sockets in sockmap, from Lorenz Bauer.
    
      19) Fix stretch ACK bugs in several TCP congestion control modules,
          from Pengcheng Yang.
    
      20) Support virtual functiosn in octeontx2 driver, from Tomasz
          Duszynski.
    
      21) Add region operations for devlink and use it in ice driver to dump
          NVM contents, from Jacob Keller.
    
      22) Add support for hw offload of MACSEC, from Antoine Tenart.
    
      23) Add support for BPF programs that can be attached to LSM hooks,
          from KP Singh.
    
      24) Support for multiple paths, path managers, and counters in MPTCP.
          From Peter Krystad, Paolo Abeni, Florian Westphal, Davide Caratti,
          and others.
    
      25) More progress on adding the netlink interface to ethtool, from
          Michal Kubecek"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next: (2121 commits)
      net: ipv6: rpl_iptunnel: Fix potential memory leak in rpl_do_srh_inline
      cxgb4/chcr: nic-tls stats in ethtool
      net: dsa: fix oops while probing Marvell DSA switches
      net/bpfilter: remove superfluous testing message
      net: macb: Fix handling of fixed-link node
      net: dsa: ksz: Select KSZ protocol tag
      netdevsim: dev: Fix memory leak in nsim_dev_take_snapshot_write
      net: stmmac: add EHL 2.5Gbps PCI info and PCI ID
      net: stmmac: add EHL PSE0 & PSE1 1Gbps PCI info and PCI ID
      net: stmmac: create dwmac-intel.c to contain all Intel platform
      net: dsa: bcm_sf2: Support specifying VLAN tag egress rule
      net: dsa: bcm_sf2: Add support for matching VLAN TCI
      net: dsa: bcm_sf2: Move writing of CFP_DATA(5) into slicing functions
      net: dsa: bcm_sf2: Check earlier for FLOW_EXT and FLOW_MAC_EXT
      net: dsa: bcm_sf2: Disable learning for ASP port
      net: dsa: b53: Deny enslaving port 7 for 7278 into a bridge
      net: dsa: b53: Prevent tagged VLAN on port 7 for 7278
      net: dsa: b53: Restore VLAN entries upon (re)configuration
      net: dsa: bcm_sf2: Fix overflow checks
      hv_netvsc: Remove unnecessary round_up for recv_completion_cnt
      ...

commit 18555cb6db2373b9a5ec1f7572773fd58c77f9ba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Mar 27 16:17:30 2020 +0100

    Revert "driver core: Set fw_devlink to "permissive" behavior by default"
    
    This reverts commit c442a0d18744d4a5857d513f171d68ed6a54df5b as it
    breaks some of the Raspberry Pi devices.  Marek writes:
            This patch has just landed in linux-next 20200326. Sadly it
            breaks booting of the Raspberry Pi3b and Pi4 boards, either in
            32bit or 64bit mode. There is no warning nor panic message, just
            a silent freeze. The last message shown on the earlycon is:
    
            [    0.893217] Serial: 8250/16550 driver, 1 ports, IRQ sharing enabled
    
    so revert it for now and let's try again and add it to linux-next after
    5.7-rc1 is out so that we can try to get more debugging/testing
    happening.
    
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9fabf9749a06..5e3cc1651c78 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2345,7 +2345,7 @@ static int device_private_init(struct device *dev)
 	return 0;
 }
 
-static u32 fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
+static u32 fw_devlink_flags;
 static int __init fw_devlink_setup(char *arg)
 {
 	if (!arg)

commit c442a0d18744d4a5857d513f171d68ed6a54df5b
Author: Saravana Kannan <saravanak@google.com>
Date:   Sat Mar 21 14:03:05 2020 -0700

    driver core: Set fw_devlink to "permissive" behavior by default
    
    Set fw_devlink to "permissive" behavior by default so that device links
    are automatically created (with DL_FLAG_SYNC_STATE_ONLY) by scanning the
    firmware.
    
    This ensures suppliers get their sync_state() calls only after all their
    consumers have probed successfully. Without this, suppliers will get
    their sync_state() calls at late_initcall_sync() even if their consuer
    
    Ideally, we'd want to set fw_devlink to "on" or "rpm" by default. But
    that needs more testing as it's known to break some corner case
    drivers/platforms.
    
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200321210305.28937-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 5e3cc1651c78..9fabf9749a06 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2345,7 +2345,7 @@ static int device_private_init(struct device *dev)
 	return 0;
 }
 
-static u32 fw_devlink_flags;
+static u32 fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
 static int __init fw_devlink_setup(char *arg)
 {
 	if (!arg)

commit 4dbe191c046e71d6ea1ba85365ecb33961b07c4f
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Mar 20 21:54:48 2020 -0700

    driver core: Add device links from fwnode only for the primary device
    
    Sometimes, more than one (generally two) device can point to the same
    fwnode.  However, only one device is set as the fwnode's device
    (fwnode->dev) and can be looked up from the fwnode.
    
    Typically, only one of these devices actually have a driver and actually
    probe. If we create device links for all these devices, then the
    suppliers' of these devices (with the same fwnode) will never get a
    sync_state() call because one of their consumer devices will never probe
    (because they don't have a driver).
    
    So, create device links only for the device that is considered as the
    fwnode's device.
    
    One such example of this is the PCI bridge platform_device and the
    corresponding pci_bus device. Both these devices will have the same
    fwnode. It's the platform_device that is registered first and is set as
    the fwnode's device. Also the platform_device is the one that actually
    probes. Without this patch none of the suppliers of a PCI bridge
    platform_device would get a sync_state() callback.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: linux-pci@vger.kernel.org
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200321045448.15192-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fc6a60998cd6..5e3cc1651c78 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2404,6 +2404,7 @@ int device_add(struct device *dev)
 	struct class_interface *class_intf;
 	int error = -EINVAL, fw_ret;
 	struct kobject *glue_dir = NULL;
+	bool is_fwnode_dev = false;
 
 	dev = get_device(dev);
 	if (!dev)
@@ -2501,8 +2502,10 @@ int device_add(struct device *dev)
 
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 
-	if (dev->fwnode && !dev->fwnode->dev)
+	if (dev->fwnode && !dev->fwnode->dev) {
 		dev->fwnode->dev = dev;
+		is_fwnode_dev = true;
+	}
 
 	/*
 	 * Check if any of the other devices (consumers) have been waiting for
@@ -2518,7 +2521,8 @@ int device_add(struct device *dev)
 	 */
 	device_link_add_missing_supplier_links();
 
-	if (fw_devlink_flags && fwnode_has_op(dev->fwnode, add_links)) {
+	if (fw_devlink_flags && is_fwnode_dev &&
+	    fwnode_has_op(dev->fwnode, add_links)) {
 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
 		if (fw_ret == -ENODEV)
 			device_link_wait_for_mandatory_supplier(dev);

commit 1d343579312311aa9875b34d5a921f5e2ec69f0a
Merge: a8eceea84a3a 0d81a3f29c0a
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Mar 12 21:29:30 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Minor overlapping changes, nothing serious.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 9a2dd570591ea1d53284208ab8838c0ab2a08340
Merge: 9211f0a6a91a 2c523b344dfa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 9 08:41:53 2020 +0100

    Merge 5.6-rc5 into driver-core-next
    
    We need the driver core and debugfs changes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9211f0a6a91ada1ee28b3fb5f30d79c8a67c73b1
Author: kbuild test robot <lkp@intel.com>
Date:   Thu Mar 5 10:09:24 2020 +0800

    driver core: fw_devlink_flags can be static
    
    Fixes: 8375e74f2bca ("driver core: Add fw_devlink kernel commandline option")
    Signed-off-by: kbuild test robot <lkp@intel.com>
    Acked-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200305020916.GA14234@3143ef58ba07
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 26acb92aa966..cd78a001d719 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2332,7 +2332,7 @@ static int device_private_init(struct device *dev)
 	return 0;
 }
 
-u32 fw_devlink_flags;
+static u32 fw_devlink_flags;
 static int __init fw_devlink_setup(char *arg)
 {
 	if (!arg)

commit 68464d79015a1bbb41872a9119a07b2cb151a4b9
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Fri Feb 14 20:47:29 2020 +0000

    driver core: Add missing annotation for device_links_write_lock()
    
    Sparse reports a warning at device_links_write_lock()
    
    warning: context imbalance in evice_links_write_lock()
             - wrong count at exit
    
    The root cause is the missing annotation at device_links_write_lock()
    Add the missing __acquires(&device_links_srcu) annotation
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20200214204741.94112-19-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ae6804da67b2..26acb92aa966 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -64,7 +64,7 @@ static inline void device_links_write_unlock(void)
 	mutex_unlock(&device_links_lock);
 }
 
-int device_links_read_lock(void)
+int device_links_read_lock(void) __acquires(&device_links_srcu)
 {
 	return srcu_read_lock(&device_links_srcu);
 }

commit ab7789c5174cb12c9f9fb4f85efc6d18e7f04c2b
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Fri Feb 14 20:47:30 2020 +0000

    driver core: Add missing annotation for device_links_read_lock()
    
    Sparse reports a warning at device_links_read_unlock()
    
    warning:  warning: context imbalance in device_links_read_unlock()
             - unexpected unlock
    
    The root cause is the missing annotation at device_links_read_unlock()
    Add the missing __releases(&device_links_srcu) annotation
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20200214204741.94112-20-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 922680af9051..ae6804da67b2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -69,7 +69,7 @@ int device_links_read_lock(void)
 	return srcu_read_lock(&device_links_srcu);
 }
 
-void device_links_read_unlock(int idx)
+void device_links_read_unlock(int idx) __releases(&device_links_srcu)
 {
 	srcu_read_unlock(&device_links_srcu, idx);
 }

commit 8375e74f2bca9802a4ddf431a6d7bd2ab9950f27
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 17:40:35 2020 -0800

    driver core: Add fw_devlink kernel commandline option
    
    fwnode_operations.add_links allows creating device links from
    information provided by firmware.
    
    fwnode_operations.add_links is currently implemented only by
    OF/devicetree code and a specific case of efi. However, there's nothing
    preventing ACPI or other firmware types from implementing it.
    
    The OF implementation is currently controlled by a kernel commandline
    parameter called of_devlink.
    
    Since this feature is generic isn't limited to OF, add a generic
    fw_devlink kernel commandline parameter to control this feature across
    firmware types.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200222014038.180923-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 79863354c801..922680af9051 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2332,6 +2332,31 @@ static int device_private_init(struct device *dev)
 	return 0;
 }
 
+u32 fw_devlink_flags;
+static int __init fw_devlink_setup(char *arg)
+{
+	if (!arg)
+		return -EINVAL;
+
+	if (strcmp(arg, "off") == 0) {
+		fw_devlink_flags = 0;
+	} else if (strcmp(arg, "permissive") == 0) {
+		fw_devlink_flags = DL_FLAG_SYNC_STATE_ONLY;
+	} else if (strcmp(arg, "on") == 0) {
+		fw_devlink_flags = DL_FLAG_AUTOPROBE_CONSUMER;
+	} else if (strcmp(arg, "rpm") == 0) {
+		fw_devlink_flags = DL_FLAG_AUTOPROBE_CONSUMER |
+				   DL_FLAG_PM_RUNTIME;
+	}
+	return 0;
+}
+early_param("fw_devlink", fw_devlink_setup);
+
+u32 fw_devlink_get_flags(void)
+{
+	return fw_devlink_flags;
+}
+
 /**
  * device_add - add device to device hierarchy.
  * @dev: device.
@@ -2480,7 +2505,7 @@ int device_add(struct device *dev)
 	 */
 	device_link_add_missing_supplier_links();
 
-	if (fwnode_has_op(dev->fwnode, add_links)) {
+	if (fw_devlink_flags && fwnode_has_op(dev->fwnode, add_links)) {
 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
 		if (fw_ret == -ENODEV)
 			device_link_wait_for_mandatory_supplier(dev);

commit 1745d299af5b373abad08fa29bff0d31dc6aff21
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 17:40:34 2020 -0800

    driver core: Reevaluate dev->links.need_for_probe as suppliers are added
    
    A previous patch 03324507e66c ("driver core: Allow
    fwnode_operations.add_links to differentiate errors") forgot to update
    all call sites to fwnode_operations.add_links. This patch fixes that.
    
    Legend:
    -> Denotes RHS is an optional/potential supplier for LHS
    => Denotes RHS is a mandatory supplier for LHS
    
    Example:
    
    Device A => Device X
    Device A -> Device Y
    
    Before this patch:
    1. Device A is added.
    2. Device A is marked as waiting for mandatory suppliers
    3. Device X is added
    4. Device A is left marked as waiting for mandatory suppliers
    
    Step 4 is wrong since all mandatory suppliers of Device A have been
    added.
    
    After this patch:
    1. Device A is added.
    2. Device A is marked as waiting for mandatory suppliers
    3. Device X is added
    4. Device A is no longer considered as waiting for mandatory suppliers
    
    This is the correct behavior.
    
    Fixes: 03324507e66c ("driver core: Allow fwnode_operations.add_links to differentiate errors")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200222014038.180923-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 42a672456432..79863354c801 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -523,9 +523,13 @@ static void device_link_add_missing_supplier_links(void)
 
 	mutex_lock(&wfs_lock);
 	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
-				 links.needs_suppliers)
-		if (!fwnode_call_int_op(dev->fwnode, add_links, dev))
+				 links.needs_suppliers) {
+		int ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+		if (!ret)
 			list_del_init(&dev->links.needs_suppliers);
+		else if (ret != -ENODEV)
+			dev->links.need_for_probe = false;
+	}
 	mutex_unlock(&wfs_lock);
 }
 

commit 77036165d8bcf7c7b2a2df28a601ec2c52bb172d
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 00:05:10 2020 -0800

    driver core: Skip unnecessary work when device doesn't have sync_state()
    
    A bunch of busy work is done for devices that don't have sync_state()
    support. Stop doing the busy work.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200221080510.197337-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 3306d5ae92a6..dbb0f9130f42 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -718,6 +718,8 @@ static void __device_links_queue_sync_state(struct device *dev,
 {
 	struct device_link *link;
 
+	if (!dev_has_sync_state(dev))
+		return;
 	if (dev->state_synced)
 		return;
 
@@ -819,7 +821,7 @@ late_initcall(sync_state_resume_initcall);
 
 static void __device_links_supplier_defer_sync(struct device *sup)
 {
-	if (list_empty(&sup->links.defer_sync))
+	if (list_empty(&sup->links.defer_sync) && dev_has_sync_state(sup))
 		list_add_tail(&sup->links.defer_sync, &deferred_sync);
 }
 

commit 21eb93f432b1a785df193df1a56a59e9eb3a985f
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 00:05:08 2020 -0800

    driver core: Call sync_state() even if supplier has no consumers
    
    The initial patch that added sync_state() support didn't handle the case
    where a supplier has no consumers. This was because when a device is
    successfully bound with a driver, only its suppliers were checked to see
    if they are eligible to get a sync_state(). This is not sufficient for
    devices that have no consumers but still need to do device state clean
    up. So fix this.
    
    Fixes: fc5a251d0fd7ca90 (driver core: Add sync_state driver/bus callback)
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200221080510.197337-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 42a672456432..3306d5ae92a6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -745,25 +745,31 @@ static void __device_links_queue_sync_state(struct device *dev,
 /**
  * device_links_flush_sync_list - Call sync_state() on a list of devices
  * @list: List of devices to call sync_state() on
+ * @dont_lock_dev: Device for which lock is already held by the caller
  *
  * Calls sync_state() on all the devices that have been queued for it. This
- * function is used in conjunction with __device_links_queue_sync_state().
+ * function is used in conjunction with __device_links_queue_sync_state(). The
+ * @dont_lock_dev parameter is useful when this function is called from a
+ * context where a device lock is already held.
  */
-static void device_links_flush_sync_list(struct list_head *list)
+static void device_links_flush_sync_list(struct list_head *list,
+					 struct device *dont_lock_dev)
 {
 	struct device *dev, *tmp;
 
 	list_for_each_entry_safe(dev, tmp, list, links.defer_sync) {
 		list_del_init(&dev->links.defer_sync);
 
-		device_lock(dev);
+		if (dev != dont_lock_dev)
+			device_lock(dev);
 
 		if (dev->bus->sync_state)
 			dev->bus->sync_state(dev);
 		else if (dev->driver && dev->driver->sync_state)
 			dev->driver->sync_state(dev);
 
-		device_unlock(dev);
+		if (dev != dont_lock_dev)
+			device_unlock(dev);
 
 		put_device(dev);
 	}
@@ -801,7 +807,7 @@ void device_links_supplier_sync_state_resume(void)
 out:
 	device_links_write_unlock();
 
-	device_links_flush_sync_list(&sync_list);
+	device_links_flush_sync_list(&sync_list, NULL);
 }
 
 static int sync_state_resume_initcall(void)
@@ -865,6 +871,11 @@ void device_links_driver_bound(struct device *dev)
 			driver_deferred_probe_add(link->consumer);
 	}
 
+	if (defer_sync_state_count)
+		__device_links_supplier_defer_sync(dev);
+	else
+		__device_links_queue_sync_state(dev, &sync_list);
+
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
 		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
@@ -883,7 +894,7 @@ void device_links_driver_bound(struct device *dev)
 
 	device_links_write_unlock();
 
-	device_links_flush_sync_list(&sync_list);
+	device_links_flush_sync_list(&sync_list, dev);
 }
 
 static void device_link_drop_managed(struct device_link *link)

commit 3b52fc5d7876a312e6a964d7e626ba05ab1ea6b2
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Thu Feb 27 04:37:16 2020 +0100

    drivers/base/power: add dpm_sysfs_change_owner()
    
    Add a helper to change the owner of a device's power entries. This
    needs to happen when the ownership of a device is changed, e.g. when
    moving network devices between network namespaces.
    This function will be used to correctly account for ownership changes,
    e.g. when moving network devices between network namespaces.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 988f34ce2eb0..fb8b7990f6fd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3552,6 +3552,10 @@ int device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid)
 	if (error)
 		goto out;
 
+	error = dpm_sysfs_change_owner(dev, kuid, kgid);
+	if (error)
+		goto out;
+
 #ifdef CONFIG_BLOCK
 	if (sysfs_deprecated && dev->class == &block_class)
 		goto out;

commit b8f33e5d76a7a1b87e0cc760d05bf2477b4e91d6
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Thu Feb 27 04:37:15 2020 +0100

    device: add device_change_owner()
    
    Add a helper to change the owner of a device's sysfs entries. This
    needs to happen when the ownership of a device is changed, e.g. when
    moving network devices between network namespaces.
    This function will be used to correctly account for ownership changes,
    e.g. when moving network devices between network namespaces.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 42a672456432..988f34ce2eb0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3458,6 +3458,122 @@ int device_move(struct device *dev, struct device *new_parent,
 }
 EXPORT_SYMBOL_GPL(device_move);
 
+static int device_attrs_change_owner(struct device *dev, kuid_t kuid,
+				     kgid_t kgid)
+{
+	struct kobject *kobj = &dev->kobj;
+	struct class *class = dev->class;
+	const struct device_type *type = dev->type;
+	int error;
+
+	if (class) {
+		/*
+		 * Change the device groups of the device class for @dev to
+		 * @kuid/@kgid.
+		 */
+		error = sysfs_groups_change_owner(kobj, class->dev_groups, kuid,
+						  kgid);
+		if (error)
+			return error;
+	}
+
+	if (type) {
+		/*
+		 * Change the device groups of the device type for @dev to
+		 * @kuid/@kgid.
+		 */
+		error = sysfs_groups_change_owner(kobj, type->groups, kuid,
+						  kgid);
+		if (error)
+			return error;
+	}
+
+	/* Change the device groups of @dev to @kuid/@kgid. */
+	error = sysfs_groups_change_owner(kobj, dev->groups, kuid, kgid);
+	if (error)
+		return error;
+
+	if (device_supports_offline(dev) && !dev->offline_disabled) {
+		/* Change online device attributes of @dev to @kuid/@kgid. */
+		error = sysfs_file_change_owner(kobj, dev_attr_online.attr.name,
+						kuid, kgid);
+		if (error)
+			return error;
+	}
+
+	return 0;
+}
+
+/**
+ * device_change_owner - change the owner of an existing device.
+ * @dev: device.
+ * @kuid: new owner's kuid
+ * @kgid: new owner's kgid
+ *
+ * This changes the owner of @dev and its corresponding sysfs entries to
+ * @kuid/@kgid. This function closely mirrors how @dev was added via driver
+ * core.
+ *
+ * Returns 0 on success or error code on failure.
+ */
+int device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid)
+{
+	int error;
+	struct kobject *kobj = &dev->kobj;
+
+	dev = get_device(dev);
+	if (!dev)
+		return -EINVAL;
+
+	/*
+	 * Change the kobject and the default attributes and groups of the
+	 * ktype associated with it to @kuid/@kgid.
+	 */
+	error = sysfs_change_owner(kobj, kuid, kgid);
+	if (error)
+		goto out;
+
+	/*
+	 * Change the uevent file for @dev to the new owner. The uevent file
+	 * was created in a separate step when @dev got added and we mirror
+	 * that step here.
+	 */
+	error = sysfs_file_change_owner(kobj, dev_attr_uevent.attr.name, kuid,
+					kgid);
+	if (error)
+		goto out;
+
+	/*
+	 * Change the device groups, the device groups associated with the
+	 * device class, and the groups associated with the device type of @dev
+	 * to @kuid/@kgid.
+	 */
+	error = device_attrs_change_owner(dev, kuid, kgid);
+	if (error)
+		goto out;
+
+#ifdef CONFIG_BLOCK
+	if (sysfs_deprecated && dev->class == &block_class)
+		goto out;
+#endif
+
+	/*
+	 * Change the owner of the symlink located in the class directory of
+	 * the device class associated with @dev which points to the actual
+	 * directory entry for @dev to @kuid/@kgid. This ensures that the
+	 * symlink shows the same permissions as its target.
+	 */
+	error = sysfs_link_change_owner(&dev->class->p->subsys.kobj, &dev->kobj,
+					dev_name(dev), kuid, kgid);
+	if (error)
+		goto out;
+
+out:
+	put_device(dev);
+	return error;
+}
+EXPORT_SYMBOL_GPL(device_change_owner);
+
 /**
  * device_shutdown - call ->shutdown() on each device to shutdown.
  */

commit 26e77708fdc20ec6c24759602640ac42b8e4e88a
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu Nov 14 14:56:45 2019 -0800

    driver core: Allow device link operations inside sync_state()
    
    Some sync_state() implementations might need to call APIs that in turn
    make calls to device link APIs. So, do the sync_state() callbacks
    without holding the device link lock.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20191114225646.251277-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e6d3e6d485da..42a672456432 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -695,7 +695,26 @@ int device_links_check_suppliers(struct device *dev)
 	return ret;
 }
 
-static void __device_links_supplier_sync_state(struct device *dev)
+/**
+ * __device_links_queue_sync_state - Queue a device for sync_state() callback
+ * @dev: Device to call sync_state() on
+ * @list: List head to queue the @dev on
+ *
+ * Queues a device for a sync_state() callback when the device links write lock
+ * isn't held. This allows the sync_state() execution flow to use device links
+ * APIs.  The caller must ensure this function is called with
+ * device_links_write_lock() held.
+ *
+ * This function does a get_device() to make sure the device is not freed while
+ * on this list.
+ *
+ * So the caller must also ensure that device_links_flush_sync_list() is called
+ * as soon as the caller releases device_links_write_lock().  This is necessary
+ * to make sure the sync_state() is called in a timely fashion and the
+ * put_device() is called on this device.
+ */
+static void __device_links_queue_sync_state(struct device *dev,
+					    struct list_head *list)
 {
 	struct device_link *link;
 
@@ -709,12 +728,45 @@ static void __device_links_supplier_sync_state(struct device *dev)
 			return;
 	}
 
-	if (dev->bus->sync_state)
-		dev->bus->sync_state(dev);
-	else if (dev->driver && dev->driver->sync_state)
-		dev->driver->sync_state(dev);
-
+	/*
+	 * Set the flag here to avoid adding the same device to a list more
+	 * than once. This can happen if new consumers get added to the device
+	 * and probed before the list is flushed.
+	 */
 	dev->state_synced = true;
+
+	if (WARN_ON(!list_empty(&dev->links.defer_sync)))
+		return;
+
+	get_device(dev);
+	list_add_tail(&dev->links.defer_sync, list);
+}
+
+/**
+ * device_links_flush_sync_list - Call sync_state() on a list of devices
+ * @list: List of devices to call sync_state() on
+ *
+ * Calls sync_state() on all the devices that have been queued for it. This
+ * function is used in conjunction with __device_links_queue_sync_state().
+ */
+static void device_links_flush_sync_list(struct list_head *list)
+{
+	struct device *dev, *tmp;
+
+	list_for_each_entry_safe(dev, tmp, list, links.defer_sync) {
+		list_del_init(&dev->links.defer_sync);
+
+		device_lock(dev);
+
+		if (dev->bus->sync_state)
+			dev->bus->sync_state(dev);
+		else if (dev->driver && dev->driver->sync_state)
+			dev->driver->sync_state(dev);
+
+		device_unlock(dev);
+
+		put_device(dev);
+	}
 }
 
 void device_links_supplier_sync_state_pause(void)
@@ -727,6 +779,7 @@ void device_links_supplier_sync_state_pause(void)
 void device_links_supplier_sync_state_resume(void)
 {
 	struct device *dev, *tmp;
+	LIST_HEAD(sync_list);
 
 	device_links_write_lock();
 	if (!defer_sync_state_count) {
@@ -738,11 +791,17 @@ void device_links_supplier_sync_state_resume(void)
 		goto out;
 
 	list_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_sync) {
-		__device_links_supplier_sync_state(dev);
+		/*
+		 * Delete from deferred_sync list before queuing it to
+		 * sync_list because defer_sync is used for both lists.
+		 */
 		list_del_init(&dev->links.defer_sync);
+		__device_links_queue_sync_state(dev, &sync_list);
 	}
 out:
 	device_links_write_unlock();
+
+	device_links_flush_sync_list(&sync_list);
 }
 
 static int sync_state_resume_initcall(void)
@@ -772,6 +831,7 @@ static void __device_links_supplier_defer_sync(struct device *sup)
 void device_links_driver_bound(struct device *dev)
 {
 	struct device_link *link;
+	LIST_HEAD(sync_list);
 
 	/*
 	 * If a device probes successfully, it's expected to have created all
@@ -815,12 +875,15 @@ void device_links_driver_bound(struct device *dev)
 		if (defer_sync_state_count)
 			__device_links_supplier_defer_sync(link->supplier);
 		else
-			__device_links_supplier_sync_state(link->supplier);
+			__device_links_queue_sync_state(link->supplier,
+							&sync_list);
 	}
 
 	dev->links.status = DL_DEV_DRIVER_BOUND;
 
 	device_links_write_unlock();
+
+	device_links_flush_sync_list(&sync_list);
 }
 
 static void device_link_drop_managed(struct device_link *link)

commit 03324507e66c7664c754b1ef92c5c3be24c78aa2
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Oct 28 15:00:24 2019 -0700

    driver core: Allow fwnode_operations.add_links to differentiate errors
    
    When add_links() still has suppliers that it needs to link to in the
    future, this patch allows it to differentiate between suppliers that are
    needed for probing vs suppliers that are needed for sync_state()
    correctness.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191028220027.251605-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 48cd43a91ce6..e6d3e6d485da 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2297,7 +2297,7 @@ int device_add(struct device *dev)
 	struct device *parent;
 	struct kobject *kobj;
 	struct class_interface *class_intf;
-	int error = -EINVAL;
+	int error = -EINVAL, fw_ret;
 	struct kobject *glue_dir = NULL;
 
 	dev = get_device(dev);
@@ -2413,9 +2413,13 @@ int device_add(struct device *dev)
 	 */
 	device_link_add_missing_supplier_links();
 
-	if (fwnode_has_op(dev->fwnode, add_links)
-	    && fwnode_call_int_op(dev->fwnode, add_links, dev))
-		device_link_wait_for_mandatory_supplier(dev, true);
+	if (fwnode_has_op(dev->fwnode, add_links)) {
+		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+		if (fw_ret == -ENODEV)
+			device_link_wait_for_mandatory_supplier(dev);
+		else if (fw_ret)
+			device_link_wait_for_optional_supplier(dev);
+	}
 
 	bus_probe_device(dev);
 	if (parent)

commit bcbbcfd57247f4c2976055995e5760fb576aae1e
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Oct 28 15:00:23 2019 -0700

    driver core: Allow a device to wait on optional suppliers
    
    Before this change, if a device is waiting on suppliers, it's assumed
    that all those suppliers are needed for the device to probe
    successfully. This change allows marking a devices as waiting only on
    optional suppliers. This allows a device to wait on suppliers (and link
    to them as soon as they are available) without preventing the device
    from being probed.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191028220027.251605-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 17ed054c4132..48cd43a91ce6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -480,13 +480,25 @@ EXPORT_SYMBOL_GPL(device_link_add);
  * This function is NOT meant to be called from the probe function of the
  * consumer but rather from code that creates/adds the consumer device.
  */
-static void device_link_wait_for_supplier(struct device *consumer)
+static void device_link_wait_for_supplier(struct device *consumer,
+					  bool need_for_probe)
 {
 	mutex_lock(&wfs_lock);
 	list_add_tail(&consumer->links.needs_suppliers, &wait_for_suppliers);
+	consumer->links.need_for_probe = need_for_probe;
 	mutex_unlock(&wfs_lock);
 }
 
+static void device_link_wait_for_mandatory_supplier(struct device *consumer)
+{
+	device_link_wait_for_supplier(consumer, true);
+}
+
+static void device_link_wait_for_optional_supplier(struct device *consumer)
+{
+	device_link_wait_for_supplier(consumer, false);
+}
+
 /**
  * device_link_add_missing_supplier_links - Add links from consumer devices to
  *					    supplier devices, leaving any
@@ -656,7 +668,8 @@ int device_links_check_suppliers(struct device *dev)
 	 * probe.
 	 */
 	mutex_lock(&wfs_lock);
-	if (!list_empty(&dev->links.needs_suppliers)) {
+	if (!list_empty(&dev->links.needs_suppliers) &&
+	    dev->links.need_for_probe) {
 		mutex_unlock(&wfs_lock);
 		return -EPROBE_DEFER;
 	}
@@ -760,6 +773,15 @@ void device_links_driver_bound(struct device *dev)
 {
 	struct device_link *link;
 
+	/*
+	 * If a device probes successfully, it's expected to have created all
+	 * the device links it needs to or make new device links as it needs
+	 * them. So, it no longer needs to wait on any suppliers.
+	 */
+	mutex_lock(&wfs_lock);
+	list_del_init(&dev->links.needs_suppliers);
+	mutex_unlock(&wfs_lock);
+
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
@@ -2393,7 +2415,7 @@ int device_add(struct device *dev)
 
 	if (fwnode_has_op(dev->fwnode, add_links)
 	    && fwnode_call_int_op(dev->fwnode, add_links, dev))
-		device_link_wait_for_supplier(dev);
+		device_link_wait_for_mandatory_supplier(dev, true);
 
 	bus_probe_device(dev);
 	if (parent)

commit 05ef983e0d65a31b370a4e1b93c1efd490ae778f
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Oct 28 15:00:22 2019 -0700

    driver core: Add device link support for SYNC_STATE_ONLY flag
    
    Parent devices might need to create "proxy" device links from themselves
    to supplier devices to make sure the supplier devices don't get a
    sync_state() before the child consumer devices get a chance to add
    device links to the supplier devices.
    
    However, the parent device has no real dependency on the supplier device
    and probing, suspend/resume or runtime PM don't need to be affected by
    the supplier device.  To capture these cases, create a SYNC_STATE_ONLY
    device link flag that only affects sync_state() behavior and doesn't
    affect probing, suspend/resume or runtime PM.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191028220027.251605-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7ea665a97da2..17ed054c4132 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -131,6 +131,9 @@ static int device_is_dependent(struct device *dev, void *target)
 		return ret;
 
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (link->flags == (DL_FLAG_SYNC_STATE_ONLY | DL_FLAG_MANAGED))
+			continue;
+
 		if (link->consumer == target)
 			return 1;
 
@@ -200,8 +203,11 @@ static int device_reorder_to_tail(struct device *dev, void *not_used)
 		device_pm_move_last(dev);
 
 	device_for_each_child(dev, NULL, device_reorder_to_tail);
-	list_for_each_entry(link, &dev->links.consumers, s_node)
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (link->flags == (DL_FLAG_SYNC_STATE_ONLY | DL_FLAG_MANAGED))
+			continue;
 		device_reorder_to_tail(link->consumer, NULL);
+	}
 
 	return 0;
 }
@@ -228,7 +234,8 @@ void device_pm_move_to_tail(struct device *dev)
 
 #define DL_MANAGED_LINK_FLAGS (DL_FLAG_AUTOREMOVE_CONSUMER | \
 			       DL_FLAG_AUTOREMOVE_SUPPLIER | \
-			       DL_FLAG_AUTOPROBE_CONSUMER)
+			       DL_FLAG_AUTOPROBE_CONSUMER  | \
+			       DL_FLAG_SYNC_STATE_ONLY)
 
 #define DL_ADD_VALID_FLAGS (DL_MANAGED_LINK_FLAGS | DL_FLAG_STATELESS | \
 			    DL_FLAG_PM_RUNTIME | DL_FLAG_RPM_ACTIVE)
@@ -296,6 +303,8 @@ struct device_link *device_link_add(struct device *consumer,
 
 	if (!consumer || !supplier || flags & ~DL_ADD_VALID_FLAGS ||
 	    (flags & DL_FLAG_STATELESS && flags & DL_MANAGED_LINK_FLAGS) ||
+	    (flags & DL_FLAG_SYNC_STATE_ONLY &&
+	     flags != DL_FLAG_SYNC_STATE_ONLY) ||
 	    (flags & DL_FLAG_AUTOPROBE_CONSUMER &&
 	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER |
 		      DL_FLAG_AUTOREMOVE_SUPPLIER)))
@@ -316,11 +325,14 @@ struct device_link *device_link_add(struct device *consumer,
 
 	/*
 	 * If the supplier has not been fully registered yet or there is a
-	 * reverse dependency between the consumer and the supplier already in
-	 * the graph, return NULL.
+	 * reverse (non-SYNC_STATE_ONLY) dependency between the consumer and
+	 * the supplier already in the graph, return NULL. If the link is a
+	 * SYNC_STATE_ONLY link, we don't check for reverse dependencies
+	 * because it only affects sync_state() callbacks.
 	 */
 	if (!device_pm_initialized(supplier)
-	    || device_is_dependent(consumer, supplier)) {
+	    || (!(flags & DL_FLAG_SYNC_STATE_ONLY) &&
+		  device_is_dependent(consumer, supplier))) {
 		link = NULL;
 		goto out;
 	}
@@ -347,9 +359,14 @@ struct device_link *device_link_add(struct device *consumer,
 		}
 
 		if (flags & DL_FLAG_STATELESS) {
-			link->flags |= DL_FLAG_STATELESS;
 			kref_get(&link->kref);
-			goto out;
+			if (link->flags & DL_FLAG_SYNC_STATE_ONLY &&
+			    !(link->flags & DL_FLAG_STATELESS)) {
+				link->flags |= DL_FLAG_STATELESS;
+				goto reorder;
+			} else {
+				goto out;
+			}
 		}
 
 		/*
@@ -371,6 +388,12 @@ struct device_link *device_link_add(struct device *consumer,
 			link->flags |= DL_FLAG_MANAGED;
 			device_link_init_status(link, consumer, supplier);
 		}
+		if (link->flags & DL_FLAG_SYNC_STATE_ONLY &&
+		    !(flags & DL_FLAG_SYNC_STATE_ONLY)) {
+			link->flags &= ~DL_FLAG_SYNC_STATE_ONLY;
+			goto reorder;
+		}
+
 		goto out;
 	}
 
@@ -410,6 +433,13 @@ struct device_link *device_link_add(struct device *consumer,
 	    flags & DL_FLAG_PM_RUNTIME)
 		pm_runtime_resume(supplier);
 
+	if (flags & DL_FLAG_SYNC_STATE_ONLY) {
+		dev_dbg(consumer,
+			"Linked as a sync state only consumer to %s\n",
+			dev_name(supplier));
+		goto out;
+	}
+reorder:
 	/*
 	 * Move the consumer and all of the devices depending on it to the end
 	 * of dpm_list and the devices_kset list.
@@ -635,7 +665,8 @@ int device_links_check_suppliers(struct device *dev)
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
-		if (!(link->flags & DL_FLAG_MANAGED))
+		if (!(link->flags & DL_FLAG_MANAGED) ||
+		    link->flags & DL_FLAG_SYNC_STATE_ONLY)
 			continue;
 
 		if (link->status != DL_STATE_AVAILABLE) {
@@ -949,7 +980,8 @@ void device_links_unbind_consumers(struct device *dev)
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
 		enum device_link_state status;
 
-		if (!(link->flags & DL_FLAG_MANAGED))
+		if (!(link->flags & DL_FLAG_MANAGED) ||
+		    link->flags & DL_FLAG_SYNC_STATE_ONLY)
 			continue;
 
 		status = link->status;

commit 8f677bc819e7a74cf10e30daf06e8b151d1e6a94
Merge: a3caeb8ffe5d d6d5df1db6e9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 27 18:54:13 2019 +0100

    Merge 5.4-rc5 into driver-core-next
    
    We want the sysfs fix in here as well to build on top of.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 65650b35133ff20f0c9ef0abd5c3c66dbce3ae57
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 9 01:29:10 2019 +0200

    cpufreq: Avoid cpufreq_suspend() deadlock on system shutdown
    
    It is incorrect to set the cpufreq syscore shutdown callback pointer
    to cpufreq_suspend(), because that function cannot be run in the
    syscore stage of system shutdown for two reasons: (a) it may attempt
    to carry out actions depending on devices that have already been shut
    down at that point and (b) the RCU synchronization carried out by it
    may not be able to make progress then.
    
    The latter issue has been present since commit 45975c7d21a1 ("rcu:
    Define RCU-sched API in terms of RCU for Tree RCU PREEMPT builds"),
    but the former one has been there since commit 90de2a4aa9f3 ("cpufreq:
    suspend cpufreq governors on shutdown") regardless.
    
    Fix that by dropping cpufreq_syscore_ops altogether and making
    device_shutdown() call cpufreq_suspend() directly before shutting
    down devices, which is along the lines of what system-wide power
    management does.
    
    Fixes: 45975c7d21a1 ("rcu: Define RCU-sched API in terms of RCU for Tree RCU PREEMPT builds")
    Fixes: 90de2a4aa9f3 ("cpufreq: suspend cpufreq governors on shutdown")
    Reported-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Tested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 4.0+ <stable@vger.kernel.org> # 4.0+

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2db62d98e395..7bd9cd366d41 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -9,6 +9,7 @@
  */
 
 #include <linux/acpi.h>
+#include <linux/cpufreq.h>
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/fwnode.h>
@@ -3179,6 +3180,8 @@ void device_shutdown(void)
 	wait_for_device_probe();
 	device_block_probing();
 
+	cpufreq_suspend();
+
 	spin_lock(&devices_kset->list_lock);
 	/*
 	 * Walk the devices list backward, shutting down each in turn.

commit fc5a251d0fd7ca9038bab78a8c97932c8c6ca23b
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Sep 4 14:11:23 2019 -0700

    driver core: Add sync_state driver/bus callback
    
    This sync_state driver/bus callback is called once all the consumers
    of a supplier have probed successfully.
    
    This allows the supplier device's driver/bus to sync the supplier
    device's state to the software state with the guarantee that all the
    consumers are actively managing the resources provided by the supplier
    device.
    
    To maintain backwards compatibility and ease transition from existing
    frameworks and resource cleanup schemes, late_initcall_sync is the
    earliest when the sync_state callback might be called.
    
    There is no upper bound on the time by which the sync_state callback
    has to be called. This is because if a consumer device never probes,
    the supplier has to maintain its resources in the state left by the
    bootloader. For example, if the bootloader leaves the display
    backlight at a fixed voltage and the backlight driver is never probed,
    you don't want the backlight to ever be turned off after boot up.
    
    Also, when multiple devices are added after kernel init, some
    suppliers could be added before their consumer devices get added. In
    these instances, the supplier devices could get their sync_state
    callback called right after they probe because the consumers devices
    haven't had a chance to create device links to the suppliers.
    
    To handle this correctly, this change also provides APIs to
    pause/resume sync state callbacks so that when multiple devices are
    added, their sync_state callback evaluation can be postponed to happen
    after all of them are added.
    
    kbuild test robot reported missing documentation for device.state_synced
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190904211126.47518-5-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b3896da73b3d..acbf0b1414ab 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -46,6 +46,8 @@ early_param("sysfs.deprecated", sysfs_deprecated_setup);
 /* Device links support. */
 static LIST_HEAD(wait_for_suppliers);
 static DEFINE_MUTEX(wfs_lock);
+static LIST_HEAD(deferred_sync);
+static unsigned int defer_sync_state_count = 1;
 
 #ifdef CONFIG_SRCU
 static DEFINE_MUTEX(device_links_lock);
@@ -648,6 +650,69 @@ int device_links_check_suppliers(struct device *dev)
 	return ret;
 }
 
+static void __device_links_supplier_sync_state(struct device *dev)
+{
+	struct device_link *link;
+
+	if (dev->state_synced)
+		return;
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (!(link->flags & DL_FLAG_MANAGED))
+			continue;
+		if (link->status != DL_STATE_ACTIVE)
+			return;
+	}
+
+	if (dev->bus->sync_state)
+		dev->bus->sync_state(dev);
+	else if (dev->driver && dev->driver->sync_state)
+		dev->driver->sync_state(dev);
+
+	dev->state_synced = true;
+}
+
+void device_links_supplier_sync_state_pause(void)
+{
+	device_links_write_lock();
+	defer_sync_state_count++;
+	device_links_write_unlock();
+}
+
+void device_links_supplier_sync_state_resume(void)
+{
+	struct device *dev, *tmp;
+
+	device_links_write_lock();
+	if (!defer_sync_state_count) {
+		WARN(true, "Unmatched sync_state pause/resume!");
+		goto out;
+	}
+	defer_sync_state_count--;
+	if (defer_sync_state_count)
+		goto out;
+
+	list_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_sync) {
+		__device_links_supplier_sync_state(dev);
+		list_del_init(&dev->links.defer_sync);
+	}
+out:
+	device_links_write_unlock();
+}
+
+static int sync_state_resume_initcall(void)
+{
+	device_links_supplier_sync_state_resume();
+	return 0;
+}
+late_initcall(sync_state_resume_initcall);
+
+static void __device_links_supplier_defer_sync(struct device *sup)
+{
+	if (list_empty(&sup->links.defer_sync))
+		list_add_tail(&sup->links.defer_sync, &deferred_sync);
+}
+
 /**
  * device_links_driver_bound - Update device links after probing its driver.
  * @dev: Device to update the links for.
@@ -692,6 +757,11 @@ void device_links_driver_bound(struct device *dev)
 
 		WARN_ON(link->status != DL_STATE_CONSUMER_PROBE);
 		WRITE_ONCE(link->status, DL_STATE_ACTIVE);
+
+		if (defer_sync_state_count)
+			__device_links_supplier_defer_sync(link->supplier);
+		else
+			__device_links_supplier_sync_state(link->supplier);
 	}
 
 	dev->links.status = DL_DEV_DRIVER_BOUND;
@@ -808,6 +878,7 @@ void device_links_driver_cleanup(struct device *dev)
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}
 
+	list_del_init(&dev->links.defer_sync);
 	__device_links_no_driver(dev);
 
 	device_links_write_unlock();
@@ -1782,6 +1853,7 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->links.consumers);
 	INIT_LIST_HEAD(&dev->links.suppliers);
 	INIT_LIST_HEAD(&dev->links.needs_suppliers);
+	INIT_LIST_HEAD(&dev->links.defer_sync);
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);

commit e2ae9bcc4aaacda04edb75c4eea93384719efaa5
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Sep 4 14:11:21 2019 -0700

    driver core: Add support for linking devices during device addition
    
    The firmware corresponding to a device (dev.fwnode) might be able to
    provide functional dependency information between a device and its
    supplier and consumer devices.  Tracking this functional dependency
    allows optimizing device probe order and informing a supplier when all
    its consumers have probed (and thereby actively managing their
    resources).
    
    The existing device links feature allows tracking and using
    supplier-consumer relationships. So, this patch adds the add_links()
    fwnode callback to allow firmware to create device links for each
    device as the device is added.
    
    However, when consumer devices are added, they might not have a supplier
    device to link to despite needing mandatory resources/functionality from
    one or more suppliers. A waiting_for_suppliers list is created to track
    such consumers and retry linking them when new devices get added.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190904211126.47518-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 510fabf8918c..b3896da73b3d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -44,6 +44,8 @@ early_param("sysfs.deprecated", sysfs_deprecated_setup);
 #endif
 
 /* Device links support. */
+static LIST_HEAD(wait_for_suppliers);
+static DEFINE_MUTEX(wfs_lock);
 
 #ifdef CONFIG_SRCU
 static DEFINE_MUTEX(device_links_lock);
@@ -430,6 +432,58 @@ struct device_link *device_link_add(struct device *consumer,
 }
 EXPORT_SYMBOL_GPL(device_link_add);
 
+/**
+ * device_link_wait_for_supplier - Add device to wait_for_suppliers list
+ * @consumer: Consumer device
+ *
+ * Marks the @consumer device as waiting for suppliers to become available by
+ * adding it to the wait_for_suppliers list. The consumer device will never be
+ * probed until it's removed from the wait_for_suppliers list.
+ *
+ * The caller is responsible for adding the links to the supplier devices once
+ * they are available and removing the @consumer device from the
+ * wait_for_suppliers list once links to all the suppliers have been created.
+ *
+ * This function is NOT meant to be called from the probe function of the
+ * consumer but rather from code that creates/adds the consumer device.
+ */
+static void device_link_wait_for_supplier(struct device *consumer)
+{
+	mutex_lock(&wfs_lock);
+	list_add_tail(&consumer->links.needs_suppliers, &wait_for_suppliers);
+	mutex_unlock(&wfs_lock);
+}
+
+/**
+ * device_link_add_missing_supplier_links - Add links from consumer devices to
+ *					    supplier devices, leaving any
+ *					    consumer with inactive suppliers on
+ *					    the wait_for_suppliers list
+ *
+ * Loops through all consumers waiting on suppliers and tries to add all their
+ * supplier links. If that succeeds, the consumer device is removed from
+ * wait_for_suppliers list. Otherwise, they are left in the wait_for_suppliers
+ * list.  Devices left on the wait_for_suppliers list will not be probed.
+ *
+ * The fwnode add_links callback is expected to return 0 if it has found and
+ * added all the supplier links for the consumer device. It should return an
+ * error if it isn't able to do so.
+ *
+ * The caller of device_link_wait_for_supplier() is expected to call this once
+ * it's aware of potential suppliers becoming available.
+ */
+static void device_link_add_missing_supplier_links(void)
+{
+	struct device *dev, *tmp;
+
+	mutex_lock(&wfs_lock);
+	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
+				 links.needs_suppliers)
+		if (!fwnode_call_int_op(dev->fwnode, add_links, dev))
+			list_del_init(&dev->links.needs_suppliers);
+	mutex_unlock(&wfs_lock);
+}
+
 static void device_link_free(struct device_link *link)
 {
 	while (refcount_dec_not_one(&link->rpm_active))
@@ -564,6 +618,17 @@ int device_links_check_suppliers(struct device *dev)
 	struct device_link *link;
 	int ret = 0;
 
+	/*
+	 * Device waiting for supplier to become available is not allowed to
+	 * probe.
+	 */
+	mutex_lock(&wfs_lock);
+	if (!list_empty(&dev->links.needs_suppliers)) {
+		mutex_unlock(&wfs_lock);
+		return -EPROBE_DEFER;
+	}
+	mutex_unlock(&wfs_lock);
+
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
@@ -848,6 +913,10 @@ static void device_links_purge(struct device *dev)
 {
 	struct device_link *link, *ln;
 
+	mutex_lock(&wfs_lock);
+	list_del(&dev->links.needs_suppliers);
+	mutex_unlock(&wfs_lock);
+
 	/*
 	 * Delete all of the remaining links from this device to any other
 	 * devices (either consumers or suppliers).
@@ -1712,6 +1781,7 @@ void device_initialize(struct device *dev)
 #endif
 	INIT_LIST_HEAD(&dev->links.consumers);
 	INIT_LIST_HEAD(&dev->links.suppliers);
+	INIT_LIST_HEAD(&dev->links.needs_suppliers);
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);
@@ -2202,6 +2272,24 @@ int device_add(struct device *dev)
 	if (dev->fwnode && !dev->fwnode->dev)
 		dev->fwnode->dev = dev;
 
+	/*
+	 * Check if any of the other devices (consumers) have been waiting for
+	 * this device (supplier) to be added so that they can create a device
+	 * link to it.
+	 *
+	 * This needs to happen after device_pm_add() because device_link_add()
+	 * requires the supplier be registered before it's called.
+	 *
+	 * But this also needs to happe before bus_probe_device() to make sure
+	 * waiting consumers can link to it before the driver is bound to the
+	 * device and the driver sync_state callback is called for this device.
+	 */
+	device_link_add_missing_supplier_links();
+
+	if (fwnode_has_op(dev->fwnode, add_links)
+	    && fwnode_call_int_op(dev->fwnode, add_links, dev))
+		device_link_wait_for_supplier(dev);
+
 	bus_probe_device(dev);
 	if (parent)
 		klist_add_tail(&dev->p->knode_parent,

commit 372a67c0c5ef63f55bd1eb480d9555328d8ec0f2
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Sep 4 14:11:20 2019 -0700

    driver core: Add fwnode_to_dev() to look up device from fwnode
    
    It's often useful to look up a device that corresponds to a fwnode. So
    add an API to do that irrespective of the bus on which the device has
    been added to.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190904211126.47518-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2db62d98e395..510fabf8918c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2198,6 +2198,10 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
+
+	if (dev->fwnode && !dev->fwnode->dev)
+		dev->fwnode->dev = dev;
+
 	bus_probe_device(dev);
 	if (parent)
 		klist_add_tail(&dev->p->knode_parent,
@@ -2342,6 +2346,9 @@ void device_del(struct device *dev)
 	kill_device(dev);
 	device_unlock(dev);
 
+	if (dev->fwnode && dev->fwnode->dev == dev)
+		dev->fwnode->dev = NULL;
+
 	/* Notify clients of device removal.  This call must come
 	 * before dpm_sysfs_remove().
 	 */

commit 1f7d290a7275edb270dbee13212c37cb59940221
Merge: fe38bd686207 ca7ce5a2710a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 18 10:04:39 2019 -0700

    Merge tag 'driver-core-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg Kroah-Hartman:
     "Here is the big driver core update for 5.4-rc1.
    
      There was a bit of a churn in here, with a number of core and OF
      platform patches being added to the tree, and then after much
      discussion and review and a day-long in-person meeting, they were
      decided to be reverted and a new set of patches is currently being
      reviewed on the mailing list.
    
      Other than that churn, there are two "persistent" branches in here
      that other trees will be pulling in as well during the merge window.
      One branch to add support for drivers to have the driver core
      automatically add sysfs attribute files when a driver is bound to a
      device so that the driver doesn't have to manually do it (and then
      clean it up, as it always gets it wrong).
    
      There's another branch in here for generic lookup helpers for the
      driver core that lots of busses are starting to use. That's the
      majority of the non-driver-core changes in this patch series.
    
      There's also some on-going debugfs file creation cleanup that has been
      slowly happening over the past few releases, with the goal to
      hopefully get that done sometime next year.
    
      All of these have been in linux-next for a while now with no reported
      issues"
    
    [ Note that the above-mentioned generic lookup helpers branch was
      already brought in by the LED merge (commit 4feaab05dc1e) that had
      shared it.
    
      Also note that that common branch introduced an i2c bug due to a bad
      conversion, which got fixed here. - Linus ]
    
    * tag 'driver-core-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (49 commits)
      coccinelle: platform_get_irq: Fix parse error
      driver-core: add include guard to linux/container.h
      sysfs: add BIN_ATTR_WO() macro
      driver core: platform: Export platform_get_irq_optional()
      hwmon: pwm-fan: Use platform_get_irq_optional()
      driver core: platform: Introduce platform_get_irq_optional()
      Revert "driver core: Add support for linking devices during device addition"
      Revert "driver core: Add edit_links() callback for drivers"
      Revert "of/platform: Add functional dependency link from DT bindings"
      Revert "driver core: Add sync_state driver/bus callback"
      Revert "of/platform: Pause/resume sync state during init and of_platform_populate()"
      Revert "of/platform: Create device links for all child-supplier depencencies"
      Revert "of/platform: Don't create device links for default busses"
      Revert "of/platform: Fix fn definitons for of_link_is_valid() and of_link_property()"
      Revert "of/platform: Fix device_links_supplier_sync_state_resume() warning"
      Revert "of/platform: Disable generic device linking code for PowerPC"
      devcoredump: fix typo in comment
      devcoredump: use memory_read_from_buffer
      of/platform: Disable generic device linking code for PowerPC
      device.h: Fix warnings for mismatched parameter names in comments
      ...

commit 4feaab05dc1eda3dbb57b097377766002e7a7cb9
Merge: e7345f92c27a 6d4faf3b6b6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 17 18:40:42 2019 -0700

    Merge tag 'leds-for-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds
    
    Pull LED updates from Jacek Anaszewski:
     "In this cycle we've finally managed to contribute the patch set
      sorting out LED naming issues. Besides that there are many changes
      scattered among various LED class drivers and triggers.
    
      LED naming related improvements:
    
       - add new 'function' and 'color' fwnode properties and deprecate
         'label' property which has been frequently abused for conveying
         vendor specific names that have been available in sysfs anyway
    
       - introduce a set of standard LED_FUNCTION* definitions
    
       - introduce a set of standard LED_COLOR_ID* definitions
    
       - add a new {devm_}led_classdev_register_ext() API with the
         capability of automatic LED name composition basing on the
         properties available in the passed fwnode; the function is
         backwards compatible in a sense that it uses 'label' data, if
         present in the fwnode, for creating LED name
    
       - add tools/leds/get_led_device_info.sh script for retrieving LED
         vendor, product and bus names, if applicable; it also performs
         basic validation of an LED name
    
       - update following drivers and their DT bindings to use the new LED
         registration API:
    
            - leds-an30259a, leds-gpio, leds-as3645a, leds-aat1290, leds-cr0014114,
              leds-lm3601x, leds-lm3692x, leds-lp8860, leds-lt3593, leds-sc27xx-blt
    
      Other LED class improvements:
    
       - replace {devm_}led_classdev_register() macros with inlines
    
       - allow to call led_classdev_unregister() unconditionally
    
       - switch to use fwnode instead of be stuck with OF one
    
      LED triggers improvements:
    
       - led-triggers:
            - fix dereferencing of null pointer
            - fix a memory leak bug
    
       - ledtrig-gpio:
            - GPIO 0 is valid
    
      Drop superseeded apu2/3 support from leds-apu since for apu2+ a newer,
      more complete driver exists, based on a generic driver for the AMD
      SOCs gpio-controller, supporting LEDs as well other devices:
    
       - drop profile field from priv data
    
       - drop iosize field from priv data
    
       - drop enum_apu_led_platform_types
    
       - drop superseeded apu2/3 led support
    
       - add pr_fmt prefix for better log output
    
       - fix error message on probing failure
    
      Other misc fixes and improvements to existing LED class drivers:
    
       - leds-ns2, leds-max77650:
            - add of_node_put() before return
    
       - leds-pwm, leds-is31fl32xx:
            - use struct_size() helper
    
       - leds-lm3697, leds-lm36274, leds-lm3532:
            - switch to use fwnode_property_count_uXX()
    
       - leds-lm3532:
            - fix brightness control for i2c mode
            - change the define for the fs current register
            - fixes for the driver for stability
            - add full scale current configuration
            - dt: Add property for full scale current.
            - avoid potentially unpaired regulator calls
            - move static keyword to the front of declarations
            - fix optional led-max-microamp prop error handling
    
       - leds-max77650:
            - add of_node_put() before return
            - add MODULE_ALIAS()
            - Switch to fwnode property API
    
       - leds-as3645a:
            - fix misuse of strlcpy
    
       - leds-netxbig:
            - add of_node_put() in netxbig_leds_get_of_pdata()
            - remove legacy board-file support
    
       - leds-is31fl319x:
            - simplify getting the adapter of a client
    
       - leds-ti-lmu-common:
            - fix coccinelle issue
            - move static keyword to the front of declaration
    
       - leds-syscon:
            - use resource managed variant of device register
    
       - leds-ktd2692:
            - fix a typo in the name of a constant
    
       - leds-lp5562:
            - allow firmware files up to the maximum length
    
       - leds-an30259a:
            - fix typo
    
       - leds-pca953x:
            - include the right header"
    
    * tag 'leds-for-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds: (72 commits)
      leds: lm3532: Fix optional led-max-microamp prop error handling
      led: triggers: Fix dereferencing of null pointer
      leds: ti-lmu-common: Move static keyword to the front of declaration
      leds: lm3532: Move static keyword to the front of declarations
      leds: trigger: gpio: GPIO 0 is valid
      leds: pwm: Use struct_size() helper
      leds: is31fl32xx: Use struct_size() helper
      leds: ti-lmu-common: Fix coccinelle issue in TI LMU
      leds: lm3532: Avoid potentially unpaired regulator calls
      leds: syscon: Use resource managed variant of device register
      leds: Replace {devm_}led_classdev_register() macros with inlines
      leds: Allow to call led_classdev_unregister() unconditionally
      leds: lm3532: Add full scale current configuration
      dt: lm3532: Add property for full scale current.
      leds: lm3532: Fixes for the driver for stability
      leds: lm3532: Change the define for the fs current register
      leds: lm3532: Fix brightness control for i2c mode
      leds: Switch to use fwnode instead of be stuck with OF one
      leds: max77650: Switch to fwnode property API
      led: triggers: Fix a memory leak bug
      ...

commit bfb3943bed670a0655aa2f9dcf82222ff09d6dd1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 27 21:41:16 2019 +0200

    Revert "driver core: Add support for linking devices during device addition"
    
    This reverts commit 5302dd7dd0b6d04c63cdce51d1e9fda9ef0be886.
    
    Based on a lot of email and in-person discussions, this patch series is
    being reworked to address a number of issues that were pointed out that
    needed to be taken care of before it should be merged.  It will be
    resubmitted with those changes hopefully soon.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 605905de0cca..066badad988c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -44,8 +44,6 @@ early_param("sysfs.deprecated", sysfs_deprecated_setup);
 #endif
 
 /* Device links support. */
-static LIST_HEAD(wait_for_suppliers);
-static DEFINE_MUTEX(wfs_lock);
 
 #ifdef CONFIG_SRCU
 static DEFINE_MUTEX(device_links_lock);
@@ -420,51 +418,6 @@ struct device_link *device_link_add(struct device *consumer,
 }
 EXPORT_SYMBOL_GPL(device_link_add);
 
-/**
- * device_link_wait_for_supplier - Mark device as waiting for supplier
- * @consumer: Consumer device
- *
- * Marks the consumer device as waiting for suppliers to become available. The
- * consumer device will never be probed until it's unmarked as waiting for
- * suppliers. The caller is responsible for adding the link to the supplier
- * once the supplier device is present.
- *
- * This function is NOT meant to be called from the probe function of the
- * consumer but rather from code that creates/adds the consumer device.
- */
-static void device_link_wait_for_supplier(struct device *consumer)
-{
-	mutex_lock(&wfs_lock);
-	list_add_tail(&consumer->links.needs_suppliers, &wait_for_suppliers);
-	mutex_unlock(&wfs_lock);
-}
-
-/**
- * device_link_check_waiting_consumers - Try to unmark waiting consumers
- *
- * Loops through all consumers waiting on suppliers and tries to add all their
- * supplier links. If that succeeds, the consumer device is unmarked as waiting
- * for suppliers. Otherwise, they are left marked as waiting on suppliers,
- *
- * The add_links bus callback is expected to return 0 if it has found and added
- * all the supplier links for the consumer device. It should return an error if
- * it isn't able to do so.
- *
- * The caller of device_link_wait_for_supplier() is expected to call this once
- * it's aware of potential suppliers becoming available.
- */
-static void device_link_check_waiting_consumers(void)
-{
-	struct device *dev, *tmp;
-
-	mutex_lock(&wfs_lock);
-	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
-				 links.needs_suppliers)
-		if (!dev->bus->add_links(dev))
-			list_del_init(&dev->links.needs_suppliers);
-	mutex_unlock(&wfs_lock);
-}
-
 static void device_link_free(struct device_link *link)
 {
 	while (refcount_dec_not_one(&link->rpm_active))
@@ -599,19 +552,6 @@ int device_links_check_suppliers(struct device *dev)
 	struct device_link *link;
 	int ret = 0;
 
-	/*
-	 * If a device is waiting for one or more suppliers (in
-	 * wait_for_suppliers list), it is not ready to probe yet. So just
-	 * return -EPROBE_DEFER without having to check the links with existing
-	 * suppliers.
-	 */
-	mutex_lock(&wfs_lock);
-	if (!list_empty(&dev->links.needs_suppliers)) {
-		mutex_unlock(&wfs_lock);
-		return -EPROBE_DEFER;
-	}
-	mutex_unlock(&wfs_lock);
-
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
@@ -896,10 +836,6 @@ static void device_links_purge(struct device *dev)
 {
 	struct device_link *link, *ln;
 
-	mutex_lock(&wfs_lock);
-	list_del(&dev->links.needs_suppliers);
-	mutex_unlock(&wfs_lock);
-
 	/*
 	 * Delete all of the remaining links from this device to any other
 	 * devices (either consumers or suppliers).
@@ -1764,7 +1700,6 @@ void device_initialize(struct device *dev)
 #endif
 	INIT_LIST_HEAD(&dev->links.consumers);
 	INIT_LIST_HEAD(&dev->links.suppliers);
-	INIT_LIST_HEAD(&dev->links.needs_suppliers);
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);
@@ -2251,24 +2186,6 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
-
-	/*
-	 * Check if any of the other devices (consumers) have been waiting for
-	 * this device (supplier) to be added so that they can create a device
-	 * link to it.
-	 *
-	 * This needs to happen after device_pm_add() because device_link_add()
-	 * requires the supplier be registered before it's called.
-	 *
-	 * But this also needs to happe before bus_probe_device() to make sure
-	 * waiting consumers can link to it before the driver is bound to the
-	 * device and the driver sync_state callback is called for this device.
-	 */
-	device_link_check_waiting_consumers();
-
-	if (dev->bus && dev->bus->add_links && dev->bus->add_links(dev))
-		device_link_wait_for_supplier(dev);
-
 	bus_probe_device(dev);
 	if (parent)
 		klist_add_tail(&dev->p->knode_parent,

commit 33cbfe54499338af08ab906a99afac247ea533f6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 27 21:41:06 2019 +0200

    Revert "driver core: Add edit_links() callback for drivers"
    
    This reverts commit 134b23eec9e3a3c795a6ceb0efe2fa63e87983b2.
    
    Based on a lot of email and in-person discussions, this patch series is
    being reworked to address a number of issues that were pointed out that
    needed to be taken care of before it should be merged.  It will be
    resubmitted with those changes hopefully soon.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index de775c7a4d7c..605905de0cca 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -439,19 +439,6 @@ static void device_link_wait_for_supplier(struct device *consumer)
 	mutex_unlock(&wfs_lock);
 }
 
-/**
- * device_link_remove_from_wfs - Unmark device as waiting for supplier
- * @consumer: Consumer device
- *
- * Unmark the consumer device as waiting for suppliers to become available.
- */
-void device_link_remove_from_wfs(struct device *consumer)
-{
-	mutex_lock(&wfs_lock);
-	list_del_init(&consumer->links.needs_suppliers);
-	mutex_unlock(&wfs_lock);
-}
-
 /**
  * device_link_check_waiting_consumers - Try to unmark waiting consumers
  *
@@ -469,19 +456,12 @@ void device_link_remove_from_wfs(struct device *consumer)
 static void device_link_check_waiting_consumers(void)
 {
 	struct device *dev, *tmp;
-	int ret;
 
 	mutex_lock(&wfs_lock);
 	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
-				 links.needs_suppliers) {
-		ret = 0;
-		if (dev->has_edit_links)
-			ret = driver_edit_links(dev);
-		else if (dev->bus->add_links)
-			ret = dev->bus->add_links(dev);
-		if (!ret)
+				 links.needs_suppliers)
+		if (!dev->bus->add_links(dev))
 			list_del_init(&dev->links.needs_suppliers);
-	}
 	mutex_unlock(&wfs_lock);
 }
 

commit bcca686c11cdad3b4566ed1818cd2688e7901def
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 27 21:40:50 2019 +0200

    Revert "driver core: Add sync_state driver/bus callback"
    
    This reverts commit 8f8184d6bf676a8680d6f441e40317d166b46f73.
    
    Based on a lot of email and in-person discussions, this patch series is
    being reworked to address a number of issues that were pointed out that
    needed to be taken care of before it should be merged.  It will be
    resubmitted with those changes hopefully soon.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 75fd59360940..de775c7a4d7c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -46,8 +46,6 @@ early_param("sysfs.deprecated", sysfs_deprecated_setup);
 /* Device links support. */
 static LIST_HEAD(wait_for_suppliers);
 static DEFINE_MUTEX(wfs_lock);
-static LIST_HEAD(deferred_sync);
-static unsigned int supplier_sync_state_disabled;
 
 #ifdef CONFIG_SRCU
 static DEFINE_MUTEX(device_links_lock);
@@ -653,62 +651,6 @@ int device_links_check_suppliers(struct device *dev)
 	return ret;
 }
 
-static void __device_links_supplier_sync_state(struct device *dev)
-{
-	struct device_link *link;
-
-	if (dev->state_synced)
-		return;
-
-	list_for_each_entry(link, &dev->links.consumers, s_node) {
-		if (!(link->flags & DL_FLAG_MANAGED))
-			continue;
-		if (link->status != DL_STATE_ACTIVE)
-			return;
-	}
-
-	if (dev->bus->sync_state)
-		dev->bus->sync_state(dev);
-	else if (dev->driver && dev->driver->sync_state)
-		dev->driver->sync_state(dev);
-
-	dev->state_synced = true;
-}
-
-void device_links_supplier_sync_state_pause(void)
-{
-	device_links_write_lock();
-	supplier_sync_state_disabled++;
-	device_links_write_unlock();
-}
-
-void device_links_supplier_sync_state_resume(void)
-{
-	struct device *dev, *tmp;
-
-	device_links_write_lock();
-	if (!supplier_sync_state_disabled) {
-		WARN(true, "Unmatched sync_state pause/resume!");
-		goto out;
-	}
-	supplier_sync_state_disabled--;
-	if (supplier_sync_state_disabled)
-		goto out;
-
-	list_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_sync) {
-		__device_links_supplier_sync_state(dev);
-		list_del_init(&dev->links.defer_sync);
-	}
-out:
-	device_links_write_unlock();
-}
-
-static void __device_links_supplier_defer_sync(struct device *sup)
-{
-	if (list_empty(&sup->links.defer_sync))
-		list_add_tail(&sup->links.defer_sync, &deferred_sync);
-}
-
 /**
  * device_links_driver_bound - Update device links after probing its driver.
  * @dev: Device to update the links for.
@@ -753,11 +695,6 @@ void device_links_driver_bound(struct device *dev)
 
 		WARN_ON(link->status != DL_STATE_CONSUMER_PROBE);
 		WRITE_ONCE(link->status, DL_STATE_ACTIVE);
-
-		if (supplier_sync_state_disabled)
-			__device_links_supplier_defer_sync(link->supplier);
-		else
-			__device_links_supplier_sync_state(link->supplier);
 	}
 
 	dev->links.status = DL_DEV_DRIVER_BOUND;
@@ -874,7 +811,6 @@ void device_links_driver_cleanup(struct device *dev)
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}
 
-	list_del_init(&dev->links.defer_sync);
 	__device_links_no_driver(dev);
 
 	device_links_write_unlock();
@@ -1849,7 +1785,6 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->links.consumers);
 	INIT_LIST_HEAD(&dev->links.suppliers);
 	INIT_LIST_HEAD(&dev->links.needs_suppliers);
-	INIT_LIST_HEAD(&dev->links.defer_sync);
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);

commit 6c06b66e957c423c341ca255118f809733011864
Merge: bb7ba8069de9 07f038a408fb
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Aug 22 20:52:04 2019 +0200

    Merge branch 'for-mingo' of git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/linux-rcu into core/rcu
    
    Pull RCU and LKMM changes from Paul E. McKenney:
    
     - A few more RCU flavor consolidation cleanups.
    
     - Miscellaneous fixes.
    
     - Updates to RCU's list-traversal macros improving lockdep usability.
    
     - Torture-test updates.
    
     - Forward-progress improvements for no-CBs CPUs: Avoid ignoring
       incoming callbacks during grace-period waits.
    
     - Forward-progress improvements for no-CBs CPUs: Use ->cblist
       structure to take advantage of others' grace periods.
    
     - Also added a small commit that avoids needlessly inflicting
       scheduler-clock ticks on callback-offloaded CPUs.
    
     - Forward-progress improvements for no-CBs CPUs: Reduce contention
       on ->nocb_lock guarding ->cblist.
    
     - Forward-progress improvements for no-CBs CPUs: Add ->nocb_bypass
       list to further reduce contention on ->nocb_lock guarding ->cblist.
    
     - LKMM updates.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c2fa1e1bfa5b74558854a70b8afd797d43eb2743
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Tue Jul 16 18:12:25 2019 -0400

    driver/core: Convert to use built-in RCU list checking
    
    This commit applies the consolidated hlist_for_each_entry_rcu() support
    for lockdep conditions.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 636058bbf48a..eede79630ceb 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -68,6 +68,11 @@ void device_links_read_unlock(int idx)
 {
 	srcu_read_unlock(&device_links_srcu, idx);
 }
+
+int device_links_read_lock_held(void)
+{
+	return srcu_read_lock_held(&device_links_srcu);
+}
 #else /* !CONFIG_SRCU */
 static DECLARE_RWSEM(device_links_lock);
 
@@ -91,6 +96,13 @@ void device_links_read_unlock(int not_used)
 {
 	up_read(&device_links_lock);
 }
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+int device_links_read_lock_held(void)
+{
+	return lockdep_is_held(&device_links_lock);
+}
+#endif
 #endif /* !CONFIG_SRCU */
 
 /**

commit e6aa640eb2f68920cb849aec0cab44f05d843238
Merge: 1f573cce48a2 d45331b00ddb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 12 07:37:39 2019 +0200

    Merge 5.3-rc4 into driver-core-next
    
    We need the driver core fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 36e630ed98d5daa628368121f74bf37bead9206b
Merge: c13f86701e1e 8097c43bcbec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 10 12:20:02 2019 -0700

    Merge tag 'driver-core-5.3-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core fixes from Greg KH:
     "Here are two small fixes for some driver core issues that have been
      reported. There is also a kernfs "fix" here, which was then reverted
      because it was found to cause problems in linux-next.
    
      The driver core fixes both resolve reported issues, one with gpioint
      stuff that showed up in 5.3-rc1, and the other finally (and hopefully)
      resolves a very long standing race when removing glue directories.
      It's nice to get that issue finally resolved and the developers
      involved should be applauded for the persistence it took to get this
      patch finally accepted.
    
      All of these have been in linux-next for a while with no reported
      issues. Well, the one reported issue, hence the revert :)"
    
    * tag 'driver-core-5.3-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:
      Revert "kernfs: fix memleak in kernel_ops_readdir()"
      kernfs: fix memleak in kernel_ops_readdir()
      driver core: Fix use-after-free and double free on glue directory
      driver core: platform: return -ENXIO for missing GpioInt

commit 8f8184d6bf676a8680d6f441e40317d166b46f73
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 31 15:17:17 2019 -0700

    driver core: Add sync_state driver/bus callback
    
    This sync_state driver/bus callback is called once all the consumers
    of a supplier have probed successfully.
    
    This allows the supplier device's driver/bus to sync the supplier
    device's state to the software state with the guarantee that all the
    consumers are actively managing the resources provided by the supplier
    device.
    
    To maintain backwards compatibility and ease transition from existing
    frameworks and resource cleanup schemes, late_initcall_sync is the
    earliest when the sync_state callback might be called.
    
    There is no upper bound on the time by which the sync_state callback
    has to be called. This is because if a consumer device never probes,
    the supplier has to maintain its resources in the state left by the
    bootloader. For example, if the bootloader leaves the display
    backlight at a fixed voltage and the backlight driver is never probed,
    you don't want the backlight to ever be turned off after boot up.
    
    Also, when multiple devices are added after kernel init, some
    suppliers could be added before their consumer devices get added. In
    these instances, the supplier devices could get their sync_state
    callback called right after they probe because the consumers devices
    haven't had a chance to create device links to the suppliers.
    
    To handle this correctly, this change also provides APIs to
    pause/resume sync state callbacks so that when multiple devices are
    added, their sync_state callback evaluation can be postponed to happen
    after all of them are added.
    
    kbuild test robot reported missing documentation for device.state_synced
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190731221721.187713-5-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index feec8dee1e91..5b1795cd116a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -46,6 +46,8 @@ early_param("sysfs.deprecated", sysfs_deprecated_setup);
 /* Device links support. */
 static LIST_HEAD(wait_for_suppliers);
 static DEFINE_MUTEX(wfs_lock);
+static LIST_HEAD(deferred_sync);
+static unsigned int supplier_sync_state_disabled;
 
 #ifdef CONFIG_SRCU
 static DEFINE_MUTEX(device_links_lock);
@@ -651,6 +653,62 @@ int device_links_check_suppliers(struct device *dev)
 	return ret;
 }
 
+static void __device_links_supplier_sync_state(struct device *dev)
+{
+	struct device_link *link;
+
+	if (dev->state_synced)
+		return;
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (!(link->flags & DL_FLAG_MANAGED))
+			continue;
+		if (link->status != DL_STATE_ACTIVE)
+			return;
+	}
+
+	if (dev->bus->sync_state)
+		dev->bus->sync_state(dev);
+	else if (dev->driver && dev->driver->sync_state)
+		dev->driver->sync_state(dev);
+
+	dev->state_synced = true;
+}
+
+void device_links_supplier_sync_state_pause(void)
+{
+	device_links_write_lock();
+	supplier_sync_state_disabled++;
+	device_links_write_unlock();
+}
+
+void device_links_supplier_sync_state_resume(void)
+{
+	struct device *dev, *tmp;
+
+	device_links_write_lock();
+	if (!supplier_sync_state_disabled) {
+		WARN(true, "Unmatched sync_state pause/resume!");
+		goto out;
+	}
+	supplier_sync_state_disabled--;
+	if (supplier_sync_state_disabled)
+		goto out;
+
+	list_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_sync) {
+		__device_links_supplier_sync_state(dev);
+		list_del_init(&dev->links.defer_sync);
+	}
+out:
+	device_links_write_unlock();
+}
+
+static void __device_links_supplier_defer_sync(struct device *sup)
+{
+	if (list_empty(&sup->links.defer_sync))
+		list_add_tail(&sup->links.defer_sync, &deferred_sync);
+}
+
 /**
  * device_links_driver_bound - Update device links after probing its driver.
  * @dev: Device to update the links for.
@@ -695,6 +753,11 @@ void device_links_driver_bound(struct device *dev)
 
 		WARN_ON(link->status != DL_STATE_CONSUMER_PROBE);
 		WRITE_ONCE(link->status, DL_STATE_ACTIVE);
+
+		if (supplier_sync_state_disabled)
+			__device_links_supplier_defer_sync(link->supplier);
+		else
+			__device_links_supplier_sync_state(link->supplier);
 	}
 
 	dev->links.status = DL_DEV_DRIVER_BOUND;
@@ -811,6 +874,7 @@ void device_links_driver_cleanup(struct device *dev)
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}
 
+	list_del_init(&dev->links.defer_sync);
 	__device_links_no_driver(dev);
 
 	device_links_write_unlock();
@@ -1782,6 +1846,7 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->links.consumers);
 	INIT_LIST_HEAD(&dev->links.suppliers);
 	INIT_LIST_HEAD(&dev->links.needs_suppliers);
+	INIT_LIST_HEAD(&dev->links.defer_sync);
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);

commit 134b23eec9e3a3c795a6ceb0efe2fa63e87983b2
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 31 15:17:15 2019 -0700

    driver core: Add edit_links() callback for drivers
    
    The driver core/bus adding supplier-consumer dependencies by default
    enables functional dependencies to be tracked correctly even when the
    consumer devices haven't had their drivers registered or loaded (if they
    are modules).
    
    However, when the bus incorrectly adds dependencies that it shouldn't
    have added, the devices might never probe.
    
    For example, if device-C is a consumer of device-S and they have
    phandles to each other in DT, the following could happen:
    
    1.  Device-S get added first.
    2.  The bus add_links() callback will (incorrectly) try to link it as
        a consumer of device-C.
    3.  Since device-C isn't present, device-S will be put in
        "waiting-for-supplier" list.
    4.  Device-C gets added next.
    5.  All devices in "waiting-for-supplier" list are retried for linking.
    6.  Device-S gets linked as consumer to Device-C.
    7.  The bus add_links() callback will (correctly) try to link it as
        a consumer of device-S.
    8.  This isn't allowed because it would create a cyclic device links.
    
    Neither devices will get probed since the supplier is marked as
    dependent on the consumer. And the consumer will never probe because the
    consumer can't get resources from the supplier.
    
    Without this patch, things stay in this broken state. However, with this
    patch, the execution will continue like this:
    
    9.  Device-C's driver is loaded.
    10. Device-C's driver removes Device-S as a consumer of Device-C.
    11. Device-C's driver adds Device-C as a consumer of Device-S.
    12. Device-S probes.
    14. Device-C probes.
    
    kbuild test robot reported missing documentation for device.has_edit_links
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190731221721.187713-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 18e04ca1de13..feec8dee1e91 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -439,6 +439,19 @@ static void device_link_wait_for_supplier(struct device *consumer)
 	mutex_unlock(&wfs_lock);
 }
 
+/**
+ * device_link_remove_from_wfs - Unmark device as waiting for supplier
+ * @consumer: Consumer device
+ *
+ * Unmark the consumer device as waiting for suppliers to become available.
+ */
+void device_link_remove_from_wfs(struct device *consumer)
+{
+	mutex_lock(&wfs_lock);
+	list_del_init(&consumer->links.needs_suppliers);
+	mutex_unlock(&wfs_lock);
+}
+
 /**
  * device_link_check_waiting_consumers - Try to unmark waiting consumers
  *
@@ -456,12 +469,19 @@ static void device_link_wait_for_supplier(struct device *consumer)
 static void device_link_check_waiting_consumers(void)
 {
 	struct device *dev, *tmp;
+	int ret;
 
 	mutex_lock(&wfs_lock);
 	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
-				 links.needs_suppliers)
-		if (!dev->bus->add_links(dev))
+				 links.needs_suppliers) {
+		ret = 0;
+		if (dev->has_edit_links)
+			ret = driver_edit_links(dev);
+		else if (dev->bus->add_links)
+			ret = dev->bus->add_links(dev);
+		if (!ret)
 			list_del_init(&dev->links.needs_suppliers);
+	}
 	mutex_unlock(&wfs_lock);
 }
 

commit 5302dd7dd0b6d04c63cdce51d1e9fda9ef0be886
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Jul 31 15:17:14 2019 -0700

    driver core: Add support for linking devices during device addition
    
    When devices are added, the bus might want to create device links to track
    functional dependencies between supplier and consumer devices. This
    tracking of supplier-consumer relationship allows optimizing device probe
    order and tracking whether all consumers of a supplier are active. The
    add_links bus callback is added to support this.
    
    However, when consumer devices are added, they might not have a supplier
    device to link to despite needing mandatory resources/functionality from
    one or more suppliers. A waiting_for_suppliers list is created to track
    such consumers and retry linking them when new devices get added.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190731221721.187713-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 90f2dd4661f5..18e04ca1de13 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -44,6 +44,8 @@ early_param("sysfs.deprecated", sysfs_deprecated_setup);
 #endif
 
 /* Device links support. */
+static LIST_HEAD(wait_for_suppliers);
+static DEFINE_MUTEX(wfs_lock);
 
 #ifdef CONFIG_SRCU
 static DEFINE_MUTEX(device_links_lock);
@@ -418,6 +420,51 @@ struct device_link *device_link_add(struct device *consumer,
 }
 EXPORT_SYMBOL_GPL(device_link_add);
 
+/**
+ * device_link_wait_for_supplier - Mark device as waiting for supplier
+ * @consumer: Consumer device
+ *
+ * Marks the consumer device as waiting for suppliers to become available. The
+ * consumer device will never be probed until it's unmarked as waiting for
+ * suppliers. The caller is responsible for adding the link to the supplier
+ * once the supplier device is present.
+ *
+ * This function is NOT meant to be called from the probe function of the
+ * consumer but rather from code that creates/adds the consumer device.
+ */
+static void device_link_wait_for_supplier(struct device *consumer)
+{
+	mutex_lock(&wfs_lock);
+	list_add_tail(&consumer->links.needs_suppliers, &wait_for_suppliers);
+	mutex_unlock(&wfs_lock);
+}
+
+/**
+ * device_link_check_waiting_consumers - Try to unmark waiting consumers
+ *
+ * Loops through all consumers waiting on suppliers and tries to add all their
+ * supplier links. If that succeeds, the consumer device is unmarked as waiting
+ * for suppliers. Otherwise, they are left marked as waiting on suppliers,
+ *
+ * The add_links bus callback is expected to return 0 if it has found and added
+ * all the supplier links for the consumer device. It should return an error if
+ * it isn't able to do so.
+ *
+ * The caller of device_link_wait_for_supplier() is expected to call this once
+ * it's aware of potential suppliers becoming available.
+ */
+static void device_link_check_waiting_consumers(void)
+{
+	struct device *dev, *tmp;
+
+	mutex_lock(&wfs_lock);
+	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
+				 links.needs_suppliers)
+		if (!dev->bus->add_links(dev))
+			list_del_init(&dev->links.needs_suppliers);
+	mutex_unlock(&wfs_lock);
+}
+
 static void device_link_free(struct device_link *link)
 {
 	while (refcount_dec_not_one(&link->rpm_active))
@@ -552,6 +599,19 @@ int device_links_check_suppliers(struct device *dev)
 	struct device_link *link;
 	int ret = 0;
 
+	/*
+	 * If a device is waiting for one or more suppliers (in
+	 * wait_for_suppliers list), it is not ready to probe yet. So just
+	 * return -EPROBE_DEFER without having to check the links with existing
+	 * suppliers.
+	 */
+	mutex_lock(&wfs_lock);
+	if (!list_empty(&dev->links.needs_suppliers)) {
+		mutex_unlock(&wfs_lock);
+		return -EPROBE_DEFER;
+	}
+	mutex_unlock(&wfs_lock);
+
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
@@ -836,6 +896,10 @@ static void device_links_purge(struct device *dev)
 {
 	struct device_link *link, *ln;
 
+	mutex_lock(&wfs_lock);
+	list_del(&dev->links.needs_suppliers);
+	mutex_unlock(&wfs_lock);
+
 	/*
 	 * Delete all of the remaining links from this device to any other
 	 * devices (either consumers or suppliers).
@@ -1697,6 +1761,7 @@ void device_initialize(struct device *dev)
 #endif
 	INIT_LIST_HEAD(&dev->links.consumers);
 	INIT_LIST_HEAD(&dev->links.suppliers);
+	INIT_LIST_HEAD(&dev->links.needs_suppliers);
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);
@@ -2132,6 +2197,24 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
+
+	/*
+	 * Check if any of the other devices (consumers) have been waiting for
+	 * this device (supplier) to be added so that they can create a device
+	 * link to it.
+	 *
+	 * This needs to happen after device_pm_add() because device_link_add()
+	 * requires the supplier be registered before it's called.
+	 *
+	 * But this also needs to happe before bus_probe_device() to make sure
+	 * waiting consumers can link to it before the driver is bound to the
+	 * device and the driver sync_state callback is called for this device.
+	 */
+	device_link_check_waiting_consumers();
+
+	if (dev->bus && dev->bus->add_links && dev->bus->add_links(dev))
+		device_link_wait_for_supplier(dev);
+
 	bus_probe_device(dev);
 	if (parent)
 		klist_add_tail(&dev->p->knode_parent,

commit ac43432cb1f5c2950408534987e57c2071e24d8f
Author: Muchun Song <smuchun@gmail.com>
Date:   Sat Jul 27 11:21:22 2019 +0800

    driver core: Fix use-after-free and double free on glue directory
    
    There is a race condition between removing glue directory and adding a new
    device under the glue dir. It can be reproduced in following test:
    
    CPU1:                                         CPU2:
    
    device_add()
      get_device_parent()
        class_dir_create_and_add()
          kobject_add_internal()
            create_dir()    // create glue_dir
    
                                                  device_add()
                                                    get_device_parent()
                                                      kobject_get() // get glue_dir
    
    device_del()
      cleanup_glue_dir()
        kobject_del(glue_dir)
    
                                                    kobject_add()
                                                      kobject_add_internal()
                                                        create_dir() // in glue_dir
                                                          sysfs_create_dir_ns()
                                                            kernfs_create_dir_ns(sd)
    
          sysfs_remove_dir() // glue_dir->sd=NULL
          sysfs_put()        // free glue_dir->sd
    
                                                              // sd is freed
                                                              kernfs_new_node(sd)
                                                                kernfs_get(glue_dir)
                                                                kernfs_add_one()
                                                                kernfs_put()
    
    Before CPU1 remove last child device under glue dir, if CPU2 add a new
    device under glue dir, the glue_dir kobject reference count will be
    increase to 2 via kobject_get() in get_device_parent(). And CPU2 has
    been called kernfs_create_dir_ns(), but not call kernfs_new_node().
    Meanwhile, CPU1 call sysfs_remove_dir() and sysfs_put(). This result in
    glue_dir->sd is freed and it's reference count will be 0. Then CPU2 call
    kernfs_get(glue_dir) will trigger a warning in kernfs_get() and increase
    it's reference count to 1. Because glue_dir->sd is freed by CPU1, the next
    call kernfs_add_one() by CPU2 will fail(This is also use-after-free)
    and call kernfs_put() to decrease reference count. Because the reference
    count is decremented to 0, it will also call kmem_cache_free() to free
    the glue_dir->sd again. This will result in double free.
    
    In order to avoid this happening, we also should make sure that kernfs_node
    for glue_dir is released in CPU1 only when refcount for glue_dir kobj is
    1 to fix this race.
    
    The following calltrace is captured in kernel 4.14 with the following patch
    applied:
    
    commit 726e41097920 ("drivers: core: Remove glue dirs from sysfs earlier")
    
    --------------------------------------------------------------------------
    [    3.633703] WARNING: CPU: 4 PID: 513 at .../fs/kernfs/dir.c:494
                    Here is WARN_ON(!atomic_read(&kn->count) in kernfs_get().
    ....
    [    3.633986] Call trace:
    [    3.633991]  kernfs_create_dir_ns+0xa8/0xb0
    [    3.633994]  sysfs_create_dir_ns+0x54/0xe8
    [    3.634001]  kobject_add_internal+0x22c/0x3f0
    [    3.634005]  kobject_add+0xe4/0x118
    [    3.634011]  device_add+0x200/0x870
    [    3.634017]  _request_firmware+0x958/0xc38
    [    3.634020]  request_firmware_into_buf+0x4c/0x70
    ....
    [    3.634064] kernel BUG at .../mm/slub.c:294!
                    Here is BUG_ON(object == fp) in set_freepointer().
    ....
    [    3.634346] Call trace:
    [    3.634351]  kmem_cache_free+0x504/0x6b8
    [    3.634355]  kernfs_put+0x14c/0x1d8
    [    3.634359]  kernfs_create_dir_ns+0x88/0xb0
    [    3.634362]  sysfs_create_dir_ns+0x54/0xe8
    [    3.634366]  kobject_add_internal+0x22c/0x3f0
    [    3.634370]  kobject_add+0xe4/0x118
    [    3.634374]  device_add+0x200/0x870
    [    3.634378]  _request_firmware+0x958/0xc38
    [    3.634381]  request_firmware_into_buf+0x4c/0x70
    --------------------------------------------------------------------------
    
    Fixes: 726e41097920 ("drivers: core: Remove glue dirs from sysfs earlier")
    Signed-off-by: Muchun Song <smuchun@gmail.com>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Prateek Sood <prsood@codeaurora.org>
    Link: https://lore.kernel.org/r/20190727032122.24639-1-smuchun@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index da84a73f2ba6..c83d7e87764a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1820,12 +1820,63 @@ static inline struct kobject *get_glue_dir(struct device *dev)
  */
 static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 {
+	unsigned int ref;
+
 	/* see if we live in a "glue" directory */
 	if (!live_in_glue_dir(glue_dir, dev))
 		return;
 
 	mutex_lock(&gdp_mutex);
-	if (!kobject_has_children(glue_dir))
+	/**
+	 * There is a race condition between removing glue directory
+	 * and adding a new device under the glue directory.
+	 *
+	 * CPU1:                                         CPU2:
+	 *
+	 * device_add()
+	 *   get_device_parent()
+	 *     class_dir_create_and_add()
+	 *       kobject_add_internal()
+	 *         create_dir()    // create glue_dir
+	 *
+	 *                                               device_add()
+	 *                                                 get_device_parent()
+	 *                                                   kobject_get() // get glue_dir
+	 *
+	 * device_del()
+	 *   cleanup_glue_dir()
+	 *     kobject_del(glue_dir)
+	 *
+	 *                                               kobject_add()
+	 *                                                 kobject_add_internal()
+	 *                                                   create_dir() // in glue_dir
+	 *                                                     sysfs_create_dir_ns()
+	 *                                                       kernfs_create_dir_ns(sd)
+	 *
+	 *       sysfs_remove_dir() // glue_dir->sd=NULL
+	 *       sysfs_put()        // free glue_dir->sd
+	 *
+	 *                                                         // sd is freed
+	 *                                                         kernfs_new_node(sd)
+	 *                                                           kernfs_get(glue_dir)
+	 *                                                           kernfs_add_one()
+	 *                                                           kernfs_put()
+	 *
+	 * Before CPU1 remove last child device under glue dir, if CPU2 add
+	 * a new device under glue dir, the glue_dir kobject reference count
+	 * will be increase to 2 in kobject_get(k). And CPU2 has been called
+	 * kernfs_create_dir_ns(). Meanwhile, CPU1 call sysfs_remove_dir()
+	 * and sysfs_put(). This result in glue_dir->sd is freed.
+	 *
+	 * Then the CPU2 will see a stale "empty" but still potentially used
+	 * glue dir around in kernfs_new_node().
+	 *
+	 * In order to avoid this happening, we also should make sure that
+	 * kernfs_node for glue_dir is released in CPU1 only when refcount
+	 * for glue_dir kobj is 1.
+	 */
+	ref = kref_read(&glue_dir->kref);
+	if (!kobject_has_children(glue_dir) && !--ref)
 		kobject_del(glue_dir);
 	kobject_put(glue_dir);
 	mutex_unlock(&gdp_mutex);

commit f87da58b797aa591f2e288c7012faf3ab1e54c55
Merge: fb583c8eeeb1 36f3313d6bff
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jul 30 13:26:39 2019 +0200

    Merge branch 'generic_lookup_helpers' into driver-core-next
    
    This was on a separate branch so that others can pull it in.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6bf85ba9e55f659ddc0747bf1bb504ec6d15f525
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:37 2019 +0100

    drivers: Add generic helper to match any device
    
    Add a generic helper to match any/all devices. Using this
    introduce new wrappers {bus/driver/class}_find_next_device().
    
    Cc: Elie Morisse <syniurge@gmail.com>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Nehal Shah <nehal-bakulchandra.shah@amd.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Shyam Sundar S K <shyam-sundar.s-k@amd.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> # PCI
    Link: https://lore.kernel.org/r/20190723221838.12024-7-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 57d71bc2c559..e22e29b3dc97 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3379,3 +3379,9 @@ int device_match_acpi_dev(struct device *dev, const void *adev)
 	return ACPI_COMPANION(dev) == adev;
 }
 EXPORT_SYMBOL(device_match_acpi_dev);
+
+int device_match_any(struct device *dev, const void *unused)
+{
+	return 1;
+}
+EXPORT_SYMBOL_GPL(device_match_any);

commit 00500147cbd3fc51353d0d003eaa9d31c72c0d50
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:36 2019 +0100

    drivers: Introduce device lookup variants by ACPI_COMPANION device
    
    Add a generic helper to match a device by the ACPI_COMPANION device
    and provide wrappers for the device lookup APIs.
    
    Cc: Len Brown <lenb@kernel.org>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-spi@vger.kernel.org
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: linux-i2c@vger.kernel.org
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # I2C parts
    Link: https://lore.kernel.org/r/20190723221838.12024-6-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 3abc32b60c0a..57d71bc2c559 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3373,3 +3373,9 @@ int device_match_devt(struct device *dev, const void *pdevt)
 	return dev->devt == *(dev_t *)pdevt;
 }
 EXPORT_SYMBOL_GPL(device_match_devt);
+
+int device_match_acpi_dev(struct device *dev, const void *adev)
+{
+	return ACPI_COMPANION(dev) == adev;
+}
+EXPORT_SYMBOL(device_match_acpi_dev);

commit 4495dfdd6193d9712b7b8f5d699d89d5996e6aaa
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:35 2019 +0100

    drivers: Introduce device lookup variants by device type
    
    Add a helper to match a device by its type and provide wrappers
    for {bus/class/driver}_find_device() APIs.
    
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: linux-usb@vger.kernel.org
    Cc: Oliver Neukum <oneukum@suse.com>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Link: https://lore.kernel.org/r/20190723221838.12024-5-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e8f81a667545..3abc32b60c0a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2867,13 +2867,6 @@ struct device *device_create_with_groups(struct class *class,
 }
 EXPORT_SYMBOL_GPL(device_create_with_groups);
 
-static int __match_devt(struct device *dev, const void *data)
-{
-	const dev_t *devt = data;
-
-	return dev->devt == *devt;
-}
-
 /**
  * device_destroy - removes a device that was created with device_create()
  * @class: pointer to the struct class that this device was registered with
@@ -2886,7 +2879,7 @@ void device_destroy(struct class *class, dev_t devt)
 {
 	struct device *dev;
 
-	dev = class_find_device(class, NULL, &devt, __match_devt);
+	dev = class_find_device_by_devt(class, devt);
 	if (dev) {
 		put_device(dev);
 		device_unregister(dev);
@@ -3374,3 +3367,9 @@ int device_match_fwnode(struct device *dev, const void *fwnode)
 	return dev_fwnode(dev) == fwnode;
 }
 EXPORT_SYMBOL_GPL(device_match_fwnode);
+
+int device_match_devt(struct device *dev, const void *pdevt)
+{
+	return dev->devt == *(dev_t *)pdevt;
+}
+EXPORT_SYMBOL_GPL(device_match_devt);

commit 67843bbaf36eb087714f40e783ee78e99e9e4b86
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:34 2019 +0100

    drivers: Introduce device lookup variants by fwnode
    
    Add a helper to match the firmware node handle of a device and provide
    wrappers for {bus/class/driver}_find_device() APIs to avoid proliferation
    of duplicate custom match functions.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Doug Ledford <dledford@redhat.com>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: linux-usb@vger.kernel.org
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Link: https://lore.kernel.org/r/20190723221838.12024-4-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fb83647d685a..e8f81a667545 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3368,3 +3368,9 @@ int device_match_of_node(struct device *dev, const void *np)
 	return dev->of_node == np;
 }
 EXPORT_SYMBOL_GPL(device_match_of_node);
+
+int device_match_fwnode(struct device *dev, const void *fwnode)
+{
+	return dev_fwnode(dev) == fwnode;
+}
+EXPORT_SYMBOL_GPL(device_match_fwnode);

commit 6cda08a20dbde45b021091230c8a359fa08c5103
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:32 2019 +0100

    drivers: Introduce device lookup variants by name
    
    Add a helper to match the device name for device lookup. Also
    reuse this generic exported helper for the existing bus_find_device_by_name().
    and add similar variants for driver/class.
    
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexander Aring <alex.aring@gmail.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Dan Murphy <dmurphy@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: linux-leds@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: linux-wpan@vger.kernel.org
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Stefan Schmidt <stefan@datenfreihafen.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20190723221838.12024-2-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index da84a73f2ba6..fb83647d685a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3357,6 +3357,12 @@ void device_set_of_node_from_dev(struct device *dev, const struct device *dev2)
 }
 EXPORT_SYMBOL_GPL(device_set_of_node_from_dev);
 
+int device_match_name(struct device *dev, const void *name)
+{
+	return sysfs_streq(dev_name(dev), name);
+}
+EXPORT_SYMBOL_GPL(device_match_name);
+
 int device_match_of_node(struct device *dev, const void *np)
 {
 	return dev->of_node == np;

commit fb583c8eeeb1fd57e24ef41ed94c9112067aeac9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 11:28:57 2019 +0200

    driver core: Fix creation of device links with PM-runtime flags
    
    After commit 515db266a9da ("driver core: Remove device link creation
    limitation"), if PM-runtime flags are passed to device_link_add(), it
    will fail (returning NULL) due to an overly restrictive flags check
    introduced by that commit.
    
    Fix this issue by extending the check in question to cover the
    PM-runtime flags too.
    
    Fixes: 515db266a9da ("driver core: Remove device link creation limitation")
    Reported-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/7674989.cD04D8YV3U@kreacher
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 21cd08162219..08eecab2497b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -213,6 +213,9 @@ void device_pm_move_to_tail(struct device *dev)
 			       DL_FLAG_AUTOREMOVE_SUPPLIER | \
 			       DL_FLAG_AUTOPROBE_CONSUMER)
 
+#define DL_ADD_VALID_FLAGS (DL_MANAGED_LINK_FLAGS | DL_FLAG_STATELESS | \
+			    DL_FLAG_PM_RUNTIME | DL_FLAG_RPM_ACTIVE)
+
 /**
  * device_link_add - Create a link between two devices.
  * @consumer: Consumer end of the link.
@@ -274,8 +277,7 @@ struct device_link *device_link_add(struct device *consumer,
 {
 	struct device_link *link;
 
-	if (!consumer || !supplier ||
-	    (flags & ~(DL_FLAG_STATELESS | DL_MANAGED_LINK_FLAGS)) ||
+	if (!consumer || !supplier || flags & ~DL_ADD_VALID_FLAGS ||
 	    (flags & DL_FLAG_STATELESS && flags & DL_MANAGED_LINK_FLAGS) ||
 	    (flags & DL_FLAG_AUTOPROBE_CONSUMER &&
 	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER |

commit 523634db145a22cd5562714d4c59ea74686afe38
Merge: 5168afe6ef59 87a30e1f05d7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 27 08:25:51 2019 -0700

    Merge tag 'libnvdimm-fixes-5.3-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm fixes from Dan Williams:
     "A collection of locking and async operations fixes for v5.3-rc2. These
      had been soaking in a branch targeting the merge window, but missed
      due to a regression hunt. This fixed up version has otherwise been in
      -next this past week with no reported issues.
    
      In order to gain confidence in the locking changes the pull also
      includes a debug / instrumentation patch to enable lockdep coverage
      for libnvdimm subsystem operations that depend on the device_lock for
      exclusion. As mentioned in the changelog it is a hack, but it works
      and documents the locking expectations of the sub-system in a way that
      others can use lockdep to verify. The driver core touches got an ack
      from Greg.
    
      Summary:
    
       - Fix duplicate device_unregister() calls (multiple threads competing
         to do unregister work when scheduling device removal from a sysfs
         attribute of the self-same device).
    
       - Fix badblocks registration order bug. Ensure region badblocks are
         initialized in advance of namespace registration.
    
       - Fix a deadlock between the bus lock and probe operations.
    
       - Export device-core infrastructure to coordinate async operations
         via the device ->dead state.
    
       - Add device-core infrastructure to validate device_lock() usage with
         lockdep"
    
    * tag 'libnvdimm-fixes-5.3-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm:
      driver-core, libnvdimm: Let device subsystems add local lockdep coverage
      libnvdimm/bus: Fix wait_nvdimm_bus_probe_idle() ABBA deadlock
      libnvdimm/bus: Stop holding nvdimm_bus_list_mutex over __nd_ioctl()
      libnvdimm/bus: Prepare the nd_ioctl() path to be re-entrant
      libnvdimm/region: Register badblocks before namespaces
      libnvdimm/bus: Prevent duplicate device_unregister() calls
      drivers/base: Introduce kill_device()

commit 515db266a9dace92b0cbaed9a6044dd5304b8ca9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 16 17:21:06 2019 +0200

    driver core: Remove device link creation limitation
    
    If device_link_add() is called for a consumer/supplier pair with an
    existing device link between them and the existing link's type is
    not in agreement with the flags passed to that function by its
    caller, NULL will be returned.  That is seriously inconvenient,
    because it forces the callers of device_link_add() to worry about
    what others may or may not do even if that is not relevant to them
    for any other reasons.
    
    It turns out, however, that this limitation can be made go away
    relatively easily.
    
    The underlying observation is that if DL_FLAG_STATELESS has been
    passed to device_link_add() in flags for the given consumer/supplier
    pair at least once, calling either device_link_del() or
    device_link_remove() to release the link returned by it should work,
    but there are no other requirements associated with that flag.  In
    turn, if at least one of the callers of device_link_add() for the
    given consumer/supplier pair has not passed DL_FLAG_STATELESS to it
    in flags, the driver core should track the status of the link and act
    on it as appropriate (ie. the link should be treated as "managed").
    This means that DL_FLAG_STATELESS needs to be set for managed device
    links and it should be valid to call device_link_del() or
    device_link_remove() to drop references to them in certain
    sutiations.
    
    To allow that to happen, introduce a new (internal) device link flag
    called DL_FLAG_MANAGED and make device_link_add() set it automatically
    whenever DL_FLAG_STATELESS is not passed to it.  Also make it take
    additional references to existing device links that were previously
    stateless (that is, with DL_FLAG_STATELESS set and DL_FLAG_MANAGED
    unset) and will need to be managed going forward and initialize
    their status (which has been DL_STATE_NONE so far).
    
    Accordingly, when a managed device link is dropped automatically
    by the driver core, make it clear DL_FLAG_MANAGED, reset the link's
    status back to DL_STATE_NONE and drop the reference to it associated
    with DL_FLAG_MANAGED instead of just deleting it right away (to
    allow it to stay around in case it still needs to be released
    explicitly by someone).
    
    With that, since setting DL_FLAG_STATELESS doesn't mean that the
    device link in question is not managed any more, replace all of the
    status-tracking checks against DL_FLAG_STATELESS with analogous
    checks against DL_FLAG_MANAGED and update the documentation to
    reflect these changes.
    
    While at it, make device_link_add() reject flags that it does not
    recognize, including DL_FLAG_MANAGED.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Saravana Kannan <saravanak@google.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Review-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/2305283.AStDPdUUnE@kreacher
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index da84a73f2ba6..21cd08162219 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -124,6 +124,50 @@ static int device_is_dependent(struct device *dev, void *target)
 	return ret;
 }
 
+static void device_link_init_status(struct device_link *link,
+				    struct device *consumer,
+				    struct device *supplier)
+{
+	switch (supplier->links.status) {
+	case DL_DEV_PROBING:
+		switch (consumer->links.status) {
+		case DL_DEV_PROBING:
+			/*
+			 * A consumer driver can create a link to a supplier
+			 * that has not completed its probing yet as long as it
+			 * knows that the supplier is already functional (for
+			 * example, it has just acquired some resources from the
+			 * supplier).
+			 */
+			link->status = DL_STATE_CONSUMER_PROBE;
+			break;
+		default:
+			link->status = DL_STATE_DORMANT;
+			break;
+		}
+		break;
+	case DL_DEV_DRIVER_BOUND:
+		switch (consumer->links.status) {
+		case DL_DEV_PROBING:
+			link->status = DL_STATE_CONSUMER_PROBE;
+			break;
+		case DL_DEV_DRIVER_BOUND:
+			link->status = DL_STATE_ACTIVE;
+			break;
+		default:
+			link->status = DL_STATE_AVAILABLE;
+			break;
+		}
+		break;
+	case DL_DEV_UNBINDING:
+		link->status = DL_STATE_SUPPLIER_UNBIND;
+		break;
+	default:
+		link->status = DL_STATE_DORMANT;
+		break;
+	}
+}
+
 static int device_reorder_to_tail(struct device *dev, void *not_used)
 {
 	struct device_link *link;
@@ -165,6 +209,10 @@ void device_pm_move_to_tail(struct device *dev)
 	device_links_read_unlock(idx);
 }
 
+#define DL_MANAGED_LINK_FLAGS (DL_FLAG_AUTOREMOVE_CONSUMER | \
+			       DL_FLAG_AUTOREMOVE_SUPPLIER | \
+			       DL_FLAG_AUTOPROBE_CONSUMER)
+
 /**
  * device_link_add - Create a link between two devices.
  * @consumer: Consumer end of the link.
@@ -179,9 +227,9 @@ void device_pm_move_to_tail(struct device *dev)
  * of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
  * ignored.
  *
- * If DL_FLAG_STATELESS is set in @flags, the link is not going to be managed by
- * the driver core and, in particular, the caller of this function is expected
- * to drop the reference to the link acquired by it directly.
+ * If DL_FLAG_STATELESS is set in @flags, the caller of this function is
+ * expected to release the link returned by it directly with the help of either
+ * device_link_del() or device_link_remove().
  *
  * If that flag is not set, however, the caller of this function is handing the
  * management of the link over to the driver core entirely and its return value
@@ -201,9 +249,16 @@ void device_pm_move_to_tail(struct device *dev)
  * be used to request the driver core to automaticall probe for a consmer
  * driver after successfully binding a driver to the supplier device.
  *
- * The combination of DL_FLAG_STATELESS and either DL_FLAG_AUTOREMOVE_CONSUMER
- * or DL_FLAG_AUTOREMOVE_SUPPLIER set in @flags at the same time is invalid and
- * will cause NULL to be returned upfront.
+ * The combination of DL_FLAG_STATELESS and one of DL_FLAG_AUTOREMOVE_CONSUMER,
+ * DL_FLAG_AUTOREMOVE_SUPPLIER, or DL_FLAG_AUTOPROBE_CONSUMER set in @flags at
+ * the same time is invalid and will cause NULL to be returned upfront.
+ * However, if a device link between the given @consumer and @supplier pair
+ * exists already when this function is called for them, the existing link will
+ * be returned regardless of its current type and status (the link's flags may
+ * be modified then).  The caller of this function is then expected to treat
+ * the link as though it has just been created, so (in particular) if
+ * DL_FLAG_STATELESS was passed in @flags, the link needs to be released
+ * explicitly when not needed any more (as stated above).
  *
  * A side effect of the link creation is re-ordering of dpm_list and the
  * devices_kset list by moving the consumer device and all devices depending
@@ -220,10 +275,8 @@ struct device_link *device_link_add(struct device *consumer,
 	struct device_link *link;
 
 	if (!consumer || !supplier ||
-	    (flags & DL_FLAG_STATELESS &&
-	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER |
-		      DL_FLAG_AUTOREMOVE_SUPPLIER |
-		      DL_FLAG_AUTOPROBE_CONSUMER)) ||
+	    (flags & ~(DL_FLAG_STATELESS | DL_MANAGED_LINK_FLAGS)) ||
+	    (flags & DL_FLAG_STATELESS && flags & DL_MANAGED_LINK_FLAGS) ||
 	    (flags & DL_FLAG_AUTOPROBE_CONSUMER &&
 	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER |
 		      DL_FLAG_AUTOREMOVE_SUPPLIER)))
@@ -236,6 +289,9 @@ struct device_link *device_link_add(struct device *consumer,
 		}
 	}
 
+	if (!(flags & DL_FLAG_STATELESS))
+		flags |= DL_FLAG_MANAGED;
+
 	device_links_write_lock();
 	device_pm_lock();
 
@@ -262,15 +318,6 @@ struct device_link *device_link_add(struct device *consumer,
 		if (link->consumer != consumer)
 			continue;
 
-		/*
-		 * Don't return a stateless link if the caller wants a stateful
-		 * one and vice versa.
-		 */
-		if (WARN_ON((flags & DL_FLAG_STATELESS) != (link->flags & DL_FLAG_STATELESS))) {
-			link = NULL;
-			goto out;
-		}
-
 		if (flags & DL_FLAG_PM_RUNTIME) {
 			if (!(link->flags & DL_FLAG_PM_RUNTIME)) {
 				pm_runtime_new_link(consumer);
@@ -281,6 +328,7 @@ struct device_link *device_link_add(struct device *consumer,
 		}
 
 		if (flags & DL_FLAG_STATELESS) {
+			link->flags |= DL_FLAG_STATELESS;
 			kref_get(&link->kref);
 			goto out;
 		}
@@ -299,6 +347,11 @@ struct device_link *device_link_add(struct device *consumer,
 			link->flags &= ~(DL_FLAG_AUTOREMOVE_CONSUMER |
 					 DL_FLAG_AUTOREMOVE_SUPPLIER);
 		}
+		if (!(link->flags & DL_FLAG_MANAGED)) {
+			kref_get(&link->kref);
+			link->flags |= DL_FLAG_MANAGED;
+			device_link_init_status(link, consumer, supplier);
+		}
 		goto out;
 	}
 
@@ -325,48 +378,10 @@ struct device_link *device_link_add(struct device *consumer,
 	kref_init(&link->kref);
 
 	/* Determine the initial link state. */
-	if (flags & DL_FLAG_STATELESS) {
+	if (flags & DL_FLAG_STATELESS)
 		link->status = DL_STATE_NONE;
-	} else {
-		switch (supplier->links.status) {
-		case DL_DEV_PROBING:
-			switch (consumer->links.status) {
-			case DL_DEV_PROBING:
-				/*
-				 * A consumer driver can create a link to a
-				 * supplier that has not completed its probing
-				 * yet as long as it knows that the supplier is
-				 * already functional (for example, it has just
-				 * acquired some resources from the supplier).
-				 */
-				link->status = DL_STATE_CONSUMER_PROBE;
-				break;
-			default:
-				link->status = DL_STATE_DORMANT;
-				break;
-			}
-			break;
-		case DL_DEV_DRIVER_BOUND:
-			switch (consumer->links.status) {
-			case DL_DEV_PROBING:
-				link->status = DL_STATE_CONSUMER_PROBE;
-				break;
-			case DL_DEV_DRIVER_BOUND:
-				link->status = DL_STATE_ACTIVE;
-				break;
-			default:
-				link->status = DL_STATE_AVAILABLE;
-				break;
-			}
-			break;
-		case DL_DEV_UNBINDING:
-			link->status = DL_STATE_SUPPLIER_UNBIND;
-			break;
-		default:
-			link->status = DL_STATE_DORMANT;
-			break;
-		}
-	}
+	else
+		device_link_init_status(link, consumer, supplier);
 
 	/*
 	 * Some callers expect the link creation during consumer driver probe to
@@ -528,7 +543,7 @@ static void device_links_missing_supplier(struct device *dev)
  * mark the link as "consumer probe in progress" to make the supplier removal
  * wait for us to complete (or bad things may happen).
  *
- * Links with the DL_FLAG_STATELESS flag set are ignored.
+ * Links without the DL_FLAG_MANAGED flag set are ignored.
  */
 int device_links_check_suppliers(struct device *dev)
 {
@@ -538,7 +553,7 @@ int device_links_check_suppliers(struct device *dev)
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		if (link->status != DL_STATE_AVAILABLE) {
@@ -563,7 +578,7 @@ int device_links_check_suppliers(struct device *dev)
  *
  * Also change the status of @dev's links to suppliers to "active".
  *
- * Links with the DL_FLAG_STATELESS flag set are ignored.
+ * Links without the DL_FLAG_MANAGED flag set are ignored.
  */
 void device_links_driver_bound(struct device *dev)
 {
@@ -572,7 +587,7 @@ void device_links_driver_bound(struct device *dev)
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		/*
@@ -593,7 +608,7 @@ void device_links_driver_bound(struct device *dev)
 	}
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		WARN_ON(link->status != DL_STATE_CONSUMER_PROBE);
@@ -605,6 +620,13 @@ void device_links_driver_bound(struct device *dev)
 	device_links_write_unlock();
 }
 
+static void device_link_drop_managed(struct device_link *link)
+{
+	link->flags &= ~DL_FLAG_MANAGED;
+	WRITE_ONCE(link->status, DL_STATE_NONE);
+	kref_put(&link->kref, __device_link_del);
+}
+
 /**
  * __device_links_no_driver - Update links of a device without a driver.
  * @dev: Device without a drvier.
@@ -615,18 +637,18 @@ void device_links_driver_bound(struct device *dev)
  * unless they already are in the "supplier unbind in progress" state in which
  * case they need not be updated.
  *
- * Links with the DL_FLAG_STATELESS flag set are ignored.
+ * Links without the DL_FLAG_MANAGED flag set are ignored.
  */
 static void __device_links_no_driver(struct device *dev)
 {
 	struct device_link *link, *ln;
 
 	list_for_each_entry_safe_reverse(link, ln, &dev->links.suppliers, c_node) {
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER)
-			__device_link_del(&link->kref);
+			device_link_drop_managed(link);
 		else if (link->status == DL_STATE_CONSUMER_PROBE ||
 			 link->status == DL_STATE_ACTIVE)
 			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
@@ -643,7 +665,7 @@ static void __device_links_no_driver(struct device *dev)
  * %__device_links_no_driver() to update links to suppliers for it as
  * appropriate.
  *
- * Links with the DL_FLAG_STATELESS flag set are ignored.
+ * Links without the DL_FLAG_MANAGED flag set are ignored.
  */
 void device_links_no_driver(struct device *dev)
 {
@@ -652,7 +674,7 @@ void device_links_no_driver(struct device *dev)
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		/*
@@ -680,7 +702,7 @@ void device_links_no_driver(struct device *dev)
  * invoke %__device_links_no_driver() to update links to suppliers for it as
  * appropriate.
  *
- * Links with the DL_FLAG_STATELESS flag set are ignored.
+ * Links without the DL_FLAG_MANAGED flag set are ignored.
  */
 void device_links_driver_cleanup(struct device *dev)
 {
@@ -689,7 +711,7 @@ void device_links_driver_cleanup(struct device *dev)
 	device_links_write_lock();
 
 	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
@@ -702,7 +724,7 @@ void device_links_driver_cleanup(struct device *dev)
 		 */
 		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
 		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
-			__device_link_del(&link->kref);
+			device_link_drop_managed(link);
 
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}
@@ -724,7 +746,7 @@ void device_links_driver_cleanup(struct device *dev)
  *
  * Return 'false' if there are no probing or active consumers.
  *
- * Links with the DL_FLAG_STATELESS flag set are ignored.
+ * Links without the DL_FLAG_MANAGED flag set are ignored.
  */
 bool device_links_busy(struct device *dev)
 {
@@ -734,7 +756,7 @@ bool device_links_busy(struct device *dev)
 	device_links_write_lock();
 
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		if (link->status == DL_STATE_CONSUMER_PROBE
@@ -764,7 +786,7 @@ bool device_links_busy(struct device *dev)
  * driver to unbind and start over (the consumer will not re-probe as we have
  * changed the state of the link already).
  *
- * Links with the DL_FLAG_STATELESS flag set are ignored.
+ * Links without the DL_FLAG_MANAGED flag set are ignored.
  */
 void device_links_unbind_consumers(struct device *dev)
 {
@@ -776,7 +798,7 @@ void device_links_unbind_consumers(struct device *dev)
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
 		enum device_link_state status;
 
-		if (link->flags & DL_FLAG_STATELESS)
+		if (!(link->flags & DL_FLAG_MANAGED))
 			continue;
 
 		status = link->status;

commit 87a30e1f05d73a34e6d1895065541369131aaf1c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jul 17 18:08:26 2019 -0700

    driver-core, libnvdimm: Let device subsystems add local lockdep coverage
    
    For good reason, the standard device_lock() is marked
    lockdep_set_novalidate_class() because there is simply no sane way to
    describe the myriad ways the device_lock() ordered with other locks.
    However, that leaves subsystems that know their own local device_lock()
    ordering rules to find lock ordering mistakes manually. Instead,
    introduce an optional / additional lockdep-enabled lock that a subsystem
    can acquire in all the same paths that the device_lock() is acquired.
    
    A conversion of the NFIT driver and NVDIMM subsystem to a
    lockdep-validate device_lock() scheme is included. The
    debug_nvdimm_lock() implementation implements the correct lock-class and
    stacking order for the libnvdimm device topology hierarchy.
    
    Yes, this is a hack, but hopefully it is a useful hack for other
    subsystems device_lock() debug sessions. Quoting Greg:
    
        "Yeah, it feels a bit hacky but it's really up to a subsystem to mess up
         using it as much as anything else, so user beware :)
    
         I don't object to it if it makes things easier for you to debug."
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ira Weiny <ira.weiny@intel.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Ira Weiny <ira.weiny@intel.com>
    Link: https://lore.kernel.org/r/156341210661.292348.7014034644265455704.stgit@dwillia2-desk3.amr.corp.intel.com

diff --git a/drivers/base/core.c b/drivers/base/core.c
index eaf3aa0cb803..4825949d6547 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1663,6 +1663,9 @@ void device_initialize(struct device *dev)
 	kobject_init(&dev->kobj, &device_ktype);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	mutex_init(&dev->mutex);
+#ifdef CONFIG_PROVE_LOCKING
+	mutex_init(&dev->lockdep_mutex);
+#endif
 	lockdep_set_novalidate_class(&dev->mutex);
 	spin_lock_init(&dev->devres_lock);
 	INIT_LIST_HEAD(&dev->devres_head);

commit 00289cd87676e14913d2d8492d1ce05c4baafdae
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jul 17 18:07:53 2019 -0700

    drivers/base: Introduce kill_device()
    
    The libnvdimm subsystem arranges for devices to be destroyed as a result
    of a sysfs operation. Since device_unregister() cannot be called from
    an actively running sysfs attribute of the same device libnvdimm
    arranges for device_unregister() to be performed in an out-of-line async
    context.
    
    The driver core maintains a 'dead' state for coordinating its own racing
    async registration / de-registration requests. Rather than add local
    'dead' state tracking infrastructure to libnvdimm device objects, export
    the existing state tracking via a new kill_device() helper.
    
    The kill_device() helper simply marks the device as dead, i.e. that it
    is on its way to device_del(), or returns that the device was already
    dead. This can be used in advance of calling device_unregister() for
    subsystems like libnvdimm that might need to handle multiple user
    threads racing to delete a device.
    
    This refactoring does not change any behavior, but it is a pre-requisite
    for follow-on fixes and therefore marked for -stable.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Fixes: 4d88a97aa9e8 ("libnvdimm, nvdimm: dimm driver and base libnvdimm device-driver...")
    Cc: <stable@vger.kernel.org>
    Tested-by: Jane Chu <jane.chu@oracle.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/156341207332.292348.14959761496009347574.stgit@dwillia2-desk3.amr.corp.intel.com
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fd7511e04e62..eaf3aa0cb803 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2211,6 +2211,24 @@ void put_device(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(put_device);
 
+bool kill_device(struct device *dev)
+{
+	/*
+	 * Require the device lock and set the "dead" flag to guarantee that
+	 * the update behavior is consistent with the other bitfields near
+	 * it and that we cannot have an asynchronous probe routine trying
+	 * to run while we are tearing out the bus/class/sysfs from
+	 * underneath the device.
+	 */
+	lockdep_assert_held(&dev->mutex);
+
+	if (dev->p->dead)
+		return false;
+	dev->p->dead = true;
+	return true;
+}
+EXPORT_SYMBOL_GPL(kill_device);
+
 /**
  * device_del - delete device from system.
  * @dev: device.
@@ -2230,15 +2248,8 @@ void device_del(struct device *dev)
 	struct kobject *glue_dir = NULL;
 	struct class_interface *class_intf;
 
-	/*
-	 * Hold the device lock and set the "dead" flag to guarantee that
-	 * the update behavior is consistent with the other bitfields near
-	 * it and that we cannot have an asynchronous probe routine trying
-	 * to run while we are tearing out the bus/class/sysfs from
-	 * underneath the device.
-	 */
 	device_lock(dev);
-	dev->p->dead = true;
+	kill_device(dev);
 	device_unlock(dev);
 
 	/* Notify clients of device removal.  This call must come

commit f632a8170a6b667ee4e3f552087588f0fe13c4bb
Merge: ef8f3d48afd6 c33d442328f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 12:24:03 2019 -0700

    Merge tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core and debugfs updates from Greg KH:
     "Here is the "big" driver core and debugfs changes for 5.3-rc1
    
      It's a lot of different patches, all across the tree due to some api
      changes and lots of debugfs cleanups.
    
      Other than the debugfs cleanups, in this set of changes we have:
    
       - bus iteration function cleanups
    
       - scripts/get_abi.pl tool to display and parse Documentation/ABI
         entries in a simple way
    
       - cleanups to Documenatation/ABI/ entries to make them parse easier
         due to typos and other minor things
    
       - default_attrs use for some ktype users
    
       - driver model documentation file conversions to .rst
    
       - compressed firmware file loading
    
       - deferred probe fixes
    
      All of these have been in linux-next for a while, with a bunch of
      merge issues that Stephen has been patient with me for"
    
    * tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (102 commits)
      debugfs: make error message a bit more verbose
      orangefs: fix build warning from debugfs cleanup patch
      ubifs: fix build warning after debugfs cleanup patch
      driver: core: Allow subsystems to continue deferring probe
      drivers: base: cacheinfo: Ensure cpu hotplug work is done before Intel RDT
      arch_topology: Remove error messages on out-of-memory conditions
      lib: notifier-error-inject: no need to check return value of debugfs_create functions
      swiotlb: no need to check return value of debugfs_create functions
      ceph: no need to check return value of debugfs_create functions
      sunrpc: no need to check return value of debugfs_create functions
      ubifs: no need to check return value of debugfs_create functions
      orangefs: no need to check return value of debugfs_create functions
      nfsd: no need to check return value of debugfs_create functions
      lib: 842: no need to check return value of debugfs_create functions
      debugfs: provide pr_fmt() macro
      debugfs: log errors when something goes wrong
      drivers: s390/cio: Fix compilation warning about const qualifiers
      drivers: Add generic helper to match by of_node
      driver_find_device: Unify the match function with class_find_device()
      bus_find_device: Unify the match callback with class_find_device
      ...

commit 65b66682344a15ba2069d4dd8d0cc39cc3aed7e9
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:54:01 2019 +0100

    drivers: Add generic helper to match by of_node
    
    Add a helper to match device by the of_node. This will be later used
    to provide wrappers to the device iterators for {bus/class/driver}_find_device().
    Convert other users to reuse this new helper.
    
    Cc: Alan Tull <atull@kernel.org>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: David Airlie <airlied@linux.ie>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: devicetree@vger.kernel.org
    Cc: dri-devel@lists.freedesktop.org
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Heiner Kallweit <hkallweit1@gmail.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: linux-fpga@vger.kernel.org
    Cc: linux-i2c@vger.kernel.org
    Cc: linux-spi@vger.kernel.org
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Moritz Fischer <mdf@kernel.org>
    Cc: Peter Rosin <peda@axentia.se>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Thor Thayer <thor.thayer@linux.intel.com>
    Cc: Wolfram Sang <wsa@the-dreams.de>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fd7511e04e62..92119080474c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3328,3 +3328,9 @@ void device_set_of_node_from_dev(struct device *dev, const struct device *dev2)
 	dev->of_node_reused = true;
 }
 EXPORT_SYMBOL_GPL(device_set_of_node_from_dev);
+
+int device_match_of_node(struct device *dev, const void *np)
+{
+	return dev->of_node == np;
+}
+EXPORT_SYMBOL_GPL(device_match_of_node);

commit dad9bb017865ae794b6cdfac40d60b1466a09195
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri May 31 17:15:37 2019 +0300

    driver core: Add helper device_find_child_by_name()
    
    It looks like the child device is often matched with a name.
    This introduces a helper that does it automatically.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fd7511e04e62..b4c64528f13c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2474,6 +2474,34 @@ struct device *device_find_child(struct device *parent, void *data,
 }
 EXPORT_SYMBOL_GPL(device_find_child);
 
+/**
+ * device_find_child_by_name - device iterator for locating a child device.
+ * @parent: parent struct device
+ * @name: name of the child device
+ *
+ * This is similar to the device_find_child() function above, but it
+ * returns a reference to a device that has the name @name.
+ *
+ * NOTE: you will need to drop the reference with put_device() after use.
+ */
+struct device *device_find_child_by_name(struct device *parent,
+					 const char *name)
+{
+	struct klist_iter i;
+	struct device *child;
+
+	if (!parent)
+		return NULL;
+
+	klist_iter_init(&parent->p->klist_children, &i);
+	while ((child = next_device(&i)))
+		if (!strcmp(dev_name(child), name) && get_device(child))
+			break;
+	klist_iter_exit(&i);
+	return child;
+}
+EXPORT_SYMBOL_GPL(device_find_child_by_name);
+
 int __init devices_init(void)
 {
 	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);

commit affada726cad2402804ec29fc000276c7dc23b95
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Apr 18 19:41:56 2019 +0200

    driver core: Clarify which counterparts to use to device_add()
    
    It is not absolutely clear from the docs how the cleanup path after
    device_add() should look like so spell it out explicitly.
    
    No functional changes, just documentation.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4aeaa0c92bda..fd7511e04e62 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1999,6 +1999,11 @@ static int device_private_init(struct device *dev)
  * NOTE: _Never_ directly free @dev after calling this function, even
  * if it returned an error! Always use put_device() to give up your
  * reference instead.
+ *
+ * Rule of thumb is: if device_add() succeeds, you should call
+ * device_del() when you want to get rid of it. If device_add() has
+ * *not* succeeded, use *only* put_device() to drop the reference
+ * count.
  */
 int device_add(struct device *dev)
 {

commit 36003d4cf57ca431fb3f94d317bcca426a2394d6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 19 17:53:26 2019 +0100

    driver core: Fix PM-runtime for links added during consumer probe
    
    Commit 4c06c4e6cf63 ("driver core: Fix possible supplier PM-usage
    counter imbalance") introduced a regression that causes suppliers
    to be suspended prematurely for device links added during consumer
    driver probe if the initial PM-runtime status of the consumer is
    "suspended" and the consumer is resumed after adding the link and
    before pm_runtime_put_suppliers() is called.  In that case,
    pm_runtime_put_suppliers() will drop the rpm_active refcount for
    the link by one and (since rpm_active is equal to two after the
    preceding consumer resume) the supplier's PM-runtime usage counter
    will be decremented, which may cause the supplier to suspend even
    though the consumer's PM-runtime status is "active".
    
    For this reason, partially revert commit 4c06c4e6cf63 as the problem
    it tried to fix needs to be addressed somewhat differently, and
    change pm_runtime_get_suppliers() and pm_runtime_put_suppliers() so
    that the latter only drops rpm_active references acquired by the
    former.  [This requires adding a new field to struct device_link,
    but I coulnd't find a cleaner way to address the issue that would
    work in all cases.]
    
    This causes pm_runtime_put_suppliers() to effectively ignore device
    links added during consumer probe, so device_link_add() doesn't need
    to worry about ensuring that suppliers will remain active after
    pm_runtime_put_suppliers() for links created with DL_FLAG_RPM_ACTIVE
    set and it only needs to bump up rpm_active by one for those links,
    so pm_runtime_active_link() is not necessary any more.
    
    Fixes: 4c06c4e6cf63 ("driver core: Fix possible supplier PM-usage counter imbalance")
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 787190238753..4aeaa0c92bda 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -277,7 +277,7 @@ struct device_link *device_link_add(struct device *consumer,
 				link->flags |= DL_FLAG_PM_RUNTIME;
 			}
 			if (flags & DL_FLAG_RPM_ACTIVE)
-				pm_runtime_active_link(link, supplier);
+				refcount_inc(&link->rpm_active);
 		}
 
 		if (flags & DL_FLAG_STATELESS) {
@@ -310,7 +310,7 @@ struct device_link *device_link_add(struct device *consumer,
 
 	if (flags & DL_FLAG_PM_RUNTIME) {
 		if (flags & DL_FLAG_RPM_ACTIVE)
-			pm_runtime_active_link(link, supplier);
+			refcount_inc(&link->rpm_active);
 
 		pm_runtime_new_link(consumer);
 	}

commit 4c06c4e6cf63d7f3d5dfe62593a073253d750a59
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 12 13:08:10 2019 +0100

    driver core: Fix possible supplier PM-usage counter imbalance
    
    If a stateless device link to a certain supplier with
    DL_FLAG_PM_RUNTIME set in the flags is added and then removed by the
    consumer driver's probe callback, the supplier's PM-runtime usage
    counter will be nonzero after that which effectively causes the
    supplier to remain "always on" going forward.
    
    Namely, device_link_add() called to add the link invokes
    device_link_rpm_prepare() which notices that the consumer driver is
    probing, so it increments the supplier's PM-runtime usage counter
    with the assumption that the link will stay around until
    pm_runtime_put_suppliers() is called by driver_probe_device(),
    but if the link goes away before that point, the supplier's
    PM-runtime usage counter will remain nonzero.
    
    To prevent that from happening, first rework pm_runtime_get_suppliers()
    and pm_runtime_put_suppliers() to use the rpm_active refounts of device
    links and make the latter only drop rpm_active and the supplier's
    PM-runtime usage counter for each link by one, unless rpm_active is
    one already for it.  Next, modify device_link_add() to bump up the
    new link's rpm_active refcount and the suppliers PM-runtime usage
    counter by two, to prevent pm_runtime_put_suppliers(), if it is
    called subsequently, from suspending the supplier prematurely (in
    case its PM-runtime usage counter goes down to 0 in there).
    
    Due to the way rpm_put_suppliers() works, this change does not
    affect runtime suspend of the consumer ends of new device links (or,
    generally, device links for which DL_FLAG_PM_RUNTIME has just been
    set).
    
    Fixes: e2f3cd831a28 ("driver core: Fix handling of runtime PM flags in device_link_add()")
    Reported-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index abfce4f613f8..787190238753 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -165,19 +165,6 @@ void device_pm_move_to_tail(struct device *dev)
 	device_links_read_unlock(idx);
 }
 
-static void device_link_rpm_prepare(struct device *consumer,
-				    struct device *supplier)
-{
-	pm_runtime_new_link(consumer);
-	/*
-	 * If the link is being added by the consumer driver at probe time,
-	 * balance the decrementation of the supplier's runtime PM usage counter
-	 * after consumer probe in driver_probe_device().
-	 */
-	if (consumer->links.status == DL_DEV_PROBING)
-		pm_runtime_get_noresume(supplier);
-}
-
 /**
  * device_link_add - Create a link between two devices.
  * @consumer: Consumer end of the link.
@@ -286,11 +273,11 @@ struct device_link *device_link_add(struct device *consumer,
 
 		if (flags & DL_FLAG_PM_RUNTIME) {
 			if (!(link->flags & DL_FLAG_PM_RUNTIME)) {
-				device_link_rpm_prepare(consumer, supplier);
+				pm_runtime_new_link(consumer);
 				link->flags |= DL_FLAG_PM_RUNTIME;
 			}
 			if (flags & DL_FLAG_RPM_ACTIVE)
-				refcount_inc(&link->rpm_active);
+				pm_runtime_active_link(link, supplier);
 		}
 
 		if (flags & DL_FLAG_STATELESS) {
@@ -323,9 +310,9 @@ struct device_link *device_link_add(struct device *consumer,
 
 	if (flags & DL_FLAG_PM_RUNTIME) {
 		if (flags & DL_FLAG_RPM_ACTIVE)
-			refcount_inc(&link->rpm_active);
+			pm_runtime_active_link(link, supplier);
 
-		device_link_rpm_prepare(consumer, supplier);
+		pm_runtime_new_link(consumer);
 	}
 
 	get_device(supplier);

commit e7dd40105aac9ba051e44ad711123bc53a5e4c71
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:59:42 2019 +0100

    driver core: Add device link flag DL_FLAG_AUTOPROBE_CONSUMER
    
    Add a new device link flag, DL_FLAG_AUTOPROBE_CONSUMER, to request the
    driver core to probe for a consumer driver automatically after binding
    a driver to the supplier device on a persistent managed device link.
    
    As unbinding the supplier driver on a managed device link causes the
    consumer driver to be detached from its device automatically, this
    flag provides a complementary mechanism which is needed to address
    some "composite device" use cases.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9d49b461b1d9..abfce4f613f8 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -208,6 +208,12 @@ static void device_link_rpm_prepare(struct device *consumer,
  * the link will be maintained until one of the devices pointed to by it (either
  * the consumer or the supplier) is unregistered.
  *
+ * Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and
+ * DL_FLAG_AUTOREMOVE_SUPPLIER are not set in @flags (that is, a persistent
+ * managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can
+ * be used to request the driver core to automaticall probe for a consmer
+ * driver after successfully binding a driver to the supplier device.
+ *
  * The combination of DL_FLAG_STATELESS and either DL_FLAG_AUTOREMOVE_CONSUMER
  * or DL_FLAG_AUTOREMOVE_SUPPLIER set in @flags at the same time is invalid and
  * will cause NULL to be returned upfront.
@@ -228,7 +234,12 @@ struct device_link *device_link_add(struct device *consumer,
 
 	if (!consumer || !supplier ||
 	    (flags & DL_FLAG_STATELESS &&
-	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER | DL_FLAG_AUTOREMOVE_SUPPLIER)))
+	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER |
+		      DL_FLAG_AUTOREMOVE_SUPPLIER |
+		      DL_FLAG_AUTOPROBE_CONSUMER)) ||
+	    (flags & DL_FLAG_AUTOPROBE_CONSUMER &&
+	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER |
+		      DL_FLAG_AUTOREMOVE_SUPPLIER)))
 		return NULL;
 
 	if (flags & DL_FLAG_PM_RUNTIME && flags & DL_FLAG_RPM_ACTIVE) {
@@ -589,6 +600,9 @@ void device_links_driver_bound(struct device *dev)
 
 		WARN_ON(link->status != DL_STATE_DORMANT);
 		WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
+
+		if (link->flags & DL_FLAG_AUTOPROBE_CONSUMER)
+			driver_deferred_probe_add(link->consumer);
 	}
 
 	list_for_each_entry(link, &dev->links.suppliers, c_node) {

commit 72175d4ea4c442d95cf690c3e968eeee90fd43ca
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:58:33 2019 +0100

    driver core: Make driver core own stateful device links
    
    Even though stateful device links are managed by the driver core in
    principle, their creators are allowed and sometimes even expected
    to drop references to them via device_link_del() or
    device_link_remove(), but that doesn't really play well with the
    "persistent" link concept.
    
    If "persistent" managed device links are created from driver
    probe callbacks, device_link_add() called to do that will take a
    new reference on the link each time the callback runs and those
    references will never be dropped, which kind of isn't nice.
    
    This issues arises because of the link reference counting carried
    out by device_link_add() for existing links, but that is only done to
    avoid deleting device links that may still be necessary, which
    shouldn't be a concern for managed (stateful) links.  These device
    links are managed by the driver core and whoever creates one of them
    will need it at least as long as until the consumer driver is detached
    from its device and deleting it may be left to the driver core just
    fine.
    
    For this reason, rework device_link_add() to apply the reference
    counting to stateless links only and make device_link_del() and
    device_link_remove() drop references to stateless links only too.
    After this change, if called to add a stateful device link for
    a consumer-supplier pair for which a stateful device link is
    present already, device_link_add() will return the existing link
    without incrementing its reference counter.  Accordingly,
    device_link_del() and device_link_remove() will WARN() and do
    nothing when called to drop a reference to a stateful link.  Thus,
    effectively, all stateful device links will be owned by the driver
    core.
    
    In addition, clean up the handling of the link management flags,
    DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER, so that
    (a) they are never set at the same time and (b) if device_link_add()
    is called for a consumer-supplier pair with an existing stateful link
    between them, the flags of that link will be combined with the flags
    passed to device_link_add() to ensure that the life time of the link
    is sufficient for all of the callers of device_link_add() for the
    same consumer-supplier pair.
    
    Update the device_link_add() kerneldoc comment to reflect the
    above changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8c7327d45406..9d49b461b1d9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -192,10 +192,21 @@ static void device_link_rpm_prepare(struct device *consumer,
  * of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
  * ignored.
  *
- * If the DL_FLAG_AUTOREMOVE_CONSUMER flag is set, the link will be removed
- * automatically when the consumer device driver unbinds from it.  Analogously,
- * if DL_FLAG_AUTOREMOVE_SUPPLIER is set in @flags, the link will be removed
- * automatically when the supplier device driver unbinds from it.
+ * If DL_FLAG_STATELESS is set in @flags, the link is not going to be managed by
+ * the driver core and, in particular, the caller of this function is expected
+ * to drop the reference to the link acquired by it directly.
+ *
+ * If that flag is not set, however, the caller of this function is handing the
+ * management of the link over to the driver core entirely and its return value
+ * can only be used to check whether or not the link is present.  In that case,
+ * the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link
+ * flags can be used to indicate to the driver core when the link can be safely
+ * deleted.  Namely, setting one of them in @flags indicates to the driver core
+ * that the link is not going to be used (by the given caller of this function)
+ * after unbinding the consumer or supplier driver, respectively, from its
+ * device, so the link can be deleted at that point.  If none of them is set,
+ * the link will be maintained until one of the devices pointed to by it (either
+ * the consumer or the supplier) is unregistered.
  *
  * The combination of DL_FLAG_STATELESS and either DL_FLAG_AUTOREMOVE_CONSUMER
  * or DL_FLAG_AUTOREMOVE_SUPPLIER set in @flags at the same time is invalid and
@@ -241,6 +252,14 @@ struct device_link *device_link_add(struct device *consumer,
 		goto out;
 	}
 
+	/*
+	 * DL_FLAG_AUTOREMOVE_SUPPLIER indicates that the link will be needed
+	 * longer than for DL_FLAG_AUTOREMOVE_CONSUMER and setting them both
+	 * together doesn't make sense, so prefer DL_FLAG_AUTOREMOVE_SUPPLIER.
+	 */
+	if (flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
+		flags &= ~DL_FLAG_AUTOREMOVE_CONSUMER;
+
 	list_for_each_entry(link, &supplier->links.consumers, s_node) {
 		if (link->consumer != consumer)
 			continue;
@@ -254,12 +273,6 @@ struct device_link *device_link_add(struct device *consumer,
 			goto out;
 		}
 
-		if (flags & DL_FLAG_AUTOREMOVE_CONSUMER)
-			link->flags |= DL_FLAG_AUTOREMOVE_CONSUMER;
-
-		if (flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
-			link->flags |= DL_FLAG_AUTOREMOVE_SUPPLIER;
-
 		if (flags & DL_FLAG_PM_RUNTIME) {
 			if (!(link->flags & DL_FLAG_PM_RUNTIME)) {
 				device_link_rpm_prepare(consumer, supplier);
@@ -269,7 +282,25 @@ struct device_link *device_link_add(struct device *consumer,
 				refcount_inc(&link->rpm_active);
 		}
 
-		kref_get(&link->kref);
+		if (flags & DL_FLAG_STATELESS) {
+			kref_get(&link->kref);
+			goto out;
+		}
+
+		/*
+		 * If the life time of the link following from the new flags is
+		 * longer than indicated by the flags of the existing link,
+		 * update the existing link to stay around longer.
+		 */
+		if (flags & DL_FLAG_AUTOREMOVE_SUPPLIER) {
+			if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER) {
+				link->flags &= ~DL_FLAG_AUTOREMOVE_CONSUMER;
+				link->flags |= DL_FLAG_AUTOREMOVE_SUPPLIER;
+			}
+		} else if (!(flags & DL_FLAG_AUTOREMOVE_CONSUMER)) {
+			link->flags &= ~(DL_FLAG_AUTOREMOVE_CONSUMER |
+					 DL_FLAG_AUTOREMOVE_SUPPLIER);
+		}
 		goto out;
 	}
 
@@ -419,8 +450,16 @@ static void __device_link_del(struct kref *kref)
 }
 #endif /* !CONFIG_SRCU */
 
+static void device_link_put_kref(struct device_link *link)
+{
+	if (link->flags & DL_FLAG_STATELESS)
+		kref_put(&link->kref, __device_link_del);
+	else
+		WARN(1, "Unable to drop a managed device link reference\n");
+}
+
 /**
- * device_link_del - Delete a link between two devices.
+ * device_link_del - Delete a stateless link between two devices.
  * @link: Device link to delete.
  *
  * The caller must ensure proper synchronization of this function with runtime
@@ -432,14 +471,14 @@ void device_link_del(struct device_link *link)
 {
 	device_links_write_lock();
 	device_pm_lock();
-	kref_put(&link->kref, __device_link_del);
+	device_link_put_kref(link);
 	device_pm_unlock();
 	device_links_write_unlock();
 }
 EXPORT_SYMBOL_GPL(device_link_del);
 
 /**
- * device_link_remove - remove a link between two devices.
+ * device_link_remove - Delete a stateless link between two devices.
  * @consumer: Consumer end of the link.
  * @supplier: Supplier end of the link.
  *
@@ -458,7 +497,7 @@ void device_link_remove(void *consumer, struct device *supplier)
 
 	list_for_each_entry(link, &supplier->links.consumers, s_node) {
 		if (link->consumer == consumer) {
-			kref_put(&link->kref, __device_link_del);
+			device_link_put_kref(link);
 			break;
 		}
 	}

commit a1fdbfbb1da2063ba98a12eb6f1bdd07451c7145
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:52:45 2019 +0100

    driver core: Do not call rpm_put_suppliers() in pm_runtime_drop_link()
    
    Calling rpm_put_suppliers() from pm_runtime_drop_link() is excessive
    as it affects all suppliers of the consumer device and not just the
    one pointed to by the device link being dropped.  Worst case it may
    cause the consumer device to stop working unexpectedly.  Moreover, in
    principle it is racy with respect to runtime PM of the consumer
    device.
    
    To avoid these problems drop runtime PM references on the particular
    supplier pointed to by the link in question only and do that after
    the link has been dropped from the consumer device's list of links to
    suppliers, which is in device_link_free().
    
    Fixes: a0504aecba76 ("PM / runtime: Drop usage count for suppliers at device link removal")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d58ea075f807..8c7327d45406 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -374,6 +374,9 @@ EXPORT_SYMBOL_GPL(device_link_add);
 
 static void device_link_free(struct device_link *link)
 {
+	while (refcount_dec_not_one(&link->rpm_active))
+		pm_runtime_put(link->supplier);
+
 	put_device(link->consumer);
 	put_device(link->supplier);
 	kfree(link);

commit 15cfb094160385cc0b303c4cda483caa102af654
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:50:39 2019 +0100

    driver core: Fix adding device links to probing suppliers
    
    Currently, it is not valid to add a device link from a consumer
    driver ->probe callback to a supplier that is still probing too, but
    generally this is a valid use case.  For example, if the consumer has
    just acquired a resource that can only be available if the supplier
    is functional, adding a device link to that supplier right away
    should be safe (and even desirable arguably), but device_link_add()
    doesn't handle that case correctly and the initial state of the link
    created by it is wrong then.
    
    To address this problem, change the initial state of device links
    added between a probing supplier and a probing consumer to
    DL_STATE_CONSUMER_PROBE and update device_links_driver_bound() to
    skip such links on the supplier side.
    
    With this change, if the supplier probe completes first,
    device_links_driver_bound() called for it will skip the link state
    update and when it is called for the consumer, the link state will
    be updated to "active".  In turn, if the consumer probe completes
    first, device_links_driver_bound() called for it will change the
    state of the link to "active" and when it is called for the
    supplier, the link status update will be skipped.
    
    However, in principle the supplier or consumer probe may still fail
    after the link has been added, so modify device_links_no_driver() to
    change device links in the "active" or "consumer probe" state to
    "dormant" on the supplier side and update __device_links_no_driver()
    to change the link state to "available" only if it is "consumer
    probe" or "active".
    
    Then, if the supplier probe fails first, the leftover link to the
    probing consumer will become "dormant" and device_links_no_driver()
    called for the consumer (when its probe fails) will clean it up.
    In turn, if the consumer probe fails first, it will either drop the
    link, or change its state to "available" and, in the latter case,
    when device_links_no_driver() is called for the supplier, it will
    update the link state to "dormant".  [If the supplier probe fails,
    but the consumer probe succeeds, which should not happen as long as
    the consumer driver is correct, the link still will be around, but
    it will be "dormant" until the supplier is probed again.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8611385e44b5..d58ea075f807 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -300,17 +300,26 @@ struct device_link *device_link_add(struct device *consumer,
 		link->status = DL_STATE_NONE;
 	} else {
 		switch (supplier->links.status) {
-		case DL_DEV_DRIVER_BOUND:
+		case DL_DEV_PROBING:
 			switch (consumer->links.status) {
 			case DL_DEV_PROBING:
 				/*
-				 * Some callers expect the link creation during
-				 * consumer driver probe to resume the supplier
-				 * even without DL_FLAG_RPM_ACTIVE.
+				 * A consumer driver can create a link to a
+				 * supplier that has not completed its probing
+				 * yet as long as it knows that the supplier is
+				 * already functional (for example, it has just
+				 * acquired some resources from the supplier).
 				 */
-				if (flags & DL_FLAG_PM_RUNTIME)
-					pm_runtime_resume(supplier);
-
+				link->status = DL_STATE_CONSUMER_PROBE;
+				break;
+			default:
+				link->status = DL_STATE_DORMANT;
+				break;
+			}
+			break;
+		case DL_DEV_DRIVER_BOUND:
+			switch (consumer->links.status) {
+			case DL_DEV_PROBING:
 				link->status = DL_STATE_CONSUMER_PROBE;
 				break;
 			case DL_DEV_DRIVER_BOUND:
@@ -330,6 +339,14 @@ struct device_link *device_link_add(struct device *consumer,
 		}
 	}
 
+	/*
+	 * Some callers expect the link creation during consumer driver probe to
+	 * resume the supplier even without DL_FLAG_RPM_ACTIVE.
+	 */
+	if (link->status == DL_STATE_CONSUMER_PROBE &&
+	    flags & DL_FLAG_PM_RUNTIME)
+		pm_runtime_resume(supplier);
+
 	/*
 	 * Move the consumer and all of the devices depending on it to the end
 	 * of dpm_list and the devices_kset list.
@@ -518,6 +535,16 @@ void device_links_driver_bound(struct device *dev)
 		if (link->flags & DL_FLAG_STATELESS)
 			continue;
 
+		/*
+		 * Links created during consumer probe may be in the "consumer
+		 * probe" state to start with if the supplier is still probing
+		 * when they are created and they may become "active" if the
+		 * consumer probe returns first.  Skip them here.
+		 */
+		if (link->status == DL_STATE_CONSUMER_PROBE ||
+		    link->status == DL_STATE_ACTIVE)
+			continue;
+
 		WARN_ON(link->status != DL_STATE_DORMANT);
 		WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
 	}
@@ -557,17 +584,48 @@ static void __device_links_no_driver(struct device *dev)
 
 		if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER)
 			__device_link_del(&link->kref);
-		else if (link->status != DL_STATE_SUPPLIER_UNBIND)
+		else if (link->status == DL_STATE_CONSUMER_PROBE ||
+			 link->status == DL_STATE_ACTIVE)
 			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
 	}
 
 	dev->links.status = DL_DEV_NO_DRIVER;
 }
 
+/**
+ * device_links_no_driver - Update links after failing driver probe.
+ * @dev: Device whose driver has just failed to probe.
+ *
+ * Clean up leftover links to consumers for @dev and invoke
+ * %__device_links_no_driver() to update links to suppliers for it as
+ * appropriate.
+ *
+ * Links with the DL_FLAG_STATELESS flag set are ignored.
+ */
 void device_links_no_driver(struct device *dev)
 {
+	struct device_link *link;
+
 	device_links_write_lock();
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		/*
+		 * The probe has failed, so if the status of the link is
+		 * "consumer probe" or "active", it must have been added by
+		 * a probing consumer while this device was still probing.
+		 * Change its state to "dormant", as it represents a valid
+		 * relationship, but it is not functionally meaningful.
+		 */
+		if (link->status == DL_STATE_CONSUMER_PROBE ||
+		    link->status == DL_STATE_ACTIVE)
+			WRITE_ONCE(link->status, DL_STATE_DORMANT);
+	}
+
 	__device_links_no_driver(dev);
+
 	device_links_write_unlock();
 }
 

commit e2f3cd831a280fc226118d9369bf3f77aab58c56
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:49:14 2019 +0100

    driver core: Fix handling of runtime PM flags in device_link_add()
    
    After commit ead18c23c263 ("driver core: Introduce device links
    reference counting"), if there is a link between the given supplier
    and the given consumer already, device_link_add() will refcount it
    and return it unconditionally without updating its flags.  It is
    possible, however, that the second (or any subsequent) caller of
    device_link_add() for the same consumer-supplier pair will pass
    DL_FLAG_PM_RUNTIME, possibly along with DL_FLAG_RPM_ACTIVE, in flags
    to it and the existing link may not behave as expected then.
    
    First, if DL_FLAG_PM_RUNTIME is not set in the existing link's flags
    at all, it needs to be set like during the original initialization of
    the link.
    
    Second, if DL_FLAG_RPM_ACTIVE is passed to device_link_add() in flags
    (in addition to DL_FLAG_PM_RUNTIME), the existing link should to be
    updated to reflect the "active" runtime PM configuration of the
    consumer-supplier pair and extra care must be taken here to avoid
    possible destructive races with runtime PM of the consumer.
    
    To that end, redefine the rpm_active field in struct device_link
    as a refcount, initialize it to 1 and make rpm_resume() (for the
    consumer) and device_link_add() increment it whenever they acquire
    a runtime PM reference on the supplier device.  Accordingly, make
    rpm_suspend() (for the consumer) and pm_runtime_clean_up_links()
    decrement it and drop runtime PM references to the supplier
    device in a loop until rpm_active becones 1 again.
    
    Fixes: ead18c23c263 ("driver core: Introduce device links reference counting")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 50610cd87e71..8611385e44b5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -165,6 +165,19 @@ void device_pm_move_to_tail(struct device *dev)
 	device_links_read_unlock(idx);
 }
 
+static void device_link_rpm_prepare(struct device *consumer,
+				    struct device *supplier)
+{
+	pm_runtime_new_link(consumer);
+	/*
+	 * If the link is being added by the consumer driver at probe time,
+	 * balance the decrementation of the supplier's runtime PM usage counter
+	 * after consumer probe in driver_probe_device().
+	 */
+	if (consumer->links.status == DL_DEV_PROBING)
+		pm_runtime_get_noresume(supplier);
+}
+
 /**
  * device_link_add - Create a link between two devices.
  * @consumer: Consumer end of the link.
@@ -201,7 +214,6 @@ struct device_link *device_link_add(struct device *consumer,
 				    struct device *supplier, u32 flags)
 {
 	struct device_link *link;
-	bool rpm_put_supplier = false;
 
 	if (!consumer || !supplier ||
 	    (flags & DL_FLAG_STATELESS &&
@@ -213,7 +225,6 @@ struct device_link *device_link_add(struct device *consumer,
 			pm_runtime_put_noidle(supplier);
 			return NULL;
 		}
-		rpm_put_supplier = true;
 	}
 
 	device_links_write_lock();
@@ -249,6 +260,15 @@ struct device_link *device_link_add(struct device *consumer,
 		if (flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
 			link->flags |= DL_FLAG_AUTOREMOVE_SUPPLIER;
 
+		if (flags & DL_FLAG_PM_RUNTIME) {
+			if (!(link->flags & DL_FLAG_PM_RUNTIME)) {
+				device_link_rpm_prepare(consumer, supplier);
+				link->flags |= DL_FLAG_PM_RUNTIME;
+			}
+			if (flags & DL_FLAG_RPM_ACTIVE)
+				refcount_inc(&link->rpm_active);
+		}
+
 		kref_get(&link->kref);
 		goto out;
 	}
@@ -257,20 +277,15 @@ struct device_link *device_link_add(struct device *consumer,
 	if (!link)
 		goto out;
 
+	refcount_set(&link->rpm_active, 1);
+
 	if (flags & DL_FLAG_PM_RUNTIME) {
-		if (flags & DL_FLAG_RPM_ACTIVE) {
-			link->rpm_active = true;
-			rpm_put_supplier = false;
-		}
-		pm_runtime_new_link(consumer);
-		/*
-		 * If the link is being added by the consumer driver at probe
-		 * time, balance the decrementation of the supplier's runtime PM
-		 * usage counter after consumer probe in driver_probe_device().
-		 */
-		if (consumer->links.status == DL_DEV_PROBING)
-			pm_runtime_get_noresume(supplier);
+		if (flags & DL_FLAG_RPM_ACTIVE)
+			refcount_inc(&link->rpm_active);
+
+		device_link_rpm_prepare(consumer, supplier);
 	}
+
 	get_device(supplier);
 	link->supplier = supplier;
 	INIT_LIST_HEAD(&link->s_node);
@@ -333,7 +348,7 @@ struct device_link *device_link_add(struct device *consumer,
 	device_pm_unlock();
 	device_links_write_unlock();
 
-	if (rpm_put_supplier)
+	if ((flags & DL_FLAG_PM_RUNTIME && flags & DL_FLAG_RPM_ACTIVE) && !link)
 		pm_runtime_put(supplier);
 
 	return link;

commit 5db25c9eb893df8f6b93c1d97b8006d768e1b6f5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:47:53 2019 +0100

    driver core: Do not resume suppliers under device_links_write_lock()
    
    It is incorrect to call pm_runtime_get_sync() under
    device_links_write_lock(), because it may end up trying to take
    device_links_read_lock() while resuming the target device and that
    will deadlock in the non-SRCU case, so avoid that by resuming the
    supplier device in device_link_add() before calling
    device_links_write_lock().
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Fixes: baa8809f6097 ("PM / runtime: Optimize the use of device links")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a4d6f9b93088..50610cd87e71 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -201,12 +201,21 @@ struct device_link *device_link_add(struct device *consumer,
 				    struct device *supplier, u32 flags)
 {
 	struct device_link *link;
+	bool rpm_put_supplier = false;
 
 	if (!consumer || !supplier ||
 	    (flags & DL_FLAG_STATELESS &&
 	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER | DL_FLAG_AUTOREMOVE_SUPPLIER)))
 		return NULL;
 
+	if (flags & DL_FLAG_PM_RUNTIME && flags & DL_FLAG_RPM_ACTIVE) {
+		if (pm_runtime_get_sync(supplier) < 0) {
+			pm_runtime_put_noidle(supplier);
+			return NULL;
+		}
+		rpm_put_supplier = true;
+	}
+
 	device_links_write_lock();
 	device_pm_lock();
 
@@ -250,13 +259,8 @@ struct device_link *device_link_add(struct device *consumer,
 
 	if (flags & DL_FLAG_PM_RUNTIME) {
 		if (flags & DL_FLAG_RPM_ACTIVE) {
-			if (pm_runtime_get_sync(supplier) < 0) {
-				pm_runtime_put_noidle(supplier);
-				kfree(link);
-				link = NULL;
-				goto out;
-			}
 			link->rpm_active = true;
+			rpm_put_supplier = false;
 		}
 		pm_runtime_new_link(consumer);
 		/*
@@ -328,6 +332,10 @@ struct device_link *device_link_add(struct device *consumer,
  out:
 	device_pm_unlock();
 	device_links_write_unlock();
+
+	if (rpm_put_supplier)
+		pm_runtime_put(supplier);
+
 	return link;
 }
 EXPORT_SYMBOL_GPL(device_link_add);

commit f265df550a4350dce0a4d721a77c52e4b847ea40
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:46:54 2019 +0100

    driver core: Avoid careless re-use of existing device links
    
    After commit ead18c23c263 ("driver core: Introduce device links
    reference counting"), if there is a link between the given supplier
    and the given consumer already, device_link_add() will refcount it
    and return it unconditionally.  However, if the flags passed to
    it on the second (or any subsequent) attempt to create a device
    link between the same consumer-supplier pair are not compatible with
    the existing link's flags, that is incorrect.
    
    First off, if the existing link is stateless and the next caller of
    device_link_add() for the same consumer-supplier pair wants a
    stateful one, or the other way around, the existing link cannot be
    returned, because it will not match the expected behavior, so make
    device_link_add() dump the stack and return NULL in that case.
    
    Moreover, if the DL_FLAG_AUTOREMOVE_CONSUMER flag is passed to
    device_link_add(), its caller will expect its reference to the link
    to be dropped automatically on consumer driver removal, which will
    not happen if that flag is not set in the link's flags (and
    analogously for DL_FLAG_AUTOREMOVE_SUPPLIER).  For this reason, make
    device_link_add() update the existing link's flags accordingly
    before returning it to the caller.
    
    Fixes: ead18c23c263 ("driver core: Introduce device links reference counting")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f24eb2daad00..a4d6f9b93088 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -221,12 +221,29 @@ struct device_link *device_link_add(struct device *consumer,
 		goto out;
 	}
 
-	list_for_each_entry(link, &supplier->links.consumers, s_node)
-		if (link->consumer == consumer) {
-			kref_get(&link->kref);
+	list_for_each_entry(link, &supplier->links.consumers, s_node) {
+		if (link->consumer != consumer)
+			continue;
+
+		/*
+		 * Don't return a stateless link if the caller wants a stateful
+		 * one and vice versa.
+		 */
+		if (WARN_ON((flags & DL_FLAG_STATELESS) != (link->flags & DL_FLAG_STATELESS))) {
+			link = NULL;
 			goto out;
 		}
 
+		if (flags & DL_FLAG_AUTOREMOVE_CONSUMER)
+			link->flags |= DL_FLAG_AUTOREMOVE_CONSUMER;
+
+		if (flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
+			link->flags |= DL_FLAG_AUTOREMOVE_SUPPLIER;
+
+		kref_get(&link->kref);
+		goto out;
+	}
+
 	link = kzalloc(sizeof(*link), GFP_KERNEL);
 	if (!link)
 		goto out;

commit c8d50986da5d74ddfc233b13b91d0a13369fa164
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:45:55 2019 +0100

    driver core: Fix DL_FLAG_AUTOREMOVE_SUPPLIER device link flag handling
    
    Change the list walk in device_links_driver_cleanup() to a safe one
    to avoid use-after-free when dropping a link from the list during the
    walk.
    
    Also, while at it, fix device_link_add() to refuse to create
    stateless device links with DL_FLAG_AUTOREMOVE_SUPPLIER set, which is
    an invalid combination (setting that flag means that the driver core
    should manage the link, so it cannot be stateless), and extend the
    kerneldoc comment of device_link_add() to cover the
    DL_FLAG_AUTOREMOVE_SUPPLIER flag properly too.
    
    Fixes: 1689cac5b32a ("driver core: Add flag to autoremove device link on supplier unbind")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 1febfd2a353a..f24eb2daad00 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -179,10 +179,14 @@ void device_pm_move_to_tail(struct device *dev)
  * of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
  * ignored.
  *
- * If the DL_FLAG_AUTOREMOVE_CONSUMER is set, the link will be removed
- * automatically when the consumer device driver unbinds from it.
- * The combination of both DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_STATELESS
- * set is invalid and will cause NULL to be returned.
+ * If the DL_FLAG_AUTOREMOVE_CONSUMER flag is set, the link will be removed
+ * automatically when the consumer device driver unbinds from it.  Analogously,
+ * if DL_FLAG_AUTOREMOVE_SUPPLIER is set in @flags, the link will be removed
+ * automatically when the supplier device driver unbinds from it.
+ *
+ * The combination of DL_FLAG_STATELESS and either DL_FLAG_AUTOREMOVE_CONSUMER
+ * or DL_FLAG_AUTOREMOVE_SUPPLIER set in @flags at the same time is invalid and
+ * will cause NULL to be returned upfront.
  *
  * A side effect of the link creation is re-ordering of dpm_list and the
  * devices_kset list by moving the consumer device and all devices depending
@@ -199,8 +203,8 @@ struct device_link *device_link_add(struct device *consumer,
 	struct device_link *link;
 
 	if (!consumer || !supplier ||
-	    ((flags & DL_FLAG_STATELESS) &&
-	     (flags & DL_FLAG_AUTOREMOVE_CONSUMER)))
+	    (flags & DL_FLAG_STATELESS &&
+	     flags & (DL_FLAG_AUTOREMOVE_CONSUMER | DL_FLAG_AUTOREMOVE_SUPPLIER)))
 		return NULL;
 
 	device_links_write_lock();
@@ -539,11 +543,11 @@ void device_links_no_driver(struct device *dev)
  */
 void device_links_driver_cleanup(struct device *dev)
 {
-	struct device_link *link;
+	struct device_link *link, *ln;
 
 	device_links_write_lock();
 
-	list_for_each_entry(link, &dev->links.consumers, s_node) {
+	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
 		if (link->flags & DL_FLAG_STATELESS)
 			continue;
 

commit 3451a495ef244a88ed6317a035299d835554d579
Author: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date:   Tue Jan 22 10:39:10 2019 -0800

    driver core: Establish order of operations for device_add and device_del via bitflag
    
    Add an additional bit flag to the device_private struct named "dead".
    
    This additional flag provides a guarantee that when a device_del is
    executed on a given interface an async worker will not attempt to attach
    the driver following the earlier device_del call. Previously this
    guarantee was not present and could result in the device_del call
    attempting to remove a driver from an interface only to have the async
    worker attempt to probe the driver later when it finally completes the
    asynchronous probe call.
    
    One additional change added was that I pulled the check for dev->driver
    out of the __device_attach_driver call and instead placed it in the
    __device_attach_async_helper call. This was motivated by the fact that the
    only other caller of this, __device_attach, had already taken the
    device_lock() and checked for dev->driver. Instead of testing for this
    twice in this path it makes more sense to just consolidate the dev->dead
    and dev->driver checks together into one set of checks.
    
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 26f8cd6dd0b3..1febfd2a353a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2080,6 +2080,17 @@ void device_del(struct device *dev)
 	struct kobject *glue_dir = NULL;
 	struct class_interface *class_intf;
 
+	/*
+	 * Hold the device lock and set the "dead" flag to guarantee that
+	 * the update behavior is consistent with the other bitfields near
+	 * it and that we cannot have an asynchronous probe routine trying
+	 * to run while we are tearing out the bus/class/sysfs from
+	 * underneath the device.
+	 */
+	device_lock(dev);
+	dev->p->dead = true;
+	device_unlock(dev);
+
 	/* Notify clients of device removal.  This call must come
 	 * before dpm_sysfs_remove().
 	 */

commit 0fe6f7874d467456da6f6a221dd92499a3ab1780
Author: Yong Wu <yong.wu@mediatek.com>
Date:   Tue Jan 1 12:51:05 2019 +0800

    driver core: Remove the link if there is no driver with AUTO flag
    
    DL_FLAG_AUTOREMOVE_CONSUMER/SUPPLIER means "Remove the link
    automatically on consumer/supplier driver unbind", that means we should
    remove whole the device_link when there is no this driver no matter what
    the ref_count of the link is.
    
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Yong Wu <yong.wu@mediatek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4e57e1632f87..26f8cd6dd0b3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -512,7 +512,7 @@ static void __device_links_no_driver(struct device *dev)
 			continue;
 
 		if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER)
-			kref_put(&link->kref, __device_link_del);
+			__device_link_del(&link->kref);
 		else if (link->status != DL_STATE_SUPPLIER_UNBIND)
 			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
 	}
@@ -557,7 +557,7 @@ void device_links_driver_cleanup(struct device *dev)
 		 */
 		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
 		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
-			kref_put(&link->kref, __device_link_del);
+			__device_link_del(&link->kref);
 
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}

commit 8a4b32691120b8fd6b029f5ad37d742a97ec82c1
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 21 17:23:41 2018 +0100

    driver core: silence device link messages unless debugging
    
    On platforms making a fair use of regulators, the dev_info() messages
    coming from the device link function are a bit too verbose. The amount
    of message will increase further with the clock framework joining the
    device link party.
    
    These messages looks valuable for people debugging device link related
    issues, so dev_dbg() looks more appropriate than dev_info().
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Acked-by: Kevin Hilman <khilman@baylibre.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4a4b6f8cbc4f..4e57e1632f87 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -302,7 +302,7 @@ struct device_link *device_link_add(struct device *consumer,
 	list_add_tail_rcu(&link->s_node, &supplier->links.consumers);
 	list_add_tail_rcu(&link->c_node, &consumer->links.suppliers);
 
-	dev_info(consumer, "Linked as a consumer to %s\n", dev_name(supplier));
+	dev_dbg(consumer, "Linked as a consumer to %s\n", dev_name(supplier));
 
  out:
 	device_pm_unlock();
@@ -328,8 +328,8 @@ static void __device_link_del(struct kref *kref)
 {
 	struct device_link *link = container_of(kref, struct device_link, kref);
 
-	dev_info(link->consumer, "Dropping the link to %s\n",
-		 dev_name(link->supplier));
+	dev_dbg(link->consumer, "Dropping the link to %s\n",
+		dev_name(link->supplier));
 
 	if (link->flags & DL_FLAG_PM_RUNTIME)
 		pm_runtime_drop_link(link->consumer);

commit 570d0200123fb4f809aa2f6226e93a458d664d70
Author: Wei Yang <richardw.yang@linux.intel.com>
Date:   Fri Jan 18 10:34:59 2019 +0800

    driver core: move device->knode_class to device_private
    
    As the description of struct device_private says, it stores data which
    is private to driver core. And it already has similar fields like:
    knode_parent, knode_driver, knode_driver and knode_bus. This look it is
    more proper to put knode_class together with those fields to make it
    private to driver core.
    
    This patch move device->knode_class to device_private to make it comply
    with code convention.
    
    Signed-off-by: Wei Yang <richardw.yang@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0073b09bb99f..4a4b6f8cbc4f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1966,7 +1966,7 @@ int device_add(struct device *dev)
 	if (dev->class) {
 		mutex_lock(&dev->class->p->mutex);
 		/* tie the class to the device */
-		klist_add_tail(&dev->knode_class,
+		klist_add_tail(&dev->p->knode_class,
 			       &dev->class->p->klist_devices);
 
 		/* notify any interfaces that the device is here */
@@ -2105,7 +2105,7 @@ void device_del(struct device *dev)
 			if (class_intf->remove_dev)
 				class_intf->remove_dev(dev, class_intf);
 		/* remove the device from the class list */
-		klist_del(&dev->knode_class);
+		klist_del(&dev->p->knode_class);
 		mutex_unlock(&dev->class->p->mutex);
 	}
 	device_remove_file(dev, &dev_attr_uevent);

commit b07039b79c9ea64c1eacda1e01d645082e4a0d5d
Merge: 02061181d3a9 16df1456aa85
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 20:44:29 2018 -0800

    Merge tag 'driver-core-4.21-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the "big" set of driver core patches for 4.21-rc1.
    
      It's not really big, just a number of small changes for some reported
      issues, some documentation updates to hopefully make it harder for
      people to abuse the driver model, and some other minor cleanups.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.21-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:
      mm, memory_hotplug: update a comment in unregister_memory()
      component: convert to DEFINE_SHOW_ATTRIBUTE
      sysfs: Disable lockdep for driver bind/unbind files
      driver core: Add missing dev->bus->need_parent_lock checks
      kobject: return error code if writing /sys/.../uevent fails
      driver core: Move async_synchronize_full call
      driver core: platform: Respect return code of platform_device_register_full()
      kref/kobject: Improve documentation
      drivers/base/memory.c: Use DEVICE_ATTR_RO and friends
      driver core: Replace simple_strto{l,ul} by kstrtou{l,ul}
      kernfs: Improve kernfs_notify() poll notification latency
      kobject: Fix warnings in lib/kobject_uevent.c
      kobject: drop unnecessary cast "%llu" for u64
      driver core: fix comments for device_block_probing()
      driver core: Replace simple_strtol by kstrtoint

commit df44b479654f62b478c18ee4d8bc4e9f897a9844
Author: Peter Rajnoha <prajnoha@redhat.com>
Date:   Wed Dec 5 12:27:44 2018 +0100

    kobject: return error code if writing /sys/.../uevent fails
    
    Propagate error code back to userspace if writing the /sys/.../uevent
    file fails. Before, the write operation always returned with success,
    even if we failed to recognize the input string or if we failed to
    generate the uevent itself.
    
    With the error codes properly propagated back to userspace, we are
    able to react in userspace accordingly by not assuming and awaiting
    a uevent that is not delivered.
    
    Signed-off-by: Peter Rajnoha <prajnoha@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e2285059161d..a4ced331bc50 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1073,8 +1073,14 @@ static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
 static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
-	if (kobject_synth_uevent(&dev->kobj, buf, count))
+	int rc;
+
+	rc = kobject_synth_uevent(&dev->kobj, buf, count);
+
+	if (rc) {
 		dev_err(dev, "uevent: failed to send synthetic uevent\n");
+		return rc;
+	}
 
 	return count;
 }

commit 186bddb28ff9f61250d1b33554321d0bf5d085f6
Author: Ezequiel Garcia <ezequiel@collabora.com>
Date:   Mon Dec 3 13:44:35 2018 -0300

    kref/kobject: Improve documentation
    
    The current kref and kobject documentation may be
    insufficient to understand these common pitfalls regarding
    object lifetime and object releasing.
    
    Add a bit more documentation and improve the warnings
    seen by the user, pointing to the right piece of documentation.
    
    Also, it's important to understand that making fun of people
    publicly is not at all helpful, doesn't provide any value,
    and it's not a healthy way of encouraging developers to do better.
    
    "Mocking mercilessly" will, if anything, make developers feel bad
    and go away. This kind of behavior should not be encouraged or justified.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@collabora.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Matthias Brugger <mbrugger@suse.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ed145fbfeddf..e2285059161d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -897,8 +897,7 @@ static void device_release(struct kobject *kobj)
 	else if (dev->class && dev->class->dev_release)
 		dev->class->dev_release(dev);
 	else
-		WARN(1, KERN_ERR "Device '%s' does not have a release() "
-			"function, it is broken and must be fixed.\n",
+		WARN(1, KERN_ERR "Device '%s' does not have a release() function, it is broken and must be fixed. See Documentation/kobject.txt.\n",
 			dev_name(dev));
 	kfree(p);
 }

commit f88184bfee48d482dfff04cd1eed6906f289db4a
Author: Kaitao cheng <pilgrimtao@gmail.com>
Date:   Tue Nov 6 08:34:54 2018 -0800

    driver core: Replace simple_strto{l,ul} by kstrtou{l,ul}
    
    The simple_strto{l,ul} are deprecated, use kstrtou{l,ul} instead.
    
    Signed-off-by: Kaitao cheng <pilgrimtao@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 04bbcd779e11..ed145fbfeddf 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -794,10 +794,12 @@ ssize_t device_store_ulong(struct device *dev,
 			   const char *buf, size_t size)
 {
 	struct dev_ext_attribute *ea = to_ext_attr(attr);
-	char *end;
-	unsigned long new = simple_strtoul(buf, &end, 0);
-	if (end == buf)
-		return -EINVAL;
+	int ret;
+	unsigned long new;
+
+	ret = kstrtoul(buf, 0, &new);
+	if (ret)
+		return ret;
 	*(unsigned long *)(ea->var) = new;
 	/* Always return full write size even if we didn't consume all */
 	return size;
@@ -818,9 +820,14 @@ ssize_t device_store_int(struct device *dev,
 			 const char *buf, size_t size)
 {
 	struct dev_ext_attribute *ea = to_ext_attr(attr);
-	char *end;
-	long new = simple_strtol(buf, &end, 0);
-	if (end == buf || new > INT_MAX || new < INT_MIN)
+	int ret;
+	long new;
+
+	ret = kstrtol(buf, 0, &new);
+	if (ret)
+		return ret;
+
+	if (new > INT_MAX || new < INT_MIN)
 		return -EINVAL;
 	*(int *)(ea->var) = new;
 	/* Always return full write size even if we didn't consume all */

commit 59abd83672f70cac4b6bf9b237506c5bc6837606
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri Nov 9 17:21:36 2018 +0300

    drivers: base: Introducing software nodes to the firmware node framework
    
    Software node is a new struct fwnode_handle type that can be
    used to describe devices in kernel (software). It is meant
    to complement fwnodes representing real firmware nodes when
    they are incomplete (for example missing device properties)
    and to supply the primary fwnode when the firmware lacks
    hardware description for a device completely.
    
    The software node type is really meant to replace the
    currently used "property_set" struct fwnode_handle type. The
    handling of struct property_set is glued to the generic
    device property handling code, and it is not possible to
    create a struct property_set independently from the device
    that it is bind to. struct property_set is only created when
    device properties are added to already initialized struct
    device, and control of it is only possible from the generic
    property handling code.
    
    Software nodes are instead designed to be created
    independently from the device entries (struct device). It
    makes them much more flexible, as then the device meant to
    be bind to the node can be created at a later time, and from
    another location. It is also possible to bind multiple
    devices to a single software node if needed.
    
    The software node implementation also includes support for
    node hierarchy, which was the main motivation for this
    commit. The node hierarchy was something that was requested
    for the struct property_set, but it did not seem reasonable
    to try to extend the property_set support for that purpose.
    struct property_set was really meant only for device
    property handling like the name suggests.
    
    Support for struct property_set is not yet removed in this
    commit, but it will be in the following one.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 260cbdf44f1d..a2f14098663f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -738,6 +738,10 @@ device_platform_notify(struct device *dev, enum kobject_action action)
 	if (ret)
 		return ret;
 
+	ret = software_node_notify(dev, action);
+	if (ret)
+		return ret;
+
 	if (platform_notify && action == KOBJ_ADD)
 		platform_notify(dev);
 	else if (platform_notify_remove && action == KOBJ_REMOVE)

commit 7847a1455fc4574d53e349d60feb1e1106cdc012
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri Nov 9 17:21:35 2018 +0300

    ACPI / glue: Add acpi_platform_notify() function
    
    Instead of relying on the "platform_notify" callback hook,
    introducing separate notification function
    acpi_platform_notify() and calling that directly from
    drivers core when device entries are added and removed.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 3972ef3f080b..260cbdf44f1d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -8,6 +8,7 @@
  * Copyright (c) 2006 Novell, Inc.
  */
 
+#include <linux/acpi.h>
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/fwnode.h>
@@ -731,6 +732,12 @@ static inline int device_is_not_partition(struct device *dev)
 static int
 device_platform_notify(struct device *dev, enum kobject_action action)
 {
+	int ret;
+
+	ret = acpi_platform_notify(dev, action);
+	if (ret)
+		return ret;
+
 	if (platform_notify && action == KOBJ_ADD)
 		platform_notify(dev);
 	else if (platform_notify_remove && action == KOBJ_REMOVE)

commit 07de0e86fe081cd74f5b397af86172d156280d3e
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri Nov 9 17:21:34 2018 +0300

    drivers core: Prepare support for multiple platform notifications
    
    Since it should be possible to support several hardware
    description models at the same time (at least in theory),
    for example ACPI and devicetree on a running system, the
    platform notifications need to be handled differently.
    
    For now a single "platform_notify" callback function was
    used to notify the underlying base system which is in charge
    of the hardware description when a new device entry was
    added to the system, but that callback is available to only
    a single base system at the time. This will add a function
    device_platform_notify() and replace all direct
    platform_notify() calls with it.
    
    device_platform_notify() will first simply call the
    platform_notify() callback, so this commit has no functional
    affect, however, the idea is that individual base systems
    will put their direct notification calls there instead of
    using the platform_notify function pointer.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 04bbcd779e11..3972ef3f080b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -728,6 +728,16 @@ static inline int device_is_not_partition(struct device *dev)
 }
 #endif
 
+static int
+device_platform_notify(struct device *dev, enum kobject_action action)
+{
+	if (platform_notify && action == KOBJ_ADD)
+		platform_notify(dev);
+	else if (platform_notify_remove && action == KOBJ_REMOVE)
+		platform_notify_remove(dev);
+	return 0;
+}
+
 /**
  * dev_driver_string - Return a device's driver name, if at all possible
  * @dev: struct device to get the name of
@@ -1883,8 +1893,9 @@ int device_add(struct device *dev)
 	}
 
 	/* notify platform of device entry */
-	if (platform_notify)
-		platform_notify(dev);
+	error = device_platform_notify(dev, KOBJ_ADD);
+	if (error)
+		goto platform_error;
 
 	error = device_create_file(dev, &dev_attr_uevent);
 	if (error)
@@ -1960,6 +1971,8 @@ int device_add(struct device *dev)
  SymlinkError:
 	device_remove_file(dev, &dev_attr_uevent);
  attrError:
+	device_platform_notify(dev, KOBJ_REMOVE);
+platform_error:
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	glue_dir = get_glue_dir(dev);
 	kobject_del(&dev->kobj);
@@ -2077,14 +2090,10 @@ void device_del(struct device *dev)
 	bus_remove_device(dev);
 	device_pm_remove(dev);
 	driver_deferred_probe_del(dev);
+	device_platform_notify(dev, KOBJ_REMOVE);
 	device_remove_properties(dev);
 	device_links_purge(dev);
 
-	/* Notify the platform of the removal, in case they
-	 * need to do anything...
-	 */
-	if (platform_notify_remove)
-		platform_notify_remove(dev);
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_REMOVED_DEVICE, dev);

commit a18d783fedfe6f9b720afe901db9501ce116ed81
Merge: d5acba26bfa0 d2fc88a61b4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 18 11:44:53 2018 -0700

    Merge tag 'driver-core-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here are all of the driver core and related patches for 4.19-rc1.
    
      Nothing huge here, just a number of small cleanups and the ability to
      now stop the deferred probing after init happens.
    
      All of these have been in linux-next for a while with only a merge
      issue reported"
    
    * tag 'driver-core-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (21 commits)
      base: core: Remove WARN_ON from link dependencies check
      drivers/base: stop new probing during shutdown
      drivers: core: Remove glue dirs from sysfs earlier
      driver core: remove unnecessary function extern declare
      sysfs.h: fix non-kernel-doc comment
      PM / Domains: Stop deferring probe at the end of initcall
      iommu: Remove IOMMU_OF_DECLARE
      iommu: Stop deferring probe at end of initcalls
      pinctrl: Support stopping deferred probe after initcalls
      dt-bindings: pinctrl: add a 'pinctrl-use-default' property
      driver core: allow stopping deferred probe after init
      driver core: add a debugfs entry to show deferred devices
      sysfs: Fix internal_create_group() for named group updates
      base: fix order of OF initialization
      linux/device.h: fix kernel-doc notation warning
      Documentation: update firmware loader fallback reference
      kobject: Replace strncpy with memcpy
      drivers: base: cacheinfo: use OF property_read_u32 instead of get_property,read_number
      kernfs: Replace strncpy with memcpy
      device: Add #define dev_fmt similar to #define pr_fmt
      ...

commit 9a76aba02a37718242d7cdc294f0a3901928aa57
Merge: 0a957467c5fd 26a1ccc6c117
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 15 15:04:25 2018 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Highlights:
    
       - Gustavo A. R. Silva keeps working on the implicit switch fallthru
         changes.
    
       - Support 802.11ax High-Efficiency wireless in cfg80211 et al, From
         Luca Coelho.
    
       - Re-enable ASPM in r8169, from Kai-Heng Feng.
    
       - Add virtual XFRM interfaces, which avoids all of the limitations of
         existing IPSEC tunnels. From Steffen Klassert.
    
       - Convert GRO over to use a hash table, so that when we have many
         flows active we don't traverse a long list during accumluation.
    
       - Many new self tests for routing, TC, tunnels, etc. Too many
         contributors to mention them all, but I'm really happy to keep
         seeing this stuff.
    
       - Hardware timestamping support for dpaa_eth/fsl-fman from Yangbo Lu.
    
       - Lots of cleanups and fixes in L2TP code from Guillaume Nault.
    
       - Add IPSEC offload support to netdevsim, from Shannon Nelson.
    
       - Add support for slotting with non-uniform distribution to netem
         packet scheduler, from Yousuk Seung.
    
       - Add UDP GSO support to mlx5e, from Boris Pismenny.
    
       - Support offloading of Team LAG in NFP, from John Hurley.
    
       - Allow to configure TX queue selection based upon RX queue, from
         Amritha Nambiar.
    
       - Support ethtool ring size configuration in aquantia, from Anton
         Mikaev.
    
       - Support DSCP and flowlabel per-transport in SCTP, from Xin Long.
    
       - Support list based batching and stack traversal of SKBs, this is
         very exciting work. From Edward Cree.
    
       - Busyloop optimizations in vhost_net, from Toshiaki Makita.
    
       - Introduce the ETF qdisc, which allows time based transmissions. IGB
         can offload this in hardware. From Vinicius Costa Gomes.
    
       - Add parameter support to devlink, from Moshe Shemesh.
    
       - Several multiplication and division optimizations for BPF JIT in
         nfp driver, from Jiong Wang.
    
       - Lots of prepatory work to make more of the packet scheduler layer
         lockless, when possible, from Vlad Buslov.
    
       - Add ACK filter and NAT awareness to sch_cake packet scheduler, from
         Toke Høiland-Jørgensen.
    
       - Support regions and region snapshots in devlink, from Alex Vesker.
    
       - Allow to attach XDP programs to both HW and SW at the same time on
         a given device, with initial support in nfp. From Jakub Kicinski.
    
       - Add TLS RX offload and support in mlx5, from Ilya Lesokhin.
    
       - Use PHYLIB in r8169 driver, from Heiner Kallweit.
    
       - All sorts of changes to support Spectrum 2 in mlxsw driver, from
         Ido Schimmel.
    
       - PTP support in mv88e6xxx DSA driver, from Andrew Lunn.
    
       - Make TCP_USER_TIMEOUT socket option more accurate, from Jon
         Maxwell.
    
       - Support for templates in packet scheduler classifier, from Jiri
         Pirko.
    
       - IPV6 support in RDS, from Ka-Cheong Poon.
    
       - Native tproxy support in nf_tables, from Máté Eckl.
    
       - Maintain IP fragment queue in an rbtree, but optimize properly for
         in-order frags. From Peter Oskolkov.
    
       - Improvde handling of ACKs on hole repairs, from Yuchung Cheng"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1996 commits)
      bpf: test: fix spelling mistake "REUSEEPORT" -> "REUSEPORT"
      hv/netvsc: Fix NULL dereference at single queue mode fallback
      net: filter: mark expected switch fall-through
      xen-netfront: fix warn message as irq device name has '/'
      cxgb4: Add new T5 PCI device ids 0x50af and 0x50b0
      net: dsa: mv88e6xxx: missing unlock on error path
      rds: fix building with IPV6=m
      inet/connection_sock: prefer _THIS_IP_ to current_text_addr
      net: dsa: mv88e6xxx: bitwise vs logical bug
      net: sock_diag: Fix spectre v1 gadget in __sock_diag_cmd()
      ieee802154: hwsim: using right kind of iteration
      net: hns3: Add vlan filter setting by ethtool command -K
      net: hns3: Set tx ring' tc info when netdev is up
      net: hns3: Remove tx ring BD len register in hns3_enet
      net: hns3: Fix desc num set to default when setting channel
      net: hns3: Fix for phy link issue when using marvell phy driver
      net: hns3: Fix for information of phydev lost problem when down/up
      net: hns3: Fix for command format parsing error in hclge_is_all_function_id_zero
      net: hns3: Add support for serdes loopback selftest
      bnxt_en: take coredump_record structure off stack
      ...

commit b018fc9800557bd14a40d69501e19c340eb2c521
Merge: c07b3682cd12 7425ecd5e3e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 14 13:12:24 2018 -0700

    Merge tag 'pm-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These add a new framework for CPU idle time injection, to be used by
      all of the idle injection code in the kernel in the future, fix some
      issues and add a number of relatively small extensions in multiple
      places.
    
      Specifics:
    
       - Add a new framework for CPU idle time injection (Daniel Lezcano).
    
       - Add AVS support to the armada-37xx cpufreq driver (Gregory
         CLEMENT).
    
       - Add support for current CPU frequency reporting to the ACPI CPPC
         cpufreq driver (George Cherian).
    
       - Rework the cooling device registration in the imx6q/thermal driver
         (Bastian Stender).
    
       - Make the pcc-cpufreq driver refuse to work with dynamic scaling
         governors on systems with many CPUs to avoid scalability issues
         with it (Rafael Wysocki).
    
       - Fix the intel_pstate driver to report different maximum CPU
         frequencies on systems where they really are different and to
         ignore the turbo active ratio if hardware-managend P-states (HWP)
         are in use; make it use the match_string() helper (Xie Yisheng,
         Srinivas Pandruvada).
    
       - Fix a minor deferred probe issue in the qcom-kryo cpufreq driver
         (Niklas Cassel).
    
       - Add a tracepoint for the tracking of frequency limits changes (from
         Andriod) to the cpufreq core (Ruchi Kandoi).
    
       - Fix a circular lock dependency between CPU hotplug and sysfs
         locking in the cpufreq core reported by lockdep (Waiman Long).
    
       - Avoid excessive error reports on driver registration failures in
         the ARM cpuidle driver (Sudeep Holla).
    
       - Add a new device links flag to the driver core to make links go
         away automatically on supplier driver removal (Vivek Gautam).
    
       - Eliminate potential race condition between system-wide power
         management transitions and system shutdown (Pingfan Liu).
    
       - Add a quirk to save NVS memory on system suspend for the ASUS 1025C
         laptop (Willy Tarreau).
    
       - Make more systems use suspend-to-idle (instead of ACPI S3) by
         default (Tristian Celestin).
    
       - Get rid of stack VLA usage in the low-level hibernation code on
         64-bit x86 (Kees Cook).
    
       - Fix error handling in the hibernation core and mark an expected
         fall-through switch in it (Chengguang Xu, Gustavo Silva).
    
       - Extend the generic power domains (genpd) framework to support
         attaching a device to a power domain by name (Ulf Hansson).
    
       - Fix device reference counting and user limits initialization in the
         devfreq core (Arvind Yadav, Matthias Kaehlcke).
    
       - Fix a few issues in the rk3399_dmc devfreq driver and improve its
         documentation (Enric Balletbo i Serra, Lin Huang, Nick Milner).
    
       - Drop a redundant error message from the exynos-ppmu devfreq driver
         (Markus Elfring)"
    
    * tag 'pm-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (35 commits)
      PM / reboot: Eliminate race between reboot and suspend
      PM / hibernate: Mark expected switch fall-through
      cpufreq: intel_pstate: Ignore turbo active ratio in HWP
      cpufreq: Fix a circular lock dependency problem
      cpu/hotplug: Add a cpus_read_trylock() function
      x86/power/hibernate_64: Remove VLA usage
      cpufreq: trace frequency limits change
      cpufreq: intel_pstate: Show different max frequency with turbo 3 and HWP
      cpufreq: pcc-cpufreq: Disable dynamic scaling on many-CPU systems
      cpufreq: qcom-kryo: Silently error out on EPROBE_DEFER
      cpufreq / CPPC: Add cpuinfo_cur_freq support for CPPC
      cpufreq: armada-37xx: Add AVS support
      dt-bindings: marvell: Add documentation for the Armada 3700 AVS binding
      PM / devfreq: rk3399_dmc: Fix duplicated opp table on reload.
      PM / devfreq: Init user limits from OPP limits, not viceversa
      PM / devfreq: rk3399_dmc: fix spelling mistakes.
      PM / devfreq: rk3399_dmc: do not print error when get supply and clk defer.
      dt-bindings: devfreq: rk3399_dmc: move interrupts to be optional.
      PM / devfreq: rk3399_dmc: remove wait for dcf irq event.
      dt-bindings: clock: add rk3399 DDR3 standard speed bins.
      ...

commit d22d59362b7b2c749245f1269d447011c76ca41d
Merge: a8afa92ec0d9 46fc033eba42
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Aug 10 17:31:24 2018 +0100

    Merge branch 'regulator-4.19' into regulator-next

commit e16f4f3e0b7daecd48d4f944ab4147c1a6cb16a8
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Mon Jul 16 13:37:44 2018 +0200

    base: core: Remove WARN_ON from link dependencies check
    
    In some cases the link between between customer and supplier
    already exist, for example when a device use its parent as a supplier.
    Do not warn about already existing dependencies because device_link_add()
    takes care of this case.
    
    Link: http://lkml.kernel.org/r/20180709111753eucas1p1f32e66fb2f7ea3216097cd72a132355d~-rzycA5Rg0378203782eucas1p1C@eucas1p1.samsung.com
    
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    Reviewed-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 5411af447418..2300d834d11f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -105,7 +105,7 @@ static int device_is_dependent(struct device *dev, void *target)
 	struct device_link *link;
 	int ret;
 
-	if (WARN_ON(dev == target))
+	if (dev == target)
 		return 1;
 
 	ret = device_for_each_child(dev, target, device_is_dependent);
@@ -113,7 +113,7 @@ static int device_is_dependent(struct device *dev, void *target)
 		return ret;
 
 	list_for_each_entry(link, &dev->links.consumers, s_node) {
-		if (WARN_ON(link->consumer == target))
+		if (link->consumer == target)
 			return 1;
 
 		ret = device_is_dependent(link->consumer, target);

commit 3297c8fc65af5d40501ea7cddff1b195cae57e4e
Author: Pingfan Liu <kernelfans@gmail.com>
Date:   Thu Jul 19 13:14:58 2018 +0800

    drivers/base: stop new probing during shutdown
    
    There is a race window in device_shutdown(), which may cause
    -1. parent device shut down before child or
    -2. no shutdown on a new probing device.
    
    For 1st, taking the following scenario:
             device_shutdown                        new plugin device
      list_del_init(parent_dev);
      spin_unlock(list_lock);
                                                      device_add(child)
                                                      probe child
      shutdown parent_dev
           --> now child is on the tail of devices_kset
    
    For 2nd, taking the following scenario:
             device_shutdown                        new plugin device
                                                      device_add(dev)
      device_lock(dev);
      ...
      device_unlock(dev);
                                                      probe dev
           --> now, the new occurred dev has no opportunity to shutdown
    
    To fix this race issue, just prevent the new probing request. With this
    logic, device_shutdown() is more similar to dpm_prepare().
    
    Signed-off-by: Pingfan Liu <kernelfans@gmail.com>
    Reviewed-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index cf8c605ec32e..5411af447418 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2811,6 +2811,9 @@ void device_shutdown(void)
 {
 	struct device *dev, *parent;
 
+	wait_for_device_probe();
+	device_block_probing();
+
 	spin_lock(&devices_kset->list_lock);
 	/*
 	 * Walk the devices list backward, shutting down each in turn.

commit 9944e894c1266dc8515c82d1ff752d681215526b
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 20 21:56:50 2018 +0000

    driver core: set up ownership of class devices in sysfs
    
    Plumb in get_ownership() callback for devices belonging to a class so that
    they can be created with uid/gid different from global root. This will
    allow network devices in a container to belong to container's root and not
    global root.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index df3e1a44707a..276c7e3f754c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -866,10 +866,19 @@ static const void *device_namespace(struct kobject *kobj)
 	return ns;
 }
 
+static void device_get_ownership(struct kobject *kobj, kuid_t *uid, kgid_t *gid)
+{
+	struct device *dev = kobj_to_dev(kobj);
+
+	if (dev->class && dev->class->get_ownership)
+		dev->class->get_ownership(dev, uid, gid);
+}
+
 static struct kobj_type device_ktype = {
 	.release	= device_release,
 	.sysfs_ops	= &dev_sysfs_ops,
 	.namespace	= device_namespace,
+	.get_ownership	= device_get_ownership,
 };
 
 

commit 726e41097920a73e4c7c33385dcc0debb1281e18
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 10 10:29:10 2018 +1000

    drivers: core: Remove glue dirs from sysfs earlier
    
    For devices with a class, we create a "glue" directory between
    the parent device and the new device with the class name.
    
    This directory is never "explicitely" removed when empty however,
    this is left to the implicit sysfs removal done by kobject_release()
    when the object loses its last reference via kobject_put().
    
    This is problematic because as long as it's not been removed from
    sysfs, it is still present in the class kset and in sysfs directory
    structure.
    
    The presence in the class kset exposes a use after free bug fixed
    by the previous patch, but the presence in sysfs means that until
    the kobject is released, which can take a while (especially with
    kobject debugging), any attempt at re-creating such as binding a
    new device for that class/parent pair, will result in a sysfs
    duplicate file name error.
    
    This fixes it by instead doing an explicit kobject_del() when
    the glue dir is empty, by keeping track of the number of
    child devices of the gluedir.
    
    This is made easy by the fact that all glue dir operations are
    done with a global mutex, and there's already a function
    (cleanup_glue_dir) called in all the right places taking that
    mutex that can be enhanced for this. It appears that this was
    in fact the intent of the function, but the implementation was
    wrong.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9a6c71038616..cf8c605ec32e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1597,6 +1597,8 @@ static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 		return;
 
 	mutex_lock(&gdp_mutex);
+	if (!kobject_has_children(glue_dir))
+		kobject_del(glue_dir);
 	kobject_put(glue_dir);
 	mutex_unlock(&gdp_mutex);
 }

commit 46d3a03781ea70e25360660ac53bbb838de11c97
Author: Shaokun Zhang <zhangshaokun@hisilicon.com>
Date:   Sun Jul 15 18:08:56 2018 +0800

    driver core: remove unnecessary function extern declare
    
    device_private_init is called only in core.c, extern declare is
    unnecessary and make it static.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Shaokun Zhang <zhangshaokun@hisilicon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ceb8ce90aebb..9a6c71038616 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1736,7 +1736,7 @@ static void device_remove_sys_dev_entry(struct device *dev)
 	}
 }
 
-int device_private_init(struct device *dev)
+static int device_private_init(struct device *dev)
 {
 	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
 	if (!dev->p)

commit 1689cac5b32a6db6f812e8063ea418a7cf023d03
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Wed Jun 27 18:20:56 2018 +0530

    driver core: Add flag to autoremove device link on supplier unbind
    
    Add a flag to autoremove the device links on supplier driver
    unbind. This obviates the need to explicitly delete the link
    in the remove path.
    We remove these links only when the supplier's link to its
    consumers has gone to DL_STATE_SUPPLIER_UNBIND state.
    
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Suggested-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 14c1e3151e08..e721218bf352 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -518,6 +518,16 @@ void device_links_driver_cleanup(struct device *dev)
 
 		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
 		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
+
+		/*
+		 * autoremove the links between this @dev and its consumer
+		 * devices that are not active, i.e. where the link state
+		 * has moved to DL_STATE_SUPPLIER_UNBIND.
+		 */
+		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
+		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
+			kref_put(&link->kref, __device_link_del);
+
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}
 

commit e88728f46cfbb59cc7e7acf1d230c05ec093764e
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Wed Jun 27 18:20:55 2018 +0530

    driver core: Rename flag AUTOREMOVE to AUTOREMOVE_CONSUMER
    
    Now that we want to add another flag to autoremove the device link
    on supplier unbind, it's fair to rename the existing flag from
    DL_FLAG_AUTOREMOVE to DL_FLAG_AUTOREMOVE_CONSUMER so that we can
    add similar flag for supplier later.
    And, while we are touching device.h, fix a doc build warning.
    
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index df3e1a44707a..14c1e3151e08 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -178,10 +178,10 @@ void device_pm_move_to_tail(struct device *dev)
  * of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
  * ignored.
  *
- * If the DL_FLAG_AUTOREMOVE is set, the link will be removed automatically
- * when the consumer device driver unbinds from it.  The combination of both
- * DL_FLAG_AUTOREMOVE and DL_FLAG_STATELESS set is invalid and will cause NULL
- * to be returned.
+ * If the DL_FLAG_AUTOREMOVE_CONSUMER is set, the link will be removed
+ * automatically when the consumer device driver unbinds from it.
+ * The combination of both DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_STATELESS
+ * set is invalid and will cause NULL to be returned.
  *
  * A side effect of the link creation is re-ordering of dpm_list and the
  * devices_kset list by moving the consumer device and all devices depending
@@ -198,7 +198,8 @@ struct device_link *device_link_add(struct device *consumer,
 	struct device_link *link;
 
 	if (!consumer || !supplier ||
-	    ((flags & DL_FLAG_STATELESS) && (flags & DL_FLAG_AUTOREMOVE)))
+	    ((flags & DL_FLAG_STATELESS) &&
+	     (flags & DL_FLAG_AUTOREMOVE_CONSUMER)))
 		return NULL;
 
 	device_links_write_lock();
@@ -479,7 +480,7 @@ static void __device_links_no_driver(struct device *dev)
 		if (link->flags & DL_FLAG_STATELESS)
 			continue;
 
-		if (link->flags & DL_FLAG_AUTOREMOVE)
+		if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER)
 			kref_put(&link->kref, __device_link_del);
 		else if (link->status != DL_STATE_SUPPLIER_UNBIND)
 			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
@@ -515,7 +516,7 @@ void device_links_driver_cleanup(struct device *dev)
 		if (link->flags & DL_FLAG_STATELESS)
 			continue;
 
-		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE);
+		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
 		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
 		WRITE_ONCE(link->status, DL_STATE_DORMANT);
 	}

commit 663336ee2628096df0ce2b546b148cb74b5249fe
Author: Joe Perches <joe@perches.com>
Date:   Wed May 9 08:15:46 2018 -0700

    device: Add #define dev_fmt similar to #define pr_fmt
    
    Add a prefixing macro to dev_<level> uses similar to the pr_fmt
    prefixing macro used in pr_<level> calls.
    
    This can help avoid some string duplication in dev_<level> uses.
    
    The default, like pr_fmt, is an empty #define dev_fmt(fmt) fmt
    
    Rename the existing dev_<level> functions to _dev_<level> and
    introduce #define dev_<level> _dev_<level> macros that use the
    new #define dev_fmt
    
    Miscellanea:
    
    o Consistently use #defines with fmt, ... and ##__VA_ARGS__
    o Remove unnecessary externs
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index df3e1a44707a..ceb8ce90aebb 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3002,12 +3002,12 @@ void func(const struct device *dev, const char *fmt, ...)	\
 }								\
 EXPORT_SYMBOL(func);
 
-define_dev_printk_level(dev_emerg, KERN_EMERG);
-define_dev_printk_level(dev_alert, KERN_ALERT);
-define_dev_printk_level(dev_crit, KERN_CRIT);
-define_dev_printk_level(dev_err, KERN_ERR);
-define_dev_printk_level(dev_warn, KERN_WARNING);
-define_dev_printk_level(dev_notice, KERN_NOTICE);
+define_dev_printk_level(_dev_emerg, KERN_EMERG);
+define_dev_printk_level(_dev_alert, KERN_ALERT);
+define_dev_printk_level(_dev_crit, KERN_CRIT);
+define_dev_printk_level(_dev_err, KERN_ERR);
+define_dev_printk_level(_dev_warn, KERN_WARNING);
+define_dev_printk_level(_dev_notice, KERN_NOTICE);
 define_dev_printk_level(_dev_info, KERN_INFO);
 
 #endif

commit d8842211b6f63d3f069df973d137de0a85964965
Author: pascal paillet <p.paillet@st.com>
Date:   Thu Jul 5 14:25:56 2018 +0000

    driver core: Add device_link_remove function
    
    Device_link_remove uses the same arguments than device_link_add. The Goal
    is to avoid storing the link pointer.
    
    Signed-off-by: pascal paillet <p.paillet@st.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 36622b52e419..3b380b1f2768 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -365,6 +365,36 @@ void device_link_del(struct device_link *link)
 }
 EXPORT_SYMBOL_GPL(device_link_del);
 
+/**
+ * device_link_remove - remove a link between two devices.
+ * @consumer: Consumer end of the link.
+ * @supplier: Supplier end of the link.
+ *
+ * The caller must ensure proper synchronization of this function with runtime
+ * PM.
+ */
+void device_link_remove(void *consumer, struct device *supplier)
+{
+	struct device_link *link;
+
+	if (WARN_ON(consumer == supplier))
+		return;
+
+	device_links_write_lock();
+	device_pm_lock();
+
+	list_for_each_entry(link, &supplier->links.consumers, s_node) {
+		if (link->consumer == consumer) {
+			kref_put(&link->kref, __device_link_del);
+			break;
+		}
+	}
+
+	device_pm_unlock();
+	device_links_write_unlock();
+}
+EXPORT_SYMBOL_GPL(device_link_remove);
+
 static void device_links_missing_supplier(struct device *dev)
 {
 	struct device_link *link;

commit 47e5abfb546a3ace23a77453dc2e9db92704c5ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 14 10:01:52 2018 +0200

    PM / core: Fix supplier device runtime PM usage counter imbalance
    
    If a device link is added via device_link_add() by the driver of the
    link's consumer device, the supplier's runtime PM usage counter is
    going to be dropped by the pm_runtime_put_suppliers() call in
    driver_probe_device().  However, in that case it is not incremented
    unless the supplier driver is already present and the link is not
    stateless.  That leads to a runtime PM usage counter imbalance for
    the supplier device in a few cases.
    
    To prevent that from happening, bump up the supplier runtime
    PM usage counter in device_link_add() for all links with the
    DL_FLAG_PM_RUNTIME flag set that are added at the consumer probe
    time.  Use pm_runtime_get_noresume() for that as the callers of
    device_link_add() who want the supplier to be resumed by it are
    expected to pass DL_FLAG_RPM_ACTIVE in flags to it anyway, but
    additionally resume the supplier if the link is added during
    consumer driver probe to retain the existing behavior for the
    callers depending on it.
    
    Fixes: 21d5c57b3726 (PM / runtime: Use device links)
    Reported-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 36622b52e419..df3e1a44707a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -236,6 +236,13 @@ struct device_link *device_link_add(struct device *consumer,
 			link->rpm_active = true;
 		}
 		pm_runtime_new_link(consumer);
+		/*
+		 * If the link is being added by the consumer driver at probe
+		 * time, balance the decrementation of the supplier's runtime PM
+		 * usage counter after consumer probe in driver_probe_device().
+		 */
+		if (consumer->links.status == DL_DEV_PROBING)
+			pm_runtime_get_noresume(supplier);
 	}
 	get_device(supplier);
 	link->supplier = supplier;
@@ -255,12 +262,12 @@ struct device_link *device_link_add(struct device *consumer,
 			switch (consumer->links.status) {
 			case DL_DEV_PROBING:
 				/*
-				 * Balance the decrementation of the supplier's
-				 * runtime PM usage counter after consumer probe
-				 * in driver_probe_device().
+				 * Some callers expect the link creation during
+				 * consumer driver probe to resume the supplier
+				 * even without DL_FLAG_RPM_ACTIVE.
 				 */
 				if (flags & DL_FLAG_PM_RUNTIME)
-					pm_runtime_get_sync(supplier);
+					pm_runtime_resume(supplier);
 
 				link->status = DL_STATE_CONSUMER_PROBE;
 				break;

commit ec064d3c6b40697fd72f4b1eeabbf293b7947a04
Merge: abf7dba7c4f7 8c97a46af04b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 16:29:19 2018 -0700

    Merge tag 'driver-core-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the driver core patchset for 4.18-rc1.
    
      The large chunk of these are firmware core documentation and api
      updates. Nothing major there, just better descriptions for others to
      be able to understand the firmware code better. There's also a user
      for a new firmware api call.
    
      Other than that, there are some minor updates for debugfs, kernfs, and
      the driver core itself.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (23 commits)
      driver core: hold dev's parent lock when needed
      driver-core: return EINVAL error instead of BUG_ON()
      driver core: add __printf verification to device_create_groups_vargs
      mm: memory_hotplug: use put_device() if device_register fail
      base: core: fix typo 'can by' to 'can be'
      debugfs: inode: debugfs_create_dir uses mode permission from parent
      debugfs: Re-use kstrtobool_from_user()
      Documentation: clarify firmware_class provenance and why we can't rename the module
      Documentation: remove stale firmware API reference
      Documentation: fix few typos and clarifications for the firmware loader
      ath10k: re-enable the firmware fallback mechanism for testmode
      ath10k: use firmware_request_nowarn() to load firmware
      firmware: add firmware_request_nowarn() - load firmware without warnings
      firmware_loader: make firmware_fallback_sysfs() print more useful
      firmware_loader: move kconfig FW_LOADER entries to its own file
      firmware_loader: replace ---help--- with help
      firmware_loader: enhance Kconfig documentation over FW_LOADER
      firmware_loader: document firmware_sysfs_fallback()
      firmware: rename fw_sysfs_fallback to firmware_fallback_sysfs()
      firmware: use () to terminate kernel-doc function names
      ...

commit 6a8b55d7f2265efdabf257211b662400615cf580
Author: Mathieu Malaterre <malat@debian.org>
Date:   Sat May 5 21:57:41 2018 +0200

    driver core: add __printf verification to device_create_groups_vargs
    
    __printf is useful to verify format and arguments. Remove the following
    warning (with W=1):
    
      drivers/base/core.c:2435:2: warning: function might be possible candidate for ‘gnu_printf’ format attribute [-Wsuggest-attribute=format]
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c4fc083870c2..35221144e0e6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2411,7 +2411,7 @@ static void device_create_release(struct device *dev)
 	kfree(dev);
 }
 
-static struct device *
+static __printf(6, 0) struct device *
 device_create_groups_vargs(struct class *class, struct device *parent,
 			   dev_t devt, void *drvdata,
 			   const struct attribute_group **groups,

commit 13509860efcada3e57c16d5f2e60dda8cef6054c
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Sun May 6 13:23:47 2018 +0200

    base: core: fix typo 'can by' to 'can be'
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d680fd030316..c4fc083870c2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2689,7 +2689,7 @@ static int device_move_class_links(struct device *dev,
 /**
  * device_move - moves a device to a new parent
  * @dev: the pointer to the struct device to be moved
- * @new_parent: the new parent of the device (can by NULL)
+ * @new_parent: the new parent of the device (can be NULL)
  * @dpm_order: how to reorder the dpm_list
  */
 int device_move(struct device *dev, struct device *new_parent,

commit 84d0c27d6233a9ba0578b20f5a09701eb66cee42
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Mon May 7 19:10:31 2018 +0900

    driver core: Don't ignore class_dir_create_and_add() failure.
    
    syzbot is hitting WARN() at kernfs_add_one() [1].
    This is because kernfs_create_link() is confused by previous device_add()
    call which continued without setting dev->kobj.parent field when
    get_device_parent() failed by memory allocation fault injection.
    Fix this by propagating the error from class_dir_create_and_add() to
    the calllers of get_device_parent().
    
    [1] https://syzkaller.appspot.com/bug?id=fae0fb607989ea744526d1c082a5b8de6529116f
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reported-by: syzbot <syzbot+df47f81c226b31d89fb1@syzkaller.appspotmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b610816eb887..d680fd030316 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1467,7 +1467,7 @@ class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)
 
 	dir = kzalloc(sizeof(*dir), GFP_KERNEL);
 	if (!dir)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	dir->class = class;
 	kobject_init(&dir->kobj, &class_dir_ktype);
@@ -1477,7 +1477,7 @@ class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)
 	retval = kobject_add(&dir->kobj, parent_kobj, "%s", class->name);
 	if (retval < 0) {
 		kobject_put(&dir->kobj);
-		return NULL;
+		return ERR_PTR(retval);
 	}
 	return &dir->kobj;
 }
@@ -1784,6 +1784,10 @@ int device_add(struct device *dev)
 
 	parent = get_device(dev->parent);
 	kobj = get_device_parent(dev, parent);
+	if (IS_ERR(kobj)) {
+		error = PTR_ERR(kobj);
+		goto parent_error;
+	}
 	if (kobj)
 		dev->kobj.parent = kobj;
 
@@ -1882,6 +1886,7 @@ int device_add(struct device *dev)
 	kobject_del(&dev->kobj);
  Error:
 	cleanup_glue_dir(dev, glue_dir);
+parent_error:
 	put_device(parent);
 name_error:
 	kfree(dev->p);
@@ -2701,6 +2706,11 @@ int device_move(struct device *dev, struct device *new_parent,
 	device_pm_lock();
 	new_parent = get_device(new_parent);
 	new_parent_kobj = get_device_parent(dev, new_parent);
+	if (IS_ERR(new_parent_kobj)) {
+		error = PTR_ERR(new_parent_kobj);
+		put_device(new_parent);
+		goto out;
+	}
 
 	pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),
 		 __func__, new_parent ? dev_name(new_parent) : "<NULL>");

commit 494fd7b7ad10c33d3a7ff7d10b71b3ecad10474a
Author: Feng Kan <fkan@apm.com>
Date:   Tue Apr 10 16:57:06 2018 -0700

    PM / core: fix deferred probe breaking suspend resume order
    
    When bridge and its endpoint is enumerated the devices are added to the
    dpm list. Afterward, the bridge defers probe when IOMMU is not ready.
    This causes the bridge to be moved to the end of the dpm list when
    deferred probe kicks in. The order of the dpm list for bridge and
    endpoint is reversed.
    
    Add reordering code to move the bridge and its children and consumers to
    the end of the pm list so the order for suspend and resume is not altered.
    The code also move device and its children and consumers to the tail of
    device_kset list if it is registered.
    
    Signed-off-by: Toan Le <toanle@apm.com>
    Signed-off-by: Feng Kan <fkan@apm.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b610816eb887..ad7b50897bcc 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -144,6 +144,26 @@ static int device_reorder_to_tail(struct device *dev, void *not_used)
 	return 0;
 }
 
+/**
+ * device_pm_move_to_tail - Move set of devices to the end of device lists
+ * @dev: Device to move
+ *
+ * This is a device_reorder_to_tail() wrapper taking the requisite locks.
+ *
+ * It moves the @dev along with all of its children and all of its consumers
+ * to the ends of the device_kset and dpm_list, recursively.
+ */
+void device_pm_move_to_tail(struct device *dev)
+{
+	int idx;
+
+	idx = device_links_read_lock();
+	device_pm_lock();
+	device_reorder_to_tail(dev, NULL);
+	device_pm_unlock();
+	device_links_read_unlock(idx);
+}
+
 /**
  * device_link_add - Create a link between two devices.
  * @consumer: Consumer end of the link.

commit ead18c23c263374ed098a7d955b29b4a466d4573
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Feb 10 19:27:12 2018 +0100

    driver core: Introduce device links reference counting
    
    If device_link_add() is invoked multiple times with the same supplier
    and consumer combo, it will create the link on first addition and
    return a pointer to the already existing link on all subsequent
    additions.
    
    The semantics for device_link_del() are quite different, it deletes
    the link unconditionally, so multiple invocations are not allowed.
    
    In other words, this snippet ...
    
        struct device *dev1, *dev2;
        struct device_link *link1, *link2;
    
        link1 = device_link_add(dev1, dev2, 0);
        link2 = device_link_add(dev1, dev2, 0);
    
        device_link_del(link1);
        device_link_del(link2);
    
    ... causes the following crash:
    
        WARNING: CPU: 4 PID: 2686 at drivers/base/power/runtime.c:1611 pm_runtime_drop_link+0x40/0x50
        [...]
        list_del corruption, 0000000039b800a4->prev is LIST_POISON2 (00000000ecf79852)
        kernel BUG at lib/list_debug.c:50!
    
    The issue isn't as arbitrary as it may seem:  Imagine a device link
    which is added in both the supplier's and the consumer's ->probe hook.
    The two drivers can't just call device_link_del() in their ->remove hook
    without coordination.
    
    Fix by counting multiple additions and dropping the device link only
    when the last addition is unwound.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 5847364f25d9..b610816eb887 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -196,8 +196,10 @@ struct device_link *device_link_add(struct device *consumer,
 	}
 
 	list_for_each_entry(link, &supplier->links.consumers, s_node)
-		if (link->consumer == consumer)
+		if (link->consumer == consumer) {
+			kref_get(&link->kref);
 			goto out;
+		}
 
 	link = kzalloc(sizeof(*link), GFP_KERNEL);
 	if (!link)
@@ -222,6 +224,7 @@ struct device_link *device_link_add(struct device *consumer,
 	link->consumer = consumer;
 	INIT_LIST_HEAD(&link->c_node);
 	link->flags = flags;
+	kref_init(&link->kref);
 
 	/* Determine the initial link state. */
 	if (flags & DL_FLAG_STATELESS) {
@@ -292,8 +295,10 @@ static void __device_link_free_srcu(struct rcu_head *rhead)
 	device_link_free(container_of(rhead, struct device_link, rcu_head));
 }
 
-static void __device_link_del(struct device_link *link)
+static void __device_link_del(struct kref *kref)
 {
+	struct device_link *link = container_of(kref, struct device_link, kref);
+
 	dev_info(link->consumer, "Dropping the link to %s\n",
 		 dev_name(link->supplier));
 
@@ -305,8 +310,10 @@ static void __device_link_del(struct device_link *link)
 	call_srcu(&device_links_srcu, &link->rcu_head, __device_link_free_srcu);
 }
 #else /* !CONFIG_SRCU */
-static void __device_link_del(struct device_link *link)
+static void __device_link_del(struct kref *kref)
 {
+	struct device_link *link = container_of(kref, struct device_link, kref);
+
 	dev_info(link->consumer, "Dropping the link to %s\n",
 		 dev_name(link->supplier));
 
@@ -324,13 +331,15 @@ static void __device_link_del(struct device_link *link)
  * @link: Device link to delete.
  *
  * The caller must ensure proper synchronization of this function with runtime
- * PM.
+ * PM.  If the link was added multiple times, it needs to be deleted as often.
+ * Care is required for hotplugged devices:  Their links are purged on removal
+ * and calling device_link_del() is then no longer allowed.
  */
 void device_link_del(struct device_link *link)
 {
 	device_links_write_lock();
 	device_pm_lock();
-	__device_link_del(link);
+	kref_put(&link->kref, __device_link_del);
 	device_pm_unlock();
 	device_links_write_unlock();
 }
@@ -444,7 +453,7 @@ static void __device_links_no_driver(struct device *dev)
 			continue;
 
 		if (link->flags & DL_FLAG_AUTOREMOVE)
-			__device_link_del(link);
+			kref_put(&link->kref, __device_link_del);
 		else if (link->status != DL_STATE_SUPPLIER_UNBIND)
 			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
 	}
@@ -597,13 +606,13 @@ static void device_links_purge(struct device *dev)
 
 	list_for_each_entry_safe_reverse(link, ln, &dev->links.suppliers, c_node) {
 		WARN_ON(link->status == DL_STATE_ACTIVE);
-		__device_link_del(link);
+		__device_link_del(&link->kref);
 	}
 
 	list_for_each_entry_safe_reverse(link, ln, &dev->links.consumers, s_node) {
 		WARN_ON(link->status != DL_STATE_DORMANT &&
 			link->status != DL_STATE_NONE);
-		__device_link_del(link);
+		__device_link_del(&link->kref);
 	}
 
 	device_links_write_unlock();

commit 433986c2c265d106d6a8e88006e0131fefc92b7b
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Feb 10 19:13:58 2018 +0100

    PM / runtime: Update links_count also if !CONFIG_SRCU
    
    Commit baa8809f6097 (PM / runtime: Optimize the use of device links)
    added an invocation of pm_runtime_drop_link() to __device_link_del().
    However there are two variants of that function, one for CONFIG_SRCU and
    another for !CONFIG_SRCU, and the commit only modified the former.
    
    Fixes: baa8809f6097 (PM / runtime: Optimize the use of device links)
    Cc: v4.10+ <stable@vger.kernel.org> # v4.10+
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b2261f92f2f1..5847364f25d9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -310,6 +310,9 @@ static void __device_link_del(struct device_link *link)
 	dev_info(link->consumer, "Dropping the link to %s\n",
 		 dev_name(link->supplier));
 
+	if (link->flags & DL_FLAG_PM_RUNTIME)
+		pm_runtime_drop_link(link->consumer);
+
 	list_del(&link->s_node);
 	list_del(&link->c_node);
 	device_link_free(link);

commit ab486bc9a591689f3ac2b6ebc072309371f8f451
Merge: 34b1cf60abb0 bb4f552a598d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 13:36:15 2018 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Add a console_msg_format command line option:
    
         The value "default" keeps the old "[time stamp] text\n" format. The
         value "syslog" allows to see the syslog-like "<log
         level>[timestamp] text" format.
    
         This feature was requested by people doing regression tests, for
         example, 0day robot. They want to have both filtered and full logs
         at hands.
    
     - Reduce the risk of softlockup:
    
         Pass the console owner in a busy loop.
    
         This is a new approach to the old problem. It was first proposed by
         Steven Rostedt on Kernel Summit 2017. It marks a context in which
         the console_lock owner calls console drivers and could not sleep.
         On the other side, printk() callers could detect this state and use
         a busy wait instead of a simple console_trylock(). Finally, the
         console_lock owner checks if there is a busy waiter at the end of
         the special context and eventually passes the console_lock to the
         waiter.
    
         The hand-off works surprisingly well and helps in many situations.
         Well, there is still a possibility of the softlockup, for example,
         when the flood of messages stops and the last owner still has too
         much to flush.
    
         There is increasing number of people having problems with
         printk-related softlockups. We might eventually need to get better
         solution. Anyway, this looks like a good start and promising
         direction.
    
     - Do not allow to schedule in console_unlock() called from printk():
    
         This reverts an older controversial commit. The reschedule helped
         to avoid softlockups. But it also slowed down the console output.
         This patch is obsoleted by the new console waiter logic described
         above. In fact, the reschedule made the hand-off less effective.
    
     - Deprecate "%pf" and "%pF" format specifier:
    
         It was needed on ia64, ppc64 and parisc64 to dereference function
         descriptors and show the real function address. It is done
         transparently by "%ps" and "pS" format specifier now.
    
         Sergey Senozhatsky found that all the function descriptors were in
         a special elf section and could be easily detected.
    
     - Remove printk_symbol() API:
    
         It has been obsoleted by "%pS" format specifier, and this change
         helped to remove few continuous lines and a less intuitive old API.
    
     - Remove redundant memsets:
    
         Sergey removed unnecessary memset when processing printk.devkmsg
         command line option.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk: (27 commits)
      printk: drop redundant devkmsg_log_str memsets
      printk: Never set console_may_schedule in console_trylock()
      printk: Hide console waiter logic into helpers
      printk: Add console owner and waiter logic to load balance console writes
      kallsyms: remove print_symbol() function
      checkpatch: add pF/pf deprecation warning
      symbol lookup: introduce dereference_symbol_descriptor()
      parisc64: Add .opd based function descriptor dereference
      powerpc64: Add .opd based function descriptor dereference
      ia64: Add .opd based function descriptor dereference
      sections: split dereference_function_descriptor()
      openrisc: Fix conflicting types for _exext and _stext
      lib: do not use print_symbol()
      irq debug: do not use print_symbol()
      sysfs: do not use print_symbol()
      drivers: do not use print_symbol()
      x86: do not use print_symbol()
      unicore32: do not use print_symbol()
      sh: do not use print_symbol()
      mn10300: do not use print_symbol()
      ...

commit a52668c6748700756545e43d0cd06ec83d7667e0
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Mon Dec 11 21:50:21 2017 +0900

    drivers: do not use print_symbol()
    
    print_symbol() is a very old API that has been obsoleted by %pS format
    specifier in a normal printk() call.
    
    Replace print_symbol() with a direct printk("%pS") call.
    
    Link: http://lkml.kernel.org/r/20171211125025.2270-10-sergey.senozhatsky@gmail.com
    To: Andrew Morton <akpm@linux-foundation.org>
    To: Russell King <linux@armlinux.org.uk>
    To: Catalin Marinas <catalin.marinas@arm.com>
    To: Mark Salter <msalter@redhat.com>
    To: Tony Luck <tony.luck@intel.com>
    To: David Howells <dhowells@redhat.com>
    To: Yoshinori Sato <ysato@users.sourceforge.jp>
    To: Guan Xuetao <gxt@mprc.pku.edu.cn>
    To: Borislav Petkov <bp@alien8.de>
    To: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    To: Thomas Gleixner <tglx@linutronix.de>
    To: Peter Zijlstra <peterz@infradead.org>
    To: Vineet Gupta <vgupta@synopsys.com>
    To: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-c6x-dev@linux-c6x.org
    Cc: linux-ia64@vger.kernel.org
    Cc: linux-am33-list@redhat.com
    Cc: linux-sh@vger.kernel.org
    Cc: linux-edac@vger.kernel.org
    Cc: x86@kernel.org
    Cc: linux-snps-arc@lists.infradead.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek@suse.com: updated commit message]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 110230d86527..409298942d5a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -22,7 +22,6 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/genhd.h>
-#include <linux/kallsyms.h>
 #include <linux/mutex.h>
 #include <linux/pm_runtime.h>
 #include <linux/netdevice.h>
@@ -687,8 +686,8 @@ static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 	if (dev_attr->show)
 		ret = dev_attr->show(dev, dev_attr, buf);
 	if (ret >= (ssize_t)PAGE_SIZE) {
-		print_symbol("dev_attr_show: %s returned bad count\n",
-				(unsigned long)dev_attr->show);
+		printk("dev_attr_show: %pS returned bad count\n",
+				dev_attr->show);
 	}
 	return ret;
 }

commit 93ead7c9483c6d7ae0f67ae6d0a5d3966d84bec8
Author: Gimcuan Hui <gimcuan@gmail.com>
Date:   Sat Nov 11 05:52:54 2017 +0000

    drivers: base: omit redundant interations
    
    When error happens, these interators return the error, no interation should
    be continued, so make the change for getting out of while immediately.
    
    Signed-off-by: Gimcuan Hui <gimcuan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bf45587bcb46..61515ef91184 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2114,7 +2114,7 @@ int device_for_each_child(struct device *parent, void *data,
 		return 0;
 
 	klist_iter_init(&parent->p->klist_children, &i);
-	while ((child = next_device(&i)) && !error)
+	while (!error && (child = next_device(&i)))
 		error = fn(child, data);
 	klist_iter_exit(&i);
 	return error;

commit 328257099077e8affd438c179d8a938948de2e7f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:09 2017 +0100

    driver core: Remove redundant license text
    
    Now that the SPDX tag is in all driver core files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index aa0593f1c2b6..bf45587bcb46 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -6,9 +6,6 @@
  * Copyright (c) 2002-3 Open Source Development Labs
  * Copyright (c) 2006 Greg Kroah-Hartman <gregkh@suse.de>
  * Copyright (c) 2006 Novell, Inc.
- *
- * This file is released under the GPLv2
- *
  */
 
 #include <linux/device.h>

commit 989d42e85dc2f6823f39b8e9d080fd04bae0645d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:07 2017 +0100

    driver core: add SPDX identifiers to all driver core files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the driver core files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 110230d86527..aa0593f1c2b6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/base/core.c - core driver model code (device registration, etc)
  *

commit b9743042b3d31fed271ae19aee79dd86817904f0
Merge: e60e1ee60630 0ff26c662d5f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 16 08:55:30 2017 -0800

    Merge tag 'driver-core-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of driver core / debugfs patches for 4.15-rc1.
    
      Not many here, mostly all are debugfs fixes to resolve some
      long-reported problems with files going away with references to them
      in userspace. There's also some SPDX cleanups for the debugfs code, as
      well as a few other minor driver core changes for issues reported by
      people.
    
      All of these have been in linux-next for a week or more with no
      reported issues"
    
    * tag 'driver-core-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:
      driver core: Fix device link deferred probe
      debugfs: Remove redundant license text
      debugfs: add SPDX identifiers to all debugfs files
      debugfs: defer debugfs_fsdata allocation to first usage
      debugfs: call debugfs_real_fops() only after debugfs_file_get()
      debugfs: purge obsolete SRCU based removal protection
      IB/hfi1: convert to debugfs_file_get() and -put()
      debugfs: convert to debugfs_file_get() and -put()
      debugfs: debugfs_real_fops(): drop __must_hold sparse annotation
      debugfs: implement per-file removal protection
      debugfs: add support for more elaborate ->d_fsdata
      driver core: Move device_links_purge() after bus_remove_device()
      arch_topology: Fix section miss match warning due to free_raw_capacity()
      driver-core: pr_err() strings should end with newlines

commit 37cb8e1f8e10c6e9bd2a1b95cdda0620a21b0551
Merge: 6a77d86655a1 aa25e446ce76
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 18:25:40 2017 -0800

    Merge tag 'devicetree-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "A bigger diffstat than usual with the kbuild changes and a tree wide
      fix in the binding documentation.
    
      Summary:
    
       - kbuild cleanups and improvements for dtbs
    
       - Code clean-up of overlay code and fixing for some long standing
         memory leak and race condition in applying overlays
    
       - Improvements to DT memory usage making sysfs/kobjects optional and
         skipping unflattening of disabled nodes. This is part of kernel
         tinification efforts.
    
       - Final piece of removing storing the full path for every DT node.
         The prerequisite conversion of printk's to use device_node format
         specifier happened in 4.14.
    
       - Sync with current upstream dtc. This brings additional checks to
         dtb compiling.
    
       - Binding doc tree wide removal of leading 0s from examples
    
       - RTC binding documentation adding missing devices and some
         consolidation of duplicated bindings
    
       - Vendor prefix documentation for nutsboard, Silicon Storage
         Technology, shimafuji, Tecon Microprocessor Technologies, DH
         electronics GmbH, Opal Kelly, and Next Thing"
    
    * tag 'devicetree-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (55 commits)
      dt-bindings: usb: add #phy-cells to usb-nop-xceiv
      dt-bindings: Remove leading zeros from bindings notation
      kbuild: handle dtb-y and CONFIG_OF_ALL_DTBS natively in Makefile.lib
      MIPS: dts: remove bogus bcm96358nb4ser.dtb from dtb-y entry
      kbuild: clean up *.dtb and *.dtb.S patterns from top-level Makefile
      .gitignore: move *.dtb and *.dtb.S patterns to the top-level .gitignore
      .gitignore: sort normal pattern rules alphabetically
      dt-bindings: add vendor prefix for Next Thing Co.
      scripts/dtc: Update to upstream version v1.4.5-6-gc1e55a5513e9
      of: dynamic: fix memory leak related to properties of __of_node_dup
      of: overlay: make pr_err() string unique
      of: overlay: pr_err from return NOTIFY_OK to overlay apply/remove
      of: overlay: remove unneeded check for NULL kbasename()
      of: overlay: remove a dependency on device node full_name
      of: overlay: simplify applying symbols from an overlay
      of: overlay: avoid race condition between applying multiple overlays
      of: overlay: loosen overly strict phandle clash check
      of: overlay: expand check of whether overlay changeset can be removed
      of: overlay: detect cases where device tree may become corrupt
      of: overlay: minor restructuring
      ...

commit 6aa7de059173a986114ac43b8f50b297a86f09a8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 23 14:07:29 2017 -0700

    locking/atomics: COCCINELLE/treewide: Convert trivial ACCESS_ONCE() patterns to READ_ONCE()/WRITE_ONCE()
    
    Please do not apply this to mainline directly, instead please re-run the
    coccinelle script shown below and apply its output.
    
    For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
    preference to ACCESS_ONCE(), and new code is expected to use one of the
    former. So far, there's been no reason to change most existing uses of
    ACCESS_ONCE(), as these aren't harmful, and changing them results in
    churn.
    
    However, for some features, the read/write distinction is critical to
    correct operation. To distinguish these cases, separate read/write
    accessors must be used. This patch migrates (most) remaining
    ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
    coccinelle script:
    
    ----
    // Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
    // WRITE_ONCE()
    
    // $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS="--include-headers" MODE=patch
    
    virtual patch
    
    @ depends on patch @
    expression E1, E2;
    @@
    
    - ACCESS_ONCE(E1) = E2
    + WRITE_ONCE(E1, E2)
    
    @ depends on patch @
    expression E;
    @@
    
    - ACCESS_ONCE(E)
    + READ_ONCE(E)
    ----
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: davem@davemloft.net
    Cc: linux-arch@vger.kernel.org
    Cc: mpe@ellerman.id.au
    Cc: shuah@kernel.org
    Cc: snitzer@redhat.com
    Cc: thor.thayer@linux.intel.com
    Cc: tj@kernel.org
    Cc: viro@zeniv.linux.org.uk
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 12ebd055724c..4b8ba2a75a4d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -668,7 +668,7 @@ const char *dev_driver_string(const struct device *dev)
 	 * so be careful about accessing it.  dev->bus and dev->class should
 	 * never change once they are set, so they don't need special care.
 	 */
-	drv = ACCESS_ONCE(dev->driver);
+	drv = READ_ONCE(dev->driver);
 	return drv ? drv->name :
 			(dev->bus ? dev->bus->name :
 			(dev->class ? dev->class->name : ""));

commit 2ec16150179888b81717d1d3ce84e634f4736af2
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Fri Oct 20 20:01:01 2017 +0800

    driver core: Move device_links_purge() after bus_remove_device()
    
    The current ordering of code in device_del() triggers a WARN_ON()
    in device_links_purge(), because of an unexpected link status.
    
    The device_links_unbind_consumers() call in device_release_driver()
    has to take place before device_links_purge() for the status of all
    links to be correct, so move the device_links_purge() call in
    device_del() after the invocation of bus_remove_device() which calls
    device_release_driver().
    
    Fixes: 9ed9895370ae (driver core: Functional dependencies tracking support)
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 12ebd055724c..2e683cdf4a08 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1958,7 +1958,6 @@ void device_del(struct device *dev)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
 
-	device_links_purge(dev);
 	dpm_sysfs_remove(dev);
 	if (parent)
 		klist_del(&dev->p->knode_parent);
@@ -1986,6 +1985,7 @@ void device_del(struct device *dev)
 	device_pm_remove(dev);
 	driver_deferred_probe_del(dev);
 	device_remove_properties(dev);
+	device_links_purge(dev);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...

commit 0c3c234b95fa7f1dfa19e1456a47ebafc300dd6b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Oct 4 14:04:01 2017 -0500

    of: wrap accesses to device_node kobject
    
    In preparation to make kobject element in struct device_node optional,
    provide and use a macro to return the kobject pointer. The only user
    outside the DT core is the driver core.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 12ebd055724c..c07b47059538 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1571,7 +1571,7 @@ static int device_add_class_symlinks(struct device *dev)
 	int error;
 
 	if (of_node) {
-		error = sysfs_create_link(&dev->kobj, &of_node->kobj,"of_node");
+		error = sysfs_create_link(&dev->kobj, of_node_kobj(of_node), "of_node");
 		if (error)
 			dev_warn(dev, "Error %d creating of_node link\n",error);
 		/* An error here doesn't warrant bringing down the device */

commit 7521621e600aeefe5ffcc1f90ae26a42fc20c452
Author: Michal Suchanek <msuchanek@suse.de>
Date:   Fri Aug 11 15:44:43 2017 +0200

    Do not disable driver and bus shutdown hook when class shutdown hook is set.
    
    As seen from the implementation of the single class shutdown hook this
    is not very sound design.
    
    Rename the class shutdown hook to shutdown_pre to make it clear it runs
    before the driver shutdown hook.
    
    Signed-off-by: Michal Suchanek <msuchanek@suse.de>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index cb4b5b1f1b09..12ebd055724c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2796,11 +2796,12 @@ void device_shutdown(void)
 		pm_runtime_get_noresume(dev);
 		pm_runtime_barrier(dev);
 
-		if (dev->class && dev->class->shutdown) {
+		if (dev->class && dev->class->shutdown_pre) {
 			if (initcall_debug)
-				dev_info(dev, "shutdown\n");
-			dev->class->shutdown(dev);
-		} else if (dev->bus && dev->bus->shutdown) {
+				dev_info(dev, "shutdown_pre\n");
+			dev->class->shutdown_pre(dev);
+		}
+		if (dev->bus && dev->bus->shutdown) {
 			if (initcall_debug)
 				dev_info(dev, "shutdown\n");
 			dev->bus->shutdown(dev);

commit 1af824f085e813e06548212b18bbc788b16f60e6
Merge: d8bcf4db9244 072a7852338a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Jul 22 12:00:15 2017 +0200

    Merge branch 'bind_unbind' into driver-core-next
    
    This merges the bind_unbind driver core feature into the
    driver-core-next branch.  bind_unbind is a branch so that others can
    pull and work off of it safely.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 57b8ff070f9897b22e4f80fda775a489fc797008
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Jul 19 17:24:33 2017 -0700

    driver core: add devm_device_add_group() and friends
    
    Many drivers create additional driver-specific device attributes when
    binding to the device, and providing managed version of
    device_create_group() will simplify unbinding and error handling in probe
    path for such drivers.
    
    Without managed version driver writers either have to mix manual and
    managed resources, which is prone to errors, or open-code this function by
    providing a wrapper to device_add_group() and use it with devm_add_action()
    or devm_add_action_or_reset().
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 14f8cf5c8b05..09723532725d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1035,6 +1035,136 @@ void device_remove_groups(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_groups);
 
+union device_attr_group_devres {
+	const struct attribute_group *group;
+	const struct attribute_group **groups;
+};
+
+static int devm_attr_group_match(struct device *dev, void *res, void *data)
+{
+	return ((union device_attr_group_devres *)res)->group == data;
+}
+
+static void devm_attr_group_remove(struct device *dev, void *res)
+{
+	union device_attr_group_devres *devres = res;
+	const struct attribute_group *group = devres->group;
+
+	dev_dbg(dev, "%s: removing group %p\n", __func__, group);
+	sysfs_remove_group(&dev->kobj, group);
+}
+
+static void devm_attr_groups_remove(struct device *dev, void *res)
+{
+	union device_attr_group_devres *devres = res;
+	const struct attribute_group **groups = devres->groups;
+
+	dev_dbg(dev, "%s: removing groups %p\n", __func__, groups);
+	sysfs_remove_groups(&dev->kobj, groups);
+}
+
+/**
+ * devm_device_add_group - given a device, create a managed attribute group
+ * @dev:	The device to create the group for
+ * @grp:	The attribute group to create
+ *
+ * This function creates a group for the first time.  It will explicitly
+ * warn and error if any of the attribute files being created already exist.
+ *
+ * Returns 0 on success or error code on failure.
+ */
+int devm_device_add_group(struct device *dev, const struct attribute_group *grp)
+{
+	union device_attr_group_devres *devres;
+	int error;
+
+	devres = devres_alloc(devm_attr_group_remove,
+			      sizeof(*devres), GFP_KERNEL);
+	if (!devres)
+		return -ENOMEM;
+
+	error = sysfs_create_group(&dev->kobj, grp);
+	if (error) {
+		devres_free(devres);
+		return error;
+	}
+
+	devres->group = grp;
+	devres_add(dev, devres);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_device_add_group);
+
+/**
+ * devm_device_remove_group: remove a managed group from a device
+ * @dev:	device to remove the group from
+ * @grp:	group to remove
+ *
+ * This function removes a group of attributes from a device. The attributes
+ * previously have to have been created for this group, otherwise it will fail.
+ */
+void devm_device_remove_group(struct device *dev,
+			      const struct attribute_group *grp)
+{
+	WARN_ON(devres_release(dev, devm_attr_group_remove,
+			       devm_attr_group_match,
+			       /* cast away const */ (void *)grp));
+}
+EXPORT_SYMBOL_GPL(devm_device_remove_group);
+
+/**
+ * devm_device_add_groups - create a bunch of managed attribute groups
+ * @dev:	The device to create the group for
+ * @groups:	The attribute groups to create, NULL terminated
+ *
+ * This function creates a bunch of managed attribute groups.  If an error
+ * occurs when creating a group, all previously created groups will be
+ * removed, unwinding everything back to the original state when this
+ * function was called.  It will explicitly warn and error if any of the
+ * attribute files being created already exist.
+ *
+ * Returns 0 on success or error code from sysfs_create_group on failure.
+ */
+int devm_device_add_groups(struct device *dev,
+			   const struct attribute_group **groups)
+{
+	union device_attr_group_devres *devres;
+	int error;
+
+	devres = devres_alloc(devm_attr_groups_remove,
+			      sizeof(*devres), GFP_KERNEL);
+	if (!devres)
+		return -ENOMEM;
+
+	error = sysfs_create_groups(&dev->kobj, groups);
+	if (error) {
+		devres_free(devres);
+		return error;
+	}
+
+	devres->groups = groups;
+	devres_add(dev, devres);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_device_add_groups);
+
+/**
+ * devm_device_remove_groups - remove a list of managed groups
+ *
+ * @dev:	The device for the groups to be removed from
+ * @groups:	NULL terminated list of groups to be removed
+ *
+ * If groups is not NULL, remove the specified groups from the device.
+ */
+void devm_device_remove_groups(struct device *dev,
+			       const struct attribute_group **groups)
+{
+	WARN_ON(devres_release(dev, devm_attr_groups_remove,
+			       devm_attr_group_match,
+			       /* cast away const */ (void *)groups));
+}
+EXPORT_SYMBOL_GPL(devm_device_remove_groups);
+
 static int device_add_attrs(struct device *dev)
 {
 	struct class *class = dev->class;

commit a7670d425b75f9e44b7d4d0aea04f4a6d5f34291
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Jul 19 17:24:31 2017 -0700

    driver core: make device_{add|remove}_groups() public
    
    Many drivers create additional driver-specific device attributes when
    binding to the device. To avoid them calling SYSFS API directly, let's
    export these helpers.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bbecaf9293be..14f8cf5c8b05 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1026,12 +1026,14 @@ int device_add_groups(struct device *dev, const struct attribute_group **groups)
 {
 	return sysfs_create_groups(&dev->kobj, groups);
 }
+EXPORT_SYMBOL_GPL(device_add_groups);
 
 void device_remove_groups(struct device *dev,
 			  const struct attribute_group **groups)
 {
 	sysfs_remove_groups(&dev->kobj, groups);
 }
+EXPORT_SYMBOL_GPL(device_remove_groups);
 
 static int device_add_attrs(struct device *dev)
 {

commit f77af15165847406b15d8f70c382c4cb15846b2a
Author: Josh Zimmerman <joshz@google.com>
Date:   Sun Jun 25 14:53:23 2017 -0700

    Add "shutdown" to "struct class".
    
    The TPM class has some common shutdown code that must be executed for
    all drivers. This adds some needed functionality for that.
    
    Signed-off-by: Josh Zimmerman <joshz@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: stable@vger.kernel.org
    Fixes: 74d6b3ceaa17 ("tpm: fix suspend/resume paths for TPM 2.0")
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8dde934f8d15..755451f684bc 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2664,7 +2664,11 @@ void device_shutdown(void)
 		pm_runtime_get_noresume(dev);
 		pm_runtime_barrier(dev);
 
-		if (dev->bus && dev->bus->shutdown) {
+		if (dev->class && dev->class->shutdown) {
+			if (initcall_debug)
+				dev_info(dev, "shutdown\n");
+			dev->class->shutdown(dev);
+		} else if (dev->bus && dev->bus->shutdown) {
 			if (initcall_debug)
 				dev_info(dev, "shutdown\n");
 			dev->bus->shutdown(dev);

commit 974668417b74ec5f68df2411f53b3d3812565059
Merge: 9a715cd54347 d565ed38d045
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 20:27:48 2017 -0700

    Merge tag 'driver-core-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the big driver core update for 4.13-rc1.
    
      The large majority of this is a lot of cleanup of old fields in the
      driver core structures and their remaining usages in random drivers.
      All of those fixes have been reviewed by the various subsystem
      maintainers. There's also some small firmware updates in here, a new
      kobject uevent api interface that makes userspace interaction easier,
      and a few other minor things.
    
      All of these have been in linux-next for a long while with no reported
      issues"
    
    * tag 'driver-core-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (56 commits)
      arm: mach-rpc: ecard: fix build error
      zram: convert remaining CLASS_ATTR() to CLASS_ATTR_RO()
      driver-core: remove struct bus_type.dev_attrs
      powerpc: vio_cmo: use dev_groups and not dev_attrs for bus_type
      powerpc: vio: use dev_groups and not dev_attrs for bus_type
      USB: usbip: convert to use DRIVER_ATTR_RW
      s390: drivers: convert to use DRIVER_ATTR_RO/WO
      platform: thinkpad_acpi: convert to use DRIVER_ATTR_RO/RW
      pcmcia: ds: convert to use DRIVER_ATTR_RO
      wireless: ipw2x00: convert to use DRIVER_ATTR_RW
      net: ehea: convert to use DRIVER_ATTR_RO
      net: caif: convert to use DRIVER_ATTR_RO
      TTY: hvc: convert to use DRIVER_ATTR_RW
      PCI: pci-driver: convert to use DRIVER_ATTR_WO
      IB: nes: convert to use DRIVER_ATTR_RW
      HID: hid-core: convert to use DRIVER_ATTR_RO and drv_groups
      arm: ecard: fix dev_groups patch typo
      tty: serdev: use dev_groups and not dev_attrs for bus_type
      sparc: vio: use dev_groups and not dev_attrs for bus_type
      hid: intel-ish-hid: use dev_groups and not dev_attrs for bus_type
      ...

commit 4e75e1d7dac9d7c95c57eceb451d01f2afcc8626
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Jun 6 17:59:00 2017 +0200

    driver core: add helper to reuse a device-tree node
    
    Add a helper function to be used when reusing the device-tree node of
    another device.
    
    It is fairly common for drivers to reuse the device-tree node of a
    parent (or other ancestor) device when creating class or bus devices
    (e.g. gpio chips, i2c adapters, iio chips, spi masters, serdev, phys,
    usb root hubs). But reusing a device-tree node may cause problems if the
    new device is later probed as for example driver core would currently
    attempt to reinitialise an already active associated pinmux
    configuration.
    
    Other potential issues include the platform-bus code unconditionally
    dropping the device-tree node reference in its device destructor,
    reinitialisation of other bus-managed resources such as clocks, and the
    recently added DMA-setup in driver core.
    
    Note that for most examples above this is currently not an issue as the
    devices are never probed, but this is a problem for the USB bus which
    has recently gained device-tree support. This was discovered and
    worked-around in a rather ad-hoc fashion by commit dc5878abf49c ("usb:
    core: move root hub's device node assignment after it is added to bus")
    by not setting the of_node pointer until after the root-hub device has
    been registered.
    
    Instead we can allow devices to reuse a device-tree node by setting a
    flag in their struct device that can be used by core, bus and driver
    code to avoid resources from being over-allocated.
    
    Note that the helper also grabs an extra reference to the device node,
    which specifically balances the unconditional put in the platform-device
    destructor.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bbecaf9293be..c3064ff09af5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2884,3 +2884,19 @@ void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode)
 	else
 		dev->fwnode = fwnode;
 }
+
+/**
+ * device_set_of_node_from_dev - reuse device-tree node of another device
+ * @dev: device whose device-tree node is being set
+ * @dev2: device whose device-tree node is being reused
+ *
+ * Takes another reference to the new device-tree node after first dropping
+ * any reference held to the old node.
+ */
+void device_set_of_node_from_dev(struct device *dev, const struct device *dev2)
+{
+	of_node_put(dev->of_node);
+	dev->of_node = of_node_get(dev2->of_node);
+	dev->of_node_reused = true;
+}
+EXPORT_SYMBOL_GPL(device_set_of_node_from_dev);

commit f36776fafbaa0094390dd4e7e3e29805e0b82730
Author: Peter Rajnoha <prajnoha@redhat.com>
Date:   Tue May 9 15:22:30 2017 +0200

    kobject: support passing in variables for synthetic uevents
    
    This patch makes it possible to pass additional arguments in addition
    to uevent action name when writing /sys/.../uevent attribute. These
    additional arguments are then inserted into generated synthetic uevent
    as additional environment variables.
    
    Before, we were not able to pass any additional uevent environment
    variables for synthetic uevents. This made it hard to identify such uevents
    properly in userspace to make proper distinction between genuine uevents
    originating from kernel and synthetic uevents triggered from userspace.
    Also, it was not possible to pass any additional information which would
    make it possible to optimize and change the way the synthetic uevents are
    processed back in userspace based on the originating environment of the
    triggering action in userspace. With the extra additional variables, we are
    able to pass through this extra information needed and also it makes it
    possible to synchronize with such synthetic uevents as they can be clearly
    identified back in userspace.
    
    The format for writing the uevent attribute is following:
    
        ACTION [UUID [KEY=VALUE ...]
    
    There's no change in how "ACTION" is recognized - it stays the same
    ("add", "change", "remove"). The "ACTION" is the only argument required
    to generate synthetic uevent, the rest of arguments, that this patch
    adds support for, are optional.
    
    The "UUID" is considered as transaction identifier so it's possible to
    use the same UUID value for one or more synthetic uevents in which case
    we logically group these uevents together for any userspace listeners.
    The "UUID" is expected to be in "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    format where "x" is a hex digit. The value appears in uevent as
    "SYNTH_UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" environment variable.
    
    The "KEY=VALUE" pairs can contain alphanumeric characters only. It's
    possible to define zero or more more pairs - each pair is then delimited
    by a space character " ". Each pair appears in synthetic uevents as
    "SYNTH_ARG_KEY=VALUE" environment variable. That means the KEY name gains
    "SYNTH_ARG_" prefix to avoid possible collisions with existing variables.
    To pass the "KEY=VALUE" pairs, it's also required to pass in the "UUID"
    part for the synthetic uevent first.
    
    If "UUID" is not passed in, the generated synthetic uevent gains
    "SYNTH_UUID=0" environment variable automatically so it's possible to
    identify this situation in userspace when reading generated uevent and so
    we can still make a difference between genuine and synthetic uevents.
    
    Signed-off-by: Peter Rajnoha <prajnoha@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bbecaf9293be..6564339d7f59 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -981,12 +981,9 @@ static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
 static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
-	enum kobject_action action;
+	if (kobject_synth_uevent(&dev->kobj, buf, count))
+		dev_err(dev, "uevent: failed to send synthetic uevent\n");
 
-	if (kobject_action_type(buf, count, &action) == 0)
-		kobject_uevent(&dev->kobj, action);
-	else
-		dev_err(dev, "uevent: unknown action-string\n");
 	return count;
 }
 static DEVICE_ATTR_RW(uevent);

commit 35dbf4efb044fbe4096a5edbb449e894aca9ef50
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Mar 17 12:24:22 2017 +0530

    driver core: don't initialize 'parent' in device_add()
    
    'parent' is always overwritten before getting used and there is no need
    to initialize it with NULL.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6bb60fb6a30b..bbecaf9293be 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1607,7 +1607,7 @@ int device_private_init(struct device *dev)
  */
 int device_add(struct device *dev)
 {
-	struct device *parent = NULL;
+	struct device *parent;
 	struct kobject *kobj;
 	struct class_interface *class_intf;
 	int error = -EINVAL;

commit 15c9e10d9ad4d41d076148bbff1de7f659f68852
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Thu Mar 16 16:40:33 2017 -0700

    drivers core: remove assert_held_device_hotplug()
    
    The last caller of assert_held_device_hotplug() is gone, so remove it again.
    
    Link: http://lkml.kernel.org/r/20170314125226.16779-3-heiko.carstens@de.ibm.com
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 684bda4d14a1..6bb60fb6a30b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -639,11 +639,6 @@ int lock_device_hotplug_sysfs(void)
 	return restart_syscall();
 }
 
-void assert_held_device_hotplug(void)
-{
-	lockdep_assert_held(&device_hotplug_lock);
-}
-
 #ifdef CONFIG_BLOCK
 static inline int device_is_not_partition(struct device *dev)
 {

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 3050e6f99403..684bda4d14a1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -26,6 +26,7 @@
 #include <linux/mutex.h>
 #include <linux/pm_runtime.h>
 #include <linux/netdevice.h>
+#include <linux/sched/signal.h>
 #include <linux/sysfs.h>
 
 #include "base.h"

commit 3fc21924100b13f73c734d0ce8dfcfe913fcf7a8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 24 14:55:48 2017 -0800

    mm: validate device_hotplug is held for memory hotplug
    
    mem_hotplug_begin() assumes that it can set mem_hotplug.active_writer
    and run the hotplug process without racing another thread.  Validate
    this assumption with a lockdep assertion.
    
    Link: http://lkml.kernel.org/r/148693886229.16345.1770484669403334689.stgit@dwillia2-desk3.amr.corp.intel.com
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Reported-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Toshi Kani <toshi.kani@hpe.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Logan Gunthorpe <logang@deltatee.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8c25e68e67d7..3050e6f99403 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -638,6 +638,11 @@ int lock_device_hotplug_sysfs(void)
 	return restart_syscall();
 }
 
+void assert_held_device_hotplug(void)
+{
+	lockdep_assert_held(&device_hotplug_lock);
+}
+
 #ifdef CONFIG_BLOCK
 static inline int device_is_not_partition(struct device *dev)
 {

commit c7334ce814f7e5d8fc1f9b3126cda0640c2f81b3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Jan 14 14:09:03 2017 +0100

    Revert "driver core: Add deferred_probe attribute to devices in sysfs"
    
    This reverts commit 6751667a29d6fd64afb9ce30567ad616b68ed789.
    
    Rob Herring objected to it, and a replacement for it will be added using
    debugfs in the future.
    
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Reported-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 020ea7f05520..8c25e68e67d7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1060,14 +1060,8 @@ static int device_add_attrs(struct device *dev)
 			goto err_remove_dev_groups;
 	}
 
-	error = device_create_file(dev, &dev_attr_deferred_probe);
-	if (error)
-		goto err_remove_online;
-
 	return 0;
 
- err_remove_online:
-	device_remove_file(dev, &dev_attr_online);
  err_remove_dev_groups:
 	device_remove_groups(dev, dev->groups);
  err_remove_type_groups:
@@ -1085,7 +1079,6 @@ static void device_remove_attrs(struct device *dev)
 	struct class *class = dev->class;
 	const struct device_type *type = dev->type;
 
-	device_remove_file(dev, &dev_attr_deferred_probe);
 	device_remove_file(dev, &dev_attr_online);
 	device_remove_groups(dev, dev->groups);
 

commit 64df1148876e35e81e91195e01c8197edc66fcc5
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Dec 4 13:10:04 2016 +0100

    driver core: Silence device links sphinx warning
    
    Silence this warning emitted by sphinx:
    include/linux/device.h:938: warning: No description found for parameter 'links'
    
    While at it, fix typos in comments of device links code.
    
    Cc: Rafael J. Wysocki <rafael@kernel.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Silvio Fricke <silvio.fricke@gmail.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b8b2f6105476..020ea7f05520 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -172,7 +172,7 @@ static int device_reorder_to_tail(struct device *dev, void *not_used)
  *
  * The supplier device is required to be registered when this function is called
  * and NULL will be returned if that is not the case.  The consumer device need
- * not be registerd, however.
+ * not be registered, however.
  */
 struct device_link *device_link_add(struct device *consumer,
 				    struct device *supplier, u32 flags)
@@ -225,7 +225,7 @@ struct device_link *device_link_add(struct device *consumer,
 	INIT_LIST_HEAD(&link->c_node);
 	link->flags = flags;
 
-	/* Deterine the initial link state. */
+	/* Determine the initial link state. */
 	if (flags & DL_FLAG_STATELESS) {
 		link->status = DL_STATE_NONE;
 	} else {

commit 6751667a29d6fd64afb9ce30567ad616b68ed789
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Tue Aug 16 14:34:18 2016 +0100

    driver core: Add deferred_probe attribute to devices in sysfs
    
    It is sometimes useful to know that a device is on the deferred probe
    list rather than, say, not having a driver available.  Expose this
    information to user-space.
    
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d0c9df5cdd9e..b8b2f6105476 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1060,8 +1060,14 @@ static int device_add_attrs(struct device *dev)
 			goto err_remove_dev_groups;
 	}
 
+	error = device_create_file(dev, &dev_attr_deferred_probe);
+	if (error)
+		goto err_remove_online;
+
 	return 0;
 
+ err_remove_online:
+	device_remove_file(dev, &dev_attr_online);
  err_remove_dev_groups:
 	device_remove_groups(dev, dev->groups);
  err_remove_type_groups:
@@ -1079,6 +1085,7 @@ static void device_remove_attrs(struct device *dev)
 	struct class *class = dev->class;
 	const struct device_type *type = dev->type;
 
+	device_remove_file(dev, &dev_attr_deferred_probe);
 	device_remove_file(dev, &dev_attr_online);
 	device_remove_groups(dev, dev->groups);
 

commit baa8809f60971d10220dfe79248f54b2b265f003
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:43 2016 +0100

    PM / runtime: Optimize the use of device links
    
    If the device has no links to suppliers that should be used for
    runtime PM (links with DEVICE_LINK_PM_RUNTIME set), there is no
    reason to walk the list of suppliers for that device during
    runtime suspend and resume.
    
    Add a simple mechanism to detect that case and possibly avoid the
    extra unnecessary overhead.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 876c62b12462..d0c9df5cdd9e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -205,14 +205,17 @@ struct device_link *device_link_add(struct device *consumer,
 	if (!link)
 		goto out;
 
-	if ((flags & DL_FLAG_PM_RUNTIME) && (flags & DL_FLAG_RPM_ACTIVE)) {
-		if (pm_runtime_get_sync(supplier) < 0) {
-			pm_runtime_put_noidle(supplier);
-			kfree(link);
-			link = NULL;
-			goto out;
+	if (flags & DL_FLAG_PM_RUNTIME) {
+		if (flags & DL_FLAG_RPM_ACTIVE) {
+			if (pm_runtime_get_sync(supplier) < 0) {
+				pm_runtime_put_noidle(supplier);
+				kfree(link);
+				link = NULL;
+				goto out;
+			}
+			link->rpm_active = true;
 		}
-		link->rpm_active = true;
+		pm_runtime_new_link(consumer);
 	}
 	get_device(supplier);
 	link->supplier = supplier;
@@ -296,6 +299,9 @@ static void __device_link_del(struct device_link *link)
 	dev_info(link->consumer, "Dropping the link to %s\n",
 		 dev_name(link->supplier));
 
+	if (link->flags & DL_FLAG_PM_RUNTIME)
+		pm_runtime_drop_link(link->consumer);
+
 	list_del_rcu(&link->s_node);
 	list_del_rcu(&link->c_node);
 	call_srcu(&device_links_srcu, &link->rcu_head, __device_link_free_srcu);

commit 21d5c57b3726166421251e94dabab047baaf8ce4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:31 2016 +0100

    PM / runtime: Use device links
    
    Modify the runtime PM framework to use device links to ensure that
    supplier devices will not be suspended if any of their consumer
    devices are active.
    
    The idea is to reference count suppliers on the consumer's resume
    and drop references to them on its suspend.  The information on
    whether or not the supplier has been reference counted by the
    consumer's (runtime) resume is stored in a new field (rpm_active)
    in the link object for each link.
    
    It may be necessary to clean up those references when the
    supplier is unbinding and that's why the links whose status is
    DEVICE_LINK_SUPPLIER_UNBIND are skipped by the runtime suspend
    and resume code.
    
    The above means that if the consumer device is probed in the
    runtime-active state, the supplier has to be resumed and reference
    counted by device_link_add() so the code works as expected on its
    (runtime) suspend.  There is a new flag, DEVICE_LINK_RPM_ACTIVE,
    to tell device_link_add() about that (in which case the caller
    is responsible for making sure that the consumer really will
    be runtime-active when runtime PM is enabled for it).
    
    The other new link flag, DEVICE_LINK_PM_RUNTIME, tells the core
    whether or not the link should be used for runtime PM at all.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 3c5ff17f578f..876c62b12462 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -152,6 +152,14 @@ static int device_reorder_to_tail(struct device *dev, void *not_used)
  * @supplier: Supplier end of the link.
  * @flags: Link flags.
  *
+ * The caller is responsible for the proper synchronization of the link creation
+ * with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
+ * runtime PM framework to take the link into account.  Second, if the
+ * DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
+ * be forced into the active metastate and reference-counted upon the creation
+ * of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
+ * ignored.
+ *
  * If the DL_FLAG_AUTOREMOVE is set, the link will be removed automatically
  * when the consumer device driver unbinds from it.  The combination of both
  * DL_FLAG_AUTOREMOVE and DL_FLAG_STATELESS set is invalid and will cause NULL
@@ -193,10 +201,19 @@ struct device_link *device_link_add(struct device *consumer,
 		if (link->consumer == consumer)
 			goto out;
 
-	link = kmalloc(sizeof(*link), GFP_KERNEL);
+	link = kzalloc(sizeof(*link), GFP_KERNEL);
 	if (!link)
 		goto out;
 
+	if ((flags & DL_FLAG_PM_RUNTIME) && (flags & DL_FLAG_RPM_ACTIVE)) {
+		if (pm_runtime_get_sync(supplier) < 0) {
+			pm_runtime_put_noidle(supplier);
+			kfree(link);
+			link = NULL;
+			goto out;
+		}
+		link->rpm_active = true;
+	}
 	get_device(supplier);
 	link->supplier = supplier;
 	INIT_LIST_HEAD(&link->s_node);
@@ -213,6 +230,14 @@ struct device_link *device_link_add(struct device *consumer,
 		case DL_DEV_DRIVER_BOUND:
 			switch (consumer->links.status) {
 			case DL_DEV_PROBING:
+				/*
+				 * Balance the decrementation of the supplier's
+				 * runtime PM usage counter after consumer probe
+				 * in driver_probe_device().
+				 */
+				if (flags & DL_FLAG_PM_RUNTIME)
+					pm_runtime_get_sync(supplier);
+
 				link->status = DL_STATE_CONSUMER_PROBE;
 				break;
 			case DL_DEV_DRIVER_BOUND:

commit 9ed9895370aedd6032af2a9181c62c394d08223b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:16 2016 +0100

    driver core: Functional dependencies tracking support
    
    Currently, there is a problem with taking functional dependencies
    between devices into account.
    
    What I mean by a "functional dependency" is when the driver of device
    B needs device A to be functional and (generally) its driver to be
    present in order to work properly.  This has certain consequences
    for power management (suspend/resume and runtime PM ordering) and
    shutdown ordering of these devices.  In general, it also implies that
    the driver of A needs to be working for B to be probed successfully
    and it cannot be unbound from the device before the B's driver.
    
    Support for representing those functional dependencies between
    devices is added here to allow the driver core to track them and act
    on them in certain cases where applicable.
    
    The argument for doing that in the driver core is that there are
    quite a few distinct use cases involving device dependencies, they
    are relatively hard to get right in a driver (if one wants to
    address all of them properly) and it only gets worse if multiplied
    by the number of drivers potentially needing to do it.  Morever, at
    least one case (asynchronous system suspend/resume) cannot be handled
    in a single driver at all, because it requires the driver of A to
    wait for B to suspend (during system suspend) and the driver of B to
    wait for A to resume (during system resume).
    
    For this reason, represent dependencies between devices as "links",
    with the help of struct device_link objects each containing pointers
    to the "linked" devices, a list node for each of them, status
    information, flags, and an RCU head for synchronization.
    
    Also add two new list heads, representing the lists of links to the
    devices that depend on the given one (consumers) and to the devices
    depended on by it (suppliers), and a "driver presence status" field
    (needed for figuring out initial states of device links) to struct
    device.
    
    The entire data structure consisting of all of the lists of link
    objects for all devices is protected by a mutex (for link object
    addition/removal and for list walks during device driver probing
    and removal) and by SRCU (for list walking in other case that will
    be introduced by subsequent change sets).  If CONFIG_SRCU is not
    selected, however, an rwsem is used for protecting the entire data
    structure.
    
    In addition, each link object has an internal status field whose
    value reflects whether or not drivers are bound to the devices
    pointed to by the link or probing/removal of their drivers is in
    progress etc.  That field is only modified under the device links
    mutex, but it may be read outside of it in some cases (introduced by
    subsequent change sets), so modifications of it are annotated with
    WRITE_ONCE().
    
    New links are added by calling device_link_add() which takes three
    arguments: pointers to the devices in question and flags.  In
    particular, if DL_FLAG_STATELESS is set in the flags, the link status
    is not to be taken into account for this link and the driver core
    will not manage it.  In turn, if DL_FLAG_AUTOREMOVE is set in the
    flags, the driver core will remove the link automatically when the
    consumer device driver unbinds from it.
    
    One of the actions carried out by device_link_add() is to reorder
    the lists used for device shutdown and system suspend/resume to
    put the consumer device along with all of its children and all of
    its consumers (and so on, recursively) to the ends of those lists
    in order to ensure the right ordering between all of the supplier
    and consumer devices.
    
    For this reason, it is not possible to create a link between two
    devices if the would-be supplier device already depends on the
    would-be consumer device as either a direct descendant of it or a
    consumer of one of its direct descendants or one of its consumers
    and so on.
    
    There are two types of link objects, persistent and non-persistent.
    The persistent ones stay around until one of the target devices is
    deleted, while the non-persistent ones are removed automatically when
    the consumer driver unbinds from its device (ie. they are assumed to
    be valid only as long as the consumer device has a driver bound to
    it).  Persistent links are created by default and non-persistent
    links are created when the DL_FLAG_AUTOREMOVE flag is passed
    to device_link_add().
    
    Both persistent and non-persistent device links can be deleted
    with an explicit call to device_link_del().
    
    Links created without the DL_FLAG_STATELESS flag set are managed
    by the driver core using a simple state machine.  There are 5 states
    each link can be in: DORMANT (unused), AVAILABLE (the supplier driver
    is present and functional), CONSUMER_PROBE (the consumer driver is
    probing), ACTIVE (both supplier and consumer drivers are present and
    functional), and SUPPLIER_UNBIND (the supplier driver is unbinding).
    The driver core updates the link state automatically depending on
    what happens to the linked devices and for each link state specific
    actions are taken in addition to that.
    
    For example, if the supplier driver unbinds from its device, the
    driver core will also unbind the drivers of all of its consumers
    automatically under the assumption that they cannot function
    properly without the supplier.  Analogously, the driver core will
    only allow the consumer driver to bind to its device if the
    supplier driver is present and functional (ie. the link is in
    the AVAILABLE state).  If that's not the case, it will rely on
    the existing deferred probing mechanism to wait for the supplier
    driver to become available.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ce057a568673..3c5ff17f578f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -44,6 +44,541 @@ static int __init sysfs_deprecated_setup(char *arg)
 early_param("sysfs.deprecated", sysfs_deprecated_setup);
 #endif
 
+/* Device links support. */
+
+#ifdef CONFIG_SRCU
+static DEFINE_MUTEX(device_links_lock);
+DEFINE_STATIC_SRCU(device_links_srcu);
+
+static inline void device_links_write_lock(void)
+{
+	mutex_lock(&device_links_lock);
+}
+
+static inline void device_links_write_unlock(void)
+{
+	mutex_unlock(&device_links_lock);
+}
+
+int device_links_read_lock(void)
+{
+	return srcu_read_lock(&device_links_srcu);
+}
+
+void device_links_read_unlock(int idx)
+{
+	srcu_read_unlock(&device_links_srcu, idx);
+}
+#else /* !CONFIG_SRCU */
+static DECLARE_RWSEM(device_links_lock);
+
+static inline void device_links_write_lock(void)
+{
+	down_write(&device_links_lock);
+}
+
+static inline void device_links_write_unlock(void)
+{
+	up_write(&device_links_lock);
+}
+
+int device_links_read_lock(void)
+{
+	down_read(&device_links_lock);
+	return 0;
+}
+
+void device_links_read_unlock(int not_used)
+{
+	up_read(&device_links_lock);
+}
+#endif /* !CONFIG_SRCU */
+
+/**
+ * device_is_dependent - Check if one device depends on another one
+ * @dev: Device to check dependencies for.
+ * @target: Device to check against.
+ *
+ * Check if @target depends on @dev or any device dependent on it (its child or
+ * its consumer etc).  Return 1 if that is the case or 0 otherwise.
+ */
+static int device_is_dependent(struct device *dev, void *target)
+{
+	struct device_link *link;
+	int ret;
+
+	if (WARN_ON(dev == target))
+		return 1;
+
+	ret = device_for_each_child(dev, target, device_is_dependent);
+	if (ret)
+		return ret;
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (WARN_ON(link->consumer == target))
+			return 1;
+
+		ret = device_is_dependent(link->consumer, target);
+		if (ret)
+			break;
+	}
+	return ret;
+}
+
+static int device_reorder_to_tail(struct device *dev, void *not_used)
+{
+	struct device_link *link;
+
+	/*
+	 * Devices that have not been registered yet will be put to the ends
+	 * of the lists during the registration, so skip them here.
+	 */
+	if (device_is_registered(dev))
+		devices_kset_move_last(dev);
+
+	if (device_pm_initialized(dev))
+		device_pm_move_last(dev);
+
+	device_for_each_child(dev, NULL, device_reorder_to_tail);
+	list_for_each_entry(link, &dev->links.consumers, s_node)
+		device_reorder_to_tail(link->consumer, NULL);
+
+	return 0;
+}
+
+/**
+ * device_link_add - Create a link between two devices.
+ * @consumer: Consumer end of the link.
+ * @supplier: Supplier end of the link.
+ * @flags: Link flags.
+ *
+ * If the DL_FLAG_AUTOREMOVE is set, the link will be removed automatically
+ * when the consumer device driver unbinds from it.  The combination of both
+ * DL_FLAG_AUTOREMOVE and DL_FLAG_STATELESS set is invalid and will cause NULL
+ * to be returned.
+ *
+ * A side effect of the link creation is re-ordering of dpm_list and the
+ * devices_kset list by moving the consumer device and all devices depending
+ * on it to the ends of these lists (that does not happen to devices that have
+ * not been registered when this function is called).
+ *
+ * The supplier device is required to be registered when this function is called
+ * and NULL will be returned if that is not the case.  The consumer device need
+ * not be registerd, however.
+ */
+struct device_link *device_link_add(struct device *consumer,
+				    struct device *supplier, u32 flags)
+{
+	struct device_link *link;
+
+	if (!consumer || !supplier ||
+	    ((flags & DL_FLAG_STATELESS) && (flags & DL_FLAG_AUTOREMOVE)))
+		return NULL;
+
+	device_links_write_lock();
+	device_pm_lock();
+
+	/*
+	 * If the supplier has not been fully registered yet or there is a
+	 * reverse dependency between the consumer and the supplier already in
+	 * the graph, return NULL.
+	 */
+	if (!device_pm_initialized(supplier)
+	    || device_is_dependent(consumer, supplier)) {
+		link = NULL;
+		goto out;
+	}
+
+	list_for_each_entry(link, &supplier->links.consumers, s_node)
+		if (link->consumer == consumer)
+			goto out;
+
+	link = kmalloc(sizeof(*link), GFP_KERNEL);
+	if (!link)
+		goto out;
+
+	get_device(supplier);
+	link->supplier = supplier;
+	INIT_LIST_HEAD(&link->s_node);
+	get_device(consumer);
+	link->consumer = consumer;
+	INIT_LIST_HEAD(&link->c_node);
+	link->flags = flags;
+
+	/* Deterine the initial link state. */
+	if (flags & DL_FLAG_STATELESS) {
+		link->status = DL_STATE_NONE;
+	} else {
+		switch (supplier->links.status) {
+		case DL_DEV_DRIVER_BOUND:
+			switch (consumer->links.status) {
+			case DL_DEV_PROBING:
+				link->status = DL_STATE_CONSUMER_PROBE;
+				break;
+			case DL_DEV_DRIVER_BOUND:
+				link->status = DL_STATE_ACTIVE;
+				break;
+			default:
+				link->status = DL_STATE_AVAILABLE;
+				break;
+			}
+			break;
+		case DL_DEV_UNBINDING:
+			link->status = DL_STATE_SUPPLIER_UNBIND;
+			break;
+		default:
+			link->status = DL_STATE_DORMANT;
+			break;
+		}
+	}
+
+	/*
+	 * Move the consumer and all of the devices depending on it to the end
+	 * of dpm_list and the devices_kset list.
+	 *
+	 * It is necessary to hold dpm_list locked throughout all that or else
+	 * we may end up suspending with a wrong ordering of it.
+	 */
+	device_reorder_to_tail(consumer, NULL);
+
+	list_add_tail_rcu(&link->s_node, &supplier->links.consumers);
+	list_add_tail_rcu(&link->c_node, &consumer->links.suppliers);
+
+	dev_info(consumer, "Linked as a consumer to %s\n", dev_name(supplier));
+
+ out:
+	device_pm_unlock();
+	device_links_write_unlock();
+	return link;
+}
+EXPORT_SYMBOL_GPL(device_link_add);
+
+static void device_link_free(struct device_link *link)
+{
+	put_device(link->consumer);
+	put_device(link->supplier);
+	kfree(link);
+}
+
+#ifdef CONFIG_SRCU
+static void __device_link_free_srcu(struct rcu_head *rhead)
+{
+	device_link_free(container_of(rhead, struct device_link, rcu_head));
+}
+
+static void __device_link_del(struct device_link *link)
+{
+	dev_info(link->consumer, "Dropping the link to %s\n",
+		 dev_name(link->supplier));
+
+	list_del_rcu(&link->s_node);
+	list_del_rcu(&link->c_node);
+	call_srcu(&device_links_srcu, &link->rcu_head, __device_link_free_srcu);
+}
+#else /* !CONFIG_SRCU */
+static void __device_link_del(struct device_link *link)
+{
+	dev_info(link->consumer, "Dropping the link to %s\n",
+		 dev_name(link->supplier));
+
+	list_del(&link->s_node);
+	list_del(&link->c_node);
+	device_link_free(link);
+}
+#endif /* !CONFIG_SRCU */
+
+/**
+ * device_link_del - Delete a link between two devices.
+ * @link: Device link to delete.
+ *
+ * The caller must ensure proper synchronization of this function with runtime
+ * PM.
+ */
+void device_link_del(struct device_link *link)
+{
+	device_links_write_lock();
+	device_pm_lock();
+	__device_link_del(link);
+	device_pm_unlock();
+	device_links_write_unlock();
+}
+EXPORT_SYMBOL_GPL(device_link_del);
+
+static void device_links_missing_supplier(struct device *dev)
+{
+	struct device_link *link;
+
+	list_for_each_entry(link, &dev->links.suppliers, c_node)
+		if (link->status == DL_STATE_CONSUMER_PROBE)
+			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
+}
+
+/**
+ * device_links_check_suppliers - Check presence of supplier drivers.
+ * @dev: Consumer device.
+ *
+ * Check links from this device to any suppliers.  Walk the list of the device's
+ * links to suppliers and see if all of them are available.  If not, simply
+ * return -EPROBE_DEFER.
+ *
+ * We need to guarantee that the supplier will not go away after the check has
+ * been positive here.  It only can go away in __device_release_driver() and
+ * that function  checks the device's links to consumers.  This means we need to
+ * mark the link as "consumer probe in progress" to make the supplier removal
+ * wait for us to complete (or bad things may happen).
+ *
+ * Links with the DL_FLAG_STATELESS flag set are ignored.
+ */
+int device_links_check_suppliers(struct device *dev)
+{
+	struct device_link *link;
+	int ret = 0;
+
+	device_links_write_lock();
+
+	list_for_each_entry(link, &dev->links.suppliers, c_node) {
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		if (link->status != DL_STATE_AVAILABLE) {
+			device_links_missing_supplier(dev);
+			ret = -EPROBE_DEFER;
+			break;
+		}
+		WRITE_ONCE(link->status, DL_STATE_CONSUMER_PROBE);
+	}
+	dev->links.status = DL_DEV_PROBING;
+
+	device_links_write_unlock();
+	return ret;
+}
+
+/**
+ * device_links_driver_bound - Update device links after probing its driver.
+ * @dev: Device to update the links for.
+ *
+ * The probe has been successful, so update links from this device to any
+ * consumers by changing their status to "available".
+ *
+ * Also change the status of @dev's links to suppliers to "active".
+ *
+ * Links with the DL_FLAG_STATELESS flag set are ignored.
+ */
+void device_links_driver_bound(struct device *dev)
+{
+	struct device_link *link;
+
+	device_links_write_lock();
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		WARN_ON(link->status != DL_STATE_DORMANT);
+		WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
+	}
+
+	list_for_each_entry(link, &dev->links.suppliers, c_node) {
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		WARN_ON(link->status != DL_STATE_CONSUMER_PROBE);
+		WRITE_ONCE(link->status, DL_STATE_ACTIVE);
+	}
+
+	dev->links.status = DL_DEV_DRIVER_BOUND;
+
+	device_links_write_unlock();
+}
+
+/**
+ * __device_links_no_driver - Update links of a device without a driver.
+ * @dev: Device without a drvier.
+ *
+ * Delete all non-persistent links from this device to any suppliers.
+ *
+ * Persistent links stay around, but their status is changed to "available",
+ * unless they already are in the "supplier unbind in progress" state in which
+ * case they need not be updated.
+ *
+ * Links with the DL_FLAG_STATELESS flag set are ignored.
+ */
+static void __device_links_no_driver(struct device *dev)
+{
+	struct device_link *link, *ln;
+
+	list_for_each_entry_safe_reverse(link, ln, &dev->links.suppliers, c_node) {
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		if (link->flags & DL_FLAG_AUTOREMOVE)
+			__device_link_del(link);
+		else if (link->status != DL_STATE_SUPPLIER_UNBIND)
+			WRITE_ONCE(link->status, DL_STATE_AVAILABLE);
+	}
+
+	dev->links.status = DL_DEV_NO_DRIVER;
+}
+
+void device_links_no_driver(struct device *dev)
+{
+	device_links_write_lock();
+	__device_links_no_driver(dev);
+	device_links_write_unlock();
+}
+
+/**
+ * device_links_driver_cleanup - Update links after driver removal.
+ * @dev: Device whose driver has just gone away.
+ *
+ * Update links to consumers for @dev by changing their status to "dormant" and
+ * invoke %__device_links_no_driver() to update links to suppliers for it as
+ * appropriate.
+ *
+ * Links with the DL_FLAG_STATELESS flag set are ignored.
+ */
+void device_links_driver_cleanup(struct device *dev)
+{
+	struct device_link *link;
+
+	device_links_write_lock();
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE);
+		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
+		WRITE_ONCE(link->status, DL_STATE_DORMANT);
+	}
+
+	__device_links_no_driver(dev);
+
+	device_links_write_unlock();
+}
+
+/**
+ * device_links_busy - Check if there are any busy links to consumers.
+ * @dev: Device to check.
+ *
+ * Check each consumer of the device and return 'true' if its link's status
+ * is one of "consumer probe" or "active" (meaning that the given consumer is
+ * probing right now or its driver is present).  Otherwise, change the link
+ * state to "supplier unbind" to prevent the consumer from being probed
+ * successfully going forward.
+ *
+ * Return 'false' if there are no probing or active consumers.
+ *
+ * Links with the DL_FLAG_STATELESS flag set are ignored.
+ */
+bool device_links_busy(struct device *dev)
+{
+	struct device_link *link;
+	bool ret = false;
+
+	device_links_write_lock();
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		if (link->status == DL_STATE_CONSUMER_PROBE
+		    || link->status == DL_STATE_ACTIVE) {
+			ret = true;
+			break;
+		}
+		WRITE_ONCE(link->status, DL_STATE_SUPPLIER_UNBIND);
+	}
+
+	dev->links.status = DL_DEV_UNBINDING;
+
+	device_links_write_unlock();
+	return ret;
+}
+
+/**
+ * device_links_unbind_consumers - Force unbind consumers of the given device.
+ * @dev: Device to unbind the consumers of.
+ *
+ * Walk the list of links to consumers for @dev and if any of them is in the
+ * "consumer probe" state, wait for all device probes in progress to complete
+ * and start over.
+ *
+ * If that's not the case, change the status of the link to "supplier unbind"
+ * and check if the link was in the "active" state.  If so, force the consumer
+ * driver to unbind and start over (the consumer will not re-probe as we have
+ * changed the state of the link already).
+ *
+ * Links with the DL_FLAG_STATELESS flag set are ignored.
+ */
+void device_links_unbind_consumers(struct device *dev)
+{
+	struct device_link *link;
+
+ start:
+	device_links_write_lock();
+
+	list_for_each_entry(link, &dev->links.consumers, s_node) {
+		enum device_link_state status;
+
+		if (link->flags & DL_FLAG_STATELESS)
+			continue;
+
+		status = link->status;
+		if (status == DL_STATE_CONSUMER_PROBE) {
+			device_links_write_unlock();
+
+			wait_for_device_probe();
+			goto start;
+		}
+		WRITE_ONCE(link->status, DL_STATE_SUPPLIER_UNBIND);
+		if (status == DL_STATE_ACTIVE) {
+			struct device *consumer = link->consumer;
+
+			get_device(consumer);
+
+			device_links_write_unlock();
+
+			device_release_driver_internal(consumer, NULL,
+						       consumer->parent);
+			put_device(consumer);
+			goto start;
+		}
+	}
+
+	device_links_write_unlock();
+}
+
+/**
+ * device_links_purge - Delete existing links to other devices.
+ * @dev: Target device.
+ */
+static void device_links_purge(struct device *dev)
+{
+	struct device_link *link, *ln;
+
+	/*
+	 * Delete all of the remaining links from this device to any other
+	 * devices (either consumers or suppliers).
+	 */
+	device_links_write_lock();
+
+	list_for_each_entry_safe_reverse(link, ln, &dev->links.suppliers, c_node) {
+		WARN_ON(link->status == DL_STATE_ACTIVE);
+		__device_link_del(link);
+	}
+
+	list_for_each_entry_safe_reverse(link, ln, &dev->links.consumers, s_node) {
+		WARN_ON(link->status != DL_STATE_DORMANT &&
+			link->status != DL_STATE_NONE);
+		__device_link_del(link);
+	}
+
+	device_links_write_unlock();
+}
+
+/* Device links support end. */
+
 int (*platform_notify)(struct device *dev) = NULL;
 int (*platform_notify_remove)(struct device *dev) = NULL;
 static struct kobject *dev_kobj;
@@ -711,6 +1246,9 @@ void device_initialize(struct device *dev)
 #ifdef CONFIG_GENERIC_MSI_IRQ
 	INIT_LIST_HEAD(&dev->msi_list);
 #endif
+	INIT_LIST_HEAD(&dev->links.consumers);
+	INIT_LIST_HEAD(&dev->links.suppliers);
+	dev->links.status = DL_DEV_NO_DRIVER;
 }
 EXPORT_SYMBOL_GPL(device_initialize);
 
@@ -1258,6 +1796,8 @@ void device_del(struct device *dev)
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
+
+	device_links_purge(dev);
 	dpm_sysfs_remove(dev);
 	if (parent)
 		klist_del(&dev->p->knode_parent);

commit 9929780e86854833e649b39b290b5fe921eb1701
Merge: 7a53eea1f7b5 dd01c75f1df3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 3 20:03:24 2016 -0700

    Merge tag 'driver-core-4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here are the "big" driver core patches for 4.9-rc1. Also in here are a
      number of debugfs fixes that cropped up due to the changes that
      happened in 4.8 for that filesystem. Overall, nothing major, just a
      few fixes and cleanups.
    
      All of these have been in linux-next with no reported issues"
    
    * tag 'driver-core-4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (23 commits)
      drivers: dma-coherent: Move spinlock in dma_alloc_from_coherent()
      drivers: dma-coherent: Fix DMA coherent size for less than page
      MAINTAINERS: extend firmware_class maintainer list
      debugfs: propagate release() call result
      driver-core: platform: Catch errors from calls to irq_get_irq_data
      sysfs print name of undiscoverable attribute group
      carl9170: fix debugfs crashes
      b43legacy: fix debugfs crash
      b43: fix debugfs crash
      debugfs: introduce a public file_operations accessor
      device core: Remove deprecated create_singlethread_workqueue
      drivers/base dmam_declare_coherent_memory leaks
      platform: don't return 0 from platform_get_irq[_byname]() on error
      cpu: clean up register_cpu func
      dma-mapping: use vma_pages().
      drivers: dma-coherent: use vma_pages().
      attribute_container: Fix typo
      base: soc: make it explicitly non-modular
      drivers: base: dma-mapping: page align the size when unmap_kernel_range
      platform driver: fix use-after-free in platform_device_del()
      ...

commit cebf8fd16900fdfd58c0028617944f808f97fe50
Author: Ming Lei <ming.lei@canonical.com>
Date:   Sun Jul 10 19:27:36 2016 +0800

    driver core: fix race between creating/querying glue dir and its cleanup
    
    The global mutex of 'gdp_mutex' is used to serialize creating/querying
    glue dir and its cleanup. Turns out it isn't a perfect way because
    part(kobj_kset_leave()) of the actual cleanup action() is done inside
    the release handler of the glue dir kobject. That means gdp_mutex has
    to be held before releasing the last reference count of the glue dir
    kobject.
    
    This patch moves glue dir's cleanup after kobject_del() in device_del()
    for avoiding the race.
    
    Cc: Yijing Wang <wangyijing@huawei.com>
    Reported-by: Chandra Sekhar Lingutla <clingutla@codeaurora.org>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0a8bdade53f2..88df65d1e6f6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -836,11 +836,29 @@ static struct kobject *get_device_parent(struct device *dev,
 	return NULL;
 }
 
+static inline bool live_in_glue_dir(struct kobject *kobj,
+				    struct device *dev)
+{
+	if (!kobj || !dev->class ||
+	    kobj->kset != &dev->class->p->glue_dirs)
+		return false;
+	return true;
+}
+
+static inline struct kobject *get_glue_dir(struct device *dev)
+{
+	return dev->kobj.parent;
+}
+
+/*
+ * make sure cleaning up dir as the last step, we need to make
+ * sure .release handler of kobject is run with holding the
+ * global lock
+ */
 static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 {
 	/* see if we live in a "glue" directory */
-	if (!glue_dir || !dev->class ||
-	    glue_dir->kset != &dev->class->p->glue_dirs)
+	if (!live_in_glue_dir(glue_dir, dev))
 		return;
 
 	mutex_lock(&gdp_mutex);
@@ -848,11 +866,6 @@ static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 	mutex_unlock(&gdp_mutex);
 }
 
-static void cleanup_device_parent(struct device *dev)
-{
-	cleanup_glue_dir(dev, dev->kobj.parent);
-}
-
 static int device_add_class_symlinks(struct device *dev)
 {
 	struct device_node *of_node = dev_of_node(dev);
@@ -1028,6 +1041,7 @@ int device_add(struct device *dev)
 	struct kobject *kobj;
 	struct class_interface *class_intf;
 	int error = -EINVAL;
+	struct kobject *glue_dir = NULL;
 
 	dev = get_device(dev);
 	if (!dev)
@@ -1072,8 +1086,10 @@ int device_add(struct device *dev)
 	/* first, register with generic layer. */
 	/* we require the name to be set before, and pass NULL */
 	error = kobject_add(&dev->kobj, dev->kobj.parent, NULL);
-	if (error)
+	if (error) {
+		glue_dir = get_glue_dir(dev);
 		goto Error;
+	}
 
 	/* notify platform of device entry */
 	if (platform_notify)
@@ -1154,9 +1170,10 @@ int device_add(struct device *dev)
 	device_remove_file(dev, &dev_attr_uevent);
  attrError:
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
+	glue_dir = get_glue_dir(dev);
 	kobject_del(&dev->kobj);
  Error:
-	cleanup_device_parent(dev);
+	cleanup_glue_dir(dev, glue_dir);
 	put_device(parent);
 name_error:
 	kfree(dev->p);
@@ -1232,6 +1249,7 @@ EXPORT_SYMBOL_GPL(put_device);
 void device_del(struct device *dev)
 {
 	struct device *parent = dev->parent;
+	struct kobject *glue_dir = NULL;
 	struct class_interface *class_intf;
 
 	/* Notify clients of device removal.  This call must come
@@ -1276,8 +1294,9 @@ void device_del(struct device *dev)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_REMOVED_DEVICE, dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
-	cleanup_device_parent(dev);
+	glue_dir = get_glue_dir(dev);
 	kobject_del(&dev->kobj);
+	cleanup_glue_dir(dev, glue_dir);
 	put_device(parent);
 }
 EXPORT_SYMBOL_GPL(device_del);

commit 478573c93abd369c4850de55c387be43aa01e2e8
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 28 02:25:41 2016 +0200

    driver core: Don't leak secondary fwnode on device removal
    
    If device_add_property_set() is called for a device, a secondary fwnode
    is allocated and assigned to the device but currently not freed once the
    device is removed.
    
    This can be triggered on Apple Macs if a Thunderbolt device is plugged
    in on boot since Apple's NHI EFI driver sets a number of properties for
    that device which are leaked on unplug.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0a8bdade53f2..70c5be5b03a7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1266,6 +1266,7 @@ void device_del(struct device *dev)
 	bus_remove_device(dev);
 	device_pm_remove(dev);
 	driver_deferred_probe_del(dev);
+	device_remove_properties(dev);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...

commit 55f89a8a4538803195395bdf347cbba51dcb1906
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Nov 30 17:11:39 2015 +0200

    driver core: Do not overwrite secondary fwnode with NULL if it is set
    
    If multiple devices share single firmware node like it is case with MFD
    devices, the same firmware node (ACPI) is assigned to all of them. The
    function also modifies the shared firmware node in order to preserve
    secondary firmware node of the device in question.
    
    If the new device which is sharing the firmware node does not have
    secondary node it will be NULL which will be assigned to the secondary node
    of the shared firmware node losing all built-in properties.
    
    Prevent this by setting the secondary firmware node only if the replacement
    is non-NULL.
    
    Print also warning if someone tries to overwrite secondary node that has
    already been assigned.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b7d56c5ea3c6..0a8bdade53f2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2261,7 +2261,10 @@ void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode)
 		if (fwnode_is_primary(fn))
 			fn = fn->secondary;
 
-		fwnode->secondary = fn;
+		if (fn) {
+			WARN_ON(fwnode->secondary);
+			fwnode->secondary = fn;
+		}
 		dev->fwnode = fwnode;
 	} else {
 		dev->fwnode = fwnode_is_primary(dev->fwnode) ?

commit 56f2de81e020c537f7e35550d13840143cb765cd
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Tue Aug 25 12:08:22 2015 +0800

    of: to support binding numa node to specified device in devicetree
    
    For now, in function device_add, the new device will be forced to
    inherit the numa node of its parent. But this will override the device's
    numa node which configured in devicetree.
    
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 334ec7ef1960..b7d56c5ea3c6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1066,7 +1066,7 @@ int device_add(struct device *dev)
 		dev->kobj.parent = kobj;
 
 	/* use parent numa_node */
-	if (parent)
+	if (parent && (dev_to_node(dev) == NUMA_NO_NODE))
 		set_dev_node(dev, dev_to_node(parent));
 
 	/* first, register with generic layer. */

commit ae982073095a44f004d7ffb9f271077abef9dbcf
Merge: f1a3c0b933e7 e625ccec1fa6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 19:45:46 2015 -0700

    Merge tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "From the number of commits perspective, the biggest items are ACPICA
      and cpufreq changes with the latter taking the lead (over 50 commits).
    
      On the cpufreq front, there are many cleanups and minor fixes in the
      core and governors, driver updates etc.  We also have a new cpufreq
      driver for Mediatek MT8173 chips.
    
      ACPICA mostly updates its debug infrastructure and adds a number of
      fixes and cleanups for a good measure.
    
      The Operating Performance Points (OPP) framework is updated with new
      DT bindings and support for them among other things.
    
      We have a few updates of the generic power domains framework and a
      reorganization of the ACPI device enumeration code and bus type
      operations.
    
      And a lot of fixes and cleanups all over.
    
      Included is one branch from the MFD tree as it contains some
      PM-related driver core and ACPI PM changes a few other commits are
      based on.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150818 including method
         tracing extensions to allow more in-depth AML debugging in the
         kernel and a number of assorted fixes and cleanups (Bob Moore, Lv
         Zheng, Markus Elfring).
    
       - ACPI sysfs code updates and a documentation update related to AML
         method tracing (Lv Zheng).
    
       - ACPI EC driver fix related to serialized evaluations of _Qxx
         methods and ACPI tools updates allowing the EC userspace tool to be
         built from the kernel source (Lv Zheng).
    
       - ACPI processor driver updates preparing it for future introduction
         of CPPC support and ACPI PCC mailbox driver updates (Ashwin
         Chaugule).
    
       - ACPI interrupts enumeration fix for a regression related to the
         handling of IRQ attribute conflicts between MADT and the ACPI
         namespace (Jiang Liu).
    
       - Fixes related to ACPI device PM (Mika Westerberg, Srinidhi
         Kasagar).
    
       - ACPI device registration code reorganization to separate the
         sysfs-related code and bus type operations from the rest (Rafael J
         Wysocki).
    
       - Assorted cleanups in the ACPI core (Jarkko Nikula, Mathias Krause,
         Andy Shevchenko, Rafael J Wysocki, Nicolas Iooss).
    
       - ACPI cpufreq driver and ia64 cpufreq driver fixes and cleanups (Pan
         Xinhui, Rafael J Wysocki).
    
       - cpufreq core cleanups on top of the previous changes allowing it to
         preseve its sysfs directories over system suspend/resume (Viresh
         Kumar, Rafael J Wysocki, Sebastian Andrzej Siewior).
    
       - cpufreq fixes and cleanups related to governors (Viresh Kumar).
    
       - cpufreq updates (core and the cpufreq-dt driver) related to the
         turbo/boost mode support (Viresh Kumar, Bartlomiej Zolnierkiewicz).
    
       - New DT bindings for Operating Performance Points (OPP), support for
         them in the OPP framework and in the cpufreq-dt driver plus related
         OPP framework fixes and cleanups (Viresh Kumar).
    
       - cpufreq powernv driver updates (Shilpasri G Bhat).
    
       - New cpufreq driver for Mediatek MT8173 (Pi-Cheng Chen).
    
       - Assorted cpufreq driver (speedstep-lib, sfi, integrator) cleanups
         and fixes (Abhilash Jindal, Andrzej Hajda, Cristian Ardelean).
    
       - intel_pstate driver updates including Skylake-S support, support
         for enabling HW P-states per CPU and an additional vendor bypass
         list entry (Kristen Carlson Accardi, Chen Yu, Ethan Zhao).
    
       - cpuidle core fixes related to the handling of coupled idle states
         (Xunlei Pang).
    
       - intel_idle driver updates including Skylake Client support and
         support for freeze-mode-specific idle states (Len Brown).
    
       - Driver core updates related to power management (Andy Shevchenko,
         Rafael J Wysocki).
    
       - Generic power domains framework fixes and cleanups (Jon Hunter,
         Geert Uytterhoeven, Rajendra Nayak, Ulf Hansson).
    
       - Device PM QoS framework update to allow the latency tolerance
         setting to be exposed to user space via sysfs (Mika Westerberg).
    
       - devfreq support for PPMUv2 in Exynos5433 and a fix for an incorrect
         exynos-ppmu DT binding (Chanwoo Choi, Javier Martinez Canillas).
    
       - System sleep support updates (Alan Stern, Len Brown, SungEun Kim).
    
       - rockchip-io AVS support updates (Heiko Stuebner).
    
       - PM core clocks support fixup (Colin Ian King).
    
       - Power capping RAPL driver update including support for Skylake H/S
         and Broadwell-H (Radivoje Jovanovic, Seiichi Ikarashi).
    
       - Generic device properties framework fixes related to the handling
         of static (driver-provided) property sets (Andy Shevchenko).
    
       - turbostat and cpupower updates (Len Brown, Shilpasri G Bhat,
         Shreyas B Prabhu)"
    
    * tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (180 commits)
      cpufreq: speedstep-lib: Use monotonic clock
      cpufreq: powernv: Increase the verbosity of OCC console messages
      cpufreq: sfi: use kmemdup rather than duplicating its implementation
      cpufreq: drop !cpufreq_driver check from cpufreq_parse_governor()
      cpufreq: rename cpufreq_real_policy as cpufreq_user_policy
      cpufreq: remove redundant 'policy' field from user_policy
      cpufreq: remove redundant 'governor' field from user_policy
      cpufreq: update user_policy.* on success
      cpufreq: use memcpy() to copy policy
      cpufreq: remove redundant CPUFREQ_INCOMPATIBLE notifier event
      cpufreq: mediatek: Add MT8173 cpufreq driver
      dt-bindings: mediatek: Add MT8173 CPU DVFS clock bindings
      PM / Domains: Fix typo in description of genpd_dev_pm_detach()
      PM / Domains: Remove unusable governor dummies
      PM / Domains: Make pm_genpd_init() available to modules
      PM / domains: Align column headers and data in pm_genpd_summary output
      powercap / RAPL: disable the 2nd power limit properly
      tools: cpupower: Fix error when running cpupower monitor
      PM / OPP: Drop unlikely before IS_ERR(_OR_NULL)
      PM / OPP: Fix static checker warning (broken 64bit big endian systems)
      ...

commit 17e6b00ac422b49d44a0b8d98402a211f726282d
Merge: 5e359bf2219d e324c4dc4a59
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 14:33:35 2015 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "This updated pull request does not contain the last few GIC related
      patches which were reported to cause a regression.  There is a fix
      available, but I let it breed for a couple of days first.
    
      The irq departement provides:
    
       - new infrastructure to support non PCI based MSI interrupts
       - a couple of new irq chip drivers
       - the usual pile of fixlets and updates to irq chip drivers
       - preparatory changes for removal of the irq argument from interrupt
         flow handlers
       - preparatory changes to remove IRQF_VALID"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (129 commits)
      irqchip/imx-gpcv2: IMX GPCv2 driver for wakeup sources
      irqchip: Add bcm2836 interrupt controller for Raspberry Pi 2
      irqchip: Add documentation for the bcm2836 interrupt controller
      irqchip/bcm2835: Add support for being used as a second level controller
      irqchip/bcm2835: Refactor handle_IRQ() calls out of MAKE_HWIRQ
      PCI: xilinx: Fix typo in function name
      irqchip/gic: Ensure gic_cpu_if_up/down() programs correct GIC instance
      irqchip/gic: Only allow the primary GIC to set the CPU map
      PCI/MSI: pci-xgene-msi: Consolidate chained IRQ handler install/remove
      unicore32/irq: Prepare puv3_gpio_handler for irq argument removal
      tile/pci_gx: Prepare trio_handle_level_irq for irq argument removal
      m68k/irq: Prepare irq handlers for irq argument removal
      C6X/megamode-pic: Prepare megamod_irq_cascade for irq argument removal
      blackfin: Prepare irq handlers for irq argument removal
      arc/irq: Prepare idu_cascade_isr for irq argument removal
      sparc/irq: Use access helper irq_data_get_affinity_mask()
      sparc/irq: Use helper irq_data_get_irq_handler_data()
      parisc/irq: Use access helper irq_data_get_affinity_mask()
      mn10300/irq: Use access helper irq_data_get_affinity_mask()
      irqchip/i8259: Prepare i8259_irq_dispatch for irq argument removal
      ...

commit 52cdbdd49853dfa856082edb0f4c4c0249d9df07
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Jul 27 20:43:01 2015 +0300

    driver core: correct device's shutdown order
    
    Now device's shutdown sequence is performed in reverse order of their
    registration in devices_kset list and this sequence corresponds to the
    reverse device's creation order. So, devices_kset data tracks
    "parent<-child" device's dependencies only.
    
    Unfortunately, that's not enough and causes problems in case of
    implementing board's specific shutdown procedures. For example [1]:
    "DRA7XX_evm uses PCF8575 and one of the PCF output lines feeds to
    MMC/SD and this line should be driven high in order for the MMC/SD to
    be detected. This line is modelled as regulator and the hsmmc driver
    takes care of enabling and disabling it. In the case of 'reboot',
    during shutdown path as part of it's cleanup process the hsmmc driver
    disables this regulator. This makes MMC boot not functional."
    
    To handle this issue the .shutdown() callback could be implemented
    for PCF8575 device where corresponding GPIO pins will be configured to
    states, required for correct warm/cold reset. This can be achieved
    only when all .shutdown() callbacks have been called already for all
    PCF8575's consumers. But devices_kset is not filled correctly now:
    
    devices_kset: Device61 4e000000.dmm
    devices_kset: Device62 48070000.i2c
    devices_kset: Device63 48072000.i2c
    devices_kset: Device64 48060000.i2c
    devices_kset: Device65 4809c000.mmc
    ...
    devices_kset: Device102 fixedregulator-sd
    ...
    devices_kset: Device181 0-0020 // PCF8575
    devices_kset: Device182 gpiochip496
    devices_kset: Device183 0-0021 // PCF8575
    devices_kset: Device184 gpiochip480
    
    As can be seen from above .shutdown() callback for PCF8575 will be called
    before its consumers, which, in turn means, that any changes of PCF8575
    GPIO's pins will be or unsafe or overwritten later by GPIO's consumers.
    The problem can be solved if devices_kset list will be filled not only
    according device creation order, but also according device's probing
    order to track "supplier<-consumer" dependencies also.
    
    Hence, as a fix, lets add devices_kset_move_last(),
    devices_kset_move_before(), devices_kset_move_after() and call them
    from device_move() and also add call of devices_kset_move_last() in
    really_probe(). After this change all entries in devices_kset will
    be sorted according to device's creation ("parent<-child") and
    probing ("supplier<-consumer") order.
    
    devices_kset after:
    devices_kset: Device121 48070000.i2c
    devices_kset: Device122 i2c-0
    ...
    devices_kset: Device147 regulator.24
    devices_kset: Device148 0-0020
    devices_kset: Device149 gpiochip496
    devices_kset: Device150 0-0021
    devices_kset: Device151 gpiochip480
    devices_kset: Device152 0-0019
    ...
    devices_kset: Device372 fixedregulator-sd
    devices_kset: Device373 regulator.29
    devices_kset: Device374 4809c000.mmc
    devices_kset: Device375 mmc0
    
    [1] http://www.spinics.net/lists/linux-mmc/msg29825.html
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index dafae6d2f7ac..fc5a558f62f9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -533,6 +533,52 @@ static DEVICE_ATTR_RO(dev);
 /* /sys/devices/ */
 struct kset *devices_kset;
 
+/**
+ * devices_kset_move_before - Move device in the devices_kset's list.
+ * @deva: Device to move.
+ * @devb: Device @deva should come before.
+ */
+static void devices_kset_move_before(struct device *deva, struct device *devb)
+{
+	if (!devices_kset)
+		return;
+	pr_debug("devices_kset: Moving %s before %s\n",
+		 dev_name(deva), dev_name(devb));
+	spin_lock(&devices_kset->list_lock);
+	list_move_tail(&deva->kobj.entry, &devb->kobj.entry);
+	spin_unlock(&devices_kset->list_lock);
+}
+
+/**
+ * devices_kset_move_after - Move device in the devices_kset's list.
+ * @deva: Device to move
+ * @devb: Device @deva should come after.
+ */
+static void devices_kset_move_after(struct device *deva, struct device *devb)
+{
+	if (!devices_kset)
+		return;
+	pr_debug("devices_kset: Moving %s after %s\n",
+		 dev_name(deva), dev_name(devb));
+	spin_lock(&devices_kset->list_lock);
+	list_move(&deva->kobj.entry, &devb->kobj.entry);
+	spin_unlock(&devices_kset->list_lock);
+}
+
+/**
+ * devices_kset_move_last - move the device to the end of devices_kset's list.
+ * @dev: device to move
+ */
+void devices_kset_move_last(struct device *dev)
+{
+	if (!devices_kset)
+		return;
+	pr_debug("devices_kset: Moving %s to end of list\n", dev_name(dev));
+	spin_lock(&devices_kset->list_lock);
+	list_move_tail(&dev->kobj.entry, &devices_kset->list);
+	spin_unlock(&devices_kset->list_lock);
+}
+
 /**
  * device_create_file - create sysfs attribute file for device.
  * @dev: device.
@@ -1923,12 +1969,15 @@ int device_move(struct device *dev, struct device *new_parent,
 		break;
 	case DPM_ORDER_DEV_AFTER_PARENT:
 		device_pm_move_after(dev, new_parent);
+		devices_kset_move_after(dev, new_parent);
 		break;
 	case DPM_ORDER_PARENT_BEFORE_DEV:
 		device_pm_move_before(new_parent, dev);
+		devices_kset_move_before(new_parent, dev);
 		break;
 	case DPM_ORDER_DEV_LAST:
 		device_pm_move_last(dev);
+		devices_kset_move_last(dev);
 		break;
 	}
 

commit 3d060aeb72113cda0acf906bfe26914fc689506a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jul 27 18:04:00 2015 +0300

    driver core: implement device_for_each_child_reverse()
    
    The new function device_for_each_child_reverse() is helpful to traverse the
    registered devices in a reversed order, e.g. in the case when an operation on
    each device should be done first on the last added device, then on one before
    last and so on.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index dafae6d2f7ac..7d6279554afc 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1252,6 +1252,19 @@ void device_unregister(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(device_unregister);
 
+static struct device *prev_device(struct klist_iter *i)
+{
+	struct klist_node *n = klist_prev(i);
+	struct device *dev = NULL;
+	struct device_private *p;
+
+	if (n) {
+		p = to_device_private_parent(n);
+		dev = p->device;
+	}
+	return dev;
+}
+
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);
@@ -1340,6 +1353,36 @@ int device_for_each_child(struct device *parent, void *data,
 }
 EXPORT_SYMBOL_GPL(device_for_each_child);
 
+/**
+ * device_for_each_child_reverse - device child iterator in reversed order.
+ * @parent: parent struct device.
+ * @fn: function to be called for each device.
+ * @data: data for the callback.
+ *
+ * Iterate over @parent's child devices, and call @fn for each,
+ * passing it @data.
+ *
+ * We check the return of @fn each time. If it returns anything
+ * other than 0, we break out and return that value.
+ */
+int device_for_each_child_reverse(struct device *parent, void *data,
+				  int (*fn)(struct device *dev, void *data))
+{
+	struct klist_iter i;
+	struct device *child;
+	int error = 0;
+
+	if (!parent->p)
+		return 0;
+
+	klist_iter_init(&parent->p->klist_children, &i);
+	while ((child = prev_device(&i)) && !error)
+		error = fn(child, data);
+	klist_iter_exit(&i);
+	return error;
+}
+EXPORT_SYMBOL_GPL(device_for_each_child_reverse);
+
 /**
  * device_find_child - device iterator for locating a particular device.
  * @parent: parent struct device

commit 4a7cc831670550e6b48ef5760e7213f89935ff0d
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jul 9 16:00:44 2015 +0800

    genirq/MSI: Move msi_list from struct pci_dev to struct device
    
    Move msi_list from struct pci_dev into struct device, so we can
    support non-PCI-device based generic MSI interrupts.
    
    msi_list is now conditional under CONFIG_GENERIC_MSI_IRQ, which is
    selected from CONFIG_PCI_MSI, so no functional change for PCI MSI
    users.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Reviewed-by: Yijing Wang <wangyijing@huawei.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Stuart Yoder <stuart.yoder@freescale.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Alexander Gordeev <agordeev@redhat.com>
    Link: http://lkml.kernel.org/r/1436428847-8886-10-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index dafae6d2f7ac..18e2a89aa138 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -662,6 +662,9 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->devres_head);
 	device_pm_init(dev);
 	set_dev_node(dev, -1);
+#ifdef CONFIG_GENERIC_MSI_IRQ
+	INIT_LIST_HEAD(&dev->msi_list);
+#endif
 }
 EXPORT_SYMBOL_GPL(device_initialize);
 

commit a29fd614a6af57610b1963e3445f1758c3806187
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Jun 25 15:02:33 2015 -0700

    drivers/base/core.c: use strreplace()
    
    This eliminates a little .text and avoids repeating the strchr call when
    we meet a '!' (which will happen at least once).
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 21d13038534e..dafae6d2f7ac 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1303,12 +1303,11 @@ const char *device_get_devnode(struct device *dev,
 		return dev_name(dev);
 
 	/* replace '!' in the name with '/' */
-	*tmp = kstrdup(dev_name(dev), GFP_KERNEL);
-	if (!*tmp)
+	s = kstrdup(dev_name(dev), GFP_KERNEL);
+	if (!s)
 		return NULL;
-	while ((s = strchr(*tmp, '!')))
-		s[0] = '/';
-	return *tmp;
+	strreplace(s, '!', '/');
+	return *tmp = s;
 }
 
 /**

commit 2481bc75283ea10e75d5fb1a8b42af363fc4b45c
Merge: 8691c130fae1 518b4e272d99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 20:21:54 2015 -0700

    Merge tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups all over, although there are a few
      items that sort of fall into the new feature category.
    
      First off, we have new callbacks for PM domains that should help us to
      handle some issues related to device initialization in a better way.
    
      There also is some consolidation in the unified device properties API
      area allowing us to use that inferface for accessing data coming from
      platform initialization code in addition to firmware-provided data.
    
      We have some new device/CPU IDs in a few drivers, support for new
      chips and a new cpufreq driver too.
    
      Specifics:
    
       - Generic PM domains support update including new PM domain callbacks
         to handle device initialization better (Russell King, Rafael J
         Wysocki, Kevin Hilman)
    
       - Unified device properties API update including a new mechanism for
         accessing data provided by platform initialization code (Rafael J
         Wysocki, Adrian Hunter)
    
       - ARM cpuidle update including ARM32/ARM64 handling consolidation
         (Daniel Lezcano)
    
       - intel_idle update including support for the Silvermont Core in the
         Baytrail SOC and for the Airmont Core in the Cherrytrail and
         Braswell SOCs (Len Brown, Mathias Krause)
    
       - New cpufreq driver for Hisilicon ACPU (Leo Yan)
    
       - intel_pstate update including support for the Knights Landing chip
         (Dasaratharaman Chandramouli, Kristen Carlson Accardi)
    
       - QorIQ cpufreq driver update (Tang Yuantian, Arnd Bergmann)
    
       - powernv cpufreq driver update (Shilpasri G Bhat)
    
       - devfreq update including Tegra support changes (Tomeu Vizoso,
         MyungJoo Ham, Chanwoo Choi)
    
       - powercap RAPL (Running-Average Power Limit) driver update including
         support for Intel Broadwell server chips (Jacob Pan, Mathias Krause)
    
       - ACPI device enumeration update related to the handling of the
         special PRP0001 device ID allowing DT-style 'compatible' property
         to be used for ACPI device identification (Rafael J Wysocki)
    
       - ACPI EC driver update including limited _DEP support (Lan Tianyu,
         Lv Zheng)
    
       - ACPI backlight driver update including a new mechanism to allow
         native backlight handling to be forced on non-Windows 8 systems and
         a new quirk for Lenovo Ideapad Z570 (Aaron Lu, Hans de Goede)
    
       - New Windows Vista compatibility quirk for Sony VGN-SR19XN (Chen Yu)
    
       - Assorted ACPI fixes and cleanups (Aaron Lu, Martin Kepplinger,
         Masanari Iida, Mika Westerberg, Nan Li, Rafael J Wysocki)
    
       - Fixes related to suspend-to-idle for the iTCO watchdog driver and
         the ACPI core system suspend/resume code (Rafael J Wysocki, Chen Yu)
    
       - PM tracing support for the suspend phase of system suspend/resume
         transitions (Zhonghui Fu)
    
       - Configurable delay for the system suspend/resume testing facility
         (Brian Norris)
    
       - PNP subsystem cleanups (Peter Huewe, Rafael J Wysocki)"
    
    * tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (74 commits)
      ACPI / scan: Fix NULL pointer dereference in acpi_companion_match()
      ACPI / scan: Rework modalias creation when "compatible" is present
      intel_idle: mark cpu id array as __initconst
      powercap / RAPL: mark rapl_ids array as __initconst
      powercap / RAPL: add ID for Broadwell server
      intel_pstate: Knights Landing support
      intel_pstate: remove MSR test
      cpufreq: fix qoriq uniprocessor build
      ACPI / scan: Take the PRP0001 position in the list of IDs into account
      ACPI / scan: Simplify acpi_match_device()
      ACPI / scan: Generalize of_compatible matching
      device property: Introduce firmware node type for platform data
      device property: Make it possible to use secondary firmware nodes
      PM / watchdog: iTCO: stop watchdog during system suspend
      cpufreq: hisilicon: add acpu driver
      ACPI / EC: Call acpi_walk_dep_device_list() after installing EC opregion handler
      cpufreq: powernv: Report cpu frequency throttling
      intel_idle: Add support for the Airmont Core in the Cherrytrail and Braswell SOCs
      intel_idle: Update support for Silvermont Core in Baytrail SOC
      PM / devfreq: tegra: Register governor on module init
      ...

commit 97badf873ab60e841243b66133ff9eff2a46ef29
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 3 23:23:37 2015 +0200

    device property: Make it possible to use secondary firmware nodes
    
    Add a secondary pointer to struct fwnode_handle so as to make it
    possible for a device to have two firmware nodes associated with
    it at the same time, for example, an ACPI node and a node with
    a set of properties provided by platform initialization code.
    
    In the future that will allow device property lookup to fall back
    from the primary firmware node to the secondary one if the given
    property is not present there to make it easier to provide defaults
    for device properties used by device drivers.
    
    Introduce two helper routines, set_primary_fwnode() and
    set_secondary_fwnode() allowing callers to add a primary/secondary
    firmware node to the given device in such a way that
    
     (1) If there's only one firmware node for that device, it will be
         pointed to by the device's firmware node pointer.
     (2) If both the primary and secondary firmware nodes are present,
         the primary one will be pointed to by the device's firmware
         node pointer, while the secondary one will be pointed to by the
         primary node's secondary pointer.
     (3) If one of these nodes is removed (by calling one of the new
         nelpers with NULL as the second argument), the other one will
         be preserved.
    
    Make ACPI use set_primary_fwnode() for attaching its firmware nodes
    to devices.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 07304a3b9ee2..c7e2a9a70865 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -12,6 +12,7 @@
 
 #include <linux/device.h>
 #include <linux/err.h>
+#include <linux/fwnode.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -2133,3 +2134,53 @@ define_dev_printk_level(dev_notice, KERN_NOTICE);
 define_dev_printk_level(_dev_info, KERN_INFO);
 
 #endif
+
+static inline bool fwnode_is_primary(struct fwnode_handle *fwnode)
+{
+	return fwnode && !IS_ERR(fwnode->secondary);
+}
+
+/**
+ * set_primary_fwnode - Change the primary firmware node of a given device.
+ * @dev: Device to handle.
+ * @fwnode: New primary firmware node of the device.
+ *
+ * Set the device's firmware node pointer to @fwnode, but if a secondary
+ * firmware node of the device is present, preserve it.
+ */
+void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode)
+{
+	if (fwnode) {
+		struct fwnode_handle *fn = dev->fwnode;
+
+		if (fwnode_is_primary(fn))
+			fn = fn->secondary;
+
+		fwnode->secondary = fn;
+		dev->fwnode = fwnode;
+	} else {
+		dev->fwnode = fwnode_is_primary(dev->fwnode) ?
+			dev->fwnode->secondary : NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(set_primary_fwnode);
+
+/**
+ * set_secondary_fwnode - Change the secondary firmware node of a given device.
+ * @dev: Device to handle.
+ * @fwnode: New secondary firmware node of the device.
+ *
+ * If a primary firmware node of the device is present, set its secondary
+ * pointer to @fwnode.  Otherwise, set the device's firmware node pointer to
+ * @fwnode.
+ */
+void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode)
+{
+	if (fwnode)
+		fwnode->secondary = ERR_PTR(-ENODEV);
+
+	if (fwnode_is_primary(dev->fwnode))
+		dev->fwnode->secondary = fwnode;
+	else
+		dev->fwnode = fwnode;
+}

commit 5590f3196b293574a12be58d06d5e1120d8856ec
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Feb 18 11:25:18 2015 +1100

    drivers/core/of: Add symlink to device-tree from devices with an OF node
    
    So I've been annoyed lately with having a bunch of devices such as i2c
    eeproms (for use by VPDs, server world !) and other bits and pieces that
    I want to be able to identify from userspace, and possibly provide
    additional data about from FW.
    
    Basically, it boils down to correlating the sysfs device with the OF
    tree device node, so that user space can use device-tree info such as
    additional "location" or "label" (or whatever else we can come up with)
    propreties to identify a given device, or get some attributes of use
    about it, etc...
    
    Now, so far, we've done that in some subsystem in a fairly ad-hoc basis
    using "devspec" properties. For example, PCI creates them if it can
    correlate the probed device with a DT node. Some powerpc specific busses
    do that too.
    
    However, i2c doesn't and it would be nice to have something more generic
    since technically any device can have a corresponding device tree node.
    
    This patch adds an "of_node" symlink to devices that have a non-NULL
    dev->of_node pointer, the patch is pretty trivial and seems to work just
    fine for me.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e0998b6b6c49..cadf165651d8 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -805,8 +805,16 @@ static void cleanup_device_parent(struct device *dev)
 
 static int device_add_class_symlinks(struct device *dev)
 {
+	struct device_node *of_node = dev_of_node(dev);
 	int error;
 
+	if (of_node) {
+		error = sysfs_create_link(&dev->kobj, &of_node->kobj,"of_node");
+		if (error)
+			dev_warn(dev, "Error %d creating of_node link\n",error);
+		/* An error here doesn't warrant bringing down the device */
+	}
+
 	if (!dev->class)
 		return 0;
 
@@ -814,7 +822,7 @@ static int device_add_class_symlinks(struct device *dev)
 				  &dev->class->p->subsys.kobj,
 				  "subsystem");
 	if (error)
-		goto out;
+		goto out_devnode;
 
 	if (dev->parent && device_is_not_partition(dev)) {
 		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
@@ -842,12 +850,16 @@ static int device_add_class_symlinks(struct device *dev)
 
 out_subsys:
 	sysfs_remove_link(&dev->kobj, "subsystem");
-out:
+out_devnode:
+	sysfs_remove_link(&dev->kobj, "of_node");
 	return error;
 }
 
 static void device_remove_class_symlinks(struct device *dev)
 {
+	if (dev_of_node(dev))
+		sysfs_remove_link(&dev->kobj, "of_node");
+
 	if (!dev->class)
 		return;
 

commit 5f0163a5ee9cc7c59751768bdfd94a73186debba
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Feb 5 11:48:26 2015 +0100

    driver core: Delete an unnecessary check before the function call "put_device"
    
    The put_device() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 07304a3b9ee2..e0998b6b6c49 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1095,8 +1095,7 @@ int device_add(struct device *dev)
 	kobject_del(&dev->kobj);
  Error:
 	cleanup_device_parent(dev);
-	if (parent)
-		put_device(parent);
+	put_device(parent);
 name_error:
 	kfree(dev->p);
 	dev->p = NULL;

commit d1f1052c520452494db548b1a701cd9020b5903e
Author: Joe Perches <joe@perches.com>
Date:   Thu Dec 25 15:07:04 2014 -0800

    device: Change dev_<level> logging functions to return void
    
    No caller or macro uses the return value so make all
    the functions return void.
    
    Compiled x86 allyesconfig and defconfig w/o CONFIG_PRINTK
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 97e2baf6e5d8..07304a3b9ee2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2080,54 +2080,47 @@ int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
 }
 EXPORT_SYMBOL(dev_printk_emit);
 
-static int __dev_printk(const char *level, const struct device *dev,
+static void __dev_printk(const char *level, const struct device *dev,
 			struct va_format *vaf)
 {
-	if (!dev)
-		return printk("%s(NULL device *): %pV", level, vaf);
-
-	return dev_printk_emit(level[1] - '0', dev,
-			       "%s %s: %pV",
-			       dev_driver_string(dev), dev_name(dev), vaf);
+	if (dev)
+		dev_printk_emit(level[1] - '0', dev, "%s %s: %pV",
+				dev_driver_string(dev), dev_name(dev), vaf);
+	else
+		printk("%s(NULL device *): %pV", level, vaf);
 }
 
-int dev_printk(const char *level, const struct device *dev,
-	       const char *fmt, ...)
+void dev_printk(const char *level, const struct device *dev,
+		const char *fmt, ...)
 {
 	struct va_format vaf;
 	va_list args;
-	int r;
 
 	va_start(args, fmt);
 
 	vaf.fmt = fmt;
 	vaf.va = &args;
 
-	r = __dev_printk(level, dev, &vaf);
+	__dev_printk(level, dev, &vaf);
 
 	va_end(args);
-
-	return r;
 }
 EXPORT_SYMBOL(dev_printk);
 
 #define define_dev_printk_level(func, kern_level)		\
-int func(const struct device *dev, const char *fmt, ...)	\
+void func(const struct device *dev, const char *fmt, ...)	\
 {								\
 	struct va_format vaf;					\
 	va_list args;						\
-	int r;							\
 								\
 	va_start(args, fmt);					\
 								\
 	vaf.fmt = fmt;						\
 	vaf.va = &args;						\
 								\
-	r = __dev_printk(kern_level, dev, &vaf);		\
+	__dev_printk(kern_level, dev, &vaf);			\
 								\
 	va_end(args);						\
-								\
-	return r;						\
 }								\
 EXPORT_SYMBOL(func);
 

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 0cd75047de7f54d6fb4aba0ec5818f8194815a5a
Author: Sergey Klyaus <Sergey.Klyaus@tune-it.ru>
Date:   Wed Oct 8 11:31:54 2014 +0400

    driver core: fix race with userland in device_add()
    
    bus_add_device() should be called before devtmpfs_create_node(), so when
    userland application opens device from devtmpfs, it wouldn't get ENODEV
    from kernel, because device_add() wasn't completed.
    
    Signed-off-by: Sergey Klyaus <Sergey.Klyaus@Tune-IT.Ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 14d162952c3b..00ec7ce6f3e3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1019,18 +1019,6 @@ int device_add(struct device *dev)
 	if (error)
 		goto attrError;
 
-	if (MAJOR(dev->devt)) {
-		error = device_create_file(dev, &dev_attr_dev);
-		if (error)
-			goto ueventattrError;
-
-		error = device_create_sys_dev_entry(dev);
-		if (error)
-			goto devtattrError;
-
-		devtmpfs_create_node(dev);
-	}
-
 	error = device_add_class_symlinks(dev);
 	if (error)
 		goto SymlinkError;
@@ -1045,6 +1033,18 @@ int device_add(struct device *dev)
 		goto DPMError;
 	device_pm_add(dev);
 
+	if (MAJOR(dev->devt)) {
+		error = device_create_file(dev, &dev_attr_dev);
+		if (error)
+			goto DevAttrError;
+
+		error = device_create_sys_dev_entry(dev);
+		if (error)
+			goto SysEntryError;
+
+		devtmpfs_create_node(dev);
+	}
+
 	/* Notify clients of device addition.  This call must come
 	 * after dpm_sysfs_add() and before kobject_uevent().
 	 */
@@ -1074,6 +1074,12 @@ int device_add(struct device *dev)
 done:
 	put_device(dev);
 	return error;
+ SysEntryError:
+	if (MAJOR(dev->devt))
+		device_remove_file(dev, &dev_attr_dev);
+ DevAttrError:
+	device_pm_remove(dev);
+	dpm_sysfs_remove(dev);
  DPMError:
 	bus_remove_device(dev);
  BusError:
@@ -1081,14 +1087,6 @@ int device_add(struct device *dev)
  AttrsError:
 	device_remove_class_symlinks(dev);
  SymlinkError:
-	if (MAJOR(dev->devt))
-		devtmpfs_delete_node(dev);
-	if (MAJOR(dev->devt))
-		device_remove_sys_dev_entry(dev);
- devtattrError:
-	if (MAJOR(dev->devt))
-		device_remove_file(dev, &dev_attr_dev);
- ueventattrError:
 	device_remove_file(dev, &dev_attr_uevent);
  attrError:
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);

commit e4a60d139060975eb956717e4f63ae348d4d8cc5
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri Nov 7 12:05:49 2014 +0800

    sysfs: driver core: Fix glue dir race condition by gdp_mutex
    
    There is a race condition when removing glue directory.
    It can be reproduced in following test:
    
    path 1: Add first child device
    device_add()
        get_device_parent()
                /*find parent from glue_dirs.list*/
                list_for_each_entry(k, &dev->class->p->glue_dirs.list, entry)
                        if (k->parent == parent_kobj) {
                                kobj = kobject_get(k);
                                break;
                        }
                ....
                class_dir_create_and_add()
    
    path2: Remove last child device under glue dir
    device_del()
        cleanup_device_parent()
                cleanup_glue_dir()
                        kobject_put(glue_dir);
    
    If path2 has been called cleanup_glue_dir(), but not
    call kobject_put(glue_dir), the glue dir is still
    in parent's kset list. Meanwhile, path1 find the glue
    dir from the glue_dirs.list. Path2 may release glue dir
    before path1 call kobject_get(). So kernel will report
    the warning and bug_on.
    
    This is a "classic" problem we have of a kref in a list
    that can be found while the last instance could be removed
    at the same time.
    
    This patch reuse gdp_mutex to fix this race condition.
    
    The following calltrace is captured in kernel 3.4, but
    the latest kernel still has this bug.
    
    -----------------------------------------------------
    <4>[ 3965.441471] WARNING: at ...include/linux/kref.h:41 kobject_get+0x33/0x40()
    <4>[ 3965.441474] Hardware name: Romley
    <4>[ 3965.441475] Modules linked in: isd_iop(O) isd_xda(O)...
    ...
    <4>[ 3965.441605] Call Trace:
    <4>[ 3965.441611]  [<ffffffff8103717a>] warn_slowpath_common+0x7a/0xb0
    <4>[ 3965.441615]  [<ffffffff810371c5>] warn_slowpath_null+0x15/0x20
    <4>[ 3965.441618]  [<ffffffff81215963>] kobject_get+0x33/0x40
    <4>[ 3965.441624]  [<ffffffff812d1e45>] get_device_parent.isra.11+0x135/0x1f0
    <4>[ 3965.441627]  [<ffffffff812d22d4>] device_add+0xd4/0x6d0
    <4>[ 3965.441631]  [<ffffffff812d0dbc>] ? dev_set_name+0x3c/0x40
    ....
    <2>[ 3965.441912] kernel BUG at ..../fs/sysfs/group.c:65!
    <4>[ 3965.441915] invalid opcode: 0000 [#1] SMP
    ...
    <4>[ 3965.686743]  [<ffffffff811a677e>] sysfs_create_group+0xe/0x10
    <4>[ 3965.686748]  [<ffffffff810cfb04>] blk_trace_init_sysfs+0x14/0x20
    <4>[ 3965.686753]  [<ffffffff811fcabb>] blk_register_queue+0x3b/0x120
    <4>[ 3965.686756]  [<ffffffff812030bc>] add_disk+0x1cc/0x490
    ....
    -------------------------------------------------------
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Weng Meiling <wengmeiling.weng@huawei.com>
    Cc: <stable@vger.kernel.org> #3.4+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 14d162952c3b..842d04707de6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -724,12 +724,12 @@ class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)
 	return &dir->kobj;
 }
 
+static DEFINE_MUTEX(gdp_mutex);
 
 static struct kobject *get_device_parent(struct device *dev,
 					 struct device *parent)
 {
 	if (dev->class) {
-		static DEFINE_MUTEX(gdp_mutex);
 		struct kobject *kobj = NULL;
 		struct kobject *parent_kobj;
 		struct kobject *k;
@@ -793,7 +793,9 @@ static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 	    glue_dir->kset != &dev->class->p->glue_dirs)
 		return;
 
+	mutex_lock(&gdp_mutex);
 	kobject_put(glue_dir);
+	mutex_unlock(&gdp_mutex);
 }
 
 static void cleanup_device_parent(struct device *dev)

commit 23971bdffff5f7c904131dfb41c186711dc2c418
Merge: c0fa2373f8cf 09b5269a1b3d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 15 07:23:49 2014 +0200

    Merge tag 'iommu-updates-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull IOMMU updates from Joerg Roedel:
     "This pull-request includes:
    
       - change in the IOMMU-API to convert the former iommu_domain_capable
         function to just iommu_capable
    
       - various fixes in handling RMRR ranges for the VT-d driver (one fix
         requires a device driver core change which was acked by Greg KH)
    
       - the AMD IOMMU driver now assigns and deassigns complete alias
         groups to fix issues with devices using the wrong PCI request-id
    
       - MMU-401 support for the ARM SMMU driver
    
       - multi-master IOMMU group support for the ARM SMMU driver
    
       - various other small fixes all over the place"
    
    * tag 'iommu-updates-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (41 commits)
      iommu/vt-d: Work around broken RMRR firmware entries
      iommu/vt-d: Store bus information in RMRR PCI device path
      iommu/vt-d: Only remove domain when device is removed
      driver core: Add BUS_NOTIFY_REMOVED_DEVICE event
      iommu/amd: Fix devid mapping for ivrs_ioapic override
      iommu/irq_remapping: Fix the regression of hpet irq remapping
      iommu: Fix bus notifier breakage
      iommu/amd: Split init_iommu_group() from iommu_init_device()
      iommu: Rework iommu_group_get_for_pci_dev()
      iommu: Make of_device_id array const
      amd_iommu: do not dereference a NULL pointer address.
      iommu/omap: Remove omap_iommu unused owner field
      iommu: Remove iommu_domain_has_cap() API function
      IB/usnic: Convert to use new iommu_capable() API function
      vfio: Convert to use new iommu_capable() API function
      kvm: iommu: Convert to use new iommu_capable() API function
      iommu/tegra: Convert to iommu_capable() API function
      iommu/msm: Convert to iommu_capable() API function
      iommu/vt-d: Convert to iommu_capable() API function
      iommu/fsl: Convert to iommu_capable() API function
      ...

commit 599bad38cf7163123af7c9efea0fcf228bc74fe1
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Sep 30 13:02:02 2014 +0200

    driver core: Add BUS_NOTIFY_REMOVED_DEVICE event
    
    This event closes an important gap in the bus notifiers.
    There is already the BUS_NOTIFY_DEL_DEVICE event, but that
    is sent when the device is still bound to its device driver.
    
    This is too early for the IOMMU code to destroy any mappings
    for the device, as they might still be in use by the driver.
    
    The new BUS_NOTIFY_REMOVED_DEVICE event introduced with this
    patch closes this gap as it is sent when the device is
    already unbound from its device driver and almost completly
    removed from the driver core.
    
    With this event the IOMMU code can safely destroy any
    mappings and other data structures when a device is removed.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Jerry Hoemann <jerry.hoemann@hp.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 20da3ad1696b..7b270a2e6ed5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1211,6 +1211,9 @@ void device_del(struct device *dev)
 	 */
 	if (platform_notify_remove)
 		platform_notify_remove(dev);
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
+					     BUS_NOTIFY_REMOVED_DEVICE, dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	cleanup_device_parent(dev);
 	kobject_del(&dev->kobj);

commit 655e5b7c031e84cf8c07cfd6a5944ce53cba1add
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Tue Aug 26 00:34:44 2014 -0700

    drivers/base: Fix length checks in create_syslog_header()/dev_vprintk_emit()
    
    snprintf() returns the number of bytes that could have been written
    (excluding the null), not the actual number of bytes written.  Given a
    long enough subsystem or device name, these functions will advance
    beyond the end of the on-stack buffer in dev_vprintk_exit(), resulting
    in an information leak or stack corruption.  I don't know whether such
    a long name is currently possible.
    
    In case snprintf() returns a value >= the buffer size, do not add
    structured logging information.  Also WARN if this happens, so we can
    fix the driver or increase the buffer size.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 20da3ad1696b..28b808c73e8e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2007,6 +2007,8 @@ create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
 		return 0;
 
 	pos += snprintf(hdr + pos, hdrlen - pos, "SUBSYSTEM=%s", subsys);
+	if (pos >= hdrlen)
+		goto overflow;
 
 	/*
 	 * Add device identifier DEVICE=:
@@ -2038,7 +2040,14 @@ create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
 				"DEVICE=+%s:%s", subsys, dev_name(dev));
 	}
 
+	if (pos >= hdrlen)
+		goto overflow;
+
 	return pos;
+
+overflow:
+	dev_WARN(dev, "device/subsystem name too long");
+	return 0;
 }
 
 int dev_vprintk_emit(int level, const struct device *dev,

commit 33ac1257ff0dee2e9c7f009b1c1914b7990217b2
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:31 2014 -0500

    sysfs, driver-core: remove unused {sysfs|device}_schedule_callback_owner()
    
    All device_schedule_callback_owner() users are converted to use
    device_remove_file_self().  Remove now unused
    {sysfs|device}_schedule_callback_owner().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0dd65281cc65..20da3ad1696b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -614,39 +614,6 @@ void device_remove_bin_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
-/**
- * device_schedule_callback_owner - helper to schedule a callback for a device
- * @dev: device.
- * @func: callback function to invoke later.
- * @owner: module owning the callback routine
- *
- * Attribute methods must not unregister themselves or their parent device
- * (which would amount to the same thing).  Attempts to do so will deadlock,
- * since unregistration is mutually exclusive with driver callbacks.
- *
- * Instead methods can call this routine, which will attempt to allocate
- * and schedule a workqueue request to call back @func with @dev as its
- * argument in the workqueue's process context.  @dev will be pinned until
- * @func returns.
- *
- * This routine is usually called via the inline device_schedule_callback(),
- * which automatically sets @owner to THIS_MODULE.
- *
- * Returns 0 if the request was submitted, -ENOMEM if storage could not
- * be allocated, -ENODEV if a reference to @owner isn't available.
- *
- * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
- * underlying sysfs routine (since it is intended for use by attribute
- * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
- */
-int device_schedule_callback_owner(struct device *dev,
-		void (*func)(struct device *), struct module *owner)
-{
-	return sysfs_schedule_callback(&dev->kobj,
-			(void (*)(void *)) func, dev, owner);
-}
-EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
-
 static void klist_children_get(struct klist_node *n)
 {
 	struct device_private *p = to_device_private_parent(n);

commit 72099304eeb316c4b00df3ae83efe4375729bd78
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Mar 25 20:54:57 2014 -0700

    Revert "sysfs, driver-core: remove unused {sysfs|device}_schedule_callback_owner()"
    
    This reverts commit d1ba277e79889085a2faec3b68b91ce89c63f888.
    
    As reported by Stephen, this patch breaks linux-next as a ppc patch
    suddenly (after 2 years) started using this old api call.  So revert it
    for now, it will go away in 3.15-rc2 when we can change the PPC call to
    the new api.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Stewart Smith <stewart@linux.vnet.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 20da3ad1696b..0dd65281cc65 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -614,6 +614,39 @@ void device_remove_bin_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
+/**
+ * device_schedule_callback_owner - helper to schedule a callback for a device
+ * @dev: device.
+ * @func: callback function to invoke later.
+ * @owner: module owning the callback routine
+ *
+ * Attribute methods must not unregister themselves or their parent device
+ * (which would amount to the same thing).  Attempts to do so will deadlock,
+ * since unregistration is mutually exclusive with driver callbacks.
+ *
+ * Instead methods can call this routine, which will attempt to allocate
+ * and schedule a workqueue request to call back @func with @dev as its
+ * argument in the workqueue's process context.  @dev will be pinned until
+ * @func returns.
+ *
+ * This routine is usually called via the inline device_schedule_callback(),
+ * which automatically sets @owner to THIS_MODULE.
+ *
+ * Returns 0 if the request was submitted, -ENOMEM if storage could not
+ * be allocated, -ENODEV if a reference to @owner isn't available.
+ *
+ * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
+ * underlying sysfs routine (since it is intended for use by attribute
+ * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
+ */
+int device_schedule_callback_owner(struct device *dev,
+		void (*func)(struct device *), struct module *owner)
+{
+	return sysfs_schedule_callback(&dev->kobj,
+			(void (*)(void *)) func, dev, owner);
+}
+EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
+
 static void klist_children_get(struct klist_node *n)
 {
 	struct device_private *p = to_device_private_parent(n);

commit aa0689b36b2144e91d2182605bed951565c4899b
Author: Roland Dreier <roland@purestorage.com>
Date:   Tue Mar 4 19:57:51 2014 -0800

    Revert "driver core: synchronize device shutdown"
    
    This reverts commit 401097ea4b89846d66ac78f7f108d49c2e922d9c.  The
    original changelog said:
    
        A patch series to make .shutdown execute asynchronously.  Some drivers's
        shutdown can take a lot of time.  The patches can help save some shutdown
        time.  The patches use Arjan's async API.
    
        This patch:
    
        synchronize all tasks submitted by .shutdown
    
    However, I'm not able to find any evidence that any other patches from
    this series were applied, nor am I able to find any async tasks that are
    scheduled in a .shutdown context.
    
    On the other hand, we see occasional hangs on shutdown that appear to be
    caused by the async_synchronize_full() in device_shutdown() waiting
    forever for the async probing in sd if a SCSI disk shows up at just the
    wrong time — the system starts the probe, but begins shutting down and
    tears down too much of the SCSI driver to finish the probe.
    
    If we had any async shutdown tasks, I guess the right fix would be to
    create a "shutdown" async domain and have device_shutdown() only wait
    for that domain.  But since there apparently are no async shutdown
    tasks, we can just revert the waiting.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 80b6a9b22f3e..20da3ad1696b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -23,7 +23,6 @@
 #include <linux/genhd.h>
 #include <linux/kallsyms.h>
 #include <linux/mutex.h>
-#include <linux/async.h>
 #include <linux/pm_runtime.h>
 #include <linux/netdevice.h>
 #include <linux/sysfs.h>
@@ -1987,7 +1986,6 @@ void device_shutdown(void)
 		spin_lock(&devices_kset->list_lock);
 	}
 	spin_unlock(&devices_kset->list_lock);
-	async_synchronize_full();
 }
 
 /*

commit 5c764dfaefc582d9c3e2bbd52ae2e30747af8a37
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sat Feb 8 09:59:02 2014 +0800

    driver core: unexport static function create_syslog_header
    
    Function create_syslog_header() is defined as static, so it should
    not be exported.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4195364f9fdd..80b6a9b22f3e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2042,7 +2042,6 @@ create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
 
 	return pos;
 }
-EXPORT_SYMBOL(create_syslog_header);
 
 int dev_vprintk_emit(int level, const struct device *dev,
 		     const char *fmt, va_list args)

commit ce8b04aa6c9bdf211b921fdd18c040ea29516b97
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:03:05 2014 -0500

    sysfs, driver-core: remove unused {sysfs|device}_schedule_callback_owner()
    
    All device_schedule_callback_owner() users are converted to use
    device_remove_file_self().  Remove now unused
    {sysfs|device}_schedule_callback_owner().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9db57afcf81f..4195364f9fdd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -615,39 +615,6 @@ void device_remove_bin_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
-/**
- * device_schedule_callback_owner - helper to schedule a callback for a device
- * @dev: device.
- * @func: callback function to invoke later.
- * @owner: module owning the callback routine
- *
- * Attribute methods must not unregister themselves or their parent device
- * (which would amount to the same thing).  Attempts to do so will deadlock,
- * since unregistration is mutually exclusive with driver callbacks.
- *
- * Instead methods can call this routine, which will attempt to allocate
- * and schedule a workqueue request to call back @func with @dev as its
- * argument in the workqueue's process context.  @dev will be pinned until
- * @func returns.
- *
- * This routine is usually called via the inline device_schedule_callback(),
- * which automatically sets @owner to THIS_MODULE.
- *
- * Returns 0 if the request was submitted, -ENOMEM if storage could not
- * be allocated, -ENODEV if a reference to @owner isn't available.
- *
- * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
- * underlying sysfs routine (since it is intended for use by attribute
- * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
- */
-int device_schedule_callback_owner(struct device *dev,
-		void (*func)(struct device *), struct module *owner)
-{
-	return sysfs_schedule_callback(&dev->kobj,
-			(void (*)(void *)) func, dev, owner);
-}
-EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
-
 static void klist_children_get(struct klist_node *n)
 {
 	struct device_private *p = to_device_private_parent(n);

commit 6b0afc2a21726b2d6b6aa441af40cafaf5405cc8
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:03:01 2014 -0500

    kernfs, sysfs, driver-core: implement kernfs_remove_self() and its wrappers
    
    Sometimes it's necessary to implement a node which wants to delete
    nodes including itself.  This isn't straightforward because of kernfs
    active reference.  While a file operation is in progress, an active
    reference is held and kernfs_remove() waits for all such references to
    drain before completing.  For a self-deleting node, this is a deadlock
    as kernfs_remove() ends up waiting for an active reference that itself
    is sitting on top of.
    
    This currently is worked around in the sysfs layer using
    sysfs_schedule_callback() which makes such removals asynchronous.
    While it works, it's rather cumbersome and inherently breaks
    synchronicity of the operation - the file operation which triggered
    the operation may complete before the removal is finished (or even
    started) and the removal may fail asynchronously.  If a removal
    operation is immmediately followed by another operation which expects
    the specific name to be available (e.g. removal followed by rename
    onto the same name), there's no way to make the latter operation
    reliable.
    
    The thing is there's no inherent reason for this to be asynchrnous.
    All that's necessary to do this synchronous is a dedicated operation
    which drops its own active ref and deactivates self.  This patch
    implements kernfs_remove_self() and its wrappers in sysfs and driver
    core.  kernfs_remove_self() is to be called from one of the file
    operations, drops the active ref the task is holding, removes the self
    node, and restores active ref to the dead node so that the ref is
    balanced afterwards.  __kernfs_remove() is updated so that it takes an
    early exit if the target node is already fully removed so that the
    active ref restored by kernfs_remove_self() after removal doesn't
    confuse the deactivation path.
    
    This makes implementing self-deleting nodes very easy.  The normal
    removal path doesn't even need to be changed to use
    kernfs_remove_self() for the self-deleting node.  The method can
    invoke kernfs_remove_self() on itself before proceeding the normal
    removal path.  kernfs_remove() invoked on the node by the normal
    deletion path will simply be ignored.
    
    This will replace sysfs_schedule_callback().  A subtle feature of
    sysfs_schedule_callback() is that it collapses multiple invocations -
    even if multiple removals are triggered, the removal callback is run
    only once.  An equivalent effect can be achieved by testing the return
    value of kernfs_remove_self() - only the one which gets %true return
    value should proceed with actual deletion.  All other instances of
    kernfs_remove_self() will wait till the enclosing kernfs operation
    which invoked the winning instance of kernfs_remove_self() finishes
    and then return %false.  This trivially makes all users of
    kernfs_remove_self() automatically show correct synchronous behavior
    even when there are multiple concurrent operations - all "echo 1 >
    delete" instances will finish only after the whole operation is
    completed by one of the instances.
    
    Note that manipulation of active ref is implemented in separate public
    functions - kernfs_[un]break_active_protection().
    kernfs_remove_self() is the only user at the moment but this will be
    used to cater to more complex cases.
    
    v2: For !CONFIG_SYSFS, dummy version kernfs_remove_self() was missing
        and sysfs_remove_file_self() had incorrect return type.  Fix it.
        Reported by kbuild test bot.
    
    v3: kernfs_[un]break_active_protection() separated out from
        kernfs_remove_self() and exposed as public API.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2b567177ef78..9db57afcf81f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -570,6 +570,23 @@ void device_remove_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_file);
 
+/**
+ * device_remove_file_self - remove sysfs attribute file from its own method.
+ * @dev: device.
+ * @attr: device attribute descriptor.
+ *
+ * See kernfs_remove_self() for details.
+ */
+bool device_remove_file_self(struct device *dev,
+			     const struct device_attribute *attr)
+{
+	if (dev)
+		return sysfs_remove_file_self(&dev->kobj, &attr->attr);
+	else
+		return false;
+}
+EXPORT_SYMBOL_GPL(device_remove_file_self);
+
 /**
  * device_create_bin_file - create sysfs binary attribute file for device.
  * @dev: device.

commit a9f138b0e537de55933335d580ebd38c2bc53c47
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:05:13 2014 -0800

    Revert "kernfs, sysfs, driver-core: implement kernfs_remove_self() and its wrappers"
    
    This reverts commit 1ae06819c77cff1ea2833c94f8c093fe8a5c79db.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9db57afcf81f..2b567177ef78 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -570,23 +570,6 @@ void device_remove_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_file);
 
-/**
- * device_remove_file_self - remove sysfs attribute file from its own method.
- * @dev: device.
- * @attr: device attribute descriptor.
- *
- * See kernfs_remove_self() for details.
- */
-bool device_remove_file_self(struct device *dev,
-			     const struct device_attribute *attr)
-{
-	if (dev)
-		return sysfs_remove_file_self(&dev->kobj, &attr->attr);
-	else
-		return false;
-}
-EXPORT_SYMBOL_GPL(device_remove_file_self);
-
 /**
  * device_create_bin_file - create sysfs binary attribute file for device.
  * @dev: device.

commit a30f82b7ebc87cdec3ef48303278f02970086118
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 13:51:36 2014 -0800

    Revert "sysfs, driver-core: remove unused {sysfs|device}_schedule_callback_owner()"
    
    This reverts commit d1ba277e79889085a2faec3b68b91ce89c63f888.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4195364f9fdd..9db57afcf81f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -615,6 +615,39 @@ void device_remove_bin_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
+/**
+ * device_schedule_callback_owner - helper to schedule a callback for a device
+ * @dev: device.
+ * @func: callback function to invoke later.
+ * @owner: module owning the callback routine
+ *
+ * Attribute methods must not unregister themselves or their parent device
+ * (which would amount to the same thing).  Attempts to do so will deadlock,
+ * since unregistration is mutually exclusive with driver callbacks.
+ *
+ * Instead methods can call this routine, which will attempt to allocate
+ * and schedule a workqueue request to call back @func with @dev as its
+ * argument in the workqueue's process context.  @dev will be pinned until
+ * @func returns.
+ *
+ * This routine is usually called via the inline device_schedule_callback(),
+ * which automatically sets @owner to THIS_MODULE.
+ *
+ * Returns 0 if the request was submitted, -ENOMEM if storage could not
+ * be allocated, -ENODEV if a reference to @owner isn't available.
+ *
+ * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
+ * underlying sysfs routine (since it is intended for use by attribute
+ * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
+ */
+int device_schedule_callback_owner(struct device *dev,
+		void (*func)(struct device *), struct module *owner)
+{
+	return sysfs_schedule_callback(&dev->kobj,
+			(void (*)(void *)) func, dev, owner);
+}
+EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
+
 static void klist_children_get(struct klist_node *n)
 {
 	struct device_private *p = to_device_private_parent(n);

commit d1ba277e79889085a2faec3b68b91ce89c63f888
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:31 2014 -0500

    sysfs, driver-core: remove unused {sysfs|device}_schedule_callback_owner()
    
    All device_schedule_callback_owner() users are converted to use
    device_remove_file_self().  Remove now unused
    {sysfs|device}_schedule_callback_owner().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9db57afcf81f..4195364f9fdd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -615,39 +615,6 @@ void device_remove_bin_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
-/**
- * device_schedule_callback_owner - helper to schedule a callback for a device
- * @dev: device.
- * @func: callback function to invoke later.
- * @owner: module owning the callback routine
- *
- * Attribute methods must not unregister themselves or their parent device
- * (which would amount to the same thing).  Attempts to do so will deadlock,
- * since unregistration is mutually exclusive with driver callbacks.
- *
- * Instead methods can call this routine, which will attempt to allocate
- * and schedule a workqueue request to call back @func with @dev as its
- * argument in the workqueue's process context.  @dev will be pinned until
- * @func returns.
- *
- * This routine is usually called via the inline device_schedule_callback(),
- * which automatically sets @owner to THIS_MODULE.
- *
- * Returns 0 if the request was submitted, -ENOMEM if storage could not
- * be allocated, -ENODEV if a reference to @owner isn't available.
- *
- * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
- * underlying sysfs routine (since it is intended for use by attribute
- * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
- */
-int device_schedule_callback_owner(struct device *dev,
-		void (*func)(struct device *), struct module *owner)
-{
-	return sysfs_schedule_callback(&dev->kobj,
-			(void (*)(void *)) func, dev, owner);
-}
-EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
-
 static void klist_children_get(struct klist_node *n)
 {
 	struct device_private *p = to_device_private_parent(n);

commit 1ae06819c77cff1ea2833c94f8c093fe8a5c79db
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:27 2014 -0500

    kernfs, sysfs, driver-core: implement kernfs_remove_self() and its wrappers
    
    Sometimes it's necessary to implement a node which wants to delete
    nodes including itself.  This isn't straightforward because of kernfs
    active reference.  While a file operation is in progress, an active
    reference is held and kernfs_remove() waits for all such references to
    drain before completing.  For a self-deleting node, this is a deadlock
    as kernfs_remove() ends up waiting for an active reference that itself
    is sitting on top of.
    
    This currently is worked around in the sysfs layer using
    sysfs_schedule_callback() which makes such removals asynchronous.
    While it works, it's rather cumbersome and inherently breaks
    synchronicity of the operation - the file operation which triggered
    the operation may complete before the removal is finished (or even
    started) and the removal may fail asynchronously.  If a removal
    operation is immmediately followed by another operation which expects
    the specific name to be available (e.g. removal followed by rename
    onto the same name), there's no way to make the latter operation
    reliable.
    
    The thing is there's no inherent reason for this to be asynchrnous.
    All that's necessary to do this synchronous is a dedicated operation
    which drops its own active ref and deactivates self.  This patch
    implements kernfs_remove_self() and its wrappers in sysfs and driver
    core.  kernfs_remove_self() is to be called from one of the file
    operations, drops the active ref and deactivates using
    __kernfs_deactivate_self(), removes the self node, and restores active
    ref to the dead node using __kernfs_reactivate_self() so that the ref
    is balanced afterwards.  __kernfs_remove() is updated so that it takes
    an early exit if the target node is already fully removed so that the
    active ref restored by kernfs_remove_self() after removal doesn't
    confuse the deactivation path.
    
    This makes implementing self-deleting nodes very easy.  The normal
    removal path doesn't even need to be changed to use
    kernfs_remove_self() for the self-deleting node.  The method can
    invoke kernfs_remove_self() on itself before proceeding the normal
    removal path.  kernfs_remove() invoked on the node by the normal
    deletion path will simply be ignored.
    
    This will replace sysfs_schedule_callback().  A subtle feature of
    sysfs_schedule_callback() is that it collapses multiple invocations -
    even if multiple removals are triggered, the removal callback is run
    only once.  An equivalent effect can be achieved by testing the return
    value of kernfs_remove_self() - only the one which gets %true return
    value should proceed with actual deletion.  All other instances of
    kernfs_remove_self() will wait till the enclosing kernfs operation
    which invoked the winning instance of kernfs_remove_self() finishes
    and then return %false.  This trivially makes all users of
    kernfs_remove_self() automatically show correct synchronous behavior
    even when there are multiple concurrent operations - all "echo 1 >
    delete" instances will finish only after the whole operation is
    completed by one of the instances.
    
    v2: For !CONFIG_SYSFS, dummy version kernfs_remove_self() was missing
        and sysfs_remove_file_self() had incorrect return type.  Fix it.
        Reported by kbuild test bot.
    
    v3: Updated to use __kernfs_{de|re}activate_self().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2b567177ef78..9db57afcf81f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -570,6 +570,23 @@ void device_remove_file(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_remove_file);
 
+/**
+ * device_remove_file_self - remove sysfs attribute file from its own method.
+ * @dev: device.
+ * @attr: device attribute descriptor.
+ *
+ * See kernfs_remove_self() for details.
+ */
+bool device_remove_file_self(struct device *dev,
+			     const struct device_attribute *attr)
+{
+	if (dev)
+		return sysfs_remove_file_self(&dev->kobj, &attr->attr);
+	else
+		return false;
+}
+EXPORT_SYMBOL_GPL(device_remove_file_self);
+
 /**
  * device_create_bin_file - create sysfs binary attribute file for device.
  * @dev: device.

commit ecfbf6fd9c03be7dfe3eafc3846641b9d463607b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 12 06:11:02 2013 +0100

    Driver core: Fix device_add_attrs() error code path
    
    If the addition of dev_attr_online fails, device_add_attrs() should
    remove device attribute groups as well as type and class attribute
    groups before returning an error code.  Make that happen.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index aab43fbb8336..2b567177ef78 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -491,11 +491,13 @@ static int device_add_attrs(struct device *dev)
 	if (device_supports_offline(dev) && !dev->offline_disabled) {
 		error = device_create_file(dev, &dev_attr_online);
 		if (error)
-			goto err_remove_type_groups;
+			goto err_remove_dev_groups;
 	}
 
 	return 0;
 
+ err_remove_dev_groups:
+	device_remove_groups(dev, dev->groups);
  err_remove_type_groups:
 	if (type)
 		device_remove_groups(dev, type->groups);

commit bbc780f8bab52fef1784151d3c4982cb1143edd2
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Thu Nov 21 20:15:48 2013 +0100

    driver core: fix device_create() error path
    
    We call put_device() in the error path, which is fine for dev==NULL.
    However, in case kobject_set_name_vargs() fails, we have dev!=NULL but
    device_initialized() wasn't called, yet.
    
    Fix this by splitting device_register() into explicit calls to
    device_add() and an early call to device_initialize().
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 67b180d855b2..aab43fbb8336 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1603,6 +1603,7 @@ device_create_groups_vargs(struct class *class, struct device *parent,
 		goto error;
 	}
 
+	device_initialize(dev);
 	dev->devt = devt;
 	dev->class = class;
 	dev->parent = parent;
@@ -1614,7 +1615,7 @@ device_create_groups_vargs(struct class *class, struct device *parent,
 	if (retval)
 		goto error;
 
-	retval = device_register(dev);
+	retval = device_add(dev);
 	if (retval)
 		goto error;
 

commit 69df75334bf6d68a0a74397c2cc32172f0d7d620
Author: ethan.zhao <ethan.kernel@gmail.com>
Date:   Sun Oct 13 22:12:35 2013 +0800

    drivers/base/core.c: output device renaming messages with dev_dbg().
    
    Replace pr_debug() with dev_dbg().
    
    Signed-off-by: ethan.zhao <ethan.kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bf35c557707f..67b180d855b2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1816,8 +1816,7 @@ int device_rename(struct device *dev, const char *new_name)
 	if (!dev)
 		return -EINVAL;
 
-	pr_debug("device: '%s': %s: renaming to '%s'\n", dev_name(dev),
-		 __func__, new_name);
+	dev_dbg(dev, "renaming to %s\n", new_name);
 
 	old_device_name = kstrdup(dev_name(dev), GFP_KERNEL);
 	if (!old_device_name) {

commit a6b01deda1e79259d2fe98fe68d41e4b7bad2783
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Oct 5 18:19:30 2013 -0700

    driver core: remove dev_bin_attrs from struct class
    
    No in-kernel code is now using this, they have all be converted over to
    using the bin_attrs support in attribute groups, so this field, and the
    code in the driver core that was creating/remove the binary files can be
    removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f67e86687ae2..bf35c557707f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -455,35 +455,6 @@ static ssize_t online_store(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RW(online);
 
-static int device_add_bin_attributes(struct device *dev,
-				     struct bin_attribute *attrs)
-{
-	int error = 0;
-	int i;
-
-	if (attrs) {
-		for (i = 0; attrs[i].attr.name; i++) {
-			error = device_create_bin_file(dev, &attrs[i]);
-			if (error)
-				break;
-		}
-		if (error)
-			while (--i >= 0)
-				device_remove_bin_file(dev, &attrs[i]);
-	}
-	return error;
-}
-
-static void device_remove_bin_attributes(struct device *dev,
-					 struct bin_attribute *attrs)
-{
-	int i;
-
-	if (attrs)
-		for (i = 0; attrs[i].attr.name; i++)
-			device_remove_bin_file(dev, &attrs[i]);
-}
-
 int device_add_groups(struct device *dev, const struct attribute_group **groups)
 {
 	return sysfs_create_groups(&dev->kobj, groups);
@@ -505,15 +476,12 @@ static int device_add_attrs(struct device *dev)
 		error = device_add_groups(dev, class->dev_groups);
 		if (error)
 			return error;
-		error = device_add_bin_attributes(dev, class->dev_bin_attrs);
-		if (error)
-			goto err_remove_class_groups;
 	}
 
 	if (type) {
 		error = device_add_groups(dev, type->groups);
 		if (error)
-			goto err_remove_class_bin_attrs;
+			goto err_remove_class_groups;
 	}
 
 	error = device_add_groups(dev, dev->groups);
@@ -531,9 +499,6 @@ static int device_add_attrs(struct device *dev)
  err_remove_type_groups:
 	if (type)
 		device_remove_groups(dev, type->groups);
- err_remove_class_bin_attrs:
-	if (class)
-		device_remove_bin_attributes(dev, class->dev_bin_attrs);
  err_remove_class_groups:
 	if (class)
 		device_remove_groups(dev, class->dev_groups);
@@ -552,10 +517,8 @@ static void device_remove_attrs(struct device *dev)
 	if (type)
 		device_remove_groups(dev, type->groups);
 
-	if (class) {
-		device_remove_bin_attributes(dev, class->dev_bin_attrs);
+	if (class)
 		device_remove_groups(dev, class->dev_groups);
-	}
 }
 
 static ssize_t dev_show(struct device *dev, struct device_attribute *attr,

commit bcc8edb52f05c1a9e75118d6b3bc04996a750593
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Oct 5 18:25:02 2013 -0700

    driver core: remove dev_attrs from struct class
    
    Now that all in-kernel users of the dev_attrs field are converted to use
    dev_groups, we can safely remove dev_attrs from struct class.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 319c2c594ac6..f67e86687ae2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -455,35 +455,6 @@ static ssize_t online_store(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RW(online);
 
-static int device_add_attributes(struct device *dev,
-				 struct device_attribute *attrs)
-{
-	int error = 0;
-	int i;
-
-	if (attrs) {
-		for (i = 0; attrs[i].attr.name; i++) {
-			error = device_create_file(dev, &attrs[i]);
-			if (error)
-				break;
-		}
-		if (error)
-			while (--i >= 0)
-				device_remove_file(dev, &attrs[i]);
-	}
-	return error;
-}
-
-static void device_remove_attributes(struct device *dev,
-				     struct device_attribute *attrs)
-{
-	int i;
-
-	if (attrs)
-		for (i = 0; attrs[i].attr.name; i++)
-			device_remove_file(dev, &attrs[i]);
-}
-
 static int device_add_bin_attributes(struct device *dev,
 				     struct bin_attribute *attrs)
 {
@@ -534,12 +505,9 @@ static int device_add_attrs(struct device *dev)
 		error = device_add_groups(dev, class->dev_groups);
 		if (error)
 			return error;
-		error = device_add_attributes(dev, class->dev_attrs);
-		if (error)
-			goto err_remove_class_groups;
 		error = device_add_bin_attributes(dev, class->dev_bin_attrs);
 		if (error)
-			goto err_remove_class_attrs;
+			goto err_remove_class_groups;
 	}
 
 	if (type) {
@@ -566,9 +534,6 @@ static int device_add_attrs(struct device *dev)
  err_remove_class_bin_attrs:
 	if (class)
 		device_remove_bin_attributes(dev, class->dev_bin_attrs);
- err_remove_class_attrs:
-	if (class)
-		device_remove_attributes(dev, class->dev_attrs);
  err_remove_class_groups:
 	if (class)
 		device_remove_groups(dev, class->dev_groups);
@@ -588,7 +553,6 @@ static void device_remove_attrs(struct device *dev)
 		device_remove_groups(dev, type->groups);
 
 	if (class) {
-		device_remove_attributes(dev, class->dev_attrs);
 		device_remove_bin_attributes(dev, class->dev_bin_attrs);
 		device_remove_groups(dev, class->dev_groups);
 	}

commit 88502b9c0a5dcc884c0dbfb6ddf964ff5da5d8d3
Merge: e18945b159a1 15c03dd4859a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Sep 29 18:29:23 2013 -0700

    Merge 3.12-rc3 into driver-core-next
    
    We want the driver core and sysfs fixes in here to make merges and
    development easier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4b30ee58ee64c64f59fd876e4afa6ed82caef3a4
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 11 22:29:06 2013 -0400

    sysfs: remove ktype->namespace() invocations in symlink code
    
    There's no reason for sysfs to be calling ktype->namespace().  It is
    backwards, obfuscates what's going on and unnecessarily tangles two
    separate layers.
    
    There are two places where symlink code calls ktype->namespace().
    
    * sysfs_do_create_link_sd() calls it to find out the namespace tag of
      the target directory.  Unless symlinking races with cross-namespace
      renaming, this equals @target_sd->s_ns.
    
    * sysfs_rename_link() uses it to find out the new namespace to rename
      to and the new namespace can be different from the existing one.
      The function is renamed to sysfs_rename_link_ns() with an explicit
      @ns argument and the ktype->namespace() invocation is shifted to the
      device layer.
    
    While this patch replaces ktype->namespace() invocation with the
    recorded result in @target_sd, this shouldn't result in any behvior
    difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c7cfadcf6752..3335000be2dc 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1881,6 +1881,7 @@ EXPORT_SYMBOL_GPL(device_destroy);
  */
 int device_rename(struct device *dev, const char *new_name)
 {
+	struct kobject *kobj = &dev->kobj;
 	char *old_device_name = NULL;
 	int error;
 
@@ -1898,13 +1899,14 @@ int device_rename(struct device *dev, const char *new_name)
 	}
 
 	if (dev->class) {
-		error = sysfs_rename_link(&dev->class->p->subsys.kobj,
-			&dev->kobj, old_device_name, new_name);
+		error = sysfs_rename_link_ns(&dev->class->p->subsys.kobj,
+					     kobj, old_device_name,
+					     new_name, kobject_namespace(kobj));
 		if (error)
 			goto out;
 	}
 
-	error = kobject_rename(&dev->kobj, new_name);
+	error = kobject_rename(kobj, new_name);
 	if (error)
 		goto out;
 

commit f123db8e9d6c84c863cb3c44d17e61995dc984fb
Author: Benson Leung <bleung@chromium.org>
Date:   Tue Sep 24 20:05:11 2013 -0700

    driver core : Fix use after free of dev->parent in device_shutdown
    
    The put_device(dev) at the bottom of the loop of device_shutdown
    may result in the dev being cleaned up. In device_create_release,
    the dev is kfreed.
    
    However, device_shutdown attempts to use the dev pointer again after
    put_device by referring to dev->parent.
    
    Copy the parent pointer instead to avoid this condition.
    
    This bug was found on Chromium OS's chromeos-3.8, which is based on v3.8.11.
    See bug report : https://code.google.com/p/chromium/issues/detail?id=297842
    This can easily be reproduced when shutting down with
    hidraw devices that report battery condition.
    Two examples are the HP Bluetooth Mouse X4000b and the Apple Magic Mouse.
    For example, with the magic mouse :
    The dev in question is "hidraw0"
    dev->parent is "magicmouse"
    
    In the course of the shutdown for this device, the input event cleanup calls
    a put on hidraw0, decrementing its reference count.
    When we finally get to put_device(dev) in device_shutdown, kobject_cleanup
    is called and device_create_release does kfree(dev).
    dev->parent is no longer valid, and we may crash in
    put_device(dev->parent).
    
    This change should be applied on any kernel with this change :
    d1c6c030fcec6f860d9bb6c632a3ebe62e28440b
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Reviewed-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c7cfadcf6752..34abf4d8a45f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2017,7 +2017,7 @@ EXPORT_SYMBOL_GPL(device_move);
  */
 void device_shutdown(void)
 {
-	struct device *dev;
+	struct device *dev, *parent;
 
 	spin_lock(&devices_kset->list_lock);
 	/*
@@ -2034,7 +2034,7 @@ void device_shutdown(void)
 		 * prevent it from being freed because parent's
 		 * lock is to be held
 		 */
-		get_device(dev->parent);
+		parent = get_device(dev->parent);
 		get_device(dev);
 		/*
 		 * Make sure the device is off the kset list, in the
@@ -2044,8 +2044,8 @@ void device_shutdown(void)
 		spin_unlock(&devices_kset->list_lock);
 
 		/* hold lock to avoid race with probe/release */
-		if (dev->parent)
-			device_lock(dev->parent);
+		if (parent)
+			device_lock(parent);
 		device_lock(dev);
 
 		/* Don't allow any more runtime suspends */
@@ -2063,11 +2063,11 @@ void device_shutdown(void)
 		}
 
 		device_unlock(dev);
-		if (dev->parent)
-			device_unlock(dev->parent);
+		if (parent)
+			device_unlock(parent);
 
 		put_device(dev);
-		put_device(dev->parent);
+		put_device(parent);
 
 		spin_lock(&devices_kset->list_lock);
 	}

commit 40031da445fb4d269af9c7c445b2adf674f171e7
Merge: dcaaaeac871f f41b83126cba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 3 15:59:39 2013 -0700

    Merge tag 'pm+acpi-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
    
     1) ACPI-based PCI hotplug (ACPIPHP) subsystem rework and introduction
        of Intel Thunderbolt support on systems that use ACPI for signalling
        Thunderbolt hotplug events.  This also should make ACPIPHP work in
        some cases in which it was known to have problems.  From
        Rafael J Wysocki, Mika Westerberg and Kirill A Shutemov.
    
     2) ACPI core code cleanups and dock station support cleanups from
        Jiang Liu and Rafael J Wysocki.
    
     3) Fixes for locking problems related to ACPI device hotplug from
        Rafael J Wysocki.
    
     4) ACPICA update to version 20130725 includig fixes, cleanups, support
        for more than 256 GPEs per GPE block and a change to make the ACPI
        PM Timer optional (we've seen systems without the PM Timer in the
        field already).  One of the fixes, related to the DeRefOf operator,
        is necessary to prevent some Windows 8 oriented AML from causing
        problems to happen.  From Bob Moore, Lv Zheng, and Jung-uk Kim.
    
     5) Removal of the old and long deprecated /proc/acpi/event interface
        and related driver changes from Thomas Renninger.
    
     6) ACPI and Xen changes to make the reduced hardware sleep work with
        the latter from Ben Guthro.
    
     7) ACPI video driver cleanups and a blacklist of systems that should
        not tell the BIOS that they are compatible with Windows 8 (or ACPI
        backlight and possibly other things will not work on them).  From
        Felipe Contreras.
    
     8) Assorted ACPI fixes and cleanups from Aaron Lu, Hanjun Guo,
        Kuppuswamy Sathyanarayanan, Lan Tianyu, Sachin Kamat, Tang Chen,
        Toshi Kani, and Wei Yongjun.
    
     9) cpufreq ondemand governor target frequency selection change to
        reduce oscillations between min and max frequencies (essentially,
        it causes the governor to choose target frequencies proportional
        to load) from Stratos Karafotis.
    
    10) cpufreq fixes allowing sysfs attributes file permissions to be
        preserved over suspend/resume cycles Srivatsa S Bhat.
    
    11) Removal of Device Tree parsing for CPU device nodes from multiple
        cpufreq drivers that required some changes related to
        of_get_cpu_node() to be made in a few architectures and in the
        driver core.  From Sudeep KarkadaNagesha.
    
    12) cpufreq core fixes and cleanups related to mutual exclusion and
        driver module references from Viresh Kumar, Lukasz Majewski and
        Rafael J Wysocki.
    
    13) Assorted cpufreq fixes and cleanups from Amit Daniel Kachhap,
        Bartlomiej Zolnierkiewicz, Hanjun Guo, Jingoo Han, Joseph Lo,
        Julia Lawall, Li Zhong, Mark Brown, Sascha Hauer, Stephen Boyd,
        Stratos Karafotis, and Viresh Kumar.
    
    14) Fixes to prevent race conditions in coupled cpuidle from happening
        from Colin Cross.
    
    15) cpuidle core fixes and cleanups from Daniel Lezcano and
        Tuukka Tikkanen.
    
    16) Assorted cpuidle fixes and cleanups from Daniel Lezcano,
        Geert Uytterhoeven, Jingoo Han, Julia Lawall, Linus Walleij,
        and Sahara.
    
    17) System sleep tracing changes from Todd E Brandt and Shuah Khan.
    
    18) PNP subsystem conversion to using struct dev_pm_ops for power
        management from Shuah Khan.
    
    * tag 'pm+acpi-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (217 commits)
      cpufreq: Don't use smp_processor_id() in preemptible context
      cpuidle: coupled: fix race condition between pokes and safe state
      cpuidle: coupled: abort idle if pokes are pending
      cpuidle: coupled: disable interrupts after entering safe state
      ACPI / hotplug: Remove containers synchronously
      driver core / ACPI: Avoid device hot remove locking issues
      cpufreq: governor: Fix typos in comments
      cpufreq: governors: Remove duplicate check of target freq in supported range
      cpufreq: Fix timer/workqueue corruption due to double queueing
      ACPI / EC: Add ASUSTEK L4R to quirk list in order to validate ECDT
      ACPI / thermal: Add check of "_TZD" availability and evaluating result
      cpufreq: imx6q: Fix clock enable balance
      ACPI: blacklist win8 OSI for buggy laptops
      cpufreq: tegra: fix the wrong clock name
      cpuidle: Change struct menu_device field types
      cpuidle: Add a comment warning about possible overflow
      cpuidle: Fix variable domains in get_typical_interval()
      cpuidle: Fix menu_device->intervals type
      cpuidle: CodingStyle: Break up multiple assignments on single line
      cpuidle: Check called function parameter in get_typical_interval()
      ...

commit 5e33bc4165f3edd558d9633002465a95230effc1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 28 21:41:01 2013 +0200

    driver core / ACPI: Avoid device hot remove locking issues
    
    device_hotplug_lock is held around the acpi_bus_trim() call in
    acpi_scan_hot_remove() which generally removes devices (it removes
    ACPI device objects at least, but it may also remove "physical"
    device objects through .detach() callbacks of ACPI scan handlers).
    Thus, potentially, device sysfs attributes are removed under that
    lock and to remove those attributes it is necessary to hold the
    s_active references of their directory entries for writing.
    
    On the other hand, the execution of a .show() or .store() callback
    from a sysfs attribute is carried out with that attribute's s_active
    reference held for reading.  Consequently, if any device sysfs
    attribute that may be removed from within acpi_scan_hot_remove()
    through acpi_bus_trim() has a .store() or .show() callback which
    acquires device_hotplug_lock, the execution of that callback may
    deadlock with the removal of the attribute.  [Unfortunately, the
    "online" device attribute of CPUs and memory blocks is one of them.]
    
    To avoid such deadlocks, make all of the sysfs attribute callbacks
    that need to lock device hotplug, for example store_online(), use
    a special function, lock_device_hotplug_sysfs(), to lock device
    hotplug and return the result of that function immediately if it is
    not zero.  This will cause the s_active reference of the directory
    entry in question to be released and the syscall to be restarted
    if device_hotplug_lock cannot be acquired.
    
    [show_online() actually doesn't need to lock device hotplug, but
    it is useful to serialize it with respect to device_offline() and
    device_online() for the same device (in case user space attempts to
    run them concurrently) which can be done with the help of
    device_lock().]
    
    Reported-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reported-and-tested-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Suggested-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8856d74545d9..ac419a15fcd4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -49,6 +49,28 @@ static struct kobject *dev_kobj;
 struct kobject *sysfs_dev_char_kobj;
 struct kobject *sysfs_dev_block_kobj;
 
+static DEFINE_MUTEX(device_hotplug_lock);
+
+void lock_device_hotplug(void)
+{
+	mutex_lock(&device_hotplug_lock);
+}
+
+void unlock_device_hotplug(void)
+{
+	mutex_unlock(&device_hotplug_lock);
+}
+
+int lock_device_hotplug_sysfs(void)
+{
+	if (mutex_trylock(&device_hotplug_lock))
+		return 0;
+
+	/* Avoid busy looping (5 ms of sleep should do). */
+	msleep(5);
+	return restart_syscall();
+}
+
 #ifdef CONFIG_BLOCK
 static inline int device_is_not_partition(struct device *dev)
 {
@@ -408,9 +430,9 @@ static ssize_t show_online(struct device *dev, struct device_attribute *attr,
 {
 	bool val;
 
-	lock_device_hotplug();
+	device_lock(dev);
 	val = !dev->offline;
-	unlock_device_hotplug();
+	device_unlock(dev);
 	return sprintf(buf, "%u\n", val);
 }
 
@@ -424,7 +446,10 @@ static ssize_t store_online(struct device *dev, struct device_attribute *attr,
 	if (ret < 0)
 		return ret;
 
-	lock_device_hotplug();
+	ret = lock_device_hotplug_sysfs();
+	if (ret)
+		return ret;
+
 	ret = val ? device_online(dev) : device_offline(dev);
 	unlock_device_hotplug();
 	return ret < 0 ? ret : count;
@@ -1479,18 +1504,6 @@ EXPORT_SYMBOL_GPL(put_device);
 EXPORT_SYMBOL_GPL(device_create_file);
 EXPORT_SYMBOL_GPL(device_remove_file);
 
-static DEFINE_MUTEX(device_hotplug_lock);
-
-void lock_device_hotplug(void)
-{
-	mutex_lock(&device_hotplug_lock);
-}
-
-void unlock_device_hotplug(void)
-{
-	mutex_unlock(&device_hotplug_lock);
-}
-
 static int device_check_offline(struct device *dev, void *not_used)
 {
 	int ret;

commit 63967685605b3c73c078807cd498c4fbf62847c1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 27 10:24:15 2013 -0700

    driver core: add #include <linux/sysfs.h> to core files.
    
    This is needed to fix the build on sh systems.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 921b94184dcc..c7b0925f627a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -26,6 +26,7 @@
 #include <linux/async.h>
 #include <linux/pm_runtime.h>
 #include <linux/netdevice.h>
+#include <linux/sysfs.h>
 
 #include "base.h"
 #include "power/power.h"

commit c5e064a6981603de65c61c4989856e984c7ad66d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 23 17:07:26 2013 -0700

    driver core: core: use DEVICE_ATTR_RO
    
    Use DEVICE_ATTR_RO() instead of a "raw" __ATTR macro, making it easier
    to audit exactly what is going on with the sysfs files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ae1acdf21bd3..921b94184dcc 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -345,7 +345,7 @@ static const struct kset_uevent_ops device_uevent_ops = {
 	.uevent =	dev_uevent,
 };
 
-static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
+static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	struct kobject *top_kobj;
@@ -388,7 +388,7 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
+static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
 	enum kobject_action action;
@@ -399,11 +399,9 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 		dev_err(dev, "uevent: unknown action-string\n");
 	return count;
 }
+static DEVICE_ATTR_RW(uevent);
 
-static struct device_attribute uevent_attr =
-	__ATTR(uevent, S_IRUGO | S_IWUSR, show_uevent, store_uevent);
-
-static ssize_t show_online(struct device *dev, struct device_attribute *attr,
+static ssize_t online_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	bool val;
@@ -414,7 +412,7 @@ static ssize_t show_online(struct device *dev, struct device_attribute *attr,
 	return sprintf(buf, "%u\n", val);
 }
 
-static ssize_t store_online(struct device *dev, struct device_attribute *attr,
+static ssize_t online_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
 	bool val;
@@ -429,9 +427,7 @@ static ssize_t store_online(struct device *dev, struct device_attribute *attr,
 	unlock_device_hotplug();
 	return ret < 0 ? ret : count;
 }
-
-static struct device_attribute online_attr =
-	__ATTR(online, S_IRUGO | S_IWUSR, show_online, store_online);
+static DEVICE_ATTR_RW(online);
 
 static int device_add_attributes(struct device *dev,
 				 struct device_attribute *attrs)
@@ -531,7 +527,7 @@ static int device_add_attrs(struct device *dev)
 		goto err_remove_type_groups;
 
 	if (device_supports_offline(dev) && !dev->offline_disabled) {
-		error = device_create_file(dev, &online_attr);
+		error = device_create_file(dev, &dev_attr_online);
 		if (error)
 			goto err_remove_type_groups;
 	}
@@ -559,7 +555,7 @@ static void device_remove_attrs(struct device *dev)
 	struct class *class = dev->class;
 	const struct device_type *type = dev->type;
 
-	device_remove_file(dev, &online_attr);
+	device_remove_file(dev, &dev_attr_online);
 	device_remove_groups(dev, dev->groups);
 
 	if (type)
@@ -572,15 +568,12 @@ static void device_remove_attrs(struct device *dev)
 	}
 }
 
-
-static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
+static ssize_t dev_show(struct device *dev, struct device_attribute *attr,
 			char *buf)
 {
 	return print_dev_t(buf, dev->devt);
 }
-
-static struct device_attribute devt_attr =
-	__ATTR(dev, S_IRUGO, show_dev, NULL);
+static DEVICE_ATTR_RO(dev);
 
 /* /sys/devices/ */
 struct kset *devices_kset;
@@ -1084,12 +1077,12 @@ int device_add(struct device *dev)
 	if (platform_notify)
 		platform_notify(dev);
 
-	error = device_create_file(dev, &uevent_attr);
+	error = device_create_file(dev, &dev_attr_uevent);
 	if (error)
 		goto attrError;
 
 	if (MAJOR(dev->devt)) {
-		error = device_create_file(dev, &devt_attr);
+		error = device_create_file(dev, &dev_attr_dev);
 		if (error)
 			goto ueventattrError;
 
@@ -1156,9 +1149,9 @@ int device_add(struct device *dev)
 		device_remove_sys_dev_entry(dev);
  devtattrError:
 	if (MAJOR(dev->devt))
-		device_remove_file(dev, &devt_attr);
+		device_remove_file(dev, &dev_attr_dev);
  ueventattrError:
-	device_remove_file(dev, &uevent_attr);
+	device_remove_file(dev, &dev_attr_uevent);
  attrError:
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
@@ -1254,7 +1247,7 @@ void device_del(struct device *dev)
 	if (MAJOR(dev->devt)) {
 		devtmpfs_delete_node(dev);
 		device_remove_sys_dev_entry(dev);
-		device_remove_file(dev, &devt_attr);
+		device_remove_file(dev, &dev_attr_dev);
 	}
 	if (dev->class) {
 		device_remove_class_symlinks(dev);
@@ -1269,7 +1262,7 @@ void device_del(struct device *dev)
 		klist_del(&dev->knode_class);
 		mutex_unlock(&dev->class->p->mutex);
 	}
-	device_remove_file(dev, &uevent_attr);
+	device_remove_file(dev, &dev_attr_uevent);
 	device_remove_attrs(dev);
 	bus_remove_device(dev);
 	device_pm_remove(dev);

commit 3e1026b3fa2f61d33ce6a9e42a22398cc4ab8e58
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 22 10:25:34 2013 -0700

    sysfs.h: remove attr_name() macro
    
    Gotta love a macro that doesn't reduce the typing you have to do.
    
    Also, only the driver core, and one network driver uses this.  The
    driver core functions will be going away soon, and I'll convert the
    network driver soon to not need this as well, so delete it for now
    before anyone else gets some bright ideas and wants to use it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d743dcee1e77..ae1acdf21bd3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -440,7 +440,7 @@ static int device_add_attributes(struct device *dev,
 	int i;
 
 	if (attrs) {
-		for (i = 0; attr_name(attrs[i]); i++) {
+		for (i = 0; attrs[i].attr.name; i++) {
 			error = device_create_file(dev, &attrs[i]);
 			if (error)
 				break;
@@ -458,7 +458,7 @@ static void device_remove_attributes(struct device *dev,
 	int i;
 
 	if (attrs)
-		for (i = 0; attr_name(attrs[i]); i++)
+		for (i = 0; attrs[i].attr.name; i++)
 			device_remove_file(dev, &attrs[i]);
 }
 
@@ -469,7 +469,7 @@ static int device_add_bin_attributes(struct device *dev,
 	int i;
 
 	if (attrs) {
-		for (i = 0; attr_name(attrs[i]); i++) {
+		for (i = 0; attrs[i].attr.name; i++) {
 			error = device_create_bin_file(dev, &attrs[i]);
 			if (error)
 				break;
@@ -487,7 +487,7 @@ static void device_remove_bin_attributes(struct device *dev,
 	int i;
 
 	if (attrs)
-		for (i = 0; attr_name(attrs[i]); i++)
+		for (i = 0; attrs[i].attr.name; i++)
 			device_remove_bin_file(dev, &attrs[i]);
 }
 

commit 3e9b2bae8369661070622d05570cbcdfa01770e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 13:47:50 2013 -0700

    sysfs: add sysfs_create/remove_groups()
    
    These functions are being open-coded in 3 different places in the driver
    core, and other driver subsystems will want to start doing this as well,
    so move it to the sysfs core to keep it all in one place, where we know
    it is written properly.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index af646afa5b7e..d743dcee1e77 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -493,31 +493,13 @@ static void device_remove_bin_attributes(struct device *dev,
 
 int device_add_groups(struct device *dev, const struct attribute_group **groups)
 {
-	int error = 0;
-	int i;
-
-	if (groups) {
-		for (i = 0; groups[i]; i++) {
-			error = sysfs_create_group(&dev->kobj, groups[i]);
-			if (error) {
-				while (--i >= 0)
-					sysfs_remove_group(&dev->kobj,
-							   groups[i]);
-				break;
-			}
-		}
-	}
-	return error;
+	return sysfs_create_groups(&dev->kobj, groups);
 }
 
 void device_remove_groups(struct device *dev,
 			  const struct attribute_group **groups)
 {
-	int i;
-
-	if (groups)
-		for (i = 0; groups[i]; i++)
-			sysfs_remove_group(&dev->kobj, groups[i]);
+	sysfs_remove_groups(&dev->kobj, groups);
 }
 
 static int device_add_attrs(struct device *dev)

commit 3454bf96041e8c4cecc7d85b87c35056050a15b5
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Sat Aug 17 20:42:24 2013 +0800

    drivers / base: Fix sysfs_deprecated_setup() __init attribute location
    
    __init belongs after the return type on functions, not before it.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 09a99d609644..af646afa5b7e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -36,7 +36,7 @@ long sysfs_deprecated = 1;
 #else
 long sysfs_deprecated = 0;
 #endif
-static __init int sysfs_deprecated_setup(char *arg)
+static int __init sysfs_deprecated_setup(char *arg)
 {
 	return kstrtol(arg, 10, &sysfs_deprecated);
 }

commit fa6fdb33b486a8afc5439c504da8d581e142c77d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 8 15:22:55 2013 -0700

    driver core: bus_type: add dev_groups
    
    attribute groups are much more flexible than just a list of attributes,
    due to their support for visibility of the attributes, and binary
    attributes. Add dev_groups to struct bus_type which should be used
    instead of dev_attrs.
    
    dev_attrs will be removed from the structure soon.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e51c78782933..09a99d609644 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -491,8 +491,7 @@ static void device_remove_bin_attributes(struct device *dev,
 			device_remove_bin_file(dev, &attrs[i]);
 }
 
-static int device_add_groups(struct device *dev,
-			     const struct attribute_group **groups)
+int device_add_groups(struct device *dev, const struct attribute_group **groups)
 {
 	int error = 0;
 	int i;
@@ -511,8 +510,8 @@ static int device_add_groups(struct device *dev,
 	return error;
 }
 
-static void device_remove_groups(struct device *dev,
-				 const struct attribute_group **groups)
+void device_remove_groups(struct device *dev,
+			  const struct attribute_group **groups)
 {
 	int i;
 

commit 34da5e6770ac06df770a0355b417155e6e84e263
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Jul 26 13:10:22 2013 +0900

    driver core: replace strict_strto*() with kstrto*()
    
    The usage of strict_strto*() is not preferred, because
    strict_strto*() is obsolete. Thus, kstrto*() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4b9b0d7f6022..e51c78782933 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -38,7 +38,7 @@ long sysfs_deprecated = 0;
 #endif
 static __init int sysfs_deprecated_setup(char *arg)
 {
-	return strict_strtol(arg, 10, &sysfs_deprecated);
+	return kstrtol(arg, 10, &sysfs_deprecated);
 }
 early_param("sysfs.deprecated", sysfs_deprecated_setup);
 #endif

commit 86df268705696ce2286410f1493e294e889bdce6
Author: David Graham White <dgwhite11@gmail.com>
Date:   Sun Jul 21 20:41:14 2013 -0400

    drivers:base:core: Moved sym export macros to respective functions
    
    Moved 11 calls to the EXPORT_SYMBOL_GPL beneath their respective functions per
    checkpatch.pl warnings.
    
    Signed-off-by: David Graham White <dgwhite11@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8856d74545d9..4b9b0d7f6022 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -626,6 +626,7 @@ int device_create_file(struct device *dev,
 
 	return error;
 }
+EXPORT_SYMBOL_GPL(device_create_file);
 
 /**
  * device_remove_file - remove sysfs attribute file.
@@ -638,6 +639,7 @@ void device_remove_file(struct device *dev,
 	if (dev)
 		sysfs_remove_file(&dev->kobj, &attr->attr);
 }
+EXPORT_SYMBOL_GPL(device_remove_file);
 
 /**
  * device_create_bin_file - create sysfs binary attribute file for device.
@@ -748,6 +750,7 @@ void device_initialize(struct device *dev)
 	device_pm_init(dev);
 	set_dev_node(dev, -1);
 }
+EXPORT_SYMBOL_GPL(device_initialize);
 
 struct kobject *virtual_device_parent(struct device *dev)
 {
@@ -1187,6 +1190,7 @@ int device_add(struct device *dev)
 	dev->p = NULL;
 	goto done;
 }
+EXPORT_SYMBOL_GPL(device_add);
 
 /**
  * device_register - register a device with the system.
@@ -1211,6 +1215,7 @@ int device_register(struct device *dev)
 	device_initialize(dev);
 	return device_add(dev);
 }
+EXPORT_SYMBOL_GPL(device_register);
 
 /**
  * get_device - increment reference count for device.
@@ -1224,6 +1229,7 @@ struct device *get_device(struct device *dev)
 {
 	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
 }
+EXPORT_SYMBOL_GPL(get_device);
 
 /**
  * put_device - decrement reference count.
@@ -1235,6 +1241,7 @@ void put_device(struct device *dev)
 	if (dev)
 		kobject_put(&dev->kobj);
 }
+EXPORT_SYMBOL_GPL(put_device);
 
 /**
  * device_del - delete device from system.
@@ -1297,6 +1304,7 @@ void device_del(struct device *dev)
 	kobject_del(&dev->kobj);
 	put_device(parent);
 }
+EXPORT_SYMBOL_GPL(device_del);
 
 /**
  * device_unregister - unregister device from system.
@@ -1315,6 +1323,7 @@ void device_unregister(struct device *dev)
 	device_del(dev);
 	put_device(dev);
 }
+EXPORT_SYMBOL_GPL(device_unregister);
 
 static struct device *next_device(struct klist_iter *i)
 {
@@ -1403,6 +1412,7 @@ int device_for_each_child(struct device *parent, void *data,
 	klist_iter_exit(&i);
 	return error;
 }
+EXPORT_SYMBOL_GPL(device_for_each_child);
 
 /**
  * device_find_child - device iterator for locating a particular device.
@@ -1437,6 +1447,7 @@ struct device *device_find_child(struct device *parent, void *data,
 	klist_iter_exit(&i);
 	return child;
 }
+EXPORT_SYMBOL_GPL(device_find_child);
 
 int __init devices_init(void)
 {
@@ -1464,21 +1475,6 @@ int __init devices_init(void)
 	return -ENOMEM;
 }
 
-EXPORT_SYMBOL_GPL(device_for_each_child);
-EXPORT_SYMBOL_GPL(device_find_child);
-
-EXPORT_SYMBOL_GPL(device_initialize);
-EXPORT_SYMBOL_GPL(device_add);
-EXPORT_SYMBOL_GPL(device_register);
-
-EXPORT_SYMBOL_GPL(device_del);
-EXPORT_SYMBOL_GPL(device_unregister);
-EXPORT_SYMBOL_GPL(get_device);
-EXPORT_SYMBOL_GPL(put_device);
-
-EXPORT_SYMBOL_GPL(device_create_file);
-EXPORT_SYMBOL_GPL(device_remove_file);
-
 static DEFINE_MUTEX(device_hotplug_lock);
 
 void lock_device_hotplug(void)

commit d05a6f96c76062b5f25858ac02cf677602076f7e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Jul 14 16:05:58 2013 -0700

    driver core: add default groups to struct class
    
    We should be using groups, not attribute lists, for classes to allow
    subdirectories, and soon, binary files.  Groups are just more flexible
    overall, so add them.
    
    The dev_attrs list will go away after all in-kernel users are converted
    to use dev_groups.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a8aae1823f73..8856d74545d9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -528,9 +528,12 @@ static int device_add_attrs(struct device *dev)
 	int error;
 
 	if (class) {
-		error = device_add_attributes(dev, class->dev_attrs);
+		error = device_add_groups(dev, class->dev_groups);
 		if (error)
 			return error;
+		error = device_add_attributes(dev, class->dev_attrs);
+		if (error)
+			goto err_remove_class_groups;
 		error = device_add_bin_attributes(dev, class->dev_bin_attrs);
 		if (error)
 			goto err_remove_class_attrs;
@@ -563,6 +566,9 @@ static int device_add_attrs(struct device *dev)
  err_remove_class_attrs:
 	if (class)
 		device_remove_attributes(dev, class->dev_attrs);
+ err_remove_class_groups:
+	if (class)
+		device_remove_groups(dev, class->dev_groups);
 
 	return error;
 }
@@ -581,6 +587,7 @@ static void device_remove_attrs(struct device *dev)
 	if (class) {
 		device_remove_attributes(dev, class->dev_attrs);
 		device_remove_bin_attributes(dev, class->dev_bin_attrs);
+		device_remove_groups(dev, class->dev_groups);
 	}
 }
 

commit 39ef311204941ddd01ea2950d6220c8ccc710d15
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Jul 14 16:05:57 2013 -0700

    driver core: Introduce device_create_groups
    
    device_create_groups lets callers create devices as well as associated
    sysfs attributes with a single call. This avoids race conditions seen
    if sysfs attributes on new devices are created later.
    
    [fixed up comment block placement and add checks for printk buffer
    formats - gregkh]
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index dc3ea237f086..a8aae1823f73 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1667,34 +1667,11 @@ static void device_create_release(struct device *dev)
 	kfree(dev);
 }
 
-/**
- * device_create_vargs - creates a device and registers it with sysfs
- * @class: pointer to the struct class that this device should be registered to
- * @parent: pointer to the parent struct device of this new device, if any
- * @devt: the dev_t for the char device to be added
- * @drvdata: the data to be added to the device for callbacks
- * @fmt: string for the device's name
- * @args: va_list for the device's name
- *
- * This function can be used by char device classes.  A struct device
- * will be created in sysfs, registered to the specified class.
- *
- * A "dev" file will be created, showing the dev_t for the device, if
- * the dev_t is not 0,0.
- * If a pointer to a parent struct device is passed in, the newly created
- * struct device will be a child of that device in sysfs.
- * The pointer to the struct device will be returned from the call.
- * Any further sysfs files that might be required can be created using this
- * pointer.
- *
- * Returns &struct device pointer on success, or ERR_PTR() on error.
- *
- * Note: the struct class passed to this function must have previously
- * been created with a call to class_create().
- */
-struct device *device_create_vargs(struct class *class, struct device *parent,
-				   dev_t devt, void *drvdata, const char *fmt,
-				   va_list args)
+static struct device *
+device_create_groups_vargs(struct class *class, struct device *parent,
+			   dev_t devt, void *drvdata,
+			   const struct attribute_group **groups,
+			   const char *fmt, va_list args)
 {
 	struct device *dev = NULL;
 	int retval = -ENODEV;
@@ -1711,6 +1688,7 @@ struct device *device_create_vargs(struct class *class, struct device *parent,
 	dev->devt = devt;
 	dev->class = class;
 	dev->parent = parent;
+	dev->groups = groups;
 	dev->release = device_create_release;
 	dev_set_drvdata(dev, drvdata);
 
@@ -1728,6 +1706,39 @@ struct device *device_create_vargs(struct class *class, struct device *parent,
 	put_device(dev);
 	return ERR_PTR(retval);
 }
+
+/**
+ * device_create_vargs - creates a device and registers it with sysfs
+ * @class: pointer to the struct class that this device should be registered to
+ * @parent: pointer to the parent struct device of this new device, if any
+ * @devt: the dev_t for the char device to be added
+ * @drvdata: the data to be added to the device for callbacks
+ * @fmt: string for the device's name
+ * @args: va_list for the device's name
+ *
+ * This function can be used by char device classes.  A struct device
+ * will be created in sysfs, registered to the specified class.
+ *
+ * A "dev" file will be created, showing the dev_t for the device, if
+ * the dev_t is not 0,0.
+ * If a pointer to a parent struct device is passed in, the newly created
+ * struct device will be a child of that device in sysfs.
+ * The pointer to the struct device will be returned from the call.
+ * Any further sysfs files that might be required can be created using this
+ * pointer.
+ *
+ * Returns &struct device pointer on success, or ERR_PTR() on error.
+ *
+ * Note: the struct class passed to this function must have previously
+ * been created with a call to class_create().
+ */
+struct device *device_create_vargs(struct class *class, struct device *parent,
+				   dev_t devt, void *drvdata, const char *fmt,
+				   va_list args)
+{
+	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
+					  fmt, args);
+}
 EXPORT_SYMBOL_GPL(device_create_vargs);
 
 /**
@@ -1767,6 +1778,50 @@ struct device *device_create(struct class *class, struct device *parent,
 }
 EXPORT_SYMBOL_GPL(device_create);
 
+/**
+ * device_create_with_groups - creates a device and registers it with sysfs
+ * @class: pointer to the struct class that this device should be registered to
+ * @parent: pointer to the parent struct device of this new device, if any
+ * @devt: the dev_t for the char device to be added
+ * @drvdata: the data to be added to the device for callbacks
+ * @groups: NULL-terminated list of attribute groups to be created
+ * @fmt: string for the device's name
+ *
+ * This function can be used by char device classes.  A struct device
+ * will be created in sysfs, registered to the specified class.
+ * Additional attributes specified in the groups parameter will also
+ * be created automatically.
+ *
+ * A "dev" file will be created, showing the dev_t for the device, if
+ * the dev_t is not 0,0.
+ * If a pointer to a parent struct device is passed in, the newly created
+ * struct device will be a child of that device in sysfs.
+ * The pointer to the struct device will be returned from the call.
+ * Any further sysfs files that might be required can be created using this
+ * pointer.
+ *
+ * Returns &struct device pointer on success, or ERR_PTR() on error.
+ *
+ * Note: the struct class passed to this function must have previously
+ * been created with a call to class_create().
+ */
+struct device *device_create_with_groups(struct class *class,
+					 struct device *parent, dev_t devt,
+					 void *drvdata,
+					 const struct attribute_group **groups,
+					 const char *fmt, ...)
+{
+	va_list vargs;
+	struct device *dev;
+
+	va_start(vargs, fmt);
+	dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,
+					 fmt, vargs);
+	va_end(vargs);
+	return dev;
+}
+EXPORT_SYMBOL_GPL(device_create_with_groups);
+
 static int __match_devt(struct device *dev, const void *data)
 {
 	const dev_t *devt = data;

commit f991fae5c6d42dfc5029150b05a78cf3f6c18cc9
Merge: d4141531f63a 2c843bd92ec2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 14:35:40 2013 -0700

    Merge tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "This time the total number of ACPI commits is slightly greater than
      the number of cpufreq commits, but Viresh Kumar (who works on cpufreq)
      remains the most active patch submitter.
    
      To me, the most significant change is the addition of offline/online
      device operations to the driver core (with the Greg's blessing) and
      the related modifications of the ACPI core hotplug code.  Next are the
      freezer updates from Colin Cross that should make the freezing of
      tasks a bit less heavy weight.
    
      We also have a couple of regression fixes, a number of fixes for
      issues that have not been identified as regressions, two new drivers
      and a bunch of cleanups all over.
    
      Highlights:
    
       - Hotplug changes to support graceful hot-removal failures.
    
         It sometimes is necessary to fail device hot-removal operations
         gracefully if they cannot be carried out completely.  For example,
         if memory from a memory module being hot-removed has been allocated
         for the kernel's own use and cannot be moved elsewhere, it's
         desirable to fail the hot-removal operation in a graceful way
         rather than to crash the kernel, but currenty a success or a kernel
         crash are the only possible outcomes of an attempted memory
         hot-removal.  Needless to say, that is not a very attractive
         alternative and it had to be addressed.
    
         However, in order to make it work for memory, I first had to make
         it work for CPUs and for this purpose I needed to modify the ACPI
         processor driver.  It's been split into two parts, a resident one
         handling the low-level initialization/cleanup and a modular one
         playing the actual driver's role (but it binds to the CPU system
         device objects rather than to the ACPI device objects representing
         processors).  That's been sort of like a live brain surgery on a
         patient who's riding a bike.
    
         So this is a little scary, but since we found and fixed a couple of
         regressions it caused to happen during the early linux-next testing
         (a month ago), nobody has complained.
    
         As a bonus we remove some duplicated ACPI hotplug code, because the
         ACPI-based CPU hotplug is now going to use the common ACPI hotplug
         code.
    
       - Lighter weight freezing of tasks.
    
         These changes from Colin Cross and Mandeep Singh Baines are
         targeted at making the freezing of tasks a bit less heavy weight
         operation.  They reduce the number of tasks woken up every time
         during the freezing, by using the observation that the freezer
         simply doesn't need to wake up some of them and wait for them all
         to call refrigerator().  The time needed for the freezer to decide
         to report a failure is reduced too.
    
         Also reintroduced is the check causing a lockdep warining to
         trigger when try_to_freeze() is called with locks held (which is
         generally unsafe and shouldn't happen).
    
       - cpufreq updates
    
         First off, a commit from Srivatsa S Bhat fixes a resume regression
         introduced during the 3.10 cycle causing some cpufreq sysfs
         attributes to return wrong values to user space after resume.  The
         fix is kind of fresh, but also it's pretty obvious once Srivatsa
         has identified the root cause.
    
         Second, we have a new freqdomain_cpus sysfs attribute for the
         acpi-cpufreq driver to provide information previously available via
         related_cpus.  From Lan Tianyu.
    
         Finally, we fix a number of issues, mostly related to the
         CPUFREQ_POSTCHANGE notifier and cpufreq Kconfig options and clean
         up some code.  The majority of changes from Viresh Kumar with bits
         from Jacob Shin, Heiko Stübner, Xiaoguang Chen, Ezequiel Garcia,
         Arnd Bergmann, and Tang Yuantian.
    
       - ACPICA update
    
         A usual bunch of updates from the ACPICA upstream.
    
         During the 3.4 cycle we introduced support for ACPI 5 extended
         sleep registers, but they are only supposed to be used if the
         HW-reduced mode bit is set in the FADT flags and the code attempted
         to use them without checking that bit.  That caused suspend/resume
         regressions to happen on some systems.  Fix from Lv Zheng causes
         those registers to be used only if the HW-reduced mode bit is set.
    
         Apart from this some other ACPICA bugs are fixed and code cleanups
         are made by Bob Moore, Tomasz Nowicki, Lv Zheng, Chao Guan, and
         Zhang Rui.
    
       - cpuidle updates
    
         New driver for Xilinx Zynq processors is added by Michal Simek.
    
         Multidriver support simplification, addition of some missing
         kerneldoc comments and Kconfig-related fixes come from Daniel
         Lezcano.
    
       - ACPI power management updates
    
         Changes to make suspend/resume work correctly in Xen guests from
         Konrad Rzeszutek Wilk, sparse warning fix from Fengguang Wu and
         cleanups and fixes of the ACPI device power state selection
         routine.
    
       - ACPI documentation updates
    
         Some previously missing pieces of ACPI documentation are added by
         Lv Zheng and Aaron Lu (hopefully, that will help people to
         uderstand how the ACPI subsystem works) and one outdated doc is
         updated by Hanjun Guo.
    
       - Assorted ACPI updates
    
         We finally nailed down the IA-64 issue that was the reason for
         reverting commit 9f29ab11ddbf ("ACPI / scan: do not match drivers
         against objects having scan handlers"), so we can fix it and move
         the ACPI scan handler check added to the ACPI video driver back to
         the core.
    
         A mechanism for adding CMOS RTC address space handlers is
         introduced by Lan Tianyu to allow some EC-related breakage to be
         fixed on some systems.
    
         A spec-compliant implementation of acpi_os_get_timer() is added by
         Mika Westerberg.
    
         The evaluation of _STA is added to do_acpi_find_child() to avoid
         situations in which a pointer to a disabled device object is
         returned instead of an enabled one with the same _ADR value.  From
         Jeff Wu.
    
         Intel BayTrail PCH (Platform Controller Hub) support is added to
         the ACPI driver for Intel Low-Power Subsystems (LPSS) and that
         driver is modified to work around a couple of known BIOS issues.
         Changes from Mika Westerberg and Heikki Krogerus.
    
         The EC driver is fixed by Vasiliy Kulikov to use get_user() and
         put_user() instead of dereferencing user space pointers blindly.
    
         Code cleanups are made by Bjorn Helgaas, Nicholas Mazzuca and Toshi
         Kani.
    
       - Assorted power management updates
    
         The "runtime idle" helper routine is changed to take the return
         values of the callbacks executed by it into account and to call
         rpm_suspend() if they return 0, which allows us to reduce the
         overall code bloat a bit (by dropping some code that's not
         necessary any more after that modification).
    
         The runtime PM documentation is updated by Alan Stern (to reflect
         the "runtime idle" behavior change).
    
         New trace points for PM QoS are added by Sahara
         (<keun-o.park@windriver.com>).
    
         PM QoS documentation is updated by Lan Tianyu.
    
         Code cleanups are made and minor issues are addressed by Bernie
         Thompson, Bjorn Helgaas, Julius Werner, and Shuah Khan.
    
       - devfreq updates
    
         New driver for the Exynos5-bus device from Abhilash Kesavan.
    
         Minor cleanups, fixes and MAINTAINERS update from MyungJoo Ham,
         Abhilash Kesavan, Paul Bolle, Rajagopal Venkat, and Wei Yongjun.
    
       - OMAP power management updates
    
         Adaptive Voltage Scaling (AVS) SmartReflex voltage control driver
         updates from Andrii Tseglytskyi and Nishanth Menon."
    
    * tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (162 commits)
      cpufreq: Fix cpufreq regression after suspend/resume
      ACPI / PM: Fix possible NULL pointer deref in acpi_pm_device_sleep_state()
      PM / Sleep: Warn about system time after resume with pm_trace
      cpufreq: don't leave stale policy pointer in cdbs->cur_policy
      acpi-cpufreq: Add new sysfs attribute freqdomain_cpus
      cpufreq: make sure frequency transitions are serialized
      ACPI: implement acpi_os_get_timer() according the spec
      ACPI / EC: Add HP Folio 13 to ec_dmi_table in order to skip DSDT scan
      ACPI: Add CMOS RTC Operation Region handler support
      ACPI / processor: Drop unused variable from processor_perflib.c
      cpufreq: tegra: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: s3c64xx: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: omap: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: imx6q: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: exynos: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: dbx500: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: davinci: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: arm-big-little: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: powernow-k8: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: pcc: call CPUFREQ_POSTCHANGE notfier in error cases
      ...

commit a204dbc61b7f4cb1a7e2cb3ad057b135164782da
Merge: 45e00374db94 08f502c1c343
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 12:58:05 2013 +0200

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI: Do not use CONFIG_ACPI_HOTPLUG_MEMORY_MODULE
      ACPI / cpufreq: Add ACPI processor device IDs to acpi-cpufreq
      Memory hotplug: Move alternative function definitions to header
      ACPI / processor: Fix potential NULL pointer dereference in acpi_processor_add()
      Memory hotplug / ACPI: Simplify memory removal
      ACPI / scan: Add second pass of companion offlining to hot-remove code
      Driver core / MM: Drop offline_memory_block()
      ACPI / processor: Pass processor object handle to acpi_bind_one()
      ACPI: Drop removal_type field from struct acpi_device
      Driver core / memory: Simplify __memory_block_change_state()
      ACPI / processor: Initialize per_cpu(processors, pr->id) properly
      CPU: Fix sysfs cpu/online of offlined CPUs
      Driver core: Introduce offline/online callbacks for memory blocks
      ACPI / memhotplug: Bind removable memory blocks to ACPI device nodes
      ACPI / processor: Use common hotplug infrastructure
      ACPI / hotplug: Use device offline/online for graceful hot-removal
      Driver core: Use generic offline/online for CPU offline/online
      Driver core: Add offline/online device operations

commit f8878dcb84f7eb85b11c6be9d7d2581a88675615
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Sat Jun 1 20:17:34 2013 -0400

    Documentation: Tidy up some drivers/base/core.c kerneldoc content.
    
    Standardize the indentation, and switch the order of a couple
    kerneldoc entries to match the parameter order. No functional change.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0dbe02b3ce9d..6fdc53d46fa0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -193,12 +193,12 @@ ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
 EXPORT_SYMBOL_GPL(device_show_bool);
 
 /**
- *	device_release - free device structure.
- *	@kobj:	device's kobject.
+ * device_release - free device structure.
+ * @kobj: device's kobject.
  *
- *	This is called once the reference count for the object
- *	reaches 0. We forward the call to the device's release
- *	method, which should handle actually freeing the structure.
+ * This is called once the reference count for the object
+ * reaches 0. We forward the call to the device's release
+ * method, which should handle actually freeing the structure.
  */
 static void device_release(struct kobject *kobj)
 {
@@ -1334,8 +1334,8 @@ const char *device_get_devnode(struct device *dev,
 /**
  * device_for_each_child - device child iterator.
  * @parent: parent struct device.
- * @data: data for the callback.
  * @fn: function to be called for each device.
+ * @data: data for the callback.
  *
  * Iterate over @parent's child devices, and call @fn for each,
  * passing it @data.
@@ -1363,8 +1363,8 @@ int device_for_each_child(struct device *parent, void *data,
 /**
  * device_find_child - device iterator for locating a particular device.
  * @parent: parent struct device
- * @data: Data to pass to match function
  * @match: Callback function to check device
+ * @data: Data to pass to match function
  *
  * This is similar to the device_for_each_child() function above, but it
  * returns a reference to a device that is 'found' for later use, as

commit 4993632218e2202d4f110c8e83ae819ca26e6845
Merge: 1c4e2d70afb1 e4aa937ec75d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 27 10:42:53 2013 +0900

    Merge 3.10-rc3 into driver-core-next
    
    We want the changes here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a4e2400a63f0e4fb6af5083a24d80b6fa4c41ccd
Author: Federico Vaga <federico.vaga@gmail.com>
Date:   Mon Apr 15 11:18:11 2013 +0200

    base/core.c: improve comment of the function device_find_child()
    
    Signed-off-by: Federico Vaga <federico.vaga@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 016312437577..3c8512f7b64c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1372,6 +1372,8 @@ int device_for_each_child(struct device *parent, void *data,
  * if it does.  If the callback returns non-zero and a reference to the
  * current device can be obtained, this function will return to the caller
  * and not iterate over any more devices.
+ *
+ * NOTE: you will need to drop the reference with put_device() after use.
  */
 struct device *device_find_child(struct device *parent, void *data,
 				 int (*match)(struct device *dev, void *data))

commit 97521978c5ea80857d4f4f74d4e1fc93721482cf
Author: dyoung@redhat.com <dyoung@redhat.com>
Date:   Thu May 16 14:31:30 2013 +0800

    driver core: print sysfs attribute name when warning about bogus permissions
    
    Make it obvious to see what attribute is using bogus permissions.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 016312437577..2499cefdcdf2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -572,9 +572,11 @@ int device_create_file(struct device *dev,
 
 	if (dev) {
 		WARN(((attr->attr.mode & S_IWUGO) && !attr->store),
-				"Write permission without 'store'\n");
+			"Attribute %s: write permission without 'store'\n",
+			attr->attr.name);
 		WARN(((attr->attr.mode & S_IRUGO) && !attr->show),
-				"Read permission without 'show'\n");
+			"Attribute %s: read permission without 'show'\n",
+			attr->attr.name);
 		error = sysfs_create_file(&dev->kobj, &attr->attr);
 	}
 

commit 4f3549d72d1b5c90ecc7e673402f38f4486d22c2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 2 22:15:29 2013 +0200

    Driver core: Add offline/online device operations
    
    In some cases, graceful hot-removal of devices is not possible,
    although in principle the devices in question support hotplug.
    For example, that may happen for the last CPU in the system or
    for memory modules holding kernel memory.
    
    In those cases it is nice to be able to check if the given device
    can be gracefully hot-removed before triggering a removal procedure
    that cannot be aborted or reversed.  Unfortunately, however, the
    kernel currently doesn't provide any support for that.
    
    To address that deficiency, introduce support for offline and
    online operations that can be performed on devices, respectively,
    before a hot-removal and in case when it is necessary (or convenient)
    to put a device back online after a successful offline (that has not
    been followed by removal).  The idea is that the offline will fail
    whenever the given device cannot be gracefully removed from the
    system and it will not be allowed to use the device after a
    successful offline (until a subsequent online) in analogy with the
    existing CPU offline/online mechanism.
    
    For now, the offline and online operations are introduced at the
    bus type level, as that should be sufficient for the most urgent use
    cases (CPUs and memory modules).  In the future, however, the
    approach may be extended to cover some more complicated device
    offline/online scenarios involving device drivers etc.
    
    The lock_device_hotplug() and unlock_device_hotplug() functions are
    introduced because subsequent patches need to put larger pieces of
    code under device_hotplug_lock to prevent race conditions between
    device offline and removal from happening.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 016312437577..60c975686089 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -403,6 +403,36 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 static struct device_attribute uevent_attr =
 	__ATTR(uevent, S_IRUGO | S_IWUSR, show_uevent, store_uevent);
 
+static ssize_t show_online(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	bool val;
+
+	lock_device_hotplug();
+	val = !dev->offline;
+	unlock_device_hotplug();
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t store_online(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	bool val;
+	int ret;
+
+	ret = strtobool(buf, &val);
+	if (ret < 0)
+		return ret;
+
+	lock_device_hotplug();
+	ret = val ? device_online(dev) : device_offline(dev);
+	unlock_device_hotplug();
+	return ret < 0 ? ret : count;
+}
+
+static struct device_attribute online_attr =
+	__ATTR(online, S_IRUGO | S_IWUSR, show_online, store_online);
+
 static int device_add_attributes(struct device *dev,
 				 struct device_attribute *attrs)
 {
@@ -516,6 +546,12 @@ static int device_add_attrs(struct device *dev)
 	if (error)
 		goto err_remove_type_groups;
 
+	if (device_supports_offline(dev) && !dev->offline_disabled) {
+		error = device_create_file(dev, &online_attr);
+		if (error)
+			goto err_remove_type_groups;
+	}
+
 	return 0;
 
  err_remove_type_groups:
@@ -536,6 +572,7 @@ static void device_remove_attrs(struct device *dev)
 	struct class *class = dev->class;
 	const struct device_type *type = dev->type;
 
+	device_remove_file(dev, &online_attr);
 	device_remove_groups(dev, dev->groups);
 
 	if (type)
@@ -1431,6 +1468,99 @@ EXPORT_SYMBOL_GPL(put_device);
 EXPORT_SYMBOL_GPL(device_create_file);
 EXPORT_SYMBOL_GPL(device_remove_file);
 
+static DEFINE_MUTEX(device_hotplug_lock);
+
+void lock_device_hotplug(void)
+{
+	mutex_lock(&device_hotplug_lock);
+}
+
+void unlock_device_hotplug(void)
+{
+	mutex_unlock(&device_hotplug_lock);
+}
+
+static int device_check_offline(struct device *dev, void *not_used)
+{
+	int ret;
+
+	ret = device_for_each_child(dev, NULL, device_check_offline);
+	if (ret)
+		return ret;
+
+	return device_supports_offline(dev) && !dev->offline ? -EBUSY : 0;
+}
+
+/**
+ * device_offline - Prepare the device for hot-removal.
+ * @dev: Device to be put offline.
+ *
+ * Execute the device bus type's .offline() callback, if present, to prepare
+ * the device for a subsequent hot-removal.  If that succeeds, the device must
+ * not be used until either it is removed or its bus type's .online() callback
+ * is executed.
+ *
+ * Call under device_hotplug_lock.
+ */
+int device_offline(struct device *dev)
+{
+	int ret;
+
+	if (dev->offline_disabled)
+		return -EPERM;
+
+	ret = device_for_each_child(dev, NULL, device_check_offline);
+	if (ret)
+		return ret;
+
+	device_lock(dev);
+	if (device_supports_offline(dev)) {
+		if (dev->offline) {
+			ret = 1;
+		} else {
+			ret = dev->bus->offline(dev);
+			if (!ret) {
+				kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+				dev->offline = true;
+			}
+		}
+	}
+	device_unlock(dev);
+
+	return ret;
+}
+
+/**
+ * device_online - Put the device back online after successful device_offline().
+ * @dev: Device to be put back online.
+ *
+ * If device_offline() has been successfully executed for @dev, but the device
+ * has not been removed subsequently, execute its bus type's .online() callback
+ * to indicate that the device can be used again.
+ *
+ * Call under device_hotplug_lock.
+ */
+int device_online(struct device *dev)
+{
+	int ret = 0;
+
+	device_lock(dev);
+	if (device_supports_offline(dev)) {
+		if (dev->offline) {
+			ret = dev->bus->online(dev);
+			if (!ret) {
+				kobject_uevent(&dev->kobj, KOBJ_ONLINE);
+				dev->offline = false;
+			}
+		} else {
+			ret = 1;
+		}
+	}
+	device_unlock(dev);
+
+	return ret;
+}
+
 struct root_device {
 	struct device dev;
 	struct module *owner;

commit 46d9be3e5eb01f71fc02653755d970247174b400
Merge: ce8aa4892944 cece95dfe5aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 29 19:07:40 2013 -0700

    Merge branch 'for-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    Pull workqueue updates from Tejun Heo:
     "A lot of activities on workqueue side this time.  The changes achieve
      the followings.
    
       - WQ_UNBOUND workqueues - the workqueues which are per-cpu - are
         updated to be able to interface with multiple backend worker pools.
         This involved a lot of churning but the end result seems actually
         neater as unbound workqueues are now a lot closer to per-cpu ones.
    
       - The ability to interface with multiple backend worker pools are
         used to implement unbound workqueues with custom attributes.
         Currently the supported attributes are the nice level and CPU
         affinity.  It may be expanded to include cgroup association in
         future.  The attributes can be specified either by calling
         apply_workqueue_attrs() or through /sys/bus/workqueue/WQ_NAME/* if
         the workqueue in question is exported through sysfs.
    
         The backend worker pools are keyed by the actual attributes and
         shared by any workqueues which share the same attributes.  When
         attributes of a workqueue are changed, the workqueue binds to the
         worker pool with the specified attributes while leaving the work
         items which are already executing in its previous worker pools
         alone.
    
         This allows converting custom worker pool implementations which
         want worker attribute tuning to use workqueues.  The writeback pool
         is already converted in block tree and there are a couple others
         are likely to follow including btrfs io workers.
    
       - WQ_UNBOUND's ability to bind to multiple worker pools is also used
         to make it NUMA-aware.  Because there's no association between work
         item issuer and the specific worker assigned to execute it, before
         this change, using unbound workqueue led to unnecessary cross-node
         bouncing and it couldn't be helped by autonuma as it requires tasks
         to have implicit node affinity and workers are assigned randomly.
    
         After these changes, an unbound workqueue now binds to multiple
         NUMA-affine worker pools so that queued work items are executed in
         the same node.  This is turned on by default but can be disabled
         system-wide or for individual workqueues.
    
         Crypto was requesting NUMA affinity as encrypting data across
         different nodes can contribute noticeable overhead and doing it
         per-cpu was too limiting for certain cases and IO throughput could
         be bottlenecked by one CPU being fully occupied while others have
         idle cycles.
    
      While the new features required a lot of changes including
      restructuring locking, it didn't complicate the execution paths much.
      The unbound workqueue handling is now closer to per-cpu ones and the
      new features are implemented by simply associating a workqueue with
      different sets of backend worker pools without changing queue,
      execution or flush paths.
    
      As such, even though the amount of change is very high, I feel
      relatively safe in that it isn't likely to cause subtle issues with
      basic correctness of work item execution and handling.  If something
      is wrong, it's likely to show up as being associated with worker pools
      with the wrong attributes or OOPS while workqueue attributes are being
      changed or during CPU hotplug.
    
      While this creates more backend worker pools, it doesn't add too many
      more workers unless, of course, there are many workqueues with unique
      combinations of attributes.  Assuming everything else is the same,
      NUMA awareness costs an extra worker pool per NUMA node with online
      CPUs.
    
      There are also a couple things which are being routed outside the
      workqueue tree.
    
       - block tree pulled in workqueue for-3.10 so that writeback worker
         pool can be converted to unbound workqueue with sysfs control
         exposed.  This simplifies the code, makes writeback workers
         NUMA-aware and allows tuning nice level and CPU affinity via sysfs.
    
       - The conversion to workqueue means that there's no 1:1 association
         between a specific worker, which makes writeback folks unhappy as
         they want to be able to tell which filesystem caused a problem from
         backtrace on systems with many filesystems mounted.  This is
         resolved by allowing work items to set debug info string which is
         printed when the task is dumped.  As this change involves unifying
         implementations of dump_stack() and friends in arch codes, it's
         being routed through Andrew's -mm tree."
    
    * 'for-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq: (84 commits)
      workqueue: use kmem_cache_free() instead of kfree()
      workqueue: avoid false negative WARN_ON() in destroy_workqueue()
      workqueue: update sysfs interface to reflect NUMA awareness and a kernel param to disable NUMA affinity
      workqueue: implement NUMA affinity for unbound workqueues
      workqueue: introduce put_pwq_unlocked()
      workqueue: introduce numa_pwq_tbl_install()
      workqueue: use NUMA-aware allocation for pool_workqueues
      workqueue: break init_and_link_pwq() into two functions and introduce alloc_unbound_pwq()
      workqueue: map an unbound workqueues to multiple per-node pool_workqueues
      workqueue: move hot fields of workqueue_struct to the end
      workqueue: make workqueue->name[] fixed len
      workqueue: add workqueue->unbound_attrs
      workqueue: determine NUMA node of workers accourding to the allowed cpumask
      workqueue: drop 'H' from kworker names of unbound worker pools
      workqueue: add wq_numa_tbl_len and wq_numa_possible_cpumask[]
      workqueue: move pwq_pool_locking outside of get/put_unbound_pool()
      workqueue: fix memory leak in apply_workqueue_attrs()
      workqueue: fix unbound workqueue attrs hashing / comparison
      workqueue: fix race condition in unbound workqueue free path
      workqueue: remove pwq_lock which is no longer used
      ...

commit 4e4098a3e08783cfd75f9fcdab276dc1d46931da
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 11 11:43:29 2013 -0700

    driver core: handle user namespaces properly with the uid/gid devtmpfs change
    
    Now that devtmpfs is caring about uid/gid, we need to use the correct
    internal types so users who have USER_NS enabled will have things work
    properly for them.
    
    Thanks to Eric for pointing this out, and the patch review.
    
    Reported-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8a428b51089d..f88d9e259a32 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -283,8 +283,8 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		const char *tmp;
 		const char *name;
 		umode_t mode = 0;
-		uid_t uid = 0;
-		gid_t gid = 0;
+		kuid_t uid = GLOBAL_ROOT_UID;
+		kgid_t gid = GLOBAL_ROOT_GID;
 
 		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
 		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
@@ -293,10 +293,10 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 			add_uevent_var(env, "DEVNAME=%s", name);
 			if (mode)
 				add_uevent_var(env, "DEVMODE=%#o", mode & 0777);
-			if (uid)
-				add_uevent_var(env, "DEVUID=%u", uid);
-			if (gid)
-				add_uevent_var(env, "DEVGID=%u", gid);
+			if (!uid_eq(uid, GLOBAL_ROOT_UID))
+				add_uevent_var(env, "DEVUID=%u", from_kuid(&init_user_ns, uid));
+			if (!gid_eq(gid, GLOBAL_ROOT_GID))
+				add_uevent_var(env, "DEVGID=%u", from_kgid(&init_user_ns, gid));
 			kfree(tmp);
 		}
 	}
@@ -1297,7 +1297,7 @@ static struct device *next_device(struct klist_iter *i)
  * freed by the caller.
  */
 const char *device_get_devnode(struct device *dev,
-			       umode_t *mode, uid_t *uid, gid_t *gid,
+			       umode_t *mode, kuid_t *uid, kgid_t *gid,
 			       const char **tmp)
 {
 	char *s;

commit 3c2670e6515cf584810f417db9b00992c8b2d75a
Author: Kay Sievers <kay@vrfy.org>
Date:   Sat Apr 6 09:56:00 2013 -0700

    driver core: add uid and gid to devtmpfs
    
    Some drivers want to tell userspace what uid and gid should be used for
    their device nodes, so allow that information to percolate through the
    driver core to userspace in order to make this happen.  This means that
    some systems (i.e.  Android and friends) will not need to even run a
    udev-like daemon for their device node manager and can just rely in
    devtmpfs fully, reducing their footprint even more.
    
    Signed-off-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a7391a30cb29..8a428b51089d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -283,15 +283,21 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		const char *tmp;
 		const char *name;
 		umode_t mode = 0;
+		uid_t uid = 0;
+		gid_t gid = 0;
 
 		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
 		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
-		name = device_get_devnode(dev, &mode, &tmp);
+		name = device_get_devnode(dev, &mode, &uid, &gid, &tmp);
 		if (name) {
 			add_uevent_var(env, "DEVNAME=%s", name);
-			kfree(tmp);
 			if (mode)
 				add_uevent_var(env, "DEVMODE=%#o", mode & 0777);
+			if (uid)
+				add_uevent_var(env, "DEVUID=%u", uid);
+			if (gid)
+				add_uevent_var(env, "DEVGID=%u", gid);
+			kfree(tmp);
 		}
 	}
 
@@ -1281,6 +1287,8 @@ static struct device *next_device(struct klist_iter *i)
  * device_get_devnode - path of device node file
  * @dev: device
  * @mode: returned file access mode
+ * @uid: returned file owner
+ * @gid: returned file group
  * @tmp: possibly allocated string
  *
  * Return the relative path of a possible device node.
@@ -1289,7 +1297,8 @@ static struct device *next_device(struct klist_iter *i)
  * freed by the caller.
  */
 const char *device_get_devnode(struct device *dev,
-			       umode_t *mode, const char **tmp)
+			       umode_t *mode, uid_t *uid, gid_t *gid,
+			       const char **tmp)
 {
 	char *s;
 
@@ -1297,7 +1306,7 @@ const char *device_get_devnode(struct device *dev,
 
 	/* the device type may provide a specific name */
 	if (dev->type && dev->type->devnode)
-		*tmp = dev->type->devnode(dev, mode);
+		*tmp = dev->type->devnode(dev, mode, uid, gid);
 	if (*tmp)
 		return *tmp;
 

commit 8f46baaa7ec6cd0851794020b31958e64679dd26
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Feb 20 10:31:42 2013 +0200

    base: core: WARN() about bogus permissions on device attributes
    
    Whenever a struct device_attribute is registered
    with mismatched permissions - read permission without
    a show routine or write permission without store
    routine - we will issue a big warning so we catch
    those early enough.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 56536f4b0f6b..a7391a30cb29 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -563,8 +563,15 @@ int device_create_file(struct device *dev,
 		       const struct device_attribute *attr)
 {
 	int error = 0;
-	if (dev)
+
+	if (dev) {
+		WARN(((attr->attr.mode & S_IWUGO) && !attr->store),
+				"Write permission without 'store'\n");
+		WARN(((attr->attr.mode & S_IRUGO) && !attr->show),
+				"Read permission without 'show'\n");
 		error = sysfs_create_file(&dev->kobj, &attr->attr);
+	}
+
 	return error;
 }
 

commit d73ce004225a7b2ed75f4340bb63721d55552265
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 12 11:30:05 2013 -0700

    driver/base: implement subsys_virtual_register()
    
    Kay tells me the most appropriate place to expose workqueues to
    userland would be /sys/devices/virtual/workqueues/WQ_NAME which is
    symlinked to /sys/bus/workqueue/devices/WQ_NAME and that we're lacking
    a way to do that outside of driver core as virtual_device_parent()
    isn't exported and there's no inteface to conveniently create a
    virtual subsystem.
    
    This patch implements subsys_virtual_register() by factoring out
    subsys_register() from subsys_system_register() and using it with
    virtual_device_parent() as the origin directory.  It's identical to
    subsys_system_register() other than the origin directory but we aren't
    gonna restrict the device names which should be used under it.
    
    This will be used to expose workqueue attributes to userland.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 56536f4b0f6b..f58084a86e8c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -690,7 +690,7 @@ void device_initialize(struct device *dev)
 	set_dev_node(dev, -1);
 }
 
-static struct kobject *virtual_device_parent(struct device *dev)
+struct kobject *virtual_device_parent(struct device *dev)
 {
 	static struct kobject *virtual_dir = NULL;
 

commit 9f3b795a626ee79574595e06d1437fe0c7d51d29
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Fri Feb 1 20:40:17 2013 +0100

    driver-core: constify data for class_find_device()
    
    All in-kernel users of class_find_device() don't really need mutable
    data for match callback.
    
    In two places (kernel/power/suspend_test.c, drivers/scsi/osd/osd_uld.c)
    this patch changes match callbacks to use const search data.
    
    The const is propagated to rtc_class_open() and power_supply_get_by_name()
    parameters.
    
    Note that there's a dev reference leak in suspend_test.c that's not
    touched in this patch.
    
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 27603a6c0a93..56536f4b0f6b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1617,9 +1617,9 @@ struct device *device_create(struct class *class, struct device *parent,
 }
 EXPORT_SYMBOL_GPL(device_create);
 
-static int __match_devt(struct device *dev, void *data)
+static int __match_devt(struct device *dev, const void *data)
 {
-	dev_t *devt = data;
+	const dev_t *devt = data;
 
 	return dev->devt == *devt;
 }

commit 53a9c87e7e02abf3575be98c9fb2018fa30a61b9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 17 13:10:23 2013 -0800

    Revert "drivers: base: Convert print_symbol to %pSR"
    
    This reverts commit e79798659339be800bf553c0b6fb06745aecf37f as %pSR
    isn't in the tree yet.
    
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2937c631ea41..27603a6c0a93 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -97,8 +97,8 @@ static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 	if (dev_attr->show)
 		ret = dev_attr->show(dev, dev_attr, buf);
 	if (ret >= (ssize_t)PAGE_SIZE) {
-		printk("dev_attr_show: %pSR returned bad count\n",
-		       dev_attr->show);
+		print_symbol("dev_attr_show: %s returned bad count\n",
+				(unsigned long)dev_attr->show);
 	}
 	return ret;
 }

commit e79798659339be800bf553c0b6fb06745aecf37f
Author: Joe Perches <joe@perches.com>
Date:   Wed Dec 12 10:19:07 2012 -0800

    drivers: base: Convert print_symbol to %pSR
    
    Use the new vsprintf extension to avoid any possible
    message interleaving.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 27603a6c0a93..2937c631ea41 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -97,8 +97,8 @@ static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 	if (dev_attr->show)
 		ret = dev_attr->show(dev, dev_attr, buf);
 	if (ret >= (ssize_t)PAGE_SIZE) {
-		print_symbol("dev_attr_show: %s returned bad count\n",
-				(unsigned long)dev_attr->show);
+		printk("dev_attr_show: %pSR returned bad count\n",
+		       dev_attr->show);
 	}
 	return ret;
 }

commit 1a5d76dbe825fa6deba3d8979bbd334ea17b6dcc
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Sat Dec 8 15:38:06 2012 -0200

    drivers/base/core.c: Remove two unused variables and two useless calls to kfree
    
    old_class_name, and new_class_name are never used. This patch remove the
    declaration and calls to kfree.
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r1 forall@
    type T; identifier i;
    @@
    * T *i = NULL;
      ... when != i
    * kfree(i);
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a235085e343c..27603a6c0a93 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1685,8 +1685,6 @@ EXPORT_SYMBOL_GPL(device_destroy);
  */
 int device_rename(struct device *dev, const char *new_name)
 {
-	char *old_class_name = NULL;
-	char *new_class_name = NULL;
 	char *old_device_name = NULL;
 	int error;
 
@@ -1717,8 +1715,6 @@ int device_rename(struct device *dev, const char *new_name)
 out:
 	put_device(dev);
 
-	kfree(new_class_name);
-	kfree(old_class_name);
 	kfree(old_device_name);
 
 	return error;

commit 2d9c8b5d6a5f5f7a6111cc68a050b5b44729376b
Merge: 17bc14b767cf 003db633d6f2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 14 09:59:59 2012 -0800

    Merge branch 'x86-ras-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 RAS update from Ingo Molnar:
     "Rework all config variables used throughout the MCA code and collect
      them together into a mca_config struct.  This keeps them tightly and
      neatly packed together instead of spilled all over the place.
    
      Then, convert those which are used as booleans into real booleans and
      save some space.  These bits are exposed via
         /sys/devices/system/machinecheck/machinecheck*/"
    
    * 'x86-ras-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86, MCA: Finish mca_config conversion
      x86, MCA: Convert the next three variables batch
      x86, MCA: Convert rip_msr, mce_bootlog, monarch_timeout
      x86, MCA: Convert dont_log_ce, banks and tolerant
      drivers/base: Add a DEVICE_BOOL_ATTR macro

commit cff2f741b8ee8a70b208830e330de053efd4fc45
Merge: b0885d01f9ab 92e9e6d1f984
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 11 13:13:55 2012 -0800

    Merge tag 'driver-core-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg Kroah-Hartman:
     "Here's the large driver core updates for 3.8-rc1.
    
      The biggest thing here is the various __dev* marking removals.  This
      is going to be a pain for the merge with different subsystem trees, I
      know, but all of the patches included here have been ACKed by their
      various subsystem maintainers, as they wanted them to go through here.
    
      If this is too much of a pain, I can pull all of them out of this tree
      and just send you one with the other fixes/updates and then, after
      3.8-rc1 is out, do the rest of the removals to ensure we catch them
      all, it's up to you.  The merges should all be trivial, and Stephen
      has been doing them all in linux-next for a few weeks now quite
      easily.
    
      Other than the __dev* marking removals, there's nothing major here,
      some firmware loading updates and other minor things in the driver
      core.
    
      All of these have (much to Stephen's annoyance), been in linux-next
      for a while.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fixed up trivial conflicts in drivers/gpio/gpio-{em,stmpe}.c due to gpio
    update.
    
    * tag 'driver-core-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (93 commits)
      modpost.c: Stop checking __dev* section mismatches
      init.h: Remove __dev* sections from the kernel
      acpi: remove use of __devinit
      PCI: Remove __dev* markings
      PCI: Always build setup-bus when PCI is enabled
      PCI: Move pci_uevent into pci-driver.c
      PCI: Remove CONFIG_HOTPLUG ifdefs
      unicore32/PCI: Remove CONFIG_HOTPLUG ifdefs
      sh/PCI: Remove CONFIG_HOTPLUG ifdefs
      powerpc/PCI: Remove CONFIG_HOTPLUG ifdefs
      mips/PCI: Remove CONFIG_HOTPLUG ifdefs
      microblaze/PCI: Remove CONFIG_HOTPLUG ifdefs
      dma: remove use of __devinit
      dma: remove use of __devexit_p
      firewire: remove use of __devinitdata
      firewire: remove use of __devinit
      leds: remove use of __devexit
      leds: remove use of __devinit
      leds: remove use of __devexit_p
      mmc: remove use of __devexit
      ...

commit 93058424af5c555f28175d41384d799f34b4f07e
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Sun Nov 18 21:27:55 2012 -0800

    drivers/base/core.c: Mark to_root_device static
    
    Nothing outside of drivers/base/core.c references this function.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 985f69c3e1e3..442e5d371ac6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1399,7 +1399,7 @@ struct root_device {
 	struct module *owner;
 };
 
-inline struct root_device *to_root_device(struct device *d)
+static inline struct root_device *to_root_device(struct device *d)
 {
 	return container_of(d, struct root_device, dev);
 }

commit 0246c4fafccd6c3580bb33e8d30a2c7927e09f02
Author: ShuoX Liu <shuox.liu@intel.com>
Date:   Fri Nov 23 15:14:12 2012 +0800

    driver core: use initcall_debug to control shutdown info
    
    syscore_shutdown uses initcall_debug to control the debug info output.
    It’s a good programming. But device_shutdown doesn’t. The patch changes
    device_shutdown to follow the style.
    
    Signed-off-by: Yanmin Zhang <yanmin_zhang@linux.intel.com>
    Signed-off-by: ShuoX Liu <shuox.liu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index abea76c36a4b..985f69c3e1e3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1840,10 +1840,12 @@ void device_shutdown(void)
 		pm_runtime_barrier(dev);
 
 		if (dev->bus && dev->bus->shutdown) {
-			dev_dbg(dev, "shutdown\n");
+			if (initcall_debug)
+				dev_info(dev, "shutdown\n");
 			dev->bus->shutdown(dev);
 		} else if (dev->driver && dev->driver->shutdown) {
-			dev_dbg(dev, "shutdown\n");
+			if (initcall_debug)
+				dev_info(dev, "shutdown\n");
 			dev->driver->shutdown(dev);
 		}
 

commit 4b6d1f12f9c4e0e420d5747d3ae285d8f66d627f
Author: LongX Zhang <longx.zhang@intel.com>
Date:   Thu Oct 25 00:21:28 2012 +0200

    driver core / PM: move the calling to device_pm_remove behind the calling to bus_remove_device
    
    We hit an hang issue when removing a mmc device on Medfield Android phone by sysfs interface.
    
    device_pm_remove will call pm_runtime_remove which would disable
    runtime PM of the device. After that pm_runtime_get* or
    pm_runtime_put* will be ignored. So if we disable the runtime PM
    before device really be removed, drivers' _remove callback may
    access HW even pm_runtime_get* fails. That is bad.
    
    Consider below call sequence when removing a device:
    device_del => device_pm_remove
                 => class_intf->remove_dev(dev, class_intf)  => pm_runtime_get_sync/put_sync
                 => bus_remove_device => device_release_driver => pm_runtime_get_sync/put_sync
    
    remove_dev might call pm_runtime_get_sync/put_sync.
    Then, generic device_release_driver also calls pm_runtime_get_sync/put_sync.
    Since device_del => device_pm_remove firstly, later _get_sync wouldn't really wake up the device.
    
    I git log -p to find the patch which moves the calling to device_pm_remove ahead.
    It's below patch:
    
    commit  775b64d2b6ca37697de925f70799c710aab5849a
    Author: Rafael J. Wysocki <rjw@sisk.pl>
    Date:   Sat Jan 12 20:40:46 2008 +0100
    
         PM: Acquire device locks on suspend
    
         This patch reorganizes the way suspend and resume notifications are
         sent to drivers.  The major changes are that now the PM core acquires
         every device semaphore before calling the methods, and calls to
         device_add() during suspends will fail, while calls to device_del()
         during suspends will block.
    
         It also provides a way to safely remove a suspended device with the
         help of the PM core, by using the device_pm_schedule_removal() callback
         introduced specifically for this purpose, and updates two drivers (msr
         and cpuid) that need to use it.
    
    As device_pm_schedule_removal is deleted by another patch, we need also revert other parts of the patch,
    i.e. move the calling of device_pm_remove after the calling to bus_remove_device.
    
    Signed-off-by: LongX Zhang <longx.zhang@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index abea76c36a4b..150a41580fad 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1180,7 +1180,6 @@ void device_del(struct device *dev)
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
-	device_pm_remove(dev);
 	dpm_sysfs_remove(dev);
 	if (parent)
 		klist_del(&dev->p->knode_parent);
@@ -1205,6 +1204,7 @@ void device_del(struct device *dev)
 	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);
 	bus_remove_device(dev);
+	device_pm_remove(dev);
 	driver_deferred_probe_del(dev);
 
 	/* Notify the platform of the removal, in case they

commit 91872392f08486f692887d2f06a333f512648f22
Author: Borislav Petkov <bp@alien8.de>
Date:   Tue Oct 9 19:52:05 2012 +0200

    drivers/base: Add a DEVICE_BOOL_ATTR macro
    
    ... which, analogous to DEVICE_INT_ATTR provides functionality to
    set/clear bools. Its purpose is to be used where values need to be used
    as booleans in configuration context.
    
    Next patch uses this.
    
    Signed-off-by: Borislav Petkov <bp@alien8.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index abea76c36a4b..c8ae1f6b01b9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -171,6 +171,27 @@ ssize_t device_show_int(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_show_int);
 
+ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	struct dev_ext_attribute *ea = to_ext_attr(attr);
+
+	if (strtobool(buf, ea->var) < 0)
+		return -EINVAL;
+
+	return size;
+}
+EXPORT_SYMBOL_GPL(device_store_bool);
+
+ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct dev_ext_attribute *ea = to_ext_attr(attr);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", *(bool *)(ea->var));
+}
+EXPORT_SYMBOL_GPL(device_show_bool);
+
 /**
  *	device_release - free device structure.
  *	@kobj:	device's kobject.

commit 666f355f3805d68b6ed5f7013806f1f65abfbf03
Author: Joe Perches <joe@perches.com>
Date:   Wed Sep 12 20:14:11 2012 -0700

    device and dynamic_debug: Use dev_vprintk_emit and dev_printk_emit
    
    Convert direct calls of vprintk_emit and printk_emit to the
    dev_ equivalents.
    
    Make create_syslog_header static.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Tested-by: Jim Cromie <jim.cromie@gmail.com>
    Acked-by: Jason Baron <jbaron@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index dff94c8fb350..abea76c36a4b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1865,7 +1865,8 @@ void device_shutdown(void)
  */
 
 #ifdef CONFIG_PRINTK
-int create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
+static int
+create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
 {
 	const char *subsys;
 	size_t pos = 0;
@@ -1943,17 +1944,12 @@ EXPORT_SYMBOL(dev_printk_emit);
 static int __dev_printk(const char *level, const struct device *dev,
 			struct va_format *vaf)
 {
-	char hdr[128];
-	size_t hdrlen;
-
 	if (!dev)
 		return printk("%s(NULL device *): %pV", level, vaf);
 
-	hdrlen = create_syslog_header(dev, hdr, sizeof(hdr));
-
-	return printk_emit(0, level[1] - '0', hdrlen ? hdr : NULL, hdrlen,
-			   "%s %s: %pV",
-			   dev_driver_string(dev), dev_name(dev), vaf);
+	return dev_printk_emit(level[1] - '0', dev,
+			       "%s %s: %pV",
+			       dev_driver_string(dev), dev_name(dev), vaf);
 }
 
 int dev_printk(const char *level, const struct device *dev,

commit 05e4e5b87aab74f994acf9dd4bed4a8f1367cd09
Author: Joe Perches <joe@perches.com>
Date:   Wed Sep 12 20:13:37 2012 -0700

    dev: Add dev_vprintk_emit and dev_printk_emit
    
    Add utility functions to consolidate the use of
    create_syslog_header and vprintk_emit.
    
    This allows conversion of logging functions that
    call create_syslog_header and then call vprintk_emit
    or printk_emit to the dev_ equivalents.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Tested-by: Jim Cromie <jim.cromie@gmail.com>
    Acked-by: Jason Baron <jbaron@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d325b9dab3ff..dff94c8fb350 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1913,6 +1913,33 @@ int create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
 }
 EXPORT_SYMBOL(create_syslog_header);
 
+int dev_vprintk_emit(int level, const struct device *dev,
+		     const char *fmt, va_list args)
+{
+	char hdr[128];
+	size_t hdrlen;
+
+	hdrlen = create_syslog_header(dev, hdr, sizeof(hdr));
+
+	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
+}
+EXPORT_SYMBOL(dev_vprintk_emit);
+
+int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
+{
+	va_list args;
+	int r;
+
+	va_start(args, fmt);
+
+	r = dev_vprintk_emit(level, dev, fmt, args);
+
+	va_end(args);
+
+	return r;
+}
+EXPORT_SYMBOL(dev_printk_emit);
+
 static int __dev_printk(const char *level, const struct device *dev,
 			struct va_format *vaf)
 {

commit 798efc60e4276825df34af0e91ecbe0781237834
Author: Joe Perches <joe@perches.com>
Date:   Wed Sep 12 20:11:29 2012 -0700

    dev_dbg/dynamic_debug: Update to use printk_emit, optimize stack
    
    commit c4e00daaa9
    ("driver-core: extend dev_printk() to pass structured data")
    changed __dev_printk and broke dynamic-debug's ability to control the
    dynamic prefix of dev_dbg(dev,..).
    
    commit af7f2158fd
    ("drivers-core: make structured logging play nice with dynamic-debug")
    made a minimal correction.
    
    The current dynamic debug code uses up to 3 recursion levels via %pV.
    This can consume quite a bit of stack.  Directly call printk_emit to
    reduce the recursion depth.
    
    These changes include:
    
    dev_dbg:
    o Create and use function create_syslog_header to format the syslog
      header for printk_emit uses.
    o Call create_syslog_header and neaten __dev_printk
    o Make __dev_printk static not global
    o Remove include header declaration of __dev_printk
    o Remove now unused EXPORT_SYMBOL() of __dev_printk
    o Whitespace neatening
    
    dynamic_dev_dbg:
    o Remove KERN_DEBUG from dynamic_emit_prefix
    o Call create_syslog_header and printk_emit
    o Whitespace neatening
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Tested-by: Jim Cromie <jim.cromie@gmail.com>
    Acked-by: Jason Baron <jbaron@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 91478bd35418..d325b9dab3ff 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1865,26 +1865,19 @@ void device_shutdown(void)
  */
 
 #ifdef CONFIG_PRINTK
-int __dev_printk(const char *level, const struct device *dev,
-		 struct va_format *vaf)
+int create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
 {
-	char dict[128];
-	const char *level_extra = "";
-	size_t dictlen = 0;
 	const char *subsys;
-
-	if (!dev)
-		return printk("%s(NULL device *): %pV", level, vaf);
+	size_t pos = 0;
 
 	if (dev->class)
 		subsys = dev->class->name;
 	else if (dev->bus)
 		subsys = dev->bus->name;
 	else
-		goto skip;
+		return 0;
 
-	dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
-			    "SUBSYSTEM=%s", subsys);
+	pos += snprintf(hdr + pos, hdrlen - pos, "SUBSYSTEM=%s", subsys);
 
 	/*
 	 * Add device identifier DEVICE=:
@@ -1900,32 +1893,41 @@ int __dev_printk(const char *level, const struct device *dev,
 			c = 'b';
 		else
 			c = 'c';
-		dictlen++;
-		dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
-				   "DEVICE=%c%u:%u",
-				   c, MAJOR(dev->devt), MINOR(dev->devt));
+		pos++;
+		pos += snprintf(hdr + pos, hdrlen - pos,
+				"DEVICE=%c%u:%u",
+				c, MAJOR(dev->devt), MINOR(dev->devt));
 	} else if (strcmp(subsys, "net") == 0) {
 		struct net_device *net = to_net_dev(dev);
 
-		dictlen++;
-		dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
-				    "DEVICE=n%u", net->ifindex);
+		pos++;
+		pos += snprintf(hdr + pos, hdrlen - pos,
+				"DEVICE=n%u", net->ifindex);
 	} else {
-		dictlen++;
-		dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
-				    "DEVICE=+%s:%s", subsys, dev_name(dev));
+		pos++;
+		pos += snprintf(hdr + pos, hdrlen - pos,
+				"DEVICE=+%s:%s", subsys, dev_name(dev));
 	}
-skip:
-	if (level[2])
-		level_extra = &level[2]; /* skip past KERN_SOH "L" */
 
-	return printk_emit(0, level[1] - '0',
-			   dictlen ? dict : NULL, dictlen,
-			   "%s %s: %s%pV",
-			   dev_driver_string(dev), dev_name(dev),
-			   level_extra, vaf);
+	return pos;
+}
+EXPORT_SYMBOL(create_syslog_header);
+
+static int __dev_printk(const char *level, const struct device *dev,
+			struct va_format *vaf)
+{
+	char hdr[128];
+	size_t hdrlen;
+
+	if (!dev)
+		return printk("%s(NULL device *): %pV", level, vaf);
+
+	hdrlen = create_syslog_header(dev, hdr, sizeof(hdr));
+
+	return printk_emit(0, level[1] - '0', hdrlen ? hdr : NULL, hdrlen,
+			   "%s %s: %pV",
+			   dev_driver_string(dev), dev_name(dev), vaf);
 }
-EXPORT_SYMBOL(__dev_printk);
 
 int dev_printk(const char *level, const struct device *dev,
 	       const char *fmt, ...)
@@ -1940,6 +1942,7 @@ int dev_printk(const char *level, const struct device *dev,
 	vaf.va = &args;
 
 	r = __dev_printk(level, dev, &vaf);
+
 	va_end(args);
 
 	return r;
@@ -1959,6 +1962,7 @@ int func(const struct device *dev, const char *fmt, ...)	\
 	vaf.va = &args;						\
 								\
 	r = __dev_printk(kern_level, dev, &vaf);		\
+								\
 	va_end(args);						\
 								\
 	return r;						\

commit 9db48aaf18d675ac41f550c9384154e0c00de2ef
Merge: 0592969e73ae fea7a08acb13
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 27 07:08:39 2012 -0700

    Merge 3.6-rc3 into driver-core-next
    
    This picks up the printk fixes in 3.6-rc3 that are needed in this branch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ebdc82899ec5ed35af1c79ed6a4eeda69dad9b90
Author: Markus Trippelsdorf <markus@trippelsdorf.de>
Date:   Sat Aug 18 18:35:51 2012 -0600

    dyndbg: fix for SOH in logging messages
    
    commit af7f2158fde was done against master, and clashed with structured
    logging's change of KERN_LEVEL to SOH.
    
    Bisected and fixed by Markus Trippelsdorf.
    
    Reported-by: Markus Trippelsdorf <markus@trippelsdorf.de>
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index cdd01c52c629..5e6e00bc1652 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1912,8 +1912,8 @@ int __dev_printk(const char *level, const struct device *dev,
 				    "DEVICE=+%s:%s", subsys, dev_name(dev));
 	}
 skip:
-	if (level[3])
-		level_extra = &level[3]; /* skip past "<L>" */
+	if (level[2])
+		level_extra = &level[2]; /* skip past KERN_SOH "L" */
 
 	return printk_emit(0, level[1] - '0',
 			   dictlen ? dict : NULL, dictlen,

commit a525a3ddeaca69f405d98442ab3c0746e53168dc
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed Jul 25 01:42:29 2012 +0800

    driver core: free devres in device_release
    
    device_del can happen anytime, so once it happens,
    the devres of the device will be freed inside device_del, but
    drivers can't know it has been deleted and may still add
    resources into the device, so memory leak is caused.
    
    This patch moves the devres_release_all to fix the problem.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f338037a4f3d..c8fe4a563866 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -184,6 +184,17 @@ static void device_release(struct kobject *kobj)
 	struct device *dev = kobj_to_dev(kobj);
 	struct device_private *p = dev->p;
 
+	/*
+	 * Some platform devices are driven without driver attached
+	 * and managed resources may have been acquired.  Make sure
+	 * all resources are released.
+	 *
+	 * Drivers still can add resources into device after device
+	 * is deleted but alive, so release devres here to avoid
+	 * possible memory leak.
+	 */
+	devres_release_all(dev);
+
 	if (dev->release)
 		dev->release(dev);
 	else if (dev->type && dev->type->release)
@@ -1196,13 +1207,6 @@ void device_del(struct device *dev)
 	bus_remove_device(dev);
 	driver_deferred_probe_del(dev);
 
-	/*
-	 * Some platform devices are driven without driver attached
-	 * and managed resources may have been acquired.  Make sure
-	 * all resources are released.
-	 */
-	devres_release_all(dev);
-
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...
 	 */

commit af7f2158fdee9d7f55b793b09f8170a3391f889a
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Thu Jul 19 13:46:21 2012 -0600

    drivers-core: make structured logging play nice with dynamic-debug
    
    commit c4e00daaa96d3a0786f1f4fe6456281c60ef9a16 changed __dev_printk
    in a way that broke dynamic-debug's ability to control the dynamic
    prefix of dev_dbg(dev,..), but not dev_dbg(NULL,..) or pr_debug(..),
    which is why it wasnt noticed sooner.
    
    When dev==NULL, __dev_printk() just calls printk(), which just works.
    But otherwise, it assumed that level was always a string like "<L>"
    and just plucked out the 'L', ignoring the rest.  However,
    dynamic_emit_prefix() adds "[tid] module:func:line:" to the string,
    those additions all got lost.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Acked-by: Jason Baron <jbaron@redhat.com>
    Cc: stable <stable@vger.kernel.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f338037a4f3d..cdd01c52c629 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1865,6 +1865,7 @@ int __dev_printk(const char *level, const struct device *dev,
 		 struct va_format *vaf)
 {
 	char dict[128];
+	const char *level_extra = "";
 	size_t dictlen = 0;
 	const char *subsys;
 
@@ -1911,10 +1912,14 @@ int __dev_printk(const char *level, const struct device *dev,
 				    "DEVICE=+%s:%s", subsys, dev_name(dev));
 	}
 skip:
+	if (level[3])
+		level_extra = &level[3]; /* skip past "<L>" */
+
 	return printk_emit(0, level[1] - '0',
 			   dictlen ? dict : NULL, dictlen,
-			   "%s %s: %pV",
-			   dev_driver_string(dev), dev_name(dev), vaf);
+			   "%s %s: %s%pV",
+			   dev_driver_string(dev), dev_name(dev),
+			   level_extra, vaf);
 }
 EXPORT_SYMBOL(__dev_printk);
 

commit b0d1f807f340e91b27aa721f6474956af11571da
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jul 3 18:49:36 2012 +0200

    driver-core: Use kobj_to_dev instead of re-implementing it
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 65849a9aeece..f338037a4f3d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -85,14 +85,13 @@ const char *dev_driver_string(const struct device *dev)
 }
 EXPORT_SYMBOL(dev_driver_string);
 
-#define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 
 static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 			     char *buf)
 {
 	struct device_attribute *dev_attr = to_dev_attr(attr);
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->show)
@@ -108,7 +107,7 @@ static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,
 			      const char *buf, size_t count)
 {
 	struct device_attribute *dev_attr = to_dev_attr(attr);
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->store)
@@ -182,7 +181,7 @@ EXPORT_SYMBOL_GPL(device_show_int);
  */
 static void device_release(struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct device_private *p = dev->p;
 
 	if (dev->release)
@@ -200,7 +199,7 @@ static void device_release(struct kobject *kobj)
 
 static const void *device_namespace(struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	const void *ns = NULL;
 
 	if (dev->class && dev->class->ns_type)
@@ -221,7 +220,7 @@ static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 	struct kobj_type *ktype = get_ktype(kobj);
 
 	if (ktype == &device_ktype) {
-		struct device *dev = to_dev(kobj);
+		struct device *dev = kobj_to_dev(kobj);
 		if (dev->bus)
 			return 1;
 		if (dev->class)
@@ -232,7 +231,7 @@ static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 
 static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 
 	if (dev->bus)
 		return dev->bus->name;
@@ -244,7 +243,7 @@ static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
 static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		      struct kobj_uevent_env *env)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	int retval = 0;
 
 	/* add device node properties if present */
@@ -1132,7 +1131,7 @@ int device_register(struct device *dev)
  */
 struct device *get_device(struct device *dev)
 {
-	return dev ? to_dev(kobject_get(&dev->kobj)) : NULL;
+	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
 }
 
 /**

commit d1c6c030fcec6f860d9bb6c632a3ebe62e28440b
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Jun 22 18:01:40 2012 +0800

    driver core: fix shutdown races with probe/remove(v3)
    
    Firstly, .shutdown callback may touch a uninitialized hardware
    if dev->driver is set and .probe is not completed.
    
    Secondly, device_shutdown() may dereference a null pointer to cause
    oops when dev->driver is cleared after it has been checked in
    device_shutdown().
    
    So just hold device lock and its parent lock(if it has) to
    fix the races.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 846d12b5d579..65849a9aeece 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1812,6 +1812,13 @@ void device_shutdown(void)
 	while (!list_empty(&devices_kset->list)) {
 		dev = list_entry(devices_kset->list.prev, struct device,
 				kobj.entry);
+
+		/*
+		 * hold reference count of device's parent to
+		 * prevent it from being freed because parent's
+		 * lock is to be held
+		 */
+		get_device(dev->parent);
 		get_device(dev);
 		/*
 		 * Make sure the device is off the kset list, in the
@@ -1820,6 +1827,11 @@ void device_shutdown(void)
 		list_del_init(&dev->kobj.entry);
 		spin_unlock(&devices_kset->list_lock);
 
+		/* hold lock to avoid race with probe/release */
+		if (dev->parent)
+			device_lock(dev->parent);
+		device_lock(dev);
+
 		/* Don't allow any more runtime suspends */
 		pm_runtime_get_noresume(dev);
 		pm_runtime_barrier(dev);
@@ -1831,7 +1843,13 @@ void device_shutdown(void)
 			dev_dbg(dev, "shutdown\n");
 			dev->driver->shutdown(dev);
 		}
+
+		device_unlock(dev);
+		if (dev->parent)
+			device_unlock(dev->parent);
+
 		put_device(dev);
+		put_device(dev->parent);
 
 		spin_lock(&devices_kset->list_lock);
 	}

commit bdd4034df8b37841eeaf7b05f86e732ab8e0b08a
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Mon Apr 23 09:16:36 2012 +0200

    driver core: always handle dpm_order
    
    If !dev->class, device_move() does not respect the dpm_order.
    Fix it to do so.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Reviewed-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    [Fixed a small dangling label compile warning]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 346be8b78b24..846d12b5d579 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1754,25 +1754,25 @@ int device_move(struct device *dev, struct device *new_parent,
 		set_dev_node(dev, dev_to_node(new_parent));
 	}
 
-	if (!dev->class)
-		goto out_put;
-	error = device_move_class_links(dev, old_parent, new_parent);
-	if (error) {
-		/* We ignore errors on cleanup since we're hosed anyway... */
-		device_move_class_links(dev, new_parent, old_parent);
-		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
-			if (new_parent)
-				klist_remove(&dev->p->knode_parent);
-			dev->parent = old_parent;
-			if (old_parent) {
-				klist_add_tail(&dev->p->knode_parent,
-					       &old_parent->p->klist_children);
-				set_dev_node(dev, dev_to_node(old_parent));
+	if (dev->class) {
+		error = device_move_class_links(dev, old_parent, new_parent);
+		if (error) {
+			/* We ignore errors on cleanup since we're hosed anyway... */
+			device_move_class_links(dev, new_parent, old_parent);
+			if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
+				if (new_parent)
+					klist_remove(&dev->p->knode_parent);
+				dev->parent = old_parent;
+				if (old_parent) {
+					klist_add_tail(&dev->p->knode_parent,
+						       &old_parent->p->klist_children);
+					set_dev_node(dev, dev_to_node(old_parent));
+				}
 			}
+			cleanup_glue_dir(dev, new_parent_kobj);
+			put_device(new_parent);
+			goto out;
 		}
-		cleanup_glue_dir(dev, new_parent_kobj);
-		put_device(new_parent);
-		goto out;
 	}
 	switch (dpm_order) {
 	case DPM_ORDER_NONE:
@@ -1787,7 +1787,7 @@ int device_move(struct device *dev, struct device *new_parent,
 		device_pm_move_last(dev);
 		break;
 	}
-out_put:
+
 	put_device(old_parent);
 out:
 	device_pm_unlock();

commit c4e00daaa96d3a0786f1f4fe6456281c60ef9a16
Author: Kay Sievers <kay@vrfy.org>
Date:   Thu May 3 02:29:59 2012 +0200

    driver-core: extend dev_printk() to pass structured data
    
    Extends dev_printk() to attach a dictionary with a device identifier
    and the driver core subsystem name to logged messages, which makes
    dev_prink() reliable machine-readable. In addition to the printed
    plain text message, it creates these properties:
        SUBSYSTEM=     - the driver-core subsytem name
        DEVICE=
          b12:8        - block dev_t
          c127:3       - char dev_t
          n8           - netdev ifindex
          +sound:card0 - subsystem:devname
    
    Tested-by: William Douglas <william.douglas@intel.com>
    Signed-off-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 33461ec35d8f..346be8b78b24 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -25,6 +25,7 @@
 #include <linux/mutex.h>
 #include <linux/async.h>
 #include <linux/pm_runtime.h>
+#include <linux/netdevice.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -1843,15 +1844,60 @@ void device_shutdown(void)
  */
 
 #ifdef CONFIG_PRINTK
-
 int __dev_printk(const char *level, const struct device *dev,
 		 struct va_format *vaf)
 {
+	char dict[128];
+	size_t dictlen = 0;
+	const char *subsys;
+
 	if (!dev)
 		return printk("%s(NULL device *): %pV", level, vaf);
 
-	return printk("%s%s %s: %pV",
-		      level, dev_driver_string(dev), dev_name(dev), vaf);
+	if (dev->class)
+		subsys = dev->class->name;
+	else if (dev->bus)
+		subsys = dev->bus->name;
+	else
+		goto skip;
+
+	dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
+			    "SUBSYSTEM=%s", subsys);
+
+	/*
+	 * Add device identifier DEVICE=:
+	 *   b12:8         block dev_t
+	 *   c127:3        char dev_t
+	 *   n8            netdev ifindex
+	 *   +sound:card0  subsystem:devname
+	 */
+	if (MAJOR(dev->devt)) {
+		char c;
+
+		if (strcmp(subsys, "block") == 0)
+			c = 'b';
+		else
+			c = 'c';
+		dictlen++;
+		dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
+				   "DEVICE=%c%u:%u",
+				   c, MAJOR(dev->devt), MINOR(dev->devt));
+	} else if (strcmp(subsys, "net") == 0) {
+		struct net_device *net = to_net_dev(dev);
+
+		dictlen++;
+		dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
+				    "DEVICE=n%u", net->ifindex);
+	} else {
+		dictlen++;
+		dictlen += snprintf(dict + dictlen, sizeof(dict) - dictlen,
+				    "DEVICE=+%s:%s", subsys, dev_name(dev));
+	}
+skip:
+	return printk_emit(0, level[1] - '0',
+			   dictlen ? dict : NULL, dictlen,
+			   "%s %s: %pV",
+			   dev_driver_string(dev), dev_name(dev), vaf);
 }
 EXPORT_SYMBOL(__dev_printk);
 

commit 9169c01236ab29ce55c93aaf22ec6ecc65c46d1a
Author: yan <clouds.yan@gmail.com>
Date:   Fri Apr 20 21:08:45 2012 +0800

    drivers/base/core.c: Fix a typo in comment
    
    Signed-off-by: YanHong <clouds.yan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6cb25f1511df..33461ec35d8f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -65,7 +65,7 @@ static inline int device_is_not_partition(struct device *dev)
  * @dev: struct device to get the name of
  *
  * Will return the device's driver's name if it is bound to a device.  If
- * the device is not bound to a device, it will return the name of the bus
+ * the device is not bound to a driver, it will return the name of the bus
  * it is attached to.  If it is not attached to a bus either, an empty
  * string will be returned.
  */

commit 0d4e293ca8271cc7d7ac1423afe5ceb7d213d0fc
Author: Peter Korsgaard <jacmet@sunsite.dk>
Date:   Tue Apr 17 12:12:57 2012 +0200

    core.c: fix 'the the' typo
    
    Signed-off-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e28ce9898af4..6cb25f1511df 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -878,8 +878,8 @@ EXPORT_SYMBOL_GPL(dev_set_name);
  * to NULL prevents an entry from being created.  class->dev_kobj must
  * be set (or cleared) before any devices are registered to the class
  * otherwise device_create_sys_dev_entry() and
- * device_remove_sys_dev_entry() will disagree about the the presence
- * of the link.
+ * device_remove_sys_dev_entry() will disagree about the presence of
+ * the link.
  */
 static struct kobject *device_to_dev_kobj(struct device *dev)
 {

commit f8974cb71310a05632aada76be6a27576d61e609
Merge: c207f3a43194 0f22dd395fc4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 21 10:30:03 2012 -0700

    Merge tag 'dt-for-linus' of git://git.secretlab.ca/git/linux-2.6
    
    Pull core device tree changes for Linux v3.4 from Grant Likely:
     "This branch contains a minor documentation addition, a utility
      function for parsing string properties needed by some of the new ARM
      platforms, disables dynamic DT code that isn't used anywhere but on a
      few PPC machines, and exports DT node compatible data to userspace via
      UEVENT properties.  Nothing earth shattering here."
    
    * tag 'dt-for-linus' of git://git.secretlab.ca/git/linux-2.6:
      of: Only compile OF_DYNAMIC on PowerPC pseries and iseries
      arm/dts: OMAP3: Add omap3evm and am335xevm support
      drivercore: Output common devicetree information in uevent
      of: Add of_property_match_string() to find index into a string list

commit ef8a3fd6e5e12e8989dae97ba5491c2e39369af9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 8 12:17:22 2012 -0800

    driver core: move the deferred probe pointer into the private area
    
    Nothing outside of the driver core needs to get to the deferred probe
    pointer, so move it inside the private area of 'struct device' so no one
    tries to mess around with it.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d4ff7adce38c..7050a75dde38 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -644,7 +644,6 @@ void device_initialize(struct device *dev)
 {
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
-	INIT_LIST_HEAD(&dev->deferred_probe);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	mutex_init(&dev->mutex);
 	lockdep_set_novalidate_class(&dev->mutex);
@@ -922,6 +921,7 @@ int device_private_init(struct device *dev)
 	dev->p->device = dev;
 	klist_init(&dev->p->klist_children, klist_children_get,
 		   klist_children_put);
+	INIT_LIST_HEAD(&dev->p->deferred_probe);
 	return 0;
 }
 

commit d1c3414c2a9d10ef7f0f7665f5d2947cd088c093
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Mar 5 08:47:41 2012 -0700

    drivercore: Add driver probe deferral mechanism
    
    Allow drivers to report at probe time that they cannot get all the resources
    required by the device, and should be retried at a later time.
    
    This should completely solve the problem of getting devices
    initialized in the right order.  Right now this is mostly handled by
    mucking about with initcall ordering which is a complete hack, and
    doesn't even remotely handle the case where device drivers are in
    modules.  This approach completely sidesteps the issues by allowing
    driver registration to occur in any order, and any driver can request
    to be retried after a few more other drivers get probed.
    
    v4: - Integrate Manjunath's addition of a separate workqueue
        - Change -EAGAIN to -EPROBE_DEFER for drivers to trigger deferral
        - Update comment blocks to reflect how the code really works
    v3: - Hold off workqueue scheduling until late_initcall so that the bulk
          of driver probes are complete before we start retrying deferred devices.
        - Tested with simple use cases.  Still needs more testing though.
          Using it to get rid of the gpio early_initcall madness, or to replace
          the ASoC internal probe deferral code would be ideal.
    v2: - added locking so it should no longer be utterly broken in that regard
        - remove device from deferred list at device_del time.
        - Still completely untested with any real use case, but has been
          boot tested.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Dilan Lee <dilee@nvidia.com>
    Cc: Manjunath GKondaiah <manjunath.gkondaiah@linaro.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 74dda4f697f9..d4ff7adce38c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -644,6 +644,7 @@ void device_initialize(struct device *dev)
 {
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
+	INIT_LIST_HEAD(&dev->deferred_probe);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	mutex_init(&dev->mutex);
 	lockdep_set_novalidate_class(&dev->mutex);
@@ -1188,6 +1189,7 @@ void device_del(struct device *dev)
 	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);
 	bus_remove_device(dev);
+	driver_deferred_probe_del(dev);
 
 	/*
 	 * Some platform devices are driven without driver attached

commit 07d57a32fb6eb2da017796e038682f817a4f685e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Feb 1 11:22:22 2012 -0700

    drivercore: Output common devicetree information in uevent
    
    When userspace needs to find a specific device, it currently isn't easy to
    resolve a /sys/devices/ path from a specific device tree node.  Nor is it
    easy to obtain the compatible list for devices.
    
    This patch generalizes the code that inserts OF_* values into the uevent
    device attribute so that any device that is attached to an OF node will
    have that information exported to userspace.  Without this patch only
    platform devices and some powerpc-specific busses have access to this
    data.
    
    The original function also creates a MODALIAS property for the compatible
    list, but that code has not been generalized into the common case because
    it has the potential to break module loading on a lot of bus types.  Bus
    types are still responsible for their own MODALIAS properties.
    
    Boot tested on ARM and compile tested on PowerPC and SPARC.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Frederic Lambert <frdrc66@gmail.com>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Mark Brown <broonie@sirena.org.uk>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4a67cc0c8b37..28d8c21bb323 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -18,6 +18,8 @@
 #include <linux/string.h>
 #include <linux/kdev_t.h>
 #include <linux/notifier.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/genhd.h>
 #include <linux/kallsyms.h>
 #include <linux/mutex.h>
@@ -267,6 +269,9 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	if (dev->driver)
 		add_uevent_var(env, "DRIVER=%s", dev->driver->name);
 
+	/* Add common DT information about the device */
+	of_device_uevent(dev, env);
+
 	/* have the bus specific function add its stuff */
 	if (dev->bus && dev->bus->uevent) {
 		retval = dev->bus->uevent(dev, env);

commit 268863f43629ef88763400d0cae4a66c754a0d23
Author: majianpeng <majianpeng@gmail.com>
Date:   Wed Jan 11 15:12:06 2012 +0000

    base/core.c:fix typo in comment in function device_add
    
    Signed-off-by: majianpeng <majianpeng@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ad29e928baaa..74dda4f697f9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1034,7 +1034,7 @@ int device_add(struct device *dev)
 	device_pm_add(dev);
 
 	/* Notify clients of device addition.  This call must come
-	 * after dpm_sysf_add() and before kobject_uevent().
+	 * after dpm_sysfs_add() and before kobject_uevent().
 	 */
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,

commit b10d5efdf7892d18b3b7d899edce2c8d9b80aea9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 17 11:39:00 2012 -0500

    Documentation update for the driver model core
    
    This patch (as1509) documents two important points regarding the use
    of device structures in the driver model:
    
            Structures must be initialized to all 0's before they are
            passed to device_initialize().
    
            Structures must not be passed to device_add() or
            device_register() more than once.
    
    Although these restrictions have applied ever since the driver model
    was first created, they have not been mentioned anywhere.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4a67cc0c8b37..ad29e928baaa 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -632,6 +632,11 @@ static void klist_children_put(struct klist_node *n)
  * may be used for reference counting of @dev after calling this
  * function.
  *
+ * All fields in @dev must be initialized by the caller to 0, except
+ * for those explicitly set to some other value.  The simplest
+ * approach is to use kzalloc() to allocate the structure containing
+ * @dev.
+ *
  * NOTE: Use put_device() to give up your reference instead of freeing
  * @dev directly once you have called this function.
  */
@@ -930,6 +935,13 @@ int device_private_init(struct device *dev)
  * to the global and sibling lists for the device, then
  * adds it to the other relevant subsystems of the driver model.
  *
+ * Do not call this routine or device_register() more than once for
+ * any device structure.  The driver model core is not designed to work
+ * with devices that get unregistered and then spring back to life.
+ * (Among other things, it's very hard to guarantee that all references
+ * to the previous incarnation of @dev have been dropped.)  Allocate
+ * and register a fresh new struct device instead.
+ *
  * NOTE: _Never_ directly free @dev after calling this function, even
  * if it returned an error! Always use put_device() to give up your
  * reference instead.
@@ -1090,6 +1102,9 @@ int device_add(struct device *dev)
  * have a clearly defined need to use and refcount the device
  * before it is added to the hierarchy.
  *
+ * For more information, see the kerneldoc for device_initialize()
+ * and device_add().
+ *
  * NOTE: _Never_ directly free @dev after calling this function, even
  * if it returned an error! Always use put_device() to give up the
  * reference initialized in this function instead.

commit 972b2c719990f91eb3b2310d44ef8a2d38955a14
Merge: 02550d61f492 c3aa077648e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 8 12:19:57 2012 -0800

    Merge branch 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    * 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (165 commits)
      reiserfs: Properly display mount options in /proc/mounts
      vfs: prevent remount read-only if pending removes
      vfs: count unlinked inodes
      vfs: protect remounting superblock read-only
      vfs: keep list of mounts for each superblock
      vfs: switch ->show_options() to struct dentry *
      vfs: switch ->show_path() to struct dentry *
      vfs: switch ->show_devname() to struct dentry *
      vfs: switch ->show_stats to struct dentry *
      switch security_path_chmod() to struct path *
      vfs: prefer ->dentry->d_sb to ->mnt->mnt_sb
      vfs: trim includes a bit
      switch mnt_namespace ->root to struct mount
      vfs: take /proc/*/mounts and friends to fs/proc_namespace.c
      vfs: opencode mntget() mnt_set_mountpoint()
      vfs: spread struct mount - remaining argument of next_mnt()
      vfs: move fsnotify junk to struct mount
      vfs: move mnt_devname
      vfs: move mnt_list to struct mount
      vfs: switch pnode.h macros to struct mount *
      ...

commit ff4b8a57f0aaa2882d444ca44b2b9b333d22a4df
Merge: 805a6af8dba5 ea04018e6bc5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 6 11:42:52 2012 -0800

    Merge branch 'driver-core-next' into Linux 3.2
    
    This resolves the conflict in the arch/arm/mach-s3c64xx/s3c6400.c file,
    and it fixes the build error in the arch/x86/kernel/microcode_core.c
    file, that the merge did not catch.
    
    The microcode_core.c patch was provided by Stephen Rothwell
    <sfr@canb.auug.org.au> who was invaluable in the merge issues involved
    with the large sysdev removal process in the driver-core tree.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2c9ede55ecec58099b72e4bb8eab719f32f72c31
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 20:24:48 2011 -0400

    switch device_get_devnode() and ->devnode() to umode_t *
    
    both callers of device_get_devnode() are only interested in lower 16bits
    and nobody tries to return anything wider than 16bit anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 919daa7cd5b1..1dfa1d616fa5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -198,7 +198,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	if (MAJOR(dev->devt)) {
 		const char *tmp;
 		const char *name;
-		mode_t mode = 0;
+		umode_t mode = 0;
 
 		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
 		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
@@ -1182,7 +1182,7 @@ static struct device *next_device(struct klist_iter *i)
  * freed by the caller.
  */
 const char *device_get_devnode(struct device *dev,
-			       mode_t *mode, const char **tmp)
+			       umode_t *mode, const char **tmp)
 {
 	char *s;
 

commit ca22e56debc57b47c422b749c93217ba62644be2
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 14 14:29:38 2011 -0800

    driver-core: implement 'sysdev' functionality for regular devices and buses
    
    All sysdev classes and sysdev devices will converted to regular devices
    and buses to properly hook userspace into the event processing.
    
    There is no interesting difference between a 'sysdev' and 'device' which
    would justify to roll an entire own subsystem with different userspace
    export semantics. Userspace relies on events and generic sysfs subsystem
    infrastructure from sysdev devices, which are currently not properly
    available.
    
    Every converted sysdev class will create a regular device with the class
    name in /sys/devices/system and all registered devices will becom a children
    of theses devices.
    
    For compatibility reasons, the sysdev class-wide attributes are created
    at this parent device. (Do not copy that logic for anything new, subsystem-
    wide properties belong to the subsystem, not to some fake parent device
    created in /sys/devices.)
    
    Every sysdev driver is implemented as a simple subsystem interface now,
    and no longer called a driver.
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 82c865452c70..a31ea193fba0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -117,6 +117,56 @@ static const struct sysfs_ops dev_sysfs_ops = {
 	.store	= dev_attr_store,
 };
 
+#define to_ext_attr(x) container_of(x, struct dev_ext_attribute, attr)
+
+ssize_t device_store_ulong(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t size)
+{
+	struct dev_ext_attribute *ea = to_ext_attr(attr);
+	char *end;
+	unsigned long new = simple_strtoul(buf, &end, 0);
+	if (end == buf)
+		return -EINVAL;
+	*(unsigned long *)(ea->var) = new;
+	/* Always return full write size even if we didn't consume all */
+	return size;
+}
+EXPORT_SYMBOL_GPL(device_store_ulong);
+
+ssize_t device_show_ulong(struct device *dev,
+			  struct device_attribute *attr,
+			  char *buf)
+{
+	struct dev_ext_attribute *ea = to_ext_attr(attr);
+	return snprintf(buf, PAGE_SIZE, "%lx\n", *(unsigned long *)(ea->var));
+}
+EXPORT_SYMBOL_GPL(device_show_ulong);
+
+ssize_t device_store_int(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t size)
+{
+	struct dev_ext_attribute *ea = to_ext_attr(attr);
+	char *end;
+	long new = simple_strtol(buf, &end, 0);
+	if (end == buf || new > INT_MAX || new < INT_MIN)
+		return -EINVAL;
+	*(int *)(ea->var) = new;
+	/* Always return full write size even if we didn't consume all */
+	return size;
+}
+EXPORT_SYMBOL_GPL(device_store_int);
+
+ssize_t device_show_int(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	struct dev_ext_attribute *ea = to_ext_attr(attr);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", *(int *)(ea->var));
+}
+EXPORT_SYMBOL_GPL(device_show_int);
 
 /**
  *	device_release - free device structure.
@@ -463,7 +513,7 @@ static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
 static struct device_attribute devt_attr =
 	__ATTR(dev, S_IRUGO, show_dev, NULL);
 
-/* kset to create /sys/devices/  */
+/* /sys/devices/ */
 struct kset *devices_kset;
 
 /**
@@ -710,6 +760,10 @@ static struct kobject *get_device_parent(struct device *dev,
 		return k;
 	}
 
+	/* subsystems can specify a default root directory for their devices */
+	if (!parent && dev->bus && dev->bus->dev_root)
+		return &dev->bus->dev_root->kobj;
+
 	if (parent)
 		return &parent->kobj;
 	return NULL;
@@ -730,14 +784,6 @@ static void cleanup_device_parent(struct device *dev)
 	cleanup_glue_dir(dev, dev->kobj.parent);
 }
 
-static void setup_parent(struct device *dev, struct device *parent)
-{
-	struct kobject *kobj;
-	kobj = get_device_parent(dev, parent);
-	if (kobj)
-		dev->kobj.parent = kobj;
-}
-
 static int device_add_class_symlinks(struct device *dev)
 {
 	int error;
@@ -890,6 +936,7 @@ int device_private_init(struct device *dev)
 int device_add(struct device *dev)
 {
 	struct device *parent = NULL;
+	struct kobject *kobj;
 	struct class_interface *class_intf;
 	int error = -EINVAL;
 
@@ -913,6 +960,10 @@ int device_add(struct device *dev)
 		dev->init_name = NULL;
 	}
 
+	/* subsystems can specify simple device enumeration */
+	if (!dev_name(dev) && dev->bus && dev->bus->dev_name)
+		dev_set_name(dev, "%s%u", dev->bus->dev_name, dev->id);
+
 	if (!dev_name(dev)) {
 		error = -EINVAL;
 		goto name_error;
@@ -921,7 +972,9 @@ int device_add(struct device *dev)
 	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
 
 	parent = get_device(dev->parent);
-	setup_parent(dev, parent);
+	kobj = get_device_parent(dev, parent);
+	if (kobj)
+		dev->kobj.parent = kobj;
 
 	/* use parent numa_node */
 	if (parent)
@@ -981,17 +1034,17 @@ int device_add(struct device *dev)
 			       &parent->p->klist_children);
 
 	if (dev->class) {
-		mutex_lock(&dev->class->p->class_mutex);
+		mutex_lock(&dev->class->p->mutex);
 		/* tie the class to the device */
 		klist_add_tail(&dev->knode_class,
 			       &dev->class->p->klist_devices);
 
 		/* notify any interfaces that the device is here */
 		list_for_each_entry(class_intf,
-				    &dev->class->p->class_interfaces, node)
+				    &dev->class->p->interfaces, node)
 			if (class_intf->add_dev)
 				class_intf->add_dev(dev, class_intf);
-		mutex_unlock(&dev->class->p->class_mutex);
+		mutex_unlock(&dev->class->p->mutex);
 	}
 done:
 	put_device(dev);
@@ -1106,15 +1159,15 @@ void device_del(struct device *dev)
 	if (dev->class) {
 		device_remove_class_symlinks(dev);
 
-		mutex_lock(&dev->class->p->class_mutex);
+		mutex_lock(&dev->class->p->mutex);
 		/* notify any interfaces that the device is now gone */
 		list_for_each_entry(class_intf,
-				    &dev->class->p->class_interfaces, node)
+				    &dev->class->p->interfaces, node)
 			if (class_intf->remove_dev)
 				class_intf->remove_dev(dev, class_intf);
 		/* remove the device from the class list */
 		klist_del(&dev->knode_class);
-		mutex_unlock(&dev->class->p->class_mutex);
+		mutex_unlock(&dev->class->p->mutex);
 	}
 	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);

commit fe6b91f47080eb17d21cbf2a39311877d57f6938
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Dec 6 23:24:52 2011 +0100

    PM / Driver core: leave runtime PM enabled during system shutdown
    
    Disabling all runtime PM during system shutdown turns out not to be a
    good idea, because some devices may need to be woken up from a
    low-power state at that time.
    
    The whole point of disabling runtime PM for system shutdown was to
    prevent untimely runtime-suspend method calls.  This patch (as1504)
    accomplishes the same result by incrementing the usage count for each
    device and waiting for ongoing runtime-PM callbacks to finish.  This
    is what we already do during system suspend and hibernation, which
    makes sense since the shutdown method is pretty much a legacy analog
    of the pm->poweroff method.
    
    This fixes a recent regression on some OMAP systems introduced by
    commit af8db1508f2c9f3b6e633e2d2d906c6557c617f9 (PM / driver core:
    disable device's runtime PM during shutdown).
    
    Reported-and-tested-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d8b3d89db043..919daa7cd5b1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1743,8 +1743,10 @@ void device_shutdown(void)
 		 */
 		list_del_init(&dev->kobj.entry);
 		spin_unlock(&devices_kset->list_lock);
-		/* Disable all device's runtime power management */
-		pm_runtime_disable(dev);
+
+		/* Don't allow any more runtime suspends */
+		pm_runtime_get_noresume(dev);
+		pm_runtime_barrier(dev);
 
 		if (dev->bus && dev->bus->shutdown) {
 			dev_dbg(dev, "shutdown\n");

commit af8db1508f2c9f3b6e633e2d2d906c6557c617f9
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Nov 15 21:52:29 2011 +0100

    PM / driver core: disable device's runtime PM during shutdown
    
    There may be an issue when the user issue "reboot/shutdown" command, then
    the device has shut down its hardware, after that, this runtime-pm featured
    device's driver will probably be scheduled to do its suspend routine,
    and at its suspend routine, it may access hardware, but the device has
    already shutdown physically, then the system hang may be occurred.
    
    I ran out this issue using an auto-suspend supported USB devices, like
    3G modem, keyboard. The usb runtime suspend routine may be scheduled
    after the usb controller has been shut down, and the usb runtime suspend
    routine will try to suspend its roothub(controller), it will access
    register, then the system hang occurs as the controller is shutdown.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: stable@kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 82c865452c70..d8b3d89db043 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -22,6 +22,7 @@
 #include <linux/kallsyms.h>
 #include <linux/mutex.h>
 #include <linux/async.h>
+#include <linux/pm_runtime.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -1742,6 +1743,8 @@ void device_shutdown(void)
 		 */
 		list_del_init(&dev->kobj.entry);
 		spin_unlock(&devices_kset->list_lock);
+		/* Disable all device's runtime power management */
+		pm_runtime_disable(dev);
 
 		if (dev->bus && dev->bus->shutdown) {
 			dev_dbg(dev, "shutdown\n");

commit cbc4663552ee476f57933920d782222d94878e7e
Author: Joe Perches <joe@perches.com>
Date:   Thu Aug 11 14:36:21 2011 -0400

    dynamic_debug: Add __dynamic_dev_dbg
    
    Unlike dynamic_pr_debug, dynamic uses of dev_dbg can not
    currently add task_pid/KBUILD_MODNAME/__func__/__LINE__
    to selected debug output.
    
    Add a new function similar to dynamic_pr_debug to
    optionally emit these prefixes.
    
    Cc: Aloisio Almeida <aloisio.almeida@openbossa.org>
    Noticed-by: Aloisio Almeida <aloisio.almeida@openbossa.org>
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bc8729d603a7..82c865452c70 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1764,8 +1764,8 @@ void device_shutdown(void)
 
 #ifdef CONFIG_PRINTK
 
-static int __dev_printk(const char *level, const struct device *dev,
-			struct va_format *vaf)
+int __dev_printk(const char *level, const struct device *dev,
+		 struct va_format *vaf)
 {
 	if (!dev)
 		return printk("%s(NULL device *): %pV", level, vaf);
@@ -1773,6 +1773,7 @@ static int __dev_printk(const char *level, const struct device *dev,
 	return printk("%s%s %s: %pV",
 		      level, dev_driver_string(dev), dev_name(dev), vaf);
 }
+EXPORT_SYMBOL(__dev_printk);
 
 int dev_printk(const char *level, const struct device *dev,
 	       const char *fmt, ...)

commit 7f100d1566d6ee353a43be92599511fc438ec281
Author: Karthigan Srinivasan <karthigan.srinivasan@hp.com>
Date:   Mon Apr 18 16:16:52 2011 -0500

    drivers/base/core.c: Fixed brace coding style issue.
    
    Fixed brace coding style issue.
    
    Signed-off-by: Karthigan Srinivasan <karthigan.srinivasan@hp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fb8130ceea10..bc8729d603a7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1314,8 +1314,7 @@ EXPORT_SYMBOL_GPL(put_device);
 EXPORT_SYMBOL_GPL(device_create_file);
 EXPORT_SYMBOL_GPL(device_remove_file);
 
-struct root_device
-{
+struct root_device {
 	struct device dev;
 	struct module *owner;
 };

commit aed65af1cc2f6fc9ded5a8158f1405a02cf6d2ff
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Mar 28 09:12:52 2011 -0700

    drivers: make device_type const
    
    The device_type structure does not contain data that changes
    during usage and should be const. This allows devices to declare
    the struct const.
    
    I have patches to change all the subsystems, but need the infra
    structure change first.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 81b78ede37c4..fb8130ceea10 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -400,7 +400,7 @@ static void device_remove_groups(struct device *dev,
 static int device_add_attrs(struct device *dev)
 {
 	struct class *class = dev->class;
-	struct device_type *type = dev->type;
+	const struct device_type *type = dev->type;
 	int error;
 
 	if (class) {
@@ -440,7 +440,7 @@ static int device_add_attrs(struct device *dev)
 static void device_remove_attrs(struct device *dev)
 {
 	struct class *class = dev->class;
-	struct device_type *type = dev->type;
+	const struct device_type *type = dev->type;
 
 	device_remove_groups(dev, dev->groups);
 

commit 481e20799bdcf98fd5a1d829d187239a90b15395
Author: Ferenc Wagner <wferi@niif.hu>
Date:   Fri Jan 7 15:17:47 2011 +0100

    driver core: Replace the dangerous to_root_device macro with an inline function
    
    The original macro worked only when applied to variables named 'dev'.
    While this could have been fixed by simply renaming the macro argument,
    a more type-safe replacement by an inline function is preferred.
    
    Signed-off-by: Ferenc Wagner <wferi@niif.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9cd3b5cfcc42..81b78ede37c4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1320,7 +1320,10 @@ struct root_device
 	struct module *owner;
 };
 
-#define to_root_device(dev) container_of(dev, struct root_device, dev)
+inline struct root_device *to_root_device(struct device *d)
+{
+	return container_of(d, struct root_device, dev);
+}
 
 static void root_device_release(struct device *dev)
 {

commit a5462516aa9942bd68c8769d4bcefa8a7c718300
Author: Timur Tabi <timur@freescale.com>
Date:   Mon Dec 13 14:08:52 2010 -0600

    driver-core: document restrictions on device_rename()
    
    Add text, courtesy of Kay Sievers, that provides some background on
    device_rename() and why it shouldn't be used.
    
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 080e9ca11017..9cd3b5cfcc42 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1551,7 +1551,34 @@ EXPORT_SYMBOL_GPL(device_destroy);
  * on the same device to ensure that new_name is valid and
  * won't conflict with other devices.
  *
- * "Never use this function, bad things will happen" - gregkh
+ * Note: Don't call this function.  Currently, the networking layer calls this
+ * function, but that will change.  The following text from Kay Sievers offers
+ * some insight:
+ *
+ * Renaming devices is racy at many levels, symlinks and other stuff are not
+ * replaced atomically, and you get a "move" uevent, but it's not easy to
+ * connect the event to the old and new device. Device nodes are not renamed at
+ * all, there isn't even support for that in the kernel now.
+ *
+ * In the meantime, during renaming, your target name might be taken by another
+ * driver, creating conflicts. Or the old name is taken directly after you
+ * renamed it -- then you get events for the same DEVPATH, before you even see
+ * the "move" event. It's just a mess, and nothing new should ever rely on
+ * kernel device renaming. Besides that, it's not even implemented now for
+ * other things than (driver-core wise very simple) network devices.
+ *
+ * We are currently about to change network renaming in udev to completely
+ * disallow renaming of devices in the same namespace as the kernel uses,
+ * because we can't solve the problems properly, that arise with swapping names
+ * of multiple interfaces without races. Means, renaming of eth[0-9]* will only
+ * be allowed to some other name than eth[0-9]*, for the aforementioned
+ * reasons.
+ *
+ * Make up a "real" name in the driver before you register anything, or add
+ * some other attributes for userspace to find the device, or use udev to add
+ * symlinks -- but never rename kernel devices later, it's a complete mess. We
+ * don't even want to get into that and try to implement the missing pieces in
+ * the core. We really have other pieces to fix in the driver core mess. :)
  */
 int device_rename(struct device *dev, const char *new_name)
 {

commit e54be894eae10eca9892e965cc9532f5d5a11767
Merge: 949f6711b83d c6c0ac664c86
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 10 16:10:33 2011 -0800

    Merge branch 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6
    
    * 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6:
      driver core: Document that device_rename() is only for networking
      sysfs: remove useless test from sysfs_merge_group
      driver-core: merge private parts of class and bus
      driver core: fix whitespace in class_attr_string

commit c97415a72521071c235e0879f9a600014afd87b1
Author: Stefan Achatz <erazor_de@users.sourceforge.net>
Date:   Fri Nov 26 19:57:29 2010 +0000

    sysfs: Introducing binary attributes for struct class
    
    Added dev_bin_attrs to struct class similar to existing dev_attrs.
    
    Signed-off-by: Stefan Achatz <erazor_de@users.sourceforge.net>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6ed645411c40..761359261589 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -338,6 +338,35 @@ static void device_remove_attributes(struct device *dev,
 			device_remove_file(dev, &attrs[i]);
 }
 
+static int device_add_bin_attributes(struct device *dev,
+				     struct bin_attribute *attrs)
+{
+	int error = 0;
+	int i;
+
+	if (attrs) {
+		for (i = 0; attr_name(attrs[i]); i++) {
+			error = device_create_bin_file(dev, &attrs[i]);
+			if (error)
+				break;
+		}
+		if (error)
+			while (--i >= 0)
+				device_remove_bin_file(dev, &attrs[i]);
+	}
+	return error;
+}
+
+static void device_remove_bin_attributes(struct device *dev,
+					 struct bin_attribute *attrs)
+{
+	int i;
+
+	if (attrs)
+		for (i = 0; attr_name(attrs[i]); i++)
+			device_remove_bin_file(dev, &attrs[i]);
+}
+
 static int device_add_groups(struct device *dev,
 			     const struct attribute_group **groups)
 {
@@ -378,12 +407,15 @@ static int device_add_attrs(struct device *dev)
 		error = device_add_attributes(dev, class->dev_attrs);
 		if (error)
 			return error;
+		error = device_add_bin_attributes(dev, class->dev_bin_attrs);
+		if (error)
+			goto err_remove_class_attrs;
 	}
 
 	if (type) {
 		error = device_add_groups(dev, type->groups);
 		if (error)
-			goto err_remove_class_attrs;
+			goto err_remove_class_bin_attrs;
 	}
 
 	error = device_add_groups(dev, dev->groups);
@@ -395,6 +427,9 @@ static int device_add_attrs(struct device *dev)
  err_remove_type_groups:
 	if (type)
 		device_remove_groups(dev, type->groups);
+ err_remove_class_bin_attrs:
+	if (class)
+		device_remove_bin_attributes(dev, class->dev_bin_attrs);
  err_remove_class_attrs:
 	if (class)
 		device_remove_attributes(dev, class->dev_attrs);
@@ -412,8 +447,10 @@ static void device_remove_attrs(struct device *dev)
 	if (type)
 		device_remove_groups(dev, type->groups);
 
-	if (class)
+	if (class) {
 		device_remove_attributes(dev, class->dev_attrs);
+		device_remove_bin_attributes(dev, class->dev_bin_attrs);
+	}
 }
 
 

commit c6c0ac664c86ff6408fadbed4913938c8a732e26
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Nov 25 09:44:07 2010 +1100

    driver core: Document that device_rename() is only for networking
    
    Document that device_rename() is not to be used by anything
    other than the network core.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 46ff6c251932..610d967632cd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1513,6 +1513,8 @@ EXPORT_SYMBOL_GPL(device_destroy);
  * exclusion between two different calls of device_rename
  * on the same device to ensure that new_name is valid and
  * won't conflict with other devices.
+ *
+ * "Never use this function, bad things will happen" - gregkh
  */
 int device_rename(struct device *dev, const char *new_name)
 {

commit 6b6e39a6a8da7234c538d14c43d3583da8875f9c
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon Nov 15 23:13:18 2010 +0100

    driver-core: merge private parts of class and bus
    
    As classes and busses are pretty much the same thing, and we want to
    merge them together into a 'subsystem' in the future, let us share the
    same private data parts to make that merge easier.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6ed645411c40..46ff6c251932 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -610,7 +610,7 @@ class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)
 	dir->class = class;
 	kobject_init(&dir->kobj, &class_dir_ktype);
 
-	dir->kobj.kset = &class->p->class_dirs;
+	dir->kobj.kset = &class->p->glue_dirs;
 
 	retval = kobject_add(&dir->kobj, parent_kobj, "%s", class->name);
 	if (retval < 0) {
@@ -635,7 +635,7 @@ static struct kobject *get_device_parent(struct device *dev,
 		if (sysfs_deprecated && dev->class == &block_class) {
 			if (parent && parent->class == &block_class)
 				return &parent->kobj;
-			return &block_class.p->class_subsys.kobj;
+			return &block_class.p->subsys.kobj;
 		}
 #endif
 
@@ -654,13 +654,13 @@ static struct kobject *get_device_parent(struct device *dev,
 		mutex_lock(&gdp_mutex);
 
 		/* find our class-directory at the parent and reference it */
-		spin_lock(&dev->class->p->class_dirs.list_lock);
-		list_for_each_entry(k, &dev->class->p->class_dirs.list, entry)
+		spin_lock(&dev->class->p->glue_dirs.list_lock);
+		list_for_each_entry(k, &dev->class->p->glue_dirs.list, entry)
 			if (k->parent == parent_kobj) {
 				kobj = kobject_get(k);
 				break;
 			}
-		spin_unlock(&dev->class->p->class_dirs.list_lock);
+		spin_unlock(&dev->class->p->glue_dirs.list_lock);
 		if (kobj) {
 			mutex_unlock(&gdp_mutex);
 			return kobj;
@@ -682,7 +682,7 @@ static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 {
 	/* see if we live in a "glue" directory */
 	if (!glue_dir || !dev->class ||
-	    glue_dir->kset != &dev->class->p->class_dirs)
+	    glue_dir->kset != &dev->class->p->glue_dirs)
 		return;
 
 	kobject_put(glue_dir);
@@ -709,7 +709,7 @@ static int device_add_class_symlinks(struct device *dev)
 		return 0;
 
 	error = sysfs_create_link(&dev->kobj,
-				  &dev->class->p->class_subsys.kobj,
+				  &dev->class->p->subsys.kobj,
 				  "subsystem");
 	if (error)
 		goto out;
@@ -728,7 +728,7 @@ static int device_add_class_symlinks(struct device *dev)
 #endif
 
 	/* link in the class directory pointing to the device */
-	error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
+	error = sysfs_create_link(&dev->class->p->subsys.kobj,
 				  &dev->kobj, dev_name(dev));
 	if (error)
 		goto out_device;
@@ -756,7 +756,7 @@ static void device_remove_class_symlinks(struct device *dev)
 	if (sysfs_deprecated && dev->class == &block_class)
 		return;
 #endif
-	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
+	sysfs_delete_link(&dev->class->p->subsys.kobj, &dev->kobj, dev_name(dev));
 }
 
 /**
@@ -947,7 +947,7 @@ int device_add(struct device *dev)
 		mutex_lock(&dev->class->p->class_mutex);
 		/* tie the class to the device */
 		klist_add_tail(&dev->knode_class,
-			       &dev->class->p->class_devices);
+			       &dev->class->p->klist_devices);
 
 		/* notify any interfaces that the device is here */
 		list_for_each_entry(class_intf,
@@ -1535,7 +1535,7 @@ int device_rename(struct device *dev, const char *new_name)
 	}
 
 	if (dev->class) {
-		error = sysfs_rename_link(&dev->class->p->class_subsys.kobj,
+		error = sysfs_rename_link(&dev->class->p->subsys.kobj,
 			&dev->kobj, old_device_name, new_name);
 		if (error)
 			goto out;

commit 229aebb873e29726b91e076161649cf45154b0bf
Merge: 8de547e18244 50a23e6eec6f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 24 13:41:39 2010 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      Update broken web addresses in arch directory.
      Update broken web addresses in the kernel.
      Revert "drivers/usb: Remove unnecessary return's from void functions" for musb gadget
      Revert "Fix typo: configuation => configuration" partially
      ida: document IDA_BITMAP_LONGS calculation
      ext2: fix a typo on comment in ext2/inode.c
      drivers/scsi: Remove unnecessary casts of private_data
      drivers/s390: Remove unnecessary casts of private_data
      net/sunrpc/rpc_pipe.c: Remove unnecessary casts of private_data
      drivers/infiniband: Remove unnecessary casts of private_data
      drivers/gpu/drm: Remove unnecessary casts of private_data
      kernel/pm_qos_params.c: Remove unnecessary casts of private_data
      fs/ecryptfs: Remove unnecessary casts of private_data
      fs/seq_file.c: Remove unnecessary casts of private_data
      arm: uengine.c: remove C99 comments
      arm: scoop.c: remove C99 comments
      Fix typo configue => configure in comments
      Fix typo: configuation => configuration
      Fix typo interrest[ing|ed] => interest[ing|ed]
      Fix various typos of valid in comments
      ...
    
    Fix up trivial conflicts in:
            drivers/char/ipmi/ipmi_si_intf.c
            drivers/usb/gadget/rndis.c
            net/irda/irnet/irnet_ppp.c

commit ead454feb6cbfe0fa6a1eeb30aa9abc338dacf62
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Sep 24 14:36:49 2010 -0700

    driver core: fix build for CONFIG_BLOCK not enabled
    
    Fix build errors when CONFIG_BLOCK is not enabled:
    
    drivers/base/core.c: In function 'get_device_parent':
    drivers/base/core.c:634: error: 'block_class' undeclared (first use in this function)
    drivers/base/core.c: In function 'device_add_class_symlinks':
    drivers/base/core.c:723: error: 'block_class' undeclared (first use in this function)
    drivers/base/core.c: In function 'device_remove_class_symlinks':
    drivers/base/core.c:751: error: 'block_class' undeclared (first use in this function)
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f7f906f0a2f2..2cb49a93b1e6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -630,12 +630,14 @@ static struct kobject *get_device_parent(struct device *dev,
 		struct kobject *parent_kobj;
 		struct kobject *k;
 
+#ifdef CONFIG_BLOCK
 		/* block disks show up in /sys/block */
 		if (sysfs_deprecated && dev->class == &block_class) {
 			if (parent && parent->class == &block_class)
 				return &parent->kobj;
 			return &block_class.p->class_subsys.kobj;
 		}
+#endif
 
 		/*
 		 * If we have no parent, we live in "virtual".
@@ -719,9 +721,11 @@ static int device_add_class_symlinks(struct device *dev)
 			goto out_subsys;
 	}
 
+#ifdef CONFIG_BLOCK
 	/* /sys/block has directories and does not need symlinks */
 	if (sysfs_deprecated && dev->class == &block_class)
 		return 0;
+#endif
 
 	/* link in the class directory pointing to the device */
 	error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
@@ -748,8 +752,10 @@ static void device_remove_class_symlinks(struct device *dev)
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 	sysfs_remove_link(&dev->kobj, "subsystem");
+#ifdef CONFIG_BLOCK
 	if (sysfs_deprecated && dev->class == &block_class)
 		return;
+#endif
 	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
 }
 

commit e52eec13cd6b7f30ab19081b387813e03e592ae5
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Sep 8 16:54:17 2010 +0200

    SYSFS: Allow boot time switching between deprecated and modern sysfs layout
    
    I have some systems which need legacy sysfs due to old tools that are
    making assumptions that a directory can never be a symlink to another
    directory, and it's a big hazzle to compile separate kernels for them.
    
    This patch turns CONFIG_SYSFS_DEPRECATED into a run time option
    that can be switched on/off the kernel command line. This way
    the same binary can be used in both cases with just a option
    on the command line.
    
    The old CONFIG_SYSFS_DEPRECATED_V2 option is still there to set
    the default. I kept the weird name to not break existing
    config files.
    
    Also the compat code can be still completely disabled by undefining
    CONFIG_SYSFS_DEPRECATED_SWITCH -- just the optimizer takes
    care of this now instead of lots of ifdefs. This makes the code
    look nicer.
    
    v2: This is an updated version on top of Kay's patch to only
    handle the block devices. I tested it on my old systems
    and that seems to work.
    
    Cc: axboe@kernel.dk
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6cf9069f3150..f7f906f0a2f2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -26,6 +26,19 @@
 #include "base.h"
 #include "power/power.h"
 
+#ifdef CONFIG_SYSFS_DEPRECATED
+#ifdef CONFIG_SYSFS_DEPRECATED_V2
+long sysfs_deprecated = 1;
+#else
+long sysfs_deprecated = 0;
+#endif
+static __init int sysfs_deprecated_setup(char *arg)
+{
+	return strict_strtol(arg, 10, &sysfs_deprecated);
+}
+early_param("sysfs.deprecated", sysfs_deprecated_setup);
+#endif
+
 int (*platform_notify)(struct device *dev) = NULL;
 int (*platform_notify_remove)(struct device *dev) = NULL;
 static struct kobject *dev_kobj;
@@ -617,14 +630,13 @@ static struct kobject *get_device_parent(struct device *dev,
 		struct kobject *parent_kobj;
 		struct kobject *k;
 
-#ifdef CONFIG_SYSFS_DEPRECATED
 		/* block disks show up in /sys/block */
-		if (dev->class == &block_class) {
+		if (sysfs_deprecated && dev->class == &block_class) {
 			if (parent && parent->class == &block_class)
 				return &parent->kobj;
 			return &block_class.p->class_subsys.kobj;
 		}
-#endif
+
 		/*
 		 * If we have no parent, we live in "virtual".
 		 * Class-devices with a non class-device as parent, live
@@ -707,11 +719,9 @@ static int device_add_class_symlinks(struct device *dev)
 			goto out_subsys;
 	}
 
-#ifdef CONFIG_SYSFS_DEPRECATED
 	/* /sys/block has directories and does not need symlinks */
-	if (dev->class == &block_class)
+	if (sysfs_deprecated && dev->class == &block_class)
 		return 0;
-#endif
 
 	/* link in the class directory pointing to the device */
 	error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
@@ -738,10 +748,8 @@ static void device_remove_class_symlinks(struct device *dev)
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 	sysfs_remove_link(&dev->kobj, "subsystem");
-#ifdef CONFIG_SYSFS_DEPRECATED
-	if (dev->class == &block_class)
+	if (sysfs_deprecated && dev->class == &block_class)
 		return;
-#endif
 	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
 }
 

commit 39aba963d937edb20db7d9d93e6dda5d2adfdcdd
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Sep 4 22:33:14 2010 -0700

    driver core: remove CONFIG_SYSFS_DEPRECATED_V2 but keep it for block devices
    
    This patch removes the old CONFIG_SYSFS_DEPRECATED_V2 config option,
    but it keeps the logic around to handle block devices in the old manner
    as some people like to run new kernel versions on old (pre 2007/2008)
    distros.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: "James E.J. Bottomley" <James.Bottomley@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d1b2c9adc271..6cf9069f3150 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -203,37 +203,6 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	if (dev->driver)
 		add_uevent_var(env, "DRIVER=%s", dev->driver->name);
 
-#ifdef CONFIG_SYSFS_DEPRECATED
-	if (dev->class) {
-		struct device *parent = dev->parent;
-
-		/* find first bus device in parent chain */
-		while (parent && !parent->bus)
-			parent = parent->parent;
-		if (parent && parent->bus) {
-			const char *path;
-
-			path = kobject_get_path(&parent->kobj, GFP_KERNEL);
-			if (path) {
-				add_uevent_var(env, "PHYSDEVPATH=%s", path);
-				kfree(path);
-			}
-
-			add_uevent_var(env, "PHYSDEVBUS=%s", parent->bus->name);
-
-			if (parent->driver)
-				add_uevent_var(env, "PHYSDEVDRIVER=%s",
-					       parent->driver->name);
-		}
-	} else if (dev->bus) {
-		add_uevent_var(env, "PHYSDEVBUS=%s", dev->bus->name);
-
-		if (dev->driver)
-			add_uevent_var(env, "PHYSDEVDRIVER=%s",
-				       dev->driver->name);
-	}
-#endif
-
 	/* have the bus specific function add its stuff */
 	if (dev->bus && dev->bus->uevent) {
 		retval = dev->bus->uevent(dev, env);
@@ -578,24 +547,6 @@ void device_initialize(struct device *dev)
 	set_dev_node(dev, -1);
 }
 
-#ifdef CONFIG_SYSFS_DEPRECATED
-static struct kobject *get_device_parent(struct device *dev,
-					 struct device *parent)
-{
-	/* class devices without a parent live in /sys/class/<classname>/ */
-	if (dev->class && (!parent || parent->class != dev->class))
-		return &dev->class->p->class_subsys.kobj;
-	/* all other devices keep their parent */
-	else if (parent)
-		return &parent->kobj;
-
-	return NULL;
-}
-
-static inline void cleanup_device_parent(struct device *dev) {}
-static inline void cleanup_glue_dir(struct device *dev,
-				    struct kobject *glue_dir) {}
-#else
 static struct kobject *virtual_device_parent(struct device *dev)
 {
 	static struct kobject *virtual_dir = NULL;
@@ -666,6 +617,14 @@ static struct kobject *get_device_parent(struct device *dev,
 		struct kobject *parent_kobj;
 		struct kobject *k;
 
+#ifdef CONFIG_SYSFS_DEPRECATED
+		/* block disks show up in /sys/block */
+		if (dev->class == &block_class) {
+			if (parent && parent->class == &block_class)
+				return &parent->kobj;
+			return &block_class.p->class_subsys.kobj;
+		}
+#endif
 		/*
 		 * If we have no parent, we live in "virtual".
 		 * Class-devices with a non class-device as parent, live
@@ -719,7 +678,6 @@ static void cleanup_device_parent(struct device *dev)
 {
 	cleanup_glue_dir(dev, dev->kobj.parent);
 }
-#endif
 
 static void setup_parent(struct device *dev, struct device *parent)
 {
@@ -742,70 +700,29 @@ static int device_add_class_symlinks(struct device *dev)
 	if (error)
 		goto out;
 
-#ifdef CONFIG_SYSFS_DEPRECATED
-	/* stacked class devices need a symlink in the class directory */
-	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
-	    device_is_not_partition(dev)) {
-		error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
-					  &dev->kobj, dev_name(dev));
-		if (error)
-			goto out_subsys;
-	}
-
 	if (dev->parent && device_is_not_partition(dev)) {
-		struct device *parent = dev->parent;
-		char *class_name;
-
-		/*
-		 * stacked class devices have the 'device' link
-		 * pointing to the bus device instead of the parent
-		 */
-		while (parent->class && !parent->bus && parent->parent)
-			parent = parent->parent;
-
-		error = sysfs_create_link(&dev->kobj,
-					  &parent->kobj,
+		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
 					  "device");
 		if (error)
-			goto out_busid;
-
-		class_name = make_class_name(dev->class->name,
-						&dev->kobj);
-		if (class_name)
-			error = sysfs_create_link(&dev->parent->kobj,
-						&dev->kobj, class_name);
-		kfree(class_name);
-		if (error)
-			goto out_device;
+			goto out_subsys;
 	}
-	return 0;
 
-out_device:
-	if (dev->parent && device_is_not_partition(dev))
-		sysfs_remove_link(&dev->kobj, "device");
-out_busid:
-	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
-	    device_is_not_partition(dev))
-		sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj,
-				  dev_name(dev));
-#else
+#ifdef CONFIG_SYSFS_DEPRECATED
+	/* /sys/block has directories and does not need symlinks */
+	if (dev->class == &block_class)
+		return 0;
+#endif
+
 	/* link in the class directory pointing to the device */
 	error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
 				  &dev->kobj, dev_name(dev));
 	if (error)
-		goto out_subsys;
+		goto out_device;
 
-	if (dev->parent && device_is_not_partition(dev)) {
-		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
-					  "device");
-		if (error)
-			goto out_busid;
-	}
 	return 0;
 
-out_busid:
-	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
-#endif
+out_device:
+	sysfs_remove_link(&dev->kobj, "device");
 
 out_subsys:
 	sysfs_remove_link(&dev->kobj, "subsystem");
@@ -818,30 +735,14 @@ static void device_remove_class_symlinks(struct device *dev)
 	if (!dev->class)
 		return;
 
-#ifdef CONFIG_SYSFS_DEPRECATED
-	if (dev->parent && device_is_not_partition(dev)) {
-		char *class_name;
-
-		class_name = make_class_name(dev->class->name, &dev->kobj);
-		if (class_name) {
-			sysfs_remove_link(&dev->parent->kobj, class_name);
-			kfree(class_name);
-		}
-		sysfs_remove_link(&dev->kobj, "device");
-	}
-
-	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
-	    device_is_not_partition(dev))
-		sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj,
-				  dev_name(dev));
-#else
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
-
-	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
-#endif
-
 	sysfs_remove_link(&dev->kobj, "subsystem");
+#ifdef CONFIG_SYSFS_DEPRECATED
+	if (dev->class == &block_class)
+		return;
+#endif
+	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
 }
 
 /**
@@ -1613,41 +1514,23 @@ int device_rename(struct device *dev, const char *new_name)
 	pr_debug("device: '%s': %s: renaming to '%s'\n", dev_name(dev),
 		 __func__, new_name);
 
-#ifdef CONFIG_SYSFS_DEPRECATED
-	if ((dev->class) && (dev->parent))
-		old_class_name = make_class_name(dev->class->name, &dev->kobj);
-#endif
-
 	old_device_name = kstrdup(dev_name(dev), GFP_KERNEL);
 	if (!old_device_name) {
 		error = -ENOMEM;
 		goto out;
 	}
 
-#ifndef CONFIG_SYSFS_DEPRECATED
 	if (dev->class) {
 		error = sysfs_rename_link(&dev->class->p->class_subsys.kobj,
 			&dev->kobj, old_device_name, new_name);
 		if (error)
 			goto out;
 	}
-#endif
+
 	error = kobject_rename(&dev->kobj, new_name);
 	if (error)
 		goto out;
 
-#ifdef CONFIG_SYSFS_DEPRECATED
-	if (old_class_name) {
-		new_class_name = make_class_name(dev->class->name, &dev->kobj);
-		if (new_class_name) {
-			error = sysfs_rename_link(&dev->parent->kobj,
-						  &dev->kobj,
-						  old_class_name,
-						  new_class_name);
-		}
-	}
-#endif
-
 out:
 	put_device(dev);
 
@@ -1664,40 +1547,13 @@ static int device_move_class_links(struct device *dev,
 				   struct device *new_parent)
 {
 	int error = 0;
-#ifdef CONFIG_SYSFS_DEPRECATED
-	char *class_name;
 
-	class_name = make_class_name(dev->class->name, &dev->kobj);
-	if (!class_name) {
-		error = -ENOMEM;
-		goto out;
-	}
-	if (old_parent) {
-		sysfs_remove_link(&dev->kobj, "device");
-		sysfs_remove_link(&old_parent->kobj, class_name);
-	}
-	if (new_parent) {
-		error = sysfs_create_link(&dev->kobj, &new_parent->kobj,
-					  "device");
-		if (error)
-			goto out;
-		error = sysfs_create_link(&new_parent->kobj, &dev->kobj,
-					  class_name);
-		if (error)
-			sysfs_remove_link(&dev->kobj, "device");
-	} else
-		error = 0;
-out:
-	kfree(class_name);
-	return error;
-#else
 	if (old_parent)
 		sysfs_remove_link(&dev->kobj, "device");
 	if (new_parent)
 		error = sysfs_create_link(&dev->kobj, &new_parent->kobj,
 					  "device");
 	return error;
-#endif
 }
 
 /**

commit fb8231a8b139035476f2a8aaac837d0099b66dad
Merge: 426d31071ac4 f6cec0ae58c1
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Aug 10 13:22:08 2010 +0200

    Merge branch 'master' into for-next
    
    Conflicts:
            arch/arm/mach-omap1/board-nokia770.c

commit eef35c2d41ddcc653c20d26b977acaa45c811e1f
Author: Stefan Weil <weil@mail.berlios.de>
Date:   Fri Aug 6 21:11:15 2010 +0200

    Fix spelling fuction -> function in comments
    
    To avoid more patches, I also fixed other spelling
    and grammar bugs when they were in the same or
    following line:
    
    successfull -> successful
    parse -> parses
    controler -> controller
    controlers -> controllers
    
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Stefan Weil <weil@mail.berlios.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f8e72724dd4b..74707b88f116 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -251,7 +251,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 				 __func__, retval);
 	}
 
-	/* have the device type specific fuction add its stuff */
+	/* have the device type specific function add its stuff */
 	if (dev->type && dev->type->uevent) {
 		retval = dev->type->uevent(dev, env);
 		if (retval)

commit 6937e8f8c0135f2325194c372ada6dc655499992
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Aug 5 17:38:18 2010 +0200

    driver core: device_rename's new_name can be const
    
    The new_name argument to device_rename() can be
    const as kobject_rename's new_name argument is.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f8e72724dd4b..d1b2c9adc271 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1599,7 +1599,7 @@ EXPORT_SYMBOL_GPL(device_destroy);
  * on the same device to ensure that new_name is valid and
  * won't conflict with other devices.
  */
-int device_rename(struct device *dev, char *new_name)
+int device_rename(struct device *dev, const char *new_name)
 {
 	char *old_class_name = NULL;
 	char *new_class_name = NULL;

commit 6ba74014c1ab0e37af7de6f64b4eccbbae3cb9e7
Merge: 5abd9ccced7a 3ff1c25927e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 4 11:47:58 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1443 commits)
      phy/marvell: add 88ec048 support
      igb: Program MDICNFG register prior to PHY init
      e1000e: correct MAC-PHY interconnect register offset for 82579
      hso: Add new product ID
      can: Add driver for esd CAN-USB/2 device
      l2tp: fix export of header file for userspace
      can-raw: Fix skb_orphan_try handling
      Revert "net: remove zap_completion_queue"
      net: cleanup inclusion
      phy/marvell: add 88e1121 interface mode support
      u32: negative offset fix
      net: Fix a typo from "dev" to "ndev"
      igb: Use irq_synchronize per vector when using MSI-X
      ixgbevf: fix null pointer dereference due to filter being set for VLAN 0
      e1000e: Fix irq_synchronize in MSI-X case
      e1000e: register pm_qos request on hardware activation
      ip_fragment: fix subtracting PPPOE_SES_HLEN from mtu twice
      net: Add getsockopt support for TCP thin-streams
      cxgb4: update driver version
      cxgb4: add new PCI IDs
      ...
    
    Manually fix up conflicts in:
     - drivers/net/e1000e/netdev.c: due to pm_qos registration
       infrastructure changes
     - drivers/net/phy/marvell.c: conflict between adding 88ec048 support
       and cleaning up the IDs
     - drivers/net/wireless/ipw2x00/ipw2100.c: trivial ipw2100_pm_qos_req
       conflict (registration change vs marking it static)

commit 24b1442d01ae155ea716dfb94ed21605541c317d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jul 24 22:43:35 2010 -0700

    Driver-core: Always create class directories for classses that support namespaces.
    
    This fixes the regression in 2.6.35-rcX where bluetooth network devices
    would fail to be deleted from sysfs, causing their destruction and
    recreation to fail.  In addition this fixes the mac80211_hwsim driver
    where it would leave around sysfs files when the driver was removed.
    
    This problem is discussed at
      https://bugzilla.kernel.org/show_bug.cgi?id=16257
    
    The reason for the regression is that the network namespace support
    added to sysfs expects and requires that network devices be put in
    directories that can contain only network devices.
    
    Today get_device_parent almost provides that guarantee for all class
    devices, except for a specific exception when the parent of a class
    devices is a class device.  It would be nice to simply remove that
    arguably incorrect special case, but apparently the input devices depend
    on it being there.  So I have only removed it for class devices with
    network namespace support.  Which today are the network devices.
    
    It has been suggested that a better fix would be to change the parent
    device from a class device to a bus device, which in the case of the
    bluetooth driver would change /sys/class/bluetooth to /sys/bus/bluetoth,
    I can not see how we would avoid significant userspace breakage if we
    were to make that change.
    
    Adding an extra directory in the path to the device will also be
    userspace visible but it is much less likely to break things.
    Everything is still accessible from /sys/class (for example), and it
    fixes two bugs.  Adding an extra directory fixes a 3 year old regression
    introduced with the new sysfs layout that makes it impossible to rename
    bnep0 network devices to names that conflict with hci device attributes
    like hci_revsion.  Adding an additional directory removes the new
    failure modes introduced by the network namespace code.
    
    If it weren't for the regession in the renaming of network devices I
    would figure out how to just make the sysfs code deal with this
    configuration of devices.
    
    In summary this patch fixes regressions by changing:
    "/sys/class/bluetooth/hci0/bnep0" to "/sys/class/bluetooth/hci0/net/bnep0".
    
    Reported-by: Johannes Berg <johannes@sipsolutions.net>
    Reported-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9630fbdf4e6c..9b9d3bd54e3a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -673,7 +673,7 @@ static struct kobject *get_device_parent(struct device *dev,
 		 */
 		if (parent == NULL)
 			parent_kobj = virtual_device_parent(dev);
-		else if (parent->class)
+		else if (parent->class && !dev->class->ns_type)
 			return &parent->kobj;
 		else
 			parent_kobj = &parent->kobj;

commit 99bcf217183e02ebae46373896fba7f12d588001
Author: Joe Perches <joe@perches.com>
Date:   Sun Jun 27 01:02:34 2010 +0000

    device.h drivers/base/core.c Convert dev_<level> logging macros to functions
    
    Reduces an x86 defconfig text and data ~55k, .6% smaller.
    
    $ size vmlinux*
       text    data     bss     dec     hex filename
    7205273  716016 1366288 9287577  8db799 vmlinux
    7258890  719768 1366288 9344946  8e97b2 vmlinux.master
    
    Uses %pV and struct va_format
    Format arguments are verified before printk
    
    The dev_info macro is converted to _dev_info because there are
    existing uses of variables named dev_info in the kernel tree
    like drivers/net/pcmcia/pcnet_cs.c
    
    A dev_info macro is created to call _dev_info
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9630fbdf4e6c..38bbbd029306 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1819,3 +1819,67 @@ void device_shutdown(void)
 	spin_unlock(&devices_kset->list_lock);
 	async_synchronize_full();
 }
+
+/*
+ * Device logging functions
+ */
+
+#ifdef CONFIG_PRINTK
+
+static int __dev_printk(const char *level, const struct device *dev,
+			struct va_format *vaf)
+{
+	if (!dev)
+		return printk("%s(NULL device *): %pV", level, vaf);
+
+	return printk("%s%s %s: %pV",
+		      level, dev_driver_string(dev), dev_name(dev), vaf);
+}
+
+int dev_printk(const char *level, const struct device *dev,
+	       const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	int r;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	r = __dev_printk(level, dev, &vaf);
+	va_end(args);
+
+	return r;
+}
+EXPORT_SYMBOL(dev_printk);
+
+#define define_dev_printk_level(func, kern_level)		\
+int func(const struct device *dev, const char *fmt, ...)	\
+{								\
+	struct va_format vaf;					\
+	va_list args;						\
+	int r;							\
+								\
+	va_start(args, fmt);					\
+								\
+	vaf.fmt = fmt;						\
+	vaf.va = &args;						\
+								\
+	r = __dev_printk(kern_level, dev, &vaf);		\
+	va_end(args);						\
+								\
+	return r;						\
+}								\
+EXPORT_SYMBOL(func);
+
+define_dev_printk_level(dev_emerg, KERN_EMERG);
+define_dev_printk_level(dev_alert, KERN_ALERT);
+define_dev_printk_level(dev_crit, KERN_CRIT);
+define_dev_printk_level(dev_err, KERN_ERR);
+define_dev_printk_level(dev_warn, KERN_WARNING);
+define_dev_printk_level(dev_notice, KERN_NOTICE);
+define_dev_printk_level(_dev_info, KERN_INFO);
+
+#endif

commit 1d9e882ba4971f31473dd812da64909f30a6c242
Author: Christoph Egger <siccegge@cs.fau.de>
Date:   Mon May 17 16:57:58 2010 +0200

    driver-core: fix Typo in drivers/base/core.c for CONFIG_MODULE
    
    In this code section the final S of CONFIG_MODULES was missed making
    the whole check useless
    
    Signed-off-by: Christoph Egger <siccegge@cs.fau.de>
    Cc: Mark McLoughlin <markmc@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 17e7d5048b83..9630fbdf4e6c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1420,7 +1420,7 @@ struct device *__root_device_register(const char *name, struct module *owner)
 		return ERR_PTR(err);
 	}
 
-#ifdef CONFIG_MODULE	/* gotta find a "cleaner" way to do this */
+#ifdef CONFIG_MODULES	/* gotta find a "cleaner" way to do this */
 	if (owner) {
 		struct module_kobject *mk = &owner->mkobj;
 

commit f349cf34731c3b3eddbcd63cb04489aee2c405bd
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 30 11:31:29 2010 -0700

    driver core: Implement ns directory support for device classes.
    
    device_del and device_rename were modified to use
    sysfs_delete_link and sysfs_rename_link respectively to ensure
    when these operations happen on devices whose classes
    are in namespace directories they work properly.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f0699918e2f6..17e7d5048b83 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -786,7 +786,7 @@ static int device_add_class_symlinks(struct device *dev)
 out_busid:
 	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev))
-		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
+		sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj,
 				  dev_name(dev));
 #else
 	/* link in the class directory pointing to the device */
@@ -804,7 +804,7 @@ static int device_add_class_symlinks(struct device *dev)
 	return 0;
 
 out_busid:
-	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev_name(dev));
+	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
 #endif
 
 out_subsys:
@@ -832,13 +832,13 @@ static void device_remove_class_symlinks(struct device *dev)
 
 	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev))
-		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
+		sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj,
 				  dev_name(dev));
 #else
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 
-	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev_name(dev));
+	sysfs_delete_link(&dev->class->p->class_subsys.kobj, &dev->kobj, dev_name(dev));
 #endif
 
 	sysfs_remove_link(&dev->kobj, "subsystem");
@@ -1624,6 +1624,14 @@ int device_rename(struct device *dev, char *new_name)
 		goto out;
 	}
 
+#ifndef CONFIG_SYSFS_DEPRECATED
+	if (dev->class) {
+		error = sysfs_rename_link(&dev->class->p->class_subsys.kobj,
+			&dev->kobj, old_device_name, new_name);
+		if (error)
+			goto out;
+	}
+#endif
 	error = kobject_rename(&dev->kobj, new_name);
 	if (error)
 		goto out;
@@ -1638,11 +1646,6 @@ int device_rename(struct device *dev, char *new_name)
 						  new_class_name);
 		}
 	}
-#else
-	if (dev->class) {
-		error = sysfs_rename_link(&dev->class->p->class_subsys.kobj,
-					  &dev->kobj, old_device_name, new_name);
-	}
 #endif
 
 out:

commit bc451f2058238013e1cdf4acd443c01734d332f0
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 30 11:31:25 2010 -0700

    kobj: Add basic infrastructure for dealing with namespaces.
    
    Move complete knowledge of namespaces into the kobject layer
    so we can use that information when reporting kobjects to
    userspace.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 356dd011b8f9..f0699918e2f6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -131,9 +131,21 @@ static void device_release(struct kobject *kobj)
 	kfree(p);
 }
 
+static const void *device_namespace(struct kobject *kobj)
+{
+	struct device *dev = to_dev(kobj);
+	const void *ns = NULL;
+
+	if (dev->class && dev->class->ns_type)
+		ns = dev->class->namespace(dev);
+
+	return ns;
+}
+
 static struct kobj_type device_ktype = {
 	.release	= device_release,
 	.sysfs_ops	= &dev_sysfs_ops,
+	.namespace	= device_namespace,
 };
 
 
@@ -595,11 +607,59 @@ static struct kobject *virtual_device_parent(struct device *dev)
 	return virtual_dir;
 }
 
-static struct kobject *get_device_parent(struct device *dev,
-					 struct device *parent)
+struct class_dir {
+	struct kobject kobj;
+	struct class *class;
+};
+
+#define to_class_dir(obj) container_of(obj, struct class_dir, kobj)
+
+static void class_dir_release(struct kobject *kobj)
+{
+	struct class_dir *dir = to_class_dir(kobj);
+	kfree(dir);
+}
+
+static const
+struct kobj_ns_type_operations *class_dir_child_ns_type(struct kobject *kobj)
 {
+	struct class_dir *dir = to_class_dir(kobj);
+	return dir->class->ns_type;
+}
+
+static struct kobj_type class_dir_ktype = {
+	.release	= class_dir_release,
+	.sysfs_ops	= &kobj_sysfs_ops,
+	.child_ns_type	= class_dir_child_ns_type
+};
+
+static struct kobject *
+class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)
+{
+	struct class_dir *dir;
 	int retval;
 
+	dir = kzalloc(sizeof(*dir), GFP_KERNEL);
+	if (!dir)
+		return NULL;
+
+	dir->class = class;
+	kobject_init(&dir->kobj, &class_dir_ktype);
+
+	dir->kobj.kset = &class->p->class_dirs;
+
+	retval = kobject_add(&dir->kobj, parent_kobj, "%s", class->name);
+	if (retval < 0) {
+		kobject_put(&dir->kobj);
+		return NULL;
+	}
+	return &dir->kobj;
+}
+
+
+static struct kobject *get_device_parent(struct device *dev,
+					 struct device *parent)
+{
 	if (dev->class) {
 		static DEFINE_MUTEX(gdp_mutex);
 		struct kobject *kobj = NULL;
@@ -634,18 +694,7 @@ static struct kobject *get_device_parent(struct device *dev,
 		}
 
 		/* or create a new class-directory at the parent device */
-		k = kobject_create();
-		if (!k) {
-			mutex_unlock(&gdp_mutex);
-			return NULL;
-		}
-		k->kset = &dev->class->p->class_dirs;
-		retval = kobject_add(k, parent_kobj, "%s", dev->class->name);
-		if (retval < 0) {
-			mutex_unlock(&gdp_mutex);
-			kobject_put(k);
-			return NULL;
-		}
+		k = class_dir_create_and_add(dev->class, parent_kobj);
 		/* do not emit an uevent for this simple "glue" directory */
 		mutex_unlock(&gdp_mutex);
 		return k;

commit 6245838fe4d2ce4aab52f543224f7d1212d9155c
Author: Hugh Daschbach <hdasch@broadcom.com>
Date:   Mon Mar 22 10:36:37 2010 -0700

    Driver core: Protect device shutdown from hot unplug events.
    
    While device_shutdown() walks through devices_kset to shutdown all
    devices, device unplug events may race to shutdown individual devices.
    Specifically, sd_shutdown(), on behalf of fc_starget_delete(), has
    been observed deleting devices during device_shutdown()'s list
    traversal.  So we factor out list_for_each_entry_safe_reverse(...) in
    favor of while (!list_empty(...)).
    
    Signed-off-by: Hugh Daschbach <hdasch@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4c5be85016b6..356dd011b8f9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1734,10 +1734,25 @@ EXPORT_SYMBOL_GPL(device_move);
  */
 void device_shutdown(void)
 {
-	struct device *dev, *devn;
+	struct device *dev;
+
+	spin_lock(&devices_kset->list_lock);
+	/*
+	 * Walk the devices list backward, shutting down each in turn.
+	 * Beware that device unplug events may also start pulling
+	 * devices offline, even as the system is shutting down.
+	 */
+	while (!list_empty(&devices_kset->list)) {
+		dev = list_entry(devices_kset->list.prev, struct device,
+				kobj.entry);
+		get_device(dev);
+		/*
+		 * Make sure the device is off the kset list, in the
+		 * event that dev->*->shutdown() doesn't remove it.
+		 */
+		list_del_init(&dev->kobj.entry);
+		spin_unlock(&devices_kset->list_lock);
 
-	list_for_each_entry_safe_reverse(dev, devn, &devices_kset->list,
-				kobj.entry) {
 		if (dev->bus && dev->bus->shutdown) {
 			dev_dbg(dev, "shutdown\n");
 			dev->bus->shutdown(dev);
@@ -1745,6 +1760,10 @@ void device_shutdown(void)
 			dev_dbg(dev, "shutdown\n");
 			dev->driver->shutdown(dev);
 		}
+		put_device(dev);
+
+		spin_lock(&devices_kset->list_lock);
 	}
+	spin_unlock(&devices_kset->list_lock);
 	async_synchronize_full();
 }

commit 1704f47b50b5d9e1b825e43e1baaf2c5897baf03
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Mar 19 01:37:42 2010 +0100

    lockdep: Add novalidate class for dev->mutex conversion
    
    The conversion of device->sem to device->mutex resulted in lockdep
    warnings. Create a novalidate class for now until the driver folks
    come up with separate classes. That way we have at least the basic
    mutex debugging coverage.
    
    Add a checkpatch error so the usage is reserved for device->mutex.
    
    [ tglx: checkpatch and compile fix for LOCKDEP=n ]
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index cf507a7d200c..4c5be85016b6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -559,6 +559,7 @@ void device_initialize(struct device *dev)
 	kobject_init(&dev->kobj, &device_ktype);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	mutex_init(&dev->mutex);
+	lockdep_set_novalidate_class(&dev->mutex);
 	spin_lock_init(&dev->devres_lock);
 	INIT_LIST_HEAD(&dev->devres_head);
 	device_pm_init(dev);

commit 3142788b7967ccfd2f1813ee9e11aeb1e1cf7de2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jan 29 20:39:02 2010 +0000

    drivers/base: Convert dev->sem to mutex
    
    The semaphore is semantically a mutex. Convert it to a real mutex and
    fix up a few places where code was relying on semaphore.h to be included
    by device.h, as well as the users of the trylock function, as that value
    is now reversed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e11c8c3e7416..cf507a7d200c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -20,7 +20,6 @@
 #include <linux/notifier.h>
 #include <linux/genhd.h>
 #include <linux/kallsyms.h>
-#include <linux/semaphore.h>
 #include <linux/mutex.h>
 #include <linux/async.h>
 
@@ -559,7 +558,7 @@ void device_initialize(struct device *dev)
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
 	INIT_LIST_HEAD(&dev->dma_pools);
-	init_MUTEX(&dev->sem);
+	mutex_init(&dev->mutex);
 	spin_lock_init(&dev->devres_lock);
 	INIT_LIST_HEAD(&dev->devres_head);
 	device_pm_init(dev);

commit ffa156590f98b750161757a16c37ac8e152a7859
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 8 16:46:19 2010 -0500

    Driver core: don't initialize wakeup flags
    
    This patch (as1351) removes an unnecessary and unwanted assignment
    from device_initialize().  The wakeup flags are set to 0 along with
    everything else when the device structure is allocated, so we don't
    need to do it again.  Furthermore, the subsystem might already have
    set these flags to their correct values; we don't want to override it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b56a0ba31d4a..e11c8c3e7416 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -562,7 +562,6 @@ void device_initialize(struct device *dev)
 	init_MUTEX(&dev->sem);
 	spin_lock_init(&dev->devres_lock);
 	INIT_LIST_HEAD(&dev->devres_head);
-	device_init_wakeup(dev, 0);
 	device_pm_init(dev);
 	set_dev_node(dev, -1);
 }

commit f0eae0ed3b7d4182a6b4dd03540a738518ea3163
Author: Jani Nikula <ext-jani.1.nikula@nokia.com>
Date:   Thu Mar 11 18:11:45 2010 +0200

    driver-core: document ERR_PTR() return values
    
    A number of functions in the driver core return ERR_PTR() values on
    error. Document this in the kernel-doc of the functions.
    
    Signed-off-by: Jani Nikula <ext-jani.1.nikula@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ef55df34ddd0..b56a0ba31d4a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1345,6 +1345,8 @@ static void root_device_release(struct device *dev)
  * 'module' symlink which points to the @owner directory
  * in sysfs.
  *
+ * Returns &struct device pointer on success, or ERR_PTR() on error.
+ *
  * Note: You probably want to use root_device_register().
  */
 struct device *__root_device_register(const char *name, struct module *owner)
@@ -1432,6 +1434,8 @@ static void device_create_release(struct device *dev)
  * Any further sysfs files that might be required can be created using this
  * pointer.
  *
+ * Returns &struct device pointer on success, or ERR_PTR() on error.
+ *
  * Note: the struct class passed to this function must have previously
  * been created with a call to class_create().
  */
@@ -1492,6 +1496,8 @@ EXPORT_SYMBOL_GPL(device_create_vargs);
  * Any further sysfs files that might be required can be created using this
  * pointer.
  *
+ * Returns &struct device pointer on success, or ERR_PTR() on error.
+ *
  * Note: the struct class passed to this function must have previously
  * been created with a call to class_create().
  */

commit 2354dcc7218853a6537ec722be40fde9a11c413b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 12 19:22:26 2010 -0800

    driver core: Use sysfs_rename_link in device_rename
    
    Don't open code the renaming of symlinks in sysfs
    instead use the new helper function sysfs_rename_link
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Eric W. Biederman <ebiederm@aristanetworks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b0d6646a2814..ef55df34ddd0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1578,22 +1578,16 @@ int device_rename(struct device *dev, char *new_name)
 	if (old_class_name) {
 		new_class_name = make_class_name(dev->class->name, &dev->kobj);
 		if (new_class_name) {
-			error = sysfs_create_link_nowarn(&dev->parent->kobj,
-							 &dev->kobj,
-							 new_class_name);
-			if (error)
-				goto out;
-			sysfs_remove_link(&dev->parent->kobj, old_class_name);
+			error = sysfs_rename_link(&dev->parent->kobj,
+						  &dev->kobj,
+						  old_class_name,
+						  new_class_name);
 		}
 	}
 #else
 	if (dev->class) {
-		error = sysfs_create_link_nowarn(&dev->class->p->class_subsys.kobj,
-						 &dev->kobj, dev_name(dev));
-		if (error)
-			goto out;
-		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
-				  old_device_name);
+		error = sysfs_rename_link(&dev->class->p->class_subsys.kobj,
+					  &dev->kobj, old_device_name, new_name);
 	}
 #endif
 

commit 52cf25d0ab7f78eeecc59ac652ed5090f69b619e
Author: Emese Revfy <re.emese@gmail.com>
Date:   Tue Jan 19 02:58:23 2010 +0100

    Driver core: Constify struct sysfs_ops in struct kobj_type
    
    Constify struct sysfs_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Acked-by: David Teigland <teigland@redhat.com>
    Acked-by: Matt Domsch <Matt_Domsch@dell.com>
    Acked-by: Maciej Sosnowski <maciej.sosnowski@intel.com>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 58ec1069f4b0..b0d6646a2814 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -100,7 +100,7 @@ static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,
 	return ret;
 }
 
-static struct sysfs_ops dev_sysfs_ops = {
+static const struct sysfs_ops dev_sysfs_ops = {
 	.show	= dev_attr_show,
 	.store	= dev_attr_store,
 };

commit 9cd43611ccfb46632bfa7d19f688924ea93f1613
Author: Emese Revfy <re.emese@gmail.com>
Date:   Thu Dec 31 14:52:51 2009 +0100

    kobject: Constify struct kset_uevent_ops
    
    Constify struct kset_uevent_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f6c73a9e3d95..58ec1069f4b0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -252,7 +252,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	return retval;
 }
 
-static struct kset_uevent_ops device_uevent_ops = {
+static const struct kset_uevent_ops device_uevent_ops = {
 	.filter =	dev_uevent_filter,
 	.name =		dev_uevent_name,
 	.uevent =	dev_uevent,

commit 3f5468c9ae293cbca43e4ffe6ca3b3235189042a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Jan 14 22:54:37 2010 +0100

    Driver-Core: require valid action string in uevent trigger
    
    No longer fall back to "add" and warn, but always require a valid
    action-string written to the "uevent" file.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fb4bc4f5151c..f6c73a9e3d95 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -306,15 +306,10 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 {
 	enum kobject_action action;
 
-	if (kobject_action_type(buf, count, &action) == 0) {
+	if (kobject_action_type(buf, count, &action) == 0)
 		kobject_uevent(&dev->kobj, action);
-		goto out;
-	}
-
-	dev_err(dev, "uevent: unsupported action-string; this will "
-		     "be ignored in a future kernel version\n");
-	kobject_uevent(&dev->kobj, KOBJ_ADD);
-out:
+	else
+		dev_err(dev, "uevent: unknown action-string\n");
 	return count;
 }
 

commit 77d3d7c1d561f49f755d7390f0764dff90765974
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Feb 5 17:57:02 2010 +0900

    driver-core: fix race condition in get_device_parent()
    
    sysfs is creating several devices in cuse class concurrently and with
    CONFIG_SYSFS_DEPRECATED turned off, it triggers the following oops.
    
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000038
     IP: [<ffffffff81158b0a>] sysfs_addrm_start+0x4a/0xf0
     PGD 75bb067 PUD 75be067 PMD 0
     Oops: 0000 [#1] PREEMPT SMP
     last sysfs file: /sys/devices/system/cpu/cpu7/topology/core_siblings
     CPU 1
     Modules linked in: cuse fuse
     Pid: 4737, comm: osspd Not tainted 2.6.31-work #77
     RIP: 0010:[<ffffffff81158b0a>]  [<ffffffff81158b0a>] sysfs_addrm_start+0x4a/0xf0
     RSP: 0018:ffff88000042f8f8  EFLAGS: 00010296
     RAX: ffff88000042ffd8 RBX: 0000000000000000 RCX: 0000000000000000
     RDX: 0000000000000000 RSI: ffff880007eef660 RDI: 0000000000000001
     RBP: ffff88000042f918 R08: 0000000000000000 R09: 0000000000000000
     R10: 0000000000000001 R11: ffffffff81158b0a R12: ffff88000042f928
     R13: 00000000fffffff4 R14: 0000000000000000 R15: ffff88000042f9a0
     FS:  00007fe93905a950(0000) GS:ffff880008600000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: 0000000000000038 CR3: 00000000077c9000 CR4: 00000000000006e0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Process osspd (pid: 4737, threadinfo ffff88000042e000, task ffff880007eef040)
     Stack:
      ffff880005da10e8 0000000011cc8d6e ffff88000042f928 ffff880003d28a28
     <0> ffff88000042f988 ffffffff811592d7 0000000000000000 0000000000000000
     <0> 0000000000000000 0000000000000000 ffff88000042f958 0000000011cc8d6e
     Call Trace:
      [<ffffffff811592d7>] create_dir+0x67/0xe0
      [<ffffffff811593a8>] sysfs_create_dir+0x58/0xb0
      [<ffffffff8128ca7c>] ? kobject_add_internal+0xcc/0x220
      [<ffffffff812942e1>] ? vsnprintf+0x3c1/0xb90
      [<ffffffff8128cab7>] kobject_add_internal+0x107/0x220
      [<ffffffff8128cd37>] kobject_add_varg+0x47/0x80
      [<ffffffff8128ce53>] kobject_add+0x53/0x90
      [<ffffffff81357d84>] device_add+0xd4/0x690
      [<ffffffff81356c2b>] ? dev_set_name+0x4b/0x70
      [<ffffffffa001a884>] cuse_process_init_reply+0x2b4/0x420 [cuse]
      ...
    
    The problem is that kobject_add_internal() first adds a kobject to the
    kset and then try to create sysfs directory for it.  If the creation
    fails, it remove the kobject from the kset.  get_device_parent()
    accesses class_dirs kset while only holding class_dirs.list_lock to
    see whether the cuse class dir exists.  But when it exists, it may not
    have finished initialization yet or may fail and get removed soon.  In
    the above case, the former happened so the second one ends up trying
    to create subdirectory under NULL sysfs_dirent.
    
    Fix it by grabbing a mutex in get_device_parent().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Colin Guthrie <cguthrie@mandriva.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 282025770429..fb4bc4f5151c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -607,6 +607,7 @@ static struct kobject *get_device_parent(struct device *dev,
 	int retval;
 
 	if (dev->class) {
+		static DEFINE_MUTEX(gdp_mutex);
 		struct kobject *kobj = NULL;
 		struct kobject *parent_kobj;
 		struct kobject *k;
@@ -623,6 +624,8 @@ static struct kobject *get_device_parent(struct device *dev,
 		else
 			parent_kobj = &parent->kobj;
 
+		mutex_lock(&gdp_mutex);
+
 		/* find our class-directory at the parent and reference it */
 		spin_lock(&dev->class->p->class_dirs.list_lock);
 		list_for_each_entry(k, &dev->class->p->class_dirs.list, entry)
@@ -631,20 +634,26 @@ static struct kobject *get_device_parent(struct device *dev,
 				break;
 			}
 		spin_unlock(&dev->class->p->class_dirs.list_lock);
-		if (kobj)
+		if (kobj) {
+			mutex_unlock(&gdp_mutex);
 			return kobj;
+		}
 
 		/* or create a new class-directory at the parent device */
 		k = kobject_create();
-		if (!k)
+		if (!k) {
+			mutex_unlock(&gdp_mutex);
 			return NULL;
+		}
 		k->kset = &dev->class->p->class_dirs;
 		retval = kobject_add(k, parent_kobj, "%s", dev->class->name);
 		if (retval < 0) {
+			mutex_unlock(&gdp_mutex);
 			kobject_put(k);
 			return NULL;
 		}
 		/* do not emit an uevent for this simple "glue" directory */
+		mutex_unlock(&gdp_mutex);
 		return k;
 	}
 

commit e6309e7568d4b9d62298a887b10de42df11cb8c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 10 19:32:49 2009 +0000

    Driver-core: Fix bogus 0 error return in device_add()
    
    If device_add() is called with a device which does not have dev->p set
    up, then device_private_init() is called. If that succeeds, then the
    error variable is set to 0. Now if the dev_name(dev) check further
    down fails, then device_add() correctly terminates, but returns 0.
    That of course lets the driver progress. If later another driver uses
    this half set up device as parent then device_add() of the child
    device explodes and renders sysfs completely unusable.
    
    Set the error to -EINVAL if dev_name() check fails.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: "Hans J. Koch" <hjk@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 83afc8b8f27b..282025770429 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -909,8 +909,10 @@ int device_add(struct device *dev)
 		dev->init_name = NULL;
 	}
 
-	if (!dev_name(dev))
+	if (!dev_name(dev)) {
+		error = -EINVAL;
 		goto name_error;
+	}
 
 	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
 

commit 66ecb92be9eb579df93add22d19843e7869f168e
Author: Phil Carmody <ext-phil.2.carmody@nokia.com>
Date:   Fri Dec 18 15:34:20 2009 +0200

    Driver core: bin_attribute parameters can often be const*
    
    Many struct bin_attribute descriptors are purely read-only
    structures, and there's no need to change them. Therefore
    make the promise not to, which will let those descriptors
    be put in a ro section.
    
    Signed-off-by: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2fd9e611f8a6..83afc8b8f27b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -472,7 +472,8 @@ void device_remove_file(struct device *dev,
  * @dev: device.
  * @attr: device binary attribute descriptor.
  */
-int device_create_bin_file(struct device *dev, struct bin_attribute *attr)
+int device_create_bin_file(struct device *dev,
+			   const struct bin_attribute *attr)
 {
 	int error = -EINVAL;
 	if (dev)
@@ -486,7 +487,8 @@ EXPORT_SYMBOL_GPL(device_create_bin_file);
  * @dev: device.
  * @attr: device binary attribute descriptor.
  */
-void device_remove_bin_file(struct device *dev, struct bin_attribute *attr)
+void device_remove_bin_file(struct device *dev,
+			    const struct bin_attribute *attr)
 {
 	if (dev)
 		sysfs_remove_bin_file(&dev->kobj, attr);

commit 26579ab70aa0e0ea434e6e100279d2f67c094431
Author: Phil Carmody <ext-phil.2.carmody@nokia.com>
Date:   Fri Dec 18 15:34:19 2009 +0200

    Driver core: device_attribute parameters can often be const*
    
    Most device_attributes are const, and are begging to be
    put in a ro section. However, the create and remove
    file interfaces were failing to propagate the const promise
    which the only functions they call offer.
    
    Signed-off-by: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f1290cbd1350..2fd9e611f8a6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -446,7 +446,8 @@ struct kset *devices_kset;
  * @dev: device.
  * @attr: device attribute descriptor.
  */
-int device_create_file(struct device *dev, struct device_attribute *attr)
+int device_create_file(struct device *dev,
+		       const struct device_attribute *attr)
 {
 	int error = 0;
 	if (dev)
@@ -459,7 +460,8 @@ int device_create_file(struct device *dev, struct device_attribute *attr)
  * @dev: device.
  * @attr: device attribute descriptor.
  */
-void device_remove_file(struct device *dev, struct device_attribute *attr)
+void device_remove_file(struct device *dev,
+			const struct device_attribute *attr)
 {
 	if (dev)
 		sysfs_remove_file(&dev->kobj, &attr->attr);

commit 3589972e51fac1e02d0aaa576fa47f568cb94d40
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Dec 4 11:06:57 2009 -0500

    Driver core: fix race in dev_driver_string
    
    This patch (as1310) works around a race in dev_driver_string().  If
    the device is unbound while the function is running, dev->driver might
    become NULL after we test it and before we dereference it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Cc: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 353b13782165..f1290cbd1350 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -56,7 +56,14 @@ static inline int device_is_not_partition(struct device *dev)
  */
 const char *dev_driver_string(const struct device *dev)
 {
-	return dev->driver ? dev->driver->name :
+	struct device_driver *drv;
+
+	/* dev->driver can change to NULL underneath us because of unbinding,
+	 * so be careful about accessing it.  dev->bus and dev->class should
+	 * never change once they are set, so they don't need special care.
+	 */
+	drv = ACCESS_ONCE(dev->driver);
+	return drv ? drv->name :
 			(dev->bus ? dev->bus->name :
 			(dev->class ? dev->class->name : ""));
 }

commit 18ef545e47c126abd87c013b762b5fbb574858ce
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Nov 4 02:50:28 2009 -0800

    Driver core: Don't remove kobjects in device_shutdown.
    
    device_shutdown is defined to just shutdown the hardware and to not
    clean up any kernel data structures.  Therefore don't put the kobjects
    for /sys/dev and /sys/dev/block and /sys/dev/char.
    
    This ensures we don't remove /sys/dev/block and /sys/dev/char while
    we still have symlinks from there to the actual devices.
    
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Eric W. Biederman <ebiederm@aristanetworks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0d3c29d72215..353b13782165 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1730,8 +1730,5 @@ void device_shutdown(void)
 			dev->driver->shutdown(dev);
 		}
 	}
-	kobject_put(sysfs_dev_char_kobj);
-	kobject_put(sysfs_dev_block_kobj);
-	kobject_put(dev_kobj);
 	async_synchronize_full();
 }

commit ad72956df2ce83f58be1dc4e503c78c28e414c2c
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Oct 28 19:51:37 2009 +0100

    Driver Core: devtmpfs: cleanup node on device creation error
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6bee6af8d8e1..0d3c29d72215 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -986,6 +986,8 @@ int device_add(struct device *dev)
  AttrsError:
 	device_remove_class_symlinks(dev);
  SymlinkError:
+	if (MAJOR(dev->devt))
+		devtmpfs_delete_node(dev);
 	if (MAJOR(dev->devt))
 		device_remove_sys_dev_entry(dev);
  devtattrError:

commit e454cea20bdcff10ee698d11b8882662a0153a47
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Sep 18 23:01:12 2009 +0200

    Driver-Core: extend devnode callbacks to provide permissions
    
    This allows subsytems to provide devtmpfs with non-default permissions
    for the device node. Instead of the default mode of 0600, null, zero,
    random, urandom, full, tty, ptmx now have a mode of 0666, which allows
    non-privileged processes to access standard device nodes in case no
    other userspace process applies the expected permissions.
    
    This also fixes a wrong assignment in pktcdvd and a checkpatch.pl complain.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 390e664ec1c7..6bee6af8d8e1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -166,13 +166,16 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	if (MAJOR(dev->devt)) {
 		const char *tmp;
 		const char *name;
+		mode_t mode = 0;
 
 		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
 		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
-		name = device_get_nodename(dev, &tmp);
+		name = device_get_devnode(dev, &mode, &tmp);
 		if (name) {
 			add_uevent_var(env, "DEVNAME=%s", name);
 			kfree(tmp);
+			if (mode)
+				add_uevent_var(env, "DEVMODE=%#o", mode & 0777);
 		}
 	}
 
@@ -1148,8 +1151,9 @@ static struct device *next_device(struct klist_iter *i)
 }
 
 /**
- * device_get_nodename - path of device node file
+ * device_get_devnode - path of device node file
  * @dev: device
+ * @mode: returned file access mode
  * @tmp: possibly allocated string
  *
  * Return the relative path of a possible device node.
@@ -1157,21 +1161,22 @@ static struct device *next_device(struct klist_iter *i)
  * a name. This memory is returned in tmp and needs to be
  * freed by the caller.
  */
-const char *device_get_nodename(struct device *dev, const char **tmp)
+const char *device_get_devnode(struct device *dev,
+			       mode_t *mode, const char **tmp)
 {
 	char *s;
 
 	*tmp = NULL;
 
 	/* the device type may provide a specific name */
-	if (dev->type && dev->type->nodename)
-		*tmp = dev->type->nodename(dev);
+	if (dev->type && dev->type->devnode)
+		*tmp = dev->type->devnode(dev, mode);
 	if (*tmp)
 		return *tmp;
 
 	/* the class may provide a specific name */
-	if (dev->class && dev->class->nodename)
-		*tmp = dev->class->nodename(dev);
+	if (dev->class && dev->class->devnode)
+		*tmp = dev->class->devnode(dev, mode);
 	if (*tmp)
 		return *tmp;
 

commit 2b2af54a5bb6f7e80ccf78f20084b93c398c3a8b
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Apr 30 15:23:42 2009 +0200

    Driver Core: devtmpfs - kernel-maintained tmpfs-based /dev
    
    Devtmpfs lets the kernel create a tmpfs instance called devtmpfs
    very early at kernel initialization, before any driver-core device
    is registered. Every device with a major/minor will provide a
    device node in devtmpfs.
    
    Devtmpfs can be changed and altered by userspace at any time,
    and in any way needed - just like today's udev-mounted tmpfs.
    Unmodified udev versions will run just fine on top of it, and will
    recognize an already existing kernel-created device node and use it.
    The default node permissions are root:root 0600. Proper permissions
    and user/group ownership, meaningful symlinks, all other policy still
    needs to be applied by userspace.
    
    If a node is created by devtmps, devtmpfs will remove the device node
    when the device goes away. If the device node was created by
    userspace, or the devtmpfs created node was replaced by userspace, it
    will no longer be removed by devtmpfs.
    
    If it is requested to auto-mount it, it makes init=/bin/sh work
    without any further userspace support. /dev will be fully populated
    and dynamic, and always reflect the current device state of the kernel.
    With the commonly used dynamic device numbers, it solves the problem
    where static devices nodes may point to the wrong devices.
    
    It is intended to make the initial bootup logic simpler and more robust,
    by de-coupling the creation of the inital environment, to reliably run
    userspace processes, from a complex userspace bootstrap logic to provide
    a working /dev.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Tested-By: Harald Hoyer <harald@redhat.com>
    Tested-By: Scott James Remnant <scott@ubuntu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a992985d1fab..390e664ec1c7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -929,6 +929,8 @@ int device_add(struct device *dev)
 		error = device_create_sys_dev_entry(dev);
 		if (error)
 			goto devtattrError;
+
+		devtmpfs_create_node(dev);
 	}
 
 	error = device_add_class_symlinks(dev);
@@ -1075,6 +1077,7 @@ void device_del(struct device *dev)
 	if (parent)
 		klist_del(&dev->p->knode_parent);
 	if (MAJOR(dev->devt)) {
+		devtmpfs_delete_node(dev);
 		device_remove_sys_dev_entry(dev);
 		device_remove_file(dev, &devt_attr);
 	}

commit a4dbd6740df0872cdf0a86841f75beec8381964d
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 24 10:06:31 2009 -0700

    driver model: constify attribute groups
    
    Let attribute group vectors be declared "const".  We'd
    like to let most attribute metadata live in read-only
    sections... this is a start.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 99dfe96fffcb..a992985d1fab 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -341,7 +341,7 @@ static void device_remove_attributes(struct device *dev,
 }
 
 static int device_add_groups(struct device *dev,
-			     struct attribute_group **groups)
+			     const struct attribute_group **groups)
 {
 	int error = 0;
 	int i;
@@ -361,7 +361,7 @@ static int device_add_groups(struct device *dev,
 }
 
 static void device_remove_groups(struct device *dev,
-				 struct attribute_group **groups)
+				 const struct attribute_group **groups)
 {
 	int i;
 

commit b4028437876866aba4747a655ede00f892089e14
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 11 14:16:57 2009 -0700

    Driver core: move dev_get/set_drvdata to drivers/base/dd.c
    
    No one should directly access the driver_data field, so remove the field
    and make it private.  We dynamically create the private field now if it
    is needed, to handle drivers that call get/set before they are
    registered with the driver core.
    
    Also update the copyright notices on these files while we are there.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c34774d0b9d3..99dfe96fffcb 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -843,6 +843,17 @@ static void device_remove_sys_dev_entry(struct device *dev)
 	}
 }
 
+int device_private_init(struct device *dev)
+{
+	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
+	if (!dev->p)
+		return -ENOMEM;
+	dev->p->device = dev;
+	klist_init(&dev->p->klist_children, klist_children_get,
+		   klist_children_put);
+	return 0;
+}
+
 /**
  * device_add - add device to device hierarchy.
  * @dev: device.
@@ -868,14 +879,11 @@ int device_add(struct device *dev)
 	if (!dev)
 		goto done;
 
-	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
 	if (!dev->p) {
-		error = -ENOMEM;
-		goto done;
+		error = device_private_init(dev);
+		if (error)
+			goto done;
 	}
-	dev->p->device = dev;
-	klist_init(&dev->p->klist_children, klist_children_get,
-		   klist_children_put);
 
 	/*
 	 * for statically allocated devices, which should all be converted

commit 2023c610dc54a4f4130b0494309a9bd668ca3df8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jul 30 15:27:18 2009 -0400

    Driver core: add new device to bus's list before probing
    
    This patch (as1271) affects when new devices get linked into their
    bus's list of devices.  Currently this happens after probing, and it
    doesn't happen at all if probing fails.  Clearly this is wrong,
    because at that point quite a few symbolic links have already been
    created in sysfs.  We are committed to adding the device, so it should
    be linked into the bus's list regardless.
    
    In addition, this needs to happen before the uevent announcing the new
    device gets issued.  Otherwise user programs might try to access the
    device before it has been added to the bus.
    
    To fix both these problems, the patch moves the call to
    klist_add_tail() forward from bus_attach_device() to bus_add_device().
    Since bus_attach_device() now does nothing but probe for drivers, it
    has been renamed to bus_probe_device().  And lastly, the kerneldoc is
    updated.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7ecb1938e590..c34774d0b9d3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -945,7 +945,7 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
-	bus_attach_device(dev);
+	bus_probe_device(dev);
 	if (parent)
 		klist_add_tail(&dev->p->knode_parent,
 			       &parent->p->klist_children);

commit 6fcf53acccf85b4b0d0260e66c692a341760f464
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Apr 30 15:23:42 2009 +0200

    Driver Core: add nodename callbacks
    
    This adds the nodename callback for struct class, struct device_type and
    struct device, to allow drivers to send userspace hints on the device
    name and subdirectory that should be used for it.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4d59975c24a8..7ecb1938e590 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -162,10 +162,18 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	struct device *dev = to_dev(kobj);
 	int retval = 0;
 
-	/* add the major/minor if present */
+	/* add device node properties if present */
 	if (MAJOR(dev->devt)) {
+		const char *tmp;
+		const char *name;
+
 		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
 		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
+		name = device_get_nodename(dev, &tmp);
+		if (name) {
+			add_uevent_var(env, "DEVNAME=%s", name);
+			kfree(tmp);
+		}
 	}
 
 	if (dev->type && dev->type->name)
@@ -1128,6 +1136,47 @@ static struct device *next_device(struct klist_iter *i)
 	return dev;
 }
 
+/**
+ * device_get_nodename - path of device node file
+ * @dev: device
+ * @tmp: possibly allocated string
+ *
+ * Return the relative path of a possible device node.
+ * Non-default names may need to allocate a memory to compose
+ * a name. This memory is returned in tmp and needs to be
+ * freed by the caller.
+ */
+const char *device_get_nodename(struct device *dev, const char **tmp)
+{
+	char *s;
+
+	*tmp = NULL;
+
+	/* the device type may provide a specific name */
+	if (dev->type && dev->type->nodename)
+		*tmp = dev->type->nodename(dev);
+	if (*tmp)
+		return *tmp;
+
+	/* the class may provide a specific name */
+	if (dev->class && dev->class->nodename)
+		*tmp = dev->class->nodename(dev);
+	if (*tmp)
+		return *tmp;
+
+	/* return name without allocation, tmp == NULL */
+	if (strchr(dev_name(dev), '!') == NULL)
+		return dev_name(dev);
+
+	/* replace '!' in the name with '/' */
+	*tmp = kstrdup(dev_name(dev), GFP_KERNEL);
+	if (!*tmp)
+		return NULL;
+	while ((s = strchr(*tmp, '!')))
+		s[0] = '/';
+	return *tmp;
+}
+
 /**
  * device_for_each_child - device child iterator.
  * @parent: parent struct device.

commit acc0e90fbccbc6e4d48184cba0983ea044e131af
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 2 15:39:55 2009 -0700

    driver core: fix gcc 4.3.3 warnings about string literals
    
    This removes the
            warning: format not a string literal and no format arguments
    warnings in the driver core that gcc 4.3.3 complains about.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7e8576d7822d..4d59975c24a8 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -875,7 +875,7 @@ int device_add(struct device *dev)
 	 * the name, and force the use of dev_name()
 	 */
 	if (dev->init_name) {
-		dev_set_name(dev, dev->init_name);
+		dev_set_name(dev, "%s", dev->init_name);
 		dev->init_name = NULL;
 	}
 
@@ -1272,7 +1272,7 @@ struct device *__root_device_register(const char *name, struct module *owner)
 	if (!root)
 		return ERR_PTR(err);
 
-	err = dev_set_name(&root->dev, name);
+	err = dev_set_name(&root->dev, "%s", name);
 	if (err) {
 		kfree(root);
 		return ERR_PTR(err);

commit 401097ea4b89846d66ac78f7f108d49c2e922d9c
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Tue May 12 13:37:57 2009 -0700

    driver core: synchronize device shutdown
    
    A patch series to make .shutdown execute asynchronously.  Some drivers's
    shutdown can take a lot of time.  The patches can help save some shutdown
    time.  The patches use Arjan's async API.
    
    
    This patch:
    
    synchronize all tasks submitted by .shutdown
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 1977d4beb89e..7e8576d7822d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -22,6 +22,7 @@
 #include <linux/kallsyms.h>
 #include <linux/semaphore.h>
 #include <linux/mutex.h>
+#include <linux/async.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -1665,4 +1666,5 @@ void device_shutdown(void)
 	kobject_put(sysfs_dev_char_kobj);
 	kobject_put(sysfs_dev_block_kobj);
 	kobject_put(dev_kobj);
+	async_synchronize_full();
 }

commit 5c8563d773c0e9f0ac2a552e84806decd98ce732
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu May 28 14:24:07 2009 -0700

    Driver Core: do not oops when driver_unregister() is called for unregistered drivers
    
    We also fix a problem with cleaning up properly when initializing
    drivers and devices, so checks like this will work successfully.
    
    Portions of the patch by Linus and Greg and Ingo.
    
    Reported-by: Ozan Çağlayan <ozan@pardus.org.tr>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4aa527b8a913..1977d4beb89e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -879,7 +879,7 @@ int device_add(struct device *dev)
 	}
 
 	if (!dev_name(dev))
-		goto done;
+		goto name_error;
 
 	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
 
@@ -978,6 +978,9 @@ int device_add(struct device *dev)
 	cleanup_device_parent(dev);
 	if (parent)
 		put_device(parent);
+name_error:
+	kfree(dev->p);
+	dev->p = NULL;
 	goto done;
 }
 

commit 8a577ffc75d9194fe8cdb7479236f2081c26ca1f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Apr 18 15:05:45 2009 -0700

    driver: dont update dev_name via device_add path
    
    notice one system /proc/iomem some entries missed the name for pci_devices
    
    it turns that dev->dev.kobj name is changed after device_add.
    
    for pci code: via acpi_pci_root_driver.ops.add (aka acpi_pci_root_add)
    ==> pci_acpi_scan_root is used to scan pci bus/device, and at the same
    time we read the resource for pci_dev in the pci_read_bases, we have
    res->name = pci_name(pci_dev); pci_name is calling dev_name.
    
    later via acpi_pci_root_driver.ops.start (aka acpi_pci_root_start) ==>
    pci_bus_add_device to add all pci_dev in kobj tree.  pci_bus_add_device
    will call device_add.
    
    actually in device_add
    
            /* first, register with generic layer. */
            error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev_name(dev));
            if (error)
                    goto Error;
    
    will get one new name for that kobj, old name is freed.
    
    [Impact: fix corrupted names in /proc/iomem ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d230ff4b3eec..4aa527b8a913 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -891,7 +891,8 @@ int device_add(struct device *dev)
 		set_dev_node(dev, dev_to_node(parent));
 
 	/* first, register with generic layer. */
-	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev_name(dev));
+	/* we require the name to be set before, and pass NULL */
+	error = kobject_add(&dev->kobj, dev->kobj.parent, NULL);
 	if (error)
 		goto Error;
 

commit 014c90dbb9b63bae067afc80a7931a76c5268ae3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 15 16:00:12 2009 -0700

    driver core: prevent device_for_each_child from oopsing
    
    David Vrabel noticed that the wireless usb stack likes to call
    device_for_each_chile() with an empty bus.  This used to work fine, but
    now oopses.  This patch fixes the oops and makes the code behave like it
    used to.
    
    Reported-by: David Vrabel <david.vrabel@csr.com>
    Tested-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e73c92d13a23..d230ff4b3eec 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1142,6 +1142,9 @@ int device_for_each_child(struct device *parent, void *data,
 	struct device *child;
 	int error = 0;
 
+	if (!parent->p)
+		return 0;
+
 	klist_iter_init(&parent->p->klist_children, &i);
 	while ((child = next_device(&i)) && !error)
 		error = fn(child, data);

commit ffa6a7054d172a2f57248dff2de600ca795c5656
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Mar 4 12:44:00 2009 +0100

    Driver core: Fix device_move() vs. dpm list ordering, v2
    
    dpm_list currently relies on the fact that child devices will
    be registered after their parents to get a correct suspend
    order. Using device_move() however destroys this assumption, as
    an already registered device may be moved under a newly registered
    one.
    
    This patch adds a new argument to device_move(), allowing callers
    to specify how dpm_list should be adapted.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 95c67ffd71da..e73c92d13a23 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1561,8 +1561,10 @@ static int device_move_class_links(struct device *dev,
  * device_move - moves a device to a new parent
  * @dev: the pointer to the struct device to be moved
  * @new_parent: the new parent of the device (can by NULL)
+ * @dpm_order: how to reorder the dpm_list
  */
-int device_move(struct device *dev, struct device *new_parent)
+int device_move(struct device *dev, struct device *new_parent,
+		enum dpm_order dpm_order)
 {
 	int error;
 	struct device *old_parent;
@@ -1572,6 +1574,7 @@ int device_move(struct device *dev, struct device *new_parent)
 	if (!dev)
 		return -EINVAL;
 
+	device_pm_lock();
 	new_parent = get_device(new_parent);
 	new_parent_kobj = get_device_parent(dev, new_parent);
 
@@ -1613,9 +1616,23 @@ int device_move(struct device *dev, struct device *new_parent)
 		put_device(new_parent);
 		goto out;
 	}
+	switch (dpm_order) {
+	case DPM_ORDER_NONE:
+		break;
+	case DPM_ORDER_DEV_AFTER_PARENT:
+		device_pm_move_after(dev, new_parent);
+		break;
+	case DPM_ORDER_PARENT_BEFORE_DEV:
+		device_pm_move_before(new_parent, dev);
+		break;
+	case DPM_ORDER_DEV_LAST:
+		device_pm_move_last(dev);
+		break;
+	}
 out_put:
 	put_device(old_parent);
 out:
+	device_pm_unlock();
 	put_device(dev);
 	return error;
 }

commit f67f129e519fa87f8ebd236b6336fe43f31ee141
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sun Mar 1 21:10:49 2009 +0800

    Driver core: implement uevent suppress in kobject
    
    This patch implements uevent suppress in kobject and removes it
    from struct device, based on the following ideas:
    
    1,Uevent sending should be one attribute of kobject, so suppressing it
    in kobject layer is more natural than in device layer. By this way,
    we can do it for other objects embedded with kobject.
    
    2,It may save several bytes for each instance of struct device.(On my
    omap3(32bit ARM) based box, can save 8bytes per device object)
    
    This patch also introduces dev_set|get_uevent_suppress() helpers to
    set and query uevent_suppress attribute in case to help kobject
    as private part of struct device in future.
    
    [This version is against the latest driver-core patch set of Greg,please
    ignore the last version.]
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a90f56f64d6f..95c67ffd71da 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -136,8 +136,6 @@ static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 
 	if (ktype == &device_ktype) {
 		struct device *dev = to_dev(kobj);
-		if (dev->uevent_suppress)
-			return 0;
 		if (dev->bus)
 			return 1;
 		if (dev->class)

commit f791b8c836307b58cbf62133a6a772ed1a92fb33
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:24:56 2008 -0800

    driver core: move klist_children into private structure
    
    Nothing outside of the driver core should ever touch klist_children, or
    knode_parent, so move them out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 16d859910104..a90f56f64d6f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -509,14 +509,16 @@ EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
 
 static void klist_children_get(struct klist_node *n)
 {
-	struct device *dev = container_of(n, struct device, knode_parent);
+	struct device_private *p = to_device_private_parent(n);
+	struct device *dev = p->device;
 
 	get_device(dev);
 }
 
 static void klist_children_put(struct klist_node *n)
 {
-	struct device *dev = container_of(n, struct device, knode_parent);
+	struct device_private *p = to_device_private_parent(n);
+	struct device *dev = p->device;
 
 	put_device(dev);
 }
@@ -540,8 +542,6 @@ void device_initialize(struct device *dev)
 {
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
-	klist_init(&dev->klist_children, klist_children_get,
-		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
 	spin_lock_init(&dev->devres_lock);
@@ -867,6 +867,8 @@ int device_add(struct device *dev)
 		goto done;
 	}
 	dev->p->device = dev;
+	klist_init(&dev->p->klist_children, klist_children_get,
+		   klist_children_put);
 
 	/*
 	 * for statically allocated devices, which should all be converted
@@ -937,7 +939,8 @@ int device_add(struct device *dev)
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);
 	if (parent)
-		klist_add_tail(&dev->knode_parent, &parent->klist_children);
+		klist_add_tail(&dev->p->knode_parent,
+			       &parent->p->klist_children);
 
 	if (dev->class) {
 		mutex_lock(&dev->class->p->class_mutex);
@@ -1051,7 +1054,7 @@ void device_del(struct device *dev)
 	device_pm_remove(dev);
 	dpm_sysfs_remove(dev);
 	if (parent)
-		klist_del(&dev->knode_parent);
+		klist_del(&dev->p->knode_parent);
 	if (MAJOR(dev->devt)) {
 		device_remove_sys_dev_entry(dev);
 		device_remove_file(dev, &devt_attr);
@@ -1112,7 +1115,14 @@ void device_unregister(struct device *dev)
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);
-	return n ? container_of(n, struct device, knode_parent) : NULL;
+	struct device *dev = NULL;
+	struct device_private *p;
+
+	if (n) {
+		p = to_device_private_parent(n);
+		dev = p->device;
+	}
+	return dev;
 }
 
 /**
@@ -1134,7 +1144,7 @@ int device_for_each_child(struct device *parent, void *data,
 	struct device *child;
 	int error = 0;
 
-	klist_iter_init(&parent->klist_children, &i);
+	klist_iter_init(&parent->p->klist_children, &i);
 	while ((child = next_device(&i)) && !error)
 		error = fn(child, data);
 	klist_iter_exit(&i);
@@ -1165,7 +1175,7 @@ struct device *device_find_child(struct device *parent, void *data,
 	if (!parent)
 		return NULL;
 
-	klist_iter_init(&parent->klist_children, &i);
+	klist_iter_init(&parent->p->klist_children, &i);
 	while ((child = next_device(&i)))
 		if (match(child, data) && get_device(child))
 			break;
@@ -1578,9 +1588,10 @@ int device_move(struct device *dev, struct device *new_parent)
 	old_parent = dev->parent;
 	dev->parent = new_parent;
 	if (old_parent)
-		klist_remove(&dev->knode_parent);
+		klist_remove(&dev->p->knode_parent);
 	if (new_parent) {
-		klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
+		klist_add_tail(&dev->p->knode_parent,
+			       &new_parent->p->klist_children);
 		set_dev_node(dev, dev_to_node(new_parent));
 	}
 
@@ -1592,11 +1603,11 @@ int device_move(struct device *dev, struct device *new_parent)
 		device_move_class_links(dev, new_parent, old_parent);
 		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
 			if (new_parent)
-				klist_remove(&dev->knode_parent);
+				klist_remove(&dev->p->knode_parent);
 			dev->parent = old_parent;
 			if (old_parent) {
-				klist_add_tail(&dev->knode_parent,
-					       &old_parent->klist_children);
+				klist_add_tail(&dev->p->knode_parent,
+					       &old_parent->p->klist_children);
 				set_dev_node(dev, dev_to_node(old_parent));
 			}
 		}

commit fb069a5d132fb926ed17af3211a114ac7cf27d7a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:23:36 2008 -0800

    driver core: create a private portion of struct device
    
    This is to be used to move things out of struct device that no code
    outside of the driver core should ever touch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 059966b617f6..16d859910104 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -109,6 +109,7 @@ static struct sysfs_ops dev_sysfs_ops = {
 static void device_release(struct kobject *kobj)
 {
 	struct device *dev = to_dev(kobj);
+	struct device_private *p = dev->p;
 
 	if (dev->release)
 		dev->release(dev);
@@ -120,6 +121,7 @@ static void device_release(struct kobject *kobj)
 		WARN(1, KERN_ERR "Device '%s' does not have a release() "
 			"function, it is broken and must be fixed.\n",
 			dev_name(dev));
+	kfree(p);
 }
 
 static struct kobj_type device_ktype = {
@@ -859,6 +861,13 @@ int device_add(struct device *dev)
 	if (!dev)
 		goto done;
 
+	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
+	if (!dev->p) {
+		error = -ENOMEM;
+		goto done;
+	}
+	dev->p->device = dev;
+
 	/*
 	 * for statically allocated devices, which should all be converted
 	 * some day, we need to initialize the name. We prevent reading back

commit 1fa5ae857bb14f6046205171d98506d8112dd74e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Jan 25 15:17:37 2009 +0100

    driver core: get rid of struct device's bus_id string array
    
    Now that all users of bus_id is gone, we can remove it from struct
    device.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f3eae630e589..059966b617f6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -777,17 +777,12 @@ static void device_remove_class_symlinks(struct device *dev)
 int dev_set_name(struct device *dev, const char *fmt, ...)
 {
 	va_list vargs;
-	char *s;
+	int err;
 
 	va_start(vargs, fmt);
-	vsnprintf(dev->bus_id, sizeof(dev->bus_id), fmt, vargs);
+	err = kobject_set_name_vargs(&dev->kobj, fmt, vargs);
 	va_end(vargs);
-
-	/* ewww... some of these buggers have / in the name... */
-	while ((s = strchr(dev->bus_id, '/')))
-		*s = '!';
-
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL_GPL(dev_set_name);
 
@@ -864,12 +859,17 @@ int device_add(struct device *dev)
 	if (!dev)
 		goto done;
 
-	/* Temporarily support init_name if it is set.
-	 * It will override bus_id for now */
-	if (dev->init_name)
-		dev_set_name(dev, "%s", dev->init_name);
+	/*
+	 * for statically allocated devices, which should all be converted
+	 * some day, we need to initialize the name. We prevent reading back
+	 * the name, and force the use of dev_name()
+	 */
+	if (dev->init_name) {
+		dev_set_name(dev, dev->init_name);
+		dev->init_name = NULL;
+	}
 
-	if (!strlen(dev->bus_id))
+	if (!dev_name(dev))
 		goto done;
 
 	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
@@ -1348,7 +1348,10 @@ struct device *device_create_vargs(struct class *class, struct device *parent,
 	dev->release = device_create_release;
 	dev_set_drvdata(dev, drvdata);
 
-	vsnprintf(dev->bus_id, BUS_ID_SIZE, fmt, args);
+	retval = kobject_set_name_vargs(&dev->kobj, fmt, args);
+	if (retval)
+		goto error;
+
 	retval = device_register(dev);
 	if (retval)
 		goto error;
@@ -1452,19 +1455,15 @@ int device_rename(struct device *dev, char *new_name)
 		old_class_name = make_class_name(dev->class->name, &dev->kobj);
 #endif
 
-	old_device_name = kmalloc(BUS_ID_SIZE, GFP_KERNEL);
+	old_device_name = kstrdup(dev_name(dev), GFP_KERNEL);
 	if (!old_device_name) {
 		error = -ENOMEM;
 		goto out;
 	}
-	strlcpy(old_device_name, dev->bus_id, BUS_ID_SIZE);
-	strlcpy(dev->bus_id, new_name, BUS_ID_SIZE);
 
 	error = kobject_rename(&dev->kobj, new_name);
-	if (error) {
-		strlcpy(dev->bus_id, old_device_name, BUS_ID_SIZE);
+	if (error)
 		goto out;
-	}
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	if (old_class_name) {

commit 7cbcf22548df1f1df7c6b0d0bda579b92efca63c
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Jan 20 16:29:13 2009 -0800

    driver-core: fix kernel-doc parameter name
    
    Fix function parameter name in kernel-doc:
    
    Warning(linux-next-20090120//drivers/base/core.c:1289): No description found for parameter 'dev'
    Warning(linux-next-20090120//drivers/base/core.c:1289): Excess function parameter 'root' description in 'root_device_unregister'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Mark McLoughlin <markmc@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 55e530942ab0..f3eae630e589 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1280,7 +1280,7 @@ EXPORT_SYMBOL_GPL(__root_device_register);
 
 /**
  * root_device_unregister - unregister and free a root device
- * @root: device going away.
+ * @dev: device going away
  *
  * This function unregisters and cleans up a device that was created by
  * root_device_register().

commit 7143f7a1a3603002e4ef3719fa92e8dd6e607099
Author: Roland Dreier <rdreier@cisco.com>
Date:   Fri Jan 9 22:27:42 2009 -0800

    driver core: Convert '/' to '!' in dev_set_name()
    
    Commit 3ada8b7e ("block: struct device - replace bus_id with dev_name(),
    dev_set_name()") deleted the code in register_disk() that changed a '/'
    to a '!' in the device name when registering a disk, but dev_set_name()
    does not perform this conversion.
    
    This leads to amusing problems with disks that have '/' in their names:
    for example a failure to boot with the root partition on a cciss device,
    even though the kernel says it knows about the root device:
    
        VFS: Cannot open root device "cciss/c0d0p6" or unknown-block(0,0)
        Please append a correct "root=" boot option; here are the available partitions:
        6800        71652960 cciss/c0d0 driver: cciss
          6802               1 cciss/c0d0p2
          6805         2931831 cciss/c0d0p5
          6806        34354908 cciss/c0d0p6
        6810        71652960 cciss/c0d1 driver: cciss
    
    Fix this by adding code to change '/' to '!' in dev_set_name() to handle
    this until dev_set_name() is converted to use kobject_set_name().
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8079afca4972..55e530942ab0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -777,10 +777,16 @@ static void device_remove_class_symlinks(struct device *dev)
 int dev_set_name(struct device *dev, const char *fmt, ...)
 {
 	va_list vargs;
+	char *s;
 
 	va_start(vargs, fmt);
 	vsnprintf(dev->bus_id, sizeof(dev->bus_id), fmt, vargs);
 	va_end(vargs);
+
+	/* ewww... some of these buggers have / in the name... */
+	while ((s = strchr(dev->bus_id, '/')))
+		*s = '!';
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(dev_set_name);

commit 926beadb3dfaddccb3348a5b9e6c2a1f8290a220
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 15:06:12 2009 -0800

    Revert "driver core: create a private portion of struct device"
    
    This reverts commit 2831fe6f9cc4e16c103504ee09a47a084297c0f3.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 5c2acf7116d7..8079afca4972 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -109,7 +109,6 @@ static struct sysfs_ops dev_sysfs_ops = {
 static void device_release(struct kobject *kobj)
 {
 	struct device *dev = to_dev(kobj);
-	struct device_private *p = dev->p;
 
 	if (dev->release)
 		dev->release(dev);
@@ -121,7 +120,6 @@ static void device_release(struct kobject *kobj)
 		WARN(1, KERN_ERR "Device '%s' does not have a release() "
 			"function, it is broken and must be fixed.\n",
 			dev_name(dev));
-	kfree(p);
 }
 
 static struct kobj_type device_ktype = {
@@ -538,12 +536,6 @@ static void klist_children_put(struct klist_node *n)
  */
 void device_initialize(struct device *dev)
 {
-	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
-	if (!dev->p) {
-		WARN_ON(1);
-		return;
-	}
-	dev->p->device = dev;
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
 	klist_init(&dev->klist_children, klist_children_get,

commit e2d4077678c7ec7661003c268120582adc544897
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 9 14:55:37 2009 -0800

    Revert "driver core: move klist_children into private structure"
    
    This reverts commit 11c3b5c3e08f4d855cbef52883c266b9ab9df879.
    
    Turns out that device_initialize shouldn't fail silently.
    This series needs to be reworked in order to get into proper
    shape.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 61df508fa62b..5c2acf7116d7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -509,16 +509,14 @@ EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
 
 static void klist_children_get(struct klist_node *n)
 {
-	struct device_private *p = to_device_private_parent(n);
-	struct device *dev = p->device;
+	struct device *dev = container_of(n, struct device, knode_parent);
 
 	get_device(dev);
 }
 
 static void klist_children_put(struct klist_node *n)
 {
-	struct device_private *p = to_device_private_parent(n);
-	struct device *dev = p->device;
+	struct device *dev = container_of(n, struct device, knode_parent);
 
 	put_device(dev);
 }
@@ -548,7 +546,7 @@ void device_initialize(struct device *dev)
 	dev->p->device = dev;
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
-	klist_init(&dev->p->klist_children, klist_children_get,
+	klist_init(&dev->klist_children, klist_children_get,
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
@@ -932,8 +930,7 @@ int device_add(struct device *dev)
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);
 	if (parent)
-		klist_add_tail(&dev->p->knode_parent,
-			       &parent->p->klist_children);
+		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
 	if (dev->class) {
 		mutex_lock(&dev->class->p->class_mutex);
@@ -1047,7 +1044,7 @@ void device_del(struct device *dev)
 	device_pm_remove(dev);
 	dpm_sysfs_remove(dev);
 	if (parent)
-		klist_del(&dev->p->knode_parent);
+		klist_del(&dev->knode_parent);
 	if (MAJOR(dev->devt)) {
 		device_remove_sys_dev_entry(dev);
 		device_remove_file(dev, &devt_attr);
@@ -1108,14 +1105,7 @@ void device_unregister(struct device *dev)
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);
-	struct device *dev = NULL;
-	struct device_private *p;
-
-	if (n) {
-		p = to_device_private_parent(n);
-		dev = p->device;
-	}
-	return dev;
+	return n ? container_of(n, struct device, knode_parent) : NULL;
 }
 
 /**
@@ -1137,7 +1127,7 @@ int device_for_each_child(struct device *parent, void *data,
 	struct device *child;
 	int error = 0;
 
-	klist_iter_init(&parent->p->klist_children, &i);
+	klist_iter_init(&parent->klist_children, &i);
 	while ((child = next_device(&i)) && !error)
 		error = fn(child, data);
 	klist_iter_exit(&i);
@@ -1168,7 +1158,7 @@ struct device *device_find_child(struct device *parent, void *data,
 	if (!parent)
 		return NULL;
 
-	klist_iter_init(&parent->p->klist_children, &i);
+	klist_iter_init(&parent->klist_children, &i);
 	while ((child = next_device(&i)))
 		if (match(child, data) && get_device(child))
 			break;
@@ -1582,10 +1572,9 @@ int device_move(struct device *dev, struct device *new_parent)
 	old_parent = dev->parent;
 	dev->parent = new_parent;
 	if (old_parent)
-		klist_remove(&dev->p->knode_parent);
+		klist_remove(&dev->knode_parent);
 	if (new_parent) {
-		klist_add_tail(&dev->p->knode_parent,
-			       &new_parent->p->klist_children);
+		klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
 		set_dev_node(dev, dev_to_node(new_parent));
 	}
 
@@ -1597,11 +1586,11 @@ int device_move(struct device *dev, struct device *new_parent)
 		device_move_class_links(dev, new_parent, old_parent);
 		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
 			if (new_parent)
-				klist_remove(&dev->p->knode_parent);
+				klist_remove(&dev->knode_parent);
 			dev->parent = old_parent;
 			if (old_parent) {
-				klist_add_tail(&dev->p->knode_parent,
-					       &old_parent->p->klist_children);
+				klist_add_tail(&dev->knode_parent,
+					       &old_parent->klist_children);
 				set_dev_node(dev, dev_to_node(old_parent));
 			}
 		}

commit 0aa0dc41bfd993491c2344870eee7a3b218551fb
Author: Mark McLoughlin <markmc@redhat.com>
Date:   Mon Dec 15 12:58:26 2008 +0000

    driver core: add root_device_register()
    
    Add support for allocating root device objects which group
    device objects under /sys/devices directories.
    
    Also add a sysfs 'module' symlink which points to the owner
    of the root device object. This symlink will be used in virtio
    to allow userspace to determine which virtio bus implementation
    a given device is associated with.
    
    [Includes suggestions from Cornelia Huck]
    
    Signed-off-by: Mark McLoughlin <markmc@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ee555d7d5c3f..61df508fa62b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1217,6 +1217,97 @@ EXPORT_SYMBOL_GPL(put_device);
 EXPORT_SYMBOL_GPL(device_create_file);
 EXPORT_SYMBOL_GPL(device_remove_file);
 
+struct root_device
+{
+	struct device dev;
+	struct module *owner;
+};
+
+#define to_root_device(dev) container_of(dev, struct root_device, dev)
+
+static void root_device_release(struct device *dev)
+{
+	kfree(to_root_device(dev));
+}
+
+/**
+ * __root_device_register - allocate and register a root device
+ * @name: root device name
+ * @owner: owner module of the root device, usually THIS_MODULE
+ *
+ * This function allocates a root device and registers it
+ * using device_register(). In order to free the returned
+ * device, use root_device_unregister().
+ *
+ * Root devices are dummy devices which allow other devices
+ * to be grouped under /sys/devices. Use this function to
+ * allocate a root device and then use it as the parent of
+ * any device which should appear under /sys/devices/{name}
+ *
+ * The /sys/devices/{name} directory will also contain a
+ * 'module' symlink which points to the @owner directory
+ * in sysfs.
+ *
+ * Note: You probably want to use root_device_register().
+ */
+struct device *__root_device_register(const char *name, struct module *owner)
+{
+	struct root_device *root;
+	int err = -ENOMEM;
+
+	root = kzalloc(sizeof(struct root_device), GFP_KERNEL);
+	if (!root)
+		return ERR_PTR(err);
+
+	err = dev_set_name(&root->dev, name);
+	if (err) {
+		kfree(root);
+		return ERR_PTR(err);
+	}
+
+	root->dev.release = root_device_release;
+
+	err = device_register(&root->dev);
+	if (err) {
+		put_device(&root->dev);
+		return ERR_PTR(err);
+	}
+
+#ifdef CONFIG_MODULE	/* gotta find a "cleaner" way to do this */
+	if (owner) {
+		struct module_kobject *mk = &owner->mkobj;
+
+		err = sysfs_create_link(&root->dev.kobj, &mk->kobj, "module");
+		if (err) {
+			device_unregister(&root->dev);
+			return ERR_PTR(err);
+		}
+		root->owner = owner;
+	}
+#endif
+
+	return &root->dev;
+}
+EXPORT_SYMBOL_GPL(__root_device_register);
+
+/**
+ * root_device_unregister - unregister and free a root device
+ * @root: device going away.
+ *
+ * This function unregisters and cleans up a device that was created by
+ * root_device_register().
+ */
+void root_device_unregister(struct device *dev)
+{
+	struct root_device *root = to_root_device(dev);
+
+	if (root->owner)
+		sysfs_remove_link(&root->dev.kobj, "module");
+
+	device_unregister(dev);
+}
+EXPORT_SYMBOL_GPL(root_device_unregister);
+
 
 static void device_create_release(struct device *dev)
 {

commit ec0676ee28528dc8dda13a93ee4b1f215a0c2f9d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Dec 5 14:10:31 2008 -0500

    Driver core: move the bus notifier call points
    
    This patch (as1184) changes the location of the notifications in
    device_add() and device_del().  Now the BUS_NOTIFY_ADD_DEVICE message
    is sent after dpm_sysfs_add(), which is necessary for clients that
    want to add attributes to the power/ subdirectory.  The
    BUS_NOTIFY_DEL_DEVICE message is correspondingly moved before
    dpm_sysfs_remove().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 180ff84ea26c..ee555d7d5c3f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -894,11 +894,6 @@ int device_add(struct device *dev)
 	if (platform_notify)
 		platform_notify(dev);
 
-	/* notify clients of device entry (new way) */
-	if (dev->bus)
-		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
-					     BUS_NOTIFY_ADD_DEVICE, dev);
-
 	error = device_create_file(dev, &uevent_attr);
 	if (error)
 		goto attrError;
@@ -926,6 +921,14 @@ int device_add(struct device *dev)
 	if (error)
 		goto DPMError;
 	device_pm_add(dev);
+
+	/* Notify clients of device addition.  This call must come
+	 * after dpm_sysf_add() and before kobject_uevent().
+	 */
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
+					     BUS_NOTIFY_ADD_DEVICE, dev);
+
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);
 	if (parent)
@@ -951,9 +954,6 @@ int device_add(struct device *dev)
  DPMError:
 	bus_remove_device(dev);
  BusError:
-	if (dev->bus)
-		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
-					     BUS_NOTIFY_DEL_DEVICE, dev);
 	device_remove_attrs(dev);
  AttrsError:
 	device_remove_class_symlinks(dev);
@@ -1038,6 +1038,12 @@ void device_del(struct device *dev)
 	struct device *parent = dev->parent;
 	struct class_interface *class_intf;
 
+	/* Notify clients of device removal.  This call must come
+	 * before dpm_sysfs_remove().
+	 */
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
+					     BUS_NOTIFY_DEL_DEVICE, dev);
 	device_pm_remove(dev);
 	dpm_sysfs_remove(dev);
 	if (parent)
@@ -1075,9 +1081,6 @@ void device_del(struct device *dev)
 	 */
 	if (platform_notify_remove)
 		platform_notify_remove(dev);
-	if (dev->bus)
-		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
-					     BUS_NOTIFY_DEL_DEVICE, dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	cleanup_device_parent(dev);
 	kobject_del(&dev->kobj);

commit 11c3b5c3e08f4d855cbef52883c266b9ab9df879
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:24:56 2008 -0800

    driver core: move klist_children into private structure
    
    Nothing outside of the driver core should ever touch klist_children, or
    knode_parent, so move them out of the public eye.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6657787e64f8..180ff84ea26c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -509,14 +509,16 @@ EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
 
 static void klist_children_get(struct klist_node *n)
 {
-	struct device *dev = container_of(n, struct device, knode_parent);
+	struct device_private *p = to_device_private_parent(n);
+	struct device *dev = p->device;
 
 	get_device(dev);
 }
 
 static void klist_children_put(struct klist_node *n)
 {
-	struct device *dev = container_of(n, struct device, knode_parent);
+	struct device_private *p = to_device_private_parent(n);
+	struct device *dev = p->device;
 
 	put_device(dev);
 }
@@ -546,7 +548,7 @@ void device_initialize(struct device *dev)
 	dev->p->device = dev;
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
-	klist_init(&dev->klist_children, klist_children_get,
+	klist_init(&dev->p->klist_children, klist_children_get,
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
@@ -927,7 +929,8 @@ int device_add(struct device *dev)
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);
 	if (parent)
-		klist_add_tail(&dev->knode_parent, &parent->klist_children);
+		klist_add_tail(&dev->p->knode_parent,
+			       &parent->p->klist_children);
 
 	if (dev->class) {
 		mutex_lock(&dev->class->p->class_mutex);
@@ -1038,7 +1041,7 @@ void device_del(struct device *dev)
 	device_pm_remove(dev);
 	dpm_sysfs_remove(dev);
 	if (parent)
-		klist_del(&dev->knode_parent);
+		klist_del(&dev->p->knode_parent);
 	if (MAJOR(dev->devt)) {
 		device_remove_sys_dev_entry(dev);
 		device_remove_file(dev, &devt_attr);
@@ -1102,7 +1105,14 @@ void device_unregister(struct device *dev)
 static struct device *next_device(struct klist_iter *i)
 {
 	struct klist_node *n = klist_next(i);
-	return n ? container_of(n, struct device, knode_parent) : NULL;
+	struct device *dev = NULL;
+	struct device_private *p;
+
+	if (n) {
+		p = to_device_private_parent(n);
+		dev = p->device;
+	}
+	return dev;
 }
 
 /**
@@ -1124,7 +1134,7 @@ int device_for_each_child(struct device *parent, void *data,
 	struct device *child;
 	int error = 0;
 
-	klist_iter_init(&parent->klist_children, &i);
+	klist_iter_init(&parent->p->klist_children, &i);
 	while ((child = next_device(&i)) && !error)
 		error = fn(child, data);
 	klist_iter_exit(&i);
@@ -1155,7 +1165,7 @@ struct device *device_find_child(struct device *parent, void *data,
 	if (!parent)
 		return NULL;
 
-	klist_iter_init(&parent->klist_children, &i);
+	klist_iter_init(&parent->p->klist_children, &i);
 	while ((child = next_device(&i)))
 		if (match(child, data) && get_device(child))
 			break;
@@ -1478,9 +1488,10 @@ int device_move(struct device *dev, struct device *new_parent)
 	old_parent = dev->parent;
 	dev->parent = new_parent;
 	if (old_parent)
-		klist_remove(&dev->knode_parent);
+		klist_remove(&dev->p->knode_parent);
 	if (new_parent) {
-		klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
+		klist_add_tail(&dev->p->knode_parent,
+			       &new_parent->p->klist_children);
 		set_dev_node(dev, dev_to_node(new_parent));
 	}
 
@@ -1492,11 +1503,11 @@ int device_move(struct device *dev, struct device *new_parent)
 		device_move_class_links(dev, new_parent, old_parent);
 		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
 			if (new_parent)
-				klist_remove(&dev->knode_parent);
+				klist_remove(&dev->p->knode_parent);
 			dev->parent = old_parent;
 			if (old_parent) {
-				klist_add_tail(&dev->knode_parent,
-					       &old_parent->klist_children);
+				klist_add_tail(&dev->p->knode_parent,
+					       &old_parent->p->klist_children);
 				set_dev_node(dev, dev_to_node(old_parent));
 			}
 		}

commit 2831fe6f9cc4e16c103504ee09a47a084297c0f3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 16 12:23:36 2008 -0800

    driver core: create a private portion of struct device
    
    This is to be used to move things out of struct device that no code
    outside of the driver core should ever touch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 14aa2b6953c9..6657787e64f8 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -109,6 +109,7 @@ static struct sysfs_ops dev_sysfs_ops = {
 static void device_release(struct kobject *kobj)
 {
 	struct device *dev = to_dev(kobj);
+	struct device_private *p = dev->p;
 
 	if (dev->release)
 		dev->release(dev);
@@ -120,6 +121,7 @@ static void device_release(struct kobject *kobj)
 		WARN(1, KERN_ERR "Device '%s' does not have a release() "
 			"function, it is broken and must be fixed.\n",
 			dev_name(dev));
+	kfree(p);
 }
 
 static struct kobj_type device_ktype = {
@@ -536,6 +538,12 @@ static void klist_children_put(struct klist_node *n)
  */
 void device_initialize(struct device *dev)
 {
+	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
+	if (!dev->p) {
+		WARN_ON(1);
+		return;
+	}
+	dev->p->device = dev;
 	dev->kobj.kset = devices_kset;
 	kobject_init(&dev->kobj, &device_ktype);
 	klist_init(&dev->klist_children, klist_children_get,

commit 1e0b2cf933ebf32494eba3f668859ba57f06a951
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:36:48 2008 +0100

    driver core: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8c2cc2648f5a..14aa2b6953c9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -119,7 +119,7 @@ static void device_release(struct kobject *kobj)
 	else
 		WARN(1, KERN_ERR "Device '%s' does not have a release() "
 			"function, it is broken and must be fixed.\n",
-			dev->bus_id);
+			dev_name(dev));
 }
 
 static struct kobj_type device_ktype = {
@@ -209,7 +209,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		retval = dev->bus->uevent(dev, env);
 		if (retval)
 			pr_debug("device: '%s': %s: bus uevent() returned %d\n",
-				 dev->bus_id, __func__, retval);
+				 dev_name(dev), __func__, retval);
 	}
 
 	/* have the class specific function add its stuff */
@@ -217,7 +217,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		retval = dev->class->dev_uevent(dev, env);
 		if (retval)
 			pr_debug("device: '%s': %s: class uevent() "
-				 "returned %d\n", dev->bus_id,
+				 "returned %d\n", dev_name(dev),
 				 __func__, retval);
 	}
 
@@ -226,7 +226,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		retval = dev->type->uevent(dev, env);
 		if (retval)
 			pr_debug("device: '%s': %s: dev_type uevent() "
-				 "returned %d\n", dev->bus_id,
+				 "returned %d\n", dev_name(dev),
 				 __func__, retval);
 	}
 
@@ -672,7 +672,7 @@ static int device_add_class_symlinks(struct device *dev)
 	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev)) {
 		error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
-					  &dev->kobj, dev->bus_id);
+					  &dev->kobj, dev_name(dev));
 		if (error)
 			goto out_subsys;
 	}
@@ -712,11 +712,11 @@ static int device_add_class_symlinks(struct device *dev)
 	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev))
 		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
-				  dev->bus_id);
+				  dev_name(dev));
 #else
 	/* link in the class directory pointing to the device */
 	error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
-				  &dev->kobj, dev->bus_id);
+				  &dev->kobj, dev_name(dev));
 	if (error)
 		goto out_subsys;
 
@@ -729,7 +729,7 @@ static int device_add_class_symlinks(struct device *dev)
 	return 0;
 
 out_busid:
-	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev->bus_id);
+	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev_name(dev));
 #endif
 
 out_subsys:
@@ -758,12 +758,12 @@ static void device_remove_class_symlinks(struct device *dev)
 	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev))
 		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
-				  dev->bus_id);
+				  dev_name(dev));
 #else
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 
-	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev->bus_id);
+	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev_name(dev));
 #endif
 
 	sysfs_remove_link(&dev->kobj, "subsystem");
@@ -866,7 +866,7 @@ int device_add(struct device *dev)
 	if (!strlen(dev->bus_id))
 		goto done;
 
-	pr_debug("device: '%s': %s\n", dev->bus_id, __func__);
+	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
 
 	parent = get_device(dev->parent);
 	setup_parent(dev, parent);
@@ -876,7 +876,7 @@ int device_add(struct device *dev)
 		set_dev_node(dev, dev_to_node(parent));
 
 	/* first, register with generic layer. */
-	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev->bus_id);
+	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev_name(dev));
 	if (error)
 		goto Error;
 
@@ -1086,7 +1086,7 @@ void device_del(struct device *dev)
  */
 void device_unregister(struct device *dev)
 {
-	pr_debug("device: '%s': %s\n", dev->bus_id, __func__);
+	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
 	device_del(dev);
 	put_device(dev);
 }
@@ -1199,7 +1199,7 @@ EXPORT_SYMBOL_GPL(device_remove_file);
 
 static void device_create_release(struct device *dev)
 {
-	pr_debug("device: '%s': %s\n", dev->bus_id, __func__);
+	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
 	kfree(dev);
 }
 
@@ -1344,7 +1344,7 @@ int device_rename(struct device *dev, char *new_name)
 	if (!dev)
 		return -EINVAL;
 
-	pr_debug("device: '%s': %s: renaming to '%s'\n", dev->bus_id,
+	pr_debug("device: '%s': %s: renaming to '%s'\n", dev_name(dev),
 		 __func__, new_name);
 
 #ifdef CONFIG_SYSFS_DEPRECATED
@@ -1381,7 +1381,7 @@ int device_rename(struct device *dev, char *new_name)
 #else
 	if (dev->class) {
 		error = sysfs_create_link_nowarn(&dev->class->p->class_subsys.kobj,
-						 &dev->kobj, dev->bus_id);
+						 &dev->kobj, dev_name(dev));
 		if (error)
 			goto out;
 		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
@@ -1459,8 +1459,8 @@ int device_move(struct device *dev, struct device *new_parent)
 	new_parent = get_device(new_parent);
 	new_parent_kobj = get_device_parent(dev, new_parent);
 
-	pr_debug("device: '%s': %s: moving to '%s'\n", dev->bus_id,
-		 __func__, new_parent ? new_parent->bus_id : "<NULL>");
+	pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),
+		 __func__, new_parent ? dev_name(new_parent) : "<NULL>");
 	error = kobject_move(&dev->kobj, new_parent_kobj);
 	if (error) {
 		cleanup_glue_dir(dev, new_parent_kobj);

commit 030c1d2bfcc2187650fb975456ca0b61a5bb77f4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu May 8 14:41:00 2008 -0700

    kobject: Fix kobject_rename and !CONFIG_SYSFS
    
    When looking at kobject_rename I found two bugs with
    that exist when sysfs support is disabled in the kernel.
    
    kobject_rename does not change the name on the kobject when
    sysfs support is not compiled in.
    
    kobject_rename without locking attempts to check the
    validity of a rename operation, which the kobject layer
    simply does not have the infrastructure to do.
    
    This patch documents the previously unstated requirement of
    kobject_rename that is the responsibility of the caller to
    provide mutual exclusion and to be certain that the new_name
    for the kobject is valid.
    
    This patch modifies sysfs_rename_dir in !CONFIG_SYSFS case
    to call kobject_set_name to actually change the kobject_name.
    
    This patch removes the bogus and misleading check in kobject_rename
    that attempts to see if a rename is valid.  The check is bogus
    because we do not have the proper locking.  The check is misleading
    because it looks like we can and do perform checking at the kobject
    level that we don't.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9649d1c422a4..8c2cc2648f5a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1327,6 +1327,11 @@ EXPORT_SYMBOL_GPL(device_destroy);
  * device_rename - renames a device
  * @dev: the pointer to the struct device to be renamed
  * @new_name: the new name of the device
+ *
+ * It is the responsibility of the caller to provide mutual
+ * exclusion between two different calls of device_rename
+ * on the same device to ensure that new_name is valid and
+ * won't conflict with other devices.
  */
 int device_rename(struct device *dev, char *new_name)
 {

commit 286661b3777897220ecfcd774bccc68a34667f39
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Sep 3 18:26:41 2008 +0200

    Driver core: Fix cleanup in device_create_vargs().
    
    If device_register() in device_create_vargs() fails, the device
    must be cleaned up with put_device() (which is also fine on NULL)
    instead of kfree().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index aac91e89d6af..9649d1c422a4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1256,7 +1256,7 @@ struct device *device_create_vargs(struct class *class, struct device *parent,
 	return dev;
 
 error:
-	kfree(dev);
+	put_device(dev);
 	return ERR_PTR(retval);
 }
 EXPORT_SYMBOL_GPL(device_create_vargs);

commit 5739411acbaa63a6c22c91e340fdcdbcc7d82a51
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Sep 3 18:26:40 2008 +0200

    Driver core: Clarify device cleanup.
    
    Make the comments on how to use device_initialize(), device_add()
    and device_register() a bit clearer - in particular, explicitly
    note that put_device() must be used once we tried to add the device
    to the hierarchy.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b98cb1416a2d..aac91e89d6af 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -523,11 +523,16 @@ static void klist_children_put(struct klist_node *n)
  * device_initialize - init device structure.
  * @dev: device.
  *
- * This prepares the device for use by other layers,
- * including adding it to the device hierarchy.
+ * This prepares the device for use by other layers by initializing
+ * its fields.
  * It is the first half of device_register(), if called by
- * that, though it can also be called separately, so one
- * may use @dev's fields (e.g. the refcount).
+ * that function, though it can also be called separately, so one
+ * may use @dev's fields. In particular, get_device()/put_device()
+ * may be used for reference counting of @dev after calling this
+ * function.
+ *
+ * NOTE: Use put_device() to give up your reference instead of freeing
+ * @dev directly once you have called this function.
  */
 void device_initialize(struct device *dev)
 {
@@ -835,9 +840,13 @@ static void device_remove_sys_dev_entry(struct device *dev)
  * This is part 2 of device_register(), though may be called
  * separately _iff_ device_initialize() has been called separately.
  *
- * This adds it to the kobject hierarchy via kobject_add(), adds it
+ * This adds @dev to the kobject hierarchy via kobject_add(), adds it
  * to the global and sibling lists for the device, then
  * adds it to the other relevant subsystems of the driver model.
+ *
+ * NOTE: _Never_ directly free @dev after calling this function, even
+ * if it returned an error! Always use put_device() to give up your
+ * reference instead.
  */
 int device_add(struct device *dev)
 {
@@ -965,6 +974,10 @@ int device_add(struct device *dev)
  * I.e. you should only call the two helpers separately if
  * have a clearly defined need to use and refcount the device
  * before it is added to the hierarchy.
+ *
+ * NOTE: _Never_ directly free @dev after calling this function, even
+ * if it returned an error! Always use put_device() to give up the
+ * reference initialized in this function instead.
  */
 int device_register(struct device *dev)
 {

commit 5a3ceb861663040f9ef0176df4aaa494bba5e352
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 25 19:50:19 2008 +0200

    driver-core: use klist for class device list and implement iterator
    
    Iterating over entries using callback usually isn't too fun especially
    when the entry being iterated over can't be manipulated freely.  This
    patch converts class->p->class_devices to klist and implements class
    device iterator so that the users can freely build their own control
    structure.  The users are also free to call back into class code
    without worrying about locking.
    
    class_for_each_device() and class_find_device() are converted to use
    the new iterators, so their users don't have to worry about locking
    anymore either.
    
    Note: This depends on klist-dont-iterate-over-deleted-entries patch
    because class_intf->add/remove_dev() depends on proper synchronization
    with device removal.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d021c98605b3..b98cb1416a2d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -536,7 +536,6 @@ void device_initialize(struct device *dev)
 	klist_init(&dev->klist_children, klist_children_get,
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
-	INIT_LIST_HEAD(&dev->node);
 	init_MUTEX(&dev->sem);
 	spin_lock_init(&dev->devres_lock);
 	INIT_LIST_HEAD(&dev->devres_head);
@@ -916,7 +915,8 @@ int device_add(struct device *dev)
 	if (dev->class) {
 		mutex_lock(&dev->class->p->class_mutex);
 		/* tie the class to the device */
-		list_add_tail(&dev->node, &dev->class->p->class_devices);
+		klist_add_tail(&dev->knode_class,
+			       &dev->class->p->class_devices);
 
 		/* notify any interfaces that the device is here */
 		list_for_each_entry(class_intf,
@@ -1032,7 +1032,7 @@ void device_del(struct device *dev)
 			if (class_intf->remove_dev)
 				class_intf->remove_dev(dev, class_intf);
 		/* remove the device from the class list */
-		list_del_init(&dev->node);
+		klist_del(&dev->knode_class);
 		mutex_unlock(&dev->class->p->class_mutex);
 	}
 	device_remove_file(dev, &uevent_attr);

commit c906a48adc74fc455378137ac5124b13e7030a15
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 30 10:45:12 2008 -0700

    driver core: add init_name to struct device
    
    This gives us a way to handle both the bus_id and init_name values being
    used for a while during the transition period.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 40041319657d..d021c98605b3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -844,13 +844,19 @@ int device_add(struct device *dev)
 {
 	struct device *parent = NULL;
 	struct class_interface *class_intf;
-	int error;
+	int error = -EINVAL;
 
 	dev = get_device(dev);
-	if (!dev || !strlen(dev->bus_id)) {
-		error = -EINVAL;
-		goto Done;
-	}
+	if (!dev)
+		goto done;
+
+	/* Temporarily support init_name if it is set.
+	 * It will override bus_id for now */
+	if (dev->init_name)
+		dev_set_name(dev, "%s", dev->init_name);
+
+	if (!strlen(dev->bus_id))
+		goto done;
 
 	pr_debug("device: '%s': %s\n", dev->bus_id, __func__);
 
@@ -919,7 +925,7 @@ int device_add(struct device *dev)
 				class_intf->add_dev(dev, class_intf);
 		mutex_unlock(&dev->class->p->class_mutex);
 	}
- Done:
+done:
 	put_device(dev);
 	return error;
  DPMError:
@@ -946,7 +952,7 @@ int device_add(struct device *dev)
 	cleanup_device_parent(dev);
 	if (parent)
 		put_device(parent);
-	goto Done;
+	goto done;
 }
 
 /**

commit 3b98aeaf3a75f544dc945694f4fcf6e1c4bab89d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Aug 7 13:06:12 2008 -0400

    PM: don't skip device PM init when CONFIG_PM_SLEEP isn't set and CONFIG_PM is set
    
    This patch (as1124) fixes a couple of bugs in the PM core.  The new
    dev->power.status field should be initialized regardless of whether
    CONFIG_PM_SLEEP is enabled, and similarly dpm_sysfs_add() should be
    called whenever CONFIG_PM is enabled.
    
    The patch separates out the call to dpm_sysfs_add() from the call to
    device_pm_add().  As a result device_pm_add() can no longer return an
    error, so its return type is changed to void.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Romit Dasgupta <romit@ti.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 44bad73d8192..40041319657d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -541,6 +541,7 @@ void device_initialize(struct device *dev)
 	spin_lock_init(&dev->devres_lock);
 	INIT_LIST_HEAD(&dev->devres_head);
 	device_init_wakeup(dev, 0);
+	device_pm_init(dev);
 	set_dev_node(dev, -1);
 }
 
@@ -897,9 +898,10 @@ int device_add(struct device *dev)
 	error = bus_add_device(dev);
 	if (error)
 		goto BusError;
-	error = device_pm_add(dev);
+	error = dpm_sysfs_add(dev);
 	if (error)
-		goto PMError;
+		goto DPMError;
+	device_pm_add(dev);
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);
 	if (parent)
@@ -920,7 +922,7 @@ int device_add(struct device *dev)
  Done:
 	put_device(dev);
 	return error;
- PMError:
+ DPMError:
 	bus_remove_device(dev);
  BusError:
 	if (dev->bus)
@@ -1007,6 +1009,7 @@ void device_del(struct device *dev)
 	struct class_interface *class_intf;
 
 	device_pm_remove(dev);
+	dpm_sysfs_remove(dev);
 	if (parent)
 		klist_del(&dev->knode_parent);
 	if (MAJOR(dev->devt)) {

commit bf9ca69fc8d19d4034391d3df4c35dccdef9d28c
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Jul 30 12:29:21 2008 -0700

    dev_printk(): constify the `dev' argument
    
    Add const markings to dev_name and dev_driver_string to make it clear that
    dev_printk doesn't modify dev.  This is a prerequisite to adding more
    const markings to other functions make it clearer, which functions can
    modify dev and which can't.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 068aa1c9538c..44bad73d8192 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -53,7 +53,7 @@ static inline int device_is_not_partition(struct device *dev)
  * it is attached to.  If it is not attached to a bus either, an empty
  * string will be returned.
  */
-const char *dev_driver_string(struct device *dev)
+const char *dev_driver_string(const struct device *dev)
 {
 	return dev->driver ? dev->driver->name :
 			(dev->bus ? dev->bus->name :

commit f810a5cf28a818db96333cd23646f0227ec015b4
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Fri Jul 25 19:45:39 2008 -0700

    Use WARN() in drivers/base/
    
    Use WARN() instead of a printk+WARN_ON() pair; this way the message
    becomes part of the warning section for better reporting/collection.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7d5c63c81a59..068aa1c9538c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -116,12 +116,10 @@ static void device_release(struct kobject *kobj)
 		dev->type->release(dev);
 	else if (dev->class && dev->class->dev_release)
 		dev->class->dev_release(dev);
-	else {
-		printk(KERN_ERR "Device '%s' does not have a release() "
+	else
+		WARN(1, KERN_ERR "Device '%s' does not have a release() "
 			"function, it is broken and must be fixed.\n",
 			dev->bus_id);
-		WARN_ON(1);
-	}
 }
 
 static struct kobj_type device_ktype = {

commit 36ce6dad6e3cb3f050ed41e0beac0070d2062b25
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Tue Jun 10 11:09:08 2008 +0200

    driver core: Suppress sysfs warnings for device_rename().
    
    driver core: Suppress sysfs warnings for device_rename().
    
    Renaming network devices to an already existing name is not
    something we want sysfs to print a scary warning for, since the
    callers can deal with this correctly. So let's introduce
    sysfs_create_link_nowarn() which gets rid of the common warning.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c05b1159023e..7d5c63c81a59 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1345,8 +1345,9 @@ int device_rename(struct device *dev, char *new_name)
 	if (old_class_name) {
 		new_class_name = make_class_name(dev->class->name, &dev->kobj);
 		if (new_class_name) {
-			error = sysfs_create_link(&dev->parent->kobj,
-						  &dev->kobj, new_class_name);
+			error = sysfs_create_link_nowarn(&dev->parent->kobj,
+							 &dev->kobj,
+							 new_class_name);
 			if (error)
 				goto out;
 			sysfs_remove_link(&dev->parent->kobj, old_class_name);
@@ -1354,8 +1355,8 @@ int device_rename(struct device *dev, char *new_name)
 	}
 #else
 	if (dev->class) {
-		error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
-					  &dev->kobj, dev->bus_id);
+		error = sysfs_create_link_nowarn(&dev->class->p->class_subsys.kobj,
+						 &dev->kobj, dev->bus_id);
 		if (error)
 			goto out;
 		sysfs_remove_link(&dev->class->p->class_subsys.kobj,

commit f75b1c60fc1e53c4004a79ea0be071aa3318cdcc
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Wed May 28 09:28:39 2008 -0700

    class: change internal semaphore to a mutex
    
    Now that the lockdep infrastructure in the class core is in place, we
    should be able to properly change the internal class semaphore to be a
    mutex.
    
    David wrote the original patch, and Greg fixed it up to apply properly
    due to all of the recent changes in this area.
    
    From: Dave Young <hidave.darkstar@gmail.com>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b90ae6f7be86..c05b1159023e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -21,6 +21,7 @@
 #include <linux/genhd.h>
 #include <linux/kallsyms.h>
 #include <linux/semaphore.h>
+#include <linux/mutex.h>
 
 #include "base.h"
 #include "power/power.h"
@@ -907,7 +908,7 @@ int device_add(struct device *dev)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
 	if (dev->class) {
-		down(&dev->class->p->class_sem);
+		mutex_lock(&dev->class->p->class_mutex);
 		/* tie the class to the device */
 		list_add_tail(&dev->node, &dev->class->p->class_devices);
 
@@ -916,7 +917,7 @@ int device_add(struct device *dev)
 				    &dev->class->p->class_interfaces, node)
 			if (class_intf->add_dev)
 				class_intf->add_dev(dev, class_intf);
-		up(&dev->class->p->class_sem);
+		mutex_unlock(&dev->class->p->class_mutex);
 	}
  Done:
 	put_device(dev);
@@ -1017,7 +1018,7 @@ void device_del(struct device *dev)
 	if (dev->class) {
 		device_remove_class_symlinks(dev);
 
-		down(&dev->class->p->class_sem);
+		mutex_lock(&dev->class->p->class_mutex);
 		/* notify any interfaces that the device is now gone */
 		list_for_each_entry(class_intf,
 				    &dev->class->p->class_interfaces, node)
@@ -1025,7 +1026,7 @@ void device_del(struct device *dev)
 				class_intf->remove_dev(dev, class_intf);
 		/* remove the device from the class list */
 		list_del_init(&dev->node);
-		up(&dev->class->p->class_sem);
+		mutex_unlock(&dev->class->p->class_mutex);
 	}
 	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);

commit d9a0157328507c5f563e16a583cd0a063854aebb
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "sem" to "class_sem" in internal class structure
    
    This renames the struct class "sem" field to be "class_sem" to make
    things easier when struct bus_type and struct class merge in the future.
    It also makes grepping for fields easier as well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6e1cff296d9f..b90ae6f7be86 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -907,7 +907,7 @@ int device_add(struct device *dev)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
 	if (dev->class) {
-		down(&dev->class->p->sem);
+		down(&dev->class->p->class_sem);
 		/* tie the class to the device */
 		list_add_tail(&dev->node, &dev->class->p->class_devices);
 
@@ -916,7 +916,7 @@ int device_add(struct device *dev)
 				    &dev->class->p->class_interfaces, node)
 			if (class_intf->add_dev)
 				class_intf->add_dev(dev, class_intf);
-		up(&dev->class->p->sem);
+		up(&dev->class->p->class_sem);
 	}
  Done:
 	put_device(dev);
@@ -1017,7 +1017,7 @@ void device_del(struct device *dev)
 	if (dev->class) {
 		device_remove_class_symlinks(dev);
 
-		down(&dev->class->p->sem);
+		down(&dev->class->p->class_sem);
 		/* notify any interfaces that the device is now gone */
 		list_for_each_entry(class_intf,
 				    &dev->class->p->class_interfaces, node)
@@ -1025,7 +1025,7 @@ void device_del(struct device *dev)
 				class_intf->remove_dev(dev, class_intf);
 		/* remove the device from the class list */
 		list_del_init(&dev->node);
-		up(&dev->class->p->sem);
+		up(&dev->class->p->class_sem);
 	}
 	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);

commit 1fbfee6c6dc0f4a4c587b6b163ee79643fc9aaa7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "subsys" to "class_subsys" in internal class structure
    
    This renames the struct class "subsys" field to be "class_subsys" to
    make things easier when struct bus_type and struct class merge in the
    future.  It also makes grepping for fields easier as well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 76fdd41fea0e..6e1cff296d9f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -551,7 +551,7 @@ static struct kobject *get_device_parent(struct device *dev,
 {
 	/* class devices without a parent live in /sys/class/<classname>/ */
 	if (dev->class && (!parent || parent->class != dev->class))
-		return &dev->class->p->subsys.kobj;
+		return &dev->class->p->class_subsys.kobj;
 	/* all other devices keep their parent */
 	else if (parent)
 		return &parent->kobj;
@@ -657,16 +657,17 @@ static int device_add_class_symlinks(struct device *dev)
 	if (!dev->class)
 		return 0;
 
-	error = sysfs_create_link(&dev->kobj, &dev->class->p->subsys.kobj,
+	error = sysfs_create_link(&dev->kobj,
+				  &dev->class->p->class_subsys.kobj,
 				  "subsystem");
 	if (error)
 		goto out;
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	/* stacked class devices need a symlink in the class directory */
-	if (dev->kobj.parent != &dev->class->p->subsys.kobj &&
+	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev)) {
-		error = sysfs_create_link(&dev->class->p->subsys.kobj,
+		error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
 					  &dev->kobj, dev->bus_id);
 		if (error)
 			goto out_subsys;
@@ -704,13 +705,14 @@ static int device_add_class_symlinks(struct device *dev)
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 out_busid:
-	if (dev->kobj.parent != &dev->class->p->subsys.kobj &&
+	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev))
-		sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
+		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
+				  dev->bus_id);
 #else
 	/* link in the class directory pointing to the device */
-	error = sysfs_create_link(&dev->class->p->subsys.kobj, &dev->kobj,
-				  dev->bus_id);
+	error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
+				  &dev->kobj, dev->bus_id);
 	if (error)
 		goto out_subsys;
 
@@ -723,7 +725,7 @@ static int device_add_class_symlinks(struct device *dev)
 	return 0;
 
 out_busid:
-	sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
+	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev->bus_id);
 #endif
 
 out_subsys:
@@ -749,14 +751,15 @@ static void device_remove_class_symlinks(struct device *dev)
 		sysfs_remove_link(&dev->kobj, "device");
 	}
 
-	if (dev->kobj.parent != &dev->class->p->subsys.kobj &&
+	if (dev->kobj.parent != &dev->class->p->class_subsys.kobj &&
 	    device_is_not_partition(dev))
-		sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
+		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
+				  dev->bus_id);
 #else
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 
-	sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
+	sysfs_remove_link(&dev->class->p->class_subsys.kobj, dev->bus_id);
 #endif
 
 	sysfs_remove_link(&dev->kobj, "subsystem");
@@ -1350,11 +1353,11 @@ int device_rename(struct device *dev, char *new_name)
 	}
 #else
 	if (dev->class) {
-		error = sysfs_create_link(&dev->class->p->subsys.kobj,
+		error = sysfs_create_link(&dev->class->p->class_subsys.kobj,
 					  &dev->kobj, dev->bus_id);
 		if (error)
 			goto out;
-		sysfs_remove_link(&dev->class->p->subsys.kobj,
+		sysfs_remove_link(&dev->class->p->class_subsys.kobj,
 				  old_device_name);
 	}
 #endif

commit 184f1f779d5a2e62de4a0b34842ddf8546beca8f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "interfaces" to "class_interfaces" in internal class structure
    
    This renames the struct class "interfaces" field to be
    "class_interfaces" to make things easier when struct bus_type and struct
    class merge in the future.  It also makes grepping for fields easier as
    well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 52d1e71f2a4c..76fdd41fea0e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -909,8 +909,8 @@ int device_add(struct device *dev)
 		list_add_tail(&dev->node, &dev->class->p->class_devices);
 
 		/* notify any interfaces that the device is here */
-		list_for_each_entry(class_intf, &dev->class->p->interfaces,
-				    node)
+		list_for_each_entry(class_intf,
+				    &dev->class->p->class_interfaces, node)
 			if (class_intf->add_dev)
 				class_intf->add_dev(dev, class_intf);
 		up(&dev->class->p->sem);
@@ -1016,8 +1016,8 @@ void device_del(struct device *dev)
 
 		down(&dev->class->p->sem);
 		/* notify any interfaces that the device is now gone */
-		list_for_each_entry(class_intf, &dev->class->p->interfaces,
-				    node)
+		list_for_each_entry(class_intf,
+				    &dev->class->p->class_interfaces, node)
 			if (class_intf->remove_dev)
 				class_intf->remove_dev(dev, class_intf);
 		/* remove the device from the class list */

commit 97ae69fdbaa71a8f7dbc20bf10fb349d1759152f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 28 09:28:39 2008 -0700

    class: rename "devices" to "class_devices" in internal class structure
    
    This renames the struct class "devices" field to be "class_devices" to
    make things easier when struct bus_type and struct class merge in the
    future.  It also makes grepping for fields easier as well.
    
    Based on an idea from Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 64c150b5a883..52d1e71f2a4c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -906,7 +906,7 @@ int device_add(struct device *dev)
 	if (dev->class) {
 		down(&dev->class->p->sem);
 		/* tie the class to the device */
-		list_add_tail(&dev->node, &dev->class->p->devices);
+		list_add_tail(&dev->node, &dev->class->p->class_devices);
 
 		/* notify any interfaces that the device is here */
 		list_for_each_entry(class_intf, &dev->class->p->interfaces,

commit 7c71448b8aa80123fc521563d5f7c63a099d97ab
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jan 22 18:17:41 2008 -0500

    class: move driver core specific parts to a private structure
    
    This moves the portions of struct class that are dynamic (kobject and
    lock and lists) out of the main structure and into a dynamic, private,
    structure.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9f05de6f80b5..64c150b5a883 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -551,7 +551,7 @@ static struct kobject *get_device_parent(struct device *dev,
 {
 	/* class devices without a parent live in /sys/class/<classname>/ */
 	if (dev->class && (!parent || parent->class != dev->class))
-		return &dev->class->subsys.kobj;
+		return &dev->class->p->subsys.kobj;
 	/* all other devices keep their parent */
 	else if (parent)
 		return &parent->kobj;
@@ -597,13 +597,13 @@ static struct kobject *get_device_parent(struct device *dev,
 			parent_kobj = &parent->kobj;
 
 		/* find our class-directory at the parent and reference it */
-		spin_lock(&dev->class->class_dirs.list_lock);
-		list_for_each_entry(k, &dev->class->class_dirs.list, entry)
+		spin_lock(&dev->class->p->class_dirs.list_lock);
+		list_for_each_entry(k, &dev->class->p->class_dirs.list, entry)
 			if (k->parent == parent_kobj) {
 				kobj = kobject_get(k);
 				break;
 			}
-		spin_unlock(&dev->class->class_dirs.list_lock);
+		spin_unlock(&dev->class->p->class_dirs.list_lock);
 		if (kobj)
 			return kobj;
 
@@ -611,7 +611,7 @@ static struct kobject *get_device_parent(struct device *dev,
 		k = kobject_create();
 		if (!k)
 			return NULL;
-		k->kset = &dev->class->class_dirs;
+		k->kset = &dev->class->p->class_dirs;
 		retval = kobject_add(k, parent_kobj, "%s", dev->class->name);
 		if (retval < 0) {
 			kobject_put(k);
@@ -630,7 +630,7 @@ static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 {
 	/* see if we live in a "glue" directory */
 	if (!glue_dir || !dev->class ||
-	    glue_dir->kset != &dev->class->class_dirs)
+	    glue_dir->kset != &dev->class->p->class_dirs)
 		return;
 
 	kobject_put(glue_dir);
@@ -657,17 +657,17 @@ static int device_add_class_symlinks(struct device *dev)
 	if (!dev->class)
 		return 0;
 
-	error = sysfs_create_link(&dev->kobj, &dev->class->subsys.kobj,
+	error = sysfs_create_link(&dev->kobj, &dev->class->p->subsys.kobj,
 				  "subsystem");
 	if (error)
 		goto out;
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	/* stacked class devices need a symlink in the class directory */
-	if (dev->kobj.parent != &dev->class->subsys.kobj &&
+	if (dev->kobj.parent != &dev->class->p->subsys.kobj &&
 	    device_is_not_partition(dev)) {
-		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
-					  dev->bus_id);
+		error = sysfs_create_link(&dev->class->p->subsys.kobj,
+					  &dev->kobj, dev->bus_id);
 		if (error)
 			goto out_subsys;
 	}
@@ -704,12 +704,12 @@ static int device_add_class_symlinks(struct device *dev)
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 out_busid:
-	if (dev->kobj.parent != &dev->class->subsys.kobj &&
+	if (dev->kobj.parent != &dev->class->p->subsys.kobj &&
 	    device_is_not_partition(dev))
-		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+		sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
 #else
 	/* link in the class directory pointing to the device */
-	error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
+	error = sysfs_create_link(&dev->class->p->subsys.kobj, &dev->kobj,
 				  dev->bus_id);
 	if (error)
 		goto out_subsys;
@@ -723,7 +723,7 @@ static int device_add_class_symlinks(struct device *dev)
 	return 0;
 
 out_busid:
-	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+	sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
 #endif
 
 out_subsys:
@@ -749,14 +749,14 @@ static void device_remove_class_symlinks(struct device *dev)
 		sysfs_remove_link(&dev->kobj, "device");
 	}
 
-	if (dev->kobj.parent != &dev->class->subsys.kobj &&
+	if (dev->kobj.parent != &dev->class->p->subsys.kobj &&
 	    device_is_not_partition(dev))
-		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+		sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
 #else
 	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 
-	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+	sysfs_remove_link(&dev->class->p->subsys.kobj, dev->bus_id);
 #endif
 
 	sysfs_remove_link(&dev->kobj, "subsystem");
@@ -904,15 +904,16 @@ int device_add(struct device *dev)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
 	if (dev->class) {
-		down(&dev->class->sem);
+		down(&dev->class->p->sem);
 		/* tie the class to the device */
-		list_add_tail(&dev->node, &dev->class->devices);
+		list_add_tail(&dev->node, &dev->class->p->devices);
 
 		/* notify any interfaces that the device is here */
-		list_for_each_entry(class_intf, &dev->class->interfaces, node)
+		list_for_each_entry(class_intf, &dev->class->p->interfaces,
+				    node)
 			if (class_intf->add_dev)
 				class_intf->add_dev(dev, class_intf);
-		up(&dev->class->sem);
+		up(&dev->class->p->sem);
 	}
  Done:
 	put_device(dev);
@@ -1013,14 +1014,15 @@ void device_del(struct device *dev)
 	if (dev->class) {
 		device_remove_class_symlinks(dev);
 
-		down(&dev->class->sem);
+		down(&dev->class->p->sem);
 		/* notify any interfaces that the device is now gone */
-		list_for_each_entry(class_intf, &dev->class->interfaces, node)
+		list_for_each_entry(class_intf, &dev->class->p->interfaces,
+				    node)
 			if (class_intf->remove_dev)
 				class_intf->remove_dev(dev, class_intf);
 		/* remove the device from the class list */
 		list_del_init(&dev->node);
-		up(&dev->class->sem);
+		up(&dev->class->p->sem);
 	}
 	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);
@@ -1348,11 +1350,12 @@ int device_rename(struct device *dev, char *new_name)
 	}
 #else
 	if (dev->class) {
-		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
-					  dev->bus_id);
+		error = sysfs_create_link(&dev->class->p->subsys.kobj,
+					  &dev->kobj, dev->bus_id);
 		if (error)
 			goto out;
-		sysfs_remove_link(&dev->class->subsys.kobj, old_device_name);
+		sysfs_remove_link(&dev->class->p->subsys.kobj,
+				  old_device_name);
 	}
 #endif
 

commit 695794ae0c5bdd9bd06e35b118801e2e9be04f9e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu May 22 17:21:08 2008 -0400

    Driver Core: add ability for class_find_device to start in middle of list
    
    This mirrors the functionality that driver_find_device has as well.
    
    We add a start variable, and all callers of the function are fixed up at
    the same time.
    
    The block layer will be using this new functionality in a follow-on
    patch.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9ae28aa709d5..9f05de6f80b5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1289,7 +1289,7 @@ void device_destroy(struct class *class, dev_t devt)
 {
 	struct device *dev;
 
-	dev = class_find_device(class, &devt, __match_devt);
+	dev = class_find_device(class, NULL, &devt, __match_devt);
 	if (dev) {
 		put_device(dev);
 		device_unregister(dev);

commit 4e10673944a5c386378ff9d692ae37e19993f9d5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 21 20:03:34 2008 -0700

    device create: convert device_create_drvdata to device_create
    
    Now that device_create() has been audited, rename things back to the
    original call to be sane.
    
    Keep the device_create_drvdata macro around to make merges easier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4dc0d272f6d9..9ae28aa709d5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1236,7 +1236,7 @@ struct device *device_create_vargs(struct class *class, struct device *parent,
 EXPORT_SYMBOL_GPL(device_create_vargs);
 
 /**
- * device_create_drvdata - creates a device and registers it with sysfs
+ * device_create - creates a device and registers it with sysfs
  * @class: pointer to the struct class that this device should be registered to
  * @parent: pointer to the parent struct device of this new device, if any
  * @devt: the dev_t for the char device to be added
@@ -1257,11 +1257,8 @@ EXPORT_SYMBOL_GPL(device_create_vargs);
  * Note: the struct class passed to this function must have previously
  * been created with a call to class_create().
  */
-struct device *device_create_drvdata(struct class *class,
-				     struct device *parent,
-				     dev_t devt,
-				     void *drvdata,
-				     const char *fmt, ...)
+struct device *device_create(struct class *class, struct device *parent,
+			     dev_t devt, void *drvdata, const char *fmt, ...)
 {
 	va_list vargs;
 	struct device *dev;
@@ -1271,7 +1268,7 @@ struct device *device_create_drvdata(struct class *class,
 	va_end(vargs);
 	return dev;
 }
-EXPORT_SYMBOL_GPL(device_create_drvdata);
+EXPORT_SYMBOL_GPL(device_create);
 
 static int __match_devt(struct device *dev, void *data)
 {

commit ccea44fadca396b0f89aed5bdeb60e4abb212566
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 21 12:52:33 2008 -0700

    driver core: remove device_create()
    
    There are no more users of this, and it is racy.  Use
    device_create_drvdata() or device_create_vargs() instead.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index be9aba4dc2fb..4dc0d272f6d9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1273,40 +1273,6 @@ struct device *device_create_drvdata(struct class *class,
 }
 EXPORT_SYMBOL_GPL(device_create_drvdata);
 
-/**
- * device_create - creates a device and registers it with sysfs
- * @class: pointer to the struct class that this device should be registered to
- * @parent: pointer to the parent struct device of this new device, if any
- * @devt: the dev_t for the char device to be added
- * @fmt: string for the device's name
- *
- * This function can be used by char device classes.  A struct device
- * will be created in sysfs, registered to the specified class.
- *
- * A "dev" file will be created, showing the dev_t for the device, if
- * the dev_t is not 0,0.
- * If a pointer to a parent struct device is passed in, the newly created
- * struct device will be a child of that device in sysfs.
- * The pointer to the struct device will be returned from the call.
- * Any further sysfs files that might be required can be created using this
- * pointer.
- *
- * Note: the struct class passed to this function must have previously
- * been created with a call to class_create().
- */
-struct device *device_create(struct class *class, struct device *parent,
-			     dev_t devt, const char *fmt, ...)
-{
-	va_list vargs;
-	struct device *dev;
-
-	va_start(vargs, fmt);
-	dev = device_create_vargs(class, parent, devt, NULL, fmt, vargs);
-	va_end(vargs);
-	return dev;
-}
-EXPORT_SYMBOL_GPL(device_create);
-
 static int __match_devt(struct device *dev, void *data)
 {
 	dev_t *devt = data;

commit e105b8bfc769b0545b6f0f395179d1e43cbee822
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Apr 21 10:51:07 2008 -0700

    sysfs: add /sys/dev/{char,block} to lookup sysfs path by major:minor
    
    Why?:
    There are occasions where userspace would like to access sysfs
    attributes for a device but it may not know how sysfs has named the
    device or the path.  For example what is the sysfs path for
    /dev/disk/by-id/ata-ST3160827AS_5MT004CK?  With this change a call to
    stat(2) returns the major:minor then userspace can see that
    /sys/dev/block/8:32 links to /sys/block/sdc.
    
    What are the alternatives?:
    1/ Add an ioctl to return the path: Doable, but sysfs is meant to reduce
       the need to proliferate ioctl interfaces into the kernel, so this
       seems counter productive.
    
    2/ Use udev to create these symlinks: Also doable, but it adds a
       udev dependency to utilities that might be running in a limited
       environment like an initramfs.
    
    3/ Do a full-tree search of sysfs.
    
    [kay.sievers@vrfy.org: fix duplicate registrations]
    [kay.sievers@vrfy.org: cleanup suggestions]
    
    Cc: Neil Brown <neilb@suse.de>
    Cc: Tejun Heo <htejun@gmail.com>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Reviewed-by: SL Baur <steve@xemacs.org>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Acked-by: Mark Lord <lkml@rtr.ca>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ee0a51a3a41d..be9aba4dc2fb 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -27,6 +27,9 @@
 
 int (*platform_notify)(struct device *dev) = NULL;
 int (*platform_notify_remove)(struct device *dev) = NULL;
+static struct kobject *dev_kobj;
+struct kobject *sysfs_dev_char_kobj;
+struct kobject *sysfs_dev_block_kobj;
 
 #ifdef CONFIG_BLOCK
 static inline int device_is_not_partition(struct device *dev)
@@ -775,6 +778,54 @@ int dev_set_name(struct device *dev, const char *fmt, ...)
 }
 EXPORT_SYMBOL_GPL(dev_set_name);
 
+/**
+ * device_to_dev_kobj - select a /sys/dev/ directory for the device
+ * @dev: device
+ *
+ * By default we select char/ for new entries.  Setting class->dev_obj
+ * to NULL prevents an entry from being created.  class->dev_kobj must
+ * be set (or cleared) before any devices are registered to the class
+ * otherwise device_create_sys_dev_entry() and
+ * device_remove_sys_dev_entry() will disagree about the the presence
+ * of the link.
+ */
+static struct kobject *device_to_dev_kobj(struct device *dev)
+{
+	struct kobject *kobj;
+
+	if (dev->class)
+		kobj = dev->class->dev_kobj;
+	else
+		kobj = sysfs_dev_char_kobj;
+
+	return kobj;
+}
+
+static int device_create_sys_dev_entry(struct device *dev)
+{
+	struct kobject *kobj = device_to_dev_kobj(dev);
+	int error = 0;
+	char devt_str[15];
+
+	if (kobj) {
+		format_dev_t(devt_str, dev->devt);
+		error = sysfs_create_link(kobj, &dev->kobj, devt_str);
+	}
+
+	return error;
+}
+
+static void device_remove_sys_dev_entry(struct device *dev)
+{
+	struct kobject *kobj = device_to_dev_kobj(dev);
+	char devt_str[15];
+
+	if (kobj) {
+		format_dev_t(devt_str, dev->devt);
+		sysfs_remove_link(kobj, devt_str);
+	}
+}
+
 /**
  * device_add - add device to device hierarchy.
  * @dev: device.
@@ -829,6 +880,10 @@ int device_add(struct device *dev)
 		error = device_create_file(dev, &devt_attr);
 		if (error)
 			goto ueventattrError;
+
+		error = device_create_sys_dev_entry(dev);
+		if (error)
+			goto devtattrError;
 	}
 
 	error = device_add_class_symlinks(dev);
@@ -872,6 +927,9 @@ int device_add(struct device *dev)
  AttrsError:
 	device_remove_class_symlinks(dev);
  SymlinkError:
+	if (MAJOR(dev->devt))
+		device_remove_sys_dev_entry(dev);
+ devtattrError:
 	if (MAJOR(dev->devt))
 		device_remove_file(dev, &devt_attr);
  ueventattrError:
@@ -948,8 +1006,10 @@ void device_del(struct device *dev)
 	device_pm_remove(dev);
 	if (parent)
 		klist_del(&dev->knode_parent);
-	if (MAJOR(dev->devt))
+	if (MAJOR(dev->devt)) {
+		device_remove_sys_dev_entry(dev);
 		device_remove_file(dev, &devt_attr);
+	}
 	if (dev->class) {
 		device_remove_class_symlinks(dev);
 
@@ -1074,7 +1134,25 @@ int __init devices_init(void)
 	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
 	if (!devices_kset)
 		return -ENOMEM;
+	dev_kobj = kobject_create_and_add("dev", NULL);
+	if (!dev_kobj)
+		goto dev_kobj_err;
+	sysfs_dev_block_kobj = kobject_create_and_add("block", dev_kobj);
+	if (!sysfs_dev_block_kobj)
+		goto block_kobj_err;
+	sysfs_dev_char_kobj = kobject_create_and_add("char", dev_kobj);
+	if (!sysfs_dev_char_kobj)
+		goto char_kobj_err;
+
 	return 0;
+
+ char_kobj_err:
+	kobject_put(sysfs_dev_block_kobj);
+ block_kobj_err:
+	kobject_put(dev_kobj);
+ dev_kobj_err:
+	kset_unregister(devices_kset);
+	return -ENOMEM;
 }
 
 EXPORT_SYMBOL_GPL(device_for_each_child);
@@ -1447,4 +1525,7 @@ void device_shutdown(void)
 			dev->driver->shutdown(dev);
 		}
 	}
+	kobject_put(sysfs_dev_char_kobj);
+	kobject_put(sysfs_dev_block_kobj);
+	kobject_put(dev_kobj);
 }

commit 4623236619ff5ce233136d13ee2747c194a63591
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Jun 4 21:40:43 2008 -0700

    dev_set_name: fix missing kernel-doc
    
    Fix kernel-doc for new dev_set_name() function:
    
    Warning(lin2626-rc5//drivers/base/core.c:767): No description found for parameter 'fmt'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 422cfcad486d..ee0a51a3a41d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -762,6 +762,7 @@ static void device_remove_class_symlinks(struct device *dev)
 /**
  * dev_set_name - set a device name
  * @dev: device
+ * @fmt: format string for the device's name
  */
 int dev_set_name(struct device *dev, const char *fmt, ...)
 {

commit 413c239fad68258157f903b3ffd9bfcc53f5e34b
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri May 30 10:16:40 2008 +1000

    driver-core: prepare for 2.6.27 api change by adding dev_set_name
    
    Create the dev_set_name function now so that various subsystems can
    start changing over to it before other changes in 2.6.27 will make it
    compulsory.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 72eccae4904b..422cfcad486d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -759,6 +759,21 @@ static void device_remove_class_symlinks(struct device *dev)
 	sysfs_remove_link(&dev->kobj, "subsystem");
 }
 
+/**
+ * dev_set_name - set a device name
+ * @dev: device
+ */
+int dev_set_name(struct device *dev, const char *fmt, ...)
+{
+	va_list vargs;
+
+	va_start(vargs, fmt);
+	vsnprintf(dev->bus_id, sizeof(dev->bus_id), fmt, vargs);
+	va_end(vargs);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dev_set_name);
+
 /**
  * device_add - add device to device hierarchy.
  * @dev: device.

commit e616c6303306df62223ebe2e68bb2f19c420dd81
Merge: 789319db76cc d3ede327e83f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 20 17:23:03 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-2.6: (27 commits)
      pktgen: make sure that pktgen_thread_worker has been executed
      [VLAN]: Propagate selected feature bits to VLAN devices
      drivers/atm/: remove CVS keywords
      vlan: Correctly handle device notifications for layered VLAN devices
      net: Fix call to ->change_rx_flags(dev, IFF_MULTICAST) in dev_change_flags()
      net_sched: cls_api: fix return value for non-existant classifiers
      ipsec: Use the correct ip_local_out function
      ipv6 addrconf: Allow infinite prefix lifetime.
      ipv6 route: Fix lifetime in netlink.
      ipv6 addrconf: Fix route lifetime setting in corner case.
      ndisc: Add missing strategies for per-device retrans timer/reachable time settings.
      ipv6: Move <linux/in6.h> from header-y to unifdef-y.
      l2tp: avoid skb truesize bug if headroom is increased
      wireless: Create 'device' symlink in sysfs
      wireless, airo: waitbusy() won't delay
      libertas: fix command timeout after firmware failure
      mac80211: Add RTNL version of ieee80211_iterate_active_interfaces
      mac80211 : Association with 11n hidden ssid ap.
      hostap: fix "registers" registration in procfs
      isdn/capi: Return proper errnos on module init.
      ...

commit 8882b39421bae317e3ee864edd845e994307ce16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu May 15 13:44:08 2008 -0700

    Driver core: add device_create_vargs and device_create_drvdata
    
    We want to have the drvdata field set properly when creating the device
    as sysfs callbacks can assume it is present and it can race the later
    setting of this field.
    
    So, create two new functions, deviec_create_vargs() and
    device_create_drvdata() that take this new field.
    
    device_create_drvdata() will go away in 2.6.27 as the drvdata field will
    just be moved to the device_create() call as it should be.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index be288b5e4180..f861c2b1dcff 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1084,11 +1084,13 @@ static void device_create_release(struct device *dev)
 }
 
 /**
- * device_create - creates a device and registers it with sysfs
+ * device_create_vargs - creates a device and registers it with sysfs
  * @class: pointer to the struct class that this device should be registered to
  * @parent: pointer to the parent struct device of this new device, if any
  * @devt: the dev_t for the char device to be added
+ * @drvdata: the data to be added to the device for callbacks
  * @fmt: string for the device's name
+ * @args: va_list for the device's name
  *
  * This function can be used by char device classes.  A struct device
  * will be created in sysfs, registered to the specified class.
@@ -1104,10 +1106,10 @@ static void device_create_release(struct device *dev)
  * Note: the struct class passed to this function must have previously
  * been created with a call to class_create().
  */
-struct device *device_create(struct class *class, struct device *parent,
-			     dev_t devt, const char *fmt, ...)
+struct device *device_create_vargs(struct class *class, struct device *parent,
+				   dev_t devt, void *drvdata, const char *fmt,
+				   va_list args)
 {
-	va_list args;
 	struct device *dev = NULL;
 	int retval = -ENODEV;
 
@@ -1124,10 +1126,9 @@ struct device *device_create(struct class *class, struct device *parent,
 	dev->class = class;
 	dev->parent = parent;
 	dev->release = device_create_release;
+	dev_set_drvdata(dev, drvdata);
 
-	va_start(args, fmt);
 	vsnprintf(dev->bus_id, BUS_ID_SIZE, fmt, args);
-	va_end(args);
 	retval = device_register(dev);
 	if (retval)
 		goto error;
@@ -1138,6 +1139,78 @@ struct device *device_create(struct class *class, struct device *parent,
 	kfree(dev);
 	return ERR_PTR(retval);
 }
+EXPORT_SYMBOL_GPL(device_create_vargs);
+
+/**
+ * device_create_drvdata - creates a device and registers it with sysfs
+ * @class: pointer to the struct class that this device should be registered to
+ * @parent: pointer to the parent struct device of this new device, if any
+ * @devt: the dev_t for the char device to be added
+ * @drvdata: the data to be added to the device for callbacks
+ * @fmt: string for the device's name
+ *
+ * This function can be used by char device classes.  A struct device
+ * will be created in sysfs, registered to the specified class.
+ *
+ * A "dev" file will be created, showing the dev_t for the device, if
+ * the dev_t is not 0,0.
+ * If a pointer to a parent struct device is passed in, the newly created
+ * struct device will be a child of that device in sysfs.
+ * The pointer to the struct device will be returned from the call.
+ * Any further sysfs files that might be required can be created using this
+ * pointer.
+ *
+ * Note: the struct class passed to this function must have previously
+ * been created with a call to class_create().
+ */
+struct device *device_create_drvdata(struct class *class,
+				     struct device *parent,
+				     dev_t devt,
+				     void *drvdata,
+				     const char *fmt, ...)
+{
+	va_list vargs;
+	struct device *dev;
+
+	va_start(vargs, fmt);
+	dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);
+	va_end(vargs);
+	return dev;
+}
+EXPORT_SYMBOL_GPL(device_create_drvdata);
+
+/**
+ * device_create - creates a device and registers it with sysfs
+ * @class: pointer to the struct class that this device should be registered to
+ * @parent: pointer to the parent struct device of this new device, if any
+ * @devt: the dev_t for the char device to be added
+ * @fmt: string for the device's name
+ *
+ * This function can be used by char device classes.  A struct device
+ * will be created in sysfs, registered to the specified class.
+ *
+ * A "dev" file will be created, showing the dev_t for the device, if
+ * the dev_t is not 0,0.
+ * If a pointer to a parent struct device is passed in, the newly created
+ * struct device will be a child of that device in sysfs.
+ * The pointer to the struct device will be returned from the call.
+ * Any further sysfs files that might be required can be created using this
+ * pointer.
+ *
+ * Note: the struct class passed to this function must have previously
+ * been created with a call to class_create().
+ */
+struct device *device_create(struct class *class, struct device *parent,
+			     dev_t devt, const char *fmt, ...)
+{
+	va_list vargs;
+	struct device *dev;
+
+	va_start(vargs, fmt);
+	dev = device_create_vargs(class, parent, devt, NULL, fmt, vargs);
+	va_end(vargs);
+	return dev;
+}
 EXPORT_SYMBOL_GPL(device_create);
 
 static int __match_devt(struct device *dev, void *data)

commit 0599ad53fee2d084f9ba26247d7452f06a40d298
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed May 14 22:34:16 2008 -0700

    sysfs: remove error messages for -EEXIST case
    
    It is possible that the entry in sysfs already exists, one case of this is
    when a network device is renamed to bonding_masters. Anyway, in this case
    the proper error path is for device_rename to return an error code, not to
    generate bogus backtrace and errors.
    
    Also, to avoid possible races, the create link should be done before the
    remove link. This makes a device rename atomic operation like other renames.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index be288b5e4180..3eeac5a78581 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1218,13 +1218,11 @@ int device_rename(struct device *dev, char *new_name)
 	}
 #else
 	if (dev->class) {
-		sysfs_remove_link(&dev->class->subsys.kobj, old_device_name);
 		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
 					  dev->bus_id);
-		if (error) {
-			dev_err(dev, "%s: sysfs_create_symlink failed (%d)\n",
-				__func__, error);
-		}
+		if (error)
+			goto out;
+		sysfs_remove_link(&dev->class->subsys.kobj, old_device_name);
 	}
 #endif
 

commit 0d358f22f6c8f03ab215eee8d52b74f78cc3c7db
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Tue Feb 19 03:20:41 2008 -0800

    driver core: try parent numa_node at first before using default
    
    in the device_add, we try to use use parent numa_node.
    need to make sure pci root bus's bridge device numa_node is set.
    then we could use device->numa_node direclty for all device.
    and don't need to call pcibus_to_node().
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9248e0927d08..be288b5e4180 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -787,6 +787,10 @@ int device_add(struct device *dev)
 	parent = get_device(dev->parent);
 	setup_parent(dev, parent);
 
+	/* use parent numa_node */
+	if (parent)
+		set_dev_node(dev, dev_to_node(parent));
+
 	/* first, register with generic layer. */
 	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev->bus_id);
 	if (error)
@@ -1306,8 +1310,11 @@ int device_move(struct device *dev, struct device *new_parent)
 	dev->parent = new_parent;
 	if (old_parent)
 		klist_remove(&dev->knode_parent);
-	if (new_parent)
+	if (new_parent) {
 		klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
+		set_dev_node(dev, dev_to_node(new_parent));
+	}
+
 	if (!dev->class)
 		goto out_put;
 	error = device_move_class_links(dev, old_parent, new_parent);
@@ -1317,9 +1324,12 @@ int device_move(struct device *dev, struct device *new_parent)
 		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
 			if (new_parent)
 				klist_remove(&dev->knode_parent);
-			if (old_parent)
+			dev->parent = old_parent;
+			if (old_parent) {
 				klist_add_tail(&dev->knode_parent,
 					       &old_parent->klist_children);
+				set_dev_node(dev, dev_to_node(old_parent));
+			}
 		}
 		cleanup_glue_dir(dev, new_parent_kobj);
 		put_device(new_parent);

commit e80ab411e589e00550e2e6e5a6a02d59cc730357
Merge: 529a41e36673 ee959b00c335
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 21 15:49:58 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-2.6: (36 commits)
      SCSI: convert struct class_device to struct device
      DRM: remove unused dev_class
      IB: rename "dev" to "srp_dev" in srp_host structure
      IB: convert struct class_device to struct device
      memstick: convert struct class_device to struct device
      driver core: replace remaining __FUNCTION__ occurrences
      sysfs: refill attribute buffer when reading from offset 0
      PM: Remove destroy_suspended_device()
      Firmware: add iSCSI iBFT Support
      PM: Remove legacy PM (fix)
      Kobject: Replace list_for_each() with list_for_each_entry().
      SYSFS: Explicitly include required header file slab.h.
      Driver core: make device_is_registered() work for class devices
      PM: Convert wakeup flag accessors to inline functions
      PM: Make wakeup flags available whenever CONFIG_PM is set
      PM: Fix misuse of wakeup flag accessors in serial core
      Driver core: Call device_pm_add() after bus_add_device() in device_add()
      PM: Handle device registrations during suspend/resume
      block: send disk "change" event for rescan_partitions()
      sysdev: detect multiple driver registrations
      ...
    
    Fixed trivial conflict in include/linux/memory.h due to semaphore header
    file change (made irrelevant by the change to mutex).

commit 2b3a302a09735276e13421db56c20045a48eb06d
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Tue Mar 4 16:41:05 2008 -0800

    driver core: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0262fc7c45fc..0737fe5392a3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -207,7 +207,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		retval = dev->bus->uevent(dev, env);
 		if (retval)
 			pr_debug("device: '%s': %s: bus uevent() returned %d\n",
-				 dev->bus_id, __FUNCTION__, retval);
+				 dev->bus_id, __func__, retval);
 	}
 
 	/* have the class specific function add its stuff */
@@ -216,7 +216,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		if (retval)
 			pr_debug("device: '%s': %s: class uevent() "
 				 "returned %d\n", dev->bus_id,
-				 __FUNCTION__, retval);
+				 __func__, retval);
 	}
 
 	/* have the device type specific fuction add its stuff */
@@ -225,7 +225,7 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		if (retval)
 			pr_debug("device: '%s': %s: dev_type uevent() "
 				 "returned %d\n", dev->bus_id,
-				 __FUNCTION__, retval);
+				 __func__, retval);
 	}
 
 	return retval;
@@ -782,7 +782,7 @@ int device_add(struct device *dev)
 		goto Done;
 	}
 
-	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
+	pr_debug("device: '%s': %s\n", dev->bus_id, __func__);
 
 	parent = get_device(dev->parent);
 	setup_parent(dev, parent);
@@ -980,7 +980,7 @@ void device_del(struct device *dev)
  */
 void device_unregister(struct device *dev)
 {
-	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
+	pr_debug("device: '%s': %s\n", dev->bus_id, __func__);
 	device_del(dev);
 	put_device(dev);
 }
@@ -1075,7 +1075,7 @@ EXPORT_SYMBOL_GPL(device_remove_file);
 
 static void device_create_release(struct device *dev)
 {
-	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
+	pr_debug("device: '%s': %s\n", dev->bus_id, __func__);
 	kfree(dev);
 }
 
@@ -1180,7 +1180,7 @@ int device_rename(struct device *dev, char *new_name)
 		return -EINVAL;
 
 	pr_debug("device: '%s': %s: renaming to '%s'\n", dev->bus_id,
-		 __FUNCTION__, new_name);
+		 __func__, new_name);
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	if ((dev->class) && (dev->parent))
@@ -1219,7 +1219,7 @@ int device_rename(struct device *dev, char *new_name)
 					  dev->bus_id);
 		if (error) {
 			dev_err(dev, "%s: sysfs_create_symlink failed (%d)\n",
-				__FUNCTION__, error);
+				__func__, error);
 		}
 	}
 #endif
@@ -1295,7 +1295,7 @@ int device_move(struct device *dev, struct device *new_parent)
 	new_parent_kobj = get_device_parent(dev, new_parent);
 
 	pr_debug("device: '%s': %s: moving to '%s'\n", dev->bus_id,
-		 __FUNCTION__, new_parent ? new_parent->bus_id : "<NULL>");
+		 __func__, new_parent ? new_parent->bus_id : "<NULL>");
 	error = kobject_move(&dev->kobj, new_parent_kobj);
 	if (error) {
 		cleanup_glue_dir(dev, new_parent_kobj);

commit b844eba292b477cda14582bfc6f535deed57a82d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Mar 23 20:28:24 2008 +0100

    PM: Remove destroy_suspended_device()
    
    After 2.6.24 there was a plan to make the PM core acquire all device
    semaphores during a suspend/hibernation to protect itself from
    concurrent operations involving device objects.  That proved to be
    too heavy-handed and we found a better way to achieve the goal, but
    before it happened, we had introduced the functions
    device_pm_schedule_removal() and destroy_suspended_device() to allow
    drivers to "safely" destroy a suspended device and we had adapted some
    drivers to use them.  Now that these functions are no longer necessary,
    it seems reasonable to remove them and modify their users to use the
    normal device unregistration instead.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index adbc01788447..0262fc7c45fc 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1163,35 +1163,6 @@ void device_destroy(struct class *class, dev_t devt)
 }
 EXPORT_SYMBOL_GPL(device_destroy);
 
-#ifdef CONFIG_PM_SLEEP
-/**
- * destroy_suspended_device - asks the PM core to remove a suspended device
- * @class: pointer to the struct class that this device was registered with
- * @devt: the dev_t of the device that was previously registered
- *
- * This call notifies the PM core of the necessity to unregister a suspended
- * device created with a call to device_create() (devices cannot be
- * unregistered directly while suspended, since the PM core holds their
- * semaphores at that time).
- *
- * It can only be called within the scope of a system sleep transition.  In
- * practice this means it has to be directly or indirectly invoked either by
- * a suspend or resume method, or by the PM core (e.g. via
- * disable_nonboot_cpus() or enable_nonboot_cpus()).
- */
-void destroy_suspended_device(struct class *class, dev_t devt)
-{
-	struct device *dev;
-
-	dev = class_find_device(class, &devt, __match_devt);
-	if (dev) {
-		device_pm_schedule_removal(dev);
-		put_device(dev);
-	}
-}
-EXPORT_SYMBOL_GPL(destroy_suspended_device);
-#endif /* CONFIG_PM_SLEEP */
-
 /**
  * device_rename - renames a device
  * @dev: the pointer to the struct device to be renamed

commit 57eee3d23e8833ca18708b374c648235691942ba
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Mar 12 00:59:38 2008 +0100

    Driver core: Call device_pm_add() after bus_add_device() in device_add()
    
    Include dpm_sysfs_add() into device_pm_add(), in analogy with
    device_pm_remove(), and modify device_add() to call the latter after
    bus_add_device(), to avoid situations in which the PM core may
    attempt to suspend a device the registration of which has not been
    successful.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 79848e6c5db5..adbc01788447 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -817,17 +817,12 @@ int device_add(struct device *dev)
 	error = device_add_attrs(dev);
 	if (error)
 		goto AttrsError;
-	error = dpm_sysfs_add(dev);
-	if (error)
-		goto PMError;
-	error = device_pm_add(dev);
-	if (error) {
-		dpm_sysfs_remove(dev);
-		goto PMError;
-	}
 	error = bus_add_device(dev);
 	if (error)
 		goto BusError;
+	error = device_pm_add(dev);
+	if (error)
+		goto PMError;
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);
 	if (parent)
@@ -847,9 +842,9 @@ int device_add(struct device *dev)
  Done:
 	put_device(dev);
 	return error;
- BusError:
-	device_pm_remove(dev);
  PMError:
+	bus_remove_device(dev);
+ BusError:
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);

commit 58aca23226a19983571bd3b65167521fc64f5869
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Mar 12 00:57:22 2008 +0100

    PM: Handle device registrations during suspend/resume
    
    Modify the PM core to protect its data structures, specifically the
    dpm_active list, from being corrupted if a child of the currently
    suspending device is registered concurrently with its ->suspend()
    callback.  In that case, since the new device (the child) is added
    to dpm_active after its parent, the PM core will attempt to
    suspend it after the parent, which is wrong.
    
    Introduce a new member of struct dev_pm_info, called 'sleeping',
    and use it to check if the parent of the device being added to
    dpm_active has been suspended, in which case the device registration
    fails.  Also, use 'sleeping' for checking if the ordering of devices
    on dpm_active is correct.
    
    Introduce variable 'all_sleeping' that will be set to 'true' once all
    devices have been suspended and make new device registrations fail
    until 'all_sleeping' is reset to 'false', in order to avoid having
    unsuspended devices around while the system is going into a sleep state.
    
    Remove pm_sleep_rwsem which is not necessary any more.
    
    Special thanks to Alan Stern for discussions and suggestions that
    lead to the creation of this patch.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 24198ad01976..79848e6c5db5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -820,7 +820,11 @@ int device_add(struct device *dev)
 	error = dpm_sysfs_add(dev);
 	if (error)
 		goto PMError;
-	device_pm_add(dev);
+	error = device_pm_add(dev);
+	if (error) {
+		dpm_sysfs_remove(dev);
+		goto PMError;
+	}
 	error = bus_add_device(dev);
 	if (error)
 		goto BusError;

commit 6188e10d38b8d7244ee7776d5f1f88c837b4b93f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Apr 18 22:21:05 2008 -0400

    Convert asm/semaphore.h users to linux/semaphore.h
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 24198ad01976..7c4b36ccb1a0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -20,7 +20,7 @@
 #include <linux/notifier.h>
 #include <linux/genhd.h>
 #include <linux/kallsyms.h>
-#include <asm/semaphore.h>
+#include <linux/semaphore.h>
 
 #include "base.h"
 #include "power/power.h"

commit 815d2d50da41f28aae58f5e9b3c61c3094422749
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Mar 4 15:09:07 2008 -0800

    driver core: debug for bad dev_attr_show() return value.
    
    Try to find the culprit who caused
    http://bugzilla.kernel.org/show_bug.cgi?id=10150
    
    Cc: <balajirrao@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7de543d1d0b4..24198ad01976 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -19,6 +19,7 @@
 #include <linux/kdev_t.h>
 #include <linux/notifier.h>
 #include <linux/genhd.h>
+#include <linux/kallsyms.h>
 #include <asm/semaphore.h>
 
 #include "base.h"
@@ -68,6 +69,10 @@ static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 
 	if (dev_attr->show)
 		ret = dev_attr->show(dev, dev_attr, buf);
+	if (ret >= (ssize_t)PAGE_SIZE) {
+		print_symbol("dev_attr_show: %s returned bad count\n",
+				(unsigned long)dev_attr->show);
+	}
 	return ret;
 }
 

commit c1fe539a7e031302af1d121163e7ce68e679ba8c
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Feb 27 15:38:23 2008 +0100

    Driver core: Fix cleanup when failing device_add().
    
    Driver core: Fix cleanup when failing device_add().
    
     - Don't call cleanup_device_parent() if we didn't call setup_parent().
     - dev->kobj.parent may be NULL when cleanup_device_parent() is called,
       so we need to handle glue_dir == NULL in cleanup_glue_dir().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7f59c2f2ebcb..7de543d1d0b4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -621,7 +621,8 @@ static struct kobject *get_device_parent(struct device *dev,
 static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 {
 	/* see if we live in a "glue" directory */
-	if (!dev->class || glue_dir->kset != &dev->class->class_dirs)
+	if (!glue_dir || !dev->class ||
+	    glue_dir->kset != &dev->class->class_dirs)
 		return;
 
 	kobject_put(glue_dir);
@@ -773,7 +774,7 @@ int device_add(struct device *dev)
 	dev = get_device(dev);
 	if (!dev || !strlen(dev->bus_id)) {
 		error = -EINVAL;
-		goto Error;
+		goto Done;
 	}
 
 	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);

commit 135dee0cd0eb2638fab899b428e51f00e8c046a8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 3 23:46:51 2008 +0100

    driver core: Remove dpm_sysfs_remove() from error path of device_add()
    
    Since device_pm_remove(dev) calls dpm_sysfs_remove(dev), it's
    incorrect to call the latter after the former in the device_add()
    error path.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 1e2e0fa8a450..7f59c2f2ebcb 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -839,7 +839,6 @@ int device_add(struct device *dev)
 	return error;
  BusError:
 	device_pm_remove(dev);
-	dpm_sysfs_remove(dev);
  PMError:
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,

commit 7a8d37a37380e2b1500592d40b7ec384dbebe7a0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 25 00:35:04 2008 +0100

    PM: Do not acquire device semaphores upfront during suspend
    
    Remove the code that acquires all device semaphores from the suspend
    code path as it causes multiple problems to appear (most notably,
    http://bugzilla.kernel.org/show_bug.cgi?id=10030) and revert the
    change introduced by commit 4145ed6dc597a9bea5f6ae8c574653b2de10620f
    depending on the code being removed.
    
    Remove pm_sleep_lock()/pm_sleep_unlock() from device_add() to avoid
    the issue reported at http://bugzilla.kernel.org/show_bug.cgi?id=9874.
    
    It should fix the regreesions reported at:
            http://bugzilla.kernel.org/show_bug.cgi?id=9874
            http://bugzilla.kernel.org/show_bug.cgi?id=10030
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9c0070b5bd3e..1e2e0fa8a450 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -770,13 +770,6 @@ int device_add(struct device *dev)
 	struct class_interface *class_intf;
 	int error;
 
-	error = pm_sleep_lock();
-	if (error) {
-		dev_warn(dev, "Suspicious %s during suspend\n", __FUNCTION__);
-		dump_stack();
-		return error;
-	}
-
 	dev = get_device(dev);
 	if (!dev || !strlen(dev->bus_id)) {
 		error = -EINVAL;
@@ -843,7 +836,6 @@ int device_add(struct device *dev)
 	}
  Done:
 	put_device(dev);
-	pm_sleep_unlock();
 	return error;
  BusError:
 	device_pm_remove(dev);

commit 0c98b19fe571ede1f14bd95b855bcbe2cca99bcf
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Thu Jan 31 10:39:38 2008 +0100

    Driver core: Remove unneeded get_{device,driver}() calls.
    
    Driver core: Remove unneeded get_{device,driver}() calls.
    
    Code trying to add/remove attributes must hold a reference to
    the device resp. driver anyway, so let's remove those reference
    count games.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a0cfda553c9d..9c0070b5bd3e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -423,10 +423,8 @@ struct kset *devices_kset;
 int device_create_file(struct device *dev, struct device_attribute *attr)
 {
 	int error = 0;
-	if (get_device(dev)) {
+	if (dev)
 		error = sysfs_create_file(&dev->kobj, &attr->attr);
-		put_device(dev);
-	}
 	return error;
 }
 
@@ -437,10 +435,8 @@ int device_create_file(struct device *dev, struct device_attribute *attr)
  */
 void device_remove_file(struct device *dev, struct device_attribute *attr)
 {
-	if (get_device(dev)) {
+	if (dev)
 		sysfs_remove_file(&dev->kobj, &attr->attr);
-		put_device(dev);
-	}
 }
 
 /**

commit cd35449b93ac128282c1f1f720e84c5935f9018e
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Mon Jan 28 16:56:11 2008 +0800

    driver core: convert to use class_find_device api
    
    Convert to use class_find_device api in drivers/base/core.c
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b1727876182c..a0cfda553c9d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1144,25 +1144,11 @@ struct device *device_create(struct class *class, struct device *parent,
 }
 EXPORT_SYMBOL_GPL(device_create);
 
-/**
- * find_device - finds a device that was created with device_create()
- * @class: pointer to the struct class that this device was registered with
- * @devt: the dev_t of the device that was previously registered
- */
-static struct device *find_device(struct class *class, dev_t devt)
+static int __match_devt(struct device *dev, void *data)
 {
-	struct device *dev = NULL;
-	struct device *dev_tmp;
+	dev_t *devt = data;
 
-	down(&class->sem);
-	list_for_each_entry(dev_tmp, &class->devices, node) {
-		if (dev_tmp->devt == devt) {
-			dev = dev_tmp;
-			break;
-		}
-	}
-	up(&class->sem);
-	return dev;
+	return dev->devt == *devt;
 }
 
 /**
@@ -1177,9 +1163,11 @@ void device_destroy(struct class *class, dev_t devt)
 {
 	struct device *dev;
 
-	dev = find_device(class, devt);
-	if (dev)
+	dev = class_find_device(class, &devt, __match_devt);
+	if (dev) {
+		put_device(dev);
 		device_unregister(dev);
+	}
 }
 EXPORT_SYMBOL_GPL(device_destroy);
 
@@ -1203,9 +1191,11 @@ void destroy_suspended_device(struct class *class, dev_t devt)
 {
 	struct device *dev;
 
-	dev = find_device(class, devt);
-	if (dev)
+	dev = class_find_device(class, &devt, __match_devt);
+	if (dev) {
 		device_pm_schedule_removal(dev);
+		put_device(dev);
+	}
 }
 EXPORT_SYMBOL_GPL(destroy_suspended_device);
 #endif /* CONFIG_PM_SLEEP */

commit 4e886c29610f4374d8971ec7a248f011cc3bd73a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sun Jan 27 12:12:43 2008 -0800

    Driver core: Fix up build when CONFIG_BLOCK=N
    
    This fixes up the driver core build errors when CONFIG_BLOCK=N
    
    Thanks to Alexander van Heukelum <heukelum@mailshack.com> for the basis
    of this patch, and to Jeremy Fitzhardinge <jeremy@goop.org> for
    reporting the problem.
    
    
    Cc: Alexander van Heukelum <heukelum@mailshack.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index edf3bbeb8d6a..b1727876182c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -27,9 +27,17 @@
 int (*platform_notify)(struct device *dev) = NULL;
 int (*platform_notify_remove)(struct device *dev) = NULL;
 
-/*
- * sysfs bindings for devices.
- */
+#ifdef CONFIG_BLOCK
+static inline int device_is_not_partition(struct device *dev)
+{
+	return !(dev->type == &part_type);
+}
+#else
+static inline int device_is_not_partition(struct device *dev)
+{
+	return 1;
+}
+#endif
 
 /**
  * dev_driver_string - Return a device's driver name, if at all possible
@@ -652,14 +660,14 @@ static int device_add_class_symlinks(struct device *dev)
 #ifdef CONFIG_SYSFS_DEPRECATED
 	/* stacked class devices need a symlink in the class directory */
 	if (dev->kobj.parent != &dev->class->subsys.kobj &&
-	    dev->type != &part_type) {
+	    device_is_not_partition(dev)) {
 		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
 					  dev->bus_id);
 		if (error)
 			goto out_subsys;
 	}
 
-	if (dev->parent && dev->type != &part_type) {
+	if (dev->parent && device_is_not_partition(dev)) {
 		struct device *parent = dev->parent;
 		char *class_name;
 
@@ -688,11 +696,11 @@ static int device_add_class_symlinks(struct device *dev)
 	return 0;
 
 out_device:
-	if (dev->parent && dev->type != &part_type)
+	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 out_busid:
 	if (dev->kobj.parent != &dev->class->subsys.kobj &&
-	    dev->type != &part_type)
+	    device_is_not_partition(dev))
 		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
 #else
 	/* link in the class directory pointing to the device */
@@ -701,7 +709,7 @@ static int device_add_class_symlinks(struct device *dev)
 	if (error)
 		goto out_subsys;
 
-	if (dev->parent && dev->type != &part_type) {
+	if (dev->parent && device_is_not_partition(dev)) {
 		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
 					  "device");
 		if (error)
@@ -725,7 +733,7 @@ static void device_remove_class_symlinks(struct device *dev)
 		return;
 
 #ifdef CONFIG_SYSFS_DEPRECATED
-	if (dev->parent && dev->type != &part_type) {
+	if (dev->parent && device_is_not_partition(dev)) {
 		char *class_name;
 
 		class_name = make_class_name(dev->class->name, &dev->kobj);
@@ -737,10 +745,10 @@ static void device_remove_class_symlinks(struct device *dev)
 	}
 
 	if (dev->kobj.parent != &dev->class->subsys.kobj &&
-	    dev->type != &part_type)
+	    device_is_not_partition(dev))
 		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
 #else
-	if (dev->parent && dev->type != &part_type)
+	if (dev->parent && device_is_not_partition(dev))
 		sysfs_remove_link(&dev->kobj, "device");
 
 	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);

commit 4a3ad20ccd8f4d2a0535cf98fa83f7b561ba59a9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 24 22:50:12 2008 -0800

    Driver core: coding style fixes
    
    Fix up a number of coding style issues in the drivers/base/ directory
    that have annoyed me over the years.  checkpatch.pl is now very happy.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f09dde3b1e27..edf3bbeb8d6a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -24,8 +24,8 @@
 #include "base.h"
 #include "power/power.h"
 
-int (*platform_notify)(struct device * dev) = NULL;
-int (*platform_notify_remove)(struct device * dev) = NULL;
+int (*platform_notify)(struct device *dev) = NULL;
+int (*platform_notify_remove)(struct device *dev) = NULL;
 
 /*
  * sysfs bindings for devices.
@@ -51,11 +51,11 @@ EXPORT_SYMBOL(dev_driver_string);
 #define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 
-static ssize_t
-dev_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
+static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
+			     char *buf)
 {
-	struct device_attribute * dev_attr = to_dev_attr(attr);
-	struct device * dev = to_dev(kobj);
+	struct device_attribute *dev_attr = to_dev_attr(attr);
+	struct device *dev = to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->show)
@@ -63,12 +63,11 @@ dev_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
 	return ret;
 }
 
-static ssize_t
-dev_attr_store(struct kobject * kobj, struct attribute * attr,
-	       const char * buf, size_t count)
+static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,
+			      const char *buf, size_t count)
 {
-	struct device_attribute * dev_attr = to_dev_attr(attr);
-	struct device * dev = to_dev(kobj);
+	struct device_attribute *dev_attr = to_dev_attr(attr);
+	struct device *dev = to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->store)
@@ -90,9 +89,9 @@ static struct sysfs_ops dev_sysfs_ops = {
  *	reaches 0. We forward the call to the device's release
  *	method, which should handle actually freeing the structure.
  */
-static void device_release(struct kobject * kobj)
+static void device_release(struct kobject *kobj)
 {
-	struct device * dev = to_dev(kobj);
+	struct device *dev = to_dev(kobj);
 
 	if (dev->release)
 		dev->release(dev);
@@ -101,8 +100,8 @@ static void device_release(struct kobject * kobj)
 	else if (dev->class && dev->class->dev_release)
 		dev->class->dev_release(dev);
 	else {
-		printk(KERN_ERR "Device '%s' does not have a release() function, "
-			"it is broken and must be fixed.\n",
+		printk(KERN_ERR "Device '%s' does not have a release() "
+			"function, it is broken and must be fixed.\n",
 			dev->bus_id);
 		WARN_ON(1);
 	}
@@ -185,7 +184,8 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		add_uevent_var(env, "PHYSDEVBUS=%s", dev->bus->name);
 
 		if (dev->driver)
-			add_uevent_var(env, "PHYSDEVDRIVER=%s", dev->driver->name);
+			add_uevent_var(env, "PHYSDEVDRIVER=%s",
+				       dev->driver->name);
 	}
 #endif
 
@@ -327,7 +327,8 @@ static int device_add_groups(struct device *dev,
 			error = sysfs_create_group(&dev->kobj, groups[i]);
 			if (error) {
 				while (--i >= 0)
-					sysfs_remove_group(&dev->kobj, groups[i]);
+					sysfs_remove_group(&dev->kobj,
+							   groups[i]);
 				break;
 			}
 		}
@@ -406,14 +407,12 @@ static struct device_attribute devt_attr =
 /* kset to create /sys/devices/  */
 struct kset *devices_kset;
 
-
 /**
- *	device_create_file - create sysfs attribute file for device.
- *	@dev:	device.
- *	@attr:	device attribute descriptor.
+ * device_create_file - create sysfs attribute file for device.
+ * @dev: device.
+ * @attr: device attribute descriptor.
  */
-
-int device_create_file(struct device * dev, struct device_attribute * attr)
+int device_create_file(struct device *dev, struct device_attribute *attr)
 {
 	int error = 0;
 	if (get_device(dev)) {
@@ -424,12 +423,11 @@ int device_create_file(struct device * dev, struct device_attribute * attr)
 }
 
 /**
- *	device_remove_file - remove sysfs attribute file.
- *	@dev:	device.
- *	@attr:	device attribute descriptor.
+ * device_remove_file - remove sysfs attribute file.
+ * @dev: device.
+ * @attr: device attribute descriptor.
  */
-
-void device_remove_file(struct device * dev, struct device_attribute * attr)
+void device_remove_file(struct device *dev, struct device_attribute *attr)
 {
 	if (get_device(dev)) {
 		sysfs_remove_file(&dev->kobj, &attr->attr);
@@ -510,18 +508,16 @@ static void klist_children_put(struct klist_node *n)
 	put_device(dev);
 }
 
-
 /**
- *	device_initialize - init device structure.
- *	@dev:	device.
+ * device_initialize - init device structure.
+ * @dev: device.
  *
- *	This prepares the device for use by other layers,
- *	including adding it to the device hierarchy.
- *	It is the first half of device_register(), if called by
- *	that, though it can also be called separately, so one
- *	may use @dev's fields (e.g. the refcount).
+ * This prepares the device for use by other layers,
+ * including adding it to the device hierarchy.
+ * It is the first half of device_register(), if called by
+ * that, though it can also be called separately, so one
+ * may use @dev's fields (e.g. the refcount).
  */
-
 void device_initialize(struct device *dev)
 {
 	dev->kobj.kset = devices_kset;
@@ -754,15 +750,15 @@ static void device_remove_class_symlinks(struct device *dev)
 }
 
 /**
- *	device_add - add device to device hierarchy.
- *	@dev:	device.
+ * device_add - add device to device hierarchy.
+ * @dev: device.
  *
- *	This is part 2 of device_register(), though may be called
- *	separately _iff_ device_initialize() has been called separately.
+ * This is part 2 of device_register(), though may be called
+ * separately _iff_ device_initialize() has been called separately.
  *
- *	This adds it to the kobject hierarchy via kobject_add(), adds it
- *	to the global and sibling lists for the device, then
- *	adds it to the other relevant subsystems of the driver model.
+ * This adds it to the kobject hierarchy via kobject_add(), adds it
+ * to the global and sibling lists for the device, then
+ * adds it to the other relevant subsystems of the driver model.
  */
 int device_add(struct device *dev)
 {
@@ -870,70 +866,63 @@ int device_add(struct device *dev)
 	goto Done;
 }
 
-
 /**
- *	device_register - register a device with the system.
- *	@dev:	pointer to the device structure
+ * device_register - register a device with the system.
+ * @dev: pointer to the device structure
  *
- *	This happens in two clean steps - initialize the device
- *	and add it to the system. The two steps can be called
- *	separately, but this is the easiest and most common.
- *	I.e. you should only call the two helpers separately if
- *	have a clearly defined need to use and refcount the device
- *	before it is added to the hierarchy.
+ * This happens in two clean steps - initialize the device
+ * and add it to the system. The two steps can be called
+ * separately, but this is the easiest and most common.
+ * I.e. you should only call the two helpers separately if
+ * have a clearly defined need to use and refcount the device
+ * before it is added to the hierarchy.
  */
-
 int device_register(struct device *dev)
 {
 	device_initialize(dev);
 	return device_add(dev);
 }
 
-
 /**
- *	get_device - increment reference count for device.
- *	@dev:	device.
+ * get_device - increment reference count for device.
+ * @dev: device.
  *
- *	This simply forwards the call to kobject_get(), though
- *	we do take care to provide for the case that we get a NULL
- *	pointer passed in.
+ * This simply forwards the call to kobject_get(), though
+ * we do take care to provide for the case that we get a NULL
+ * pointer passed in.
  */
-
-struct device * get_device(struct device * dev)
+struct device *get_device(struct device *dev)
 {
 	return dev ? to_dev(kobject_get(&dev->kobj)) : NULL;
 }
 
-
 /**
- *	put_device - decrement reference count.
- *	@dev:	device in question.
+ * put_device - decrement reference count.
+ * @dev: device in question.
  */
-void put_device(struct device * dev)
+void put_device(struct device *dev)
 {
 	/* might_sleep(); */
 	if (dev)
 		kobject_put(&dev->kobj);
 }
 
-
 /**
- *	device_del - delete device from system.
- *	@dev:	device.
+ * device_del - delete device from system.
+ * @dev: device.
  *
- *	This is the first part of the device unregistration
- *	sequence. This removes the device from the lists we control
- *	from here, has it removed from the other driver model
- *	subsystems it was added to in device_add(), and removes it
- *	from the kobject hierarchy.
+ * This is the first part of the device unregistration
+ * sequence. This removes the device from the lists we control
+ * from here, has it removed from the other driver model
+ * subsystems it was added to in device_add(), and removes it
+ * from the kobject hierarchy.
  *
- *	NOTE: this should be called manually _iff_ device_add() was
- *	also called manually.
+ * NOTE: this should be called manually _iff_ device_add() was
+ * also called manually.
  */
-
-void device_del(struct device * dev)
+void device_del(struct device *dev)
 {
-	struct device * parent = dev->parent;
+	struct device *parent = dev->parent;
 	struct class_interface *class_intf;
 
 	device_pm_remove(dev);
@@ -979,47 +968,46 @@ void device_del(struct device * dev)
 }
 
 /**
- *	device_unregister - unregister device from system.
- *	@dev:	device going away.
+ * device_unregister - unregister device from system.
+ * @dev: device going away.
  *
- *	We do this in two parts, like we do device_register(). First,
- *	we remove it from all the subsystems with device_del(), then
- *	we decrement the reference count via put_device(). If that
- *	is the final reference count, the device will be cleaned up
- *	via device_release() above. Otherwise, the structure will
- *	stick around until the final reference to the device is dropped.
+ * We do this in two parts, like we do device_register(). First,
+ * we remove it from all the subsystems with device_del(), then
+ * we decrement the reference count via put_device(). If that
+ * is the final reference count, the device will be cleaned up
+ * via device_release() above. Otherwise, the structure will
+ * stick around until the final reference to the device is dropped.
  */
-void device_unregister(struct device * dev)
+void device_unregister(struct device *dev)
 {
 	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
 	device_del(dev);
 	put_device(dev);
 }
 
-
-static struct device * next_device(struct klist_iter * i)
+static struct device *next_device(struct klist_iter *i)
 {
-	struct klist_node * n = klist_next(i);
+	struct klist_node *n = klist_next(i);
 	return n ? container_of(n, struct device, knode_parent) : NULL;
 }
 
 /**
- *	device_for_each_child - device child iterator.
- *	@parent: parent struct device.
- *	@data:	data for the callback.
- *	@fn:	function to be called for each device.
+ * device_for_each_child - device child iterator.
+ * @parent: parent struct device.
+ * @data: data for the callback.
+ * @fn: function to be called for each device.
  *
- *	Iterate over @parent's child devices, and call @fn for each,
- *	passing it @data.
+ * Iterate over @parent's child devices, and call @fn for each,
+ * passing it @data.
  *
- *	We check the return of @fn each time. If it returns anything
- *	other than 0, we break out and return that value.
+ * We check the return of @fn each time. If it returns anything
+ * other than 0, we break out and return that value.
  */
-int device_for_each_child(struct device * parent, void * data,
-		     int (*fn)(struct device *, void *))
+int device_for_each_child(struct device *parent, void *data,
+			  int (*fn)(struct device *dev, void *data))
 {
 	struct klist_iter i;
-	struct device * child;
+	struct device *child;
 	int error = 0;
 
 	klist_iter_init(&parent->klist_children, &i);
@@ -1044,8 +1032,8 @@ int device_for_each_child(struct device * parent, void * data,
  * current device can be obtained, this function will return to the caller
  * and not iterate over any more devices.
  */
-struct device * device_find_child(struct device *parent, void *data,
-				  int (*match)(struct device *, void *))
+struct device *device_find_child(struct device *parent, void *data,
+				 int (*match)(struct device *dev, void *data))
 {
 	struct klist_iter i;
 	struct device *child;
@@ -1312,8 +1300,7 @@ static int device_move_class_links(struct device *dev,
 					  class_name);
 		if (error)
 			sysfs_remove_link(&dev->kobj, "device");
-	}
-	else
+	} else
 		error = 0;
 out:
 	kfree(class_name);
@@ -1344,7 +1331,7 @@ int device_move(struct device *dev, struct device *new_parent)
 		return -EINVAL;
 
 	new_parent = get_device(new_parent);
-	new_parent_kobj = get_device_parent (dev, new_parent);
+	new_parent_kobj = get_device_parent(dev, new_parent);
 
 	pr_debug("device: '%s': %s: moving to '%s'\n", dev->bus_id,
 		 __FUNCTION__, new_parent ? new_parent->bus_id : "<NULL>");
@@ -1390,7 +1377,7 @@ EXPORT_SYMBOL_GPL(device_move);
  */
 void device_shutdown(void)
 {
-	struct device * dev, *devn;
+	struct device *dev, *devn;
 
 	list_for_each_entry_safe_reverse(dev, devn, &devices_kset->list,
 				kobj.entry) {

commit 63b6971a0876b744e2fcf3c9df15d130501e1deb
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Jan 21 16:09:44 2008 +0100

    Driver core: Cleanup get_device_parent() in device_add() and device_move()
    
    Make setup_parent() void as get_device_parent() will always return
    either a valid kobject or NULL.
    Introduce cleanup_glue_dir() to drop reference grabbed on "glue"
    directory by get_device_parent(). Use it for cleanup in device_move()
    and device_add() on errors.
    
    This should fix the refcounting problem reported in
    http://marc.info/?l=linux-kernel&m=120052487909200&w=2
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Cc: Gabor Gombas <gombasg@sztaki.hu>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d5d542db96fd..f09dde3b1e27 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -552,6 +552,8 @@ static struct kobject *get_device_parent(struct device *dev,
 }
 
 static inline void cleanup_device_parent(struct device *dev) {}
+static inline void cleanup_glue_dir(struct device *dev,
+				    struct kobject *glue_dir) {}
 #else
 static struct kobject *virtual_device_parent(struct device *dev)
 {
@@ -616,27 +618,27 @@ static struct kobject *get_device_parent(struct device *dev,
 	return NULL;
 }
 
-static void cleanup_device_parent(struct device *dev)
+static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
 {
-	struct kobject *glue_dir = dev->kobj.parent;
-
 	/* see if we live in a "glue" directory */
 	if (!dev->class || glue_dir->kset != &dev->class->class_dirs)
 		return;
 
 	kobject_put(glue_dir);
 }
+
+static void cleanup_device_parent(struct device *dev)
+{
+	cleanup_glue_dir(dev, dev->kobj.parent);
+}
 #endif
 
-static int setup_parent(struct device *dev, struct device *parent)
+static void setup_parent(struct device *dev, struct device *parent)
 {
 	struct kobject *kobj;
 	kobj = get_device_parent(dev, parent);
-	if (IS_ERR(kobj))
-		return PTR_ERR(kobj);
 	if (kobj)
 		dev->kobj.parent = kobj;
-	return 0;
 }
 
 static int device_add_class_symlinks(struct device *dev)
@@ -784,9 +786,7 @@ int device_add(struct device *dev)
 	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
 
 	parent = get_device(dev->parent);
-	error = setup_parent(dev, parent);
-	if (error)
-		goto Error;
+	setup_parent(dev, parent);
 
 	/* first, register with generic layer. */
 	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev->bus_id);
@@ -864,6 +864,7 @@ int device_add(struct device *dev)
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
  Error:
+	cleanup_device_parent(dev);
 	if (parent)
 		put_device(parent);
 	goto Done;
@@ -1344,15 +1345,12 @@ int device_move(struct device *dev, struct device *new_parent)
 
 	new_parent = get_device(new_parent);
 	new_parent_kobj = get_device_parent (dev, new_parent);
-	if (IS_ERR(new_parent_kobj)) {
-		error = PTR_ERR(new_parent_kobj);
-		put_device(new_parent);
-		goto out;
-	}
+
 	pr_debug("device: '%s': %s: moving to '%s'\n", dev->bus_id,
 		 __FUNCTION__, new_parent ? new_parent->bus_id : "<NULL>");
 	error = kobject_move(&dev->kobj, new_parent_kobj);
 	if (error) {
+		cleanup_glue_dir(dev, new_parent_kobj);
 		put_device(new_parent);
 		goto out;
 	}
@@ -1375,6 +1373,7 @@ int device_move(struct device *dev, struct device *new_parent)
 				klist_add_tail(&dev->knode_parent,
 					       &old_parent->klist_children);
 		}
+		cleanup_glue_dir(dev, new_parent_kobj);
 		put_device(new_parent);
 		goto out;
 	}

commit 0f4dafc0563c6c49e17fe14b3f5f356e4c4b8806
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 19 01:40:42 2007 +0100

    Kobject: auto-cleanup on final unref
    
    We save the current state in the object itself, so we can do proper
    cleanup when the last reference is dropped.
    
    If the initial reference is dropped, the object will be removed from
    sysfs if needed, if an "add" event was sent, "remove" will be send, and
    the allocated resources are released.
    
    This allows us to clean up some driver core usage as well as allowing us
    to do other such changes to the rest of the kernel.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 675a719dcdd2..d5d542db96fd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -576,8 +576,8 @@ static struct kobject *get_device_parent(struct device *dev,
 
 		/*
 		 * If we have no parent, we live in "virtual".
-		 * Class-devices with a bus-device as parent, live
-		 * in a class-directory to prevent namespace collisions.
+		 * Class-devices with a non class-device as parent, live
+		 * in a "glue" directory to prevent namespace collisions.
 		 */
 		if (parent == NULL)
 			parent_kobj = virtual_device_parent(dev);
@@ -607,8 +607,7 @@ static struct kobject *get_device_parent(struct device *dev,
 			kobject_put(k);
 			return NULL;
 		}
-		/* Do not emit a uevent, as it's not needed for this
-		 * "class glue" directory. */
+		/* do not emit an uevent for this simple "glue" directory */
 		return k;
 	}
 
@@ -619,30 +618,13 @@ static struct kobject *get_device_parent(struct device *dev,
 
 static void cleanup_device_parent(struct device *dev)
 {
-	struct device *d;
-	int other = 0;
+	struct kobject *glue_dir = dev->kobj.parent;
 
-	if (!dev->class)
-		return;
-
-	/* see if we live in a parent class directory */
-	if (dev->kobj.parent->kset != &dev->class->class_dirs)
+	/* see if we live in a "glue" directory */
+	if (!dev->class || glue_dir->kset != &dev->class->class_dirs)
 		return;
 
-	/* if we are the last child of our class, delete the directory */
-	down(&dev->class->sem);
-	list_for_each_entry(d, &dev->class->devices, node) {
-		if (d == dev)
-			continue;
-		if (d->kobj.parent == dev->kobj.parent) {
-			other = 1;
-			break;
-		}
-	}
-	if (!other)
-		kobject_del(dev->kobj.parent);
-	kobject_put(dev->kobj.parent);
-	up(&dev->class->sem);
+	kobject_put(glue_dir);
 }
 #endif
 

commit f9cb074bff8e762ef24c44678a5a7d907f82fbeb
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: rename kobject_init_ng() to kobject_init()
    
    Now that the old kobject_init() function is gone, rename
    kobject_init_ng() to kobject_init() to clean up the namespace.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e88170293ca0..675a719dcdd2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -525,7 +525,7 @@ static void klist_children_put(struct klist_node *n)
 void device_initialize(struct device *dev)
 {
 	dev->kobj.kset = devices_kset;
-	kobject_init_ng(&dev->kobj, &device_ktype);
+	kobject_init(&dev->kobj, &device_ktype);
 	klist_init(&dev->klist_children, klist_children_get,
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);

commit b2d6db5878a0832659ed58476357eea2db915550
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: rename kobject_add_ng() to kobject_add()
    
    Now that the old kobject_add() function is gone, rename kobject_add_ng()
    to kobject_add() to clean up the namespace.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 06e8738ab263..e88170293ca0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -602,7 +602,7 @@ static struct kobject *get_device_parent(struct device *dev,
 		if (!k)
 			return NULL;
 		k->kset = &dev->class->class_dirs;
-		retval = kobject_add_ng(k, parent_kobj, "%s", dev->class->name);
+		retval = kobject_add(k, parent_kobj, "%s", dev->class->name);
 		if (retval < 0) {
 			kobject_put(k);
 			return NULL;
@@ -776,7 +776,7 @@ static void device_remove_class_symlinks(struct device *dev)
  *	This is part 2 of device_register(), though may be called
  *	separately _iff_ device_initialize() has been called separately.
  *
- *	This adds it to the kobject hierarchy via kobject_add_ng(), adds it
+ *	This adds it to the kobject hierarchy via kobject_add(), adds it
  *	to the global and sibling lists for the device, then
  *	adds it to the other relevant subsystems of the driver model.
  */
@@ -807,7 +807,7 @@ int device_add(struct device *dev)
 		goto Error;
 
 	/* first, register with generic layer. */
-	error = kobject_add_ng(&dev->kobj, dev->kobj.parent, "%s", dev->bus_id);
+	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev->bus_id);
 	if (error)
 		goto Error;
 

commit edfaa7c36574f1bf09c65ad602412db9da5f96bf
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon May 21 22:08:01 2007 +0200

    Driver core: convert block from raw kobjects to core devices
    
    This moves the block devices to /sys/class/block. It will create a
    flat list of all block devices, with the disks and partitions in one
    directory. For compatibility /sys/block is created and contains symlinks
    to the disks.
    
      /sys/class/block
      |-- sda -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda
      |-- sda1 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda1
      |-- sda10 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda10
      |-- sda5 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda5
      |-- sda6 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda6
      |-- sda7 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda7
      |-- sda8 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda8
      |-- sda9 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda9
      `-- sr0 -> ../../devices/pci0000:00/0000:00:1f.2/host1/target1:0:0/1:0:0:0/block/sr0
    
      /sys/block/
      |-- sda -> ../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda
      `-- sr0 -> ../devices/pci0000:00/0000:00:1f.2/host1/target1:0:0/1:0:0:0/block/sr0
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 13cae18936c5..06e8738ab263 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -671,14 +671,15 @@ static int device_add_class_symlinks(struct device *dev)
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	/* stacked class devices need a symlink in the class directory */
-	if (dev->kobj.parent != &dev->class->subsys.kobj) {
+	if (dev->kobj.parent != &dev->class->subsys.kobj &&
+	    dev->type != &part_type) {
 		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
 					  dev->bus_id);
 		if (error)
 			goto out_subsys;
 	}
 
-	if (dev->parent) {
+	if (dev->parent && dev->type != &part_type) {
 		struct device *parent = dev->parent;
 		char *class_name;
 
@@ -707,10 +708,11 @@ static int device_add_class_symlinks(struct device *dev)
 	return 0;
 
 out_device:
-	if (dev->parent)
+	if (dev->parent && dev->type != &part_type)
 		sysfs_remove_link(&dev->kobj, "device");
 out_busid:
-	if (dev->kobj.parent != &dev->class->subsys.kobj)
+	if (dev->kobj.parent != &dev->class->subsys.kobj &&
+	    dev->type != &part_type)
 		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
 #else
 	/* link in the class directory pointing to the device */
@@ -719,7 +721,7 @@ static int device_add_class_symlinks(struct device *dev)
 	if (error)
 		goto out_subsys;
 
-	if (dev->parent) {
+	if (dev->parent && dev->type != &part_type) {
 		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
 					  "device");
 		if (error)
@@ -743,7 +745,7 @@ static void device_remove_class_symlinks(struct device *dev)
 		return;
 
 #ifdef CONFIG_SYSFS_DEPRECATED
-	if (dev->parent) {
+	if (dev->parent && dev->type != &part_type) {
 		char *class_name;
 
 		class_name = make_class_name(dev->class->name, &dev->kobj);
@@ -754,10 +756,11 @@ static void device_remove_class_symlinks(struct device *dev)
 		sysfs_remove_link(&dev->kobj, "device");
 	}
 
-	if (dev->kobj.parent != &dev->class->subsys.kobj)
+	if (dev->kobj.parent != &dev->class->subsys.kobj &&
+	    dev->type != &part_type)
 		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
 #else
-	if (dev->parent)
+	if (dev->parent && dev->type != &part_type)
 		sysfs_remove_link(&dev->kobj, "device");
 
 	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
@@ -925,6 +928,7 @@ struct device * get_device(struct device * dev)
  */
 void put_device(struct device * dev)
 {
+	/* might_sleep(); */
 	if (dev)
 		kobject_put(&dev->kobj);
 }

commit da231fd5d113ab6da5dab7a2d2c38d0a540f939c
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Nov 21 17:29:15 2007 +0100

    Driver core: fix class glue dir cleanup logic
    
    We should remove the glue directory between the class and the bus
    device _after_ we sent out the 'remove' event for the device, otherwise
    the parent relationship is no longer valid, and composing the path
    with deleted sysfs entries will not work.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 22fdf320a2a6..13cae18936c5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -18,7 +18,7 @@
 #include <linux/string.h>
 #include <linux/kdev_t.h>
 #include <linux/notifier.h>
-
+#include <linux/genhd.h>
 #include <asm/semaphore.h>
 
 #include "base.h"
@@ -538,22 +538,20 @@ void device_initialize(struct device *dev)
 }
 
 #ifdef CONFIG_SYSFS_DEPRECATED
-static struct kobject * get_device_parent(struct device *dev,
-					  struct device *parent)
+static struct kobject *get_device_parent(struct device *dev,
+					 struct device *parent)
 {
-	/*
-	 * Set the parent to the class, not the parent device
-	 * for topmost devices in class hierarchy.
-	 * This keeps sysfs from having a symlink to make old
-	 * udevs happy
-	 */
+	/* class devices without a parent live in /sys/class/<classname>/ */
 	if (dev->class && (!parent || parent->class != dev->class))
 		return &dev->class->subsys.kobj;
+	/* all other devices keep their parent */
 	else if (parent)
 		return &parent->kobj;
 
 	return NULL;
 }
+
+static inline void cleanup_device_parent(struct device *dev) {}
 #else
 static struct kobject *virtual_device_parent(struct device *dev)
 {
@@ -566,8 +564,8 @@ static struct kobject *virtual_device_parent(struct device *dev)
 	return virtual_dir;
 }
 
-static struct kobject * get_device_parent(struct device *dev,
-					  struct device *parent)
+static struct kobject *get_device_parent(struct device *dev,
+					 struct device *parent)
 {
 	int retval;
 
@@ -618,6 +616,34 @@ static struct kobject * get_device_parent(struct device *dev,
 		return &parent->kobj;
 	return NULL;
 }
+
+static void cleanup_device_parent(struct device *dev)
+{
+	struct device *d;
+	int other = 0;
+
+	if (!dev->class)
+		return;
+
+	/* see if we live in a parent class directory */
+	if (dev->kobj.parent->kset != &dev->class->class_dirs)
+		return;
+
+	/* if we are the last child of our class, delete the directory */
+	down(&dev->class->sem);
+	list_for_each_entry(d, &dev->class->devices, node) {
+		if (d == dev)
+			continue;
+		if (d->kobj.parent == dev->kobj.parent) {
+			other = 1;
+			break;
+		}
+	}
+	if (!other)
+		kobject_del(dev->kobj.parent);
+	kobject_put(dev->kobj.parent);
+	up(&dev->class->sem);
+}
 #endif
 
 static int setup_parent(struct device *dev, struct device *parent)
@@ -637,65 +663,74 @@ static int device_add_class_symlinks(struct device *dev)
 
 	if (!dev->class)
 		return 0;
+
 	error = sysfs_create_link(&dev->kobj, &dev->class->subsys.kobj,
 				  "subsystem");
 	if (error)
 		goto out;
-	/*
-	 * If this is not a "fake" compatible device, then create the
-	 * symlink from the class to the device.
-	 */
+
+#ifdef CONFIG_SYSFS_DEPRECATED
+	/* stacked class devices need a symlink in the class directory */
 	if (dev->kobj.parent != &dev->class->subsys.kobj) {
 		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
 					  dev->bus_id);
 		if (error)
 			goto out_subsys;
 	}
+
 	if (dev->parent) {
-#ifdef CONFIG_SYSFS_DEPRECATED
-		{
-			struct device *parent = dev->parent;
-			char *class_name;
-
-			/*
-			 * In old sysfs stacked class devices had 'device'
-			 * link pointing to real device instead of parent
-			 */
-			while (parent->class && !parent->bus && parent->parent)
-				parent = parent->parent;
-
-			error = sysfs_create_link(&dev->kobj,
-						  &parent->kobj,
-						  "device");
-			if (error)
-				goto out_busid;
+		struct device *parent = dev->parent;
+		char *class_name;
 
-			class_name = make_class_name(dev->class->name,
-							&dev->kobj);
-			if (class_name)
-				error = sysfs_create_link(&dev->parent->kobj,
-							&dev->kobj, class_name);
-			kfree(class_name);
-			if (error)
-				goto out_device;
-		}
-#else
-		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
+		/*
+		 * stacked class devices have the 'device' link
+		 * pointing to the bus device instead of the parent
+		 */
+		while (parent->class && !parent->bus && parent->parent)
+			parent = parent->parent;
+
+		error = sysfs_create_link(&dev->kobj,
+					  &parent->kobj,
 					  "device");
 		if (error)
 			goto out_busid;
-#endif
+
+		class_name = make_class_name(dev->class->name,
+						&dev->kobj);
+		if (class_name)
+			error = sysfs_create_link(&dev->parent->kobj,
+						&dev->kobj, class_name);
+		kfree(class_name);
+		if (error)
+			goto out_device;
 	}
 	return 0;
 
-#ifdef CONFIG_SYSFS_DEPRECATED
 out_device:
 	if (dev->parent)
 		sysfs_remove_link(&dev->kobj, "device");
-#endif
 out_busid:
 	if (dev->kobj.parent != &dev->class->subsys.kobj)
 		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+#else
+	/* link in the class directory pointing to the device */
+	error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
+				  dev->bus_id);
+	if (error)
+		goto out_subsys;
+
+	if (dev->parent) {
+		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
+					  "device");
+		if (error)
+			goto out_busid;
+	}
+	return 0;
+
+out_busid:
+	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+#endif
+
 out_subsys:
 	sysfs_remove_link(&dev->kobj, "subsystem");
 out:
@@ -706,8 +741,9 @@ static void device_remove_class_symlinks(struct device *dev)
 {
 	if (!dev->class)
 		return;
-	if (dev->parent) {
+
 #ifdef CONFIG_SYSFS_DEPRECATED
+	if (dev->parent) {
 		char *class_name;
 
 		class_name = make_class_name(dev->class->name, &dev->kobj);
@@ -715,11 +751,18 @@ static void device_remove_class_symlinks(struct device *dev)
 			sysfs_remove_link(&dev->parent->kobj, class_name);
 			kfree(class_name);
 		}
-#endif
 		sysfs_remove_link(&dev->kobj, "device");
 	}
+
 	if (dev->kobj.parent != &dev->class->subsys.kobj)
 		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+#else
+	if (dev->parent)
+		sysfs_remove_link(&dev->kobj, "device");
+
+	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+#endif
+
 	sysfs_remove_link(&dev->kobj, "subsystem");
 }
 
@@ -830,26 +873,6 @@ int device_add(struct device *dev)
  SymlinkError:
 	if (MAJOR(dev->devt))
 		device_remove_file(dev, &devt_attr);
-
-	if (dev->class) {
-		sysfs_remove_link(&dev->kobj, "subsystem");
-		/* If this is not a "fake" compatible device, remove the
-		 * symlink from the class to the device. */
-		if (dev->kobj.parent != &dev->class->subsys.kobj)
-			sysfs_remove_link(&dev->class->subsys.kobj,
-					  dev->bus_id);
-		if (parent) {
-#ifdef CONFIG_SYSFS_DEPRECATED
-			char *class_name = make_class_name(dev->class->name,
-							   &dev->kobj);
-			if (class_name)
-				sysfs_remove_link(&dev->parent->kobj,
-						  class_name);
-			kfree(class_name);
-#endif
-			sysfs_remove_link(&dev->kobj, "device");
-		}
-	}
  ueventattrError:
 	device_remove_file(dev, &uevent_attr);
  attrError:
@@ -932,23 +955,7 @@ void device_del(struct device * dev)
 	if (MAJOR(dev->devt))
 		device_remove_file(dev, &devt_attr);
 	if (dev->class) {
-		sysfs_remove_link(&dev->kobj, "subsystem");
-		/* If this is not a "fake" compatible device, remove the
-		 * symlink from the class to the device. */
-		if (dev->kobj.parent != &dev->class->subsys.kobj)
-			sysfs_remove_link(&dev->class->subsys.kobj,
-					  dev->bus_id);
-		if (parent) {
-#ifdef CONFIG_SYSFS_DEPRECATED
-			char *class_name = make_class_name(dev->class->name,
-							   &dev->kobj);
-			if (class_name)
-				sysfs_remove_link(&dev->parent->kobj,
-						  class_name);
-			kfree(class_name);
-#endif
-			sysfs_remove_link(&dev->kobj, "device");
-		}
+		device_remove_class_symlinks(dev);
 
 		down(&dev->class->sem);
 		/* notify any interfaces that the device is now gone */
@@ -958,31 +965,6 @@ void device_del(struct device * dev)
 		/* remove the device from the class list */
 		list_del_init(&dev->node);
 		up(&dev->class->sem);
-
-		/* If we live in a parent class-directory, unreference it */
-		if (dev->kobj.parent->kset == &dev->class->class_dirs) {
-			struct device *d;
-			int other = 0;
-
-			/*
-			 * if we are the last child of our class, delete
-			 * our class-directory at this parent
-			 */
-			down(&dev->class->sem);
-			list_for_each_entry(d, &dev->class->devices, node) {
-				if (d == dev)
-					continue;
-				if (d->kobj.parent == dev->kobj.parent) {
-					other = 1;
-					break;
-				}
-			}
-			if (!other)
-				kobject_del(dev->kobj.parent);
-
-			kobject_put(dev->kobj.parent);
-			up(&dev->class->sem);
-		}
 	}
 	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);
@@ -1004,9 +986,9 @@ void device_del(struct device * dev)
 		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
+	cleanup_device_parent(dev);
 	kobject_del(&dev->kobj);
-	if (parent)
-		put_device(parent);
+	put_device(parent);
 }
 
 /**

commit 7dc72b2842381684b864750af31a5fb168dec764
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 23:49:41 2007 -0800

    Driver core: clean up debugging messages
    
    The driver core debugging messages are a mess.  This provides a unified
    message that makes them actually useful.
    
    The format for new kobject debug messages should be:
            driver/bus/class: 'OBJECT_NAME': FUNCTION_NAME: message.\n
    
    Note, the class code is not changed in this patch due to pending patches
    in my queue that this would conflict with.  A later patch will clean
    them up.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 414a480e10a3..22fdf320a2a6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -193,15 +193,16 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	if (dev->bus && dev->bus->uevent) {
 		retval = dev->bus->uevent(dev, env);
 		if (retval)
-			pr_debug ("%s: bus uevent() returned %d\n",
-				  __FUNCTION__, retval);
+			pr_debug("device: '%s': %s: bus uevent() returned %d\n",
+				 dev->bus_id, __FUNCTION__, retval);
 	}
 
 	/* have the class specific function add its stuff */
 	if (dev->class && dev->class->dev_uevent) {
 		retval = dev->class->dev_uevent(dev, env);
 		if (retval)
-			pr_debug("%s: class uevent() returned %d\n",
+			pr_debug("device: '%s': %s: class uevent() "
+				 "returned %d\n", dev->bus_id,
 				 __FUNCTION__, retval);
 	}
 
@@ -209,7 +210,8 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj,
 	if (dev->type && dev->type->uevent) {
 		retval = dev->type->uevent(dev, env);
 		if (retval)
-			pr_debug("%s: dev_type uevent() returned %d\n",
+			pr_debug("device: '%s': %s: dev_type uevent() "
+				 "returned %d\n", dev->bus_id,
 				 __FUNCTION__, retval);
 	}
 
@@ -751,7 +753,7 @@ int device_add(struct device *dev)
 		goto Error;
 	}
 
-	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);
+	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
 
 	parent = get_device(dev->parent);
 	error = setup_parent(dev, parent);
@@ -1020,7 +1022,7 @@ void device_del(struct device * dev)
  */
 void device_unregister(struct device * dev)
 {
-	pr_debug("DEV: Unregistering device. ID = '%s'\n", dev->bus_id);
+	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
 	device_del(dev);
 	put_device(dev);
 }
@@ -1116,7 +1118,7 @@ EXPORT_SYMBOL_GPL(device_remove_file);
 
 static void device_create_release(struct device *dev)
 {
-	pr_debug("%s called for %s\n", __FUNCTION__, dev->bus_id);
+	pr_debug("device: '%s': %s\n", dev->bus_id, __FUNCTION__);
 	kfree(dev);
 }
 
@@ -1259,7 +1261,8 @@ int device_rename(struct device *dev, char *new_name)
 	if (!dev)
 		return -EINVAL;
 
-	pr_debug("DEVICE: renaming '%s' to '%s'\n", dev->bus_id, new_name);
+	pr_debug("device: '%s': %s: renaming to '%s'\n", dev->bus_id,
+		 __FUNCTION__, new_name);
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	if ((dev->class) && (dev->parent))
@@ -1378,8 +1381,8 @@ int device_move(struct device *dev, struct device *new_parent)
 		put_device(new_parent);
 		goto out;
 	}
-	pr_debug("DEVICE: moving '%s' to '%s'\n", dev->bus_id,
-		 new_parent ? new_parent->bus_id : "<NULL>");
+	pr_debug("device: '%s': %s: moving to '%s'\n", dev->bus_id,
+		 __FUNCTION__, new_parent ? new_parent->bus_id : "<NULL>");
 	error = kobject_move(&dev->kobj, new_parent_kobj);
 	if (error) {
 		put_device(new_parent);

commit c6f7e72a3f4641095ade9ded287d910c980c6148
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 19:41:16 2007 -0700

    driver core: remove fields from struct bus_type
    
    struct bus_type is static everywhere in the kernel.  This moves the
    kobject in the structure out of it, and a bunch of other private only to
    the driver core fields are now moved to a private structure.  This lets
    us dynamically create the backing kobject properly and gives us the
    chance to be able to document to users exactly how to use the struct
    bus_type as there are no fields they can improperly access.
    
    Thanks to Kay for the build fixes on this patch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index beb351600675..414a480e10a3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -769,7 +769,7 @@ int device_add(struct device *dev)
 
 	/* notify clients of device entry (new way) */
 	if (dev->bus)
-		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	error = device_create_file(dev, &uevent_attr);
@@ -820,7 +820,7 @@ int device_add(struct device *dev)
 	dpm_sysfs_remove(dev);
  PMError:
 	if (dev->bus)
-		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
 	device_remove_attrs(dev);
  AttrsError:
@@ -999,7 +999,7 @@ void device_del(struct device * dev)
 	if (platform_notify_remove)
 		platform_notify_remove(dev);
 	if (dev->bus)
-		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);

commit 9990513c1ef040528c4e38163a073089d39c7903
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: convert drivers/base/core.c to use kobject_init/add_ng()
    
    This converts the code to use the new kobject functions, cleaning up the
    logic in doing so.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b3a931fe6b16..beb351600675 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -523,8 +523,7 @@ static void klist_children_put(struct klist_node *n)
 void device_initialize(struct device *dev)
 {
 	dev->kobj.kset = devices_kset;
-	dev->kobj.ktype = &device_ktype;
-	kobject_init(&dev->kobj);
+	kobject_init_ng(&dev->kobj, &device_ktype);
 	klist_init(&dev->klist_children, klist_children_get,
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
@@ -729,7 +728,7 @@ static void device_remove_class_symlinks(struct device *dev)
  *	This is part 2 of device_register(), though may be called
  *	separately _iff_ device_initialize() has been called separately.
  *
- *	This adds it to the kobject hierarchy via kobject_add(), adds it
+ *	This adds it to the kobject hierarchy via kobject_add_ng(), adds it
  *	to the global and sibling lists for the device, then
  *	adds it to the other relevant subsystems of the driver model.
  */
@@ -760,8 +759,7 @@ int device_add(struct device *dev)
 		goto Error;
 
 	/* first, register with generic layer. */
-	kobject_set_name(&dev->kobj, "%s", dev->bus_id);
-	error = kobject_add(&dev->kobj);
+	error = kobject_add_ng(&dev->kobj, dev->kobj.parent, "%s", dev->bus_id);
 	if (error)
 		goto Error;
 

commit 37b0c020343080241984d978981d6caf877b278a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 26 22:11:55 2007 -0800

    driver core: clean up device_shutdown
    
    device_shutdown does not need to be in a separate file.  Move it into
    the driver core file where it belongs.
    
    This also moves us one more step closer to making devices_kset static,
    now only the crazy sysdevs are keeping that from happening...
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d2de2d59af42..b3a931fe6b16 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1415,5 +1415,23 @@ int device_move(struct device *dev, struct device *new_parent)
 	put_device(dev);
 	return error;
 }
-
 EXPORT_SYMBOL_GPL(device_move);
+
+/**
+ * device_shutdown - call ->shutdown() on each device to shutdown.
+ */
+void device_shutdown(void)
+{
+	struct device * dev, *devn;
+
+	list_for_each_entry_safe_reverse(dev, devn, &devices_kset->list,
+				kobj.entry) {
+		if (dev->bus && dev->bus->shutdown) {
+			dev_dbg(dev, "shutdown\n");
+			dev->bus->shutdown(dev);
+		} else if (dev->driver && dev->driver->shutdown) {
+			dev_dbg(dev, "shutdown\n");
+			dev->driver->shutdown(dev);
+		}
+	}
+}

commit 881c6cfd7c5edfe6129006e2404654bfe5911050
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 09:29:06 2007 -0600

    kset: convert /sys/devices to use kset_create
    
    Dynamically create the kset instead of declaring it statically.  We also
    rename devices_subsys to devices_kset to catch all users of the
    variable.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7762ee86697d..d2de2d59af42 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -401,11 +401,8 @@ static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
 static struct device_attribute devt_attr =
 	__ATTR(dev, S_IRUGO, show_dev, NULL);
 
-/*
- *	devices_subsys - structure to be registered with kobject core.
- */
-
-decl_subsys(devices, &device_uevent_ops);
+/* kset to create /sys/devices/  */
+struct kset *devices_kset;
 
 
 /**
@@ -525,7 +522,7 @@ static void klist_children_put(struct klist_node *n)
 
 void device_initialize(struct device *dev)
 {
-	dev->kobj.kset = &devices_subsys;
+	dev->kobj.kset = devices_kset;
 	dev->kobj.ktype = &device_ktype;
 	kobject_init(&dev->kobj);
 	klist_init(&dev->klist_children, klist_children_get,
@@ -563,7 +560,7 @@ static struct kobject *virtual_device_parent(struct device *dev)
 
 	if (!virtual_dir)
 		virtual_dir = kobject_create_and_add("virtual",
-						     &devices_subsys.kobj);
+						     &devices_kset->kobj);
 
 	return virtual_dir;
 }
@@ -1097,7 +1094,10 @@ struct device * device_find_child(struct device *parent, void *data,
 
 int __init devices_init(void)
 {
-	return subsystem_register(&devices_subsys);
+	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
+	if (!devices_kset)
+		return -ENOMEM;
+	return 0;
 }
 
 EXPORT_SYMBOL_GPL(device_for_each_child);

commit 43968d2f1648f4dc92437dc0363a3e88377445b3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 5 22:24:43 2007 -0800

    kobject: get rid of kobject_kset_add_dir
    
    kobject_kset_add_dir is only called in one place so remove it and use
    kobject_create() instead.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 992eba3289bd..7762ee86697d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -571,6 +571,8 @@ static struct kobject *virtual_device_parent(struct device *dev)
 static struct kobject * get_device_parent(struct device *dev,
 					  struct device *parent)
 {
+	int retval;
+
 	if (dev->class) {
 		struct kobject *kobj = NULL;
 		struct kobject *parent_kobj;
@@ -600,8 +602,18 @@ static struct kobject * get_device_parent(struct device *dev,
 			return kobj;
 
 		/* or create a new class-directory at the parent device */
-		return kobject_kset_add_dir(&dev->class->class_dirs,
-					    parent_kobj, dev->class->name);
+		k = kobject_create();
+		if (!k)
+			return NULL;
+		k->kset = &dev->class->class_dirs;
+		retval = kobject_add_ng(k, parent_kobj, "%s", dev->class->name);
+		if (retval < 0) {
+			kobject_put(k);
+			return NULL;
+		}
+		/* Do not emit a uevent, as it's not needed for this
+		 * "class glue" directory. */
+		return k;
 	}
 
 	if (parent)

commit 4ff6abff832fbc6cb1d769f6106c841bc2b09f63
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 5 22:24:43 2007 -0800

    kobject: get rid of kobject_add_dir
    
    kobject_create_and_add is the same as kobject_add_dir, so drop
    kobject_add_dir.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c8f2ac03d46d..992eba3289bd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -562,7 +562,8 @@ static struct kobject *virtual_device_parent(struct device *dev)
 	static struct kobject *virtual_dir = NULL;
 
 	if (!virtual_dir)
-		virtual_dir = kobject_add_dir(&devices_subsys.kobj, "virtual");
+		virtual_dir = kobject_create_and_add("virtual",
+						     &devices_subsys.kobj);
 
 	return virtual_dir;
 }

commit 3514faca19a6fdc209734431c509631ea92b094e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 16 10:11:44 2007 -0600

    kobject: remove struct kobj_type from struct kset
    
    We don't need a "default" ktype for a kset.  We should set this
    explicitly every time for each kset.  This change is needed so that we
    can make ksets dynamic, and cleans up one of the odd, undocumented
    assumption that the kset/kobject/ktype model has.
    
    This patch is based on a lot of help from Kay Sievers.
    
    Nasty bug in the block code was found by Dave Young
    <hidave.darkstar@gmail.com>
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ce6b64c489ad..c8f2ac03d46d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -405,7 +405,7 @@ static struct device_attribute devt_attr =
  *	devices_subsys - structure to be registered with kobject core.
  */
 
-decl_subsys(devices, &device_ktype, &device_uevent_ops);
+decl_subsys(devices, &device_uevent_ops);
 
 
 /**
@@ -525,7 +525,8 @@ static void klist_children_put(struct klist_node *n)
 
 void device_initialize(struct device *dev)
 {
-	kobj_set_kset_s(dev, devices_subsys);
+	dev->kobj.kset = &devices_subsys;
+	dev->kobj.ktype = &device_ktype;
 	kobject_init(&dev->kobj);
 	klist_init(&dev->klist_children, klist_children_get,
 		   klist_children_put);

commit 775b64d2b6ca37697de925f70799c710aab5849a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 12 20:40:46 2008 +0100

    PM: Acquire device locks on suspend
    
    This patch reorganizes the way suspend and resume notifications are
    sent to drivers.  The major changes are that now the PM core acquires
    every device semaphore before calling the methods, and calls to
    device_add() during suspends will fail, while calls to device_del()
    during suspends will block.
    
    It also provides a way to safely remove a suspended device with the
    help of the PM core, by using the device_pm_schedule_removal() callback
    introduced specifically for this purpose, and updates two drivers (msr
    and cpuid) that need to use it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 2683eac30c68..ce6b64c489ad 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -726,11 +726,20 @@ int device_add(struct device *dev)
 {
 	struct device *parent = NULL;
 	struct class_interface *class_intf;
-	int error = -EINVAL;
+	int error;
+
+	error = pm_sleep_lock();
+	if (error) {
+		dev_warn(dev, "Suspicious %s during suspend\n", __FUNCTION__);
+		dump_stack();
+		return error;
+	}
 
 	dev = get_device(dev);
-	if (!dev || !strlen(dev->bus_id))
+	if (!dev || !strlen(dev->bus_id)) {
+		error = -EINVAL;
 		goto Error;
+	}
 
 	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);
 
@@ -795,6 +804,7 @@ int device_add(struct device *dev)
 	}
  Done:
 	put_device(dev);
+	pm_sleep_unlock();
 	return error;
  BusError:
 	device_pm_remove(dev);
@@ -905,6 +915,7 @@ void device_del(struct device * dev)
 	struct device * parent = dev->parent;
 	struct class_interface *class_intf;
 
+	device_pm_remove(dev);
 	if (parent)
 		klist_del(&dev->knode_parent);
 	if (MAJOR(dev->devt))
@@ -981,7 +992,6 @@ void device_del(struct device * dev)
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
-	device_pm_remove(dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
 	if (parent)
@@ -1156,14 +1166,11 @@ struct device *device_create(struct class *class, struct device *parent,
 EXPORT_SYMBOL_GPL(device_create);
 
 /**
- * device_destroy - removes a device that was created with device_create()
+ * find_device - finds a device that was created with device_create()
  * @class: pointer to the struct class that this device was registered with
  * @devt: the dev_t of the device that was previously registered
- *
- * This call unregisters and cleans up a device that was created with a
- * call to device_create().
  */
-void device_destroy(struct class *class, dev_t devt)
+static struct device *find_device(struct class *class, dev_t devt)
 {
 	struct device *dev = NULL;
 	struct device *dev_tmp;
@@ -1176,12 +1183,54 @@ void device_destroy(struct class *class, dev_t devt)
 		}
 	}
 	up(&class->sem);
+	return dev;
+}
 
+/**
+ * device_destroy - removes a device that was created with device_create()
+ * @class: pointer to the struct class that this device was registered with
+ * @devt: the dev_t of the device that was previously registered
+ *
+ * This call unregisters and cleans up a device that was created with a
+ * call to device_create().
+ */
+void device_destroy(struct class *class, dev_t devt)
+{
+	struct device *dev;
+
+	dev = find_device(class, devt);
 	if (dev)
 		device_unregister(dev);
 }
 EXPORT_SYMBOL_GPL(device_destroy);
 
+#ifdef CONFIG_PM_SLEEP
+/**
+ * destroy_suspended_device - asks the PM core to remove a suspended device
+ * @class: pointer to the struct class that this device was registered with
+ * @devt: the dev_t of the device that was previously registered
+ *
+ * This call notifies the PM core of the necessity to unregister a suspended
+ * device created with a call to device_create() (devices cannot be
+ * unregistered directly while suspended, since the PM core holds their
+ * semaphores at that time).
+ *
+ * It can only be called within the scope of a system sleep transition.  In
+ * practice this means it has to be directly or indirectly invoked either by
+ * a suspend or resume method, or by the PM core (e.g. via
+ * disable_nonboot_cpus() or enable_nonboot_cpus()).
+ */
+void destroy_suspended_device(struct class *class, dev_t devt)
+{
+	struct device *dev;
+
+	dev = find_device(class, devt);
+	if (dev)
+		device_pm_schedule_removal(dev);
+}
+EXPORT_SYMBOL_GPL(destroy_suspended_device);
+#endif /* CONFIG_PM_SLEEP */
+
 /**
  * device_rename - renames a device
  * @dev: the pointer to the struct device to be renamed

commit dec13c15445fec29ca9087890895718450e80b95
Author: Daniel Drake <dsd@gentoo.org>
Date:   Wed Nov 21 14:55:18 2007 -0800

    create /sys/.../power when CONFIG_PM is set
    
    The CONFIG_SUSPEND changes in 2.6.23 caused a regression under certain
    configuration conditions (SUSPEND=n, USB_AUTOSUSPEND=y) where all USB
    device attributes in sysfs (idVendor, idProduct, ...) silently disappeared,
    causing udev breakage and more.
    
    The cause of this is that the /sys/.../power subdirectory is now only
    created when CONFIG_PM_SLEEP is set, however, it should be created whenever
    CONFIG_PM is set to handle the above situation.  The following patch fixes
    the regression.
    
    Signed-off-by: Daniel Drake <dsd@gentoo.org>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 3f4d6aa13990..2683eac30c68 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -770,9 +770,10 @@ int device_add(struct device *dev)
 	error = device_add_attrs(dev);
 	if (error)
 		goto AttrsError;
-	error = device_pm_add(dev);
+	error = dpm_sysfs_add(dev);
 	if (error)
 		goto PMError;
+	device_pm_add(dev);
 	error = bus_add_device(dev);
 	if (error)
 		goto BusError;
@@ -797,6 +798,7 @@ int device_add(struct device *dev)
 	return error;
  BusError:
 	device_pm_remove(dev);
+	dpm_sysfs_remove(dev);
  PMError:
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->bus_notifier,

commit 60b8cabd8e8a1d266aa8778957691cd925673083
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Oct 26 20:07:44 2007 +0200

    Driver Core: fix bug in device_rename() for SYSFS_DEPRECATED=y
    
    This should fix the sysfs warnings that renaming network devices is
    causing to show up with CONFIG_SYSFS_DEPRECATED=y
    
    The code just shouldn't run if class devices are real directories, it's
    an update for the symlink in the class directory. Nobody noticed that as
    long as the creation of sysfs files silently failed, and we both missed
    it before the merge, because we don't run SYSFS_DEPRECATED=y.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Larry Finger <Larry.Finger@lwfinger.net>
    Cc: David Miller <davem@davemloft.net>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c1343414d285..3f4d6aa13990 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1228,18 +1228,18 @@ int device_rename(struct device *dev, char *new_name)
 			sysfs_remove_link(&dev->parent->kobj, old_class_name);
 		}
 	}
-#endif
-
+#else
 	if (dev->class) {
 		sysfs_remove_link(&dev->class->subsys.kobj, old_device_name);
 		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
 					  dev->bus_id);
 		if (error) {
-			/* Uh... how to unravel this if restoring can fail? */
 			dev_err(dev, "%s: sysfs_create_symlink failed (%d)\n",
 				__FUNCTION__, error);
 		}
 	}
+#endif
+
 out:
 	put_device(dev);
 

commit 8f4afc410b8d2be49f34835b6bbe788f50471b02
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 11 10:47:49 2007 -0600

    Driver core: rename ktype_device
    
    This makes it a bit more sane when trying to figure out how to clean up
    the ktype mess.
    
    Based on a larger patch from Kay Sievers
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 65de221e3bfa..c1343414d285 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -108,7 +108,7 @@ static void device_release(struct kobject * kobj)
 	}
 }
 
-static struct kobj_type ktype_device = {
+static struct kobj_type device_ktype = {
 	.release	= device_release,
 	.sysfs_ops	= &dev_sysfs_ops,
 };
@@ -118,7 +118,7 @@ static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 {
 	struct kobj_type *ktype = get_ktype(kobj);
 
-	if (ktype == &ktype_device) {
+	if (ktype == &device_ktype) {
 		struct device *dev = to_dev(kobj);
 		if (dev->uevent_suppress)
 			return 0;
@@ -405,7 +405,7 @@ static struct device_attribute devt_attr =
  *	devices_subsys - structure to be registered with kobject core.
  */
 
-decl_subsys(devices, &ktype_device, &device_uevent_ops);
+decl_subsys(devices, &device_ktype, &device_uevent_ops);
 
 
 /**

commit 5c5daf657cb5f963a38413f2852279d7a3843144
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Aug 12 20:43:55 2007 +0200

    Driver core: exclude kobject_uevent.c for !CONFIG_HOTPLUG
    
    Move uevent specific logic from the core into kobject_uevent.c, which
    does no longer require to link the unused string array if hotplug
    is not compiled in.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d487c032dc4a..65de221e3bfa 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -234,13 +234,11 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 
 	/* search the kset, the device belongs to */
 	top_kobj = &dev->kobj;
-	if (!top_kobj->kset && top_kobj->parent) {
-		do {
-			top_kobj = top_kobj->parent;
-		} while (!top_kobj->kset && top_kobj->parent);
-	}
+	while (!top_kobj->kset && top_kobj->parent)
+		top_kobj = top_kobj->parent;
 	if (!top_kobj->kset)
 		goto out;
+
 	kset = top_kobj->kset;
 	if (!kset->uevent_ops || !kset->uevent_ops->uevent)
 		goto out;
@@ -270,17 +268,9 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
-	size_t len = count;
 	enum kobject_action action;
 
-	if (len && buf[len-1] == '\n')
-		len--;
-
-	for (action = 0; action < KOBJ_MAX; action++) {
-		if (strncmp(kobject_actions[action], buf, len) != 0)
-			continue;
-		if (kobject_actions[action][len] != '\0')
-			continue;
+	if (kobject_action_type(buf, count, &action) == 0) {
 		kobject_uevent(&dev->kobj, action);
 		goto out;
 	}

commit 7eff2e7a8b65c25920207324e56611150eb1cd9a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 15:15:12 2007 +0200

    Driver core: change add_uevent_var to use a struct
    
    This changes the uevent buffer functions to use a struct instead of a
    long list of parameters. It does no longer require the caller to do the
    proper buffer termination and size accounting, which is currently wrong
    in some places. It fixes a known bug where parts of the uevent
    environment are overwritten because of wrong index calculations.
    
    Many thanks to Mathieu Desnoyers for finding bugs and improving the
    error handling.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ec86d6fc2360..d487c032dc4a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -141,33 +141,23 @@ static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
 	return NULL;
 }
 
-static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
-			int num_envp, char *buffer, int buffer_size)
+static int dev_uevent(struct kset *kset, struct kobject *kobj,
+		      struct kobj_uevent_env *env)
 {
 	struct device *dev = to_dev(kobj);
-	int i = 0;
-	int length = 0;
 	int retval = 0;
 
 	/* add the major/minor if present */
 	if (MAJOR(dev->devt)) {
-		add_uevent_var(envp, num_envp, &i,
-			       buffer, buffer_size, &length,
-			       "MAJOR=%u", MAJOR(dev->devt));
-		add_uevent_var(envp, num_envp, &i,
-			       buffer, buffer_size, &length,
-			       "MINOR=%u", MINOR(dev->devt));
+		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
+		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
 	}
 
 	if (dev->type && dev->type->name)
-		add_uevent_var(envp, num_envp, &i,
-			       buffer, buffer_size, &length,
-			       "DEVTYPE=%s", dev->type->name);
+		add_uevent_var(env, "DEVTYPE=%s", dev->type->name);
 
 	if (dev->driver)
-		add_uevent_var(envp, num_envp, &i,
-			       buffer, buffer_size, &length,
-			       "DRIVER=%s", dev->driver->name);
+		add_uevent_var(env, "DRIVER=%s", dev->driver->name);
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	if (dev->class) {
@@ -181,59 +171,43 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 
 			path = kobject_get_path(&parent->kobj, GFP_KERNEL);
 			if (path) {
-				add_uevent_var(envp, num_envp, &i,
-					       buffer, buffer_size, &length,
-					       "PHYSDEVPATH=%s", path);
+				add_uevent_var(env, "PHYSDEVPATH=%s", path);
 				kfree(path);
 			}
 
-			add_uevent_var(envp, num_envp, &i,
-				       buffer, buffer_size, &length,
-				       "PHYSDEVBUS=%s", parent->bus->name);
+			add_uevent_var(env, "PHYSDEVBUS=%s", parent->bus->name);
 
 			if (parent->driver)
-				add_uevent_var(envp, num_envp, &i,
-					       buffer, buffer_size, &length,
-					       "PHYSDEVDRIVER=%s", parent->driver->name);
+				add_uevent_var(env, "PHYSDEVDRIVER=%s",
+					       parent->driver->name);
 		}
 	} else if (dev->bus) {
-		add_uevent_var(envp, num_envp, &i,
-			       buffer, buffer_size, &length,
-			       "PHYSDEVBUS=%s", dev->bus->name);
+		add_uevent_var(env, "PHYSDEVBUS=%s", dev->bus->name);
 
 		if (dev->driver)
-			add_uevent_var(envp, num_envp, &i,
-				       buffer, buffer_size, &length,
-				       "PHYSDEVDRIVER=%s", dev->driver->name);
+			add_uevent_var(env, "PHYSDEVDRIVER=%s", dev->driver->name);
 	}
 #endif
 
-	/* terminate, set to next free slot, shrink available space */
-	envp[i] = NULL;
-	envp = &envp[i];
-	num_envp -= i;
-	buffer = &buffer[length];
-	buffer_size -= length;
-
+	/* have the bus specific function add its stuff */
 	if (dev->bus && dev->bus->uevent) {
-		/* have the bus specific function add its stuff */
-		retval = dev->bus->uevent(dev, envp, num_envp, buffer, buffer_size);
+		retval = dev->bus->uevent(dev, env);
 		if (retval)
 			pr_debug ("%s: bus uevent() returned %d\n",
 				  __FUNCTION__, retval);
 	}
 
+	/* have the class specific function add its stuff */
 	if (dev->class && dev->class->dev_uevent) {
-		/* have the class specific function add its stuff */
-		retval = dev->class->dev_uevent(dev, envp, num_envp, buffer, buffer_size);
+		retval = dev->class->dev_uevent(dev, env);
 		if (retval)
 			pr_debug("%s: class uevent() returned %d\n",
 				 __FUNCTION__, retval);
 	}
 
+	/* have the device type specific fuction add its stuff */
 	if (dev->type && dev->type->uevent) {
-		/* have the device type specific fuction add its stuff */
-		retval = dev->type->uevent(dev, envp, num_envp, buffer, buffer_size);
+		retval = dev->type->uevent(dev, env);
 		if (retval)
 			pr_debug("%s: dev_type uevent() returned %d\n",
 				 __FUNCTION__, retval);
@@ -253,9 +227,7 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 {
 	struct kobject *top_kobj;
 	struct kset *kset;
-	char *envp[32];
-	char *data = NULL;
-	char *pos;
+	struct kobj_uevent_env *env = NULL;
 	int i;
 	size_t count = 0;
 	int retval;
@@ -278,26 +250,20 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 		if (!kset->uevent_ops->filter(kset, &dev->kobj))
 			goto out;
 
-	data = (char *)get_zeroed_page(GFP_KERNEL);
-	if (!data)
+	env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);
+	if (!env)
 		return -ENOMEM;
 
 	/* let the kset specific function add its keys */
-	pos = data;
-	memset(envp, 0, sizeof(envp));
-	retval = kset->uevent_ops->uevent(kset, &dev->kobj,
-					  envp, ARRAY_SIZE(envp),
-					  pos, PAGE_SIZE);
+	retval = kset->uevent_ops->uevent(kset, &dev->kobj, env);
 	if (retval)
 		goto out;
 
 	/* copy keys to file */
-	for (i = 0; envp[i]; i++) {
-		pos = &buf[count];
-		count += sprintf(pos, "%s\n", envp[i]);
-	}
+	for (i = 0; i < env->envp_idx; i++)
+		count += sprintf(&buf[count], "%s\n", env->envp[i]);
 out:
-	free_page((unsigned long)data);
+	kfree(env);
 	return count;
 }
 

commit 3eb215de26e6e94bf5fed9cb77230c383b30e53b
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sun Oct 7 12:22:21 2007 -0400

    Driver core: fix SYSF_DEPRECATED breakage for nested classdevs
    
    We should only reparent to a class former class devices that
    form the base of class hierarchy. Nested devices should still
    grow from their real parents.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Tested-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Tested-by: Anssi Hannula <anssi.hannula@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 67c92582d6ef..ec86d6fc2360 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -586,9 +586,13 @@ void device_initialize(struct device *dev)
 static struct kobject * get_device_parent(struct device *dev,
 					  struct device *parent)
 {
-	/* Set the parent to the class, not the parent device */
-	/* this keeps sysfs from having a symlink to make old udevs happy */
-	if (dev->class)
+	/*
+	 * Set the parent to the class, not the parent device
+	 * for topmost devices in class hierarchy.
+	 * This keeps sysfs from having a symlink to make old
+	 * udevs happy
+	 */
+	if (dev->class && (!parent || parent->class != dev->class))
 		return &dev->class->subsys.kobj;
 	else if (parent)
 		return &parent->kobj;

commit 5309809129ca3ab14f8bd5e5ef66c1b7686eb639
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Sep 26 09:16:21 2007 -0700

    Add explicit zeroing to "envp" array in device 'show' method
    
    As Stephen Hemminger says, this is a "belt and suspenders" patch that
    zeroes the envp array at allocation time, even though all the users
    should NULL-terminate it anyway (and we've hopefully fixed everybody
    that doesn't do that).
    
    And we'll apparently clean the whole envp thing up for 2.6.24 anyway.
    
    But let's just be robust, and do both this *and* make sure that all
    users are doing the right thing.
    
    Acked-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6de33d7a29ba..67c92582d6ef 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -284,6 +284,7 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 
 	/* let the kset specific function add its keys */
 	pos = data;
+	memset(envp, 0, sizeof(envp));
 	retval = kset->uevent_ops->uevent(kset, &dev->kobj,
 					  envp, ARRAY_SIZE(envp),
 					  pos, PAGE_SIZE);

commit 4f01a757e75f2a3cab2bab89c4176498963946b9
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Tue Sep 18 22:46:50 2007 -0700

    Driver core: fix deprectated sysfs structure for nested class devices
    
    Nested class devices used to have 'device' symlink point to a real
    (physical) device instead of a parent class device.  When converting
    subsystems to struct device we need to keep doing what class devices did if
    CONFIG_SYSFS_DEPRECATED is Y, otherwise parts of udev break.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Acked-by: Greg KH <greg@kroah.com>
    Tested-by: Anssi Hannula <anssi.hannula@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e6738bcbe5a9..6de33d7a29ba 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -679,14 +679,26 @@ static int device_add_class_symlinks(struct device *dev)
 			goto out_subsys;
 	}
 	if (dev->parent) {
-		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
-					  "device");
-		if (error)
-			goto out_busid;
 #ifdef CONFIG_SYSFS_DEPRECATED
 		{
-			char * class_name = make_class_name(dev->class->name,
-								&dev->kobj);
+			struct device *parent = dev->parent;
+			char *class_name;
+
+			/*
+			 * In old sysfs stacked class devices had 'device'
+			 * link pointing to real device instead of parent
+			 */
+			while (parent->class && !parent->bus && parent->parent)
+				parent = parent->parent;
+
+			error = sysfs_create_link(&dev->kobj,
+						  &parent->kobj,
+						  "device");
+			if (error)
+				goto out_busid;
+
+			class_name = make_class_name(dev->class->name,
+							&dev->kobj);
 			if (class_name)
 				error = sysfs_create_link(&dev->parent->kobj,
 							&dev->kobj, class_name);
@@ -694,6 +706,11 @@ static int device_add_class_symlinks(struct device *dev)
 			if (error)
 				goto out_device;
 		}
+#else
+		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
+					  "device");
+		if (error)
+			goto out_busid;
 #endif
 	}
 	return 0;

commit 27907689eedd799a6a0c1a2f18a3563c6e9e9767
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Jul 25 09:58:08 2007 +0200

    driver core: revert "device" link creation check
    
    driver core: revert "device" link creation check
    
    Commit 2ee97caf0a6602f749ddbfdb1449e383e1212707 introduced an extra
    check on when to create the "device" symlink. Unfortunately, this
    breaks input, so let's revert to the old behaviour.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b9bb3995db84..e6738bcbe5a9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -678,8 +678,7 @@ static int device_add_class_symlinks(struct device *dev)
 		if (error)
 			goto out_subsys;
 	}
-	/* only bus-device parents get a "device"-link */
-	if (dev->parent && dev->parent->bus) {
+	if (dev->parent) {
 		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
 					  "device");
 		if (error)

commit ff2ee8cf30199bb625706a43d9cc3bd1ff5ebe42
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Apr 9 12:14:34 2002 -0700

    kobject: put kobject_actions in kobject.h
    
    This prevents the extern declaration in the driver core.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 3599ab2506d2..b9bb3995db84 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -24,8 +24,6 @@
 #include "base.h"
 #include "power/power.h"
 
-extern const char *kobject_actions[];
-
 int (*platform_notify)(struct device * dev) = NULL;
 int (*platform_notify_remove)(struct device * dev) = NULL;
 

commit 2ee97caf0a6602f749ddbfdb1449e383e1212707
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Jul 18 01:43:47 2007 -0700

    Driver core: check return code of sysfs_create_link()
    
    Check for return value of sysfs_create_link() in device_add() and
    device_rename().  Add helper functions device_add_class_symlinks() and
    device_remove_class_symlinks() to make the code easier to read.
    
    [akpm@linux-foundation.org: fix unused var warnings]
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 91a0367d583e..3599ab2506d2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -660,6 +660,82 @@ static int setup_parent(struct device *dev, struct device *parent)
 	return 0;
 }
 
+static int device_add_class_symlinks(struct device *dev)
+{
+	int error;
+
+	if (!dev->class)
+		return 0;
+	error = sysfs_create_link(&dev->kobj, &dev->class->subsys.kobj,
+				  "subsystem");
+	if (error)
+		goto out;
+	/*
+	 * If this is not a "fake" compatible device, then create the
+	 * symlink from the class to the device.
+	 */
+	if (dev->kobj.parent != &dev->class->subsys.kobj) {
+		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
+					  dev->bus_id);
+		if (error)
+			goto out_subsys;
+	}
+	/* only bus-device parents get a "device"-link */
+	if (dev->parent && dev->parent->bus) {
+		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
+					  "device");
+		if (error)
+			goto out_busid;
+#ifdef CONFIG_SYSFS_DEPRECATED
+		{
+			char * class_name = make_class_name(dev->class->name,
+								&dev->kobj);
+			if (class_name)
+				error = sysfs_create_link(&dev->parent->kobj,
+							&dev->kobj, class_name);
+			kfree(class_name);
+			if (error)
+				goto out_device;
+		}
+#endif
+	}
+	return 0;
+
+#ifdef CONFIG_SYSFS_DEPRECATED
+out_device:
+	if (dev->parent)
+		sysfs_remove_link(&dev->kobj, "device");
+#endif
+out_busid:
+	if (dev->kobj.parent != &dev->class->subsys.kobj)
+		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+out_subsys:
+	sysfs_remove_link(&dev->kobj, "subsystem");
+out:
+	return error;
+}
+
+static void device_remove_class_symlinks(struct device *dev)
+{
+	if (!dev->class)
+		return;
+	if (dev->parent) {
+#ifdef CONFIG_SYSFS_DEPRECATED
+		char *class_name;
+
+		class_name = make_class_name(dev->class->name, &dev->kobj);
+		if (class_name) {
+			sysfs_remove_link(&dev->parent->kobj, class_name);
+			kfree(class_name);
+		}
+#endif
+		sysfs_remove_link(&dev->kobj, "device");
+	}
+	if (dev->kobj.parent != &dev->class->subsys.kobj)
+		sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
+	sysfs_remove_link(&dev->kobj, "subsystem");
+}
+
 /**
  *	device_add - add device to device hierarchy.
  *	@dev:	device.
@@ -674,7 +750,6 @@ static int setup_parent(struct device *dev, struct device *parent)
 int device_add(struct device *dev)
 {
 	struct device *parent = NULL;
-	char *class_name = NULL;
 	struct class_interface *class_intf;
 	int error = -EINVAL;
 
@@ -714,27 +789,9 @@ int device_add(struct device *dev)
 			goto ueventattrError;
 	}
 
-	if (dev->class) {
-		sysfs_create_link(&dev->kobj, &dev->class->subsys.kobj,
-				  "subsystem");
-		/* If this is not a "fake" compatible device, then create the
-		 * symlink from the class to the device. */
-		if (dev->kobj.parent != &dev->class->subsys.kobj)
-			sysfs_create_link(&dev->class->subsys.kobj,
-					  &dev->kobj, dev->bus_id);
-		if (parent) {
-			sysfs_create_link(&dev->kobj, &dev->parent->kobj,
-							"device");
-#ifdef CONFIG_SYSFS_DEPRECATED
-			class_name = make_class_name(dev->class->name,
-							&dev->kobj);
-			if (class_name)
-				sysfs_create_link(&dev->parent->kobj,
-						  &dev->kobj, class_name);
-#endif
-		}
-	}
-
+	error = device_add_class_symlinks(dev);
+	if (error)
+		goto SymlinkError;
 	error = device_add_attrs(dev);
 	if (error)
 		goto AttrsError;
@@ -761,7 +818,6 @@ int device_add(struct device *dev)
 		up(&dev->class->sem);
 	}
  Done:
-	kfree(class_name);
 	put_device(dev);
 	return error;
  BusError:
@@ -772,6 +828,8 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_DEL_DEVICE, dev);
 	device_remove_attrs(dev);
  AttrsError:
+	device_remove_class_symlinks(dev);
+ SymlinkError:
 	if (MAJOR(dev->devt))
 		device_remove_file(dev, &devt_attr);
 
@@ -1156,7 +1214,7 @@ int device_rename(struct device *dev, char *new_name)
 {
 	char *old_class_name = NULL;
 	char *new_class_name = NULL;
-	char *old_symlink_name = NULL;
+	char *old_device_name = NULL;
 	int error;
 
 	dev = get_device(dev);
@@ -1170,42 +1228,49 @@ int device_rename(struct device *dev, char *new_name)
 		old_class_name = make_class_name(dev->class->name, &dev->kobj);
 #endif
 
-	if (dev->class) {
-		old_symlink_name = kmalloc(BUS_ID_SIZE, GFP_KERNEL);
-		if (!old_symlink_name) {
-			error = -ENOMEM;
-			goto out_free_old_class;
-		}
-		strlcpy(old_symlink_name, dev->bus_id, BUS_ID_SIZE);
+	old_device_name = kmalloc(BUS_ID_SIZE, GFP_KERNEL);
+	if (!old_device_name) {
+		error = -ENOMEM;
+		goto out;
 	}
-
+	strlcpy(old_device_name, dev->bus_id, BUS_ID_SIZE);
 	strlcpy(dev->bus_id, new_name, BUS_ID_SIZE);
 
 	error = kobject_rename(&dev->kobj, new_name);
+	if (error) {
+		strlcpy(dev->bus_id, old_device_name, BUS_ID_SIZE);
+		goto out;
+	}
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	if (old_class_name) {
 		new_class_name = make_class_name(dev->class->name, &dev->kobj);
 		if (new_class_name) {
-			sysfs_create_link(&dev->parent->kobj, &dev->kobj,
-					  new_class_name);
+			error = sysfs_create_link(&dev->parent->kobj,
+						  &dev->kobj, new_class_name);
+			if (error)
+				goto out;
 			sysfs_remove_link(&dev->parent->kobj, old_class_name);
 		}
 	}
 #endif
 
 	if (dev->class) {
-		sysfs_remove_link(&dev->class->subsys.kobj,
-				  old_symlink_name);
-		sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
-				  dev->bus_id);
+		sysfs_remove_link(&dev->class->subsys.kobj, old_device_name);
+		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
+					  dev->bus_id);
+		if (error) {
+			/* Uh... how to unravel this if restoring can fail? */
+			dev_err(dev, "%s: sysfs_create_symlink failed (%d)\n",
+				__FUNCTION__, error);
+		}
 	}
+out:
 	put_device(dev);
 
 	kfree(new_class_name);
-	kfree(old_symlink_name);
- out_free_old_class:
 	kfree(old_class_name);
+	kfree(old_device_name);
 
 	return error;
 }

commit 60a96a59569bab85571d0089682109bd3324e896
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Jul 8 22:29:26 2007 +0200

    Driver core: accept all valid action-strings in uevent-trigger
    
    This allows the uevent file to handle any type of uevent action to be
    triggered by userspace instead of just the "add" uevent.
    
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0455aa78fa13..91a0367d583e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -24,6 +24,8 @@
 #include "base.h"
 #include "power/power.h"
 
+extern const char *kobject_actions[];
+
 int (*platform_notify)(struct device * dev) = NULL;
 int (*platform_notify_remove)(struct device * dev) = NULL;
 
@@ -303,10 +305,25 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
-	if (memcmp(buf, "add", 3) != 0)
-		dev_err(dev, "uevent: unsupported action-string; this will "
-			"be ignored in a future kernel version");
+	size_t len = count;
+	enum kobject_action action;
+
+	if (len && buf[len-1] == '\n')
+		len--;
+
+	for (action = 0; action < KOBJ_MAX; action++) {
+		if (strncmp(kobject_actions[action], buf, len) != 0)
+			continue;
+		if (kobject_actions[action][len] != '\0')
+			continue;
+		kobject_uevent(&dev->kobj, action);
+		goto out;
+	}
+
+	dev_err(dev, "uevent: unsupported action-string; this will "
+		     "be ignored in a future kernel version\n");
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
+out:
 	return count;
 }
 

commit ad6a1e1c66009ba9dcd2f5c90ffa1fb4ce72fce0
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 03:45:17 2007 +0900

    driver-core: make devt_attr and uevent_attr static
    
    devt_attr and uevent_attr are either allocated dynamically with or
    embedded in device and class_device as they needed their owner field
    set to the module implementing the driver.  Now that sysfs implements
    immediate disconnect and owner field removed from struct attribute,
    there is no reason to do this.  Remove these attributes from
    [class_]device and use static attribute structures instead.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e3fb87bfc6e1..0455aa78fa13 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -310,6 +310,9 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
+static struct device_attribute uevent_attr =
+	__ATTR(uevent, S_IRUGO | S_IWUSR, show_uevent, store_uevent);
+
 static int device_add_attributes(struct device *dev,
 				 struct device_attribute *attrs)
 {
@@ -423,6 +426,9 @@ static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
 	return print_dev_t(buf, dev->devt);
 }
 
+static struct device_attribute devt_attr =
+	__ATTR(dev, S_IRUGO, show_dev, NULL);
+
 /*
  *	devices_subsys - structure to be registered with kobject core.
  */
@@ -681,31 +687,14 @@ int device_add(struct device *dev)
 		blocking_notifier_call_chain(&dev->bus->bus_notifier,
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
-	dev->uevent_attr.attr.name = "uevent";
-	dev->uevent_attr.attr.mode = S_IRUGO | S_IWUSR;
-	dev->uevent_attr.store = store_uevent;
-	dev->uevent_attr.show = show_uevent;
-	error = device_create_file(dev, &dev->uevent_attr);
+	error = device_create_file(dev, &uevent_attr);
 	if (error)
 		goto attrError;
 
 	if (MAJOR(dev->devt)) {
-		struct device_attribute *attr;
-		attr = kzalloc(sizeof(*attr), GFP_KERNEL);
-		if (!attr) {
-			error = -ENOMEM;
-			goto ueventattrError;
-		}
-		attr->attr.name = "dev";
-		attr->attr.mode = S_IRUGO;
-		attr->show = show_dev;
-		error = device_create_file(dev, attr);
-		if (error) {
-			kfree(attr);
+		error = device_create_file(dev, &devt_attr);
+		if (error)
 			goto ueventattrError;
-		}
-
-		dev->devt_attr = attr;
 	}
 
 	if (dev->class) {
@@ -766,10 +755,8 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_DEL_DEVICE, dev);
 	device_remove_attrs(dev);
  AttrsError:
-	if (dev->devt_attr) {
-		device_remove_file(dev, dev->devt_attr);
-		kfree(dev->devt_attr);
-	}
+	if (MAJOR(dev->devt))
+		device_remove_file(dev, &devt_attr);
 
 	if (dev->class) {
 		sysfs_remove_link(&dev->kobj, "subsystem");
@@ -791,7 +778,7 @@ int device_add(struct device *dev)
 		}
 	}
  ueventattrError:
-	device_remove_file(dev, &dev->uevent_attr);
+	device_remove_file(dev, &uevent_attr);
  attrError:
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
@@ -868,10 +855,8 @@ void device_del(struct device * dev)
 
 	if (parent)
 		klist_del(&dev->knode_parent);
-	if (dev->devt_attr) {
-		device_remove_file(dev, dev->devt_attr);
-		kfree(dev->devt_attr);
-	}
+	if (MAJOR(dev->devt))
+		device_remove_file(dev, &devt_attr);
 	if (dev->class) {
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		/* If this is not a "fake" compatible device, remove the
@@ -925,7 +910,7 @@ void device_del(struct device * dev)
 			up(&dev->class->sem);
 		}
 	}
-	device_remove_file(dev, &dev->uevent_attr);
+	device_remove_file(dev, &uevent_attr);
 	device_remove_attrs(dev);
 	bus_remove_device(dev);
 

commit 7b595756ec1f49e0049a9e01a1298d53a7faaa15
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 03:45:17 2007 +0900

    sysfs: kill unnecessary attribute->owner
    
    sysfs is now completely out of driver/module lifetime game.  After
    deletion, a sysfs node doesn't access anything outside sysfs proper,
    so there's no reason to hold onto the attribute owners.  Note that
    often the wrong modules were accounted for as owners leading to
    accessing removed modules.
    
    This patch kills now unnecessary attribute->owner.  Note that with
    this change, userland holding a sysfs node does not prevent the
    backing module from being unloaded.
    
    For more info regarding lifetime rule cleanup, please read the
    following message.
    
      http://article.gmane.org/gmane.linux.kernel/510293
    
    (tweaked by Greg to not delete the field just yet, to make it easier to
    merge things properly.)
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index cff4fbfbb055..e3fb87bfc6e1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -683,8 +683,6 @@ int device_add(struct device *dev)
 
 	dev->uevent_attr.attr.name = "uevent";
 	dev->uevent_attr.attr.mode = S_IRUGO | S_IWUSR;
-	if (dev->driver)
-		dev->uevent_attr.attr.owner = dev->driver->owner;
 	dev->uevent_attr.store = store_uevent;
 	dev->uevent_attr.show = show_uevent;
 	error = device_create_file(dev, &dev->uevent_attr);
@@ -700,8 +698,6 @@ int device_add(struct device *dev)
 		}
 		attr->attr.name = "dev";
 		attr->attr.mode = S_IRUGO;
-		if (dev->driver)
-			attr->attr.owner = dev->driver->owner;
 		attr->show = show_dev;
 		error = device_create_file(dev, attr);
 		if (error) {

commit dc0afa8388972a9ed7c2203cc46d8df1a4713f65
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Jul 9 11:39:18 2007 -0700

    Driver core: coding style cleanup
    
    This converts code of the form
    
            if ((error = some_func()))
                    goto fixup;
    to
            error = some_func();
            if (error)
                    goto fixup;
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index dd40d78a023d..cff4fbfbb055 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -733,11 +733,14 @@ int device_add(struct device *dev)
 		}
 	}
 
-	if ((error = device_add_attrs(dev)))
+	error = device_add_attrs(dev);
+	if (error)
 		goto AttrsError;
-	if ((error = device_pm_add(dev)))
+	error = device_pm_add(dev);
+	if (error)
 		goto PMError;
-	if ((error = bus_add_device(dev)))
+	error = bus_add_device(dev);
+	if (error)
 		goto BusError;
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);

commit 2c7afd125cc482dbdf6b0a169c42337e7e76cda5
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue May 1 13:46:26 2007 +0200

    Driver core: keep PHYSDEV for old struct class_device
    
    Class-devices created by "struct class_device" are going to be replaced
    by "struct device". Keep the deprecated PHYSDEV* variables for the already
    "deprecated" struct class_device" devices.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b78fc1e68264..dd40d78a023d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -180,10 +180,12 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 			const char *path;
 
 			path = kobject_get_path(&parent->kobj, GFP_KERNEL);
-			add_uevent_var(envp, num_envp, &i,
-				       buffer, buffer_size, &length,
-				       "PHYSDEVPATH=%s", path);
-			kfree(path);
+			if (path) {
+				add_uevent_var(envp, num_envp, &i,
+					       buffer, buffer_size, &length,
+					       "PHYSDEVPATH=%s", path);
+				kfree(path);
+			}
 
 			add_uevent_var(envp, num_envp, &i,
 				       buffer, buffer_size, &length,

commit 823bccfc4002296ba88c3ad0f049e1abd8108d30
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 13 13:15:19 2007 -0700

    remove "struct subsystem" as it is no longer needed
    
    We need to work on cleaning up the relationship between kobjects, ksets and
    ktypes.  The removal of 'struct subsystem' is the first step of this,
    especially as it is not really needed at all.
    
    Thanks to Kay for fixing the bugs in this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 59d9816c332e..b78fc1e68264 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -565,7 +565,7 @@ static struct kobject * get_device_parent(struct device *dev,
 	/* Set the parent to the class, not the parent device */
 	/* this keeps sysfs from having a symlink to make old udevs happy */
 	if (dev->class)
-		return &dev->class->subsys.kset.kobj;
+		return &dev->class->subsys.kobj;
 	else if (parent)
 		return &parent->kobj;
 
@@ -577,7 +577,7 @@ static struct kobject *virtual_device_parent(struct device *dev)
 	static struct kobject *virtual_dir = NULL;
 
 	if (!virtual_dir)
-		virtual_dir = kobject_add_dir(&devices_subsys.kset.kobj, "virtual");
+		virtual_dir = kobject_add_dir(&devices_subsys.kobj, "virtual");
 
 	return virtual_dir;
 }
@@ -711,12 +711,12 @@ int device_add(struct device *dev)
 	}
 
 	if (dev->class) {
-		sysfs_create_link(&dev->kobj, &dev->class->subsys.kset.kobj,
+		sysfs_create_link(&dev->kobj, &dev->class->subsys.kobj,
 				  "subsystem");
 		/* If this is not a "fake" compatible device, then create the
 		 * symlink from the class to the device. */
-		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
-			sysfs_create_link(&dev->class->subsys.kset.kobj,
+		if (dev->kobj.parent != &dev->class->subsys.kobj)
+			sysfs_create_link(&dev->class->subsys.kobj,
 					  &dev->kobj, dev->bus_id);
 		if (parent) {
 			sysfs_create_link(&dev->kobj, &dev->parent->kobj,
@@ -774,8 +774,8 @@ int device_add(struct device *dev)
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		/* If this is not a "fake" compatible device, remove the
 		 * symlink from the class to the device. */
-		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
-			sysfs_remove_link(&dev->class->subsys.kset.kobj,
+		if (dev->kobj.parent != &dev->class->subsys.kobj)
+			sysfs_remove_link(&dev->class->subsys.kobj,
 					  dev->bus_id);
 		if (parent) {
 #ifdef CONFIG_SYSFS_DEPRECATED
@@ -875,8 +875,8 @@ void device_del(struct device * dev)
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		/* If this is not a "fake" compatible device, remove the
 		 * symlink from the class to the device. */
-		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
-			sysfs_remove_link(&dev->class->subsys.kset.kobj,
+		if (dev->kobj.parent != &dev->class->subsys.kobj)
+			sysfs_remove_link(&dev->class->subsys.kobj,
 					  dev->bus_id);
 		if (parent) {
 #ifdef CONFIG_SYSFS_DEPRECATED
@@ -1192,9 +1192,9 @@ int device_rename(struct device *dev, char *new_name)
 #endif
 
 	if (dev->class) {
-		sysfs_remove_link(&dev->class->subsys.kset.kobj,
+		sysfs_remove_link(&dev->class->subsys.kobj,
 				  old_symlink_name);
-		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
+		sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
 				  dev->bus_id);
 	}
 	put_device(dev);

commit c7308c81a8220ab68eebfadde37db881a2800064
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 2 14:14:11 2007 +0200

    Driver core: fix show_uevent from taking up way too much stack
    
    Declaring an array of PAGE_SIZE does bad things for people running with
    4k stacks...
    
    Thanks to Tilman Schmidt for tracking this down.
    
    Cc: Tilman Schmidt <tilman@imap.cc>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8aa090da1cd7..59d9816c332e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -252,7 +252,7 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 	struct kobject *top_kobj;
 	struct kset *kset;
 	char *envp[32];
-	char data[PAGE_SIZE];
+	char *data = NULL;
 	char *pos;
 	int i;
 	size_t count = 0;
@@ -276,6 +276,10 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 		if (!kset->uevent_ops->filter(kset, &dev->kobj))
 			goto out;
 
+	data = (char *)get_zeroed_page(GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
 	/* let the kset specific function add its keys */
 	pos = data;
 	retval = kset->uevent_ops->uevent(kset, &dev->kobj,
@@ -290,6 +294,7 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 		count += sprintf(pos, "%s\n", envp[i]);
 	}
 out:
+	free_page((unsigned long)data);
 	return count;
 }
 

commit 523ded71de0c5e66973335bf99a80edfda9f401b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 26 00:12:04 2007 -0700

    device_schedule_callback() needs a module reference
    
    This patch (as896b) fixes an oversight in the design of
    device_schedule_callback().  It is necessary to acquire a reference to the
    module owning the callback routine, to prevent the module from being
    unloaded before the callback can run.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Satyam Sharma <satyam.sharma@gmail.com>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f69305c7269d..8aa090da1cd7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -480,9 +480,10 @@ void device_remove_bin_file(struct device *dev, struct bin_attribute *attr)
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
 /**
- * device_schedule_callback - helper to schedule a callback for a device
+ * device_schedule_callback_owner - helper to schedule a callback for a device
  * @dev: device.
  * @func: callback function to invoke later.
+ * @owner: module owning the callback routine
  *
  * Attribute methods must not unregister themselves or their parent device
  * (which would amount to the same thing).  Attempts to do so will deadlock,
@@ -493,20 +494,23 @@ EXPORT_SYMBOL_GPL(device_remove_bin_file);
  * argument in the workqueue's process context.  @dev will be pinned until
  * @func returns.
  *
+ * This routine is usually called via the inline device_schedule_callback(),
+ * which automatically sets @owner to THIS_MODULE.
+ *
  * Returns 0 if the request was submitted, -ENOMEM if storage could not
- * be allocated.
+ * be allocated, -ENODEV if a reference to @owner isn't available.
  *
  * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
  * underlying sysfs routine (since it is intended for use by attribute
  * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
  */
-int device_schedule_callback(struct device *dev,
-		void (*func)(struct device *))
+int device_schedule_callback_owner(struct device *dev,
+		void (*func)(struct device *), struct module *owner)
 {
 	return sysfs_schedule_callback(&dev->kobj,
-			(void (*)(void *)) func, dev);
+			(void (*)(void *)) func, dev, owner);
 }
-EXPORT_SYMBOL_GPL(device_schedule_callback);
+EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
 
 static void klist_children_get(struct klist_node *n)
 {

commit 22af74f3b221f1436a37554501431e51c06ee77e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Apr 6 01:40:38 2007 +0200

    Driver core: warn when userspace writes to the uevent file in a non-supported way
    
    In the future we will allow the uevent type to be written to the uevent
    file to trigger the different types of uevents.  But for now, as we only
    support the ADD event, warn if userspace tries to write anything else to
    this file.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 72c6ee57471b..f69305c7269d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -296,6 +296,9 @@ static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
 static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
+	if (memcmp(buf, "add", 3) != 0)
+		dev_err(dev, "uevent: unsupported action-string; this will "
+			"be ignored in a future kernel version");
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	return count;
 }

commit 16574dccd8f62dc1b585325f8a6a0aab10047ed8
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Apr 6 01:40:38 2007 +0200

    Driver core: make uevent-environment available in uevent-file
    
    This allows sysfs to show the environment variables that are available
    if the uevent happens.  This lets userspace not have to cache all of
    this information as the kernel already knows it.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c34a4d8842e1..72c6ee57471b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -246,6 +246,53 @@ static struct kset_uevent_ops device_uevent_ops = {
 	.uevent =	dev_uevent,
 };
 
+static ssize_t show_uevent(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct kobject *top_kobj;
+	struct kset *kset;
+	char *envp[32];
+	char data[PAGE_SIZE];
+	char *pos;
+	int i;
+	size_t count = 0;
+	int retval;
+
+	/* search the kset, the device belongs to */
+	top_kobj = &dev->kobj;
+	if (!top_kobj->kset && top_kobj->parent) {
+		do {
+			top_kobj = top_kobj->parent;
+		} while (!top_kobj->kset && top_kobj->parent);
+	}
+	if (!top_kobj->kset)
+		goto out;
+	kset = top_kobj->kset;
+	if (!kset->uevent_ops || !kset->uevent_ops->uevent)
+		goto out;
+
+	/* respect filter */
+	if (kset->uevent_ops && kset->uevent_ops->filter)
+		if (!kset->uevent_ops->filter(kset, &dev->kobj))
+			goto out;
+
+	/* let the kset specific function add its keys */
+	pos = data;
+	retval = kset->uevent_ops->uevent(kset, &dev->kobj,
+					  envp, ARRAY_SIZE(envp),
+					  pos, PAGE_SIZE);
+	if (retval)
+		goto out;
+
+	/* copy keys to file */
+	for (i = 0; envp[i]; i++) {
+		pos = &buf[count];
+		count += sprintf(pos, "%s\n", envp[i]);
+	}
+out:
+	return count;
+}
+
 static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
@@ -621,10 +668,11 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	dev->uevent_attr.attr.name = "uevent";
-	dev->uevent_attr.attr.mode = S_IWUSR;
+	dev->uevent_attr.attr.mode = S_IRUGO | S_IWUSR;
 	if (dev->driver)
 		dev->uevent_attr.attr.owner = dev->driver->owner;
 	dev->uevent_attr.store = store_uevent;
+	dev->uevent_attr.show = show_uevent;
 	error = device_create_file(dev, &dev->uevent_attr);
 	if (error)
 		goto attrError;

commit 83b5fb4cce13b9f7b218ed88ee05387c3f3bdda3
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Thu Mar 29 11:12:11 2007 +0200

    Driver core: suppress uevents via filter
    
    Suppress uevents for devices if uevent_suppress is set via
    dev_uevent_filter(). This makes the driver core suppress all device
    uevents, not just the add event in device_add().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index be6aeb430798..c34a4d8842e1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -120,6 +120,8 @@ static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 
 	if (ktype == &ktype_device) {
 		struct device *dev = to_dev(kobj);
+		if (dev->uevent_suppress)
+			return 0;
 		if (dev->bus)
 			return 1;
 		if (dev->class)
@@ -675,8 +677,7 @@ int device_add(struct device *dev)
 		goto PMError;
 	if ((error = bus_add_device(dev)))
 		goto BusError;
-	if (!dev->uevent_suppress)
-		kobject_uevent(&dev->kobj, KOBJ_ADD);
+	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	bus_attach_device(dev);
 	if (parent)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);

commit c6a46696f97ff260a4ecce5e287f8de4b9d7fe14
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Feb 5 16:15:26 2007 -0800

    driver core: don't fail attaching the device if it cannot be bound
    
    Don't fail bus_attach_device() if the device cannot be bound.
    
    If dev->driver has been specified, reset it to NULL if device_bind_driver()
    failed and add the device as an unbound device.  As a result,
    bus_attach_device() now cannot fail, and we can remove some checking from
    device_add().
    
    Also remove an unneeded check in bus_rescan_devices_helper().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bffb69e4bde2..be6aeb430798 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -677,8 +677,7 @@ int device_add(struct device *dev)
 		goto BusError;
 	if (!dev->uevent_suppress)
 		kobject_uevent(&dev->kobj, KOBJ_ADD);
-	if ((error = bus_attach_device(dev)))
-		goto AttachError;
+	bus_attach_device(dev);
 	if (parent)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
@@ -697,8 +696,6 @@ int device_add(struct device *dev)
 	kfree(class_name);
 	put_device(dev);
 	return error;
- AttachError:
-	bus_remove_device(dev);
  BusError:
 	device_pm_remove(dev);
  PMError:

commit 414264f959cf46f49f974b3510400e12ac3624a6
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon Mar 12 21:08:57 2007 +0100

    Driver core: add name to device_type
    
    If "name" of a device_type is specified, the uevent will
    contain the device_type name in the DEVTYPE variable.
    This helps userspace to distingiush between different types
    of devices, belonging to the same subsystem.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bb2cc37a4d43..bffb69e4bde2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -157,6 +157,11 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 			       "MINOR=%u", MINOR(dev->devt));
 	}
 
+	if (dev->type && dev->type->name)
+		add_uevent_var(envp, num_envp, &i,
+			       buffer, buffer_size, &length,
+			       "DEVTYPE=%s", dev->type->name);
+
 	if (dev->driver)
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,

commit 621a1672f7377e08a942f205d6742d8af1292aab
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Sat Mar 10 01:37:34 2007 -0500

    driver core: Use attribute groups in struct device_type
    
    Driver core: use attribute groups in struct device_type
    
    Attribute groups are more flexible than attribute lists
    (an attribute list can be represented by anonymous group)
    so switch struct device_type to use them.
    
    Also rework attribute creation for devices so that they all
    cleaned up properly in case of errors.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Kay Sievers <kay.sievers@novell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 9ea12d9b48a6..bb2cc37a4d43 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -246,64 +246,95 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-static int device_add_groups(struct device *dev)
+static int device_add_attributes(struct device *dev,
+				 struct device_attribute *attrs)
+{
+	int error = 0;
+	int i;
+
+	if (attrs) {
+		for (i = 0; attr_name(attrs[i]); i++) {
+			error = device_create_file(dev, &attrs[i]);
+			if (error)
+				break;
+		}
+		if (error)
+			while (--i >= 0)
+				device_remove_file(dev, &attrs[i]);
+	}
+	return error;
+}
+
+static void device_remove_attributes(struct device *dev,
+				     struct device_attribute *attrs)
 {
 	int i;
+
+	if (attrs)
+		for (i = 0; attr_name(attrs[i]); i++)
+			device_remove_file(dev, &attrs[i]);
+}
+
+static int device_add_groups(struct device *dev,
+			     struct attribute_group **groups)
+{
 	int error = 0;
+	int i;
 
-	if (dev->groups) {
-		for (i = 0; dev->groups[i]; i++) {
-			error = sysfs_create_group(&dev->kobj, dev->groups[i]);
+	if (groups) {
+		for (i = 0; groups[i]; i++) {
+			error = sysfs_create_group(&dev->kobj, groups[i]);
 			if (error) {
 				while (--i >= 0)
-					sysfs_remove_group(&dev->kobj, dev->groups[i]);
-				goto out;
+					sysfs_remove_group(&dev->kobj, groups[i]);
+				break;
 			}
 		}
 	}
-out:
 	return error;
 }
 
-static void device_remove_groups(struct device *dev)
+static void device_remove_groups(struct device *dev,
+				 struct attribute_group **groups)
 {
 	int i;
-	if (dev->groups) {
-		for (i = 0; dev->groups[i]; i++) {
-			sysfs_remove_group(&dev->kobj, dev->groups[i]);
-		}
-	}
+
+	if (groups)
+		for (i = 0; groups[i]; i++)
+			sysfs_remove_group(&dev->kobj, groups[i]);
 }
 
 static int device_add_attrs(struct device *dev)
 {
 	struct class *class = dev->class;
 	struct device_type *type = dev->type;
-	int error = 0;
-	int i;
+	int error;
 
-	if (class && class->dev_attrs) {
-		for (i = 0; attr_name(class->dev_attrs[i]); i++) {
-			error = device_create_file(dev, &class->dev_attrs[i]);
-			if (error)
-				break;
-		}
+	if (class) {
+		error = device_add_attributes(dev, class->dev_attrs);
 		if (error)
-			while (--i >= 0)
-				device_remove_file(dev, &class->dev_attrs[i]);
+			return error;
 	}
 
-	if (type && type->attrs) {
-		for (i = 0; attr_name(type->attrs[i]); i++) {
-			error = device_create_file(dev, &type->attrs[i]);
-			if (error)
-				break;
-		}
+	if (type) {
+		error = device_add_groups(dev, type->groups);
 		if (error)
-			while (--i >= 0)
-				device_remove_file(dev, &type->attrs[i]);
+			goto err_remove_class_attrs;
 	}
 
+	error = device_add_groups(dev, dev->groups);
+	if (error)
+		goto err_remove_type_groups;
+
+	return 0;
+
+ err_remove_type_groups:
+	if (type)
+		device_remove_groups(dev, type->groups);
+ err_remove_class_attrs:
+	if (class)
+		device_remove_attributes(dev, class->dev_attrs);
+
 	return error;
 }
 
@@ -311,17 +342,14 @@ static void device_remove_attrs(struct device *dev)
 {
 	struct class *class = dev->class;
 	struct device_type *type = dev->type;
-	int i;
 
-	if (class && class->dev_attrs) {
-		for (i = 0; attr_name(class->dev_attrs[i]); i++)
-			device_remove_file(dev, &class->dev_attrs[i]);
-	}
+	device_remove_groups(dev, dev->groups);
 
-	if (type && type->attrs) {
-		for (i = 0; attr_name(type->attrs[i]); i++)
-			device_remove_file(dev, &type->attrs[i]);
-	}
+	if (type)
+		device_remove_groups(dev, type->groups);
+
+	if (class)
+		device_remove_attributes(dev, class->dev_attrs);
 }
 
 
@@ -638,8 +666,6 @@ int device_add(struct device *dev)
 
 	if ((error = device_add_attrs(dev)))
 		goto AttrsError;
-	if ((error = device_add_groups(dev)))
-		goto GroupError;
 	if ((error = device_pm_add(dev)))
 		goto PMError;
 	if ((error = bus_add_device(dev)))
@@ -663,7 +689,7 @@ int device_add(struct device *dev)
 		up(&dev->class->sem);
 	}
  Done:
- 	kfree(class_name);
+	kfree(class_name);
 	put_device(dev);
 	return error;
  AttachError:
@@ -674,8 +700,6 @@ int device_add(struct device *dev)
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
-	device_remove_groups(dev);
- GroupError:
 	device_remove_attrs(dev);
  AttrsError:
 	if (dev->devt_attr) {
@@ -838,7 +862,6 @@ void device_del(struct device * dev)
 		}
 	}
 	device_remove_file(dev, &dev->uevent_attr);
-	device_remove_groups(dev);
 	device_remove_attrs(dev);
 	bus_remove_device(dev);
 

commit a456b7023e0abf80bb03b0bdf5471b48878e5c49
Author: Jean Delvare <khali@linux-fr.org>
Date:   Fri Mar 9 16:33:10 2007 +0100

    dev_printk and new-style class devices
    
    As the new-style class devices (as opposed to old-style struct
    class_device) are becoming more widely used, I noticed that the
    dev_printk-based functions are not working properly with these.
    New-style class devices have no driver nor bus, almost by definition,
    and as a result dev_driver_string(), which is used as the first
    parameter of dev_printk, resolves to an empty string. This causes
    entries like the following to show in my logs:
    
     i2c-2: adapter [SMBus stub driver] registered
    
    Notice the unaesthetical leading whitespace. In order to fix this
    problem, I suggest that we extend dev_driver_string to deal with
    new-style class devices:
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 658eae5dacda..9ea12d9b48a6 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -43,7 +43,8 @@ int (*platform_notify_remove)(struct device * dev) = NULL;
 const char *dev_driver_string(struct device *dev)
 {
 	return dev->driver ? dev->driver->name :
-			(dev->bus ? dev->bus->name : "");
+			(dev->bus ? dev->bus->name :
+			(dev->class ? dev->class->name : ""));
 }
 EXPORT_SYMBOL(dev_driver_string);
 

commit 864062457a2e444227bd368ca5f2a2b740de604f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Mar 14 03:25:56 2007 +0100

    driver core: fix namespace issue with devices assigned to classes
    
      - uses a kset in "struct class" to keep track of all directories
        belonging to this class
      - merges with the /sys/devices/virtual logic.
      - removes the namespace-dir if the last member of that class
        leaves the directory.
    
    There may be locking or refcounting fixes left, I stopped when it seemed
    to work with network and sound modules. :)
    
    From: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index db3a151be4a1..658eae5dacda 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -477,34 +477,58 @@ static struct kobject * get_device_parent(struct device *dev,
 	return NULL;
 }
 #else
-static struct kobject * virtual_device_parent(struct device *dev)
+static struct kobject *virtual_device_parent(struct device *dev)
 {
-	if (!dev->class)
-		return ERR_PTR(-ENODEV);
-
-	if (!dev->class->virtual_dir) {
-		static struct kobject *virtual_dir = NULL;
+	static struct kobject *virtual_dir = NULL;
 
-		if (!virtual_dir)
-			virtual_dir = kobject_add_dir(&devices_subsys.kset.kobj, "virtual");
-		dev->class->virtual_dir = kobject_add_dir(virtual_dir, dev->class->name);
-	}
+	if (!virtual_dir)
+		virtual_dir = kobject_add_dir(&devices_subsys.kset.kobj, "virtual");
 
-	return dev->class->virtual_dir;
+	return virtual_dir;
 }
 
 static struct kobject * get_device_parent(struct device *dev,
 					  struct device *parent)
 {
-	/* if this is a class device, and has no parent, create one */
-	if ((dev->class) && (parent == NULL)) {
-		return virtual_device_parent(dev);
-	} else if (parent)
+	if (dev->class) {
+		struct kobject *kobj = NULL;
+		struct kobject *parent_kobj;
+		struct kobject *k;
+
+		/*
+		 * If we have no parent, we live in "virtual".
+		 * Class-devices with a bus-device as parent, live
+		 * in a class-directory to prevent namespace collisions.
+		 */
+		if (parent == NULL)
+			parent_kobj = virtual_device_parent(dev);
+		else if (parent->class)
+			return &parent->kobj;
+		else
+			parent_kobj = &parent->kobj;
+
+		/* find our class-directory at the parent and reference it */
+		spin_lock(&dev->class->class_dirs.list_lock);
+		list_for_each_entry(k, &dev->class->class_dirs.list, entry)
+			if (k->parent == parent_kobj) {
+				kobj = kobject_get(k);
+				break;
+			}
+		spin_unlock(&dev->class->class_dirs.list_lock);
+		if (kobj)
+			return kobj;
+
+		/* or create a new class-directory at the parent device */
+		return kobject_kset_add_dir(&dev->class->class_dirs,
+					    parent_kobj, dev->class->name);
+	}
+
+	if (parent)
 		return &parent->kobj;
 	return NULL;
 }
-
 #endif
+
 static int setup_parent(struct device *dev, struct device *parent)
 {
 	struct kobject *kobj;
@@ -541,7 +565,6 @@ int device_add(struct device *dev)
 	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);
 
 	parent = get_device(dev->parent);
-
 	error = setup_parent(dev, parent);
 	if (error)
 		goto Error;
@@ -787,6 +810,31 @@ void device_del(struct device * dev)
 		/* remove the device from the class list */
 		list_del_init(&dev->node);
 		up(&dev->class->sem);
+
+		/* If we live in a parent class-directory, unreference it */
+		if (dev->kobj.parent->kset == &dev->class->class_dirs) {
+			struct device *d;
+			int other = 0;
+
+			/*
+			 * if we are the last child of our class, delete
+			 * our class-directory at this parent
+			 */
+			down(&dev->class->sem);
+			list_for_each_entry(d, &dev->class->devices, node) {
+				if (d == dev)
+					continue;
+				if (d->kobj.parent == dev->kobj.parent) {
+					other = 1;
+					break;
+				}
+			}
+			if (!other)
+				kobject_del(dev->kobj.parent);
+
+			kobject_put(dev->kobj.parent);
+			up(&dev->class->sem);
+		}
 	}
 	device_remove_file(dev, &dev->uevent_attr);
 	device_remove_groups(dev);

commit 00ed8e3dda47f8421b11da17e353d7db8c878121
Author: Dmitriy Monakhov <dmonakhov@sw.ru>
Date:   Sun Mar 11 15:36:19 2007 +0300

    driver core: fix device_add error path
    
     - At the moment we jump here device was't added to
       dev->class->devices list yet.
    
    Signed-off-by: Monakhov Dmitriy <dmonakhov@openvz.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d7fcf823a42a..db3a151be4a1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -677,15 +677,6 @@ int device_add(struct device *dev)
 #endif
 			sysfs_remove_link(&dev->kobj, "device");
 		}
-
-		down(&dev->class->sem);
-		/* notify any interfaces that the device is now gone */
-		list_for_each_entry(class_intf, &dev->class->interfaces, node)
-			if (class_intf->remove_dev)
-				class_intf->remove_dev(dev, class_intf);
-		/* remove the device from the class list */
-		list_del_init(&dev->node);
-		up(&dev->class->sem);
 	}
  ueventattrError:
 	device_remove_file(dev, &dev->uevent_attr);

commit 2363cc0264c42636e9e7622f78dde5c2f66beb8e
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Apr 4 19:08:22 2007 -0700

    [PATCH] remove protection of LANANA-reserved majors
    
    Revert all this.  It can cause device-mapper to receive a different major from
    earlier kernels and it turns out that the Amanda backup program (via GNU tar,
    apparently) checks major numbers on files when performing incremental backups.
    
    Which is a bit broken of Amanda (or tar), but this feature isn't important
    enough to justify the churn.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ad0f4a2f25c4..d7fcf823a42a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -27,20 +27,6 @@
 int (*platform_notify)(struct device * dev) = NULL;
 int (*platform_notify_remove)(struct device * dev) = NULL;
 
-/*
- * Detect the LANANA-assigned LOCAL/EXPERIMENTAL majors
- */
-bool is_lanana_major(unsigned int major)
-{
-	if (major >= 60 && major <= 63)
-		return 1;
-	if (major >= 120 && major <= 127)
-		return 1;
-	if (major >= 240 && major <= 254)
-		return 1;
-	return 0;
-}
-
 /*
  * sysfs bindings for devices.
  */

commit d9a9cdfb078d755e648d53ec25b7370f84ee5729
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Mar 15 15:50:34 2007 -0400

    [PATCH] sysfs and driver core: add callback helper, used by SCSI and S390
    
    This patch (as868) adds a helper routine for device drivers that need
    to set up a callback to perform some action in a different process's
    context.  This is intended for use by attribute methods that want to
    unregister themselves or their parent device.  Attribute method calls
    are mutually exclusive with unregistration, so such actions cannot be
    taken directly.
    
    Two attribute methods are converted to use the new helper routine: one
    for SCSI device deletion and one for System/390 ccwgroup devices.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f191afe62b4d..ad0f4a2f25c4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -407,6 +407,35 @@ void device_remove_bin_file(struct device *dev, struct bin_attribute *attr)
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
+/**
+ * device_schedule_callback - helper to schedule a callback for a device
+ * @dev: device.
+ * @func: callback function to invoke later.
+ *
+ * Attribute methods must not unregister themselves or their parent device
+ * (which would amount to the same thing).  Attempts to do so will deadlock,
+ * since unregistration is mutually exclusive with driver callbacks.
+ *
+ * Instead methods can call this routine, which will attempt to allocate
+ * and schedule a workqueue request to call back @func with @dev as its
+ * argument in the workqueue's process context.  @dev will be pinned until
+ * @func returns.
+ *
+ * Returns 0 if the request was submitted, -ENOMEM if storage could not
+ * be allocated.
+ *
+ * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
+ * underlying sysfs routine (since it is intended for use by attribute
+ * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
+ */
+int device_schedule_callback(struct device *dev,
+		void (*func)(struct device *))
+{
+	return sysfs_schedule_callback(&dev->kobj,
+			(void (*)(void *)) func, dev);
+}
+EXPORT_SYMBOL_GPL(device_schedule_callback);
+
 static void klist_children_get(struct klist_node *n)
 {
 	struct device *dev = container_of(n, struct device, knode_parent);

commit a2807dbcbd681e1f36e813fb26e2f24d15018b91
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Feb 28 12:38:31 2007 +0100

    driver core: export device_rename
    
    In wireless we'd like to allow renaming of the phy devices we surface in
    sysfs. The base wireless code, however, can be built modular and thus we
    need device_rename exported.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fb16f293561d..f191afe62b4d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1065,7 +1065,7 @@ int device_rename(struct device *dev, char *new_name)
 
 	return error;
 }
-
+EXPORT_SYMBOL_GPL(device_rename);
 
 static int device_move_class_links(struct device *dev,
 				   struct device *old_parent,

commit f7f3461d87536bed52bb83bc8fbe6bfd28619fb1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Mar 6 12:55:53 2007 -0800

    Driver core: add device symlink back to sysfs
    
    This moves the device symlink back to sysfs even if
    CONFIG_SYSFS_DEPRECATED is enabled as too many userspace programs (well,
    HAL), still rely on this link to be present.
    
    I will rework the ability for sysfs to change layouts like this in the
    future, but for now, this patch should fix people's network connections.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 89ebe3682726..fb16f293561d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -584,17 +584,17 @@ int device_add(struct device *dev)
 		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
 			sysfs_create_link(&dev->class->subsys.kset.kobj,
 					  &dev->kobj, dev->bus_id);
-#ifdef CONFIG_SYSFS_DEPRECATED
 		if (parent) {
 			sysfs_create_link(&dev->kobj, &dev->parent->kobj,
 							"device");
+#ifdef CONFIG_SYSFS_DEPRECATED
 			class_name = make_class_name(dev->class->name,
 							&dev->kobj);
 			if (class_name)
 				sysfs_create_link(&dev->parent->kobj,
 						  &dev->kobj, class_name);
-		}
 #endif
+		}
 	}
 
 	if ((error = device_add_attrs(dev)))
@@ -651,17 +651,17 @@ int device_add(struct device *dev)
 		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
 			sysfs_remove_link(&dev->class->subsys.kset.kobj,
 					  dev->bus_id);
-#ifdef CONFIG_SYSFS_DEPRECATED
 		if (parent) {
+#ifdef CONFIG_SYSFS_DEPRECATED
 			char *class_name = make_class_name(dev->class->name,
 							   &dev->kobj);
 			if (class_name)
 				sysfs_remove_link(&dev->parent->kobj,
 						  class_name);
 			kfree(class_name);
+#endif
 			sysfs_remove_link(&dev->kobj, "device");
 		}
-#endif
 
 		down(&dev->class->sem);
 		/* notify any interfaces that the device is now gone */
@@ -761,17 +761,17 @@ void device_del(struct device * dev)
 		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
 			sysfs_remove_link(&dev->class->subsys.kset.kobj,
 					  dev->bus_id);
-#ifdef CONFIG_SYSFS_DEPRECATED
 		if (parent) {
+#ifdef CONFIG_SYSFS_DEPRECATED
 			char *class_name = make_class_name(dev->class->name,
 							   &dev->kobj);
 			if (class_name)
 				sysfs_remove_link(&dev->parent->kobj,
 						  class_name);
 			kfree(class_name);
+#endif
 			sysfs_remove_link(&dev->kobj, "device");
 		}
-#endif
 
 		down(&dev->class->sem);
 		/* notify any interfaces that the device is now gone */
@@ -1071,8 +1071,8 @@ static int device_move_class_links(struct device *dev,
 				   struct device *old_parent,
 				   struct device *new_parent)
 {
+	int error = 0;
 #ifdef CONFIG_SYSFS_DEPRECATED
-	int error;
 	char *class_name;
 
 	class_name = make_class_name(dev->class->name, &dev->kobj);
@@ -1100,7 +1100,12 @@ static int device_move_class_links(struct device *dev,
 	kfree(class_name);
 	return error;
 #else
-	return 0;
+	if (old_parent)
+		sysfs_remove_link(&dev->kobj, "device");
+	if (new_parent)
+		error = sysfs_create_link(&dev->kobj, &new_parent->kobj,
+					  "device");
+	return error;
 #endif
 }
 

commit 2f8d16a996da0b9be2536994aa7a825418364471
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Mar 9 19:34:19 2007 +0900

    devres: release resources on device_del()
    
    Some platform devices are driven without driver attached, so managed
    resources can be acquired without driver attached.  Make sure such
    resources are released by calling devres_release_all() in
    device_del().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index cf2a398aaaa1..89ebe3682726 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -787,6 +787,13 @@ void device_del(struct device * dev)
 	device_remove_attrs(dev);
 	bus_remove_device(dev);
 
+	/*
+	 * Some platform devices are driven without driver attached
+	 * and managed resources may have been acquired.  Make sure
+	 * all resources are released.
+	 */
+	devres_release_all(dev);
+
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...
 	 */

commit 82f0cf9b7c42684c29189ddb6d0bc86eb1137fc4
Author: James Simmons <jsimmons@infradead.org>
Date:   Wed Feb 21 17:44:51 2007 +0000

    Driver core: fix error by cleanup up symlinks properly
    
    When a device fails to register the class symlinks where not cleaned up.
    This left a symlink in the /sys/class/"device"/ directory that pointed
    to no where. This caused the sysfs_follow_link Oops I reported earlier.
    This patch cleanups up the symlink. Please apply. Thank you.
    
    Signed-Off: James Simmons <jsimmons@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d04fd33dcd91..cf2a398aaaa1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -637,12 +637,41 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_DEL_DEVICE, dev);
 	device_remove_groups(dev);
  GroupError:
- 	device_remove_attrs(dev);
+	device_remove_attrs(dev);
  AttrsError:
 	if (dev->devt_attr) {
 		device_remove_file(dev, dev->devt_attr);
 		kfree(dev->devt_attr);
 	}
+
+	if (dev->class) {
+		sysfs_remove_link(&dev->kobj, "subsystem");
+		/* If this is not a "fake" compatible device, remove the
+		 * symlink from the class to the device. */
+		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
+			sysfs_remove_link(&dev->class->subsys.kset.kobj,
+					  dev->bus_id);
+#ifdef CONFIG_SYSFS_DEPRECATED
+		if (parent) {
+			char *class_name = make_class_name(dev->class->name,
+							   &dev->kobj);
+			if (class_name)
+				sysfs_remove_link(&dev->parent->kobj,
+						  class_name);
+			kfree(class_name);
+			sysfs_remove_link(&dev->kobj, "device");
+		}
+#endif
+
+		down(&dev->class->sem);
+		/* notify any interfaces that the device is now gone */
+		list_for_each_entry(class_intf, &dev->class->interfaces, node)
+			if (class_intf->remove_dev)
+				class_intf->remove_dev(dev, class_intf);
+		/* remove the device from the class list */
+		list_del_init(&dev->node);
+		up(&dev->class->sem);
+	}
  ueventattrError:
 	device_remove_file(dev, &dev->uevent_attr);
  attrError:

commit b446b60e4eb5e5457120c4728ada871b1209c1d0
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Feb 20 13:57:48 2007 -0800

    [PATCH] rework reserved major handling
    
    Several people have reported failures in dynamic major device number handling
    due to the recent changes in there to avoid handing out the local/experimental
    majors.
    
    Rolf reports that this is due to a gcc-4.1.0 bug.
    
    The patch refactors that code a lot in an attempt to provoke the compiler into
    behaving.
    
    Cc: Rolf Eike Beer <eike-kernel@sf-tec.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a8ac34ba6107..d04fd33dcd91 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -27,6 +27,20 @@
 int (*platform_notify)(struct device * dev) = NULL;
 int (*platform_notify_remove)(struct device * dev) = NULL;
 
+/*
+ * Detect the LANANA-assigned LOCAL/EXPERIMENTAL majors
+ */
+bool is_lanana_major(unsigned int major)
+{
+	if (major >= 60 && major <= 63)
+		return 1;
+	if (major >= 120 && major <= 127)
+		return 1;
+	if (major >= 240 && major <= 254)
+		return 1;
+	return 0;
+}
+
 /*
  * sysfs bindings for devices.
  */

commit 9ac7849e35f705830f7b016ff272b0ff1f7ff759
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:26 2007 +0900

    devres: device resource management
    
    Implement device resource management, in short, devres.  A device
    driver can allocate arbirary size of devres data which is associated
    with a release function.  On driver detach, release function is
    invoked on the devres data, then, devres data is freed.
    
    devreses are typed by associated release functions.  Some devreses are
    better represented by single instance of the type while others need
    multiple instances sharing the same release function.  Both usages are
    supported.
    
    devreses can be grouped using devres group such that a device driver
    can easily release acquired resources halfway through initialization
    or selectively release resources (e.g. resources for port 1 out of 4
    ports).
    
    This patch adds devres core including documentation and the following
    managed interfaces.
    
    * alloc/free    : devm_kzalloc(), devm_kzfree()
    * IO region     : devm_request_region(), devm_release_region()
    * IRQ           : devm_request_irq(), devm_free_irq()
    * DMA           : dmam_alloc_coherent(), dmam_free_coherent(),
                      dmam_declare_coherent_memory(), dmam_pool_create(),
                      dmam_pool_destroy()
    * PCI           : pcim_enable_device(), pcim_pin_device(), pci_is_managed()
    * iomap         : devm_ioport_map(), devm_ioport_unmap(), devm_ioremap(),
                      devm_ioremap_nocache(), devm_iounmap(), pcim_iomap_table(),
                      pcim_iomap(), pcim_iounmap()
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e13614241c9e..a8ac34ba6107 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -428,6 +428,8 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->dma_pools);
 	INIT_LIST_HEAD(&dev->node);
 	init_MUTEX(&dev->sem);
+	spin_lock_init(&dev->devres_lock);
+	INIT_LIST_HEAD(&dev->devres_head);
 	device_init_wakeup(dev, 0);
 	set_dev_node(dev, -1);
 }

commit b7a3e813fb84624166f034e25234f98de5846bfc
Author: Kay Sievers <kay.sievers@novell.com>
Date:   Sat Oct 7 21:54:55 2006 +0200

    Driver core: allow to delay the uevent at device creation time
    
    For the block subsystem, we want to delay all uevents until the
    disk has been scanned and allpartitons are already created before
    the first event is sent out.
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 34ac18778d8a..e13614241c9e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -589,7 +589,8 @@ int device_add(struct device *dev)
 		goto PMError;
 	if ((error = bus_add_device(dev)))
 		goto BusError;
-	kobject_uevent(&dev->kobj, KOBJ_ADD);
+	if (!dev->uevent_suppress)
+		kobject_uevent(&dev->kobj, KOBJ_ADD);
 	if ((error = bus_attach_device(dev)))
 		goto AttachError;
 	if (parent)

commit f9f852df2faf76a2667949ddb4947d4b8f99f02f
Author: Kay Sievers <kay.sievers@novell.com>
Date:   Sat Oct 7 21:54:55 2006 +0200

    Driver core: add device_type to struct device
    
    This allows us to add type specific attributes, uevent vars and
    release funtions.
    
    A subsystem can carry different types of devices like the "block"
    subsys has disks and partitions. Both types create a different set
    of attributes, but belong to the same subsystem.
    
    This corresponds to the low level objects:
      kobject   -> device       (object/device data)
      kobj_type -> device_type  (type of object/device we are embedded in)
      kset      -> class/bus    (list of objects/devices of a subsystem)
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7a5336f7df89..34ac18778d8a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -95,6 +95,8 @@ static void device_release(struct kobject * kobj)
 
 	if (dev->release)
 		dev->release(dev);
+	else if (dev->type && dev->type->release)
+		dev->type->release(dev);
 	else if (dev->class && dev->class->dev_release)
 		dev->class->dev_release(dev);
 	else {
@@ -206,19 +208,25 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 	if (dev->bus && dev->bus->uevent) {
 		/* have the bus specific function add its stuff */
 		retval = dev->bus->uevent(dev, envp, num_envp, buffer, buffer_size);
-			if (retval) {
-			pr_debug ("%s - uevent() returned %d\n",
+		if (retval)
+			pr_debug ("%s: bus uevent() returned %d\n",
 				  __FUNCTION__, retval);
-		}
 	}
 
 	if (dev->class && dev->class->dev_uevent) {
 		/* have the class specific function add its stuff */
 		retval = dev->class->dev_uevent(dev, envp, num_envp, buffer, buffer_size);
-			if (retval) {
-				pr_debug("%s - dev_uevent() returned %d\n",
-					 __FUNCTION__, retval);
-		}
+		if (retval)
+			pr_debug("%s: class uevent() returned %d\n",
+				 __FUNCTION__, retval);
+	}
+
+	if (dev->type && dev->type->uevent) {
+		/* have the device type specific fuction add its stuff */
+		retval = dev->type->uevent(dev, envp, num_envp, buffer, buffer_size);
+		if (retval)
+			pr_debug("%s: dev_type uevent() returned %d\n",
+				 __FUNCTION__, retval);
 	}
 
 	return retval;
@@ -269,37 +277,50 @@ static void device_remove_groups(struct device *dev)
 static int device_add_attrs(struct device *dev)
 {
 	struct class *class = dev->class;
+	struct device_type *type = dev->type;
 	int error = 0;
 	int i;
 
-	if (!class)
-		return 0;
-
-	if (class->dev_attrs) {
+	if (class && class->dev_attrs) {
 		for (i = 0; attr_name(class->dev_attrs[i]); i++) {
 			error = device_create_file(dev, &class->dev_attrs[i]);
 			if (error)
 				break;
 		}
+		if (error)
+			while (--i >= 0)
+				device_remove_file(dev, &class->dev_attrs[i]);
 	}
-	if (error)
-		while (--i >= 0)
-			device_remove_file(dev, &class->dev_attrs[i]);
+
+	if (type && type->attrs) {
+		for (i = 0; attr_name(type->attrs[i]); i++) {
+			error = device_create_file(dev, &type->attrs[i]);
+			if (error)
+				break;
+		}
+		if (error)
+			while (--i >= 0)
+				device_remove_file(dev, &type->attrs[i]);
+	}
+
 	return error;
 }
 
 static void device_remove_attrs(struct device *dev)
 {
 	struct class *class = dev->class;
+	struct device_type *type = dev->type;
 	int i;
 
-	if (!class)
-		return;
-
-	if (class->dev_attrs) {
+	if (class && class->dev_attrs) {
 		for (i = 0; attr_name(class->dev_attrs[i]); i++)
 			device_remove_file(dev, &class->dev_attrs[i]);
 	}
+
+	if (type && type->attrs) {
+		for (i = 0; attr_name(type->attrs[i]); i++)
+			device_remove_file(dev, &type->attrs[i]);
+	}
 }
 
 

commit 239378f16aa1ab5c502e42a06359d2de4f88ebb4
Author: Kay Sievers <kay.sievers@novell.com>
Date:   Sat Oct 7 21:54:55 2006 +0200

    Driver core: add uevent vars for devices of a class
    
    Devices converted from class_device to device should have
    the same uevent keys as the original class_device had. We
    search up the parents until we find the first bus device and
    add the (already deprecated) PHYDEV* values.
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6fee3e6b1ac2..7a5336f7df89 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -154,25 +154,47 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 			       "MINOR=%u", MINOR(dev->devt));
 	}
 
-#ifdef CONFIG_SYSFS_DEPRECATED
-	/* add bus name (same as SUBSYSTEM, deprecated) */
-	if (dev->bus)
-		add_uevent_var(envp, num_envp, &i,
-			       buffer, buffer_size, &length,
-			       "PHYSDEVBUS=%s", dev->bus->name);
-#endif
-
-	/* add driver name (PHYSDEV* values are deprecated)*/
-	if (dev->driver) {
+	if (dev->driver)
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,
 			       "DRIVER=%s", dev->driver->name);
+
 #ifdef CONFIG_SYSFS_DEPRECATED
+	if (dev->class) {
+		struct device *parent = dev->parent;
+
+		/* find first bus device in parent chain */
+		while (parent && !parent->bus)
+			parent = parent->parent;
+		if (parent && parent->bus) {
+			const char *path;
+
+			path = kobject_get_path(&parent->kobj, GFP_KERNEL);
+			add_uevent_var(envp, num_envp, &i,
+				       buffer, buffer_size, &length,
+				       "PHYSDEVPATH=%s", path);
+			kfree(path);
+
+			add_uevent_var(envp, num_envp, &i,
+				       buffer, buffer_size, &length,
+				       "PHYSDEVBUS=%s", parent->bus->name);
+
+			if (parent->driver)
+				add_uevent_var(envp, num_envp, &i,
+					       buffer, buffer_size, &length,
+					       "PHYSDEVDRIVER=%s", parent->driver->name);
+		}
+	} else if (dev->bus) {
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,
-			       "PHYSDEVDRIVER=%s", dev->driver->name);
-#endif
+			       "PHYSDEVBUS=%s", dev->bus->name);
+
+		if (dev->driver)
+			add_uevent_var(envp, num_envp, &i,
+				       buffer, buffer_size, &length,
+				       "PHYSDEVDRIVER=%s", dev->driver->name);
 	}
+#endif
 
 	/* terminate, set to next free slot, shrink available space */
 	envp[i] = NULL;

commit cb360bbf6352712310a7528137919c626a782744
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Nov 27 10:35:05 2006 +0100

    driver core fixes: make_class_name() retval checks
    
    Make make_class_name() return NULL on error and fixup callers in the
    driver core.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c60114dbe5f5..6fee3e6b1ac2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -527,9 +527,13 @@ int device_add(struct device *dev)
 					  &dev->kobj, dev->bus_id);
 #ifdef CONFIG_SYSFS_DEPRECATED
 		if (parent) {
-			sysfs_create_link(&dev->kobj, &dev->parent->kobj, "device");
-			class_name = make_class_name(dev->class->name, &dev->kobj);
-			sysfs_create_link(&dev->parent->kobj, &dev->kobj, class_name);
+			sysfs_create_link(&dev->kobj, &dev->parent->kobj,
+							"device");
+			class_name = make_class_name(dev->class->name,
+							&dev->kobj);
+			if (class_name)
+				sysfs_create_link(&dev->parent->kobj,
+						  &dev->kobj, class_name);
 		}
 #endif
 	}
@@ -672,7 +676,9 @@ void device_del(struct device * dev)
 		if (parent) {
 			char *class_name = make_class_name(dev->class->name,
 							   &dev->kobj);
-			sysfs_remove_link(&dev->parent->kobj, class_name);
+			if (class_name)
+				sysfs_remove_link(&dev->parent->kobj,
+						  class_name);
 			kfree(class_name);
 			sysfs_remove_link(&dev->kobj, "device");
 		}
@@ -975,8 +981,7 @@ static int device_move_class_links(struct device *dev,
 
 	class_name = make_class_name(dev->class->name, &dev->kobj);
 	if (!class_name) {
-		error = PTR_ERR(class_name);
-		class_name = NULL;
+		error = -ENOMEM;
 		goto out;
 	}
 	if (old_parent) {

commit c744aeae9d173a953b771a7ad5c872f91fa99dec
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Jan 8 20:16:44 2007 +0100

    driver core: Allow device_move(dev, NULL).
    
    If we allow NULL as the new parent in device_move(), we need to make sure
    that the device is placed into the same place as it would if it was
    newly registered:
    
    - Consider the device virtual tree. In order to be able to reuse code,
      setup_parent() has been tweaked a bit.
    - kobject_move() can fall back to the kset's kobject.
    - sysfs_move_dir() uses the sysfs root dir as fallback.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 36eedfdeb547..c60114dbe5f5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -390,22 +390,23 @@ void device_initialize(struct device *dev)
 }
 
 #ifdef CONFIG_SYSFS_DEPRECATED
-static int setup_parent(struct device *dev, struct device *parent)
+static struct kobject * get_device_parent(struct device *dev,
+					  struct device *parent)
 {
 	/* Set the parent to the class, not the parent device */
 	/* this keeps sysfs from having a symlink to make old udevs happy */
 	if (dev->class)
-		dev->kobj.parent = &dev->class->subsys.kset.kobj;
+		return &dev->class->subsys.kset.kobj;
 	else if (parent)
-		dev->kobj.parent = &parent->kobj;
+		return &parent->kobj;
 
-	return 0;
+	return NULL;
 }
 #else
-static int virtual_device_parent(struct device *dev)
+static struct kobject * virtual_device_parent(struct device *dev)
 {
 	if (!dev->class)
-		return -ENODEV;
+		return ERR_PTR(-ENODEV);
 
 	if (!dev->class->virtual_dir) {
 		static struct kobject *virtual_dir = NULL;
@@ -415,25 +416,31 @@ static int virtual_device_parent(struct device *dev)
 		dev->class->virtual_dir = kobject_add_dir(virtual_dir, dev->class->name);
 	}
 
-	dev->kobj.parent = dev->class->virtual_dir;
-	return 0;
+	return dev->class->virtual_dir;
 }
 
-static int setup_parent(struct device *dev, struct device *parent)
+static struct kobject * get_device_parent(struct device *dev,
+					  struct device *parent)
 {
-	int error;
-
 	/* if this is a class device, and has no parent, create one */
 	if ((dev->class) && (parent == NULL)) {
-		error = virtual_device_parent(dev);
-		if (error)
-			return error;
+		return virtual_device_parent(dev);
 	} else if (parent)
-		dev->kobj.parent = &parent->kobj;
+		return &parent->kobj;
+	return NULL;
+}
 
+#endif
+static int setup_parent(struct device *dev, struct device *parent)
+{
+	struct kobject *kobj;
+	kobj = get_device_parent(dev, parent);
+	if (IS_ERR(kobj))
+		return PTR_ERR(kobj);
+	if (kobj)
+		dev->kobj.parent = kobj;
 	return 0;
 }
-#endif
 
 /**
  *	device_add - add device to device hierarchy.
@@ -976,12 +983,18 @@ static int device_move_class_links(struct device *dev,
 		sysfs_remove_link(&dev->kobj, "device");
 		sysfs_remove_link(&old_parent->kobj, class_name);
 	}
-	error = sysfs_create_link(&dev->kobj, &new_parent->kobj, "device");
-	if (error)
-		goto out;
-	error = sysfs_create_link(&new_parent->kobj, &dev->kobj, class_name);
-	if (error)
-		sysfs_remove_link(&dev->kobj, "device");
+	if (new_parent) {
+		error = sysfs_create_link(&dev->kobj, &new_parent->kobj,
+					  "device");
+		if (error)
+			goto out;
+		error = sysfs_create_link(&new_parent->kobj, &dev->kobj,
+					  class_name);
+		if (error)
+			sysfs_remove_link(&dev->kobj, "device");
+	}
+	else
+		error = 0;
 out:
 	kfree(class_name);
 	return error;
@@ -993,25 +1006,28 @@ static int device_move_class_links(struct device *dev,
 /**
  * device_move - moves a device to a new parent
  * @dev: the pointer to the struct device to be moved
- * @new_parent: the new parent of the device
+ * @new_parent: the new parent of the device (can by NULL)
  */
 int device_move(struct device *dev, struct device *new_parent)
 {
 	int error;
 	struct device *old_parent;
+	struct kobject *new_parent_kobj;
 
 	dev = get_device(dev);
 	if (!dev)
 		return -EINVAL;
 
 	new_parent = get_device(new_parent);
-	if (!new_parent) {
-		error = -EINVAL;
+	new_parent_kobj = get_device_parent (dev, new_parent);
+	if (IS_ERR(new_parent_kobj)) {
+		error = PTR_ERR(new_parent_kobj);
+		put_device(new_parent);
 		goto out;
 	}
 	pr_debug("DEVICE: moving '%s' to '%s'\n", dev->bus_id,
-		new_parent->bus_id);
-	error = kobject_move(&dev->kobj, &new_parent->kobj);
+		 new_parent ? new_parent->bus_id : "<NULL>");
+	error = kobject_move(&dev->kobj, new_parent_kobj);
 	if (error) {
 		put_device(new_parent);
 		goto out;
@@ -1020,7 +1036,8 @@ int device_move(struct device *dev, struct device *new_parent)
 	dev->parent = new_parent;
 	if (old_parent)
 		klist_remove(&dev->knode_parent);
-	klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
+	if (new_parent)
+		klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
 	if (!dev->class)
 		goto out_put;
 	error = device_move_class_links(dev, old_parent, new_parent);
@@ -1028,7 +1045,8 @@ int device_move(struct device *dev, struct device *new_parent)
 		/* We ignore errors on cleanup since we're hosed anyway... */
 		device_move_class_links(dev, new_parent, old_parent);
 		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
-			klist_remove(&dev->knode_parent);
+			if (new_parent)
+				klist_remove(&dev->knode_parent);
 			if (old_parent)
 				klist_add_tail(&dev->knode_parent,
 					       &old_parent->klist_children);

commit 717e48c29d9a58f4d31c1651bec364212da5f6b2
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Jan 8 20:16:41 2007 +0100

    driver core: Remove device_is_registered() in device_move().
    
    device_is_registered() will always be false for a device with no bus. Remove
    this check and trust the caller to know what they're doing.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 67b79a7592a9..36eedfdeb547 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1004,10 +1004,6 @@ int device_move(struct device *dev, struct device *new_parent)
 	if (!dev)
 		return -EINVAL;
 
-	if (!device_is_registered(dev)) {
-		error = -EINVAL;
-		goto out;
-	}
 	new_parent = get_device(new_parent);
 	if (!new_parent) {
 		error = -EINVAL;

commit 873481367edb18a7d0d7e5a285e6728c16bb44a9
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Dec 6 20:32:33 2006 -0800

    [PATCH] add numa node information to struct device
    
    For node-aware skb allocations we need information about the node in struct
    net_device or struct device.  Davem suggested to put it into struct device
    which this patch does.
    
    In particular:
    
     - struct device gets a new int numa_node member if CONFIG_NUMA is set
     - there are two new helpers, dev_to_node and set_dev_node to
       transparently deal with the non-numa case
     - for pci devices the node-info is set to the value we get from
       pcibus_to_node.
    
    Note that for some architectures pcibus_to_node doesn't work yet at the time
    we call it currently.  This is harmless and will just mean skb allocations
    aren't node-local on this architectures until the implementation of
    pcibus_to_node on these architectures have been updated (There are patches for
    x86 and x86_64 floating around)
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Christoph Lameter <clameter@engr.sgi.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e4b530ef757d..67b79a7592a9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -386,6 +386,7 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->node);
 	init_MUTEX(&dev->sem);
 	device_init_wakeup(dev, 0);
+	set_dev_node(dev, -1);
 }
 
 #ifdef CONFIG_SYSFS_DEPRECATED

commit acf02d23b96efa92e7cff05987122ceeb37dd075
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Nov 22 17:49:39 2006 +0100

    driver core: Use klist_remove() in device_move()
    
    As pointed out by Alan Stern, device_move needs to use klist_remove which waits
    until removal is complete.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e4eaf46c4d93..e4b530ef757d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1022,7 +1022,7 @@ int device_move(struct device *dev, struct device *new_parent)
 	old_parent = dev->parent;
 	dev->parent = new_parent;
 	if (old_parent)
-		klist_del(&dev->knode_parent);
+		klist_remove(&dev->knode_parent);
 	klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
 	if (!dev->class)
 		goto out_put;
@@ -1031,7 +1031,7 @@ int device_move(struct device *dev, struct device *new_parent)
 		/* We ignore errors on cleanup since we're hosed anyway... */
 		device_move_class_links(dev, new_parent, old_parent);
 		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
-			klist_del(&dev->knode_parent);
+			klist_remove(&dev->knode_parent);
 			if (old_parent)
 				klist_add_tail(&dev->knode_parent,
 					       &old_parent->klist_children);

commit 8a82472f86bf693b8e91ed56c9ca4f62fbbdcfa3
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Nov 20 17:07:51 2006 +0100

    driver core: Introduce device_move(): move a device to a new parent.
    
    Provide a function device_move() to move a device to a new parent device. Add
    auxilliary functions kobject_move() and sysfs_move_dir().
    kobject_move() generates a new uevent of type KOBJ_MOVE, containing the
    previous path (DEVPATH_OLD) in addition to the usual values. For this, a new
    interface kobject_uevent_env() is created that allows to add further
    environmental data to the uevent at the kobject layer.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 75b45a10935a..e4eaf46c4d93 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -955,3 +955,95 @@ int device_rename(struct device *dev, char *new_name)
 
 	return error;
 }
+
+
+static int device_move_class_links(struct device *dev,
+				   struct device *old_parent,
+				   struct device *new_parent)
+{
+#ifdef CONFIG_SYSFS_DEPRECATED
+	int error;
+	char *class_name;
+
+	class_name = make_class_name(dev->class->name, &dev->kobj);
+	if (!class_name) {
+		error = PTR_ERR(class_name);
+		class_name = NULL;
+		goto out;
+	}
+	if (old_parent) {
+		sysfs_remove_link(&dev->kobj, "device");
+		sysfs_remove_link(&old_parent->kobj, class_name);
+	}
+	error = sysfs_create_link(&dev->kobj, &new_parent->kobj, "device");
+	if (error)
+		goto out;
+	error = sysfs_create_link(&new_parent->kobj, &dev->kobj, class_name);
+	if (error)
+		sysfs_remove_link(&dev->kobj, "device");
+out:
+	kfree(class_name);
+	return error;
+#else
+	return 0;
+#endif
+}
+
+/**
+ * device_move - moves a device to a new parent
+ * @dev: the pointer to the struct device to be moved
+ * @new_parent: the new parent of the device
+ */
+int device_move(struct device *dev, struct device *new_parent)
+{
+	int error;
+	struct device *old_parent;
+
+	dev = get_device(dev);
+	if (!dev)
+		return -EINVAL;
+
+	if (!device_is_registered(dev)) {
+		error = -EINVAL;
+		goto out;
+	}
+	new_parent = get_device(new_parent);
+	if (!new_parent) {
+		error = -EINVAL;
+		goto out;
+	}
+	pr_debug("DEVICE: moving '%s' to '%s'\n", dev->bus_id,
+		new_parent->bus_id);
+	error = kobject_move(&dev->kobj, &new_parent->kobj);
+	if (error) {
+		put_device(new_parent);
+		goto out;
+	}
+	old_parent = dev->parent;
+	dev->parent = new_parent;
+	if (old_parent)
+		klist_del(&dev->knode_parent);
+	klist_add_tail(&dev->knode_parent, &new_parent->klist_children);
+	if (!dev->class)
+		goto out_put;
+	error = device_move_class_links(dev, old_parent, new_parent);
+	if (error) {
+		/* We ignore errors on cleanup since we're hosed anyway... */
+		device_move_class_links(dev, new_parent, old_parent);
+		if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
+			klist_del(&dev->knode_parent);
+			if (old_parent)
+				klist_add_tail(&dev->knode_parent,
+					       &old_parent->klist_children);
+		}
+		put_device(new_parent);
+		goto out;
+	}
+out_put:
+	put_device(old_parent);
+out:
+	put_device(dev);
+	return error;
+}
+
+EXPORT_SYMBOL_GPL(device_move);

commit af9e0765362151b27372c14d9d6dc417184182d3
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Nov 17 02:19:44 2006 +0100

    Driver core: make drivers/base/core.c:setup_parent() static
    
    This patch makes the needlessly global setup_parent() static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a29e68545462..75b45a10935a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -389,7 +389,7 @@ void device_initialize(struct device *dev)
 }
 
 #ifdef CONFIG_SYSFS_DEPRECATED
-int setup_parent(struct device *dev, struct device *parent)
+static int setup_parent(struct device *dev, struct device *parent)
 {
 	/* Set the parent to the class, not the parent device */
 	/* this keeps sysfs from having a symlink to make old udevs happy */
@@ -418,7 +418,7 @@ static int virtual_device_parent(struct device *dev)
 	return 0;
 }
 
-int setup_parent(struct device *dev, struct device *parent)
+static int setup_parent(struct device *dev, struct device *parent)
 {
 	int error;
 

commit 5ab699810d46011ad2195c5916f3cbc684bfe3ee
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Thu Nov 16 15:42:07 2006 +0100

    driver core: Introduce device_find_child().
    
    Introduce device_find_child() to match device_for_each_child().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 5d11bbdfbd2f..a29e68545462 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -750,12 +750,45 @@ int device_for_each_child(struct device * parent, void * data,
 	return error;
 }
 
+/**
+ * device_find_child - device iterator for locating a particular device.
+ * @parent: parent struct device
+ * @data: Data to pass to match function
+ * @match: Callback function to check device
+ *
+ * This is similar to the device_for_each_child() function above, but it
+ * returns a reference to a device that is 'found' for later use, as
+ * determined by the @match callback.
+ *
+ * The callback should return 0 if the device doesn't match and non-zero
+ * if it does.  If the callback returns non-zero and a reference to the
+ * current device can be obtained, this function will return to the caller
+ * and not iterate over any more devices.
+ */
+struct device * device_find_child(struct device *parent, void *data,
+				  int (*match)(struct device *, void *))
+{
+	struct klist_iter i;
+	struct device *child;
+
+	if (!parent)
+		return NULL;
+
+	klist_iter_init(&parent->klist_children, &i);
+	while ((child = next_device(&i)))
+		if (match(child, data) && get_device(child))
+			break;
+	klist_iter_exit(&i);
+	return child;
+}
+
 int __init devices_init(void)
 {
 	return subsystem_register(&devices_subsys);
 }
 
 EXPORT_SYMBOL_GPL(device_for_each_child);
+EXPORT_SYMBOL_GPL(device_find_child);
 
 EXPORT_SYMBOL_GPL(device_initialize);
 EXPORT_SYMBOL_GPL(device_add);

commit 289535334646796fe41f199718e4a731f7411a92
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Nov 8 19:46:14 2006 -0800

    Driver core: Call platform_notify_remove later
    
    Move the call to platform_notify_remove() to after the call to
    bus_remove_device(), where it belongs.  It's bogus to notify the platform
    of removal while drivers are still attached to the device and possibly
    still operating since the platform might use this callback to tear down
    some resources used by the driver (ACPI bits, iommu table, ...)
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "Brown, Len" <len.brown@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f544adc5a5e2..5d11bbdfbd2f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -682,6 +682,7 @@ void device_del(struct device * dev)
 	device_remove_file(dev, &dev->uevent_attr);
 	device_remove_groups(dev);
 	device_remove_attrs(dev);
+	bus_remove_device(dev);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...
@@ -691,7 +692,6 @@ void device_del(struct device * dev)
 	if (dev->bus)
 		blocking_notifier_call_chain(&dev->bus->bus_notifier,
 					     BUS_NOTIFY_DEL_DEVICE, dev);
-	bus_remove_device(dev);
 	device_pm_remove(dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);

commit a87cb2ac4a78c590583b52a3ed196adc6c25b6c9
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Sep 14 11:23:28 2006 +0200

    CONFIG_SYSFS_DEPRECATED - PHYSDEV* uevent variables
    
    Disable the PHYSDEV* uevent variables if CONFIG_SYSFS_DEPRECATED is
    enabled.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b565b7e9d40b..f544adc5a5e2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -154,20 +154,24 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 			       "MINOR=%u", MINOR(dev->devt));
 	}
 
+#ifdef CONFIG_SYSFS_DEPRECATED
 	/* add bus name (same as SUBSYSTEM, deprecated) */
 	if (dev->bus)
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,
 			       "PHYSDEVBUS=%s", dev->bus->name);
+#endif
 
 	/* add driver name (PHYSDEV* values are deprecated)*/
 	if (dev->driver) {
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,
 			       "DRIVER=%s", dev->driver->name);
+#ifdef CONFIG_SYSFS_DEPRECATED
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,
 			       "PHYSDEVDRIVER=%s", dev->driver->name);
+#endif
 	}
 
 	/* terminate, set to next free slot, shrink available space */

commit 99ef3ef8d5f2f5b5312627127ad63df27c0d0d05
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Sep 14 11:23:28 2006 +0200

    CONFIG_SYSFS_DEPRECATED - device symlinks
    
    Turn off device symlinks CONFIG_SYSFS_DEPRECATED is enabled.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8f8347b9197f..b565b7e9d40b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -513,11 +513,13 @@ int device_add(struct device *dev)
 		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
 			sysfs_create_link(&dev->class->subsys.kset.kobj,
 					  &dev->kobj, dev->bus_id);
+#ifdef CONFIG_SYSFS_DEPRECATED
 		if (parent) {
 			sysfs_create_link(&dev->kobj, &dev->parent->kobj, "device");
 			class_name = make_class_name(dev->class->name, &dev->kobj);
 			sysfs_create_link(&dev->parent->kobj, &dev->kobj, class_name);
 		}
+#endif
 	}
 
 	if ((error = device_add_attrs(dev)))
@@ -639,7 +641,6 @@ void put_device(struct device * dev)
 void device_del(struct device * dev)
 {
 	struct device * parent = dev->parent;
-	char *class_name = NULL;
 	struct class_interface *class_intf;
 
 	if (parent)
@@ -655,12 +656,16 @@ void device_del(struct device * dev)
 		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
 			sysfs_remove_link(&dev->class->subsys.kset.kobj,
 					  dev->bus_id);
-		class_name = make_class_name(dev->class->name, &dev->kobj);
+#ifdef CONFIG_SYSFS_DEPRECATED
 		if (parent) {
-			sysfs_remove_link(&dev->kobj, "device");
+			char *class_name = make_class_name(dev->class->name,
+							   &dev->kobj);
 			sysfs_remove_link(&dev->parent->kobj, class_name);
+			kfree(class_name);
+			sysfs_remove_link(&dev->kobj, "device");
 		}
-		kfree(class_name);
+#endif
+
 		down(&dev->class->sem);
 		/* notify any interfaces that the device is now gone */
 		list_for_each_entry(class_intf, &dev->class->interfaces, node)
@@ -869,8 +874,10 @@ int device_rename(struct device *dev, char *new_name)
 
 	pr_debug("DEVICE: renaming '%s' to '%s'\n", dev->bus_id, new_name);
 
+#ifdef CONFIG_SYSFS_DEPRECATED
 	if ((dev->class) && (dev->parent))
 		old_class_name = make_class_name(dev->class->name, &dev->kobj);
+#endif
 
 	if (dev->class) {
 		old_symlink_name = kmalloc(BUS_ID_SIZE, GFP_KERNEL);
@@ -885,6 +892,7 @@ int device_rename(struct device *dev, char *new_name)
 
 	error = kobject_rename(&dev->kobj, new_name);
 
+#ifdef CONFIG_SYSFS_DEPRECATED
 	if (old_class_name) {
 		new_class_name = make_class_name(dev->class->name, &dev->kobj);
 		if (new_class_name) {
@@ -893,6 +901,8 @@ int device_rename(struct device *dev, char *new_name)
 			sysfs_remove_link(&dev->parent->kobj, old_class_name);
 		}
 	}
+#endif
+
 	if (dev->class) {
 		sysfs_remove_link(&dev->class->subsys.kset.kobj,
 				  old_symlink_name);

commit 40fa54226f518a9bc97ed1d711c0016e416e3782
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 24 00:37:58 2006 +0100

    Driver core: make old versions of udev work properly
    
    If CONFIG_SYSFS_DEPRECATED is enabled, old versions of udev will work
    properly with devices that are associated with a class.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index dbcd40b987d2..8f8347b9197f 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -384,6 +384,19 @@ void device_initialize(struct device *dev)
 	device_init_wakeup(dev, 0);
 }
 
+#ifdef CONFIG_SYSFS_DEPRECATED
+int setup_parent(struct device *dev, struct device *parent)
+{
+	/* Set the parent to the class, not the parent device */
+	/* this keeps sysfs from having a symlink to make old udevs happy */
+	if (dev->class)
+		dev->kobj.parent = &dev->class->subsys.kset.kobj;
+	else if (parent)
+		dev->kobj.parent = &parent->kobj;
+
+	return 0;
+}
+#else
 static int virtual_device_parent(struct device *dev)
 {
 	if (!dev->class)
@@ -401,6 +414,22 @@ static int virtual_device_parent(struct device *dev)
 	return 0;
 }
 
+int setup_parent(struct device *dev, struct device *parent)
+{
+	int error;
+
+	/* if this is a class device, and has no parent, create one */
+	if ((dev->class) && (parent == NULL)) {
+		error = virtual_device_parent(dev);
+		if (error)
+			return error;
+	} else if (parent)
+		dev->kobj.parent = &parent->kobj;
+
+	return 0;
+}
+#endif
+
 /**
  *	device_add - add device to device hierarchy.
  *	@dev:	device.
@@ -423,23 +452,18 @@ int device_add(struct device *dev)
 	if (!dev || !strlen(dev->bus_id))
 		goto Error;
 
-	/* if this is a class device, and has no parent, create one */
-	if ((dev->class) && (dev->parent == NULL)) {
-		error = virtual_device_parent(dev);
-		if (error)
-			goto Error;
-	}
+	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);
 
 	parent = get_device(dev->parent);
 
-	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);
+	error = setup_parent(dev, parent);
+	if (error)
+		goto Error;
 
 	/* first, register with generic layer. */
 	kobject_set_name(&dev->kobj, "%s", dev->bus_id);
-	if (parent)
-		dev->kobj.parent = &parent->kobj;
-
-	if ((error = kobject_add(&dev->kobj)))
+	error = kobject_add(&dev->kobj);
+	if (error)
 		goto Error;
 
 	/* notify platform of device entry */
@@ -484,8 +508,11 @@ int device_add(struct device *dev)
 	if (dev->class) {
 		sysfs_create_link(&dev->kobj, &dev->class->subsys.kset.kobj,
 				  "subsystem");
-		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
-				  dev->bus_id);
+		/* If this is not a "fake" compatible device, then create the
+		 * symlink from the class to the device. */
+		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
+			sysfs_create_link(&dev->class->subsys.kset.kobj,
+					  &dev->kobj, dev->bus_id);
 		if (parent) {
 			sysfs_create_link(&dev->kobj, &dev->parent->kobj, "device");
 			class_name = make_class_name(dev->class->name, &dev->kobj);
@@ -623,7 +650,11 @@ void device_del(struct device * dev)
 	}
 	if (dev->class) {
 		sysfs_remove_link(&dev->kobj, "subsystem");
-		sysfs_remove_link(&dev->class->subsys.kset.kobj, dev->bus_id);
+		/* If this is not a "fake" compatible device, remove the
+		 * symlink from the class to the device. */
+		if (dev->kobj.parent != &dev->class->subsys.kset.kobj)
+			sysfs_remove_link(&dev->class->subsys.kset.kobj,
+					  dev->bus_id);
 		class_name = make_class_name(dev->class->name, &dev->kobj);
 		if (parent) {
 			sysfs_remove_link(&dev->kobj, "device");

commit f0ee61a6cecd100301a60d99feb187776533b2a2
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Oct 23 10:40:54 2006 -0700

    Driver Core: Move virtual_device_parent() to core.c
    
    It doesn't need to be global or in device.h
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d4f35d8902a2..dbcd40b987d2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -384,6 +384,23 @@ void device_initialize(struct device *dev)
 	device_init_wakeup(dev, 0);
 }
 
+static int virtual_device_parent(struct device *dev)
+{
+	if (!dev->class)
+		return -ENODEV;
+
+	if (!dev->class->virtual_dir) {
+		static struct kobject *virtual_dir = NULL;
+
+		if (!virtual_dir)
+			virtual_dir = kobject_add_dir(&devices_subsys.kset.kobj, "virtual");
+		dev->class->virtual_dir = kobject_add_dir(virtual_dir, dev->class->name);
+	}
+
+	dev->kobj.parent = dev->class->virtual_dir;
+	return 0;
+}
+
 /**
  *	device_add - add device to device hierarchy.
  *	@dev:	device.

commit 116af378201ef793424cd10508ccf18b06d8a021
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Oct 25 13:44:59 2006 +1000

    Driver core: add notification of bus events
    
    I finally did as you suggested and added the notifier to the struct
    bus_type itself. There are still problems to be expected is something
    attaches to a bus type where the code can hook in different struct
    device sub-classes (which is imho a big bogosity but I won't even try to
    argue that case now) but it will solve nicely a number of issues I've
    had so far.
    
    That also means that clients interested in registering for such
    notifications have to do it before devices are added and after bus types
    are registered. Fortunately, most bus types that matter for the various
    usage scenarios I have in mind are registerd at postcore_initcall time,
    which means I have a really nice spot at arch_initcall time to add my
    notifiers.
    
    There are 4 notifications provided. Device being added (before hooked to
    the bus) and removed (failure of previous case or after being unhooked
    from the bus), along with driver being bound to a device and about to be
    unbound.
    
    The usage I have for these are:
    
     - The 2 first ones are used to maintain a struct device_ext that is
    hooked to struct device.firmware_data. This structure contains for now a
    pointer to the Open Firmware node related to the device (if any), the
    NUMA node ID (for quick access to it) and the DMA operations pointers &
    iommu table instance for DMA to/from this device. For bus types I own
    (like IBM VIO or EBUS), I just maintain that structure directly from the
    bus code when creating the devices. But for bus types managed by generic
    code like PCI or platform (actually, of_platform which is a variation of
    platform linked to Open Firmware device-tree), I need this notifier.
    
     - The other two ones have a completely different usage scenario. I have
    cases where multiple devices and their drivers depend on each other. For
    example, the IBM EMAC network driver needs to attach to a MAL DMA engine
    which is a separate device, and a PHY interface which is also a separate
    device. They are all of_platform_device's (well, about to be with my
    upcoming patches) but there is no say in what precise order the core
    will "probe" them and instanciate the various modules. The solution I
    found for that is to have the drivers for emac to use multithread_probe,
    and wait for a driver to be bound to the target MAL and PHY control
    devices (the device-tree contains reference to the MAL and PHY interface
    nodes, which I can then match to of_platform_devices). Right now, I've
    been polling, but with that notifier, I can more cleanly wait (with a
    timeout of course).
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 002fde46d38d..d4f35d8902a2 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -17,6 +17,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/kdev_t.h>
+#include <linux/notifier.h>
 
 #include <asm/semaphore.h>
 
@@ -428,6 +429,11 @@ int device_add(struct device *dev)
 	if (platform_notify)
 		platform_notify(dev);
 
+	/* notify clients of device entry (new way) */
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+					     BUS_NOTIFY_ADD_DEVICE, dev);
+
 	dev->uevent_attr.attr.name = "uevent";
 	dev->uevent_attr.attr.mode = S_IWUSR;
 	if (dev->driver)
@@ -504,6 +510,9 @@ int device_add(struct device *dev)
  BusError:
 	device_pm_remove(dev);
  PMError:
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+					     BUS_NOTIFY_DEL_DEVICE, dev);
 	device_remove_groups(dev);
  GroupError:
  	device_remove_attrs(dev);
@@ -622,6 +631,9 @@ void device_del(struct device * dev)
 	 */
 	if (platform_notify_remove)
 		platform_notify_remove(dev);
+	if (dev->bus)
+		blocking_notifier_call_chain(&dev->bus->bus_notifier,
+					     BUS_NOTIFY_DEL_DEVICE, dev);
 	bus_remove_device(dev);
 	device_pm_remove(dev);
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);

commit 82189b9807e05ea8d1f69de5bf92eaf244a0eb12
Author: Catalin Marinas <catalin.marinas@gmail.com>
Date:   Sat Nov 25 11:09:30 2006 -0800

    [PATCH] Fix device_attribute memory leak in device_del
    
    dev->devt_attr is allocated in device_add() but it is never freed in
    device_del() in the drivers/base/core.c file (reported by kmemleak).
    
    Signed-off-by: Catalin Marinas <catalin.marinas@gmail.com>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 68ad11af22b4..002fde46d38d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -591,8 +591,10 @@ void device_del(struct device * dev)
 
 	if (parent)
 		klist_del(&dev->knode_parent);
-	if (dev->devt_attr)
+	if (dev->devt_attr) {
 		device_remove_file(dev, dev->devt_attr);
+		kfree(dev->devt_attr);
+	}
 	if (dev->class) {
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		sysfs_remove_link(&dev->class->subsys.kset.kobj, dev->bus_id);

commit f70fa6296c2ec8f541f0a9b406ccc2d9d127d639
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Oct 5 17:03:24 2006 -0400

    Driver core: Don't ignore error returns from probing
    
    This patch (as797) fixes device_add() in the driver core.  It needs to
    pay attention when the driver for a new device reports an error.
    
    At the same time, since bus_remove_device() undoes the effects of both
    bus_add_device() and bus_attach_device(), it needs to check whether
    the bus_attach_device step failed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 41f3dca55cd0..68ad11af22b4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -479,7 +479,8 @@ int device_add(struct device *dev)
 	if ((error = bus_add_device(dev)))
 		goto BusError;
 	kobject_uevent(&dev->kobj, KOBJ_ADD);
-	bus_attach_device(dev);
+	if ((error = bus_attach_device(dev)))
+		goto AttachError;
 	if (parent)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
@@ -498,6 +499,8 @@ int device_add(struct device *dev)
  	kfree(class_name);
 	put_device(dev);
 	return error;
+ AttachError:
+	bus_remove_device(dev);
  BusError:
 	device_pm_remove(dev);
  PMError:

commit 952ab431cd36c7ab573f685af8679c3677cbdc29
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Thu Sep 28 23:56:01 2006 +0200

    Driver core: Don't leak 'old_class_name' in drivers/base/core.c::device_rename()
    
    If kmalloc() fails to allocate space for 'old_symlink_name' in
    drivers/base/core.c::device_rename(), then we'll leak 'old_class_name'.
    
    Spotted by the Coverity checker.
    
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 365f709715ef..41f3dca55cd0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -809,8 +809,10 @@ int device_rename(struct device *dev, char *new_name)
 
 	if (dev->class) {
 		old_symlink_name = kmalloc(BUS_ID_SIZE, GFP_KERNEL);
-		if (!old_symlink_name)
-			return -ENOMEM;
+		if (!old_symlink_name) {
+			error = -ENOMEM;
+			goto out_free_old_class;
+		}
 		strlcpy(old_symlink_name, dev->bus_id, BUS_ID_SIZE);
 	}
 
@@ -834,9 +836,10 @@ int device_rename(struct device *dev, char *new_name)
 	}
 	put_device(dev);
 
-	kfree(old_class_name);
 	kfree(new_class_name);
 	kfree(old_symlink_name);
+ out_free_old_class:
+	kfree(old_class_name);
 
 	return error;
 }

commit a306eea40952e6365301e8a2f7d5ffa9c6a1921b
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Fri Sep 22 11:37:13 2006 +0200

    driver core fixes: device_add() cleanup on error
    
    Check for return code of device_create_file() and correct cleanup in
    the error case in device_add().
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index aee3743bd4a3..365f709715ef 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -433,14 +433,16 @@ int device_add(struct device *dev)
 	if (dev->driver)
 		dev->uevent_attr.attr.owner = dev->driver->owner;
 	dev->uevent_attr.store = store_uevent;
-	device_create_file(dev, &dev->uevent_attr);
+	error = device_create_file(dev, &dev->uevent_attr);
+	if (error)
+		goto attrError;
 
 	if (MAJOR(dev->devt)) {
 		struct device_attribute *attr;
 		attr = kzalloc(sizeof(*attr), GFP_KERNEL);
 		if (!attr) {
 			error = -ENOMEM;
-			goto PMError;
+			goto ueventattrError;
 		}
 		attr->attr.name = "dev";
 		attr->attr.mode = S_IRUGO;
@@ -450,7 +452,7 @@ int device_add(struct device *dev)
 		error = device_create_file(dev, attr);
 		if (error) {
 			kfree(attr);
-			goto attrError;
+			goto ueventattrError;
 		}
 
 		dev->devt_attr = attr;
@@ -507,6 +509,8 @@ int device_add(struct device *dev)
 		device_remove_file(dev, dev->devt_attr);
 		kfree(dev->devt_attr);
 	}
+ ueventattrError:
+	device_remove_file(dev, &dev->uevent_attr);
  attrError:
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);

commit 310a922d4307ed38b37982a6f93b11fdf3b8dcb1
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sat Sep 23 23:35:04 2006 -0600

    Fix dev_printk() is now GPL-only
    
    Make dev_printk usable from non-GPL modules again
    
    dev_printk now calls dev_driver_string.  We want even proprietary modules
    to be calling dev_printk, so the export of dev_driver_string needs to be
    non-GPL-only.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b224bb43ff63..aee3743bd4a3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -44,7 +44,7 @@ const char *dev_driver_string(struct device *dev)
 	return dev->driver ? dev->driver->name :
 			(dev->bus ? dev->bus->name : "");
 }
-EXPORT_SYMBOL_GPL(dev_driver_string);
+EXPORT_SYMBOL(dev_driver_string);
 
 #define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)

commit 370226449ced358e52d198081120826ef52c166b
Author: Brian Walsh <brian@walsh.ws>
Date:   Mon Aug 14 22:43:19 2006 -0700

    drivers/base: Platform notify needs to occur before drivers attach to the device
    
    The platform_notify call for Arm and PPC architectures needs to be called
    before the driver attaches to the device.  The problem only presents itself
    when hotplugging certain devices while the driver is already loaded.
    
    Signed-off-by: Brian Walsh <brian@walsh.ws>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bc9f35c81691..b224bb43ff63 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -424,6 +424,10 @@ int device_add(struct device *dev)
 	if ((error = kobject_add(&dev->kobj)))
 		goto Error;
 
+	/* notify platform of device entry */
+	if (platform_notify)
+		platform_notify(dev);
+
 	dev->uevent_attr.attr.name = "uevent";
 	dev->uevent_attr.attr.mode = S_IWUSR;
 	if (dev->driver)
@@ -488,10 +492,6 @@ int device_add(struct device *dev)
 				class_intf->add_dev(dev, class_intf);
 		up(&dev->class->sem);
 	}
-
-	/* notify platform of device entry */
-	if (platform_notify)
-		platform_notify(dev);
  Done:
  	kfree(class_name);
 	put_device(dev);

commit 2589f1887b0bf9f08ec3d7f3c5705ccb7c628076
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Sep 19 09:39:19 2006 -0700

    Driver core: add ability for devices to create and remove bin files
    
    Makes it easier for devices to create and remove binary attribute files
    so they don't have to call directly into sysfs.  This is needed to help
    with the conversion from struct class_device to struct device.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 1d3d3582fcca..bc9f35c81691 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -319,6 +319,32 @@ void device_remove_file(struct device * dev, struct device_attribute * attr)
 	}
 }
 
+/**
+ * device_create_bin_file - create sysfs binary attribute file for device.
+ * @dev: device.
+ * @attr: device binary attribute descriptor.
+ */
+int device_create_bin_file(struct device *dev, struct bin_attribute *attr)
+{
+	int error = -EINVAL;
+	if (dev)
+		error = sysfs_create_bin_file(&dev->kobj, attr);
+	return error;
+}
+EXPORT_SYMBOL_GPL(device_create_bin_file);
+
+/**
+ * device_remove_bin_file - remove sysfs binary attribute file
+ * @dev: device.
+ * @attr: device binary attribute descriptor.
+ */
+void device_remove_bin_file(struct device *dev, struct bin_attribute *attr)
+{
+	if (dev)
+		sysfs_remove_bin_file(&dev->kobj, attr);
+}
+EXPORT_SYMBOL_GPL(device_remove_bin_file);
+
 static void klist_children_get(struct klist_node *n)
 {
 	struct device *dev = container_of(n, struct device, knode_parent);

commit c47ed219ba81632595e9f02e27318151fec16c9e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 13 15:34:05 2006 +0200

    Class: add support for class interfaces for devices
    
    When moving class_device usage over to device, we need to handle
    class_interfaces properly with devices.  This patch adds that support.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e21a65fc043e..1d3d3582fcca 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -372,6 +372,7 @@ int device_add(struct device *dev)
 {
 	struct device *parent = NULL;
 	char *class_name = NULL;
+	struct class_interface *class_intf;
 	int error = -EINVAL;
 
 	dev = get_device(dev);
@@ -451,9 +452,14 @@ int device_add(struct device *dev)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
 	if (dev->class) {
-		/* tie the class to the device */
 		down(&dev->class->sem);
+		/* tie the class to the device */
 		list_add_tail(&dev->node, &dev->class->devices);
+
+		/* notify any interfaces that the device is here */
+		list_for_each_entry(class_intf, &dev->class->interfaces, node)
+			if (class_intf->add_dev)
+				class_intf->add_dev(dev, class_intf);
 		up(&dev->class->sem);
 	}
 
@@ -548,6 +554,7 @@ void device_del(struct device * dev)
 {
 	struct device * parent = dev->parent;
 	char *class_name = NULL;
+	struct class_interface *class_intf;
 
 	if (parent)
 		klist_del(&dev->knode_parent);
@@ -563,6 +570,11 @@ void device_del(struct device * dev)
 		}
 		kfree(class_name);
 		down(&dev->class->sem);
+		/* notify any interfaces that the device is now gone */
+		list_for_each_entry(class_intf, &dev->class->interfaces, node)
+			if (class_intf->remove_dev)
+				class_intf->remove_dev(dev, class_intf);
+		/* remove the device from the class list */
 		list_del_init(&dev->node);
 		up(&dev->class->sem);
 	}

commit c205ef4880273d2de4ee5388d4e52227ff688cc4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 7 22:19:37 2006 -0700

    Driver core: create devices/virtual/ tree
    
    This change creates a devices/virtual/CLASS_NAME tree for struct devices
    that belong to a class, yet do not have a "real" struct device for a
    parent.  It automatically creates the directories on the fly as needed.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0db47561331e..e21a65fc043e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -378,6 +378,13 @@ int device_add(struct device *dev)
 	if (!dev || !strlen(dev->bus_id))
 		goto Error;
 
+	/* if this is a class device, and has no parent, create one */
+	if ((dev->class) && (dev->parent == NULL)) {
+		error = virtual_device_parent(dev);
+		if (error)
+			goto Error;
+	}
+
 	parent = get_device(dev->parent);
 
 	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);

commit a2de48cace5d0993da6cfa28b276ae724dc3569b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 3 14:31:12 2006 -0700

    Driver core: add device_rename function
    
    The network layer needs this to convert to using struct device instead
    of a struct class_device.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f1228f25efe0..0db47561331e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -736,3 +736,58 @@ void device_destroy(struct class *class, dev_t devt)
 		device_unregister(dev);
 }
 EXPORT_SYMBOL_GPL(device_destroy);
+
+/**
+ * device_rename - renames a device
+ * @dev: the pointer to the struct device to be renamed
+ * @new_name: the new name of the device
+ */
+int device_rename(struct device *dev, char *new_name)
+{
+	char *old_class_name = NULL;
+	char *new_class_name = NULL;
+	char *old_symlink_name = NULL;
+	int error;
+
+	dev = get_device(dev);
+	if (!dev)
+		return -EINVAL;
+
+	pr_debug("DEVICE: renaming '%s' to '%s'\n", dev->bus_id, new_name);
+
+	if ((dev->class) && (dev->parent))
+		old_class_name = make_class_name(dev->class->name, &dev->kobj);
+
+	if (dev->class) {
+		old_symlink_name = kmalloc(BUS_ID_SIZE, GFP_KERNEL);
+		if (!old_symlink_name)
+			return -ENOMEM;
+		strlcpy(old_symlink_name, dev->bus_id, BUS_ID_SIZE);
+	}
+
+	strlcpy(dev->bus_id, new_name, BUS_ID_SIZE);
+
+	error = kobject_rename(&dev->kobj, new_name);
+
+	if (old_class_name) {
+		new_class_name = make_class_name(dev->class->name, &dev->kobj);
+		if (new_class_name) {
+			sysfs_create_link(&dev->parent->kobj, &dev->kobj,
+					  new_class_name);
+			sysfs_remove_link(&dev->parent->kobj, old_class_name);
+		}
+	}
+	if (dev->class) {
+		sysfs_remove_link(&dev->class->subsys.kset.kobj,
+				  old_symlink_name);
+		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
+				  dev->bus_id);
+	}
+	put_device(dev);
+
+	kfree(old_class_name);
+	kfree(new_class_name);
+	kfree(old_symlink_name);
+
+	return error;
+}

commit 2620efef7029bb040430f50f0fc148f2d5e002ad
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 28 16:19:58 2006 -0700

    Driver core: add ability for classes to handle devices properly
    
    This adds two new callbacks to the class structure:
            int     (*dev_uevent)(struct device *dev, char **envp, int num_envp,
                            char *buffer, int buffer_size);
            void    (*dev_release)(struct device *dev);
    
    And one pointer:
            struct device_attribute         * dev_attrs;
    
    which all corrispond with the same thing as the "normal" class devices
    do, yet this is for when a struct device is bound to a class.
    
    Someday soon, struct class_device will go away, and then the other
    fields in this structure can be removed too.  But this is necessary in
    order to get the transition to work properly.
    
    Tested out on a network core patch that converted it to use struct
    device instead of struct class_device.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 5c91d0d81e78..f1228f25efe0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -94,6 +94,8 @@ static void device_release(struct kobject * kobj)
 
 	if (dev->release)
 		dev->release(dev);
+	else if (dev->class && dev->class->dev_release)
+		dev->class->dev_release(dev);
 	else {
 		printk(KERN_ERR "Device '%s' does not have a release() function, "
 			"it is broken and must be fixed.\n",
@@ -183,6 +185,15 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 		}
 	}
 
+	if (dev->class && dev->class->dev_uevent) {
+		/* have the class specific function add its stuff */
+		retval = dev->class->dev_uevent(dev, envp, num_envp, buffer, buffer_size);
+			if (retval) {
+				pr_debug("%s - dev_uevent() returned %d\n",
+					 __FUNCTION__, retval);
+		}
+	}
+
 	return retval;
 }
 
@@ -228,6 +239,43 @@ static void device_remove_groups(struct device *dev)
 	}
 }
 
+static int device_add_attrs(struct device *dev)
+{
+	struct class *class = dev->class;
+	int error = 0;
+	int i;
+
+	if (!class)
+		return 0;
+
+	if (class->dev_attrs) {
+		for (i = 0; attr_name(class->dev_attrs[i]); i++) {
+			error = device_create_file(dev, &class->dev_attrs[i]);
+			if (error)
+				break;
+		}
+	}
+	if (error)
+		while (--i >= 0)
+			device_remove_file(dev, &class->dev_attrs[i]);
+	return error;
+}
+
+static void device_remove_attrs(struct device *dev)
+{
+	struct class *class = dev->class;
+	int i;
+
+	if (!class)
+		return;
+
+	if (class->dev_attrs) {
+		for (i = 0; attr_name(class->dev_attrs[i]); i++)
+			device_remove_file(dev, &class->dev_attrs[i]);
+	}
+}
+
+
 static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
 			char *buf)
 {
@@ -382,6 +430,8 @@ int device_add(struct device *dev)
 		}
 	}
 
+	if ((error = device_add_attrs(dev)))
+		goto AttrsError;
 	if ((error = device_add_groups(dev)))
 		goto GroupError;
 	if ((error = device_pm_add(dev)))
@@ -412,6 +462,8 @@ int device_add(struct device *dev)
  PMError:
 	device_remove_groups(dev);
  GroupError:
+ 	device_remove_attrs(dev);
+ AttrsError:
 	if (dev->devt_attr) {
 		device_remove_file(dev, dev->devt_attr);
 		kfree(dev->devt_attr);
@@ -509,6 +561,7 @@ void device_del(struct device * dev)
 	}
 	device_remove_file(dev, &dev->uevent_attr);
 	device_remove_groups(dev);
+	device_remove_attrs(dev);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...

commit 64bb5d2c116478dba7501d2acf078ed74ba30c1f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 28 16:19:58 2006 -0700

    Driver core: allow devices in classes to have no parent
    
    This fixes an oops when a device is attached to a class, yet has no
    "parent" device.  An example of this would be the "lo" device in the
    network core.
    
    We should create a "virtual" subdirectory under /sys/devices/ for these,
    but no one seems to agree on a proper name for it yet...
    
    Oh, and update my copyright on the driver core.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 641c0c42bb48..5c91d0d81e78 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3,6 +3,8 @@
  *
  * Copyright (c) 2002-3 Patrick Mochel
  * Copyright (c) 2002-3 Open Source Development Labs
+ * Copyright (c) 2006 Greg Kroah-Hartman <gregkh@suse.de>
+ * Copyright (c) 2006 Novell, Inc.
  *
  * This file is released under the GPLv2
  *
@@ -373,10 +375,11 @@ int device_add(struct device *dev)
 				  "subsystem");
 		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
 				  dev->bus_id);
-
-		sysfs_create_link(&dev->kobj, &dev->parent->kobj, "device");
-		class_name = make_class_name(dev->class->name, &dev->kobj);
-		sysfs_create_link(&dev->parent->kobj, &dev->kobj, class_name);
+		if (parent) {
+			sysfs_create_link(&dev->kobj, &dev->parent->kobj, "device");
+			class_name = make_class_name(dev->class->name, &dev->kobj);
+			sysfs_create_link(&dev->parent->kobj, &dev->kobj, class_name);
+		}
 	}
 
 	if ((error = device_add_groups(dev)))
@@ -495,8 +498,10 @@ void device_del(struct device * dev)
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		sysfs_remove_link(&dev->class->subsys.kset.kobj, dev->bus_id);
 		class_name = make_class_name(dev->class->name, &dev->kobj);
-		sysfs_remove_link(&dev->kobj, "device");
-		sysfs_remove_link(&dev->parent->kobj, class_name);
+		if (parent) {
+			sysfs_remove_link(&dev->kobj, "device");
+			sysfs_remove_link(&dev->parent->kobj, class_name);
+		}
 		kfree(class_name);
 		down(&dev->class->sem);
 		list_del_init(&dev->node);
@@ -625,10 +630,6 @@ struct device *device_create(struct class *class, struct device *parent,
 
 	if (class == NULL || IS_ERR(class))
 		goto error;
-	if (parent == NULL) {
-		printk(KERN_WARNING "%s does not work yet for NULL parents\n", __FUNCTION__);
-		goto error;
-	}
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {

commit de0ff00d723fd821d372496e2c084805644aa5e1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 27 00:06:09 2006 -0700

    Driver core: add groups support to struct device
    
    This is needed for the network class devices in order to be able to
    convert over to use struct device.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 5d4b7e04471e..641c0c42bb48 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -197,6 +197,35 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
+static int device_add_groups(struct device *dev)
+{
+	int i;
+	int error = 0;
+
+	if (dev->groups) {
+		for (i = 0; dev->groups[i]; i++) {
+			error = sysfs_create_group(&dev->kobj, dev->groups[i]);
+			if (error) {
+				while (--i >= 0)
+					sysfs_remove_group(&dev->kobj, dev->groups[i]);
+				goto out;
+			}
+		}
+	}
+out:
+	return error;
+}
+
+static void device_remove_groups(struct device *dev)
+{
+	int i;
+	if (dev->groups) {
+		for (i = 0; dev->groups[i]; i++) {
+			sysfs_remove_group(&dev->kobj, dev->groups[i]);
+		}
+	}
+}
+
 static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
 			char *buf)
 {
@@ -350,6 +379,8 @@ int device_add(struct device *dev)
 		sysfs_create_link(&dev->parent->kobj, &dev->kobj, class_name);
 	}
 
+	if ((error = device_add_groups(dev)))
+		goto GroupError;
 	if ((error = device_pm_add(dev)))
 		goto PMError;
 	if ((error = bus_add_device(dev)))
@@ -376,6 +407,8 @@ int device_add(struct device *dev)
  BusError:
 	device_pm_remove(dev);
  PMError:
+	device_remove_groups(dev);
+ GroupError:
 	if (dev->devt_attr) {
 		device_remove_file(dev, dev->devt_attr);
 		kfree(dev->devt_attr);
@@ -470,6 +503,7 @@ void device_del(struct device * dev)
 		up(&dev->class->sem);
 	}
 	device_remove_file(dev, &dev->uevent_attr);
+	device_remove_groups(dev);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...

commit 5cbe5f8a5897470698222ac9924429056e57d84c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Aug 10 01:19:19 2006 -0400

    device_create(): make fmt argument 'const char *'
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 04d089fd4f76..5d4b7e04471e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -583,7 +583,7 @@ static void device_create_release(struct device *dev)
  * been created with a call to class_create().
  */
 struct device *device_create(struct class *class, struct device *parent,
-			     dev_t devt, char *fmt, ...)
+			     dev_t devt, const char *fmt, ...)
 {
 	va_list args;
 	struct device *dev = NULL;

commit d81d9d6b9f7d0af7d4341951d48d296681878f7a
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Sun Aug 13 06:17:09 2006 +0200

    deprecate PHYSDEV* keys
    
    deprecate PHYSDEV* values in the uevent environment
    
    These values are no longer needed and inconsistent with the
    stacking of class devices. The event environment should not
    carry properties of a parent device. The key PHYSDEVDRIVER is
    available as DRIVER, PHYDEVBUS is indentical SUBSYSTEM. Class
    devices should not carry any of these values.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index be6b5bc0677d..04d089fd4f76 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -149,17 +149,21 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 			       "MINOR=%u", MINOR(dev->devt));
 	}
 
-	/* add bus name of physical device */
+	/* add bus name (same as SUBSYSTEM, deprecated) */
 	if (dev->bus)
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,
 			       "PHYSDEVBUS=%s", dev->bus->name);
 
-	/* add driver name of physical device */
-	if (dev->driver)
+	/* add driver name (PHYSDEV* values are deprecated)*/
+	if (dev->driver) {
+		add_uevent_var(envp, num_envp, &i,
+			       buffer, buffer_size, &length,
+			       "DRIVER=%s", dev->driver->name);
 		add_uevent_var(envp, num_envp, &i,
 			       buffer, buffer_size, &length,
 			       "PHYSDEVDRIVER=%s", dev->driver->name);
+	}
 
 	/* terminate, set to next free slot, shrink available space */
 	envp[i] = NULL;

commit 42734dafa43e453a8b6769a5ebd3a01ffc1fd116
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Wed Jul 5 00:53:19 2006 +0200

    [PATCH] Driver core: kernel-doc in drivers/base/core.c corrections
    
    Corrects the kerneldocs for device_create() and device_destroy()
    with an eye on coding style, grammar and readability.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index e61ad4e78c18..be6b5bc0677d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -559,20 +559,20 @@ static void device_create_release(struct device *dev)
 
 /**
  * device_create - creates a device and registers it with sysfs
- * @class: pointer to the struct class that this device should be registered to.
- * @parent: pointer to the parent struct device of this new device, if any.
- * @devt: the dev_t for the char device to be added.
- * @fmt: string for the class device's name
+ * @class: pointer to the struct class that this device should be registered to
+ * @parent: pointer to the parent struct device of this new device, if any
+ * @devt: the dev_t for the char device to be added
+ * @fmt: string for the device's name
+ *
+ * This function can be used by char device classes.  A struct device
+ * will be created in sysfs, registered to the specified class.
  *
- * This function can be used by char device classes.  A struct
- * device will be created in sysfs, registered to the specified
- * class.
  * A "dev" file will be created, showing the dev_t for the device, if
  * the dev_t is not 0,0.
- * If a pointer to a parent struct device is passed in, the newly
- * created struct device will be a child of that device in sysfs.  The
- * pointer to the struct device will be returned from the call.  Any
- * further sysfs files that might be required can be created using this
+ * If a pointer to a parent struct device is passed in, the newly created
+ * struct device will be a child of that device in sysfs.
+ * The pointer to the struct device will be returned from the call.
+ * Any further sysfs files that might be required can be created using this
  * pointer.
  *
  * Note: the struct class passed to this function must have previously
@@ -620,11 +620,11 @@ EXPORT_SYMBOL_GPL(device_create);
 
 /**
  * device_destroy - removes a device that was created with device_create()
- * @class: the pointer to the struct class that this device was registered * with.
- * @devt: the dev_t of the device that was previously registered.
+ * @class: pointer to the struct class that this device was registered with
+ * @devt: the dev_t of the device that was previously registered
  *
- * This call unregisters and cleans up a class device that was created with a
- * call to class_device_create()
+ * This call unregisters and cleans up a device that was created with a
+ * call to device_create().
  */
 void device_destroy(struct class *class, dev_t devt)
 {

commit 7d12e9de5d73a836f040157b27166e68990ea9b4
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Thu Jun 22 15:14:07 2006 -0700

    [PATCH] Driver core: fix driver-core kernel-doc
    
    Warning(/var/linsrc/linux-2617-g4//drivers/base/core.c:574): No description found for parameter 'class'
    Warning(/var/linsrc/linux-2617-g4//drivers/base/core.c:574): No description found for parameter 'devt'
    Warning(/var/linsrc/linux-2617-g4//drivers/base/core.c:626): No description found for parameter 'devt'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b21f864c9ce8..e61ad4e78c18 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -559,9 +559,9 @@ static void device_create_release(struct device *dev)
 
 /**
  * device_create - creates a device and registers it with sysfs
- * @cs: pointer to the struct class that this device should be registered to.
+ * @class: pointer to the struct class that this device should be registered to.
  * @parent: pointer to the parent struct device of this new device, if any.
- * @dev: the dev_t for the char device to be added.
+ * @devt: the dev_t for the char device to be added.
  * @fmt: string for the class device's name
  *
  * This function can be used by char device classes.  A struct
@@ -621,7 +621,7 @@ EXPORT_SYMBOL_GPL(device_create);
 /**
  * device_destroy - removes a device that was created with device_create()
  * @class: the pointer to the struct class that this device was registered * with.
- * @dev: the dev_t of the device that was previously registered.
+ * @devt: the dev_t of the device that was previously registered.
  *
  * This call unregisters and cleans up a class device that was created with a
  * call to class_device_create()

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 27c2176895de..b21f864c9ce8 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -8,7 +8,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/init.h>

commit 5d9fd169c9fbdaecdc430431e59bf94ff40b93d3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 22 17:17:32 2006 -0700

    [PATCH] Driver core: fix locking issues with the devices that are attached to classes
    
    Doh, that was foolish...
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d0f84ff78776..27c2176895de 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -356,6 +356,13 @@ int device_add(struct device *dev)
 	if (parent)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
+	if (dev->class) {
+		/* tie the class to the device */
+		down(&dev->class->sem);
+		list_add_tail(&dev->node, &dev->class->devices);
+		up(&dev->class->sem);
+	}
+
 	/* notify platform of device entry */
 	if (platform_notify)
 		platform_notify(dev);
@@ -455,6 +462,9 @@ void device_del(struct device * dev)
 		sysfs_remove_link(&dev->kobj, "device");
 		sysfs_remove_link(&dev->parent->kobj, class_name);
 		kfree(class_name);
+		down(&dev->class->sem);
+		list_del_init(&dev->node);
+		up(&dev->class->sem);
 	}
 	device_remove_file(dev, &dev->uevent_attr);
 
@@ -601,11 +611,6 @@ struct device *device_create(struct class *class, struct device *parent,
 	if (retval)
 		goto error;
 
-	/* tie the class to the device */
-	down(&class->sem);
-	list_add_tail(&dev->node, &class->devices);
-	up(&class->sem);
-
 	return dev;
 
 error:
@@ -636,9 +641,7 @@ void device_destroy(struct class *class, dev_t devt)
 	}
 	up(&class->sem);
 
-	if (dev) {
-		list_del_init(&dev->node);
+	if (dev)
 		device_unregister(dev);
-	}
 }
 EXPORT_SYMBOL_GPL(device_destroy);

commit 3e95637a48820ff8bedb33e6439def96ccff1de5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 16 17:10:48 2006 -0400

    [PATCH] Driver Core: Make dev_info and friends print the bus name if there is no driver
    
    This patch (as721) makes dev_info and related macros print the device's
    bus name if the device doesn't have a driver, instead of printing just a
    blank.  If the device isn't on a bus either... well, then it does leave
    a blank space.  But it will be easier for someone else to change if they
    want.
    
    Cc: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a979bc3f49a9..d0f84ff78776 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -29,6 +29,22 @@ int (*platform_notify_remove)(struct device * dev) = NULL;
  * sysfs bindings for devices.
  */
 
+/**
+ * dev_driver_string - Return a device's driver name, if at all possible
+ * @dev: struct device to get the name of
+ *
+ * Will return the device's driver's name if it is bound to a device.  If
+ * the device is not bound to a device, it will return the name of the bus
+ * it is attached to.  If it is not attached to a bus either, an empty
+ * string will be returned.
+ */
+const char *dev_driver_string(struct device *dev)
+{
+	return dev->driver ? dev->driver->name :
+			(dev->bus ? dev->bus->name : "");
+}
+EXPORT_SYMBOL_GPL(dev_driver_string);
+
 #define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 

commit e9a7d305faec364ba973d6c22c9b1e802ef79204
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 20 13:59:20 2006 -0700

    [PATCH] Driver core: add proper symlinks for devices
    
    We need to create the "compatible" symlinks that class_devices used to
    create when they were in the class directories so that userspace does
    not know anything changed at all.
    
    Yeah, we have a lot of symlinks now, but we should be able to get rid of
    them in a year or two... (wishful thinking...)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index cc8bb97427d0..a979bc3f49a9 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -273,6 +273,7 @@ void device_initialize(struct device *dev)
 int device_add(struct device *dev)
 {
 	struct device *parent = NULL;
+	char *class_name = NULL;
 	int error = -EINVAL;
 
 	dev = get_device(dev);
@@ -324,6 +325,10 @@ int device_add(struct device *dev)
 				  "subsystem");
 		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
 				  dev->bus_id);
+
+		sysfs_create_link(&dev->kobj, &dev->parent->kobj, "device");
+		class_name = make_class_name(dev->class->name, &dev->kobj);
+		sysfs_create_link(&dev->parent->kobj, &dev->kobj, class_name);
 	}
 
 	if ((error = device_pm_add(dev)))
@@ -339,6 +344,7 @@ int device_add(struct device *dev)
 	if (platform_notify)
 		platform_notify(dev);
  Done:
+ 	kfree(class_name);
 	put_device(dev);
 	return error;
  BusError:
@@ -420,6 +426,7 @@ void put_device(struct device * dev)
 void device_del(struct device * dev)
 {
 	struct device * parent = dev->parent;
+	char *class_name = NULL;
 
 	if (parent)
 		klist_del(&dev->knode_parent);
@@ -428,6 +435,10 @@ void device_del(struct device * dev)
 	if (dev->class) {
 		sysfs_remove_link(&dev->kobj, "subsystem");
 		sysfs_remove_link(&dev->class->subsys.kset.kobj, dev->bus_id);
+		class_name = make_class_name(dev->class->name, &dev->kobj);
+		sysfs_remove_link(&dev->kobj, "device");
+		sysfs_remove_link(&dev->parent->kobj, class_name);
+		kfree(class_name);
 	}
 	device_remove_file(dev, &dev->uevent_attr);
 

commit b9d9c82b4d081feb464f62dfc786c8621d09ecd2
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Thu Jun 15 15:31:56 2006 +0200

    [PATCH] Driver core: add generic "subsystem" link to all devices
    
    Like the SUBSYTEM= key we find in the environment of the uevent, this
    creates a generic "subsystem" link in sysfs for every device. Userspace
    usually doesn't care at all if its a "class" or a "bus" device. This
    provides an unified way to determine the subsytem of a device, regardless
    of the way the driver core has created it.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 252cf403f891..cc8bb97427d0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -319,9 +319,12 @@ int device_add(struct device *dev)
 		dev->devt_attr = attr;
 	}
 
-	if (dev->class)
+	if (dev->class) {
+		sysfs_create_link(&dev->kobj, &dev->class->subsys.kset.kobj,
+				  "subsystem");
 		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
 				  dev->bus_id);
+	}
 
 	if ((error = device_pm_add(dev)))
 		goto PMError;
@@ -422,8 +425,10 @@ void device_del(struct device * dev)
 		klist_del(&dev->knode_parent);
 	if (dev->devt_attr)
 		device_remove_file(dev, dev->devt_attr);
-	if (dev->class)
+	if (dev->class) {
+		sysfs_remove_link(&dev->kobj, "subsystem");
 		sysfs_remove_link(&dev->class->subsys.kset.kobj, dev->bus_id);
+	}
 	device_remove_file(dev, &dev->uevent_attr);
 
 	/* Notify the platform of the removal, in case they

commit 23681e479129854305da1da32f7f1eaf635ef22c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 14 12:14:34 2006 -0700

    [PATCH] Driver core: allow struct device to have a dev_t
    
    This is the first step in moving class_device to being replaced by
    struct device.  It allows struct device to export a dev_t and makes it
    easy to dynamically create and destroy struct device as long as they are
    associated with a specific class.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d5e15a03584e..252cf403f891 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/kdev_t.h>
 
 #include <asm/semaphore.h>
 
@@ -98,6 +99,8 @@ static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 		struct device *dev = to_dev(kobj);
 		if (dev->bus)
 			return 1;
+		if (dev->class)
+			return 1;
 	}
 	return 0;
 }
@@ -106,7 +109,11 @@ static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
 {
 	struct device *dev = to_dev(kobj);
 
-	return dev->bus->name;
+	if (dev->bus)
+		return dev->bus->name;
+	if (dev->class)
+		return dev->class->name;
+	return NULL;
 }
 
 static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
@@ -117,6 +124,16 @@ static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 	int length = 0;
 	int retval = 0;
 
+	/* add the major/minor if present */
+	if (MAJOR(dev->devt)) {
+		add_uevent_var(envp, num_envp, &i,
+			       buffer, buffer_size, &length,
+			       "MAJOR=%u", MAJOR(dev->devt));
+		add_uevent_var(envp, num_envp, &i,
+			       buffer, buffer_size, &length,
+			       "MINOR=%u", MINOR(dev->devt));
+	}
+
 	/* add bus name of physical device */
 	if (dev->bus)
 		add_uevent_var(envp, num_envp, &i,
@@ -161,6 +178,12 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
+static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return print_dev_t(buf, dev->devt);
+}
+
 /*
  *	devices_subsys - structure to be registered with kobject core.
  */
@@ -231,6 +254,7 @@ void device_initialize(struct device *dev)
 	klist_init(&dev->klist_children, klist_children_get,
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
+	INIT_LIST_HEAD(&dev->node);
 	init_MUTEX(&dev->sem);
 	device_init_wakeup(dev, 0);
 }
@@ -274,6 +298,31 @@ int device_add(struct device *dev)
 	dev->uevent_attr.store = store_uevent;
 	device_create_file(dev, &dev->uevent_attr);
 
+	if (MAJOR(dev->devt)) {
+		struct device_attribute *attr;
+		attr = kzalloc(sizeof(*attr), GFP_KERNEL);
+		if (!attr) {
+			error = -ENOMEM;
+			goto PMError;
+		}
+		attr->attr.name = "dev";
+		attr->attr.mode = S_IRUGO;
+		if (dev->driver)
+			attr->attr.owner = dev->driver->owner;
+		attr->show = show_dev;
+		error = device_create_file(dev, attr);
+		if (error) {
+			kfree(attr);
+			goto attrError;
+		}
+
+		dev->devt_attr = attr;
+	}
+
+	if (dev->class)
+		sysfs_create_link(&dev->class->subsys.kset.kobj, &dev->kobj,
+				  dev->bus_id);
+
 	if ((error = device_pm_add(dev)))
 		goto PMError;
 	if ((error = bus_add_device(dev)))
@@ -292,6 +341,11 @@ int device_add(struct device *dev)
  BusError:
 	device_pm_remove(dev);
  PMError:
+	if (dev->devt_attr) {
+		device_remove_file(dev, dev->devt_attr);
+		kfree(dev->devt_attr);
+	}
+ attrError:
 	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
  Error:
@@ -366,6 +420,10 @@ void device_del(struct device * dev)
 
 	if (parent)
 		klist_del(&dev->knode_parent);
+	if (dev->devt_attr)
+		device_remove_file(dev, dev->devt_attr);
+	if (dev->class)
+		sysfs_remove_link(&dev->class->subsys.kset.kobj, dev->bus_id);
 	device_remove_file(dev, &dev->uevent_attr);
 
 	/* Notify the platform of the removal, in case they
@@ -450,3 +508,105 @@ EXPORT_SYMBOL_GPL(put_device);
 
 EXPORT_SYMBOL_GPL(device_create_file);
 EXPORT_SYMBOL_GPL(device_remove_file);
+
+
+static void device_create_release(struct device *dev)
+{
+	pr_debug("%s called for %s\n", __FUNCTION__, dev->bus_id);
+	kfree(dev);
+}
+
+/**
+ * device_create - creates a device and registers it with sysfs
+ * @cs: pointer to the struct class that this device should be registered to.
+ * @parent: pointer to the parent struct device of this new device, if any.
+ * @dev: the dev_t for the char device to be added.
+ * @fmt: string for the class device's name
+ *
+ * This function can be used by char device classes.  A struct
+ * device will be created in sysfs, registered to the specified
+ * class.
+ * A "dev" file will be created, showing the dev_t for the device, if
+ * the dev_t is not 0,0.
+ * If a pointer to a parent struct device is passed in, the newly
+ * created struct device will be a child of that device in sysfs.  The
+ * pointer to the struct device will be returned from the call.  Any
+ * further sysfs files that might be required can be created using this
+ * pointer.
+ *
+ * Note: the struct class passed to this function must have previously
+ * been created with a call to class_create().
+ */
+struct device *device_create(struct class *class, struct device *parent,
+			     dev_t devt, char *fmt, ...)
+{
+	va_list args;
+	struct device *dev = NULL;
+	int retval = -ENODEV;
+
+	if (class == NULL || IS_ERR(class))
+		goto error;
+	if (parent == NULL) {
+		printk(KERN_WARNING "%s does not work yet for NULL parents\n", __FUNCTION__);
+		goto error;
+	}
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	dev->devt = devt;
+	dev->class = class;
+	dev->parent = parent;
+	dev->release = device_create_release;
+
+	va_start(args, fmt);
+	vsnprintf(dev->bus_id, BUS_ID_SIZE, fmt, args);
+	va_end(args);
+	retval = device_register(dev);
+	if (retval)
+		goto error;
+
+	/* tie the class to the device */
+	down(&class->sem);
+	list_add_tail(&dev->node, &class->devices);
+	up(&class->sem);
+
+	return dev;
+
+error:
+	kfree(dev);
+	return ERR_PTR(retval);
+}
+EXPORT_SYMBOL_GPL(device_create);
+
+/**
+ * device_destroy - removes a device that was created with device_create()
+ * @class: the pointer to the struct class that this device was registered * with.
+ * @dev: the dev_t of the device that was previously registered.
+ *
+ * This call unregisters and cleans up a class device that was created with a
+ * call to class_device_create()
+ */
+void device_destroy(struct class *class, dev_t devt)
+{
+	struct device *dev = NULL;
+	struct device *dev_tmp;
+
+	down(&class->sem);
+	list_for_each_entry(dev_tmp, &class->devices, node) {
+		if (dev_tmp->devt == devt) {
+			dev = dev_tmp;
+			break;
+		}
+	}
+	up(&class->sem);
+
+	if (dev) {
+		list_del_init(&dev->node);
+		device_unregister(dev);
+	}
+}
+EXPORT_SYMBOL_GPL(device_destroy);

commit 53877d06d53a412d901bb323f080296c363d8b51
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Tue Apr 4 20:42:26 2006 +0200

    [PATCH] Driver core: bus device event delay
    
    split bus_add_device() and send device uevents after sysfs population
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6b355bd7816d..d5e15a03584e 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -274,11 +274,12 @@ int device_add(struct device *dev)
 	dev->uevent_attr.store = store_uevent;
 	device_create_file(dev, &dev->uevent_attr);
 
-	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	if ((error = device_pm_add(dev)))
 		goto PMError;
 	if ((error = bus_add_device(dev)))
 		goto BusError;
+	kobject_uevent(&dev->kobj, KOBJ_ADD);
+	bus_attach_device(dev);
 	if (parent)
 		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 

commit 0863afb32b77fc89c7110b3d10fb048cb56bb1b5
Author: Martin Waitz <tali@admingilde.org>
Date:   Mon Jan 9 20:53:55 2006 -0800

    [PATCH] DocBook: fix kernel-doc comments
    
    Fix typos in comments to remove kernel-doc warnings.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fd8059920dbf..6b355bd7816d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -161,8 +161,8 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-/**
- *	device_subsys - structure to be registered with kobject core.
+/*
+ *	devices_subsys - structure to be registered with kobject core.
  */
 
 decl_subsys(devices, &ktype_device, &device_uevent_ops);

commit 312c004d36ce6c739512bac83b452f4c20ab1f62
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Wed Nov 16 09:00:00 2005 +0100

    [PATCH] driver core: replace "hotplug" by "uevent"
    
    Leave the overloaded "hotplug" word to susbsystems which are handling
    real devices. The driver core does not "plug" anything, it just exports
    the state to userspace and generates events.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 8615b42b517a..fd8059920dbf 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -90,7 +90,7 @@ static struct kobj_type ktype_device = {
 };
 
 
-static int dev_hotplug_filter(struct kset *kset, struct kobject *kobj)
+static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
 {
 	struct kobj_type *ktype = get_ktype(kobj);
 
@@ -102,14 +102,14 @@ static int dev_hotplug_filter(struct kset *kset, struct kobject *kobj)
 	return 0;
 }
 
-static const char *dev_hotplug_name(struct kset *kset, struct kobject *kobj)
+static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
 {
 	struct device *dev = to_dev(kobj);
 
 	return dev->bus->name;
 }
 
-static int dev_hotplug(struct kset *kset, struct kobject *kobj, char **envp,
+static int dev_uevent(struct kset *kset, struct kobject *kobj, char **envp,
 			int num_envp, char *buffer, int buffer_size)
 {
 	struct device *dev = to_dev(kobj);
@@ -119,15 +119,15 @@ static int dev_hotplug(struct kset *kset, struct kobject *kobj, char **envp,
 
 	/* add bus name of physical device */
 	if (dev->bus)
-		add_hotplug_env_var(envp, num_envp, &i,
-				    buffer, buffer_size, &length,
-				    "PHYSDEVBUS=%s", dev->bus->name);
+		add_uevent_var(envp, num_envp, &i,
+			       buffer, buffer_size, &length,
+			       "PHYSDEVBUS=%s", dev->bus->name);
 
 	/* add driver name of physical device */
 	if (dev->driver)
-		add_hotplug_env_var(envp, num_envp, &i,
-				    buffer, buffer_size, &length,
-				    "PHYSDEVDRIVER=%s", dev->driver->name);
+		add_uevent_var(envp, num_envp, &i,
+			       buffer, buffer_size, &length,
+			       "PHYSDEVDRIVER=%s", dev->driver->name);
 
 	/* terminate, set to next free slot, shrink available space */
 	envp[i] = NULL;
@@ -136,11 +136,11 @@ static int dev_hotplug(struct kset *kset, struct kobject *kobj, char **envp,
 	buffer = &buffer[length];
 	buffer_size -= length;
 
-	if (dev->bus && dev->bus->hotplug) {
+	if (dev->bus && dev->bus->uevent) {
 		/* have the bus specific function add its stuff */
-		retval = dev->bus->hotplug (dev, envp, num_envp, buffer, buffer_size);
+		retval = dev->bus->uevent(dev, envp, num_envp, buffer, buffer_size);
 			if (retval) {
-			pr_debug ("%s - hotplug() returned %d\n",
+			pr_debug ("%s - uevent() returned %d\n",
 				  __FUNCTION__, retval);
 		}
 	}
@@ -148,16 +148,16 @@ static int dev_hotplug(struct kset *kset, struct kobject *kobj, char **envp,
 	return retval;
 }
 
-static struct kset_hotplug_ops device_hotplug_ops = {
-	.filter =	dev_hotplug_filter,
-	.name =		dev_hotplug_name,
-	.hotplug =	dev_hotplug,
+static struct kset_uevent_ops device_uevent_ops = {
+	.filter =	dev_uevent_filter,
+	.name =		dev_uevent_name,
+	.uevent =	dev_uevent,
 };
 
 static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
-	kobject_hotplug(&dev->kobj, KOBJ_ADD);
+	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	return count;
 }
 
@@ -165,7 +165,7 @@ static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
  *	device_subsys - structure to be registered with kobject core.
  */
 
-decl_subsys(devices, &ktype_device, &device_hotplug_ops);
+decl_subsys(devices, &ktype_device, &device_uevent_ops);
 
 
 /**
@@ -274,7 +274,7 @@ int device_add(struct device *dev)
 	dev->uevent_attr.store = store_uevent;
 	device_create_file(dev, &dev->uevent_attr);
 
-	kobject_hotplug(&dev->kobj, KOBJ_ADD);
+	kobject_uevent(&dev->kobj, KOBJ_ADD);
 	if ((error = device_pm_add(dev)))
 		goto PMError;
 	if ((error = bus_add_device(dev)))
@@ -291,7 +291,7 @@ int device_add(struct device *dev)
  BusError:
 	device_pm_remove(dev);
  PMError:
-	kobject_hotplug(&dev->kobj, KOBJ_REMOVE);
+	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
  Error:
 	if (parent)
@@ -374,7 +374,7 @@ void device_del(struct device * dev)
 		platform_notify_remove(dev);
 	bus_remove_device(dev);
 	device_pm_remove(dev);
-	kobject_hotplug(&dev->kobj, KOBJ_REMOVE);
+	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
 	if (parent)
 		put_device(parent);

commit c41455fbac06712992da491844449775cf9a8c80
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Oct 23 11:59:14 2005 -0700

    [PATCH] kernel-doc: drivers/base fixes
    
    driver/base: add missing function parameters; eliminate all warnings.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index ac4b5fdd95f5..8615b42b517a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -407,11 +407,11 @@ static struct device * next_device(struct klist_iter * i)
 
 /**
  *	device_for_each_child - device child iterator.
- *	@dev:	parent struct device.
+ *	@parent: parent struct device.
  *	@data:	data for the callback.
  *	@fn:	function to be called for each device.
  *
- *	Iterate over @dev's child devices, and call @fn for each,
+ *	Iterate over @parent's child devices, and call @fn for each,
  *	passing it @data.
  *
  *	We check the return of @fn each time. If it returns anything

commit a7fd67062efc5b0fc9a61368c607fa92d1d57f9e
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Sat Oct 1 14:49:43 2005 +0200

    [PATCH] add sysfs attr to re-emit device hotplug event
    
    A "coldplug + udevstart" can be simple like this:
      for i in /sys/block/*/*/uevent; do echo 1 > $i; done
      for i in /sys/class/*/*/uevent; do echo 1 > $i; done
      for i in /sys/bus/*/devices/*/uevent; do echo 1 > $i; done
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 31109193e2c4..ac4b5fdd95f5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -154,6 +154,13 @@ static struct kset_hotplug_ops device_hotplug_ops = {
 	.hotplug =	dev_hotplug,
 };
 
+static ssize_t store_uevent(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	kobject_hotplug(&dev->kobj, KOBJ_ADD);
+	return count;
+}
+
 /**
  *	device_subsys - structure to be registered with kobject core.
  */
@@ -259,6 +266,14 @@ int device_add(struct device *dev)
 
 	if ((error = kobject_add(&dev->kobj)))
 		goto Error;
+
+	dev->uevent_attr.attr.name = "uevent";
+	dev->uevent_attr.attr.mode = S_IWUSR;
+	if (dev->driver)
+		dev->uevent_attr.attr.owner = dev->driver->owner;
+	dev->uevent_attr.store = store_uevent;
+	device_create_file(dev, &dev->uevent_attr);
+
 	kobject_hotplug(&dev->kobj, KOBJ_ADD);
 	if ((error = device_pm_add(dev)))
 		goto PMError;
@@ -350,6 +365,7 @@ void device_del(struct device * dev)
 
 	if (parent)
 		klist_del(&dev->knode_parent);
+	device_remove_file(dev, &dev->uevent_attr);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...

commit 0ac85241ebc7bf6b86ab498960cc121d53ef69ae
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Sep 12 19:39:34 2005 -0700

    [PATCH] driver model wakeup flags
    
    This is a refresh of an earlier patch to add "wakeup" support to the
    PM core model.  This provides per-device bus-neutral control of the
    use of wakeup events.
    
      * "struct device_pm_info" has two bits that are initialized as
        part of setting up the enclosing struct device:
          - "can_wakeup", reflecting hardware capabilities
          - "may_wakeup", the policy setting (when CONFIG_PM)
    
      * There's a writeable sysfs "wakeup" file, with one of two values:
          - "enabled", when the policy is to allow wakeup
          - "disabled", when the policy is not to allow it
          - "" if the device can't currently issue wakeups
    
    By default, wakeup is enabled on all devices that support it.  If its
    driver doesn't support it ... treat it as a bug.  :)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 6ab73f5c799a..31109193e2c4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -225,6 +225,7 @@ void device_initialize(struct device *dev)
 		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
+	device_init_wakeup(dev, 0);
 }
 
 /**

commit 34bb61f9ddabd7a7f909cbfb05592eb775f6662a
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Sep 6 16:56:51 2005 -0700

    [PATCH] fix klist semantics for lists which have elements removed on traversal
    
    The problem is that klists claim to provide semantics for safe traversal of
    lists which are being modified.  The failure case is when traversal of a
    list causes element removal (a fairly common case).  The issue is that
    although the list node is refcounted, if it is embedded in an object (which
    is universally the case), then the object will be freed regardless of the
    klist refcount leading to slab corruption because the klist iterator refers
    to the prior element to get the next.
    
    The solution is to make the klist take and release references to the
    embedding object meaning that the embedding object won't be released until
    the list relinquishes the reference to it.
    
    (akpm: fast-track this because it's needed for the 2.6.13 scsi merge)
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index c8a33df00761..6ab73f5c799a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -191,6 +191,20 @@ void device_remove_file(struct device * dev, struct device_attribute * attr)
 	}
 }
 
+static void klist_children_get(struct klist_node *n)
+{
+	struct device *dev = container_of(n, struct device, knode_parent);
+
+	get_device(dev);
+}
+
+static void klist_children_put(struct klist_node *n)
+{
+	struct device *dev = container_of(n, struct device, knode_parent);
+
+	put_device(dev);
+}
+
 
 /**
  *	device_initialize - init device structure.
@@ -207,7 +221,8 @@ void device_initialize(struct device *dev)
 {
 	kobj_set_kset_s(dev, devices_subsys);
 	kobject_init(&dev->kobj);
-	klist_init(&dev->klist_children);
+	klist_init(&dev->klist_children, klist_children_get,
+		   klist_children_put);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
 }

commit d856f1e337782326c638c70c0b4df2b909350dec
Author: James Bottomley <James.Bottomley@SteelEye.com>
Date:   Fri Aug 19 09:14:01 2005 -0400

    [PATCH] klist: fix klist to have the same klist_add semantics as list_head
    
    at the moment, the list_head semantics are
    
    list_add(node, head)
    
    whereas current klist semantics are
    
    klist_add(head, node)
    
    This is bound to cause confusion, and since klist is the newcomer, it
    should follow the list_head semantics.
    
    I also added missing include guards to klist.h
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index efe03a024a5b..c8a33df00761 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -249,7 +249,7 @@ int device_add(struct device *dev)
 	if ((error = bus_add_device(dev)))
 		goto BusError;
 	if (parent)
-		klist_add_tail(&parent->klist_children, &dev->knode_parent);
+		klist_add_tail(&dev->knode_parent, &parent->klist_children);
 
 	/* notify platform of device entry */
 	if (platform_notify)

commit d62c0f9fd2d3943a3eca85b490d86e1605000ccb
Author: Patrick Mochel <mochel@digitalimplant.org>
Date:   Fri Jun 24 08:39:33 2005 -0700

    [PATCH] Driver core: Use klist_del() instead of klist_remove().
    
    Use klist_del() instead of klist_remove() when unregistering devices.
    This will prevent a deadlock when executing a recursive unregister using
    device_for_each_child().
    
    Signed-off-by Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 86d79755fbfb..efe03a024a5b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -333,7 +333,7 @@ void device_del(struct device * dev)
 	struct device * parent = dev->parent;
 
 	if (parent)
-		klist_remove(&dev->knode_parent);
+		klist_del(&dev->knode_parent);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...

commit 54b6f35c99974e99e64c05c2895718355123c55f
Author: Yani Ioannou <yani.ioannou@gmail.com>
Date:   Tue May 17 06:39:34 2005 -0400

    [PATCH] Driver core: change device_attribute callbacks
    
    This patch adds the device_attribute paramerter to the
    device_attribute store and show sysfs callback functions, and passes a
    reference to the attribute when the callbacks are called.
    
    Signed-off-by: Yani Ioannou <yani.ioannou@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 1d8c7790b55a..86d79755fbfb 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -39,7 +39,7 @@ dev_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
 	ssize_t ret = -EIO;
 
 	if (dev_attr->show)
-		ret = dev_attr->show(dev, buf);
+		ret = dev_attr->show(dev, dev_attr, buf);
 	return ret;
 }
 
@@ -52,7 +52,7 @@ dev_attr_store(struct kobject * kobj, struct attribute * attr,
 	ssize_t ret = -EIO;
 
 	if (dev_attr->store)
-		ret = dev_attr->store(dev, buf, count);
+		ret = dev_attr->store(dev, dev_attr, buf, count);
 	return ret;
 }
 

commit 36239577cfb6b9a7c111209536b54200b0252ebf
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 19:08:30 2005 -0800

    [PATCH] Use a klist for device child lists.
    
    - Use klist iterator in device_for_each_child(), making it safe to use for
      removing devices.
    - Remove unused list_to_dev() function.
    - Kills all usage of devices_subsys.rwsem.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bfa4268289ea..1d8c7790b55a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -207,8 +207,7 @@ void device_initialize(struct device *dev)
 {
 	kobj_set_kset_s(dev, devices_subsys);
 	kobject_init(&dev->kobj);
-	INIT_LIST_HEAD(&dev->node);
-	INIT_LIST_HEAD(&dev->children);
+	klist_init(&dev->klist_children);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
 }
@@ -249,10 +248,8 @@ int device_add(struct device *dev)
 		goto PMError;
 	if ((error = bus_add_device(dev)))
 		goto BusError;
-	down_write(&devices_subsys.rwsem);
 	if (parent)
-		list_add_tail(&dev->node, &parent->children);
-	up_write(&devices_subsys.rwsem);
+		klist_add_tail(&parent->klist_children, &dev->knode_parent);
 
 	/* notify platform of device entry */
 	if (platform_notify)
@@ -335,10 +332,8 @@ void device_del(struct device * dev)
 {
 	struct device * parent = dev->parent;
 
-	down_write(&devices_subsys.rwsem);
 	if (parent)
-		list_del_init(&dev->node);
-	up_write(&devices_subsys.rwsem);
+		klist_remove(&dev->knode_parent);
 
 	/* Notify the platform of the removal, in case they
 	 * need to do anything...
@@ -372,6 +367,12 @@ void device_unregister(struct device * dev)
 }
 
 
+static struct device * next_device(struct klist_iter * i)
+{
+	struct klist_node * n = klist_next(i);
+	return n ? container_of(n, struct device, knode_parent) : NULL;
+}
+
 /**
  *	device_for_each_child - device child iterator.
  *	@dev:	parent struct device.
@@ -384,18 +385,17 @@ void device_unregister(struct device * dev)
  *	We check the return of @fn each time. If it returns anything
  *	other than 0, we break out and return that value.
  */
-int device_for_each_child(struct device * dev, void * data,
+int device_for_each_child(struct device * parent, void * data,
 		     int (*fn)(struct device *, void *))
 {
+	struct klist_iter i;
 	struct device * child;
 	int error = 0;
 
-	down_read(&devices_subsys.rwsem);
-	list_for_each_entry(child, &dev->children, node) {
-		if((error = fn(child, data)))
-			break;
-	}
-	up_read(&devices_subsys.rwsem);
+	klist_iter_init(&parent->klist_children, &i);
+	while ((child = next_device(&i)) && !error)
+		error = fn(child, data);
+	klist_iter_exit(&i);
 	return error;
 }
 

commit 63c4f204ffc8219696bda88eb20c9873d007a2fc
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 13:08:05 2005 -0800

    [PATCH] Remove struct device::driver_list.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f258a21ed78a..bfa4268289ea 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -209,7 +209,6 @@ void device_initialize(struct device *dev)
 	kobject_init(&dev->kobj);
 	INIT_LIST_HEAD(&dev->node);
 	INIT_LIST_HEAD(&dev->children);
-	INIT_LIST_HEAD(&dev->driver_list);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
 }

commit 7dc35cdf69149a7f2b5216ada9bafe359746ac1c
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 13:03:35 2005 -0800

    [PATCH] Remove struct device::bus_list.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 0eb1d424bd1d..f258a21ed78a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -209,7 +209,6 @@ void device_initialize(struct device *dev)
 	kobject_init(&dev->kobj);
 	INIT_LIST_HEAD(&dev->node);
 	INIT_LIST_HEAD(&dev->children);
-	INIT_LIST_HEAD(&dev->bus_list);
 	INIT_LIST_HEAD(&dev->driver_list);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);

commit cb85b6f1cc811ecb9ed4b950206d8941ba710e68
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 10:48:35 2005 -0800

    [PATCH] Remove the unused device_find().
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index bc5bec61a01a..0eb1d424bd1d 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -401,24 +401,6 @@ int device_for_each_child(struct device * dev, void * data,
 	return error;
 }
 
-/**
- *	device_find - locate device on a bus by name.
- *	@name:	name of the device.
- *	@bus:	bus to scan for the device.
- *
- *	Call kset_find_obj() to iterate over list of devices on
- *	a bus to find device by name. Return device if found.
- *
- *	Note that kset_find_obj increments device's reference count.
- */
-struct device *device_find(const char *name, struct bus_type *bus)
-{
-	struct kobject *k = kset_find_obj(&bus->devices, name);
-	if (k)
-		return to_dev(k);
-	return NULL;
-}
-
 int __init devices_init(void)
 {
 	return subsystem_register(&devices_subsys);
@@ -434,7 +416,6 @@ EXPORT_SYMBOL_GPL(device_del);
 EXPORT_SYMBOL_GPL(device_unregister);
 EXPORT_SYMBOL_GPL(get_device);
 EXPORT_SYMBOL_GPL(put_device);
-EXPORT_SYMBOL_GPL(device_find);
 
 EXPORT_SYMBOL_GPL(device_create_file);
 EXPORT_SYMBOL_GPL(device_remove_file);

commit 94e7b1c5ff2055571703e38b059afffe17658432
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 12:25:36 2005 -0800

    [PATCH] Add a klist to struct device_driver for the devices bound to it.
    
    - Use it in driver_for_each_device() instead of the regular list_head and stop using
      the bus's rwsem for protection.
    - Use driver_for_each_device() in driver_detach() so we don't deadlock on the
      bus's rwsem.
    - Remove ->devices.
    - Move klist access and sysfs link access out from under device's semaphore, since
      they're synchronized through other means.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 93440824b800..bc5bec61a01a 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -209,8 +209,8 @@ void device_initialize(struct device *dev)
 	kobject_init(&dev->kobj);
 	INIT_LIST_HEAD(&dev->node);
 	INIT_LIST_HEAD(&dev->children);
-	INIT_LIST_HEAD(&dev->driver_list);
 	INIT_LIST_HEAD(&dev->bus_list);
+	INIT_LIST_HEAD(&dev->driver_list);
 	INIT_LIST_HEAD(&dev->dma_pools);
 	init_MUTEX(&dev->sem);
 }

commit af70316af182f4716cc5eec7e0d27fc731d164bd
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 10:41:04 2005 -0800

    [PATCH] Add a semaphore to struct device to synchronize calls to its driver.
    
    This adds a per-device semaphore that is taken before every call from the core to a
    driver method. This prevents e.g. simultaneous calls to the ->suspend() or ->resume()
    and ->probe() or ->release(), potentially saving a whole lot of headaches.
    
    It also moves us a step closer to removing the bus rwsem, since it protects the fields
    in struct device that are modified by the core.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a293a788abd4..93440824b800 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -212,6 +212,7 @@ void device_initialize(struct device *dev)
 	INIT_LIST_HEAD(&dev->driver_list);
 	INIT_LIST_HEAD(&dev->bus_list);
 	INIT_LIST_HEAD(&dev->dma_pools);
+	init_MUTEX(&dev->sem);
 }
 
 /**

commit 4a0c20bf8c0fe2116f8fd7d3da6122bf8a01f026
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Fri Apr 29 01:23:47 2005 -0500

    [PATCH] sysfs: (driver/base) if show/store is missing return -EIO
    
    sysfs: fix drivers/base so if an attribute doesn't implement
           show or store method read/write will return -EIO
           instead of 0.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 32f3f09a42e0..a293a788abd4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -36,7 +36,7 @@ dev_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
 {
 	struct device_attribute * dev_attr = to_dev_attr(attr);
 	struct device * dev = to_dev(kobj);
-	ssize_t ret = 0;
+	ssize_t ret = -EIO;
 
 	if (dev_attr->show)
 		ret = dev_attr->show(dev, buf);
@@ -49,7 +49,7 @@ dev_attr_store(struct kobject * kobj, struct attribute * attr,
 {
 	struct device_attribute * dev_attr = to_dev_attr(attr);
 	struct device * dev = to_dev(kobj);
-	ssize_t ret = 0;
+	ssize_t ret = -EIO;
 
 	if (dev_attr->store)
 		ret = dev_attr->store(dev, buf, count);

commit 419cab3fc69588ebe35b845cc3a584ae172463de
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Tue Apr 26 02:32:54 2005 -0500

    [PATCH] kset_hotplug_ops->name shoudl return const char *
    
    kobject: change name() method in kset_hotplug_ops return const char *
             since users shoudl not try to modify returned data.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index fbc223486f81..32f3f09a42e0 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -102,7 +102,7 @@ static int dev_hotplug_filter(struct kset *kset, struct kobject *kobj)
 	return 0;
 }
 
-static char *dev_hotplug_name(struct kset *kset, struct kobject *kobj)
+static const char *dev_hotplug_name(struct kset *kset, struct kobject *kobj)
 {
 	struct device *dev = to_dev(kobj);
 

commit 187a1a94d629621d1471b42308e63573b1150773
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon May 23 15:50:26 2005 -0700

    [PATCH] driver core: restore event order for device_add()
    
    As a result of the split of the kobject-registration and the
    corresponding hotplug event, the order of events for device_add() has
    changed. This restores the old order, cause it confused some userspace
    applications.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d21eb7744496..fbc223486f81 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -245,6 +245,7 @@ int device_add(struct device *dev)
 
 	if ((error = kobject_add(&dev->kobj)))
 		goto Error;
+	kobject_hotplug(&dev->kobj, KOBJ_ADD);
 	if ((error = device_pm_add(dev)))
 		goto PMError;
 	if ((error = bus_add_device(dev)))
@@ -257,14 +258,13 @@ int device_add(struct device *dev)
 	/* notify platform of device entry */
 	if (platform_notify)
 		platform_notify(dev);
-
-	kobject_hotplug(&dev->kobj, KOBJ_ADD);
  Done:
 	put_device(dev);
 	return error;
  BusError:
 	device_pm_remove(dev);
  PMError:
+	kobject_hotplug(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
  Error:
 	if (parent)

commit 0b405a0f7e4d4d18fd1fe46ddf5ff465443036ab
Author: David Brownell <david-b@pacbell.net>
Date:   Thu May 12 12:06:27 2005 -0700

    [PATCH] Driver Core: remove driver model detach_state
    
    The driver model has a "detach_state" mechanism that:
    
     - Has never been used by any in-kernel drive;
     - Is superfluous, since driver remove() methods can do the same thing;
     - Became buggy when the suspend() parameter changed semantics and type;
     - Could self-deadlock when called from certain suspend contexts;
     - Is effectively wasted documentation, object code, and headspace.
    
    This removes that "detach_state" mechanism; net code shrink, as well
    as a per-device saving in the driver model and sysfs.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 268a9c8d168b..d21eb7744496 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -31,8 +31,6 @@ int (*platform_notify_remove)(struct device * dev) = NULL;
 #define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 
-extern struct attribute * dev_default_attrs[];
-
 static ssize_t
 dev_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
 {
@@ -89,7 +87,6 @@ static void device_release(struct kobject * kobj)
 static struct kobj_type ktype_device = {
 	.release	= device_release,
 	.sysfs_ops	= &dev_sysfs_ops,
-	.default_attrs	= dev_default_attrs,
 };
 
 

commit 177a4324944478f2799ce4ede2797cb0f602f274
Author: Alexander Nyberg <alexn@dsv.su.se>
Date:   Sat Feb 26 13:38:51 2005 +0100

    [PATCH] Hotplug: Make dev->bus checking consistent
    
    Earlier in the same function dev->bus is checked before dereferenced,
    make consistent although I honestly don't know if dev->bus could
    ever be NULL
    
    Found by the Coverity tool
    
    Signed-off-by: Alexander Nyberg <alexn@dsv.su.se>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a7cedd8cefe5..268a9c8d168b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -139,7 +139,7 @@ static int dev_hotplug(struct kset *kset, struct kobject *kobj, char **envp,
 	buffer = &buffer[length];
 	buffer_size -= length;
 
-	if (dev->bus->hotplug) {
+	if (dev->bus && dev->bus->hotplug) {
 		/* have the bus specific function add its stuff */
 		retval = dev->bus->hotplug (dev, envp, num_envp, buffer, buffer_size);
 			if (retval) {

commit e57cd73e2e844a3da25cc6b420674c81bbe1b387
Author: kay.sievers@vrfy.org <kay.sievers@vrfy.org>
Date:   Mon Apr 18 21:57:36 2005 -0700

    [PATCH] kobject/hotplug split - devices core
    
    kobject_add() and kobject_del() don't emit hotplug events anymore. Do it
    ourselves if we are finished populating the device directory.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4e6cce8e6d35..a7cedd8cefe5 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -260,6 +260,8 @@ int device_add(struct device *dev)
 	/* notify platform of device entry */
 	if (platform_notify)
 		platform_notify(dev);
+
+	kobject_hotplug(&dev->kobj, KOBJ_ADD);
  Done:
 	put_device(dev);
 	return error;
@@ -349,6 +351,7 @@ void device_del(struct device * dev)
 		platform_notify_remove(dev);
 	bus_remove_device(dev);
 	device_pm_remove(dev);
+	kobject_hotplug(&dev->kobj, KOBJ_REMOVE);
 	kobject_del(&dev->kobj);
 	if (parent)
 		put_device(parent);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/base/core.c b/drivers/base/core.c
new file mode 100644
index 000000000000..4e6cce8e6d35
--- /dev/null
+++ b/drivers/base/core.c
@@ -0,0 +1,439 @@
+/*
+ * drivers/base/core.c - core driver model code (device registration, etc)
+ *
+ * Copyright (c) 2002-3 Patrick Mochel
+ * Copyright (c) 2002-3 Open Source Development Labs
+ *
+ * This file is released under the GPLv2
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include <asm/semaphore.h>
+
+#include "base.h"
+#include "power/power.h"
+
+int (*platform_notify)(struct device * dev) = NULL;
+int (*platform_notify_remove)(struct device * dev) = NULL;
+
+/*
+ * sysfs bindings for devices.
+ */
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+#define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
+
+extern struct attribute * dev_default_attrs[];
+
+static ssize_t
+dev_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct device_attribute * dev_attr = to_dev_attr(attr);
+	struct device * dev = to_dev(kobj);
+	ssize_t ret = 0;
+
+	if (dev_attr->show)
+		ret = dev_attr->show(dev, buf);
+	return ret;
+}
+
+static ssize_t
+dev_attr_store(struct kobject * kobj, struct attribute * attr,
+	       const char * buf, size_t count)
+{
+	struct device_attribute * dev_attr = to_dev_attr(attr);
+	struct device * dev = to_dev(kobj);
+	ssize_t ret = 0;
+
+	if (dev_attr->store)
+		ret = dev_attr->store(dev, buf, count);
+	return ret;
+}
+
+static struct sysfs_ops dev_sysfs_ops = {
+	.show	= dev_attr_show,
+	.store	= dev_attr_store,
+};
+
+
+/**
+ *	device_release - free device structure.
+ *	@kobj:	device's kobject.
+ *
+ *	This is called once the reference count for the object
+ *	reaches 0. We forward the call to the device's release
+ *	method, which should handle actually freeing the structure.
+ */
+static void device_release(struct kobject * kobj)
+{
+	struct device * dev = to_dev(kobj);
+
+	if (dev->release)
+		dev->release(dev);
+	else {
+		printk(KERN_ERR "Device '%s' does not have a release() function, "
+			"it is broken and must be fixed.\n",
+			dev->bus_id);
+		WARN_ON(1);
+	}
+}
+
+static struct kobj_type ktype_device = {
+	.release	= device_release,
+	.sysfs_ops	= &dev_sysfs_ops,
+	.default_attrs	= dev_default_attrs,
+};
+
+
+static int dev_hotplug_filter(struct kset *kset, struct kobject *kobj)
+{
+	struct kobj_type *ktype = get_ktype(kobj);
+
+	if (ktype == &ktype_device) {
+		struct device *dev = to_dev(kobj);
+		if (dev->bus)
+			return 1;
+	}
+	return 0;
+}
+
+static char *dev_hotplug_name(struct kset *kset, struct kobject *kobj)
+{
+	struct device *dev = to_dev(kobj);
+
+	return dev->bus->name;
+}
+
+static int dev_hotplug(struct kset *kset, struct kobject *kobj, char **envp,
+			int num_envp, char *buffer, int buffer_size)
+{
+	struct device *dev = to_dev(kobj);
+	int i = 0;
+	int length = 0;
+	int retval = 0;
+
+	/* add bus name of physical device */
+	if (dev->bus)
+		add_hotplug_env_var(envp, num_envp, &i,
+				    buffer, buffer_size, &length,
+				    "PHYSDEVBUS=%s", dev->bus->name);
+
+	/* add driver name of physical device */
+	if (dev->driver)
+		add_hotplug_env_var(envp, num_envp, &i,
+				    buffer, buffer_size, &length,
+				    "PHYSDEVDRIVER=%s", dev->driver->name);
+
+	/* terminate, set to next free slot, shrink available space */
+	envp[i] = NULL;
+	envp = &envp[i];
+	num_envp -= i;
+	buffer = &buffer[length];
+	buffer_size -= length;
+
+	if (dev->bus->hotplug) {
+		/* have the bus specific function add its stuff */
+		retval = dev->bus->hotplug (dev, envp, num_envp, buffer, buffer_size);
+			if (retval) {
+			pr_debug ("%s - hotplug() returned %d\n",
+				  __FUNCTION__, retval);
+		}
+	}
+
+	return retval;
+}
+
+static struct kset_hotplug_ops device_hotplug_ops = {
+	.filter =	dev_hotplug_filter,
+	.name =		dev_hotplug_name,
+	.hotplug =	dev_hotplug,
+};
+
+/**
+ *	device_subsys - structure to be registered with kobject core.
+ */
+
+decl_subsys(devices, &ktype_device, &device_hotplug_ops);
+
+
+/**
+ *	device_create_file - create sysfs attribute file for device.
+ *	@dev:	device.
+ *	@attr:	device attribute descriptor.
+ */
+
+int device_create_file(struct device * dev, struct device_attribute * attr)
+{
+	int error = 0;
+	if (get_device(dev)) {
+		error = sysfs_create_file(&dev->kobj, &attr->attr);
+		put_device(dev);
+	}
+	return error;
+}
+
+/**
+ *	device_remove_file - remove sysfs attribute file.
+ *	@dev:	device.
+ *	@attr:	device attribute descriptor.
+ */
+
+void device_remove_file(struct device * dev, struct device_attribute * attr)
+{
+	if (get_device(dev)) {
+		sysfs_remove_file(&dev->kobj, &attr->attr);
+		put_device(dev);
+	}
+}
+
+
+/**
+ *	device_initialize - init device structure.
+ *	@dev:	device.
+ *
+ *	This prepares the device for use by other layers,
+ *	including adding it to the device hierarchy.
+ *	It is the first half of device_register(), if called by
+ *	that, though it can also be called separately, so one
+ *	may use @dev's fields (e.g. the refcount).
+ */
+
+void device_initialize(struct device *dev)
+{
+	kobj_set_kset_s(dev, devices_subsys);
+	kobject_init(&dev->kobj);
+	INIT_LIST_HEAD(&dev->node);
+	INIT_LIST_HEAD(&dev->children);
+	INIT_LIST_HEAD(&dev->driver_list);
+	INIT_LIST_HEAD(&dev->bus_list);
+	INIT_LIST_HEAD(&dev->dma_pools);
+}
+
+/**
+ *	device_add - add device to device hierarchy.
+ *	@dev:	device.
+ *
+ *	This is part 2 of device_register(), though may be called
+ *	separately _iff_ device_initialize() has been called separately.
+ *
+ *	This adds it to the kobject hierarchy via kobject_add(), adds it
+ *	to the global and sibling lists for the device, then
+ *	adds it to the other relevant subsystems of the driver model.
+ */
+int device_add(struct device *dev)
+{
+	struct device *parent = NULL;
+	int error = -EINVAL;
+
+	dev = get_device(dev);
+	if (!dev || !strlen(dev->bus_id))
+		goto Error;
+
+	parent = get_device(dev->parent);
+
+	pr_debug("DEV: registering device: ID = '%s'\n", dev->bus_id);
+
+	/* first, register with generic layer. */
+	kobject_set_name(&dev->kobj, "%s", dev->bus_id);
+	if (parent)
+		dev->kobj.parent = &parent->kobj;
+
+	if ((error = kobject_add(&dev->kobj)))
+		goto Error;
+	if ((error = device_pm_add(dev)))
+		goto PMError;
+	if ((error = bus_add_device(dev)))
+		goto BusError;
+	down_write(&devices_subsys.rwsem);
+	if (parent)
+		list_add_tail(&dev->node, &parent->children);
+	up_write(&devices_subsys.rwsem);
+
+	/* notify platform of device entry */
+	if (platform_notify)
+		platform_notify(dev);
+ Done:
+	put_device(dev);
+	return error;
+ BusError:
+	device_pm_remove(dev);
+ PMError:
+	kobject_del(&dev->kobj);
+ Error:
+	if (parent)
+		put_device(parent);
+	goto Done;
+}
+
+
+/**
+ *	device_register - register a device with the system.
+ *	@dev:	pointer to the device structure
+ *
+ *	This happens in two clean steps - initialize the device
+ *	and add it to the system. The two steps can be called
+ *	separately, but this is the easiest and most common.
+ *	I.e. you should only call the two helpers separately if
+ *	have a clearly defined need to use and refcount the device
+ *	before it is added to the hierarchy.
+ */
+
+int device_register(struct device *dev)
+{
+	device_initialize(dev);
+	return device_add(dev);
+}
+
+
+/**
+ *	get_device - increment reference count for device.
+ *	@dev:	device.
+ *
+ *	This simply forwards the call to kobject_get(), though
+ *	we do take care to provide for the case that we get a NULL
+ *	pointer passed in.
+ */
+
+struct device * get_device(struct device * dev)
+{
+	return dev ? to_dev(kobject_get(&dev->kobj)) : NULL;
+}
+
+
+/**
+ *	put_device - decrement reference count.
+ *	@dev:	device in question.
+ */
+void put_device(struct device * dev)
+{
+	if (dev)
+		kobject_put(&dev->kobj);
+}
+
+
+/**
+ *	device_del - delete device from system.
+ *	@dev:	device.
+ *
+ *	This is the first part of the device unregistration
+ *	sequence. This removes the device from the lists we control
+ *	from here, has it removed from the other driver model
+ *	subsystems it was added to in device_add(), and removes it
+ *	from the kobject hierarchy.
+ *
+ *	NOTE: this should be called manually _iff_ device_add() was
+ *	also called manually.
+ */
+
+void device_del(struct device * dev)
+{
+	struct device * parent = dev->parent;
+
+	down_write(&devices_subsys.rwsem);
+	if (parent)
+		list_del_init(&dev->node);
+	up_write(&devices_subsys.rwsem);
+
+	/* Notify the platform of the removal, in case they
+	 * need to do anything...
+	 */
+	if (platform_notify_remove)
+		platform_notify_remove(dev);
+	bus_remove_device(dev);
+	device_pm_remove(dev);
+	kobject_del(&dev->kobj);
+	if (parent)
+		put_device(parent);
+}
+
+/**
+ *	device_unregister - unregister device from system.
+ *	@dev:	device going away.
+ *
+ *	We do this in two parts, like we do device_register(). First,
+ *	we remove it from all the subsystems with device_del(), then
+ *	we decrement the reference count via put_device(). If that
+ *	is the final reference count, the device will be cleaned up
+ *	via device_release() above. Otherwise, the structure will
+ *	stick around until the final reference to the device is dropped.
+ */
+void device_unregister(struct device * dev)
+{
+	pr_debug("DEV: Unregistering device. ID = '%s'\n", dev->bus_id);
+	device_del(dev);
+	put_device(dev);
+}
+
+
+/**
+ *	device_for_each_child - device child iterator.
+ *	@dev:	parent struct device.
+ *	@data:	data for the callback.
+ *	@fn:	function to be called for each device.
+ *
+ *	Iterate over @dev's child devices, and call @fn for each,
+ *	passing it @data.
+ *
+ *	We check the return of @fn each time. If it returns anything
+ *	other than 0, we break out and return that value.
+ */
+int device_for_each_child(struct device * dev, void * data,
+		     int (*fn)(struct device *, void *))
+{
+	struct device * child;
+	int error = 0;
+
+	down_read(&devices_subsys.rwsem);
+	list_for_each_entry(child, &dev->children, node) {
+		if((error = fn(child, data)))
+			break;
+	}
+	up_read(&devices_subsys.rwsem);
+	return error;
+}
+
+/**
+ *	device_find - locate device on a bus by name.
+ *	@name:	name of the device.
+ *	@bus:	bus to scan for the device.
+ *
+ *	Call kset_find_obj() to iterate over list of devices on
+ *	a bus to find device by name. Return device if found.
+ *
+ *	Note that kset_find_obj increments device's reference count.
+ */
+struct device *device_find(const char *name, struct bus_type *bus)
+{
+	struct kobject *k = kset_find_obj(&bus->devices, name);
+	if (k)
+		return to_dev(k);
+	return NULL;
+}
+
+int __init devices_init(void)
+{
+	return subsystem_register(&devices_subsys);
+}
+
+EXPORT_SYMBOL_GPL(device_for_each_child);
+
+EXPORT_SYMBOL_GPL(device_initialize);
+EXPORT_SYMBOL_GPL(device_add);
+EXPORT_SYMBOL_GPL(device_register);
+
+EXPORT_SYMBOL_GPL(device_del);
+EXPORT_SYMBOL_GPL(device_unregister);
+EXPORT_SYMBOL_GPL(get_device);
+EXPORT_SYMBOL_GPL(put_device);
+EXPORT_SYMBOL_GPL(device_find);
+
+EXPORT_SYMBOL_GPL(device_create_file);
+EXPORT_SYMBOL_GPL(device_remove_file);
