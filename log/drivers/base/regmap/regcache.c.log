commit 37613fa5b762a73073de3c2e23baa4a1da337e71
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 25 20:06:18 2019 +0200

    regmap: add proper SPDX identifiers on files that did not have them.
    
    There were a few files in the regmap code that did not have SPDX
    identifiers on them, so fix that up.  At the same time, remove the "free
    form" text that specified the license of the file, as that is impossible
    for any tool to properly parse.
    
    Also, as Mark loves // comment markers, convert all of the headers to be
    the same to make things look consistent :)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 773560348337..a93cafd7be4f 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -1,14 +1,10 @@
-/*
- * Register cache access API
- *
- * Copyright 2011 Wolfson Microelectronics plc
- *
- * Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
+// SPDX-License-Identifier: GPL-2.0
+//
+// Register cache access API
+//
+// Copyright 2011 Wolfson Microelectronics plc
+//
+// Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
 
 #include <linux/bsearch.h>
 #include <linux/device.h>

commit f458e6102c1fe3a1d28bae85cdeb0cd66537c4fe
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jun 8 15:43:19 2017 +0100

    regmap: Fix typo in IS_ENABLED() check
    
    Reported-by: Andreas Ziegler <andreas.ziegler@fau.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f3a435ee5fe8..773560348337 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -21,7 +21,7 @@
 
 static const struct regcache_ops *cache_types[] = {
 	&regcache_rbtree_ops,
-#if IS_ENABLED(CONFIG_REGCHACHE_COMPRESSED)
+#if IS_ENABLED(CONFIG_REGCACHE_COMPRESSED)
 	&regcache_lzo_ops,
 #endif
 	&regcache_flat_ops,

commit 34a730aa74c7c743f4ca9635e0d0b2479d6ed53c
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Fri Jun 2 15:15:37 2017 +0200

    regmap: make LZO cache optional
    
    Commit 2cbbb579bcbe3 ("regmap: Add the LZO cache support") added support
    for LZO compression in regcache, but there were never any users added
    afterwards. Since LZO support itself has its own size, it currently is
    rather a deoptimization.
    
    So make it optional by introducing a symbol that can be selected by
    drivers wanting to make use of it.
    
    Saves e.g. ~46 kB on MIPS (size of LZO support + regcache LZO code).
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index b0a0dcf32fb7..f3a435ee5fe8 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -21,7 +21,9 @@
 
 static const struct regcache_ops *cache_types[] = {
 	&regcache_rbtree_ops,
+#if IS_ENABLED(CONFIG_REGCHACHE_COMPRESSED)
 	&regcache_lzo_ops,
+#endif
 	&regcache_flat_ops,
 };
 

commit 2cf8e2dfdf88363476f23bc600745250b94dbbed
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Jan 12 11:17:39 2017 +0000

    regmap: Fixup the kernel-doc comments on functions/structures
    
    Most of the kernel-doc comments in regmap don't actually generate
    correctly. This patch fixes up a few common issues, corrects some typos
    and adds some missing argument descriptions.
    
    The most common issues being using a : after the function name which
    causes the short description to not render correctly and not separating
    the long and short descriptions of the function. There are quite a few
    instances of arguments not being described or given the wrong name as
    well.
    
    This patch doesn't fixup functions/structures that are currently missing
    descriptions.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4e582561e1e7..b0a0dcf32fb7 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -224,7 +224,7 @@ void regcache_exit(struct regmap *map)
 }
 
 /**
- * regcache_read: Fetch the value of a given register from the cache.
+ * regcache_read - Fetch the value of a given register from the cache.
  *
  * @map: map to configure.
  * @reg: The register index.
@@ -255,7 +255,7 @@ int regcache_read(struct regmap *map,
 }
 
 /**
- * regcache_write: Set the value of a given register in the cache.
+ * regcache_write - Set the value of a given register in the cache.
  *
  * @map: map to configure.
  * @reg: The register index.
@@ -328,7 +328,7 @@ static int regcache_default_sync(struct regmap *map, unsigned int min,
 }
 
 /**
- * regcache_sync: Sync the register cache with the hardware.
+ * regcache_sync - Sync the register cache with the hardware.
  *
  * @map: map to configure.
  *
@@ -396,7 +396,7 @@ int regcache_sync(struct regmap *map)
 EXPORT_SYMBOL_GPL(regcache_sync);
 
 /**
- * regcache_sync_region: Sync part  of the register cache with the hardware.
+ * regcache_sync_region - Sync part  of the register cache with the hardware.
  *
  * @map: map to sync.
  * @min: first register to sync
@@ -452,7 +452,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 EXPORT_SYMBOL_GPL(regcache_sync_region);
 
 /**
- * regcache_drop_region: Discard part of the register cache
+ * regcache_drop_region - Discard part of the register cache
  *
  * @map: map to operate on
  * @min: first register to discard
@@ -483,10 +483,10 @@ int regcache_drop_region(struct regmap *map, unsigned int min,
 EXPORT_SYMBOL_GPL(regcache_drop_region);
 
 /**
- * regcache_cache_only: Put a register map into cache only mode
+ * regcache_cache_only - Put a register map into cache only mode
  *
  * @map: map to configure
- * @cache_only: flag if changes should be written to the hardware
+ * @enable: flag if changes should be written to the hardware
  *
  * When a register map is marked as cache only writes to the register
  * map API will only update the register cache, they will not cause
@@ -505,7 +505,7 @@ void regcache_cache_only(struct regmap *map, bool enable)
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 
 /**
- * regcache_mark_dirty: Indicate that HW registers were reset to default values
+ * regcache_mark_dirty - Indicate that HW registers were reset to default values
  *
  * @map: map to mark
  *
@@ -527,10 +527,10 @@ void regcache_mark_dirty(struct regmap *map)
 EXPORT_SYMBOL_GPL(regcache_mark_dirty);
 
 /**
- * regcache_cache_bypass: Put a register map into cache bypass mode
+ * regcache_cache_bypass - Put a register map into cache bypass mode
  *
  * @map: map to configure
- * @cache_bypass: flag if changes should not be written to the cache
+ * @enable: flag if changes should not be written to the cache
  *
  * When a register map is marked with the cache bypass option, writes
  * to the register map API will only update the hardware and not the

commit b2c7f5d9c939a37c1ce7f86a642de70e3033ee9e
Author: Maarten ter Huurne <maarten@treewalker.org>
Date:   Fri Jul 29 23:42:12 2016 +0200

    regmap: cache: Fix num_reg_defaults computation from reg_defaults_raw
    
    In 3245d460 (regmap: cache: Fall back to register by register read for
    cache defaults) non-readable registers are skipped when initializing
    reg_defaults, but are still included in num_reg_defaults. So there can
    be uninitialized entries at the end of reg_defaults, which can cause
    problems when the register cache initializes from the full array.
    
    Fixed it by excluding non-readable registers from the count as well.
    
    Signed-off-by: Maarten ter Huurne <maarten@treewalker.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index df7ff7290821..4e582561e1e7 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -38,10 +38,11 @@ static int regcache_hw_init(struct regmap *map)
 
 	/* calculate the size of reg_defaults */
 	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++)
-		if (!regmap_volatile(map, i * map->reg_stride))
+		if (regmap_readable(map, i * map->reg_stride) &&
+		    !regmap_volatile(map, i * map->reg_stride))
 			count++;
 
-	/* all registers are volatile, so just bypass */
+	/* all registers are unreadable or volatile, so just bypass */
 	if (!count) {
 		map->cache_bypass = true;
 		return 0;

commit 267c85860308d36bc163c5573308cd024f659d7c
Author: Andrew F. Davis <afd@ti.com>
Date:   Wed Mar 23 09:26:33 2016 -0500

    regmap: cache: Fix typo in cache_bypass parameter description
    
    Setting the flag 'cache_bypass' will bypass the cache not the hardware.
    Fix this comment here.
    
    Fixes: 0eef6b0415f5 ("regmap: Fix doc comment")
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4170b7d95276..df7ff7290821 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -529,7 +529,7 @@ EXPORT_SYMBOL_GPL(regcache_mark_dirty);
  * regcache_cache_bypass: Put a register map into cache bypass mode
  *
  * @map: map to configure
- * @cache_bypass: flag if changes should not be written to the hardware
+ * @cache_bypass: flag if changes should not be written to the cache
  *
  * When a register map is marked with the cache bypass option, writes
  * to the register map API will only update the hardware and not the

commit 781aab8457610d0b4d60cd85bb22e609941be721
Merge: 0e03ae749227 aacaaa4c8e1c
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Mar 5 21:30:29 2016 +0900

    Merge remote-tracking branch 'regmap/topic/mmio' into regmap-next

commit 0e03ae7492271a62f6085c9c7f301ac8a481b001
Merge: fc77dbd34c5c d51fe1f393a6
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Mar 5 21:30:22 2016 +0900

    Merge remote-tracking branch 'regmap/fix/raw' into regmap-linus

commit 3245d460a1eb55b5c3ca31dde7b5c5ac71546edf
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Feb 2 10:16:51 2016 -0200

    regmap: cache: Fall back to register by register read for cache defaults
    
    If we are unable to read the cache defaults for a regmap then fall back
    on attempting to read them word by word. This is going to be painfully
    slow for large regmaps but might be adequate for smaller ones.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    [maciej: Use cache_bypass around read and skipping of unreadable regs]
    Signed-off-by: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Tested-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 348be3a35410..cccceb599b02 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -30,7 +30,7 @@ static int regcache_hw_init(struct regmap *map)
 	int i, j;
 	int ret;
 	int count;
-	unsigned int val;
+	unsigned int reg, val;
 	void *tmp_buf;
 
 	if (!map->num_reg_defaults_raw)
@@ -67,27 +67,46 @@ static int regcache_hw_init(struct regmap *map)
 		ret = regmap_raw_read(map, 0, tmp_buf,
 				      map->num_reg_defaults_raw);
 		map->cache_bypass = cache_bypass;
-		if (ret < 0)
-			goto err_cache_free;
-
-		map->reg_defaults_raw = tmp_buf;
-		map->cache_free = 1;
+		if (ret == 0) {
+			map->reg_defaults_raw = tmp_buf;
+			map->cache_free = 1;
+		} else {
+			kfree(tmp_buf);
+		}
 	}
 
 	/* fill the reg_defaults */
 	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
-		if (regmap_volatile(map, i * map->reg_stride))
+		reg = i * map->reg_stride;
+
+		if (!regmap_readable(map, reg))
 			continue;
-		val = regcache_get_val(map, map->reg_defaults_raw, i);
-		map->reg_defaults[j].reg = i * map->reg_stride;
+
+		if (regmap_volatile(map, reg))
+			continue;
+
+		if (map->reg_defaults_raw) {
+			val = regcache_get_val(map, map->reg_defaults_raw, i);
+		} else {
+			bool cache_bypass = map->cache_bypass;
+
+			map->cache_bypass = true;
+			ret = regmap_read(map, reg, &val);
+			map->cache_bypass = cache_bypass;
+			if (ret != 0) {
+				dev_err(map->dev, "Failed to read %d: %d\n",
+					reg, ret);
+				goto err_free;
+			}
+		}
+
+		map->reg_defaults[j].reg = reg;
 		map->reg_defaults[j].def = val;
 		j++;
 	}
 
 	return 0;
 
-err_cache_free:
-	kfree(tmp_buf);
 err_free:
 	kfree(map->reg_defaults);
 

commit d51fe1f393a6b99e9133a3360036af2c21983ec2
Author: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
Date:   Wed Jan 13 22:41:12 2016 +0100

    regmap: pass buffer size to regmap_raw_read() in regcache_hw_init()
    
    regcache_hw_init() uses regmap_raw_read() to initialize cache
    when reg_defaults_raw isn't provided.
    
    The last parameter to regmap_raw_read() is buffer size in bytes,
    however regcache_hw_init() called it with number of registers
    to read instead, which cause problem if they aren't one byte
    wide in cache.
    
    This wasn't triggered by any of current in-tree drivers
    since they either have one-byte registers or provide
    reg_defaults_raw explicitly.
    
    Signed-off-by: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4c07802986b2..45ae91eb6be9 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -57,7 +57,7 @@ static int regcache_hw_init(struct regmap *map)
 		bool cache_bypass = map->cache_bypass;
 		dev_warn(map->dev, "No cache defaults, reading back from HW\n");
 
-		/* Bypass the cache access till data read from HW*/
+		/* Bypass the cache access till data read from HW */
 		map->cache_bypass = true;
 		tmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);
 		if (!tmp_buf) {
@@ -65,7 +65,7 @@ static int regcache_hw_init(struct regmap *map)
 			goto err_free;
 		}
 		ret = regmap_raw_read(map, 0, tmp_buf,
-				      map->num_reg_defaults_raw);
+				      map->cache_size_raw);
 		map->cache_bypass = cache_bypass;
 		if (ret < 0)
 			goto err_cache_free;

commit a8d99344c9ebc2f12232473f92beac2f894b6ea5
Merge: 8798975bb645 782035ea94dc 7a78479fd2ac
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jan 5 19:07:17 2016 +0000

    Merge remote-tracking branches 'regmap/topic/64bit' and 'regmap/topic/irq-type' into regmap-next

commit 167f7066a637332b463adf3b87b2af1c1031591a
Author: Xiubo Li <lixiubo@cmss.chinamobile.com>
Date:   Fri Dec 11 11:23:20 2015 +0800

    regmap: cache: Move the num_reg_defaults check as early as possible
    
    If the register defaults are provided by the driver without the
    number by mistake, it should just return an error with one promotion.
    
    This should be as early as possible, then there is no need to verify
    the register defaults' stride and the other code followed.
    
    Signed-off-by: Xiubo Li <lixiubo@cmss.chinamobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 9436a0d4cf71..60aeaad7fb69 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -109,6 +109,12 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 		return 0;
 	}
 
+	if (config->reg_defaults && !config->num_reg_defaults) {
+		dev_err(map->dev,
+			 "Register defaults are set without the number!\n");
+		return -EINVAL;
+	}
+
 	for (i = 0; i < config->num_reg_defaults; i++)
 		if (config->reg_defaults[i].reg % map->reg_stride)
 			return -EINVAL;
@@ -142,8 +148,6 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	 * a copy of it.
 	 */
 	if (config->reg_defaults) {
-		if (!map->num_reg_defaults)
-			return -EINVAL;
 		tmp_buf = kmemdup(config->reg_defaults, map->num_reg_defaults *
 				  sizeof(struct reg_default), GFP_KERNEL);
 		if (!tmp_buf)

commit 8cfe2fd3562ba673435bb2d7a4bb451aabd47809
Author: Xiubo Li <lixiubo@cmss.chinamobile.com>
Date:   Fri Dec 11 11:23:19 2015 +0800

    regmap: cache: Add warning info for the cache check
    
    If there is no cache used for the drivers, the register defaults
    or the register defaults raw are not need any more. This patch
    will check this and print a warning.
    
    Signed-off-by: Xiubo Li <lixiubo@cmss.chinamobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4c07802986b2..9436a0d4cf71 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -100,15 +100,19 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	int i;
 	void *tmp_buf;
 
-	for (i = 0; i < config->num_reg_defaults; i++)
-		if (config->reg_defaults[i].reg % map->reg_stride)
-			return -EINVAL;
-
 	if (map->cache_type == REGCACHE_NONE) {
+		if (config->reg_defaults || config->num_reg_defaults_raw)
+			dev_warn(map->dev,
+				 "No cache used with register defaults set!\n");
+
 		map->cache_bypass = true;
 		return 0;
 	}
 
+	for (i = 0; i < config->num_reg_defaults; i++)
+		if (config->reg_defaults[i].reg % map->reg_stride)
+			return -EINVAL;
+
 	for (i = 0; i < ARRAY_SIZE(cache_types); i++)
 		if (cache_types[i]->type == map->cache_type)
 			break;

commit 8b7663de6e2bfe3c40e1846e1c4625f33d138757
Author: Xiubo Li <lixiubo@cmss.chinamobile.com>
Date:   Wed Dec 9 13:09:07 2015 +0800

    regmap: cache: Add 64-bit mode support
    
    Since the mmio has support the 64-bit has been supported for the
    64-bit platform, so should the regcache core too.
    
    Signed-off-by: Xiubo Li <lixiubo@cmss.chinamobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 3cb8c59a5ff6..1c0210aa2573 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -551,6 +551,14 @@ bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
 		cache[idx] = val;
 		break;
 	}
+#ifdef CONFIG_64BIT
+	case 8: {
+		u64 *cache = base;
+
+		cache[idx] = val;
+		break;
+	}
+#endif
 	default:
 		BUG();
 	}
@@ -584,6 +592,13 @@ unsigned int regcache_get_val(struct regmap *map, const void *base,
 
 		return cache[idx];
 	}
+#ifdef CONFIG_64BIT
+	case 8: {
+		const u64 *cache = base;
+
+		return cache[idx];
+	}
+#endif
 	default:
 		BUG();
 	}

commit 2fd6902ed7587c302611906b5151f6a7efeb2c63
Author: Xiubo Li <lixiubo@cmss.chinamobile.com>
Date:   Wed Dec 9 13:09:06 2015 +0800

    regmap: cache: To suppress the noise of checkpatch
    
    There will be some warning like the following when checking new
    patches near this code:
        "WARNING: Missing a blank line after declarations"
    This patch will suppress this warning.
    
    Signed-off-by: Xiubo Li <lixiubo@cmss.chinamobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4c07802986b2..3cb8c59a5ff6 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -535,16 +535,19 @@ bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
 	switch (map->cache_word_size) {
 	case 1: {
 		u8 *cache = base;
+
 		cache[idx] = val;
 		break;
 	}
 	case 2: {
 		u16 *cache = base;
+
 		cache[idx] = val;
 		break;
 	}
 	case 4: {
 		u32 *cache = base;
+
 		cache[idx] = val;
 		break;
 	}
@@ -568,14 +571,17 @@ unsigned int regcache_get_val(struct regmap *map, const void *base,
 	switch (map->cache_word_size) {
 	case 1: {
 		const u8 *cache = base;
+
 		return cache[idx];
 	}
 	case 2: {
 		const u16 *cache = base;
+
 		return cache[idx];
 	}
 	case 4: {
 		const u32 *cache = base;
+
 		return cache[idx];
 	}
 	default:

commit 621a5f7ad9cd1ce7933f1d302067cbd58354173c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Sep 26 15:04:07 2015 -0700

    debugfs: Pass bool pointer to debugfs_create_bool()
    
    Its a bit odd that debugfs_create_bool() takes 'u32 *' as an argument,
    when all it needs is a boolean pointer.
    
    It would be better to update this API to make it accept 'bool *'
    instead, as that will make it more consistent and often more convenient.
    Over that bool takes just a byte.
    
    That required updates to all user sites as well, in the same commit
    updating the API. regmap core was also using
    debugfs_{read|write}_file_bool(), directly and variable types were
    updated for that to be bool as well.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 6f8a13ec32a4..4c07802986b2 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -54,11 +54,11 @@ static int regcache_hw_init(struct regmap *map)
 		return -ENOMEM;
 
 	if (!map->reg_defaults_raw) {
-		u32 cache_bypass = map->cache_bypass;
+		bool cache_bypass = map->cache_bypass;
 		dev_warn(map->dev, "No cache defaults, reading back from HW\n");
 
 		/* Bypass the cache access till data read from HW*/
-		map->cache_bypass = 1;
+		map->cache_bypass = true;
 		tmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);
 		if (!tmp_buf) {
 			ret = -ENOMEM;
@@ -285,9 +285,9 @@ static int regcache_default_sync(struct regmap *map, unsigned int min,
 		if (!regcache_reg_needs_sync(map, reg, val))
 			continue;
 
-		map->cache_bypass = 1;
+		map->cache_bypass = true;
 		ret = _regmap_write(map, reg, val);
-		map->cache_bypass = 0;
+		map->cache_bypass = false;
 		if (ret) {
 			dev_err(map->dev, "Unable to sync register %#x. %d\n",
 				reg, ret);
@@ -315,7 +315,7 @@ int regcache_sync(struct regmap *map)
 	int ret = 0;
 	unsigned int i;
 	const char *name;
-	unsigned int bypass;
+	bool bypass;
 
 	BUG_ON(!map->cache_ops);
 
@@ -333,7 +333,7 @@ int regcache_sync(struct regmap *map)
 	map->async = true;
 
 	/* Apply any patch first */
-	map->cache_bypass = 1;
+	map->cache_bypass = true;
 	for (i = 0; i < map->patch_regs; i++) {
 		ret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);
 		if (ret != 0) {
@@ -342,7 +342,7 @@ int regcache_sync(struct regmap *map)
 			goto out;
 		}
 	}
-	map->cache_bypass = 0;
+	map->cache_bypass = false;
 
 	if (map->cache_ops->sync)
 		ret = map->cache_ops->sync(map, 0, map->max_register);
@@ -384,7 +384,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 {
 	int ret = 0;
 	const char *name;
-	unsigned int bypass;
+	bool bypass;
 
 	BUG_ON(!map->cache_ops);
 
@@ -637,11 +637,11 @@ static int regcache_sync_block_single(struct regmap *map, void *block,
 		if (!regcache_reg_needs_sync(map, regtmp, val))
 			continue;
 
-		map->cache_bypass = 1;
+		map->cache_bypass = true;
 
 		ret = _regmap_write(map, regtmp, val);
 
-		map->cache_bypass = 0;
+		map->cache_bypass = false;
 		if (ret != 0) {
 			dev_err(map->dev, "Unable to sync register %#x. %d\n",
 				regtmp, ret);
@@ -668,14 +668,14 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 	dev_dbg(map->dev, "Writing %zu bytes for %d registers from 0x%x-0x%x\n",
 		count * val_bytes, count, base, cur - map->reg_stride);
 
-	map->cache_bypass = 1;
+	map->cache_bypass = true;
 
 	ret = _regmap_raw_write(map, base, *data, count * val_bytes);
 	if (ret)
 		dev_err(map->dev, "Unable to sync registers %#x-%#x. %d\n",
 			base, cur - map->reg_stride, ret);
 
-	map->cache_bypass = 0;
+	map->cache_bypass = false;
 
 	*data = NULL;
 

commit 67921a1a6660d32cc2770d05d656a1187b6d94d5
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Fri Aug 21 10:26:42 2015 +0200

    regmap: Split use_single_rw internally into use_single_read/write
    
    use_single_rw currently reflects the capabilities of the connected
    device. The capabilities of the bus are currently missing for this
    variable.
    
    As there are read only and write only buses we need seperate values for
    use_single_rw to also reflect tha capabilities of the bus.
    
    This patch splits use_single_rw into use_single_read and
    use_single_write. The initialization is changed to check the
    configuration for use_single_rw and to check the capabilities of the
    used bus.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index b9862d741a56..6f8a13ec32a4 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -729,7 +729,7 @@ int regcache_sync_block(struct regmap *map, void *block,
 			unsigned int block_base, unsigned int start,
 			unsigned int end)
 {
-	if (regmap_can_raw_write(map) && !map->use_single_rw)
+	if (regmap_can_raw_write(map) && !map->use_single_write)
 		return regcache_sync_block_raw(map, block, cache_present,
 					       block_base, start, end);
 	else

commit 1c79771a7270278e6ff486edf4dfeb8c4fc01ee0
Author: Kevin Cernekee <cernekee@chromium.org>
Date:   Tue May 5 15:14:14 2015 -0700

    regmap: Use regcache_mark_dirty() to indicate power loss or reset
    
    Existing regmap users call regcache_mark_dirty() as part of the
    suspend/resume sequence, to tell regcache that non-default values need to
    be resynced post-resume.  Add an internal "no_sync_defaults" regmap flag
    to remember this state, so that regcache_sync() can differentiate between
    these two cases:
    
    1) HW was reset, so any cache values that match map->reg_defaults can be
    safely skipped.  On some chips there are a lot of registers in the
    reg_defaults list, so this optimization speeds things up quite a bit.
    
    2) HW was not reset (maybe it was just clock-gated), so if we cached
    any writes, they should be sent to the hardware regardless of whether
    they match the HW default.  Currently this will write out all values in
    the regcache, since we don't maintain per-register dirty bits.
    
    Suggested-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Kevin Cernekee <cernekee@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index c58493eaf050..b9862d741a56 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -254,6 +254,10 @@ static bool regcache_reg_needs_sync(struct regmap *map, unsigned int reg,
 {
 	int ret;
 
+	/* If we don't know the chip just got reset, then sync everything. */
+	if (!map->no_sync_defaults)
+		return true;
+
 	/* Is this the hardware default?  If so skip. */
 	ret = regcache_lookup_reg(map, reg);
 	if (ret >= 0 && val == map->reg_defaults[ret].def)
@@ -352,6 +356,7 @@ int regcache_sync(struct regmap *map)
 	/* Restore the bypass state */
 	map->async = false;
 	map->cache_bypass = bypass;
+	map->no_sync_defaults = false;
 	map->unlock(map->lock_arg);
 
 	regmap_async_complete(map);
@@ -407,6 +412,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 	/* Restore the bypass state */
 	map->cache_bypass = bypass;
 	map->async = false;
+	map->no_sync_defaults = false;
 	map->unlock(map->lock_arg);
 
 	regmap_async_complete(map);
@@ -471,18 +477,23 @@ void regcache_cache_only(struct regmap *map, bool enable)
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 
 /**
- * regcache_mark_dirty: Mark the register cache as dirty
+ * regcache_mark_dirty: Indicate that HW registers were reset to default values
  *
  * @map: map to mark
  *
- * Mark the register cache as dirty, for example due to the device
- * having been powered down for suspend.  If the cache is not marked
- * as dirty then the cache sync will be suppressed.
+ * Inform regcache that the device has been powered down or reset, so that
+ * on resume, regcache_sync() knows to write out all non-default values
+ * stored in the cache.
+ *
+ * If this function is not called, regcache_sync() will assume that
+ * the hardware state still matches the cache state, modulo any writes that
+ * happened when cache_only was true.
  */
 void regcache_mark_dirty(struct regmap *map)
 {
 	map->lock(map->lock_arg);
 	map->cache_dirty = true;
+	map->no_sync_defaults = true;
 	map->unlock(map->lock_arg);
 }
 EXPORT_SYMBOL_GPL(regcache_mark_dirty);

commit 3969fa080661dcdf20d04392b900189086e04c2c
Author: Kevin Cernekee <cernekee@chromium.org>
Date:   Tue May 5 15:14:13 2015 -0700

    regmap: Add a helper function for regcache sync test
    
    We're going to add another "does this register need syncing?" check, so
    rather than repeating it in three places, we'll separate all of the
    relevant logic into a helper function.
    
    Signed-off-by: Kevin Cernekee <cernekee@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 7eb7b3b98794..c58493eaf050 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -249,6 +249,18 @@ int regcache_write(struct regmap *map,
 	return 0;
 }
 
+static bool regcache_reg_needs_sync(struct regmap *map, unsigned int reg,
+				    unsigned int val)
+{
+	int ret;
+
+	/* Is this the hardware default?  If so skip. */
+	ret = regcache_lookup_reg(map, reg);
+	if (ret >= 0 && val == map->reg_defaults[ret].def)
+		return false;
+	return true;
+}
+
 static int regcache_default_sync(struct regmap *map, unsigned int min,
 				 unsigned int max)
 {
@@ -266,9 +278,7 @@ static int regcache_default_sync(struct regmap *map, unsigned int min,
 		if (ret)
 			return ret;
 
-		/* Is this the hardware default?  If so skip. */
-		ret = regcache_lookup_reg(map, reg);
-		if (ret >= 0 && val == map->reg_defaults[ret].def)
+		if (!regcache_reg_needs_sync(map, reg, val))
 			continue;
 
 		map->cache_bypass = 1;
@@ -613,10 +623,7 @@ static int regcache_sync_block_single(struct regmap *map, void *block,
 			continue;
 
 		val = regcache_get_val(map, block, i);
-
-		/* Is this the hardware default?  If so skip. */
-		ret = regcache_lookup_reg(map, regtmp);
-		if (ret >= 0 && val == map->reg_defaults[ret].def)
+		if (!regcache_reg_needs_sync(map, regtmp, val))
 			continue;
 
 		map->cache_bypass = 1;
@@ -688,10 +695,7 @@ static int regcache_sync_block_raw(struct regmap *map, void *block,
 		}
 
 		val = regcache_get_val(map, block, i);
-
-		/* Is this the hardware default?  If so skip. */
-		ret = regcache_lookup_reg(map, regtmp);
-		if (ret >= 0 && val == map->reg_defaults[ret].def) {
+		if (!regcache_reg_needs_sync(map, regtmp, val)) {
 			ret = regcache_sync_block_raw_flush(map, &data,
 							    base, regtmp);
 			if (ret != 0)

commit 1b57c7c2fbb81763cd4a6940c8530c98022c409c
Merge: 8d9095c667a1 f58078dacaaf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 13 15:00:55 2015 -0700

    Merge tag 'regmap-v4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap
    
    Pull regmap update from Mark Brown:
     "Just one patch for regmap this time around, a change from Steven
      Rostedt to prettify the way we're making the regmap internal header
      available to the trace events (it turns out that the trace subsystem
      doesn't actually need to be in trace/events)"
    
    * tag 'regmap-v4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap:
      regmap: Move tracing header into drivers/base/regmap

commit 7c90de34b23ba69050b3a8fa7e524e871bcf3921
Merge: 90a5a895cc8b c6b570d97c0e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 24 16:42:54 2015 -0700

    Merge tag 'regmap-fix-v4.0-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap
    
    Pull regmap fix from Mark Brown:
     "This patch fixes a bad interaction between the support that was added
      for having regmaps without devices for early system controller
      initialization and the trace support.
    
      There's a very good analysis of the actual issue in the commit message
      for the change"
    
    * tag 'regmap-fix-v4.0-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap:
      regmap: introduce regmap_name to fix syscon regmap trace events

commit f58078dacaaf6fbe664d5404dca7f76dce576113
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Thu Mar 19 17:50:47 2015 -0400

    regmap: Move tracing header into drivers/base/regmap
    
    The tracing events for regmap are confined to the regmap subsystem. It
    also requires accessing an internal header. Instead of including the
    internal header from a generic file location, move the tracing file
    into the regmap directory.
    
    Also rename the regmap tracing header to trace.h, as it is redundant to
    keep the regmap.h name when it is in the regmap directory.
    
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f5db662e951e..0deae4fdd762 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -15,8 +15,8 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/sort.h>
-#include <trace/events/regmap.h>
 
+#include "trace.h"
 #include "internal.h"
 
 static const struct regcache_ops *cache_types[] = {

commit c6b570d97c0e77f570bb6b2ed30d372b2b1e9aae
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Mar 9 12:20:13 2015 +0100

    regmap: introduce regmap_name to fix syscon regmap trace events
    
    This patch fixes a NULL pointer dereference when enabling regmap event
    tracing in the presence of a syscon regmap, introduced by commit bdb0066df96e
    ("mfd: syscon: Decouple syscon interface from platform devices").
    That patch introduced syscon regmaps that have their dev field set to NULL.
    The regmap trace events expect it to point to a valid struct device and feed
    it to dev_name():
    
      $ echo 1 > /sys/kernel/debug/tracing/events/regmap/enable
    
      Unable to handle kernel NULL pointer dereference at virtual address 0000002c
      pgd = 80004000
      [0000002c] *pgd=00000000
      Internal error: Oops: 17 [#1] SMP ARM
      Modules linked in: coda videobuf2_vmalloc
      CPU: 0 PID: 304 Comm: kworker/0:2 Not tainted 4.0.0-rc2+ #9197
      Hardware name: Freescale i.MX6 Quad/DualLite (Device Tree)
      Workqueue: events_freezable thermal_zone_device_check
      task: 9f25a200 ti: 9f1ee000 task.ti: 9f1ee000
      PC is at ftrace_raw_event_regmap_block+0x3c/0xe4
      LR is at _regmap_raw_read+0x1bc/0x1cc
      pc : [<803636e8>]    lr : [<80365f2c>]    psr: 600f0093
      sp : 9f1efd78  ip : 9f1efdb8  fp : 9f1efdb4
      r10: 00000004  r9 : 00000001  r8 : 00000001
      r7 : 00000180  r6 : 00000000  r5 : 9f00e3c0  r4 : 00000003
      r3 : 00000001  r2 : 00000180  r1 : 00000000  r0 : 9f00e3c0
      Flags: nZCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
      Control: 10c5387d  Table: 2d91004a  DAC: 00000015
      Process kworker/0:2 (pid: 304, stack limit = 0x9f1ee210)
      Stack: (0x9f1efd78 to 0x9f1f0000)
      fd60:                                                       9f1efda4 9f1efd88
      fd80: 800708c0 805f9510 80927140 800f0013 9f1fc800 9eb2f490 00000000 00000180
      fda0: 808e3840 00000001 9f1efdfc 9f1efdb8 80365f2c 803636b8 805f8958 800708e0
      fdc0: a00f0013 803636ac 9f16de00 00000180 80927140 9f1fc800 9f1fc800 9f1efe6c
      fde0: 9f1efe6c 9f732400 00000000 00000000 9f1efe1c 9f1efe00 80365f70 80365d7c
      fe00: 80365f3c 9f1fc800 9f1fc800 00000180 9f1efe44 9f1efe20 803656a4 80365f48
      fe20: 9f1fc800 00000180 9f1efe6c 9f1efe6c 9f732400 00000000 9f1efe64 9f1efe48
      fe40: 803657bc 80365634 00000001 9e95f910 9f1fc800 9f1efeb4 9f1efe8c 9f1efe68
      fe60: 80452ac0 80365778 9f1efe8c 9f1efe78 9e93d400 9e93d5e8 9f1efeb4 9f72ef40
      fe80: 9f1efeac 9f1efe90 8044e11c 80452998 8045298c 9e93d608 9e93d400 808e1978
      fea0: 9f1efecc 9f1efeb0 8044fd14 8044e0d0 ffffffff 9f25a200 9e93d608 9e481380
      fec0: 9f1efedc 9f1efed0 8044fde8 8044fcec 9f1eff1c 9f1efee0 80038d50 8044fdd8
      fee0: 9f1ee020 9f72ef40 9e481398 00000000 00000008 9f72ef54 9f1ee020 9f72ef40
      ff00: 9e481398 9e481380 00000008 9f72ef40 9f1eff5c 9f1eff20 80039754 80038bfc
      ff20: 00000000 9e481380 80894100 808e1662 00000000 9e4f2ec0 00000000 9e481380
      ff40: 800396f8 00000000 00000000 00000000 9f1effac 9f1eff60 8003e020 80039704
      ff60: ffffffff 00000000 ffffffff 9e481380 00000000 00000000 9f1eff78 9f1eff78
      ff80: 00000000 00000000 9f1eff88 9f1eff88 9e4f2ec0 8003df30 00000000 00000000
      ffa0: 00000000 9f1effb0 8000eb60 8003df3c 00000000 00000000 00000000 00000000
      ffc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
      ffe0: 00000000 00000000 00000000 00000000 00000013 00000000 ffffffff ffffffff
      Backtrace:
      [<803636ac>] (ftrace_raw_event_regmap_block) from [<80365f2c>] (_regmap_raw_read+0x1bc/0x1cc)
       r9:00000001 r8:808e3840 r7:00000180 r6:00000000 r5:9eb2f490 r4:9f1fc800
      [<80365d70>] (_regmap_raw_read) from [<80365f70>] (_regmap_bus_read+0x34/0x6c)
       r10:00000000 r9:00000000 r8:9f732400 r7:9f1efe6c r6:9f1efe6c r5:9f1fc800
       r4:9f1fc800
      [<80365f3c>] (_regmap_bus_read) from [<803656a4>] (_regmap_read+0x7c/0x144)
       r6:00000180 r5:9f1fc800 r4:9f1fc800 r3:80365f3c
      [<80365628>] (_regmap_read) from [<803657bc>] (regmap_read+0x50/0x70)
       r9:00000000 r8:9f732400 r7:9f1efe6c r6:9f1efe6c r5:00000180 r4:9f1fc800
      [<8036576c>] (regmap_read) from [<80452ac0>] (imx_get_temp+0x134/0x1a4)
       r6:9f1efeb4 r5:9f1fc800 r4:9e95f910 r3:00000001
      [<8045298c>] (imx_get_temp) from [<8044e11c>] (thermal_zone_get_temp+0x58/0x74)
       r7:9f72ef40 r6:9f1efeb4 r5:9e93d5e8 r4:9e93d400
      [<8044e0c4>] (thermal_zone_get_temp) from [<8044fd14>] (thermal_zone_device_update+0x34/0xec)
       r6:808e1978 r5:9e93d400 r4:9e93d608 r3:8045298c
      [<8044fce0>] (thermal_zone_device_update) from [<8044fde8>] (thermal_zone_device_check+0x1c/0x20)
       r5:9e481380 r4:9e93d608
      [<8044fdcc>] (thermal_zone_device_check) from [<80038d50>] (process_one_work+0x160/0x3d4)
      [<80038bf0>] (process_one_work) from [<80039754>] (worker_thread+0x5c/0x4f4)
       r10:9f72ef40 r9:00000008 r8:9e481380 r7:9e481398 r6:9f72ef40 r5:9f1ee020
       r4:9f72ef54
      [<800396f8>] (worker_thread) from [<8003e020>] (kthread+0xf0/0x108)
       r10:00000000 r9:00000000 r8:00000000 r7:800396f8 r6:9e481380 r5:00000000
       r4:9e4f2ec0
      [<8003df30>] (kthread) from [<8000eb60>] (ret_from_fork+0x14/0x34)
       r7:00000000 r6:00000000 r5:8003df30 r4:9e4f2ec0
      Code: e3140040 1a00001a e3140020 1a000016 (e596002c)
      ---[ end trace 193c15c2494ec960 ]---
    
    Fixes: bdb0066df96e (mfd: syscon: Decouple syscon interface from platform devices)
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f373c35f9e1d..f5db662e951e 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -218,7 +218,7 @@ int regcache_read(struct regmap *map,
 		ret = map->cache_ops->read(map, reg, value);
 
 		if (ret == 0)
-			trace_regmap_reg_read_cache(map->dev, reg, *value);
+			trace_regmap_reg_read_cache(map, reg, *value);
 
 		return ret;
 	}
@@ -311,7 +311,7 @@ int regcache_sync(struct regmap *map)
 	dev_dbg(map->dev, "Syncing %s cache\n",
 		map->cache_ops->name);
 	name = map->cache_ops->name;
-	trace_regcache_sync(map->dev, name, "start");
+	trace_regcache_sync(map, name, "start");
 
 	if (!map->cache_dirty)
 		goto out;
@@ -346,7 +346,7 @@ int regcache_sync(struct regmap *map)
 
 	regmap_async_complete(map);
 
-	trace_regcache_sync(map->dev, name, "stop");
+	trace_regcache_sync(map, name, "stop");
 
 	return ret;
 }
@@ -381,7 +381,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 	name = map->cache_ops->name;
 	dev_dbg(map->dev, "Syncing %s cache from %d-%d\n", name, min, max);
 
-	trace_regcache_sync(map->dev, name, "start region");
+	trace_regcache_sync(map, name, "start region");
 
 	if (!map->cache_dirty)
 		goto out;
@@ -401,7 +401,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 
 	regmap_async_complete(map);
 
-	trace_regcache_sync(map->dev, name, "stop region");
+	trace_regcache_sync(map, name, "stop region");
 
 	return ret;
 }
@@ -428,7 +428,7 @@ int regcache_drop_region(struct regmap *map, unsigned int min,
 
 	map->lock(map->lock_arg);
 
-	trace_regcache_drop_region(map->dev, min, max);
+	trace_regcache_drop_region(map, min, max);
 
 	ret = map->cache_ops->drop(map, min, max);
 
@@ -455,7 +455,7 @@ void regcache_cache_only(struct regmap *map, bool enable)
 	map->lock(map->lock_arg);
 	WARN_ON(map->cache_bypass && enable);
 	map->cache_only = enable;
-	trace_regmap_cache_only(map->dev, enable);
+	trace_regmap_cache_only(map, enable);
 	map->unlock(map->lock_arg);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
@@ -493,7 +493,7 @@ void regcache_cache_bypass(struct regmap *map, bool enable)
 	map->lock(map->lock_arg);
 	WARN_ON(map->cache_only && enable);
 	map->cache_bypass = enable;
-	trace_regmap_cache_bypass(map->dev, enable);
+	trace_regmap_cache_bypass(map, enable);
 	map->unlock(map->lock_arg);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);

commit 4ceba98d3fe204c59e5f63c4d834b45dcfe789f0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 4 15:29:17 2015 +0100

    regmap: Skip read-only registers in regcache_sync()
    
    regcache_sync() spews warnings when a value was cached for a read-only
    register as it tries to write all registers no matter whether they are
    writable or not.  This patch adds regmap_wrtieable() checks for
    avoiding it in regcache_sync_block_single() and regcache_block_raw().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f373c35f9e1d..da84f544c544 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -608,7 +608,8 @@ static int regcache_sync_block_single(struct regmap *map, void *block,
 	for (i = start; i < end; i++) {
 		regtmp = block_base + (i * map->reg_stride);
 
-		if (!regcache_reg_present(cache_present, i))
+		if (!regcache_reg_present(cache_present, i) ||
+		    !regmap_writeable(map, regtmp))
 			continue;
 
 		val = regcache_get_val(map, block, i);
@@ -677,7 +678,8 @@ static int regcache_sync_block_raw(struct regmap *map, void *block,
 	for (i = start; i < end; i++) {
 		regtmp = block_base + (i * map->reg_stride);
 
-		if (!regcache_reg_present(cache_present, i)) {
+		if (!regcache_reg_present(cache_present, i) ||
+		    !regmap_writeable(map, regtmp)) {
 			ret = regcache_sync_block_raw_flush(map, &data,
 							    base, regtmp);
 			if (ret != 0)

commit a63b87838a592577c7134a3cb89c74e59b9dd9c1
Merge: c6efe576183a 22853223d15b e39be3a31b8f
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Nov 21 11:32:36 2014 +0000

    Merge remote-tracking branches 'regmap/topic/ac97' and 'regmap/topic/headers' into regmap-next

commit e39be3a31b8f16d92fff096e92b593a9bffecb93
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Oct 9 17:02:52 2014 +0800

    regmap: cache: Sort include headers alphabetically
    
    If the inlcude headers aren't sorted alphabetically, then the
    logical choice is to append new ones, however that creates a
    lot of potential for conflicts or duplicates because every change
    will then add new includes in the same location.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f1280dc356d0..489680433f9d 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -10,12 +10,12 @@
  * published by the Free Software Foundation.
  */
 
-#include <linux/slab.h>
-#include <linux/export.h>
-#include <linux/device.h>
-#include <trace/events/regmap.h>
 #include <linux/bsearch.h>
+#include <linux/device.h>
+#include <linux/export.h>
+#include <linux/slab.h>
 #include <linux/sort.h>
+#include <trace/events/regmap.h>
 
 #include "internal.h"
 

commit fb70067e4a2cc45d273864f071fd6cf62143137a
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Oct 9 17:02:57 2014 +0800

    regmap: cache: Fix possible ZERO_SIZE_PTR pointer dereferencing error.
    
    When all the registers are volatile(unlikely, but logically and mostly
    will happen for some 'device' who has very few registers), then the
    count will be euqal to 0, then kmalloc() will return ZERO_SIZE_PTR,
    which equals to ((void *)16).
    
    So this patch fix this with just doing the zero check before calling
    kmalloc(). If the count == 0, so we can make sure that all the registers
    are volatile, so no cache is need.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 726d956f6a29..d815929ba745 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -36,6 +36,23 @@ static int regcache_hw_init(struct regmap *map)
 	if (!map->num_reg_defaults_raw)
 		return -EINVAL;
 
+	/* calculate the size of reg_defaults */
+	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++)
+		if (!regmap_volatile(map, i * map->reg_stride))
+			count++;
+
+	/* all registers are volatile, so just bypass */
+	if (!count) {
+		map->cache_bypass = true;
+		return 0;
+	}
+
+	map->num_reg_defaults = count;
+	map->reg_defaults = kmalloc_array(count, sizeof(struct reg_default),
+					  GFP_KERNEL);
+	if (!map->reg_defaults)
+		return -ENOMEM;
+
 	if (!map->reg_defaults_raw) {
 		u32 cache_bypass = map->cache_bypass;
 		dev_warn(map->dev, "No cache defaults, reading back from HW\n");
@@ -43,33 +60,21 @@ static int regcache_hw_init(struct regmap *map)
 		/* Bypass the cache access till data read from HW*/
 		map->cache_bypass = 1;
 		tmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);
-		if (!tmp_buf)
-			return -ENOMEM;
+		if (!tmp_buf) {
+			ret = -ENOMEM;
+			goto err_free;
+		}
 		ret = regmap_raw_read(map, 0, tmp_buf,
 				      map->num_reg_defaults_raw);
 		map->cache_bypass = cache_bypass;
-		if (ret < 0) {
-			kfree(tmp_buf);
-			return ret;
-		}
+		if (ret < 0)
+			goto err_cache_free;
+
 		map->reg_defaults_raw = tmp_buf;
 		map->cache_free = 1;
 	}
 
-	/* calculate the size of reg_defaults */
-	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++)
-		if (!regmap_volatile(map, i * map->reg_stride))
-			count++;
-
-	map->reg_defaults = kmalloc_array(count, sizeof(struct reg_default),
-					  GFP_KERNEL);
-	if (!map->reg_defaults) {
-		ret = -ENOMEM;
-		goto err_free;
-	}
-
 	/* fill the reg_defaults */
-	map->num_reg_defaults = count;
 	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
 		if (regmap_volatile(map, i * map->reg_stride))
 			continue;
@@ -81,9 +86,10 @@ static int regcache_hw_init(struct regmap *map)
 
 	return 0;
 
+err_cache_free:
+	kfree(tmp_buf);
 err_free:
-	if (map->cache_free)
-		kfree(map->reg_defaults_raw);
+	kfree(map->reg_defaults);
 
 	return ret;
 }
@@ -147,6 +153,8 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 		ret = regcache_hw_init(map);
 		if (ret < 0)
 			return ret;
+		if (map->cache_bypass)
+			return 0;
 	}
 
 	if (!map->max_register)

commit 06f9c24e55075e50ebc8b249a7853ad31bc1b3d1
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Oct 9 17:02:56 2014 +0800

    regmap: cache: use kmalloc_array instead of kmalloc
    
    This patch fixes checkpatch.pl warning for regmap cache.
    WARNING : prefer kmalloc_array over kmalloc with multiply
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 0852c890b4b5..726d956f6a29 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -61,8 +61,8 @@ static int regcache_hw_init(struct regmap *map)
 		if (!regmap_volatile(map, i * map->reg_stride))
 			count++;
 
-	map->reg_defaults = kmalloc(count * sizeof(struct reg_default),
-				      GFP_KERNEL);
+	map->reg_defaults = kmalloc_array(count, sizeof(struct reg_default),
+					  GFP_KERNEL);
 	if (!map->reg_defaults) {
 		ret = -ENOMEM;
 		goto err_free;

commit fbba43c527d851088a891ed83346d5cc9f095b64
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Oct 9 17:02:55 2014 +0800

    regmap: cache: speed regcache_hw_init() up.
    
    This may speed regcache_hw_init() up for some cases that there
    has volatile registers.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 6bec659e35d9..0852c890b4b5 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -71,9 +71,9 @@ static int regcache_hw_init(struct regmap *map)
 	/* fill the reg_defaults */
 	map->num_reg_defaults = count;
 	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
-		val = regcache_get_val(map, map->reg_defaults_raw, i);
 		if (regmap_volatile(map, i * map->reg_stride))
 			continue;
+		val = regcache_get_val(map, map->reg_defaults_raw, i);
 		map->reg_defaults[j].reg = i * map->reg_stride;
 		map->reg_defaults[j].def = val;
 		j++;

commit ba3f1c85a6e05e0ff90215d817249617fcbee523
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Oct 9 17:02:54 2014 +0800

    regmap: cache: fix errno in regcache_hw_init()
    
    When kmalloc() fails, we should return -ENOMEM.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 7558e6b01c04..6bec659e35d9 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -44,7 +44,7 @@ static int regcache_hw_init(struct regmap *map)
 		map->cache_bypass = 1;
 		tmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);
 		if (!tmp_buf)
-			return -EINVAL;
+			return -ENOMEM;
 		ret = regmap_raw_read(map, 0, tmp_buf,
 				      map->num_reg_defaults_raw);
 		map->cache_bypass = cache_bypass;

commit 5bd83ed0984b0b0ac51d648b0ec167b36291f87e
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Oct 9 17:02:53 2014 +0800

    regmap: cache: cleanup regcache_hw_init()
    
    Remove the redundant code for regmap cache.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f1280dc356d0..7558e6b01c04 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -57,12 +57,9 @@ static int regcache_hw_init(struct regmap *map)
 	}
 
 	/* calculate the size of reg_defaults */
-	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {
-		val = regcache_get_val(map, map->reg_defaults_raw, i);
-		if (regmap_volatile(map, i * map->reg_stride))
-			continue;
-		count++;
-	}
+	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++)
+		if (!regmap_volatile(map, i * map->reg_stride))
+			count++;
 
 	map->reg_defaults = kmalloc(count * sizeof(struct reg_default),
 				      GFP_KERNEL);

commit f5b313a2bcd4c436560c044c726d9ad84a3e4bb3
Merge: 45942c310da8 f29a43206ae1
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 29 20:49:42 2014 +0100

    Merge remote-tracking branch 'regmap/topic/cache' into regmap-next

commit f29a43206ae1adfadbb344f5ef9bc200784f9d61
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Sep 16 14:04:14 2014 +0300

    regmap: cache: Do not fail silently from regcache_sync calls
    
    Call stack of regcache_sync calls may not emit any error message even if
    operation was cancelled due an error in I/O driver. One such a silent error
    is for instance if I2C bus driver doesn't receive ACK from the I2C device
    and returns -EREMOTEIO.
    
    Since many users of regcache_sync() don't check and print the error there is
    no any indication that HW registers are potentially out of sync.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 29b4128da0b0..da7b3bfd4d7f 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -269,8 +269,11 @@ static int regcache_default_sync(struct regmap *map, unsigned int min,
 		map->cache_bypass = 1;
 		ret = _regmap_write(map, reg, val);
 		map->cache_bypass = 0;
-		if (ret)
+		if (ret) {
+			dev_err(map->dev, "Unable to sync register %#x. %d\n",
+				reg, ret);
 			return ret;
+		}
 		dev_dbg(map->dev, "Synced register %#x, value %#x\n", reg, val);
 	}
 
@@ -615,8 +618,11 @@ static int regcache_sync_block_single(struct regmap *map, void *block,
 		ret = _regmap_write(map, regtmp, val);
 
 		map->cache_bypass = 0;
-		if (ret != 0)
+		if (ret != 0) {
+			dev_err(map->dev, "Unable to sync register %#x. %d\n",
+				regtmp, ret);
 			return ret;
+		}
 		dev_dbg(map->dev, "Synced register %#x, value %#x\n",
 			regtmp, val);
 	}
@@ -641,6 +647,9 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 	map->cache_bypass = 1;
 
 	ret = _regmap_raw_write(map, base, *data, count * val_bytes);
+	if (ret)
+		dev_err(map->dev, "Unable to sync registers %#x-%#x. %d\n",
+			base, cur - map->reg_stride, ret);
 
 	map->cache_bypass = 0;
 

commit 5c1ebe7f73f9166893c3459915db8a09d6d1d715
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Aug 27 13:09:12 2014 +0100

    regmap: Don't attempt block writes when syncing cache on single_rw devices
    
    If the device can't support block writes then don't attempt to use raw
    syncing which will automatically generate block writes for adjacent
    registers, use the existing _single() block syncing implementation.
    
    Reported-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 29b4128da0b0..5617da6dc898 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -698,7 +698,7 @@ int regcache_sync_block(struct regmap *map, void *block,
 			unsigned int block_base, unsigned int start,
 			unsigned int end)
 {
-	if (regmap_can_raw_write(map))
+	if (regmap_can_raw_write(map) && !map->use_single_rw)
 		return regcache_sync_block_raw(map, block, cache_present,
 					       block_base, start, end);
 	else

commit 6012b1f3424c4dc36369697845a9ca699887b0c7
Merge: b3bf36cb6a97 83f8475ce99f 72a6a5df2c6c 4999e9621a58 451485ba6bfb 6cfec04bcc05 13ff50c85846 e894c3f46c30
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Mar 28 11:50:43 2014 +0000

    Merge remote-tracking branches 'regmap/topic/cache', 'regmap/topic/irq', 'regmap/topic/lock', 'regmap/topic/mmio', 'regmap/topic/nodev', 'regmap/topic/parse-val' and 'regmap/topic/patch' into regmap-next

commit 83f8475ce99fa1c44b03059b6cc5dcaae69b4819
Author: Dylan Reid <dgreid@chromium.org>
Date:   Tue Mar 18 13:45:09 2014 -0700

    regmap: cache: Don't attempt to sync non-writeable registers
    
    In the regcache_default_sync, if a register isn't writeable, then
    _regmap_write will return an error and the rest of the sync will be
    aborted.  Avoid this by checking if a register is writeable before
    trying to sync it.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index bb3ba42e0329..a9d8d7be6aa3 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -253,7 +253,8 @@ static int regcache_default_sync(struct regmap *map, unsigned int min,
 		unsigned int val;
 		int ret;
 
-		if (regmap_volatile(map, reg))
+		if (regmap_volatile(map, reg) ||
+		    !regmap_writeable(map, reg))
 			continue;
 
 		ret = regcache_read(map, reg, &val);

commit 756173285e87c792c6fa8eaaaf1217cfcf1416dd
Author: Dylan Reid <dgreid@chromium.org>
Date:   Tue Mar 18 13:45:08 2014 -0700

    regmap: cache: Step by stride in default sync
    
    The default sync operation was still assuming a stride of one, fix it
    to respect the reg_stride set in the map.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index d4dd77134814..bb3ba42e0329 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -249,7 +249,7 @@ static int regcache_default_sync(struct regmap *map, unsigned int min,
 {
 	unsigned int reg;
 
-	for (reg = min; reg <= max; reg++) {
+	for (reg = min; reg <= max; reg += map->reg_stride) {
 		unsigned int val;
 		int ret;
 

commit 7a7a70b49b51e90593ae072a9402d6615d05e895
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Fri Feb 21 19:37:10 2014 +0000

    regmap: Check stride of register patch as we register it
    
    Currently, we check the registers in the patch are aligned to the
    register stride everytime we sync the cache and the first time the patch
    is written out is unchecked.
    
    This patch checks the register patch when we first register it so the
    first writes are no longer unchecked and then doesn't check on
    subsequent syncs as the patch will be unchanged.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index d4dd77134814..16426aa1457c 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -312,10 +312,6 @@ int regcache_sync(struct regmap *map)
 	/* Apply any patch first */
 	map->cache_bypass = 1;
 	for (i = 0; i < map->patch_regs; i++) {
-		if (map->patch[i].reg % map->reg_stride) {
-			ret = -EINVAL;
-			goto out;
-		}
 		ret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);
 		if (ret != 0) {
 			dev_err(map->dev, "Failed to write %x = %x: %d\n",

commit 78ba73eecd2256790926859849801c0446766c0a
Author: Dylan Reid <dgreid@chromium.org>
Date:   Fri Jan 24 15:40:39 2014 -0800

    regmap: cache: Handle stride > 1 in sync_block_raw_flush
    
    regcache_sync_block_raw_flush takes the address of the base register
    and the address of one past the last register to write to.  "count" is
    the number of registers in the range, not the number of bytes, it
    should be (end addr - start addr) / stride. Without accounting for
    strides greater than one, registers past the end might be synced or
    the writeable_reg callback at the beginning of _regmap_raw_write will
    fail and nothing will be written.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index d4dd77134814..dd56177b7010 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -636,10 +636,10 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 	if (*data == NULL)
 		return 0;
 
-	count = cur - base;
+	count = (cur - base) / map->reg_stride;
 
 	dev_dbg(map->dev, "Writing %zu bytes for %d registers from 0x%x-0x%x\n",
-		count * val_bytes, count, base, cur - 1);
+		count * val_bytes, count, base, cur - map->reg_stride);
 
 	map->cache_bypass = 1;
 

commit affbe886e712437c25b575eac5fde5886bb42aec
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Oct 10 21:06:32 2013 +0100

    regmap: Use async I/O during cache sync
    
    Try to speed up I/O a little by not synchronising until we are finished
    scheduling writes. A brief survey of existing users suggests we have none
    that would currently benefit from an async cache sync.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index a36112af494c..d4dd77134814 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -307,6 +307,8 @@ int regcache_sync(struct regmap *map)
 	if (!map->cache_dirty)
 		goto out;
 
+	map->async = true;
+
 	/* Apply any patch first */
 	map->cache_bypass = 1;
 	for (i = 0; i < map->patch_regs; i++) {
@@ -332,11 +334,15 @@ int regcache_sync(struct regmap *map)
 		map->cache_dirty = false;
 
 out:
-	trace_regcache_sync(map->dev, name, "stop");
 	/* Restore the bypass state */
+	map->async = false;
 	map->cache_bypass = bypass;
 	map->unlock(map->lock_arg);
 
+	regmap_async_complete(map);
+
+	trace_regcache_sync(map->dev, name, "stop");
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regcache_sync);
@@ -375,17 +381,23 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 	if (!map->cache_dirty)
 		goto out;
 
+	map->async = true;
+
 	if (map->cache_ops->sync)
 		ret = map->cache_ops->sync(map, min, max);
 	else
 		ret = regcache_default_sync(map, min, max);
 
 out:
-	trace_regcache_sync(map->dev, name, "stop region");
 	/* Restore the bypass state */
 	map->cache_bypass = bypass;
+	map->async = false;
 	map->unlock(map->lock_arg);
 
+	regmap_async_complete(map);
+
+	trace_regcache_sync(map->dev, name, "stop region");
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regcache_sync_region);

commit 0a8198094da895c8d5db95812fe9de7027d808e4
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Oct 9 12:28:52 2013 +0100

    regmap: Simplify the initiation of async I/O
    
    Rather than passing a flag around through the entire call stack store it
    in the regmap struct and read it when required. This minimises the
    visibility of the feature through the API, minimising the code updates
    needed to use it more widely.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index d6c2d691b6e8..a36112af494c 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -631,8 +631,7 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 
 	map->cache_bypass = 1;
 
-	ret = _regmap_raw_write(map, base, *data, count * val_bytes,
-				false);
+	ret = _regmap_raw_write(map, base, *data, count * val_bytes);
 
 	map->cache_bypass = 0;
 

commit 3f4ff561bc88b074d5e868dde4012d89cbb06c87
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Aug 29 10:26:34 2013 +0200

    regmap: rbtree: Make cache_present bitmap per node
    
    With devices which have a dense and small register map but placed at a large
    offset the global cache_present bitmap imposes a huge memory overhead. Making
    the cache_present per rbtree node avoids the issue and easily reduces the memory
    footprint by a factor of ten. For devices with a more sparse map or without a
    large base register offset the memory usage might increase slightly by a few
    bytes, but not significantly. E.g. for a device which has ~50 registers at
    offset 0x4000 the memory footprint of the register cache goes down form 2496
    bytes to 175 bytes.
    
    Moving the bitmap to a per node basis means that the handling of the bitmap is
    now cache implementation specific and can no longer be managed by the core. The
    regcache_sync_block() function is extended by a additional parameter so that the
    cache implementation can tell the core which registers in the block are set and
    which are not. The parameter is optional and if NULL the core assumes that all
    registers are set. The rbtree cache also needs to implement its own drop
    callback instead of relying on the core to handle this.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index e2abd0548e7b..d6c2d691b6e8 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -121,8 +121,6 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	map->reg_defaults_raw = config->reg_defaults_raw;
 	map->cache_word_size = DIV_ROUND_UP(config->val_bits, 8);
 	map->cache_size_raw = map->cache_word_size * config->num_reg_defaults_raw;
-	map->cache_present = NULL;
-	map->cache_present_nbits = 0;
 
 	map->cache = NULL;
 	map->cache_ops = cache_types[i];
@@ -181,7 +179,6 @@ void regcache_exit(struct regmap *map)
 
 	BUG_ON(!map->cache_ops);
 
-	kfree(map->cache_present);
 	kfree(map->reg_defaults);
 	if (map->cache_free)
 		kfree(map->reg_defaults_raw);
@@ -407,22 +404,16 @@ EXPORT_SYMBOL_GPL(regcache_sync_region);
 int regcache_drop_region(struct regmap *map, unsigned int min,
 			 unsigned int max)
 {
-	unsigned int reg;
 	int ret = 0;
 
-	if (!map->cache_present && !(map->cache_ops && map->cache_ops->drop))
+	if (!map->cache_ops || !map->cache_ops->drop)
 		return -EINVAL;
 
 	map->lock(map->lock_arg);
 
 	trace_regcache_drop_region(map->dev, min, max);
 
-	if (map->cache_present)
-		for (reg = min; reg < max + 1; reg++)
-			clear_bit(reg, map->cache_present);
-
-	if (map->cache_ops && map->cache_ops->drop)
-		ret = map->cache_ops->drop(map, min, max);
+	ret = map->cache_ops->drop(map, min, max);
 
 	map->unlock(map->lock_arg);
 
@@ -490,42 +481,6 @@ void regcache_cache_bypass(struct regmap *map, bool enable)
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);
 
-int regcache_set_reg_present(struct regmap *map, unsigned int reg)
-{
-	unsigned long *cache_present;
-	unsigned int cache_present_size;
-	unsigned int nregs;
-	int i;
-
-	nregs = reg + 1;
-	cache_present_size = BITS_TO_LONGS(nregs);
-	cache_present_size *= sizeof(long);
-
-	if (!map->cache_present) {
-		cache_present = kmalloc(cache_present_size, GFP_KERNEL);
-		if (!cache_present)
-			return -ENOMEM;
-		bitmap_zero(cache_present, nregs);
-		map->cache_present = cache_present;
-		map->cache_present_nbits = nregs;
-	}
-
-	if (nregs > map->cache_present_nbits) {
-		cache_present = krealloc(map->cache_present,
-					 cache_present_size, GFP_KERNEL);
-		if (!cache_present)
-			return -ENOMEM;
-		for (i = 0; i < nregs; i++)
-			if (i >= map->cache_present_nbits)
-				clear_bit(i, cache_present);
-		map->cache_present = cache_present;
-		map->cache_present_nbits = nregs;
-	}
-
-	set_bit(reg, map->cache_present);
-	return 0;
-}
-
 bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
 		      unsigned int val)
 {
@@ -617,7 +572,16 @@ int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 		return -ENOENT;
 }
 
+static bool regcache_reg_present(unsigned long *cache_present, unsigned int idx)
+{
+	if (!cache_present)
+		return true;
+
+	return test_bit(idx, cache_present);
+}
+
 static int regcache_sync_block_single(struct regmap *map, void *block,
+				      unsigned long *cache_present,
 				      unsigned int block_base,
 				      unsigned int start, unsigned int end)
 {
@@ -627,7 +591,7 @@ static int regcache_sync_block_single(struct regmap *map, void *block,
 	for (i = start; i < end; i++) {
 		regtmp = block_base + (i * map->reg_stride);
 
-		if (!regcache_reg_present(map, regtmp))
+		if (!regcache_reg_present(cache_present, i))
 			continue;
 
 		val = regcache_get_val(map, block, i);
@@ -678,6 +642,7 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 }
 
 static int regcache_sync_block_raw(struct regmap *map, void *block,
+			    unsigned long *cache_present,
 			    unsigned int block_base, unsigned int start,
 			    unsigned int end)
 {
@@ -690,7 +655,7 @@ static int regcache_sync_block_raw(struct regmap *map, void *block,
 	for (i = start; i < end; i++) {
 		regtmp = block_base + (i * map->reg_stride);
 
-		if (!regcache_reg_present(map, regtmp)) {
+		if (!regcache_reg_present(cache_present, i)) {
 			ret = regcache_sync_block_raw_flush(map, &data,
 							    base, regtmp);
 			if (ret != 0)
@@ -721,13 +686,14 @@ static int regcache_sync_block_raw(struct regmap *map, void *block,
 }
 
 int regcache_sync_block(struct regmap *map, void *block,
+			unsigned long *cache_present,
 			unsigned int block_base, unsigned int start,
 			unsigned int end)
 {
 	if (regmap_can_raw_write(map))
-		return regcache_sync_block_raw(map, block, block_base,
-					       start, end);
+		return regcache_sync_block_raw(map, block, cache_present,
+					       block_base, start, end);
 	else
-		return regcache_sync_block_single(map, block, block_base,
-						  start, end);
+		return regcache_sync_block_single(map, block, cache_present,
+						  block_base, start, end);
 }

commit 65c180fd95993abc31c8770e014ebedade46b623
Merge: b6752123ccef 515f2261703d
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Aug 29 13:32:36 2013 +0100

    Merge remote-tracking branch 'regmap/topic/cache' into regmap-rbtree

commit 515f2261703d09c6b647a5687b7d657dd5911065
Author: Ionut Nicu <ioan.nicu.ext@nsn.com>
Date:   Fri Aug 9 12:09:20 2013 +0200

    regmap: regcache: allow read-only regs to be cached
    
    The regmap_writeable() check should not be done in
    regcache_write() because this prevents read-only
    registers to be cached. After a read on a read-only
    register its value will not be stored in the cache
    and the next time someone will try to read it the
    value will be read from the bus instead of the
    cache.
    
    Instead the regmap_writeable() check should be done
    in _regmap_write() to prevent callers from writing
    to read-only registers.
    
    Signed-off-by: Ionut Nicu <ioan.nicu.ext@nsn.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index e69102696533..f1aa1bcd36a0 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -241,9 +241,6 @@ int regcache_write(struct regmap *map,
 
 	BUG_ON(!map->cache_ops);
 
-	if (!regmap_writeable(map, reg))
-		return -EIO;
-
 	if (!regmap_volatile(map, reg))
 		return map->cache_ops->write(map, reg, value);
 

commit 2d49b5987561e480bdbd8692b27fc5f49a1e2f0b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Aug 5 11:21:29 2013 +0200

    regmap: cache: Make sure to sync the last register in a block
    
    regcache_sync_block_raw_flush() expects the address of the register after last
    register that needs to be synced as its parameter. But the last call to
    regcache_sync_block_raw_flush() in regcache_sync_block_raw() passes the address
    of the last register in the block. This effectively always skips over the last
    register in a block, even if it needs to be synced. In order to fix it increase
    the address by one register.
    
    The issue was introduced in commit 75a5f89 ("regmap: cache: Write consecutive
    registers in a single block write").
    
    Cc: stable@vger.kernel.org # 3.10+
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index e69102696533..3455f833e473 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -719,7 +719,8 @@ static int regcache_sync_block_raw(struct regmap *map, void *block,
 		}
 	}
 
-	return regcache_sync_block_raw_flush(map, &data, base, regtmp);
+	return regcache_sync_block_raw_flush(map, &data, base, regtmp +
+			map->reg_stride);
 }
 
 int regcache_sync_block(struct regmap *map, void *block,

commit d856fce41b74ecf2004d99f781e44abd7815d7f8
Author: Maarten ter Huurne <maarten@treewalker.org>
Date:   Mon Jun 3 00:15:26 2013 +0200

    regmap: Implemented default cache sync operation
    
    This can be used for cache types for which syncing values one by one is
    equally efficient as syncing a range, such as the flat cache.
    
    Signed-off-by: Maarten ter Huurne <maarten@treewalker.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4bfa219ef37d..e69102696533 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -250,6 +250,38 @@ int regcache_write(struct regmap *map,
 	return 0;
 }
 
+static int regcache_default_sync(struct regmap *map, unsigned int min,
+				 unsigned int max)
+{
+	unsigned int reg;
+
+	for (reg = min; reg <= max; reg++) {
+		unsigned int val;
+		int ret;
+
+		if (regmap_volatile(map, reg))
+			continue;
+
+		ret = regcache_read(map, reg, &val);
+		if (ret)
+			return ret;
+
+		/* Is this the hardware default?  If so skip. */
+		ret = regcache_lookup_reg(map, reg);
+		if (ret >= 0 && val == map->reg_defaults[ret].def)
+			continue;
+
+		map->cache_bypass = 1;
+		ret = _regmap_write(map, reg, val);
+		map->cache_bypass = 0;
+		if (ret)
+			return ret;
+		dev_dbg(map->dev, "Synced register %#x, value %#x\n", reg, val);
+	}
+
+	return 0;
+}
+
 /**
  * regcache_sync: Sync the register cache with the hardware.
  *
@@ -268,7 +300,7 @@ int regcache_sync(struct regmap *map)
 	const char *name;
 	unsigned int bypass;
 
-	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
+	BUG_ON(!map->cache_ops);
 
 	map->lock(map->lock_arg);
 	/* Remember the initial bypass state */
@@ -297,7 +329,10 @@ int regcache_sync(struct regmap *map)
 	}
 	map->cache_bypass = 0;
 
-	ret = map->cache_ops->sync(map, 0, map->max_register);
+	if (map->cache_ops->sync)
+		ret = map->cache_ops->sync(map, 0, map->max_register);
+	else
+		ret = regcache_default_sync(map, 0, map->max_register);
 
 	if (ret == 0)
 		map->cache_dirty = false;
@@ -331,7 +366,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 	const char *name;
 	unsigned int bypass;
 
-	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
+	BUG_ON(!map->cache_ops);
 
 	map->lock(map->lock_arg);
 
@@ -346,7 +381,10 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 	if (!map->cache_dirty)
 		goto out;
 
-	ret = map->cache_ops->sync(map, min, max);
+	if (map->cache_ops->sync)
+		ret = map->cache_ops->sync(map, min, max);
+	else
+		ret = regcache_default_sync(map, min, max);
 
 out:
 	trace_regcache_sync(map->dev, name, "stop region");

commit 81485f5220770c381ac076573642ac44f13723af
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu May 23 15:06:15 2013 +0200

    regmap: regcache: Fixup locking for custom lock callbacks
    
    The parameter passed to the regmap lock/unlock callbacks needs to be
    map->lock_arg, regcache passes just map. This works fine in the case that no
    custom locking callbacks are used, since in this case map->lock_arg equals map,
    but will break when custom locking callbacks are used. The issue was introduced
    in commit 0d4529c5 ("regmap: make lock/unlock functions customizable") and is
    fixed by this patch.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 8a0ab5fa75f5..4bfa219ef37d 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -270,7 +270,7 @@ int regcache_sync(struct regmap *map)
 
 	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
 
-	map->lock(map);
+	map->lock(map->lock_arg);
 	/* Remember the initial bypass state */
 	bypass = map->cache_bypass;
 	dev_dbg(map->dev, "Syncing %s cache\n",
@@ -306,7 +306,7 @@ int regcache_sync(struct regmap *map)
 	trace_regcache_sync(map->dev, name, "stop");
 	/* Restore the bypass state */
 	map->cache_bypass = bypass;
-	map->unlock(map);
+	map->unlock(map->lock_arg);
 
 	return ret;
 }
@@ -333,7 +333,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 
 	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
 
-	map->lock(map);
+	map->lock(map->lock_arg);
 
 	/* Remember the initial bypass state */
 	bypass = map->cache_bypass;
@@ -352,7 +352,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 	trace_regcache_sync(map->dev, name, "stop region");
 	/* Restore the bypass state */
 	map->cache_bypass = bypass;
-	map->unlock(map);
+	map->unlock(map->lock_arg);
 
 	return ret;
 }
@@ -378,7 +378,7 @@ int regcache_drop_region(struct regmap *map, unsigned int min,
 	if (!map->cache_present && !(map->cache_ops && map->cache_ops->drop))
 		return -EINVAL;
 
-	map->lock(map);
+	map->lock(map->lock_arg);
 
 	trace_regcache_drop_region(map->dev, min, max);
 
@@ -389,7 +389,7 @@ int regcache_drop_region(struct regmap *map, unsigned int min,
 	if (map->cache_ops && map->cache_ops->drop)
 		ret = map->cache_ops->drop(map, min, max);
 
-	map->unlock(map);
+	map->unlock(map->lock_arg);
 
 	return ret;
 }
@@ -409,11 +409,11 @@ EXPORT_SYMBOL_GPL(regcache_drop_region);
  */
 void regcache_cache_only(struct regmap *map, bool enable)
 {
-	map->lock(map);
+	map->lock(map->lock_arg);
 	WARN_ON(map->cache_bypass && enable);
 	map->cache_only = enable;
 	trace_regmap_cache_only(map->dev, enable);
-	map->unlock(map);
+	map->unlock(map->lock_arg);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 
@@ -428,9 +428,9 @@ EXPORT_SYMBOL_GPL(regcache_cache_only);
  */
 void regcache_mark_dirty(struct regmap *map)
 {
-	map->lock(map);
+	map->lock(map->lock_arg);
 	map->cache_dirty = true;
-	map->unlock(map);
+	map->unlock(map->lock_arg);
 }
 EXPORT_SYMBOL_GPL(regcache_mark_dirty);
 
@@ -447,11 +447,11 @@ EXPORT_SYMBOL_GPL(regcache_mark_dirty);
  */
 void regcache_cache_bypass(struct regmap *map, bool enable)
 {
-	map->lock(map);
+	map->lock(map->lock_arg);
 	WARN_ON(map->cache_only && enable);
 	map->cache_bypass = enable;
 	trace_regmap_cache_bypass(map->dev, enable);
-	map->unlock(map);
+	map->unlock(map->lock_arg);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);
 

commit 697e85bc6a9aa44ecd73392586fe9cfd7e0467ba
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed May 8 13:55:22 2013 +0100

    regmap: Add support for discarding parts of the register cache
    
    Allow drivers to discard parts of the register cache, for example if part
    of the hardware has been reset.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 75923f2396bd..8a0ab5fa75f5 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -358,6 +358,43 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 }
 EXPORT_SYMBOL_GPL(regcache_sync_region);
 
+/**
+ * regcache_drop_region: Discard part of the register cache
+ *
+ * @map: map to operate on
+ * @min: first register to discard
+ * @max: last register to discard
+ *
+ * Discard part of the register cache.
+ *
+ * Return a negative value on failure, 0 on success.
+ */
+int regcache_drop_region(struct regmap *map, unsigned int min,
+			 unsigned int max)
+{
+	unsigned int reg;
+	int ret = 0;
+
+	if (!map->cache_present && !(map->cache_ops && map->cache_ops->drop))
+		return -EINVAL;
+
+	map->lock(map);
+
+	trace_regcache_drop_region(map->dev, min, max);
+
+	if (map->cache_present)
+		for (reg = min; reg < max + 1; reg++)
+			clear_bit(reg, map->cache_present);
+
+	if (map->cache_ops && map->cache_ops->drop)
+		ret = map->cache_ops->drop(map, min, max);
+
+	map->unlock(map);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regcache_drop_region);
+
 /**
  * regcache_cache_only: Put a register map into cache only mode
  *

commit 9659293c1784f3d9df2235f6ebf92f6f9059a563
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Thu Apr 4 19:40:45 2013 +0300

    regmap: cache: Fix format specifier in dev_dbg
    
    Fix format specifier in dev_dbg and suppress the following warning
    
    drivers/base/regmap/regcache.c: In function
    regcache_sync_block_raw_flush:
    drivers/base/regmap/regcache.c:593:2: warning: format %d expects
    argument of type int, but argument 4 has type size_t [-Wformat]
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 3ae8d9bafe68..75923f2396bd 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -590,7 +590,7 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 
 	count = cur - base;
 
-	dev_dbg(map->dev, "Writing %d bytes for %d registers from 0x%x-0x%x\n",
+	dev_dbg(map->dev, "Writing %zu bytes for %d registers from 0x%x-0x%x\n",
 		count * val_bytes, count, base, cur - 1);
 
 	map->cache_bypass = 1;

commit f52687afb87cfb2d26699d7f84088c2b04adde50
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Apr 4 14:36:18 2013 +0530

    regmap: cache: Make regcache_sync_block_raw static
    
    regcache_sync_block_raw is used only in this file. Hence make it static.
    Silences the following warning:
    drivers/base/regmap/regcache.c:608:5: warning:
    symbol 'regcache_sync_block_raw' was not declared. Should it be static?
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index d81f60576e02..3ae8d9bafe68 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -605,7 +605,7 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 	return ret;
 }
 
-int regcache_sync_block_raw(struct regmap *map, void *block,
+static int regcache_sync_block_raw(struct regmap *map, void *block,
 			    unsigned int block_base, unsigned int start,
 			    unsigned int end)
 {

commit 75a5f89f635c2b7cd1f94fcaef5f764d480c8481
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Mar 29 20:50:07 2013 +0000

    regmap: cache: Write consecutive registers in a single block write
    
    When syncing blocks of data using raw writes combine the writes into a
    single block write, saving us bus overhead for setup, addressing and
    teardown.
    
    Currently the block write is done unconditionally as it is expected that
    hardware which has a register format which can support raw writes will
    support auto incrementing writes, this decision may need to be revised in
    future.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index da4d9843520f..d81f60576e02 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -579,42 +579,72 @@ static int regcache_sync_block_single(struct regmap *map, void *block,
 	return 0;
 }
 
+static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
+					 unsigned int base, unsigned int cur)
+{
+	size_t val_bytes = map->format.val_bytes;
+	int ret, count;
+
+	if (*data == NULL)
+		return 0;
+
+	count = cur - base;
+
+	dev_dbg(map->dev, "Writing %d bytes for %d registers from 0x%x-0x%x\n",
+		count * val_bytes, count, base, cur - 1);
+
+	map->cache_bypass = 1;
+
+	ret = _regmap_raw_write(map, base, *data, count * val_bytes,
+				false);
+
+	map->cache_bypass = 0;
+
+	*data = NULL;
+
+	return ret;
+}
+
 int regcache_sync_block_raw(struct regmap *map, void *block,
 			    unsigned int block_base, unsigned int start,
 			    unsigned int end)
 {
-	unsigned int i, regtmp, val;
-	const void *addr;
+	unsigned int i, val;
+	unsigned int regtmp = 0;
+	unsigned int base = 0;
+	const void *data = NULL;
 	int ret;
 
 	for (i = start; i < end; i++) {
 		regtmp = block_base + (i * map->reg_stride);
 
-		if (!regcache_reg_present(map, regtmp))
+		if (!regcache_reg_present(map, regtmp)) {
+			ret = regcache_sync_block_raw_flush(map, &data,
+							    base, regtmp);
+			if (ret != 0)
+				return ret;
 			continue;
+		}
 
 		val = regcache_get_val(map, block, i);
 
 		/* Is this the hardware default?  If so skip. */
 		ret = regcache_lookup_reg(map, regtmp);
-		if (ret >= 0 && val == map->reg_defaults[ret].def)
+		if (ret >= 0 && val == map->reg_defaults[ret].def) {
+			ret = regcache_sync_block_raw_flush(map, &data,
+							    base, regtmp);
+			if (ret != 0)
+				return ret;
 			continue;
+		}
 
-		map->cache_bypass = 1;
-
-		addr = regcache_get_val_addr(map, block, i);
-		ret = _regmap_raw_write(map, regtmp, addr,
-					map->format.val_bytes,
-					false);
-
-		map->cache_bypass = 0;
-		if (ret != 0)
-			return ret;
-		dev_dbg(map->dev, "Synced register %#x, value %#x\n",
-			regtmp, val);
+		if (!data) {
+			data = regcache_get_val_addr(map, block, i);
+			base = regtmp;
+		}
 	}
 
-	return 0;
+	return regcache_sync_block_raw_flush(map, &data, base, regtmp);
 }
 
 int regcache_sync_block(struct regmap *map, void *block,

commit cfdeb8c37ed32024dcb7d2e3bd70e2a9f9dfc0e6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Mar 29 20:12:21 2013 +0000

    regmap: cache: Split raw and non-raw syncs
    
    For code clarity after implementing block writes split out the raw and
    non-raw I/O sync implementations.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index bb317db6818f..da4d9843520f 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -545,9 +545,43 @@ int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 		return -ENOENT;
 }
 
-int regcache_sync_block(struct regmap *map, void *block,
-			unsigned int block_base, unsigned int start,
-			unsigned int end)
+static int regcache_sync_block_single(struct regmap *map, void *block,
+				      unsigned int block_base,
+				      unsigned int start, unsigned int end)
+{
+	unsigned int i, regtmp, val;
+	int ret;
+
+	for (i = start; i < end; i++) {
+		regtmp = block_base + (i * map->reg_stride);
+
+		if (!regcache_reg_present(map, regtmp))
+			continue;
+
+		val = regcache_get_val(map, block, i);
+
+		/* Is this the hardware default?  If so skip. */
+		ret = regcache_lookup_reg(map, regtmp);
+		if (ret >= 0 && val == map->reg_defaults[ret].def)
+			continue;
+
+		map->cache_bypass = 1;
+
+		ret = _regmap_write(map, regtmp, val);
+
+		map->cache_bypass = 0;
+		if (ret != 0)
+			return ret;
+		dev_dbg(map->dev, "Synced register %#x, value %#x\n",
+			regtmp, val);
+	}
+
+	return 0;
+}
+
+int regcache_sync_block_raw(struct regmap *map, void *block,
+			    unsigned int block_base, unsigned int start,
+			    unsigned int end)
 {
 	unsigned int i, regtmp, val;
 	const void *addr;
@@ -568,14 +602,10 @@ int regcache_sync_block(struct regmap *map, void *block,
 
 		map->cache_bypass = 1;
 
-		if (regmap_can_raw_write(map)) {
-			addr = regcache_get_val_addr(map, block, i);
-			ret = _regmap_raw_write(map, regtmp, addr,
-						map->format.val_bytes,
-						false);
-		} else {
-			ret = _regmap_write(map, regtmp, val);
-		}
+		addr = regcache_get_val_addr(map, block, i);
+		ret = _regmap_raw_write(map, regtmp, addr,
+					map->format.val_bytes,
+					false);
 
 		map->cache_bypass = 0;
 		if (ret != 0)
@@ -586,3 +616,15 @@ int regcache_sync_block(struct regmap *map, void *block,
 
 	return 0;
 }
+
+int regcache_sync_block(struct regmap *map, void *block,
+			unsigned int block_base, unsigned int start,
+			unsigned int end)
+{
+	if (regmap_can_raw_write(map))
+		return regcache_sync_block_raw(map, block, block_base,
+					       start, end);
+	else
+		return regcache_sync_block_single(map, block, block_base,
+						  start, end);
+}

commit f8bd822cbf953299b2957b45f6a43c08e7931ddc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Mar 29 19:32:28 2013 +0000

    regmap: cache: Factor out block sync
    
    The idea of holding blocks of registers in device format is shared between
    at least rbtree and lzo cache formats so split out the loop that does the
    sync from the rbtree code so optimisations on it can be reused.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 0fedf4fa0116..bb317db6818f 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -544,3 +544,45 @@ int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 	else
 		return -ENOENT;
 }
+
+int regcache_sync_block(struct regmap *map, void *block,
+			unsigned int block_base, unsigned int start,
+			unsigned int end)
+{
+	unsigned int i, regtmp, val;
+	const void *addr;
+	int ret;
+
+	for (i = start; i < end; i++) {
+		regtmp = block_base + (i * map->reg_stride);
+
+		if (!regcache_reg_present(map, regtmp))
+			continue;
+
+		val = regcache_get_val(map, block, i);
+
+		/* Is this the hardware default?  If so skip. */
+		ret = regcache_lookup_reg(map, regtmp);
+		if (ret >= 0 && val == map->reg_defaults[ret].def)
+			continue;
+
+		map->cache_bypass = 1;
+
+		if (regmap_can_raw_write(map)) {
+			addr = regcache_get_val_addr(map, block, i);
+			ret = _regmap_raw_write(map, regtmp, addr,
+						map->format.val_bytes,
+						false);
+		} else {
+			ret = _regmap_write(map, regtmp, val);
+		}
+
+		map->cache_bypass = 0;
+		if (ret != 0)
+			return ret;
+		dev_dbg(map->dev, "Synced register %#x, value %#x\n",
+			regtmp, val);
+	}
+
+	return 0;
+}

commit 78493f2d7b51d6f6d03982cee559c62dfab4c292
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Mar 29 19:18:59 2013 +0000

    regmap: cache: Factor out reg_present support from rbtree cache
    
    The idea of maintaining a bitmap of present registers is something that
    can usefully be used by other cache types that maintain blocks of cached
    registers so move the code out of the rbtree cache and into the generic
    regcache code.
    
    Refactor the interface slightly as we go to wrap the set bit and enlarge
    bitmap operations (since we never do one without the other) and make it
    more robust for reads of uncached registers by bounds checking before we
    look at the bitmap.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 229c804e409e..0fedf4fa0116 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -121,6 +121,8 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	map->reg_defaults_raw = config->reg_defaults_raw;
 	map->cache_word_size = DIV_ROUND_UP(config->val_bits, 8);
 	map->cache_size_raw = map->cache_word_size * config->num_reg_defaults_raw;
+	map->cache_present = NULL;
+	map->cache_present_nbits = 0;
 
 	map->cache = NULL;
 	map->cache_ops = cache_types[i];
@@ -179,6 +181,7 @@ void regcache_exit(struct regmap *map)
 
 	BUG_ON(!map->cache_ops);
 
+	kfree(map->cache_present);
 	kfree(map->reg_defaults);
 	if (map->cache_free)
 		kfree(map->reg_defaults_raw);
@@ -415,6 +418,42 @@ void regcache_cache_bypass(struct regmap *map, bool enable)
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);
 
+int regcache_set_reg_present(struct regmap *map, unsigned int reg)
+{
+	unsigned long *cache_present;
+	unsigned int cache_present_size;
+	unsigned int nregs;
+	int i;
+
+	nregs = reg + 1;
+	cache_present_size = BITS_TO_LONGS(nregs);
+	cache_present_size *= sizeof(long);
+
+	if (!map->cache_present) {
+		cache_present = kmalloc(cache_present_size, GFP_KERNEL);
+		if (!cache_present)
+			return -ENOMEM;
+		bitmap_zero(cache_present, nregs);
+		map->cache_present = cache_present;
+		map->cache_present_nbits = nregs;
+	}
+
+	if (nregs > map->cache_present_nbits) {
+		cache_present = krealloc(map->cache_present,
+					 cache_present_size, GFP_KERNEL);
+		if (!cache_present)
+			return -ENOMEM;
+		for (i = 0; i < nregs; i++)
+			if (i >= map->cache_present_nbits)
+				clear_bit(i, cache_present);
+		map->cache_present = cache_present;
+		map->cache_present_nbits = nregs;
+	}
+
+	set_bit(reg, map->cache_present);
+	return 0;
+}
+
 bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
 		      unsigned int val)
 {

commit 8817796b75c8847d63d6d4523c79c24b47748a05
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 13 19:29:36 2013 +0000

    regmap: cache: Provide a get address of value operation
    
    Provide a helper to do the size based index into a block of registers and
    use it when reading a value.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 0f4fb8bc37e5..229c804e409e 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -458,8 +458,8 @@ unsigned int regcache_get_val(struct regmap *map, const void *base,
 
 	/* Use device native format if possible */
 	if (map->format.parse_val)
-		return map->format.parse_val(base +
-					     (map->cache_word_size * idx));
+		return map->format.parse_val(regcache_get_val_addr(map, base,
+								   idx));
 
 	switch (map->cache_word_size) {
 	case 1: {

commit eb4cb76ff00e27858e5c80f69dbe8cc15364578c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 21 18:39:47 2013 +0000

    regmap: cache: Store caches in native register format where possible
    
    This allows the cached data to be sent directly to the device when
    we sync it.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 6948996d2498..0f4fb8bc37e5 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -45,8 +45,8 @@ static int regcache_hw_init(struct regmap *map)
 		tmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);
 		if (!tmp_buf)
 			return -EINVAL;
-		ret = regmap_bulk_read(map, 0, tmp_buf,
-				       map->num_reg_defaults_raw);
+		ret = regmap_raw_read(map, 0, tmp_buf,
+				      map->num_reg_defaults_raw);
 		map->cache_bypass = cache_bypass;
 		if (ret < 0) {
 			kfree(tmp_buf);
@@ -421,6 +421,13 @@ bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
 	if (regcache_get_val(map, base, idx) == val)
 		return true;
 
+	/* Use device native format if possible */
+	if (map->format.format_val) {
+		map->format.format_val(base + (map->cache_word_size * idx),
+				       val, 0);
+		return false;
+	}
+
 	switch (map->cache_word_size) {
 	case 1: {
 		u8 *cache = base;
@@ -449,6 +456,11 @@ unsigned int regcache_get_val(struct regmap *map, const void *base,
 	if (!base)
 		return -EINVAL;
 
+	/* Use device native format if possible */
+	if (map->format.parse_val)
+		return map->format.parse_val(base +
+					     (map->cache_word_size * idx));
+
 	switch (map->cache_word_size) {
 	case 1: {
 		const u8 *cache = base;

commit 325acab447f775bc2258b3a37a780893c203ab6c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 21 18:07:01 2013 +0000

    regmap: cache: Use regcache_get_value() to check if we updated
    
    Factor things out a little.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f0a3db6ff9c2..6948996d2498 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -418,25 +418,22 @@ EXPORT_SYMBOL_GPL(regcache_cache_bypass);
 bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
 		      unsigned int val)
 {
+	if (regcache_get_val(map, base, idx) == val)
+		return true;
+
 	switch (map->cache_word_size) {
 	case 1: {
 		u8 *cache = base;
-		if (cache[idx] == val)
-			return true;
 		cache[idx] = val;
 		break;
 	}
 	case 2: {
 		u16 *cache = base;
-		if (cache[idx] == val)
-			return true;
 		cache[idx] = val;
 		break;
 	}
 	case 4: {
 		u32 *cache = base;
-		if (cache[idx] == val)
-			return true;
 		cache[idx] = val;
 		break;
 	}

commit 879082c9fe6e8fbddf787170eee605e4be138d0f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 21 18:03:13 2013 +0000

    regmap: cache: Pass the map rather than the word size when updating values
    
    It's more idiomatic to pass the map structure around and this means we
    can use other bits of information from the map.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index e69ff3e4742c..f0a3db6ff9c2 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -58,8 +58,7 @@ static int regcache_hw_init(struct regmap *map)
 
 	/* calculate the size of reg_defaults */
 	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {
-		val = regcache_get_val(map->reg_defaults_raw,
-				       i, map->cache_word_size);
+		val = regcache_get_val(map, map->reg_defaults_raw, i);
 		if (regmap_volatile(map, i * map->reg_stride))
 			continue;
 		count++;
@@ -75,8 +74,7 @@ static int regcache_hw_init(struct regmap *map)
 	/* fill the reg_defaults */
 	map->num_reg_defaults = count;
 	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
-		val = regcache_get_val(map->reg_defaults_raw,
-				       i, map->cache_word_size);
+		val = regcache_get_val(map, map->reg_defaults_raw, i);
 		if (regmap_volatile(map, i * map->reg_stride))
 			continue;
 		map->reg_defaults[j].reg = i * map->reg_stride;
@@ -417,10 +415,10 @@ void regcache_cache_bypass(struct regmap *map, bool enable)
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);
 
-bool regcache_set_val(void *base, unsigned int idx,
-		      unsigned int val, unsigned int word_size)
+bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
+		      unsigned int val)
 {
-	switch (word_size) {
+	switch (map->cache_word_size) {
 	case 1: {
 		u8 *cache = base;
 		if (cache[idx] == val)
@@ -448,13 +446,13 @@ bool regcache_set_val(void *base, unsigned int idx,
 	return false;
 }
 
-unsigned int regcache_get_val(const void *base, unsigned int idx,
-			      unsigned int word_size)
+unsigned int regcache_get_val(struct regmap *map, const void *base,
+			      unsigned int idx)
 {
 	if (!base)
 		return -EINVAL;
 
-	switch (word_size) {
+	switch (map->cache_word_size) {
 	case 1: {
 		const u8 *cache = base;
 		return cache[idx];

commit 2ac902ce17f9dfa0d4d1f0818be147b5d2515fb7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 19 14:51:55 2012 +0000

    regmap: flat: Add flat cache type
    
    While for I2C and SPI devices the overhead of using rbtree for devices with
    only one block of registers is negligible the same isn't always going to
    be true for MMIO devices where the I/O costs are very much lower. Cater
    for these devices by adding a simple flat array type for them where the
    lookups are simple array accesses, taking us right back to the original
    ASoC cache implementation.
    
    Thanks to Magnus Damm for the discussion which prompted this.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 835883bda977..e69ff3e4742c 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -22,6 +22,7 @@
 static const struct regcache_ops *cache_types[] = {
 	&regcache_rbtree_ops,
 	&regcache_lzo_ops,
+	&regcache_flat_ops,
 };
 
 static int regcache_hw_init(struct regmap *map)

commit f01ee60fffa4dc6c77122121233a793f7f696e67
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Apr 9 13:40:24 2012 -0600

    regmap: implement register striding
    
    regmap_config.reg_stride is introduced. All extant register addresses
    are a multiple of this value. Users of serial-oriented regmap busses will
    typically set this to 1. Users of the MMIO regmap bus will typically set
    this based on the value size of their registers, in bytes, so 4 for a
    32-bit register.
    
    Throughout the regmap code, actual register addresses are used. Wherever
    the register address is used to index some array of values, the address
    is divided by the stride to determine the index, or vice-versa. Error-
    checking is added to all entry-points for register address data to ensure
    that register addresses actually satisfy the specified stride. The MMIO
    bus ensures that the specified stride is large enough for the register
    size.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index d4368e8b6f9d..835883bda977 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -59,7 +59,7 @@ static int regcache_hw_init(struct regmap *map)
 	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {
 		val = regcache_get_val(map->reg_defaults_raw,
 				       i, map->cache_word_size);
-		if (regmap_volatile(map, i))
+		if (regmap_volatile(map, i * map->reg_stride))
 			continue;
 		count++;
 	}
@@ -76,9 +76,9 @@ static int regcache_hw_init(struct regmap *map)
 	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
 		val = regcache_get_val(map->reg_defaults_raw,
 				       i, map->cache_word_size);
-		if (regmap_volatile(map, i))
+		if (regmap_volatile(map, i * map->reg_stride))
 			continue;
-		map->reg_defaults[j].reg = i;
+		map->reg_defaults[j].reg = i * map->reg_stride;
 		map->reg_defaults[j].def = val;
 		j++;
 	}
@@ -98,6 +98,10 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	int i;
 	void *tmp_buf;
 
+	for (i = 0; i < config->num_reg_defaults; i++)
+		if (config->reg_defaults[i].reg % map->reg_stride)
+			return -EINVAL;
+
 	if (map->cache_type == REGCACHE_NONE) {
 		map->cache_bypass = true;
 		return 0;
@@ -278,6 +282,10 @@ int regcache_sync(struct regmap *map)
 	/* Apply any patch first */
 	map->cache_bypass = 1;
 	for (i = 0; i < map->patch_regs; i++) {
+		if (map->patch[i].reg % map->reg_stride) {
+			ret = -EINVAL;
+			goto out;
+		}
 		ret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);
 		if (ret != 0) {
 			dev_err(map->dev, "Failed to write %x = %x: %d\n",

commit c0cc6fe1d09e3f1baecbdf8922473c8e7d3a5317
Merge: 0034102808e0 d939fb9a78b4 851960ba7cb3 abec95adefae
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 10 11:01:07 2012 +0100

    Merge branches 'regmap-core', 'regmap-mmio' and 'regmap-naming' into regmap-stride

commit bacdbe077342ecc9e7b3e374cc5a41995116706a
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Apr 4 15:48:28 2012 -0600

    regmap: introduce fast_io busses, and use a spinlock for them
    
    Some bus types have very fast IO. For these, acquiring a mutex for every
    IO operation is a significant overhead. Allow busses to indicate their IO
    is fast, and enhance regmap to use a spinlock for those busses.
    
    [Currently limited to native endian registers -- broonie]
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 87f54dbf601b..4ad18505e9ae 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -264,7 +264,7 @@ int regcache_sync(struct regmap *map)
 
 	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
 
-	mutex_lock(&map->lock);
+	map->lock(map);
 	/* Remember the initial bypass state */
 	bypass = map->cache_bypass;
 	dev_dbg(map->dev, "Syncing %s cache\n",
@@ -296,7 +296,7 @@ int regcache_sync(struct regmap *map)
 	trace_regcache_sync(map->dev, name, "stop");
 	/* Restore the bypass state */
 	map->cache_bypass = bypass;
-	mutex_unlock(&map->lock);
+	map->unlock(map);
 
 	return ret;
 }
@@ -323,7 +323,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 
 	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
 
-	mutex_lock(&map->lock);
+	map->lock(map);
 
 	/* Remember the initial bypass state */
 	bypass = map->cache_bypass;
@@ -342,7 +342,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 	trace_regcache_sync(map->dev, name, "stop region");
 	/* Restore the bypass state */
 	map->cache_bypass = bypass;
-	mutex_unlock(&map->lock);
+	map->unlock(map);
 
 	return ret;
 }
@@ -361,11 +361,11 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
  */
 void regcache_cache_only(struct regmap *map, bool enable)
 {
-	mutex_lock(&map->lock);
+	map->lock(map);
 	WARN_ON(map->cache_bypass && enable);
 	map->cache_only = enable;
 	trace_regmap_cache_only(map->dev, enable);
-	mutex_unlock(&map->lock);
+	map->unlock(map);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 
@@ -380,9 +380,9 @@ EXPORT_SYMBOL_GPL(regcache_cache_only);
  */
 void regcache_mark_dirty(struct regmap *map)
 {
-	mutex_lock(&map->lock);
+	map->lock(map);
 	map->cache_dirty = true;
-	mutex_unlock(&map->lock);
+	map->unlock(map);
 }
 EXPORT_SYMBOL_GPL(regcache_mark_dirty);
 
@@ -399,11 +399,11 @@ EXPORT_SYMBOL_GPL(regcache_mark_dirty);
  */
 void regcache_cache_bypass(struct regmap *map, bool enable)
 {
-	mutex_lock(&map->lock);
+	map->lock(map);
 	WARN_ON(map->cache_only && enable);
 	map->cache_bypass = enable;
 	trace_regmap_cache_bypass(map->dev, enable);
-	mutex_unlock(&map->lock);
+	map->unlock(map);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);
 

commit e466de05194b666114713b753e2f4be1d4200140
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 3 13:08:53 2012 +0100

    regmap: Export regcache_sync_region()
    
    regcache_sync_region() isn't going to be useful to most drivers if we
    don't export it since otherwise they can't use it when built modular.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 87f54dbf601b..74b69095def6 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -346,6 +346,7 @@ int regcache_sync_region(struct regmap *map, unsigned int min,
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(regcache_sync_region);
 
 /**
  * regcache_cache_only: Put a register map into cache only mode

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit addfd8a09e1f434a73b3d87d36ef050c73511d2b
Merge: eae4b51b21f7 df00c79f78d8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 14 13:15:48 2012 +0000

    Merge remote-tracking branch 'regmap/topic/bulk' into regmap-next

commit 4a6be7bb7474500a69f6d8f25899b8038491bdbb
Merge: 7d9aca39dcac f9353e70bceb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 14 13:14:24 2012 +0000

    Merge remote-tracking branches 'regmap/topic/patch' and 'regmap/topic/sync' into regmap-next

commit 7d9aca39dcacd2b3f42e2e287162329f410f93e1
Merge: e1c1c69c8fc7 a0cc0209abb9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 14 13:13:25 2012 +0000

    Merge remote-tracking branch 'regmap/topic/drivers' into regmap-next
    
    Resolved simple add/add conflicts:
            drivers/base/regmap/internal.h
            drivers/base/regmap/regmap.c

commit 51990e825431089747f8896244b5c17d3a6423f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jan 22 11:23:42 2012 -0500

    device.h: cleanup users outside of linux/include (C files)
    
    For files that are actively using linux/device.h, make sure
    that they call it out.  This will allow us to clean up some
    of the implicit uses of linux/device.h within include/*
    without introducing build regressions.
    
    Yes, this was created by "cheating" -- i.e. the headers were
    cleaned up, and then the fallout was found and fixed, and then
    the two commits were reordered.  This ensures we don't introduce
    build regressions into the git history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 1ead66186b7c..214f704c34db 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -12,6 +12,7 @@
 
 #include <linux/slab.h>
 #include <linux/export.h>
+#include <linux/device.h>
 #include <trace/events/regmap.h>
 #include <linux/bsearch.h>
 #include <linux/sort.h>

commit 4d4cfd1656b5f6c88eae51c40741a695b108b006
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 23 20:53:37 2012 +0000

    regmap: Allow drivers to sync only part of the register cache
    
    Provide a regcache_sync_region() operation which allows drivers to
    write only part of the cache back to the hardware. This is intended
    for use in cases like power domains or DSP memories where part of the
    device register map may be reset without fully resetting the device.
    
    Fully supporting these devices is likely to require additional work to
    make specific regions of the register map cache only while they are in
    reset, but this is enough for most devices.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index aec5a7486a29..b35f8751471d 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -298,6 +298,51 @@ int regcache_sync(struct regmap *map)
 }
 EXPORT_SYMBOL_GPL(regcache_sync);
 
+/**
+ * regcache_sync_region: Sync part  of the register cache with the hardware.
+ *
+ * @map: map to sync.
+ * @min: first register to sync
+ * @max: last register to sync
+ *
+ * Write all non-default register values in the specified region to
+ * the hardware.
+ *
+ * Return a negative value on failure, 0 on success.
+ */
+int regcache_sync_region(struct regmap *map, unsigned int min,
+			 unsigned int max)
+{
+	int ret = 0;
+	const char *name;
+	unsigned int bypass;
+
+	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
+
+	mutex_lock(&map->lock);
+
+	/* Remember the initial bypass state */
+	bypass = map->cache_bypass;
+
+	name = map->cache_ops->name;
+	dev_dbg(map->dev, "Syncing %s cache from %d-%d\n", name, min, max);
+
+	trace_regcache_sync(map->dev, name, "start region");
+
+	if (!map->cache_dirty)
+		goto out;
+
+	ret = map->cache_ops->sync(map, min, max);
+
+out:
+	trace_regcache_sync(map->dev, name, "stop region");
+	/* Restore the bypass state */
+	map->cache_bypass = bypass;
+	mutex_unlock(&map->lock);
+
+	return ret;
+}
+
 /**
  * regcache_cache_only: Put a register map into cache only mode
  *

commit ac8d91c801905a061ca883dca427a5e19602a1e7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 23 19:31:04 2012 +0000

    regmap: Supply ranges to the sync operations
    
    In order to allow us to support partial sync operations add minimum and
    maximum register arguments to the sync operation and update the rbtree
    and lzo caches to use this new information. The LZO implementation is
    obviously not good, we could exit the iteration earlier, but there may
    be room for more wide reaching optimisation there.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 46c42d3a4655..aec5a7486a29 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -283,7 +283,7 @@ int regcache_sync(struct regmap *map)
 	}
 	map->cache_bypass = 0;
 
-	ret = map->cache_ops->sync(map);
+	ret = map->cache_ops->sync(map, 0, map->max_register);
 
 	if (ret == 0)
 		map->cache_dirty = false;

commit 5d5b7d4f80ed6e861c1c220fd57e3dad0912526e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 23 22:02:57 2012 +0000

    regmap: Add tracepoints for cache only and cache bypass
    
    Useful for figuring out where the hardware interaction went or came from.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 69d4c9c5a4a8..2d89ce08f137 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -313,6 +313,7 @@ void regcache_cache_only(struct regmap *map, bool enable)
 	mutex_lock(&map->lock);
 	WARN_ON(map->cache_bypass && enable);
 	map->cache_only = enable;
+	trace_regmap_cache_only(map->dev, enable);
 	mutex_unlock(&map->lock);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
@@ -350,6 +351,7 @@ void regcache_cache_bypass(struct regmap *map, bool enable)
 	mutex_lock(&map->lock);
 	WARN_ON(map->cache_only && enable);
 	map->cache_bypass = enable;
+	trace_regmap_cache_bypass(map->dev, enable);
 	mutex_unlock(&map->lock);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);

commit 6ff7373809a9b4eb644d83e2e299da297e1cbffa
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 23 22:05:59 2012 +0000

    regmap: Mark the cache as clean after a successful sync
    
    Previously the cache would never be marked clean, meaning syncs would
    never be suppressed which isn't the end of the world but could be
    inefficient.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4d43ed363481..46c42d3a4655 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -285,6 +285,9 @@ int regcache_sync(struct regmap *map)
 
 	ret = map->cache_ops->sync(map);
 
+	if (ret == 0)
+		map->cache_dirty = false;
+
 out:
 	trace_regcache_sync(map->dev, name, "stop");
 	/* Restore the bypass state */

commit c3ec23288a92e20e0aff84a4cb6fbc7cc9bcf567
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 23 20:48:40 2012 +0000

    regmap: Remove default cache sync implementation
    
    It's not used as all cache types have sync operations so it's just dead
    code which never gets tested.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index ee36bed9479c..4d43ed363481 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -254,12 +254,11 @@ EXPORT_SYMBOL_GPL(regcache_write);
 int regcache_sync(struct regmap *map)
 {
 	int ret = 0;
-	unsigned int val;
 	unsigned int i;
 	const char *name;
 	unsigned int bypass;
 
-	BUG_ON(!map->cache_ops);
+	BUG_ON(!map->cache_ops || !map->cache_ops->sync);
 
 	mutex_lock(&map->lock);
 	/* Remember the initial bypass state */
@@ -284,24 +283,8 @@ int regcache_sync(struct regmap *map)
 	}
 	map->cache_bypass = 0;
 
-	if (map->cache_ops->sync) {
-		ret = map->cache_ops->sync(map);
-	} else {
-		for (i = 0; i < map->num_reg_defaults; i++) {
-			ret = regcache_read(map, i, &val);
-			if (ret < 0)
-				goto out;
-			map->cache_bypass = 1;
-			ret = _regmap_write(map, i, val);
-			map->cache_bypass = 0;
-			if (ret < 0)
-				goto out;
-			dev_dbg(map->dev, "Synced register %#x, value %#x\n",
-				map->reg_defaults[i].reg,
-				map->reg_defaults[i].def);
-		}
+	ret = map->cache_ops->sync(map);
 
-	}
 out:
 	trace_regcache_sync(map->dev, name, "stop");
 	/* Restore the bypass state */

commit aca1e172a1096ed3785e0da01d82943b7562527c
Merge: 3bf06a1ad9b1 2a14d7d9b743
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Feb 20 21:21:33 2012 +0000

    Merge branch 'topic/patch' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap into regmap-drivers

commit 7d5e525b9ceda0e3b85da0acdaa2de19fea51edc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 17 15:58:25 2012 -0800

    regmap: Implement support for 32 bit registers and values
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 7e18d1e70f12..69d4c9c5a4a8 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -372,6 +372,13 @@ bool regcache_set_val(void *base, unsigned int idx,
 		cache[idx] = val;
 		break;
 	}
+	case 4: {
+		u32 *cache = base;
+		if (cache[idx] == val)
+			return true;
+		cache[idx] = val;
+		break;
+	}
 	default:
 		BUG();
 	}
@@ -393,6 +400,10 @@ unsigned int regcache_get_val(const void *base, unsigned int idx,
 		const u16 *cache = base;
 		return cache[idx];
 	}
+	case 4: {
+		const u32 *cache = base;
+		return cache[idx];
+	}
 	default:
 		BUG();
 	}

commit df00c79f78d8b0ad788daf689ea461ace9d0811f
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Fri Feb 17 18:57:26 2012 +0530

    regmap: Bypassing cache when initializing cache
    
    During regcache_init, if client has not passed the
    default data of cached register then it is directly
    read from the hw to initialize cache. This hw register
    read happens before cache ops are initialized and hence
    avoiding register read to check for the data available
    on cache or not by enabling flag of cache_bypass.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 1ead66186b7c..4b903a8e92a2 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -35,12 +35,17 @@ static int regcache_hw_init(struct regmap *map)
 		return -EINVAL;
 
 	if (!map->reg_defaults_raw) {
+		u32 cache_bypass = map->cache_bypass;
 		dev_warn(map->dev, "No cache defaults, reading back from HW\n");
+
+		/* Bypass the cache access till data read from HW*/
+		map->cache_bypass = 1;
 		tmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);
 		if (!tmp_buf)
 			return -EINVAL;
 		ret = regmap_bulk_read(map, 0, tmp_buf,
 				       map->num_reg_defaults_raw);
+		map->cache_bypass = cache_bypass;
 		if (ret < 0) {
 			kfree(tmp_buf);
 			return ret;

commit 61cddc57dc14a5dffa0921d9a24fd68edbb374ac
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Feb 15 10:23:25 2012 +0100

    regmap: Fix cache defaults initialization from raw cache defaults
    
    Currently registers with a value of 0 are ignored when initializing the register
    defaults from raw defaults. This worked in the past, because registers without a
    explicit default were assumed to have a default value of 0. This was changed in
    commit b03622a8 ("regmap: Ensure rbtree syncs registers set to zero properly").
    As a result registers, which have a raw default value of 0 are now assumed to
    have no default. This again can result in unnecessary writes when syncing the
    cache. It will also result in unnecessary reads for e.g. the first update
    operation. In the case where readback is not possible this will even let the
    update operation fail, if the register has not been written to before.
    
    So this patch removes the check. Instead it adds a check to ignore raw defaults
    for registers which are volatile, since those registers are not cached.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 1ead66186b7c..d1daa5e9fadf 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -53,7 +53,7 @@ static int regcache_hw_init(struct regmap *map)
 	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {
 		val = regcache_get_val(map->reg_defaults_raw,
 				       i, map->cache_word_size);
-		if (!val)
+		if (regmap_volatile(map, i))
 			continue;
 		count++;
 	}
@@ -70,7 +70,7 @@ static int regcache_hw_init(struct regmap *map)
 	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
 		val = regcache_get_val(map->reg_defaults_raw,
 				       i, map->cache_word_size);
-		if (!val)
+		if (regmap_volatile(map, i))
 			continue;
 		map->reg_defaults[j].reg = i;
 		map->reg_defaults[j].def = val;

commit aa795d129246cb4c973076e3242b8a2eb374f1ef
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jan 31 11:48:18 2012 +0800

    regmap: Remove incorrect unreachable comment in regcache_set_val()
    
    regcache_set_val() returns false if cache[idx] != val.
    Thus it actually is not unreachable.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 99beccfad4d7..7e18d1e70f12 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -375,7 +375,6 @@ bool regcache_set_val(void *base, unsigned int idx,
 	default:
 		BUG();
 	}
-	/* unreachable */
 	return false;
 }
 

commit 8a892d6996b60c822f19ad1844eb15b96ce393c7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 25 21:05:48 2012 +0000

    regmap: Bypass the cache when applying patches
    
    Otherwise any patch that affects a register which is writable may trash
    cached values.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 9c6a5c13f1da..ee36bed9479c 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -273,6 +273,7 @@ int regcache_sync(struct regmap *map)
 		goto out;
 
 	/* Apply any patch first */
+	map->cache_bypass = 1;
 	for (i = 0; i < map->patch_regs; i++) {
 		ret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);
 		if (ret != 0) {
@@ -281,6 +282,7 @@ int regcache_sync(struct regmap *map)
 			goto out;
 		}
 	}
+	map->cache_bypass = 0;
 
 	if (map->cache_ops->sync) {
 		ret = map->cache_ops->sync(map);

commit d9db762708e27c2892db9d8a54e735a8e506e16e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 25 21:06:33 2012 +0000

    regmap: Skip patch application when the cache is not dirty on sync
    
    On the basis that if we don't actually need to resync the cache then the
    patches are probably also already applied.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index ce2034c10ffb..9c6a5c13f1da 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -269,6 +269,9 @@ int regcache_sync(struct regmap *map)
 	name = map->cache_ops->name;
 	trace_regcache_sync(map->dev, name, "start");
 
+	if (!map->cache_dirty)
+		goto out;
+
 	/* Apply any patch first */
 	for (i = 0; i < map->patch_regs; i++) {
 		ret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);
@@ -279,8 +282,6 @@ int regcache_sync(struct regmap *map)
 		}
 	}
 
-	if (!map->cache_dirty)
-		goto out;
 	if (map->cache_ops->sync) {
 		ret = map->cache_ops->sync(map);
 	} else {

commit 7e53b195e412a813e915843adc7e4d91868e8e94
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 25 20:46:53 2012 +0000

    regmap: Unexport regcache_write() and regcache_read()
    
    They have no current users which is fortunate as they don't take the lock
    and therefore aren't safe to use externally. We'll need to add new
    operations if direct cache access is needed.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 1ead66186b7c..99beccfad4d7 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -211,7 +211,6 @@ int regcache_read(struct regmap *map,
 
 	return -EINVAL;
 }
-EXPORT_SYMBOL_GPL(regcache_read);
 
 /**
  * regcache_write: Set the value of a given register in the cache.
@@ -238,7 +237,6 @@ int regcache_write(struct regmap *map,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(regcache_write);
 
 /**
  * regcache_sync: Sync the register cache with the hardware.

commit 22f0d90a34827812413bb3fbeda6a2a79bb58423
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Jan 21 12:01:14 2012 +0000

    regmap: Support register patch sets
    
    Device manufacturers frequently provide register sequences, usually not
    fully documented, to be run at startup in order to provide better defaults
    for devices (for example, improving performance in the light of silicon
    evaluation). Support such updates by allowing drivers to register update
    sets with the core. These updates will be written to the device immediately
    and will also be rewritten when the cache is synced.
    
    The assumption is that the reason for resyncing the cache will always be
    that the device has been powered off. If this turns out to not be the case
    then a separate operation can be provided.
    
    Currently the implementation only allows a single set of updates to be
    specified for a device, this could be extended in future.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 1ead66186b7c..ce2034c10ffb 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -268,6 +268,17 @@ int regcache_sync(struct regmap *map)
 		map->cache_ops->name);
 	name = map->cache_ops->name;
 	trace_regcache_sync(map->dev, name, "start");
+
+	/* Apply any patch first */
+	for (i = 0; i < map->patch_regs; i++) {
+		ret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);
+		if (ret != 0) {
+			dev_err(map->dev, "Failed to write %x = %x: %d\n",
+				map->patch[i].reg, map->patch[i].def, ret);
+			goto out;
+		}
+	}
+
 	if (!map->cache_dirty)
 		goto out;
 	if (map->cache_ops->sync) {

commit bc7ee55633867909bb05e71f957a4d3c1aa1b488
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 30 14:27:08 2011 +0000

    regmap: Add trace event for successful cache reads
    
    Currently we only trace physical reads, there's no instrumentation if
    the read is satisfied from cache.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 1ca2d7a1051f..1ead66186b7c 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -193,13 +193,21 @@ void regcache_exit(struct regmap *map)
 int regcache_read(struct regmap *map,
 		  unsigned int reg, unsigned int *value)
 {
+	int ret;
+
 	if (map->cache_type == REGCACHE_NONE)
 		return -ENOSYS;
 
 	BUG_ON(!map->cache_ops);
 
-	if (!regmap_volatile(map, reg))
-		return map->cache_ops->read(map, reg, value);
+	if (!regmap_volatile(map, reg)) {
+		ret = map->cache_ops->read(map, reg, value);
+
+		if (ret == 0)
+			trace_regmap_reg_read_cache(map->dev, reg, *value);
+
+		return ret;
+	}
 
 	return -EINVAL;
 }

commit 4c691664583ef6a91f9ed0e08a75fbd30a5ffd5c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Nov 18 16:53:00 2011 +0000

    regmap: Remove indexed cache type
    
    There should be no situation where it offers any advantage over rbtree
    and there are no current users so remove the code for simplicity.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index e21eebd36afa..1ca2d7a1051f 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -19,7 +19,6 @@
 #include "internal.h"
 
 static const struct regcache_ops *cache_types[] = {
-	&regcache_indexed_ops,
 	&regcache_rbtree_ops,
 	&regcache_lzo_ops,
 };
@@ -420,22 +419,3 @@ int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 	else
 		return -ENOENT;
 }
-
-int regcache_insert_reg(struct regmap *map, unsigned int reg,
-			unsigned int val)
-{
-	void *tmp;
-
-	tmp = krealloc(map->reg_defaults,
-		       (map->num_reg_defaults + 1) * sizeof(struct reg_default),
-		       GFP_KERNEL);
-	if (!tmp)
-		return -ENOMEM;
-	map->reg_defaults = tmp;
-	map->num_reg_defaults++;
-	map->reg_defaults[map->num_reg_defaults - 1].reg = reg;
-	map->reg_defaults[map->num_reg_defaults - 1].def = val;
-	sort(map->reg_defaults, map->num_reg_defaults,
-	     sizeof(struct reg_default), regcache_default_cmp, NULL);
-	return 0;
-}

commit b44d48c1ccf70273a91b7d3a920b0b54c3cb314f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 20:34:04 2011 +0100

    regmap: Drop check whether a register is readable in regcache_read
    
    One of the reasons for using a cache is to have a software shadow of a register
    which is writable but not readable. This allows us to do a read-modify-write
    operation on such a register.
    
    Currently regcache checks whether a register is readable when performing a
    cached read and returns an error if it is not. Drop this check, since it will
    prevent us from using the cache for registers where read-back is not possible.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 6d93e49c462f..e21eebd36afa 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -199,9 +199,6 @@ int regcache_read(struct regmap *map,
 
 	BUG_ON(!map->cache_ops);
 
-	if (!regmap_readable(map, reg))
-		return -EIO;
-
 	if (!regmap_volatile(map, reg))
 		return map->cache_ops->read(map, reg, value);
 

commit 064d4db11e23949c40b8a2f2f6be11c131b53932
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 20:34:03 2011 +0100

    regmap: Properly round cache_word_size
    
    regcache currently only properly works with val bit sizes of 8 or 16, since
    it will, when calculating the cache word size, round down. This causes the
    cache storage to be too small to hold the full register value. Fix this by
    rounding up instead.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index d687df6ebdb0..6d93e49c462f 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -111,8 +111,8 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	map->num_reg_defaults = config->num_reg_defaults;
 	map->num_reg_defaults_raw = config->num_reg_defaults_raw;
 	map->reg_defaults_raw = config->reg_defaults_raw;
-	map->cache_size_raw = (config->val_bits / 8) * config->num_reg_defaults_raw;
-	map->cache_word_size = config->val_bits / 8;
+	map->cache_word_size = DIV_ROUND_UP(config->val_bits, 8);
+	map->cache_size_raw = map->cache_word_size * config->num_reg_defaults_raw;
 
 	map->cache = NULL;
 	map->cache_ops = cache_types[i];

commit 720e4616e8fd85284ef1addd8b8d93d8415e8dbc
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 16:28:17 2011 +0100

    regmap: Make reg_config reg_defaults const
    
    The reg_defaults field usually points to a static per driver array, which should
    not be modified. Make requirement this explicit by making reg_defaults const.
    To allow this the regcache_init code needs some minor changes. Previoulsy the
    reg_config was not available in regcache_init and regmap->reg_defaults was used
    to pass the default register set to regcache_init. Now that the reg_config is
    available we can work on it directly.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 0ad6cfb2c8cc..d687df6ebdb0 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -108,7 +108,6 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 		return -EINVAL;
 	}
 
-	map->reg_defaults = config->reg_defaults;
 	map->num_reg_defaults = config->num_reg_defaults;
 	map->num_reg_defaults_raw = config->num_reg_defaults_raw;
 	map->reg_defaults_raw = config->reg_defaults_raw;
@@ -127,10 +126,10 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	 * won't vanish from under us.  We'll need to make
 	 * a copy of it.
 	 */
-	if (map->reg_defaults) {
+	if (config->reg_defaults) {
 		if (!map->num_reg_defaults)
 			return -EINVAL;
-		tmp_buf = kmemdup(map->reg_defaults, map->num_reg_defaults *
+		tmp_buf = kmemdup(config->reg_defaults, map->num_reg_defaults *
 				  sizeof(struct reg_default), GFP_KERNEL);
 		if (!tmp_buf)
 			return -ENOMEM;

commit e5e3b8abeda1cf45f5a079458dbc267952694c7a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 16:28:16 2011 +0100

    regmap: Move initialization of regcache related fields to regcache_init
    
    Move the initialization regcache related fields of the regmap struct to
    regcache_init. This allows us to keep regmap and regcache code better
    separated.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 27fae58ff4cb..0ad6cfb2c8cc 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -87,7 +87,7 @@ static int regcache_hw_init(struct regmap *map)
 	return ret;
 }
 
-int regcache_init(struct regmap *map)
+int regcache_init(struct regmap *map, const struct regmap_config *config)
 {
 	int ret;
 	int i;
@@ -108,6 +108,13 @@ int regcache_init(struct regmap *map)
 		return -EINVAL;
 	}
 
+	map->reg_defaults = config->reg_defaults;
+	map->num_reg_defaults = config->num_reg_defaults;
+	map->num_reg_defaults_raw = config->num_reg_defaults_raw;
+	map->reg_defaults_raw = config->reg_defaults_raw;
+	map->cache_size_raw = (config->val_bits / 8) * config->num_reg_defaults_raw;
+	map->cache_word_size = config->val_bits / 8;
+
 	map->cache = NULL;
 	map->cache_ops = cache_types[i];
 

commit bd061c78cabc28bb64ed79f784d24918b6bdb791
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 14 10:40:17 2011 +0100

    regmap: Fix memory leak in regcache_init error path
    
    Make sure all allocated memory gets freed again in case initializing the cache
    failed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 79446262812c..27fae58ff4cb 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -144,9 +144,18 @@ int regcache_init(struct regmap *map)
 	if (map->cache_ops->init) {
 		dev_dbg(map->dev, "Initializing %s cache\n",
 			map->cache_ops->name);
-		return map->cache_ops->init(map);
+		ret = map->cache_ops->init(map);
+		if (ret)
+			goto err_free;
 	}
 	return 0;
+
+err_free:
+	kfree(map->reg_defaults);
+	if (map->cache_free)
+		kfree(map->reg_defaults_raw);
+
+	return ret;
 }
 
 void regcache_exit(struct regmap *map)

commit 021cd616decb4e8a4b31f1f8c466a847e8c04e67
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 14 10:40:16 2011 +0100

    regmap: Fix memory leak in regcache_hw_init error path
    
    Make sure reg_defaults_raw gets freed in case of an error.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 6ab9f0384d82..79446262812c 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -61,8 +61,10 @@ static int regcache_hw_init(struct regmap *map)
 
 	map->reg_defaults = kmalloc(count * sizeof(struct reg_default),
 				      GFP_KERNEL);
-	if (!map->reg_defaults)
-		return -ENOMEM;
+	if (!map->reg_defaults) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
 
 	/* fill the reg_defaults */
 	map->num_reg_defaults = count;
@@ -77,6 +79,12 @@ static int regcache_hw_init(struct regmap *map)
 	}
 
 	return 0;
+
+err_free:
+	if (map->cache_free)
+		kfree(map->reg_defaults_raw);
+
+	return ret;
 }
 
 int regcache_init(struct regmap *map)

commit 8ae0d7e8a918e9603748abe9b31984fc5d96abb3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Oct 26 10:34:22 2011 +0200

    regmap: Track if the register cache is dirty and suppress unneeded syncs
    
    Allow drivers to optimise out the register cache sync if they didn't need
    to do one. If the hardware is desynced from the register cache (by power
    loss for example) then the driver should call regcache_mark_dirty() to
    let the core know about this.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 666f6f5011dc..6ab9f0384d82 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -241,6 +241,8 @@ int regcache_sync(struct regmap *map)
 		map->cache_ops->name);
 	name = map->cache_ops->name;
 	trace_regcache_sync(map->dev, name, "start");
+	if (!map->cache_dirty)
+		goto out;
 	if (map->cache_ops->sync) {
 		ret = map->cache_ops->sync(map);
 	} else {
@@ -290,6 +292,23 @@ void regcache_cache_only(struct regmap *map, bool enable)
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 
+/**
+ * regcache_mark_dirty: Mark the register cache as dirty
+ *
+ * @map: map to mark
+ *
+ * Mark the register cache as dirty, for example due to the device
+ * having been powered down for suspend.  If the cache is not marked
+ * as dirty then the cache sync will be suppressed.
+ */
+void regcache_mark_dirty(struct regmap *map)
+{
+	mutex_lock(&map->lock);
+	map->cache_dirty = true;
+	mutex_unlock(&map->lock);
+}
+EXPORT_SYMBOL_GPL(regcache_mark_dirty);
+
 /**
  * regcache_cache_bypass: Put a register map into cache bypass mode
  *

commit 1b6bc32f0a7380102499deb6aa99a59e789efb33
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 07:12:15 2011 -0400

    drivers/base: Add export.h for EXPORT_SYMBOL/THIS_MODULE as required.
    
    Most of these files were implicitly getting EXPORT_SYMBOL via
    device.h which was including module.h, but that path will be broken
    soon.
    
    [ with input from Stephen Rothwell <sfr@canb.auug.org.au> ]
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index afcfef838263..666f6f5011dc 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -11,6 +11,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/export.h>
 #include <trace/events/regmap.h>
 #include <linux/bsearch.h>
 #include <linux/sort.h>

commit 8528bdd450d34687b380c0f87992d105bdf54ca3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Oct 9 13:13:58 2011 +0100

    regmap: Allow caches for devices with no defaults
    
    We only really need the defaults in order to cut down the number of
    registers we sync and to satisfy reads while the device is powered off
    but not all devices are going to need to do that (always on devices like
    PMICs being the prime example) so don't require those devices to supply
    a default.  Instead only try to fall back to hardware defaults if the
    driver told us to.
    
    Devices using LZO won't be able to instantiate with this, that will require
    some updates in the LZO code to handle this case.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 409abd282c6c..afcfef838263 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -119,7 +119,7 @@ int regcache_init(struct regmap *map)
 		if (!tmp_buf)
 			return -ENOMEM;
 		map->reg_defaults = tmp_buf;
-	} else {
+	} else if (map->num_reg_defaults_raw) {
 		/* Some devices such as PMICs don't have cache defaults,
 		 * we cope with this by reading back the HW registers and
 		 * crafting the cache defaults by hand.

commit 6e6ace00a045251bd172b9b9c2379857bbff3dc7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Oct 9 13:23:31 2011 +0100

    regmap: Return a sensible error code if we fail to read the cache
    
    If a register isn't cached then let callers know that so they can fall
    back or error handle appropriately.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index c5379c86de88..409abd282c6c 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -378,7 +378,7 @@ int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 	if (r)
 		return r - map->reg_defaults;
 	else
-		return -1;
+		return -ENOENT;
 }
 
 int regcache_insert_reg(struct regmap *map, unsigned int reg,

commit f094fea68f0575286c55c06141cc89ffd0049024
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 4 22:05:47 2011 +0100

    regmap: Use bsearch() to search the register defaults
    
    Rather than open coding a binary search use the standard bsearch() using
    the comparison function we're already using for sort() on insert. This
    fixes a lockup I was observing due to iterating on min <= max rather
    than min < max when we fail to look up.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index b10e38fa0e3f..c5379c86de88 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -12,6 +12,7 @@
 
 #include <linux/slab.h>
 #include <trace/events/regmap.h>
+#include <linux/bsearch.h>
 #include <linux/sort.h>
 
 #include "internal.h"
@@ -355,25 +356,7 @@ unsigned int regcache_get_val(const void *base, unsigned int idx,
 	return -1;
 }
 
-int regcache_lookup_reg(struct regmap *map, unsigned int reg)
-{
-	unsigned int min, max, index;
-
-	min = 0;
-	max = map->num_reg_defaults - 1;
-	do {
-		index = (min + max) / 2;
-		if (map->reg_defaults[index].reg == reg)
-			return index;
-		if (map->reg_defaults[index].reg < reg)
-			min = index + 1;
-		else
-			max = index;
-	} while (min <= max);
-	return -1;
-}
-
-static int regcache_insert_cmp(const void *a, const void *b)
+static int regcache_default_cmp(const void *a, const void *b)
 {
 	const struct reg_default *_a = a;
 	const struct reg_default *_b = b;
@@ -381,6 +364,23 @@ static int regcache_insert_cmp(const void *a, const void *b)
 	return _a->reg - _b->reg;
 }
 
+int regcache_lookup_reg(struct regmap *map, unsigned int reg)
+{
+	struct reg_default key;
+	struct reg_default *r;
+
+	key.reg = reg;
+	key.def = 0;
+
+	r = bsearch(&key, map->reg_defaults, map->num_reg_defaults,
+		    sizeof(struct reg_default), regcache_default_cmp);
+
+	if (r)
+		return r - map->reg_defaults;
+	else
+		return -1;
+}
+
 int regcache_insert_reg(struct regmap *map, unsigned int reg,
 			unsigned int val)
 {
@@ -396,6 +396,6 @@ int regcache_insert_reg(struct regmap *map, unsigned int reg,
 	map->reg_defaults[map->num_reg_defaults - 1].reg = reg;
 	map->reg_defaults[map->num_reg_defaults - 1].def = val;
 	sort(map->reg_defaults, map->num_reg_defaults,
-	     sizeof(struct reg_default), regcache_insert_cmp, NULL);
+	     sizeof(struct reg_default), regcache_default_cmp, NULL);
 	return 0;
 }

commit 0eef6b0415f58ed16aff95af8c92514ce5c01258
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Oct 3 06:54:16 2011 +0100

    regmap: Fix doc comment
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index e1846eb2f171..b10e38fa0e3f 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -292,7 +292,7 @@ EXPORT_SYMBOL_GPL(regcache_cache_only);
  * regcache_cache_bypass: Put a register map into cache bypass mode
  *
  * @map: map to configure
- * @cache_only: flag if changes should not be written to the hardware
+ * @cache_bypass: flag if changes should not be written to the hardware
  *
  * When a register map is marked with the cache bypass option, writes
  * to the register map API will only update the hardware and not the

commit c08604b8ae72b4fa1843a76fc7b403ddec49f8f4
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Oct 3 10:50:14 2011 +0100

    regmap: Optimize the lookup path to use binary search
    
    Since there are more lookups than insertions in a typical
    scenario, optimize the linear search into a binary search.  For
    this to work, we need to keep reg_defaults sorted upon
    insertions, for now be lazy and use sort().
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 2d55b261f1c5..e1846eb2f171 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -12,6 +12,7 @@
 
 #include <linux/slab.h>
 #include <trace/events/regmap.h>
+#include <linux/sort.h>
 
 #include "internal.h"
 
@@ -356,14 +357,30 @@ unsigned int regcache_get_val(const void *base, unsigned int idx,
 
 int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 {
-	unsigned int i;
-
-	for (i = 0; i < map->num_reg_defaults; i++)
-		if (map->reg_defaults[i].reg == reg)
-			return i;
+	unsigned int min, max, index;
+
+	min = 0;
+	max = map->num_reg_defaults - 1;
+	do {
+		index = (min + max) / 2;
+		if (map->reg_defaults[index].reg == reg)
+			return index;
+		if (map->reg_defaults[index].reg < reg)
+			min = index + 1;
+		else
+			max = index;
+	} while (min <= max);
 	return -1;
 }
 
+static int regcache_insert_cmp(const void *a, const void *b)
+{
+	const struct reg_default *_a = a;
+	const struct reg_default *_b = b;
+
+	return _a->reg - _b->reg;
+}
+
 int regcache_insert_reg(struct regmap *map, unsigned int reg,
 			unsigned int val)
 {
@@ -378,5 +395,7 @@ int regcache_insert_reg(struct regmap *map, unsigned int reg,
 	map->num_reg_defaults++;
 	map->reg_defaults[map->num_reg_defaults - 1].reg = reg;
 	map->reg_defaults[map->num_reg_defaults - 1].def = val;
+	sort(map->reg_defaults, map->num_reg_defaults,
+	     sizeof(struct reg_default), regcache_insert_cmp, NULL);
 	return 0;
 }

commit ac77a765cb6e3b5aa41c186ad9f37db7fdad7dbe
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Sep 29 14:36:28 2011 +0100

    regmap: Ensure we scream if we enable cache bypass/only at the same time
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 876622453cd8..2d55b261f1c5 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -281,6 +281,7 @@ EXPORT_SYMBOL_GPL(regcache_sync);
 void regcache_cache_only(struct regmap *map, bool enable)
 {
 	mutex_lock(&map->lock);
+	WARN_ON(map->cache_bypass && enable);
 	map->cache_only = enable;
 	mutex_unlock(&map->lock);
 }
@@ -300,6 +301,7 @@ EXPORT_SYMBOL_GPL(regcache_cache_only);
 void regcache_cache_bypass(struct regmap *map, bool enable)
 {
 	mutex_lock(&map->lock);
+	WARN_ON(map->cache_only && enable);
 	map->cache_bypass = enable;
 	mutex_unlock(&map->lock);
 }

commit 6eb0f5e0154facfe4f0acdb9f474cde773319efc
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Sep 29 14:36:27 2011 +0100

    regmap: Implement regcache_cache_bypass helper function
    
    Ensure we've got a function so users can enable/disable the
    cache bypass option.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 5dbc5076267e..876622453cd8 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -286,6 +286,25 @@ void regcache_cache_only(struct regmap *map, bool enable)
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 
+/**
+ * regcache_cache_bypass: Put a register map into cache bypass mode
+ *
+ * @map: map to configure
+ * @cache_only: flag if changes should not be written to the hardware
+ *
+ * When a register map is marked with the cache bypass option, writes
+ * to the register map API will only update the hardware and not the
+ * the cache directly.  This is useful when syncing the cache back to
+ * the hardware.
+ */
+void regcache_cache_bypass(struct regmap *map, bool enable)
+{
+	mutex_lock(&map->lock);
+	map->cache_bypass = enable;
+	mutex_unlock(&map->lock);
+}
+EXPORT_SYMBOL_GPL(regcache_cache_bypass);
+
 bool regcache_set_val(void *base, unsigned int idx,
 		      unsigned int val, unsigned int word_size)
 {

commit beb1a10f219ce720c13168203bd5ebe4ce7879e0
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Sep 29 14:36:26 2011 +0100

    regmap: Save/restore the bypass state upon syncing
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 59e432c0163d..5dbc5076267e 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -227,10 +227,13 @@ int regcache_sync(struct regmap *map)
 	unsigned int val;
 	unsigned int i;
 	const char *name;
+	unsigned int bypass;
 
 	BUG_ON(!map->cache_ops);
 
 	mutex_lock(&map->lock);
+	/* Remember the initial bypass state */
+	bypass = map->cache_bypass;
 	dev_dbg(map->dev, "Syncing %s cache\n",
 		map->cache_ops->name);
 	name = map->cache_ops->name;
@@ -255,6 +258,8 @@ int regcache_sync(struct regmap *map)
 	}
 out:
 	trace_regcache_sync(map->dev, name, "stop");
+	/* Restore the bypass state */
+	map->cache_bypass = bypass;
 	mutex_unlock(&map->lock);
 
 	return ret;

commit 13753a9088af23c61e2f5c10a8f3ea136d8ebab5
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Sep 29 14:36:25 2011 +0100

    regmap: Lock the sync path, ensure we use the lockless _regmap_write()
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 2caf6e49c389..59e432c0163d 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -230,6 +230,7 @@ int regcache_sync(struct regmap *map)
 
 	BUG_ON(!map->cache_ops);
 
+	mutex_lock(&map->lock);
 	dev_dbg(map->dev, "Syncing %s cache\n",
 		map->cache_ops->name);
 	name = map->cache_ops->name;
@@ -242,7 +243,7 @@ int regcache_sync(struct regmap *map)
 			if (ret < 0)
 				goto out;
 			map->cache_bypass = 1;
-			ret = regmap_write(map, i, val);
+			ret = _regmap_write(map, i, val);
 			map->cache_bypass = 0;
 			if (ret < 0)
 				goto out;
@@ -254,6 +255,7 @@ int regcache_sync(struct regmap *map)
 	}
 out:
 	trace_regcache_sync(map->dev, name, "stop");
+	mutex_unlock(&map->lock);
 
 	return ret;
 }

commit 5fcd2560767cead8f0c741340e132c5417d9f73b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Sep 29 15:24:54 2011 +0100

    regmap: Fix apostrophe usage
    
    An apostrophe does not mean "look out, here comes an s!".
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 4dfab4107bfe..2caf6e49c389 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -118,7 +118,7 @@ int regcache_init(struct regmap *map)
 			return -ENOMEM;
 		map->reg_defaults = tmp_buf;
 	} else {
-		/* Some devices such as PMIC's don't have cache defaults,
+		/* Some devices such as PMICs don't have cache defaults,
 		 * we cope with this by reading back the HW registers and
 		 * crafting the cache defaults by hand.
 		 */

commit 2cd148f1599a425f0f3ac6753da96a1a1aa3ce76
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Sep 29 10:40:55 2011 +0100

    regmap: Fix lock used for regcache_cache_only()
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 744ed145bfa4..4dfab4107bfe 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -273,9 +273,9 @@ EXPORT_SYMBOL_GPL(regcache_sync);
  */
 void regcache_cache_only(struct regmap *map, bool enable)
 {
-	mutex_lock(&map->sync_lock);
+	mutex_lock(&map->lock);
 	map->cache_only = enable;
-	mutex_unlock(&map->sync_lock);
+	mutex_unlock(&map->lock);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 

commit 38f6916976f9e964748f097be3688e334fb60f3d
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Sep 28 11:43:45 2011 +0100

    regmap: Grab the lock in regcache_cache_only()
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index f46e247912cb..744ed145bfa4 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -273,7 +273,9 @@ EXPORT_SYMBOL_GPL(regcache_sync);
  */
 void regcache_cache_only(struct regmap *map, bool enable)
 {
+	mutex_lock(&map->sync_lock);
 	map->cache_only = enable;
+	mutex_unlock(&map->sync_lock);
 }
 EXPORT_SYMBOL_GPL(regcache_cache_only);
 

commit ec8a365fe62c78a16268bd1d12dfbebc2b775991
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Sep 28 11:43:42 2011 +0100

    regmap: Modify map->cache_bypass directly
    
    In preperation for the upcoming patches, modify map->cache_bypass
    directly.  The helper functions will grab an exclusive lock.  Because
    we'll have acquired the same lock we need to avoid a deadlock.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 5364dde2ecd0..f46e247912cb 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -241,9 +241,9 @@ int regcache_sync(struct regmap *map)
 			ret = regcache_read(map, i, &val);
 			if (ret < 0)
 				goto out;
-			regcache_cache_bypass(map, true);
+			map->cache_bypass = 1;
 			ret = regmap_write(map, i, val);
-			regcache_cache_bypass(map, false);
+			map->cache_bypass = 0;
 			if (ret < 0)
 				goto out;
 			dev_dbg(map->dev, "Synced register %#x, value %#x\n",

commit a40c282362419b8bccb75cea081992f535841085
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Sep 28 11:43:41 2011 +0100

    regmap: Fix regcache_sync generic implementation
    
    We want to use regmap_write() to actually write anything
    to the HW.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 6b9efd938dca..5364dde2ecd0 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -242,7 +242,7 @@ int regcache_sync(struct regmap *map)
 			if (ret < 0)
 				goto out;
 			regcache_cache_bypass(map, true);
-			ret = regcache_write(map, i, val);
+			ret = regmap_write(map, i, val);
 			regcache_cache_bypass(map, false);
 			if (ret < 0)
 				goto out;

commit 954757d767a78bc4b863fa9ea703bd7f814c8a55
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Tue Sep 27 11:25:06 2011 +0100

    regmap: Implement generic syncing functionality
    
    In the absence of a sync callback, do it manually.  This of course
    can't take advantange of the specific optimizations of each
    cache type but it will do well enough in most cases.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index e2b172b93dba..6b9efd938dca 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -223,20 +223,39 @@ EXPORT_SYMBOL_GPL(regcache_write);
  */
 int regcache_sync(struct regmap *map)
 {
-	int ret;
+	int ret = 0;
+	unsigned int val;
+	unsigned int i;
 	const char *name;
 
 	BUG_ON(!map->cache_ops);
 
+	dev_dbg(map->dev, "Syncing %s cache\n",
+		map->cache_ops->name);
+	name = map->cache_ops->name;
+	trace_regcache_sync(map->dev, name, "start");
 	if (map->cache_ops->sync) {
-		dev_dbg(map->dev, "Syncing %s cache\n",
-			map->cache_ops->name);
-		name = map->cache_ops->name;
-		trace_regcache_sync(map->dev, name, "start");
 		ret = map->cache_ops->sync(map);
-		trace_regcache_sync(map->dev, name, "stop");
+	} else {
+		for (i = 0; i < map->num_reg_defaults; i++) {
+			ret = regcache_read(map, i, &val);
+			if (ret < 0)
+				goto out;
+			regcache_cache_bypass(map, true);
+			ret = regcache_write(map, i, val);
+			regcache_cache_bypass(map, false);
+			if (ret < 0)
+				goto out;
+			dev_dbg(map->dev, "Synced register %#x, value %#x\n",
+				map->reg_defaults[i].reg,
+				map->reg_defaults[i].def);
+		}
+
 	}
-	return 0;
+out:
+	trace_regcache_sync(map->dev, name, "stop");
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(regcache_sync);
 

commit 92afb286d744511f51a05f8acb6c111d05737617
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Sep 19 18:22:14 2011 +0100

    regmap: Allow drivers to control cache_only flag
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 179f222d76c3..e2b172b93dba 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -240,6 +240,24 @@ int regcache_sync(struct regmap *map)
 }
 EXPORT_SYMBOL_GPL(regcache_sync);
 
+/**
+ * regcache_cache_only: Put a register map into cache only mode
+ *
+ * @map: map to configure
+ * @cache_only: flag if changes should be written to the hardware
+ *
+ * When a register map is marked as cache only writes to the register
+ * map API will only update the register cache, they will not cause
+ * any hardware changes.  This is useful for allowing portions of
+ * drivers to act as though the device were functioning as normal when
+ * it is disabled for power saving reasons.
+ */
+void regcache_cache_only(struct regmap *map, bool enable)
+{
+	map->cache_only = enable;
+}
+EXPORT_SYMBOL_GPL(regcache_cache_only);
+
 bool regcache_set_val(void *base, unsigned int idx,
 		      unsigned int val, unsigned int word_size)
 {

commit e7a6db30df42234bc0f7b9a0af402838e0f146b1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Sep 19 16:08:03 2011 +0100

    regmap: A cache type of _NONE behaves like a bypassed cache
    
    Avoid extra special casing by setting the cache_bypass flag when we're
    not caching.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 00609bf785fb..179f222d76c3 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -82,8 +82,10 @@ int regcache_init(struct regmap *map)
 	int i;
 	void *tmp_buf;
 
-	if (map->cache_type == REGCACHE_NONE)
+	if (map->cache_type == REGCACHE_NONE) {
+		map->cache_bypass = true;
 		return 0;
+	}
 
 	for (i = 0; i < ARRAY_SIZE(cache_types); i++)
 		if (cache_types[i]->type == map->cache_type)

commit 593600890110c02eb471cf844649dee213870416
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Sep 19 14:34:04 2011 +0100

    regmap: Add the regcache_sync trace event
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 142d9cdfef3a..00609bf785fb 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -221,12 +221,18 @@ EXPORT_SYMBOL_GPL(regcache_write);
  */
 int regcache_sync(struct regmap *map)
 {
+	int ret;
+	const char *name;
+
 	BUG_ON(!map->cache_ops);
 
 	if (map->cache_ops->sync) {
 		dev_dbg(map->dev, "Syncing %s cache\n",
 			map->cache_ops->name);
-		return map->cache_ops->sync(map);
+		name = map->cache_ops->name;
+		trace_regcache_sync(map->dev, name, "start");
+		ret = map->cache_ops->sync(map);
+		trace_regcache_sync(map->dev, name, "stop");
 	}
 	return 0;
 }

commit 2cbbb579bcbe3e11baf1c59920dcd5a780b80447
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Sep 19 14:34:03 2011 +0100

    regmap: Add the LZO cache support
    
    This patch adds support for LZO compression when storing the register
    cache.
    
    For a typical device whose register map would normally occupy 25kB or 50kB
    by using the LZO compression technique, one can get down to ~5-7kB.  There
    might be a performance penalty associated with each individual read/write
    due to decompressing/compressing the underlying cache, however that should not
    be noticeable.  These memory benefits depend on whether the target architecture
    can get rid of the memory occupied by the original register defaults cache
    which is marked as __devinitconst.  Nevertheless there will be some memory
    gain even if the target architecture can't get rid of the original register
    map, this should be around ~30-32kB instead of 50kB.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index b870a668b771..142d9cdfef3a 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -18,6 +18,7 @@
 static const struct regcache_ops *cache_types[] = {
 	&regcache_indexed_ops,
 	&regcache_rbtree_ops,
+	&regcache_lzo_ops,
 };
 
 static int regcache_hw_init(struct regmap *map)

commit 28644c809f44498b8cd91d00b4cdb09e63b99843
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Sep 19 14:34:02 2011 +0100

    regmap: Add the rbtree cache support
    
    This patch adds support for the rbtree cache compression type.
    
    Each rbnode manages a variable length block of registers.  There can be no
    two nodes with overlapping blocks.  Each block has a base register and a
    currently top register, all the other registers, if any, lie in between these
    two and in ascending order.
    
    The reasoning behind the construction of this rbtree is simple.  In the
    snd_soc_rbtree_cache_init() function, we iterate over the register defaults
    provided by the regcache core.  For each register value that is non-zero we
    insert it in the rbtree.  In order to determine in which rbnode we need
    to add the register, we first look if there is another register already
    added that is adjacent to the one we are about to add.  If that is the case
    we append it in that rbnode block, otherwise we create a new rbnode
    with a single register in its block and add it to the tree.
    
    There are various optimizations across the implementation to speed up lookups
    by caching the most recently used rbnode.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Tested-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 22b73ec12fd5..b870a668b771 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -17,6 +17,7 @@
 
 static const struct regcache_ops *cache_types[] = {
 	&regcache_indexed_ops,
+	&regcache_rbtree_ops,
 };
 
 static int regcache_hw_init(struct regmap *map)

commit 195af65ca92179ac2b524d35d732dc6fecec2744
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Sep 19 14:34:01 2011 +0100

    regmap: Add the indexed cache support
    
    This is the simplest form of a cache available in regcache.  Any
    registers whose default value is 0 are ignored.  If any of those
    registers are modified in the future, they will be placed in the
    cache on demand.  The cache layout is essentially using the provided
    register defaults by the regcache core directly and does not re-map
    it to another representation.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 9575e4c5f34a..22b73ec12fd5 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -16,6 +16,7 @@
 #include "internal.h"
 
 static const struct regcache_ops *cache_types[] = {
+	&regcache_indexed_ops,
 };
 
 static int regcache_hw_init(struct regmap *map)

commit 9fabe24e9b1af84509b842731d2beaf85e66681e
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Sep 19 14:34:00 2011 +0100

    regmap: Introduce caching support
    
    This patch introduces caching support for regmap.  The regcache API
    has evolved essentially out of ASoC soc-cache so most of the actual
    caching types (except LZO) have been tested in the past.
    
    The purpose of regcache is to optimize in time and space the handling
    of register caches.  Time optimization is achieved by not having to go
    over a slow bus like I2C to read the value of a register, instead it is
    cached locally in memory and can be retrieved faster.  Regarding space
    optimization, some of the cache types are better at packing the caches,
    for e.g. the rbtree and the LZO caches.  By doing this the sacrifice in
    time still wins over doing I2C transactions.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Tested-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
new file mode 100644
index 000000000000..9575e4c5f34a
--- /dev/null
+++ b/drivers/base/regmap/regcache.c
@@ -0,0 +1,304 @@
+/*
+ * Register cache access API
+ *
+ * Copyright 2011 Wolfson Microelectronics plc
+ *
+ * Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/slab.h>
+#include <trace/events/regmap.h>
+
+#include "internal.h"
+
+static const struct regcache_ops *cache_types[] = {
+};
+
+static int regcache_hw_init(struct regmap *map)
+{
+	int i, j;
+	int ret;
+	int count;
+	unsigned int val;
+	void *tmp_buf;
+
+	if (!map->num_reg_defaults_raw)
+		return -EINVAL;
+
+	if (!map->reg_defaults_raw) {
+		dev_warn(map->dev, "No cache defaults, reading back from HW\n");
+		tmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);
+		if (!tmp_buf)
+			return -EINVAL;
+		ret = regmap_bulk_read(map, 0, tmp_buf,
+				       map->num_reg_defaults_raw);
+		if (ret < 0) {
+			kfree(tmp_buf);
+			return ret;
+		}
+		map->reg_defaults_raw = tmp_buf;
+		map->cache_free = 1;
+	}
+
+	/* calculate the size of reg_defaults */
+	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {
+		val = regcache_get_val(map->reg_defaults_raw,
+				       i, map->cache_word_size);
+		if (!val)
+			continue;
+		count++;
+	}
+
+	map->reg_defaults = kmalloc(count * sizeof(struct reg_default),
+				      GFP_KERNEL);
+	if (!map->reg_defaults)
+		return -ENOMEM;
+
+	/* fill the reg_defaults */
+	map->num_reg_defaults = count;
+	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
+		val = regcache_get_val(map->reg_defaults_raw,
+				       i, map->cache_word_size);
+		if (!val)
+			continue;
+		map->reg_defaults[j].reg = i;
+		map->reg_defaults[j].def = val;
+		j++;
+	}
+
+	return 0;
+}
+
+int regcache_init(struct regmap *map)
+{
+	int ret;
+	int i;
+	void *tmp_buf;
+
+	if (map->cache_type == REGCACHE_NONE)
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(cache_types); i++)
+		if (cache_types[i]->type == map->cache_type)
+			break;
+
+	if (i == ARRAY_SIZE(cache_types)) {
+		dev_err(map->dev, "Could not match compress type: %d\n",
+			map->cache_type);
+		return -EINVAL;
+	}
+
+	map->cache = NULL;
+	map->cache_ops = cache_types[i];
+
+	if (!map->cache_ops->read ||
+	    !map->cache_ops->write ||
+	    !map->cache_ops->name)
+		return -EINVAL;
+
+	/* We still need to ensure that the reg_defaults
+	 * won't vanish from under us.  We'll need to make
+	 * a copy of it.
+	 */
+	if (map->reg_defaults) {
+		if (!map->num_reg_defaults)
+			return -EINVAL;
+		tmp_buf = kmemdup(map->reg_defaults, map->num_reg_defaults *
+				  sizeof(struct reg_default), GFP_KERNEL);
+		if (!tmp_buf)
+			return -ENOMEM;
+		map->reg_defaults = tmp_buf;
+	} else {
+		/* Some devices such as PMIC's don't have cache defaults,
+		 * we cope with this by reading back the HW registers and
+		 * crafting the cache defaults by hand.
+		 */
+		ret = regcache_hw_init(map);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (!map->max_register)
+		map->max_register = map->num_reg_defaults_raw;
+
+	if (map->cache_ops->init) {
+		dev_dbg(map->dev, "Initializing %s cache\n",
+			map->cache_ops->name);
+		return map->cache_ops->init(map);
+	}
+	return 0;
+}
+
+void regcache_exit(struct regmap *map)
+{
+	if (map->cache_type == REGCACHE_NONE)
+		return;
+
+	BUG_ON(!map->cache_ops);
+
+	kfree(map->reg_defaults);
+	if (map->cache_free)
+		kfree(map->reg_defaults_raw);
+
+	if (map->cache_ops->exit) {
+		dev_dbg(map->dev, "Destroying %s cache\n",
+			map->cache_ops->name);
+		map->cache_ops->exit(map);
+	}
+}
+
+/**
+ * regcache_read: Fetch the value of a given register from the cache.
+ *
+ * @map: map to configure.
+ * @reg: The register index.
+ * @value: The value to be returned.
+ *
+ * Return a negative value on failure, 0 on success.
+ */
+int regcache_read(struct regmap *map,
+		  unsigned int reg, unsigned int *value)
+{
+	if (map->cache_type == REGCACHE_NONE)
+		return -ENOSYS;
+
+	BUG_ON(!map->cache_ops);
+
+	if (!regmap_readable(map, reg))
+		return -EIO;
+
+	if (!regmap_volatile(map, reg))
+		return map->cache_ops->read(map, reg, value);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(regcache_read);
+
+/**
+ * regcache_write: Set the value of a given register in the cache.
+ *
+ * @map: map to configure.
+ * @reg: The register index.
+ * @value: The new register value.
+ *
+ * Return a negative value on failure, 0 on success.
+ */
+int regcache_write(struct regmap *map,
+		   unsigned int reg, unsigned int value)
+{
+	if (map->cache_type == REGCACHE_NONE)
+		return 0;
+
+	BUG_ON(!map->cache_ops);
+
+	if (!regmap_writeable(map, reg))
+		return -EIO;
+
+	if (!regmap_volatile(map, reg))
+		return map->cache_ops->write(map, reg, value);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(regcache_write);
+
+/**
+ * regcache_sync: Sync the register cache with the hardware.
+ *
+ * @map: map to configure.
+ *
+ * Any registers that should not be synced should be marked as
+ * volatile.  In general drivers can choose not to use the provided
+ * syncing functionality if they so require.
+ *
+ * Return a negative value on failure, 0 on success.
+ */
+int regcache_sync(struct regmap *map)
+{
+	BUG_ON(!map->cache_ops);
+
+	if (map->cache_ops->sync) {
+		dev_dbg(map->dev, "Syncing %s cache\n",
+			map->cache_ops->name);
+		return map->cache_ops->sync(map);
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(regcache_sync);
+
+bool regcache_set_val(void *base, unsigned int idx,
+		      unsigned int val, unsigned int word_size)
+{
+	switch (word_size) {
+	case 1: {
+		u8 *cache = base;
+		if (cache[idx] == val)
+			return true;
+		cache[idx] = val;
+		break;
+	}
+	case 2: {
+		u16 *cache = base;
+		if (cache[idx] == val)
+			return true;
+		cache[idx] = val;
+		break;
+	}
+	default:
+		BUG();
+	}
+	/* unreachable */
+	return false;
+}
+
+unsigned int regcache_get_val(const void *base, unsigned int idx,
+			      unsigned int word_size)
+{
+	if (!base)
+		return -EINVAL;
+
+	switch (word_size) {
+	case 1: {
+		const u8 *cache = base;
+		return cache[idx];
+	}
+	case 2: {
+		const u16 *cache = base;
+		return cache[idx];
+	}
+	default:
+		BUG();
+	}
+	/* unreachable */
+	return -1;
+}
+
+int regcache_lookup_reg(struct regmap *map, unsigned int reg)
+{
+	unsigned int i;
+
+	for (i = 0; i < map->num_reg_defaults; i++)
+		if (map->reg_defaults[i].reg == reg)
+			return i;
+	return -1;
+}
+
+int regcache_insert_reg(struct regmap *map, unsigned int reg,
+			unsigned int val)
+{
+	void *tmp;
+
+	tmp = krealloc(map->reg_defaults,
+		       (map->num_reg_defaults + 1) * sizeof(struct reg_default),
+		       GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	map->reg_defaults = tmp;
+	map->num_reg_defaults++;
+	map->reg_defaults[map->num_reg_defaults - 1].reg = reg;
+	map->reg_defaults[map->num_reg_defaults - 1].def = val;
+	return 0;
+}
