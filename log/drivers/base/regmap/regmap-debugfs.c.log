commit ee43695571c258c0945d4c456ea85b2af9aafdf4
Merge: 60541fb62438 299632e54b2e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 17 09:58:18 2020 -0700

    Merge tag 'regmap-fix-v5.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap into master
    
    Pull regmap fixes from Mark Brown:
     "A couple of substantial fixes here, one from Doug which fixes the
      debugfs code for MMIO regmaps (fortunately not the common case) and
      one from Marc fixing lookups of multiple regmaps for the same device
      (a very unusual case).
    
      There's also a fix for Kconfig to ensure we enable SoundWire properly"
    
    * tag 'regmap-fix-v5.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap:
      regmap: debugfs: Don't sleep while atomic for fast_io regmaps
      regmap: add missing dependency on SoundWire
      regmap: dev_get_regmap_match(): fix string comparison

commit 299632e54b2e692d2830af84be51172480dc1e26
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed Jul 15 16:46:15 2020 -0700

    regmap: debugfs: Don't sleep while atomic for fast_io regmaps
    
    If a regmap has "fast_io" set then its lock function uses a spinlock.
    That doesn't work so well with the functions:
    * regmap_cache_only_write_file()
    * regmap_cache_bypass_write_file()
    
    Both of the above functions have the pattern:
    1. Lock the regmap.
    2. Call:
       debugfs_write_file_bool()
         copy_from_user()
           __might_fault()
             __might_sleep()
    
    Let's reorder things a bit so that we do all of our sleepable
    functions before we grab the lock.
    
    Fixes: d3dc5430d68f ("regmap: debugfs: Allow writes to cache state settings")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Link: https://lore.kernel.org/r/20200715164611.1.I35b3533e8a80efde0cec1cc70f71e1e74b2fa0da@changeid
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index e72843fe41df..e16afa27700d 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -457,29 +457,31 @@ static ssize_t regmap_cache_only_write_file(struct file *file,
 {
 	struct regmap *map = container_of(file->private_data,
 					  struct regmap, cache_only);
-	ssize_t result;
-	bool was_enabled, require_sync = false;
+	bool new_val, require_sync = false;
 	int err;
 
-	map->lock(map->lock_arg);
+	err = kstrtobool_from_user(user_buf, count, &new_val);
+	/* Ignore malforned data like debugfs_write_file_bool() */
+	if (err)
+		return count;
 
-	was_enabled = map->cache_only;
+	err = debugfs_file_get(file->f_path.dentry);
+	if (err)
+		return err;
 
-	result = debugfs_write_file_bool(file, user_buf, count, ppos);
-	if (result < 0) {
-		map->unlock(map->lock_arg);
-		return result;
-	}
+	map->lock(map->lock_arg);
 
-	if (map->cache_only && !was_enabled) {
+	if (new_val && !map->cache_only) {
 		dev_warn(map->dev, "debugfs cache_only=Y forced\n");
 		add_taint(TAINT_USER, LOCKDEP_STILL_OK);
-	} else if (!map->cache_only && was_enabled) {
+	} else if (!new_val && map->cache_only) {
 		dev_warn(map->dev, "debugfs cache_only=N forced: syncing cache\n");
 		require_sync = true;
 	}
+	map->cache_only = new_val;
 
 	map->unlock(map->lock_arg);
+	debugfs_file_put(file->f_path.dentry);
 
 	if (require_sync) {
 		err = regcache_sync(map);
@@ -487,7 +489,7 @@ static ssize_t regmap_cache_only_write_file(struct file *file,
 			dev_err(map->dev, "Failed to sync cache %d\n", err);
 	}
 
-	return result;
+	return count;
 }
 
 static const struct file_operations regmap_cache_only_fops = {
@@ -502,28 +504,32 @@ static ssize_t regmap_cache_bypass_write_file(struct file *file,
 {
 	struct regmap *map = container_of(file->private_data,
 					  struct regmap, cache_bypass);
-	ssize_t result;
-	bool was_enabled;
+	bool new_val;
+	int err;
 
-	map->lock(map->lock_arg);
+	err = kstrtobool_from_user(user_buf, count, &new_val);
+	/* Ignore malforned data like debugfs_write_file_bool() */
+	if (err)
+		return count;
 
-	was_enabled = map->cache_bypass;
+	err = debugfs_file_get(file->f_path.dentry);
+	if (err)
+		return err;
 
-	result = debugfs_write_file_bool(file, user_buf, count, ppos);
-	if (result < 0)
-		goto out;
+	map->lock(map->lock_arg);
 
-	if (map->cache_bypass && !was_enabled) {
+	if (new_val && !map->cache_bypass) {
 		dev_warn(map->dev, "debugfs cache_bypass=Y forced\n");
 		add_taint(TAINT_USER, LOCKDEP_STILL_OK);
-	} else if (!map->cache_bypass && was_enabled) {
+	} else if (!new_val && map->cache_bypass) {
 		dev_warn(map->dev, "debugfs cache_bypass=N forced\n");
 	}
+	map->cache_bypass = new_val;
 
-out:
 	map->unlock(map->lock_arg);
+	debugfs_file_put(file->f_path.dentry);
 
-	return result;
+	return count;
 }
 
 static const struct file_operations regmap_cache_bypass_fops = {

commit 74edd08a4fbf51d65fd8f4c7d8289cd0f392bd91
Author: Peng Fan <peng.fan@nxp.com>
Date:   Fri Mar 13 09:58:07 2020 +0800

    regmap: debugfs: check count when read regmap file
    
    When executing the following command, we met kernel dump.
    dmesg -c > /dev/null; cd /sys;
    for i in `ls /sys/kernel/debug/regmap/* -d`; do
            echo "Checking regmap in $i";
            cat $i/registers;
    done && grep -ri "0x02d0" *;
    
    It is because the count value is too big, and kmalloc fails. So add an
    upper bound check to allow max size `PAGE_SIZE << (MAX_ORDER - 1)`.
    
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Link: https://lore.kernel.org/r/1584064687-12964-1-git-send-email-peng.fan@nxp.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index e72843fe41df..089e5dc7144a 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -227,6 +227,9 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 	if (*ppos < 0 || !count)
 		return -EINVAL;
 
+	if (count > (PAGE_SIZE << (MAX_ORDER - 1)))
+		count = PAGE_SIZE << (MAX_ORDER - 1);
+
 	buf = kmalloc(count, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
@@ -371,6 +374,9 @@ static ssize_t regmap_reg_ranges_read_file(struct file *file,
 	if (*ppos < 0 || !count)
 		return -EINVAL;
 
+	if (count > (PAGE_SIZE << (MAX_ORDER - 1)))
+		count = PAGE_SIZE << (MAX_ORDER - 1);
+
 	buf = kmalloc(count, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;

commit 9d52a35ebd4bb6e495ab06e4ce1f568daa0f70e1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 31 15:29:23 2019 +0200

    regmap: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    The debugfs core will warn if a file or directory can not be created, so
    there's no need to duplicate the warning, nor really do anything else.
    
    Cc: Mark Brown <broonie@kernel.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190731132923.GA13829@kroah.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index e5e1b3a01b1a..e72843fe41df 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -588,14 +588,6 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	}
 
 	map->debugfs = debugfs_create_dir(name, regmap_debugfs_root);
-	if (!map->debugfs) {
-		dev_warn(map->dev,
-			 "Failed to create %s debugfs directory\n", name);
-
-		kfree(map->debugfs_name);
-		map->debugfs_name = NULL;
-		return;
-	}
 
 	debugfs_create_file("name", 0400, map->debugfs,
 			    map, &regmap_name_fops);
@@ -672,10 +664,6 @@ void regmap_debugfs_initcall(void)
 	struct regmap_debugfs_node *node, *tmp;
 
 	regmap_debugfs_root = debugfs_create_dir("regmap", NULL);
-	if (!regmap_debugfs_root) {
-		pr_warn("regmap: Failed to create debugfs root\n");
-		return;
-	}
 
 	mutex_lock(&regmap_debugfs_early_lock);
 	list_for_each_entry_safe(node, tmp, &regmap_debugfs_early_list, link) {

commit 2899872b627e99b7586fe3b6c9f861da1b4d5072
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Fri May 17 13:23:49 2019 +0000

    regmap: debugfs: Fix memory leak in regmap_debugfs_init
    
    As detected by kmemleak running on i.MX6ULL board:
    
    nreferenced object 0xd8366600 (size 64):
      comm "swapper/0", pid 1, jiffies 4294937370 (age 933.220s)
      hex dump (first 32 bytes):
        64 75 6d 6d 79 2d 69 6f 6d 75 78 63 2d 67 70 72  dummy-iomuxc-gpr
        40 32 30 65 34 30 30 30 00 e3 f3 ab fe d1 1b dd  @20e4000........
      backtrace:
        [<b0402aec>] kasprintf+0x2c/0x54
        [<a6fbad2c>] regmap_debugfs_init+0x7c/0x31c
        [<9c8d91fa>] __regmap_init+0xb5c/0xcf4
        [<5b1c3d2a>] of_syscon_register+0x164/0x2c4
        [<596a5d80>] syscon_node_to_regmap+0x64/0x90
        [<49bd597b>] imx6ul_init_machine+0x34/0xa0
        [<250a4dac>] customize_machine+0x1c/0x30
        [<2d19fdaf>] do_one_initcall+0x7c/0x398
        [<e6084469>] kernel_init_freeable+0x328/0x448
        [<168c9101>] kernel_init+0x8/0x114
        [<913268aa>] ret_from_fork+0x14/0x20
        [<ce7b131a>] 0x0
    
    Root cause is that map->debugfs_name is allocated using kasprintf
    and then the pointer is lost by assigning it other memory address.
    
    Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 263f82516ff4..e5e1b3a01b1a 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -579,6 +579,8 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	}
 
 	if (!strcmp(name, "dummy")) {
+		kfree(map->debugfs_name);
+
 		map->debugfs_name = kasprintf(GFP_KERNEL, "dummy%d",
 						dummy_index);
 		name = map->debugfs_name;

commit 37613fa5b762a73073de3c2e23baa4a1da337e71
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 25 20:06:18 2019 +0200

    regmap: add proper SPDX identifiers on files that did not have them.
    
    There were a few files in the regmap code that did not have SPDX
    identifiers on them, so fix that up.  At the same time, remove the "free
    form" text that specified the license of the file, as that is impossible
    for any tool to properly parse.
    
    Also, as Mark loves // comment markers, convert all of the headers to be
    the same to make things look consistent :)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index fc45c2bb961a..263f82516ff4 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -1,14 +1,10 @@
-/*
- * Register map access API - debugfs
- *
- * Copyright 2011 Wolfson Microelectronics plc
- *
- * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
+// SPDX-License-Identifier: GPL-2.0
+//
+// Register map access API - debugfs
+//
+// Copyright 2011 Wolfson Microelectronics plc
+//
+// Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 
 #include <linux/slab.h>
 #include <linux/mutex.h>

commit cc6a8d69ba624f0ad7a09ed095b7bd4b86476489
Author: Lucas Tanure <tanureal@opensource.cirrus.com>
Date:   Tue Mar 19 09:41:33 2019 +0000

    regmap: debugfs: Jump to the next readable register
    
    Improve the speed of the loop jumping to the next
    available register
    
    Signed-off-by: Lucas Tanure <tanureal@opensource.cirrus.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Tested-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 648779e6df88..fc45c2bb961a 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -195,6 +195,28 @@ static inline void regmap_calc_tot_len(struct regmap *map,
 	}
 }
 
+static int regmap_next_readable_reg(struct regmap *map, int reg)
+{
+	struct regmap_debugfs_off_cache *c;
+	int ret = -EINVAL;
+
+	if (regmap_printable(map, reg + map->reg_stride)) {
+		ret = reg + map->reg_stride;
+	} else {
+		mutex_lock(&map->cache_lock);
+		list_for_each_entry(c, &map->debugfs_off_cache, list) {
+			if (reg > c->max_reg)
+				continue;
+			if (reg < c->base_reg) {
+				ret = c->base_reg;
+				break;
+			}
+		}
+		mutex_unlock(&map->cache_lock);
+	}
+	return ret;
+}
+
 static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 				   unsigned int to, char __user *user_buf,
 				   size_t count, loff_t *ppos)
@@ -218,9 +240,8 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 	/* Work out which register we're starting at */
 	start_reg = regmap_debugfs_get_dump_start(map, from, *ppos, &p);
 
-	for (i = start_reg; i <= to; i += map->reg_stride) {
-		if (!regmap_printable(map, i))
-			continue;
+	for (i = start_reg; i >= 0 && i <= to;
+	     i = regmap_next_readable_reg(map, i)) {
 
 		/* If we're in the region the user is trying to read */
 		if (p >= *ppos) {

commit a1c67d65df0b5a3858741a144cd43f8e62c5c175
Author: Lucas Tanure <tanureal@opensource.cirrus.com>
Date:   Tue Mar 19 09:41:32 2019 +0000

    regmap: debugfs: Replace code by already existing function
    
    Signed-off-by: Lucas Tanure <tanureal@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 19eb454f26c3..648779e6df88 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -219,10 +219,7 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 	start_reg = regmap_debugfs_get_dump_start(map, from, *ppos, &p);
 
 	for (i = start_reg; i <= to; i += map->reg_stride) {
-		if (!regmap_readable(map, i) && !regmap_cached(map, i))
-			continue;
-
-		if (regmap_precious(map, i))
+		if (!regmap_printable(map, i))
 			continue;
 
 		/* If we're in the region the user is trying to read */

commit 580d48573c43211fe51f411d484dbb693cc93f7c
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Sat Dec 15 03:41:19 2018 -0500

    regmap: debugfs: convert to DEFINE_SHOW_ATTRIBUTE
    
    Use DEFINE_SHOW_ATTRIBUTE macro to simplify the code.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 87b562e49a43..19eb454f26c3 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -435,17 +435,7 @@ static int regmap_access_show(struct seq_file *s, void *ignored)
 	return 0;
 }
 
-static int access_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, regmap_access_show, inode->i_private);
-}
-
-static const struct file_operations regmap_access_fops = {
-	.open		= access_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(regmap_access);
 
 static ssize_t regmap_cache_only_write_file(struct file *file,
 					    const char __user *user_buf,

commit 59dd2a85040103e95b1c87b1b920d357ee91dada
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Mon Mar 5 23:13:04 2018 -0300

    regmap: debugfs: Improve warning message on debugfs_create_dir() failure
    
    Currently when debugfs_create_dir() fails we receive a warning message
    that provides no indication as to what was the directory entry that
    failed to be created.
    
    Improve the warning message by printing the directory name that failed
    in order to help debugging.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index c84f5ceb015a..87b562e49a43 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -583,7 +583,8 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 
 	map->debugfs = debugfs_create_dir(name, regmap_debugfs_root);
 	if (!map->debugfs) {
-		dev_warn(map->dev, "Failed to create debugfs directory\n");
+		dev_warn(map->dev,
+			 "Failed to create %s debugfs directory\n", name);
 
 		kfree(map->debugfs_name);
 		map->debugfs_name = NULL;

commit 17cf46cfe975f1dd04db6bd38398923846512d49
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Tue Mar 6 19:04:03 2018 +0800

    regmap: debugfs: Free map->debugfs_name when debugfs_create_dir() failed
    
    Free map->debugfs_name when debugfs_create_dir() failed to avoid memory
    leak.
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index dd3a16894e3c..c84f5ceb015a 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -584,6 +584,9 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	map->debugfs = debugfs_create_dir(name, regmap_debugfs_root);
 	if (!map->debugfs) {
 		dev_warn(map->dev, "Failed to create debugfs directory\n");
+
+		kfree(map->debugfs_name);
+		map->debugfs_name = NULL;
 		return;
 	}
 

commit 46589e9c753b7c905e8671a89cbb9728f3b99855
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 5 20:26:51 2018 +0000

    regmap: debugfs: Don't leak dummy names
    
    When allocating dummy names we need to store a pointer to the string we
    allocate so that we don't leak it on free.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index e3e7b91cc421..dd3a16894e3c 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -575,7 +575,9 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	}
 
 	if (!strcmp(name, "dummy")) {
-		name = kasprintf(GFP_KERNEL, "dummy%d", dummy_index);
+		map->debugfs_name = kasprintf(GFP_KERNEL, "dummy%d",
+						dummy_index);
+		name = map->debugfs_name;
 		dummy_index++;
 	}
 

commit a430ab205d29e7d1537b220fcf989b8080d8267f
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Mon Mar 5 15:52:09 2018 -0300

    regmap: debugfs: Disambiguate dummy debugfs file name
    
    Since commit 9b947a13e7f6 ("regmap: use debugfs even when no device")
    allows the usage of regmap debugfs even when there is no device
    associated, which causes several warnings like this:
    
    (NULL device *): Failed to create debugfs directory
    
    This happens when the debugfs file name is 'dummy'.
    
    The first dummy debugfs creation works fine, but subsequent creations
    fail as they have all the same name.
    
    Disambiguate the 'dummy' debugfs file name by adding a suffix entry,
    so that the names become dummy0, dummy1, dummy2, etc.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 7eb512ba2828..e3e7b91cc421 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -25,6 +25,7 @@ struct regmap_debugfs_node {
 	struct list_head link;
 };
 
+static unsigned int dummy_index;
 static struct dentry *regmap_debugfs_root;
 static LIST_HEAD(regmap_debugfs_early_list);
 static DEFINE_MUTEX(regmap_debugfs_early_lock);
@@ -573,6 +574,11 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 		name = devname;
 	}
 
+	if (!strcmp(name, "dummy")) {
+		name = kasprintf(GFP_KERNEL, "dummy%d", dummy_index);
+		dummy_index++;
+	}
+
 	map->debugfs = debugfs_create_dir(name, regmap_debugfs_root);
 	if (!map->debugfs) {
 		dev_warn(map->dev, "Failed to create debugfs directory\n");

commit 12ae3808c160b7be0de3c633ac4cbe8c5f2937bf
Author: David Lechner <david@lechnology.com>
Date:   Mon Feb 19 15:43:01 2018 -0600

    regmap: Allow missing device in regmap_name_read_file()
    
    This fixes a possible NULL pointer dereference oops in
    regmap_name_read_file() when the regmap does not have a device
    associated with it. For example syscon regmaps retrieved with
    syscon_regmap_lookup_by_compatible() don't have a device.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index f3266334063e..7eb512ba2828 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -40,6 +40,7 @@ static ssize_t regmap_name_read_file(struct file *file,
 				     loff_t *ppos)
 {
 	struct regmap *map = file->private_data;
+	const char *name = "nodev";
 	int ret;
 	char *buf;
 
@@ -47,7 +48,10 @@ static ssize_t regmap_name_read_file(struct file *file,
 	if (!buf)
 		return -ENOMEM;
 
-	ret = snprintf(buf, PAGE_SIZE, "%s\n", map->dev->driver->name);
+	if (map->dev && map->dev->driver)
+		name = map->dev->driver->name;
+
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", name);
 	if (ret < 0) {
 		kfree(buf);
 		return ret;

commit 078711d7f88d33b0adebb402a1bcb2aa89afe68b
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Fri Dec 22 18:42:08 2017 +0100

    regmap: debugfs: document why we don't create the debugfs entries
    
    This is a follow-up to commit a5ba91c380b8 ("regmap: debugfs: emit a
    debug message when locking is disabled"). I figured that a user may
    see this message, grep the code, come to this place and he still won't
    know why we actually disabled debugfs.
    
    Add a comment explaining the reason.
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index ae962b756863..f3266334063e 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -529,6 +529,13 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	struct regmap_range_node *range_node;
 	const char *devname = "dummy";
 
+	/*
+	 * Userspace can initiate reads from the hardware over debugfs.
+	 * Normally internal regmap structures and buffers are protected with
+	 * a mutex or a spinlock, but if the regmap owner decided to disable
+	 * all locking mechanisms, this is no longer the case. For safety:
+	 * don't create the debugfs entries if locking is disabled.
+	 */
 	if (map->debugfs_disable) {
 		dev_dbg(map->dev, "regmap locking disabled - not creating debugfs entries\n");
 		return;

commit a5ba91c380b8bcca21e6166fc71c5e5ac9f0db68
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Thu Dec 21 12:12:50 2017 +0100

    regmap: debugfs: emit a debug message when locking is disabled
    
    We currently silently omit creating the debugfs entries when regmap
    locking is disabled. Users may not be aware of the reason for which
    regmap files don't show up in debugfs. Add a dev_dbg() message
    explaining that.
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index c8ecefd75d6f..ae962b756863 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -529,8 +529,10 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	struct regmap_range_node *range_node;
 	const char *devname = "dummy";
 
-	if (map->debugfs_disable)
+	if (map->debugfs_disable) {
+		dev_dbg(map->dev, "regmap locking disabled - not creating debugfs entries\n");
 		return;
+	}
 
 	/* If we don't have the debugfs root yet, postpone init */
 	if (!regmap_debugfs_root) {

commit 72465736adf2aade263a9475a1d42007fd49e703
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 12 16:56:43 2017 +0000

    regmap: Disable debugfs when locking is disabled
    
    The recently added support for disabling the regmap internal locking left
    debugfs enabled for devices with the locking disabled. This is a problem
    since debugfs allows userspace to do things like initiate reads from the
    hardware which will use the scratch buffers protected by the regmap locking
    so could cause data corruption.
    
    For safety address this by just disabling debugfs for these devices. That
    is overly conservative since some of the debugfs files just read internal
    data structures but it's much simpler to implmement and less likely to
    lead to problems with tooling that works with debugfs.
    
    Reported-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 36ce3511c733..c8ecefd75d6f 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -529,6 +529,9 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	struct regmap_range_node *range_node;
 	const char *devname = "dummy";
 
+	if (map->debugfs_disable)
+		return;
+
 	/* If we don't have the debugfs root yet, postpone init */
 	if (!regmap_debugfs_root) {
 		struct regmap_debugfs_node *node;

commit 359a2f17604e2c1c8938be2bba32a8cef9cf6303
Author: Cristian Birsan <cristian.birsan@microchip.com>
Date:   Mon Aug 8 18:44:22 2016 +0300

    regmap: debugfs: Add support for dumping write only device registers
    
    Add support for dumping write only device registers in debugfs. This is
    useful for audio codecs that have write only registers (like WM8731).
    The logic that decides if a value can be printed is moved to
    regmap_printable() function to allow for easier future updates.
    
    Signed-off-by: Cristian Birsan <cristian.birsan@microchip.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 1ee3d40861c7..36ce3511c733 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -77,6 +77,17 @@ static void regmap_debugfs_free_dump_cache(struct regmap *map)
 	}
 }
 
+static bool regmap_printable(struct regmap *map, unsigned int reg)
+{
+	if (regmap_precious(map, reg))
+		return false;
+
+	if (!regmap_readable(map, reg) && !regmap_cached(map, reg))
+		return false;
+
+	return true;
+}
+
 /*
  * Work out where the start offset maps into register numbers, bearing
  * in mind that we suppress hidden registers.
@@ -105,8 +116,7 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	if (list_empty(&map->debugfs_off_cache)) {
 		for (; i <= map->max_register; i += map->reg_stride) {
 			/* Skip unprinted registers, closing off cache entry */
-			if (!regmap_readable(map, i) ||
-			    regmap_precious(map, i)) {
+			if (!regmap_printable(map, i)) {
 				if (c) {
 					c->max = p - 1;
 					c->max_reg = i - map->reg_stride;
@@ -204,7 +214,7 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 	start_reg = regmap_debugfs_get_dump_start(map, from, *ppos, &p);
 
 	for (i = start_reg; i <= to; i += map->reg_stride) {
-		if (!regmap_readable(map, i))
+		if (!regmap_readable(map, i) && !regmap_cached(map, i))
 			continue;
 
 		if (regmap_precious(map, i))

commit 8da61f24cc4a4a66ecae69aa9b9aa8fd989a8969
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Oct 20 15:40:59 2015 +0100

    regmap: debugfs: Use seq_file for the access map
    
    Unlike the registers file we don't have any substantial performance
    concerns rendering the entire file (it involves no device accesses) so
    just use seq_printf() to simplify the code.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 3f0a7e262d69..1ee3d40861c7 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -397,72 +397,39 @@ static const struct file_operations regmap_reg_ranges_fops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t regmap_access_read_file(struct file *file,
-				       char __user *user_buf, size_t count,
-				       loff_t *ppos)
+static int regmap_access_show(struct seq_file *s, void *ignored)
 {
-	int reg_len, tot_len;
-	size_t buf_pos = 0;
-	loff_t p = 0;
-	ssize_t ret;
-	int i;
-	struct regmap *map = file->private_data;
-	char *buf;
-
-	if (*ppos < 0 || !count)
-		return -EINVAL;
+	struct regmap *map = s->private;
+	int i, reg_len;
 
-	buf = kmalloc(count, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	/* Calculate the length of a fixed format  */
 	reg_len = regmap_calc_reg_len(map->max_register);
-	tot_len = reg_len + 10; /* ': R W V P\n' */
 
 	for (i = 0; i <= map->max_register; i += map->reg_stride) {
 		/* Ignore registers which are neither readable nor writable */
 		if (!regmap_readable(map, i) && !regmap_writeable(map, i))
 			continue;
 
-		/* If we're in the region the user is trying to read */
-		if (p >= *ppos) {
-			/* ...but not beyond it */
-			if (buf_pos + tot_len + 1 >= count)
-				break;
-
-			/* Format the register */
-			snprintf(buf + buf_pos, count - buf_pos,
-				 "%.*x: %c %c %c %c\n",
-				 reg_len, i,
-				 regmap_readable(map, i) ? 'y' : 'n',
-				 regmap_writeable(map, i) ? 'y' : 'n',
-				 regmap_volatile(map, i) ? 'y' : 'n',
-				 regmap_precious(map, i) ? 'y' : 'n');
-
-			buf_pos += tot_len;
-		}
-		p += tot_len;
-	}
-
-	ret = buf_pos;
-
-	if (copy_to_user(user_buf, buf, buf_pos)) {
-		ret = -EFAULT;
-		goto out;
+		/* Format the register */
+		seq_printf(s, "%.*x: %c %c %c %c\n", reg_len, i,
+			   regmap_readable(map, i) ? 'y' : 'n',
+			   regmap_writeable(map, i) ? 'y' : 'n',
+			   regmap_volatile(map, i) ? 'y' : 'n',
+			   regmap_precious(map, i) ? 'y' : 'n');
 	}
 
-	*ppos += buf_pos;
+	return 0;
+}
 
-out:
-	kfree(buf);
-	return ret;
+static int access_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, regmap_access_show, inode->i_private);
 }
 
 static const struct file_operations regmap_access_fops = {
-	.open = simple_open,
-	.read = regmap_access_read_file,
-	.llseek = default_llseek,
+	.open		= access_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
 };
 
 static ssize_t regmap_cache_only_write_file(struct file *file,

commit ca07e9f3cb929548feee8b16715983a4ed009eb6
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 30 20:30:27 2015 +0200

    regmap: debugfs: simplify regmap_reg_ranges_read_file() slightly
    
    By printing the newline character to entry, we can avoid accounting
    for it manually in several places.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 69894bb9b6dd..3f0a7e262d69 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -365,17 +365,15 @@ static ssize_t regmap_reg_ranges_read_file(struct file *file,
 	p = 0;
 	mutex_lock(&map->cache_lock);
 	list_for_each_entry(c, &map->debugfs_off_cache, list) {
-		entry_len = snprintf(entry, PAGE_SIZE, "%x-%x",
+		entry_len = snprintf(entry, PAGE_SIZE, "%x-%x\n",
 				     c->base_reg, c->max_reg);
 		if (p >= *ppos) {
-			if (buf_pos + 1 + entry_len > count)
+			if (buf_pos + entry_len > count)
 				break;
 			memcpy(buf + buf_pos, entry, entry_len);
 			buf_pos += entry_len;
-			buf[buf_pos] = '\n';
-			buf_pos++;
 		}
-		p += entry_len + 1;
+		p += entry_len;
 	}
 	mutex_unlock(&map->cache_lock);
 

commit 20991cdb26ffc51030223320a6dd266f4fc28fbd
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 30 20:30:26 2015 +0200

    regmap: debugfs: use memcpy instead of snprintf
    
    Since we know the length of entry and that there's room enough in the
    output buffer, using memcpy instead of snprintf is simpler and
    cheaper.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 1ffc101ca011..69894bb9b6dd 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -370,8 +370,7 @@ static ssize_t regmap_reg_ranges_read_file(struct file *file,
 		if (p >= *ppos) {
 			if (buf_pos + 1 + entry_len > count)
 				break;
-			snprintf(buf + buf_pos, count - buf_pos,
-				 "%s", entry);
+			memcpy(buf + buf_pos, entry, entry_len);
 			buf_pos += entry_len;
 			buf[buf_pos] = '\n';
 			buf_pos++;

commit e34dc490713f8d9dfbbb5bb56d966d90a9344131
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 30 20:30:25 2015 +0200

    regmap: debugfs: use snprintf return value in regmap_reg_ranges_read_file()
    
    Calling strlen() no less than three times on entry is silly. Since
    we're formatting into a buffer with plenty of room, there's no chance
    of truncation, so snprintf() has actually returned the value we want,
    meaning we don't even have to call strlen once.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 4a4737887cce..1ffc101ca011 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -337,6 +337,7 @@ static ssize_t regmap_reg_ranges_read_file(struct file *file,
 	char *buf;
 	char *entry;
 	int ret;
+	unsigned entry_len;
 
 	if (*ppos < 0 || !count)
 		return -EINVAL;
@@ -364,18 +365,18 @@ static ssize_t regmap_reg_ranges_read_file(struct file *file,
 	p = 0;
 	mutex_lock(&map->cache_lock);
 	list_for_each_entry(c, &map->debugfs_off_cache, list) {
-		snprintf(entry, PAGE_SIZE, "%x-%x",
-			 c->base_reg, c->max_reg);
+		entry_len = snprintf(entry, PAGE_SIZE, "%x-%x",
+				     c->base_reg, c->max_reg);
 		if (p >= *ppos) {
-			if (buf_pos + 1 + strlen(entry) > count)
+			if (buf_pos + 1 + entry_len > count)
 				break;
 			snprintf(buf + buf_pos, count - buf_pos,
 				 "%s", entry);
-			buf_pos += strlen(entry);
+			buf_pos += entry_len;
 			buf[buf_pos] = '\n';
 			buf_pos++;
 		}
-		p += strlen(entry) + 1;
+		p += entry_len + 1;
 	}
 	mutex_unlock(&map->cache_lock);
 

commit 9ae3109d1d9ff367e0d0efa7073cc078edb9a372
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Sep 19 07:31:47 2015 -0700

    regmap: debugfs: Remove scratch buffer for register length calculation
    
    Now we no longer use the scratch buffer for register length calculation
    there is no need for callers to supply one.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 4c55cfbad19e..4a4737887cce 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -30,7 +30,7 @@ static LIST_HEAD(regmap_debugfs_early_list);
 static DEFINE_MUTEX(regmap_debugfs_early_lock);
 
 /* Calculate the length of a fixed format  */
-static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)
+static size_t regmap_calc_reg_len(int max_val)
 {
 	return snprintf(NULL, 0, "%x", max_val);
 }
@@ -173,8 +173,7 @@ static inline void regmap_calc_tot_len(struct regmap *map,
 {
 	/* Calculate the length of a fixed format  */
 	if (!map->debugfs_tot_len) {
-		map->debugfs_reg_len = regmap_calc_reg_len(map->max_register,
-							   buf, count);
+		map->debugfs_reg_len = regmap_calc_reg_len(map->max_register),
 		map->debugfs_val_len = 2 * map->format.val_bytes;
 		map->debugfs_tot_len = map->debugfs_reg_len +
 			map->debugfs_val_len + 3;      /* : \n */
@@ -420,7 +419,7 @@ static ssize_t regmap_access_read_file(struct file *file,
 		return -ENOMEM;
 
 	/* Calculate the length of a fixed format  */
-	reg_len = regmap_calc_reg_len(map->max_register, buf, count);
+	reg_len = regmap_calc_reg_len(map->max_register);
 	tot_len = reg_len + 10; /* ': R W V P\n' */
 
 	for (i = 0; i <= map->max_register; i += map->reg_stride) {

commit 176fc2d5770a0990eebff903ba680d2edd32e718
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Sep 19 07:12:34 2015 -0700

    regmap: debugfs: Don't bother actually printing when calculating max length
    
    The in kernel snprintf() will conveniently return the actual length of
    the printed string even if not given an output beffer at all so just do
    that rather than relying on the user to pass in a suitable buffer,
    ensuring that we don't need to worry if the buffer was truncated due to
    the size of the buffer passed in.
    
    Reported-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 1f327898e53d..4c55cfbad19e 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -32,8 +32,7 @@ static DEFINE_MUTEX(regmap_debugfs_early_lock);
 /* Calculate the length of a fixed format  */
 static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)
 {
-	snprintf(buf, buf_size, "%x", max_val);
-	return strlen(buf);
+	return snprintf(NULL, 0, "%x", max_val);
 }
 
 static ssize_t regmap_name_read_file(struct file *file,

commit b763ec17ac762470eec5be8ebcc43e4f8b2c2b82
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Sep 19 07:00:18 2015 -0700

    regmap: debugfs: Ensure we don't underflow when printing access masks
    
    If a read is attempted which is smaller than the line length then we may
    underflow the subtraction we're doing with the unsigned size_t type so
    move some of the calculation to be additions on the right hand side
    instead in order to avoid this.
    
    Reported-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index f42f2bac6466..1f327898e53d 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -432,7 +432,7 @@ static ssize_t regmap_access_read_file(struct file *file,
 		/* If we're in the region the user is trying to read */
 		if (p >= *ppos) {
 			/* ...but not beyond it */
-			if (buf_pos >= count - 1 - tot_len)
+			if (buf_pos + tot_len + 1 >= count)
 				break;
 
 			/* Format the register */

commit 1635e88885a8e16dec21206c981421f1f3c3b1df
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Aug 6 10:35:23 2015 +0800

    regmap: debugfs: Fix misuse of IS_ENABLED
    
    IS_ENABLED should only be used for CONFIG_* symbols.
    
    I have done a small test:
      #define REGMAP_ALLOW_WRITE_DEBUGFS
      IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS) returns 0.
    
      #define REGMAP_ALLOW_WRITE_DEBUGFS 0
      IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS) returns 0.
    
      #define REGMAP_ALLOW_WRITE_DEBUGFS 1
      IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS) returns 1.
    
      #define REGMAP_ALLOW_WRITE_DEBUGFS 2
      IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS) returns 0.
    
    So fix the misuse of IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS) and switch to
    use #if defined(REGMAP_ALLOW_WRITE_DEBUGFS) instead.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 6a61e4fa73a2..f42f2bac6466 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -599,10 +599,11 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	if (map->max_register || regmap_readable(map, 0)) {
 		umode_t registers_mode;
 
-		if (IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS))
-			registers_mode = 0600;
-		else
-			registers_mode = 0400;
+#if defined(REGMAP_ALLOW_WRITE_DEBUGFS)
+		registers_mode = 0600;
+#else
+		registers_mode = 0400;
+#endif
 
 		debugfs_create_file("registers", registers_mode, map->debugfs,
 				    map, &regmap_map_fops);

commit d3dc5430d68fb91a62d971648170b34d46ab85bc
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Tue Jun 23 14:32:55 2015 +0100

    regmap: debugfs: Allow writes to cache state settings
    
    Allow the user to write the cache_only and cache_bypass settings.
    This can be useful for debugging.
    
    Since this can lead to the hardware getting out-of-sync with the
    cache, at least for the period that the cache state is forced, the
    kernel is tainted and the action is recorded in the kernel log.
    
    When disabling cache_only through debugfs a cache sync will be performed.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 5799a0b9e6cc..6a61e4fa73a2 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -469,6 +469,87 @@ static const struct file_operations regmap_access_fops = {
 	.llseek = default_llseek,
 };
 
+static ssize_t regmap_cache_only_write_file(struct file *file,
+					    const char __user *user_buf,
+					    size_t count, loff_t *ppos)
+{
+	struct regmap *map = container_of(file->private_data,
+					  struct regmap, cache_only);
+	ssize_t result;
+	bool was_enabled, require_sync = false;
+	int err;
+
+	map->lock(map->lock_arg);
+
+	was_enabled = map->cache_only;
+
+	result = debugfs_write_file_bool(file, user_buf, count, ppos);
+	if (result < 0) {
+		map->unlock(map->lock_arg);
+		return result;
+	}
+
+	if (map->cache_only && !was_enabled) {
+		dev_warn(map->dev, "debugfs cache_only=Y forced\n");
+		add_taint(TAINT_USER, LOCKDEP_STILL_OK);
+	} else if (!map->cache_only && was_enabled) {
+		dev_warn(map->dev, "debugfs cache_only=N forced: syncing cache\n");
+		require_sync = true;
+	}
+
+	map->unlock(map->lock_arg);
+
+	if (require_sync) {
+		err = regcache_sync(map);
+		if (err)
+			dev_err(map->dev, "Failed to sync cache %d\n", err);
+	}
+
+	return result;
+}
+
+static const struct file_operations regmap_cache_only_fops = {
+	.open = simple_open,
+	.read = debugfs_read_file_bool,
+	.write = regmap_cache_only_write_file,
+};
+
+static ssize_t regmap_cache_bypass_write_file(struct file *file,
+					      const char __user *user_buf,
+					      size_t count, loff_t *ppos)
+{
+	struct regmap *map = container_of(file->private_data,
+					  struct regmap, cache_bypass);
+	ssize_t result;
+	bool was_enabled;
+
+	map->lock(map->lock_arg);
+
+	was_enabled = map->cache_bypass;
+
+	result = debugfs_write_file_bool(file, user_buf, count, ppos);
+	if (result < 0)
+		goto out;
+
+	if (map->cache_bypass && !was_enabled) {
+		dev_warn(map->dev, "debugfs cache_bypass=Y forced\n");
+		add_taint(TAINT_USER, LOCKDEP_STILL_OK);
+	} else if (!map->cache_bypass && was_enabled) {
+		dev_warn(map->dev, "debugfs cache_bypass=N forced\n");
+	}
+
+out:
+	map->unlock(map->lock_arg);
+
+	return result;
+}
+
+static const struct file_operations regmap_cache_bypass_fops = {
+	.open = simple_open,
+	.read = debugfs_read_file_bool,
+	.write = regmap_cache_bypass_write_file,
+};
+
 void regmap_debugfs_init(struct regmap *map, const char *name)
 {
 	struct rb_node *next;
@@ -530,12 +611,13 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	}
 
 	if (map->cache_type) {
-		debugfs_create_bool("cache_only", 0400, map->debugfs,
-				    &map->cache_only);
+		debugfs_create_file("cache_only", 0600, map->debugfs,
+				    &map->cache_only, &regmap_cache_only_fops);
 		debugfs_create_bool("cache_dirty", 0400, map->debugfs,
 				    &map->cache_dirty);
-		debugfs_create_bool("cache_bypass", 0400, map->debugfs,
-				    &map->cache_bypass);
+		debugfs_create_file("cache_bypass", 0600, map->debugfs,
+				    &map->cache_bypass,
+				    &regmap_cache_bypass_fops);
 	}
 
 	next = rb_first(&map->range_tree);

commit 18a64d844c0e98ad00f735f5ea6a3affb6b76639
Merge: 25a948778759 18c0301f9898
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 29 20:49:40 2014 +0100

    Merge remote-tracking branch 'regmap/fix/debugfs' into regmap-linus

commit 18c0301f9898feaac38135b2cea476bb606830e3
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Mon Sep 8 08:43:37 2014 +0200

    regmap: Fix debugfs-file 'registers' mode
    
    The macro "REGMAP_ALLOW_WRITE_DEBUGFS" can be used to enable write
    support on the registers file in the debugfs. The mode of the file is
    fixed to 0400 so it is not possible to write the file ever.
    
    This patch fixes the mode by setting it to the correct value depending
    on the macro.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index bdd88708e4d6..a88cbd42edf0 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -516,7 +516,14 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 			    map, &regmap_reg_ranges_fops);
 
 	if (map->max_register || regmap_readable(map, 0)) {
-		debugfs_create_file("registers", 0400, map->debugfs,
+		umode_t registers_mode;
+
+		if (IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS))
+			registers_mode = 0600;
+		else
+			registers_mode = 0400;
+
+		debugfs_create_file("registers", registers_mode, map->debugfs,
 				    map, &regmap_map_fops);
 		debugfs_create_file("access", 0400, map->debugfs,
 				    map, &regmap_access_fops);

commit 2c98e0c1cc6b8e86f1978286c3d4e0769ee9d733
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Sun Sep 28 11:35:25 2014 +0800

    regmap: debugfs: fix possbile NULL pointer dereference
    
    If 'map->dev' is NULL and there will lead dev_name() to be NULL pointer
    dereference. So before dev_name(), we need to have check of the map->dev
    pionter.
    
    We also should make sure that the 'name' pointer shouldn't be NULL for
    debugfs_create_dir(). So here using one default "dummy" debugfs name when
    the 'name' pointer and 'map->dev' are both NULL.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 45d812c0ea77..bdd88708e4d6 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -473,6 +473,7 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 {
 	struct rb_node *next;
 	struct regmap_range_node *range_node;
+	const char *devname = "dummy";
 
 	/* If we don't have the debugfs root yet, postpone init */
 	if (!regmap_debugfs_root) {
@@ -491,12 +492,15 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	INIT_LIST_HEAD(&map->debugfs_off_cache);
 	mutex_init(&map->cache_lock);
 
+	if (map->dev)
+		devname = dev_name(map->dev);
+
 	if (name) {
 		map->debugfs_name = kasprintf(GFP_KERNEL, "%s-%s",
-					      dev_name(map->dev), name);
+					      devname, name);
 		name = map->debugfs_name;
 	} else {
-		name = dev_name(map->dev);
+		name = devname;
 	}
 
 	map->debugfs = debugfs_create_dir(name, regmap_debugfs_root);

commit 2324067fa9a41b2d0b6ddbc7ac0497d105593b76
Merge: b92178623f19 ffff7a12ace2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 15 16:20:56 2014 -0700

    Merge tag 'regmap-v3.17-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap
    
    Pull regmap fix from Mark Brown:
     "Fix registers file in debugfs
    
      Ensure that the mode reported for the registers file in debugfs is
      accurate by marking it as read only when the define to enable writes
      has not been set.  This is on the edge of being a bug fix but it's
      debugfs and it makes it much easier for users to spot what's going
      wrong when they forget to enable writeability"
    
    * tag 'regmap-v3.17-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap:
      regmap: Fix debugfs-file 'registers' mode

commit ffff7a12ace24c54220631b79abb02ab65780b5a
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Mon Sep 8 08:43:37 2014 +0200

    regmap: Fix debugfs-file 'registers' mode
    
    The macro "REGMAP_ALLOW_WRITE_DEBUGFS" can be used to enable write
    support on the registers file in the debugfs. The mode of the file is
    fixed to 0400 so it is not possible to write the file ever.
    
    This patch fixes the mode by setting it to the correct value depending
    on the macro.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 45d812c0ea77..9c9255142079 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -512,7 +512,14 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 			    map, &regmap_reg_ranges_fops);
 
 	if (map->max_register || regmap_readable(map, 0)) {
-		debugfs_create_file("registers", 0400, map->debugfs,
+		umode_t registers_mode;
+
+		if (IS_ENABLED(REGMAP_ALLOW_WRITE_DEBUGFS))
+			registers_mode = 0600;
+		else
+			registers_mode = 0400;
+
+		debugfs_create_file("registers", registers_mode, map->debugfs,
 				    map, &regmap_map_fops);
 		debugfs_create_file("access", 0400, map->debugfs,
 				    map, &regmap_access_fops);

commit 5e0cbe78762b5f02986bf9e59a188dad2f6e0be1
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Aug 24 15:32:27 2014 +0200

    regmap: Fix regcache debugfs initialization
    
    Commit 6cfec04bcc05 ("regmap: Separate regmap dev initialization") moved the
    regmap debugfs initialization after regcache initialization. This means
    that the regmap debugfs directory is not created yet when the cache
    initialization runs and so any debugfs files registered by the regcache are
    created in the debugfs root directory rather than the debugfs directory of
    the regmap instance. Fix this by adding a separate callback for the
    regcache debugfs initialization which will be called after the parent
    debugfs entry has been created.
    
    Fixes: 6cfec04bcc05 (regmap: Separate regmap dev initialization)
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 45d812c0ea77..65ea7b256b3e 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -538,6 +538,9 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 
 		next = rb_next(&range_node->node);
 	}
+
+	if (map->cache_ops && map->cache_ops->debugfs_init)
+		map->cache_ops->debugfs_init(map);
 }
 
 void regmap_debugfs_exit(struct regmap *map)

commit 676970da5cf6fec096945a8bbc19749089af57aa
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Thu Jan 30 13:26:32 2014 +0000

    regmap: debugfs: "registers" & "access" for single register maps
    
    When a map covers a single register, max_register is equal
    to 0, so the "registers" & "access" files were not created.
    Now they will be, as register 0 must be readable for such
    map to make sense.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index c5471cd6ebb7..45d812c0ea77 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -511,7 +511,7 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	debugfs_create_file("range", 0400, map->debugfs,
 			    map, &regmap_reg_ranges_fops);
 
-	if (map->max_register) {
+	if (map->max_register || regmap_readable(map, 0)) {
 		debugfs_create_file("registers", 0400, map->debugfs,
 				    map, &regmap_map_fops);
 		debugfs_create_file("access", 0400, map->debugfs,

commit a52eaeb1898bc0589888ee62de291aa278379004
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Oct 24 15:03:41 2013 +0300

    regmap: debugfs: Fix a boot time crash with early regmap init
    
    If called early enough, regmap_debugfs_init causes a crash, if the
    fs subsystem does not have its mount cache created yet. Even if this
    would work, the root node for the regmap debugfs is still missing,
    thus postpone the regmap_debugfs_init in this case until the root
    node is created. A special regmap_debugfs_early list is created for
    this purpose which is parsed later in the boot.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index de11ecaf3833..c5471cd6ebb7 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -15,10 +15,19 @@
 #include <linux/debugfs.h>
 #include <linux/uaccess.h>
 #include <linux/device.h>
+#include <linux/list.h>
 
 #include "internal.h"
 
+struct regmap_debugfs_node {
+	struct regmap *map;
+	const char *name;
+	struct list_head link;
+};
+
 static struct dentry *regmap_debugfs_root;
+static LIST_HEAD(regmap_debugfs_early_list);
+static DEFINE_MUTEX(regmap_debugfs_early_lock);
 
 /* Calculate the length of a fixed format  */
 static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)
@@ -465,6 +474,20 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	struct rb_node *next;
 	struct regmap_range_node *range_node;
 
+	/* If we don't have the debugfs root yet, postpone init */
+	if (!regmap_debugfs_root) {
+		struct regmap_debugfs_node *node;
+		node = kzalloc(sizeof(*node), GFP_KERNEL);
+		if (!node)
+			return;
+		node->map = map;
+		node->name = name;
+		mutex_lock(&regmap_debugfs_early_lock);
+		list_add(&node->link, &regmap_debugfs_early_list);
+		mutex_unlock(&regmap_debugfs_early_lock);
+		return;
+	}
+
 	INIT_LIST_HEAD(&map->debugfs_off_cache);
 	mutex_init(&map->cache_lock);
 
@@ -519,18 +542,42 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 
 void regmap_debugfs_exit(struct regmap *map)
 {
-	debugfs_remove_recursive(map->debugfs);
-	mutex_lock(&map->cache_lock);
-	regmap_debugfs_free_dump_cache(map);
-	mutex_unlock(&map->cache_lock);
-	kfree(map->debugfs_name);
+	if (map->debugfs) {
+		debugfs_remove_recursive(map->debugfs);
+		mutex_lock(&map->cache_lock);
+		regmap_debugfs_free_dump_cache(map);
+		mutex_unlock(&map->cache_lock);
+		kfree(map->debugfs_name);
+	} else {
+		struct regmap_debugfs_node *node, *tmp;
+
+		mutex_lock(&regmap_debugfs_early_lock);
+		list_for_each_entry_safe(node, tmp, &regmap_debugfs_early_list,
+					 link) {
+			if (node->map == map) {
+				list_del(&node->link);
+				kfree(node);
+			}
+		}
+		mutex_unlock(&regmap_debugfs_early_lock);
+	}
 }
 
 void regmap_debugfs_initcall(void)
 {
+	struct regmap_debugfs_node *node, *tmp;
+
 	regmap_debugfs_root = debugfs_create_dir("regmap", NULL);
 	if (!regmap_debugfs_root) {
 		pr_warn("regmap: Failed to create debugfs root\n");
 		return;
 	}
+
+	mutex_lock(&regmap_debugfs_early_lock);
+	list_for_each_entry_safe(node, tmp, &regmap_debugfs_early_list, link) {
+		regmap_debugfs_init(node->map, node->name);
+		list_del(&node->link);
+		kfree(node);
+	}
+	mutex_unlock(&regmap_debugfs_early_lock);
 }

commit 542a086ac72fb193cbc1b996963a572269e57743
Merge: 1d1fdd95df68 1eeeef153c02
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 3 11:37:15 2013 -0700

    Merge tag 'driver-core-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core patches from Greg KH:
     "Here's the big driver core pull request for 3.12-rc1.
    
      Lots of tiny changes here fixing up the way sysfs attributes are
      created, to try to make drivers simpler, and fix a whole class race
      conditions with creations of device attributes after the device was
      announced to userspace.
    
      All the various pieces are acked by the different subsystem
      maintainers"
    
    * tag 'driver-core-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (119 commits)
      firmware loader: fix pending_fw_head list corruption
      drivers/base/memory.c: introduce help macro to_memory_block
      dynamic debug: line queries failing due to uninitialized local variable
      sysfs: sysfs_create_groups returns a value.
      debugfs: provide debugfs_create_x64() when disabled
      rbd: convert bus code to use bus_groups
      firmware: dcdbas: use binary attribute groups
      sysfs: add sysfs_create/remove_groups for when SYSFS is not enabled
      driver core: add #include <linux/sysfs.h> to core files.
      HID: convert bus code to use dev_groups
      Input: serio: convert bus code to use drv_groups
      Input: gameport: convert bus code to use drv_groups
      driver core: firmware: use __ATTR_RW()
      driver core: core: use DEVICE_ATTR_RO
      driver core: bus: use DRIVER_ATTR_WO()
      driver core: create write-only attribute macros for devices and drivers
      sysfs: create __ATTR_WO()
      driver-core: platform: convert bus code to use dev_groups
      workqueue: convert bus code to use dev_groups
      MEI: convert bus code to use dev_groups
      ...

commit 26ee47411ae22caa07d3f3b63ca6d097cba6681b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Aug 28 17:55:07 2013 +0200

    regmap: debugfs: Fix continued read from registers file
    
    The regmap_debugfs_get_dump_start() function maps from a file offset to the
    register that can be found at that position in the file. This is done using a
    look-up table. Commit d6814a7d ("regmap: debugfs: Suppress cache for partial
    register files") added a check to bypass the look-up table for partial register
    files, since the offsets in that table are only correct for the full register
    file. The check incorrectly uses the file offset instead of the register base
    address and returns it. This will cause the file offset to be interpreted as a
    register address which will result in a incorrect output from the registers file
    for all reads except at position 0.
    
    The issue can easily be reproduced by doing small reads the registers file, e.g.
    `dd if=registers bs=10 count=5`.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 53495753fbdb..6c2652a8ad50 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -85,8 +85,8 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	unsigned int reg_offset;
 
 	/* Suppress the cache if we're using a subrange */
-	if (from)
-		return from;
+	if (base)
+		return base;
 
 	/*
 	 * If we don't have a cache build one so we don't have to do a

commit 34da5e6770ac06df770a0355b417155e6e84e263
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Jul 26 13:10:22 2013 +0900

    driver core: replace strict_strto*() with kstrto*()
    
    The usage of strict_strto*() is not preferred, because
    strict_strto*() is obsolete. Thus, kstrto*() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 53495753fbdb..634164da9c15 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -281,7 +281,7 @@ static ssize_t regmap_map_write_file(struct file *file,
 	reg = simple_strtoul(start, &start, 16);
 	while (*start == ' ')
 		start++;
-	if (strict_strtoul(start, 16, &value))
+	if (kstrtoul(start, 16, &value))
 		return -EINVAL;
 
 	/* Userspace has been fiddling around behind the kernel's back */

commit ad4f496b445eac30bb6ddc72599bf6dd73529cd2
Merge: 912af52f31e7 213fa5d9685b
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Jun 30 12:40:02 2013 +0100

    Merge remote-tracking branch 'regmap/topic/debugfs' into regmap-next

commit feff98f5507f98c0422252caec41c3be9e6b6399
Merge: 9e895ace5d82 d6814a7dafa5
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Jun 30 12:40:01 2013 +0100

    Merge remote-tracking branch 'regmap/topic/cache' into regmap-next

commit d6814a7dafa590ec5fe0597922ea76354f9bec59
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed May 29 15:54:54 2013 +0100

    regmap: debugfs: Suppress cache for partial register files
    
    The cache is based on the full register map so confuses things if used
    for a partial map.
    
    Reported-by: Bard Liao <bardliao@realtek.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 23b701f5fd2f..686400994868 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -84,6 +84,10 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	unsigned int fpos_offset;
 	unsigned int reg_offset;
 
+	/* Suppress the cache if we're using a subrange */
+	if (from)
+		return from;
+
 	/*
 	 * If we don't have a cache build one so we don't have to do a
 	 * linear scan each time.

commit 213fa5d9685b985e0c61a8db1883a3abf94b18d7
Author: Srinivas Kandagatla <srinivas.kandagatla@st.com>
Date:   Tue May 14 07:54:23 2013 +0100

    regmap: debugfs: Fix return from regmap_debugfs_get_dump_start
    
    regmap_debugfs_get_dump_start should return the offset of the register
    it should start reading from, However in the current code at one point
    the code does not return correct register offset.
    
    With this patch all the returns from this function takes reg_stride in
    to consideration to return correct offset.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 8772fb77e6ed..98cb94e58320 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -145,7 +145,7 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 			reg_offset = fpos_offset / map->debugfs_tot_len;
 			*pos = c->min + (reg_offset * map->debugfs_tot_len);
 			mutex_unlock(&map->cache_lock);
-			return c->base_reg + reg_offset;
+			return c->base_reg + (reg_offset * map->reg_stride);
 		}
 
 		*pos = c->max;

commit f9e464a566a1c3c9b71558e5523288b5432c3e3f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu May 9 14:35:49 2013 +0100

    regmap: debugfs: Don't mark lockdep as broken due to debugfs write
    
    A register write to hardware is reasonably unlikely to cause locking
    dependency issues, the reason we're tainting is that unexpected changes
    in the hardware configuration may confuse drivers.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 975719bc3450..8772fb77e6ed 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -281,7 +281,7 @@ static ssize_t regmap_map_write_file(struct file *file,
 		return -EINVAL;
 
 	/* Userspace has been fiddling around behind the kernel's back */
-	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);
+	add_taint(TAINT_USER, LOCKDEP_STILL_OK);
 
 	ret = regmap_write(map, reg, value);
 	if (ret < 0)

commit 68e850d80df934b9c9c15d8a0956512cb3b6f1fc
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu May 9 12:46:41 2013 +0100

    regmap: debugfs: Check return value of regmap_write()
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 23b701f5fd2f..975719bc3450 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -265,6 +265,7 @@ static ssize_t regmap_map_write_file(struct file *file,
 	char *start = buf;
 	unsigned long reg, value;
 	struct regmap *map = file->private_data;
+	int ret;
 
 	buf_size = min(count, (sizeof(buf)-1));
 	if (copy_from_user(buf, user_buf, buf_size))
@@ -282,7 +283,9 @@ static ssize_t regmap_map_write_file(struct file *file,
 	/* Userspace has been fiddling around behind the kernel's back */
 	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);
 
-	regmap_write(map, reg, value);
+	ret = regmap_write(map, reg, value);
+	if (ret < 0)
+		return ret;
 	return buf_size;
 }
 #else

commit 065b4c587557dcd3dc8d3ff1ba2b9ecc6e0c6668
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Feb 20 12:15:23 2013 +0000

    regmap: debugfs: Add a registers `range' file
    
    This file lists the register ranges in the register map.  The condition
    to split the range is based on whether the block is readable or not.
    
    Ensure that we lock the `debugfs_off_cache' list whenever we access
    and modify the list.  There is a possible race otherwise between the
    read() operations of the `registers' file and the `range' file.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 886b2f7682c2..23b701f5fd2f 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -88,6 +88,7 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	 * If we don't have a cache build one so we don't have to do a
 	 * linear scan each time.
 	 */
+	mutex_lock(&map->cache_lock);
 	i = base;
 	if (list_empty(&map->debugfs_off_cache)) {
 		for (; i <= map->max_register; i += map->reg_stride) {
@@ -110,6 +111,7 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 				c = kzalloc(sizeof(*c), GFP_KERNEL);
 				if (!c) {
 					regmap_debugfs_free_dump_cache(map);
+					mutex_unlock(&map->cache_lock);
 					return base;
 				}
 				c->min = p;
@@ -142,12 +144,14 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 			fpos_offset = from - c->min;
 			reg_offset = fpos_offset / map->debugfs_tot_len;
 			*pos = c->min + (reg_offset * map->debugfs_tot_len);
+			mutex_unlock(&map->cache_lock);
 			return c->base_reg + reg_offset;
 		}
 
 		*pos = c->max;
 		ret = c->max_reg;
 	}
+	mutex_unlock(&map->cache_lock);
 
 	return ret;
 }
@@ -308,6 +312,79 @@ static const struct file_operations regmap_range_fops = {
 	.llseek = default_llseek,
 };
 
+static ssize_t regmap_reg_ranges_read_file(struct file *file,
+					   char __user *user_buf, size_t count,
+					   loff_t *ppos)
+{
+	struct regmap *map = file->private_data;
+	struct regmap_debugfs_off_cache *c;
+	loff_t p = 0;
+	size_t buf_pos = 0;
+	char *buf;
+	char *entry;
+	int ret;
+
+	if (*ppos < 0 || !count)
+		return -EINVAL;
+
+	buf = kmalloc(count, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	entry = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!entry) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	/* While we are at it, build the register dump cache
+	 * now so the read() operation on the `registers' file
+	 * can benefit from using the cache.  We do not care
+	 * about the file position information that is contained
+	 * in the cache, just about the actual register blocks */
+	regmap_calc_tot_len(map, buf, count);
+	regmap_debugfs_get_dump_start(map, 0, *ppos, &p);
+
+	/* Reset file pointer as the fixed-format of the `registers'
+	 * file is not compatible with the `range' file */
+	p = 0;
+	mutex_lock(&map->cache_lock);
+	list_for_each_entry(c, &map->debugfs_off_cache, list) {
+		snprintf(entry, PAGE_SIZE, "%x-%x",
+			 c->base_reg, c->max_reg);
+		if (p >= *ppos) {
+			if (buf_pos + 1 + strlen(entry) > count)
+				break;
+			snprintf(buf + buf_pos, count - buf_pos,
+				 "%s", entry);
+			buf_pos += strlen(entry);
+			buf[buf_pos] = '\n';
+			buf_pos++;
+		}
+		p += strlen(entry) + 1;
+	}
+	mutex_unlock(&map->cache_lock);
+
+	kfree(entry);
+	ret = buf_pos;
+
+	if (copy_to_user(user_buf, buf, buf_pos)) {
+		ret = -EFAULT;
+		goto out_buf;
+	}
+
+	*ppos += buf_pos;
+out_buf:
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations regmap_reg_ranges_fops = {
+	.open = simple_open,
+	.read = regmap_reg_ranges_read_file,
+	.llseek = default_llseek,
+};
+
 static ssize_t regmap_access_read_file(struct file *file,
 				       char __user *user_buf, size_t count,
 				       loff_t *ppos)
@@ -382,6 +459,7 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	struct regmap_range_node *range_node;
 
 	INIT_LIST_HEAD(&map->debugfs_off_cache);
+	mutex_init(&map->cache_lock);
 
 	if (name) {
 		map->debugfs_name = kasprintf(GFP_KERNEL, "%s-%s",
@@ -400,6 +478,9 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	debugfs_create_file("name", 0400, map->debugfs,
 			    map, &regmap_name_fops);
 
+	debugfs_create_file("range", 0400, map->debugfs,
+			    map, &regmap_reg_ranges_fops);
+
 	if (map->max_register) {
 		debugfs_create_file("registers", 0400, map->debugfs,
 				    map, &regmap_map_fops);
@@ -432,7 +513,9 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 void regmap_debugfs_exit(struct regmap *map)
 {
 	debugfs_remove_recursive(map->debugfs);
+	mutex_lock(&map->cache_lock);
 	regmap_debugfs_free_dump_cache(map);
+	mutex_unlock(&map->cache_lock);
 	kfree(map->debugfs_name);
 }
 

commit 480738de0e076d759a973be623fac195cb901b82
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Feb 20 12:15:22 2013 +0000

    regmap: debugfs: Simplify calculation of `c->max_reg'
    
    We don't need to use any of the file position information
    to calculate the base and max register of each block.  Just
    use the counter directly.
    
    Set `i = base' at the top to avoid GCC flow analysis bugs.  The
    value of `i' can never be undefined or 0 in the if (c) { ... }.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 81d6f605c92e..886b2f7682c2 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -88,16 +88,15 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	 * If we don't have a cache build one so we don't have to do a
 	 * linear scan each time.
 	 */
+	i = base;
 	if (list_empty(&map->debugfs_off_cache)) {
-		for (i = base; i <= map->max_register; i += map->reg_stride) {
+		for (; i <= map->max_register; i += map->reg_stride) {
 			/* Skip unprinted registers, closing off cache entry */
 			if (!regmap_readable(map, i) ||
 			    regmap_precious(map, i)) {
 				if (c) {
 					c->max = p - 1;
-					fpos_offset = c->max - c->min;
-					reg_offset = fpos_offset / map->debugfs_tot_len;
-					c->max_reg = c->base_reg + reg_offset;
+					c->max_reg = i - map->reg_stride;
 					list_add_tail(&c->list,
 						      &map->debugfs_off_cache);
 					c = NULL;
@@ -124,9 +123,7 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	/* Close the last entry off if we didn't scan beyond it */
 	if (c) {
 		c->max = p - 1;
-		fpos_offset = c->max - c->min;
-		reg_offset = fpos_offset / map->debugfs_tot_len;
-		c->max_reg = c->base_reg + reg_offset;
+		c->max_reg = i - map->reg_stride;
 		list_add_tail(&c->list,
 			      &map->debugfs_off_cache);
 	}

commit 9043a2650cd21f96f831a97f516c2c302e21fb70
Merge: ab7826595e9e d9d8d7ed498e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 15:41:43 2013 -0800

    Merge tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull module update from Rusty Russell:
     "The sweeping change is to make add_taint() explicitly indicate whether
      to disable lockdep, but it's a mechanical change."
    
    * tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux:
      MODSIGN: Add option to not sign modules during modules_install
      MODSIGN: Add -s <signature> option to sign-file
      MODSIGN: Specify the hash algorithm on sign-file command line
      MODSIGN: Simplify Makefile with a Kconfig helper
      module: clean up load_module a little more.
      modpost: Ignore ARC specific non-alloc sections
      module: constify within_module_*
      taint: add explicit flag to show whether lock dep is still OK.
      module: printk message when module signature fail taints kernel.

commit 4dd7c5531d3b046574da39096b1a66c738aca102
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Feb 11 10:50:59 2013 +0000

    regmap: debugfs: Factor out debugfs_tot_len calc into a function
    
    In preparation to support the regmap debugfs ranges functionality
    factor this code out to a separate function.  We'll need to ensure
    that the value has been correctly calculated from two separate places
    in the code.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 246f459e9170..78d5f20c5f5b 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -155,6 +155,19 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	return ret;
 }
 
+static inline void regmap_calc_tot_len(struct regmap *map,
+				       void *buf, size_t count)
+{
+	/* Calculate the length of a fixed format  */
+	if (!map->debugfs_tot_len) {
+		map->debugfs_reg_len = regmap_calc_reg_len(map->max_register,
+							   buf, count);
+		map->debugfs_val_len = 2 * map->format.val_bytes;
+		map->debugfs_tot_len = map->debugfs_reg_len +
+			map->debugfs_val_len + 3;      /* : \n */
+	}
+}
+
 static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 				   unsigned int to, char __user *user_buf,
 				   size_t count, loff_t *ppos)
@@ -173,14 +186,7 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 	if (!buf)
 		return -ENOMEM;
 
-	/* Calculate the length of a fixed format  */
-	if (!map->debugfs_tot_len) {
-		map->debugfs_reg_len = regmap_calc_reg_len(map->max_register,
-							   buf, count);
-		map->debugfs_val_len = 2 * map->format.val_bytes;
-		map->debugfs_tot_len = map->debugfs_reg_len +
-			map->debugfs_val_len + 3;      /* : \n */
-	}
+	regmap_calc_tot_len(map, buf, count);
 
 	/* Work out which register we're starting at */
 	start_reg = regmap_debugfs_get_dump_start(map, from, *ppos, &p);

commit cf57d6071f0610c99856c006ac06eb98a151f485
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Fri Feb 8 12:47:20 2013 +0000

    regmap: debugfs: Optimize seeking within blocks of registers
    
    Optimize this so that we can better guess where to start scanning
    from.  We know the length of the register field format, therefore
    given the file pointer position align to the nearest register
    field and scan from there onwards.  We round down in this calculation
    and we let the rest of the code figure out where to start scanning
    from.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 3fade1ceaf15..246f459e9170 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -139,15 +139,17 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	WARN_ON(list_empty(&map->debugfs_off_cache));
 	ret = base;
 
-	/* Find the relevant block */
+	/* Find the relevant block:offset */
 	list_for_each_entry(c, &map->debugfs_off_cache, list) {
 		if (from >= c->min && from <= c->max) {
-			*pos = c->min;
-			return c->base_reg;
+			fpos_offset = from - c->min;
+			reg_offset = fpos_offset / map->debugfs_tot_len;
+			*pos = c->min + (reg_offset * map->debugfs_tot_len);
+			return c->base_reg + reg_offset;
 		}
 
-		*pos = c->min;
-		ret = c->base_reg;
+		*pos = c->max;
+		ret = c->max_reg;
 	}
 
 	return ret;

commit c2c1ee66016a45477f58f0fd30907b1e959ca76b
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Fri Feb 8 12:47:14 2013 +0000

    regmap: debugfs: Add a `max_reg' member in struct regmap_debugfs_off_cache
    
    We are keeping track of the maximum register as well, this will make
    things easier for us in sharing this code with the code implementing
    the register ranges functionality.  It also simplifies a bit the
    calculations when looking for the relevant block:offset from within
    the cache.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 0e94fd3c95a3..3fade1ceaf15 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -81,6 +81,8 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	struct regmap_debugfs_off_cache *c = NULL;
 	loff_t p = 0;
 	unsigned int i, ret;
+	unsigned int fpos_offset;
+	unsigned int reg_offset;
 
 	/*
 	 * If we don't have a cache build one so we don't have to do a
@@ -93,6 +95,9 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 			    regmap_precious(map, i)) {
 				if (c) {
 					c->max = p - 1;
+					fpos_offset = c->max - c->min;
+					reg_offset = fpos_offset / map->debugfs_tot_len;
+					c->max_reg = c->base_reg + reg_offset;
 					list_add_tail(&c->list,
 						      &map->debugfs_off_cache);
 					c = NULL;
@@ -119,6 +124,9 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	/* Close the last entry off if we didn't scan beyond it */
 	if (c) {
 		c->max = p - 1;
+		fpos_offset = c->max - c->min;
+		reg_offset = fpos_offset / map->debugfs_tot_len;
+		c->max_reg = c->base_reg + reg_offset;
 		list_add_tail(&c->list,
 			      &map->debugfs_off_cache);
 	}

commit f3eb83994cb4c172ce5028b5ae7ea08462cc3f1d
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Feb 7 10:51:56 2013 +0000

    regmap: debugfs: Fix reading in register field units
    
    At the moment, if the length of the register field format is
    N bytes, we can only get anything meaningful back to userspace
    by providing a buffer that is N + 2 bytes large.  Fix this
    so we that we only need to provide a buffer of N bytes.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index faa93cc6802e..0e94fd3c95a3 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -185,7 +185,7 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 		/* If we're in the region the user is trying to read */
 		if (p >= *ppos) {
 			/* ...but not beyond it */
-			if (buf_pos + 1 + map->debugfs_tot_len >= count)
+			if (buf_pos + map->debugfs_tot_len > count)
 				break;
 
 			/* Format the register */

commit a3471469bcba61f8f18ca4c267b0cdd90a61e035
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 26 11:45:35 2013 +0000

    regmap: regmap: avoid spurious warning in regmap_read_debugfs
    
    Gcc warns about the case where regmap_read_debugfs tries to walk an
    empty map->debugfs_off_cache list, which would results in uninitialized
    variable getting returned, if we hadn't checked the same condition
    just before that.
    
    After an originally suggested inferior patch from Arnd Bergmann,
    this is the solution that Russell King came up with, sidestepping
    the problem by merging the error case for an empty list with the
    normal path.
    
    Without this patch, building mxs_defconfig results in:
    
    drivers/base/regmap/regmap-debugfs.c: In function 'regmap_read_debugfs':
    drivers/base/regmap/regmap-debugfs.c:147:9: : warning: 'ret' may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    Reported-by: Vincent Stehle <v-stehle@ti.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index d9a6c94ce423..faa93cc6802e 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -128,10 +128,8 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 	 * allocate and we should never be in this code if there are
 	 * no registers at all.
 	 */
-	if (list_empty(&map->debugfs_off_cache)) {
-		WARN_ON(list_empty(&map->debugfs_off_cache));
-		return base;
-	}
+	WARN_ON(list_empty(&map->debugfs_off_cache));
+	ret = base;
 
 	/* Find the relevant block */
 	list_for_each_entry(c, &map->debugfs_off_cache, list) {

commit 373d4d099761cb1f637bed488ab3871945882273
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Jan 21 17:17:39 2013 +1030

    taint: add explicit flag to show whether lock dep is still OK.
    
    Fix up all callers as they were before, with make one change: an
    unsigned module taints the kernel, but doesn't turn off lockdep.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 46a213a596e2..f63c830083ec 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -267,7 +267,7 @@ static ssize_t regmap_map_write_file(struct file *file,
 		return -EINVAL;
 
 	/* Userspace has been fiddling around behind the kernel's back */
-	add_taint(TAINT_USER);
+	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);
 
 	regmap_write(map, reg, value);
 	return buf_size;

commit f32ca3db7f0b05a88edf37ccb00e262290a213e7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jan 17 00:33:36 2013 +0900

    regmap: debugfs: Fix seeking from the cache
    
    We don't want to bomb out early if we failed to get the cache any more,
    just soldier on instead and we won't get confused and always return the
    first block.
    
    Reported-by: Philipp Zabel <p.zabel@pengutronix.de
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 46a213a596e2..d9a6c94ce423 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -121,8 +121,6 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 		c->max = p - 1;
 		list_add_tail(&c->list,
 			      &map->debugfs_off_cache);
-	} else {
-		return base;
 	}
 
 	/*

commit e8d6539c8a94b88fc7ca5d6bdd9eeb0e64b434e4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 8 18:47:52 2013 +0000

    regmap: debugfs: Make sure we store the last entry in the offset cache
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 720e14248167..46a213a596e2 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -116,6 +116,15 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 		}
 	}
 
+	/* Close the last entry off if we didn't scan beyond it */
+	if (c) {
+		c->max = p - 1;
+		list_add_tail(&c->list,
+			      &map->debugfs_off_cache);
+	} else {
+		return base;
+	}
+
 	/*
 	 * This should never happen; we return above if we fail to
 	 * allocate and we should never be in this code if there are

commit 5bd9f4bb34c16b62725b9486a290c01b1fdfec1c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 8 13:44:50 2013 +0000

    regmap: debugfs: Ensure a correct return value for empty caches
    
    This should never happen in the real world.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 9099cd33fbcb..720e14248167 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -116,6 +116,16 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 		}
 	}
 
+	/*
+	 * This should never happen; we return above if we fail to
+	 * allocate and we should never be in this code if there are
+	 * no registers at all.
+	 */
+	if (list_empty(&map->debugfs_off_cache)) {
+		WARN_ON(list_empty(&map->debugfs_off_cache));
+		return base;
+	}
+
 	/* Find the relevant block */
 	list_for_each_entry(c, &map->debugfs_off_cache, list) {
 		if (from >= c->min && from <= c->max) {

commit 95f971c745a343255744703dc4ae8d78508519cc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 8 13:35:58 2013 +0000

    regmap: debugfs: Discard the cache if we fail to allocate an entry
    
    Rather than trying to soldier on with a partially allocated cache just
    throw the cache away and pretend we don't have one in case we can get a
    full cache next time around.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index e8d15db2f126..9099cd33fbcb 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -56,6 +56,19 @@ static const struct file_operations regmap_name_fops = {
 	.llseek = default_llseek,
 };
 
+static void regmap_debugfs_free_dump_cache(struct regmap *map)
+{
+	struct regmap_debugfs_off_cache *c;
+
+	while (!list_empty(&map->debugfs_off_cache)) {
+		c = list_first_entry(&map->debugfs_off_cache,
+				     struct regmap_debugfs_off_cache,
+				     list);
+		list_del(&c->list);
+		kfree(c);
+	}
+}
+
 /*
  * Work out where the start offset maps into register numbers, bearing
  * in mind that we suppress hidden registers.
@@ -91,8 +104,10 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 			/* No cache entry?  Start a new one */
 			if (!c) {
 				c = kzalloc(sizeof(*c), GFP_KERNEL);
-				if (!c)
-					break;
+				if (!c) {
+					regmap_debugfs_free_dump_cache(map);
+					return base;
+				}
 				c->min = p;
 				c->base_reg = i;
 			}
@@ -388,16 +403,8 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 
 void regmap_debugfs_exit(struct regmap *map)
 {
-	struct regmap_debugfs_off_cache *c;
-
 	debugfs_remove_recursive(map->debugfs);
-	while (!list_empty(&map->debugfs_off_cache)) {
-		c = list_first_entry(&map->debugfs_off_cache,
-				     struct regmap_debugfs_off_cache,
-				     list);
-		list_del(&c->list);
-		kfree(c);
-	}
+	regmap_debugfs_free_dump_cache(map);
 	kfree(map->debugfs_name);
 }
 

commit 5a1d6d172bc8a3ecf29add6c84d047025cb71566
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 8 20:40:19 2013 +0000

    regmap: debugfs: Fix check for block start in cached seeks
    
    Check for the block we were asked to start from, not the position we're
    in.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 43d51dc3d58b..e8d15db2f126 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -103,7 +103,7 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 
 	/* Find the relevant block */
 	list_for_each_entry(c, &map->debugfs_off_cache, list) {
-		if (*pos >= c->min && *pos <= c->max) {
+		if (from >= c->min && from <= c->max) {
 			*pos = c->min;
 			return c->base_reg;
 		}

commit 120f80518125b8c312007a54106759d608487553
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 2 15:32:00 2013 +0000

    regmap: debugfs: Fix attempts to read nonexistant register blocks
    
    Return the start of the last block we tried to read rather than a position,
    and also make sure we update the byte position while we're at it.  Without
    this reads that go into nonexistant areas get confused.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 07aad786f817..43d51dc3d58b 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -108,7 +108,8 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 			return c->base_reg;
 		}
 
-		ret = c->max;
+		*pos = c->min;
+		ret = c->base_reg;
 	}
 
 	return ret;

commit 5166b7c006eeb4f6becc0822974d8da259484ba1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 11 01:24:29 2012 +0900

    regmap: debugfs: Cache offsets of valid regions for dump
    
    Avoid doing a linear scan of the entire register map for each read() of
    the debugfs register dump by recording the offsets where valid registers
    exist when we first read the registers file. This assumes the set of
    valid registers never changes, if this is not the case invalidation of
    the cache will be required.
    
    This could be further improved for large blocks of contiguous registers
    by calculating the register we will read from within the block - currently
    we do a linear scan of the block. An rbtree may also be worthwhile.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 749a1dc5bbfb..07aad786f817 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -65,25 +65,53 @@ static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
 						  loff_t from,
 						  loff_t *pos)
 {
-	loff_t p = *pos;
-	unsigned int i;
-
-	for (i = base; i <= map->max_register; i += map->reg_stride) {
-		if (!regmap_readable(map, i))
-			continue;
-
-		if (regmap_precious(map, i))
-			continue;
+	struct regmap_debugfs_off_cache *c = NULL;
+	loff_t p = 0;
+	unsigned int i, ret;
+
+	/*
+	 * If we don't have a cache build one so we don't have to do a
+	 * linear scan each time.
+	 */
+	if (list_empty(&map->debugfs_off_cache)) {
+		for (i = base; i <= map->max_register; i += map->reg_stride) {
+			/* Skip unprinted registers, closing off cache entry */
+			if (!regmap_readable(map, i) ||
+			    regmap_precious(map, i)) {
+				if (c) {
+					c->max = p - 1;
+					list_add_tail(&c->list,
+						      &map->debugfs_off_cache);
+					c = NULL;
+				}
+
+				continue;
+			}
+
+			/* No cache entry?  Start a new one */
+			if (!c) {
+				c = kzalloc(sizeof(*c), GFP_KERNEL);
+				if (!c)
+					break;
+				c->min = p;
+				c->base_reg = i;
+			}
+
+			p += map->debugfs_tot_len;
+		}
+	}
 
-		if (i >= from) {
-			*pos = p;
-			return i;
+	/* Find the relevant block */
+	list_for_each_entry(c, &map->debugfs_off_cache, list) {
+		if (*pos >= c->min && *pos <= c->max) {
+			*pos = c->min;
+			return c->base_reg;
 		}
 
-		p += map->debugfs_tot_len;
+		ret = c->max;
 	}
 
-	return base;
+	return ret;
 }
 
 static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
@@ -309,6 +337,8 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 	struct rb_node *next;
 	struct regmap_range_node *range_node;
 
+	INIT_LIST_HEAD(&map->debugfs_off_cache);
+
 	if (name) {
 		map->debugfs_name = kasprintf(GFP_KERNEL, "%s-%s",
 					      dev_name(map->dev), name);
@@ -357,7 +387,16 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 
 void regmap_debugfs_exit(struct regmap *map)
 {
+	struct regmap_debugfs_off_cache *c;
+
 	debugfs_remove_recursive(map->debugfs);
+	while (!list_empty(&map->debugfs_off_cache)) {
+		c = list_first_entry(&map->debugfs_off_cache,
+				     struct regmap_debugfs_off_cache,
+				     list);
+		list_del(&c->list);
+		kfree(c);
+	}
 	kfree(map->debugfs_name);
 }
 

commit afab2f7b21b042bcbffb1e82f78243382a122d70
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Dec 9 17:20:10 2012 +0900

    regmap: debugfs: Factor out initial seek
    
    In preparation for doing things a bit more quickly than a linear scan
    factor out the initial seek from the debugfs register dump.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 3df274e06062..749a1dc5bbfb 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -56,16 +56,46 @@ static const struct file_operations regmap_name_fops = {
 	.llseek = default_llseek,
 };
 
+/*
+ * Work out where the start offset maps into register numbers, bearing
+ * in mind that we suppress hidden registers.
+ */
+static unsigned int regmap_debugfs_get_dump_start(struct regmap *map,
+						  unsigned int base,
+						  loff_t from,
+						  loff_t *pos)
+{
+	loff_t p = *pos;
+	unsigned int i;
+
+	for (i = base; i <= map->max_register; i += map->reg_stride) {
+		if (!regmap_readable(map, i))
+			continue;
+
+		if (regmap_precious(map, i))
+			continue;
+
+		if (i >= from) {
+			*pos = p;
+			return i;
+		}
+
+		p += map->debugfs_tot_len;
+	}
+
+	return base;
+}
+
 static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 				   unsigned int to, char __user *user_buf,
 				   size_t count, loff_t *ppos)
 {
 	size_t buf_pos = 0;
-	loff_t p = 0;
+	loff_t p = *ppos;
 	ssize_t ret;
 	int i;
 	char *buf;
-	unsigned int val;
+	unsigned int val, start_reg;
 
 	if (*ppos < 0 || !count)
 		return -EINVAL;
@@ -83,7 +113,10 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 			map->debugfs_val_len + 3;      /* : \n */
 	}
 
-	for (i = from; i <= to; i += map->reg_stride) {
+	/* Work out which register we're starting at */
+	start_reg = regmap_debugfs_get_dump_start(map, from, *ppos, &p);
+
+	for (i = start_reg; i <= to; i += map->reg_stride) {
 		if (!regmap_readable(map, i))
 			continue;
 

commit db04328c167ff8e7c57f4a3532214aeada3a82fd
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 11 01:14:11 2012 +0900

    regmap: debugfs: Avoid overflows for very small reads
    
    If count is less than the size of a register then we may hit integer
    wraparound when trying to move backwards to check if we're still in
    the buffer. Instead move the position forwards to check if it's still
    in the buffer, we are unlikely to be able to allocate a buffer
    sufficiently big to overflow here.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 00fbd58706b2..3df274e06062 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -93,7 +93,7 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 		/* If we're in the region the user is trying to read */
 		if (p >= *ppos) {
 			/* ...but not beyond it */
-			if (buf_pos >= count - 1 - map->debugfs_tot_len)
+			if (buf_pos + 1 + map->debugfs_tot_len >= count)
 				break;
 
 			/* Format the register */

commit cbc1938badc31f43ab77e92a9b1a51c4fe8b4113
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 6 13:29:05 2012 +0900

    regmap: Cache register and value sizes for debugfs
    
    No point in calculating them every time.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index f4b9dd01c981..00fbd58706b2 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -60,7 +60,6 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 				   unsigned int to, char __user *user_buf,
 				   size_t count, loff_t *ppos)
 {
-	int reg_len, val_len, tot_len;
 	size_t buf_pos = 0;
 	loff_t p = 0;
 	ssize_t ret;
@@ -76,9 +75,13 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 		return -ENOMEM;
 
 	/* Calculate the length of a fixed format  */
-	reg_len = regmap_calc_reg_len(map->max_register, buf, count);
-	val_len = 2 * map->format.val_bytes;
-	tot_len = reg_len + val_len + 3;      /* : \n */
+	if (!map->debugfs_tot_len) {
+		map->debugfs_reg_len = regmap_calc_reg_len(map->max_register,
+							   buf, count);
+		map->debugfs_val_len = 2 * map->format.val_bytes;
+		map->debugfs_tot_len = map->debugfs_reg_len +
+			map->debugfs_val_len + 3;      /* : \n */
+	}
 
 	for (i = from; i <= to; i += map->reg_stride) {
 		if (!regmap_readable(map, i))
@@ -90,26 +93,27 @@ static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
 		/* If we're in the region the user is trying to read */
 		if (p >= *ppos) {
 			/* ...but not beyond it */
-			if (buf_pos >= count - 1 - tot_len)
+			if (buf_pos >= count - 1 - map->debugfs_tot_len)
 				break;
 
 			/* Format the register */
 			snprintf(buf + buf_pos, count - buf_pos, "%.*x: ",
-				 reg_len, i - from);
-			buf_pos += reg_len + 2;
+				 map->debugfs_reg_len, i - from);
+			buf_pos += map->debugfs_reg_len + 2;
 
 			/* Format the value, write all X if we can't read */
 			ret = regmap_read(map, i, &val);
 			if (ret == 0)
 				snprintf(buf + buf_pos, count - buf_pos,
-					 "%.*x", val_len, val);
+					 "%.*x", map->debugfs_val_len, val);
 			else
-				memset(buf + buf_pos, 'X', val_len);
+				memset(buf + buf_pos, 'X',
+				       map->debugfs_val_len);
 			buf_pos += 2 * map->format.val_bytes;
 
 			buf[buf_pos++] = '\n';
 		}
-		p += tot_len;
+		p += map->debugfs_tot_len;
 	}
 
 	ret = buf_pos;

commit 4b020b3f9ba2af8031c5c7d759fbafd234d1c390
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Oct 3 13:13:16 2012 +0100

    regmap: Provide debugfs read of register ranges
    
    If a register range is named then provide a debugfs file showing the
    contents of the range separately.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 25b6843d6a41..f4b9dd01c981 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -183,6 +183,22 @@ static const struct file_operations regmap_map_fops = {
 	.llseek = default_llseek,
 };
 
+static ssize_t regmap_range_read_file(struct file *file, char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	struct regmap_range_node *range = file->private_data;
+	struct regmap *map = range->map;
+
+	return regmap_read_debugfs(map, range->range_min, range->range_max,
+				   user_buf, count, ppos);
+}
+
+static const struct file_operations regmap_range_fops = {
+	.open = simple_open,
+	.read = regmap_range_read_file,
+	.llseek = default_llseek,
+};
+
 static ssize_t regmap_access_read_file(struct file *file,
 				       char __user *user_buf, size_t count,
 				       loff_t *ppos)
@@ -253,6 +269,9 @@ static const struct file_operations regmap_access_fops = {
 
 void regmap_debugfs_init(struct regmap *map, const char *name)
 {
+	struct rb_node *next;
+	struct regmap_range_node *range_node;
+
 	if (name) {
 		map->debugfs_name = kasprintf(GFP_KERNEL, "%s-%s",
 					      dev_name(map->dev), name);
@@ -285,6 +304,18 @@ void regmap_debugfs_init(struct regmap *map, const char *name)
 		debugfs_create_bool("cache_bypass", 0400, map->debugfs,
 				    &map->cache_bypass);
 	}
+
+	next = rb_first(&map->range_tree);
+	while (next) {
+		range_node = rb_entry(next, struct regmap_range_node, node);
+
+		if (range_node->name)
+			debugfs_create_file(range_node->name, 0400,
+					    map->debugfs, range_node,
+					    &regmap_range_fops);
+
+		next = rb_next(&range_node->node);
+	}
 }
 
 void regmap_debugfs_exit(struct regmap *map)

commit bd9cc12f4a7e7389432bba0cae6970dfc28f423c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Oct 3 12:45:37 2012 +0100

    regmap: Factor out debugfs register read
    
    This will allow the use of the same code for reading register ranges.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index bb1ff175b962..25b6843d6a41 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -56,15 +56,15 @@ static const struct file_operations regmap_name_fops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
-				    size_t count, loff_t *ppos)
+static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,
+				   unsigned int to, char __user *user_buf,
+				   size_t count, loff_t *ppos)
 {
 	int reg_len, val_len, tot_len;
 	size_t buf_pos = 0;
 	loff_t p = 0;
 	ssize_t ret;
 	int i;
-	struct regmap *map = file->private_data;
 	char *buf;
 	unsigned int val;
 
@@ -80,7 +80,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 	val_len = 2 * map->format.val_bytes;
 	tot_len = reg_len + val_len + 3;      /* : \n */
 
-	for (i = 0; i <= map->max_register; i += map->reg_stride) {
+	for (i = from; i <= to; i += map->reg_stride) {
 		if (!regmap_readable(map, i))
 			continue;
 
@@ -95,7 +95,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 
 			/* Format the register */
 			snprintf(buf + buf_pos, count - buf_pos, "%.*x: ",
-				 reg_len, i);
+				 reg_len, i - from);
 			buf_pos += reg_len + 2;
 
 			/* Format the value, write all X if we can't read */
@@ -126,6 +126,15 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 	return ret;
 }
 
+static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct regmap *map = file->private_data;
+
+	return regmap_read_debugfs(map, 0, map->max_register, user_buf,
+				   count, ppos);
+}
+
 #undef REGMAP_ALLOW_WRITE_DEBUGFS
 #ifdef REGMAP_ALLOW_WRITE_DEBUGFS
 /*

commit f01ee60fffa4dc6c77122121233a793f7f696e67
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Apr 9 13:40:24 2012 -0600

    regmap: implement register striding
    
    regmap_config.reg_stride is introduced. All extant register addresses
    are a multiple of this value. Users of serial-oriented regmap busses will
    typically set this to 1. Users of the MMIO regmap bus will typically set
    this based on the value size of their registers, in bytes, so 4 for a
    32-bit register.
    
    Throughout the regmap code, actual register addresses are used. Wherever
    the register address is used to index some array of values, the address
    is divided by the stride to determine the index, or vice-versa. Error-
    checking is added to all entry-points for register address data to ensure
    that register addresses actually satisfy the specified stride. The MMIO
    bus ensures that the specified stride is large enough for the register
    size.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index df97c93efa8e..bb1ff175b962 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -80,7 +80,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 	val_len = 2 * map->format.val_bytes;
 	tot_len = reg_len + val_len + 3;      /* : \n */
 
-	for (i = 0; i < map->max_register + 1; i++) {
+	for (i = 0; i <= map->max_register; i += map->reg_stride) {
 		if (!regmap_readable(map, i))
 			continue;
 
@@ -197,7 +197,7 @@ static ssize_t regmap_access_read_file(struct file *file,
 	reg_len = regmap_calc_reg_len(map->max_register, buf, count);
 	tot_len = reg_len + 10; /* ': R W V P\n' */
 
-	for (i = 0; i < map->max_register + 1; i++) {
+	for (i = 0; i <= map->max_register; i += map->reg_stride) {
 		/* Ignore registers which are neither readable nor writable */
 		if (!regmap_readable(map, i) && !regmap_writeable(map, i))
 			continue;

commit c0cc6fe1d09e3f1baecbdf8922473c8e7d3a5317
Merge: 0034102808e0 d939fb9a78b4 851960ba7cb3 abec95adefae
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 10 11:01:07 2012 +0100

    Merge branches 'regmap-core', 'regmap-mmio' and 'regmap-naming' into regmap-stride

commit d3c242e1f22f5dfed009296ee45ce896153f0b53
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Apr 4 15:48:29 2012 -0600

    regmap: allow regmap instances to be named
    
    Some devices have multiple separate register regions. Logically, one
    regmap would be created per region. One issue that prevents this is that
    each instance will attempt to create the same debugfs files. Avoid this
    by allowing regmaps to be named, and use the name to construct the
    debugfs directory name.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 58517a5dac13..9715e8e44506 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -248,10 +248,17 @@ static const struct file_operations regmap_access_fops = {
 	.llseek = default_llseek,
 };
 
-void regmap_debugfs_init(struct regmap *map)
+void regmap_debugfs_init(struct regmap *map, const char *name)
 {
-	map->debugfs = debugfs_create_dir(dev_name(map->dev),
-					  regmap_debugfs_root);
+	if (name) {
+		map->debugfs_name = kasprintf(GFP_KERNEL, "%s-%s",
+					      dev_name(map->dev), name);
+		name = map->debugfs_name;
+	} else {
+		name = dev_name(map->dev);
+	}
+
+	map->debugfs = debugfs_create_dir(name, regmap_debugfs_root);
 	if (!map->debugfs) {
 		dev_warn(map->dev, "Failed to create debugfs directory\n");
 		return;
@@ -280,6 +287,7 @@ void regmap_debugfs_init(struct regmap *map)
 void regmap_debugfs_exit(struct regmap *map)
 {
 	debugfs_remove_recursive(map->debugfs);
+	kfree(map->debugfs_name);
 }
 
 void regmap_debugfs_initcall(void)

commit 234e340582901211f40d8c732afc49f0630ecf05
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 5 14:25:11 2012 -0700

    simple_open: automatically convert to simple_open()
    
    Many users of debugfs copy the implementation of default_open() when
    they want to support a custom read/write function op.  This leads to a
    proliferation of the default_open() implementation across the entire
    tree.
    
    Now that the common implementation has been consolidated into libfs we
    can replace all the users of this function with simple_open().
    
    This replacement was done with the following semantic patch:
    
    <smpl>
    @ open @
    identifier open_f != simple_open;
    identifier i, f;
    @@
    -int open_f(struct inode *i, struct file *f)
    -{
    (
    -if (i->i_private)
    -f->private_data = i->i_private;
    |
    -f->private_data = i->i_private;
    )
    -return 0;
    -}
    
    @ has_open depends on open @
    identifier fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...
    -.open = open_f,
    +.open = simple_open,
    ...
    };
    </smpl>
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 58517a5dac13..251eb70f83e7 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -27,12 +27,6 @@ static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)
 	return strlen(buf);
 }
 
-static int regmap_open_file(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
 static ssize_t regmap_name_read_file(struct file *file,
 				     char __user *user_buf, size_t count,
 				     loff_t *ppos)
@@ -57,7 +51,7 @@ static ssize_t regmap_name_read_file(struct file *file,
 }
 
 static const struct file_operations regmap_name_fops = {
-	.open = regmap_open_file,
+	.open = simple_open,
 	.read = regmap_name_read_file,
 	.llseek = default_llseek,
 };
@@ -174,7 +168,7 @@ static ssize_t regmap_map_write_file(struct file *file,
 #endif
 
 static const struct file_operations regmap_map_fops = {
-	.open = regmap_open_file,
+	.open = simple_open,
 	.read = regmap_map_read_file,
 	.write = regmap_map_write_file,
 	.llseek = default_llseek,
@@ -243,7 +237,7 @@ static ssize_t regmap_access_read_file(struct file *file,
 }
 
 static const struct file_operations regmap_access_fops = {
-	.open = regmap_open_file,
+	.open = simple_open,
 	.read = regmap_access_read_file,
 	.llseek = default_llseek,
 };

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 51990e825431089747f8896244b5c17d3a6423f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jan 22 11:23:42 2012 -0500

    device.h: cleanup users outside of linux/include (C files)
    
    For files that are actively using linux/device.h, make sure
    that they call it out.  This will allow us to clean up some
    of the implicit uses of linux/device.h within include/*
    without introducing build regressions.
    
    Yes, this was created by "cheating" -- i.e. the headers were
    cleaned up, and then the fallout was found and fixed, and then
    the two commits were reordered.  This ensures we don't introduce
    build regressions into the git history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 6f397476e27c..8c90a83ae24f 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -15,6 +15,7 @@
 #include <linux/mutex.h>
 #include <linux/debugfs.h>
 #include <linux/uaccess.h>
+#include <linux/device.h>
 
 #include "internal.h"
 

commit 19694b5ea1d3a723dafe9544b5ee9a935414dc28
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Feb 28 19:28:02 2012 -0500

    regmap: delete unused module.h from drivers/base/regmap files
    
    Remove unused module.h and/or replace with export.h
    as required.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index c32b60a93ceb..372f81a21201 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -11,7 +11,6 @@
  */
 
 #include <linux/slab.h>
-#include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/debugfs.h>
 #include <linux/uaccess.h>

commit f0c2319f9f196726ebe4d7508fd8fbd804988db3
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Feb 22 14:20:09 2012 +0000

    regmap: Expose the driver name in debugfs
    
    Add a file called 'name' containing the name of the driver.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 7accb81dd94e..c32b60a93ceb 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -33,6 +33,35 @@ static int regmap_open_file(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static ssize_t regmap_name_read_file(struct file *file,
+				     char __user *user_buf, size_t count,
+				     loff_t *ppos)
+{
+	struct regmap *map = file->private_data;
+	int ret;
+	char *buf;
+
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", map->dev->driver->name);
+	if (ret < 0) {
+		kfree(buf);
+		return ret;
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations regmap_name_fops = {
+	.open = regmap_open_file,
+	.read = regmap_name_read_file,
+	.llseek = default_llseek,
+};
+
 static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 				    size_t count, loff_t *ppos)
 {
@@ -228,6 +257,9 @@ void regmap_debugfs_init(struct regmap *map)
 		return;
 	}
 
+	debugfs_create_file("name", 0400, map->debugfs,
+			    map, &regmap_name_fops);
+
 	if (map->max_register) {
 		debugfs_create_file("registers", 0400, map->debugfs,
 				    map, &regmap_map_fops);

commit 09c6ecd394105c4864a0e409e181c9b1578c2a63
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Feb 22 12:43:50 2012 +0000

    regmap: Add support for writing to regmap registers via debugfs
    
    To enable writing to the regmap debugfs registers file users will
    need to modify the source directly and #define REGMAP_ALLOW_WRITE_DEBUGFS.
    The reason for this is that it is dangerous to expose this
    functionality in general where clients could potentially be PMICs.
    
    [A couple of minor style updates -- broonie]
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index b3b4b8f7f409..7accb81dd94e 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -103,9 +103,51 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 	return ret;
 }
 
+#undef REGMAP_ALLOW_WRITE_DEBUGFS
+#ifdef REGMAP_ALLOW_WRITE_DEBUGFS
+/*
+ * This can be dangerous especially when we have clients such as
+ * PMICs, therefore don't provide any real compile time configuration option
+ * for this feature, people who want to use this will need to modify
+ * the source code directly.
+ */
+static ssize_t regmap_map_write_file(struct file *file,
+				     const char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	char buf[32];
+	size_t buf_size;
+	char *start = buf;
+	unsigned long reg, value;
+	struct regmap *map = file->private_data;
+
+	buf_size = min(count, (sizeof(buf)-1));
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	while (*start == ' ')
+		start++;
+	reg = simple_strtoul(start, &start, 16);
+	while (*start == ' ')
+		start++;
+	if (strict_strtoul(start, 16, &value))
+		return -EINVAL;
+
+	/* Userspace has been fiddling around behind the kernel's back */
+	add_taint(TAINT_USER);
+
+	regmap_write(map, reg, value);
+	return buf_size;
+}
+#else
+#define regmap_map_write_file NULL
+#endif
+
 static const struct file_operations regmap_map_fops = {
 	.open = regmap_open_file,
 	.read = regmap_map_read_file,
+	.write = regmap_map_write_file,
 	.llseek = default_llseek,
 };
 

commit 028a01e601487b5991b70dba506dfe87d83543f6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Feb 6 18:02:06 2012 +0000

    regmap: Add debugfs information for the cache status
    
    Show all the cache status flags in debugfs if we have a cache.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 6f397476e27c..b3b4b8f7f409 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -192,6 +192,15 @@ void regmap_debugfs_init(struct regmap *map)
 		debugfs_create_file("access", 0400, map->debugfs,
 				    map, &regmap_access_fops);
 	}
+
+	if (map->cache_type) {
+		debugfs_create_bool("cache_only", 0400, map->debugfs,
+				    &map->cache_only);
+		debugfs_create_bool("cache_dirty", 0400, map->debugfs,
+				    &map->cache_dirty);
+		debugfs_create_bool("cache_bypass", 0400, map->debugfs,
+				    &map->cache_bypass);
+	}
 }
 
 void regmap_debugfs_exit(struct regmap *map)

commit d813ae9a105219255c07d382059de831186c10d0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Sep 5 08:13:07 2011 -0700

    regmap: Include the last register in debugfs output
    
    Off by one in the array iteration.
    
    Reported-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 7a8d67537d3f..6f397476e27c 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -57,7 +57,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 	val_len = 2 * map->format.val_bytes;
 	tot_len = reg_len + val_len + 3;      /* : \n */
 
-	for (i = 0; i < map->max_register; i++) {
+	for (i = 0; i < map->max_register + 1; i++) {
 		if (!regmap_readable(map, i))
 			continue;
 
@@ -132,7 +132,7 @@ static ssize_t regmap_access_read_file(struct file *file,
 	reg_len = regmap_calc_reg_len(map->max_register, buf, count);
 	tot_len = reg_len + 10; /* ': R W V P\n' */
 
-	for (i = 0; i < map->max_register; i++) {
+	for (i = 0; i < map->max_register + 1; i++) {
 		/* Ignore registers which are neither readable nor writable */
 		if (!regmap_readable(map, i) && !regmap_writeable(map, i))
 			continue;

commit 449e38427fe57a6120fecd1051981c89ee862b3d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Aug 10 17:28:04 2011 +0900

    regmap: Provide access information via debugfs
    
    Let userspace know what the access map for the device is. This is helpful
    for verifying that the access map is correctly configured and could also
    be useful for programs that try to work with the data. File format is:
    
    register: R W V P
    
    where R, W, V and P are 'y' or 'n' showing readable, writable, volatile
    and precious respectively.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index e541d7f4b4e0..7a8d67537d3f 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -109,6 +109,73 @@ static const struct file_operations regmap_map_fops = {
 	.llseek = default_llseek,
 };
 
+static ssize_t regmap_access_read_file(struct file *file,
+				       char __user *user_buf, size_t count,
+				       loff_t *ppos)
+{
+	int reg_len, tot_len;
+	size_t buf_pos = 0;
+	loff_t p = 0;
+	ssize_t ret;
+	int i;
+	struct regmap *map = file->private_data;
+	char *buf;
+
+	if (*ppos < 0 || !count)
+		return -EINVAL;
+
+	buf = kmalloc(count, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* Calculate the length of a fixed format  */
+	reg_len = regmap_calc_reg_len(map->max_register, buf, count);
+	tot_len = reg_len + 10; /* ': R W V P\n' */
+
+	for (i = 0; i < map->max_register; i++) {
+		/* Ignore registers which are neither readable nor writable */
+		if (!regmap_readable(map, i) && !regmap_writeable(map, i))
+			continue;
+
+		/* If we're in the region the user is trying to read */
+		if (p >= *ppos) {
+			/* ...but not beyond it */
+			if (buf_pos >= count - 1 - tot_len)
+				break;
+
+			/* Format the register */
+			snprintf(buf + buf_pos, count - buf_pos,
+				 "%.*x: %c %c %c %c\n",
+				 reg_len, i,
+				 regmap_readable(map, i) ? 'y' : 'n',
+				 regmap_writeable(map, i) ? 'y' : 'n',
+				 regmap_volatile(map, i) ? 'y' : 'n',
+				 regmap_precious(map, i) ? 'y' : 'n');
+
+			buf_pos += tot_len;
+		}
+		p += tot_len;
+	}
+
+	ret = buf_pos;
+
+	if (copy_to_user(user_buf, buf, buf_pos)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	*ppos += buf_pos;
+
+out:
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations regmap_access_fops = {
+	.open = regmap_open_file,
+	.read = regmap_access_read_file,
+	.llseek = default_llseek,
+};
 
 void regmap_debugfs_init(struct regmap *map)
 {
@@ -119,9 +186,12 @@ void regmap_debugfs_init(struct regmap *map)
 		return;
 	}
 
-	if (map->max_register)
+	if (map->max_register) {
 		debugfs_create_file("registers", 0400, map->debugfs,
 				    map, &regmap_map_fops);
+		debugfs_create_file("access", 0400, map->debugfs,
+				    map, &regmap_access_fops);
+	}
 }
 
 void regmap_debugfs_exit(struct regmap *map)

commit 21f555445676e5c7d30bb9b3487cb183d02e45e3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Aug 10 17:15:31 2011 +0900

    regmap: Share some of the debugfs infrastructure ready for more files
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index fff8e832a985..e541d7f4b4e0 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -20,7 +20,14 @@
 
 static struct dentry *regmap_debugfs_root;
 
-static int regmap_map_open_file(struct inode *inode, struct file *file)
+/* Calculate the length of a fixed format  */
+static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)
+{
+	snprintf(buf, buf_size, "%x", max_val);
+	return strlen(buf);
+}
+
+static int regmap_open_file(struct inode *inode, struct file *file)
 {
 	file->private_data = inode->i_private;
 	return 0;
@@ -46,8 +53,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 		return -ENOMEM;
 
 	/* Calculate the length of a fixed format  */
-	snprintf(buf, count, "%x", map->max_register);
-	reg_len = strlen(buf);
+	reg_len = regmap_calc_reg_len(map->max_register, buf, count);
 	val_len = 2 * map->format.val_bytes;
 	tot_len = reg_len + val_len + 3;      /* : \n */
 
@@ -98,7 +104,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 }
 
 static const struct file_operations regmap_map_fops = {
-	.open = regmap_map_open_file,
+	.open = regmap_open_file,
 	.read = regmap_map_read_file,
 	.llseek = default_llseek,
 };

commit 8de2f081ef8ee716663f916df9f2a7d015fa0dad
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Aug 10 17:14:41 2011 +0900

    regmap: Add functions to check for access on registers
    
    We're going to be using these in quite a few places so factor out the
    readable/writable/volatile/precious checks.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 6e304a4e2706..fff8e832a985 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -52,12 +52,10 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 	tot_len = reg_len + val_len + 3;      /* : \n */
 
 	for (i = 0; i < map->max_register; i++) {
-		if (map->readable_reg &&
-		    !map->readable_reg(map->dev, i))
+		if (!regmap_readable(map, i))
 			continue;
 
-		if (map->precious_reg &&
-		    map->precious_reg(map->dev, i))
+		if (regmap_precious(map, i))
 			continue;
 
 		/* If we're in the region the user is trying to read */

commit cb3c2dcfa34072b785cf292ca0b66494496572b9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Aug 9 16:47:42 2011 +0900

    regmap: Fix type of field width specifiers for x86_64
    
    x86_64 size_t is not an int but the printf format specifier for size_t
    should be an int.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 184b618e318e..6e304a4e2706 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -29,7 +29,7 @@ static int regmap_map_open_file(struct inode *inode, struct file *file)
 static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 				    size_t count, loff_t *ppos)
 {
-	size_t reg_len, val_len, tot_len;
+	int reg_len, val_len, tot_len;
 	size_t buf_pos = 0;
 	loff_t p = 0;
 	ssize_t ret;

commit 2efe1642b73e74604498175de032b8a604868fb7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 8 15:41:46 2011 +0900

    regmap: Skip precious registers when dumping registers via debugfs
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 2be8bf86825b..184b618e318e 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -56,6 +56,10 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 		    !map->readable_reg(map->dev, i))
 			continue;
 
+		if (map->precious_reg &&
+		    map->precious_reg(map->dev, i))
+			continue;
+
 		/* If we're in the region the user is trying to read */
 		if (p >= *ppos) {
 			/* ...but not beyond it */

commit 31244e396fa9e4854cfd6dfe305983e77802c156
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jul 20 22:56:53 2011 +0100

    regmap: Provide register map dump via debugfs
    
    Copy over the read parts of the ASoC debugfs implementation into regmap,
    allowing users to see what the register values the device has are at
    runtime. The implementation, especially the support for seeking, is
    mostly due to Dimitris Papastamos' work in ASoC.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
new file mode 100644
index 000000000000..2be8bf86825b
--- /dev/null
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -0,0 +1,131 @@
+/*
+ * Register map access API - debugfs
+ *
+ * Copyright 2011 Wolfson Microelectronics plc
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+
+#include "internal.h"
+
+static struct dentry *regmap_debugfs_root;
+
+static int regmap_map_open_file(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	size_t reg_len, val_len, tot_len;
+	size_t buf_pos = 0;
+	loff_t p = 0;
+	ssize_t ret;
+	int i;
+	struct regmap *map = file->private_data;
+	char *buf;
+	unsigned int val;
+
+	if (*ppos < 0 || !count)
+		return -EINVAL;
+
+	buf = kmalloc(count, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* Calculate the length of a fixed format  */
+	snprintf(buf, count, "%x", map->max_register);
+	reg_len = strlen(buf);
+	val_len = 2 * map->format.val_bytes;
+	tot_len = reg_len + val_len + 3;      /* : \n */
+
+	for (i = 0; i < map->max_register; i++) {
+		if (map->readable_reg &&
+		    !map->readable_reg(map->dev, i))
+			continue;
+
+		/* If we're in the region the user is trying to read */
+		if (p >= *ppos) {
+			/* ...but not beyond it */
+			if (buf_pos >= count - 1 - tot_len)
+				break;
+
+			/* Format the register */
+			snprintf(buf + buf_pos, count - buf_pos, "%.*x: ",
+				 reg_len, i);
+			buf_pos += reg_len + 2;
+
+			/* Format the value, write all X if we can't read */
+			ret = regmap_read(map, i, &val);
+			if (ret == 0)
+				snprintf(buf + buf_pos, count - buf_pos,
+					 "%.*x", val_len, val);
+			else
+				memset(buf + buf_pos, 'X', val_len);
+			buf_pos += 2 * map->format.val_bytes;
+
+			buf[buf_pos++] = '\n';
+		}
+		p += tot_len;
+	}
+
+	ret = buf_pos;
+
+	if (copy_to_user(user_buf, buf, buf_pos)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	*ppos += buf_pos;
+
+out:
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations regmap_map_fops = {
+	.open = regmap_map_open_file,
+	.read = regmap_map_read_file,
+	.llseek = default_llseek,
+};
+
+
+void regmap_debugfs_init(struct regmap *map)
+{
+	map->debugfs = debugfs_create_dir(dev_name(map->dev),
+					  regmap_debugfs_root);
+	if (!map->debugfs) {
+		dev_warn(map->dev, "Failed to create debugfs directory\n");
+		return;
+	}
+
+	if (map->max_register)
+		debugfs_create_file("registers", 0400, map->debugfs,
+				    map, &regmap_map_fops);
+}
+
+void regmap_debugfs_exit(struct regmap *map)
+{
+	debugfs_remove_recursive(map->debugfs);
+}
+
+void regmap_debugfs_initcall(void)
+{
+	regmap_debugfs_root = debugfs_create_dir("regmap", NULL);
+	if (!regmap_debugfs_root) {
+		pr_warn("regmap: Failed to create debugfs root\n");
+		return;
+	}
+}
