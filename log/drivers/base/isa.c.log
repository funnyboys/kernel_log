commit 73cf7e111ed69d8e1b59a3ae41b14bc77215e9ee
Merge: 328257099077 50c4c4e268a2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 11 08:50:05 2017 +0100

    Merge 4.15-rc3 into driver-core-next
    
    We want the fixes and changes in here for testing.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 989d42e85dc2f6823f39b8e9d080fd04bae0645d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:07 2017 +0100

    driver core: add SPDX identifiers to all driver core files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the driver core files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/isa.c b/drivers/base/isa.c
index cd6ccdcf9df0..61ab202aae43 100644
--- a/drivers/base/isa.c
+++ b/drivers/base/isa.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * ISA bus.
  */

commit 5a244727f428a06634f22bb890e78024ab0c89f3
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Wed Nov 8 10:23:11 2017 -0500

    isa: Prevent NULL dereference in isa_bus driver callbacks
    
    The isa_driver structure for an isa_bus device is stored in the device
    platform_data member of the respective device structure. This
    platform_data member may be reset to NULL if isa_driver match callback
    for the device fails, indicating a device unsupported by the ISA driver.
    
    This patch fixes a possible NULL pointer dereference if one of the
    isa_driver callbacks to attempted for an unsupported device. This error
    should not occur in practice since ISA devices are typically manually
    configured and loaded by the users, but we may as well prevent this
    error from popping up for the 0day testers.
    
    Fixes: a5117ba7da37 ("[PATCH] Driver model: add ISA bus")
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/isa.c b/drivers/base/isa.c
index cd6ccdcf9df0..372d10af2600 100644
--- a/drivers/base/isa.c
+++ b/drivers/base/isa.c
@@ -39,7 +39,7 @@ static int isa_bus_probe(struct device *dev)
 {
 	struct isa_driver *isa_driver = dev->platform_data;
 
-	if (isa_driver->probe)
+	if (isa_driver && isa_driver->probe)
 		return isa_driver->probe(dev, to_isa_dev(dev)->id);
 
 	return 0;
@@ -49,7 +49,7 @@ static int isa_bus_remove(struct device *dev)
 {
 	struct isa_driver *isa_driver = dev->platform_data;
 
-	if (isa_driver->remove)
+	if (isa_driver && isa_driver->remove)
 		return isa_driver->remove(dev, to_isa_dev(dev)->id);
 
 	return 0;
@@ -59,7 +59,7 @@ static void isa_bus_shutdown(struct device *dev)
 {
 	struct isa_driver *isa_driver = dev->platform_data;
 
-	if (isa_driver->shutdown)
+	if (isa_driver && isa_driver->shutdown)
 		isa_driver->shutdown(dev, to_isa_dev(dev)->id);
 }
 
@@ -67,7 +67,7 @@ static int isa_bus_suspend(struct device *dev, pm_message_t state)
 {
 	struct isa_driver *isa_driver = dev->platform_data;
 
-	if (isa_driver->suspend)
+	if (isa_driver && isa_driver->suspend)
 		return isa_driver->suspend(dev, to_isa_dev(dev)->id, state);
 
 	return 0;
@@ -77,7 +77,7 @@ static int isa_bus_resume(struct device *dev)
 {
 	struct isa_driver *isa_driver = dev->platform_data;
 
-	if (isa_driver->resume)
+	if (isa_driver && isa_driver->resume)
 		return isa_driver->resume(dev, to_isa_dev(dev)->id);
 
 	return 0;

commit 32a5a0c047343b11f581f663a2309cf43d13466f
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Wed May 11 17:01:40 2016 -0400

    isa: Call isa_bus_init before dependent ISA bus drivers register
    
    The isa_bus_init function must be called before drivers which utilize
    the ISA bus driver are registered. A race condition for initilization
    exists if device_initcall is used (the isa_bus_init callback is placed
    in the same initcall level as dependent drivers which use module_init).
    This patch ensures that isa_bus_init is called first by utilizing
    postcore_initcall in favor of device_initcall.
    
    Fixes: a5117ba7da37 ("[PATCH] Driver model: add ISA bus")
    Cc: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/isa.c b/drivers/base/isa.c
index 91dba65d7264..cd6ccdcf9df0 100644
--- a/drivers/base/isa.c
+++ b/drivers/base/isa.c
@@ -180,4 +180,4 @@ static int __init isa_bus_init(void)
 	return error;
 }
 
-device_initcall(isa_bus_init);
+postcore_initcall(isa_bus_init);

commit 2f4f27d42a301ed147e50c2edbcd27bb8990bc8e
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:18 2009 -0700

    dma-mapping: replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/isa.c b/drivers/base/isa.c
index 479694b6cbe3..91dba65d7264 100644
--- a/drivers/base/isa.c
+++ b/drivers/base/isa.c
@@ -141,7 +141,7 @@ int isa_register_driver(struct isa_driver *isa_driver, unsigned int ndev)
 		isa_dev->dev.release		= isa_dev_release;
 		isa_dev->id			= id;
 
-		isa_dev->dev.coherent_dma_mask = DMA_24BIT_MASK;
+		isa_dev->dev.coherent_dma_mask = DMA_BIT_MASK(24);
 		isa_dev->dev.dma_mask = &isa_dev->dev.coherent_dma_mask;
 
 		error = device_register(&isa_dev->dev);

commit 1e0b2cf933ebf32494eba3f668859ba57f06a951
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:36:48 2008 +0100

    driver core: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/base/isa.c b/drivers/base/isa.c
index efd577574948..479694b6cbe3 100644
--- a/drivers/base/isa.c
+++ b/drivers/base/isa.c
@@ -11,7 +11,7 @@
 #include <linux/isa.h>
 
 static struct device isa_bus = {
-	.bus_id		= "isa"
+	.init_name	= "isa"
 };
 
 struct isa_dev {
@@ -135,9 +135,8 @@ int isa_register_driver(struct isa_driver *isa_driver, unsigned int ndev)
 		isa_dev->dev.parent	= &isa_bus;
 		isa_dev->dev.bus	= &isa_bus_type;
 
-		snprintf(isa_dev->dev.bus_id, BUS_ID_SIZE, "%s.%u",
-				isa_driver->driver.name, id);
-
+		dev_set_name(&isa_dev->dev, "%s.%u",
+			     isa_driver->driver.name, id);
 		isa_dev->dev.platform_data	= isa_driver;
 		isa_dev->dev.release		= isa_dev_release;
 		isa_dev->id			= id;

commit 00412be1d7bdf451653c7dafeb09f4f83398d756
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Fri Jul 25 19:44:45 2008 -0700

    isa: set 24-bit dma_mask for ISA devices
    
    dma_alloc_coherent() on x86 currently takes a passed in NULL device
    pointer to mean that it should allocate an ISA compatible (24-bit) buffer
    which is a bit of a hack.
    
    The ALSA ISA drivers are the main consumers of this but have a struct
    device in fact readily available.
    
    For the legacy drivers, this sets the device dma_mask in preparation for
    using the actual device with the DMA API so as to eventually not need the
    NULL hack in dma_alloc_coherent().
    
    This does not fix a current bug -- 2.6.26-rc1 stumbled over the NULL hack
    in dma_alloc_coherent() but this has already been fixed in commit
    4a367f3a9dbf2e7ffcee4702203479809236ee6e by Takashi Iwai.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/isa.c b/drivers/base/isa.c
index d2222397a401..efd577574948 100644
--- a/drivers/base/isa.c
+++ b/drivers/base/isa.c
@@ -7,6 +7,7 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/dma-mapping.h>
 #include <linux/isa.h>
 
 static struct device isa_bus = {
@@ -141,6 +142,9 @@ int isa_register_driver(struct isa_driver *isa_driver, unsigned int ndev)
 		isa_dev->dev.release		= isa_dev_release;
 		isa_dev->id			= id;
 
+		isa_dev->dev.coherent_dma_mask = DMA_24BIT_MASK;
+		isa_dev->dev.dma_mask = &isa_dev->dev.coherent_dma_mask;
+
 		error = device_register(&isa_dev->dev);
 		if (error) {
 			put_device(&isa_dev->dev);

commit a5117ba7da37deb09df5eb802dace229b3fb1e9f
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Tue Jun 6 23:54:02 2006 +0200

    [PATCH] Driver model: add ISA bus
    
    During the recent "isa drivers using platform devices" discussion it was
    pointed out that (ALSA) ISA drivers ran into the problem of not having
    the option to fail driver load (device registration rather) upon not
    finding their hardware due to a probe() error not being passed up
    through the driver model. In the course of that, I suggested a seperate
    ISA bus might be best; Russell King agreed and suggested this bus could
    use the .match() method for the actual device discovery.
    
    The attached does this. For this old non (generically) discoverable ISA
    hardware only the driver itself can do discovery so as a difference with
    the platform_bus, this isa_bus also distributes match() up to the driver.
    
    As another difference: these devices only exist in the driver model due
    to the driver creating them because it might want to drive them, meaning
    that all device creation has been made internal as well.
    
    The usage model this provides is nice, and has been acked from the ALSA
    side by Takashi Iwai and Jaroslav Kysela. The ALSA driver module_init's
    now (for oldisa-only drivers) become:
    
    static int __init alsa_card_foo_init(void)
    {
            return isa_register_driver(&snd_foo_isa_driver, SNDRV_CARDS);
    }
    
    static void __exit alsa_card_foo_exit(void)
    {
            isa_unregister_driver(&snd_foo_isa_driver);
    }
    
    Quite like the other bus models therefore. This removes a lot of
    duplicated init code from the ALSA ISA drivers.
    
    The passed in isa_driver struct is the regular driver struct embedding a
    struct device_driver, the normal probe/remove/shutdown/suspend/resume
    callbacks, and as indicated that .match callback.
    
    The "SNDRV_CARDS" you see being passed in is a "unsigned int ndev"
    parameter, indicating how many devices to create and call our methods with.
    
    The platform_driver callbacks are called with a platform_device param;
    the isa_driver callbacks are being called with a "struct device *dev,
    unsigned int id" pair directly -- with the device creation completely
    internal to the bus it's much cleaner to not leak isa_dev's by passing
    them in at all. The id is the only thing we ever want other then the
    struct device * anyways, and it makes for nicer code in the callbacks as
    well.
    
    With this additional .match() callback ISA drivers have all options. If
    ALSA would want to keep the old non-load behaviour, it could stick all
    of the old .probe in .match, which would only keep them registered after
    everything was found to be present and accounted for. If it wanted the
    behaviour of always loading as it inadvertently did for a bit after the
    changeover to platform devices, it could just not provide a .match() and
    do everything in .probe() as before.
    
    If it, as Takashi Iwai already suggested earlier as a way of following
    the model from saner buses more closely, wants to load when a later bind
    could conceivably succeed, it could use .match() for the prerequisites
    (such as checking the user wants the card enabled and that port/irq/dma
    values have been passed in) and .probe() for everything else. This is
    the nicest model.
    
    To the code...
    
    This exports only two functions; isa_{,un}register_driver().
    
    isa_register_driver() register's the struct device_driver, and then
    loops over the passed in ndev creating devices and registering them.
    This causes the bus match method to be called for them, which is:
    
    int isa_bus_match(struct device *dev, struct device_driver *driver)
    {
              struct isa_driver *isa_driver = to_isa_driver(driver);
    
              if (dev->platform_data == isa_driver) {
                      if (!isa_driver->match ||
                              isa_driver->match(dev, to_isa_dev(dev)->id))
                              return 1;
                      dev->platform_data = NULL;
              }
              return 0;
    }
    
    The first thing this does is check if this device is in fact one of this
    driver's devices by seeing if the device's platform_data pointer is set
    to this driver. Platform devices compare strings, but we don't need to
    do that with everything being internal, so isa_register_driver() abuses
    dev->platform_data as a isa_driver pointer which we can then check here.
    I believe platform_data is available for this, but if rather not, moving
    the isa_driver pointer to the private struct isa_dev is ofcourse fine as
    well.
    
    Then, if the the driver did not provide a .match, it matches. If it did,
    the driver match() method is called to determine a match.
    
    If it did _not_ match, dev->platform_data is reset to indicate this to
    isa_register_driver which can then unregister the device again.
    
    If during all this, there's any error, or no devices matched at all
    everything is backed out again and the error, or -ENODEV, is returned.
    
    isa_unregister_driver() just unregisters the matched devices and the
    driver itself.
    
    More global points/questions...
    
    - I'm introducing include/linux/isa.h. It was available but is ofcourse
    a somewhat generic name. Moving more isa stuff over to it in time is
    ofcourse fine, so can I have it please? :)
    
    - I'm using device_initcall() and added the isa.o (dependent on
    CONFIG_ISA) after the base driver model things in the Makefile. Will
    this do, or I really need to stick it in drivers/base/init.c, inside
    #ifdef CONFIG_ISA? It's working fine.
    
    Lastly -- I also looked, a bit, into integrating with PnP. "Old ISA"
    could be another pnp_protocol, but this does not seem to be a good
    match, largely due to the same reason platform_devices weren't -- the
    devices do not have a life of their own outside the driver, meaning the
    pnp_protocol {get,set}_resources callbacks would need to callback into
    driver -- which again means you first need to _have_ that driver. Even
    if there's clean way around that, you only end up inventing fake but
    valid-form PnP IDs and generally catering to the PnP layer without any
    practical advantages over this very simple isa_bus. The thing I also
    suggested earlier about the user echoing values into /sys to set up the
    hardware from userspace first is... well, cute, but a horrible idea from
    a user standpoint.
    
    Comments ofcourse appreciated. Hope it's okay. As said, the usage model
    is nice at least.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>

diff --git a/drivers/base/isa.c b/drivers/base/isa.c
new file mode 100644
index 000000000000..d2222397a401
--- /dev/null
+++ b/drivers/base/isa.c
@@ -0,0 +1,180 @@
+/*
+ * ISA bus.
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/isa.h>
+
+static struct device isa_bus = {
+	.bus_id		= "isa"
+};
+
+struct isa_dev {
+	struct device dev;
+	struct device *next;
+	unsigned int id;
+};
+
+#define to_isa_dev(x) container_of((x), struct isa_dev, dev)
+
+static int isa_bus_match(struct device *dev, struct device_driver *driver)
+{
+	struct isa_driver *isa_driver = to_isa_driver(driver);
+
+	if (dev->platform_data == isa_driver) {
+		if (!isa_driver->match ||
+			isa_driver->match(dev, to_isa_dev(dev)->id))
+			return 1;
+		dev->platform_data = NULL;
+	}
+	return 0;
+}
+
+static int isa_bus_probe(struct device *dev)
+{
+	struct isa_driver *isa_driver = dev->platform_data;
+
+	if (isa_driver->probe)
+		return isa_driver->probe(dev, to_isa_dev(dev)->id);
+
+	return 0;
+}
+
+static int isa_bus_remove(struct device *dev)
+{
+	struct isa_driver *isa_driver = dev->platform_data;
+
+	if (isa_driver->remove)
+		return isa_driver->remove(dev, to_isa_dev(dev)->id);
+
+	return 0;
+}
+
+static void isa_bus_shutdown(struct device *dev)
+{
+	struct isa_driver *isa_driver = dev->platform_data;
+
+	if (isa_driver->shutdown)
+		isa_driver->shutdown(dev, to_isa_dev(dev)->id);
+}
+
+static int isa_bus_suspend(struct device *dev, pm_message_t state)
+{
+	struct isa_driver *isa_driver = dev->platform_data;
+
+	if (isa_driver->suspend)
+		return isa_driver->suspend(dev, to_isa_dev(dev)->id, state);
+
+	return 0;
+}
+
+static int isa_bus_resume(struct device *dev)
+{
+	struct isa_driver *isa_driver = dev->platform_data;
+
+	if (isa_driver->resume)
+		return isa_driver->resume(dev, to_isa_dev(dev)->id);
+
+	return 0;
+}
+
+static struct bus_type isa_bus_type = {
+	.name		= "isa",
+	.match		= isa_bus_match,
+	.probe		= isa_bus_probe,
+	.remove		= isa_bus_remove,
+	.shutdown	= isa_bus_shutdown,
+	.suspend	= isa_bus_suspend,
+	.resume		= isa_bus_resume
+};
+
+static void isa_dev_release(struct device *dev)
+{
+	kfree(to_isa_dev(dev));
+}
+
+void isa_unregister_driver(struct isa_driver *isa_driver)
+{
+	struct device *dev = isa_driver->devices;
+
+	while (dev) {
+		struct device *tmp = to_isa_dev(dev)->next;
+		device_unregister(dev);
+		dev = tmp;
+	}
+	driver_unregister(&isa_driver->driver);
+}
+EXPORT_SYMBOL_GPL(isa_unregister_driver);
+
+int isa_register_driver(struct isa_driver *isa_driver, unsigned int ndev)
+{
+	int error;
+	unsigned int id;
+
+	isa_driver->driver.bus	= &isa_bus_type;
+	isa_driver->devices	= NULL;
+
+	error = driver_register(&isa_driver->driver);
+	if (error)
+		return error;
+
+	for (id = 0; id < ndev; id++) {
+		struct isa_dev *isa_dev;
+
+		isa_dev = kzalloc(sizeof *isa_dev, GFP_KERNEL);
+		if (!isa_dev) {
+			error = -ENOMEM;
+			break;
+		}
+
+		isa_dev->dev.parent	= &isa_bus;
+		isa_dev->dev.bus	= &isa_bus_type;
+
+		snprintf(isa_dev->dev.bus_id, BUS_ID_SIZE, "%s.%u",
+				isa_driver->driver.name, id);
+
+		isa_dev->dev.platform_data	= isa_driver;
+		isa_dev->dev.release		= isa_dev_release;
+		isa_dev->id			= id;
+
+		error = device_register(&isa_dev->dev);
+		if (error) {
+			put_device(&isa_dev->dev);
+			break;
+		}
+
+		if (isa_dev->dev.platform_data) {
+			isa_dev->next = isa_driver->devices;
+			isa_driver->devices = &isa_dev->dev;
+		} else
+			device_unregister(&isa_dev->dev);
+	}
+
+	if (!error && !isa_driver->devices)
+		error = -ENODEV;
+
+	if (error)
+		isa_unregister_driver(isa_driver);
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(isa_register_driver);
+
+static int __init isa_bus_init(void)
+{
+	int error;
+
+	error = bus_register(&isa_bus_type);
+	if (!error) {
+		error = device_register(&isa_bus);
+		if (error)
+			bus_unregister(&isa_bus_type);
+	}
+	return error;
+}
+
+device_initcall(isa_bus_init);
