commit 82c298100a2db7e4241e0fee73d94dc5ee573837
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:05 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 176
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170025.980374610@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 0fe6ddcb3fdc..f4cb29766888 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * mISDNinfineon.c
  *		Support for cards based on following Infineon ISDN chipsets
@@ -17,25 +18,9 @@
  *		- Berkom Scitel BRIX Quadro
  *		- Dr.Neuhaus (Sagem) Niccy
  *
- *
- *
  * Author       Karsten Keil <keil@isdn4linux.de>
  *
  * Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include <linux/interrupt.h>

commit d721fe99f6ada070ae8fc0ec3e01ce5a42def0d9
Author: Kangjie Lu <kjlu@umn.edu>
Date:   Fri Mar 8 23:49:34 2019 -0600

    isdn: mISDNinfineon: fix potential NULL pointer dereference
    
    In case ioremap fails, the fix returns -ENOMEM to avoid NULL
    pointer dereference.
    
    Signed-off-by: Kangjie Lu <kjlu@umn.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 3e01012be4ab..0fe6ddcb3fdc 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -712,8 +712,11 @@ setup_io(struct inf_hw *hw)
 				(ulong)hw->addr.start, (ulong)hw->addr.size);
 			return err;
 		}
-		if (hw->ci->addr_mode == AM_MEMIO)
+		if (hw->ci->addr_mode == AM_MEMIO) {
 			hw->addr.p = ioremap(hw->addr.start, hw->addr.size);
+			if (unlikely(!hw->addr.p))
+				return -ENOMEM;
+		}
 		hw->addr.mode = hw->ci->addr_mode;
 		if (debug & DEBUG_HW)
 			pr_notice("%s: IO addr %lx (%lu bytes) mode%d\n",

commit d287c5024361554d746e918b20d69a37f1b6bd79
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Jul 3 16:17:31 2018 -0500

    isdn: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Warning level 2 was used: -Wimplicit-fallthrough=2
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 1fc290659e94..3e01012be4ab 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -887,6 +887,7 @@ release_card(struct inf_hw *card) {
 				release_card(card->sc[i]);
 			card->sc[i] = NULL;
 		}
+		/* fall through */
 	default:
 		pci_disable_device(card->pdev);
 		pci_set_drvdata(card->pdev, NULL);

commit e4dca7b7aa08b22893c45485d222b5807c1375ae
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 17 19:04:42 2017 -0700

    treewide: Fix function prototypes for module_param_call()
    
    Several function prototypes for the set/get functions defined by
    module_param_call() have a slightly wrong argument types. This fixes
    those in an effort to clean up the calls when running under type-enforced
    compiler instrumentation for CFI. This is the result of running the
    following semantic patch:
    
    @match_module_param_call_function@
    declarer name module_param_call;
    identifier _name, _set_func, _get_func;
    expression _arg, _mode;
    @@
    
     module_param_call(_name, _set_func, _get_func, _arg, _mode);
    
    @fix_set_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._set_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _set_func(
    -_val_type _val
    +const char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    @fix_get_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._get_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _get_func(
    -_val_type _val
    +char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    Two additional by-hand changes are included for places where the above
    Coccinelle script didn't notice them:
    
            drivers/platform/x86/thinkpad_acpi.c
            fs/lockd/svc.c
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index d5bdbaf93a1a..1fc290659e94 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -244,7 +244,7 @@ _set_debug(struct inf_hw *card)
 }
 
 static int
-set_debug(const char *val, struct kernel_param *kp)
+set_debug(const char *val, const struct kernel_param *kp)
 {
 	int ret;
 	struct inf_hw *card;

commit d939be3add4f1410079dad2755d4936cdb70903b
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Fri Feb 27 23:52:31 2015 +0900

    treewide: Fix typo in printk messages
    
    This patch fix spelling typo in printk messages.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index c1493f4162fb..d5bdbaf93a1a 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -1092,7 +1092,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 	card->ci = get_card_info(ent->driver_data);
 	if (!card->ci) {
-		pr_info("mISDN: do not have informations about adapter at %s\n",
+		pr_info("mISDN: do not have information about adapter at %s\n",
 			pci_name(pdev));
 		kfree(card);
 		pci_disable_device(pdev);

commit ed5a84cdf593e54969518e82762786fbe1284ce4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:13:05 2012 -0800

    Drivers: isdn: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 631eb3fa63cf..c1493f4162fb 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -125,7 +125,7 @@ struct inf_hw {
 #define PCI_SUBVENDOR_SEDLBAUER_PCI     0x53
 #define PCI_SUB_ID_SEDLBAUER            0x01
 
-static struct pci_device_id infineon_ids[] __devinitdata = {
+static struct pci_device_id infineon_ids[] = {
 	{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA20), INF_DIVA20 },
 	{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA20_U), INF_DIVA20U },
 	{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA201), INF_DIVA201 },
@@ -603,7 +603,7 @@ inf_ctrl(struct inf_hw *hw, u32 cmd, u_long arg)
 	return ret;
 }
 
-static int __devinit
+static int
 init_irq(struct inf_hw *hw)
 {
 	int	ret, cnt = 3;
@@ -662,7 +662,7 @@ release_io(struct inf_hw *hw)
 	}
 }
 
-static int __devinit
+static int
 setup_io(struct inf_hw *hw)
 {
 	int err = 0;
@@ -896,7 +896,7 @@ release_card(struct inf_hw *card) {
 	inf_cnt--;
 }
 
-static int __devinit
+static int
 setup_instance(struct inf_hw *card)
 {
 	int err;
@@ -1060,7 +1060,7 @@ static const struct inf_cinfo inf_card_info[] = {
 	}
 };
 
-static const struct inf_cinfo * __devinit
+static const struct inf_cinfo *
 get_card_info(enum inf_types typ)
 {
 	const struct inf_cinfo *ci = inf_card_info;
@@ -1073,7 +1073,7 @@ get_card_info(enum inf_types typ)
 	return NULL;
 }
 
-static int __devinit
+static int
 inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	int err = -ENOMEM;
@@ -1135,7 +1135,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return err;
 }
 
-static void __devexit
+static void
 inf_remove(struct pci_dev *pdev)
 {
 	struct inf_hw	*card = pci_get_drvdata(pdev);
@@ -1149,7 +1149,7 @@ inf_remove(struct pci_dev *pdev)
 static struct pci_driver infineon_driver = {
 	.name = "ISDN Infineon pci",
 	.probe = inf_probe,
-	.remove = __devexit_p(inf_remove),
+	.remove = inf_remove,
 	.id_table = infineon_ids,
 };
 

commit 475be4d85a274d0961593db41cf85689db1d583c
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 19 19:52:38 2012 -0800

    isdn: whitespace coding style cleanup
    
    isdn source code uses a not-current coding style.
    
    Update the coding style used on a per-line basis
    so that git diff -w shows only elided blank lines
    at EOF.
    
    Done with emacs and some scripts and some typing.
    
    Built x86 allyesconfig.
    No detected change in objdump -d or size.
    
    Signed-off-by: Joe Perches <joe@perches.com>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 6218775ce87d..631eb3fa63cf 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -431,11 +431,11 @@ enable_hwirq(struct inf_hw *hw)
 		break;
 	case INF_GAZEL_R685:
 		outb(GAZEL_ISAC_EN + GAZEL_HSCX_EN + GAZEL_PCI_EN,
-			(u32)hw->cfg.start + GAZEL_INCSR);
+		     (u32)hw->cfg.start + GAZEL_INCSR);
 		break;
 	case INF_GAZEL_R753:
 		outb(GAZEL_IPAC_EN + GAZEL_PCI_EN,
-			(u32)hw->cfg.start + GAZEL_INCSR);
+		     (u32)hw->cfg.start + GAZEL_INCSR);
 		break;
 	default:
 		break;
@@ -511,21 +511,21 @@ reset_inf(struct inf_hw *hw)
 		/* Workaround PCI9060 */
 		outb(9, (u32)hw->cfg.start + 0x69);
 		outb(DIVA_RESET_BIT | DIVA_LED_A,
-			(u32)hw->cfg.start + DIVA_PCI_CTRL);
+		     (u32)hw->cfg.start + DIVA_PCI_CTRL);
 		break;
 	case INF_DIVA201:
 		writel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,
-			hw->cfg.p + PITA_MISC_REG);
+		       hw->cfg.p + PITA_MISC_REG);
 		mdelay(1);
 		writel(PITA_PARA_MPX_MODE, hw->cfg.p + PITA_MISC_REG);
 		mdelay(10);
 		break;
 	case INF_DIVA202:
 		writel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,
-			hw->cfg.p + PITA_MISC_REG);
+		       hw->cfg.p + PITA_MISC_REG);
 		mdelay(1);
 		writel(PITA_PARA_MPX_MODE | PITA_SER_SOFTRESET,
-			hw->cfg.p + PITA_MISC_REG);
+		       hw->cfg.p + PITA_MISC_REG);
 		mdelay(10);
 		break;
 	case INF_SPEEDWIN:
@@ -630,7 +630,7 @@ init_irq(struct inf_hw *hw)
 		msleep_interruptible(10);
 		if (debug & DEBUG_HW)
 			pr_notice("%s: IRQ %d count %d\n", hw->name,
-				hw->irq, hw->irqcnt);
+				  hw->irq, hw->irqcnt);
 		if (!hw->irqcnt) {
 			pr_info("%s: IRQ(%d) got no requests during init %d\n",
 				hw->name, hw->irq, 3 - cnt);
@@ -672,11 +672,11 @@ setup_io(struct inf_hw *hw)
 		hw->cfg.size = pci_resource_len(hw->pdev, hw->ci->cfg_bar);
 		if (hw->ci->cfg_mode == AM_MEMIO) {
 			if (!request_mem_region(hw->cfg.start, hw->cfg.size,
-			    hw->name))
+						hw->name))
 				err = -EBUSY;
 		} else {
 			if (!request_region(hw->cfg.start, hw->cfg.size,
-			    hw->name))
+					    hw->name))
 				err = -EBUSY;
 		}
 		if (err) {
@@ -690,8 +690,8 @@ setup_io(struct inf_hw *hw)
 		hw->cfg.mode = hw->ci->cfg_mode;
 		if (debug & DEBUG_HW)
 			pr_notice("%s: IO cfg %lx (%lu bytes) mode%d\n",
-				hw->name, (ulong)hw->cfg.start,
-				(ulong)hw->cfg.size, hw->ci->cfg_mode);
+				  hw->name, (ulong)hw->cfg.start,
+				  (ulong)hw->cfg.size, hw->ci->cfg_mode);
 
 	}
 	if (hw->ci->addr_mode) {
@@ -699,11 +699,11 @@ setup_io(struct inf_hw *hw)
 		hw->addr.size = pci_resource_len(hw->pdev, hw->ci->addr_bar);
 		if (hw->ci->addr_mode == AM_MEMIO) {
 			if (!request_mem_region(hw->addr.start, hw->addr.size,
-			    hw->name))
+						hw->name))
 				err = -EBUSY;
 		} else {
 			if (!request_region(hw->addr.start, hw->addr.size,
-			    hw->name))
+					    hw->name))
 				err = -EBUSY;
 		}
 		if (err) {
@@ -717,8 +717,8 @@ setup_io(struct inf_hw *hw)
 		hw->addr.mode = hw->ci->addr_mode;
 		if (debug & DEBUG_HW)
 			pr_notice("%s: IO addr %lx (%lu bytes) mode%d\n",
-				hw->name, (ulong)hw->addr.start,
-				(ulong)hw->addr.size, hw->ci->addr_mode);
+				  hw->name, (ulong)hw->addr.start,
+				  (ulong)hw->addr.size, hw->ci->addr_mode);
 
 	}
 
@@ -903,7 +903,7 @@ setup_instance(struct inf_hw *card)
 	ulong flags;
 
 	snprintf(card->name, MISDN_MAX_IDLEN - 1, "%s.%d", card->ci->name,
-		inf_cnt + 1);
+		 inf_cnt + 1);
 	write_lock_irqsave(&card_lock, flags);
 	list_add_tail(&card->list, &Cards);
 	write_unlock_irqrestore(&card_lock, flags);
@@ -928,7 +928,7 @@ setup_instance(struct inf_hw *card)
 		goto error_setup;
 
 	err = mISDN_register_device(&card->ipac.isac.dch.dev,
-		&card->pdev->dev, card->name);
+				    &card->pdev->dev, card->name);
 	if (err)
 		goto error;
 
@@ -1099,7 +1099,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		return -EINVAL;
 	} else
 		pr_notice("mISDN: found adapter %s at %s\n",
-			card->ci->full, pci_name(pdev));
+			  card->ci->full, pci_name(pdev));
 
 	card->irq = pdev->irq;
 	pci_set_drvdata(pdev, card);

commit a6b7a407865aab9f849dd99a71072b7cd1175116
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jun 6 10:43:46 2011 +0000

    net: remove interrupt.h inclusion from netdevice.h
    
    * remove interrupt.g inclusion from netdevice.h -- not needed
    * fixup fallout, add interrupt.h and hardirq.h back where needed.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index bc0529ac88a1..6218775ce87d 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -38,6 +38,7 @@
  *
  */
 
+#include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>

commit ad65ffd12dccf6d1031298eacc060327751084da
Author: Joe Perches <joe@perches.com>
Date:   Sun Nov 14 17:04:26 2010 +0000

    drivers/isdn: Remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index e90db8870b6c..bc0529ac88a1 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -420,7 +420,7 @@ enable_hwirq(struct inf_hw *hw)
 		break;
 	case INF_NICCY:
 		val = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
-		val |= NICCY_IRQ_ENABLE;;
+		val |= NICCY_IRQ_ENABLE;
 		outl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
 		break;
 	case INF_SCT_1:
@@ -924,7 +924,7 @@ setup_instance(struct inf_hw *card)
 		mISDNipac_init(&card->ipac, card);
 
 	if (card->ipac.isac.dch.dev.Bprotocols == 0)
-		goto error_setup;;
+		goto error_setup;
 
 	err = mISDN_register_device(&card->ipac.isac.dch.dev,
 		&card->pdev->dev, card->name);

commit 4101e976e0376a1820ae55adf8bca7dda5089a7d
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Oct 26 02:20:56 2010 +0000

    drivers/isdn: delete double assignment
    
    Delete successive assignments to the same location.  In the first case, the
    hscx array has two elements, so change the assignment to initialize the
    second one.  In the second case, the two assignments are simply identical.
    Furthermore, neither is necessary, because the effect of the assignment is
    only visible in the next line, in the assignment in the if test.  The patch
    inlines the right hand side value in the latter assignment and pulls that
    assignment out of the if test.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression i;
    @@
    
    *i = ...;
     i = ...;
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index af25e1f3efd4..e90db8870b6c 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -563,7 +563,7 @@ reset_inf(struct inf_hw *hw)
 		mdelay(10);
 		hw->ipac.isac.adf2 = 0x87;
 		hw->ipac.hscx[0].slot = 0x1f;
-		hw->ipac.hscx[0].slot = 0x23;
+		hw->ipac.hscx[1].slot = 0x23;
 		break;
 	case INF_GAZEL_R753:
 		val = inl((u32)hw->cfg.start + GAZEL_CNTRL);

commit 06d88e4a88cf6a90de6f0744e2cc320eb67aac81
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Mon Aug 9 09:50:53 2010 +0000

    isdn: mISDN: call pci_disable_device() if pci_probe() failed
    
    Driver should call pci_disable_device() if it returns from pci_probe()
    with error.
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index d2dd61d65d51..af25e1f3efd4 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -1094,6 +1094,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		pr_info("mISDN: do not have informations about adapter at %s\n",
 			pci_name(pdev));
 		kfree(card);
+		pci_disable_device(pdev);
 		return -EINVAL;
 	} else
 		pr_notice("mISDN: found adapter %s at %s\n",
@@ -1103,7 +1104,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_set_drvdata(pdev, card);
 	err = setup_instance(card);
 	if (err) {
-		pci_disable_device(card->pdev);
+		pci_disable_device(pdev);
 		kfree(card);
 		pci_set_drvdata(pdev, NULL);
 	} else if (ent->driver_data == INF_SCT_1) {
@@ -1114,6 +1115,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			sc = kzalloc(sizeof(struct inf_hw), GFP_KERNEL);
 			if (!sc) {
 				release_card(card);
+				pci_disable_device(pdev);
 				return -ENOMEM;
 			}
 			sc->irq = card->irq;
@@ -1121,6 +1123,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			sc->ci = card->ci + i;
 			err = setup_instance(sc);
 			if (err) {
+				pci_disable_device(pdev);
 				kfree(sc);
 				release_card(card);
 				break;

commit 3cfc2c42c1cbc8e238bb9c0612c0df4565e3a8b4
Merge: 5cf65713f877 0ea6e6112219
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 4 15:31:02 2010 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (48 commits)
      Documentation: update broken web addresses.
      fix comment typo "choosed" -> "chosen"
      hostap:hostap_hw.c Fix typo in comment
      Fix spelling contorller -> controller in comments
      Kconfig.debug: FAIL_IO_TIMEOUT: typo Faul -> Fault
      fs/Kconfig: Fix typo Userpace -> Userspace
      Removing dead MACH_U300_BS26
      drivers/infiniband: Remove unnecessary casts of private_data
      fs/ocfs2: Remove unnecessary casts of private_data
      libfc: use ARRAY_SIZE
      scsi: bfa: use ARRAY_SIZE
      drm: i915: use ARRAY_SIZE
      drm: drm_edid: use ARRAY_SIZE
      synclink: use ARRAY_SIZE
      block: cciss: use ARRAY_SIZE
      comment typo fixes: charater => character
      fix comment typos concerning "challenge"
      arm: plat-spear: fix typo in kerneldoc
      reiserfs: typo comment fix
      update email address
      ...

commit d930d1a142af07f25c5cbf33aeea6ebbd25315ce
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Thu Jul 15 09:04:07 2010 +0000

    mISDN: Convert pci_table entries to PCI_VDEVICE (if PCI_ANY_ID is used)
    
    This patch converts pci_table entries, where .subvendor=PCI_ANY_ID and
    .subdevice=PCI_ANY_ID, .class=0 and .class_mask=0, to use the
    PCI_VDEVICE macro, and thus improves readability.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index f5b3d2b26a08..2a2181d58deb 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -125,36 +125,25 @@ struct inf_hw {
 #define PCI_SUB_ID_SEDLBAUER            0x01
 
 static struct pci_device_id infineon_ids[] __devinitdata = {
-	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA20,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA20},
-	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA20_U,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA20U},
-	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA201,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA201},
-	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA202,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA202},
+	{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA20), INF_DIVA20 },
+	{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA20_U), INF_DIVA20U },
+	{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA201), INF_DIVA201 },
+	{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA202), INF_DIVA202 },
 	{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,
 	  PCI_SUBVENDOR_SEDLBAUER_PCI, PCI_SUB_ID_SEDLBAUER, 0, 0,
-	  INF_SPEEDWIN},
+	  INF_SPEEDWIN },
 	{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,
-	  PCI_SUBVENDOR_HST_SAPHIR3, PCI_SUB_ID_SEDLBAUER, 0, 0, INF_SAPHIR3},
-	{ PCI_VENDOR_ID_ELSA, PCI_DEVICE_ID_ELSA_MICROLINK,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_QS1000},
-	{ PCI_VENDOR_ID_ELSA, PCI_DEVICE_ID_ELSA_QS3000,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_QS3000},
-	{ PCI_VENDOR_ID_SATSAGEM, PCI_DEVICE_ID_SATSAGEM_NICCY,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_NICCY},
+	  PCI_SUBVENDOR_HST_SAPHIR3, PCI_SUB_ID_SEDLBAUER, 0, 0, INF_SAPHIR3 },
+	{ PCI_VDEVICE(ELSA, PCI_DEVICE_ID_ELSA_MICROLINK), INF_QS1000 },
+	{ PCI_VDEVICE(ELSA, PCI_DEVICE_ID_ELSA_QS3000), INF_QS3000 },
+	{ PCI_VDEVICE(SATSAGEM, PCI_DEVICE_ID_SATSAGEM_NICCY), INF_NICCY },
 	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,
 	  PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO, 0, 0,
-	  INF_SCT_1},
-	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_R685,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R685},
-	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_R753,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R753},
-	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_DJINN_ITOO,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R753},
-	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_OLITEC,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R753},
+	  INF_SCT_1 },
+	{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_R685), INF_GAZEL_R685 },
+	{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_R753), INF_GAZEL_R753 },
+	{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_DJINN_ITOO), INF_GAZEL_R753 },
+	{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_OLITEC), INF_GAZEL_R753 },
 	{ }
 };
 MODULE_DEVICE_TABLE(pci, infineon_ids);

commit 698f93159a735bd29a8767c9f60d9b2d75870f8e
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Jul 2 20:41:51 2010 +0200

    fix comment/printk typos concerning "already"
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index f5b3d2b26a08..4975976e93ac 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -1150,7 +1150,7 @@ inf_remove(struct pci_dev *pdev)
 	if (card)
 		release_card(card);
 	else
-		pr_debug("%s: drvdata allready removed\n", __func__);
+		pr_debug("%s: drvdata already removed\n", __func__);
 }
 
 static struct pci_driver infineon_driver = {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 36c6c616a655..f5b3d2b26a08 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -42,6 +42,7 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/mISDNhw.h>
+#include <linux/slab.h>
 #include "ipac.h"
 
 #define INFINEON_REV	"1.0"

commit f0f4d641d4ebfeb4194e9c26dfa6286802e2e8d1
Author: Darren Jenkins <darrenrjenkins@gmail.com>
Date:   Tue Feb 2 12:43:45 2010 +0000

    hardware/mISDN/mISDNinfineon.c: bail out of loop on error
    
    If setup_instance() fails we kfree() the card, and then use it in the next
    loop iteration.  So lets bail out of the loop instead.
    
    Coverity CID: 13357
    
    Signed-off-by: Darren Jenkins <darrenrjenkins@gmail.com>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 62441ba53b95..36c6c616a655 100644
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -1133,6 +1133,7 @@ inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			if (err) {
 				kfree(sc);
 				release_card(card);
+				break;
 			} else
 				card->sc[i - 1] = sc;
 		}

commit cae86d4a4e56eeda1afdea38f230d222edda7dd5
Author: Karsten Keil <keil@b1-systems.de>
Date:   Wed Jul 22 19:42:46 2009 +0200

    mISDN: Add driver for Infineon ISDN chipset family
    
    This driver supports cards with Infineon ISAC/HSCX, ISACX, IPAC
    and IPACX chips from various manufacturers.
    
    Signed-off-by: Karsten Keil <keil@b1-systems.de>

diff --git a/drivers/isdn/hardware/mISDN/mISDNinfineon.c b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
new file mode 100644
index 000000000000..62441ba53b95
--- /dev/null
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@ -0,0 +1,1178 @@
+/*
+ * mISDNinfineon.c
+ *		Support for cards based on following Infineon ISDN chipsets
+ *		- ISAC + HSCX
+ *		- IPAC and IPAC-X
+ *		- ISAC-SX + HSCX
+ *
+ * Supported cards:
+ *		- Dialogic Diva 2.0
+ *		- Dialogic Diva 2.0U
+ *		- Dialogic Diva 2.01
+ *		- Dialogic Diva 2.02
+ *		- Sedlbauer Speedwin
+ *		- HST Saphir3
+ *		- Develo (former ELSA) Microlink PCI (Quickstep 1000)
+ *		- Develo (former ELSA) Quickstep 3000
+ *		- Berkom Scitel BRIX Quadro
+ *		- Dr.Neuhaus (Sagem) Niccy
+ *
+ *
+ *
+ * Author       Karsten Keil <keil@isdn4linux.de>
+ *
+ * Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/mISDNhw.h>
+#include "ipac.h"
+
+#define INFINEON_REV	"1.0"
+
+static int inf_cnt;
+static u32 debug;
+static u32 irqloops = 4;
+
+enum inf_types {
+	INF_NONE,
+	INF_DIVA20,
+	INF_DIVA20U,
+	INF_DIVA201,
+	INF_DIVA202,
+	INF_SPEEDWIN,
+	INF_SAPHIR3,
+	INF_QS1000,
+	INF_QS3000,
+	INF_NICCY,
+	INF_SCT_1,
+	INF_SCT_2,
+	INF_SCT_3,
+	INF_SCT_4,
+	INF_GAZEL_R685,
+	INF_GAZEL_R753
+};
+
+enum addr_mode {
+	AM_NONE = 0,
+	AM_IO,
+	AM_MEMIO,
+	AM_IND_IO,
+};
+
+struct inf_cinfo {
+	enum inf_types	typ;
+	const char	*full;
+	const char	*name;
+	enum addr_mode	cfg_mode;
+	enum addr_mode	addr_mode;
+	u8		cfg_bar;
+	u8		addr_bar;
+	void		*irqfunc;
+};
+
+struct _ioaddr {
+	enum addr_mode	mode;
+	union {
+		void __iomem	*p;
+		struct _ioport	io;
+	} a;
+};
+
+struct _iohandle {
+	enum addr_mode	mode;
+	resource_size_t	size;
+	resource_size_t	start;
+	void __iomem	*p;
+};
+
+struct inf_hw {
+	struct list_head	list;
+	struct pci_dev		*pdev;
+	const struct inf_cinfo	*ci;
+	char			name[MISDN_MAX_IDLEN];
+	u32			irq;
+	u32			irqcnt;
+	struct _iohandle	cfg;
+	struct _iohandle	addr;
+	struct _ioaddr		isac;
+	struct _ioaddr		hscx;
+	spinlock_t		lock;	/* HW access lock */
+	struct ipac_hw		ipac;
+	struct inf_hw		*sc[3];	/* slave cards */
+};
+
+
+#define PCI_SUBVENDOR_HST_SAPHIR3       0x52
+#define PCI_SUBVENDOR_SEDLBAUER_PCI     0x53
+#define PCI_SUB_ID_SEDLBAUER            0x01
+
+static struct pci_device_id infineon_ids[] __devinitdata = {
+	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA20,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA20},
+	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA20_U,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA20U},
+	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA201,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA201},
+	{ PCI_VENDOR_ID_EICON, PCI_DEVICE_ID_EICON_DIVA202,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_DIVA202},
+	{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,
+	  PCI_SUBVENDOR_SEDLBAUER_PCI, PCI_SUB_ID_SEDLBAUER, 0, 0,
+	  INF_SPEEDWIN},
+	{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,
+	  PCI_SUBVENDOR_HST_SAPHIR3, PCI_SUB_ID_SEDLBAUER, 0, 0, INF_SAPHIR3},
+	{ PCI_VENDOR_ID_ELSA, PCI_DEVICE_ID_ELSA_MICROLINK,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_QS1000},
+	{ PCI_VENDOR_ID_ELSA, PCI_DEVICE_ID_ELSA_QS3000,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_QS3000},
+	{ PCI_VENDOR_ID_SATSAGEM, PCI_DEVICE_ID_SATSAGEM_NICCY,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_NICCY},
+	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,
+	  PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO, 0, 0,
+	  INF_SCT_1},
+	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_R685,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R685},
+	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_R753,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R753},
+	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_DJINN_ITOO,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R753},
+	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_OLITEC,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, INF_GAZEL_R753},
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, infineon_ids);
+
+/* PCI interface specific defines */
+/* Diva 2.0/2.0U */
+#define DIVA_HSCX_PORT		0x00
+#define DIVA_HSCX_ALE		0x04
+#define DIVA_ISAC_PORT		0x08
+#define DIVA_ISAC_ALE		0x0C
+#define DIVA_PCI_CTRL           0x10
+
+/* DIVA_PCI_CTRL bits */
+#define DIVA_IRQ_BIT		0x01
+#define DIVA_RESET_BIT		0x08
+#define DIVA_EEPROM_CLK		0x40
+#define DIVA_LED_A		0x10
+#define DIVA_LED_B		0x20
+#define DIVA_IRQ_CLR		0x80
+
+/* Diva 2.01/2.02 */
+/* Siemens PITA */
+#define PITA_ICR_REG		0x00
+#define PITA_INT0_STATUS	0x02
+
+#define PITA_MISC_REG		0x1c
+#define PITA_PARA_SOFTRESET	0x01000000
+#define PITA_SER_SOFTRESET	0x02000000
+#define PITA_PARA_MPX_MODE	0x04000000
+#define PITA_INT0_ENABLE	0x00020000
+
+/* TIGER 100 Registers */
+#define TIGER_RESET_ADDR	0x00
+#define TIGER_EXTERN_RESET	0x01
+#define TIGER_AUX_CTRL		0x02
+#define TIGER_AUX_DATA		0x03
+#define TIGER_AUX_IRQMASK	0x05
+#define TIGER_AUX_STATUS	0x07
+
+/* Tiger AUX BITs */
+#define TIGER_IOMASK		0xdd	/* 1 and 5 are inputs */
+#define TIGER_IRQ_BIT		0x02
+
+#define TIGER_IPAC_ALE		0xC0
+#define TIGER_IPAC_PORT		0xC8
+
+/* ELSA (now Develo) PCI cards */
+#define ELSA_IRQ_ADDR		0x4c
+#define ELSA_IRQ_MASK		0x04
+#define QS1000_IRQ_OFF		0x01
+#define QS3000_IRQ_OFF		0x03
+#define QS1000_IRQ_ON		0x41
+#define QS3000_IRQ_ON		0x43
+
+/* Dr Neuhaus/Sagem Niccy */
+#define NICCY_ISAC_PORT		0x00
+#define NICCY_HSCX_PORT		0x01
+#define NICCY_ISAC_ALE		0x02
+#define NICCY_HSCX_ALE		0x03
+
+#define NICCY_IRQ_CTRL_REG	0x38
+#define NICCY_IRQ_ENABLE	0x001f00
+#define NICCY_IRQ_DISABLE	0xff0000
+#define NICCY_IRQ_BIT		0x800000
+
+
+/* Scitel PLX */
+#define SCT_PLX_IRQ_ADDR	0x4c
+#define SCT_PLX_RESET_ADDR	0x50
+#define SCT_PLX_IRQ_ENABLE	0x41
+#define SCT_PLX_RESET_BIT	0x04
+
+/* Gazel */
+#define	GAZEL_IPAC_DATA_PORT	0x04
+/* Gazel PLX */
+#define GAZEL_CNTRL		0x50
+#define GAZEL_RESET		0x04
+#define GAZEL_RESET_9050	0x40000000
+#define GAZEL_INCSR		0x4C
+#define GAZEL_ISAC_EN		0x08
+#define GAZEL_INT_ISAC		0x20
+#define GAZEL_HSCX_EN		0x01
+#define GAZEL_INT_HSCX		0x04
+#define GAZEL_PCI_EN		0x40
+#define GAZEL_IPAC_EN		0x03
+
+
+static LIST_HEAD(Cards);
+static DEFINE_RWLOCK(card_lock); /* protect Cards */
+
+static void
+_set_debug(struct inf_hw *card)
+{
+	card->ipac.isac.dch.debug = debug;
+	card->ipac.hscx[0].bch.debug = debug;
+	card->ipac.hscx[1].bch.debug = debug;
+}
+
+static int
+set_debug(const char *val, struct kernel_param *kp)
+{
+	int ret;
+	struct inf_hw *card;
+
+	ret = param_set_uint(val, kp);
+	if (!ret) {
+		read_lock(&card_lock);
+		list_for_each_entry(card, &Cards, list)
+			_set_debug(card);
+		read_unlock(&card_lock);
+	}
+	return ret;
+}
+
+MODULE_AUTHOR("Karsten Keil");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(INFINEON_REV);
+module_param_call(debug, set_debug, param_get_uint, &debug, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "infineon debug mask");
+module_param(irqloops, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(irqloops, "infineon maximal irqloops (default 4)");
+
+/* Interface functions */
+
+IOFUNC_IO(ISAC, inf_hw, isac.a.io)
+IOFUNC_IO(IPAC, inf_hw, hscx.a.io)
+IOFUNC_IND(ISAC, inf_hw, isac.a.io)
+IOFUNC_IND(IPAC, inf_hw, hscx.a.io)
+IOFUNC_MEMIO(ISAC, inf_hw, u32, isac.a.p)
+IOFUNC_MEMIO(IPAC, inf_hw, u32, hscx.a.p)
+
+static irqreturn_t
+diva_irq(int intno, void *dev_id)
+{
+	struct inf_hw *hw = dev_id;
+	u8 val;
+
+	spin_lock(&hw->lock);
+	val = inb((u32)hw->cfg.start + DIVA_PCI_CTRL);
+	if (!(val & DIVA_IRQ_BIT)) { /* for us or shared ? */
+		spin_unlock(&hw->lock);
+		return IRQ_NONE; /* shared */
+	}
+	hw->irqcnt++;
+	mISDNipac_irq(&hw->ipac, irqloops);
+	spin_unlock(&hw->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+diva20x_irq(int intno, void *dev_id)
+{
+	struct inf_hw *hw = dev_id;
+	u8 val;
+
+	spin_lock(&hw->lock);
+	val = readb(hw->cfg.p);
+	if (!(val & PITA_INT0_STATUS)) { /* for us or shared ? */
+		spin_unlock(&hw->lock);
+		return IRQ_NONE; /* shared */
+	}
+	hw->irqcnt++;
+	mISDNipac_irq(&hw->ipac, irqloops);
+	writeb(PITA_INT0_STATUS, hw->cfg.p); /* ACK PITA INT0 */
+	spin_unlock(&hw->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+tiger_irq(int intno, void *dev_id)
+{
+	struct inf_hw *hw = dev_id;
+	u8 val;
+
+	spin_lock(&hw->lock);
+	val = inb((u32)hw->cfg.start + TIGER_AUX_STATUS);
+	if (val & TIGER_IRQ_BIT) { /* for us or shared ? */
+		spin_unlock(&hw->lock);
+		return IRQ_NONE; /* shared */
+	}
+	hw->irqcnt++;
+	mISDNipac_irq(&hw->ipac, irqloops);
+	spin_unlock(&hw->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+elsa_irq(int intno, void *dev_id)
+{
+	struct inf_hw *hw = dev_id;
+	u8 val;
+
+	spin_lock(&hw->lock);
+	val = inb((u32)hw->cfg.start + ELSA_IRQ_ADDR);
+	if (!(val & ELSA_IRQ_MASK)) {
+		spin_unlock(&hw->lock);
+		return IRQ_NONE; /* shared */
+	}
+	hw->irqcnt++;
+	mISDNipac_irq(&hw->ipac, irqloops);
+	spin_unlock(&hw->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+niccy_irq(int intno, void *dev_id)
+{
+	struct inf_hw *hw = dev_id;
+	u32 val;
+
+	spin_lock(&hw->lock);
+	val = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
+	if (!(val & NICCY_IRQ_BIT)) { /* for us or shared ? */
+		spin_unlock(&hw->lock);
+		return IRQ_NONE; /* shared */
+	}
+	outl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
+	hw->irqcnt++;
+	mISDNipac_irq(&hw->ipac, irqloops);
+	spin_unlock(&hw->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+gazel_irq(int intno, void *dev_id)
+{
+	struct inf_hw *hw = dev_id;
+	irqreturn_t ret;
+
+	spin_lock(&hw->lock);
+	ret = mISDNipac_irq(&hw->ipac, irqloops);
+	spin_unlock(&hw->lock);
+	return ret;
+}
+
+static irqreturn_t
+ipac_irq(int intno, void *dev_id)
+{
+	struct inf_hw *hw = dev_id;
+	u8 val;
+
+	spin_lock(&hw->lock);
+	val = hw->ipac.read_reg(hw, IPAC_ISTA);
+	if (!(val & 0x3f)) {
+		spin_unlock(&hw->lock);
+		return IRQ_NONE; /* shared */
+	}
+	hw->irqcnt++;
+	mISDNipac_irq(&hw->ipac, irqloops);
+	spin_unlock(&hw->lock);
+	return IRQ_HANDLED;
+}
+
+static void
+enable_hwirq(struct inf_hw *hw)
+{
+	u16 w;
+	u32 val;
+
+	switch (hw->ci->typ) {
+	case INF_DIVA201:
+	case INF_DIVA202:
+		writel(PITA_INT0_ENABLE, hw->cfg.p);
+		break;
+	case INF_SPEEDWIN:
+	case INF_SAPHIR3:
+		outb(TIGER_IRQ_BIT, (u32)hw->cfg.start + TIGER_AUX_IRQMASK);
+		break;
+	case INF_QS1000:
+		outb(QS1000_IRQ_ON, (u32)hw->cfg.start + ELSA_IRQ_ADDR);
+		break;
+	case INF_QS3000:
+		outb(QS3000_IRQ_ON, (u32)hw->cfg.start + ELSA_IRQ_ADDR);
+		break;
+	case INF_NICCY:
+		val = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
+		val |= NICCY_IRQ_ENABLE;;
+		outl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
+		break;
+	case INF_SCT_1:
+		w = inw((u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);
+		w |= SCT_PLX_IRQ_ENABLE;
+		outw(w, (u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);
+		break;
+	case INF_GAZEL_R685:
+		outb(GAZEL_ISAC_EN + GAZEL_HSCX_EN + GAZEL_PCI_EN,
+			(u32)hw->cfg.start + GAZEL_INCSR);
+		break;
+	case INF_GAZEL_R753:
+		outb(GAZEL_IPAC_EN + GAZEL_PCI_EN,
+			(u32)hw->cfg.start + GAZEL_INCSR);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+disable_hwirq(struct inf_hw *hw)
+{
+	u16 w;
+	u32 val;
+
+	switch (hw->ci->typ) {
+	case INF_DIVA201:
+	case INF_DIVA202:
+		writel(0, hw->cfg.p);
+		break;
+	case INF_SPEEDWIN:
+	case INF_SAPHIR3:
+		outb(0, (u32)hw->cfg.start + TIGER_AUX_IRQMASK);
+		break;
+	case INF_QS1000:
+		outb(QS1000_IRQ_OFF, (u32)hw->cfg.start + ELSA_IRQ_ADDR);
+		break;
+	case INF_QS3000:
+		outb(QS3000_IRQ_OFF, (u32)hw->cfg.start + ELSA_IRQ_ADDR);
+		break;
+	case INF_NICCY:
+		val = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
+		val &= NICCY_IRQ_DISABLE;
+		outl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);
+		break;
+	case INF_SCT_1:
+		w = inw((u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);
+		w &= (~SCT_PLX_IRQ_ENABLE);
+		outw(w, (u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);
+		break;
+	case INF_GAZEL_R685:
+	case INF_GAZEL_R753:
+		outb(0, (u32)hw->cfg.start + GAZEL_INCSR);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+ipac_chip_reset(struct inf_hw *hw)
+{
+	hw->ipac.write_reg(hw, IPAC_POTA2, 0x20);
+	mdelay(5);
+	hw->ipac.write_reg(hw, IPAC_POTA2, 0x00);
+	mdelay(5);
+	hw->ipac.write_reg(hw, IPAC_CONF, hw->ipac.conf);
+	hw->ipac.write_reg(hw, IPAC_MASK, 0xc0);
+}
+
+static void
+reset_inf(struct inf_hw *hw)
+{
+	u16 w;
+	u32 val;
+
+	if (debug & DEBUG_HW)
+		pr_notice("%s: resetting card\n", hw->name);
+	switch (hw->ci->typ) {
+	case INF_DIVA20:
+	case INF_DIVA20U:
+		outb(0, (u32)hw->cfg.start + DIVA_PCI_CTRL);
+		mdelay(10);
+		outb(DIVA_RESET_BIT, (u32)hw->cfg.start + DIVA_PCI_CTRL);
+		mdelay(10);
+		/* Workaround PCI9060 */
+		outb(9, (u32)hw->cfg.start + 0x69);
+		outb(DIVA_RESET_BIT | DIVA_LED_A,
+			(u32)hw->cfg.start + DIVA_PCI_CTRL);
+		break;
+	case INF_DIVA201:
+		writel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,
+			hw->cfg.p + PITA_MISC_REG);
+		mdelay(1);
+		writel(PITA_PARA_MPX_MODE, hw->cfg.p + PITA_MISC_REG);
+		mdelay(10);
+		break;
+	case INF_DIVA202:
+		writel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,
+			hw->cfg.p + PITA_MISC_REG);
+		mdelay(1);
+		writel(PITA_PARA_MPX_MODE | PITA_SER_SOFTRESET,
+			hw->cfg.p + PITA_MISC_REG);
+		mdelay(10);
+		break;
+	case INF_SPEEDWIN:
+	case INF_SAPHIR3:
+		ipac_chip_reset(hw);
+		hw->ipac.write_reg(hw, IPAC_ACFG, 0xff);
+		hw->ipac.write_reg(hw, IPAC_AOE, 0x00);
+		hw->ipac.write_reg(hw, IPAC_PCFG, 0x12);
+		break;
+	case INF_QS1000:
+	case INF_QS3000:
+		ipac_chip_reset(hw);
+		hw->ipac.write_reg(hw, IPAC_ACFG, 0x00);
+		hw->ipac.write_reg(hw, IPAC_AOE, 0x3c);
+		hw->ipac.write_reg(hw, IPAC_ATX, 0xff);
+		break;
+	case INF_NICCY:
+		break;
+	case INF_SCT_1:
+		w = inw((u32)hw->cfg.start + SCT_PLX_RESET_ADDR);
+		w &= (~SCT_PLX_RESET_BIT);
+		outw(w, (u32)hw->cfg.start + SCT_PLX_RESET_ADDR);
+		mdelay(10);
+		w = inw((u32)hw->cfg.start + SCT_PLX_RESET_ADDR);
+		w |= SCT_PLX_RESET_BIT;
+		outw(w, (u32)hw->cfg.start + SCT_PLX_RESET_ADDR);
+		mdelay(10);
+		break;
+	case INF_GAZEL_R685:
+		val = inl((u32)hw->cfg.start + GAZEL_CNTRL);
+		val |= (GAZEL_RESET_9050 + GAZEL_RESET);
+		outl(val, (u32)hw->cfg.start + GAZEL_CNTRL);
+		val &= ~(GAZEL_RESET_9050 + GAZEL_RESET);
+		mdelay(4);
+		outl(val, (u32)hw->cfg.start + GAZEL_CNTRL);
+		mdelay(10);
+		hw->ipac.isac.adf2 = 0x87;
+		hw->ipac.hscx[0].slot = 0x1f;
+		hw->ipac.hscx[0].slot = 0x23;
+		break;
+	case INF_GAZEL_R753:
+		val = inl((u32)hw->cfg.start + GAZEL_CNTRL);
+		val |= (GAZEL_RESET_9050 + GAZEL_RESET);
+		outl(val, (u32)hw->cfg.start + GAZEL_CNTRL);
+		val &= ~(GAZEL_RESET_9050 + GAZEL_RESET);
+		mdelay(4);
+		outl(val, (u32)hw->cfg.start + GAZEL_CNTRL);
+		mdelay(10);
+		ipac_chip_reset(hw);
+		hw->ipac.write_reg(hw, IPAC_ACFG, 0xff);
+		hw->ipac.write_reg(hw, IPAC_AOE, 0x00);
+		hw->ipac.conf = 0x01; /* IOM off */
+		break;
+	default:
+		return;
+	}
+	enable_hwirq(hw);
+}
+
+static int
+inf_ctrl(struct inf_hw *hw, u32 cmd, u_long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case HW_RESET_REQ:
+		reset_inf(hw);
+		break;
+	default:
+		pr_info("%s: %s unknown command %x %lx\n",
+			hw->name, __func__, cmd, arg);
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int __devinit
+init_irq(struct inf_hw *hw)
+{
+	int	ret, cnt = 3;
+	u_long	flags;
+
+	if (!hw->ci->irqfunc)
+		return -EINVAL;
+	ret = request_irq(hw->irq, hw->ci->irqfunc, IRQF_SHARED, hw->name, hw);
+	if (ret) {
+		pr_info("%s: couldn't get interrupt %d\n", hw->name, hw->irq);
+		return ret;
+	}
+	while (cnt--) {
+		spin_lock_irqsave(&hw->lock, flags);
+		reset_inf(hw);
+		ret = hw->ipac.init(&hw->ipac);
+		if (ret) {
+			spin_unlock_irqrestore(&hw->lock, flags);
+			pr_info("%s: ISAC init failed with %d\n",
+				hw->name, ret);
+			break;
+		}
+		spin_unlock_irqrestore(&hw->lock, flags);
+		msleep_interruptible(10);
+		if (debug & DEBUG_HW)
+			pr_notice("%s: IRQ %d count %d\n", hw->name,
+				hw->irq, hw->irqcnt);
+		if (!hw->irqcnt) {
+			pr_info("%s: IRQ(%d) got no requests during init %d\n",
+				hw->name, hw->irq, 3 - cnt);
+		} else
+			return 0;
+	}
+	free_irq(hw->irq, hw);
+	return -EIO;
+}
+
+static void
+release_io(struct inf_hw *hw)
+{
+	if (hw->cfg.mode) {
+		if (hw->cfg.p) {
+			release_mem_region(hw->cfg.start, hw->cfg.size);
+			iounmap(hw->cfg.p);
+		} else
+			release_region(hw->cfg.start, hw->cfg.size);
+		hw->cfg.mode = AM_NONE;
+	}
+	if (hw->addr.mode) {
+		if (hw->addr.p) {
+			release_mem_region(hw->addr.start, hw->addr.size);
+			iounmap(hw->addr.p);
+		} else
+			release_region(hw->addr.start, hw->addr.size);
+		hw->addr.mode = AM_NONE;
+	}
+}
+
+static int __devinit
+setup_io(struct inf_hw *hw)
+{
+	int err = 0;
+
+	if (hw->ci->cfg_mode) {
+		hw->cfg.start = pci_resource_start(hw->pdev, hw->ci->cfg_bar);
+		hw->cfg.size = pci_resource_len(hw->pdev, hw->ci->cfg_bar);
+		if (hw->ci->cfg_mode == AM_MEMIO) {
+			if (!request_mem_region(hw->cfg.start, hw->cfg.size,
+			    hw->name))
+				err = -EBUSY;
+		} else {
+			if (!request_region(hw->cfg.start, hw->cfg.size,
+			    hw->name))
+				err = -EBUSY;
+		}
+		if (err) {
+			pr_info("mISDN: %s config port %lx (%lu bytes)"
+				"already in use\n", hw->name,
+				(ulong)hw->cfg.start, (ulong)hw->cfg.size);
+			return err;
+		}
+		if (hw->ci->cfg_mode == AM_MEMIO)
+			hw->cfg.p = ioremap(hw->cfg.start, hw->cfg.size);
+		hw->cfg.mode = hw->ci->cfg_mode;
+		if (debug & DEBUG_HW)
+			pr_notice("%s: IO cfg %lx (%lu bytes) mode%d\n",
+				hw->name, (ulong)hw->cfg.start,
+				(ulong)hw->cfg.size, hw->ci->cfg_mode);
+
+	}
+	if (hw->ci->addr_mode) {
+		hw->addr.start = pci_resource_start(hw->pdev, hw->ci->addr_bar);
+		hw->addr.size = pci_resource_len(hw->pdev, hw->ci->addr_bar);
+		if (hw->ci->addr_mode == AM_MEMIO) {
+			if (!request_mem_region(hw->addr.start, hw->addr.size,
+			    hw->name))
+				err = -EBUSY;
+		} else {
+			if (!request_region(hw->addr.start, hw->addr.size,
+			    hw->name))
+				err = -EBUSY;
+		}
+		if (err) {
+			pr_info("mISDN: %s address port %lx (%lu bytes)"
+				"already in use\n", hw->name,
+				(ulong)hw->addr.start, (ulong)hw->addr.size);
+			return err;
+		}
+		if (hw->ci->addr_mode == AM_MEMIO)
+			hw->addr.p = ioremap(hw->addr.start, hw->addr.size);
+		hw->addr.mode = hw->ci->addr_mode;
+		if (debug & DEBUG_HW)
+			pr_notice("%s: IO addr %lx (%lu bytes) mode%d\n",
+				hw->name, (ulong)hw->addr.start,
+				(ulong)hw->addr.size, hw->ci->addr_mode);
+
+	}
+
+	switch (hw->ci->typ) {
+	case INF_DIVA20:
+	case INF_DIVA20U:
+		hw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;
+		hw->isac.mode = hw->cfg.mode;
+		hw->isac.a.io.ale = (u32)hw->cfg.start + DIVA_ISAC_ALE;
+		hw->isac.a.io.port = (u32)hw->cfg.start + DIVA_ISAC_PORT;
+		hw->hscx.mode = hw->cfg.mode;
+		hw->hscx.a.io.ale = (u32)hw->cfg.start + DIVA_HSCX_ALE;
+		hw->hscx.a.io.port = (u32)hw->cfg.start + DIVA_HSCX_PORT;
+		break;
+	case INF_DIVA201:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.mode = hw->addr.mode;
+		hw->isac.a.p = hw->addr.p;
+		hw->hscx.mode = hw->addr.mode;
+		hw->hscx.a.p = hw->addr.p;
+		break;
+	case INF_DIVA202:
+		hw->ipac.type = IPAC_TYPE_IPACX;
+		hw->isac.mode = hw->addr.mode;
+		hw->isac.a.p = hw->addr.p;
+		hw->hscx.mode = hw->addr.mode;
+		hw->hscx.a.p = hw->addr.p;
+		break;
+	case INF_SPEEDWIN:
+	case INF_SAPHIR3:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.mode = hw->cfg.mode;
+		hw->isac.a.io.ale = (u32)hw->cfg.start + TIGER_IPAC_ALE;
+		hw->isac.a.io.port = (u32)hw->cfg.start + TIGER_IPAC_PORT;
+		hw->hscx.mode = hw->cfg.mode;
+		hw->hscx.a.io.ale = (u32)hw->cfg.start + TIGER_IPAC_ALE;
+		hw->hscx.a.io.port = (u32)hw->cfg.start + TIGER_IPAC_PORT;
+		outb(0xff, (ulong)hw->cfg.start);
+		mdelay(1);
+		outb(0x00, (ulong)hw->cfg.start);
+		mdelay(1);
+		outb(TIGER_IOMASK, (ulong)hw->cfg.start + TIGER_AUX_CTRL);
+		break;
+	case INF_QS1000:
+	case INF_QS3000:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.a.io.ale = (u32)hw->addr.start;
+		hw->isac.a.io.port = (u32)hw->addr.start + 1;
+		hw->isac.mode = hw->addr.mode;
+		hw->hscx.a.io.ale = (u32)hw->addr.start;
+		hw->hscx.a.io.port = (u32)hw->addr.start + 1;
+		hw->hscx.mode = hw->addr.mode;
+		break;
+	case INF_NICCY:
+		hw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;
+		hw->isac.mode = hw->addr.mode;
+		hw->isac.a.io.ale = (u32)hw->addr.start + NICCY_ISAC_ALE;
+		hw->isac.a.io.port = (u32)hw->addr.start + NICCY_ISAC_PORT;
+		hw->hscx.mode = hw->addr.mode;
+		hw->hscx.a.io.ale = (u32)hw->addr.start + NICCY_HSCX_ALE;
+		hw->hscx.a.io.port = (u32)hw->addr.start + NICCY_HSCX_PORT;
+		break;
+	case INF_SCT_1:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.a.io.ale = (u32)hw->addr.start;
+		hw->isac.a.io.port = hw->isac.a.io.ale + 4;
+		hw->isac.mode = hw->addr.mode;
+		hw->hscx.a.io.ale = hw->isac.a.io.ale;
+		hw->hscx.a.io.port = hw->isac.a.io.port;
+		hw->hscx.mode = hw->addr.mode;
+		break;
+	case INF_SCT_2:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.a.io.ale = (u32)hw->addr.start + 0x08;
+		hw->isac.a.io.port = hw->isac.a.io.ale + 4;
+		hw->isac.mode = hw->addr.mode;
+		hw->hscx.a.io.ale = hw->isac.a.io.ale;
+		hw->hscx.a.io.port = hw->isac.a.io.port;
+		hw->hscx.mode = hw->addr.mode;
+		break;
+	case INF_SCT_3:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.a.io.ale = (u32)hw->addr.start + 0x10;
+		hw->isac.a.io.port = hw->isac.a.io.ale + 4;
+		hw->isac.mode = hw->addr.mode;
+		hw->hscx.a.io.ale = hw->isac.a.io.ale;
+		hw->hscx.a.io.port = hw->isac.a.io.port;
+		hw->hscx.mode = hw->addr.mode;
+		break;
+	case INF_SCT_4:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.a.io.ale = (u32)hw->addr.start + 0x20;
+		hw->isac.a.io.port = hw->isac.a.io.ale + 4;
+		hw->isac.mode = hw->addr.mode;
+		hw->hscx.a.io.ale = hw->isac.a.io.ale;
+		hw->hscx.a.io.port = hw->isac.a.io.port;
+		hw->hscx.mode = hw->addr.mode;
+		break;
+	case INF_GAZEL_R685:
+		hw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.mode = hw->addr.mode;
+		hw->isac.a.io.port = (u32)hw->addr.start;
+		hw->hscx.mode = hw->addr.mode;
+		hw->hscx.a.io.port = hw->isac.a.io.port;
+		break;
+	case INF_GAZEL_R753:
+		hw->ipac.type = IPAC_TYPE_IPAC;
+		hw->ipac.isac.off = 0x80;
+		hw->isac.mode = hw->addr.mode;
+		hw->isac.a.io.ale = (u32)hw->addr.start;
+		hw->isac.a.io.port = (u32)hw->addr.start + GAZEL_IPAC_DATA_PORT;
+		hw->hscx.mode = hw->addr.mode;
+		hw->hscx.a.io.ale = hw->isac.a.io.ale;
+		hw->hscx.a.io.port = hw->isac.a.io.port;
+		break;
+	default:
+		return -EINVAL;
+	}
+	switch (hw->isac.mode) {
+	case AM_MEMIO:
+		ASSIGN_FUNC_IPAC(MIO, hw->ipac);
+		break;
+	case AM_IND_IO:
+		ASSIGN_FUNC_IPAC(IND, hw->ipac);
+		break;
+	case AM_IO:
+		ASSIGN_FUNC_IPAC(IO, hw->ipac);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void
+release_card(struct inf_hw *card) {
+	ulong	flags;
+	int	i;
+
+	spin_lock_irqsave(&card->lock, flags);
+	disable_hwirq(card);
+	spin_unlock_irqrestore(&card->lock, flags);
+	card->ipac.isac.release(&card->ipac.isac);
+	free_irq(card->irq, card);
+	mISDN_unregister_device(&card->ipac.isac.dch.dev);
+	release_io(card);
+	write_lock_irqsave(&card_lock, flags);
+	list_del(&card->list);
+	write_unlock_irqrestore(&card_lock, flags);
+	switch (card->ci->typ) {
+	case INF_SCT_2:
+	case INF_SCT_3:
+	case INF_SCT_4:
+		break;
+	case INF_SCT_1:
+		for (i = 0; i < 3; i++) {
+			if (card->sc[i])
+				release_card(card->sc[i]);
+			card->sc[i] = NULL;
+		}
+	default:
+		pci_disable_device(card->pdev);
+		pci_set_drvdata(card->pdev, NULL);
+		break;
+	}
+	kfree(card);
+	inf_cnt--;
+}
+
+static int __devinit
+setup_instance(struct inf_hw *card)
+{
+	int err;
+	ulong flags;
+
+	snprintf(card->name, MISDN_MAX_IDLEN - 1, "%s.%d", card->ci->name,
+		inf_cnt + 1);
+	write_lock_irqsave(&card_lock, flags);
+	list_add_tail(&card->list, &Cards);
+	write_unlock_irqrestore(&card_lock, flags);
+
+	_set_debug(card);
+	card->ipac.isac.name = card->name;
+	card->ipac.name = card->name;
+	card->ipac.owner = THIS_MODULE;
+	spin_lock_init(&card->lock);
+	card->ipac.isac.hwlock = &card->lock;
+	card->ipac.hwlock = &card->lock;
+	card->ipac.ctrl = (void *)&inf_ctrl;
+
+	err = setup_io(card);
+	if (err)
+		goto error_setup;
+
+	card->ipac.isac.dch.dev.Bprotocols =
+		mISDNipac_init(&card->ipac, card);
+
+	if (card->ipac.isac.dch.dev.Bprotocols == 0)
+		goto error_setup;;
+
+	err = mISDN_register_device(&card->ipac.isac.dch.dev,
+		&card->pdev->dev, card->name);
+	if (err)
+		goto error;
+
+	err = init_irq(card);
+	if (!err)  {
+		inf_cnt++;
+		pr_notice("Infineon %d cards installed\n", inf_cnt);
+		return 0;
+	}
+	mISDN_unregister_device(&card->ipac.isac.dch.dev);
+error:
+	card->ipac.release(&card->ipac);
+error_setup:
+	release_io(card);
+	write_lock_irqsave(&card_lock, flags);
+	list_del(&card->list);
+	write_unlock_irqrestore(&card_lock, flags);
+	return err;
+}
+
+static const struct inf_cinfo inf_card_info[] = {
+	{
+		INF_DIVA20,
+		"Dialogic Diva 2.0",
+		"diva20",
+		AM_IND_IO, AM_NONE, 2, 0,
+		&diva_irq
+	},
+	{
+		INF_DIVA20U,
+		"Dialogic Diva 2.0U",
+		"diva20U",
+		AM_IND_IO, AM_NONE, 2, 0,
+		&diva_irq
+	},
+	{
+		INF_DIVA201,
+		"Dialogic Diva 2.01",
+		"diva201",
+		AM_MEMIO, AM_MEMIO, 0, 1,
+		&diva20x_irq
+	},
+	{
+		INF_DIVA202,
+		"Dialogic Diva 2.02",
+		"diva202",
+		AM_MEMIO, AM_MEMIO, 0, 1,
+		&diva20x_irq
+	},
+	{
+		INF_SPEEDWIN,
+		"Sedlbauer SpeedWin PCI",
+		"speedwin",
+		AM_IND_IO, AM_NONE, 0, 0,
+		&tiger_irq
+	},
+	{
+		INF_SAPHIR3,
+		"HST Saphir 3",
+		"saphir",
+		AM_IND_IO, AM_NONE, 0, 0,
+		&tiger_irq
+	},
+	{
+		INF_QS1000,
+		"Develo Microlink PCI",
+		"qs1000",
+		AM_IO, AM_IND_IO, 1, 3,
+		&elsa_irq
+	},
+	{
+		INF_QS3000,
+		"Develo QuickStep 3000",
+		"qs3000",
+		AM_IO, AM_IND_IO, 1, 3,
+		&elsa_irq
+	},
+	{
+		INF_NICCY,
+		"Sagem NICCY",
+		"niccy",
+		AM_IO, AM_IND_IO, 0, 1,
+		&niccy_irq
+	},
+	{
+		INF_SCT_1,
+		"SciTel Quadro",
+		"p1_scitel",
+		AM_IO, AM_IND_IO, 1, 5,
+		&ipac_irq
+	},
+	{
+		INF_SCT_2,
+		"SciTel Quadro",
+		"p2_scitel",
+		AM_NONE, AM_IND_IO, 0, 4,
+		&ipac_irq
+	},
+	{
+		INF_SCT_3,
+		"SciTel Quadro",
+		"p3_scitel",
+		AM_NONE, AM_IND_IO, 0, 3,
+		&ipac_irq
+	},
+	{
+		INF_SCT_4,
+		"SciTel Quadro",
+		"p4_scitel",
+		AM_NONE, AM_IND_IO, 0, 2,
+		&ipac_irq
+	},
+	{
+		INF_GAZEL_R685,
+		"Gazel R685",
+		"gazel685",
+		AM_IO, AM_IO, 1, 2,
+		&gazel_irq
+	},
+	{
+		INF_GAZEL_R753,
+		"Gazel R753",
+		"gazel753",
+		AM_IO, AM_IND_IO, 1, 2,
+		&ipac_irq
+	},
+	{
+		INF_NONE,
+	}
+};
+
+static const struct inf_cinfo * __devinit
+get_card_info(enum inf_types typ)
+{
+	const struct inf_cinfo *ci = inf_card_info;
+
+	while (ci->typ != INF_NONE) {
+		if (ci->typ == typ)
+			return ci;
+		ci++;
+	}
+	return NULL;
+}
+
+static int __devinit
+inf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int err = -ENOMEM;
+	struct inf_hw *card;
+
+	card = kzalloc(sizeof(struct inf_hw), GFP_KERNEL);
+	if (!card) {
+		pr_info("No memory for Infineon ISDN card\n");
+		return err;
+	}
+	card->pdev = pdev;
+	err = pci_enable_device(pdev);
+	if (err) {
+		kfree(card);
+		return err;
+	}
+	card->ci = get_card_info(ent->driver_data);
+	if (!card->ci) {
+		pr_info("mISDN: do not have informations about adapter at %s\n",
+			pci_name(pdev));
+		kfree(card);
+		return -EINVAL;
+	} else
+		pr_notice("mISDN: found adapter %s at %s\n",
+			card->ci->full, pci_name(pdev));
+
+	card->irq = pdev->irq;
+	pci_set_drvdata(pdev, card);
+	err = setup_instance(card);
+	if (err) {
+		pci_disable_device(card->pdev);
+		kfree(card);
+		pci_set_drvdata(pdev, NULL);
+	} else if (ent->driver_data == INF_SCT_1) {
+		int i;
+		struct inf_hw *sc;
+
+		for (i = 1; i < 4; i++) {
+			sc = kzalloc(sizeof(struct inf_hw), GFP_KERNEL);
+			if (!sc) {
+				release_card(card);
+				return -ENOMEM;
+			}
+			sc->irq = card->irq;
+			sc->pdev = card->pdev;
+			sc->ci = card->ci + i;
+			err = setup_instance(sc);
+			if (err) {
+				kfree(sc);
+				release_card(card);
+			} else
+				card->sc[i - 1] = sc;
+		}
+	}
+	return err;
+}
+
+static void __devexit
+inf_remove(struct pci_dev *pdev)
+{
+	struct inf_hw	*card = pci_get_drvdata(pdev);
+
+	if (card)
+		release_card(card);
+	else
+		pr_debug("%s: drvdata allready removed\n", __func__);
+}
+
+static struct pci_driver infineon_driver = {
+	.name = "ISDN Infineon pci",
+	.probe = inf_probe,
+	.remove = __devexit_p(inf_remove),
+	.id_table = infineon_ids,
+};
+
+static int __init
+infineon_init(void)
+{
+	int err;
+
+	pr_notice("Infineon ISDN Driver Rev. %s\n", INFINEON_REV);
+	err = pci_register_driver(&infineon_driver);
+	return err;
+}
+
+static void __exit
+infineon_cleanup(void)
+{
+	pci_unregister_driver(&infineon_driver);
+}
+
+module_init(infineon_init);
+module_exit(infineon_cleanup);
