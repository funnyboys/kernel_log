commit 436b2a8039ac00f8dc6ae8f3bd2be83748f72312
Merge: 1b96a41b4209 1d28122131b2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 25 19:40:40 2019 -0800

    Merge tag 'printk-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Allow to print symbolic error names via new %pe modifier.
    
     - Use pr_warn() instead of the remaining pr_warning() calls. Fix
       formatting of the related lines.
    
     - Add VSPRINTF entry to MAINTAINERS.
    
    * tag 'printk-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk: (32 commits)
      checkpatch: don't warn about new vsprintf pointer extension '%pe'
      MAINTAINERS: Add VSPRINTF
      tools lib api: Renaming pr_warning to pr_warn
      ASoC: samsung: Use pr_warn instead of pr_warning
      lib: cpu_rmap: Use pr_warn instead of pr_warning
      trace: Use pr_warn instead of pr_warning
      dma-debug: Use pr_warn instead of pr_warning
      vgacon: Use pr_warn instead of pr_warning
      fs: afs: Use pr_warn instead of pr_warning
      sh/intc: Use pr_warn instead of pr_warning
      scsi: Use pr_warn instead of pr_warning
      platform/x86: intel_oaktrail: Use pr_warn instead of pr_warning
      platform/x86: asus-laptop: Use pr_warn instead of pr_warning
      platform/x86: eeepc-laptop: Use pr_warn instead of pr_warning
      oprofile: Use pr_warn instead of pr_warning
      of: Use pr_warn instead of pr_warning
      macintosh: Use pr_warn instead of pr_warning
      idsn: Use pr_warn instead of pr_warning
      ide: Use pr_warn instead of pr_warning
      crypto: n2: Use pr_warn instead of pr_warning
      ...

commit 257daba4eb7f2b78c5b3d77443985c6c53560c73
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Fri Oct 18 11:18:31 2019 +0800

    idsn: Use pr_warn instead of pr_warning
    
    As said in commit f2c2cbcc35d4 ("powerpc: Use pr_warn instead of
    pr_warning"), removing pr_warning so all logging messages use a
    consistent <prefix>_warn style. Let's do it.
    
    Link: http://lkml.kernel.org/r/20191018031850.48498-14-wangkefeng.wang@huawei.com
    To: linux-kernel@vger.kernel.org
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index f915399d75ca..f468b4154dba 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -939,8 +939,8 @@ hscx_empty_fifo(struct hscx_hw *hscx, u8 count)
 		hscx_cmdr(hscx, 0x80); /* RMC */
 		if (hscx->bch.rx_skb)
 			skb_trim(hscx->bch.rx_skb, 0);
-		pr_warning("%s.B%d: No bufferspace for %d bytes\n",
-			   hscx->ip->name, hscx->bch.nr, count);
+		pr_warn("%s.B%d: No bufferspace for %d bytes\n",
+			hscx->ip->name, hscx->bch.nr, count);
 		return;
 	}
 	p = skb_put(hscx->bch.rx_skb, count);

commit 0f817a5eb9e33cec5baf9dc265bdf240b03cf51b
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 21 20:10:56 2019 +0200

    mISDN: Delete unnecessary checks before the macro call “dev_kfree_skb”
    
    The dev_kfree_skb() function performs also input parameter validation.
    Thus the test around the shown calls is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index f915399d75ca..bca880213e91 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -190,8 +190,7 @@ isac_rme_irq(struct isac_hw *isac)
 #endif
 		}
 		WriteISAC(isac, ISAC_CMDR, 0x80);
-		if (isac->dch.rx_skb)
-			dev_kfree_skb(isac->dch.rx_skb);
+		dev_kfree_skb(isac->dch.rx_skb);
 		isac->dch.rx_skb = NULL;
 	} else {
 		count = ReadISAC(isac, ISAC_RBCL) & 0x1f;
@@ -210,8 +209,7 @@ isac_xpr_irq(struct isac_hw *isac)
 	if (isac->dch.tx_skb && isac->dch.tx_idx < isac->dch.tx_skb->len) {
 		isac_fill_fifo(isac);
 	} else {
-		if (isac->dch.tx_skb)
-			dev_kfree_skb(isac->dch.tx_skb);
+		dev_kfree_skb(isac->dch.tx_skb);
 		if (get_next_dframe(&isac->dch))
 			isac_fill_fifo(isac);
 	}
@@ -464,8 +462,7 @@ isacsx_rme_irq(struct isac_hw *isac)
 			isac->dch.err_crc++;
 #endif
 		WriteISAC(isac, ISACX_CMDRD, ISACX_CMDRD_RMC);
-		if (isac->dch.rx_skb)
-			dev_kfree_skb(isac->dch.rx_skb);
+		dev_kfree_skb(isac->dch.rx_skb);
 		isac->dch.rx_skb = NULL;
 	} else {
 		count = ReadISAC(isac, ISACX_RBCLD) & 0x1f;
@@ -1012,8 +1009,7 @@ hscx_xpr(struct hscx_hw *hx)
 	if (hx->bch.tx_skb && hx->bch.tx_idx < hx->bch.tx_skb->len) {
 		hscx_fill_fifo(hx);
 	} else {
-		if (hx->bch.tx_skb)
-			dev_kfree_skb(hx->bch.tx_skb);
+		dev_kfree_skb(hx->bch.tx_skb);
 		if (get_next_bframe(&hx->bch)) {
 			hscx_fill_fifo(hx);
 			test_and_clear_bit(FLG_TX_EMPTY, &hx->bch.Flags);

commit 82c298100a2db7e4241e0fee73d94dc5ee573837
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:05 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 176
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170025.980374610@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 4d78f870435e..f915399d75ca 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * isac.c   ISAC specific routines
  *
  * Author       Karsten Keil <keil@isdn4linux.de>
  *
  * Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include <linux/irqreturn.h>

commit e313ac12eb13a9738116192848695da54c38b1ae
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:29:14 2017 -0700

    mISDN: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: Geliang Tang <geliangtang@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Anton Vasilyev <vasilyev@ispras.ru>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index e240010b93fa..4d78f870435e 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -172,7 +172,6 @@ isac_fill_fifo(struct isac_hw *isac)
 		pr_debug("%s: %s dbusytimer running\n", isac->name, __func__);
 		del_timer(&isac->dch.timer);
 	}
-	init_timer(&isac->dch.timer);
 	isac->dch.timer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ)/1000);
 	add_timer(&isac->dch.timer);
 	if (isac->dch.debug & DEBUG_HW_DFIFO) {
@@ -727,8 +726,9 @@ isac_release(struct isac_hw *isac)
 }
 
 static void
-dbusy_timer_handler(struct isac_hw *isac)
+dbusy_timer_handler(struct timer_list *t)
 {
+	struct isac_hw *isac = from_timer(isac, t, dch.timer);
 	int rbch, star;
 	u_long flags;
 
@@ -796,8 +796,7 @@ isac_init(struct isac_hw *isac)
 	}
 	isac->mon_tx = NULL;
 	isac->mon_rx = NULL;
-	setup_timer(&isac->dch.timer, (void *)dbusy_timer_handler,
-		    (long)isac);
+	timer_setup(&isac->dch.timer, dbusy_timer_handler, 0);
 	isac->mocr = 0xaa;
 	if (isac->type & IPAC_TYPE_ISACX) {
 		/* Disable all IRQ */

commit 02417f47875c2a22d2a8c140c5b945c741005938
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Wed Jun 7 15:15:01 2017 -0500

    mISDN: remove unnecessary variable assignments
    
    Remove unnecessary variable assignments.
    
    Addresses-Coverity-ID: 1226917
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 6742b0dc0821..e240010b93fa 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -364,8 +364,8 @@ isac_mos_irq(struct isac_hw *isac)
 			WriteISAC(isac, ISAC_MOCR, isac->mocr);
 			if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 				if (isac->monitor)
-					ret = isac->monitor(isac->dch.hw,
-							    MONITOR_TX_0, NULL, 0);
+					isac->monitor(isac->dch.hw,
+						      MONITOR_TX_0, NULL, 0);
 			}
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
@@ -375,8 +375,8 @@ isac_mos_irq(struct isac_hw *isac)
 		}
 		if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 			if (isac->monitor)
-				ret = isac->monitor(isac->dch.hw,
-						    MONITOR_TX_0, NULL, 0);
+				isac->monitor(isac->dch.hw,
+					      MONITOR_TX_0, NULL, 0);
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
 			isac->mon_txc = 0;
@@ -397,8 +397,8 @@ isac_mos_irq(struct isac_hw *isac)
 			WriteISAC(isac, ISAC_MOCR, isac->mocr);
 			if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 				if (isac->monitor)
-					ret = isac->monitor(isac->dch.hw,
-							    MONITOR_TX_1, NULL, 0);
+					isac->monitor(isac->dch.hw,
+						      MONITOR_TX_1, NULL, 0);
 			}
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
@@ -408,8 +408,8 @@ isac_mos_irq(struct isac_hw *isac)
 		}
 		if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 			if (isac->monitor)
-				ret = isac->monitor(isac->dch.hw,
-						    MONITOR_TX_1, NULL, 0);
+				isac->monitor(isac->dch.hw,
+					      MONITOR_TX_1, NULL, 0);
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
 			isac->mon_txc = 0;

commit aff55a3638a2d13de5cf0b0c45993378282cbe91
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Thu Mar 23 21:15:57 2017 +0800

    isdn: use setup_timer
    
    Use setup_timer() instead of init_timer() to simplify the code.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 77dec28ba874..6742b0dc0821 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -796,9 +796,8 @@ isac_init(struct isac_hw *isac)
 	}
 	isac->mon_tx = NULL;
 	isac->mon_rx = NULL;
-	isac->dch.timer.function = (void *) dbusy_timer_handler;
-	isac->dch.timer.data = (long)isac;
-	init_timer(&isac->dch.timer);
+	setup_timer(&isac->dch.timer, (void *)dbusy_timer_handler,
+		    (long)isac);
 	isac->mocr = 0xaa;
 	if (isac->type & IPAC_TYPE_ISACX) {
 		/* Disable all IRQ */

commit b8a14f3379a637f61deed4ce3e5180f1f34d40d1
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 27 14:29:50 2017 -0800

    scripts/spelling.txt: add "overwriten" pattern and fix typo instances
    
    Fix typos and add the following to the scripts/spelling.txt:
    
      overwrien||overwritten
    
    Link: http://lkml.kernel.org/r/1481573103-11329-30-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 8d338ba366d0..77dec28ba874 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1625,7 +1625,7 @@ mISDNipac_init(struct ipac_hw *ipac, void *hw)
 		ipac->hscx[i].bch.hw = hw;
 		ipac->hscx[i].ip = ipac;
 		/* default values for IOM time slots
-		 * can be overwriten by card */
+		 * can be overwritten by card */
 		ipac->hscx[i].slot = (i == 0) ? 0x2f : 0x03;
 	}
 

commit 569e937e0100c8841619bd2150d15682141a6b0b
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Thu Sep 1 14:16:24 2016 +0800

    mISDN: mark symbols static where possible
    
    We get a few warnings when building kernel with W=1:
    drivers/isdn/hardware/mISDN/hfcmulti.c:568:1: warning: no previous declaration for 'enablepcibridge' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:574:1: warning: no previous declaration for 'disablepcibridge' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:580:1: warning: no previous declaration for 'readpcibridge' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:608:1: warning: no previous declaration for 'writepcibridge' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:638:1: warning: no previous declaration for 'cpld_set_reg' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:645:1: warning: no previous declaration for 'cpld_write_reg' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:657:1: warning: no previous declaration for 'cpld_read_reg' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:674:1: warning: no previous declaration for 'vpm_write_address' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:681:1: warning: no previous declaration for 'vpm_read_address' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:695:1: warning: no previous declaration for 'vpm_in' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:716:1: warning: no previous declaration for 'vpm_out' [-Wmissing-declarations]
    drivers/isdn/hardware/mISDN/hfcmulti.c:1028:1: warning: no previous declaration for 'plxsd_checksync' [-Wmissing-declarations]
    ....
    
    In fact, these functions are only used in the file in which they are
    declared and don't need a declaration, but can be made static.
    so this patch marks these functions with 'static'.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index aa9b6c3cadc1..8d338ba366d0 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -113,7 +113,7 @@ isac_ph_state_bh(struct dchannel *dch)
 	pr_debug("%s: TE newstate %x\n", isac->name, dch->state);
 }
 
-void
+static void
 isac_empty_fifo(struct isac_hw *isac, int count)
 {
 	u8 *ptr;

commit 1e1589ad8b5cb5b8a6781ba5850cf710ada0e919
Author: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
Date:   Sun Mar 13 00:19:07 2016 +0100

    mISDN: Support DR6 indication in mISDNipac driver
    
    According to figure 39 in PEB3086 data sheet, version 1.4 this indication
    replaces DR when layer 1 transition source state is F6.
    
    This fixes mISDN layer 1 getting stuck in F6 state in TE mode on
    Dialogic Diva 2.02 card (and possibly others) when NT deactivates it.
    
    Signed-off-by: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
    Acked-by: Karsten Keil <keil@b1-systems.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index cb428b9ee441..aa9b6c3cadc1 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -80,6 +80,7 @@ isac_ph_state_bh(struct dchannel *dch)
 		l1_event(dch->l1, HW_DEACT_CNF);
 		break;
 	case ISAC_IND_DR:
+	case ISAC_IND_DR6:
 		dch->state = 3;
 		l1_event(dch->l1, HW_DEACT_IND);
 		break;
@@ -660,6 +661,7 @@ isac_l1cmd(struct dchannel *dch, u32 cmd)
 		spin_lock_irqsave(isac->hwlock, flags);
 		if ((isac->state == ISAC_IND_EI) ||
 		    (isac->state == ISAC_IND_DR) ||
+		    (isac->state == ISAC_IND_DR6) ||
 		    (isac->state == ISAC_IND_RS))
 			ph_command(isac, ISAC_CMD_TIM);
 		else

commit 40d24c4d8a7430aa4dfd7a665fa3faf3b05b673f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Dec 15 13:07:52 2015 +0300

    mISDN: fix a loop count
    
    There are two issue here.
    1)  cnt starts as maxloop + 1 so all these loops iterate one more time
        than intended.
    2)  At the end of the loop we test for "if (maxloop && !cnt)" but for
        the first two loops, we end with cnt equal to -1.  Changing this to
        a pre-op means we end with cnt set to 0.
    
    Fixes: cae86d4a4e56 ('mISDN: Add driver for Infineon ISDN chipset family')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index a77eea594b69..cb428b9ee441 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1170,7 +1170,7 @@ mISDNipac_irq(struct ipac_hw *ipac, int maxloop)
 
 	if (ipac->type & IPAC_TYPE_IPACX) {
 		ista = ReadIPAC(ipac, ISACX_ISTA);
-		while (ista && cnt--) {
+		while (ista && --cnt) {
 			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
 			if (ista & IPACX__ICA)
 				ipac_irq(&ipac->hscx[0], ista);
@@ -1182,7 +1182,7 @@ mISDNipac_irq(struct ipac_hw *ipac, int maxloop)
 		}
 	} else if (ipac->type & IPAC_TYPE_IPAC) {
 		ista = ReadIPAC(ipac, IPAC_ISTA);
-		while (ista && cnt--) {
+		while (ista && --cnt) {
 			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
 			if (ista & (IPAC__ICD | IPAC__EXD)) {
 				istad = ReadISAC(isac, ISAC_ISTA);
@@ -1200,7 +1200,7 @@ mISDNipac_irq(struct ipac_hw *ipac, int maxloop)
 			ista = ReadIPAC(ipac, IPAC_ISTA);
 		}
 	} else if (ipac->type & IPAC_TYPE_HSCX) {
-		while (cnt) {
+		while (--cnt) {
 			ista = ReadIPAC(ipac, IPAC_ISTAB + ipac->hscx[1].off);
 			pr_debug("%s: B2 ISTA %02x\n", ipac->name, ista);
 			if (ista)
@@ -1211,7 +1211,6 @@ mISDNipac_irq(struct ipac_hw *ipac, int maxloop)
 				mISDNisac_irq(isac, istad);
 			if (0 == (ista | istad))
 				break;
-			cnt--;
 		}
 	}
 	if (cnt > maxloop) /* only for ISAC/HSCX without PCI IRQ test */

commit 3e7a8716e20b759eec0ad88145255bb33174f0c8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 13 17:10:58 2015 +0100

    mISDN: avoid arch specific __builtin_return_address call
    
    Not all architectures are able to call __builtin_return_address().
    On ARM, the mISDN code produces this warning:
    
    hardware/mISDN/w6692.c: In function 'w6692_dctrl':
    hardware/mISDN/w6692.c:1181:75: warning: unsupported argument to '__builtin_return_address'
      pr_debug("%s: %s dev(%d) open from %p\n", card->name, __func__,
                                                                               ^
    hardware/mISDN/mISDNipac.c: In function 'open_dchannel':
    hardware/mISDN/mISDNipac.c:759:75: warning: unsupported argument to '__builtin_return_address'
      pr_debug("%s: %s dev(%d) open from %p\n", isac->name, __func__,
                                                                               ^
    
    In a lot of cases, this is relatively easy to work around by
    passing the value of __builtin_return_address(0) from the
    callers into the functions that want it. One exception is
    the indirect 'open' function call in struct isac_hw. While it
    would be possible to fix this as well, this patch only addresses
    the other callers properly and lets this one return the direct
    parent function, which should be good enough.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index ccd7d851be26..a77eea594b69 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -754,10 +754,10 @@ dbusy_timer_handler(struct isac_hw *isac)
 }
 
 static int
-open_dchannel(struct isac_hw *isac, struct channel_req *rq)
+open_dchannel_caller(struct isac_hw *isac, struct channel_req *rq, void *caller)
 {
 	pr_debug("%s: %s dev(%d) open from %p\n", isac->name, __func__,
-		 isac->dch.dev.id, __builtin_return_address(1));
+		 isac->dch.dev.id, caller);
 	if (rq->protocol != ISDN_P_TE_S0)
 		return -EINVAL;
 	if (rq->adr.channel == 1)
@@ -771,6 +771,12 @@ open_dchannel(struct isac_hw *isac, struct channel_req *rq)
 	return 0;
 }
 
+static int
+open_dchannel(struct isac_hw *isac, struct channel_req *rq)
+{
+	return open_dchannel_caller(isac, rq, __builtin_return_address(0));
+}
+
 static const char *ISACVer[] =
 {"2086/2186 V1.1", "2085 B1", "2085 B2",
  "2085 V2.3"};
@@ -1548,7 +1554,7 @@ ipac_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)
 	case OPEN_CHANNEL:
 		rq = arg;
 		if (rq->protocol == ISDN_P_TE_S0)
-			err = open_dchannel(isac, rq);
+			err = open_dchannel_caller(isac, rq, __builtin_return_address(0));
 		else
 			err = open_bchannel(ipac, rq);
 		if (err)

commit 4b921eda53366b319602351ff4d7256fafa4bd1b
Author: Karsten Keil <keil@b1-systems.de>
Date:   Thu Sep 13 04:36:20 2012 +0000

    mISDN: Fix wrong usage of flush_work_sync while holding locks
    
    It is a bad idea to hold a spinlock and call flush_work_sync.
    Move the workqueue cleanup outside the spinlock and use cancel_work_sync,
    on closing the channel this seems to be the more correct function.
    Remove the never used and constant return value of mISDN_freebchannel.
    
    Signed-off-by: Karsten Keil <keil@b1-systems.de>
    Cc: <stable@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 752e0825591f..ccd7d851be26 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1406,8 +1406,9 @@ hscx_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)
 	switch (cmd) {
 	case CLOSE_CHANNEL:
 		test_and_clear_bit(FLG_OPEN, &bch->Flags);
+		cancel_work_sync(&bch->workq);
 		spin_lock_irqsave(hx->ip->hwlock, flags);
-		mISDN_freebchannel(bch);
+		mISDN_clear_bchannel(bch);
 		hscx_mode(hx, ISDN_P_NONE);
 		spin_unlock_irqrestore(hx->ip->hwlock, flags);
 		ch->protocol = ISDN_P_NONE;

commit c27b46e7f1cbf3be95a4cf5840c76a7b7d54b26f
Author: Karsten Keil <kkeil@linux-pingi.de>
Date:   Tue May 15 23:51:08 2012 +0000

    mISDN: Implement MISDN_CTRL_RX_OFF for more drivers
    
    MISDN_CTRL_RX_OFF is a meachanism to discard RX data in the driver if
    the data is not needed by the application. It can be used when playing
    mesages, but not recording or with unidirectional protocols.
    
    Signed-off-by: Karsten Keil <kkeil@linux-pingi.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 374a17751ffb..752e0825591f 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -936,6 +936,11 @@ hscx_empty_fifo(struct hscx_hw *hscx, u8 count)
 	int maxlen;
 
 	pr_debug("%s: B%1d %d\n", hscx->ip->name, hscx->bch.nr, count);
+	if (test_bit(FLG_RX_OFF, &hscx->bch.Flags)) {
+		hscx->bch.dropcnt += count;
+		hscx_cmdr(hscx, 0x80); /* RMC */
+		return;
+	}
 	maxlen = bchannel_get_rxbuf(&hscx->bch, count);
 	if (maxlen < 0) {
 		hscx_cmdr(hscx, 0x80); /* RMC */

commit 6d1ee48fd0d8d2586aaeda24dacffc426c2be44a
Author: Karsten Keil <kkeil@linux-pingi.de>
Date:   Tue May 15 23:51:07 2012 +0000

    mISDN: Implement MISDN_CTRL_FILL_EMPTY for more drivers
    
    MISDN_CTRL_FILL_EMPTY is a meachanism to send a fixed value (normally silence)
    as long no data from upper layers is available. It can be used when recording
    voice messages or with unidirectional protocols.
    
    Signed-off-by: Karsten Keil <kkeil@linux-pingi.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 3e71a5ef4bbc..374a17751ffb 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -969,22 +969,28 @@ hscx_fill_fifo(struct hscx_hw *hscx)
 	int count, more;
 	u8 *p;
 
-	if (!hscx->bch.tx_skb)
-		return;
-	count = hscx->bch.tx_skb->len - hscx->bch.tx_idx;
-	if (count <= 0)
-		return;
-	p = hscx->bch.tx_skb->data + hscx->bch.tx_idx;
-
-	more = test_bit(FLG_TRANSPARENT, &hscx->bch.Flags) ? 1 : 0;
-	if (count > hscx->fifo_size) {
+	if (!hscx->bch.tx_skb) {
+		if (!test_bit(FLG_TX_EMPTY, &hscx->bch.Flags))
+			return;
 		count = hscx->fifo_size;
 		more = 1;
-	}
-	pr_debug("%s: B%1d %d/%d/%d\n", hscx->ip->name, hscx->bch.nr, count,
-		 hscx->bch.tx_idx, hscx->bch.tx_skb->len);
-	hscx->bch.tx_idx += count;
+		p = hscx->log;
+		memset(p, hscx->bch.fill[0], count);
+	} else {
+		count = hscx->bch.tx_skb->len - hscx->bch.tx_idx;
+		if (count <= 0)
+			return;
+		p = hscx->bch.tx_skb->data + hscx->bch.tx_idx;
 
+		more = test_bit(FLG_TRANSPARENT, &hscx->bch.Flags) ? 1 : 0;
+		if (count > hscx->fifo_size) {
+			count = hscx->fifo_size;
+			more = 1;
+		}
+		pr_debug("%s: B%1d %d/%d/%d\n", hscx->ip->name, hscx->bch.nr,
+			 count, hscx->bch.tx_idx, hscx->bch.tx_skb->len);
+		hscx->bch.tx_idx += count;
+	}
 	if (hscx->ip->type & IPAC_TYPE_IPACX)
 		hscx->ip->write_fifo(hscx->ip->hw,
 				     hscx->off + IPACX_XFIFOB, p, count);
@@ -995,7 +1001,7 @@ hscx_fill_fifo(struct hscx_hw *hscx)
 	}
 	hscx_cmdr(hscx, more ? 0x08 : 0x0a);
 
-	if (hscx->bch.debug & DEBUG_HW_BFIFO) {
+	if (hscx->bch.tx_skb && (hscx->bch.debug & DEBUG_HW_BFIFO)) {
 		snprintf(hscx->log, 64, "B%1d-send %s %d ",
 			 hscx->bch.nr, hscx->ip->name, count);
 		print_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);
@@ -1010,8 +1016,12 @@ hscx_xpr(struct hscx_hw *hx)
 	} else {
 		if (hx->bch.tx_skb)
 			dev_kfree_skb(hx->bch.tx_skb);
-		if (get_next_bframe(&hx->bch))
+		if (get_next_bframe(&hx->bch)) {
 			hscx_fill_fifo(hx);
+			test_and_clear_bit(FLG_TX_EMPTY, &hx->bch.Flags);
+		} else if (test_bit(FLG_TX_EMPTY, &hx->bch.Flags)) {
+			hscx_fill_fifo(hx);
+		}
 	}
 }
 
@@ -1128,7 +1138,9 @@ ipac_irq(struct hscx_hw *hx, u8 ista)
 
 	if (istab & IPACX_B_XDU) {
 		if (test_bit(FLG_TRANSPARENT, &hx->bch.Flags)) {
-			hscx_fill_fifo(hx);
+			if (test_bit(FLG_FILLEMPTY, &hx->bch.Flags))
+				test_and_set_bit(FLG_TX_EMPTY, &hx->bch.Flags);
+			hscx_xpr(hx);
 			return;
 		}
 		pr_debug("%s: B%1d XDU error at len %d\n", hx->ip->name,

commit 034005a0119b9c2aabe0ac3953eb9a65ca937a69
Author: Karsten Keil <kkeil@linux-pingi.de>
Date:   Tue May 15 23:51:06 2012 +0000

    mISDN: Allow to set a minimum length for transparent data
    
    If the FIFO of the card is small, many short messages are queued up to
    the upper layers and the userspace. This change allows the applications
    to set a minimum datalen they want from the drivers.
    Create a common control function to avoid code duplication in each
    driver.
    
    Signed-off-by: Karsten Keil <kkeil@linux-pingi.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 7d109ed35366..3e71a5ef4bbc 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1063,7 +1063,7 @@ ipac_rme(struct hscx_hw *hx)
 		skb_trim(hx->bch.rx_skb, 0);
 	} else {
 		skb_trim(hx->bch.rx_skb, hx->bch.rx_skb->len - 1);
-		recv_Bchannel(&hx->bch, 0);
+		recv_Bchannel(&hx->bch, 0, false);
 	}
 }
 
@@ -1114,11 +1114,8 @@ ipac_irq(struct hscx_hw *hx, u8 ista)
 
 	if (istab & IPACX_B_RPF) {
 		hscx_empty_fifo(hx, hx->fifo_size);
-		if (test_bit(FLG_TRANSPARENT, &hx->bch.Flags)) {
-			/* receive transparent audio data */
-			if (hx->bch.rx_skb)
-				recv_Bchannel(&hx->bch, 0);
-		}
+		if (test_bit(FLG_TRANSPARENT, &hx->bch.Flags))
+			recv_Bchannel(&hx->bch, 0, false);
 	}
 
 	if (istab & IPACX_B_RFO) {
@@ -1377,20 +1374,7 @@ hscx_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)
 static int
 channel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)
 {
-	int	ret = 0;
-
-	switch (cq->op) {
-	case MISDN_CTRL_GETOP:
-		cq->op = 0;
-		break;
-		/* Nothing implemented yet */
-	case MISDN_CTRL_FILL_EMPTY:
-	default:
-		pr_info("%s: unknown Op %x\n", __func__, cq->op);
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
+	return mISDN_ctrl_bchannel(bch, cq);
 }
 
 static int
@@ -1608,7 +1592,8 @@ mISDNipac_init(struct ipac_hw *ipac, void *hw)
 		set_channelmap(i + 1, ipac->isac.dch.dev.channelmap);
 		list_add(&ipac->hscx[i].bch.ch.list,
 			 &ipac->isac.dch.dev.bchannels);
-		mISDN_initbchannel(&ipac->hscx[i].bch, MAX_DATA_MEM);
+		mISDN_initbchannel(&ipac->hscx[i].bch, MAX_DATA_MEM,
+				   ipac->hscx[i].fifo_size);
 		ipac->hscx[i].bch.ch.nr = i + 1;
 		ipac->hscx[i].bch.ch.send = &hscx_l2l1;
 		ipac->hscx[i].bch.ch.ctrl = hscx_bctrl;

commit 7206e659f689558b41aa058c3040b081cb281d03
Author: Karsten Keil <kkeil@linux-pingi.de>
Date:   Tue May 15 23:51:05 2012 +0000

    mISDN: Reduce RX buffer allocation for transparent data
    
    We did allways allocate maxsize buffers, but for transparent data we know
    the actual size.
    Use a common function to calculate size and detect overflows.
    
    Signed-off-by: Karsten Keil <kkeil@linux-pingi.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index e4b6d8d51aae..7d109ed35366 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -933,22 +933,16 @@ static void
 hscx_empty_fifo(struct hscx_hw *hscx, u8 count)
 {
 	u8 *p;
+	int maxlen;
 
 	pr_debug("%s: B%1d %d\n", hscx->ip->name, hscx->bch.nr, count);
-	if (!hscx->bch.rx_skb) {
-		hscx->bch.rx_skb = mI_alloc_skb(hscx->bch.maxlen, GFP_ATOMIC);
-		if (!hscx->bch.rx_skb) {
-			pr_info("%s: B receive out of memory\n",
-				hscx->ip->name);
-			hscx_cmdr(hscx, 0x80); /* RMC */
-			return;
-		}
-	}
-	if ((hscx->bch.rx_skb->len + count) > hscx->bch.maxlen) {
-		pr_debug("%s: overrun %d\n", hscx->ip->name,
-			 hscx->bch.rx_skb->len + count);
-		skb_trim(hscx->bch.rx_skb, 0);
+	maxlen = bchannel_get_rxbuf(&hscx->bch, count);
+	if (maxlen < 0) {
 		hscx_cmdr(hscx, 0x80); /* RMC */
+		if (hscx->bch.rx_skb)
+			skb_trim(hscx->bch.rx_skb, 0);
+		pr_warning("%s.B%d: No bufferspace for %d bytes\n",
+			   hscx->ip->name, hscx->bch.nr, count);
 		return;
 	}
 	p = skb_put(hscx->bch.rx_skb, count);

commit 8bfddfbe2100862fd39b97001d0559ccd4c77f19
Author: Karsten Keil <kkeil@linux-pingi.de>
Date:   Tue May 15 23:51:02 2012 +0000

    mISDN: Early confirm for transparent data
    
    It is better to send a confirm for transparent data early as possible
    to avoid TX underuns.
    
    Signed-off-by: Karsten Keil <kkeil@linux-pingi.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 6c044d55536b..e4b6d8d51aae 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1011,15 +1011,11 @@ hscx_fill_fifo(struct hscx_hw *hscx)
 static void
 hscx_xpr(struct hscx_hw *hx)
 {
-	if (hx->bch.tx_skb && hx->bch.tx_idx < hx->bch.tx_skb->len)
+	if (hx->bch.tx_skb && hx->bch.tx_idx < hx->bch.tx_skb->len) {
 		hscx_fill_fifo(hx);
-	else {
-		if (hx->bch.tx_skb) {
-			/* send confirm, on trans, free on hdlc. */
-			if (test_bit(FLG_TRANSPARENT, &hx->bch.Flags))
-				confirm_Bsend(&hx->bch);
+	} else {
+		if (hx->bch.tx_skb)
 			dev_kfree_skb(hx->bch.tx_skb);
-		}
 		if (get_next_bframe(&hx->bch))
 			hscx_fill_fifo(hx);
 	}
@@ -1342,22 +1338,17 @@ hscx_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)
 	struct hscx_hw	*hx = container_of(bch, struct hscx_hw, bch);
 	int ret = -EINVAL;
 	struct mISDNhead *hh = mISDN_HEAD_P(skb);
-	u32 id;
-	u_long flags;
+	unsigned long flags;
 
 	switch (hh->prim) {
 	case PH_DATA_REQ:
 		spin_lock_irqsave(hx->ip->hwlock, flags);
 		ret = bchannel_senddata(bch, skb);
 		if (ret > 0) { /* direct TX */
-			id = hh->id; /* skb can be freed */
 			ret = 0;
 			hscx_fill_fifo(hx);
-			spin_unlock_irqrestore(hx->ip->hwlock, flags);
-			if (!test_bit(FLG_TRANSPARENT, &bch->Flags))
-				queue_ch_frame(ch, PH_DATA_CNF, id, NULL);
-		} else
-			spin_unlock_irqrestore(hx->ip->hwlock, flags);
+		}
+		spin_unlock_irqrestore(hx->ip->hwlock, flags);
 		return ret;
 	case PH_ACTIVATE_REQ:
 		spin_lock_irqsave(hx->ip->hwlock, flags);

commit 1368112c07bae879fa3d1c21f236ca8eea3e5e84
Author: Karsten Keil <kkeil@linux-pingi.de>
Date:   Tue May 15 23:51:01 2012 +0000

    mISDN: Cleanup channel also if it already was deactivated
    
    If a channel was closed after it was deactivated it could happen that
    something was not proper resetted. The test if a channel is still activ
    was wrong, so remove it and always do the cleanup.
    
    Signed-off-by: Karsten Keil <kkeil@linux-pingi.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 92d4a78bc0a5..6c044d55536b 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1420,15 +1420,10 @@ hscx_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)
 	switch (cmd) {
 	case CLOSE_CHANNEL:
 		test_and_clear_bit(FLG_OPEN, &bch->Flags);
-		if (test_bit(FLG_ACTIVE, &bch->Flags)) {
-			spin_lock_irqsave(hx->ip->hwlock, flags);
-			mISDN_freebchannel(bch);
-			hscx_mode(hx, ISDN_P_NONE);
-			spin_unlock_irqrestore(hx->ip->hwlock, flags);
-		} else {
-			skb_queue_purge(&bch->rqueue);
-			bch->rcount = 0;
-		}
+		spin_lock_irqsave(hx->ip->hwlock, flags);
+		mISDN_freebchannel(bch);
+		hscx_mode(hx, ISDN_P_NONE);
+		spin_unlock_irqrestore(hx->ip->hwlock, flags);
 		ch->protocol = ISDN_P_NONE;
 		ch->peer = NULL;
 		module_put(hx->ip->owner);

commit c626c127279b265ab293348763e043864d58d42c
Author: Karsten Keil <isdn@linux-pingi.de>
Date:   Fri May 4 04:15:33 2012 +0000

    mISDN: Make layer1 timer 3 value configurable
    
    For certification test it is very useful to change the layer1
    timer3 value on runtime.
    
    Signed-off-by: Karsten Keil <kkeil@linux-pingi.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 884369f09cad..92d4a78bc0a5 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -603,10 +603,11 @@ isac_l1hw(struct mISDNchannel *ch, struct sk_buff *skb)
 }
 
 static int
-isac_ctrl(struct isac_hw *isac, u32 cmd, u_long para)
+isac_ctrl(struct isac_hw *isac, u32 cmd, unsigned long para)
 {
 	u8 tl = 0;
-	u_long flags;
+	unsigned long flags;
+	int ret = 0;
 
 	switch (cmd) {
 	case HW_TESTLOOP:
@@ -626,12 +627,15 @@ isac_ctrl(struct isac_hw *isac, u32 cmd, u_long para)
 		}
 		spin_unlock_irqrestore(isac->hwlock, flags);
 		break;
+	case HW_TIMER3_VALUE:
+		ret = l1_event(isac->dch.l1, HW_TIMER3_VALUE | (para & 0xff));
+		break;
 	default:
 		pr_debug("%s: %s unknown command %x %lx\n", isac->name,
 			 __func__, cmd, para);
-		return -1;
+		ret = -1;
 	}
-	return 0;
+	return ret;
 }
 
 static int
@@ -1526,7 +1530,7 @@ channel_ctrl(struct ipac_hw *ipac, struct mISDN_ctrl_req *cq)
 
 	switch (cq->op) {
 	case MISDN_CTRL_GETOP:
-		cq->op = MISDN_CTRL_LOOP;
+		cq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;
 		break;
 	case MISDN_CTRL_LOOP:
 		/* cq->channel: 0 disable, 1 B1 loop 2 B2 loop, 3 both */
@@ -1536,6 +1540,9 @@ channel_ctrl(struct ipac_hw *ipac, struct mISDN_ctrl_req *cq)
 		}
 		ret = ipac->ctrl(ipac, HW_TESTLOOP, cq->channel);
 		break;
+	case MISDN_CTRL_L1_TIMER3:
+		ret = ipac->isac.ctrl(&ipac->isac, HW_TIMER3_VALUE, cq->p1);
+		break;
 	default:
 		pr_info("%s: unknown CTRL OP %x\n", ipac->name, cq->op);
 		ret = -EINVAL;

commit 819a100846295461bc0f1bfcb8e5ab11c1bc4cdb
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Mar 26 21:20:48 2012 +0000

    mISDN: array underflow in open_bchannel()
    
    There are two channels here.  User space starts counting channels at one
    but in the kernel we start at zero.  If the user passes in a zero
    channel that's invalid and could lead to memory corruption.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index b47e9bed2185..884369f09cad 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -1506,7 +1506,7 @@ open_bchannel(struct ipac_hw *ipac, struct channel_req *rq)
 {
 	struct bchannel		*bch;
 
-	if (rq->adr.channel > 2)
+	if (rq->adr.channel == 0 || rq->adr.channel > 2)
 		return -EINVAL;
 	if (rq->protocol == ISDN_P_NONE)
 		return -EINVAL;

commit 475be4d85a274d0961593db41cf85689db1d583c
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 19 19:52:38 2012 -0800

    isdn: whitespace coding style cleanup
    
    isdn source code uses a not-current coding style.
    
    Update the coding style used on a per-line basis
    so that git diff -w shows only elided blank lines
    at EOF.
    
    Done with emacs and some scripts and some typing.
    
    Built x86 allyesconfig.
    No detected change in objdump -d or size.
    
    Signed-off-by: Joe Perches <joe@perches.com>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index d2ffb1d9b831..b47e9bed2185 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -129,7 +129,7 @@ isac_empty_fifo(struct isac_hw *isac, int count)
 	}
 	if ((isac->dch.rx_skb->len + count) >= isac->dch.maxlen) {
 		pr_debug("%s: %s overrun %d\n", isac->name, __func__,
-			    isac->dch.rx_skb->len + count);
+			 isac->dch.rx_skb->len + count);
 		WriteISAC(isac, ISAC_CMDR, 0x80);
 		return;
 	}
@@ -140,7 +140,7 @@ isac_empty_fifo(struct isac_hw *isac, int count)
 		char	pfx[MISDN_MAX_IDLEN + 16];
 
 		snprintf(pfx, MISDN_MAX_IDLEN + 15, "D-recv %s %d ",
-			isac->name, count);
+			 isac->name, count);
 		print_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);
 	}
 }
@@ -178,7 +178,7 @@ isac_fill_fifo(struct isac_hw *isac)
 		char	pfx[MISDN_MAX_IDLEN + 16];
 
 		snprintf(pfx, MISDN_MAX_IDLEN + 15, "D-send %s %d ",
-			isac->name, count);
+			 isac->name, count);
 		print_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);
 	}
 }
@@ -283,7 +283,7 @@ isac_mos_irq(struct isac_hw *isac)
 		}
 		isac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR0);
 		pr_debug("%s: ISAC MOR0 %02x\n", isac->name,
-			isac->mon_rx[isac->mon_rxp - 1]);
+			 isac->mon_rx[isac->mon_rxp - 1]);
 		if (isac->mon_rxp == 1) {
 			isac->mocr |= 0x04;
 			WriteISAC(isac, ISAC_MOCR, isac->mocr);
@@ -313,7 +313,7 @@ isac_mos_irq(struct isac_hw *isac)
 		}
 		isac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR1);
 		pr_debug("%s: ISAC MOR1 %02x\n", isac->name,
-			isac->mon_rx[isac->mon_rxp - 1]);
+			 isac->mon_rx[isac->mon_rxp - 1]);
 		isac->mocr |= 0x40;
 		WriteISAC(isac, ISAC_MOCR, isac->mocr);
 	}
@@ -325,7 +325,7 @@ isac_mos_irq(struct isac_hw *isac)
 		WriteISAC(isac, ISAC_MOCR, isac->mocr);
 		if (isac->monitor) {
 			ret = isac->monitor(isac->dch.hw, MONITOR_RX_0,
-				isac->mon_rx, isac->mon_rxp);
+					    isac->mon_rx, isac->mon_rxp);
 			if (ret)
 				kfree(isac->mon_rx);
 		} else {
@@ -343,7 +343,7 @@ isac_mos_irq(struct isac_hw *isac)
 		WriteISAC(isac, ISAC_MOCR, isac->mocr);
 		if (isac->monitor) {
 			ret = isac->monitor(isac->dch.hw, MONITOR_RX_1,
-				isac->mon_rx, isac->mon_rxp);
+					    isac->mon_rx, isac->mon_rxp);
 			if (ret)
 				kfree(isac->mon_rx);
 		} else {
@@ -356,7 +356,7 @@ isac_mos_irq(struct isac_hw *isac)
 	}
 	if (val & 0x02) {
 		if ((!isac->mon_tx) || (isac->mon_txc &&
-			(isac->mon_txp >= isac->mon_txc) && !(val & 0x08))) {
+					(isac->mon_txp >= isac->mon_txc) && !(val & 0x08))) {
 			isac->mocr &= 0xf0;
 			WriteISAC(isac, ISAC_MOCR, isac->mocr);
 			isac->mocr |= 0x0a;
@@ -364,7 +364,7 @@ isac_mos_irq(struct isac_hw *isac)
 			if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 				if (isac->monitor)
 					ret = isac->monitor(isac->dch.hw,
-						MONITOR_TX_0, NULL, 0);
+							    MONITOR_TX_0, NULL, 0);
 			}
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
@@ -375,7 +375,7 @@ isac_mos_irq(struct isac_hw *isac)
 		if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 			if (isac->monitor)
 				ret = isac->monitor(isac->dch.hw,
-					MONITOR_TX_0, NULL, 0);
+						    MONITOR_TX_0, NULL, 0);
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
 			isac->mon_txc = 0;
@@ -384,12 +384,12 @@ isac_mos_irq(struct isac_hw *isac)
 		}
 		WriteISAC(isac, ISAC_MOX0, isac->mon_tx[isac->mon_txp++]);
 		pr_debug("%s: ISAC %02x -> MOX0\n", isac->name,
-			isac->mon_tx[isac->mon_txp - 1]);
+			 isac->mon_tx[isac->mon_txp - 1]);
 	}
 AfterMOX0:
 	if (val & 0x20) {
 		if ((!isac->mon_tx) || (isac->mon_txc &&
-			(isac->mon_txp >= isac->mon_txc) && !(val & 0x80))) {
+					(isac->mon_txp >= isac->mon_txc) && !(val & 0x80))) {
 			isac->mocr &= 0x0f;
 			WriteISAC(isac, ISAC_MOCR, isac->mocr);
 			isac->mocr |= 0xa0;
@@ -397,7 +397,7 @@ isac_mos_irq(struct isac_hw *isac)
 			if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 				if (isac->monitor)
 					ret = isac->monitor(isac->dch.hw,
-						MONITOR_TX_1, NULL, 0);
+							    MONITOR_TX_1, NULL, 0);
 			}
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
@@ -408,7 +408,7 @@ isac_mos_irq(struct isac_hw *isac)
 		if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
 			if (isac->monitor)
 				ret = isac->monitor(isac->dch.hw,
-					MONITOR_TX_1, NULL, 0);
+						    MONITOR_TX_1, NULL, 0);
 			kfree(isac->mon_tx);
 			isac->mon_tx = NULL;
 			isac->mon_txc = 0;
@@ -417,7 +417,7 @@ isac_mos_irq(struct isac_hw *isac)
 		}
 		WriteISAC(isac, ISAC_MOX1, isac->mon_tx[isac->mon_txp++]);
 		pr_debug("%s: ISAC %02x -> MOX1\n", isac->name,
-			isac->mon_tx[isac->mon_txp - 1]);
+			 isac->mon_tx[isac->mon_txp - 1]);
 	}
 AfterMOX1:
 	val = 0; /* dummy to avoid warning */
@@ -432,7 +432,7 @@ isac_cisq_irq(struct isac_hw *isac) {
 	pr_debug("%s: ISAC CIR0 %02X\n", isac->name, val);
 	if (val & 2) {
 		pr_debug("%s: ph_state change %x->%x\n", isac->name,
-			isac->state, (val >> 2) & 0xf);
+			 isac->state, (val >> 2) & 0xf);
 		isac->state = (val >> 2) & 0xf;
 		isac_ph_state_change(isac);
 	}
@@ -451,7 +451,7 @@ isacsx_cic_irq(struct isac_hw *isac)
 	pr_debug("%s: ISACX CIR0 %02X\n", isac->name, val);
 	if (val & ISACX_CIR0_CIC0) {
 		pr_debug("%s: ph_state change %x->%x\n", isac->name,
-			isac->state, val >> 4);
+			 isac->state, val >> 4);
 		isac->state = val >> 4;
 		isac_ph_state_change(isac);
 	}
@@ -488,7 +488,7 @@ isacsx_rme_irq(struct isac_hw *isac)
 		if (isac->dch.rx_skb) {
 			skb_trim(isac->dch.rx_skb, isac->dch.rx_skb->len - 1);
 			pr_debug("%s: dchannel received %d\n", isac->name,
-				isac->dch.rx_skb->len);
+				 isac->dch.rx_skb->len);
 			recv_Dchannel(&isac->dch);
 		}
 	}
@@ -628,7 +628,7 @@ isac_ctrl(struct isac_hw *isac, u32 cmd, u_long para)
 		break;
 	default:
 		pr_debug("%s: %s unknown command %x %lx\n", isac->name,
-			__func__, cmd, para);
+			 __func__, cmd, para);
 		return -1;
 	}
 	return 0;
@@ -685,16 +685,16 @@ isac_l1cmd(struct dchannel *dch, u32 cmd)
 	case PH_ACTIVATE_IND:
 		test_and_set_bit(FLG_ACTIVE, &dch->Flags);
 		_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,
-			GFP_ATOMIC);
+			    GFP_ATOMIC);
 		break;
 	case PH_DEACTIVATE_IND:
 		test_and_clear_bit(FLG_ACTIVE, &dch->Flags);
 		_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,
-			GFP_ATOMIC);
+			    GFP_ATOMIC);
 		break;
 	default:
 		pr_debug("%s: %s unknown command %x\n", isac->name,
-			__func__, cmd);
+			 __func__, cmd);
 		return -1;
 	}
 	return 0;
@@ -731,7 +731,7 @@ dbusy_timer_handler(struct isac_hw *isac)
 		rbch = ReadISAC(isac, ISAC_RBCH);
 		star = ReadISAC(isac, ISAC_STAR);
 		pr_debug("%s: D-Channel Busy RBCH %02x STAR %02x\n",
-			isac->name, rbch, star);
+			 isac->name, rbch, star);
 		if (rbch & ISAC_RBCH_XAC) /* D-Channel Busy */
 			test_and_set_bit(FLG_L1_BUSY, &isac->dch.Flags);
 		else {
@@ -753,7 +753,7 @@ static int
 open_dchannel(struct isac_hw *isac, struct channel_req *rq)
 {
 	pr_debug("%s: %s dev(%d) open from %p\n", isac->name, __func__,
-		isac->dch.dev.id, __builtin_return_address(1));
+		 isac->dch.dev.id, __builtin_return_address(1));
 	if (rq->protocol != ISDN_P_TE_S0)
 		return -EINVAL;
 	if (rq->adr.channel == 1)
@@ -763,7 +763,7 @@ open_dchannel(struct isac_hw *isac, struct channel_req *rq)
 	rq->ch->protocol = rq->protocol;
 	if (isac->dch.state == 7)
 		_queue_data(rq->ch, PH_ACTIVATE_IND, MISDN_ID_ANY,
-		    0, NULL, GFP_KERNEL);
+			    0, NULL, GFP_KERNEL);
 	return 0;
 }
 
@@ -807,7 +807,7 @@ isac_init(struct isac_hw *isac)
 		val = ReadISAC(isac, ISACX_ID);
 		if (isac->dch.debug & DEBUG_HW)
 			pr_notice("%s: ISACX Design ID %x\n",
-				isac->name, val & 0x3f);
+				  isac->name, val & 0x3f);
 		val = ReadISAC(isac, ISACX_CIR0);
 		pr_debug("%s: ISACX CIR0 %02X\n", isac->name, val);
 		isac->state = val >> 4;
@@ -832,7 +832,7 @@ isac_init(struct isac_hw *isac)
 		val = ReadISAC(isac, ISAC_RBCH);
 		if (isac->dch.debug & DEBUG_HW)
 			pr_notice("%s: ISAC version (%x): %s\n", isac->name,
-				val, ISACVer[(val >> 5) & 3]);
+				  val, ISACVer[(val >> 5) & 3]);
 		isac->type |= ((val >> 5) & 3);
 		if (!isac->adf2)
 			isac->adf2 = 0x80;
@@ -889,7 +889,7 @@ waitforCEC(struct hscx_hw *hx)
 	}
 	if (to < 50)
 		pr_debug("%s: B%1d CEC %d us\n", hx->ip->name, hx->bch.nr,
-			50 - to);
+			 50 - to);
 	if (!to)
 		pr_info("%s: B%1d CEC timeout\n", hx->ip->name, hx->bch.nr);
 }
@@ -909,7 +909,7 @@ waitforXFW(struct hscx_hw *hx)
 	}
 	if (to < 50)
 		pr_debug("%s: B%1d XFW %d us\n", hx->ip->name, hx->bch.nr,
-			50 - to);
+			 50 - to);
 	if (!to)
 		pr_info("%s: B%1d XFW timeout\n", hx->ip->name, hx->bch.nr);
 }
@@ -942,7 +942,7 @@ hscx_empty_fifo(struct hscx_hw *hscx, u8 count)
 	}
 	if ((hscx->bch.rx_skb->len + count) > hscx->bch.maxlen) {
 		pr_debug("%s: overrun %d\n", hscx->ip->name,
-			hscx->bch.rx_skb->len + count);
+			 hscx->bch.rx_skb->len + count);
 		skb_trim(hscx->bch.rx_skb, 0);
 		hscx_cmdr(hscx, 0x80); /* RMC */
 		return;
@@ -951,16 +951,16 @@ hscx_empty_fifo(struct hscx_hw *hscx, u8 count)
 
 	if (hscx->ip->type & IPAC_TYPE_IPACX)
 		hscx->ip->read_fifo(hscx->ip->hw,
-			hscx->off + IPACX_RFIFOB, p, count);
+				    hscx->off + IPACX_RFIFOB, p, count);
 	else
 		hscx->ip->read_fifo(hscx->ip->hw,
-			hscx->off, p, count);
+				    hscx->off, p, count);
 
 	hscx_cmdr(hscx, 0x80); /* RMC */
 
 	if (hscx->bch.debug & DEBUG_HW_BFIFO) {
 		snprintf(hscx->log, 64, "B%1d-recv %s %d ",
-			hscx->bch.nr, hscx->ip->name, count);
+			 hscx->bch.nr, hscx->ip->name, count);
 		print_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);
 	}
 }
@@ -984,22 +984,22 @@ hscx_fill_fifo(struct hscx_hw *hscx)
 		more = 1;
 	}
 	pr_debug("%s: B%1d %d/%d/%d\n", hscx->ip->name, hscx->bch.nr, count,
-		hscx->bch.tx_idx, hscx->bch.tx_skb->len);
+		 hscx->bch.tx_idx, hscx->bch.tx_skb->len);
 	hscx->bch.tx_idx += count;
 
 	if (hscx->ip->type & IPAC_TYPE_IPACX)
 		hscx->ip->write_fifo(hscx->ip->hw,
-			hscx->off + IPACX_XFIFOB, p, count);
+				     hscx->off + IPACX_XFIFOB, p, count);
 	else {
 		waitforXFW(hscx);
 		hscx->ip->write_fifo(hscx->ip->hw,
-			hscx->off, p, count);
+				     hscx->off, p, count);
 	}
 	hscx_cmdr(hscx, more ? 0x08 : 0x0a);
 
 	if (hscx->bch.debug & DEBUG_HW_BFIFO) {
 		snprintf(hscx->log, 64, "B%1d-send %s %d ",
-			hscx->bch.nr, hscx->ip->name, count);
+			 hscx->bch.nr, hscx->ip->name, count);
 		print_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);
 	}
 }
@@ -1037,18 +1037,18 @@ ipac_rme(struct hscx_hw *hx)
 		if (!(rstab & 0x80)) {
 			if (hx->bch.debug & DEBUG_HW_BCHANNEL)
 				pr_notice("%s: B%1d invalid frame\n",
-					hx->ip->name, hx->bch.nr);
+					  hx->ip->name, hx->bch.nr);
 		}
 		if (rstab & 0x40) {
 			if (hx->bch.debug & DEBUG_HW_BCHANNEL)
 				pr_notice("%s: B%1d RDO proto=%x\n",
-					hx->ip->name, hx->bch.nr,
-					hx->bch.state);
+					  hx->ip->name, hx->bch.nr,
+					  hx->bch.state);
 		}
 		if (!(rstab & 0x20)) {
 			if (hx->bch.debug & DEBUG_HW_BCHANNEL)
 				pr_notice("%s: B%1d CRC error\n",
-					hx->ip->name, hx->bch.nr);
+					  hx->ip->name, hx->bch.nr);
 		}
 		hscx_cmdr(hx, 0x80); /* Do RMC */
 		return;
@@ -1065,7 +1065,7 @@ ipac_rme(struct hscx_hw *hx)
 		return;
 	if (hx->bch.rx_skb->len < 2) {
 		pr_debug("%s: B%1d frame to short %d\n",
-			hx->ip->name, hx->bch.nr, hx->bch.rx_skb->len);
+			 hx->ip->name, hx->bch.nr, hx->bch.rx_skb->len);
 		skb_trim(hx->bch.rx_skb, 0);
 	} else {
 		skb_trim(hx->bch.rx_skb, hx->bch.rx_skb->len - 1);
@@ -1086,7 +1086,7 @@ ipac_irq(struct hscx_hw *hx, u8 ista)
 		if (m & ista) {
 			exirb = ReadHSCX(hx, IPAC_EXIRB);
 			pr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,
-				hx->bch.nr, exirb);
+				 hx->bch.nr, exirb);
 		}
 	} else if (hx->bch.nr & 2) { /* HSCX B */
 		if (ista & (HSCX__EXA | HSCX__ICA))
@@ -1094,7 +1094,7 @@ ipac_irq(struct hscx_hw *hx, u8 ista)
 		if (ista & HSCX__EXB) {
 			exirb = ReadHSCX(hx, IPAC_EXIRB);
 			pr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,
-				hx->bch.nr, exirb);
+				 hx->bch.nr, exirb);
 		}
 		istab = ista & 0xF8;
 	} else { /* HSCX A */
@@ -1102,7 +1102,7 @@ ipac_irq(struct hscx_hw *hx, u8 ista)
 		if (ista & HSCX__EXA) {
 			exirb = ReadHSCX(hx, IPAC_EXIRB);
 			pr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,
-				hx->bch.nr, exirb);
+				 hx->bch.nr, exirb);
 		}
 		istab = istab & 0xF8;
 	}
@@ -1141,7 +1141,7 @@ ipac_irq(struct hscx_hw *hx, u8 ista)
 			return;
 		}
 		pr_debug("%s: B%1d XDU error at len %d\n", hx->ip->name,
-			hx->bch.nr, hx->bch.tx_idx);
+			 hx->bch.nr, hx->bch.tx_idx);
 		hx->bch.tx_idx = 0;
 		hscx_cmdr(hx, 0x01);	/* XRES */
 	}
@@ -1204,10 +1204,10 @@ mISDNipac_irq(struct ipac_hw *ipac, int maxloop)
 		return IRQ_NONE;
 	if (cnt < maxloop)
 		pr_debug("%s: %d irqloops cpu%d\n", ipac->name,
-			maxloop - cnt, smp_processor_id());
+			 maxloop - cnt, smp_processor_id());
 	if (maxloop && !cnt)
 		pr_notice("%s: %d IRQ LOOP cpu%d\n", ipac->name,
-			maxloop, smp_processor_id());
+			  maxloop, smp_processor_id());
 	return IRQ_HANDLED;
 }
 EXPORT_SYMBOL(mISDNipac_irq);
@@ -1216,7 +1216,7 @@ static int
 hscx_mode(struct hscx_hw *hscx, u32 bprotocol)
 {
 	pr_debug("%s: HSCX %c protocol %x-->%x ch %d\n", hscx->ip->name,
-		'@' + hscx->bch.nr, hscx->bch.state, bprotocol, hscx->bch.nr);
+		 '@' + hscx->bch.nr, hscx->bch.state, bprotocol, hscx->bch.nr);
 	if (hscx->ip->type & IPAC_TYPE_IPACX) {
 		if (hscx->bch.nr & 1) { /* B1 and ICA */
 			WriteIPAC(hscx->ip, ISACX_BCHA_TSDP_BC1, 0x80);
@@ -1364,7 +1364,7 @@ hscx_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)
 		spin_unlock_irqrestore(hx->ip->hwlock, flags);
 		if (!ret)
 			_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,
-				NULL, GFP_KERNEL);
+				    NULL, GFP_KERNEL);
 		break;
 	case PH_DEACTIVATE_REQ:
 		spin_lock_irqsave(hx->ip->hwlock, flags);
@@ -1372,7 +1372,7 @@ hscx_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)
 		hscx_mode(hx, ISDN_P_NONE);
 		spin_unlock_irqrestore(hx->ip->hwlock, flags);
 		_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,
-			NULL, GFP_KERNEL);
+			    NULL, GFP_KERNEL);
 		ret = 0;
 		break;
 	default:
@@ -1394,7 +1394,7 @@ channel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)
 	case MISDN_CTRL_GETOP:
 		cq->op = 0;
 		break;
-	/* Nothing implemented yet */
+		/* Nothing implemented yet */
 	case MISDN_CTRL_FILL_EMPTY:
 	default:
 		pr_info("%s: unknown Op %x\n", __func__, cq->op);
@@ -1467,7 +1467,7 @@ hscx_init(struct hscx_hw *hx)
 		pr_debug("%s: HSCX VSTR %02x\n", hx->ip->name, val);
 		if (hx->bch.debug & DEBUG_HW)
 			pr_notice("%s: HSCX version %s\n", hx->ip->name,
-				HSCXVer[val & 0x0f]);
+				  HSCXVer[val & 0x0f]);
 	} else
 		WriteHSCX(hx, IPAC_CCR1, 0x82);
 	WriteHSCX(hx, IPAC_CCR2, 0x30);
@@ -1491,7 +1491,7 @@ ipac_init(struct ipac_hw *ipac)
 		val = ReadIPAC(ipac, IPAC_CONF);
 		/* conf is default 0, but can be overwritten by card setup */
 		pr_debug("%s: IPAC CONF %02x/%02x\n", ipac->name,
-			val, ipac->conf);
+			 val, ipac->conf);
 		WriteIPAC(ipac, IPAC_CONF, ipac->conf);
 		val = ReadIPAC(ipac, IPAC_ID);
 		if (ipac->hscx[0].bch.debug & DEBUG_HW)
@@ -1569,7 +1569,7 @@ ipac_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)
 		break;
 	case CLOSE_CHANNEL:
 		pr_debug("%s: dev(%d) close from %p\n", ipac->name,
-			dch->dev.id, __builtin_return_address(0));
+			 dch->dev.id, __builtin_return_address(0));
 		module_put(ipac->owner);
 		break;
 	case CONTROL_CHANNEL:
@@ -1620,7 +1620,7 @@ mISDNipac_init(struct ipac_hw *ipac, void *hw)
 		ipac->hscx[i].bch.nr = i + 1;
 		set_channelmap(i + 1, ipac->isac.dch.dev.channelmap);
 		list_add(&ipac->hscx[i].bch.ch.list,
-			&ipac->isac.dch.dev.bchannels);
+			 &ipac->isac.dch.dev.bchannels);
 		mISDN_initbchannel(&ipac->hscx[i].bch, MAX_DATA_MEM);
 		ipac->hscx[i].bch.ch.nr = i + 1;
 		ipac->hscx[i].bch.ch.send = &hscx_l2l1;

commit a6b7a407865aab9f849dd99a71072b7cd1175116
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jun 6 10:43:46 2011 +0000

    net: remove interrupt.h inclusion from netdevice.h
    
    * remove interrupt.g inclusion from netdevice.h -- not needed
    * fixup fallout, add interrupt.h and hardirq.h back where needed.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 64ecc6f5ffaf..d2ffb1d9b831 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -20,6 +20,7 @@
  *
  */
 
+#include <linux/irqreturn.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/mISDNhw.h>

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
index 613ba0435372..64ecc6f5ffaf 100644
--- a/drivers/isdn/hardware/mISDN/mISDNipac.c
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -20,6 +20,7 @@
  *
  */
 
+#include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/mISDNhw.h>
 #include "ipac.h"

commit cae86d4a4e56eeda1afdea38f230d222edda7dd5
Author: Karsten Keil <keil@b1-systems.de>
Date:   Wed Jul 22 19:42:46 2009 +0200

    mISDN: Add driver for Infineon ISDN chipset family
    
    This driver supports cards with Infineon ISAC/HSCX, ISACX, IPAC
    and IPACX chips from various manufacturers.
    
    Signed-off-by: Karsten Keil <keil@b1-systems.de>

diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c
new file mode 100644
index 000000000000..613ba0435372
--- /dev/null
+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c
@@ -0,0 +1,1655 @@
+/*
+ * isac.c   ISAC specific routines
+ *
+ * Author       Karsten Keil <keil@isdn4linux.de>
+ *
+ * Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/mISDNhw.h>
+#include "ipac.h"
+
+
+#define DBUSY_TIMER_VALUE	80
+#define ARCOFI_USE		1
+
+#define ISAC_REV		"2.0"
+
+MODULE_AUTHOR("Karsten Keil");
+MODULE_VERSION(ISAC_REV);
+MODULE_LICENSE("GPL v2");
+
+#define ReadISAC(is, o)		(is->read_reg(is->dch.hw, o + is->off))
+#define	WriteISAC(is, o, v)	(is->write_reg(is->dch.hw, o + is->off, v))
+#define ReadHSCX(h, o)		(h->ip->read_reg(h->ip->hw, h->off + o))
+#define WriteHSCX(h, o, v)	(h->ip->write_reg(h->ip->hw, h->off + o, v))
+#define ReadIPAC(ip, o)		(ip->read_reg(ip->hw, o))
+#define WriteIPAC(ip, o, v)	(ip->write_reg(ip->hw, o, v))
+
+static inline void
+ph_command(struct isac_hw *isac, u8 command)
+{
+	pr_debug("%s: ph_command %x\n", isac->name, command);
+	if (isac->type & IPAC_TYPE_ISACX)
+		WriteISAC(isac, ISACX_CIX0, (command << 4) | 0xE);
+	else
+		WriteISAC(isac, ISAC_CIX0, (command << 2) | 3);
+}
+
+static void
+isac_ph_state_change(struct isac_hw *isac)
+{
+	switch (isac->state) {
+	case (ISAC_IND_RS):
+	case (ISAC_IND_EI):
+		ph_command(isac, ISAC_CMD_DUI);
+	}
+	schedule_event(&isac->dch, FLG_PHCHANGE);
+}
+
+static void
+isac_ph_state_bh(struct dchannel *dch)
+{
+	struct isac_hw *isac = container_of(dch, struct isac_hw, dch);
+
+	switch (isac->state) {
+	case ISAC_IND_RS:
+	case ISAC_IND_EI:
+		dch->state = 0;
+		l1_event(dch->l1, HW_RESET_IND);
+		break;
+	case ISAC_IND_DID:
+		dch->state = 3;
+		l1_event(dch->l1, HW_DEACT_CNF);
+		break;
+	case ISAC_IND_DR:
+		dch->state = 3;
+		l1_event(dch->l1, HW_DEACT_IND);
+		break;
+	case ISAC_IND_PU:
+		dch->state = 4;
+		l1_event(dch->l1, HW_POWERUP_IND);
+		break;
+	case ISAC_IND_RSY:
+		if (dch->state <= 5) {
+			dch->state = 5;
+			l1_event(dch->l1, ANYSIGNAL);
+		} else {
+			dch->state = 8;
+			l1_event(dch->l1, LOSTFRAMING);
+		}
+		break;
+	case ISAC_IND_ARD:
+		dch->state = 6;
+		l1_event(dch->l1, INFO2);
+		break;
+	case ISAC_IND_AI8:
+		dch->state = 7;
+		l1_event(dch->l1, INFO4_P8);
+		break;
+	case ISAC_IND_AI10:
+		dch->state = 7;
+		l1_event(dch->l1, INFO4_P10);
+		break;
+	}
+	pr_debug("%s: TE newstate %x\n", isac->name, dch->state);
+}
+
+void
+isac_empty_fifo(struct isac_hw *isac, int count)
+{
+	u8 *ptr;
+
+	pr_debug("%s: %s  %d\n", isac->name, __func__, count);
+
+	if (!isac->dch.rx_skb) {
+		isac->dch.rx_skb = mI_alloc_skb(isac->dch.maxlen, GFP_ATOMIC);
+		if (!isac->dch.rx_skb) {
+			pr_info("%s: D receive out of memory\n", isac->name);
+			WriteISAC(isac, ISAC_CMDR, 0x80);
+			return;
+		}
+	}
+	if ((isac->dch.rx_skb->len + count) >= isac->dch.maxlen) {
+		pr_debug("%s: %s overrun %d\n", isac->name, __func__,
+			    isac->dch.rx_skb->len + count);
+		WriteISAC(isac, ISAC_CMDR, 0x80);
+		return;
+	}
+	ptr = skb_put(isac->dch.rx_skb, count);
+	isac->read_fifo(isac->dch.hw, isac->off, ptr, count);
+	WriteISAC(isac, ISAC_CMDR, 0x80);
+	if (isac->dch.debug & DEBUG_HW_DFIFO) {
+		char	pfx[MISDN_MAX_IDLEN + 16];
+
+		snprintf(pfx, MISDN_MAX_IDLEN + 15, "D-recv %s %d ",
+			isac->name, count);
+		print_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);
+	}
+}
+
+static void
+isac_fill_fifo(struct isac_hw *isac)
+{
+	int count, more;
+	u8 *ptr;
+
+	if (!isac->dch.tx_skb)
+		return;
+	count = isac->dch.tx_skb->len - isac->dch.tx_idx;
+	if (count <= 0)
+		return;
+
+	more = 0;
+	if (count > 32) {
+		more = !0;
+		count = 32;
+	}
+	pr_debug("%s: %s  %d\n", isac->name, __func__, count);
+	ptr = isac->dch.tx_skb->data + isac->dch.tx_idx;
+	isac->dch.tx_idx += count;
+	isac->write_fifo(isac->dch.hw, isac->off, ptr, count);
+	WriteISAC(isac, ISAC_CMDR, more ? 0x8 : 0xa);
+	if (test_and_set_bit(FLG_BUSY_TIMER, &isac->dch.Flags)) {
+		pr_debug("%s: %s dbusytimer running\n", isac->name, __func__);
+		del_timer(&isac->dch.timer);
+	}
+	init_timer(&isac->dch.timer);
+	isac->dch.timer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ)/1000);
+	add_timer(&isac->dch.timer);
+	if (isac->dch.debug & DEBUG_HW_DFIFO) {
+		char	pfx[MISDN_MAX_IDLEN + 16];
+
+		snprintf(pfx, MISDN_MAX_IDLEN + 15, "D-send %s %d ",
+			isac->name, count);
+		print_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);
+	}
+}
+
+static void
+isac_rme_irq(struct isac_hw *isac)
+{
+	u8 val, count;
+
+	val = ReadISAC(isac, ISAC_RSTA);
+	if ((val & 0x70) != 0x20) {
+		if (val & 0x40) {
+			pr_debug("%s: ISAC RDO\n", isac->name);
+#ifdef ERROR_STATISTIC
+			isac->dch.err_rx++;
+#endif
+		}
+		if (!(val & 0x20)) {
+			pr_debug("%s: ISAC CRC error\n", isac->name);
+#ifdef ERROR_STATISTIC
+			isac->dch.err_crc++;
+#endif
+		}
+		WriteISAC(isac, ISAC_CMDR, 0x80);
+		if (isac->dch.rx_skb)
+			dev_kfree_skb(isac->dch.rx_skb);
+		isac->dch.rx_skb = NULL;
+	} else {
+		count = ReadISAC(isac, ISAC_RBCL) & 0x1f;
+		if (count == 0)
+			count = 32;
+		isac_empty_fifo(isac, count);
+		recv_Dchannel(&isac->dch);
+	}
+}
+
+static void
+isac_xpr_irq(struct isac_hw *isac)
+{
+	if (test_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags))
+		del_timer(&isac->dch.timer);
+	if (isac->dch.tx_skb && isac->dch.tx_idx < isac->dch.tx_skb->len) {
+		isac_fill_fifo(isac);
+	} else {
+		if (isac->dch.tx_skb)
+			dev_kfree_skb(isac->dch.tx_skb);
+		if (get_next_dframe(&isac->dch))
+			isac_fill_fifo(isac);
+	}
+}
+
+static void
+isac_retransmit(struct isac_hw *isac)
+{
+	if (test_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags))
+		del_timer(&isac->dch.timer);
+	if (test_bit(FLG_TX_BUSY, &isac->dch.Flags)) {
+		/* Restart frame */
+		isac->dch.tx_idx = 0;
+		isac_fill_fifo(isac);
+	} else if (isac->dch.tx_skb) { /* should not happen */
+		pr_info("%s: tx_skb exist but not busy\n", isac->name);
+		test_and_set_bit(FLG_TX_BUSY, &isac->dch.Flags);
+		isac->dch.tx_idx = 0;
+		isac_fill_fifo(isac);
+	} else {
+		pr_info("%s: ISAC XDU no TX_BUSY\n", isac->name);
+		if (get_next_dframe(&isac->dch))
+			isac_fill_fifo(isac);
+	}
+}
+
+static void
+isac_mos_irq(struct isac_hw *isac)
+{
+	u8 val;
+	int ret;
+
+	val = ReadISAC(isac, ISAC_MOSR);
+	pr_debug("%s: ISAC MOSR %02x\n", isac->name, val);
+#if ARCOFI_USE
+	if (val & 0x08) {
+		if (!isac->mon_rx) {
+			isac->mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);
+			if (!isac->mon_rx) {
+				pr_info("%s: ISAC MON RX out of memory!\n",
+					isac->name);
+				isac->mocr &= 0xf0;
+				isac->mocr |= 0x0a;
+				WriteISAC(isac, ISAC_MOCR, isac->mocr);
+				goto afterMONR0;
+			} else
+				isac->mon_rxp = 0;
+		}
+		if (isac->mon_rxp >= MAX_MON_FRAME) {
+			isac->mocr &= 0xf0;
+			isac->mocr |= 0x0a;
+			WriteISAC(isac, ISAC_MOCR, isac->mocr);
+			isac->mon_rxp = 0;
+			pr_debug("%s: ISAC MON RX overflow!\n", isac->name);
+			goto afterMONR0;
+		}
+		isac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR0);
+		pr_debug("%s: ISAC MOR0 %02x\n", isac->name,
+			isac->mon_rx[isac->mon_rxp - 1]);
+		if (isac->mon_rxp == 1) {
+			isac->mocr |= 0x04;
+			WriteISAC(isac, ISAC_MOCR, isac->mocr);
+		}
+	}
+afterMONR0:
+	if (val & 0x80) {
+		if (!isac->mon_rx) {
+			isac->mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);
+			if (!isac->mon_rx) {
+				pr_info("%s: ISAC MON RX out of memory!\n",
+					isac->name);
+				isac->mocr &= 0x0f;
+				isac->mocr |= 0xa0;
+				WriteISAC(isac, ISAC_MOCR, isac->mocr);
+				goto afterMONR1;
+			} else
+				isac->mon_rxp = 0;
+		}
+		if (isac->mon_rxp >= MAX_MON_FRAME) {
+			isac->mocr &= 0x0f;
+			isac->mocr |= 0xa0;
+			WriteISAC(isac, ISAC_MOCR, isac->mocr);
+			isac->mon_rxp = 0;
+			pr_debug("%s: ISAC MON RX overflow!\n", isac->name);
+			goto afterMONR1;
+		}
+		isac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR1);
+		pr_debug("%s: ISAC MOR1 %02x\n", isac->name,
+			isac->mon_rx[isac->mon_rxp - 1]);
+		isac->mocr |= 0x40;
+		WriteISAC(isac, ISAC_MOCR, isac->mocr);
+	}
+afterMONR1:
+	if (val & 0x04) {
+		isac->mocr &= 0xf0;
+		WriteISAC(isac, ISAC_MOCR, isac->mocr);
+		isac->mocr |= 0x0a;
+		WriteISAC(isac, ISAC_MOCR, isac->mocr);
+		if (isac->monitor) {
+			ret = isac->monitor(isac->dch.hw, MONITOR_RX_0,
+				isac->mon_rx, isac->mon_rxp);
+			if (ret)
+				kfree(isac->mon_rx);
+		} else {
+			pr_info("%s: MONITOR 0 received %d but no user\n",
+				isac->name, isac->mon_rxp);
+			kfree(isac->mon_rx);
+		}
+		isac->mon_rx = NULL;
+		isac->mon_rxp = 0;
+	}
+	if (val & 0x40) {
+		isac->mocr &= 0x0f;
+		WriteISAC(isac, ISAC_MOCR, isac->mocr);
+		isac->mocr |= 0xa0;
+		WriteISAC(isac, ISAC_MOCR, isac->mocr);
+		if (isac->monitor) {
+			ret = isac->monitor(isac->dch.hw, MONITOR_RX_1,
+				isac->mon_rx, isac->mon_rxp);
+			if (ret)
+				kfree(isac->mon_rx);
+		} else {
+			pr_info("%s: MONITOR 1 received %d but no user\n",
+				isac->name, isac->mon_rxp);
+			kfree(isac->mon_rx);
+		}
+		isac->mon_rx = NULL;
+		isac->mon_rxp = 0;
+	}
+	if (val & 0x02) {
+		if ((!isac->mon_tx) || (isac->mon_txc &&
+			(isac->mon_txp >= isac->mon_txc) && !(val & 0x08))) {
+			isac->mocr &= 0xf0;
+			WriteISAC(isac, ISAC_MOCR, isac->mocr);
+			isac->mocr |= 0x0a;
+			WriteISAC(isac, ISAC_MOCR, isac->mocr);
+			if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
+				if (isac->monitor)
+					ret = isac->monitor(isac->dch.hw,
+						MONITOR_TX_0, NULL, 0);
+			}
+			kfree(isac->mon_tx);
+			isac->mon_tx = NULL;
+			isac->mon_txc = 0;
+			isac->mon_txp = 0;
+			goto AfterMOX0;
+		}
+		if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
+			if (isac->monitor)
+				ret = isac->monitor(isac->dch.hw,
+					MONITOR_TX_0, NULL, 0);
+			kfree(isac->mon_tx);
+			isac->mon_tx = NULL;
+			isac->mon_txc = 0;
+			isac->mon_txp = 0;
+			goto AfterMOX0;
+		}
+		WriteISAC(isac, ISAC_MOX0, isac->mon_tx[isac->mon_txp++]);
+		pr_debug("%s: ISAC %02x -> MOX0\n", isac->name,
+			isac->mon_tx[isac->mon_txp - 1]);
+	}
+AfterMOX0:
+	if (val & 0x20) {
+		if ((!isac->mon_tx) || (isac->mon_txc &&
+			(isac->mon_txp >= isac->mon_txc) && !(val & 0x80))) {
+			isac->mocr &= 0x0f;
+			WriteISAC(isac, ISAC_MOCR, isac->mocr);
+			isac->mocr |= 0xa0;
+			WriteISAC(isac, ISAC_MOCR, isac->mocr);
+			if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
+				if (isac->monitor)
+					ret = isac->monitor(isac->dch.hw,
+						MONITOR_TX_1, NULL, 0);
+			}
+			kfree(isac->mon_tx);
+			isac->mon_tx = NULL;
+			isac->mon_txc = 0;
+			isac->mon_txp = 0;
+			goto AfterMOX1;
+		}
+		if (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {
+			if (isac->monitor)
+				ret = isac->monitor(isac->dch.hw,
+					MONITOR_TX_1, NULL, 0);
+			kfree(isac->mon_tx);
+			isac->mon_tx = NULL;
+			isac->mon_txc = 0;
+			isac->mon_txp = 0;
+			goto AfterMOX1;
+		}
+		WriteISAC(isac, ISAC_MOX1, isac->mon_tx[isac->mon_txp++]);
+		pr_debug("%s: ISAC %02x -> MOX1\n", isac->name,
+			isac->mon_tx[isac->mon_txp - 1]);
+	}
+AfterMOX1:
+	val = 0; /* dummy to avoid warning */
+#endif
+}
+
+static void
+isac_cisq_irq(struct isac_hw *isac) {
+	u8 val;
+
+	val = ReadISAC(isac, ISAC_CIR0);
+	pr_debug("%s: ISAC CIR0 %02X\n", isac->name, val);
+	if (val & 2) {
+		pr_debug("%s: ph_state change %x->%x\n", isac->name,
+			isac->state, (val >> 2) & 0xf);
+		isac->state = (val >> 2) & 0xf;
+		isac_ph_state_change(isac);
+	}
+	if (val & 1) {
+		val = ReadISAC(isac, ISAC_CIR1);
+		pr_debug("%s: ISAC CIR1 %02X\n", isac->name, val);
+	}
+}
+
+static void
+isacsx_cic_irq(struct isac_hw *isac)
+{
+	u8 val;
+
+	val = ReadISAC(isac, ISACX_CIR0);
+	pr_debug("%s: ISACX CIR0 %02X\n", isac->name, val);
+	if (val & ISACX_CIR0_CIC0) {
+		pr_debug("%s: ph_state change %x->%x\n", isac->name,
+			isac->state, val >> 4);
+		isac->state = val >> 4;
+		isac_ph_state_change(isac);
+	}
+}
+
+static void
+isacsx_rme_irq(struct isac_hw *isac)
+{
+	int count;
+	u8 val;
+
+	val = ReadISAC(isac, ISACX_RSTAD);
+	if ((val & (ISACX_RSTAD_VFR |
+		    ISACX_RSTAD_RDO |
+		    ISACX_RSTAD_CRC |
+		    ISACX_RSTAD_RAB))
+	    != (ISACX_RSTAD_VFR | ISACX_RSTAD_CRC)) {
+		pr_debug("%s: RSTAD %#x, dropped\n", isac->name, val);
+#ifdef ERROR_STATISTIC
+		if (val & ISACX_RSTAD_CRC)
+			isac->dch.err_rx++;
+		else
+			isac->dch.err_crc++;
+#endif
+		WriteISAC(isac, ISACX_CMDRD, ISACX_CMDRD_RMC);
+		if (isac->dch.rx_skb)
+			dev_kfree_skb(isac->dch.rx_skb);
+		isac->dch.rx_skb = NULL;
+	} else {
+		count = ReadISAC(isac, ISACX_RBCLD) & 0x1f;
+		if (count == 0)
+			count = 32;
+		isac_empty_fifo(isac, count);
+		if (isac->dch.rx_skb) {
+			skb_trim(isac->dch.rx_skb, isac->dch.rx_skb->len - 1);
+			pr_debug("%s: dchannel received %d\n", isac->name,
+				isac->dch.rx_skb->len);
+			recv_Dchannel(&isac->dch);
+		}
+	}
+}
+
+irqreturn_t
+mISDNisac_irq(struct isac_hw *isac, u8 val)
+{
+	if (unlikely(!val))
+		return IRQ_NONE;
+	pr_debug("%s: ISAC interrupt %02x\n", isac->name, val);
+	if (isac->type & IPAC_TYPE_ISACX) {
+		if (val & ISACX__CIC)
+			isacsx_cic_irq(isac);
+		if (val & ISACX__ICD) {
+			val = ReadISAC(isac, ISACX_ISTAD);
+			pr_debug("%s: ISTAD %02x\n", isac->name, val);
+			if (val & ISACX_D_XDU) {
+				pr_debug("%s: ISAC XDU\n", isac->name);
+#ifdef ERROR_STATISTIC
+				isac->dch.err_tx++;
+#endif
+				isac_retransmit(isac);
+			}
+			if (val & ISACX_D_XMR) {
+				pr_debug("%s: ISAC XMR\n", isac->name);
+#ifdef ERROR_STATISTIC
+				isac->dch.err_tx++;
+#endif
+				isac_retransmit(isac);
+			}
+			if (val & ISACX_D_XPR)
+				isac_xpr_irq(isac);
+			if (val & ISACX_D_RFO) {
+				pr_debug("%s: ISAC RFO\n", isac->name);
+				WriteISAC(isac, ISACX_CMDRD, ISACX_CMDRD_RMC);
+			}
+			if (val & ISACX_D_RME)
+				isacsx_rme_irq(isac);
+			if (val & ISACX_D_RPF)
+				isac_empty_fifo(isac, 0x20);
+		}
+	} else {
+		if (val & 0x80)	/* RME */
+			isac_rme_irq(isac);
+		if (val & 0x40)	/* RPF */
+			isac_empty_fifo(isac, 32);
+		if (val & 0x10)	/* XPR */
+			isac_xpr_irq(isac);
+		if (val & 0x04)	/* CISQ */
+			isac_cisq_irq(isac);
+		if (val & 0x20)	/* RSC - never */
+			pr_debug("%s: ISAC RSC interrupt\n", isac->name);
+		if (val & 0x02)	/* SIN - never */
+			pr_debug("%s: ISAC SIN interrupt\n", isac->name);
+		if (val & 0x01) {	/* EXI */
+			val = ReadISAC(isac, ISAC_EXIR);
+			pr_debug("%s: ISAC EXIR %02x\n", isac->name, val);
+			if (val & 0x80)	/* XMR */
+				pr_debug("%s: ISAC XMR\n", isac->name);
+			if (val & 0x40) { /* XDU */
+				pr_debug("%s: ISAC XDU\n", isac->name);
+#ifdef ERROR_STATISTIC
+				isac->dch.err_tx++;
+#endif
+				isac_retransmit(isac);
+			}
+			if (val & 0x04)	/* MOS */
+				isac_mos_irq(isac);
+		}
+	}
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(mISDNisac_irq);
+
+static int
+isac_l1hw(struct mISDNchannel *ch, struct sk_buff *skb)
+{
+	struct mISDNdevice	*dev = container_of(ch, struct mISDNdevice, D);
+	struct dchannel		*dch = container_of(dev, struct dchannel, dev);
+	struct isac_hw		*isac = container_of(dch, struct isac_hw, dch);
+	int			ret = -EINVAL;
+	struct mISDNhead	*hh = mISDN_HEAD_P(skb);
+	u32			id;
+	u_long			flags;
+
+	switch (hh->prim) {
+	case PH_DATA_REQ:
+		spin_lock_irqsave(isac->hwlock, flags);
+		ret = dchannel_senddata(dch, skb);
+		if (ret > 0) { /* direct TX */
+			id = hh->id; /* skb can be freed */
+			isac_fill_fifo(isac);
+			ret = 0;
+			spin_unlock_irqrestore(isac->hwlock, flags);
+			queue_ch_frame(ch, PH_DATA_CNF, id, NULL);
+		} else
+			spin_unlock_irqrestore(isac->hwlock, flags);
+		return ret;
+	case PH_ACTIVATE_REQ:
+		ret = l1_event(dch->l1, hh->prim);
+		break;
+	case PH_DEACTIVATE_REQ:
+		test_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);
+		ret = l1_event(dch->l1, hh->prim);
+		break;
+	}
+
+	if (!ret)
+		dev_kfree_skb(skb);
+	return ret;
+}
+
+static int
+isac_ctrl(struct isac_hw *isac, u32 cmd, u_long para)
+{
+	u8 tl = 0;
+	u_long flags;
+
+	switch (cmd) {
+	case HW_TESTLOOP:
+		spin_lock_irqsave(isac->hwlock, flags);
+		if (!(isac->type & IPAC_TYPE_ISACX)) {
+			/* TODO: implement for IPAC_TYPE_ISACX */
+			if (para & 1) /* B1 */
+				tl |= 0x0c;
+			else if (para & 2) /* B2 */
+				tl |= 0x3;
+			/* we only support IOM2 mode */
+			WriteISAC(isac, ISAC_SPCR, tl);
+			if (tl)
+				WriteISAC(isac, ISAC_ADF1, 0x8);
+			else
+				WriteISAC(isac, ISAC_ADF1, 0x0);
+		}
+		spin_unlock_irqrestore(isac->hwlock, flags);
+		break;
+	default:
+		pr_debug("%s: %s unknown command %x %lx\n", isac->name,
+			__func__, cmd, para);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+isac_l1cmd(struct dchannel *dch, u32 cmd)
+{
+	struct isac_hw *isac = container_of(dch, struct isac_hw, dch);
+	u_long flags;
+
+	pr_debug("%s: cmd(%x) state(%02x)\n", isac->name, cmd, isac->state);
+	switch (cmd) {
+	case INFO3_P8:
+		spin_lock_irqsave(isac->hwlock, flags);
+		ph_command(isac, ISAC_CMD_AR8);
+		spin_unlock_irqrestore(isac->hwlock, flags);
+		break;
+	case INFO3_P10:
+		spin_lock_irqsave(isac->hwlock, flags);
+		ph_command(isac, ISAC_CMD_AR10);
+		spin_unlock_irqrestore(isac->hwlock, flags);
+		break;
+	case HW_RESET_REQ:
+		spin_lock_irqsave(isac->hwlock, flags);
+		if ((isac->state == ISAC_IND_EI) ||
+		    (isac->state == ISAC_IND_DR) ||
+		    (isac->state == ISAC_IND_RS))
+			ph_command(isac, ISAC_CMD_TIM);
+		else
+			ph_command(isac, ISAC_CMD_RS);
+		spin_unlock_irqrestore(isac->hwlock, flags);
+		break;
+	case HW_DEACT_REQ:
+		skb_queue_purge(&dch->squeue);
+		if (dch->tx_skb) {
+			dev_kfree_skb(dch->tx_skb);
+			dch->tx_skb = NULL;
+		}
+		dch->tx_idx = 0;
+		if (dch->rx_skb) {
+			dev_kfree_skb(dch->rx_skb);
+			dch->rx_skb = NULL;
+		}
+		test_and_clear_bit(FLG_TX_BUSY, &dch->Flags);
+		if (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))
+			del_timer(&dch->timer);
+		break;
+	case HW_POWERUP_REQ:
+		spin_lock_irqsave(isac->hwlock, flags);
+		ph_command(isac, ISAC_CMD_TIM);
+		spin_unlock_irqrestore(isac->hwlock, flags);
+		break;
+	case PH_ACTIVATE_IND:
+		test_and_set_bit(FLG_ACTIVE, &dch->Flags);
+		_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,
+			GFP_ATOMIC);
+		break;
+	case PH_DEACTIVATE_IND:
+		test_and_clear_bit(FLG_ACTIVE, &dch->Flags);
+		_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,
+			GFP_ATOMIC);
+		break;
+	default:
+		pr_debug("%s: %s unknown command %x\n", isac->name,
+			__func__, cmd);
+		return -1;
+	}
+	return 0;
+}
+
+static void
+isac_release(struct isac_hw *isac)
+{
+	if (isac->type & IPAC_TYPE_ISACX)
+		WriteISAC(isac, ISACX_MASK, 0xff);
+	else
+		WriteISAC(isac, ISAC_MASK, 0xff);
+	if (isac->dch.timer.function != NULL) {
+		del_timer(&isac->dch.timer);
+		isac->dch.timer.function = NULL;
+	}
+	kfree(isac->mon_rx);
+	isac->mon_rx = NULL;
+	kfree(isac->mon_tx);
+	isac->mon_tx = NULL;
+	if (isac->dch.l1)
+		l1_event(isac->dch.l1, CLOSE_CHANNEL);
+	mISDN_freedchannel(&isac->dch);
+}
+
+static void
+dbusy_timer_handler(struct isac_hw *isac)
+{
+	int rbch, star;
+	u_long flags;
+
+	if (test_bit(FLG_BUSY_TIMER, &isac->dch.Flags)) {
+		spin_lock_irqsave(isac->hwlock, flags);
+		rbch = ReadISAC(isac, ISAC_RBCH);
+		star = ReadISAC(isac, ISAC_STAR);
+		pr_debug("%s: D-Channel Busy RBCH %02x STAR %02x\n",
+			isac->name, rbch, star);
+		if (rbch & ISAC_RBCH_XAC) /* D-Channel Busy */
+			test_and_set_bit(FLG_L1_BUSY, &isac->dch.Flags);
+		else {
+			/* discard frame; reset transceiver */
+			test_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags);
+			if (isac->dch.tx_idx)
+				isac->dch.tx_idx = 0;
+			else
+				pr_info("%s: ISAC D-Channel Busy no tx_idx\n",
+					isac->name);
+			/* Transmitter reset */
+			WriteISAC(isac, ISAC_CMDR, 0x01);
+		}
+		spin_unlock_irqrestore(isac->hwlock, flags);
+	}
+}
+
+static int
+open_dchannel(struct isac_hw *isac, struct channel_req *rq)
+{
+	pr_debug("%s: %s dev(%d) open from %p\n", isac->name, __func__,
+		isac->dch.dev.id, __builtin_return_address(1));
+	if (rq->protocol != ISDN_P_TE_S0)
+		return -EINVAL;
+	if (rq->adr.channel == 1)
+		/* E-Channel not supported */
+		return -EINVAL;
+	rq->ch = &isac->dch.dev.D;
+	rq->ch->protocol = rq->protocol;
+	if (isac->dch.state == 7)
+		_queue_data(rq->ch, PH_ACTIVATE_IND, MISDN_ID_ANY,
+		    0, NULL, GFP_KERNEL);
+	return 0;
+}
+
+static const char *ISACVer[] =
+{"2086/2186 V1.1", "2085 B1", "2085 B2",
+ "2085 V2.3"};
+
+static int
+isac_init(struct isac_hw *isac)
+{
+	u8 val;
+	int err = 0;
+
+	if (!isac->dch.l1) {
+		err = create_l1(&isac->dch, isac_l1cmd);
+		if (err)
+			return err;
+	}
+	isac->mon_tx = NULL;
+	isac->mon_rx = NULL;
+	isac->dch.timer.function = (void *) dbusy_timer_handler;
+	isac->dch.timer.data = (long)isac;
+	init_timer(&isac->dch.timer);
+	isac->mocr = 0xaa;
+	if (isac->type & IPAC_TYPE_ISACX) {
+		/* Disable all IRQ */
+		WriteISAC(isac, ISACX_MASK, 0xff);
+		val = ReadISAC(isac, ISACX_STARD);
+		pr_debug("%s: ISACX STARD %x\n", isac->name, val);
+		val = ReadISAC(isac, ISACX_ISTAD);
+		pr_debug("%s: ISACX ISTAD %x\n", isac->name, val);
+		val = ReadISAC(isac, ISACX_ISTA);
+		pr_debug("%s: ISACX ISTA %x\n", isac->name, val);
+		/* clear LDD */
+		WriteISAC(isac, ISACX_TR_CONF0, 0x00);
+		/* enable transmitter */
+		WriteISAC(isac, ISACX_TR_CONF2, 0x00);
+		/* transparent mode 0, RAC, stop/go */
+		WriteISAC(isac, ISACX_MODED, 0xc9);
+		/* all HDLC IRQ unmasked */
+		val = ReadISAC(isac, ISACX_ID);
+		if (isac->dch.debug & DEBUG_HW)
+			pr_notice("%s: ISACX Design ID %x\n",
+				isac->name, val & 0x3f);
+		val = ReadISAC(isac, ISACX_CIR0);
+		pr_debug("%s: ISACX CIR0 %02X\n", isac->name, val);
+		isac->state = val >> 4;
+		isac_ph_state_change(isac);
+		ph_command(isac, ISAC_CMD_RS);
+		WriteISAC(isac, ISACX_MASK, IPACX__ON);
+		WriteISAC(isac, ISACX_MASKD, 0x00);
+	} else { /* old isac */
+		WriteISAC(isac, ISAC_MASK, 0xff);
+		val = ReadISAC(isac, ISAC_STAR);
+		pr_debug("%s: ISAC STAR %x\n", isac->name, val);
+		val = ReadISAC(isac, ISAC_MODE);
+		pr_debug("%s: ISAC MODE %x\n", isac->name, val);
+		val = ReadISAC(isac, ISAC_ADF2);
+		pr_debug("%s: ISAC ADF2 %x\n", isac->name, val);
+		val = ReadISAC(isac, ISAC_ISTA);
+		pr_debug("%s: ISAC ISTA %x\n", isac->name, val);
+		if (val & 0x01) {
+			val = ReadISAC(isac, ISAC_EXIR);
+			pr_debug("%s: ISAC EXIR %x\n", isac->name, val);
+		}
+		val = ReadISAC(isac, ISAC_RBCH);
+		if (isac->dch.debug & DEBUG_HW)
+			pr_notice("%s: ISAC version (%x): %s\n", isac->name,
+				val, ISACVer[(val >> 5) & 3]);
+		isac->type |= ((val >> 5) & 3);
+		if (!isac->adf2)
+			isac->adf2 = 0x80;
+		if (!(isac->adf2 & 0x80)) { /* only IOM 2 Mode */
+			pr_info("%s: only support IOM2 mode but adf2=%02x\n",
+				isac->name, isac->adf2);
+			isac_release(isac);
+			return -EINVAL;
+		}
+		WriteISAC(isac, ISAC_ADF2, isac->adf2);
+		WriteISAC(isac, ISAC_SQXR, 0x2f);
+		WriteISAC(isac, ISAC_SPCR, 0x00);
+		WriteISAC(isac, ISAC_STCR, 0x70);
+		WriteISAC(isac, ISAC_MODE, 0xc9);
+		WriteISAC(isac, ISAC_TIMR, 0x00);
+		WriteISAC(isac, ISAC_ADF1, 0x00);
+		val = ReadISAC(isac, ISAC_CIR0);
+		pr_debug("%s: ISAC CIR0 %x\n", isac->name, val);
+		isac->state = (val >> 2) & 0xf;
+		isac_ph_state_change(isac);
+		ph_command(isac, ISAC_CMD_RS);
+		WriteISAC(isac, ISAC_MASK, 0);
+	}
+	return err;
+}
+
+int
+mISDNisac_init(struct isac_hw *isac, void *hw)
+{
+	mISDN_initdchannel(&isac->dch, MAX_DFRAME_LEN_L1, isac_ph_state_bh);
+	isac->dch.hw = hw;
+	isac->dch.dev.D.send = isac_l1hw;
+	isac->init = isac_init;
+	isac->release = isac_release;
+	isac->ctrl = isac_ctrl;
+	isac->open = open_dchannel;
+	isac->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0);
+	isac->dch.dev.nrbchan = 2;
+	return 0;
+}
+EXPORT_SYMBOL(mISDNisac_init);
+
+static void
+waitforCEC(struct hscx_hw *hx)
+{
+	u8 starb, to = 50;
+
+	while (to) {
+		starb = ReadHSCX(hx, IPAC_STARB);
+		if (!(starb & 0x04))
+			break;
+		udelay(1);
+		to--;
+	}
+	if (to < 50)
+		pr_debug("%s: B%1d CEC %d us\n", hx->ip->name, hx->bch.nr,
+			50 - to);
+	if (!to)
+		pr_info("%s: B%1d CEC timeout\n", hx->ip->name, hx->bch.nr);
+}
+
+
+static void
+waitforXFW(struct hscx_hw *hx)
+{
+	u8 starb, to = 50;
+
+	while (to) {
+		starb = ReadHSCX(hx, IPAC_STARB);
+		if ((starb & 0x44) == 0x40)
+			break;
+		udelay(1);
+		to--;
+	}
+	if (to < 50)
+		pr_debug("%s: B%1d XFW %d us\n", hx->ip->name, hx->bch.nr,
+			50 - to);
+	if (!to)
+		pr_info("%s: B%1d XFW timeout\n", hx->ip->name, hx->bch.nr);
+}
+
+static void
+hscx_cmdr(struct hscx_hw *hx, u8 cmd)
+{
+	if (hx->ip->type & IPAC_TYPE_IPACX)
+		WriteHSCX(hx, IPACX_CMDRB, cmd);
+	else {
+		waitforCEC(hx);
+		WriteHSCX(hx, IPAC_CMDRB, cmd);
+	}
+}
+
+static void
+hscx_empty_fifo(struct hscx_hw *hscx, u8 count)
+{
+	u8 *p;
+
+	pr_debug("%s: B%1d %d\n", hscx->ip->name, hscx->bch.nr, count);
+	if (!hscx->bch.rx_skb) {
+		hscx->bch.rx_skb = mI_alloc_skb(hscx->bch.maxlen, GFP_ATOMIC);
+		if (!hscx->bch.rx_skb) {
+			pr_info("%s: B receive out of memory\n",
+				hscx->ip->name);
+			hscx_cmdr(hscx, 0x80); /* RMC */
+			return;
+		}
+	}
+	if ((hscx->bch.rx_skb->len + count) > hscx->bch.maxlen) {
+		pr_debug("%s: overrun %d\n", hscx->ip->name,
+			hscx->bch.rx_skb->len + count);
+		skb_trim(hscx->bch.rx_skb, 0);
+		hscx_cmdr(hscx, 0x80); /* RMC */
+		return;
+	}
+	p = skb_put(hscx->bch.rx_skb, count);
+
+	if (hscx->ip->type & IPAC_TYPE_IPACX)
+		hscx->ip->read_fifo(hscx->ip->hw,
+			hscx->off + IPACX_RFIFOB, p, count);
+	else
+		hscx->ip->read_fifo(hscx->ip->hw,
+			hscx->off, p, count);
+
+	hscx_cmdr(hscx, 0x80); /* RMC */
+
+	if (hscx->bch.debug & DEBUG_HW_BFIFO) {
+		snprintf(hscx->log, 64, "B%1d-recv %s %d ",
+			hscx->bch.nr, hscx->ip->name, count);
+		print_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);
+	}
+}
+
+static void
+hscx_fill_fifo(struct hscx_hw *hscx)
+{
+	int count, more;
+	u8 *p;
+
+	if (!hscx->bch.tx_skb)
+		return;
+	count = hscx->bch.tx_skb->len - hscx->bch.tx_idx;
+	if (count <= 0)
+		return;
+	p = hscx->bch.tx_skb->data + hscx->bch.tx_idx;
+
+	more = test_bit(FLG_TRANSPARENT, &hscx->bch.Flags) ? 1 : 0;
+	if (count > hscx->fifo_size) {
+		count = hscx->fifo_size;
+		more = 1;
+	}
+	pr_debug("%s: B%1d %d/%d/%d\n", hscx->ip->name, hscx->bch.nr, count,
+		hscx->bch.tx_idx, hscx->bch.tx_skb->len);
+	hscx->bch.tx_idx += count;
+
+	if (hscx->ip->type & IPAC_TYPE_IPACX)
+		hscx->ip->write_fifo(hscx->ip->hw,
+			hscx->off + IPACX_XFIFOB, p, count);
+	else {
+		waitforXFW(hscx);
+		hscx->ip->write_fifo(hscx->ip->hw,
+			hscx->off, p, count);
+	}
+	hscx_cmdr(hscx, more ? 0x08 : 0x0a);
+
+	if (hscx->bch.debug & DEBUG_HW_BFIFO) {
+		snprintf(hscx->log, 64, "B%1d-send %s %d ",
+			hscx->bch.nr, hscx->ip->name, count);
+		print_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);
+	}
+}
+
+static void
+hscx_xpr(struct hscx_hw *hx)
+{
+	if (hx->bch.tx_skb && hx->bch.tx_idx < hx->bch.tx_skb->len)
+		hscx_fill_fifo(hx);
+	else {
+		if (hx->bch.tx_skb) {
+			/* send confirm, on trans, free on hdlc. */
+			if (test_bit(FLG_TRANSPARENT, &hx->bch.Flags))
+				confirm_Bsend(&hx->bch);
+			dev_kfree_skb(hx->bch.tx_skb);
+		}
+		if (get_next_bframe(&hx->bch))
+			hscx_fill_fifo(hx);
+	}
+}
+
+static void
+ipac_rme(struct hscx_hw *hx)
+{
+	int count;
+	u8 rstab;
+
+	if (hx->ip->type & IPAC_TYPE_IPACX)
+		rstab = ReadHSCX(hx, IPACX_RSTAB);
+	else
+		rstab = ReadHSCX(hx, IPAC_RSTAB);
+	pr_debug("%s: B%1d RSTAB %02x\n", hx->ip->name, hx->bch.nr, rstab);
+	if ((rstab & 0xf0) != 0xa0) {
+		/* !(VFR && !RDO && CRC && !RAB) */
+		if (!(rstab & 0x80)) {
+			if (hx->bch.debug & DEBUG_HW_BCHANNEL)
+				pr_notice("%s: B%1d invalid frame\n",
+					hx->ip->name, hx->bch.nr);
+		}
+		if (rstab & 0x40) {
+			if (hx->bch.debug & DEBUG_HW_BCHANNEL)
+				pr_notice("%s: B%1d RDO proto=%x\n",
+					hx->ip->name, hx->bch.nr,
+					hx->bch.state);
+		}
+		if (!(rstab & 0x20)) {
+			if (hx->bch.debug & DEBUG_HW_BCHANNEL)
+				pr_notice("%s: B%1d CRC error\n",
+					hx->ip->name, hx->bch.nr);
+		}
+		hscx_cmdr(hx, 0x80); /* Do RMC */
+		return;
+	}
+	if (hx->ip->type & IPAC_TYPE_IPACX)
+		count = ReadHSCX(hx, IPACX_RBCLB);
+	else
+		count = ReadHSCX(hx, IPAC_RBCLB);
+	count &= (hx->fifo_size - 1);
+	if (count == 0)
+		count = hx->fifo_size;
+	hscx_empty_fifo(hx, count);
+	if (!hx->bch.rx_skb)
+		return;
+	if (hx->bch.rx_skb->len < 2) {
+		pr_debug("%s: B%1d frame to short %d\n",
+			hx->ip->name, hx->bch.nr, hx->bch.rx_skb->len);
+		skb_trim(hx->bch.rx_skb, 0);
+	} else {
+		skb_trim(hx->bch.rx_skb, hx->bch.rx_skb->len - 1);
+		recv_Bchannel(&hx->bch, 0);
+	}
+}
+
+static void
+ipac_irq(struct hscx_hw *hx, u8 ista)
+{
+	u8 istab, m, exirb = 0;
+
+	if (hx->ip->type & IPAC_TYPE_IPACX)
+		istab = ReadHSCX(hx, IPACX_ISTAB);
+	else if (hx->ip->type & IPAC_TYPE_IPAC) {
+		istab = ReadHSCX(hx, IPAC_ISTAB);
+		m = (hx->bch.nr & 1) ? IPAC__EXA : IPAC__EXB;
+		if (m & ista) {
+			exirb = ReadHSCX(hx, IPAC_EXIRB);
+			pr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,
+				hx->bch.nr, exirb);
+		}
+	} else if (hx->bch.nr & 2) { /* HSCX B */
+		if (ista & (HSCX__EXA | HSCX__ICA))
+			ipac_irq(&hx->ip->hscx[0], ista);
+		if (ista & HSCX__EXB) {
+			exirb = ReadHSCX(hx, IPAC_EXIRB);
+			pr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,
+				hx->bch.nr, exirb);
+		}
+		istab = ista & 0xF8;
+	} else { /* HSCX A */
+		istab = ReadHSCX(hx, IPAC_ISTAB);
+		if (ista & HSCX__EXA) {
+			exirb = ReadHSCX(hx, IPAC_EXIRB);
+			pr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,
+				hx->bch.nr, exirb);
+		}
+		istab = istab & 0xF8;
+	}
+	if (exirb & IPAC_B_XDU)
+		istab |= IPACX_B_XDU;
+	if (exirb & IPAC_B_RFO)
+		istab |= IPACX_B_RFO;
+	pr_debug("%s: B%1d ISTAB %02x\n", hx->ip->name, hx->bch.nr, istab);
+
+	if (!test_bit(FLG_ACTIVE, &hx->bch.Flags))
+		return;
+
+	if (istab & IPACX_B_RME)
+		ipac_rme(hx);
+
+	if (istab & IPACX_B_RPF) {
+		hscx_empty_fifo(hx, hx->fifo_size);
+		if (test_bit(FLG_TRANSPARENT, &hx->bch.Flags)) {
+			/* receive transparent audio data */
+			if (hx->bch.rx_skb)
+				recv_Bchannel(&hx->bch, 0);
+		}
+	}
+
+	if (istab & IPACX_B_RFO) {
+		pr_debug("%s: B%1d RFO error\n", hx->ip->name, hx->bch.nr);
+		hscx_cmdr(hx, 0x40);	/* RRES */
+	}
+
+	if (istab & IPACX_B_XPR)
+		hscx_xpr(hx);
+
+	if (istab & IPACX_B_XDU) {
+		if (test_bit(FLG_TRANSPARENT, &hx->bch.Flags)) {
+			hscx_fill_fifo(hx);
+			return;
+		}
+		pr_debug("%s: B%1d XDU error at len %d\n", hx->ip->name,
+			hx->bch.nr, hx->bch.tx_idx);
+		hx->bch.tx_idx = 0;
+		hscx_cmdr(hx, 0x01);	/* XRES */
+	}
+}
+
+irqreturn_t
+mISDNipac_irq(struct ipac_hw *ipac, int maxloop)
+{
+	int cnt = maxloop + 1;
+	u8 ista, istad;
+	struct isac_hw  *isac = &ipac->isac;
+
+	if (ipac->type & IPAC_TYPE_IPACX) {
+		ista = ReadIPAC(ipac, ISACX_ISTA);
+		while (ista && cnt--) {
+			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
+			if (ista & IPACX__ICA)
+				ipac_irq(&ipac->hscx[0], ista);
+			if (ista & IPACX__ICB)
+				ipac_irq(&ipac->hscx[1], ista);
+			if (ista & (ISACX__ICD | ISACX__CIC))
+				mISDNisac_irq(&ipac->isac, ista);
+			ista = ReadIPAC(ipac, ISACX_ISTA);
+		}
+	} else if (ipac->type & IPAC_TYPE_IPAC) {
+		ista = ReadIPAC(ipac, IPAC_ISTA);
+		while (ista && cnt--) {
+			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
+			if (ista & (IPAC__ICD | IPAC__EXD)) {
+				istad = ReadISAC(isac, ISAC_ISTA);
+				pr_debug("%s: ISTAD %02x\n", ipac->name, istad);
+				if (istad & IPAC_D_TIN2)
+					pr_debug("%s TIN2 irq\n", ipac->name);
+				if (ista & IPAC__EXD)
+					istad |= 1; /* ISAC EXI */
+				mISDNisac_irq(isac, istad);
+			}
+			if (ista & (IPAC__ICA | IPAC__EXA))
+				ipac_irq(&ipac->hscx[0], ista);
+			if (ista & (IPAC__ICB | IPAC__EXB))
+				ipac_irq(&ipac->hscx[1], ista);
+			ista = ReadIPAC(ipac, IPAC_ISTA);
+		}
+	} else if (ipac->type & IPAC_TYPE_HSCX) {
+		while (cnt) {
+			ista = ReadIPAC(ipac, IPAC_ISTAB + ipac->hscx[1].off);
+			pr_debug("%s: B2 ISTA %02x\n", ipac->name, ista);
+			if (ista)
+				ipac_irq(&ipac->hscx[1], ista);
+			istad = ReadISAC(isac, ISAC_ISTA);
+			pr_debug("%s: ISTAD %02x\n", ipac->name, istad);
+			if (istad)
+				mISDNisac_irq(isac, istad);
+			if (0 == (ista | istad))
+				break;
+			cnt--;
+		}
+	}
+	if (cnt > maxloop) /* only for ISAC/HSCX without PCI IRQ test */
+		return IRQ_NONE;
+	if (cnt < maxloop)
+		pr_debug("%s: %d irqloops cpu%d\n", ipac->name,
+			maxloop - cnt, smp_processor_id());
+	if (maxloop && !cnt)
+		pr_notice("%s: %d IRQ LOOP cpu%d\n", ipac->name,
+			maxloop, smp_processor_id());
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(mISDNipac_irq);
+
+static int
+hscx_mode(struct hscx_hw *hscx, u32 bprotocol)
+{
+	pr_debug("%s: HSCX %c protocol %x-->%x ch %d\n", hscx->ip->name,
+		'@' + hscx->bch.nr, hscx->bch.state, bprotocol, hscx->bch.nr);
+	if (hscx->ip->type & IPAC_TYPE_IPACX) {
+		if (hscx->bch.nr & 1) { /* B1 and ICA */
+			WriteIPAC(hscx->ip, ISACX_BCHA_TSDP_BC1, 0x80);
+			WriteIPAC(hscx->ip, ISACX_BCHA_CR, 0x88);
+		} else { /* B2 and ICB */
+			WriteIPAC(hscx->ip, ISACX_BCHB_TSDP_BC1, 0x81);
+			WriteIPAC(hscx->ip, ISACX_BCHB_CR, 0x88);
+		}
+		switch (bprotocol) {
+		case ISDN_P_NONE: /* init */
+			WriteHSCX(hscx, IPACX_MODEB, 0xC0);	/* rec off */
+			WriteHSCX(hscx, IPACX_EXMB,  0x30);	/* std adj. */
+			WriteHSCX(hscx, IPACX_MASKB, 0xFF);	/* ints off */
+			hscx_cmdr(hscx, 0x41);
+			test_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);
+			test_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);
+			break;
+		case ISDN_P_B_RAW:
+			WriteHSCX(hscx, IPACX_MODEB, 0x88);	/* ex trans */
+			WriteHSCX(hscx, IPACX_EXMB,  0x00);	/* trans */
+			hscx_cmdr(hscx, 0x41);
+			WriteHSCX(hscx, IPACX_MASKB, IPACX_B_ON);
+			test_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);
+			break;
+		case ISDN_P_B_HDLC:
+			WriteHSCX(hscx, IPACX_MODEB, 0xC0);	/* trans */
+			WriteHSCX(hscx, IPACX_EXMB,  0x00);	/* hdlc,crc */
+			hscx_cmdr(hscx, 0x41);
+			WriteHSCX(hscx, IPACX_MASKB, IPACX_B_ON);
+			test_and_set_bit(FLG_HDLC, &hscx->bch.Flags);
+			break;
+		default:
+			pr_info("%s: protocol not known %x\n", hscx->ip->name,
+				bprotocol);
+			return -ENOPROTOOPT;
+		}
+	} else if (hscx->ip->type & IPAC_TYPE_IPAC) { /* IPAC */
+		WriteHSCX(hscx, IPAC_CCR1, 0x82);
+		WriteHSCX(hscx, IPAC_CCR2, 0x30);
+		WriteHSCX(hscx, IPAC_XCCR, 0x07);
+		WriteHSCX(hscx, IPAC_RCCR, 0x07);
+		WriteHSCX(hscx, IPAC_TSAX, hscx->slot);
+		WriteHSCX(hscx, IPAC_TSAR, hscx->slot);
+		switch (bprotocol) {
+		case ISDN_P_NONE:
+			WriteHSCX(hscx, IPAC_TSAX, 0x1F);
+			WriteHSCX(hscx, IPAC_TSAR, 0x1F);
+			WriteHSCX(hscx, IPAC_MODEB, 0x84);
+			WriteHSCX(hscx, IPAC_CCR1, 0x82);
+			WriteHSCX(hscx, IPAC_MASKB, 0xFF);	/* ints off */
+			test_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);
+			test_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);
+			break;
+		case ISDN_P_B_RAW:
+			WriteHSCX(hscx, IPAC_MODEB, 0xe4);	/* ex trans */
+			WriteHSCX(hscx, IPAC_CCR1, 0x82);
+			hscx_cmdr(hscx, 0x41);
+			WriteHSCX(hscx, IPAC_MASKB, 0);
+			test_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);
+			break;
+		case ISDN_P_B_HDLC:
+			WriteHSCX(hscx, IPAC_MODEB, 0x8c);
+			WriteHSCX(hscx, IPAC_CCR1, 0x8a);
+			hscx_cmdr(hscx, 0x41);
+			WriteHSCX(hscx, IPAC_MASKB, 0);
+			test_and_set_bit(FLG_HDLC, &hscx->bch.Flags);
+			break;
+		default:
+			pr_info("%s: protocol not known %x\n", hscx->ip->name,
+				bprotocol);
+			return -ENOPROTOOPT;
+		}
+	} else if (hscx->ip->type & IPAC_TYPE_HSCX) { /* HSCX */
+		WriteHSCX(hscx, IPAC_CCR1, 0x85);
+		WriteHSCX(hscx, IPAC_CCR2, 0x30);
+		WriteHSCX(hscx, IPAC_XCCR, 0x07);
+		WriteHSCX(hscx, IPAC_RCCR, 0x07);
+		WriteHSCX(hscx, IPAC_TSAX, hscx->slot);
+		WriteHSCX(hscx, IPAC_TSAR, hscx->slot);
+		switch (bprotocol) {
+		case ISDN_P_NONE:
+			WriteHSCX(hscx, IPAC_TSAX, 0x1F);
+			WriteHSCX(hscx, IPAC_TSAR, 0x1F);
+			WriteHSCX(hscx, IPAC_MODEB, 0x84);
+			WriteHSCX(hscx, IPAC_CCR1, 0x85);
+			WriteHSCX(hscx, IPAC_MASKB, 0xFF);	/* ints off */
+			test_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);
+			test_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);
+			break;
+		case ISDN_P_B_RAW:
+			WriteHSCX(hscx, IPAC_MODEB, 0xe4);	/* ex trans */
+			WriteHSCX(hscx, IPAC_CCR1, 0x85);
+			hscx_cmdr(hscx, 0x41);
+			WriteHSCX(hscx, IPAC_MASKB, 0);
+			test_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);
+			break;
+		case ISDN_P_B_HDLC:
+			WriteHSCX(hscx, IPAC_MODEB, 0x8c);
+			WriteHSCX(hscx, IPAC_CCR1, 0x8d);
+			hscx_cmdr(hscx, 0x41);
+			WriteHSCX(hscx, IPAC_MASKB, 0);
+			test_and_set_bit(FLG_HDLC, &hscx->bch.Flags);
+			break;
+		default:
+			pr_info("%s: protocol not known %x\n", hscx->ip->name,
+				bprotocol);
+			return -ENOPROTOOPT;
+		}
+	} else
+		return -EINVAL;
+	hscx->bch.state = bprotocol;
+	return 0;
+}
+
+static int
+hscx_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)
+{
+	struct bchannel *bch = container_of(ch, struct bchannel, ch);
+	struct hscx_hw	*hx = container_of(bch, struct hscx_hw, bch);
+	int ret = -EINVAL;
+	struct mISDNhead *hh = mISDN_HEAD_P(skb);
+	u32 id;
+	u_long flags;
+
+	switch (hh->prim) {
+	case PH_DATA_REQ:
+		spin_lock_irqsave(hx->ip->hwlock, flags);
+		ret = bchannel_senddata(bch, skb);
+		if (ret > 0) { /* direct TX */
+			id = hh->id; /* skb can be freed */
+			ret = 0;
+			hscx_fill_fifo(hx);
+			spin_unlock_irqrestore(hx->ip->hwlock, flags);
+			if (!test_bit(FLG_TRANSPARENT, &bch->Flags))
+				queue_ch_frame(ch, PH_DATA_CNF, id, NULL);
+		} else
+			spin_unlock_irqrestore(hx->ip->hwlock, flags);
+		return ret;
+	case PH_ACTIVATE_REQ:
+		spin_lock_irqsave(hx->ip->hwlock, flags);
+		if (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))
+			ret = hscx_mode(hx, ch->protocol);
+		else
+			ret = 0;
+		spin_unlock_irqrestore(hx->ip->hwlock, flags);
+		if (!ret)
+			_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,
+				NULL, GFP_KERNEL);
+		break;
+	case PH_DEACTIVATE_REQ:
+		spin_lock_irqsave(hx->ip->hwlock, flags);
+		mISDN_clear_bchannel(bch);
+		hscx_mode(hx, ISDN_P_NONE);
+		spin_unlock_irqrestore(hx->ip->hwlock, flags);
+		_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,
+			NULL, GFP_KERNEL);
+		ret = 0;
+		break;
+	default:
+		pr_info("%s: %s unknown prim(%x,%x)\n",
+			hx->ip->name, __func__, hh->prim, hh->id);
+		ret = -EINVAL;
+	}
+	if (!ret)
+		dev_kfree_skb(skb);
+	return ret;
+}
+
+static int
+channel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)
+{
+	int	ret = 0;
+
+	switch (cq->op) {
+	case MISDN_CTRL_GETOP:
+		cq->op = 0;
+		break;
+	/* Nothing implemented yet */
+	case MISDN_CTRL_FILL_EMPTY:
+	default:
+		pr_info("%s: unknown Op %x\n", __func__, cq->op);
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int
+hscx_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)
+{
+	struct bchannel *bch = container_of(ch, struct bchannel, ch);
+	struct hscx_hw	*hx = container_of(bch, struct hscx_hw, bch);
+	int ret = -EINVAL;
+	u_long flags;
+
+	pr_debug("%s: %s cmd:%x %p\n", hx->ip->name, __func__, cmd, arg);
+	switch (cmd) {
+	case CLOSE_CHANNEL:
+		test_and_clear_bit(FLG_OPEN, &bch->Flags);
+		if (test_bit(FLG_ACTIVE, &bch->Flags)) {
+			spin_lock_irqsave(hx->ip->hwlock, flags);
+			mISDN_freebchannel(bch);
+			hscx_mode(hx, ISDN_P_NONE);
+			spin_unlock_irqrestore(hx->ip->hwlock, flags);
+		} else {
+			skb_queue_purge(&bch->rqueue);
+			bch->rcount = 0;
+		}
+		ch->protocol = ISDN_P_NONE;
+		ch->peer = NULL;
+		module_put(hx->ip->owner);
+		ret = 0;
+		break;
+	case CONTROL_CHANNEL:
+		ret = channel_bctrl(bch, arg);
+		break;
+	default:
+		pr_info("%s: %s unknown prim(%x)\n",
+			hx->ip->name, __func__, cmd);
+	}
+	return ret;
+}
+
+static void
+free_ipac(struct ipac_hw *ipac)
+{
+	isac_release(&ipac->isac);
+}
+
+static const char *HSCXVer[] =
+{"A1", "?1", "A2", "?3", "A3", "V2.1", "?6", "?7",
+ "?8", "?9", "?10", "?11", "?12", "?13", "?14", "???"};
+
+
+
+static void
+hscx_init(struct hscx_hw *hx)
+{
+	u8 val;
+
+	WriteHSCX(hx, IPAC_RAH2, 0xFF);
+	WriteHSCX(hx, IPAC_XBCH, 0x00);
+	WriteHSCX(hx, IPAC_RLCR, 0x00);
+
+	if (hx->ip->type & IPAC_TYPE_HSCX) {
+		WriteHSCX(hx, IPAC_CCR1, 0x85);
+		val = ReadHSCX(hx, HSCX_VSTR);
+		pr_debug("%s: HSCX VSTR %02x\n", hx->ip->name, val);
+		if (hx->bch.debug & DEBUG_HW)
+			pr_notice("%s: HSCX version %s\n", hx->ip->name,
+				HSCXVer[val & 0x0f]);
+	} else
+		WriteHSCX(hx, IPAC_CCR1, 0x82);
+	WriteHSCX(hx, IPAC_CCR2, 0x30);
+	WriteHSCX(hx, IPAC_XCCR, 0x07);
+	WriteHSCX(hx, IPAC_RCCR, 0x07);
+}
+
+static int
+ipac_init(struct ipac_hw *ipac)
+{
+	u8 val;
+
+	if (ipac->type & IPAC_TYPE_HSCX) {
+		hscx_init(&ipac->hscx[0]);
+		hscx_init(&ipac->hscx[1]);
+		val = ReadIPAC(ipac, IPAC_ID);
+	} else if (ipac->type & IPAC_TYPE_IPAC) {
+		hscx_init(&ipac->hscx[0]);
+		hscx_init(&ipac->hscx[1]);
+		WriteIPAC(ipac, IPAC_MASK, IPAC__ON);
+		val = ReadIPAC(ipac, IPAC_CONF);
+		/* conf is default 0, but can be overwritten by card setup */
+		pr_debug("%s: IPAC CONF %02x/%02x\n", ipac->name,
+			val, ipac->conf);
+		WriteIPAC(ipac, IPAC_CONF, ipac->conf);
+		val = ReadIPAC(ipac, IPAC_ID);
+		if (ipac->hscx[0].bch.debug & DEBUG_HW)
+			pr_notice("%s: IPAC Design ID %02x\n", ipac->name, val);
+	}
+	/* nothing special for IPACX to do here */
+	return isac_init(&ipac->isac);
+}
+
+static int
+open_bchannel(struct ipac_hw *ipac, struct channel_req *rq)
+{
+	struct bchannel		*bch;
+
+	if (rq->adr.channel > 2)
+		return -EINVAL;
+	if (rq->protocol == ISDN_P_NONE)
+		return -EINVAL;
+	bch = &ipac->hscx[rq->adr.channel - 1].bch;
+	if (test_and_set_bit(FLG_OPEN, &bch->Flags))
+		return -EBUSY; /* b-channel can be only open once */
+	test_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);
+	bch->ch.protocol = rq->protocol;
+	rq->ch = &bch->ch;
+	return 0;
+}
+
+static int
+channel_ctrl(struct ipac_hw *ipac, struct mISDN_ctrl_req *cq)
+{
+	int	ret = 0;
+
+	switch (cq->op) {
+	case MISDN_CTRL_GETOP:
+		cq->op = MISDN_CTRL_LOOP;
+		break;
+	case MISDN_CTRL_LOOP:
+		/* cq->channel: 0 disable, 1 B1 loop 2 B2 loop, 3 both */
+		if (cq->channel < 0 || cq->channel > 3) {
+			ret = -EINVAL;
+			break;
+		}
+		ret = ipac->ctrl(ipac, HW_TESTLOOP, cq->channel);
+		break;
+	default:
+		pr_info("%s: unknown CTRL OP %x\n", ipac->name, cq->op);
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int
+ipac_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)
+{
+	struct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);
+	struct dchannel *dch = container_of(dev, struct dchannel, dev);
+	struct isac_hw *isac = container_of(dch, struct isac_hw, dch);
+	struct ipac_hw *ipac = container_of(isac, struct ipac_hw, isac);
+	struct channel_req *rq;
+	int err = 0;
+
+	pr_debug("%s: DCTRL: %x %p\n", ipac->name, cmd, arg);
+	switch (cmd) {
+	case OPEN_CHANNEL:
+		rq = arg;
+		if (rq->protocol == ISDN_P_TE_S0)
+			err = open_dchannel(isac, rq);
+		else
+			err = open_bchannel(ipac, rq);
+		if (err)
+			break;
+		if (!try_module_get(ipac->owner))
+			pr_info("%s: cannot get module\n", ipac->name);
+		break;
+	case CLOSE_CHANNEL:
+		pr_debug("%s: dev(%d) close from %p\n", ipac->name,
+			dch->dev.id, __builtin_return_address(0));
+		module_put(ipac->owner);
+		break;
+	case CONTROL_CHANNEL:
+		err = channel_ctrl(ipac, arg);
+		break;
+	default:
+		pr_debug("%s: unknown DCTRL command %x\n", ipac->name, cmd);
+		return -EINVAL;
+	}
+	return err;
+}
+
+u32
+mISDNipac_init(struct ipac_hw *ipac, void *hw)
+{
+	u32 ret;
+	u8 i;
+
+	ipac->hw = hw;
+	if (ipac->isac.dch.debug & DEBUG_HW)
+		pr_notice("%s: ipac type %x\n", ipac->name, ipac->type);
+	if (ipac->type & IPAC_TYPE_HSCX) {
+		ipac->isac.type = IPAC_TYPE_ISAC;
+		ipac->hscx[0].off = 0;
+		ipac->hscx[1].off = 0x40;
+		ipac->hscx[0].fifo_size = 32;
+		ipac->hscx[1].fifo_size = 32;
+	} else if (ipac->type & IPAC_TYPE_IPAC) {
+		ipac->isac.type = IPAC_TYPE_IPAC | IPAC_TYPE_ISAC;
+		ipac->hscx[0].off = 0;
+		ipac->hscx[1].off = 0x40;
+		ipac->hscx[0].fifo_size = 64;
+		ipac->hscx[1].fifo_size = 64;
+	} else if (ipac->type & IPAC_TYPE_IPACX) {
+		ipac->isac.type = IPAC_TYPE_IPACX | IPAC_TYPE_ISACX;
+		ipac->hscx[0].off = IPACX_OFF_ICA;
+		ipac->hscx[1].off = IPACX_OFF_ICB;
+		ipac->hscx[0].fifo_size = 64;
+		ipac->hscx[1].fifo_size = 64;
+	} else
+		return 0;
+
+	mISDNisac_init(&ipac->isac, hw);
+
+	ipac->isac.dch.dev.D.ctrl = ipac_dctrl;
+
+	for (i = 0; i < 2; i++) {
+		ipac->hscx[i].bch.nr = i + 1;
+		set_channelmap(i + 1, ipac->isac.dch.dev.channelmap);
+		list_add(&ipac->hscx[i].bch.ch.list,
+			&ipac->isac.dch.dev.bchannels);
+		mISDN_initbchannel(&ipac->hscx[i].bch, MAX_DATA_MEM);
+		ipac->hscx[i].bch.ch.nr = i + 1;
+		ipac->hscx[i].bch.ch.send = &hscx_l2l1;
+		ipac->hscx[i].bch.ch.ctrl = hscx_bctrl;
+		ipac->hscx[i].bch.hw = hw;
+		ipac->hscx[i].ip = ipac;
+		/* default values for IOM time slots
+		 * can be overwriten by card */
+		ipac->hscx[i].slot = (i == 0) ? 0x2f : 0x03;
+	}
+
+	ipac->init = ipac_init;
+	ipac->release = free_ipac;
+
+	ret =	(1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
+		(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));
+	return ret;
+}
+EXPORT_SYMBOL(mISDNipac_init);
+
+static int __init
+isac_mod_init(void)
+{
+	pr_notice("mISDNipac module version %s\n", ISAC_REV);
+	return 0;
+}
+
+static void __exit
+isac_mod_cleanup(void)
+{
+	pr_notice("mISDNipac module unloaded\n");
+}
+module_init(isac_mod_init);
+module_exit(isac_mod_cleanup);
