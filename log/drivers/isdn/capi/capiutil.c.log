commit f59aba2f75795e5b6a4f1aa31f3e20d7b71ca804
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Dec 10 21:59:16 2019 +0100

    isdn: capi: dead code removal
    
    The staging isdn drivers are gone, and CONFIG_BT_CMTP is now
    the only user. This means a lot of the code in the subsystem
    has no remaining callers and can be removed.
    
    Change the capi user space front-end to be part of kernelcapi,
    and the combined module to only be compiled if BT_CMTP is
    also enabled, then remove the interfaces that have no remaining
    callers.
    
    As the notifier list and the capi_drivers list have no callers
    outside of kcapi.c, the implementation gets much simpler.
    
    Some definitions from the include/linux/*.h headers are only
    needed internally and are moved to kcapi.h.
    
    Acked-by: David Miller <davem@davemloft.net>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20191210210455.3475361-2-arnd@arndb.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 9846d82eb097..f26bf3c66d7e 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -20,6 +20,8 @@
 #include <linux/isdn/capiutil.h>
 #include <linux/slab.h>
 
+#include "kcapi.h"
+
 /* from CAPI2.0 DDK AVM Berlin GmbH */
 
 typedef struct {
@@ -245,190 +247,6 @@ static void jumpcstruct(_cmsg *cmsg)
 		}
 	}
 }
-/*-------------------------------------------------------*/
-static void pars_2_message(_cmsg *cmsg)
-{
-
-	for (; TYP != _CEND; cmsg->p++) {
-		switch (TYP) {
-		case _CBYTE:
-			byteTLcpy(cmsg->m + cmsg->l, OFF);
-			cmsg->l++;
-			break;
-		case _CWORD:
-			wordTLcpy(cmsg->m + cmsg->l, OFF);
-			cmsg->l += 2;
-			break;
-		case _CDWORD:
-			dwordTLcpy(cmsg->m + cmsg->l, OFF);
-			cmsg->l += 4;
-			break;
-		case _CSTRUCT:
-			if (*(u8 **) OFF == NULL) {
-				*(cmsg->m + cmsg->l) = '\0';
-				cmsg->l++;
-			} else if (**(_cstruct *) OFF != 0xff) {
-				structTLcpy(cmsg->m + cmsg->l, *(_cstruct *) OFF, 1 + **(_cstruct *) OFF);
-				cmsg->l += 1 + **(_cstruct *) OFF;
-			} else {
-				_cstruct s = *(_cstruct *) OFF;
-				structTLcpy(cmsg->m + cmsg->l, s, 3 + *(u16 *) (s + 1));
-				cmsg->l += 3 + *(u16 *) (s + 1);
-			}
-			break;
-		case _CMSTRUCT:
-/*----- Metastruktur 0 -----*/
-			if (*(_cmstruct *) OFF == CAPI_DEFAULT) {
-				*(cmsg->m + cmsg->l) = '\0';
-				cmsg->l++;
-				jumpcstruct(cmsg);
-			}
-/*----- Metastruktur wird composed -----*/
-			else {
-				unsigned _l = cmsg->l;
-				unsigned _ls;
-				cmsg->l++;
-				cmsg->p++;
-				pars_2_message(cmsg);
-				_ls = cmsg->l - _l - 1;
-				if (_ls < 255)
-					(cmsg->m + _l)[0] = (u8) _ls;
-				else {
-					structTLcpyovl(cmsg->m + _l + 3, cmsg->m + _l + 1, _ls);
-					(cmsg->m + _l)[0] = 0xff;
-					wordTLcpy(cmsg->m + _l + 1, &_ls);
-				}
-			}
-			break;
-		}
-	}
-}
-
-/**
- * capi_cmsg2message() - assemble CAPI 2.0 message from _cmsg structure
- * @cmsg:	_cmsg structure
- * @msg:	buffer for assembled message
- *
- * Return value: 0 for success
- */
-
-unsigned capi_cmsg2message(_cmsg *cmsg, u8 *msg)
-{
-	cmsg->m = msg;
-	cmsg->l = 8;
-	cmsg->p = 0;
-	cmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);
-	if (!cmsg->par)
-		return 1;	/* invalid command/subcommand */
-
-	pars_2_message(cmsg);
-
-	wordTLcpy(msg + 0, &cmsg->l);
-	byteTLcpy(cmsg->m + 4, &cmsg->Command);
-	byteTLcpy(cmsg->m + 5, &cmsg->Subcommand);
-	wordTLcpy(cmsg->m + 2, &cmsg->ApplId);
-	wordTLcpy(cmsg->m + 6, &cmsg->Messagenumber);
-
-	return 0;
-}
-
-/*-------------------------------------------------------*/
-static void message_2_pars(_cmsg *cmsg)
-{
-	for (; TYP != _CEND; cmsg->p++) {
-
-		switch (TYP) {
-		case _CBYTE:
-			byteTRcpy(cmsg->m + cmsg->l, OFF);
-			cmsg->l++;
-			break;
-		case _CWORD:
-			wordTRcpy(cmsg->m + cmsg->l, OFF);
-			cmsg->l += 2;
-			break;
-		case _CDWORD:
-			dwordTRcpy(cmsg->m + cmsg->l, OFF);
-			cmsg->l += 4;
-			break;
-		case _CSTRUCT:
-			*(u8 **) OFF = cmsg->m + cmsg->l;
-
-			if (cmsg->m[cmsg->l] != 0xff)
-				cmsg->l += 1 + cmsg->m[cmsg->l];
-			else
-				cmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);
-			break;
-		case _CMSTRUCT:
-/*----- Metastruktur 0 -----*/
-			if (cmsg->m[cmsg->l] == '\0') {
-				*(_cmstruct *) OFF = CAPI_DEFAULT;
-				cmsg->l++;
-				jumpcstruct(cmsg);
-			} else {
-				unsigned _l = cmsg->l;
-				*(_cmstruct *) OFF = CAPI_COMPOSE;
-				cmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;
-				cmsg->p++;
-				message_2_pars(cmsg);
-			}
-			break;
-		}
-	}
-}
-
-/**
- * capi_message2cmsg() - disassemble CAPI 2.0 message into _cmsg structure
- * @cmsg:	_cmsg structure
- * @msg:	buffer for assembled message
- *
- * Return value: 0 for success
- */
-
-unsigned capi_message2cmsg(_cmsg *cmsg, u8 *msg)
-{
-	memset(cmsg, 0, sizeof(_cmsg));
-	cmsg->m = msg;
-	cmsg->l = 8;
-	cmsg->p = 0;
-	byteTRcpy(cmsg->m + 4, &cmsg->Command);
-	byteTRcpy(cmsg->m + 5, &cmsg->Subcommand);
-	cmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);
-	if (!cmsg->par)
-		return 1;	/* invalid command/subcommand */
-
-	message_2_pars(cmsg);
-
-	wordTRcpy(msg + 0, &cmsg->l);
-	wordTRcpy(cmsg->m + 2, &cmsg->ApplId);
-	wordTRcpy(cmsg->m + 6, &cmsg->Messagenumber);
-
-	return 0;
-}
-
-/**
- * capi_cmsg_header() - initialize header part of _cmsg structure
- * @cmsg:	_cmsg structure
- * @_ApplId:	ApplID field value
- * @_Command:	Command field value
- * @_Subcommand:	Subcommand field value
- * @_Messagenumber:	Message Number field value
- * @_Controller:	Controller/PLCI/NCCI field value
- *
- * Return value: 0 for success
- */
-
-unsigned capi_cmsg_header(_cmsg *cmsg, u16 _ApplId,
-			  u8 _Command, u8 _Subcommand,
-			  u16 _Messagenumber, u32 _Controller)
-{
-	memset(cmsg, 0, sizeof(_cmsg));
-	cmsg->ApplId = _ApplId;
-	cmsg->Command = _Command;
-	cmsg->Subcommand = _Subcommand;
-	cmsg->Messagenumber = _Messagenumber;
-	cmsg->adr.adrController = _Controller;
-	return 0;
-}
 
 /*-------------------------------------------------------*/
 
@@ -561,8 +379,6 @@ static char *pnames[] =
 	/*2f */ "Useruserdata"
 };
 
-
-
 #include <stdarg.h>
 
 /*-------------------------------------------------------*/
@@ -800,37 +616,6 @@ _cdebbuf *capi_message2str(u8 *msg)
 	return cdb;
 }
 
-/**
- * capi_cmsg2str() - format _cmsg structure for printing
- * @cmsg:	_cmsg structure
- *
- * Allocates a CAPI debug buffer and fills it with a printable representation
- * of the CAPI 2.0 message stored in @cmsg by a previous call to
- * capi_cmsg2message() or capi_message2cmsg().
- * Return value: allocated debug buffer, NULL on error
- * The returned buffer should be freed by a call to cdebbuf_free() after use.
- */
-
-_cdebbuf *capi_cmsg2str(_cmsg *cmsg)
-{
-	_cdebbuf *cdb;
-
-	if (!cmsg->m)
-		return NULL;	/* no message */
-	cdb = cdebbuf_alloc();
-	if (!cdb)
-		return NULL;
-	cmsg->l = 8;
-	cmsg->p = 0;
-	cdb = bufprint(cdb, "%s ID=%03d #0x%04x LEN=%04d\n",
-		       capi_cmd2str(cmsg->Command, cmsg->Subcommand),
-		       ((u16 *) cmsg->m)[1],
-		       ((u16 *) cmsg->m)[3],
-		       ((u16 *) cmsg->m)[0]);
-	cdb = protocol_message_2_pars(cdb, cmsg, 1);
-	return cdb;
-}
-
 int __init cdebug_init(void)
 {
 	g_cmsg = kmalloc(sizeof(_cmsg), GFP_KERNEL);
@@ -854,7 +639,7 @@ int __init cdebug_init(void)
 	return 0;
 }
 
-void __exit cdebug_exit(void)
+void cdebug_exit(void)
 {
 	if (g_debbuf)
 		kfree(g_debbuf->buf);
@@ -885,16 +670,8 @@ int __init cdebug_init(void)
 	return 0;
 }
 
-void __exit cdebug_exit(void)
+void cdebug_exit(void)
 {
 }
 
 #endif
-
-EXPORT_SYMBOL(cdebbuf_free);
-EXPORT_SYMBOL(capi_cmsg2message);
-EXPORT_SYMBOL(capi_message2cmsg);
-EXPORT_SYMBOL(capi_cmsg_header);
-EXPORT_SYMBOL(capi_cmd2str);
-EXPORT_SYMBOL(capi_cmsg2str);
-EXPORT_SYMBOL(capi_message2str);

commit 330078abd823cf644444999e7812a8884fce7b8e
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Wed Dec 10 13:41:55 2014 +0100

    isdn/capi: correct argument types of command_2_index
    
    Utility function command_2_index is always called with arguments of
    type u8. Adapt its declaration accordingly.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 36c1b37cea0a..9846d82eb097 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -201,7 +201,7 @@ static unsigned char *cpars[] =
 #define structTRcpyovl(x, y, l) memmove(y, x, l)
 
 /*-------------------------------------------------------*/
-static unsigned command_2_index(unsigned c, unsigned sc)
+static unsigned command_2_index(u8 c, u8 sc)
 {
 	if (c & 0x80)
 		c = 0x9 + (c & 0x0f);

commit 340184b35ac8786bdb574d2c8ce8e4f1269ec4da
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Sat Oct 11 13:46:30 2014 +0200

    isdn/capi: don't return NULL from capi_cmd2str()
    
    capi_cmd2str() is used in many places to build log messages.
    None of them is prepared to handle NULL as a result.
    Change the function to return printable string "INVALID_COMMAND"
    instead.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 36835ef3f340..36c1b37cea0a 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -489,12 +489,17 @@ static char *mnames[] =
  * @cmd:	command number
  * @subcmd:	subcommand number
  *
- * Return value: static string, NULL if command/subcommand unknown
+ * Return value: static string
  */
 
 char *capi_cmd2str(u8 cmd, u8 subcmd)
 {
-	return mnames[command_2_index(cmd, subcmd)];
+	char *result;
+
+	result = mnames[command_2_index(cmd, subcmd)];
+	if (result == NULL)
+		result = "INVALID_COMMAND";
+	return result;
 }
 
 

commit 5510ab18048397193ae073d6b0d4ea78ff0170f5
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Sat Oct 11 13:46:30 2014 +0200

    isdn/capi: prevent NULL pointer dereference on invalid CAPI command
    
    An invalid CAPI 2.0 command/subcommand combination may retrieve a
    NULL pointer from the cpars[] array which will later be dereferenced
    by the parser routines.
    Fix by adding NULL pointer checks in strategic places.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 8e401eda2aa1..36835ef3f340 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -318,6 +318,8 @@ unsigned capi_cmsg2message(_cmsg *cmsg, u8 *msg)
 	cmsg->l = 8;
 	cmsg->p = 0;
 	cmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);
+	if (!cmsg->par)
+		return 1;	/* invalid command/subcommand */
 
 	pars_2_message(cmsg);
 
@@ -391,6 +393,8 @@ unsigned capi_message2cmsg(_cmsg *cmsg, u8 *msg)
 	byteTRcpy(cmsg->m + 4, &cmsg->Command);
 	byteTRcpy(cmsg->m + 5, &cmsg->Subcommand);
 	cmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);
+	if (!cmsg->par)
+		return 1;	/* invalid command/subcommand */
 
 	message_2_pars(cmsg);
 
@@ -640,6 +644,9 @@ static _cdebbuf *printstruct(_cdebbuf *cdb, u8 *m)
 
 static _cdebbuf *protocol_message_2_pars(_cdebbuf *cdb, _cmsg *cmsg, int level)
 {
+	if (!cmsg->par)
+		return NULL;	/* invalid command/subcommand */
+
 	for (; TYP != _CEND; cmsg->p++) {
 		int slen = 29 + 3 - level;
 		int i;

commit 854d23b77aa25b203c7af11de885c3b8b3834c20
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Sat Oct 11 13:46:30 2014 +0200

    isdn/capi: refactor command/subcommand table accesses
    
    Encapsulate accesses to the CAPI 2.0 command/subcommand name and
    parameter tables in a single place in preparation for redesign.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index b501d76209f0..8e401eda2aa1 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -212,6 +212,19 @@ static unsigned command_2_index(unsigned c, unsigned sc)
 	return (sc & 3) * (0x9 + 0x9) + c;
 }
 
+/**
+ * capi_cmd2par() - find parameter string for CAPI 2.0 command/subcommand
+ * @cmd:	command number
+ * @subcmd:	subcommand number
+ *
+ * Return value: static string, NULL if command/subcommand unknown
+ */
+
+static unsigned char *capi_cmd2par(u8 cmd, u8 subcmd)
+{
+	return cpars[command_2_index(cmd, subcmd)];
+}
+
 /*-------------------------------------------------------*/
 #define TYP (cdef[cmsg->par[cmsg->p]].typ)
 #define OFF (((u8 *)cmsg) + cdef[cmsg->par[cmsg->p]].off)
@@ -304,7 +317,7 @@ unsigned capi_cmsg2message(_cmsg *cmsg, u8 *msg)
 	cmsg->m = msg;
 	cmsg->l = 8;
 	cmsg->p = 0;
-	cmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];
+	cmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);
 
 	pars_2_message(cmsg);
 
@@ -377,7 +390,7 @@ unsigned capi_message2cmsg(_cmsg *cmsg, u8 *msg)
 	cmsg->p = 0;
 	byteTRcpy(cmsg->m + 4, &cmsg->Command);
 	byteTRcpy(cmsg->m + 5, &cmsg->Subcommand);
-	cmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];
+	cmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);
 
 	message_2_pars(cmsg);
 
@@ -761,10 +774,10 @@ _cdebbuf *capi_message2str(u8 *msg)
 	cmsg->p = 0;
 	byteTRcpy(cmsg->m + 4, &cmsg->Command);
 	byteTRcpy(cmsg->m + 5, &cmsg->Subcommand);
-	cmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];
+	cmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);
 
 	cdb = bufprint(cdb, "%-26s ID=%03d #0x%04x LEN=%04d\n",
-		       mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
+		       capi_cmd2str(cmsg->Command, cmsg->Subcommand),
 		       ((unsigned short *) msg)[1],
 		       ((unsigned short *) msg)[3],
 		       ((unsigned short *) msg)[0]);
@@ -798,7 +811,7 @@ _cdebbuf *capi_cmsg2str(_cmsg *cmsg)
 	cmsg->l = 8;
 	cmsg->p = 0;
 	cdb = bufprint(cdb, "%s ID=%03d #0x%04x LEN=%04d\n",
-		       mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
+		       capi_cmd2str(cmsg->Command, cmsg->Subcommand),
 		       ((u16 *) cmsg->m)[1],
 		       ((u16 *) cmsg->m)[3],
 		       ((u16 *) cmsg->m)[0]);

commit 5362247a42e18ef74e698bb23575c272f8e35375
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Sat Oct 11 13:46:30 2014 +0200

    isdn/capi: prevent index overrun from command_2_index()
    
    The result of the function command_2_index() is used to index two
    arrays mnames[] and cpars[] with max. index 0x4e but in its current
    form that function can produce results up to 3*(0x9+0x9)+0x7f =
    0xb5.
    Fix by clamping all result values potentially overrunning the arrays
    to zero which is already handled as an invalid value.
    
    Re-spotted with Coverity.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 4073d1684d07..b501d76209f0 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -207,6 +207,8 @@ static unsigned command_2_index(unsigned c, unsigned sc)
 		c = 0x9 + (c & 0x0f);
 	else if (c == 0x41)
 		c = 0x9 + 0x1;
+	if (c > 0x18)
+		c = 0x00;
 	return (sc & 3) * (0x9 + 0x9) + c;
 }
 

commit 51db998fb6e04e8dfcf4e33295651367b91238a5
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Fri Oct 3 17:03:32 2014 +0200

    isdn/capi: drop two dead if branches
    
    The last branch in command_2_index() cannot be reached since
    c==0xff is already caught by the first "if".
    The empty second branch makes no difference since no other branch
    will be taken for c<0x0f.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 6e797e502cfa..4073d1684d07 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -205,11 +205,8 @@ static unsigned command_2_index(unsigned c, unsigned sc)
 {
 	if (c & 0x80)
 		c = 0x9 + (c & 0x0f);
-	else if (c <= 0x0f);
 	else if (c == 0x41)
 		c = 0x9 + 0x1;
-	else if (c == 0xff)
-		c = 0x00;
 	return (sc & 3) * (0x9 + 0x9) + c;
 }
 

commit ca05e3a7551b71891d42d637d3a1e443c6bbd781
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Sun Jun 1 23:47:24 2014 +0200

    isdn/capi: move capi_info2str to capidrv.c
    
    capi_info2str() is apparently meant to be of general utility. It is
    actually only used in capidrv.c. So move it from capiutil.c to
    capidrv.c and (obviously) stop exporting it.
    
    And, since we're touching this, merge the two versions of this
    function.
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index d26f17033b68..6e797e502cfa 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -22,205 +22,6 @@
 
 /* from CAPI2.0 DDK AVM Berlin GmbH */
 
-#ifndef CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON
-char *capi_info2str(u16 reason)
-{
-	return "..";
-}
-#else
-char *capi_info2str(u16 reason)
-{
-	switch (reason) {
-
-/*-- informative values (corresponding message was processed) -----*/
-	case 0x0001:
-		return "NCPI not supported by current protocol, NCPI ignored";
-	case 0x0002:
-		return "Flags not supported by current protocol, flags ignored";
-	case 0x0003:
-		return "Alert already sent by another application";
-
-/*-- error information concerning CAPI_REGISTER -----*/
-	case 0x1001:
-		return "Too many applications";
-	case 0x1002:
-		return "Logical block size too small, must be at least 128 Bytes";
-	case 0x1003:
-		return "Buffer exceeds 64 kByte";
-	case 0x1004:
-		return "Message buffer size too small, must be at least 1024 Bytes";
-	case 0x1005:
-		return "Max. number of logical connections not supported";
-	case 0x1006:
-		return "Reserved";
-	case 0x1007:
-		return "The message could not be accepted because of an internal busy condition";
-	case 0x1008:
-		return "OS resource error (no memory ?)";
-	case 0x1009:
-		return "CAPI not installed";
-	case 0x100A:
-		return "Controller does not support external equipment";
-	case 0x100B:
-		return "Controller does only support external equipment";
-
-/*-- error information concerning message exchange functions -----*/
-	case 0x1101:
-		return "Illegal application number";
-	case 0x1102:
-		return "Illegal command or subcommand or message length less than 12 bytes";
-	case 0x1103:
-		return "The message could not be accepted because of a queue full condition !! The error code does not imply that CAPI cannot receive messages directed to another controller, PLCI or NCCI";
-	case 0x1104:
-		return "Queue is empty";
-	case 0x1105:
-		return "Queue overflow, a message was lost !! This indicates a configuration error. The only recovery from this error is to perform a CAPI_RELEASE";
-	case 0x1106:
-		return "Unknown notification parameter";
-	case 0x1107:
-		return "The Message could not be accepted because of an internal busy condition";
-	case 0x1108:
-		return "OS Resource error (no memory ?)";
-	case 0x1109:
-		return "CAPI not installed";
-	case 0x110A:
-		return "Controller does not support external equipment";
-	case 0x110B:
-		return "Controller does only support external equipment";
-
-/*-- error information concerning resource / coding problems -----*/
-	case 0x2001:
-		return "Message not supported in current state";
-	case 0x2002:
-		return "Illegal Controller / PLCI / NCCI";
-	case 0x2003:
-		return "Out of PLCI";
-	case 0x2004:
-		return "Out of NCCI";
-	case 0x2005:
-		return "Out of LISTEN";
-	case 0x2006:
-		return "Out of FAX resources (protocol T.30)";
-	case 0x2007:
-		return "Illegal message parameter coding";
-
-/*-- error information concerning requested services  -----*/
-	case 0x3001:
-		return "B1 protocol not supported";
-	case 0x3002:
-		return "B2 protocol not supported";
-	case 0x3003:
-		return "B3 protocol not supported";
-	case 0x3004:
-		return "B1 protocol parameter not supported";
-	case 0x3005:
-		return "B2 protocol parameter not supported";
-	case 0x3006:
-		return "B3 protocol parameter not supported";
-	case 0x3007:
-		return "B protocol combination not supported";
-	case 0x3008:
-		return "NCPI not supported";
-	case 0x3009:
-		return "CIP Value unknown";
-	case 0x300A:
-		return "Flags not supported (reserved bits)";
-	case 0x300B:
-		return "Facility not supported";
-	case 0x300C:
-		return "Data length not supported by current protocol";
-	case 0x300D:
-		return "Reset procedure not supported by current protocol";
-
-/*-- informations about the clearing of a physical connection -----*/
-	case 0x3301:
-		return "Protocol error layer 1 (broken line or B-channel removed by signalling protocol)";
-	case 0x3302:
-		return "Protocol error layer 2";
-	case 0x3303:
-		return "Protocol error layer 3";
-	case 0x3304:
-		return "Another application got that call";
-/*-- T.30 specific reasons -----*/
-	case 0x3311:
-		return "Connecting not successful (remote station is no FAX G3 machine)";
-	case 0x3312:
-		return "Connecting not successful (training error)";
-	case 0x3313:
-		return "Disconnected before transfer (remote station does not support transfer mode, e.g. resolution)";
-	case 0x3314:
-		return "Disconnected during transfer (remote abort)";
-	case 0x3315:
-		return "Disconnected during transfer (remote procedure error, e.g. unsuccessful repetition of T.30 commands)";
-	case 0x3316:
-		return "Disconnected during transfer (local tx data underrun)";
-	case 0x3317:
-		return "Disconnected during transfer (local rx data overflow)";
-	case 0x3318:
-		return "Disconnected during transfer (local abort)";
-	case 0x3319:
-		return "Illegal parameter coding (e.g. SFF coding error)";
-
-/*-- disconnect causes from the network according to ETS 300 102-1/Q.931 -----*/
-	case 0x3481: return "Unallocated (unassigned) number";
-	case 0x3482: return "No route to specified transit network";
-	case 0x3483: return "No route to destination";
-	case 0x3486: return "Channel unacceptable";
-	case 0x3487:
-		return "Call awarded and being delivered in an established channel";
-	case 0x3490: return "Normal call clearing";
-	case 0x3491: return "User busy";
-	case 0x3492: return "No user responding";
-	case 0x3493: return "No answer from user (user alerted)";
-	case 0x3495: return "Call rejected";
-	case 0x3496: return "Number changed";
-	case 0x349A: return "Non-selected user clearing";
-	case 0x349B: return "Destination out of order";
-	case 0x349C: return "Invalid number format";
-	case 0x349D: return "Facility rejected";
-	case 0x349E: return "Response to STATUS ENQUIRY";
-	case 0x349F: return "Normal, unspecified";
-	case 0x34A2: return "No circuit / channel available";
-	case 0x34A6: return "Network out of order";
-	case 0x34A9: return "Temporary failure";
-	case 0x34AA: return "Switching equipment congestion";
-	case 0x34AB: return "Access information discarded";
-	case 0x34AC: return "Requested circuit / channel not available";
-	case 0x34AF: return "Resources unavailable, unspecified";
-	case 0x34B1: return "Quality of service unavailable";
-	case 0x34B2: return "Requested facility not subscribed";
-	case 0x34B9: return "Bearer capability not authorized";
-	case 0x34BA: return "Bearer capability not presently available";
-	case 0x34BF: return "Service or option not available, unspecified";
-	case 0x34C1: return "Bearer capability not implemented";
-	case 0x34C2: return "Channel type not implemented";
-	case 0x34C5: return "Requested facility not implemented";
-	case 0x34C6: return "Only restricted digital information bearer capability is available";
-	case 0x34CF: return "Service or option not implemented, unspecified";
-	case 0x34D1: return "Invalid call reference value";
-	case 0x34D2: return "Identified channel does not exist";
-	case 0x34D3: return "A suspended call exists, but this call identity does not";
-	case 0x34D4: return "Call identity in use";
-	case 0x34D5: return "No call suspended";
-	case 0x34D6: return "Call having the requested call identity has been cleared";
-	case 0x34D8: return "Incompatible destination";
-	case 0x34DB: return "Invalid transit network selection";
-	case 0x34DF: return "Invalid message, unspecified";
-	case 0x34E0: return "Mandatory information element is missing";
-	case 0x34E1: return "Message type non-existent or not implemented";
-	case 0x34E2: return "Message not compatible with call state or message type non-existent or not implemented";
-	case 0x34E3: return "Information element non-existent or not implemented";
-	case 0x34E4: return "Invalid information element contents";
-	case 0x34E5: return "Message not compatible with call state";
-	case 0x34E6: return "Recovery on timer expiry";
-	case 0x34EF: return "Protocol error, unspecified";
-	case 0x34FF: return "Interworking, unspecified";
-
-	default: return "No additional information";
-	}
-}
-#endif
-
 typedef struct {
 	int typ;
 	size_t off;
@@ -1073,4 +874,3 @@ EXPORT_SYMBOL(capi_cmsg_header);
 EXPORT_SYMBOL(capi_cmd2str);
 EXPORT_SYMBOL(capi_cmsg2str);
 EXPORT_SYMBOL(capi_message2str);
-EXPORT_SYMBOL(capi_info2str);

commit 475be4d85a274d0961593db41cf85689db1d583c
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 19 19:52:38 2012 -0800

    isdn: whitespace coding style cleanup
    
    isdn source code uses a not-current coding style.
    
    Update the coding style used on a per-line basis
    so that git diff -w shows only elided blank lines
    at EOF.
    
    Done with emacs and some scripts and some typing.
    
    Built x86 allyesconfig.
    No detected change in objdump -d or size.
    
    Signed-off-by: Joe Perches <joe@perches.com>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 03c469e4451f..d26f17033b68 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -25,149 +25,149 @@
 #ifndef CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON
 char *capi_info2str(u16 reason)
 {
-    return "..";
+	return "..";
 }
 #else
 char *capi_info2str(u16 reason)
 {
-    switch (reason) {
+	switch (reason) {
 
 /*-- informative values (corresponding message was processed) -----*/
 	case 0x0001:
-	   return "NCPI not supported by current protocol, NCPI ignored";
+		return "NCPI not supported by current protocol, NCPI ignored";
 	case 0x0002:
-	   return "Flags not supported by current protocol, flags ignored";
+		return "Flags not supported by current protocol, flags ignored";
 	case 0x0003:
-	   return "Alert already sent by another application";
+		return "Alert already sent by another application";
 
 /*-- error information concerning CAPI_REGISTER -----*/
 	case 0x1001:
-	   return "Too many applications";
+		return "Too many applications";
 	case 0x1002:
-	   return "Logical block size too small, must be at least 128 Bytes";
+		return "Logical block size too small, must be at least 128 Bytes";
 	case 0x1003:
-	   return "Buffer exceeds 64 kByte";
+		return "Buffer exceeds 64 kByte";
 	case 0x1004:
-	   return "Message buffer size too small, must be at least 1024 Bytes";
+		return "Message buffer size too small, must be at least 1024 Bytes";
 	case 0x1005:
-	   return "Max. number of logical connections not supported";
+		return "Max. number of logical connections not supported";
 	case 0x1006:
-	   return "Reserved";
+		return "Reserved";
 	case 0x1007:
-	   return "The message could not be accepted because of an internal busy condition";
+		return "The message could not be accepted because of an internal busy condition";
 	case 0x1008:
-	   return "OS resource error (no memory ?)";
+		return "OS resource error (no memory ?)";
 	case 0x1009:
-	   return "CAPI not installed";
+		return "CAPI not installed";
 	case 0x100A:
-	   return "Controller does not support external equipment";
+		return "Controller does not support external equipment";
 	case 0x100B:
-	   return "Controller does only support external equipment";
+		return "Controller does only support external equipment";
 
 /*-- error information concerning message exchange functions -----*/
 	case 0x1101:
-	   return "Illegal application number";
+		return "Illegal application number";
 	case 0x1102:
-	   return "Illegal command or subcommand or message length less than 12 bytes";
+		return "Illegal command or subcommand or message length less than 12 bytes";
 	case 0x1103:
-	   return "The message could not be accepted because of a queue full condition !! The error code does not imply that CAPI cannot receive messages directed to another controller, PLCI or NCCI";
+		return "The message could not be accepted because of a queue full condition !! The error code does not imply that CAPI cannot receive messages directed to another controller, PLCI or NCCI";
 	case 0x1104:
-	   return "Queue is empty";
+		return "Queue is empty";
 	case 0x1105:
-	   return "Queue overflow, a message was lost !! This indicates a configuration error. The only recovery from this error is to perform a CAPI_RELEASE";
+		return "Queue overflow, a message was lost !! This indicates a configuration error. The only recovery from this error is to perform a CAPI_RELEASE";
 	case 0x1106:
-	   return "Unknown notification parameter";
+		return "Unknown notification parameter";
 	case 0x1107:
-	   return "The Message could not be accepted because of an internal busy condition";
+		return "The Message could not be accepted because of an internal busy condition";
 	case 0x1108:
-	   return "OS Resource error (no memory ?)";
+		return "OS Resource error (no memory ?)";
 	case 0x1109:
-	   return "CAPI not installed";
+		return "CAPI not installed";
 	case 0x110A:
-	   return "Controller does not support external equipment";
+		return "Controller does not support external equipment";
 	case 0x110B:
-	   return "Controller does only support external equipment";
+		return "Controller does only support external equipment";
 
 /*-- error information concerning resource / coding problems -----*/
 	case 0x2001:
-	   return "Message not supported in current state";
+		return "Message not supported in current state";
 	case 0x2002:
-	   return "Illegal Controller / PLCI / NCCI";
+		return "Illegal Controller / PLCI / NCCI";
 	case 0x2003:
-	   return "Out of PLCI";
+		return "Out of PLCI";
 	case 0x2004:
-	   return "Out of NCCI";
+		return "Out of NCCI";
 	case 0x2005:
-	   return "Out of LISTEN";
+		return "Out of LISTEN";
 	case 0x2006:
-	   return "Out of FAX resources (protocol T.30)";
+		return "Out of FAX resources (protocol T.30)";
 	case 0x2007:
-	   return "Illegal message parameter coding";
+		return "Illegal message parameter coding";
 
 /*-- error information concerning requested services  -----*/
 	case 0x3001:
-	   return "B1 protocol not supported";
-	case 0x3002: 
-	   return "B2 protocol not supported";
-	case 0x3003: 
-	   return "B3 protocol not supported";
-	case 0x3004: 
-	   return "B1 protocol parameter not supported";
-	case 0x3005: 
-	   return "B2 protocol parameter not supported";
-	case 0x3006: 
-	   return "B3 protocol parameter not supported";
-	case 0x3007: 
-	   return "B protocol combination not supported";
-	case 0x3008: 
-	   return "NCPI not supported";
-	case 0x3009: 
-	   return "CIP Value unknown";
-	case 0x300A: 
-	   return "Flags not supported (reserved bits)";
-	case 0x300B: 
-	   return "Facility not supported";
-	case 0x300C: 
-	   return "Data length not supported by current protocol";
-	case 0x300D: 
-	   return "Reset procedure not supported by current protocol";
+		return "B1 protocol not supported";
+	case 0x3002:
+		return "B2 protocol not supported";
+	case 0x3003:
+		return "B3 protocol not supported";
+	case 0x3004:
+		return "B1 protocol parameter not supported";
+	case 0x3005:
+		return "B2 protocol parameter not supported";
+	case 0x3006:
+		return "B3 protocol parameter not supported";
+	case 0x3007:
+		return "B protocol combination not supported";
+	case 0x3008:
+		return "NCPI not supported";
+	case 0x3009:
+		return "CIP Value unknown";
+	case 0x300A:
+		return "Flags not supported (reserved bits)";
+	case 0x300B:
+		return "Facility not supported";
+	case 0x300C:
+		return "Data length not supported by current protocol";
+	case 0x300D:
+		return "Reset procedure not supported by current protocol";
 
 /*-- informations about the clearing of a physical connection -----*/
-	case 0x3301: 
-	   return "Protocol error layer 1 (broken line or B-channel removed by signalling protocol)";
-	case 0x3302: 
-	   return "Protocol error layer 2";
-	case 0x3303: 
-	   return "Protocol error layer 3";
-	case 0x3304: 
-	   return "Another application got that call";
+	case 0x3301:
+		return "Protocol error layer 1 (broken line or B-channel removed by signalling protocol)";
+	case 0x3302:
+		return "Protocol error layer 2";
+	case 0x3303:
+		return "Protocol error layer 3";
+	case 0x3304:
+		return "Another application got that call";
 /*-- T.30 specific reasons -----*/
-	case 0x3311: 
-	   return "Connecting not successful (remote station is no FAX G3 machine)";
-	case 0x3312: 
-	   return "Connecting not successful (training error)";
-	case 0x3313: 
-	   return "Disconnected before transfer (remote station does not support transfer mode, e.g. resolution)";
-	case 0x3314: 
-	   return "Disconnected during transfer (remote abort)";
-	case 0x3315: 
-	   return "Disconnected during transfer (remote procedure error, e.g. unsuccessful repetition of T.30 commands)";
-	case 0x3316: 
-	   return "Disconnected during transfer (local tx data underrun)";
-	case 0x3317: 
-	   return "Disconnected during transfer (local rx data overflow)";
-	case 0x3318: 
-	   return "Disconnected during transfer (local abort)";
-	case 0x3319: 
-	   return "Illegal parameter coding (e.g. SFF coding error)";
+	case 0x3311:
+		return "Connecting not successful (remote station is no FAX G3 machine)";
+	case 0x3312:
+		return "Connecting not successful (training error)";
+	case 0x3313:
+		return "Disconnected before transfer (remote station does not support transfer mode, e.g. resolution)";
+	case 0x3314:
+		return "Disconnected during transfer (remote abort)";
+	case 0x3315:
+		return "Disconnected during transfer (remote procedure error, e.g. unsuccessful repetition of T.30 commands)";
+	case 0x3316:
+		return "Disconnected during transfer (local tx data underrun)";
+	case 0x3317:
+		return "Disconnected during transfer (local rx data overflow)";
+	case 0x3318:
+		return "Disconnected during transfer (local abort)";
+	case 0x3319:
+		return "Illegal parameter coding (e.g. SFF coding error)";
 
 /*-- disconnect causes from the network according to ETS 300 102-1/Q.931 -----*/
 	case 0x3481: return "Unallocated (unassigned) number";
 	case 0x3482: return "No route to specified transit network";
 	case 0x3483: return "No route to destination";
 	case 0x3486: return "Channel unacceptable";
-	case 0x3487: 
-	   return "Call awarded and being delivered in an established channel";
+	case 0x3487:
+		return "Call awarded and being delivered in an established channel";
 	case 0x3490: return "Normal call clearing";
 	case 0x3491: return "User busy";
 	case 0x3492: return "No user responding";
@@ -217,7 +217,7 @@ char *capi_info2str(u16 reason)
 	case 0x34FF: return "Interworking, unspecified";
 
 	default: return "No additional information";
-    }
+	}
 }
 #endif
 
@@ -235,169 +235,169 @@ typedef struct {
 
 static _cdef cdef[] =
 {
-    /*00 */ 
- {_CEND},
-    /*01 */ 
- {_CEND},
-    /*02 */ 
- {_CEND},
-    /*03 */ 
- {_CDWORD, offsetof(_cmsg, adr.adrController)},
-    /*04 */ 
- {_CMSTRUCT, offsetof(_cmsg, AdditionalInfo)},
-    /*05 */ 
- {_CSTRUCT, offsetof(_cmsg, B1configuration)},
-    /*06 */ 
- {_CWORD, offsetof(_cmsg, B1protocol)},
-    /*07 */ 
- {_CSTRUCT, offsetof(_cmsg, B2configuration)},
-    /*08 */ 
- {_CWORD, offsetof(_cmsg, B2protocol)},
-    /*09 */ 
- {_CSTRUCT, offsetof(_cmsg, B3configuration)},
-    /*0a */ 
- {_CWORD, offsetof(_cmsg, B3protocol)},
-    /*0b */ 
- {_CSTRUCT, offsetof(_cmsg, BC)},
-    /*0c */ 
- {_CSTRUCT, offsetof(_cmsg, BChannelinformation)},
-    /*0d */ 
- {_CMSTRUCT, offsetof(_cmsg, BProtocol)},
-    /*0e */ 
- {_CSTRUCT, offsetof(_cmsg, CalledPartyNumber)},
-    /*0f */ 
- {_CSTRUCT, offsetof(_cmsg, CalledPartySubaddress)},
-    /*10 */ 
- {_CSTRUCT, offsetof(_cmsg, CallingPartyNumber)},
-    /*11 */ 
- {_CSTRUCT, offsetof(_cmsg, CallingPartySubaddress)},
-    /*12 */ 
- {_CDWORD, offsetof(_cmsg, CIPmask)},
-    /*13 */ 
- {_CDWORD, offsetof(_cmsg, CIPmask2)},
-    /*14 */ 
- {_CWORD, offsetof(_cmsg, CIPValue)},
-    /*15 */ 
- {_CDWORD, offsetof(_cmsg, Class)},
-    /*16 */ 
- {_CSTRUCT, offsetof(_cmsg, ConnectedNumber)},
-    /*17 */ 
- {_CSTRUCT, offsetof(_cmsg, ConnectedSubaddress)},
-    /*18 */ 
- {_CDWORD, offsetof(_cmsg, Data)},
-    /*19 */ 
- {_CWORD, offsetof(_cmsg, DataHandle)},
-    /*1a */ 
- {_CWORD, offsetof(_cmsg, DataLength)},
-    /*1b */ 
- {_CSTRUCT, offsetof(_cmsg, FacilityConfirmationParameter)},
-    /*1c */ 
- {_CSTRUCT, offsetof(_cmsg, Facilitydataarray)},
-    /*1d */ 
- {_CSTRUCT, offsetof(_cmsg, FacilityIndicationParameter)},
-    /*1e */ 
- {_CSTRUCT, offsetof(_cmsg, FacilityRequestParameter)},
-    /*1f */ 
- {_CWORD, offsetof(_cmsg, FacilitySelector)},
-    /*20 */ 
- {_CWORD, offsetof(_cmsg, Flags)},
-    /*21 */ 
- {_CDWORD, offsetof(_cmsg, Function)},
-    /*22 */ 
- {_CSTRUCT, offsetof(_cmsg, HLC)},
-    /*23 */ 
- {_CWORD, offsetof(_cmsg, Info)},
-    /*24 */ 
- {_CSTRUCT, offsetof(_cmsg, InfoElement)},
-    /*25 */ 
- {_CDWORD, offsetof(_cmsg, InfoMask)},
-    /*26 */ 
- {_CWORD, offsetof(_cmsg, InfoNumber)},
-    /*27 */ 
- {_CSTRUCT, offsetof(_cmsg, Keypadfacility)},
-    /*28 */ 
- {_CSTRUCT, offsetof(_cmsg, LLC)},
-    /*29 */ 
- {_CSTRUCT, offsetof(_cmsg, ManuData)},
-    /*2a */ 
- {_CDWORD, offsetof(_cmsg, ManuID)},
-    /*2b */ 
- {_CSTRUCT, offsetof(_cmsg, NCPI)},
-    /*2c */ 
- {_CWORD, offsetof(_cmsg, Reason)},
-    /*2d */ 
- {_CWORD, offsetof(_cmsg, Reason_B3)},
-    /*2e */ 
- {_CWORD, offsetof(_cmsg, Reject)},
-    /*2f */ 
- {_CSTRUCT, offsetof(_cmsg, Useruserdata)}
+	/*00 */
+	{_CEND},
+	/*01 */
+	{_CEND},
+	/*02 */
+	{_CEND},
+	/*03 */
+	{_CDWORD, offsetof(_cmsg, adr.adrController)},
+	/*04 */
+	{_CMSTRUCT, offsetof(_cmsg, AdditionalInfo)},
+	/*05 */
+	{_CSTRUCT, offsetof(_cmsg, B1configuration)},
+	/*06 */
+	{_CWORD, offsetof(_cmsg, B1protocol)},
+	/*07 */
+	{_CSTRUCT, offsetof(_cmsg, B2configuration)},
+	/*08 */
+	{_CWORD, offsetof(_cmsg, B2protocol)},
+	/*09 */
+	{_CSTRUCT, offsetof(_cmsg, B3configuration)},
+	/*0a */
+	{_CWORD, offsetof(_cmsg, B3protocol)},
+	/*0b */
+	{_CSTRUCT, offsetof(_cmsg, BC)},
+	/*0c */
+	{_CSTRUCT, offsetof(_cmsg, BChannelinformation)},
+	/*0d */
+	{_CMSTRUCT, offsetof(_cmsg, BProtocol)},
+	/*0e */
+	{_CSTRUCT, offsetof(_cmsg, CalledPartyNumber)},
+	/*0f */
+	{_CSTRUCT, offsetof(_cmsg, CalledPartySubaddress)},
+	/*10 */
+	{_CSTRUCT, offsetof(_cmsg, CallingPartyNumber)},
+	/*11 */
+	{_CSTRUCT, offsetof(_cmsg, CallingPartySubaddress)},
+	/*12 */
+	{_CDWORD, offsetof(_cmsg, CIPmask)},
+	/*13 */
+	{_CDWORD, offsetof(_cmsg, CIPmask2)},
+	/*14 */
+	{_CWORD, offsetof(_cmsg, CIPValue)},
+	/*15 */
+	{_CDWORD, offsetof(_cmsg, Class)},
+	/*16 */
+	{_CSTRUCT, offsetof(_cmsg, ConnectedNumber)},
+	/*17 */
+	{_CSTRUCT, offsetof(_cmsg, ConnectedSubaddress)},
+	/*18 */
+	{_CDWORD, offsetof(_cmsg, Data)},
+	/*19 */
+	{_CWORD, offsetof(_cmsg, DataHandle)},
+	/*1a */
+	{_CWORD, offsetof(_cmsg, DataLength)},
+	/*1b */
+	{_CSTRUCT, offsetof(_cmsg, FacilityConfirmationParameter)},
+	/*1c */
+	{_CSTRUCT, offsetof(_cmsg, Facilitydataarray)},
+	/*1d */
+	{_CSTRUCT, offsetof(_cmsg, FacilityIndicationParameter)},
+	/*1e */
+	{_CSTRUCT, offsetof(_cmsg, FacilityRequestParameter)},
+	/*1f */
+	{_CWORD, offsetof(_cmsg, FacilitySelector)},
+	/*20 */
+	{_CWORD, offsetof(_cmsg, Flags)},
+	/*21 */
+	{_CDWORD, offsetof(_cmsg, Function)},
+	/*22 */
+	{_CSTRUCT, offsetof(_cmsg, HLC)},
+	/*23 */
+	{_CWORD, offsetof(_cmsg, Info)},
+	/*24 */
+	{_CSTRUCT, offsetof(_cmsg, InfoElement)},
+	/*25 */
+	{_CDWORD, offsetof(_cmsg, InfoMask)},
+	/*26 */
+	{_CWORD, offsetof(_cmsg, InfoNumber)},
+	/*27 */
+	{_CSTRUCT, offsetof(_cmsg, Keypadfacility)},
+	/*28 */
+	{_CSTRUCT, offsetof(_cmsg, LLC)},
+	/*29 */
+	{_CSTRUCT, offsetof(_cmsg, ManuData)},
+	/*2a */
+	{_CDWORD, offsetof(_cmsg, ManuID)},
+	/*2b */
+	{_CSTRUCT, offsetof(_cmsg, NCPI)},
+	/*2c */
+	{_CWORD, offsetof(_cmsg, Reason)},
+	/*2d */
+	{_CWORD, offsetof(_cmsg, Reason_B3)},
+	/*2e */
+	{_CWORD, offsetof(_cmsg, Reject)},
+	/*2f */
+	{_CSTRUCT, offsetof(_cmsg, Useruserdata)}
 };
 
 static unsigned char *cpars[] =
 {
-    /* ALERT_REQ */ [0x01] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
-    /* CONNECT_REQ */ [0x02] = "\x03\x14\x0e\x10\x0f\x11\x0d\x06\x08\x0a\x05\x07\x09\x01\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
-    /* DISCONNECT_REQ */ [0x04] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
-    /* LISTEN_REQ */ [0x05] = "\x03\x25\x12\x13\x10\x11\x01",
-    /* INFO_REQ */ [0x08] = "\x03\x0e\x04\x0c\x27\x2f\x1c\x01\x01",
-    /* FACILITY_REQ */ [0x09] = "\x03\x1f\x1e\x01",
-    /* SELECT_B_PROTOCOL_REQ */ [0x0a] = "\x03\x0d\x06\x08\x0a\x05\x07\x09\x01\x01",
-    /* CONNECT_B3_REQ */ [0x0b] = "\x03\x2b\x01",
-    /* DISCONNECT_B3_REQ */ [0x0d] = "\x03\x2b\x01",
-    /* DATA_B3_REQ */ [0x0f] = "\x03\x18\x1a\x19\x20\x01",
-    /* RESET_B3_REQ */ [0x10] = "\x03\x2b\x01",
-    /* ALERT_CONF */ [0x13] = "\x03\x23\x01",
-    /* CONNECT_CONF */ [0x14] = "\x03\x23\x01",
-    /* DISCONNECT_CONF */ [0x16] = "\x03\x23\x01",
-    /* LISTEN_CONF */ [0x17] = "\x03\x23\x01",
-    /* MANUFACTURER_REQ */ [0x18] = "\x03\x2a\x15\x21\x29\x01",
-    /* INFO_CONF */ [0x1a] = "\x03\x23\x01",
-    /* FACILITY_CONF */ [0x1b] = "\x03\x23\x1f\x1b\x01",
-    /* SELECT_B_PROTOCOL_CONF */ [0x1c] = "\x03\x23\x01",
-    /* CONNECT_B3_CONF */ [0x1d] = "\x03\x23\x01",
-    /* DISCONNECT_B3_CONF */ [0x1f] = "\x03\x23\x01",
-    /* DATA_B3_CONF */ [0x21] = "\x03\x19\x23\x01",
-    /* RESET_B3_CONF */ [0x22] = "\x03\x23\x01",
-    /* CONNECT_IND */ [0x26] = "\x03\x14\x0e\x10\x0f\x11\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
-    /* CONNECT_ACTIVE_IND */ [0x27] = "\x03\x16\x17\x28\x01",
-    /* DISCONNECT_IND */ [0x28] = "\x03\x2c\x01",
-    /* MANUFACTURER_CONF */ [0x2a] = "\x03\x2a\x15\x21\x29\x01",
-    /* INFO_IND */ [0x2c] = "\x03\x26\x24\x01",
-    /* FACILITY_IND */ [0x2d] = "\x03\x1f\x1d\x01",
-    /* CONNECT_B3_IND */ [0x2f] = "\x03\x2b\x01",
-    /* CONNECT_B3_ACTIVE_IND */ [0x30] = "\x03\x2b\x01",
-    /* DISCONNECT_B3_IND */ [0x31] = "\x03\x2d\x2b\x01",
-    /* DATA_B3_IND */ [0x33] = "\x03\x18\x1a\x19\x20\x01",
-    /* RESET_B3_IND */ [0x34] = "\x03\x2b\x01",
-    /* CONNECT_B3_T90_ACTIVE_IND */ [0x35] = "\x03\x2b\x01",
-    /* CONNECT_RESP */ [0x38] = "\x03\x2e\x0d\x06\x08\x0a\x05\x07\x09\x01\x16\x17\x28\x04\x0c\x27\x2f\x1c\x01\x01",
-    /* CONNECT_ACTIVE_RESP */ [0x39] = "\x03\x01",
-    /* DISCONNECT_RESP */ [0x3a] = "\x03\x01",
-    /* MANUFACTURER_IND */ [0x3c] = "\x03\x2a\x15\x21\x29\x01",
-    /* INFO_RESP */ [0x3e] = "\x03\x01",
-    /* FACILITY_RESP */ [0x3f] = "\x03\x1f\x01",
-    /* CONNECT_B3_RESP */ [0x41] = "\x03\x2e\x2b\x01",
-    /* CONNECT_B3_ACTIVE_RESP */ [0x42] = "\x03\x01",
-    /* DISCONNECT_B3_RESP */ [0x43] = "\x03\x01",
-    /* DATA_B3_RESP */ [0x45] = "\x03\x19\x01",
-    /* RESET_B3_RESP */ [0x46] = "\x03\x01",
-    /* CONNECT_B3_T90_ACTIVE_RESP */ [0x47] = "\x03\x01",
-    /* MANUFACTURER_RESP */ [0x4e] = "\x03\x2a\x15\x21\x29\x01",
+	/* ALERT_REQ */ [0x01] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
+	/* CONNECT_REQ */ [0x02] = "\x03\x14\x0e\x10\x0f\x11\x0d\x06\x08\x0a\x05\x07\x09\x01\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
+	/* DISCONNECT_REQ */ [0x04] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
+	/* LISTEN_REQ */ [0x05] = "\x03\x25\x12\x13\x10\x11\x01",
+	/* INFO_REQ */ [0x08] = "\x03\x0e\x04\x0c\x27\x2f\x1c\x01\x01",
+	/* FACILITY_REQ */ [0x09] = "\x03\x1f\x1e\x01",
+	/* SELECT_B_PROTOCOL_REQ */ [0x0a] = "\x03\x0d\x06\x08\x0a\x05\x07\x09\x01\x01",
+	/* CONNECT_B3_REQ */ [0x0b] = "\x03\x2b\x01",
+	/* DISCONNECT_B3_REQ */ [0x0d] = "\x03\x2b\x01",
+	/* DATA_B3_REQ */ [0x0f] = "\x03\x18\x1a\x19\x20\x01",
+	/* RESET_B3_REQ */ [0x10] = "\x03\x2b\x01",
+	/* ALERT_CONF */ [0x13] = "\x03\x23\x01",
+	/* CONNECT_CONF */ [0x14] = "\x03\x23\x01",
+	/* DISCONNECT_CONF */ [0x16] = "\x03\x23\x01",
+	/* LISTEN_CONF */ [0x17] = "\x03\x23\x01",
+	/* MANUFACTURER_REQ */ [0x18] = "\x03\x2a\x15\x21\x29\x01",
+	/* INFO_CONF */ [0x1a] = "\x03\x23\x01",
+	/* FACILITY_CONF */ [0x1b] = "\x03\x23\x1f\x1b\x01",
+	/* SELECT_B_PROTOCOL_CONF */ [0x1c] = "\x03\x23\x01",
+	/* CONNECT_B3_CONF */ [0x1d] = "\x03\x23\x01",
+	/* DISCONNECT_B3_CONF */ [0x1f] = "\x03\x23\x01",
+	/* DATA_B3_CONF */ [0x21] = "\x03\x19\x23\x01",
+	/* RESET_B3_CONF */ [0x22] = "\x03\x23\x01",
+	/* CONNECT_IND */ [0x26] = "\x03\x14\x0e\x10\x0f\x11\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
+	/* CONNECT_ACTIVE_IND */ [0x27] = "\x03\x16\x17\x28\x01",
+	/* DISCONNECT_IND */ [0x28] = "\x03\x2c\x01",
+	/* MANUFACTURER_CONF */ [0x2a] = "\x03\x2a\x15\x21\x29\x01",
+	/* INFO_IND */ [0x2c] = "\x03\x26\x24\x01",
+	/* FACILITY_IND */ [0x2d] = "\x03\x1f\x1d\x01",
+	/* CONNECT_B3_IND */ [0x2f] = "\x03\x2b\x01",
+	/* CONNECT_B3_ACTIVE_IND */ [0x30] = "\x03\x2b\x01",
+	/* DISCONNECT_B3_IND */ [0x31] = "\x03\x2d\x2b\x01",
+	/* DATA_B3_IND */ [0x33] = "\x03\x18\x1a\x19\x20\x01",
+	/* RESET_B3_IND */ [0x34] = "\x03\x2b\x01",
+	/* CONNECT_B3_T90_ACTIVE_IND */ [0x35] = "\x03\x2b\x01",
+	/* CONNECT_RESP */ [0x38] = "\x03\x2e\x0d\x06\x08\x0a\x05\x07\x09\x01\x16\x17\x28\x04\x0c\x27\x2f\x1c\x01\x01",
+	/* CONNECT_ACTIVE_RESP */ [0x39] = "\x03\x01",
+	/* DISCONNECT_RESP */ [0x3a] = "\x03\x01",
+	/* MANUFACTURER_IND */ [0x3c] = "\x03\x2a\x15\x21\x29\x01",
+	/* INFO_RESP */ [0x3e] = "\x03\x01",
+	/* FACILITY_RESP */ [0x3f] = "\x03\x1f\x01",
+	/* CONNECT_B3_RESP */ [0x41] = "\x03\x2e\x2b\x01",
+	/* CONNECT_B3_ACTIVE_RESP */ [0x42] = "\x03\x01",
+	/* DISCONNECT_B3_RESP */ [0x43] = "\x03\x01",
+	/* DATA_B3_RESP */ [0x45] = "\x03\x19\x01",
+	/* RESET_B3_RESP */ [0x46] = "\x03\x01",
+	/* CONNECT_B3_T90_ACTIVE_RESP */ [0x47] = "\x03\x01",
+	/* MANUFACTURER_RESP */ [0x4e] = "\x03\x2a\x15\x21\x29\x01",
 };
 
 /*-------------------------------------------------------*/
 
-#define byteTLcpy(x,y)        *(u8 *)(x)=*(u8 *)(y);
-#define wordTLcpy(x,y)        *(u16 *)(x)=*(u16 *)(y);
-#define dwordTLcpy(x,y)       memcpy(x,y,4);
-#define structTLcpy(x,y,l)    memcpy (x,y,l)
-#define structTLcpyovl(x,y,l) memmove (x,y,l)
+#define byteTLcpy(x, y)         *(u8 *)(x) = *(u8 *)(y);
+#define wordTLcpy(x, y)         *(u16 *)(x) = *(u16 *)(y);
+#define dwordTLcpy(x, y)        memcpy(x, y, 4);
+#define structTLcpy(x, y, l)    memcpy(x, y, l)
+#define structTLcpyovl(x, y, l) memmove(x, y, l)
 
-#define byteTRcpy(x,y)        *(u8 *)(y)=*(u8 *)(x);
-#define wordTRcpy(x,y)        *(u16 *)(y)=*(u16 *)(x);
-#define dwordTRcpy(x,y)       memcpy(y,x,4);
-#define structTRcpy(x,y,l)    memcpy (y,x,l)
-#define structTRcpyovl(x,y,l) memmove (y,x,l)
+#define byteTRcpy(x, y)         *(u8 *)(y) = *(u8 *)(x);
+#define wordTRcpy(x, y)         *(u16 *)(y) = *(u16 *)(x);
+#define dwordTRcpy(x, y)        memcpy(y, x, 4);
+#define structTRcpy(x, y, l)    memcpy(y, x, l)
+#define structTRcpyovl(x, y, l) memmove(y, x, l)
 
 /*-------------------------------------------------------*/
 static unsigned command_2_index(unsigned c, unsigned sc)
@@ -414,9 +414,9 @@ static unsigned command_2_index(unsigned c, unsigned sc)
 
 /*-------------------------------------------------------*/
 #define TYP (cdef[cmsg->par[cmsg->p]].typ)
-#define OFF (((u8 *)cmsg)+cdef[cmsg->par[cmsg->p]].off)
+#define OFF (((u8 *)cmsg) + cdef[cmsg->par[cmsg->p]].off)
 
-static void jumpcstruct(_cmsg * cmsg)
+static void jumpcstruct(_cmsg *cmsg)
 {
 	unsigned layer;
 	for (cmsg->p++, layer = 1; layer;) {
@@ -433,7 +433,7 @@ static void jumpcstruct(_cmsg * cmsg)
 	}
 }
 /*-------------------------------------------------------*/
-static void pars_2_message(_cmsg * cmsg)
+static void pars_2_message(_cmsg *cmsg)
 {
 
 	for (; TYP != _CEND; cmsg->p++) {
@@ -499,7 +499,7 @@ static void pars_2_message(_cmsg * cmsg)
  * Return value: 0 for success
  */
 
-unsigned capi_cmsg2message(_cmsg * cmsg, u8 * msg)
+unsigned capi_cmsg2message(_cmsg *cmsg, u8 *msg)
 {
 	cmsg->m = msg;
 	cmsg->l = 8;
@@ -518,7 +518,7 @@ unsigned capi_cmsg2message(_cmsg * cmsg, u8 * msg)
 }
 
 /*-------------------------------------------------------*/
-static void message_2_pars(_cmsg * cmsg)
+static void message_2_pars(_cmsg *cmsg)
 {
 	for (; TYP != _CEND; cmsg->p++) {
 
@@ -569,7 +569,7 @@ static void message_2_pars(_cmsg * cmsg)
  * Return value: 0 for success
  */
 
-unsigned capi_message2cmsg(_cmsg * cmsg, u8 * msg)
+unsigned capi_message2cmsg(_cmsg *cmsg, u8 *msg)
 {
 	memset(cmsg, 0, sizeof(_cmsg));
 	cmsg->m = msg;
@@ -600,7 +600,7 @@ unsigned capi_message2cmsg(_cmsg * cmsg, u8 * msg)
  * Return value: 0 for success
  */
 
-unsigned capi_cmsg_header(_cmsg * cmsg, u16 _ApplId,
+unsigned capi_cmsg_header(_cmsg *cmsg, u16 _ApplId,
 			  u8 _Command, u8 _Subcommand,
 			  u16 _Messagenumber, u32 _Controller)
 {
@@ -689,54 +689,54 @@ char *capi_cmd2str(u8 cmd, u8 subcmd)
 
 static char *pnames[] =
 {
-    /*00 */ NULL,
-    /*01 */ NULL,
-    /*02 */ NULL,
-    /*03 */ "Controller/PLCI/NCCI",
-    /*04 */ "AdditionalInfo",
-    /*05 */ "B1configuration",
-    /*06 */ "B1protocol",
-    /*07 */ "B2configuration",
-    /*08 */ "B2protocol",
-    /*09 */ "B3configuration",
-    /*0a */ "B3protocol",
-    /*0b */ "BC",
-    /*0c */ "BChannelinformation",
-    /*0d */ "BProtocol",
-    /*0e */ "CalledPartyNumber",
-    /*0f */ "CalledPartySubaddress",
-    /*10 */ "CallingPartyNumber",
-    /*11 */ "CallingPartySubaddress",
-    /*12 */ "CIPmask",
-    /*13 */ "CIPmask2",
-    /*14 */ "CIPValue",
-    /*15 */ "Class",
-    /*16 */ "ConnectedNumber",
-    /*17 */ "ConnectedSubaddress",
-    /*18 */ "Data32",
-    /*19 */ "DataHandle",
-    /*1a */ "DataLength",
-    /*1b */ "FacilityConfirmationParameter",
-    /*1c */ "Facilitydataarray",
-    /*1d */ "FacilityIndicationParameter",
-    /*1e */ "FacilityRequestParameter",
-    /*1f */ "FacilitySelector",
-    /*20 */ "Flags",
-    /*21 */ "Function",
-    /*22 */ "HLC",
-    /*23 */ "Info",
-    /*24 */ "InfoElement",
-    /*25 */ "InfoMask",
-    /*26 */ "InfoNumber",
-    /*27 */ "Keypadfacility",
-    /*28 */ "LLC",
-    /*29 */ "ManuData",
-    /*2a */ "ManuID",
-    /*2b */ "NCPI",
-    /*2c */ "Reason",
-    /*2d */ "Reason_B3",
-    /*2e */ "Reject",
-    /*2f */ "Useruserdata"
+	/*00 */ NULL,
+	/*01 */ NULL,
+	/*02 */ NULL,
+	/*03 */ "Controller/PLCI/NCCI",
+	/*04 */ "AdditionalInfo",
+	/*05 */ "B1configuration",
+	/*06 */ "B1protocol",
+	/*07 */ "B2configuration",
+	/*08 */ "B2protocol",
+	/*09 */ "B3configuration",
+	/*0a */ "B3protocol",
+	/*0b */ "BC",
+	/*0c */ "BChannelinformation",
+	/*0d */ "BProtocol",
+	/*0e */ "CalledPartyNumber",
+	/*0f */ "CalledPartySubaddress",
+	/*10 */ "CallingPartyNumber",
+	/*11 */ "CallingPartySubaddress",
+	/*12 */ "CIPmask",
+	/*13 */ "CIPmask2",
+	/*14 */ "CIPValue",
+	/*15 */ "Class",
+	/*16 */ "ConnectedNumber",
+	/*17 */ "ConnectedSubaddress",
+	/*18 */ "Data32",
+	/*19 */ "DataHandle",
+	/*1a */ "DataLength",
+	/*1b */ "FacilityConfirmationParameter",
+	/*1c */ "Facilitydataarray",
+	/*1d */ "FacilityIndicationParameter",
+	/*1e */ "FacilityRequestParameter",
+	/*1f */ "FacilitySelector",
+	/*20 */ "Flags",
+	/*21 */ "Function",
+	/*22 */ "HLC",
+	/*23 */ "Info",
+	/*24 */ "InfoElement",
+	/*25 */ "InfoMask",
+	/*26 */ "InfoNumber",
+	/*27 */ "Keypadfacility",
+	/*28 */ "LLC",
+	/*29 */ "ManuData",
+	/*2a */ "ManuID",
+	/*2b */ "NCPI",
+	/*2c */ "Reason",
+	/*2d */ "Reason_B3",
+	/*2e */ "Reject",
+	/*2f */ "Useruserdata"
 };
 
 
@@ -744,10 +744,10 @@ static char *pnames[] =
 #include <stdarg.h>
 
 /*-------------------------------------------------------*/
-static _cdebbuf *bufprint(_cdebbuf *cdb, char *fmt,...)
+static _cdebbuf *bufprint(_cdebbuf *cdb, char *fmt, ...)
 {
 	va_list f;
-	size_t n,r;
+	size_t n, r;
 
 	if (!cdb)
 		return NULL;
@@ -783,7 +783,7 @@ static _cdebbuf *bufprint(_cdebbuf *cdb, char *fmt,...)
 	return cdb;
 }
 
-static _cdebbuf *printstructlen(_cdebbuf *cdb, u8 * m, unsigned len)
+static _cdebbuf *printstructlen(_cdebbuf *cdb, u8 *m, unsigned len)
 {
 	unsigned hex = 0;
 
@@ -807,7 +807,7 @@ static _cdebbuf *printstructlen(_cdebbuf *cdb, u8 * m, unsigned len)
 	return cdb;
 }
 
-static _cdebbuf *printstruct(_cdebbuf *cdb, u8 * m)
+static _cdebbuf *printstruct(_cdebbuf *cdb, u8 *m)
 {
 	unsigned len;
 
@@ -940,7 +940,7 @@ void cdebbuf_free(_cdebbuf *cdb)
  * The returned buffer should be freed by a call to cdebbuf_free() after use.
  */
 
-_cdebbuf *capi_message2str(u8 * msg)
+_cdebbuf *capi_message2str(u8 *msg)
 {
 	_cdebbuf *cdb;
 	_cmsg	*cmsg;
@@ -964,10 +964,10 @@ _cdebbuf *capi_message2str(u8 * msg)
 	cmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];
 
 	cdb = bufprint(cdb, "%-26s ID=%03d #0x%04x LEN=%04d\n",
-		 mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
-		 ((unsigned short *) msg)[1],
-		 ((unsigned short *) msg)[3],
-		 ((unsigned short *) msg)[0]);
+		       mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
+		       ((unsigned short *) msg)[1],
+		       ((unsigned short *) msg)[3],
+		       ((unsigned short *) msg)[0]);
 
 	cdb = protocol_message_2_pars(cdb, cmsg, 1);
 	if (unlikely(cmsg != g_cmsg))
@@ -986,7 +986,7 @@ _cdebbuf *capi_message2str(u8 * msg)
  * The returned buffer should be freed by a call to cdebbuf_free() after use.
  */
 
-_cdebbuf *capi_cmsg2str(_cmsg * cmsg)
+_cdebbuf *capi_cmsg2str(_cmsg *cmsg)
 {
 	_cdebbuf *cdb;
 
@@ -998,17 +998,17 @@ _cdebbuf *capi_cmsg2str(_cmsg * cmsg)
 	cmsg->l = 8;
 	cmsg->p = 0;
 	cdb = bufprint(cdb, "%s ID=%03d #0x%04x LEN=%04d\n",
-		 mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
-		 ((u16 *) cmsg->m)[1],
-		 ((u16 *) cmsg->m)[3],
-		 ((u16 *) cmsg->m)[0]);
+		       mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
+		       ((u16 *) cmsg->m)[1],
+		       ((u16 *) cmsg->m)[3],
+		       ((u16 *) cmsg->m)[0]);
 	cdb = protocol_message_2_pars(cdb, cmsg, 1);
 	return cdb;
 }
 
 int __init cdebug_init(void)
 {
-	g_cmsg= kmalloc(sizeof(_cmsg), GFP_KERNEL);
+	g_cmsg = kmalloc(sizeof(_cmsg), GFP_KERNEL);
 	if (!g_cmsg)
 		return -ENOMEM;
 	g_debbuf = kmalloc(sizeof(_cdebbuf), GFP_KERNEL);
@@ -1041,12 +1041,12 @@ void __exit cdebug_exit(void)
 
 static _cdebbuf g_debbuf = {"CONFIG_CAPI_TRACE not enabled", NULL, 0, 0};
 
-_cdebbuf *capi_message2str(u8 * msg)
+_cdebbuf *capi_message2str(u8 *msg)
 {
 	return &g_debbuf;
 }
 
-_cdebbuf *capi_cmsg2str(_cmsg * cmsg)
+_cdebbuf *capi_cmsg2str(_cmsg *cmsg)
 {
 	return &g_debbuf;
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 26626eead828..03c469e4451f 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -18,6 +18,7 @@
 #include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/isdn/capiutil.h>
+#include <linux/slab.h>
 
 /* from CAPI2.0 DDK AVM Berlin GmbH */
 

commit a419aef8b858a2bdb98df60336063d28df4b272f
Author: Joe Perches <joe@perches.com>
Date:   Tue Aug 18 11:18:35 2009 -0700

    trivial: remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 16f2e465e5f9..26626eead828 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -1019,7 +1019,7 @@ int __init cdebug_init(void)
 	if (!g_debbuf->buf) {
 		kfree(g_cmsg);
 		kfree(g_debbuf);
-		return -ENOMEM;;
+		return -ENOMEM;
 	}
 	g_debbuf->size = CDEBUG_GSIZE;
 	g_debbuf->buf[0] = 0;

commit 7d31acda9f8eaa27e2fd232712f7e1f3e9a79bdb
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Sun Jun 7 09:09:24 2009 +0000

    isdn: prevent NULL ptr Oops in capi_cmsg2str()
    
    The dereferencing of the private pointer cmsg->m in capi_cmsg2str() may
    cause an Oops in case of an error, which is particularly inconvenient
    as that function is typically used to format an error message. Add a
    NULL pointer check to avoid this.
    
    Impact: error handling improvement
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index c7c29022a23a..16f2e465e5f9 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -989,6 +989,8 @@ _cdebbuf *capi_cmsg2str(_cmsg * cmsg)
 {
 	_cdebbuf *cdb;
 
+	if (!cmsg->m)
+		return NULL;	/* no message */
 	cdb = cdebbuf_alloc();
 	if (!cdb)
 		return NULL;

commit 4793d15b25821003486bb11b54eaf2f3130ecacd
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Sun Jun 7 09:09:23 2009 +0000

    isdn: kerneldoc for capiutil.c
    
    Add kerneldoc comments for the exported funtions in capiutil.c.
    
    Impact: documentation
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 29419a8d31dc..c7c29022a23a 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -490,7 +490,14 @@ static void pars_2_message(_cmsg * cmsg)
 	}
 }
 
-/*-------------------------------------------------------*/
+/**
+ * capi_cmsg2message() - assemble CAPI 2.0 message from _cmsg structure
+ * @cmsg:	_cmsg structure
+ * @msg:	buffer for assembled message
+ *
+ * Return value: 0 for success
+ */
+
 unsigned capi_cmsg2message(_cmsg * cmsg, u8 * msg)
 {
 	cmsg->m = msg;
@@ -553,7 +560,14 @@ static void message_2_pars(_cmsg * cmsg)
 	}
 }
 
-/*-------------------------------------------------------*/
+/**
+ * capi_message2cmsg() - disassemble CAPI 2.0 message into _cmsg structure
+ * @cmsg:	_cmsg structure
+ * @msg:	buffer for assembled message
+ *
+ * Return value: 0 for success
+ */
+
 unsigned capi_message2cmsg(_cmsg * cmsg, u8 * msg)
 {
 	memset(cmsg, 0, sizeof(_cmsg));
@@ -573,7 +587,18 @@ unsigned capi_message2cmsg(_cmsg * cmsg, u8 * msg)
 	return 0;
 }
 
-/*-------------------------------------------------------*/
+/**
+ * capi_cmsg_header() - initialize header part of _cmsg structure
+ * @cmsg:	_cmsg structure
+ * @_ApplId:	ApplID field value
+ * @_Command:	Command field value
+ * @_Subcommand:	Subcommand field value
+ * @_Messagenumber:	Message Number field value
+ * @_Controller:	Controller/PLCI/NCCI field value
+ *
+ * Return value: 0 for success
+ */
+
 unsigned capi_cmsg_header(_cmsg * cmsg, u16 _ApplId,
 			  u8 _Command, u8 _Subcommand,
 			  u16 _Messagenumber, u32 _Controller)
@@ -641,6 +666,14 @@ static char *mnames[] =
 	[0x4e] = "MANUFACTURER_RESP"
 };
 
+/**
+ * capi_cmd2str() - convert CAPI 2.0 command/subcommand number to name
+ * @cmd:	command number
+ * @subcmd:	subcommand number
+ *
+ * Return value: static string, NULL if command/subcommand unknown
+ */
+
 char *capi_cmd2str(u8 cmd, u8 subcmd)
 {
 	return mnames[command_2_index(cmd, subcmd)];
@@ -879,6 +912,11 @@ static _cdebbuf *cdebbuf_alloc(void)
 	return cdb;
 }
 
+/**
+ * cdebbuf_free() - free CAPI debug buffer
+ * @cdb:	buffer to free
+ */
+
 void cdebbuf_free(_cdebbuf *cdb)
 {
 	if (likely(cdb == g_debbuf)) {
@@ -891,6 +929,16 @@ void cdebbuf_free(_cdebbuf *cdb)
 }
 
 
+/**
+ * capi_message2str() - format CAPI 2.0 message for printing
+ * @msg:	CAPI 2.0 message
+ *
+ * Allocates a CAPI debug buffer and fills it with a printable representation
+ * of the CAPI 2.0 message in @msg.
+ * Return value: allocated debug buffer, NULL on error
+ * The returned buffer should be freed by a call to cdebbuf_free() after use.
+ */
+
 _cdebbuf *capi_message2str(u8 * msg)
 {
 	_cdebbuf *cdb;
@@ -926,6 +974,17 @@ _cdebbuf *capi_message2str(u8 * msg)
 	return cdb;
 }
 
+/**
+ * capi_cmsg2str() - format _cmsg structure for printing
+ * @cmsg:	_cmsg structure
+ *
+ * Allocates a CAPI debug buffer and fills it with a printable representation
+ * of the CAPI 2.0 message stored in @cmsg by a previous call to
+ * capi_cmsg2message() or capi_message2cmsg().
+ * Return value: allocated debug buffer, NULL on error
+ * The returned buffer should be freed by a call to cdebbuf_free() after use.
+ */
+
 _cdebbuf *capi_cmsg2str(_cmsg * cmsg)
 {
 	_cdebbuf *cdb;

commit 066b2118976e6e7cc50eed39e2747c75343a23c4
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Wed May 14 23:30:06 2008 -0700

    isdn/capi: Return proper errnos on module init.
    
    cdebug_init() is called from kcapi_init() which is module
    initialization function, so it must return negative values on errors.
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Acked-by: Karsten Keil <kkeil@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index ebef4ce1b00c..29419a8d31dc 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -948,17 +948,17 @@ int __init cdebug_init(void)
 {
 	g_cmsg= kmalloc(sizeof(_cmsg), GFP_KERNEL);
 	if (!g_cmsg)
-		return ENOMEM;
+		return -ENOMEM;
 	g_debbuf = kmalloc(sizeof(_cdebbuf), GFP_KERNEL);
 	if (!g_debbuf) {
 		kfree(g_cmsg);
-		return ENOMEM;
+		return -ENOMEM;
 	}
 	g_debbuf->buf = kmalloc(CDEBUG_GSIZE, GFP_KERNEL);
 	if (!g_debbuf->buf) {
 		kfree(g_cmsg);
 		kfree(g_debbuf);
-		return ENOMEM;;
+		return -ENOMEM;;
 	}
 	g_debbuf->size = CDEBUG_GSIZE;
 	g_debbuf->buf[0] = 0;

commit 2f9e9b6db31d96fe4e8b519b8aab1ba172dd3ddf
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 02:14:37 2008 -0700

    capi: fix sparse warnings using integer as NULL pointer
    
    drivers/isdn/capi/kcapi.c:829:30: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/kcapi.c:838:27: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/kcapi.c:954:17: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/kcapi.c:1007:37: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/kcapi.c:1009:33: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capiutil.c:453:24: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capilib.c:47:30: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:353:29: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:369:15: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:486:48: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:515:46: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:541:47: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:692:47: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:699:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:704:14: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:943:53: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:948:32: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:969:42: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:989:48: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:1026:69: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:1028:19: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:1061:20: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:1529:37: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capi.c:1531:33: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:338:15: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:758:32: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:880:40: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:407:15: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:429:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:407:15: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:444:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:429:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:429:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:429:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:429:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:429:49: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:1664:61: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:1969:37: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:2294:37: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:2297:33: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:2338:37: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capidrv.c:2341:33: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capifs.c:192:37: warning: Using plain integer as NULL pointer
    drivers/isdn/capi/capifs.c:194:33: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index 22379b94e88f..ebef4ce1b00c 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -450,7 +450,7 @@ static void pars_2_message(_cmsg * cmsg)
 			cmsg->l += 4;
 			break;
 		case _CSTRUCT:
-			if (*(u8 **) OFF == 0) {
+			if (*(u8 **) OFF == NULL) {
 				*(cmsg->m + cmsg->l) = '\0';
 				cmsg->l++;
 			} else if (**(_cstruct *) OFF != 0xff) {

commit 3a3a51d1f2efe10090cd779a66c4b3c8f57eaf9f
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue May 8 00:32:33 2007 -0700

    make drivers/isdn/capi/capiutil.c:cdebbuf_alloc() static
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Karsten Keil <kkeil@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index ad1e2702c2d1..22379b94e88f 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -855,7 +855,7 @@ static _cdebbuf *g_debbuf;
 static u_long g_debbuf_lock;
 static _cmsg *g_cmsg;
 
-_cdebbuf *cdebbuf_alloc(void)
+static _cdebbuf *cdebbuf_alloc(void)
 {
 	_cdebbuf *cdb;
 
@@ -989,11 +989,6 @@ _cdebbuf *capi_cmsg2str(_cmsg * cmsg)
 	return &g_debbuf;
 }
 
-_cdebbuf *cdebbuf_alloc(void)
-{
-	return &g_debbuf;
-}
-
 void cdebbuf_free(_cdebbuf *cdb)
 {
 }
@@ -1009,7 +1004,6 @@ void __exit cdebug_exit(void)
 
 #endif
 
-EXPORT_SYMBOL(cdebbuf_alloc);
 EXPORT_SYMBOL(cdebbuf_free);
 EXPORT_SYMBOL(capi_cmsg2message);
 EXPORT_SYMBOL(capi_message2cmsg);

commit 17f0cd2f350b90b28301e27fe0e39f34bfe7e730
Author: Karsten Keil <kkeil@suse.de>
Date:   Wed Feb 28 20:13:50 2007 -0800

    [PATCH] Fix buffer overflow and races in capi debug functions
    
    The CAPI trace debug functions were using a fixed size buffer, which can be
    overflowed if wrong formatted CAPI messages were sent to the kernel capi
    layer.  The code was also not protected against multiple callers.  This fix
    bug 8028.
    
    Additionally the patch make the CAPI trace functions optional.
    
    Signed-off-by: Karsten Keil <kkeil@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index c1b21552fc03..ad1e2702c2d1 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -648,6 +648,9 @@ char *capi_cmd2str(u8 cmd, u8 subcmd)
 
 
 /*-------------------------------------------------------*/
+
+#ifdef CONFIG_CAPI_TRACE
+
 /*-------------------------------------------------------*/
 
 static char *pnames[] =
@@ -703,44 +706,77 @@ static char *pnames[] =
 };
 
 
-static char buf[8192];
-static char *p = NULL;
 
 #include <stdarg.h>
 
 /*-------------------------------------------------------*/
-static void bufprint(char *fmt,...)
+static _cdebbuf *bufprint(_cdebbuf *cdb, char *fmt,...)
 {
 	va_list f;
+	size_t n,r;
+
+	if (!cdb)
+		return NULL;
 	va_start(f, fmt);
-	vsprintf(p, fmt, f);
+	r = cdb->size - cdb->pos;
+	n = vsnprintf(cdb->p, r, fmt, f);
 	va_end(f);
-	p += strlen(p);
+	if (n >= r) {
+		/* truncated, need bigger buffer */
+		size_t ns = 2 * cdb->size;
+		u_char *nb;
+
+		while ((ns - cdb->pos) <= n)
+			ns *= 2;
+		nb = kmalloc(ns, GFP_ATOMIC);
+		if (!nb) {
+			cdebbuf_free(cdb);
+			return NULL;
+		}
+		memcpy(nb, cdb->buf, cdb->pos);
+		kfree(cdb->buf);
+		nb[cdb->pos] = 0;
+		cdb->buf = nb;
+		cdb->p = cdb->buf + cdb->pos;
+		cdb->size = ns;
+		va_start(f, fmt);
+		r = cdb->size - cdb->pos;
+		n = vsnprintf(cdb->p, r, fmt, f);
+		va_end(f);
+	}
+	cdb->p += n;
+	cdb->pos += n;
+	return cdb;
 }
 
-static void printstructlen(u8 * m, unsigned len)
+static _cdebbuf *printstructlen(_cdebbuf *cdb, u8 * m, unsigned len)
 {
 	unsigned hex = 0;
+
+	if (!cdb)
+		return NULL;
 	for (; len; len--, m++)
 		if (isalnum(*m) || *m == ' ') {
 			if (hex)
-				bufprint(">");
-			bufprint("%c", *m);
+				cdb = bufprint(cdb, ">");
+			cdb = bufprint(cdb, "%c", *m);
 			hex = 0;
 		} else {
 			if (!hex)
-				bufprint("<%02x", *m);
+				cdb = bufprint(cdb, "<%02x", *m);
 			else
-				bufprint(" %02x", *m);
+				cdb = bufprint(cdb, " %02x", *m);
 			hex = 1;
 		}
 	if (hex)
-		bufprint(">");
+		cdb = bufprint(cdb, ">");
+	return cdb;
 }
 
-static void printstruct(u8 * m)
+static _cdebbuf *printstruct(_cdebbuf *cdb, u8 * m)
 {
 	unsigned len;
+
 	if (m[0] != 0xff) {
 		len = m[0];
 		m += 1;
@@ -748,42 +784,45 @@ static void printstruct(u8 * m)
 		len = ((u16 *) (m + 1))[0];
 		m += 3;
 	}
-	printstructlen(m, len);
+	cdb = printstructlen(cdb, m, len);
+	return cdb;
 }
 
 /*-------------------------------------------------------*/
 #define NAME (pnames[cmsg->par[cmsg->p]])
 
-static void protocol_message_2_pars(_cmsg * cmsg, int level)
+static _cdebbuf *protocol_message_2_pars(_cdebbuf *cdb, _cmsg *cmsg, int level)
 {
 	for (; TYP != _CEND; cmsg->p++) {
 		int slen = 29 + 3 - level;
 		int i;
 
-		bufprint("  ");
+		if (!cdb)
+			return NULL;
+		cdb = bufprint(cdb, "  ");
 		for (i = 0; i < level - 1; i++)
-			bufprint(" ");
+			cdb = bufprint(cdb, " ");
 
 		switch (TYP) {
 		case _CBYTE:
-			bufprint("%-*s = 0x%x\n", slen, NAME, *(u8 *) (cmsg->m + cmsg->l));
+			cdb = bufprint(cdb, "%-*s = 0x%x\n", slen, NAME, *(u8 *) (cmsg->m + cmsg->l));
 			cmsg->l++;
 			break;
 		case _CWORD:
-			bufprint("%-*s = 0x%x\n", slen, NAME, *(u16 *) (cmsg->m + cmsg->l));
+			cdb = bufprint(cdb, "%-*s = 0x%x\n", slen, NAME, *(u16 *) (cmsg->m + cmsg->l));
 			cmsg->l += 2;
 			break;
 		case _CDWORD:
-			bufprint("%-*s = 0x%lx\n", slen, NAME, *(u32 *) (cmsg->m + cmsg->l));
+			cdb = bufprint(cdb, "%-*s = 0x%lx\n", slen, NAME, *(u32 *) (cmsg->m + cmsg->l));
 			cmsg->l += 4;
 			break;
 		case _CSTRUCT:
-			bufprint("%-*s = ", slen, NAME);
+			cdb = bufprint(cdb, "%-*s = ", slen, NAME);
 			if (cmsg->m[cmsg->l] == '\0')
-				bufprint("default");
+				cdb = bufprint(cdb, "default");
 			else
-				printstruct(cmsg->m + cmsg->l);
-			bufprint("\n");
+				cdb = printstruct(cdb, cmsg->m + cmsg->l);
+			cdb = bufprint(cdb, "\n");
 			if (cmsg->m[cmsg->l] != 0xff)
 				cmsg->l += 1 + cmsg->m[cmsg->l];
 			else
@@ -794,61 +833,184 @@ static void protocol_message_2_pars(_cmsg * cmsg, int level)
 		case _CMSTRUCT:
 /*----- Metastruktur 0 -----*/
 			if (cmsg->m[cmsg->l] == '\0') {
-				bufprint("%-*s = default\n", slen, NAME);
+				cdb = bufprint(cdb, "%-*s = default\n", slen, NAME);
 				cmsg->l++;
 				jumpcstruct(cmsg);
 			} else {
 				char *name = NAME;
 				unsigned _l = cmsg->l;
-				bufprint("%-*s\n", slen, name);
+				cdb = bufprint(cdb, "%-*s\n", slen, name);
 				cmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;
 				cmsg->p++;
-				protocol_message_2_pars(cmsg, level + 1);
+				cdb = protocol_message_2_pars(cdb, cmsg, level + 1);
 			}
 			break;
 		}
 	}
+	return cdb;
 }
 /*-------------------------------------------------------*/
-char *capi_message2str(u8 * msg)
+
+static _cdebbuf *g_debbuf;
+static u_long g_debbuf_lock;
+static _cmsg *g_cmsg;
+
+_cdebbuf *cdebbuf_alloc(void)
 {
+	_cdebbuf *cdb;
+
+	if (likely(!test_and_set_bit(1, &g_debbuf_lock))) {
+		cdb = g_debbuf;
+		goto init;
+	} else
+		cdb = kmalloc(sizeof(_cdebbuf), GFP_ATOMIC);
+	if (!cdb)
+		return NULL;
+	cdb->buf = kmalloc(CDEBUG_SIZE, GFP_ATOMIC);
+	if (!cdb->buf) {
+		kfree(cdb);
+		return NULL;
+	}
+	cdb->size = CDEBUG_SIZE;
+init:
+	cdb->buf[0] = 0;
+	cdb->p = cdb->buf;
+	cdb->pos = 0;
+	return cdb;
+}
 
-	_cmsg cmsg;
-	p = buf;
-	p[0] = 0;
+void cdebbuf_free(_cdebbuf *cdb)
+{
+	if (likely(cdb == g_debbuf)) {
+		test_and_clear_bit(1, &g_debbuf_lock);
+		return;
+	}
+	if (likely(cdb))
+		kfree(cdb->buf);
+	kfree(cdb);
+}
 
-	cmsg.m = msg;
-	cmsg.l = 8;
-	cmsg.p = 0;
-	byteTRcpy(cmsg.m + 4, &cmsg.Command);
-	byteTRcpy(cmsg.m + 5, &cmsg.Subcommand);
-	cmsg.par = cpars[command_2_index(cmsg.Command, cmsg.Subcommand)];
 
-	bufprint("%-26s ID=%03d #0x%04x LEN=%04d\n",
-		 mnames[command_2_index(cmsg.Command, cmsg.Subcommand)],
+_cdebbuf *capi_message2str(u8 * msg)
+{
+	_cdebbuf *cdb;
+	_cmsg	*cmsg;
+
+	cdb = cdebbuf_alloc();
+	if (unlikely(!cdb))
+		return NULL;
+	if (likely(cdb == g_debbuf))
+		cmsg = g_cmsg;
+	else
+		cmsg = kmalloc(sizeof(_cmsg), GFP_ATOMIC);
+	if (unlikely(!cmsg)) {
+		cdebbuf_free(cdb);
+		return NULL;
+	}
+	cmsg->m = msg;
+	cmsg->l = 8;
+	cmsg->p = 0;
+	byteTRcpy(cmsg->m + 4, &cmsg->Command);
+	byteTRcpy(cmsg->m + 5, &cmsg->Subcommand);
+	cmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];
+
+	cdb = bufprint(cdb, "%-26s ID=%03d #0x%04x LEN=%04d\n",
+		 mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
 		 ((unsigned short *) msg)[1],
 		 ((unsigned short *) msg)[3],
 		 ((unsigned short *) msg)[0]);
 
-	protocol_message_2_pars(&cmsg, 1);
-	return buf;
+	cdb = protocol_message_2_pars(cdb, cmsg, 1);
+	if (unlikely(cmsg != g_cmsg))
+		kfree(cmsg);
+	return cdb;
 }
 
-char *capi_cmsg2str(_cmsg * cmsg)
+_cdebbuf *capi_cmsg2str(_cmsg * cmsg)
 {
-	p = buf;
-	p[0] = 0;
+	_cdebbuf *cdb;
+
+	cdb = cdebbuf_alloc();
+	if (!cdb)
+		return NULL;
 	cmsg->l = 8;
 	cmsg->p = 0;
-	bufprint("%s ID=%03d #0x%04x LEN=%04d\n",
+	cdb = bufprint(cdb, "%s ID=%03d #0x%04x LEN=%04d\n",
 		 mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
 		 ((u16 *) cmsg->m)[1],
 		 ((u16 *) cmsg->m)[3],
 		 ((u16 *) cmsg->m)[0]);
-	protocol_message_2_pars(cmsg, 1);
-	return buf;
+	cdb = protocol_message_2_pars(cdb, cmsg, 1);
+	return cdb;
 }
 
+int __init cdebug_init(void)
+{
+	g_cmsg= kmalloc(sizeof(_cmsg), GFP_KERNEL);
+	if (!g_cmsg)
+		return ENOMEM;
+	g_debbuf = kmalloc(sizeof(_cdebbuf), GFP_KERNEL);
+	if (!g_debbuf) {
+		kfree(g_cmsg);
+		return ENOMEM;
+	}
+	g_debbuf->buf = kmalloc(CDEBUG_GSIZE, GFP_KERNEL);
+	if (!g_debbuf->buf) {
+		kfree(g_cmsg);
+		kfree(g_debbuf);
+		return ENOMEM;;
+	}
+	g_debbuf->size = CDEBUG_GSIZE;
+	g_debbuf->buf[0] = 0;
+	g_debbuf->p = g_debbuf->buf;
+	g_debbuf->pos = 0;
+	return 0;
+}
+
+void __exit cdebug_exit(void)
+{
+	if (g_debbuf)
+		kfree(g_debbuf->buf);
+	kfree(g_debbuf);
+	kfree(g_cmsg);
+}
+
+#else /* !CONFIG_CAPI_TRACE */
+
+static _cdebbuf g_debbuf = {"CONFIG_CAPI_TRACE not enabled", NULL, 0, 0};
+
+_cdebbuf *capi_message2str(u8 * msg)
+{
+	return &g_debbuf;
+}
+
+_cdebbuf *capi_cmsg2str(_cmsg * cmsg)
+{
+	return &g_debbuf;
+}
+
+_cdebbuf *cdebbuf_alloc(void)
+{
+	return &g_debbuf;
+}
+
+void cdebbuf_free(_cdebbuf *cdb)
+{
+}
+
+int __init cdebug_init(void)
+{
+	return 0;
+}
+
+void __exit cdebug_exit(void)
+{
+}
+
+#endif
+
+EXPORT_SYMBOL(cdebbuf_alloc);
+EXPORT_SYMBOL(cdebbuf_free);
 EXPORT_SYMBOL(capi_cmsg2message);
 EXPORT_SYMBOL(capi_message2cmsg);
 EXPORT_SYMBOL(capi_cmsg_header);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
index e7cf6bc286a6..c1b21552fc03 100644
--- a/drivers/isdn/capi/capiutil.c
+++ b/drivers/isdn/capi/capiutil.c
@@ -17,7 +17,6 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/init.h>
-#include <linux/config.h>
 #include <linux/isdn/capiutil.h>
 
 /* from CAPI2.0 DDK AVM Berlin GmbH */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/isdn/capi/capiutil.c b/drivers/isdn/capi/capiutil.c
new file mode 100644
index 000000000000..e7cf6bc286a6
--- /dev/null
+++ b/drivers/isdn/capi/capiutil.c
@@ -0,0 +1,859 @@
+/* $Id: capiutil.c,v 1.13.6.4 2001/09/23 22:24:33 kai Exp $
+ *
+ * CAPI 2.0 convert capi message to capi message struct
+ *
+ * From CAPI 2.0 Development Kit AVM 1995 (msg.c)
+ * Rewritten for Linux 1996 by Carsten Paeth <calle@calle.de>
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/isdn/capiutil.h>
+
+/* from CAPI2.0 DDK AVM Berlin GmbH */
+
+#ifndef CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON
+char *capi_info2str(u16 reason)
+{
+    return "..";
+}
+#else
+char *capi_info2str(u16 reason)
+{
+    switch (reason) {
+
+/*-- informative values (corresponding message was processed) -----*/
+	case 0x0001:
+	   return "NCPI not supported by current protocol, NCPI ignored";
+	case 0x0002:
+	   return "Flags not supported by current protocol, flags ignored";
+	case 0x0003:
+	   return "Alert already sent by another application";
+
+/*-- error information concerning CAPI_REGISTER -----*/
+	case 0x1001:
+	   return "Too many applications";
+	case 0x1002:
+	   return "Logical block size too small, must be at least 128 Bytes";
+	case 0x1003:
+	   return "Buffer exceeds 64 kByte";
+	case 0x1004:
+	   return "Message buffer size too small, must be at least 1024 Bytes";
+	case 0x1005:
+	   return "Max. number of logical connections not supported";
+	case 0x1006:
+	   return "Reserved";
+	case 0x1007:
+	   return "The message could not be accepted because of an internal busy condition";
+	case 0x1008:
+	   return "OS resource error (no memory ?)";
+	case 0x1009:
+	   return "CAPI not installed";
+	case 0x100A:
+	   return "Controller does not support external equipment";
+	case 0x100B:
+	   return "Controller does only support external equipment";
+
+/*-- error information concerning message exchange functions -----*/
+	case 0x1101:
+	   return "Illegal application number";
+	case 0x1102:
+	   return "Illegal command or subcommand or message length less than 12 bytes";
+	case 0x1103:
+	   return "The message could not be accepted because of a queue full condition !! The error code does not imply that CAPI cannot receive messages directed to another controller, PLCI or NCCI";
+	case 0x1104:
+	   return "Queue is empty";
+	case 0x1105:
+	   return "Queue overflow, a message was lost !! This indicates a configuration error. The only recovery from this error is to perform a CAPI_RELEASE";
+	case 0x1106:
+	   return "Unknown notification parameter";
+	case 0x1107:
+	   return "The Message could not be accepted because of an internal busy condition";
+	case 0x1108:
+	   return "OS Resource error (no memory ?)";
+	case 0x1109:
+	   return "CAPI not installed";
+	case 0x110A:
+	   return "Controller does not support external equipment";
+	case 0x110B:
+	   return "Controller does only support external equipment";
+
+/*-- error information concerning resource / coding problems -----*/
+	case 0x2001:
+	   return "Message not supported in current state";
+	case 0x2002:
+	   return "Illegal Controller / PLCI / NCCI";
+	case 0x2003:
+	   return "Out of PLCI";
+	case 0x2004:
+	   return "Out of NCCI";
+	case 0x2005:
+	   return "Out of LISTEN";
+	case 0x2006:
+	   return "Out of FAX resources (protocol T.30)";
+	case 0x2007:
+	   return "Illegal message parameter coding";
+
+/*-- error information concerning requested services  -----*/
+	case 0x3001:
+	   return "B1 protocol not supported";
+	case 0x3002: 
+	   return "B2 protocol not supported";
+	case 0x3003: 
+	   return "B3 protocol not supported";
+	case 0x3004: 
+	   return "B1 protocol parameter not supported";
+	case 0x3005: 
+	   return "B2 protocol parameter not supported";
+	case 0x3006: 
+	   return "B3 protocol parameter not supported";
+	case 0x3007: 
+	   return "B protocol combination not supported";
+	case 0x3008: 
+	   return "NCPI not supported";
+	case 0x3009: 
+	   return "CIP Value unknown";
+	case 0x300A: 
+	   return "Flags not supported (reserved bits)";
+	case 0x300B: 
+	   return "Facility not supported";
+	case 0x300C: 
+	   return "Data length not supported by current protocol";
+	case 0x300D: 
+	   return "Reset procedure not supported by current protocol";
+
+/*-- informations about the clearing of a physical connection -----*/
+	case 0x3301: 
+	   return "Protocol error layer 1 (broken line or B-channel removed by signalling protocol)";
+	case 0x3302: 
+	   return "Protocol error layer 2";
+	case 0x3303: 
+	   return "Protocol error layer 3";
+	case 0x3304: 
+	   return "Another application got that call";
+/*-- T.30 specific reasons -----*/
+	case 0x3311: 
+	   return "Connecting not successful (remote station is no FAX G3 machine)";
+	case 0x3312: 
+	   return "Connecting not successful (training error)";
+	case 0x3313: 
+	   return "Disconnected before transfer (remote station does not support transfer mode, e.g. resolution)";
+	case 0x3314: 
+	   return "Disconnected during transfer (remote abort)";
+	case 0x3315: 
+	   return "Disconnected during transfer (remote procedure error, e.g. unsuccessful repetition of T.30 commands)";
+	case 0x3316: 
+	   return "Disconnected during transfer (local tx data underrun)";
+	case 0x3317: 
+	   return "Disconnected during transfer (local rx data overflow)";
+	case 0x3318: 
+	   return "Disconnected during transfer (local abort)";
+	case 0x3319: 
+	   return "Illegal parameter coding (e.g. SFF coding error)";
+
+/*-- disconnect causes from the network according to ETS 300 102-1/Q.931 -----*/
+	case 0x3481: return "Unallocated (unassigned) number";
+	case 0x3482: return "No route to specified transit network";
+	case 0x3483: return "No route to destination";
+	case 0x3486: return "Channel unacceptable";
+	case 0x3487: 
+	   return "Call awarded and being delivered in an established channel";
+	case 0x3490: return "Normal call clearing";
+	case 0x3491: return "User busy";
+	case 0x3492: return "No user responding";
+	case 0x3493: return "No answer from user (user alerted)";
+	case 0x3495: return "Call rejected";
+	case 0x3496: return "Number changed";
+	case 0x349A: return "Non-selected user clearing";
+	case 0x349B: return "Destination out of order";
+	case 0x349C: return "Invalid number format";
+	case 0x349D: return "Facility rejected";
+	case 0x349E: return "Response to STATUS ENQUIRY";
+	case 0x349F: return "Normal, unspecified";
+	case 0x34A2: return "No circuit / channel available";
+	case 0x34A6: return "Network out of order";
+	case 0x34A9: return "Temporary failure";
+	case 0x34AA: return "Switching equipment congestion";
+	case 0x34AB: return "Access information discarded";
+	case 0x34AC: return "Requested circuit / channel not available";
+	case 0x34AF: return "Resources unavailable, unspecified";
+	case 0x34B1: return "Quality of service unavailable";
+	case 0x34B2: return "Requested facility not subscribed";
+	case 0x34B9: return "Bearer capability not authorized";
+	case 0x34BA: return "Bearer capability not presently available";
+	case 0x34BF: return "Service or option not available, unspecified";
+	case 0x34C1: return "Bearer capability not implemented";
+	case 0x34C2: return "Channel type not implemented";
+	case 0x34C5: return "Requested facility not implemented";
+	case 0x34C6: return "Only restricted digital information bearer capability is available";
+	case 0x34CF: return "Service or option not implemented, unspecified";
+	case 0x34D1: return "Invalid call reference value";
+	case 0x34D2: return "Identified channel does not exist";
+	case 0x34D3: return "A suspended call exists, but this call identity does not";
+	case 0x34D4: return "Call identity in use";
+	case 0x34D5: return "No call suspended";
+	case 0x34D6: return "Call having the requested call identity has been cleared";
+	case 0x34D8: return "Incompatible destination";
+	case 0x34DB: return "Invalid transit network selection";
+	case 0x34DF: return "Invalid message, unspecified";
+	case 0x34E0: return "Mandatory information element is missing";
+	case 0x34E1: return "Message type non-existent or not implemented";
+	case 0x34E2: return "Message not compatible with call state or message type non-existent or not implemented";
+	case 0x34E3: return "Information element non-existent or not implemented";
+	case 0x34E4: return "Invalid information element contents";
+	case 0x34E5: return "Message not compatible with call state";
+	case 0x34E6: return "Recovery on timer expiry";
+	case 0x34EF: return "Protocol error, unspecified";
+	case 0x34FF: return "Interworking, unspecified";
+
+	default: return "No additional information";
+    }
+}
+#endif
+
+typedef struct {
+	int typ;
+	size_t off;
+} _cdef;
+
+#define _CBYTE	       1
+#define _CWORD	       2
+#define _CDWORD        3
+#define _CSTRUCT       4
+#define _CMSTRUCT      5
+#define _CEND	       6
+
+static _cdef cdef[] =
+{
+    /*00 */ 
+ {_CEND},
+    /*01 */ 
+ {_CEND},
+    /*02 */ 
+ {_CEND},
+    /*03 */ 
+ {_CDWORD, offsetof(_cmsg, adr.adrController)},
+    /*04 */ 
+ {_CMSTRUCT, offsetof(_cmsg, AdditionalInfo)},
+    /*05 */ 
+ {_CSTRUCT, offsetof(_cmsg, B1configuration)},
+    /*06 */ 
+ {_CWORD, offsetof(_cmsg, B1protocol)},
+    /*07 */ 
+ {_CSTRUCT, offsetof(_cmsg, B2configuration)},
+    /*08 */ 
+ {_CWORD, offsetof(_cmsg, B2protocol)},
+    /*09 */ 
+ {_CSTRUCT, offsetof(_cmsg, B3configuration)},
+    /*0a */ 
+ {_CWORD, offsetof(_cmsg, B3protocol)},
+    /*0b */ 
+ {_CSTRUCT, offsetof(_cmsg, BC)},
+    /*0c */ 
+ {_CSTRUCT, offsetof(_cmsg, BChannelinformation)},
+    /*0d */ 
+ {_CMSTRUCT, offsetof(_cmsg, BProtocol)},
+    /*0e */ 
+ {_CSTRUCT, offsetof(_cmsg, CalledPartyNumber)},
+    /*0f */ 
+ {_CSTRUCT, offsetof(_cmsg, CalledPartySubaddress)},
+    /*10 */ 
+ {_CSTRUCT, offsetof(_cmsg, CallingPartyNumber)},
+    /*11 */ 
+ {_CSTRUCT, offsetof(_cmsg, CallingPartySubaddress)},
+    /*12 */ 
+ {_CDWORD, offsetof(_cmsg, CIPmask)},
+    /*13 */ 
+ {_CDWORD, offsetof(_cmsg, CIPmask2)},
+    /*14 */ 
+ {_CWORD, offsetof(_cmsg, CIPValue)},
+    /*15 */ 
+ {_CDWORD, offsetof(_cmsg, Class)},
+    /*16 */ 
+ {_CSTRUCT, offsetof(_cmsg, ConnectedNumber)},
+    /*17 */ 
+ {_CSTRUCT, offsetof(_cmsg, ConnectedSubaddress)},
+    /*18 */ 
+ {_CDWORD, offsetof(_cmsg, Data)},
+    /*19 */ 
+ {_CWORD, offsetof(_cmsg, DataHandle)},
+    /*1a */ 
+ {_CWORD, offsetof(_cmsg, DataLength)},
+    /*1b */ 
+ {_CSTRUCT, offsetof(_cmsg, FacilityConfirmationParameter)},
+    /*1c */ 
+ {_CSTRUCT, offsetof(_cmsg, Facilitydataarray)},
+    /*1d */ 
+ {_CSTRUCT, offsetof(_cmsg, FacilityIndicationParameter)},
+    /*1e */ 
+ {_CSTRUCT, offsetof(_cmsg, FacilityRequestParameter)},
+    /*1f */ 
+ {_CWORD, offsetof(_cmsg, FacilitySelector)},
+    /*20 */ 
+ {_CWORD, offsetof(_cmsg, Flags)},
+    /*21 */ 
+ {_CDWORD, offsetof(_cmsg, Function)},
+    /*22 */ 
+ {_CSTRUCT, offsetof(_cmsg, HLC)},
+    /*23 */ 
+ {_CWORD, offsetof(_cmsg, Info)},
+    /*24 */ 
+ {_CSTRUCT, offsetof(_cmsg, InfoElement)},
+    /*25 */ 
+ {_CDWORD, offsetof(_cmsg, InfoMask)},
+    /*26 */ 
+ {_CWORD, offsetof(_cmsg, InfoNumber)},
+    /*27 */ 
+ {_CSTRUCT, offsetof(_cmsg, Keypadfacility)},
+    /*28 */ 
+ {_CSTRUCT, offsetof(_cmsg, LLC)},
+    /*29 */ 
+ {_CSTRUCT, offsetof(_cmsg, ManuData)},
+    /*2a */ 
+ {_CDWORD, offsetof(_cmsg, ManuID)},
+    /*2b */ 
+ {_CSTRUCT, offsetof(_cmsg, NCPI)},
+    /*2c */ 
+ {_CWORD, offsetof(_cmsg, Reason)},
+    /*2d */ 
+ {_CWORD, offsetof(_cmsg, Reason_B3)},
+    /*2e */ 
+ {_CWORD, offsetof(_cmsg, Reject)},
+    /*2f */ 
+ {_CSTRUCT, offsetof(_cmsg, Useruserdata)}
+};
+
+static unsigned char *cpars[] =
+{
+    /* ALERT_REQ */ [0x01] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
+    /* CONNECT_REQ */ [0x02] = "\x03\x14\x0e\x10\x0f\x11\x0d\x06\x08\x0a\x05\x07\x09\x01\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
+    /* DISCONNECT_REQ */ [0x04] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
+    /* LISTEN_REQ */ [0x05] = "\x03\x25\x12\x13\x10\x11\x01",
+    /* INFO_REQ */ [0x08] = "\x03\x0e\x04\x0c\x27\x2f\x1c\x01\x01",
+    /* FACILITY_REQ */ [0x09] = "\x03\x1f\x1e\x01",
+    /* SELECT_B_PROTOCOL_REQ */ [0x0a] = "\x03\x0d\x06\x08\x0a\x05\x07\x09\x01\x01",
+    /* CONNECT_B3_REQ */ [0x0b] = "\x03\x2b\x01",
+    /* DISCONNECT_B3_REQ */ [0x0d] = "\x03\x2b\x01",
+    /* DATA_B3_REQ */ [0x0f] = "\x03\x18\x1a\x19\x20\x01",
+    /* RESET_B3_REQ */ [0x10] = "\x03\x2b\x01",
+    /* ALERT_CONF */ [0x13] = "\x03\x23\x01",
+    /* CONNECT_CONF */ [0x14] = "\x03\x23\x01",
+    /* DISCONNECT_CONF */ [0x16] = "\x03\x23\x01",
+    /* LISTEN_CONF */ [0x17] = "\x03\x23\x01",
+    /* MANUFACTURER_REQ */ [0x18] = "\x03\x2a\x15\x21\x29\x01",
+    /* INFO_CONF */ [0x1a] = "\x03\x23\x01",
+    /* FACILITY_CONF */ [0x1b] = "\x03\x23\x1f\x1b\x01",
+    /* SELECT_B_PROTOCOL_CONF */ [0x1c] = "\x03\x23\x01",
+    /* CONNECT_B3_CONF */ [0x1d] = "\x03\x23\x01",
+    /* DISCONNECT_B3_CONF */ [0x1f] = "\x03\x23\x01",
+    /* DATA_B3_CONF */ [0x21] = "\x03\x19\x23\x01",
+    /* RESET_B3_CONF */ [0x22] = "\x03\x23\x01",
+    /* CONNECT_IND */ [0x26] = "\x03\x14\x0e\x10\x0f\x11\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
+    /* CONNECT_ACTIVE_IND */ [0x27] = "\x03\x16\x17\x28\x01",
+    /* DISCONNECT_IND */ [0x28] = "\x03\x2c\x01",
+    /* MANUFACTURER_CONF */ [0x2a] = "\x03\x2a\x15\x21\x29\x01",
+    /* INFO_IND */ [0x2c] = "\x03\x26\x24\x01",
+    /* FACILITY_IND */ [0x2d] = "\x03\x1f\x1d\x01",
+    /* CONNECT_B3_IND */ [0x2f] = "\x03\x2b\x01",
+    /* CONNECT_B3_ACTIVE_IND */ [0x30] = "\x03\x2b\x01",
+    /* DISCONNECT_B3_IND */ [0x31] = "\x03\x2d\x2b\x01",
+    /* DATA_B3_IND */ [0x33] = "\x03\x18\x1a\x19\x20\x01",
+    /* RESET_B3_IND */ [0x34] = "\x03\x2b\x01",
+    /* CONNECT_B3_T90_ACTIVE_IND */ [0x35] = "\x03\x2b\x01",
+    /* CONNECT_RESP */ [0x38] = "\x03\x2e\x0d\x06\x08\x0a\x05\x07\x09\x01\x16\x17\x28\x04\x0c\x27\x2f\x1c\x01\x01",
+    /* CONNECT_ACTIVE_RESP */ [0x39] = "\x03\x01",
+    /* DISCONNECT_RESP */ [0x3a] = "\x03\x01",
+    /* MANUFACTURER_IND */ [0x3c] = "\x03\x2a\x15\x21\x29\x01",
+    /* INFO_RESP */ [0x3e] = "\x03\x01",
+    /* FACILITY_RESP */ [0x3f] = "\x03\x1f\x01",
+    /* CONNECT_B3_RESP */ [0x41] = "\x03\x2e\x2b\x01",
+    /* CONNECT_B3_ACTIVE_RESP */ [0x42] = "\x03\x01",
+    /* DISCONNECT_B3_RESP */ [0x43] = "\x03\x01",
+    /* DATA_B3_RESP */ [0x45] = "\x03\x19\x01",
+    /* RESET_B3_RESP */ [0x46] = "\x03\x01",
+    /* CONNECT_B3_T90_ACTIVE_RESP */ [0x47] = "\x03\x01",
+    /* MANUFACTURER_RESP */ [0x4e] = "\x03\x2a\x15\x21\x29\x01",
+};
+
+/*-------------------------------------------------------*/
+
+#define byteTLcpy(x,y)        *(u8 *)(x)=*(u8 *)(y);
+#define wordTLcpy(x,y)        *(u16 *)(x)=*(u16 *)(y);
+#define dwordTLcpy(x,y)       memcpy(x,y,4);
+#define structTLcpy(x,y,l)    memcpy (x,y,l)
+#define structTLcpyovl(x,y,l) memmove (x,y,l)
+
+#define byteTRcpy(x,y)        *(u8 *)(y)=*(u8 *)(x);
+#define wordTRcpy(x,y)        *(u16 *)(y)=*(u16 *)(x);
+#define dwordTRcpy(x,y)       memcpy(y,x,4);
+#define structTRcpy(x,y,l)    memcpy (y,x,l)
+#define structTRcpyovl(x,y,l) memmove (y,x,l)
+
+/*-------------------------------------------------------*/
+static unsigned command_2_index(unsigned c, unsigned sc)
+{
+	if (c & 0x80)
+		c = 0x9 + (c & 0x0f);
+	else if (c <= 0x0f);
+	else if (c == 0x41)
+		c = 0x9 + 0x1;
+	else if (c == 0xff)
+		c = 0x00;
+	return (sc & 3) * (0x9 + 0x9) + c;
+}
+
+/*-------------------------------------------------------*/
+#define TYP (cdef[cmsg->par[cmsg->p]].typ)
+#define OFF (((u8 *)cmsg)+cdef[cmsg->par[cmsg->p]].off)
+
+static void jumpcstruct(_cmsg * cmsg)
+{
+	unsigned layer;
+	for (cmsg->p++, layer = 1; layer;) {
+		/* $$$$$ assert (cmsg->p); */
+		cmsg->p++;
+		switch (TYP) {
+		case _CMSTRUCT:
+			layer++;
+			break;
+		case _CEND:
+			layer--;
+			break;
+		}
+	}
+}
+/*-------------------------------------------------------*/
+static void pars_2_message(_cmsg * cmsg)
+{
+
+	for (; TYP != _CEND; cmsg->p++) {
+		switch (TYP) {
+		case _CBYTE:
+			byteTLcpy(cmsg->m + cmsg->l, OFF);
+			cmsg->l++;
+			break;
+		case _CWORD:
+			wordTLcpy(cmsg->m + cmsg->l, OFF);
+			cmsg->l += 2;
+			break;
+		case _CDWORD:
+			dwordTLcpy(cmsg->m + cmsg->l, OFF);
+			cmsg->l += 4;
+			break;
+		case _CSTRUCT:
+			if (*(u8 **) OFF == 0) {
+				*(cmsg->m + cmsg->l) = '\0';
+				cmsg->l++;
+			} else if (**(_cstruct *) OFF != 0xff) {
+				structTLcpy(cmsg->m + cmsg->l, *(_cstruct *) OFF, 1 + **(_cstruct *) OFF);
+				cmsg->l += 1 + **(_cstruct *) OFF;
+			} else {
+				_cstruct s = *(_cstruct *) OFF;
+				structTLcpy(cmsg->m + cmsg->l, s, 3 + *(u16 *) (s + 1));
+				cmsg->l += 3 + *(u16 *) (s + 1);
+			}
+			break;
+		case _CMSTRUCT:
+/*----- Metastruktur 0 -----*/
+			if (*(_cmstruct *) OFF == CAPI_DEFAULT) {
+				*(cmsg->m + cmsg->l) = '\0';
+				cmsg->l++;
+				jumpcstruct(cmsg);
+			}
+/*----- Metastruktur wird composed -----*/
+			else {
+				unsigned _l = cmsg->l;
+				unsigned _ls;
+				cmsg->l++;
+				cmsg->p++;
+				pars_2_message(cmsg);
+				_ls = cmsg->l - _l - 1;
+				if (_ls < 255)
+					(cmsg->m + _l)[0] = (u8) _ls;
+				else {
+					structTLcpyovl(cmsg->m + _l + 3, cmsg->m + _l + 1, _ls);
+					(cmsg->m + _l)[0] = 0xff;
+					wordTLcpy(cmsg->m + _l + 1, &_ls);
+				}
+			}
+			break;
+		}
+	}
+}
+
+/*-------------------------------------------------------*/
+unsigned capi_cmsg2message(_cmsg * cmsg, u8 * msg)
+{
+	cmsg->m = msg;
+	cmsg->l = 8;
+	cmsg->p = 0;
+	cmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];
+
+	pars_2_message(cmsg);
+
+	wordTLcpy(msg + 0, &cmsg->l);
+	byteTLcpy(cmsg->m + 4, &cmsg->Command);
+	byteTLcpy(cmsg->m + 5, &cmsg->Subcommand);
+	wordTLcpy(cmsg->m + 2, &cmsg->ApplId);
+	wordTLcpy(cmsg->m + 6, &cmsg->Messagenumber);
+
+	return 0;
+}
+
+/*-------------------------------------------------------*/
+static void message_2_pars(_cmsg * cmsg)
+{
+	for (; TYP != _CEND; cmsg->p++) {
+
+		switch (TYP) {
+		case _CBYTE:
+			byteTRcpy(cmsg->m + cmsg->l, OFF);
+			cmsg->l++;
+			break;
+		case _CWORD:
+			wordTRcpy(cmsg->m + cmsg->l, OFF);
+			cmsg->l += 2;
+			break;
+		case _CDWORD:
+			dwordTRcpy(cmsg->m + cmsg->l, OFF);
+			cmsg->l += 4;
+			break;
+		case _CSTRUCT:
+			*(u8 **) OFF = cmsg->m + cmsg->l;
+
+			if (cmsg->m[cmsg->l] != 0xff)
+				cmsg->l += 1 + cmsg->m[cmsg->l];
+			else
+				cmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);
+			break;
+		case _CMSTRUCT:
+/*----- Metastruktur 0 -----*/
+			if (cmsg->m[cmsg->l] == '\0') {
+				*(_cmstruct *) OFF = CAPI_DEFAULT;
+				cmsg->l++;
+				jumpcstruct(cmsg);
+			} else {
+				unsigned _l = cmsg->l;
+				*(_cmstruct *) OFF = CAPI_COMPOSE;
+				cmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;
+				cmsg->p++;
+				message_2_pars(cmsg);
+			}
+			break;
+		}
+	}
+}
+
+/*-------------------------------------------------------*/
+unsigned capi_message2cmsg(_cmsg * cmsg, u8 * msg)
+{
+	memset(cmsg, 0, sizeof(_cmsg));
+	cmsg->m = msg;
+	cmsg->l = 8;
+	cmsg->p = 0;
+	byteTRcpy(cmsg->m + 4, &cmsg->Command);
+	byteTRcpy(cmsg->m + 5, &cmsg->Subcommand);
+	cmsg->par = cpars[command_2_index(cmsg->Command, cmsg->Subcommand)];
+
+	message_2_pars(cmsg);
+
+	wordTRcpy(msg + 0, &cmsg->l);
+	wordTRcpy(cmsg->m + 2, &cmsg->ApplId);
+	wordTRcpy(cmsg->m + 6, &cmsg->Messagenumber);
+
+	return 0;
+}
+
+/*-------------------------------------------------------*/
+unsigned capi_cmsg_header(_cmsg * cmsg, u16 _ApplId,
+			  u8 _Command, u8 _Subcommand,
+			  u16 _Messagenumber, u32 _Controller)
+{
+	memset(cmsg, 0, sizeof(_cmsg));
+	cmsg->ApplId = _ApplId;
+	cmsg->Command = _Command;
+	cmsg->Subcommand = _Subcommand;
+	cmsg->Messagenumber = _Messagenumber;
+	cmsg->adr.adrController = _Controller;
+	return 0;
+}
+
+/*-------------------------------------------------------*/
+
+static char *mnames[] =
+{
+	[0x01] = "ALERT_REQ",
+	[0x02] = "CONNECT_REQ",
+	[0x04] = "DISCONNECT_REQ",
+	[0x05] = "LISTEN_REQ",
+	[0x08] = "INFO_REQ",
+	[0x09] = "FACILITY_REQ",
+	[0x0a] = "SELECT_B_PROTOCOL_REQ",
+	[0x0b] = "CONNECT_B3_REQ",
+	[0x0d] = "DISCONNECT_B3_REQ",
+	[0x0f] = "DATA_B3_REQ",
+	[0x10] = "RESET_B3_REQ",
+	[0x13] = "ALERT_CONF",
+	[0x14] = "CONNECT_CONF",
+	[0x16] = "DISCONNECT_CONF",
+	[0x17] = "LISTEN_CONF",
+	[0x18] = "MANUFACTURER_REQ",
+	[0x1a] = "INFO_CONF",
+	[0x1b] = "FACILITY_CONF",
+	[0x1c] = "SELECT_B_PROTOCOL_CONF",
+	[0x1d] = "CONNECT_B3_CONF",
+	[0x1f] = "DISCONNECT_B3_CONF",
+	[0x21] = "DATA_B3_CONF",
+	[0x22] = "RESET_B3_CONF",
+	[0x26] = "CONNECT_IND",
+	[0x27] = "CONNECT_ACTIVE_IND",
+	[0x28] = "DISCONNECT_IND",
+	[0x2a] = "MANUFACTURER_CONF",
+	[0x2c] = "INFO_IND",
+	[0x2d] = "FACILITY_IND",
+	[0x2f] = "CONNECT_B3_IND",
+	[0x30] = "CONNECT_B3_ACTIVE_IND",
+	[0x31] = "DISCONNECT_B3_IND",
+	[0x33] = "DATA_B3_IND",
+	[0x34] = "RESET_B3_IND",
+	[0x35] = "CONNECT_B3_T90_ACTIVE_IND",
+	[0x38] = "CONNECT_RESP",
+	[0x39] = "CONNECT_ACTIVE_RESP",
+	[0x3a] = "DISCONNECT_RESP",
+	[0x3c] = "MANUFACTURER_IND",
+	[0x3e] = "INFO_RESP",
+	[0x3f] = "FACILITY_RESP",
+	[0x41] = "CONNECT_B3_RESP",
+	[0x42] = "CONNECT_B3_ACTIVE_RESP",
+	[0x43] = "DISCONNECT_B3_RESP",
+	[0x45] = "DATA_B3_RESP",
+	[0x46] = "RESET_B3_RESP",
+	[0x47] = "CONNECT_B3_T90_ACTIVE_RESP",
+	[0x4e] = "MANUFACTURER_RESP"
+};
+
+char *capi_cmd2str(u8 cmd, u8 subcmd)
+{
+	return mnames[command_2_index(cmd, subcmd)];
+}
+
+
+/*-------------------------------------------------------*/
+/*-------------------------------------------------------*/
+
+static char *pnames[] =
+{
+    /*00 */ NULL,
+    /*01 */ NULL,
+    /*02 */ NULL,
+    /*03 */ "Controller/PLCI/NCCI",
+    /*04 */ "AdditionalInfo",
+    /*05 */ "B1configuration",
+    /*06 */ "B1protocol",
+    /*07 */ "B2configuration",
+    /*08 */ "B2protocol",
+    /*09 */ "B3configuration",
+    /*0a */ "B3protocol",
+    /*0b */ "BC",
+    /*0c */ "BChannelinformation",
+    /*0d */ "BProtocol",
+    /*0e */ "CalledPartyNumber",
+    /*0f */ "CalledPartySubaddress",
+    /*10 */ "CallingPartyNumber",
+    /*11 */ "CallingPartySubaddress",
+    /*12 */ "CIPmask",
+    /*13 */ "CIPmask2",
+    /*14 */ "CIPValue",
+    /*15 */ "Class",
+    /*16 */ "ConnectedNumber",
+    /*17 */ "ConnectedSubaddress",
+    /*18 */ "Data32",
+    /*19 */ "DataHandle",
+    /*1a */ "DataLength",
+    /*1b */ "FacilityConfirmationParameter",
+    /*1c */ "Facilitydataarray",
+    /*1d */ "FacilityIndicationParameter",
+    /*1e */ "FacilityRequestParameter",
+    /*1f */ "FacilitySelector",
+    /*20 */ "Flags",
+    /*21 */ "Function",
+    /*22 */ "HLC",
+    /*23 */ "Info",
+    /*24 */ "InfoElement",
+    /*25 */ "InfoMask",
+    /*26 */ "InfoNumber",
+    /*27 */ "Keypadfacility",
+    /*28 */ "LLC",
+    /*29 */ "ManuData",
+    /*2a */ "ManuID",
+    /*2b */ "NCPI",
+    /*2c */ "Reason",
+    /*2d */ "Reason_B3",
+    /*2e */ "Reject",
+    /*2f */ "Useruserdata"
+};
+
+
+static char buf[8192];
+static char *p = NULL;
+
+#include <stdarg.h>
+
+/*-------------------------------------------------------*/
+static void bufprint(char *fmt,...)
+{
+	va_list f;
+	va_start(f, fmt);
+	vsprintf(p, fmt, f);
+	va_end(f);
+	p += strlen(p);
+}
+
+static void printstructlen(u8 * m, unsigned len)
+{
+	unsigned hex = 0;
+	for (; len; len--, m++)
+		if (isalnum(*m) || *m == ' ') {
+			if (hex)
+				bufprint(">");
+			bufprint("%c", *m);
+			hex = 0;
+		} else {
+			if (!hex)
+				bufprint("<%02x", *m);
+			else
+				bufprint(" %02x", *m);
+			hex = 1;
+		}
+	if (hex)
+		bufprint(">");
+}
+
+static void printstruct(u8 * m)
+{
+	unsigned len;
+	if (m[0] != 0xff) {
+		len = m[0];
+		m += 1;
+	} else {
+		len = ((u16 *) (m + 1))[0];
+		m += 3;
+	}
+	printstructlen(m, len);
+}
+
+/*-------------------------------------------------------*/
+#define NAME (pnames[cmsg->par[cmsg->p]])
+
+static void protocol_message_2_pars(_cmsg * cmsg, int level)
+{
+	for (; TYP != _CEND; cmsg->p++) {
+		int slen = 29 + 3 - level;
+		int i;
+
+		bufprint("  ");
+		for (i = 0; i < level - 1; i++)
+			bufprint(" ");
+
+		switch (TYP) {
+		case _CBYTE:
+			bufprint("%-*s = 0x%x\n", slen, NAME, *(u8 *) (cmsg->m + cmsg->l));
+			cmsg->l++;
+			break;
+		case _CWORD:
+			bufprint("%-*s = 0x%x\n", slen, NAME, *(u16 *) (cmsg->m + cmsg->l));
+			cmsg->l += 2;
+			break;
+		case _CDWORD:
+			bufprint("%-*s = 0x%lx\n", slen, NAME, *(u32 *) (cmsg->m + cmsg->l));
+			cmsg->l += 4;
+			break;
+		case _CSTRUCT:
+			bufprint("%-*s = ", slen, NAME);
+			if (cmsg->m[cmsg->l] == '\0')
+				bufprint("default");
+			else
+				printstruct(cmsg->m + cmsg->l);
+			bufprint("\n");
+			if (cmsg->m[cmsg->l] != 0xff)
+				cmsg->l += 1 + cmsg->m[cmsg->l];
+			else
+				cmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);
+
+			break;
+
+		case _CMSTRUCT:
+/*----- Metastruktur 0 -----*/
+			if (cmsg->m[cmsg->l] == '\0') {
+				bufprint("%-*s = default\n", slen, NAME);
+				cmsg->l++;
+				jumpcstruct(cmsg);
+			} else {
+				char *name = NAME;
+				unsigned _l = cmsg->l;
+				bufprint("%-*s\n", slen, name);
+				cmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;
+				cmsg->p++;
+				protocol_message_2_pars(cmsg, level + 1);
+			}
+			break;
+		}
+	}
+}
+/*-------------------------------------------------------*/
+char *capi_message2str(u8 * msg)
+{
+
+	_cmsg cmsg;
+	p = buf;
+	p[0] = 0;
+
+	cmsg.m = msg;
+	cmsg.l = 8;
+	cmsg.p = 0;
+	byteTRcpy(cmsg.m + 4, &cmsg.Command);
+	byteTRcpy(cmsg.m + 5, &cmsg.Subcommand);
+	cmsg.par = cpars[command_2_index(cmsg.Command, cmsg.Subcommand)];
+
+	bufprint("%-26s ID=%03d #0x%04x LEN=%04d\n",
+		 mnames[command_2_index(cmsg.Command, cmsg.Subcommand)],
+		 ((unsigned short *) msg)[1],
+		 ((unsigned short *) msg)[3],
+		 ((unsigned short *) msg)[0]);
+
+	protocol_message_2_pars(&cmsg, 1);
+	return buf;
+}
+
+char *capi_cmsg2str(_cmsg * cmsg)
+{
+	p = buf;
+	p[0] = 0;
+	cmsg->l = 8;
+	cmsg->p = 0;
+	bufprint("%s ID=%03d #0x%04x LEN=%04d\n",
+		 mnames[command_2_index(cmsg->Command, cmsg->Subcommand)],
+		 ((u16 *) cmsg->m)[1],
+		 ((u16 *) cmsg->m)[3],
+		 ((u16 *) cmsg->m)[0]);
+	protocol_message_2_pars(cmsg, 1);
+	return buf;
+}
+
+EXPORT_SYMBOL(capi_cmsg2message);
+EXPORT_SYMBOL(capi_message2cmsg);
+EXPORT_SYMBOL(capi_cmsg_header);
+EXPORT_SYMBOL(capi_cmd2str);
+EXPORT_SYMBOL(capi_cmsg2str);
+EXPORT_SYMBOL(capi_message2str);
+EXPORT_SYMBOL(capi_info2str);
