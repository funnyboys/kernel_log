commit 6e2bbb688aa6d05073dd1dd0b836d9becec195c1
Merge: 5ad18b2e60b7 3d25025ce9c2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 9 08:57:45 2019 -0700

    Merge tag 'pwm/for-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm
    
    Pull pwm updates from Thierry Reding:
     "This set of changes contains a new driver for SiFive SoCs as well as
      enhancements to the core (device links are used to track dependencies
      between PWM providers and consumers, support for PWM controllers via
      ACPI, sysfs will now suspend/resume PWMs that it has claimed) and
      various existing drivers"
    
    * tag 'pwm/for-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm: (37 commits)
      pwm: fsl-ftm: Make sure to unlock mutex on failure
      pwm: fsl-ftm: Use write protection for prescaler & polarity
      pwm: fsl-ftm: More relaxed permissions for updating period
      pwm: atmel-hlcdc: Add compatible for SAM9X60 HLCDC's PWM
      pwm: bcm2835: Improve precision of PWM
      leds: pwm: Support ACPI via firmware-node framework
      pwm: Add support referencing PWMs from ACPI
      pwm: rcar: Remove suspend/resume support
      pwm: sysfs: Add suspend/resume support
      pwm: Add power management descriptions
      pwm: meson: Add documentation to the driver
      pwm: meson: Add support PWM_POLARITY_INVERSED when disabling
      pwm: meson: Don't cache struct pwm_state internally
      pwm: meson: Read the full hardware state in meson_pwm_get_state()
      pwm: meson: Simplify the calculation of the pre-divider and count
      pwm: meson: Move pwm_set_chip_data() to meson_pwm_request()
      pwm: meson: Add the per-channel register offsets and bits in a struct
      pwm: meson: Add the meson_pwm_channel data to struct meson_pwm
      pwm: meson: Pass struct pwm_device to meson_pwm_calc()
      pwm: meson: Don't duplicate the polarity internally
      ...

commit 7fd4edc57bbae9bd62838ebf69d3abfaf8f01173
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Fri May 31 18:55:00 2019 +0900

    pwm: sysfs: Add suspend/resume support
    
    According to the Documentation/pwm.txt, all PWM consumers should have
    power management. Since this sysfs interface is one of consumers so that
    this patch adds suspend/resume support.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    [thierry.reding@gmail.com: fix build warnings for !PM]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 719f8fada0a7..8158a434f7b8 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -27,6 +27,7 @@ struct pwm_export {
 	struct device child;
 	struct pwm_device *pwm;
 	struct mutex lock;
+	struct pwm_state suspend;
 };
 
 static struct pwm_export *child_to_pwm_export(struct device *child)
@@ -381,10 +382,111 @@ static struct attribute *pwm_chip_attrs[] = {
 };
 ATTRIBUTE_GROUPS(pwm_chip);
 
+/* takes export->lock on success */
+static struct pwm_export *pwm_class_get_state(struct device *parent,
+					      struct pwm_device *pwm,
+					      struct pwm_state *state)
+{
+	struct device *child;
+	struct pwm_export *export;
+
+	if (!test_bit(PWMF_EXPORTED, &pwm->flags))
+		return NULL;
+
+	child = device_find_child(parent, pwm, pwm_unexport_match);
+	if (!child)
+		return NULL;
+
+	export = child_to_pwm_export(child);
+	put_device(child);	/* for device_find_child() */
+
+	mutex_lock(&export->lock);
+	pwm_get_state(pwm, state);
+
+	return export;
+}
+
+static int pwm_class_apply_state(struct pwm_export *export,
+				 struct pwm_device *pwm,
+				 struct pwm_state *state)
+{
+	int ret = pwm_apply_state(pwm, state);
+
+	/* release lock taken in pwm_class_get_state */
+	mutex_unlock(&export->lock);
+
+	return ret;
+}
+
+static int pwm_class_resume_npwm(struct device *parent, unsigned int npwm)
+{
+	struct pwm_chip *chip = dev_get_drvdata(parent);
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < npwm; i++) {
+		struct pwm_device *pwm = &chip->pwms[i];
+		struct pwm_state state;
+		struct pwm_export *export;
+
+		export = pwm_class_get_state(parent, pwm, &state);
+		if (!export)
+			continue;
+
+		state.enabled = export->suspend.enabled;
+		ret = pwm_class_apply_state(export, pwm, &state);
+		if (ret < 0)
+			break;
+	}
+
+	return ret;
+}
+
+static int __maybe_unused pwm_class_suspend(struct device *parent)
+{
+	struct pwm_chip *chip = dev_get_drvdata(parent);
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < chip->npwm; i++) {
+		struct pwm_device *pwm = &chip->pwms[i];
+		struct pwm_state state;
+		struct pwm_export *export;
+
+		export = pwm_class_get_state(parent, pwm, &state);
+		if (!export)
+			continue;
+
+		export->suspend = state;
+		state.enabled = false;
+		ret = pwm_class_apply_state(export, pwm, &state);
+		if (ret < 0) {
+			/*
+			 * roll back the PWM devices that were disabled by
+			 * this suspend function.
+			 */
+			pwm_class_resume_npwm(parent, i);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int __maybe_unused pwm_class_resume(struct device *parent)
+{
+	struct pwm_chip *chip = dev_get_drvdata(parent);
+
+	return pwm_class_resume_npwm(parent, chip->npwm);
+}
+
+static SIMPLE_DEV_PM_OPS(pwm_class_pm_ops, pwm_class_suspend, pwm_class_resume);
+
 static struct class pwm_class = {
 	.name = "pwm",
 	.owner = THIS_MODULE,
 	.dev_groups = pwm_chip_groups,
+	.pm = &pwm_class_pm_ops,
 };
 
 static int pwmchip_sysfs_match(struct device *parent, const void *data)

commit 3e0a4e85803345e31ae2d0009bedf252e43278cb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 118
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091651.032047323@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 719f8fada0a7..bf6823fe0812 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -1,19 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * A simple sysfs interface for the generic PWM framework
  *
  * Copyright (C) 2013 H Hartley Sweeten <hsweeten@visionengravers.com>
  *
  * Based on previous work by Lars Poeschel <poeschel@lemonage.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/device.h>

commit 9ff06679e109a216fc4a0cf5b4069a5305df141c
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Mar 12 10:25:47 2019 +0100

    pwm: sysfs: fix typo "its" -> "it's"
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 13d9bd54dfce..719f8fada0a7 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -398,7 +398,7 @@ void pwmchip_sysfs_export(struct pwm_chip *chip)
 
 	/*
 	 * If device_create() fails the pwm_chip is still usable by
-	 * the kernel its just not exported.
+	 * the kernel it's just not exported.
 	 */
 	parent = device_create(&pwm_class, chip->dev, MKDEV(0, 0), chip,
 			       "pwmchip%d", chip->base);

commit 347ab9480313737c0f1aaa08e8f2e1a791235535
Author: Phong Hoang <phong.hoang.wz@renesas.com>
Date:   Tue Mar 19 19:40:08 2019 +0900

    pwm: Fix deadlock warning when removing PWM device
    
    This patch fixes deadlock warning if removing PWM device
    when CONFIG_PROVE_LOCKING is enabled.
    
    This issue can be reproceduced by the following steps on
    the R-Car H3 Salvator-X board if the backlight is disabled:
    
     # cd /sys/class/pwm/pwmchip0
     # echo 0 > export
     # ls
     device  export  npwm  power  pwm0  subsystem  uevent  unexport
     # cd device/driver
     # ls
     bind  e6e31000.pwm  uevent  unbind
     # echo e6e31000.pwm > unbind
    
    [   87.659974] ======================================================
    [   87.666149] WARNING: possible circular locking dependency detected
    [   87.672327] 5.0.0 #7 Not tainted
    [   87.675549] ------------------------------------------------------
    [   87.681723] bash/2986 is trying to acquire lock:
    [   87.686337] 000000005ea0e178 (kn->count#58){++++}, at: kernfs_remove_by_name_ns+0x50/0xa0
    [   87.694528]
    [   87.694528] but task is already holding lock:
    [   87.700353] 000000006313b17c (pwm_lock){+.+.}, at: pwmchip_remove+0x28/0x13c
    [   87.707405]
    [   87.707405] which lock already depends on the new lock.
    [   87.707405]
    [   87.715574]
    [   87.715574] the existing dependency chain (in reverse order) is:
    [   87.723048]
    [   87.723048] -> #1 (pwm_lock){+.+.}:
    [   87.728017]        __mutex_lock+0x70/0x7e4
    [   87.732108]        mutex_lock_nested+0x1c/0x24
    [   87.736547]        pwm_request_from_chip.part.6+0x34/0x74
    [   87.741940]        pwm_request_from_chip+0x20/0x40
    [   87.746725]        export_store+0x6c/0x1f4
    [   87.750820]        dev_attr_store+0x18/0x28
    [   87.754998]        sysfs_kf_write+0x54/0x64
    [   87.759175]        kernfs_fop_write+0xe4/0x1e8
    [   87.763615]        __vfs_write+0x40/0x184
    [   87.767619]        vfs_write+0xa8/0x19c
    [   87.771448]        ksys_write+0x58/0xbc
    [   87.775278]        __arm64_sys_write+0x18/0x20
    [   87.779721]        el0_svc_common+0xd0/0x124
    [   87.783986]        el0_svc_compat_handler+0x1c/0x24
    [   87.788858]        el0_svc_compat+0x8/0x18
    [   87.792947]
    [   87.792947] -> #0 (kn->count#58){++++}:
    [   87.798260]        lock_acquire+0xc4/0x22c
    [   87.802353]        __kernfs_remove+0x258/0x2c4
    [   87.806790]        kernfs_remove_by_name_ns+0x50/0xa0
    [   87.811836]        remove_files.isra.1+0x38/0x78
    [   87.816447]        sysfs_remove_group+0x48/0x98
    [   87.820971]        sysfs_remove_groups+0x34/0x4c
    [   87.825583]        device_remove_attrs+0x6c/0x7c
    [   87.830197]        device_del+0x11c/0x33c
    [   87.834201]        device_unregister+0x14/0x2c
    [   87.838638]        pwmchip_sysfs_unexport+0x40/0x4c
    [   87.843509]        pwmchip_remove+0xf4/0x13c
    [   87.847773]        rcar_pwm_remove+0x28/0x34
    [   87.852039]        platform_drv_remove+0x24/0x64
    [   87.856651]        device_release_driver_internal+0x18c/0x21c
    [   87.862391]        device_release_driver+0x14/0x1c
    [   87.867175]        unbind_store+0xe0/0x124
    [   87.871265]        drv_attr_store+0x20/0x30
    [   87.875442]        sysfs_kf_write+0x54/0x64
    [   87.879618]        kernfs_fop_write+0xe4/0x1e8
    [   87.884055]        __vfs_write+0x40/0x184
    [   87.888057]        vfs_write+0xa8/0x19c
    [   87.891887]        ksys_write+0x58/0xbc
    [   87.895716]        __arm64_sys_write+0x18/0x20
    [   87.900154]        el0_svc_common+0xd0/0x124
    [   87.904417]        el0_svc_compat_handler+0x1c/0x24
    [   87.909289]        el0_svc_compat+0x8/0x18
    [   87.913378]
    [   87.913378] other info that might help us debug this:
    [   87.913378]
    [   87.921374]  Possible unsafe locking scenario:
    [   87.921374]
    [   87.927286]        CPU0                    CPU1
    [   87.931808]        ----                    ----
    [   87.936331]   lock(pwm_lock);
    [   87.939293]                                lock(kn->count#58);
    [   87.945120]                                lock(pwm_lock);
    [   87.950599]   lock(kn->count#58);
    [   87.953908]
    [   87.953908]  *** DEADLOCK ***
    [   87.953908]
    [   87.959821] 4 locks held by bash/2986:
    [   87.963563]  #0: 00000000ace7bc30 (sb_writers#6){.+.+}, at: vfs_write+0x188/0x19c
    [   87.971044]  #1: 00000000287991b2 (&of->mutex){+.+.}, at: kernfs_fop_write+0xb4/0x1e8
    [   87.978872]  #2: 00000000f739d016 (&dev->mutex){....}, at: device_release_driver_internal+0x40/0x21c
    [   87.988001]  #3: 000000006313b17c (pwm_lock){+.+.}, at: pwmchip_remove+0x28/0x13c
    [   87.995481]
    [   87.995481] stack backtrace:
    [   87.999836] CPU: 0 PID: 2986 Comm: bash Not tainted 5.0.0 #7
    [   88.005489] Hardware name: Renesas Salvator-X board based on r8a7795 ES1.x (DT)
    [   88.012791] Call trace:
    [   88.015235]  dump_backtrace+0x0/0x190
    [   88.018891]  show_stack+0x14/0x1c
    [   88.022204]  dump_stack+0xb0/0xec
    [   88.025514]  print_circular_bug.isra.32+0x1d0/0x2e0
    [   88.030385]  __lock_acquire+0x1318/0x1864
    [   88.034388]  lock_acquire+0xc4/0x22c
    [   88.037958]  __kernfs_remove+0x258/0x2c4
    [   88.041874]  kernfs_remove_by_name_ns+0x50/0xa0
    [   88.046398]  remove_files.isra.1+0x38/0x78
    [   88.050487]  sysfs_remove_group+0x48/0x98
    [   88.054490]  sysfs_remove_groups+0x34/0x4c
    [   88.058580]  device_remove_attrs+0x6c/0x7c
    [   88.062671]  device_del+0x11c/0x33c
    [   88.066154]  device_unregister+0x14/0x2c
    [   88.070070]  pwmchip_sysfs_unexport+0x40/0x4c
    [   88.074421]  pwmchip_remove+0xf4/0x13c
    [   88.078163]  rcar_pwm_remove+0x28/0x34
    [   88.081906]  platform_drv_remove+0x24/0x64
    [   88.085996]  device_release_driver_internal+0x18c/0x21c
    [   88.091215]  device_release_driver+0x14/0x1c
    [   88.095478]  unbind_store+0xe0/0x124
    [   88.099048]  drv_attr_store+0x20/0x30
    [   88.102704]  sysfs_kf_write+0x54/0x64
    [   88.106359]  kernfs_fop_write+0xe4/0x1e8
    [   88.110275]  __vfs_write+0x40/0x184
    [   88.113757]  vfs_write+0xa8/0x19c
    [   88.117065]  ksys_write+0x58/0xbc
    [   88.120374]  __arm64_sys_write+0x18/0x20
    [   88.124291]  el0_svc_common+0xd0/0x124
    [   88.128034]  el0_svc_compat_handler+0x1c/0x24
    [   88.132384]  el0_svc_compat+0x8/0x18
    
    The sysfs unexport in pwmchip_remove() is completely asymmetric
    to what we do in pwmchip_add_with_polarity() and commit 0733424c9ba9
    ("pwm: Unexport children before chip removal") is a strong indication
    that this was wrong to begin with. We should just move
    pwmchip_sysfs_unexport() where it belongs, which is right after
    pwmchip_sysfs_unexport_children(). In that case, we do not need
    separate functions anymore either.
    
    We also really want to remove sysfs irrespective of whether or not
    the chip will be removed as a result of pwmchip_remove(). We can only
    assume that the driver will be gone after that, so we shouldn't leave
    any dangling sysfs files around.
    
    This warning disappears if we move pwmchip_sysfs_unexport() to
    the top of pwmchip_remove(), pwmchip_sysfs_unexport_children().
    That way it is also outside of the pwm_lock section, which indeed
    doesn't seem to be needed.
    
    Moving the pwmchip_sysfs_export() call outside of that section also
    seems fine and it'd be perfectly symmetric with pwmchip_remove() again.
    
    So, this patch fixes them.
    
    Signed-off-by: Phong Hoang <phong.hoang.wz@renesas.com>
    [shimoda: revise the commit log and code]
    Fixes: 76abbdde2d95 ("pwm: Add sysfs interface")
    Fixes: 0733424c9ba9 ("pwm: Unexport children before chip removal")
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Hoan Nguyen An <na-hoan@jinso.co.jp>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Reviewed-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index ceb233dd6048..13d9bd54dfce 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -409,19 +409,6 @@ void pwmchip_sysfs_export(struct pwm_chip *chip)
 }
 
 void pwmchip_sysfs_unexport(struct pwm_chip *chip)
-{
-	struct device *parent;
-
-	parent = class_find_device(&pwm_class, NULL, chip,
-				   pwmchip_sysfs_match);
-	if (parent) {
-		/* for class_find_device() */
-		put_device(parent);
-		device_unregister(parent);
-	}
-}
-
-void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)
 {
 	struct device *parent;
 	unsigned int i;
@@ -439,6 +426,7 @@ void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)
 	}
 
 	put_device(parent);
+	device_unregister(parent);
 }
 
 static int __init pwm_sysfs_init(void)

commit 552c02e3e7cfe2744b59de285aaea70021ae95c9
Author: Fabrice Gasnier <fabrice.gasnier@st.com>
Date:   Mon Oct 1 15:23:57 2018 +0200

    pwm: Send a uevent on the pwmchip device upon channel sysfs (un)export
    
    This patch sends a uevent (KOBJ_CHANGE) on the pwmchipN device,
    everytime a pwmX channel has been exported/unexported via sysfs. This
    allows udev to implement rules on such events, like:
    
    SUBSYSTEM=="pwm*", PROGRAM="/bin/sh -c '\
            chown -R root:gpio /sys/class/pwm && chmod -R 770 /sys/class/pwm;\
            chown -R root:gpio
    /sys/devices/platform/soc/*.pwm/pwm/pwmchip* && chmod -R 770
    /sys/devices/platform/soc/*.pwm/pwm/pwmchip*\
    '"
    
    This is a replacement patch for commit 7e5d1fd75c3d ("pwm: Set class for
    exported channels in sysfs"), see [1].
    
    basic testing:
    $ udevadm monitor --environment &
    $ echo 0 > /sys/class/pwm/pwmchip0/export
    KERNEL[197.321736] change   /devices/.../pwm/pwmchip0 (pwm)
    ACTION=change
    DEVPATH=/devices/.../pwm/pwmchip0
    EXPORT=pwm0
    SEQNUM=2045
    SUBSYSTEM=pwm
    
    [1] https://lkml.org/lkml/2018/9/25/713
    
    Signed-off-by: Fabrice Gasnier <fabrice.gasnier@st.com>
    Tested-by: Gottfried Haider <gottfried.haider@gmail.com>
    Tested-by: Michal Vokáč <michal.vokac@ysoft.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 4726d43aaa0c..ceb233dd6048 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -249,6 +249,7 @@ static void pwm_export_release(struct device *child)
 static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 {
 	struct pwm_export *export;
+	char *pwm_prop[2];
 	int ret;
 
 	if (test_and_set_bit(PWMF_EXPORTED, &pwm->flags))
@@ -276,6 +277,10 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 		export = NULL;
 		return ret;
 	}
+	pwm_prop[0] = kasprintf(GFP_KERNEL, "EXPORT=pwm%u", pwm->hwpwm);
+	pwm_prop[1] = NULL;
+	kobject_uevent_env(&parent->kobj, KOBJ_CHANGE, pwm_prop);
+	kfree(pwm_prop[0]);
 
 	return 0;
 }
@@ -288,6 +293,7 @@ static int pwm_unexport_match(struct device *child, void *data)
 static int pwm_unexport_child(struct device *parent, struct pwm_device *pwm)
 {
 	struct device *child;
+	char *pwm_prop[2];
 
 	if (!test_and_clear_bit(PWMF_EXPORTED, &pwm->flags))
 		return -ENODEV;
@@ -296,6 +302,11 @@ static int pwm_unexport_child(struct device *parent, struct pwm_device *pwm)
 	if (!child)
 		return -ENODEV;
 
+	pwm_prop[0] = kasprintf(GFP_KERNEL, "UNEXPORT=pwm%u", pwm->hwpwm);
+	pwm_prop[1] = NULL;
+	kobject_uevent_env(&parent->kobj, KOBJ_CHANGE, pwm_prop);
+	kfree(pwm_prop[0]);
+
 	/* for device_find_child() */
 	put_device(child);
 	device_unregister(child);

commit c289d6625237aa785b484b4e94c23b3b91ea7e60
Author: Fabrice Gasnier <fabrice.gasnier@st.com>
Date:   Mon Oct 1 15:23:56 2018 +0200

    Revert "pwm: Set class for exported channels in sysfs"
    
    This reverts commit 7e5d1fd75c3dde9fc10c4472b9368089d1b81d00 ("pwm: Set
    class for exported channels in sysfs") as it causes regression with
    multiple pwm chip[1], when exporting a pwm channel (echo X > export):
    
    - ABI (Documentation/ABI/testing/sysfs-class-pwm) states pwmX should be
      created in /sys/class/pwm/pwmchipN/pwmX
    - Reverted patch causes new entry to be also created directly in
      /sys/class/pwm/pwmX
    - 1st time, exporting pwmX will create an entry in /sys/class/pwm/pwmX
    - class attributes are added under pwmX folder, such as export, unexport
      npwm, symlinks. This is wrong as it belongs to pwmchipN. It may cause
      bad behavior and report wrong values.
    - when another export happens on another pwmchip, it can't be created
      (e.g. -EEXIST). This is causing the issue with multiple pwmchip.
    
    Example on stm32 (stm32429i-eval) platform:
    $ ls /sys/class/pwm
    pwmchip0 pwmchip4
    
    $ cd /sys/class/pwm/pwmchip0/
    $ echo 0 > export
    $ ls /sys/class/pwm
    pwm0 pwmchip0 pwmchip4
    
    $ cd /sys/class/pwm/pwmchip4/
    $ echo 0 > export
    sysfs: cannot create duplicate filename '/class/pwm/pwm0'
    ...Exception stack follows...
    
    This is also seen on other platform [2]
    
    [1] https://lkml.org/lkml/2018/9/25/713
    [2] https://lkml.org/lkml/2018/9/25/447
    
    Signed-off-by: Fabrice Gasnier <fabrice.gasnier@st.com>
    Tested-by: Gottfried Haider <gottfried.haider@gmail.com>
    Tested-by: Michal Vokáč <michal.vokac@ysoft.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 7c71cdb8a9d8..4726d43aaa0c 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -263,7 +263,6 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 	export->pwm = pwm;
 	mutex_init(&export->lock);
 
-	export->child.class = parent->class;
 	export->child.release = pwm_export_release;
 	export->child.parent = parent;
 	export->child.devt = MKDEV(0, 0);

commit 8bbf5b426160343b554117eb9abdf4dad9a50e65
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Mar 8 15:27:37 2018 +0530

    pwm: sysfs: Use put_device() instead of kfree()
    
    Never directly free @dev after calling device_register(), even if it
    returned an error! Always use put_device() to give up the reference
    initialized.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 83f2b0b15712..7c71cdb8a9d8 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -273,7 +273,8 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 	ret = device_register(&export->child);
 	if (ret) {
 		clear_bit(PWMF_EXPORTED, &pwm->flags);
-		kfree(export);
+		put_device(&export->child);
+		export = NULL;
 		return ret;
 	}
 

commit 7e5d1fd75c3dde9fc10c4472b9368089d1b81d00
Author: Gottfried Haider <gottfried.haider@gmail.com>
Date:   Tue Sep 26 11:59:51 2017 +0000

    pwm: Set class for exported channels in sysfs
    
    Notifications for devices without bus or class set get dropped by
    dev_uevent_filter(). Adding the class to the exported child matches
    what the GPIO subsystem is doing.
    
    With this change exporting a channel triggers a udev event, which
    gives userspace a chance to fixup permissions and makes it possible
    for non-root users to make use of the PWM subsystem.
    
    Signed-off-by: Gottfried Haider <gottfried.haider@gmail.com>
    CC: Thierry Reding <thierry.reding@gmail.com>
    CC: H Hartley Sweeten <hsweeten@visionengravers.com>
    CC: linux-pwm@vger.kernel.org
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-rpi-kernel@lists.infradead.org
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index a813239300c3..83f2b0b15712 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -263,6 +263,7 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 	export->pwm = pwm;
 	mutex_init(&export->lock);
 
+	export->child.class = parent->class;
 	export->child.release = pwm_export_release;
 	export->child.parent = parent;
 	export->child.devt = MKDEV(0, 0);

commit 0e1614ac84f1719d87bed577963bb8140d0c9ce8
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 1 11:46:39 2016 +0100

    pwm: Fix device reference leak
    
    Make sure to drop the reference to the parent device taken by
    class_find_device() after "unexporting" any children when deregistering
    a PWM chip.
    
    Fixes: 0733424c9ba9 ("pwm: Unexport children before chip removal")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 0296d8178ae2..a813239300c3 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -425,6 +425,8 @@ void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)
 		if (test_bit(PWMF_EXPORTED, &pwm->flags))
 			pwm_unexport_child(parent, pwm);
 	}
+
+	put_device(parent);
 }
 
 static int __init pwm_sysfs_init(void)

commit 0733424c9ba9f42242409d1ece780777272f7ea1
Author: David Hsu <davidhsu@google.com>
Date:   Tue Aug 9 14:57:46 2016 -0700

    pwm: Unexport children before chip removal
    
    Exported pwm channels aren't removed before the pwmchip and are
    leaked. This results in invalid sysfs files. This fix removes
    all exported pwm channels before chip removal.
    
    Signed-off-by: David Hsu <davidhsu@google.com>
    Fixes: 76abbdde2d95 ("pwm: Add sysfs interface")
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 18ed725594c3..0296d8178ae2 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -409,6 +409,24 @@ void pwmchip_sysfs_unexport(struct pwm_chip *chip)
 	}
 }
 
+void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)
+{
+	struct device *parent;
+	unsigned int i;
+
+	parent = class_find_device(&pwm_class, NULL, chip,
+				   pwmchip_sysfs_match);
+	if (!parent)
+		return;
+
+	for (i = 0; i < chip->npwm; i++) {
+		struct pwm_device *pwm = &chip->pwms[i];
+
+		if (test_bit(PWMF_EXPORTED, &pwm->flags))
+			pwm_unexport_child(parent, pwm);
+	}
+}
+
 static int __init pwm_sysfs_init(void)
 {
 	return class_register(&pwm_class);

commit bd2686122d3b45db1398776921bd47fedfd6d6a5
Merge: 489babeae6b9 1a366fe9153f
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Jul 25 16:23:39 2016 +0200

    Merge branch 'for-4.8/capture' into for-next

commit 1a366fe9153f445e950a7a344932b7419aa83094
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Jun 8 10:21:25 2016 +0100

    pwm: sysfs: Add PWM capture support
    
    Allow a user to read PWM capture results from sysfs. To start a capture
    and read the result, simply read the file:
    
      $ cat $PWMCHIP/capture
    
    The output format is "<period> <duty cycle>".
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index d98599249a05..c3b1b563480e 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -208,16 +208,33 @@ static ssize_t polarity_store(struct device *child,
 	return ret ? : size;
 }
 
+static ssize_t capture_show(struct device *child,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_capture result;
+	int ret;
+
+	ret = pwm_capture(pwm, &result, jiffies_to_msecs(HZ));
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%u %u\n", result.period, result.duty_cycle);
+}
+
 static DEVICE_ATTR_RW(period);
 static DEVICE_ATTR_RW(duty_cycle);
 static DEVICE_ATTR_RW(enable);
 static DEVICE_ATTR_RW(polarity);
+static DEVICE_ATTR_RO(capture);
 
 static struct attribute *pwm_attrs[] = {
 	&dev_attr_period.attr,
 	&dev_attr_duty_cycle.attr,
 	&dev_attr_enable.attr,
 	&dev_attr_polarity.attr,
+	&dev_attr_capture.attr,
 	NULL
 };
 ATTRIBUTE_GROUPS(pwm);

commit fe5aa34d6eb9c4d34071845f70f3714b41c8a77d
Author: Ryo Kodama <ryo.kodama.vz@renesas.com>
Date:   Wed Jun 8 10:58:23 2016 +0900

    pwm: sysfs: Get return value from pwm_apply_state()
    
    This patch adds to check the return value from pwm_apply_state()
    used in enable_store(). The error of enable_store() doesn't work
    if the return value doesn't received.
    
    Signed-off-by: Ryo Kodama <ryo.kodama.vz@renesas.com>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Fixes: 39100ceea79f ("pwm: Switch to the atomic API")
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index d98599249a05..01695d48dd54 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -152,7 +152,7 @@ static ssize_t enable_store(struct device *child,
 		goto unlock;
 	}
 
-	pwm_apply_state(pwm, &state);
+	ret = pwm_apply_state(pwm, &state);
 
 unlock:
 	mutex_unlock(&export->lock);

commit 39100ceea79ff2efeb2fb094baf120c73d5ccf47
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:43 2016 +0200

    pwm: Switch to the atomic API
    
    Replace legacy pwm_get/set_xxx() and pwm_config/enable/disable() calls
    by pwm_get/apply_state().
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 187ca0875cf6..d98599249a05 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -46,8 +46,11 @@ static ssize_t period_show(struct device *child,
 			   char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_state state;
 
-	return sprintf(buf, "%u\n", pwm_get_period(pwm));
+	pwm_get_state(pwm, &state);
+
+	return sprintf(buf, "%u\n", state.period);
 }
 
 static ssize_t period_store(struct device *child,
@@ -56,6 +59,7 @@ static ssize_t period_store(struct device *child,
 {
 	struct pwm_export *export = child_to_pwm_export(child);
 	struct pwm_device *pwm = export->pwm;
+	struct pwm_state state;
 	unsigned int val;
 	int ret;
 
@@ -64,7 +68,9 @@ static ssize_t period_store(struct device *child,
 		return ret;
 
 	mutex_lock(&export->lock);
-	ret = pwm_config(pwm, pwm_get_duty_cycle(pwm), val);
+	pwm_get_state(pwm, &state);
+	state.period = val;
+	ret = pwm_apply_state(pwm, &state);
 	mutex_unlock(&export->lock);
 
 	return ret ? : size;
@@ -75,8 +81,11 @@ static ssize_t duty_cycle_show(struct device *child,
 			       char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
 
-	return sprintf(buf, "%u\n", pwm_get_duty_cycle(pwm));
+	return sprintf(buf, "%u\n", state.duty_cycle);
 }
 
 static ssize_t duty_cycle_store(struct device *child,
@@ -85,6 +94,7 @@ static ssize_t duty_cycle_store(struct device *child,
 {
 	struct pwm_export *export = child_to_pwm_export(child);
 	struct pwm_device *pwm = export->pwm;
+	struct pwm_state state;
 	unsigned int val;
 	int ret;
 
@@ -93,7 +103,9 @@ static ssize_t duty_cycle_store(struct device *child,
 		return ret;
 
 	mutex_lock(&export->lock);
-	ret = pwm_config(pwm, val, pwm_get_period(pwm));
+	pwm_get_state(pwm, &state);
+	state.duty_cycle = val;
+	ret = pwm_apply_state(pwm, &state);
 	mutex_unlock(&export->lock);
 
 	return ret ? : size;
@@ -104,8 +116,11 @@ static ssize_t enable_show(struct device *child,
 			   char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_state state;
 
-	return sprintf(buf, "%d\n", pwm_is_enabled(pwm));
+	pwm_get_state(pwm, &state);
+
+	return sprintf(buf, "%d\n", state.enabled);
 }
 
 static ssize_t enable_store(struct device *child,
@@ -114,6 +129,7 @@ static ssize_t enable_store(struct device *child,
 {
 	struct pwm_export *export = child_to_pwm_export(child);
 	struct pwm_device *pwm = export->pwm;
+	struct pwm_state state;
 	int val, ret;
 
 	ret = kstrtoint(buf, 0, &val);
@@ -122,20 +138,24 @@ static ssize_t enable_store(struct device *child,
 
 	mutex_lock(&export->lock);
 
+	pwm_get_state(pwm, &state);
+
 	switch (val) {
 	case 0:
-		pwm_disable(pwm);
+		state.enabled = false;
 		break;
 	case 1:
-		ret = pwm_enable(pwm);
+		state.enabled = true;
 		break;
 	default:
 		ret = -EINVAL;
-		break;
+		goto unlock;
 	}
 
-	mutex_unlock(&export->lock);
+	pwm_apply_state(pwm, &state);
 
+unlock:
+	mutex_unlock(&export->lock);
 	return ret ? : size;
 }
 
@@ -145,8 +165,11 @@ static ssize_t polarity_show(struct device *child,
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 	const char *polarity = "unknown";
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
 
-	switch (pwm_get_polarity(pwm)) {
+	switch (state.polarity) {
 	case PWM_POLARITY_NORMAL:
 		polarity = "normal";
 		break;
@@ -166,6 +189,7 @@ static ssize_t polarity_store(struct device *child,
 	struct pwm_export *export = child_to_pwm_export(child);
 	struct pwm_device *pwm = export->pwm;
 	enum pwm_polarity polarity;
+	struct pwm_state state;
 	int ret;
 
 	if (sysfs_streq(buf, "normal"))
@@ -176,7 +200,9 @@ static ssize_t polarity_store(struct device *child,
 		return -EINVAL;
 
 	mutex_lock(&export->lock);
-	ret = pwm_set_polarity(pwm, polarity);
+	pwm_get_state(pwm, &state);
+	state.polarity = polarity;
+	ret = pwm_apply_state(pwm, &state);
 	mutex_unlock(&export->lock);
 
 	return ret ? : size;

commit 459a25afe97cb3d7f978b90c881f4d7aac8fb755
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Wed Mar 30 22:03:27 2016 +0200

    pwm: Get rid of pwm->lock
    
    PWM devices are not protected against concurrent accesses. The lock in
    struct pwm_device might let PWM users think it is, but it's actually
    only protecting the enabled state.
    
    Removing this lock should be fine as long as all PWM users are aware
    that accesses to the PWM device have to be serialized, which seems to be
    the case for all of them except the sysfs interface. Patch the sysfs
    code by adding a lock to the pwm_export struct and making sure it's
    taken for all relevant accesses to the exported PWM device.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 9c90886f4123..187ca0875cf6 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -26,6 +26,7 @@
 struct pwm_export {
 	struct device child;
 	struct pwm_device *pwm;
+	struct mutex lock;
 };
 
 static struct pwm_export *child_to_pwm_export(struct device *child)
@@ -53,7 +54,8 @@ static ssize_t period_store(struct device *child,
 			    struct device_attribute *attr,
 			    const char *buf, size_t size)
 {
-	struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_export *export = child_to_pwm_export(child);
+	struct pwm_device *pwm = export->pwm;
 	unsigned int val;
 	int ret;
 
@@ -61,7 +63,9 @@ static ssize_t period_store(struct device *child,
 	if (ret)
 		return ret;
 
+	mutex_lock(&export->lock);
 	ret = pwm_config(pwm, pwm_get_duty_cycle(pwm), val);
+	mutex_unlock(&export->lock);
 
 	return ret ? : size;
 }
@@ -79,7 +83,8 @@ static ssize_t duty_cycle_store(struct device *child,
 				struct device_attribute *attr,
 				const char *buf, size_t size)
 {
-	struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_export *export = child_to_pwm_export(child);
+	struct pwm_device *pwm = export->pwm;
 	unsigned int val;
 	int ret;
 
@@ -87,7 +92,9 @@ static ssize_t duty_cycle_store(struct device *child,
 	if (ret)
 		return ret;
 
+	mutex_lock(&export->lock);
 	ret = pwm_config(pwm, val, pwm_get_period(pwm));
+	mutex_unlock(&export->lock);
 
 	return ret ? : size;
 }
@@ -105,13 +112,16 @@ static ssize_t enable_store(struct device *child,
 			    struct device_attribute *attr,
 			    const char *buf, size_t size)
 {
-	struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_export *export = child_to_pwm_export(child);
+	struct pwm_device *pwm = export->pwm;
 	int val, ret;
 
 	ret = kstrtoint(buf, 0, &val);
 	if (ret)
 		return ret;
 
+	mutex_lock(&export->lock);
+
 	switch (val) {
 	case 0:
 		pwm_disable(pwm);
@@ -124,6 +134,8 @@ static ssize_t enable_store(struct device *child,
 		break;
 	}
 
+	mutex_unlock(&export->lock);
+
 	return ret ? : size;
 }
 
@@ -151,7 +163,8 @@ static ssize_t polarity_store(struct device *child,
 			      struct device_attribute *attr,
 			      const char *buf, size_t size)
 {
-	struct pwm_device *pwm = child_to_pwm_device(child);
+	struct pwm_export *export = child_to_pwm_export(child);
+	struct pwm_device *pwm = export->pwm;
 	enum pwm_polarity polarity;
 	int ret;
 
@@ -162,7 +175,9 @@ static ssize_t polarity_store(struct device *child,
 	else
 		return -EINVAL;
 
+	mutex_lock(&export->lock);
 	ret = pwm_set_polarity(pwm, polarity);
+	mutex_unlock(&export->lock);
 
 	return ret ? : size;
 }
@@ -203,6 +218,7 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 	}
 
 	export->pwm = pwm;
+	mutex_init(&export->lock);
 
 	export->child.release = pwm_export_release;
 	export->child.parent = parent;

commit 65cdc6914a959d8e1ea562f05fb323a0b8cb7cb1
Author: Olliver Schinagl <oliver@schinagl.nl>
Date:   Mon Oct 26 22:32:37 2015 +0100

    pwm: sysfs: Make use of the DEVICE_ATTR_[RW][WO] macro's
    
    For the npwm property the PWM sysfs interface already made use of the
    DEVICE_ATTR_RO macro. This patch expands this to the other sysfs
    properties so that the code base is concise and makes use of this
    helpful macro.
    
    This has the advantage of slightly reducing the code size, improving
    readability and no longer using magic values for permissions.
    
    Signed-off-by: Olliver Schinagl <oliver@schinagl.nl>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index ba67845b9063..9c90886f4123 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -40,18 +40,18 @@ static struct pwm_device *child_to_pwm_device(struct device *child)
 	return export->pwm;
 }
 
-static ssize_t pwm_period_show(struct device *child,
-			       struct device_attribute *attr,
-			       char *buf)
+static ssize_t period_show(struct device *child,
+			   struct device_attribute *attr,
+			   char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 
 	return sprintf(buf, "%u\n", pwm_get_period(pwm));
 }
 
-static ssize_t pwm_period_store(struct device *child,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+static ssize_t period_store(struct device *child,
+			    struct device_attribute *attr,
+			    const char *buf, size_t size)
 {
 	struct pwm_device *pwm = child_to_pwm_device(child);
 	unsigned int val;
@@ -66,18 +66,18 @@ static ssize_t pwm_period_store(struct device *child,
 	return ret ? : size;
 }
 
-static ssize_t pwm_duty_cycle_show(struct device *child,
-				   struct device_attribute *attr,
-				   char *buf)
+static ssize_t duty_cycle_show(struct device *child,
+			       struct device_attribute *attr,
+			       char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 
 	return sprintf(buf, "%u\n", pwm_get_duty_cycle(pwm));
 }
 
-static ssize_t pwm_duty_cycle_store(struct device *child,
-				    struct device_attribute *attr,
-				    const char *buf, size_t size)
+static ssize_t duty_cycle_store(struct device *child,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
 {
 	struct pwm_device *pwm = child_to_pwm_device(child);
 	unsigned int val;
@@ -92,18 +92,18 @@ static ssize_t pwm_duty_cycle_store(struct device *child,
 	return ret ? : size;
 }
 
-static ssize_t pwm_enable_show(struct device *child,
-			       struct device_attribute *attr,
-			       char *buf)
+static ssize_t enable_show(struct device *child,
+			   struct device_attribute *attr,
+			   char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 
 	return sprintf(buf, "%d\n", pwm_is_enabled(pwm));
 }
 
-static ssize_t pwm_enable_store(struct device *child,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+static ssize_t enable_store(struct device *child,
+			    struct device_attribute *attr,
+			    const char *buf, size_t size)
 {
 	struct pwm_device *pwm = child_to_pwm_device(child);
 	int val, ret;
@@ -127,9 +127,9 @@ static ssize_t pwm_enable_store(struct device *child,
 	return ret ? : size;
 }
 
-static ssize_t pwm_polarity_show(struct device *child,
-				 struct device_attribute *attr,
-				 char *buf)
+static ssize_t polarity_show(struct device *child,
+			     struct device_attribute *attr,
+			     char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 	const char *polarity = "unknown";
@@ -147,9 +147,9 @@ static ssize_t pwm_polarity_show(struct device *child,
 	return sprintf(buf, "%s\n", polarity);
 }
 
-static ssize_t pwm_polarity_store(struct device *child,
-				  struct device_attribute *attr,
-				  const char *buf, size_t size)
+static ssize_t polarity_store(struct device *child,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
 {
 	struct pwm_device *pwm = child_to_pwm_device(child);
 	enum pwm_polarity polarity;
@@ -167,10 +167,10 @@ static ssize_t pwm_polarity_store(struct device *child,
 	return ret ? : size;
 }
 
-static DEVICE_ATTR(period, 0644, pwm_period_show, pwm_period_store);
-static DEVICE_ATTR(duty_cycle, 0644, pwm_duty_cycle_show, pwm_duty_cycle_store);
-static DEVICE_ATTR(enable, 0644, pwm_enable_show, pwm_enable_store);
-static DEVICE_ATTR(polarity, 0644, pwm_polarity_show, pwm_polarity_store);
+static DEVICE_ATTR_RW(period);
+static DEVICE_ATTR_RW(duty_cycle);
+static DEVICE_ATTR_RW(enable);
+static DEVICE_ATTR_RW(polarity);
 
 static struct attribute *pwm_attrs[] = {
 	&dev_attr_period.attr,
@@ -244,9 +244,9 @@ static int pwm_unexport_child(struct device *parent, struct pwm_device *pwm)
 	return 0;
 }
 
-static ssize_t pwm_export_store(struct device *parent,
-				struct device_attribute *attr,
-				const char *buf, size_t len)
+static ssize_t export_store(struct device *parent,
+			    struct device_attribute *attr,
+			    const char *buf, size_t len)
 {
 	struct pwm_chip *chip = dev_get_drvdata(parent);
 	struct pwm_device *pwm;
@@ -270,11 +270,11 @@ static ssize_t pwm_export_store(struct device *parent,
 
 	return ret ? : len;
 }
-static DEVICE_ATTR(export, 0200, NULL, pwm_export_store);
+static DEVICE_ATTR_WO(export);
 
-static ssize_t pwm_unexport_store(struct device *parent,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
+static ssize_t unexport_store(struct device *parent,
+			      struct device_attribute *attr,
+			      const char *buf, size_t len)
 {
 	struct pwm_chip *chip = dev_get_drvdata(parent);
 	unsigned int hwpwm;
@@ -291,7 +291,7 @@ static ssize_t pwm_unexport_store(struct device *parent,
 
 	return ret ? : len;
 }
-static DEVICE_ATTR(unexport, 0200, NULL, pwm_unexport_store);
+static DEVICE_ATTR_WO(unexport);
 
 static ssize_t npwm_show(struct device *parent, struct device_attribute *attr,
 			 char *buf)

commit 0344d0d69b3360ec551581c141c6599a0dcb5f27
Author: Olliver Schinagl <oliver@schinagl.nl>
Date:   Mon Oct 26 22:32:36 2015 +0100

    pwm: sysfs: Remove unnecessary temporary variable
    
    Use the result of pwm_is_enabled() directly instead of storing it in a
    temporary variable.
    
    Signed-off-by: Olliver Schinagl <oliver@schinagl.nl>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index c472772f00a7..ba67845b9063 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -97,9 +97,8 @@ static ssize_t pwm_enable_show(struct device *child,
 			       char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
-	int enabled = pwm_is_enabled(pwm);
 
-	return sprintf(buf, "%d\n", enabled);
+	return sprintf(buf, "%d\n", pwm_is_enabled(pwm));
 }
 
 static ssize_t pwm_enable_store(struct device *child,

commit 412820dd536fe2d01a35f0d68982ea225ec255b3
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Jul 20 09:58:09 2015 +0200

    pwm: sysfs: Remove unnecessary padding
    
    Padding initializers so that assignment operators align is bound to lead
    to inconsistencies or churn. Single spaces around the assignment is just
    fine.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index fbfc9e903230..c472772f00a7 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -312,9 +312,9 @@ static struct attribute *pwm_chip_attrs[] = {
 ATTRIBUTE_GROUPS(pwm_chip);
 
 static struct class pwm_class = {
-	.name		= "pwm",
-	.owner		= THIS_MODULE,
-	.dev_groups	= pwm_chip_groups,
+	.name = "pwm",
+	.owner = THIS_MODULE,
+	.dev_groups = pwm_chip_groups,
 };
 
 static int pwmchip_sysfs_match(struct device *parent, const void *data)

commit 5a063d87e97df28ca0b00807bc4d6fa11c5a5107
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Jul 20 09:56:05 2015 +0200

    pwm: sysfs: Properly convert from enum to string
    
    The current code will check for polarity in a boolean way. While it is
    correct that polarity is either normal or inversed, make it more obvious
    that it's an enumeration by using a switch statement and explicit
    matches on the enumeration values.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index ac0abecfbaa0..fbfc9e903230 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -133,9 +133,19 @@ static ssize_t pwm_polarity_show(struct device *child,
 				 char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
+	const char *polarity = "unknown";
 
-	return sprintf(buf, "%s\n",
-		       pwm_get_polarity(pwm) ? "inversed" : "normal");
+	switch (pwm_get_polarity(pwm)) {
+	case PWM_POLARITY_NORMAL:
+		polarity = "normal";
+		break;
+
+	case PWM_POLARITY_INVERSED:
+		polarity = "inversed";
+		break;
+	}
+
+	return sprintf(buf, "%s\n", polarity);
 }
 
 static ssize_t pwm_polarity_store(struct device *child,

commit 15da7b5001e498fa7dc619d4d7951f9665b071e4
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jul 1 10:21:50 2015 +0200

    pwm: Make use of pwm_get_xxx() helpers where appropriate
    
    Use the pwm_get_xxx() helpers instead of directly accessing the fields
    in struct pwm_device. This will allow us to smoothly move to the atomic
    update approach.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index eecf21d68108..ac0abecfbaa0 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -46,7 +46,7 @@ static ssize_t pwm_period_show(struct device *child,
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 
-	return sprintf(buf, "%u\n", pwm->period);
+	return sprintf(buf, "%u\n", pwm_get_period(pwm));
 }
 
 static ssize_t pwm_period_store(struct device *child,
@@ -61,7 +61,7 @@ static ssize_t pwm_period_store(struct device *child,
 	if (ret)
 		return ret;
 
-	ret = pwm_config(pwm, pwm->duty_cycle, val);
+	ret = pwm_config(pwm, pwm_get_duty_cycle(pwm), val);
 
 	return ret ? : size;
 }
@@ -72,7 +72,7 @@ static ssize_t pwm_duty_cycle_show(struct device *child,
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 
-	return sprintf(buf, "%u\n", pwm->duty_cycle);
+	return sprintf(buf, "%u\n", pwm_get_duty_cycle(pwm));
 }
 
 static ssize_t pwm_duty_cycle_store(struct device *child,
@@ -87,7 +87,7 @@ static ssize_t pwm_duty_cycle_store(struct device *child,
 	if (ret)
 		return ret;
 
-	ret = pwm_config(pwm, val, pwm->period);
+	ret = pwm_config(pwm, val, pwm_get_period(pwm));
 
 	return ret ? : size;
 }
@@ -134,7 +134,8 @@ static ssize_t pwm_polarity_show(struct device *child,
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
 
-	return sprintf(buf, "%s\n", pwm->polarity ? "inversed" : "normal");
+	return sprintf(buf, "%s\n",
+		       pwm_get_polarity(pwm) ? "inversed" : "normal");
 }
 
 static ssize_t pwm_polarity_store(struct device *child,

commit 5c31252c4a86dc591c23f1a951edd52ad791ef0e
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jul 1 10:21:47 2015 +0200

    pwm: Add the pwm_is_enabled() helper
    
    Some PWM drivers are testing the PWMF_ENABLED flag. Create a helper
    function to hide the logic behind enabled test. This will allow us to
    smoothly move from the current approach to an atomic PWM update
    approach.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 4bd0c639e16d..eecf21d68108 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -97,7 +97,7 @@ static ssize_t pwm_enable_show(struct device *child,
 			       char *buf)
 {
 	const struct pwm_device *pwm = child_to_pwm_device(child);
-	int enabled = test_bit(PWMF_ENABLED, &pwm->flags);
+	int enabled = pwm_is_enabled(pwm);
 
 	return sprintf(buf, "%d\n", enabled);
 }

commit 6ca142ad0d1bdf8dd116351b7b9a2bc5670d5271
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Dec 4 18:29:53 2013 +0800

    pwm: sysfs: Convert to use ATTRIBUTE_GROUPS macro
    
    Use new ATTRIBUTE_GROUPS macro to reduce the number of lines of code.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 8c20332d4825..4bd0c639e16d 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -169,15 +169,7 @@ static struct attribute *pwm_attrs[] = {
 	&dev_attr_polarity.attr,
 	NULL
 };
-
-static const struct attribute_group pwm_attr_group = {
-	.attrs		= pwm_attrs,
-};
-
-static const struct attribute_group *pwm_attr_groups[] = {
-	&pwm_attr_group,
-	NULL,
-};
+ATTRIBUTE_GROUPS(pwm);
 
 static void pwm_export_release(struct device *child)
 {
@@ -205,7 +197,7 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 	export->child.release = pwm_export_release;
 	export->child.parent = parent;
 	export->child.devt = MKDEV(0, 0);
-	export->child.groups = pwm_attr_groups;
+	export->child.groups = pwm_groups;
 	dev_set_name(&export->child, "pwm%u", pwm->hwpwm);
 
 	ret = device_register(&export->child);

commit 9da01759636f519967c0922ae12bd9fff739db9a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 24 15:05:39 2013 -0700

    pwm: convert class code to use dev_groups
    
    The dev_attrs field of struct class is going away soon, dev_groups
    should be used instead.  This converts the PWM class code to use the
    correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 8ca5de316d3b..8c20332d4825 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -268,6 +268,7 @@ static ssize_t pwm_export_store(struct device *parent,
 
 	return ret ? : len;
 }
+static DEVICE_ATTR(export, 0200, NULL, pwm_export_store);
 
 static ssize_t pwm_unexport_store(struct device *parent,
 				  struct device_attribute *attr,
@@ -288,27 +289,29 @@ static ssize_t pwm_unexport_store(struct device *parent,
 
 	return ret ? : len;
 }
+static DEVICE_ATTR(unexport, 0200, NULL, pwm_unexport_store);
 
-static ssize_t pwm_npwm_show(struct device *parent,
-			     struct device_attribute *attr,
-			     char *buf)
+static ssize_t npwm_show(struct device *parent, struct device_attribute *attr,
+			 char *buf)
 {
 	const struct pwm_chip *chip = dev_get_drvdata(parent);
 
 	return sprintf(buf, "%u\n", chip->npwm);
 }
+static DEVICE_ATTR_RO(npwm);
 
-static struct device_attribute pwm_chip_attrs[] = {
-	__ATTR(export, 0200, NULL, pwm_export_store),
-	__ATTR(unexport, 0200, NULL, pwm_unexport_store),
-	__ATTR(npwm, 0444, pwm_npwm_show, NULL),
-	__ATTR_NULL,
+static struct attribute *pwm_chip_attrs[] = {
+	&dev_attr_export.attr,
+	&dev_attr_unexport.attr,
+	&dev_attr_npwm.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(pwm_chip);
 
 static struct class pwm_class = {
 	.name		= "pwm",
 	.owner		= THIS_MODULE,
-	.dev_attrs	= pwm_chip_attrs,
+	.dev_groups	= pwm_chip_groups,
 };
 
 static int pwmchip_sysfs_match(struct device *parent, const void *data)

commit 76abbdde2d95a3807d0dc6bf9f84d03d0dbd4f3d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 11 10:38:59 2013 -0700

    pwm: Add sysfs interface
    
    Add a simple sysfs interface to the generic PWM framework.
    
      /sys/class/pwm/
      `-- pwmchipN/           for each PWM chip
          |-- export          (w/o) ask the kernel to export a PWM channel
          |-- npwm            (r/o) number of PWM channels in this PWM chip
          |-- pwmX/           for each exported PWM channel
          |   |-- duty_cycle  (r/w) duty cycle (in nanoseconds)
          |   |-- enable      (r/w) enable/disable PWM
          |   |-- period      (r/w) period (in nanoseconds)
          |   `-- polarity    (r/w) polarity of PWM (normal/inversed)
          `-- unexport        (w/o) return a PWM channel to the kernel
    
    Based on work by Lars Poeschel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Lars Poeschel <poeschel@lemonage.de>
    Cc: Ryan Mallon <rmallon@gmail.com>
    Cc: Rob Landley <rob@landley.net>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
new file mode 100644
index 000000000000..8ca5de316d3b
--- /dev/null
+++ b/drivers/pwm/sysfs.c
@@ -0,0 +1,352 @@
+/*
+ * A simple sysfs interface for the generic PWM framework
+ *
+ * Copyright (C) 2013 H Hartley Sweeten <hsweeten@visionengravers.com>
+ *
+ * Based on previous work by Lars Poeschel <poeschel@lemonage.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/kdev_t.h>
+#include <linux/pwm.h>
+
+struct pwm_export {
+	struct device child;
+	struct pwm_device *pwm;
+};
+
+static struct pwm_export *child_to_pwm_export(struct device *child)
+{
+	return container_of(child, struct pwm_export, child);
+}
+
+static struct pwm_device *child_to_pwm_device(struct device *child)
+{
+	struct pwm_export *export = child_to_pwm_export(child);
+
+	return export->pwm;
+}
+
+static ssize_t pwm_period_show(struct device *child,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	const struct pwm_device *pwm = child_to_pwm_device(child);
+
+	return sprintf(buf, "%u\n", pwm->period);
+}
+
+static ssize_t pwm_period_store(struct device *child,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct pwm_device *pwm = child_to_pwm_device(child);
+	unsigned int val;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	ret = pwm_config(pwm, pwm->duty_cycle, val);
+
+	return ret ? : size;
+}
+
+static ssize_t pwm_duty_cycle_show(struct device *child,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	const struct pwm_device *pwm = child_to_pwm_device(child);
+
+	return sprintf(buf, "%u\n", pwm->duty_cycle);
+}
+
+static ssize_t pwm_duty_cycle_store(struct device *child,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	struct pwm_device *pwm = child_to_pwm_device(child);
+	unsigned int val;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	ret = pwm_config(pwm, val, pwm->period);
+
+	return ret ? : size;
+}
+
+static ssize_t pwm_enable_show(struct device *child,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	const struct pwm_device *pwm = child_to_pwm_device(child);
+	int enabled = test_bit(PWMF_ENABLED, &pwm->flags);
+
+	return sprintf(buf, "%d\n", enabled);
+}
+
+static ssize_t pwm_enable_store(struct device *child,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct pwm_device *pwm = child_to_pwm_device(child);
+	int val, ret;
+
+	ret = kstrtoint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	switch (val) {
+	case 0:
+		pwm_disable(pwm);
+		break;
+	case 1:
+		ret = pwm_enable(pwm);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret ? : size;
+}
+
+static ssize_t pwm_polarity_show(struct device *child,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	const struct pwm_device *pwm = child_to_pwm_device(child);
+
+	return sprintf(buf, "%s\n", pwm->polarity ? "inversed" : "normal");
+}
+
+static ssize_t pwm_polarity_store(struct device *child,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	struct pwm_device *pwm = child_to_pwm_device(child);
+	enum pwm_polarity polarity;
+	int ret;
+
+	if (sysfs_streq(buf, "normal"))
+		polarity = PWM_POLARITY_NORMAL;
+	else if (sysfs_streq(buf, "inversed"))
+		polarity = PWM_POLARITY_INVERSED;
+	else
+		return -EINVAL;
+
+	ret = pwm_set_polarity(pwm, polarity);
+
+	return ret ? : size;
+}
+
+static DEVICE_ATTR(period, 0644, pwm_period_show, pwm_period_store);
+static DEVICE_ATTR(duty_cycle, 0644, pwm_duty_cycle_show, pwm_duty_cycle_store);
+static DEVICE_ATTR(enable, 0644, pwm_enable_show, pwm_enable_store);
+static DEVICE_ATTR(polarity, 0644, pwm_polarity_show, pwm_polarity_store);
+
+static struct attribute *pwm_attrs[] = {
+	&dev_attr_period.attr,
+	&dev_attr_duty_cycle.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_polarity.attr,
+	NULL
+};
+
+static const struct attribute_group pwm_attr_group = {
+	.attrs		= pwm_attrs,
+};
+
+static const struct attribute_group *pwm_attr_groups[] = {
+	&pwm_attr_group,
+	NULL,
+};
+
+static void pwm_export_release(struct device *child)
+{
+	struct pwm_export *export = child_to_pwm_export(child);
+
+	kfree(export);
+}
+
+static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
+{
+	struct pwm_export *export;
+	int ret;
+
+	if (test_and_set_bit(PWMF_EXPORTED, &pwm->flags))
+		return -EBUSY;
+
+	export = kzalloc(sizeof(*export), GFP_KERNEL);
+	if (!export) {
+		clear_bit(PWMF_EXPORTED, &pwm->flags);
+		return -ENOMEM;
+	}
+
+	export->pwm = pwm;
+
+	export->child.release = pwm_export_release;
+	export->child.parent = parent;
+	export->child.devt = MKDEV(0, 0);
+	export->child.groups = pwm_attr_groups;
+	dev_set_name(&export->child, "pwm%u", pwm->hwpwm);
+
+	ret = device_register(&export->child);
+	if (ret) {
+		clear_bit(PWMF_EXPORTED, &pwm->flags);
+		kfree(export);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int pwm_unexport_match(struct device *child, void *data)
+{
+	return child_to_pwm_device(child) == data;
+}
+
+static int pwm_unexport_child(struct device *parent, struct pwm_device *pwm)
+{
+	struct device *child;
+
+	if (!test_and_clear_bit(PWMF_EXPORTED, &pwm->flags))
+		return -ENODEV;
+
+	child = device_find_child(parent, pwm, pwm_unexport_match);
+	if (!child)
+		return -ENODEV;
+
+	/* for device_find_child() */
+	put_device(child);
+	device_unregister(child);
+	pwm_put(pwm);
+
+	return 0;
+}
+
+static ssize_t pwm_export_store(struct device *parent,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	struct pwm_chip *chip = dev_get_drvdata(parent);
+	struct pwm_device *pwm;
+	unsigned int hwpwm;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &hwpwm);
+	if (ret < 0)
+		return ret;
+
+	if (hwpwm >= chip->npwm)
+		return -ENODEV;
+
+	pwm = pwm_request_from_chip(chip, hwpwm, "sysfs");
+	if (IS_ERR(pwm))
+		return PTR_ERR(pwm);
+
+	ret = pwm_export_child(parent, pwm);
+	if (ret < 0)
+		pwm_put(pwm);
+
+	return ret ? : len;
+}
+
+static ssize_t pwm_unexport_store(struct device *parent,
+				  struct device_attribute *attr,
+				  const char *buf, size_t len)
+{
+	struct pwm_chip *chip = dev_get_drvdata(parent);
+	unsigned int hwpwm;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &hwpwm);
+	if (ret < 0)
+		return ret;
+
+	if (hwpwm >= chip->npwm)
+		return -ENODEV;
+
+	ret = pwm_unexport_child(parent, &chip->pwms[hwpwm]);
+
+	return ret ? : len;
+}
+
+static ssize_t pwm_npwm_show(struct device *parent,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	const struct pwm_chip *chip = dev_get_drvdata(parent);
+
+	return sprintf(buf, "%u\n", chip->npwm);
+}
+
+static struct device_attribute pwm_chip_attrs[] = {
+	__ATTR(export, 0200, NULL, pwm_export_store),
+	__ATTR(unexport, 0200, NULL, pwm_unexport_store),
+	__ATTR(npwm, 0444, pwm_npwm_show, NULL),
+	__ATTR_NULL,
+};
+
+static struct class pwm_class = {
+	.name		= "pwm",
+	.owner		= THIS_MODULE,
+	.dev_attrs	= pwm_chip_attrs,
+};
+
+static int pwmchip_sysfs_match(struct device *parent, const void *data)
+{
+	return dev_get_drvdata(parent) == data;
+}
+
+void pwmchip_sysfs_export(struct pwm_chip *chip)
+{
+	struct device *parent;
+
+	/*
+	 * If device_create() fails the pwm_chip is still usable by
+	 * the kernel its just not exported.
+	 */
+	parent = device_create(&pwm_class, chip->dev, MKDEV(0, 0), chip,
+			       "pwmchip%d", chip->base);
+	if (IS_ERR(parent)) {
+		dev_warn(chip->dev,
+			 "device_create failed for pwm_chip sysfs export\n");
+	}
+}
+
+void pwmchip_sysfs_unexport(struct pwm_chip *chip)
+{
+	struct device *parent;
+
+	parent = class_find_device(&pwm_class, NULL, chip,
+				   pwmchip_sysfs_match);
+	if (parent) {
+		/* for class_find_device() */
+		put_device(parent);
+		device_unregister(parent);
+	}
+}
+
+static int __init pwm_sysfs_init(void)
+{
+	return class_register(&pwm_class);
+}
+subsys_initcall(pwm_sysfs_init);
