commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index 757230e1f575..48f34d20aecd 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Intel Low Power Subsystem PWM controller driver
  *
  * Copyright (C) 2014, Intel Corporation
  *
  * Derived from the original pwm-lpss.c
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/acpi.h>

commit 4743765babb278a7d399df5733fc8a6b6bbedf3e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Oct 14 17:12:01 2018 +0200

    pwm: lpss: Force runtime-resume on suspend on Cherry Trail
    
    On Cherry Trail devices under Windows the PWM controller used for the
    backlight is considered part of the GPU even though it is part of the LPSS
    block and thus is an entirely different independent hardware unit.
    
    Because of this on Cherry Trail the GPU's (GFX0 ACPI node) _PS3 and _PS0
    methods save and restore the PWM controller registers.
    
    If userspace blanks the screen before suspending, such as e.g. GNOME
    does, then the PWM controller will be runtime-suspended when the suspend
    starts. This causes the GFX0 _PS? methods to save a value of 0xffffffff
    for the PWM control register and to restore this value on resume.
    
    0xffffffff is not a valid value for the register and writing this causes
    problems such as e.g. a flickering backlight.
    
    This commit adds a prepare method to the dev_pm_ops and makes it return 0
    on Cherry Trail devices forcing a runtime-resume before other device's
    suspend methods run. This fixes the reading and writing back of 0xffffffff.
    
    Since we now always runtime-resume the device on suspend, it will be
    resumed on resume too and we no longer need to check for the GFX0 _PS0
    method having resumed it underneath us, so this commit removes the now no
    longer necessary complete dev_pm_op.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index b6edf8af26cc..757230e1f575 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -30,7 +30,7 @@ static const struct pwm_lpss_boardinfo pwm_lpss_bsw_info = {
 	.clk_rate = 19200000,
 	.npwm = 1,
 	.base_unit_bits = 16,
-	.check_power_on_resume = true,
+	.other_devices_aml_touches_pwm_regs = true,
 };
 
 /* Broxton */
@@ -61,6 +61,7 @@ static int pwm_lpss_probe_platform(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, lpwm);
 
+	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_SMART_PREPARE);
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 
@@ -75,25 +76,22 @@ static int pwm_lpss_remove_platform(struct platform_device *pdev)
 	return pwm_lpss_remove(lpwm);
 }
 
-static void pwm_lpss_complete(struct device *dev)
+static int pwm_lpss_prepare(struct device *dev)
 {
 	struct pwm_lpss_chip *lpwm = dev_get_drvdata(dev);
-	int ret, state;
 
-	/* The PWM may be turned on by AML code, update our state to match */
-	if (pm_runtime_suspended(dev) && lpwm->info->check_power_on_resume) {
-		pm_runtime_disable(dev);
+	/*
+	 * If other device's AML code touches the PWM regs on suspend/resume
+	 * force runtime-resume the PWM controller to allow this.
+	 */
+	if (lpwm->info->other_devices_aml_touches_pwm_regs)
+		return 0; /* Force runtime-resume */
 
-		ret = acpi_device_get_power(ACPI_COMPANION(dev), &state);
-		if (ret == 0 && state == ACPI_STATE_D0)
-			pm_runtime_set_active(dev);
-
-		pm_runtime_enable(dev);
-	}
+	return 1; /* If runtime-suspended leave as is */
 }
 
 static const struct dev_pm_ops pwm_lpss_platform_pm_ops = {
-	.complete = pwm_lpss_complete,
+	.prepare = pwm_lpss_prepare,
 	SET_SYSTEM_SLEEP_PM_OPS(pwm_lpss_suspend, pwm_lpss_resume)
 };
 

commit 6a425ecd19a2c0e19a501323216ecf987de07841
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 12 12:12:27 2018 +0200

    pwm: lpss: Check PWM powerstate after resume on Cherry Trail devices
    
    The _PS0 method for the integrated graphics on some Cherry Trail devices
    (observed on a HP Pavilion X2 10-p0XX) turns on the PWM chip (puts it in
    D0), causing an inconsistency between the state the pm-core thinks it is
    in (left runtime suspended as it was before the suspend/resume) and the
    state it actually is in.
    
    Interestingly enough this is done on a device where the pwm controller is
    not used for the backlight at all, since it uses an eDP panel. On devices
    where the PWM is used this is not a problem since we will resume it
    ourselves anyways.
    
    This inconsistency causes us to never suspend the pwm controller again,
    which causes the device to not be able to reach S0ix states when suspended.
    
    This commit adds a resume-complete handler, which when we think the device
    is still run-time suspended checks the actual power-state and if necessary
    updates the rpm-core's internal state.
    
    This fixes the Pavilion X2 10-p0XX not reaching S0ix states when suspended.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index 7304f36ee715..b6edf8af26cc 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -30,6 +30,7 @@ static const struct pwm_lpss_boardinfo pwm_lpss_bsw_info = {
 	.clk_rate = 19200000,
 	.npwm = 1,
 	.base_unit_bits = 16,
+	.check_power_on_resume = true,
 };
 
 /* Broxton */
@@ -74,9 +75,27 @@ static int pwm_lpss_remove_platform(struct platform_device *pdev)
 	return pwm_lpss_remove(lpwm);
 }
 
-static SIMPLE_DEV_PM_OPS(pwm_lpss_platform_pm_ops,
-			 pwm_lpss_suspend,
-			 pwm_lpss_resume);
+static void pwm_lpss_complete(struct device *dev)
+{
+	struct pwm_lpss_chip *lpwm = dev_get_drvdata(dev);
+	int ret, state;
+
+	/* The PWM may be turned on by AML code, update our state to match */
+	if (pm_runtime_suspended(dev) && lpwm->info->check_power_on_resume) {
+		pm_runtime_disable(dev);
+
+		ret = acpi_device_get_power(ACPI_COMPANION(dev), &state);
+		if (ret == 0 && state == ACPI_STATE_D0)
+			pm_runtime_set_active(dev);
+
+		pm_runtime_enable(dev);
+	}
+}
+
+static const struct dev_pm_ops pwm_lpss_platform_pm_ops = {
+	.complete = pwm_lpss_complete,
+	SET_SYSTEM_SLEEP_PM_OPS(pwm_lpss_suspend, pwm_lpss_resume)
+};
 
 static const struct acpi_device_id pwm_lpss_acpi_match[] = {
 	{ "80860F09", (unsigned long)&pwm_lpss_byt_info },

commit 1688c8717118f37191d824862a006c8373d261de
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 12 12:12:25 2018 +0200

    pwm: lpss: Add ACPI HID for second PWM controller on Cherry Trail devices
    
    The second PWM controller on Cherry Trail devices uses a separate ACPI
    HID: "80862289", add this so that the driver will properly bind to the
    second PWM controller.
    
    The second PWM controller is usually not used, the main thing gained by
    this is properly putting the PWM controller in D3 on suspend.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index 5561b9e190f8..7304f36ee715 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -81,6 +81,7 @@ static SIMPLE_DEV_PM_OPS(pwm_lpss_platform_pm_ops,
 static const struct acpi_device_id pwm_lpss_acpi_match[] = {
 	{ "80860F09", (unsigned long)&pwm_lpss_byt_info },
 	{ "80862288", (unsigned long)&pwm_lpss_bsw_info },
+	{ "80862289", (unsigned long)&pwm_lpss_bsw_info },
 	{ "80865AC8", (unsigned long)&pwm_lpss_bxt_info },
 	{ },
 };

commit 1d375b58c12f08d8570b30b865def4734517f04f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Apr 26 14:10:23 2018 +0200

    pwm: lpss: platform: Save/restore the ctrl register over a suspend/resume
    
    On some devices the contents of the ctrl register get lost over a
    suspend/resume and the PWM comes back up disabled after the resume.
    
    This is seen on some Bay Trail devices with the PWM in ACPI enumerated
    mode, so it shows up as a platform device instead of a PCI device.
    
    If we still think it is enabled and then try to change the duty-cycle
    after this, we end up with a "PWM_SW_UPDATE was not cleared" error and
    the PWM is stuck in that state from then on.
    
    This commit adds suspend and resume pm callbacks to the pwm-lpss-platform
    code, which save/restore the ctrl register over a suspend/resume, fixing
    this.
    
    Note that:
    
    1) There is no need to do this over a runtime suspend, since we
    only runtime suspend when disabled and then we properly set the enable
    bit and reprogram the timings when we re-enable the PWM.
    
    2) This may be happening on more systems then we realize, but has been
    covered up sofar by a bug in the acpi-lpss.c code which was save/restoring
    the regular device registers instead of the lpss private registers due to
    lpss_device_desc.prv_offset not being set. This is fixed by a later patch
    in this series.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index 5d6ed1507d29..5561b9e190f8 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -74,6 +74,10 @@ static int pwm_lpss_remove_platform(struct platform_device *pdev)
 	return pwm_lpss_remove(lpwm);
 }
 
+static SIMPLE_DEV_PM_OPS(pwm_lpss_platform_pm_ops,
+			 pwm_lpss_suspend,
+			 pwm_lpss_resume);
+
 static const struct acpi_device_id pwm_lpss_acpi_match[] = {
 	{ "80860F09", (unsigned long)&pwm_lpss_byt_info },
 	{ "80862288", (unsigned long)&pwm_lpss_bsw_info },
@@ -86,6 +90,7 @@ static struct platform_driver pwm_lpss_driver_platform = {
 	.driver = {
 		.name = "pwm-lpss",
 		.acpi_match_table = pwm_lpss_acpi_match,
+		.pm = &pwm_lpss_platform_pm_ops,
 	},
 	.probe = pwm_lpss_probe_platform,
 	.remove = pwm_lpss_remove_platform,

commit b997e3edca4fb4ab7732ab7240c545da0c360a44
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Apr 6 14:54:01 2017 +0300

    pwm: lpss: Set enable-bit before waiting for update-bit to go low
    
    At least on cherrytrail, the update bit will never go low when the
    enabled bit is not set.
    
    This causes the backlight on my cube iwork8 air tablet to never turn on
    again after being turned off because in the pwm_lpss_apply enable path
    pwm_lpss_update will fail causing an error exit and the enable-bit to
    never get set. Any following pwm_lpss_apply calls will fail the
    pwm_lpss_is_updating check.
    
    Since the docs say that the update bit should be set before the
    enable-bit, split pwm_lpss_update into setting the update-bit and
    pwm_lpss_wait_for_update, and move the pwm_lpss_wait_for_update call
    in the enable path to after setting the enable-bit.
    
    Fixes: 10d56a4 ("pwm: lpss: Avoid reconfiguring while UPDATE bit...")
    Cc: Ilkka Koskinen <ilkka.koskinen@intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index b22b6fdadb9a..5d6ed1507d29 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -37,6 +37,7 @@ static const struct pwm_lpss_boardinfo pwm_lpss_bxt_info = {
 	.clk_rate = 19200000,
 	.npwm = 4,
 	.base_unit_bits = 22,
+	.bypass = true,
 };
 
 static int pwm_lpss_probe_platform(struct platform_device *pdev)

commit 9900073cf5587662df9b7ef59f649ff100229d85
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Jan 28 17:10:43 2017 +0200

    pwm: lpss: Do not export board infos for different PWM types
    
    The PWM LPSS probe drivers just pass a pointer to the exported board
    info structures to pwm_lpss_probe() based on device PCI or ACPI ID.
    
    In order to remove the knowledge of specific devices from library part of
    the driver and reduce noise in exported namespace just duplicate the
    board info structures and stop exporting them.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index 54433fc6d1a4..b22b6fdadb9a 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -18,6 +18,27 @@
 
 #include "pwm-lpss.h"
 
+/* BayTrail */
+static const struct pwm_lpss_boardinfo pwm_lpss_byt_info = {
+	.clk_rate = 25000000,
+	.npwm = 1,
+	.base_unit_bits = 16,
+};
+
+/* Braswell */
+static const struct pwm_lpss_boardinfo pwm_lpss_bsw_info = {
+	.clk_rate = 19200000,
+	.npwm = 1,
+	.base_unit_bits = 16,
+};
+
+/* Broxton */
+static const struct pwm_lpss_boardinfo pwm_lpss_bxt_info = {
+	.clk_rate = 19200000,
+	.npwm = 4,
+	.base_unit_bits = 22,
+};
+
 static int pwm_lpss_probe_platform(struct platform_device *pdev)
 {
 	const struct pwm_lpss_boardinfo *info;

commit f080be27d7d9333e4815655a2cedab91c3aa7acc
Author: Qipeng Zha <qipeng.zha@intel.com>
Date:   Mon Oct 26 12:58:27 2015 +0200

    pwm: lpss: Add support for runtime PM
    
    To be able to save some power when PWM is not in use, add support for
    runtime PM for this driver. This also allows the platform to transition to
    low power S0ix states when the system is idle.
    
    Signed-off-by: Huiquan Zhong <huiquan.zhong@intel.com>
    Signed-off-by: Qipeng Zha <qipeng.zha@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index a914aacf6757..54433fc6d1a4 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -14,6 +14,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 
 #include "pwm-lpss.h"
 
@@ -36,6 +37,10 @@ static int pwm_lpss_probe_platform(struct platform_device *pdev)
 		return PTR_ERR(lpwm);
 
 	platform_set_drvdata(pdev, lpwm);
+
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
 	return 0;
 }
 
@@ -43,6 +48,7 @@ static int pwm_lpss_remove_platform(struct platform_device *pdev)
 {
 	struct pwm_lpss_chip *lpwm = platform_get_drvdata(pdev);
 
+	pm_runtime_disable(&pdev->dev);
 	return pwm_lpss_remove(lpwm);
 }
 

commit 03f00e5311d5d0d3ac716121865cb967259980ca
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Oct 20 16:53:07 2015 +0300

    pwm: lpss: Add more Intel Broxton IDs
    
    Add more Intel Broxton ACPI and PCI IDs to the driver supported devices
    list.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
index 18a9c880a76d..a914aacf6757 100644
--- a/drivers/pwm/pwm-lpss-platform.c
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -49,6 +49,7 @@ static int pwm_lpss_remove_platform(struct platform_device *pdev)
 static const struct acpi_device_id pwm_lpss_acpi_match[] = {
 	{ "80860F09", (unsigned long)&pwm_lpss_byt_info },
 	{ "80862288", (unsigned long)&pwm_lpss_bsw_info },
+	{ "80865AC8", (unsigned long)&pwm_lpss_bxt_info },
 	{ },
 };
 MODULE_DEVICE_TABLE(acpi, pwm_lpss_acpi_match);

commit c558e39e14c2372394f49e07fbe94e9708b615cb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 19 19:17:35 2014 +0300

    pwm: lpss: Properly split driver to parts
    
    The driver consists of core, PCI, and platform parts. It would be better
    to split them into separate files.
    
    The platform driver is now called pwm-lpss-platform. Thus, previously
    set CONFIG_PWM_LPSS=m is not enough to build it. But we are on the safe
    side since it seems no one from outside Intel is using it for now.
    
    While here, move to use macros module_pci_driver() and
    module_platform_driver().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    [thierry.reding: change select to depends on PWM_LPSS, cleanup]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpss-platform.c b/drivers/pwm/pwm-lpss-platform.c
new file mode 100644
index 000000000000..18a9c880a76d
--- /dev/null
+++ b/drivers/pwm/pwm-lpss-platform.c
@@ -0,0 +1,68 @@
+/*
+ * Intel Low Power Subsystem PWM controller driver
+ *
+ * Copyright (C) 2014, Intel Corporation
+ *
+ * Derived from the original pwm-lpss.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/acpi.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include "pwm-lpss.h"
+
+static int pwm_lpss_probe_platform(struct platform_device *pdev)
+{
+	const struct pwm_lpss_boardinfo *info;
+	const struct acpi_device_id *id;
+	struct pwm_lpss_chip *lpwm;
+	struct resource *r;
+
+	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
+	if (!id)
+		return -ENODEV;
+
+	info = (const struct pwm_lpss_boardinfo *)id->driver_data;
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	lpwm = pwm_lpss_probe(&pdev->dev, r, info);
+	if (IS_ERR(lpwm))
+		return PTR_ERR(lpwm);
+
+	platform_set_drvdata(pdev, lpwm);
+	return 0;
+}
+
+static int pwm_lpss_remove_platform(struct platform_device *pdev)
+{
+	struct pwm_lpss_chip *lpwm = platform_get_drvdata(pdev);
+
+	return pwm_lpss_remove(lpwm);
+}
+
+static const struct acpi_device_id pwm_lpss_acpi_match[] = {
+	{ "80860F09", (unsigned long)&pwm_lpss_byt_info },
+	{ "80862288", (unsigned long)&pwm_lpss_bsw_info },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, pwm_lpss_acpi_match);
+
+static struct platform_driver pwm_lpss_driver_platform = {
+	.driver = {
+		.name = "pwm-lpss",
+		.acpi_match_table = pwm_lpss_acpi_match,
+	},
+	.probe = pwm_lpss_probe_platform,
+	.remove = pwm_lpss_remove_platform,
+};
+module_platform_driver(pwm_lpss_driver_platform);
+
+MODULE_DESCRIPTION("PWM platform driver for Intel LPSS");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:pwm-lpss");
