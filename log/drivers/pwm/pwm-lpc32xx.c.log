commit a10e763b87134a9a4ca3a38b5c4b533e75ec63a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:32 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 372
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081036.435762997@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index a9b3cff96aac..710d9a207d2b 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -1,10 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 2012 Alexandre Pereira da Silva <aletes.xgr@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2.
- *
  */
 
 #include <linux/clk.h>

commit acfd92fdfb9384d54d9404101e8657e75c2372f3
Author: Sylvain Lemieux <slemieux@tycoint.com>
Date:   Mon Jun 27 09:09:55 2016 -0400

    pwm: lpc32xx: Set PWM_PIN_LEVEL bit to default value
    
    The PWM_PIN_LEVEL bit is leave unset by the kernel PWM driver.
    
    Prior to commit 08ee77b5a5de27ad63c92262ebcb4efe0da93b58,
    the PWM_PIN_LEVEL bit was always clear when the PWM was disable
    and a 0 logic level was apply to the output.
    
    According to the LPC32x0 User Manual [1],
    the default value for bit 30 (PWM_PIN_LEVEL) is 0.
    
    This change initialize the pin level to 0 (default value) and
    update the register value accordingly.
    
    [1] http://www.nxp.com/documents/user_manual/UM10326.pdf
    
    Signed-off-by: Sylvain Lemieux <slemieux@tycoint.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 4d470c1a406a..a9b3cff96aac 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -25,6 +25,7 @@ struct lpc32xx_pwm_chip {
 };
 
 #define PWM_ENABLE	BIT(31)
+#define PWM_PIN_LEVEL	BIT(30)
 
 #define to_lpc32xx_pwm_chip(_chip) \
 	container_of(_chip, struct lpc32xx_pwm_chip, chip)
@@ -103,6 +104,7 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 	struct lpc32xx_pwm_chip *lpc32xx;
 	struct resource *res;
 	int ret;
+	u32 val;
 
 	lpc32xx = devm_kzalloc(&pdev->dev, sizeof(*lpc32xx), GFP_KERNEL);
 	if (!lpc32xx)
@@ -128,6 +130,11 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/* When PWM is disable, configure the output to the default value */
+	val = readl(lpc32xx->base + (lpc32xx->chip.pwms[0].hwpwm << 2));
+	val &= ~PWM_PIN_LEVEL;
+	writel(val, lpc32xx->base + (lpc32xx->chip.pwms[0].hwpwm << 2));
+
 	platform_set_drvdata(pdev, lpc32xx);
 
 	return 0;

commit d6dbdf0ddefa581e49c2abe5fb0eb17d14111d89
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Sun Dec 6 13:32:02 2015 +0200

    pwm: lpc32xx: return ERANGE, if requested period is not supported
    
    Instead of silent acceptance of unsupported requested configuration
    for PWM period and setting the boundary supported value, return
    -ERANGE to a caller.
    
    Duty period value equal to 0 or period is still accepted to allow
    configuration by PWM sysfs interface, when it is set to 0 by default.
    
    For reference this is a list of restrictions on period_ns == 1/freq:
    
      | PWM parent clock | parent clock divisor | max freq | min freq |
      +------------------+----------------------+----------+----------+
      |   HCLK == 13 MHz |      1 (min)         | 50.7 KHz | 198.3 Hz |
      |   HCLK == 13 MHz |     15 (max)         | 3.38 KHz | 13.22 Hz |
      |  RTC == 32.7 KHz |      1 (min)         |   128 Hz |   0.5 Hz |
      |  RTC == 32.7 KHz |     15 (max)         | 8.533 Hz | 0.033 Hz |
    
    Note that PWM sysfs interface does not support setting of period more
    than NSEC_PER_SEC / MAX_INT32 ~ 2 seconds, however this PWM controller
    supports a period up to 30 seconds.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 294a68f82558..4d470c1a406a 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -41,9 +41,9 @@ static int lpc32xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 	/* The highest acceptable divisor is 256, which is represented by 0 */
 	period_cycles = div64_u64(c * period_ns,
 			       (unsigned long long)NSEC_PER_SEC * 256);
-	if (!period_cycles)
-		period_cycles = 1;
-	if (period_cycles > 255)
+	if (!period_cycles || period_cycles > 256)
+		return -ERANGE;
+	if (period_cycles == 256)
 		period_cycles = 0;
 
 	/* Compute 256 x #duty/period value and care for corner cases */

commit 5a9fc9c666d5d759699cf5495bda85f1da0d747e
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Sun Dec 6 13:32:01 2015 +0200

    pwm: lpc32xx: fix and simplify duty cycle and period calculations
    
    The change fixes a problem, if duty_ns is too small in comparison
    to period_ns (as a valid corner case duty_ns is 0 ns), then due to
    PWM_DUTY() macro applied on a value the result is overflowed over 8
    bits, and instead of the highest bitfield duty cycle value 0xff the
    invalid duty cycle bitfield value 0x00 is written.
    
    For reference the LPC32xx spec defines PWMx_DUTY bitfield description
    is this way and it seems to be correct:
    
     [Low]/[High] = [PWM_DUTY]/[256-PWM_DUTY], where 0 < PWM_DUTY <= 255.
    
    In addition according to my oscilloscope measurements LPC32xx PWM is
    "tristate" in sense that it produces a wave with floating min/max
    voltage levels for different duty cycle values, for corner cases:
    
      PWM_DUTY == 0x01 => signal is in range from -1.05v to 0v
      ....
      PWM_DUTY == 0x80 => signal is in range from -0.75v to +0.75v
      ....
      PWM_DUTY == 0xff => signal is in range from 0v to +1.05v
    
      PWM_DUTY == 0x00 => signal is around 0v, PWM is off
    
    Due to this peculiarity on very long period ranges (less than 1KHz)
    and odd pre-divider values PWM generated wave does not remind a
    clock shape signal, but rather a heartbit shape signal with positive
    and negative peaks, so I would recommend to use high-speed HCLK clock
    as a PWM parent clock and avoid using RTC clock as a parent.
    
    The change corrects PWM output in corner cases and prevents any
    possible overflows in calculation of values for PWM_DUTY and
    PWM_RELOADV bitfields, thus helper macro definitions may be removed.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 63468a872ca7..294a68f82558 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -24,9 +24,7 @@ struct lpc32xx_pwm_chip {
 	void __iomem *base;
 };
 
-#define PWM_ENABLE	(1 << 31)
-#define PWM_RELOADV(x)	(((x) & 0xFF) << 8)
-#define PWM_DUTY(x)	((x) & 0xFF)
+#define PWM_ENABLE	BIT(31)
 
 #define to_lpc32xx_pwm_chip(_chip) \
 	container_of(_chip, struct lpc32xx_pwm_chip, chip)
@@ -38,40 +36,27 @@ static int lpc32xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 	unsigned long long c;
 	int period_cycles, duty_cycles;
 	u32 val;
-
-	c = clk_get_rate(lpc32xx->clk) / 256;
-	c = c * period_ns;
-	do_div(c, NSEC_PER_SEC);
-
-	/* Handle high and low extremes */
-	if (c == 0)
-		c = 1;
-	if (c > 255)
-		c = 0; /* 0 set division by 256 */
-	period_cycles = c;
-
-	/* The duty-cycle value is as follows:
-	 *
-	 *  DUTY-CYCLE     HIGH LEVEL
-	 *      1            99.9%
-	 *      25           90.0%
-	 *      128          50.0%
-	 *      220          10.0%
-	 *      255           0.1%
-	 *      0             0.0%
-	 *
-	 * In other words, the register value is duty-cycle % 256 with
-	 * duty-cycle in the range 1-256.
-	 */
-	c = 256 * duty_ns;
-	do_div(c, period_ns);
-	if (c > 255)
-		c = 255;
-	duty_cycles = 256 - c;
+	c = clk_get_rate(lpc32xx->clk);
+
+	/* The highest acceptable divisor is 256, which is represented by 0 */
+	period_cycles = div64_u64(c * period_ns,
+			       (unsigned long long)NSEC_PER_SEC * 256);
+	if (!period_cycles)
+		period_cycles = 1;
+	if (period_cycles > 255)
+		period_cycles = 0;
+
+	/* Compute 256 x #duty/period value and care for corner cases */
+	duty_cycles = div64_u64((unsigned long long)(period_ns - duty_ns) * 256,
+				period_ns);
+	if (!duty_cycles)
+		duty_cycles = 1;
+	if (duty_cycles > 255)
+		duty_cycles = 255;
 
 	val = readl(lpc32xx->base + (pwm->hwpwm << 2));
 	val &= ~0xFFFF;
-	val |= PWM_RELOADV(period_cycles) | PWM_DUTY(duty_cycles);
+	val |= (period_cycles << 8) | duty_cycles;
 	writel(val, lpc32xx->base + (pwm->hwpwm << 2));
 
 	return 0;

commit 82aff048dde444334c7045fab620b13058ff15a7
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Sun Dec 6 13:32:00 2015 +0200

    pwm: lpc32xx: make device usable with common clock framework
    
    As a preparatory change for switching LPC32xx mach support to common
    clock framework fix clk_enable/clk_disable calls without matching
    clk_prepare/clk_unprepare.
    
    The driver can not be used on a platform with common clock framework
    until clk_prepare/clk_unprepare calls are added, otherwise clk_enable
    calls will fail and a WARN is generated:
    
        # echo 1 > /sys/bus/platform/drivers/lpc32xx-pwm/4005c000.pwm/pwm/pwmchip0/pwm0/enable
        ------------[ cut here ]------------
        WARNING: CPU: 0 PID: 701 at drivers/clk/clk.c:727 clk_core_enable+0x2c/0xa4()
        Modules linked in: sc16is7xx
        CPU: 0 PID: 701 Comm: sh Tainted: G        W       4.3.0-rc2+ #171
        Hardware name: LPC32XX SoC (Flattened Device Tree)
        Backtrace:
        [<>] (dump_backtrace) from [<>] (show_stack+0x18/0x1c)
        [<>] (show_stack) from [<>] (dump_stack+0x20/0x28)
        [<>] (dump_stack) from [<>] (warn_slowpath_common+0x90/0xb8)
        [<>] (warn_slowpath_common) from [<>] (warn_slowpath_null+0x24/0x2c)
        [<>] (warn_slowpath_null) from [<>] (clk_core_enable+0x2c/0xa4)
        [<>] (clk_core_enable) from [<>] (clk_enable+0x24/0x38)
        [<>] (clk_enable) from [<>] (lpc32xx_pwm_enable+0x1c/0x40)
        [<>] (lpc32xx_pwm_enable) from [<>] (pwm_enable+0x48/0x5c)
        [<>] (pwm_enable) from [<>] (pwm_enable_store+0x5c/0x78)
        [<>] (pwm_enable_store) from [<>] (dev_attr_store+0x20/0x2c)
        [<>] (dev_attr_store) from [<>] (sysfs_kf_write+0x44/0x50)
        [<>] (sysfs_kf_write) from [<>] (kernfs_fop_write+0x134/0x194)
        [<>] (kernfs_fop_write) from [<>] (__vfs_write+0x34/0xdc)
        [<>] (__vfs_write) from [<>] (vfs_write+0xb8/0x140)
        [<>] (vfs_write) from [<>] (SyS_write+0x50/0x90)
        [<>] (SyS_write) from [<>] (ret_fast_syscall+0x0/0x38)
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index ce8ab202be8b..63468a872ca7 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -83,7 +83,7 @@ static int lpc32xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 	u32 val;
 	int ret;
 
-	ret = clk_enable(lpc32xx->clk);
+	ret = clk_prepare_enable(lpc32xx->clk);
 	if (ret)
 		return ret;
 
@@ -103,7 +103,7 @@ static void lpc32xx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
 	val &= ~PWM_ENABLE;
 	writel(val, lpc32xx->base + (pwm->hwpwm << 2));
 
-	clk_disable(lpc32xx->clk);
+	clk_disable_unprepare(lpc32xx->clk);
 }
 
 static const struct pwm_ops lpc32xx_pwm_ops = {

commit ebe1fca35038df28b5c183e8486863e765364ec1
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Sun Dec 6 13:31:59 2015 +0200

    pwm: lpc32xx: correct number of PWM channels from 2 to 1
    
    LPC32xx SoC has two independent PWM controllers, they have different
    clock parents, clock gates and even slightly different controls, and
    each of these two PWM controllers has one output channel. Due to
    almost similar controls arranged in a row it is incorrectly set that
    there is one PWM controller with two channels, fix this problem, which
    at the moment prevents separate configuration of different clock
    parents and gates for both PWM controllers.
    
    The change makes previous PWM device node description incompatible
    with this update.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 9fde60ce8e7b..ce8ab202be8b 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -134,7 +134,7 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 
 	lpc32xx->chip.dev = &pdev->dev;
 	lpc32xx->chip.ops = &lpc32xx_pwm_ops;
-	lpc32xx->chip.npwm = 2;
+	lpc32xx->chip.npwm = 1;
 	lpc32xx->chip.base = -1;
 
 	ret = pwmchip_add(&lpc32xx->chip);

commit f05fae14a10ca0c07f176e680ef9ff9d348e7153
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:28 2014 +0200

    pwm: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 9dc0f9d42bfa..9fde60ce8e7b 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -168,7 +168,6 @@ MODULE_DEVICE_TABLE(of, lpc32xx_pwm_dt_ids);
 static struct platform_driver lpc32xx_pwm_driver = {
 	.driver = {
 		.name = "lpc32xx-pwm",
-		.owner = THIS_MODULE,
 		.of_match_table = lpc32xx_pwm_dt_ids,
 	},
 	.probe = lpc32xx_pwm_probe,

commit 3cb3b2bfddcdf0bd44b787127b52c2bd1ce9f291
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Sep 30 08:56:40 2013 +0530

    pwm: lpc32xx: Remove redundant of_match_ptr
    
    The data structure of_match_ptr() protects is always compiled in.
    Hence of_match_ptr() is not needed.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index efac99e03d57..9dc0f9d42bfa 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -169,7 +169,7 @@ static struct platform_driver lpc32xx_pwm_driver = {
 	.driver = {
 		.name = "lpc32xx-pwm",
 		.owner = THIS_MODULE,
-		.of_match_table = of_match_ptr(lpc32xx_pwm_dt_ids),
+		.of_match_table = lpc32xx_pwm_dt_ids,
 	},
 	.probe = lpc32xx_pwm_probe,
 	.remove = lpc32xx_pwm_remove,

commit 88d5a2e6ffaa32e2a09a994872ca10aca07a36e9
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Aug 14 11:11:25 2013 +0200

    pwm: simplify use of devm_ioremap_resource
    
    Remove unneeded error handling on the result of a call to
    platform_get_resource when the value is passed to devm_ioremap_resource.
    
    Move the call to platform_get_resource adjacent to the call to
    devm_ioremap_resource to make the connection between them more clear.
    
    A simplified version of the semantic patch that makes this change is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression pdev,res,n,e,e1;
    expression ret != 0;
    identifier l;
    @@
    
    - res = platform_get_resource(pdev, IORESOURCE_MEM, n);
      ... when != res
    - if (res == NULL) { ... \(goto l;\|return ret;\) }
      ... when != res
    + res = platform_get_resource(pdev, IORESOURCE_MEM, n);
      e = devm_ioremap_resource(e1, res);
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index efb6c7bf8750..efac99e03d57 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -124,9 +124,6 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -EINVAL;
-
 	lpc32xx->base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(lpc32xx->base))
 		return PTR_ERR(lpc32xx->base);

commit 3dd0a909479c1d372341d749b4ff94cd638b57da
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Wed Jun 12 13:18:29 2013 +0200

    pwm: Fill in missing .owner fields
    
    Some drivers don't set the .owner fields of the struct device_driver or
    struct pwm_ops, which causes the module usage count to become wrong.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 8272883c0d05..efb6c7bf8750 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -171,6 +171,7 @@ MODULE_DEVICE_TABLE(of, lpc32xx_pwm_dt_ids);
 static struct platform_driver lpc32xx_pwm_driver = {
 	.driver = {
 		.name = "lpc32xx-pwm",
+		.owner = THIS_MODULE,
 		.of_match_table = of_match_ptr(lpc32xx_pwm_dt_ids),
 	},
 	.probe = lpc32xx_pwm_probe,

commit affb923df96d6c927f9a3dfb0e6f4be940b185cd
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Apr 23 14:02:49 2013 +0800

    pwm: lpc32xx: Don't change PWM_ENABLE bit in lpc32xx_pwm_config
    
    lpc32xx_pwm_config() is supposed to set duty_ns and period_ns,
    it should not change PWM_ENABLE bit.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 6b6272f61da5..8272883c0d05 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -37,6 +37,7 @@ static int lpc32xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 	struct lpc32xx_pwm_chip *lpc32xx = to_lpc32xx_pwm_chip(chip);
 	unsigned long long c;
 	int period_cycles, duty_cycles;
+	u32 val;
 
 	c = clk_get_rate(lpc32xx->clk) / 256;
 	c = c * period_ns;
@@ -68,8 +69,10 @@ static int lpc32xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 		c = 255;
 	duty_cycles = 256 - c;
 
-	writel(PWM_ENABLE | PWM_RELOADV(period_cycles) | PWM_DUTY(duty_cycles),
-		lpc32xx->base + (pwm->hwpwm << 2));
+	val = readl(lpc32xx->base + (pwm->hwpwm << 2));
+	val &= ~0xFFFF;
+	val |= PWM_RELOADV(period_cycles) | PWM_DUTY(duty_cycles);
+	writel(val, lpc32xx->base + (pwm->hwpwm << 2));
 
 	return 0;
 }

commit 08ee77b5a5de27ad63c92262ebcb4efe0da93b58
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Apr 23 14:01:31 2013 +0800

    pwm: lpc32xx: Properly set PWM_ENABLE bit in lpc32xx_pwm_[enable|disable]
    
    According to the LPC32x0 User Manual [1]:
    
    For both PWM1 and PWM2 Control Registers:
    BIT 31:
    This bit gates the PWM_CLK signal and enables the external output pin
    to the PWM_PIN_STATE logical level.
    
    0 = PWM disabled. (Default)
    1 = PWM enabled
    
    So in lpc32xx_pwm_enable(), we should set PWM_ENABLE bit.
    In lpc32xx_pwm_disable(), we should just clear PWM_ENABLE bit rather than
    write 0 to the register which will also clear PWMx_RELOADV and PWMx_DUTY bits.
    
    [1] http://www.nxp.com/documents/user_manual/UM10326.pdf
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index b55cc5c1d614..6b6272f61da5 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -77,15 +77,29 @@ static int lpc32xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 static int lpc32xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
 	struct lpc32xx_pwm_chip *lpc32xx = to_lpc32xx_pwm_chip(chip);
+	u32 val;
+	int ret;
+
+	ret = clk_enable(lpc32xx->clk);
+	if (ret)
+		return ret;
 
-	return clk_enable(lpc32xx->clk);
+	val = readl(lpc32xx->base + (pwm->hwpwm << 2));
+	val |= PWM_ENABLE;
+	writel(val, lpc32xx->base + (pwm->hwpwm << 2));
+
+	return 0;
 }
 
 static void lpc32xx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
 	struct lpc32xx_pwm_chip *lpc32xx = to_lpc32xx_pwm_chip(chip);
+	u32 val;
+
+	val = readl(lpc32xx->base + (pwm->hwpwm << 2));
+	val &= ~PWM_ENABLE;
+	writel(val, lpc32xx->base + (pwm->hwpwm << 2));
 
-	writel(0, lpc32xx->base + (pwm->hwpwm << 2));
 	clk_disable(lpc32xx->clk);
 }
 

commit f1a8870aeb5baeb58f0613d1f1e1dca967127fbd
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Thu Apr 18 10:04:14 2013 +0200

    pwm: Constify OF match tables
    
    A few drivers already annotate this properly. Make the same change for
    all other OF supporting drivers.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index b3f0d0dfd748..b55cc5c1d614 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -145,7 +145,7 @@ static int lpc32xx_pwm_remove(struct platform_device *pdev)
 	return pwmchip_remove(&lpc32xx->chip);
 }
 
-static struct of_device_id lpc32xx_pwm_dt_ids[] = {
+static const struct of_device_id lpc32xx_pwm_dt_ids[] = {
 	{ .compatible = "nxp,lpc3220-pwm", },
 	{ /* sentinel */ }
 };

commit 6d4294d1634543853febc4287ecf02998fd234e1
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:16 2013 +0100

    pwm: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 14106440294f..b3f0d0dfd748 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -110,9 +110,9 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 	if (!res)
 		return -EINVAL;
 
-	lpc32xx->base = devm_request_and_ioremap(&pdev->dev, res);
-	if (!lpc32xx->base)
-		return -EADDRNOTAVAIL;
+	lpc32xx->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(lpc32xx->base))
+		return PTR_ERR(lpc32xx->base);
 
 	lpc32xx->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(lpc32xx->clk))

commit 74779e22261172ea728b989310f6ecc991b57d62
Merge: 5031a2a7c12b 20e8ac3eea4d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 19 08:19:07 2012 -0800

    Merge tag 'for-3.8-rc1' of git://gitorious.org/linux-pwm/linux-pwm
    
    Pull pwm changes from Thierry Reding:
     "A new driver has been added for the SPEAr platform and the
      TWL4030/6030 driver has been replaced by two drivers that control the
      regular PWMs and the PWM driven LEDs provided by the chips.
    
      The vt8500, tiecap, tiehrpwm, i.MX, LPC32xx and Samsung drivers have
      all been improved and the device tree bindings now support the PWM
      signal polarity."
    
    Fix up trivial conflicts due to __devinit/exit removal.
    
    * tag 'for-3.8-rc1' of git://gitorious.org/linux-pwm/linux-pwm: (21 commits)
      pwm: samsung: add missing s3c->pwm_id assignment
      pwm: lpc32xx: Set the chip base for dynamic allocation
      pwm: lpc32xx: Properly disable the clock on device removal
      pwm: lpc32xx: Fix the PWM polarity
      pwm: i.MX: eliminate build warning
      pwm: Export of_pwm_xlate_with_flags()
      pwm: Remove pwm-twl6030 driver
      pwm: New driver to support PWM driven LEDs on TWL4030/6030 series of PMICs
      pwm: New driver to support PWMs on TWL4030/6030 series of PMICs
      pwm: pwm-tiehrpwm: pinctrl support
      pwm: tiehrpwm: Add device-tree binding
      pwm: pwm-tiehrpwm: Adding TBCLK gating support.
      pwm: pwm-tiecap: pinctrl support
      pwm: tiecap: Add device-tree binding
      pwm: Add TI PWM subsystem driver
      pwm: Device tree support for PWM polarity
      pwm: vt8500: Ensure PWM clock is enabled during pwm_config
      pwm: vt8500: Fix build error
      pwm: spear: Staticize spear_pwm_config()
      pwm: Add SPEAr PWM chip driver support
      ...

commit 8fc6d09dcbcdb252e8b029f2a26fe303cc4649ec
Author: Alban Bedel <alban.bedel@avionic-design.de>
Date:   Wed Nov 14 12:58:15 2012 +0100

    pwm: lpc32xx: Set the chip base for dynamic allocation
    
    Doing so allows the base to be allocated dynamically at runtime and
    makes it easier for the chip to coexist with other PWM chips.
    
    Signed-off-by: Alban Bedel <alban.bedel@avionic-design.de>
    Acked-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Acked-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 971874b0707a..81db1bd5e92d 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -121,6 +121,7 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 	lpc32xx->chip.dev = &pdev->dev;
 	lpc32xx->chip.ops = &lpc32xx_pwm_ops;
 	lpc32xx->chip.npwm = 2;
+	lpc32xx->chip.base = -1;
 
 	ret = pwmchip_add(&lpc32xx->chip);
 	if (ret < 0) {

commit 54b2a999a167510aa6eb54f49ef21a40946c88ba
Author: Alban Bedel <alban.bedel@avionic-design.de>
Date:   Wed Nov 14 12:58:14 2012 +0100

    pwm: lpc32xx: Properly disable the clock on device removal
    
    A single clock is used for all PWMs meaning the clock's reference count
    might be between 0 and N when .remove() is called. Instead of a single
    clk_disable() call pwm_disable() on each PWM, to ensure that
    clk_disable() is called for each PWM that is still enabled.
    
    Signed-off-by: Alban Bedel <alban.bedel@avionic-design.de>
    Acked-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Acked-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index c9b2eb5932b1..971874b0707a 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -136,8 +136,11 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 static int __devexit lpc32xx_pwm_remove(struct platform_device *pdev)
 {
 	struct lpc32xx_pwm_chip *lpc32xx = platform_get_drvdata(pdev);
+	unsigned int i;
+
+	for (i = 0; i < lpc32xx->chip.npwm; i++)
+		pwm_disable(&lpc32xx->chip.pwms[i]);
 
-	clk_disable(lpc32xx->clk);
 	return pwmchip_remove(&lpc32xx->chip);
 }
 

commit a9a18e0691228707230df660dd56364aebf6ea47
Author: Alban Bedel <alban.bedel@avionic-design.de>
Date:   Wed Nov 14 12:58:13 2012 +0100

    pwm: lpc32xx: Fix the PWM polarity
    
    The duty cycles value goes from 1 (99% HIGH) to 256 (0% HIGH) but it
    is stored modulo 256 in the register as it is only 8 bits wide.
    
    Signed-off-by: Alban Bedel <alban.bedel@avionic-design.de>
    Acked-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Acked-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index adb87f0c1633..c9b2eb5932b1 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -49,9 +49,24 @@ static int lpc32xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 		c = 0; /* 0 set division by 256 */
 	period_cycles = c;
 
+	/* The duty-cycle value is as follows:
+	 *
+	 *  DUTY-CYCLE     HIGH LEVEL
+	 *      1            99.9%
+	 *      25           90.0%
+	 *      128          50.0%
+	 *      220          10.0%
+	 *      255           0.1%
+	 *      0             0.0%
+	 *
+	 * In other words, the register value is duty-cycle % 256 with
+	 * duty-cycle in the range 1-256.
+	 */
 	c = 256 * duty_ns;
 	do_div(c, period_ns);
-	duty_cycles = c;
+	if (c > 255)
+		c = 255;
+	duty_cycles = 256 - c;
 
 	writel(PWM_ENABLE | PWM_RELOADV(period_cycles) | PWM_DUTY(duty_cycles),
 		lpc32xx->base + (pwm->hwpwm << 2));

commit 77f37917a6f2bd8635b553178bb34bdd80f08e40
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:09 2012 -0500

    pwm: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index 33967a084789..015a82235620 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -118,7 +118,7 @@ static int lpc32xx_pwm_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __devexit lpc32xx_pwm_remove(struct platform_device *pdev)
+static int lpc32xx_pwm_remove(struct platform_device *pdev)
 {
 	struct lpc32xx_pwm_chip *lpc32xx = platform_get_drvdata(pdev);
 

commit fd1091125a1d11fcc635749d0d3dec36904a7a48
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:28 2012 -0500

    pwm: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
index adb87f0c1633..33967a084789 100644
--- a/drivers/pwm/pwm-lpc32xx.c
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -138,7 +138,7 @@ static struct platform_driver lpc32xx_pwm_driver = {
 		.of_match_table = of_match_ptr(lpc32xx_pwm_dt_ids),
 	},
 	.probe = lpc32xx_pwm_probe,
-	.remove = __devexit_p(lpc32xx_pwm_remove),
+	.remove = lpc32xx_pwm_remove,
 };
 module_platform_driver(lpc32xx_pwm_driver);
 

commit 2132fa8d95bc13b8b0e307553b04ee3517762ebe
Author: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
Date:   Tue Jul 10 11:38:10 2012 -0300

    pwm: add lpc32xx PWM support
    
    Add lpc32xx SOC PWM driver.
    
    Signed-off-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Acked-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/pwm/pwm-lpc32xx.c b/drivers/pwm/pwm-lpc32xx.c
new file mode 100644
index 000000000000..adb87f0c1633
--- /dev/null
+++ b/drivers/pwm/pwm-lpc32xx.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2012 Alexandre Pereira da Silva <aletes.xgr@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+
+struct lpc32xx_pwm_chip {
+	struct pwm_chip chip;
+	struct clk *clk;
+	void __iomem *base;
+};
+
+#define PWM_ENABLE	(1 << 31)
+#define PWM_RELOADV(x)	(((x) & 0xFF) << 8)
+#define PWM_DUTY(x)	((x) & 0xFF)
+
+#define to_lpc32xx_pwm_chip(_chip) \
+	container_of(_chip, struct lpc32xx_pwm_chip, chip)
+
+static int lpc32xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			      int duty_ns, int period_ns)
+{
+	struct lpc32xx_pwm_chip *lpc32xx = to_lpc32xx_pwm_chip(chip);
+	unsigned long long c;
+	int period_cycles, duty_cycles;
+
+	c = clk_get_rate(lpc32xx->clk) / 256;
+	c = c * period_ns;
+	do_div(c, NSEC_PER_SEC);
+
+	/* Handle high and low extremes */
+	if (c == 0)
+		c = 1;
+	if (c > 255)
+		c = 0; /* 0 set division by 256 */
+	period_cycles = c;
+
+	c = 256 * duty_ns;
+	do_div(c, period_ns);
+	duty_cycles = c;
+
+	writel(PWM_ENABLE | PWM_RELOADV(period_cycles) | PWM_DUTY(duty_cycles),
+		lpc32xx->base + (pwm->hwpwm << 2));
+
+	return 0;
+}
+
+static int lpc32xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct lpc32xx_pwm_chip *lpc32xx = to_lpc32xx_pwm_chip(chip);
+
+	return clk_enable(lpc32xx->clk);
+}
+
+static void lpc32xx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct lpc32xx_pwm_chip *lpc32xx = to_lpc32xx_pwm_chip(chip);
+
+	writel(0, lpc32xx->base + (pwm->hwpwm << 2));
+	clk_disable(lpc32xx->clk);
+}
+
+static const struct pwm_ops lpc32xx_pwm_ops = {
+	.config = lpc32xx_pwm_config,
+	.enable = lpc32xx_pwm_enable,
+	.disable = lpc32xx_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+static int lpc32xx_pwm_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_pwm_chip *lpc32xx;
+	struct resource *res;
+	int ret;
+
+	lpc32xx = devm_kzalloc(&pdev->dev, sizeof(*lpc32xx), GFP_KERNEL);
+	if (!lpc32xx)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
+	lpc32xx->base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!lpc32xx->base)
+		return -EADDRNOTAVAIL;
+
+	lpc32xx->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(lpc32xx->clk))
+		return PTR_ERR(lpc32xx->clk);
+
+	lpc32xx->chip.dev = &pdev->dev;
+	lpc32xx->chip.ops = &lpc32xx_pwm_ops;
+	lpc32xx->chip.npwm = 2;
+
+	ret = pwmchip_add(&lpc32xx->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add PWM chip, error %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, lpc32xx);
+
+	return 0;
+}
+
+static int __devexit lpc32xx_pwm_remove(struct platform_device *pdev)
+{
+	struct lpc32xx_pwm_chip *lpc32xx = platform_get_drvdata(pdev);
+
+	clk_disable(lpc32xx->clk);
+	return pwmchip_remove(&lpc32xx->chip);
+}
+
+static struct of_device_id lpc32xx_pwm_dt_ids[] = {
+	{ .compatible = "nxp,lpc3220-pwm", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, lpc32xx_pwm_dt_ids);
+
+static struct platform_driver lpc32xx_pwm_driver = {
+	.driver = {
+		.name = "lpc32xx-pwm",
+		.of_match_table = of_match_ptr(lpc32xx_pwm_dt_ids),
+	},
+	.probe = lpc32xx_pwm_probe,
+	.remove = __devexit_p(lpc32xx_pwm_remove),
+};
+module_platform_driver(lpc32xx_pwm_driver);
+
+MODULE_ALIAS("platform:lpc32xx-pwm");
+MODULE_AUTHOR("Alexandre Pereira da Silva <aletes.xgr@gmail.com>");
+MODULE_DESCRIPTION("LPC32XX PWM Driver");
+MODULE_LICENSE("GPL v2");
