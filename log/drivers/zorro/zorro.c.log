commit 573a73abc316ca6fe30fd52eaaf31c93077b2b23
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Feb 27 12:37:48 2020 -0600

    zorro: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200227183748.GA31018@embeddedor
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 8eeb84c239db..47c733817903 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -41,7 +41,7 @@ struct zorro_dev *zorro_autocon;
 
 struct zorro_bus {
 	struct device dev;
-	struct zorro_dev devices[0];
+	struct zorro_dev devices[];
 };
 
 

commit 285767604576148fc1be7fcd112e4a90eb0d6ad2
Merge: 5eb6eed7e0fe 0ed2dd03b94b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 6 17:27:14 2018 -0700

    Merge tag 'overflow-v4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull overflow updates from Kees Cook:
     "This adds the new overflow checking helpers and adds them to the
      2-factor argument allocators. And this adds the saturating size
      helpers and does a treewide replacement for the struct_size() usage.
      Additionally this adds the overflow testing modules to make sure
      everything works.
    
      I'm still working on the treewide replacements for allocators with
      "simple" multiplied arguments:
    
         *alloc(a * b, ...) -> *alloc_array(a, b, ...)
    
      and
    
         *zalloc(a * b, ...) -> *calloc(a, b, ...)
    
      as well as the more complex cases, but that's separable from this
      portion of the series. I expect to have the rest sent before -rc1
      closes; there are a lot of messy cases to clean up.
    
      Summary:
    
       - Introduce arithmetic overflow test helper functions (Rasmus)
    
       - Use overflow helpers in 2-factor allocators (Kees, Rasmus)
    
       - Introduce overflow test module (Rasmus, Kees)
    
       - Introduce saturating size helper functions (Matthew, Kees)
    
       - Treewide use of struct_size() for allocators (Kees)"
    
    * tag 'overflow-v4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux:
      treewide: Use struct_size() for devm_kmalloc() and friends
      treewide: Use struct_size() for vmalloc()-family
      treewide: Use struct_size() for kmalloc()-family
      device: Use overflow helpers for devm_kmalloc()
      mm: Use overflow helpers in kvmalloc()
      mm: Use overflow helpers in kmalloc_array*()
      test_overflow: Add memory allocation overflow tests
      overflow.h: Add allocation size calculation helpers
      test_overflow: Report test failures
      test_overflow: macrofy some more, do more tests for free
      lib: add runtime test of check_*_overflow functions
      compiler.h: enable builtin overflow checkers and add fallback code

commit acafe7e30216166a17e6e226aadc3ecb63993242
Author: Kees Cook <keescook@chromium.org>
Date:   Tue May 8 13:45:50 2018 -0700

    treewide: Use struct_size() for kmalloc()-family
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct foo {
        int stuff;
        void *entry[];
    };
    
    instance = kmalloc(sizeof(struct foo) + sizeof(void *) * count, GFP_KERNEL);
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper:
    
    instance = kmalloc(struct_size(instance, entry, count), GFP_KERNEL);
    
    This patch makes the changes for kmalloc()-family (and kvmalloc()-family)
    uses. It was done via automatic conversion with manual review for the
    "CHECKME" non-standard cases noted below, using the following Coccinelle
    script:
    
    // pkey_cache = kmalloc(sizeof *pkey_cache + tprops->pkey_tbl_len *
    //                      sizeof *pkey_cache->table, GFP_KERNEL);
    @@
    identifier alloc =~ "kmalloc|kzalloc|kvmalloc|kvzalloc";
    expression GFP;
    identifier VAR, ELEMENT;
    expression COUNT;
    @@
    
    - alloc(sizeof(*VAR) + COUNT * sizeof(*VAR->ELEMENT), GFP)
    + alloc(struct_size(VAR, ELEMENT, COUNT), GFP)
    
    // mr = kzalloc(sizeof(*mr) + m * sizeof(mr->map[0]), GFP_KERNEL);
    @@
    identifier alloc =~ "kmalloc|kzalloc|kvmalloc|kvzalloc";
    expression GFP;
    identifier VAR, ELEMENT;
    expression COUNT;
    @@
    
    - alloc(sizeof(*VAR) + COUNT * sizeof(VAR->ELEMENT[0]), GFP)
    + alloc(struct_size(VAR, ELEMENT, COUNT), GFP)
    
    // Same pattern, but can't trivially locate the trailing element name,
    // or variable name.
    @@
    identifier alloc =~ "kmalloc|kzalloc|kvmalloc|kvzalloc";
    expression GFP;
    expression SOMETHING, COUNT, ELEMENT;
    @@
    
    - alloc(sizeof(SOMETHING) + COUNT * sizeof(ELEMENT), GFP)
    + alloc(CHECKME_struct_size(&SOMETHING, ELEMENT, COUNT), GFP)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 47728477297e..875e569bf123 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -136,8 +136,7 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 	int error;
 
 	/* Initialize the Zorro bus */
-	bus = kzalloc(sizeof(*bus) +
-		      zorro_num_autocon * sizeof(bus->devices[0]),
+	bus = kzalloc(struct_size(bus, devices, zorro_num_autocon),
 		      GFP_KERNEL);
 	if (!bus)
 		return -ENOMEM;

commit d49cbe73beb7ff51cb09aeb8b1b1347d2e08438a
Author: Jacob <jacobenders1@gmail.com>
Date:   Sat May 12 23:11:40 2018 -0400

    zorro: Add a blank line after declarations
    
    Fixes a coding style issue.
    
    Signed-off-by: Jacob Enders <jacobenders1@gmail.com>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 47728477297e..67fa900572a9 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -101,6 +101,7 @@ static void __init mark_region(unsigned long start, unsigned long end,
 	end = end > Z2RAM_END ? Z2RAM_SIZE : end-Z2RAM_START;
 	while (start < end) {
 		u32 chunk = start>>Z2RAM_CHUNKSHIFT;
+
 		if (flag)
 			set_bit(chunk, zorro_unused_z2ram);
 		else
@@ -117,6 +118,7 @@ static struct resource __init *zorro_find_parent_resource(
 
 	for (i = 0; i < bridge->num_resources; i++) {
 		struct resource *r = &bridge->resource[i];
+
 		if (zorro_resource_start(z) >= r->start &&
 		    zorro_resource_end(z) <= r->end)
 			return r;
@@ -168,6 +170,7 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 		if (z->id == ZORRO_PROD_GVP_EPC_BASE) {
 			/* GVP quirk */
 			unsigned long magic = zi->boardaddr + 0x8000;
+
 			z->id |= *(u16 *)ZTWO_VADDR(magic) & GVP_PRODMASK;
 		}
 		z->slotaddr = zi->slotaddr;

commit 55496d3fe2acd1a365c43cbd613a20ecd4d74395
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Sat Mar 3 12:04:13 2018 +1300

    zorro: Set up z->dev.dma_mask for the DMA API
    
    The generic DMA API uses dev->dma_mask to check the DMA addressable
    memory bitmask, and warns if no mask is set or even allocated.
    
    Set z->dev.dma_coherent_mask on Zorro bus scan, and make z->dev.dma_mask
    to point to z->dev.dma_coherent_mask so device drivers that need DMA have
    everything set up to avoid warnings from dma_alloc_coherent(). Drivers can
    still use dma_set_mask_and_coherent() to explicitly set their DMA bit mask.
    
    Signed-off-by: Michael Schmitz <schmitzmic@gmail.com>
    [geert: Handle Zorro II with 24-bit address space]
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index cc1b1ac57d61..47728477297e 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -16,6 +16,7 @@
 #include <linux/bitops.h>
 #include <linux/string.h>
 #include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 #include <linux/slab.h>
 
 #include <asm/byteorder.h>
@@ -185,6 +186,17 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 		z->dev.parent = &bus->dev;
 		z->dev.bus = &zorro_bus_type;
 		z->dev.id = i;
+		switch (z->rom.er_Type & ERT_TYPEMASK) {
+		case ERT_ZORROIII:
+			z->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+			break;
+
+		case ERT_ZORROII:
+		default:
+			z->dev.coherent_dma_mask = DMA_BIT_MASK(24);
+			break;
+		}
+		z->dev.dma_mask = &z->dev.coherent_dma_mask;
 	}
 
 	/* ... then register them */

commit 87e715deb8e24bf1a6a9a1babaf465c28c93889c
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Feb 14 12:24:09 2017 -0800

    zorro: stop creating attributes by hand
    
    Instead of creating attributes one by one, define attribute_group array
    and attach it to bus->dev_groups, so that all needed attributes are created
    automatically when a new device is registered on the bus.
    
    Also switch to using standard DEVICE_ATTR_RO() macros.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index d295d9878dff..cc1b1ac57d61 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -197,9 +197,6 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 			put_device(&z->dev);
 			continue;
 		}
-		error = zorro_create_sysfs_dev_files(z);
-		if (error)
-			dev_err(&z->dev, "Error creating sysfs files\n");
 	}
 
 	/* Mark all available Zorro II memory */

commit 467817edc57ff0b1e3a1d3d97b534296a956fb82
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:57 2014 +0200

    zorro: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 707c1a5a0317..d295d9878dff 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -222,7 +222,6 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 static struct platform_driver amiga_zorro_driver = {
 	.driver   = {
 		.name	= "amiga-zorro",
-		.owner	= THIS_MODULE,
 	},
 };
 

commit bd9ba8f40ee30edf31cc0845d8838bc43d172ef3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Oct 4 09:38:53 2013 +0200

    zorro/UAPI: Use proper types (endianness/size) in <linux/zorro.h>
    
    Fix member definitions for non-native userspace handling:
      - All multi-byte values are big-endian, hence use __be*,
      - All pointers are 32-bit pointers under AmigaOS, but unused (except for
        cd_BoardAddr) under Linux, hence use __be32.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 450abf100f06..707c1a5a0317 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -18,6 +18,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
+#include <asm/byteorder.h>
 #include <asm/setup.h>
 #include <asm/amigahw.h>
 
@@ -161,7 +162,8 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 		z = &zorro_autocon[i];
 
 		z->rom = zi->rom;
-		z->id = (z->rom.er_Manufacturer<<16) | (z->rom.er_Product<<8);
+		z->id = (be16_to_cpu(z->rom.er_Manufacturer) << 16) |
+			(z->rom.er_Product << 8);
 		if (z->id == ZORRO_PROD_GVP_EPC_BASE) {
 			/* GVP quirk */
 			unsigned long magic = zi->boardaddr + 0x8000;

commit 83b7bce3d390f15047e05a186bb4051536ee9dbc
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Oct 16 11:28:54 2013 +0200

    zorro: Let the driver core handle device enumeration
    
    Filling in dev_name of the Zorro bus type and dev.id of each device allows
    the driver core to enumerate devices, so we don't have to do that
    ourselves.
    
    This changes the names of devices in sysfs from "%02x" to "zorro%u".
    
    Note that filling in dev.id is also needed to support MFD Zorro devices.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 10c7f77aec08..450abf100f06 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -142,7 +142,7 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 
 	zorro_autocon = bus->devices;
 	bus->dev.parent = &pdev->dev;
-	dev_set_name(&bus->dev, "zorro");
+	dev_set_name(&bus->dev, zorro_bus_type.name);
 	error = device_register(&bus->dev);
 	if (error) {
 		pr_err("Zorro: Error registering zorro_bus\n");
@@ -180,9 +180,9 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 			dev_err(&bus->dev,
 				"Address space collision on device %s %pR\n",
 				z->name, &z->resource);
-		dev_set_name(&z->dev, "%02x", i);
 		z->dev.parent = &bus->dev;
 		z->dev.bus = &zorro_bus_type;
+		z->dev.id = i;
 	}
 
 	/* ... then register them */

commit c293738e6d8dfb9c941759855b5161fde449644d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sat Jun 29 10:40:20 2013 +0200

    zorro: Do not allocate zorro_autocon[] statically
    
    Currently the array of Zorro devices is allocated statically, wasting
    up to 4.5 KiB when running an Amiga or multi-platform kernel on a machine
    with no or a handful of Zorro expansion cards. Convert it to conditional
    dynamic memory allocation to fix this.
    
    amiga_parse_bootinfo() still needs to store some information about the
    detected Zorro devices, at a time even the bootmem allocator is not yet
    available.  This is now handled using a much smaller array (typically less
    than 0.5 KiB), which is __initdata and thus freed later.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 858c9714b2f3..10c7f77aec08 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -29,7 +29,8 @@
      */
 
 unsigned int zorro_num_autocon;
-struct zorro_dev zorro_autocon[ZORRO_NUM_AUTO];
+struct zorro_dev_init zorro_autocon_init[ZORRO_NUM_AUTO] __initdata;
+struct zorro_dev *zorro_autocon;
 
 
     /*
@@ -38,6 +39,7 @@ struct zorro_dev zorro_autocon[ZORRO_NUM_AUTO];
 
 struct zorro_bus {
 	struct device dev;
+	struct zorro_dev devices[0];
 };
 
 
@@ -125,16 +127,20 @@ static struct resource __init *zorro_find_parent_resource(
 static int __init amiga_zorro_probe(struct platform_device *pdev)
 {
 	struct zorro_bus *bus;
+	struct zorro_dev_init *zi;
 	struct zorro_dev *z;
 	struct resource *r;
 	unsigned int i;
 	int error;
 
 	/* Initialize the Zorro bus */
-	bus = kzalloc(sizeof(*bus), GFP_KERNEL);
+	bus = kzalloc(sizeof(*bus) +
+		      zorro_num_autocon * sizeof(bus->devices[0]),
+		      GFP_KERNEL);
 	if (!bus)
 		return -ENOMEM;
 
+	zorro_autocon = bus->devices;
 	bus->dev.parent = &pdev->dev;
 	dev_set_name(&bus->dev, "zorro");
 	error = device_register(&bus->dev);
@@ -151,15 +157,22 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 
 	/* First identify all devices ... */
 	for (i = 0; i < zorro_num_autocon; i++) {
+		zi = &zorro_autocon_init[i];
 		z = &zorro_autocon[i];
+
+		z->rom = zi->rom;
 		z->id = (z->rom.er_Manufacturer<<16) | (z->rom.er_Product<<8);
 		if (z->id == ZORRO_PROD_GVP_EPC_BASE) {
 			/* GVP quirk */
-			unsigned long magic = zorro_resource_start(z)+0x8000;
+			unsigned long magic = zi->boardaddr + 0x8000;
 			z->id |= *(u16 *)ZTWO_VADDR(magic) & GVP_PRODMASK;
 		}
+		z->slotaddr = zi->slotaddr;
+		z->slotsize = zi->slotsize;
 		sprintf(z->name, "Zorro device %08x", z->id);
 		zorro_name_device(z);
+		z->resource.start = zi->boardaddr;
+		z->resource.end = zi->boardaddr + zi->boardsize - 1;
 		z->resource.name = z->name;
 		r = zorro_find_parent_resource(pdev, z);
 		error = request_resource(r, &z->resource);

commit 897f3325a17e17dcdf8f3950a2b83542645902e5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jun 27 10:57:38 2012 +0200

    zorro: Remove unused zorro_bus.devices
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 181fa8158a8b..858c9714b2f3 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -37,7 +37,6 @@ struct zorro_dev zorro_autocon[ZORRO_NUM_AUTO];
      */
 
 struct zorro_bus {
-	struct list_head devices;	/* list of devices on this bus */
 	struct device dev;
 };
 
@@ -136,7 +135,6 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 	if (!bus)
 		return -ENOMEM;
 
-	INIT_LIST_HEAD(&bus->devices);
 	bus->dev.parent = &pdev->dev;
 	dev_set_name(&bus->dev, "zorro");
 	error = device_register(&bus->dev);

commit a7f4d00a82feb5b311f765bf9522bc55bee0684f
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Sep 22 21:47:38 2011 +0200

    zorro: Defer device_register() until all devices have been identified
    
    As the Amiga Zorro II address space is limited to 8.5 MiB and Zorro
    devices can contain only one BAR, several Amiga Zorro II expansion
    boards (mainly graphics cards) contain multiple Zorro devices: a small
    one for the control registers and one (or more) for the graphics memory.
    
    The conversion of cirrusfb to the new driver framework introduced a
    regression: the driver contains a zorro_driver for the first Zorro
    device, and uses the (old) zorro_find_device() call to find the second
    Zorro device.
    
    However, as the Zorro core calls device_register() as soon as a Zorro
    device is identified, it may not have identified the second Zorro device
    belonging to the same physical Zorro expansion card.  Hence cirrusfb
    could no longer find the second part of the Picasso II graphics card,
    causing a NULL pointer dereference.
    
    Defer the registration of Zorro devices with the driver framework until
    all Zorro devices have been identified to fix this.
    
    Note that the alternative solution (modifying cirrusfb to register a
    zorro_driver for all Zorro devices belonging to a graphics card, instead
    of only for the first one, and adding a synchronization mechanism to
    defer initialization until all have been found), is not an option, as on
    some cards one device may be optional (e.g.  the second bank of 2 MiB of
    graphics memory on the Picasso IV in Zorro II mode).
    
    Reported-by: Ingo JÃ¼rgensmann <ij@2011.bluespice.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index e0c2807b0970..181fa8158a8b 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -148,10 +148,10 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 	}
 	platform_set_drvdata(pdev, bus);
 
-	/* Register all devices */
 	pr_info("Zorro: Probing AutoConfig expansion devices: %u device%s\n",
 		 zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
 
+	/* First identify all devices ... */
 	for (i = 0; i < zorro_num_autocon; i++) {
 		z = &zorro_autocon[i];
 		z->id = (z->rom.er_Manufacturer<<16) | (z->rom.er_Product<<8);
@@ -172,6 +172,11 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 		dev_set_name(&z->dev, "%02x", i);
 		z->dev.parent = &bus->dev;
 		z->dev.bus = &zorro_bus_type;
+	}
+
+	/* ... then register them */
+	for (i = 0; i < zorro_num_autocon; i++) {
+		z = &zorro_autocon[i];
 		error = device_register(&z->dev);
 		if (error) {
 			dev_err(&bus->dev, "Error registering device %s\n",

commit 10b68799b32d60ff578742d0deebc98afff30dba
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Sun Sep 19 16:55:21 2010 +0400

    zorro: Fix device_register() error handling
    
    If device_register() fails then call put_device().
    See comment to device_register.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 6455f3a244c5..e0c2807b0970 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -142,6 +142,7 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 	error = device_register(&bus->dev);
 	if (error) {
 		pr_err("Zorro: Error registering zorro_bus\n");
+		put_device(&bus->dev);
 		kfree(bus);
 		return error;
 	}
@@ -175,6 +176,7 @@ static int __init amiga_zorro_probe(struct platform_device *pdev)
 		if (error) {
 			dev_err(&bus->dev, "Error registering device %s\n",
 				z->name);
+			put_device(&z->dev);
 			continue;
 		}
 		error = zorro_create_sysfs_dev_files(z);

commit 0d305464aefff342c85b4db8b3d7a4345246e5a1
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 5 12:40:41 2009 +0200

    m68k: amiga - Zorro host bridge platform device conversion
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index d45fb34e2d23..6455f3a244c5 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -15,6 +15,8 @@
 #include <linux/zorro.h>
 #include <linux/bitops.h>
 #include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
 
 #include <asm/setup.h>
 #include <asm/amigahw.h>
@@ -26,24 +28,17 @@
      *  Zorro Expansion Devices
      */
 
-u_int zorro_num_autocon = 0;
+unsigned int zorro_num_autocon;
 struct zorro_dev zorro_autocon[ZORRO_NUM_AUTO];
 
 
     /*
-     *  Single Zorro bus
+     *  Zorro bus
      */
 
-struct zorro_bus zorro_bus = {\
-    .resources = {
-	/* Zorro II regions (on Zorro II/III) */
-	{ .name = "Zorro II exp", .start = 0x00e80000, .end = 0x00efffff },
-	{ .name = "Zorro II mem", .start = 0x00200000, .end = 0x009fffff },
-	/* Zorro III regions (on Zorro III only) */
-	{ .name = "Zorro III exp", .start = 0xff000000, .end = 0xffffffff },
-	{ .name = "Zorro III cfg", .start = 0x40000000, .end = 0x7fffffff }
-    },
-    .name = "Zorro bus"
+struct zorro_bus {
+	struct list_head devices;	/* list of devices on this bus */
+	struct device dev;
 };
 
 
@@ -53,18 +48,19 @@ struct zorro_bus zorro_bus = {\
 
 struct zorro_dev *zorro_find_device(zorro_id id, struct zorro_dev *from)
 {
-    struct zorro_dev *z;
+	struct zorro_dev *z;
 
-    if (!MACH_IS_AMIGA || !AMIGAHW_PRESENT(ZORRO))
-	return NULL;
+	if (!zorro_num_autocon)
+		return NULL;
 
-    for (z = from ? from+1 : &zorro_autocon[0];
-	 z < zorro_autocon+zorro_num_autocon;
-	 z++)
-	if (id == ZORRO_WILDCARD || id == z->id)
-	    return z;
-    return NULL;
+	for (z = from ? from+1 : &zorro_autocon[0];
+	     z < zorro_autocon+zorro_num_autocon;
+	     z++)
+		if (id == ZORRO_WILDCARD || id == z->id)
+			return z;
+	return NULL;
 }
+EXPORT_SYMBOL(zorro_find_device);
 
 
     /*
@@ -83,121 +79,138 @@ struct zorro_dev *zorro_find_device(zorro_id id, struct zorro_dev *from)
      */
 
 DECLARE_BITMAP(zorro_unused_z2ram, 128);
+EXPORT_SYMBOL(zorro_unused_z2ram);
 
 
 static void __init mark_region(unsigned long start, unsigned long end,
 			       int flag)
 {
-    if (flag)
-	start += Z2RAM_CHUNKMASK;
-    else
-	end += Z2RAM_CHUNKMASK;
-    start &= ~Z2RAM_CHUNKMASK;
-    end &= ~Z2RAM_CHUNKMASK;
-
-    if (end <= Z2RAM_START || start >= Z2RAM_END)
-	return;
-    start = start < Z2RAM_START ? 0x00000000 : start-Z2RAM_START;
-    end = end > Z2RAM_END ? Z2RAM_SIZE : end-Z2RAM_START;
-    while (start < end) {
-	u32 chunk = start>>Z2RAM_CHUNKSHIFT;
 	if (flag)
-	    set_bit(chunk, zorro_unused_z2ram);
+		start += Z2RAM_CHUNKMASK;
 	else
-	    clear_bit(chunk, zorro_unused_z2ram);
-	start += Z2RAM_CHUNKSIZE;
-    }
+		end += Z2RAM_CHUNKMASK;
+	start &= ~Z2RAM_CHUNKMASK;
+	end &= ~Z2RAM_CHUNKMASK;
+
+	if (end <= Z2RAM_START || start >= Z2RAM_END)
+		return;
+	start = start < Z2RAM_START ? 0x00000000 : start-Z2RAM_START;
+	end = end > Z2RAM_END ? Z2RAM_SIZE : end-Z2RAM_START;
+	while (start < end) {
+		u32 chunk = start>>Z2RAM_CHUNKSHIFT;
+		if (flag)
+			set_bit(chunk, zorro_unused_z2ram);
+		else
+			clear_bit(chunk, zorro_unused_z2ram);
+		start += Z2RAM_CHUNKSIZE;
+	}
 }
 
 
-static struct resource __init *zorro_find_parent_resource(struct zorro_dev *z)
+static struct resource __init *zorro_find_parent_resource(
+	struct platform_device *bridge, struct zorro_dev *z)
 {
-    int i;
+	int i;
 
-    for (i = 0; i < zorro_bus.num_resources; i++)
-	if (zorro_resource_start(z) >= zorro_bus.resources[i].start &&
-	    zorro_resource_end(z) <= zorro_bus.resources[i].end)
-		return &zorro_bus.resources[i];
-    return &iomem_resource;
+	for (i = 0; i < bridge->num_resources; i++) {
+		struct resource *r = &bridge->resource[i];
+		if (zorro_resource_start(z) >= r->start &&
+		    zorro_resource_end(z) <= r->end)
+			return r;
+	}
+	return &iomem_resource;
 }
 
 
-    /*
-     *  Initialization
-     */
 
-static int __init zorro_init(void)
+static int __init amiga_zorro_probe(struct platform_device *pdev)
 {
-    struct zorro_dev *z;
-    unsigned int i;
-    int error;
-
-    if (!MACH_IS_AMIGA || !AMIGAHW_PRESENT(ZORRO))
-	return 0;
-
-    pr_info("Zorro: Probing AutoConfig expansion devices: %d device%s\n",
-	   zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
-
-    /* Initialize the Zorro bus */
-    INIT_LIST_HEAD(&zorro_bus.devices);
-    dev_set_name(&zorro_bus.dev, "zorro");
-    error = device_register(&zorro_bus.dev);
-    if (error) {
-	pr_err("Zorro: Error registering zorro_bus\n");
-	return error;
-    }
-
-    /* Request the resources */
-    zorro_bus.num_resources = AMIGAHW_PRESENT(ZORRO3) ? 4 : 2;
-    for (i = 0; i < zorro_bus.num_resources; i++)
-	request_resource(&iomem_resource, &zorro_bus.resources[i]);
-
-    /* Register all devices */
-    for (i = 0; i < zorro_num_autocon; i++) {
-	z = &zorro_autocon[i];
-	z->id = (z->rom.er_Manufacturer<<16) | (z->rom.er_Product<<8);
-	if (z->id == ZORRO_PROD_GVP_EPC_BASE) {
-	    /* GVP quirk */
-	    unsigned long magic = zorro_resource_start(z)+0x8000;
-	    z->id |= *(u16 *)ZTWO_VADDR(magic) & GVP_PRODMASK;
-	}
-	sprintf(z->name, "Zorro device %08x", z->id);
-	zorro_name_device(z);
-	z->resource.name = z->name;
-	if (request_resource(zorro_find_parent_resource(z), &z->resource))
-	    pr_err("Zorro: Address space collision on device %s %pR\n",
-		   z->name, &z->resource);
-	dev_set_name(&z->dev, "%02x", i);
-	z->dev.parent = &zorro_bus.dev;
-	z->dev.bus = &zorro_bus_type;
-	error = device_register(&z->dev);
+	struct zorro_bus *bus;
+	struct zorro_dev *z;
+	struct resource *r;
+	unsigned int i;
+	int error;
+
+	/* Initialize the Zorro bus */
+	bus = kzalloc(sizeof(*bus), GFP_KERNEL);
+	if (!bus)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&bus->devices);
+	bus->dev.parent = &pdev->dev;
+	dev_set_name(&bus->dev, "zorro");
+	error = device_register(&bus->dev);
 	if (error) {
-	    pr_err("Zorro: Error registering device %s\n", z->name);
-	    continue;
+		pr_err("Zorro: Error registering zorro_bus\n");
+		kfree(bus);
+		return error;
 	}
-	error = zorro_create_sysfs_dev_files(z);
-	if (error)
-	    dev_err(&z->dev, "Error creating sysfs files\n");
-    }
-
-    /* Mark all available Zorro II memory */
-    zorro_for_each_dev(z) {
-	if (z->rom.er_Type & ERTF_MEMLIST)
-	    mark_region(zorro_resource_start(z), zorro_resource_end(z)+1, 1);
-    }
-
-    /* Unmark all used Zorro II memory */
-    for (i = 0; i < m68k_num_memory; i++)
-	if (m68k_memory[i].addr < 16*1024*1024)
-	    mark_region(m68k_memory[i].addr,
-			m68k_memory[i].addr+m68k_memory[i].size, 0);
-
-    return 0;
+	platform_set_drvdata(pdev, bus);
+
+	/* Register all devices */
+	pr_info("Zorro: Probing AutoConfig expansion devices: %u device%s\n",
+		 zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
+
+	for (i = 0; i < zorro_num_autocon; i++) {
+		z = &zorro_autocon[i];
+		z->id = (z->rom.er_Manufacturer<<16) | (z->rom.er_Product<<8);
+		if (z->id == ZORRO_PROD_GVP_EPC_BASE) {
+			/* GVP quirk */
+			unsigned long magic = zorro_resource_start(z)+0x8000;
+			z->id |= *(u16 *)ZTWO_VADDR(magic) & GVP_PRODMASK;
+		}
+		sprintf(z->name, "Zorro device %08x", z->id);
+		zorro_name_device(z);
+		z->resource.name = z->name;
+		r = zorro_find_parent_resource(pdev, z);
+		error = request_resource(r, &z->resource);
+		if (error)
+			dev_err(&bus->dev,
+				"Address space collision on device %s %pR\n",
+				z->name, &z->resource);
+		dev_set_name(&z->dev, "%02x", i);
+		z->dev.parent = &bus->dev;
+		z->dev.bus = &zorro_bus_type;
+		error = device_register(&z->dev);
+		if (error) {
+			dev_err(&bus->dev, "Error registering device %s\n",
+				z->name);
+			continue;
+		}
+		error = zorro_create_sysfs_dev_files(z);
+		if (error)
+			dev_err(&z->dev, "Error creating sysfs files\n");
+	}
+
+	/* Mark all available Zorro II memory */
+	zorro_for_each_dev(z) {
+		if (z->rom.er_Type & ERTF_MEMLIST)
+			mark_region(zorro_resource_start(z),
+				    zorro_resource_end(z)+1, 1);
+	}
+
+	/* Unmark all used Zorro II memory */
+	for (i = 0; i < m68k_num_memory; i++)
+		if (m68k_memory[i].addr < 16*1024*1024)
+			mark_region(m68k_memory[i].addr,
+				    m68k_memory[i].addr+m68k_memory[i].size,
+				    0);
+
+	return 0;
 }
 
-subsys_initcall(zorro_init);
+static struct platform_driver amiga_zorro_driver = {
+	.driver   = {
+		.name	= "amiga-zorro",
+		.owner	= THIS_MODULE,
+	},
+};
 
-EXPORT_SYMBOL(zorro_find_device);
-EXPORT_SYMBOL(zorro_unused_z2ram);
+static int __init amiga_zorro_init(void)
+{
+	return platform_driver_probe(&amiga_zorro_driver, amiga_zorro_probe);
+}
+
+module_init(amiga_zorro_init);
 
 MODULE_LICENSE("GPL");

commit 2796872c40c462bacf2d09bb99faa6dcd640a620
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Mar 24 16:38:21 2009 -0700

    zorro: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index a1585d6f6486..d45fb34e2d23 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -140,7 +140,7 @@ static int __init zorro_init(void)
 
     /* Initialize the Zorro bus */
     INIT_LIST_HEAD(&zorro_bus.devices);
-    strcpy(zorro_bus.dev.bus_id, "zorro");
+    dev_set_name(&zorro_bus.dev, "zorro");
     error = device_register(&zorro_bus.dev);
     if (error) {
 	pr_err("Zorro: Error registering zorro_bus\n");
@@ -167,7 +167,7 @@ static int __init zorro_init(void)
 	if (request_resource(zorro_find_parent_resource(z), &z->resource))
 	    pr_err("Zorro: Address space collision on device %s %pR\n",
 		   z->name, &z->resource);
-	sprintf(z->dev.bus_id, "%02x", i);
+	dev_set_name(&z->dev, "%02x", i);
 	z->dev.parent = &zorro_bus.dev;
 	z->dev.bus = &zorro_bus_type;
 	error = device_register(&z->dev);

commit b01e3b07ec29e98464a4f580ae000291cf0d2f87
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:23:35 2008 +0100

    m68k: zorro - Use %pR to print resources
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 2dda20ac6b36..a1585d6f6486 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -165,10 +165,8 @@ static int __init zorro_init(void)
 	zorro_name_device(z);
 	z->resource.name = z->name;
 	if (request_resource(zorro_find_parent_resource(z), &z->resource))
-	    printk(KERN_ERR "Zorro: Address space collision on device %s "
-		   "[%lx:%lx]\n",
-		   z->name, (unsigned long)zorro_resource_start(z),
-		   (unsigned long)zorro_resource_end(z));
+	    pr_err("Zorro: Address space collision on device %s %pR\n",
+		   z->name, &z->resource);
 	sprintf(z->dev.bus_id, "%02x", i);
 	z->dev.parent = &zorro_bus.dev;
 	z->dev.bus = &zorro_bus_type;

commit 11a8b2c5cde1377c716087df0866d7dc5a6d5d10
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:21:19 2008 +0100

    m68k: zorro - Kill warn_unused_result warnings
    
    warning: ignoring return value of 'device_register', declared with attribute
    warn_unused_result
    warning: ignoring return value of 'device_create_file', declared with
    attribute warn_unused_result
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index dff16d9767d8..2dda20ac6b36 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -130,6 +130,7 @@ static int __init zorro_init(void)
 {
     struct zorro_dev *z;
     unsigned int i;
+    int error;
 
     if (!MACH_IS_AMIGA || !AMIGAHW_PRESENT(ZORRO))
 	return 0;
@@ -140,7 +141,11 @@ static int __init zorro_init(void)
     /* Initialize the Zorro bus */
     INIT_LIST_HEAD(&zorro_bus.devices);
     strcpy(zorro_bus.dev.bus_id, "zorro");
-    device_register(&zorro_bus.dev);
+    error = device_register(&zorro_bus.dev);
+    if (error) {
+	pr_err("Zorro: Error registering zorro_bus\n");
+	return error;
+    }
 
     /* Request the resources */
     zorro_bus.num_resources = AMIGAHW_PRESENT(ZORRO3) ? 4 : 2;
@@ -167,8 +172,14 @@ static int __init zorro_init(void)
 	sprintf(z->dev.bus_id, "%02x", i);
 	z->dev.parent = &zorro_bus.dev;
 	z->dev.bus = &zorro_bus_type;
-	device_register(&z->dev);
-	zorro_create_sysfs_dev_files(z);
+	error = device_register(&z->dev);
+	if (error) {
+	    pr_err("Zorro: Error registering device %s\n", z->name);
+	    continue;
+	}
+	error = zorro_create_sysfs_dev_files(z);
+	if (error)
+	    dev_err(&z->dev, "Error creating sysfs files\n");
     }
 
     /* Mark all available Zorro II memory */

commit f30828a6745281edda735f642b5f814e1123ecd3
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 17 21:16:08 2008 +0200

    m68k: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 4cc42b64820c..dff16d9767d8 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -1,6 +1,4 @@
 /*
- *    $Id: zorro.c,v 1.1.2.1 1998/06/07 23:21:02 geert Exp $
- *
  *    Zorro Bus Services
  *
  *    Copyright (C) 1995-2003 Geert Uytterhoeven

commit 318175766e7688ba52cdf771d37e98a1e4759f98
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue May 1 22:33:04 2007 +0200

    Amiga Zorro bus: kill resource_size_t warnings
    
    Kill resource_size_t warnings by casting resource_size_t to unsigned long when
    formatting Zorro bus resources, as they are always 32-bit.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index 0f2b40605b06..4cc42b64820c 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -164,7 +164,8 @@ static int __init zorro_init(void)
 	if (request_resource(zorro_find_parent_resource(z), &z->resource))
 	    printk(KERN_ERR "Zorro: Address space collision on device %s "
 		   "[%lx:%lx]\n",
-		   z->name, zorro_resource_start(z), zorro_resource_end(z));
+		   z->name, (unsigned long)zorro_resource_start(z),
+		   (unsigned long)zorro_resource_end(z));
 	sprintf(z->dev.bus_id, "%02x", i);
 	z->dev.parent = &zorro_bus.dev;
 	z->dev.bus = &zorro_bus_type;

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
index d3c05dfe20d2..0f2b40605b06 100644
--- a/drivers/zorro/zorro.c
+++ b/drivers/zorro/zorro.c
@@ -16,6 +16,8 @@
 #include <linux/init.h>
 #include <linux/zorro.h>
 #include <linux/bitops.h>
+#include <linux/string.h>
+
 #include <asm/setup.h>
 #include <asm/amigahw.h>
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/zorro/zorro.c b/drivers/zorro/zorro.c
new file mode 100644
index 000000000000..d3c05dfe20d2
--- /dev/null
+++ b/drivers/zorro/zorro.c
@@ -0,0 +1,193 @@
+/*
+ *    $Id: zorro.c,v 1.1.2.1 1998/06/07 23:21:02 geert Exp $
+ *
+ *    Zorro Bus Services
+ *
+ *    Copyright (C) 1995-2003 Geert Uytterhoeven
+ *
+ *    This file is subject to the terms and conditions of the GNU General Public
+ *    License.  See the file COPYING in the main directory of this archive
+ *    for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/zorro.h>
+#include <linux/bitops.h>
+#include <asm/setup.h>
+#include <asm/amigahw.h>
+
+#include "zorro.h"
+
+
+    /*
+     *  Zorro Expansion Devices
+     */
+
+u_int zorro_num_autocon = 0;
+struct zorro_dev zorro_autocon[ZORRO_NUM_AUTO];
+
+
+    /*
+     *  Single Zorro bus
+     */
+
+struct zorro_bus zorro_bus = {\
+    .resources = {
+	/* Zorro II regions (on Zorro II/III) */
+	{ .name = "Zorro II exp", .start = 0x00e80000, .end = 0x00efffff },
+	{ .name = "Zorro II mem", .start = 0x00200000, .end = 0x009fffff },
+	/* Zorro III regions (on Zorro III only) */
+	{ .name = "Zorro III exp", .start = 0xff000000, .end = 0xffffffff },
+	{ .name = "Zorro III cfg", .start = 0x40000000, .end = 0x7fffffff }
+    },
+    .name = "Zorro bus"
+};
+
+
+    /*
+     *  Find Zorro Devices
+     */
+
+struct zorro_dev *zorro_find_device(zorro_id id, struct zorro_dev *from)
+{
+    struct zorro_dev *z;
+
+    if (!MACH_IS_AMIGA || !AMIGAHW_PRESENT(ZORRO))
+	return NULL;
+
+    for (z = from ? from+1 : &zorro_autocon[0];
+	 z < zorro_autocon+zorro_num_autocon;
+	 z++)
+	if (id == ZORRO_WILDCARD || id == z->id)
+	    return z;
+    return NULL;
+}
+
+
+    /*
+     *  Bitmask indicating portions of available Zorro II RAM that are unused
+     *  by the system. Every bit represents a 64K chunk, for a maximum of 8MB
+     *  (128 chunks, physical 0x00200000-0x009fffff).
+     *
+     *  If you want to use (= allocate) portions of this RAM, you should clear
+     *  the corresponding bits.
+     *
+     *  Possible uses:
+     *      - z2ram device
+     *      - SCSI DMA bounce buffers
+     *
+     *  FIXME: use the normal resource management
+     */
+
+DECLARE_BITMAP(zorro_unused_z2ram, 128);
+
+
+static void __init mark_region(unsigned long start, unsigned long end,
+			       int flag)
+{
+    if (flag)
+	start += Z2RAM_CHUNKMASK;
+    else
+	end += Z2RAM_CHUNKMASK;
+    start &= ~Z2RAM_CHUNKMASK;
+    end &= ~Z2RAM_CHUNKMASK;
+
+    if (end <= Z2RAM_START || start >= Z2RAM_END)
+	return;
+    start = start < Z2RAM_START ? 0x00000000 : start-Z2RAM_START;
+    end = end > Z2RAM_END ? Z2RAM_SIZE : end-Z2RAM_START;
+    while (start < end) {
+	u32 chunk = start>>Z2RAM_CHUNKSHIFT;
+	if (flag)
+	    set_bit(chunk, zorro_unused_z2ram);
+	else
+	    clear_bit(chunk, zorro_unused_z2ram);
+	start += Z2RAM_CHUNKSIZE;
+    }
+}
+
+
+static struct resource __init *zorro_find_parent_resource(struct zorro_dev *z)
+{
+    int i;
+
+    for (i = 0; i < zorro_bus.num_resources; i++)
+	if (zorro_resource_start(z) >= zorro_bus.resources[i].start &&
+	    zorro_resource_end(z) <= zorro_bus.resources[i].end)
+		return &zorro_bus.resources[i];
+    return &iomem_resource;
+}
+
+
+    /*
+     *  Initialization
+     */
+
+static int __init zorro_init(void)
+{
+    struct zorro_dev *z;
+    unsigned int i;
+
+    if (!MACH_IS_AMIGA || !AMIGAHW_PRESENT(ZORRO))
+	return 0;
+
+    pr_info("Zorro: Probing AutoConfig expansion devices: %d device%s\n",
+	   zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
+
+    /* Initialize the Zorro bus */
+    INIT_LIST_HEAD(&zorro_bus.devices);
+    strcpy(zorro_bus.dev.bus_id, "zorro");
+    device_register(&zorro_bus.dev);
+
+    /* Request the resources */
+    zorro_bus.num_resources = AMIGAHW_PRESENT(ZORRO3) ? 4 : 2;
+    for (i = 0; i < zorro_bus.num_resources; i++)
+	request_resource(&iomem_resource, &zorro_bus.resources[i]);
+
+    /* Register all devices */
+    for (i = 0; i < zorro_num_autocon; i++) {
+	z = &zorro_autocon[i];
+	z->id = (z->rom.er_Manufacturer<<16) | (z->rom.er_Product<<8);
+	if (z->id == ZORRO_PROD_GVP_EPC_BASE) {
+	    /* GVP quirk */
+	    unsigned long magic = zorro_resource_start(z)+0x8000;
+	    z->id |= *(u16 *)ZTWO_VADDR(magic) & GVP_PRODMASK;
+	}
+	sprintf(z->name, "Zorro device %08x", z->id);
+	zorro_name_device(z);
+	z->resource.name = z->name;
+	if (request_resource(zorro_find_parent_resource(z), &z->resource))
+	    printk(KERN_ERR "Zorro: Address space collision on device %s "
+		   "[%lx:%lx]\n",
+		   z->name, zorro_resource_start(z), zorro_resource_end(z));
+	sprintf(z->dev.bus_id, "%02x", i);
+	z->dev.parent = &zorro_bus.dev;
+	z->dev.bus = &zorro_bus_type;
+	device_register(&z->dev);
+	zorro_create_sysfs_dev_files(z);
+    }
+
+    /* Mark all available Zorro II memory */
+    zorro_for_each_dev(z) {
+	if (z->rom.er_Type & ERTF_MEMLIST)
+	    mark_region(zorro_resource_start(z), zorro_resource_end(z)+1, 1);
+    }
+
+    /* Unmark all used Zorro II memory */
+    for (i = 0; i < m68k_num_memory; i++)
+	if (m68k_memory[i].addr < 16*1024*1024)
+	    mark_region(m68k_memory[i].addr,
+			m68k_memory[i].addr+m68k_memory[i].size, 0);
+
+    return 0;
+}
+
+subsys_initcall(zorro_init);
+
+EXPORT_SYMBOL(zorro_find_device);
+EXPORT_SYMBOL(zorro_unused_z2ram);
+
+MODULE_LICENSE("GPL");
