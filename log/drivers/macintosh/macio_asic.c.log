commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 3543a82081de..92d142d2b75f 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Bus & driver management routines for devices within
  * a MacIO ASIC. Interface to new driver model mostly
@@ -5,11 +6,6 @@
  * 
  *  Copyright (C) 2005 Ben. Herrenschmidt (benh@kernel.crashing.org)
  *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version
- *  2 of the License, or (at your option) any later version.
- *
  * TODO:
  * 
  *  - Don't probe below media bay by default, but instead provide

commit f1e0addca8bd7386f8cabbc64c9988fff91c131f
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:28 2018 -0600

    macintosh: Use of_node_name_{eq, prefix} for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_{eq,prefix}
    helpers instead. This removes direct access to the node name pointer.
    
    This changes a single case insensitive node name comparison to case
    sensitive for "ata4". This is the only instance of a case insensitive
    comparison for all the open coded node name comparisons on powerpc.
    Searching the commit history, there doesn't appear to be any reason for
    it to be case insensitive.
    
    A couple of open coded iterating thru the child node names are converted
    to use for_each_child_of_node() instead.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index bc8418801224..3543a82081de 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -190,11 +190,11 @@ static int macio_resource_quirks(struct device_node *np, struct resource *res,
 		return 0;
 
 	/* Grand Central has too large resource 0 on some machines */
-	if (index == 0 && !strcmp(np->name, "gc"))
+	if (index == 0 && of_node_name_eq(np, "gc"))
 		res->end = res->start + 0x1ffff;
 
 	/* Airport has bogus resource 2 */
-	if (index >= 2 && !strcmp(np->name, "radio"))
+	if (index >= 2 && of_node_name_eq(np, "radio"))
 		return 1;
 
 #ifndef CONFIG_PPC64
@@ -207,20 +207,20 @@ static int macio_resource_quirks(struct device_node *np, struct resource *res,
 	 * level of hierarchy, but I don't really feel the need
 	 * for it
 	 */
-	if (!strcmp(np->name, "escc"))
+	if (of_node_name_eq(np, "escc"))
 		return 1;
 
 	/* ESCC has bogus resources >= 3 */
-	if (index >= 3 && !(strcmp(np->name, "ch-a") &&
-			    strcmp(np->name, "ch-b")))
+	if (index >= 3 && (of_node_name_eq(np, "ch-a") ||
+			   of_node_name_eq(np, "ch-b")))
 		return 1;
 
 	/* Media bay has too many resources, keep only first one */
-	if (index > 0 && !strcmp(np->name, "media-bay"))
+	if (index > 0 && of_node_name_eq(np, "media-bay"))
 		return 1;
 
 	/* Some older IDE resources have bogus sizes */
-	if (!strcmp(np->name, "IDE") || !strcmp(np->name, "ATA") ||
+	if (of_node_name_eq(np, "IDE") || of_node_name_eq(np, "ATA") ||
 	    of_node_is_type(np, "ide") || of_node_is_type(np, "ata")) {
 		if (index == 0 && (res->end - res->start) > 0xfff)
 			res->end = res->start + 0xfff;
@@ -260,7 +260,7 @@ static void macio_add_missing_resources(struct macio_dev *dev)
 	irq_base = 64;
 
 	/* Fix SCC */
-	if (strcmp(np->name, "ch-a") == 0) {
+	if (of_node_name_eq(np, "ch-a")) {
 		macio_create_fixup_irq(dev, 0, 15 + irq_base);
 		macio_create_fixup_irq(dev, 1,  4 + irq_base);
 		macio_create_fixup_irq(dev, 2,  5 + irq_base);
@@ -268,18 +268,18 @@ static void macio_add_missing_resources(struct macio_dev *dev)
 	}
 
 	/* Fix media-bay */
-	if (strcmp(np->name, "media-bay") == 0) {
+	if (of_node_name_eq(np, "media-bay")) {
 		macio_create_fixup_irq(dev, 0, 29 + irq_base);
 		printk(KERN_INFO "macio: fixed media-bay irq on gatwick\n");
 	}
 
 	/* Fix left media bay childs */
-	if (dev->media_bay != NULL && strcmp(np->name, "floppy") == 0) {
+	if (dev->media_bay != NULL && of_node_name_eq(np, "floppy")) {
 		macio_create_fixup_irq(dev, 0, 19 + irq_base);
 		macio_create_fixup_irq(dev, 1,  1 + irq_base);
 		printk(KERN_INFO "macio: fixed left floppy irqs\n");
 	}
-	if (dev->media_bay != NULL && strcasecmp(np->name, "ata4") == 0) {
+	if (dev->media_bay != NULL && of_node_name_eq(np, "ata4")) {
 		macio_create_fixup_irq(dev, 0, 14 + irq_base);
 		macio_create_fixup_irq(dev, 0,  3 + irq_base);
 		printk(KERN_INFO "macio: fixed left ide irqs\n");
@@ -438,11 +438,8 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 
 static int macio_skip_device(struct device_node *np)
 {
-	if (strncmp(np->name, "battery", 7) == 0)
-		return 1;
-	if (strncmp(np->name, "escc-legacy", 11) == 0)
-		return 1;
-	return 0;
+	return of_node_name_prefix(np, "battery") ||
+	       of_node_name_prefix(np, "escc-legacy");
 }
 
 /**
@@ -489,9 +486,9 @@ static void macio_pci_add_devices(struct macio_chip *chip)
 					    root_res);
 		if (mdev == NULL)
 			of_node_put(np);
-		else if (strncmp(np->name, "media-bay", 9) == 0)
+		else if (of_node_name_prefix(np, "media-bay"))
 			mbdev = mdev;
-		else if (strncmp(np->name, "escc", 4) == 0)
+		else if (of_node_name_prefix(np, "escc"))
 			sdev = mdev;
 	}
 

commit bf82d3758d4a075d17f4930c9872b05bd277ab0c
Author: Rob Herring <robh@kernel.org>
Date:   Fri Nov 16 16:11:01 2018 -0600

    macintosh: Use device_type helpers to access the node type
    
    Remove directly accessing device_node.type pointer and use the
    accessors instead. This will eventually allow removing the type
    pointer.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 17d3bc917562..bc8418801224 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -220,8 +220,8 @@ static int macio_resource_quirks(struct device_node *np, struct resource *res,
 		return 1;
 
 	/* Some older IDE resources have bogus sizes */
-	if (!(strcmp(np->name, "IDE") && strcmp(np->name, "ATA") &&
-	      strcmp(np->type, "ide") && strcmp(np->type, "ata"))) {
+	if (!strcmp(np->name, "IDE") || !strcmp(np->name, "ATA") ||
+	    of_node_is_type(np, "ide") || of_node_is_type(np, "ata")) {
 		if (index == 0 && (res->end - res->start) > 0xfff)
 			res->end = res->start + 0xfff;
 		if (index == 1 && (res->end - res->start) > 0xff)

commit 0bdba867f01d69cffefee707504d3155a30f2d0f
Author: Rob Herring <robh@kernel.org>
Date:   Tue Sep 4 16:27:44 2018 -0500

    macintosh: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 07074820a167..17d3bc917562 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -360,9 +360,10 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 					       struct macio_dev *in_bay,
 					       struct resource *parent_res)
 {
+	char name[MAX_NODE_NAME_SIZE + 1];
 	struct macio_dev *dev;
 	const u32 *reg;
-	
+
 	if (np == NULL)
 		return NULL;
 
@@ -402,6 +403,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 #endif
 
 	/* MacIO itself has a different reg, we use it's PCI base */
+	snprintf(name, sizeof(name), "%pOFn", np);
 	if (np == chip->of_node) {
 		dev_set_name(&dev->ofdev.dev, "%1d.%08x:%.*s",
 			     chip->lbus.index,
@@ -410,12 +412,12 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 #else
 			0, /* NuBus may want to do something better here */
 #endif
-			MAX_NODE_NAME_SIZE, np->name);
+			MAX_NODE_NAME_SIZE, name);
 	} else {
 		reg = of_get_property(np, "reg", NULL);
 		dev_set_name(&dev->ofdev.dev, "%1d.%08x:%.*s",
 			     chip->lbus.index,
-			     reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);
+			     reg ? *reg : 0, MAX_NODE_NAME_SIZE, name);
 	}
 
 	/* Setup interrupts & resources */

commit 7bcfab202ca71bece02b283cdd104301c07eece4
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Feb 13 07:44:34 2018 -0800

    powerpc/macio: set a proper dma_coherent_mask
    
    We have expected busses to set up a coherent mask to properly use the
    common dma mapping code for a long time, and now that I've added a warning
    macio turned out to not set one up yet.  This sets it to the same value
    as the dma_mask, which seems to be what the drivers expect.
    
    Reported-by: Mathieu Malaterre <malat@debian.org>
    Tested-by: Mathieu Malaterre <malat@debian.org>
    Reported-by: Meelis Roos <mroos@linux.ee>
    Tested-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 62f541f968f6..07074820a167 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -375,6 +375,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	dev->ofdev.dev.of_node = np;
 	dev->ofdev.archdata.dma_mask = 0xffffffffUL;
 	dev->ofdev.dev.dma_mask = &dev->ofdev.archdata.dma_mask;
+	dev->ofdev.dev.coherent_dma_mask = dev->ofdev.archdata.dma_mask;
 	dev->ofdev.dev.parent = parent;
 	dev->ofdev.dev.bus = &macio_bus_type;
 	dev->ofdev.dev.release = macio_release_dev;

commit 60bb70aa761ca4090a718926f8299364a0c61ae0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jun 6 14:17:12 2017 +0200

    macintosh: use dev_groups and not dev_attrs for bus_type
    
    The dev_attrs field has long been "depreciated" and is finally being
    removed, so move the driver to use the "correct" dev_groups field
    instead for struct bus_type.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index f757cef293f8..62f541f968f6 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -133,7 +133,7 @@ static int macio_device_resume(struct device * dev)
 	return 0;
 }
 
-extern struct device_attribute macio_dev_attrs[];
+extern const struct attribute_group *macio_dev_groups[];
 
 struct bus_type macio_bus_type = {
        .name	= "macio",
@@ -144,7 +144,7 @@ struct bus_type macio_bus_type = {
        .shutdown = macio_device_shutdown,
        .suspend	= macio_device_suspend,
        .resume	= macio_device_resume,
-       .dev_attrs = macio_dev_attrs,
+       .dev_groups = macio_dev_groups,
 };
 
 static int __init macio_bus_driver_init(void)

commit 46f401c4297a2232a037ad8801b6c83c90414cf7
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Mar 9 20:33:51 2017 -0600

    powerpc/pmac: Fix crash in dma-mapping.h with NULL dma_ops
    
    Commit 5657933dbb6e ("treewide: Move dma_ops from struct dev_archdata
    into struct device") introduced a crash for macio devices, an example
    backtrace being:
    
      kernel BUG at ./include/linux/dma-mapping.h:465!
      Oops: Exception in kernel mode, sig: 5 [#1]
      ...
      NIP [c031ddb0] dmam_alloc_coherent+0x74/0x140
      LR [c031de70] dmam_alloc_coherent+0x134/0x140
      Call Trace:
       dmam_alloc_coherent+0x134/0x140 (unreliable)
       pata_macio_port_start+0x3c/0x8c
       ata_host_start.part.5+0xfc/0x208
       ata_host_activate+0x128/0x154
       pata_macio_common_init+0x2f0/0x538
       pata_macio_attach+0xd8/0x180
       macio_device_probe+0x5c/0xec
       driver_probe_device+0x21c/0x314
       __driver_attach+0xcc/0xd0
       bus_for_each_dev+0x68/0xb4
       bus_add_driver+0x1dc/0x244
       driver_register+0x88/0x130
       pata_macio_init+0x5c/0x88
       do_one_initcall+0x40/0x170
       kernel_init_freeable+0x134/0x1d0
       kernel_init+0x18/0x110
       ret_from_kernel_thread+0x5c/0x64
    
    This was caused by the device having NULL dma_ops, triggering the
    BUG_ON(). Previously the device inherited its dma_ops via the assignment
    to dev->ofdev.dev.archdata. However after commit 5657933dbb6e the
    dma_ops are moved into dev->ofdev.dev, and so they need to be explicitly
    copied.
    
    Fixes: 5657933dbb6e ("treewide: Move dma_ops from struct dev_archdata into struct device")
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Suggested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [mpe: Rewrite change log, add backtrace]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 3f041b187033..f757cef293f8 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -392,6 +392,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	 * To get all the fields, copy all archdata
 	 */
 	dev->ofdev.dev.archdata = chip->lbus.pdev->dev.archdata;
+	dev->ofdev.dev.dma_ops = chip->lbus.pdev->dev.dma_ops;
 #endif /* CONFIG_PCI */
 
 #ifdef DEBUG

commit ef24ba7091517d2bbf9ba2cb4256c0dccd51d248
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Sep 6 21:53:24 2016 +1000

    powerpc: Remove all usages of NO_IRQ
    
    NO_IRQ has been == 0 on powerpc for just over ten years (since commit
    0ebfff1491ef ("[POWERPC] Add new interrupt mapping core and change
    platforms to use it")). It's also 0 on most other arches.
    
    Although it's fairly harmless, every now and then it causes confusion
    when a driver is built on powerpc and another arch which doesn't define
    NO_IRQ. There's at least 6 definitions of NO_IRQ in drivers/, at least
    some of which are to work around that problem.
    
    So we'd like to remove it. This is fairly trivial in the arch code, we
    just convert:
    
        if (irq == NO_IRQ)  to      if (!irq)
        if (irq != NO_IRQ)  to      if (irq)
        irq = NO_IRQ;       to      irq = 0;
        return NO_IRQ;      to      return 0;
    
    And a few other odd cases as well.
    
    At least for now we keep the #define NO_IRQ, because there is driver
    code that uses NO_IRQ and the fixes to remove those will go via other
    trees.
    
    Note we also change some occurrences in PPC sound drivers, drivers/ps3,
    and drivers/macintosh.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index b6819f0fc608..3f041b187033 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -236,7 +236,7 @@ static void macio_create_fixup_irq(struct macio_dev *dev, int index,
 	unsigned int irq;
 
 	irq = irq_create_mapping(NULL, line);
-	if (irq != NO_IRQ) {
+	if (!irq) {
 		dev->interrupt[index].start = irq;
 		dev->interrupt[index].flags = IORESOURCE_IRQ;
 		dev->interrupt[index].name = dev_name(&dev->ofdev.dev);
@@ -299,7 +299,7 @@ static void macio_setup_interrupts(struct macio_dev *dev)
 			break;
 		res = &dev->interrupt[j];
 		irq = irq_of_parse_and_map(np, i++);
-		if (irq == NO_IRQ)
+		if (!irq)
 			break;
 		res->start = irq;
 		res->flags = IORESOURCE_IRQ;

commit 952bbcb0781bd1341f6a9f5c96fc32737392c04a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 5 14:58:12 2016 -0600

    PCI: Remove includes of asm/pci-bridge.h
    
    Drivers should include asm/pci-bridge.h only when they need the arch-
    specific things provided there.  Outside of the arch/ directories, the only
    drivers that actually need things provided by asm/pci-bridge.h are the
    powerpc RPA hotplug drivers in drivers/pci/hotplug/rpa*.
    
    Remove the includes of asm/pci-bridge.h from the other drivers, adding an
    include of linux/pci.h if necessary.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 4f12c6f01fe7..b6819f0fc608 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -31,7 +31,6 @@
 #include <asm/macio.h>
 #include <asm/pmac_feature.h>
 #include <asm/prom.h>
-#include <asm/pci-bridge.h>
 
 #undef DEBUG
 

commit 5af5073004071cedd0343eee51d77955037ec6f3
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Sep 17 14:28:33 2013 -0500

    drivers: clean-up prom.h implicit includes
    
    Powerpc is a mess of implicit includes by prom.h. Add the necessary
    explicit includes to drivers in preparation of prom.h cleanup.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index ac5c87939860..4f12c6f01fe7 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -24,6 +24,8 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/machdep.h>
 #include <asm/macio.h>

commit 1da42fb6bf6fcddfa8981df0cf63b67c745778a6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 15:03:50 2012 -0800

    Drivers: macintosh: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitconst,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index ef87310b7662..ac5c87939860 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -679,7 +679,7 @@ void macio_release_resources(struct macio_dev *dev)
 
 #ifdef CONFIG_PCI
 
-static int __devinit macio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+static int macio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct device_node* np;
 	struct macio_chip* chip;
@@ -739,7 +739,7 @@ static int __devinit macio_pci_probe(struct pci_dev *pdev, const struct pci_devi
 	return 0;
 }
 
-static void __devexit macio_pci_remove(struct pci_dev* pdev)
+static void macio_pci_remove(struct pci_dev* pdev)
 {
 	panic("removing of macio-asic not supported !\n");
 }
@@ -748,7 +748,7 @@ static void __devexit macio_pci_remove(struct pci_dev* pdev)
  * MacIO is matched against any Apple ID, it's probe() function
  * will then decide wether it applies or not
  */
-static const struct pci_device_id __devinitconst pci_ids[] = { {
+static const struct pci_device_id pci_ids[] = { {
 	.vendor		= PCI_VENDOR_ID_APPLE,
 	.device		= PCI_ANY_ID,
 	.subvendor	= PCI_ANY_ID,

commit dd0e981a6cc855a785e43d743c399196c144cdd6
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Oct 4 17:11:50 2012 -0700

    sections: fix section conflicts in drivers/macintosh
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 20e5c2cda430..ef87310b7662 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -748,7 +748,7 @@ static void __devexit macio_pci_remove(struct pci_dev* pdev)
  * MacIO is matched against any Apple ID, it's probe() function
  * will then decide wether it applies or not
  */
-static const struct pci_device_id __devinitdata pci_ids [] = { {
+static const struct pci_device_id __devinitconst pci_ids[] = { {
 	.vendor		= PCI_VENDOR_ID_APPLE,
 	.device		= PCI_ANY_ID,
 	.subvendor	= PCI_ANY_ID,

commit 07d57a32fb6eb2da017796e038682f817a4f685e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Feb 1 11:22:22 2012 -0700

    drivercore: Output common devicetree information in uevent
    
    When userspace needs to find a specific device, it currently isn't easy to
    resolve a /sys/devices/ path from a specific device tree node.  Nor is it
    easy to obtain the compatible list for devices.
    
    This patch generalizes the code that inserts OF_* values into the uevent
    device attribute so that any device that is attached to an OF node will
    have that information exported to userspace.  Without this patch only
    platform devices and some powerpc-specific busses have access to this
    data.
    
    The original function also creates a MODALIAS property for the compatible
    list, but that code has not been generalized into the common case because
    it has the potential to break module loading on a lot of bus types.  Bus
    types are still responsible for their own MODALIAS properties.
    
    Boot tested on ARM and compile tested on PowerPC and SPARC.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Frederic Lambert <frdrc66@gmail.com>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Mark Brown <broonie@sirena.org.uk>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 4daf9e5a7736..20e5c2cda430 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -137,7 +137,7 @@ extern struct device_attribute macio_dev_attrs[];
 struct bus_type macio_bus_type = {
        .name	= "macio",
        .match	= macio_bus_match,
-       .uevent = of_device_uevent,
+       .uevent = of_device_uevent_modalias,
        .probe	= macio_device_probe,
        .remove	= macio_device_remove,
        .shutdown = macio_device_shutdown,

commit f6aedd8606ae673f8e1f4d972fc86c451fbc8ba7
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Tue Oct 26 17:35:11 2010 +0000

    powerpc/macio: Ensure all dma routines get copied over
    
    Also add a comment to dev_archdata, indicating that changes there need
    to be verified against the driver code.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index b6e7ddc09d76..4daf9e5a7736 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -387,11 +387,10 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	/* Set the DMA ops to the ones from the PCI device, this could be
 	 * fishy if we didn't know that on PowerMac it's always direct ops
 	 * or iommu ops that will work fine
+	 *
+	 * To get all the fields, copy all archdata
 	 */
-	dev->ofdev.dev.archdata.dma_ops =
-		chip->lbus.pdev->dev.archdata.dma_ops;
-	dev->ofdev.dev.archdata.dma_data =
-		chip->lbus.pdev->dev.archdata.dma_data;
+	dev->ofdev.dev.archdata = chip->lbus.pdev->dev.archdata;
 #endif /* CONFIG_PCI */
 
 #ifdef DEBUG

commit c2cdf6aba0dfcfb54be646ab630c1bccd180e890
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Jun 2 17:09:18 2010 +1000

    powerpc/macio: Fix probing of macio devices by using the right of match table
    
    Grant patches added an of mach table to struct device_driver. However,
    while he changed the macio device code to use that, he left the match
    table pointer in struct macio_driver and didn't update drivers to use
    the "new" one, thus breaking the probing.
    
    This completes the change by moving all drivers to setup the "new"
    one, removing all traces of the old one, and while at it (since it
    changes the exact same locations), I also remove two other duplicates
    from struct driver which are the name and owner fields.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 40390ac01309..b6e7ddc09d76 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -526,7 +526,6 @@ static void macio_pci_add_devices(struct macio_chip *chip)
 int macio_register_driver(struct macio_driver *drv)
 {
 	/* initialize common driver fields */
-	drv->driver.name = drv->name;
 	drv->driver.bus = &macio_bus_type;
 
 	/* register with core */

commit 83aea945c21c646184a494a32ad5524248b60226
Author: Andreas Schwab <schwab@linux-m68k.org>
Date:   Tue Jun 1 05:58:40 2010 +0000

    powerpc/macio: Don't dereference pointer before null check
    
    Signed-off-by: Andreas Schwab <schwab@linux-m68k.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 97147804a49c..40390ac01309 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -492,8 +492,8 @@ static void macio_pci_add_devices(struct macio_chip *chip)
 	}
 
 	/* Add media bay devices if any */
-	pnode = mbdev->ofdev.dev.of_node;
-	if (mbdev)
+	if (mbdev) {
+		pnode = mbdev->ofdev.dev.of_node;
 		for (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {
 			if (macio_skip_device(np))
 				continue;
@@ -502,10 +502,11 @@ static void macio_pci_add_devices(struct macio_chip *chip)
 						 mbdev,  root_res) == NULL)
 				of_node_put(np);
 		}
+	}
 
 	/* Add serial ports if any */
-	pnode = sdev->ofdev.dev.of_node;
 	if (sdev) {
+		pnode = sdev->ofdev.dev.of_node;
 		for (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {
 			if (macio_skip_device(np))
 				continue;

commit 44504b2bebf8b5823c59484e73096a7d6574471d
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:22 2010 -0700

    of: change of_match_device to work with struct device
    
    The of_node pointer is now stored directly in struct device, so
    of_match_device() should work with any device, not just struct of_device.
    
    This patch changes the interface to of_match_device() to accept a
    struct device instead of struct of_device.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index e3ba1d8001a3..97147804a49c 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -39,13 +39,12 @@ static struct macio_chip      *macio_on_hold;
 
 static int macio_bus_match(struct device *dev, struct device_driver *drv) 
 {
-	struct macio_dev * macio_dev = to_macio_device(dev);
 	const struct of_device_id * matches = drv->of_match_table;
 
 	if (!matches) 
 		return 0;
 
-	return of_match_device(matches, &macio_dev->ofdev) != NULL;
+	return of_match_device(matches, dev) != NULL;
 }
 
 struct macio_dev *macio_dev_get(struct macio_dev *dev)
@@ -83,7 +82,7 @@ static int macio_device_probe(struct device *dev)
 
 	macio_dev_get(macio_dev);
 
-	match = of_match_device(drv->driver.of_match_table, &macio_dev->ofdev);
+	match = of_match_device(drv->driver.of_match_table, dev);
 	if (match)
 		error = drv->probe(macio_dev, match);
 	if (error)

commit 597b9d1e44e9ba69f2454a5318bbe7a6d5e6930a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:01 2010 -0700

    drivercore: Add of_match_table to the common device drivers
    
    OF-style matching can be available to any device, on any type of bus.
    This patch allows any driver to provide an OF match table when CONFIG_OF
    is enabled so that drivers can be bound against devices described in
    the device tree.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 48a5f0406865..e3ba1d8001a3 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -40,8 +40,7 @@ static struct macio_chip      *macio_on_hold;
 static int macio_bus_match(struct device *dev, struct device_driver *drv) 
 {
 	struct macio_dev * macio_dev = to_macio_device(dev);
-	struct macio_driver * macio_drv = to_macio_driver(drv);
-	const struct of_device_id * matches = macio_drv->match_table;
+	const struct of_device_id * matches = drv->of_match_table;
 
 	if (!matches) 
 		return 0;
@@ -84,7 +83,7 @@ static int macio_device_probe(struct device *dev)
 
 	macio_dev_get(macio_dev);
 
-	match = of_match_device(drv->match_table, &macio_dev->ofdev);
+	match = of_match_device(drv->driver.of_match_table, &macio_dev->ofdev);
 	if (match)
 		error = drv->probe(macio_dev, match);
 	if (error)

commit cb6dc512b745292eaf123fedf437c211e27fb680
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:59 2010 -0700

    arch/powerpc: Move dma_mask from of_device into pdev_archdata
    
    By moving dma_mask into pdev_archdata, and adding archdata to
    struct of_device, it makes it possible to substitute of_device
    with struct platform_device, which is a stepping stone to
    removing the of_platform bus entirely.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 67fe13ffe90b..48a5f0406865 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -374,8 +374,8 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	dev->bus = &chip->lbus;
 	dev->media_bay = in_bay;
 	dev->ofdev.dev.of_node = np;
-	dev->ofdev.dma_mask = 0xffffffffUL;
-	dev->ofdev.dev.dma_mask = &dev->ofdev.dma_mask;
+	dev->ofdev.archdata.dma_mask = 0xffffffffUL;
+	dev->ofdev.dev.dma_mask = &dev->ofdev.archdata.dma_mask;
 	dev->ofdev.dev.parent = parent;
 	dev->ofdev.dev.bus = &macio_bus_type;
 	dev->ofdev.dev.release = macio_release_dev;

commit 61c7a080a5a061c976988fd4b844dfb468dda255
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:29 2010 -0700

    of: Always use 'struct device.of_node' to get device node pointer.
    
    The following structure elements duplicate the information in
    'struct device.of_node' and so are being eliminated.  This patch
    makes all readers of these elements use device.of_node instead.
    
    (struct of_device *)->node
    (struct dev_archdata *)->prom_node (sparc)
    (struct dev_archdata *)->of_node (powerpc & microblaze)
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 26a303a1d1ab..67fe13ffe90b 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -248,7 +248,7 @@ static void macio_create_fixup_irq(struct macio_dev *dev, int index,
 
 static void macio_add_missing_resources(struct macio_dev *dev)
 {
-	struct device_node *np = dev->ofdev.node;
+	struct device_node *np = dev->ofdev.dev.of_node;
 	unsigned int irq_base;
 
 	/* Gatwick has some missing interrupts on child nodes */
@@ -289,7 +289,7 @@ static void macio_add_missing_resources(struct macio_dev *dev)
 
 static void macio_setup_interrupts(struct macio_dev *dev)
 {
-	struct device_node *np = dev->ofdev.node;
+	struct device_node *np = dev->ofdev.dev.of_node;
 	unsigned int irq;
 	int i = 0, j = 0;
 
@@ -317,7 +317,7 @@ static void macio_setup_interrupts(struct macio_dev *dev)
 static void macio_setup_resources(struct macio_dev *dev,
 				  struct resource *parent_res)
 {
-	struct device_node *np = dev->ofdev.node;
+	struct device_node *np = dev->ofdev.dev.of_node;
 	struct resource r;
 	int index;
 
@@ -373,7 +373,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 
 	dev->bus = &chip->lbus;
 	dev->media_bay = in_bay;
-	dev->ofdev.node = np;
+	dev->ofdev.dev.of_node = np;
 	dev->ofdev.dma_mask = 0xffffffffUL;
 	dev->ofdev.dev.dma_mask = &dev->ofdev.dma_mask;
 	dev->ofdev.dev.parent = parent;
@@ -494,9 +494,9 @@ static void macio_pci_add_devices(struct macio_chip *chip)
 	}
 
 	/* Add media bay devices if any */
+	pnode = mbdev->ofdev.dev.of_node;
 	if (mbdev)
-		for (np = NULL; (np = of_get_next_child(mbdev->ofdev.node, np))
-			     != NULL;) {
+		for (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {
 			if (macio_skip_device(np))
 				continue;
 			of_node_get(np);
@@ -506,9 +506,9 @@ static void macio_pci_add_devices(struct macio_chip *chip)
 		}
 
 	/* Add serial ports if any */
+	pnode = sdev->ofdev.dev.of_node;
 	if (sdev) {
-		for (np = NULL; (np = of_get_next_child(sdev->ofdev.node, np))
-			     != NULL;) {
+		for (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {
 			if (macio_skip_device(np))
 				continue;
 			of_node_get(np);

commit 128b4a0ef74e8d48033513e41a413087ba30e36b
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Dec 1 14:36:27 2009 +0000

    powerpc/macio: Add dma_parms support to macio
    
    This adds dma_parms to macio devices and initializes them with
    default values. This will allow pata_macio to setup the appropriate
    max segment size for the block layer.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 5200acfc9d38..26a303a1d1ab 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -379,6 +379,11 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	dev->ofdev.dev.parent = parent;
 	dev->ofdev.dev.bus = &macio_bus_type;
 	dev->ofdev.dev.release = macio_release_dev;
+	dev->ofdev.dev.dma_parms = &dev->dma_parms;
+
+	/* Standard DMA paremeters */
+	dma_set_max_seg_size(&dev->ofdev.dev, 65536);
+	dma_set_seg_boundary(&dev->ofdev.dev, 0xffffffff);
 
 #ifdef CONFIG_PCI
 	/* Set the DMA ops to the ones from the PCI device, this could be

commit 7fb19ea054a0cdf1a4d935e68d51bde4d3725414
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Dec 1 14:36:26 2009 +0000

    powerpc/macio: Add devres support to macio_device
    
    This adds some basic devres support. When enabled via macio_enable_devres()
    resources requested by drivers will be automatically released.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 588a5b0bc4b5..5200acfc9d38 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -538,6 +538,42 @@ void macio_unregister_driver(struct macio_driver *drv)
 	driver_unregister(&drv->driver);
 }
 
+/* Managed MacIO resources */
+struct macio_devres {
+	u32	res_mask;
+};
+
+static void maciom_release(struct device *gendev, void *res)
+{
+	struct macio_dev *dev = to_macio_device(gendev);
+	struct macio_devres *dr = res;
+	int i, max;
+
+	max = min(dev->n_resources, 32);
+	for (i = 0; i < max; i++) {
+		if (dr->res_mask & (1 << i))
+			macio_release_resource(dev, i);
+	}
+}
+
+int macio_enable_devres(struct macio_dev *dev)
+{
+	struct macio_devres *dr;
+
+	dr = devres_find(&dev->ofdev.dev, maciom_release, NULL, NULL);
+	if (!dr) {
+		dr = devres_alloc(maciom_release, sizeof(*dr), GFP_KERNEL);
+		if (!dr)
+			return -ENOMEM;
+	}
+	return devres_get(&dev->ofdev.dev, dr, NULL, NULL) != NULL;
+}
+
+static struct macio_devres * find_macio_dr(struct macio_dev *dev)
+{
+	return devres_find(&dev->ofdev.dev, maciom_release, NULL, NULL);
+}
+
 /**
  *	macio_request_resource - Request an MMIO resource
  * 	@dev: pointer to the device holding the resource
@@ -555,6 +591,8 @@ void macio_unregister_driver(struct macio_driver *drv)
 int macio_request_resource(struct macio_dev *dev, int resource_no,
 			   const char *name)
 {
+	struct macio_devres *dr = find_macio_dr(dev);
+
 	if (macio_resource_len(dev, resource_no) == 0)
 		return 0;
 		
@@ -562,6 +600,9 @@ int macio_request_resource(struct macio_dev *dev, int resource_no,
 				macio_resource_len(dev, resource_no),
 				name))
 		goto err_out;
+
+	if (dr && resource_no < 32)
+		dr->res_mask |= 1 << resource_no;
 	
 	return 0;
 
@@ -582,10 +623,14 @@ int macio_request_resource(struct macio_dev *dev, int resource_no,
  */
 void macio_release_resource(struct macio_dev *dev, int resource_no)
 {
+	struct macio_devres *dr = find_macio_dr(dev);
+
 	if (macio_resource_len(dev, resource_no) == 0)
 		return;
 	release_mem_region(macio_resource_start(dev, resource_no),
 			   macio_resource_len(dev, resource_no));
+	if (dr && resource_no < 32)
+		dr->res_mask &= ~(1 << resource_no);
 }
 
 /**
@@ -744,3 +789,5 @@ EXPORT_SYMBOL(macio_request_resource);
 EXPORT_SYMBOL(macio_release_resource);
 EXPORT_SYMBOL(macio_request_resources);
 EXPORT_SYMBOL(macio_release_resources);
+EXPORT_SYMBOL(macio_enable_devres);
+

commit fb2881a7134576a6e95a63e3d2f34ea5629db4a1
Author: roel kluin <roel.kluin@gmail.com>
Date:   Mon Aug 3 02:41:42 2009 +0000

    powerpc/macio: Don't the address of an array element before boundchecking
    
    Check whether index is within bounds before grabbing the element.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index a0f68386c12f..588a5b0bc4b5 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -294,10 +294,11 @@ static void macio_setup_interrupts(struct macio_dev *dev)
 	int i = 0, j = 0;
 
 	for (;;) {
-		struct resource *res = &dev->interrupt[j];
+		struct resource *res;
 
 		if (j >= MACIO_DEV_COUNT_IRQS)
 			break;
+		res = &dev->interrupt[j];
 		irq = irq_of_parse_and_map(np, i++);
 		if (irq == NO_IRQ)
 			break;
@@ -321,9 +322,10 @@ static void macio_setup_resources(struct macio_dev *dev,
 	int index;
 
 	for (index = 0; of_address_to_resource(np, index, &r) == 0; index++) {
-		struct resource *res = &dev->resource[index];
+		struct resource *res;
 		if (index >= MACIO_DEV_COUNT_RESOURCES)
 			break;
+		res = &dev->resource[index];
 		*res = r;
 		res->name = dev_name(&dev->ofdev.dev);
 

commit 3514141aedc16c7344117d5bd79ec1310edf8fb3
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Jun 18 19:20:51 2009 +0000

    powerpc/pmac: Fix DMA ops for MacIO devices
    
    The macio_dev's created to map devices inside the MacIO ASICs
    don't have proper dma_ops. This causes crashes on some machines
    since the SCSI code calls dma_map_* on our behalf using the
    device we hang from.
    
    This fixes it by copying the parent PCI device dma_ops into
    the macio_dev when creating it.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 6e149f4a1fff..a0f68386c12f 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -378,6 +378,17 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	dev->ofdev.dev.bus = &macio_bus_type;
 	dev->ofdev.dev.release = macio_release_dev;
 
+#ifdef CONFIG_PCI
+	/* Set the DMA ops to the ones from the PCI device, this could be
+	 * fishy if we didn't know that on PowerMac it's always direct ops
+	 * or iommu ops that will work fine
+	 */
+	dev->ofdev.dev.archdata.dma_ops =
+		chip->lbus.pdev->dev.archdata.dma_ops;
+	dev->ofdev.dev.archdata.dma_data =
+		chip->lbus.pdev->dev.archdata.dma_data;
+#endif /* CONFIG_PCI */
+
 #ifdef DEBUG
 	printk("preparing mdev @%p, ofdev @%p, dev @%p, kobj @%p\n",
 	       dev, &dev->ofdev, &dev->ofdev.dev, &dev->ofdev.dev.kobj);

commit 1d7e6cca1dfd167e5f1e2a7c53119b0c80c90c35
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Jan 6 10:44:39 2009 -0800

    macintosh: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index ec9e5f32f0ae..6e149f4a1fff 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -33,7 +33,7 @@
 
 #undef DEBUG
 
-#define MAX_NODE_NAME_SIZE (BUS_ID_SIZE - 12)
+#define MAX_NODE_NAME_SIZE (20 - 12)
 
 static struct macio_chip      *macio_on_hold;
 
@@ -240,7 +240,7 @@ static void macio_create_fixup_irq(struct macio_dev *dev, int index,
 	if (irq != NO_IRQ) {
 		dev->interrupt[index].start = irq;
 		dev->interrupt[index].flags = IORESOURCE_IRQ;
-		dev->interrupt[index].name = dev->ofdev.dev.bus_id;
+		dev->interrupt[index].name = dev_name(&dev->ofdev.dev);
 	}
 	if (dev->n_interrupts <= index)
 		dev->n_interrupts = index + 1;
@@ -303,7 +303,7 @@ static void macio_setup_interrupts(struct macio_dev *dev)
 			break;
 		res->start = irq;
 		res->flags = IORESOURCE_IRQ;
-		res->name = dev->ofdev.dev.bus_id;
+		res->name = dev_name(&dev->ofdev.dev);
 		if (macio_resource_quirks(np, res, i - 1)) {
 			memset(res, 0, sizeof(struct resource));
 			continue;
@@ -325,7 +325,7 @@ static void macio_setup_resources(struct macio_dev *dev,
 		if (index >= MACIO_DEV_COUNT_RESOURCES)
 			break;
 		*res = r;
-		res->name = dev->ofdev.dev.bus_id;
+		res->name = dev_name(&dev->ofdev.dev);
 
 		if (macio_resource_quirks(np, res, index)) {
 			memset(res, 0, sizeof(struct resource));
@@ -338,7 +338,7 @@ static void macio_setup_resources(struct macio_dev *dev,
 		if (insert_resource(parent_res, res)) {
 			printk(KERN_WARNING "Can't request resource "
 			       "%d for MacIO device %s\n",
-			       index, dev->ofdev.dev.bus_id);
+			       index, dev_name(&dev->ofdev.dev));
 		}
 	}
 	dev->n_resources = index;
@@ -385,8 +385,8 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 
 	/* MacIO itself has a different reg, we use it's PCI base */
 	if (np == chip->of_node) {
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
-			chip->lbus.index,
+		dev_set_name(&dev->ofdev.dev, "%1d.%08x:%.*s",
+			     chip->lbus.index,
 #ifdef CONFIG_PCI
 			(unsigned int)pci_resource_start(chip->lbus.pdev, 0),
 #else
@@ -395,9 +395,9 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 			MAX_NODE_NAME_SIZE, np->name);
 	} else {
 		reg = of_get_property(np, "reg", NULL);
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
-			chip->lbus.index,
-			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);
+		dev_set_name(&dev->ofdev.dev, "%1d.%08x:%.*s",
+			     chip->lbus.index,
+			     reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);
 	}
 
 	/* Setup interrupts & resources */
@@ -408,7 +408,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	/* Register with core */
 	if (of_device_register(&dev->ofdev) != 0) {
 		printk(KERN_DEBUG"macio: device registration error for %s!\n",
-		       dev->ofdev.dev.bus_id);
+		       dev_name(&dev->ofdev.dev));
 		kfree(dev);
 		return NULL;
 	}
@@ -558,7 +558,7 @@ int macio_request_resource(struct macio_dev *dev, int resource_no,
 		resource_no,
 		macio_resource_len(dev, resource_no),
 		macio_resource_start(dev, resource_no),
-		dev->ofdev.dev.bus_id);
+		dev_name(&dev->ofdev.dev));
 	return -EBUSY;
 }
 

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index c96b7fe882a4..ec9e5f32f0ae 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -365,10 +365,9 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	if (np == NULL)
 		return NULL;
 
-	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
 		return NULL;
-	memset(dev, 0, sizeof(*dev));
 
 	dev->bus = &chip->lbus;
 	dev->media_bay = in_bay;

commit 01b2726dd11ef198ac6cf8f88974b4427d40ffdb
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Apr 27 13:41:15 2007 +1000

    [POWERPC] Rename get_property to of_get_property: partial drivers
    
    This does drivers/machintosh and the hvc code.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index e851266a2db1..c96b7fe882a4 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -395,7 +395,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 #endif
 			MAX_NODE_NAME_SIZE, np->name);
 	} else {
-		reg = get_property(np, "reg", NULL);
+		reg = of_get_property(np, "reg", NULL);
 		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
 			chip->lbus.index,
 			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);

commit a48141db68e4b9143759435badcc1a49d9022db4
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Apr 26 22:24:31 2007 +1000

    Revert "[POWERPC] Rename get_property to of_get_property: drivers"
    
    This reverts commit d05c7a80cf39ae7d0f8d0c3e47c93d51fcd393d3,
    which included changes which should go via other subsystem
    maintainers.

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index c96b7fe882a4..e851266a2db1 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -395,7 +395,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 #endif
 			MAX_NODE_NAME_SIZE, np->name);
 	} else {
-		reg = of_get_property(np, "reg", NULL);
+		reg = get_property(np, "reg", NULL);
 		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
 			chip->lbus.index,
 			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);

commit d05c7a80cf39ae7d0f8d0c3e47c93d51fcd393d3
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 3 22:40:39 2007 +1000

    [POWERPC] Rename get_property to of_get_property: drivers
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index e851266a2db1..c96b7fe882a4 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -395,7 +395,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 #endif
 			MAX_NODE_NAME_SIZE, np->name);
 	} else {
-		reg = get_property(np, "reg", NULL);
+		reg = of_get_property(np, "reg", NULL);
 		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
 			chip->lbus.index,
 			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);

commit cc11645b9d04c3df5180620bded522e14e619604
Author: Sylvain Munaut <tnt@246tNt.com>
Date:   Mon Feb 12 23:13:26 2007 +0100

    [POWERPC] powermac: Use the new of_device common uevent handler
    
    The generation of the uevent is now common to all bus using
    of_device.
    
    Signed-off-by: Sylvain Munaut <tnt@246tNt.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index d56216067549..e851266a2db1 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -134,108 +134,12 @@ static int macio_device_resume(struct device * dev)
 	return 0;
 }
 
-static int macio_uevent(struct device *dev, char **envp, int num_envp,
-                          char *buffer, int buffer_size)
-{
-	struct macio_dev * macio_dev;
-	struct of_device * of;
-	char *scratch;
-	const char *compat, *compat2;
-
-	int i = 0;
-	int length, cplen, cplen2, seen = 0;
-
-	if (!dev)
-		return -ENODEV;
-
-	macio_dev = to_macio_device(dev);
-	if (!macio_dev)
-		return -ENODEV;
-
-	of = &macio_dev->ofdev;
-
-	/* stuff we want to pass to /sbin/hotplug */
-	envp[i++] = scratch = buffer;
-	length = scnprintf (scratch, buffer_size, "OF_NAME=%s", of->node->name);
-	++length;
-	buffer_size -= length;
-	if ((buffer_size <= 0) || (i >= num_envp))
-		return -ENOMEM;
-	scratch += length;
-
-	envp[i++] = scratch;
-	length = scnprintf (scratch, buffer_size, "OF_TYPE=%s", of->node->type);
-	++length;
-	buffer_size -= length;
-	if ((buffer_size <= 0) || (i >= num_envp))
-		return -ENOMEM;
-	scratch += length;
-
-        /* Since the compatible field can contain pretty much anything
-         * it's not really legal to split it out with commas. We split it
-         * up using a number of environment variables instead. */
-
-	compat = get_property(of->node, "compatible", &cplen);
-	compat2 = compat;
-	cplen2= cplen;
-	while (compat && cplen > 0) {
-                envp[i++] = scratch;
-		length = scnprintf (scratch, buffer_size,
-		                     "OF_COMPATIBLE_%d=%s", seen, compat);
-		++length;
-		buffer_size -= length;
-		if ((buffer_size <= 0) || (i >= num_envp))
-			return -ENOMEM;
-		scratch += length;
-		length = strlen (compat) + 1;
-		compat += length;
-		cplen -= length;
-		seen++;
-	}
-
-	envp[i++] = scratch;
-	length = scnprintf (scratch, buffer_size, "OF_COMPATIBLE_N=%d", seen);
-	++length;
-	buffer_size -= length;
-	if ((buffer_size <= 0) || (i >= num_envp))
-		return -ENOMEM;
-	scratch += length;
-
-	envp[i++] = scratch;
-	length = scnprintf (scratch, buffer_size, "MODALIAS=of:N%sT%s",
-			of->node->name, of->node->type);
-	/* overwrite '\0' */
-	buffer_size -= length;
-	if ((buffer_size <= 0) || (i >= num_envp))
-		return -ENOMEM;
-	scratch += length;
-
-	if (!compat2) {
-		compat2 = "";
-		cplen2 = 1;
-	}
-	while (cplen2 > 0) {
-		length = snprintf (scratch, buffer_size, "C%s", compat2);
-		buffer_size -= length;
-		if (buffer_size <= 0)
-			return -ENOMEM;
-		scratch += length;
-		length = strlen (compat2) + 1;
-		compat2 += length;
-		cplen2 -= length;
-	}
-
-	envp[i] = NULL;
-
-	return 0;
-}
-
 extern struct device_attribute macio_dev_attrs[];
 
 struct bus_type macio_bus_type = {
        .name	= "macio",
        .match	= macio_bus_match,
-       .uevent = macio_uevent,
+       .uevent = of_device_uevent,
        .probe	= macio_device_probe,
        .remove	= macio_device_remove,
        .shutdown = macio_device_shutdown,

commit 57cad8084e0837e0f2c97da789ec9b3f36809be9
Merge: cb18bd40030c 49b1e3ea19b1
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Aug 1 10:37:25 2006 +1000

    Merge branch 'merge'

commit 018a3d1db7cdb6127656c1622ee1d2302e16436d
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Wed Jul 12 15:40:29 2006 +1000

    [POWERPC] powermac: Constify & voidify get_property()
    
    Now that get_property() returns a void *, there's no need to cast its
    return value. Also, treat the return value as const, so we can
    constify get_property later.
    
    powermac platform & macintosh driver changes.
    
    Built for pmac32_defconfig, g5_defconfig
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 80c0c665b5f6..7817cf286d0c 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -139,7 +139,9 @@ static int macio_uevent(struct device *dev, char **envp, int num_envp,
 {
 	struct macio_dev * macio_dev;
 	struct of_device * of;
-	char *scratch, *compat, *compat2;
+	char *scratch;
+	const char *compat, *compat2;
+
 	int i = 0;
 	int length, cplen, cplen2, seen = 0;
 
@@ -173,7 +175,7 @@ static int macio_uevent(struct device *dev, char **envp, int num_envp,
          * it's not really legal to split it out with commas. We split it
          * up using a number of environment variables instead. */
 
-	compat = (char *) get_property(of->node, "compatible", &cplen);
+	compat = get_property(of->node, "compatible", &cplen);
 	compat2 = compat;
 	cplen2= cplen;
 	while (compat && cplen > 0) {
@@ -454,7 +456,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 					       struct resource *parent_res)
 {
 	struct macio_dev *dev;
-	u32 *reg;
+	const u32 *reg;
 	
 	if (np == NULL)
 		return NULL;
@@ -489,7 +491,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 #endif
 			MAX_NODE_NAME_SIZE, np->name);
 	} else {
-		reg = (u32 *)get_property(np, "reg", NULL);
+		reg = get_property(np, "reg", NULL);
 		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
 			chip->lbus.index,
 			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);

commit 6e99e4582861578fb00d84d085f8f283569f51dd
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 10 04:44:42 2006 -0700

    [PATCH] powerpc: fix trigger handling in the new irq code
    
    This patch slightly reworks the new irq code to fix a small design error.  I
    removed the passing of the trigger to the map() calls entirely, it was not a
    good idea to have one call do two different things.  It also fixes a couple of
    corner cases.
    
    Mapping a linux virtual irq to a physical irq now does only that.  Setting the
    trigger is a different action which has a different call.
    
    The main changes are:
    
    - I no longer call host->ops->map() for an already mapped irq, I just return
      the virtual number that was already mapped.  It was called before to give an
      opportunity to change the trigger, but that was causing issues as that could
      happen while the interrupt was in use by a device, and because of the
      trigger change, map would potentially muck around with things in a racy way.
       That was causing much burden on a given's controller implementation of
      map() to get it right.  This is much simpler now.  map() is only called on
      the initial mapping of an irq, meaning that you know that this irq is _not_
      being used.  You can initialize the hardware if you want (though you don't
      have to).
    
    - Controllers that can handle different type of triggers (level/edge/etc...)
      now implement the standard irq_chip->set_type() call as defined by the
      generic code.  That means that you can use the standard set_irq_type() to
      configure an irq line manually if you wish or (though I don't like that
      interface), pass explicit trigger flags to request_irq() as defined by the
      generic kernel interfaces.  Also, using those interfaces guarantees that
      your controller set_type callback is called with the descriptor lock held,
      thus providing locking against activity on the same interrupt (including
      mask/unmask/etc...) automatically.  A result is that, for example, MPIC's
      own map() implementation calls irq_set_type(NONE) to configure the hardware
      to the default triggers.
    
    - To allow the above, the irq_map array entry for the new mapped interrupt
      is now set before map() callback is called for the controller.
    
    - The irq_create_of_mapping() (also used by irq_of_parse_and_map()) function
      for mapping interrupts from the device-tree now also call the separate
      set_irq_type(), and only does so if there is a change in the trigger type.
    
    - While I was at it, I changed pci_read_irq_line() (which is the helper I
      would expect most archs to use in their pcibios_fixup() to get the PCI
      interrupt routing from the device tree) to also handle a fallback when the
      DT mapping fails consisting of reading the PCI_INTERRUPT_PIN to know wether
      the device has an interrupt at all, and the the PCI_INTERRUPT_LINE to get an
      interrupt number from the device.  That number is then mapped using the
      default controller, and the trigger is set to level low.  That default
      behaviour works for several platforms that don't have a proper interrupt
      tree like Pegasos.  If it doesn't work for your platform, then either
      provide a proper interrupt tree from the firmware so that fallback isn't
      needed, or don't call pci_read_irq_line()
    
    - Add back a bit that got dropped by my main rework patch for properly
      clearing pending IPIs on pSeries when using a kexec
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 80c0c665b5f6..82657bc86d19 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -330,7 +330,7 @@ static void macio_create_fixup_irq(struct macio_dev *dev, int index,
 {
 	unsigned int irq;
 
-	irq = irq_create_mapping(NULL, line, 0);
+	irq = irq_create_mapping(NULL, line);
 	if (irq != NO_IRQ) {
 		dev->interrupt[index].start = irq;
 		dev->interrupt[index].flags = IORESOURCE_IRQ;

commit 0ebfff1491ef85d41ddf9c633834838be144f69f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 3 21:36:01 2006 +1000

    [POWERPC] Add new interrupt mapping core and change platforms to use it
    
    This adds the new irq remapper core and removes the old one.  Because
    there are some fundamental conflicts with the old code, like the value
    of NO_IRQ which I'm now setting to 0 (as per discussions with Linus),
    etc..., this commit also changes the relevant platform and driver code
    over to use the new remapper (so as not to cause difficulties later
    in bisecting).
    
    This patch removes the old pre-parsing of the open firmware interrupt
    tree along with all the bogus assumptions it made to try to renumber
    interrupts according to the platform. This is all to be handled by the
    new code now.
    
    For the pSeries XICS interrupt controller, a single remapper host is
    created for the whole machine regardless of how many interrupt
    presentation and source controllers are found, and it's set to match
    any device node that isn't a 8259.  That works fine on pSeries and
    avoids having to deal with some of the complexities of split source
    controllers vs. presentation controllers in the pSeries device trees.
    
    The powerpc i8259 PIC driver now always requests the legacy interrupt
    range. It also has the feature of being able to match any device node
    (including NULL) if passed no device node as an input. That will help
    porting over platforms with broken device-trees like Pegasos who don't
    have a proper interrupt tree.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 40ae7b6a939d..80c0c665b5f6 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -280,75 +280,128 @@ static void macio_release_dev(struct device *dev)
 static int macio_resource_quirks(struct device_node *np, struct resource *res,
 				 int index)
 {
-	if (res->flags & IORESOURCE_MEM) {
-		/* Grand Central has too large resource 0 on some machines */
-		if (index == 0 && !strcmp(np->name, "gc"))
-			res->end = res->start + 0x1ffff;
+	/* Only quirks for memory resources for now */
+	if ((res->flags & IORESOURCE_MEM) == 0)
+		return 0;
+
+	/* Grand Central has too large resource 0 on some machines */
+	if (index == 0 && !strcmp(np->name, "gc"))
+		res->end = res->start + 0x1ffff;
 
-		/* Airport has bogus resource 2 */
-		if (index >= 2 && !strcmp(np->name, "radio"))
-			return 1;
+	/* Airport has bogus resource 2 */
+	if (index >= 2 && !strcmp(np->name, "radio"))
+		return 1;
 
 #ifndef CONFIG_PPC64
-		/* DBDMAs may have bogus sizes */
-		if ((res->start & 0x0001f000) == 0x00008000)
-			res->end = res->start + 0xff;
+	/* DBDMAs may have bogus sizes */
+	if ((res->start & 0x0001f000) == 0x00008000)
+		res->end = res->start + 0xff;
 #endif /* CONFIG_PPC64 */
 
-		/* ESCC parent eats child resources. We could have added a
-		 * level of hierarchy, but I don't really feel the need
-		 * for it
-		 */
-		if (!strcmp(np->name, "escc"))
-			return 1;
-
-		/* ESCC has bogus resources >= 3 */
-		if (index >= 3 && !(strcmp(np->name, "ch-a") &&
-				    strcmp(np->name, "ch-b")))
-			return 1;
-
-		/* Media bay has too many resources, keep only first one */
-		if (index > 0 && !strcmp(np->name, "media-bay"))
-			return 1;
-
-		/* Some older IDE resources have bogus sizes */
-		if (!(strcmp(np->name, "IDE") && strcmp(np->name, "ATA") &&
-		      strcmp(np->type, "ide") && strcmp(np->type, "ata"))) {
-			if (index == 0 && (res->end - res->start) > 0xfff)
-				res->end = res->start + 0xfff;
-			if (index == 1 && (res->end - res->start) > 0xff)
-				res->end = res->start + 0xff;
-		}
+	/* ESCC parent eats child resources. We could have added a
+	 * level of hierarchy, but I don't really feel the need
+	 * for it
+	 */
+	if (!strcmp(np->name, "escc"))
+		return 1;
+
+	/* ESCC has bogus resources >= 3 */
+	if (index >= 3 && !(strcmp(np->name, "ch-a") &&
+			    strcmp(np->name, "ch-b")))
+		return 1;
+
+	/* Media bay has too many resources, keep only first one */
+	if (index > 0 && !strcmp(np->name, "media-bay"))
+		return 1;
+
+	/* Some older IDE resources have bogus sizes */
+	if (!(strcmp(np->name, "IDE") && strcmp(np->name, "ATA") &&
+	      strcmp(np->type, "ide") && strcmp(np->type, "ata"))) {
+		if (index == 0 && (res->end - res->start) > 0xfff)
+			res->end = res->start + 0xfff;
+		if (index == 1 && (res->end - res->start) > 0xff)
+			res->end = res->start + 0xff;
 	}
 	return 0;
 }
 
+static void macio_create_fixup_irq(struct macio_dev *dev, int index,
+				   unsigned int line)
+{
+	unsigned int irq;
 
-static void macio_setup_interrupts(struct macio_dev *dev)
+	irq = irq_create_mapping(NULL, line, 0);
+	if (irq != NO_IRQ) {
+		dev->interrupt[index].start = irq;
+		dev->interrupt[index].flags = IORESOURCE_IRQ;
+		dev->interrupt[index].name = dev->ofdev.dev.bus_id;
+	}
+	if (dev->n_interrupts <= index)
+		dev->n_interrupts = index + 1;
+}
+
+static void macio_add_missing_resources(struct macio_dev *dev)
 {
 	struct device_node *np = dev->ofdev.node;
-	int i,j;
+	unsigned int irq_base;
+
+	/* Gatwick has some missing interrupts on child nodes */
+	if (dev->bus->chip->type != macio_gatwick)
+		return;
 
-	/* For now, we use pre-parsed entries in the device-tree for
-	 * interrupt routing and addresses, but we should change that
-	 * to dynamically parsed entries and so get rid of most of the
-	 * clutter in struct device_node
+	/* irq_base is always 64 on gatwick. I have no cleaner way to get
+	 * that value from here at this point
 	 */
-	for (i = j = 0; i < np->n_intrs; i++) {
+	irq_base = 64;
+
+	/* Fix SCC */
+	if (strcmp(np->name, "ch-a") == 0) {
+		macio_create_fixup_irq(dev, 0, 15 + irq_base);
+		macio_create_fixup_irq(dev, 1,  4 + irq_base);
+		macio_create_fixup_irq(dev, 2,  5 + irq_base);
+		printk(KERN_INFO "macio: fixed SCC irqs on gatwick\n");
+	}
+
+	/* Fix media-bay */
+	if (strcmp(np->name, "media-bay") == 0) {
+		macio_create_fixup_irq(dev, 0, 29 + irq_base);
+		printk(KERN_INFO "macio: fixed media-bay irq on gatwick\n");
+	}
+
+	/* Fix left media bay childs */
+	if (dev->media_bay != NULL && strcmp(np->name, "floppy") == 0) {
+		macio_create_fixup_irq(dev, 0, 19 + irq_base);
+		macio_create_fixup_irq(dev, 1,  1 + irq_base);
+		printk(KERN_INFO "macio: fixed left floppy irqs\n");
+	}
+	if (dev->media_bay != NULL && strcasecmp(np->name, "ata4") == 0) {
+		macio_create_fixup_irq(dev, 0, 14 + irq_base);
+		macio_create_fixup_irq(dev, 0,  3 + irq_base);
+		printk(KERN_INFO "macio: fixed left ide irqs\n");
+	}
+}
+
+static void macio_setup_interrupts(struct macio_dev *dev)
+{
+	struct device_node *np = dev->ofdev.node;
+	unsigned int irq;
+	int i = 0, j = 0;
+
+	for (;;) {
 		struct resource *res = &dev->interrupt[j];
 
 		if (j >= MACIO_DEV_COUNT_IRQS)
 			break;
-		res->start = np->intrs[i].line;
-		res->flags = IORESOURCE_IO;
-		if (np->intrs[j].sense)
-			res->flags |= IORESOURCE_IRQ_LOWLEVEL;
-		else
-			res->flags |= IORESOURCE_IRQ_HIGHEDGE;
+		irq = irq_of_parse_and_map(np, i++);
+		if (irq == NO_IRQ)
+			break;
+		res->start = irq;
+		res->flags = IORESOURCE_IRQ;
 		res->name = dev->ofdev.dev.bus_id;
-		if (macio_resource_quirks(np, res, i))
+		if (macio_resource_quirks(np, res, i - 1)) {
 			memset(res, 0, sizeof(struct resource));
-		else
+			continue;
+		} else
 			j++;
 	}
 	dev->n_interrupts = j;
@@ -445,6 +498,7 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 	/* Setup interrupts & resources */
 	macio_setup_interrupts(dev);
 	macio_setup_resources(dev, parent_res);
+	macio_add_missing_resources(dev);
 
 	/* Register with core */
 	if (of_device_register(&dev->ofdev) != 0) {

commit d63fb6c55f5f9eb3032fc5c3ab6eb9a26dd67cdc
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sun Jul 2 11:55:03 2006 +1000

    [PATCH] powermac: Fix some 64b resource damage
    
    The 64 bits resource patches did a bit of damage on PowerMac causing a
    buffer overflow in macio_asic and a warning in a sound driver. The
    former is fixed by reverting the sprintf of the bus_id to %08x as it was
    before. The bus_id used for macio devices is always a 32 bits value
    (macio always sits in 32 bits space) and since it's exposed to userland,
    the format of the string shouldn't be changed like that anyway. The
    second by using the proper type for printk.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index d832e109b1b1..40ae7b6a939d 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -427,10 +427,10 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 
 	/* MacIO itself has a different reg, we use it's PCI base */
 	if (np == chip->of_node) {
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%016llx:%.*s",
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
 			chip->lbus.index,
 #ifdef CONFIG_PCI
-			(unsigned long long)pci_resource_start(chip->lbus.pdev, 0),
+			(unsigned int)pci_resource_start(chip->lbus.pdev, 0),
 #else
 			0, /* NuBus may want to do something better here */
 #endif

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index c687ac703941..d832e109b1b1 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -17,7 +17,6 @@
  *    sub-devices.
  */
  
-#include <linux/config.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>

commit e29419fffceb8ec36def3c922040e1ca7bcd3de5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 15:20:16 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in misc drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 431bd37225a1..c687ac703941 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -428,10 +428,10 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
 
 	/* MacIO itself has a different reg, we use it's PCI base */
 	if (np == chip->of_node) {
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%08lx:%.*s",
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%016llx:%.*s",
 			chip->lbus.index,
 #ifdef CONFIG_PCI
-			pci_resource_start(chip->lbus.pdev, 0),
+			(unsigned long long)pci_resource_start(chip->lbus.pdev, 0),
 #else
 			0, /* NuBus may want to do something better here */
 #endif

commit d56a3e380085bf45cc2adba80c4e6490ba644231
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 21 23:20:28 2006 -0800

    [PATCH] macintosh: tidy-up driver_register() return values
    
    Remove the assumption that driver_register() returns the number of devices
    bound to the driver.  In fact, it returns zero for success or a negative
    error value.
    
    All callers of macio_register_driver() either ignore the return value or
    return it as the return value of a module_init() function.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 69596f6438e9..431bd37225a1 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -550,15 +550,12 @@ static void macio_pci_add_devices(struct macio_chip *chip)
  */
 int macio_register_driver(struct macio_driver *drv)
 {
-	int count = 0;
-
 	/* initialize common driver fields */
 	drv->driver.name = drv->name;
 	drv->driver.bus = &macio_bus_type;
 
 	/* register with core */
-	count = driver_register(&drv->driver);
-	return count ? count : 1;
+	return driver_register(&drv->driver);
 }
 
 /**

commit e61997881e0402aedbfad8696e369568a0583f14
Author: Olaf Hering <olh@suse.de>
Date:   Wed Feb 1 03:05:58 2006 -0800

    [PATCH] MODALIAS= for macio
    
    Prodive a MODALIAS= enviroment variable for devices on the mac-io bus.
    Change the buffer length counter to not waste memory by advancing the
    pointer for the next string too far.  Tested on an ibook1 with modular
    pmac_zilog.
    
    Signed-off-by: Olaf Hering <olh@suse.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index ed6d3174d660..69596f6438e9 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -140,10 +140,9 @@ static int macio_uevent(struct device *dev, char **envp, int num_envp,
 {
 	struct macio_dev * macio_dev;
 	struct of_device * of;
-	char *scratch, *compat;
+	char *scratch, *compat, *compat2;
 	int i = 0;
-	int length = 0;
-	int cplen, seen = 0;
+	int length, cplen, cplen2, seen = 0;
 
 	if (!dev)
 		return -ENODEV;
@@ -153,23 +152,22 @@ static int macio_uevent(struct device *dev, char **envp, int num_envp,
 		return -ENODEV;
 
 	of = &macio_dev->ofdev;
-	scratch = buffer;
 
 	/* stuff we want to pass to /sbin/hotplug */
-	envp[i++] = scratch;
-	length += scnprintf (scratch, buffer_size - length, "OF_NAME=%s",
-	                     of->node->name);
-	if ((buffer_size - length <= 0) || (i >= num_envp))
-		return -ENOMEM;
+	envp[i++] = scratch = buffer;
+	length = scnprintf (scratch, buffer_size, "OF_NAME=%s", of->node->name);
 	++length;
+	buffer_size -= length;
+	if ((buffer_size <= 0) || (i >= num_envp))
+		return -ENOMEM;
 	scratch += length;
 
 	envp[i++] = scratch;
-	length += scnprintf (scratch, buffer_size - length, "OF_TYPE=%s",
-	                     of->node->type);
-	if ((buffer_size - length <= 0) || (i >= num_envp))
-		return -ENOMEM;
+	length = scnprintf (scratch, buffer_size, "OF_TYPE=%s", of->node->type);
 	++length;
+	buffer_size -= length;
+	if ((buffer_size <= 0) || (i >= num_envp))
+		return -ENOMEM;
 	scratch += length;
 
         /* Since the compatible field can contain pretty much anything
@@ -177,29 +175,55 @@ static int macio_uevent(struct device *dev, char **envp, int num_envp,
          * up using a number of environment variables instead. */
 
 	compat = (char *) get_property(of->node, "compatible", &cplen);
+	compat2 = compat;
+	cplen2= cplen;
 	while (compat && cplen > 0) {
-		int l;
                 envp[i++] = scratch;
-		length += scnprintf (scratch, buffer_size - length,
+		length = scnprintf (scratch, buffer_size,
 		                     "OF_COMPATIBLE_%d=%s", seen, compat);
-		if ((buffer_size - length <= 0) || (i >= num_envp))
+		++length;
+		buffer_size -= length;
+		if ((buffer_size <= 0) || (i >= num_envp))
 			return -ENOMEM;
-		length++;
 		scratch += length;
-		l = strlen (compat) + 1;
-		compat += l;
-		cplen -= l;
+		length = strlen (compat) + 1;
+		compat += length;
+		cplen -= length;
 		seen++;
 	}
 
 	envp[i++] = scratch;
-	length += scnprintf (scratch, buffer_size - length,
-	                     "OF_COMPATIBLE_N=%d", seen);
-	if ((buffer_size - length <= 0) || (i >= num_envp))
-		return -ENOMEM;
+	length = scnprintf (scratch, buffer_size, "OF_COMPATIBLE_N=%d", seen);
 	++length;
+	buffer_size -= length;
+	if ((buffer_size <= 0) || (i >= num_envp))
+		return -ENOMEM;
+	scratch += length;
+
+	envp[i++] = scratch;
+	length = scnprintf (scratch, buffer_size, "MODALIAS=of:N%sT%s",
+			of->node->name, of->node->type);
+	/* overwrite '\0' */
+	buffer_size -= length;
+	if ((buffer_size <= 0) || (i >= num_envp))
+		return -ENOMEM;
 	scratch += length;
 
+	if (!compat2) {
+		compat2 = "";
+		cplen2 = 1;
+	}
+	while (cplen2 > 0) {
+		length = snprintf (scratch, buffer_size, "C%s", compat2);
+		buffer_size -= length;
+		if (buffer_size <= 0)
+			return -ENOMEM;
+		scratch += length;
+		length = strlen (compat2) + 1;
+		compat2 += length;
+		cplen2 -= length;
+	}
+
 	envp[i] = NULL;
 
 	return 0;

commit 4866b124a1ded3b94b0cea0bd543f46ffa9a3943
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Thu Jan 5 14:39:24 2006 +0000

    [PATCH] Add macio_bus_type probe and remove methods
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 2a545ceb523b..ed6d3174d660 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -211,6 +211,9 @@ struct bus_type macio_bus_type = {
        .name	= "macio",
        .match	= macio_bus_match,
        .uevent = macio_uevent,
+       .probe	= macio_device_probe,
+       .remove	= macio_device_remove,
+       .shutdown = macio_device_shutdown,
        .suspend	= macio_device_suspend,
        .resume	= macio_device_resume,
        .dev_attrs = macio_dev_attrs,
@@ -528,9 +531,6 @@ int macio_register_driver(struct macio_driver *drv)
 	/* initialize common driver fields */
 	drv->driver.name = drv->name;
 	drv->driver.bus = &macio_bus_type;
-	drv->driver.probe = macio_device_probe;
-	drv->driver.remove = macio_device_remove;
-	drv->driver.shutdown = macio_device_shutdown;
 
 	/* register with core */
 	count = driver_register(&drv->driver);

commit cc5d0189b9ba95260857a5018a1c2fef90008507
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Dec 13 18:01:21 2005 +1100

    [PATCH] powerpc: Remove device_node addrs/n_addr
    
    The pre-parsed addrs/n_addrs fields in struct device_node are finally
    gone. Remove the dodgy heuristics that did that parsing at boot and
    remove the fields themselves since we now have a good replacement with
    the new OF parsing code. This patch also fixes a bunch of drivers to use
    the new code instead, so that at least pmac32, pseries, iseries and g5
    defconfigs build.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 0137ff239f13..2a545ceb523b 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -256,42 +256,42 @@ static int macio_resource_quirks(struct device_node *np, struct resource *res,
 {
 	if (res->flags & IORESOURCE_MEM) {
 		/* Grand Central has too large resource 0 on some machines */
-		if (index == 0 && !strcmp(np->name, "gc")) {
-			np->addrs[0].size = 0x20000;
+		if (index == 0 && !strcmp(np->name, "gc"))
 			res->end = res->start + 0x1ffff;
-		}
+
 		/* Airport has bogus resource 2 */
 		if (index >= 2 && !strcmp(np->name, "radio"))
 			return 1;
+
+#ifndef CONFIG_PPC64
 		/* DBDMAs may have bogus sizes */
-		if ((res->start & 0x0001f000) == 0x00008000) {
-			np->addrs[index].size = 0x100;
+		if ((res->start & 0x0001f000) == 0x00008000)
 			res->end = res->start + 0xff;
-		}
+#endif /* CONFIG_PPC64 */
+
 		/* ESCC parent eats child resources. We could have added a
 		 * level of hierarchy, but I don't really feel the need
 		 * for it
 		 */
 		if (!strcmp(np->name, "escc"))
 			return 1;
+
 		/* ESCC has bogus resources >= 3 */
 		if (index >= 3 && !(strcmp(np->name, "ch-a") &&
 				    strcmp(np->name, "ch-b")))
 			return 1;
+
 		/* Media bay has too many resources, keep only first one */
 		if (index > 0 && !strcmp(np->name, "media-bay"))
 			return 1;
+
 		/* Some older IDE resources have bogus sizes */
 		if (!(strcmp(np->name, "IDE") && strcmp(np->name, "ATA") &&
 		      strcmp(np->type, "ide") && strcmp(np->type, "ata"))) {
-			if (index == 0 && np->addrs[0].size > 0x1000) {
-				np->addrs[0].size = 0x1000;
+			if (index == 0 && (res->end - res->start) > 0xfff)
 				res->end = res->start + 0xfff;
-			}
-			if (index == 1 && np->addrs[1].size > 0x100) {
-				np->addrs[1].size = 0x100;
+			if (index == 1 && (res->end - res->start) > 0xff)
 				res->end = res->start + 0xff;
-			}
 		}
 	}
 	return 0;
@@ -349,7 +349,7 @@ static void macio_setup_resources(struct macio_dev *dev,
 		/* Currently, we consider failure as harmless, this may
 		 * change in the future, once I've found all the device
 		 * tree bugs in older machines & worked around them
-l		 */
+		 */
 		if (insert_resource(parent_res, res)) {
 			printk(KERN_WARNING "Can't request resource "
 			       "%d for MacIO device %s\n",

commit d2dd482bc17c3bc240045f80a7c4b4d5cea5e29c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Nov 30 16:57:28 2005 +1100

    [PATCH] powerpc: Update OF address parsers
    
    This updates the OF address parsers to return the IO flags
    indicating the type of address obtained. It also adds a PCI
    call for converting physical addresses that hit IO space into
    into IO tokens, and add routines that return the translated
    addresses into struct resource
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index f14c744a94ef..0137ff239f13 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -332,18 +332,14 @@ static void macio_setup_resources(struct macio_dev *dev,
 				  struct resource *parent_res)
 {
 	struct device_node *np = dev->ofdev.node;
-	u32 *addr;
-	u64 size;
+	struct resource r;
 	int index;
 
-	for (index = 0; (addr = of_get_address(np, index, &size)) != NULL;
-	     index++) {
+	for (index = 0; of_address_to_resource(np, index, &r) == 0; index++) {
 		struct resource *res = &dev->resource[index];
 		if (index >= MACIO_DEV_COUNT_RESOURCES)
 			break;
-		res->start = of_translate_address(np, addr);
-		res->end = res->start + (unsigned long)size - 1;
-		res->flags = IORESOURCE_MEM;
+		*res = r;
 		res->name = dev->ofdev.dev.bus_id;
 
 		if (macio_resource_quirks(np, res, index)) {
@@ -353,7 +349,7 @@ static void macio_setup_resources(struct macio_dev *dev,
 		/* Currently, we consider failure as harmless, this may
 		 * change in the future, once I've found all the device
 		 * tree bugs in older machines & worked around them
-		 */
+l		 */
 		if (insert_resource(parent_res, res)) {
 			printk(KERN_WARNING "Can't request resource "
 			       "%d for MacIO device %s\n",

commit 2c5bd01f8f5d7c655d9d1aa60b696d980947e3be
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Nov 23 17:59:04 2005 +1100

    [PATCH] powerpc: convert macio_asic to use prom_parse
    
    Converts the macio_asic core to use the new OF parsing routines instead
    of relying on the pre-parsed values in struct device_node.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 228e1852a836..f14c744a94ef 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -3,6 +3,13 @@
  * a MacIO ASIC. Interface to new driver model mostly
  * stolen from the PCI version.
  * 
+ *  Copyright (C) 2005 Ben. Herrenschmidt (benh@kernel.crashing.org)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
  * TODO:
  * 
  *  - Don't probe below media bay by default, but instead provide
@@ -218,12 +225,14 @@ postcore_initcall(macio_bus_driver_init);
 
 
 /**
- * macio_release_dev - free a macio device structure when all users of it are finished.
+ * macio_release_dev - free a macio device structure when all users of it are
+ * finished.
  * @dev: device that's been disconnected
  *
- * Will be called only by the device core when all users of this macio device are
- * done. This currently means never as we don't hot remove any macio device yet,
- * though that will happen with mediabay based devices in a later implementation.
+ * Will be called only by the device core when all users of this macio device
+ * are done. This currently means never as we don't hot remove any macio
+ * device yet, though that will happen with mediabay based devices in a later
+ * implementation.
  */
 static void macio_release_dev(struct device *dev)
 {
@@ -242,7 +251,8 @@ static void macio_release_dev(struct device *dev)
  * If this routine returns non-null, then the resource is completely
  * skipped.
  */
-static int macio_resource_quirks(struct device_node *np, struct resource *res, int index)
+static int macio_resource_quirks(struct device_node *np, struct resource *res,
+				 int index)
 {
 	if (res->flags & IORESOURCE_MEM) {
 		/* Grand Central has too large resource 0 on some machines */
@@ -258,12 +268,15 @@ static int macio_resource_quirks(struct device_node *np, struct resource *res, i
 			np->addrs[index].size = 0x100;
 			res->end = res->start + 0xff;
 		}
-		/* ESCC parent eats child resources. We could have added a level of hierarchy,
-		 * but I don't really feel the need for it */
+		/* ESCC parent eats child resources. We could have added a
+		 * level of hierarchy, but I don't really feel the need
+		 * for it
+		 */
 		if (!strcmp(np->name, "escc"))
 			return 1;
 		/* ESCC has bogus resources >= 3 */
-		if (index >= 3 && !(strcmp(np->name, "ch-a") && strcmp(np->name, "ch-b")))
+		if (index >= 3 && !(strcmp(np->name, "ch-a") &&
+				    strcmp(np->name, "ch-b")))
 			return 1;
 		/* Media bay has too many resources, keep only first one */
 		if (index > 0 && !strcmp(np->name, "media-bay"))
@@ -285,6 +298,71 @@ static int macio_resource_quirks(struct device_node *np, struct resource *res, i
 }
 
 
+static void macio_setup_interrupts(struct macio_dev *dev)
+{
+	struct device_node *np = dev->ofdev.node;
+	int i,j;
+
+	/* For now, we use pre-parsed entries in the device-tree for
+	 * interrupt routing and addresses, but we should change that
+	 * to dynamically parsed entries and so get rid of most of the
+	 * clutter in struct device_node
+	 */
+	for (i = j = 0; i < np->n_intrs; i++) {
+		struct resource *res = &dev->interrupt[j];
+
+		if (j >= MACIO_DEV_COUNT_IRQS)
+			break;
+		res->start = np->intrs[i].line;
+		res->flags = IORESOURCE_IO;
+		if (np->intrs[j].sense)
+			res->flags |= IORESOURCE_IRQ_LOWLEVEL;
+		else
+			res->flags |= IORESOURCE_IRQ_HIGHEDGE;
+		res->name = dev->ofdev.dev.bus_id;
+		if (macio_resource_quirks(np, res, i))
+			memset(res, 0, sizeof(struct resource));
+		else
+			j++;
+	}
+	dev->n_interrupts = j;
+}
+
+static void macio_setup_resources(struct macio_dev *dev,
+				  struct resource *parent_res)
+{
+	struct device_node *np = dev->ofdev.node;
+	u32 *addr;
+	u64 size;
+	int index;
+
+	for (index = 0; (addr = of_get_address(np, index, &size)) != NULL;
+	     index++) {
+		struct resource *res = &dev->resource[index];
+		if (index >= MACIO_DEV_COUNT_RESOURCES)
+			break;
+		res->start = of_translate_address(np, addr);
+		res->end = res->start + (unsigned long)size - 1;
+		res->flags = IORESOURCE_MEM;
+		res->name = dev->ofdev.dev.bus_id;
+
+		if (macio_resource_quirks(np, res, index)) {
+			memset(res, 0, sizeof(struct resource));
+			continue;
+		}
+		/* Currently, we consider failure as harmless, this may
+		 * change in the future, once I've found all the device
+		 * tree bugs in older machines & worked around them
+		 */
+		if (insert_resource(parent_res, res)) {
+			printk(KERN_WARNING "Can't request resource "
+			       "%d for MacIO device %s\n",
+			       index, dev->ofdev.dev.bus_id);
+		}
+	}
+	dev->n_resources = index;
+}
+
 /**
  * macio_add_one_device - Add one device from OF node to the device tree
  * @chip: pointer to the macio_chip holding the device
@@ -294,12 +372,13 @@ static int macio_resource_quirks(struct device_node *np, struct resource *res, i
  * When media-bay is changed to hotswap drivers, this function will
  * be exposed to the bay driver some way...
  */
-static struct macio_dev * macio_add_one_device(struct macio_chip *chip, struct device *parent,
-					       struct device_node *np, struct macio_dev *in_bay,
+static struct macio_dev * macio_add_one_device(struct macio_chip *chip,
+					       struct device *parent,
+					       struct device_node *np,
+					       struct macio_dev *in_bay,
 					       struct resource *parent_res)
 {
 	struct macio_dev *dev;
-	int i, j;
 	u32 *reg;
 	
 	if (np == NULL)
@@ -326,7 +405,8 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip, struct d
 
 	/* MacIO itself has a different reg, we use it's PCI base */
 	if (np == chip->of_node) {
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%08lx:%.*s", chip->lbus.index,
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%08lx:%.*s",
+			chip->lbus.index,
 #ifdef CONFIG_PCI
 			pci_resource_start(chip->lbus.pdev, 0),
 #else
@@ -335,57 +415,16 @@ static struct macio_dev * macio_add_one_device(struct macio_chip *chip, struct d
 			MAX_NODE_NAME_SIZE, np->name);
 	} else {
 		reg = (u32 *)get_property(np, "reg", NULL);
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s", chip->lbus.index,
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s",
+			chip->lbus.index,
 			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);
 	}
 
-	/* For now, we use pre-parsed entries in the device-tree for
-	 * interrupt routing and addresses, but we should change that
-	 * to dynamically parsed entries and so get rid of most of the
-	 * clutter in struct device_node
-	 */
-	for (i = j = 0; i < np->n_intrs; i++) {
-		struct resource *res = &dev->interrupt[j];
-
-		if (j >= MACIO_DEV_COUNT_IRQS)
-			break;
-		res->start = np->intrs[i].line;
-		res->flags = IORESOURCE_IO;
-		if (np->intrs[j].sense)
-			res->flags |= IORESOURCE_IRQ_LOWLEVEL;
-		else
-			res->flags |= IORESOURCE_IRQ_HIGHEDGE;
-		res->name = dev->ofdev.dev.bus_id;
-		if (macio_resource_quirks(np, res, i))
-			memset(res, 0, sizeof(struct resource));
-		else
-			j++;
-	}
-	dev->n_interrupts = j;
-	for (i = j = 0; i < np->n_addrs; i++) {
-		struct resource *res = &dev->resource[j];
-		
-		if (j >= MACIO_DEV_COUNT_RESOURCES)
-			break;
-		res->start = np->addrs[i].address;
-		res->end = np->addrs[i].address + np->addrs[i].size - 1;
-		res->flags = IORESOURCE_MEM;
-		res->name = dev->ofdev.dev.bus_id;
-		if (macio_resource_quirks(np, res, i))
-			memset(res, 0, sizeof(struct resource));
-		else {
-			j++;
-			/* Currently, we consider failure as harmless, this may
-			 * change in the future, once I've found all the device
-			 * tree bugs in older machines & worked around them
-			 */
-			if (insert_resource(parent_res, res))
-       				printk(KERN_WARNING "Can't request resource %d for MacIO"
-				       " device %s\n", i, dev->ofdev.dev.bus_id);
-		}
-	}
-	dev->n_resources = j;
+	/* Setup interrupts & resources */
+	macio_setup_interrupts(dev);
+	macio_setup_resources(dev, parent_res);
 
+	/* Register with core */
 	if (of_device_register(&dev->ofdev) != 0) {
 		printk(KERN_DEBUG"macio: device registration error for %s!\n",
 		       dev->ofdev.dev.bus_id);
@@ -442,36 +481,42 @@ static void macio_pci_add_devices(struct macio_chip *chip)
 
 	/* First scan 1st level */
 	for (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {
-		if (!macio_skip_device(np)) {
-			of_node_get(np);
-			mdev = macio_add_one_device(chip, &rdev->ofdev.dev, np, NULL, root_res);
-			if (mdev == NULL)
-				of_node_put(np);
-			else if (strncmp(np->name, "media-bay", 9) == 0)
-				mbdev = mdev;
-			else if (strncmp(np->name, "escc", 4) == 0)
-				sdev = mdev;
-		}
+		if (macio_skip_device(np))
+			continue;
+		of_node_get(np);
+		mdev = macio_add_one_device(chip, &rdev->ofdev.dev, np, NULL,
+					    root_res);
+		if (mdev == NULL)
+			of_node_put(np);
+		else if (strncmp(np->name, "media-bay", 9) == 0)
+			mbdev = mdev;
+		else if (strncmp(np->name, "escc", 4) == 0)
+			sdev = mdev;
 	}
 
 	/* Add media bay devices if any */
 	if (mbdev)
-		for (np = NULL; (np = of_get_next_child(mbdev->ofdev.node, np)) != NULL;)
-			if (!macio_skip_device(np)) {
-				of_node_get(np);
-				if (macio_add_one_device(chip, &mbdev->ofdev.dev, np, mbdev,
-							 root_res) == NULL)
-					of_node_put(np);
-			}
+		for (np = NULL; (np = of_get_next_child(mbdev->ofdev.node, np))
+			     != NULL;) {
+			if (macio_skip_device(np))
+				continue;
+			of_node_get(np);
+			if (macio_add_one_device(chip, &mbdev->ofdev.dev, np,
+						 mbdev,  root_res) == NULL)
+				of_node_put(np);
+		}
+
 	/* Add serial ports if any */
 	if (sdev) {
-		for (np = NULL; (np = of_get_next_child(sdev->ofdev.node, np)) != NULL;)
-			if (!macio_skip_device(np)) {
-				of_node_get(np);
-				if (macio_add_one_device(chip, &sdev->ofdev.dev, np, NULL,
-							 root_res) == NULL)
-					of_node_put(np);
-			}
+		for (np = NULL; (np = of_get_next_child(sdev->ofdev.node, np))
+			     != NULL;) {
+			if (macio_skip_device(np))
+				continue;
+			of_node_get(np);
+			if (macio_add_one_device(chip, &sdev->ofdev.dev, np,
+						 NULL, root_res) == NULL)
+				of_node_put(np);
+		}
 	}
 }
 
@@ -519,7 +564,8 @@ void macio_unregister_driver(struct macio_driver *drv)
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
  */
-int macio_request_resource(struct macio_dev *dev, int resource_no, const char *name)
+int macio_request_resource(struct macio_dev *dev, int resource_no,
+			   const char *name)
 {
 	if (macio_resource_len(dev, resource_no) == 0)
 		return 0;
@@ -606,20 +652,20 @@ static int __devinit macio_pci_probe(struct pci_dev *pdev, const struct pci_devi
 	if (ent->vendor != PCI_VENDOR_ID_APPLE)
 		return -ENODEV;
 
-	/* Note regarding refcounting: We assume pci_device_to_OF_node() is ported
-	 * to new OF APIs and returns a node with refcount incremented. This isn't
-	 * the case today, but on the other hand ppc32 doesn't do refcounting. This
-	 * will have to be fixed when going to ppc64. --BenH.
+	/* Note regarding refcounting: We assume pci_device_to_OF_node() is
+	 * ported to new OF APIs and returns a node with refcount incremented.
 	 */
 	np = pci_device_to_OF_node(pdev);
 	if (np == NULL)
 		return -ENODEV;
 
-	/* This assumption is wrong, fix that here for now until I fix the arch */
+	/* The above assumption is wrong !!!
+	 * fix that here for now until I fix the arch code
+	 */
 	of_node_get(np);
 
-	/* We also assume that pmac_feature will have done a get() on nodes stored
-	 * in the macio chips array
+	/* We also assume that pmac_feature will have done a get() on nodes
+	 * stored in the macio chips array
 	 */
 	chip = macio_find(np, macio_unknown);
        	of_node_put(np);
@@ -639,9 +685,9 @@ static int __devinit macio_pci_probe(struct pci_dev *pdev, const struct pci_devi
 
 	/*
 	 * HACK ALERT: The WallStreet PowerBook and some OHare based machines
-	 * have 2 macio ASICs. I must probe the "main" one first or IDE ordering
-	 * will be incorrect. So I put on "hold" the second one since it seem to
-	 * appear first on PCI
+	 * have 2 macio ASICs. I must probe the "main" one first or IDE
+	 * ordering will be incorrect. So I put on "hold" the second one since
+	 * it seem to appear first on PCI
 	 */
 	if (chip->type == macio_gatwick || chip->type == macio_ohareII)
 		if (macio_chips[0].lbus.pdev == NULL) {

commit 312c004d36ce6c739512bac83b452f4c20ab1f62
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Wed Nov 16 09:00:00 2005 +0100

    [PATCH] driver core: replace "hotplug" by "uevent"
    
    Leave the overloaded "hotplug" word to susbsystems which are handling
    real devices. The driver core does not "plug" anything, it just exports
    the state to userspace and generates events.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index c34c96d18907..228e1852a836 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -128,7 +128,7 @@ static int macio_device_resume(struct device * dev)
 	return 0;
 }
 
-static int macio_hotplug (struct device *dev, char **envp, int num_envp,
+static int macio_uevent(struct device *dev, char **envp, int num_envp,
                           char *buffer, int buffer_size)
 {
 	struct macio_dev * macio_dev;
@@ -203,7 +203,7 @@ extern struct device_attribute macio_dev_attrs[];
 struct bus_type macio_bus_type = {
        .name	= "macio",
        .match	= macio_bus_match,
-       .hotplug = macio_hotplug,
+       .uevent = macio_uevent,
        .suspend	= macio_device_suspend,
        .resume	= macio_device_resume,
        .dev_attrs = macio_dev_attrs,

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 1ee003346923..c34c96d18907 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -17,6 +17,8 @@
 #include <linux/pci_ids.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+
 #include <asm/machdep.h>
 #include <asm/macio.h>
 #include <asm/pmac_feature.h>

commit 184f6eb8c46afc2a4aa6cb7c51ebc423c36d9c9d
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jul 6 15:45:09 2005 -0400

    [PATCH] openfirmware: implement hotplug for macio devices
    
    This adds the hotplug routine for generating hotplug events when devices
    are seen on the macio bus.  It uses the attributed created by the sysfs
    nodes to generate the hotplug environment vars for userspace.
    
    Since the characters allowed inside the 'compatible' field are NUL
    terminated, they are exported as individual OF_COMPATIBLE_# variables,
    with OF_COMPATIBLE_N maintaining a count of how many there are.
    
    In order for hotplug to work with macio devices, patches to
    module-init-tools and hotplug must be applied.  Those patches are
    available at:
    
    ftp://ftp.suse.com/pub/people/jeffm/linux/macio-hotplug/
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 7fa369cfcceb..1ee003346923 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -126,11 +126,82 @@ static int macio_device_resume(struct device * dev)
 	return 0;
 }
 
+static int macio_hotplug (struct device *dev, char **envp, int num_envp,
+                          char *buffer, int buffer_size)
+{
+	struct macio_dev * macio_dev;
+	struct of_device * of;
+	char *scratch, *compat;
+	int i = 0;
+	int length = 0;
+	int cplen, seen = 0;
+
+	if (!dev)
+		return -ENODEV;
+
+	macio_dev = to_macio_device(dev);
+	if (!macio_dev)
+		return -ENODEV;
+
+	of = &macio_dev->ofdev;
+	scratch = buffer;
+
+	/* stuff we want to pass to /sbin/hotplug */
+	envp[i++] = scratch;
+	length += scnprintf (scratch, buffer_size - length, "OF_NAME=%s",
+	                     of->node->name);
+	if ((buffer_size - length <= 0) || (i >= num_envp))
+		return -ENOMEM;
+	++length;
+	scratch += length;
+
+	envp[i++] = scratch;
+	length += scnprintf (scratch, buffer_size - length, "OF_TYPE=%s",
+	                     of->node->type);
+	if ((buffer_size - length <= 0) || (i >= num_envp))
+		return -ENOMEM;
+	++length;
+	scratch += length;
+
+        /* Since the compatible field can contain pretty much anything
+         * it's not really legal to split it out with commas. We split it
+         * up using a number of environment variables instead. */
+
+	compat = (char *) get_property(of->node, "compatible", &cplen);
+	while (compat && cplen > 0) {
+		int l;
+                envp[i++] = scratch;
+		length += scnprintf (scratch, buffer_size - length,
+		                     "OF_COMPATIBLE_%d=%s", seen, compat);
+		if ((buffer_size - length <= 0) || (i >= num_envp))
+			return -ENOMEM;
+		length++;
+		scratch += length;
+		l = strlen (compat) + 1;
+		compat += l;
+		cplen -= l;
+		seen++;
+	}
+
+	envp[i++] = scratch;
+	length += scnprintf (scratch, buffer_size - length,
+	                     "OF_COMPATIBLE_N=%d", seen);
+	if ((buffer_size - length <= 0) || (i >= num_envp))
+		return -ENOMEM;
+	++length;
+	scratch += length;
+
+	envp[i] = NULL;
+
+	return 0;
+}
+
 extern struct device_attribute macio_dev_attrs[];
 
 struct bus_type macio_bus_type = {
        .name	= "macio",
        .match	= macio_bus_match,
+       .hotplug = macio_hotplug,
        .suspend	= macio_device_suspend,
        .resume	= macio_device_resume,
        .dev_attrs = macio_dev_attrs,

commit b5bf5b6786ccfc9e0c8801291f463d92c8e0b423
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jul 6 15:26:27 2005 -0400

    [PATCH] openfirmware: add sysfs nodes for open firmware devices
    
    This adds sysfs nodes that the hotplug userspace can use to load the
    appropriate modules.
    
    In order for hotplug to work with macio devices, patches to
    module-init-tools and hotplug must be applied.  Those patches are
    available at:
    
     ftp://ftp.suse.com/pub/people/jeffm/linux/macio-hotplug/
    
    Changes: The previous versions were built on 2.6.12. 2.6.13-rcX introduced
             a device_attribute parameter to the show functions. Since that
             parameter was treated as the output buffer, memory corruption would
             result, causing Oopsen very quickly.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 37b18ee08a2d..7fa369cfcceb 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -126,11 +126,14 @@ static int macio_device_resume(struct device * dev)
 	return 0;
 }
 
+extern struct device_attribute macio_dev_attrs[];
+
 struct bus_type macio_bus_type = {
        .name	= "macio",
        .match	= macio_bus_match,
        .suspend	= macio_device_suspend,
        .resume	= macio_device_resume,
+       .dev_attrs = macio_dev_attrs,
 };
 
 static int __init macio_bus_driver_init(void)

commit 5e6557722e69840506eb8bc5a1edcdb4e447a917
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jul 6 15:44:41 2005 -0400

    [PATCH] openfirmware: generate device table for userspace
    
    This converts the usage of struct of_match to struct of_device_id,
    similar to pci_device_id.  This allows a device table to be generated,
    which can be parsed by depmod(8) to generate a map file for module
    loading.
    
    In order for hotplug to work with macio devices, patches to
    module-init-tools and hotplug must be applied.  Those patches are
    available at:
    
     ftp://ftp.suse.com/pub/people/jeffm/linux/macio-hotplug/
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index d0bda7e3e6aa..37b18ee08a2d 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -33,7 +33,7 @@ static int macio_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct macio_dev * macio_dev = to_macio_device(dev);
 	struct macio_driver * macio_drv = to_macio_driver(drv);
-	const struct of_match * matches = macio_drv->match_table;
+	const struct of_device_id * matches = macio_drv->match_table;
 
 	if (!matches) 
 		return 0;
@@ -66,7 +66,7 @@ static int macio_device_probe(struct device *dev)
 	int error = -ENODEV;
 	struct macio_driver *drv;
 	struct macio_dev *macio_dev;
-	const struct of_match *match;
+	const struct of_device_id *match;
 
 	drv = to_macio_driver(dev->driver);
 	macio_dev = to_macio_device(dev);

commit f45139044db870835b53a0fea41da2e04c3958d0
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Apr 16 15:25:32 2005 -0700

    [PATCH] fix u32 vs. pm_message_t in drivers/macintosh
    
    I thought I'm done with fixing u32 vs.  pm_message_t ...  unfortunately that
    turned out not to be the case as Russel King pointed out.  Here are fixes for
    drivers/macintosh.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
index 3a609ecd251b..d0bda7e3e6aa 100644
--- a/drivers/macintosh/macio_asic.c
+++ b/drivers/macintosh/macio_asic.c
@@ -106,7 +106,7 @@ static void macio_device_shutdown(struct device *dev)
 		drv->shutdown(macio_dev);
 }
 
-static int macio_device_suspend(struct device *dev, u32 state)
+static int macio_device_suspend(struct device *dev, pm_message_t state)
 {
 	struct macio_dev * macio_dev = to_macio_device(dev);
 	struct macio_driver * drv = to_macio_driver(dev->driver);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/macintosh/macio_asic.c b/drivers/macintosh/macio_asic.c
new file mode 100644
index 000000000000..3a609ecd251b
--- /dev/null
+++ b/drivers/macintosh/macio_asic.c
@@ -0,0 +1,636 @@
+/*
+ * Bus & driver management routines for devices within
+ * a MacIO ASIC. Interface to new driver model mostly
+ * stolen from the PCI version.
+ * 
+ * TODO:
+ * 
+ *  - Don't probe below media bay by default, but instead provide
+ *    some hooks for media bay to dynamically add/remove it's own
+ *    sub-devices.
+ */
+ 
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/machdep.h>
+#include <asm/macio.h>
+#include <asm/pmac_feature.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+
+#undef DEBUG
+
+#define MAX_NODE_NAME_SIZE (BUS_ID_SIZE - 12)
+
+static struct macio_chip      *macio_on_hold;
+
+static int macio_bus_match(struct device *dev, struct device_driver *drv) 
+{
+	struct macio_dev * macio_dev = to_macio_device(dev);
+	struct macio_driver * macio_drv = to_macio_driver(drv);
+	const struct of_match * matches = macio_drv->match_table;
+
+	if (!matches) 
+		return 0;
+
+	return of_match_device(matches, &macio_dev->ofdev) != NULL;
+}
+
+struct macio_dev *macio_dev_get(struct macio_dev *dev)
+{
+	struct device *tmp;
+
+	if (!dev)
+		return NULL;
+	tmp = get_device(&dev->ofdev.dev);
+	if (tmp)
+		return to_macio_device(tmp);
+	else
+		return NULL;
+}
+
+void macio_dev_put(struct macio_dev *dev)
+{
+	if (dev)
+		put_device(&dev->ofdev.dev);
+}
+
+
+static int macio_device_probe(struct device *dev)
+{
+	int error = -ENODEV;
+	struct macio_driver *drv;
+	struct macio_dev *macio_dev;
+	const struct of_match *match;
+
+	drv = to_macio_driver(dev->driver);
+	macio_dev = to_macio_device(dev);
+
+	if (!drv->probe)
+		return error;
+
+	macio_dev_get(macio_dev);
+
+	match = of_match_device(drv->match_table, &macio_dev->ofdev);
+	if (match)
+		error = drv->probe(macio_dev, match);
+	if (error)
+		macio_dev_put(macio_dev);
+
+	return error;
+}
+
+static int macio_device_remove(struct device *dev)
+{
+	struct macio_dev * macio_dev = to_macio_device(dev);
+	struct macio_driver * drv = to_macio_driver(dev->driver);
+
+	if (dev->driver && drv->remove)
+		drv->remove(macio_dev);
+	macio_dev_put(macio_dev);
+
+	return 0;
+}
+
+static void macio_device_shutdown(struct device *dev)
+{
+	struct macio_dev * macio_dev = to_macio_device(dev);
+	struct macio_driver * drv = to_macio_driver(dev->driver);
+
+	if (dev->driver && drv->shutdown)
+		drv->shutdown(macio_dev);
+}
+
+static int macio_device_suspend(struct device *dev, u32 state)
+{
+	struct macio_dev * macio_dev = to_macio_device(dev);
+	struct macio_driver * drv = to_macio_driver(dev->driver);
+
+	if (dev->driver && drv->suspend)
+		return drv->suspend(macio_dev, state);
+	return 0;
+}
+
+static int macio_device_resume(struct device * dev)
+{
+	struct macio_dev * macio_dev = to_macio_device(dev);
+	struct macio_driver * drv = to_macio_driver(dev->driver);
+
+	if (dev->driver && drv->resume)
+		return drv->resume(macio_dev);
+	return 0;
+}
+
+struct bus_type macio_bus_type = {
+       .name	= "macio",
+       .match	= macio_bus_match,
+       .suspend	= macio_device_suspend,
+       .resume	= macio_device_resume,
+};
+
+static int __init macio_bus_driver_init(void)
+{
+	return bus_register(&macio_bus_type);
+}
+
+postcore_initcall(macio_bus_driver_init);
+
+
+/**
+ * macio_release_dev - free a macio device structure when all users of it are finished.
+ * @dev: device that's been disconnected
+ *
+ * Will be called only by the device core when all users of this macio device are
+ * done. This currently means never as we don't hot remove any macio device yet,
+ * though that will happen with mediabay based devices in a later implementation.
+ */
+static void macio_release_dev(struct device *dev)
+{
+	struct macio_dev *mdev;
+
+        mdev = to_macio_device(dev);
+	kfree(mdev);
+}
+
+/**
+ * macio_resource_quirks - tweak or skip some resources for a device
+ * @np: pointer to the device node
+ * @res: resulting resource
+ * @index: index of resource in node
+ *
+ * If this routine returns non-null, then the resource is completely
+ * skipped.
+ */
+static int macio_resource_quirks(struct device_node *np, struct resource *res, int index)
+{
+	if (res->flags & IORESOURCE_MEM) {
+		/* Grand Central has too large resource 0 on some machines */
+		if (index == 0 && !strcmp(np->name, "gc")) {
+			np->addrs[0].size = 0x20000;
+			res->end = res->start + 0x1ffff;
+		}
+		/* Airport has bogus resource 2 */
+		if (index >= 2 && !strcmp(np->name, "radio"))
+			return 1;
+		/* DBDMAs may have bogus sizes */
+		if ((res->start & 0x0001f000) == 0x00008000) {
+			np->addrs[index].size = 0x100;
+			res->end = res->start + 0xff;
+		}
+		/* ESCC parent eats child resources. We could have added a level of hierarchy,
+		 * but I don't really feel the need for it */
+		if (!strcmp(np->name, "escc"))
+			return 1;
+		/* ESCC has bogus resources >= 3 */
+		if (index >= 3 && !(strcmp(np->name, "ch-a") && strcmp(np->name, "ch-b")))
+			return 1;
+		/* Media bay has too many resources, keep only first one */
+		if (index > 0 && !strcmp(np->name, "media-bay"))
+			return 1;
+		/* Some older IDE resources have bogus sizes */
+		if (!(strcmp(np->name, "IDE") && strcmp(np->name, "ATA") &&
+		      strcmp(np->type, "ide") && strcmp(np->type, "ata"))) {
+			if (index == 0 && np->addrs[0].size > 0x1000) {
+				np->addrs[0].size = 0x1000;
+				res->end = res->start + 0xfff;
+			}
+			if (index == 1 && np->addrs[1].size > 0x100) {
+				np->addrs[1].size = 0x100;
+				res->end = res->start + 0xff;
+			}
+		}
+	}
+	return 0;
+}
+
+
+/**
+ * macio_add_one_device - Add one device from OF node to the device tree
+ * @chip: pointer to the macio_chip holding the device
+ * @np: pointer to the device node in the OF tree
+ * @in_bay: set to 1 if device is part of a media-bay
+ *
+ * When media-bay is changed to hotswap drivers, this function will
+ * be exposed to the bay driver some way...
+ */
+static struct macio_dev * macio_add_one_device(struct macio_chip *chip, struct device *parent,
+					       struct device_node *np, struct macio_dev *in_bay,
+					       struct resource *parent_res)
+{
+	struct macio_dev *dev;
+	int i, j;
+	u32 *reg;
+	
+	if (np == NULL)
+		return NULL;
+
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+	memset(dev, 0, sizeof(*dev));
+
+	dev->bus = &chip->lbus;
+	dev->media_bay = in_bay;
+	dev->ofdev.node = np;
+	dev->ofdev.dma_mask = 0xffffffffUL;
+	dev->ofdev.dev.dma_mask = &dev->ofdev.dma_mask;
+	dev->ofdev.dev.parent = parent;
+	dev->ofdev.dev.bus = &macio_bus_type;
+	dev->ofdev.dev.release = macio_release_dev;
+
+#ifdef DEBUG
+	printk("preparing mdev @%p, ofdev @%p, dev @%p, kobj @%p\n",
+	       dev, &dev->ofdev, &dev->ofdev.dev, &dev->ofdev.dev.kobj);
+#endif
+
+	/* MacIO itself has a different reg, we use it's PCI base */
+	if (np == chip->of_node) {
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%08lx:%.*s", chip->lbus.index,
+#ifdef CONFIG_PCI
+			pci_resource_start(chip->lbus.pdev, 0),
+#else
+			0, /* NuBus may want to do something better here */
+#endif
+			MAX_NODE_NAME_SIZE, np->name);
+	} else {
+		reg = (u32 *)get_property(np, "reg", NULL);
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s", chip->lbus.index,
+			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);
+	}
+
+	/* For now, we use pre-parsed entries in the device-tree for
+	 * interrupt routing and addresses, but we should change that
+	 * to dynamically parsed entries and so get rid of most of the
+	 * clutter in struct device_node
+	 */
+	for (i = j = 0; i < np->n_intrs; i++) {
+		struct resource *res = &dev->interrupt[j];
+
+		if (j >= MACIO_DEV_COUNT_IRQS)
+			break;
+		res->start = np->intrs[i].line;
+		res->flags = IORESOURCE_IO;
+		if (np->intrs[j].sense)
+			res->flags |= IORESOURCE_IRQ_LOWLEVEL;
+		else
+			res->flags |= IORESOURCE_IRQ_HIGHEDGE;
+		res->name = dev->ofdev.dev.bus_id;
+		if (macio_resource_quirks(np, res, i))
+			memset(res, 0, sizeof(struct resource));
+		else
+			j++;
+	}
+	dev->n_interrupts = j;
+	for (i = j = 0; i < np->n_addrs; i++) {
+		struct resource *res = &dev->resource[j];
+		
+		if (j >= MACIO_DEV_COUNT_RESOURCES)
+			break;
+		res->start = np->addrs[i].address;
+		res->end = np->addrs[i].address + np->addrs[i].size - 1;
+		res->flags = IORESOURCE_MEM;
+		res->name = dev->ofdev.dev.bus_id;
+		if (macio_resource_quirks(np, res, i))
+			memset(res, 0, sizeof(struct resource));
+		else {
+			j++;
+			/* Currently, we consider failure as harmless, this may
+			 * change in the future, once I've found all the device
+			 * tree bugs in older machines & worked around them
+			 */
+			if (insert_resource(parent_res, res))
+       				printk(KERN_WARNING "Can't request resource %d for MacIO"
+				       " device %s\n", i, dev->ofdev.dev.bus_id);
+		}
+	}
+	dev->n_resources = j;
+
+	if (of_device_register(&dev->ofdev) != 0) {
+		printk(KERN_DEBUG"macio: device registration error for %s!\n",
+		       dev->ofdev.dev.bus_id);
+		kfree(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+static int macio_skip_device(struct device_node *np)
+{
+	if (strncmp(np->name, "battery", 7) == 0)
+		return 1;
+	if (strncmp(np->name, "escc-legacy", 11) == 0)
+		return 1;
+	return 0;
+}
+
+/**
+ * macio_pci_add_devices - Adds sub-devices of mac-io to the device tree
+ * @chip: pointer to the macio_chip holding the devices
+ * 
+ * This function will do the job of extracting devices from the
+ * Open Firmware device tree, build macio_dev structures and add
+ * them to the Linux device tree.
+ * 
+ * For now, childs of media-bay are added now as well. This will
+ * change rsn though.
+ */
+static void macio_pci_add_devices(struct macio_chip *chip)
+{
+	struct device_node *np, *pnode;
+	struct macio_dev *rdev, *mdev, *mbdev = NULL, *sdev = NULL;
+	struct device *parent = NULL;
+	struct resource *root_res = &iomem_resource;
+	
+	/* Add a node for the macio bus itself */
+#ifdef CONFIG_PCI
+	if (chip->lbus.pdev) {
+		parent = &chip->lbus.pdev->dev;
+		root_res = &chip->lbus.pdev->resource[0];
+	}
+#endif
+	pnode = of_node_get(chip->of_node);
+	if (pnode == NULL)
+		return;
+
+	/* Add macio itself to hierarchy */
+	rdev = macio_add_one_device(chip, parent, pnode, NULL, root_res);
+	if (rdev == NULL)
+		return;
+	root_res = &rdev->resource[0];
+
+	/* First scan 1st level */
+	for (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {
+		if (!macio_skip_device(np)) {
+			of_node_get(np);
+			mdev = macio_add_one_device(chip, &rdev->ofdev.dev, np, NULL, root_res);
+			if (mdev == NULL)
+				of_node_put(np);
+			else if (strncmp(np->name, "media-bay", 9) == 0)
+				mbdev = mdev;
+			else if (strncmp(np->name, "escc", 4) == 0)
+				sdev = mdev;
+		}
+	}
+
+	/* Add media bay devices if any */
+	if (mbdev)
+		for (np = NULL; (np = of_get_next_child(mbdev->ofdev.node, np)) != NULL;)
+			if (!macio_skip_device(np)) {
+				of_node_get(np);
+				if (macio_add_one_device(chip, &mbdev->ofdev.dev, np, mbdev,
+							 root_res) == NULL)
+					of_node_put(np);
+			}
+	/* Add serial ports if any */
+	if (sdev) {
+		for (np = NULL; (np = of_get_next_child(sdev->ofdev.node, np)) != NULL;)
+			if (!macio_skip_device(np)) {
+				of_node_get(np);
+				if (macio_add_one_device(chip, &sdev->ofdev.dev, np, NULL,
+							 root_res) == NULL)
+					of_node_put(np);
+			}
+	}
+}
+
+
+/**
+ * macio_register_driver - Registers a new MacIO device driver
+ * @drv: pointer to the driver definition structure
+ */
+int macio_register_driver(struct macio_driver *drv)
+{
+	int count = 0;
+
+	/* initialize common driver fields */
+	drv->driver.name = drv->name;
+	drv->driver.bus = &macio_bus_type;
+	drv->driver.probe = macio_device_probe;
+	drv->driver.remove = macio_device_remove;
+	drv->driver.shutdown = macio_device_shutdown;
+
+	/* register with core */
+	count = driver_register(&drv->driver);
+	return count ? count : 1;
+}
+
+/**
+ * macio_unregister_driver - Unregisters a new MacIO device driver
+ * @drv: pointer to the driver definition structure
+ */
+void macio_unregister_driver(struct macio_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+
+/**
+ *	macio_request_resource - Request an MMIO resource
+ * 	@dev: pointer to the device holding the resource
+ *	@resource_no: resource number to request
+ *	@name: resource name
+ *
+ *	Mark  memory region number @resource_no associated with MacIO
+ *	device @dev as being reserved by owner @name.  Do not access
+ *	any address inside the memory regions unless this call returns
+ *	successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int macio_request_resource(struct macio_dev *dev, int resource_no, const char *name)
+{
+	if (macio_resource_len(dev, resource_no) == 0)
+		return 0;
+		
+	if (!request_mem_region(macio_resource_start(dev, resource_no),
+				macio_resource_len(dev, resource_no),
+				name))
+		goto err_out;
+	
+	return 0;
+
+err_out:
+	printk (KERN_WARNING "MacIO: Unable to reserve resource #%d:%lx@%lx"
+		" for device %s\n",
+		resource_no,
+		macio_resource_len(dev, resource_no),
+		macio_resource_start(dev, resource_no),
+		dev->ofdev.dev.bus_id);
+	return -EBUSY;
+}
+
+/**
+ * macio_release_resource - Release an MMIO resource
+ * @dev: pointer to the device holding the resource
+ * @resource_no: resource number to release
+ */
+void macio_release_resource(struct macio_dev *dev, int resource_no)
+{
+	if (macio_resource_len(dev, resource_no) == 0)
+		return;
+	release_mem_region(macio_resource_start(dev, resource_no),
+			   macio_resource_len(dev, resource_no));
+}
+
+/**
+ *	macio_request_resources - Reserve all memory resources
+ *	@dev: MacIO device whose resources are to be reserved
+ *	@name: Name to be associated with resource.
+ *
+ *	Mark all memory regions associated with MacIO device @dev as
+ *	being reserved by owner @name.  Do not access any address inside
+ *	the memory regions unless this call returns successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int macio_request_resources(struct macio_dev *dev, const char *name)
+{
+	int i;
+	
+	for (i = 0; i < dev->n_resources; i++)
+		if (macio_request_resource(dev, i, name))
+			goto err_out;
+	return 0;
+
+err_out:
+	while(--i >= 0)
+		macio_release_resource(dev, i);
+		
+	return -EBUSY;
+}
+
+/**
+ *	macio_release_resources - Release reserved memory resources
+ *	@dev: MacIO device whose resources were previously reserved
+ */
+
+void macio_release_resources(struct macio_dev *dev)
+{
+	int i;
+	
+	for (i = 0; i < dev->n_resources; i++)
+		macio_release_resource(dev, i);
+}
+
+
+#ifdef CONFIG_PCI
+
+static int __devinit macio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct device_node* np;
+	struct macio_chip* chip;
+	
+	if (ent->vendor != PCI_VENDOR_ID_APPLE)
+		return -ENODEV;
+
+	/* Note regarding refcounting: We assume pci_device_to_OF_node() is ported
+	 * to new OF APIs and returns a node with refcount incremented. This isn't
+	 * the case today, but on the other hand ppc32 doesn't do refcounting. This
+	 * will have to be fixed when going to ppc64. --BenH.
+	 */
+	np = pci_device_to_OF_node(pdev);
+	if (np == NULL)
+		return -ENODEV;
+
+	/* This assumption is wrong, fix that here for now until I fix the arch */
+	of_node_get(np);
+
+	/* We also assume that pmac_feature will have done a get() on nodes stored
+	 * in the macio chips array
+	 */
+	chip = macio_find(np, macio_unknown);
+       	of_node_put(np);
+	if (chip == NULL)
+		return -ENODEV;
+
+	/* XXX Need locking ??? */
+	if (chip->lbus.pdev == NULL) {
+		chip->lbus.pdev = pdev;
+		chip->lbus.chip = chip;
+		pci_set_drvdata(pdev, &chip->lbus);
+		pci_set_master(pdev);
+	}
+
+	printk(KERN_INFO "MacIO PCI driver attached to %s chipset\n",
+		chip->name);
+
+	/*
+	 * HACK ALERT: The WallStreet PowerBook and some OHare based machines
+	 * have 2 macio ASICs. I must probe the "main" one first or IDE ordering
+	 * will be incorrect. So I put on "hold" the second one since it seem to
+	 * appear first on PCI
+	 */
+	if (chip->type == macio_gatwick || chip->type == macio_ohareII)
+		if (macio_chips[0].lbus.pdev == NULL) {
+			macio_on_hold = chip;
+			return 0;
+		}
+
+	macio_pci_add_devices(chip);
+	if (macio_on_hold && macio_chips[0].lbus.pdev != NULL) {
+		macio_pci_add_devices(macio_on_hold);
+		macio_on_hold = NULL;
+	}
+
+	return 0;
+}
+
+static void __devexit macio_pci_remove(struct pci_dev* pdev)
+{
+	panic("removing of macio-asic not supported !\n");
+}
+
+/*
+ * MacIO is matched against any Apple ID, it's probe() function
+ * will then decide wether it applies or not
+ */
+static const struct pci_device_id __devinitdata pci_ids [] = { {
+	.vendor		= PCI_VENDOR_ID_APPLE,
+	.device		= PCI_ANY_ID,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+
+	}, { /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE (pci, pci_ids);
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver macio_pci_driver = {
+	.name		= (char *) "macio",
+	.id_table	= pci_ids,
+
+	.probe		= macio_pci_probe,
+	.remove		= macio_pci_remove,
+};
+
+#endif /* CONFIG_PCI */
+
+static int __init macio_module_init (void) 
+{
+#ifdef CONFIG_PCI
+	int rc;
+
+	rc = pci_register_driver(&macio_pci_driver);
+	if (rc)
+		return rc;
+#endif /* CONFIG_PCI */
+	return 0;
+}
+
+module_init(macio_module_init);
+
+EXPORT_SYMBOL(macio_register_driver);
+EXPORT_SYMBOL(macio_unregister_driver);
+EXPORT_SYMBOL(macio_dev_get);
+EXPORT_SYMBOL(macio_dev_put);
+EXPORT_SYMBOL(macio_request_resource);
+EXPORT_SYMBOL(macio_release_resource);
+EXPORT_SYMBOL(macio_request_resources);
+EXPORT_SYMBOL(macio_release_resources);
