commit dae5f0afcfc35ff64dfb65cddc6842ceeeca68c4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 25 09:08:48 2018 +0200

    gpio: Use SPDX header for core library
    
    Use the SPDX headers and cut down on boilerplate to indicate the
    license in the core gpiolib implementation.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index 8b830996fe02..30e2476a6dc4 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/gpio/consumer.h>
 #include <linux/gpio/driver.h>
 

commit 85b03b3033fd4eba82665b3b9902c095a08cc52f
Author: Johan Hovold <johan@kernel.org>
Date:   Sun Jul 3 18:32:05 2016 +0200

    Revert "gpiolib: Split GPIO flags parsing and GPIO configuration"
    
    This reverts commit 923b93e451db876d1479d3e4458fce14fec31d1c.
    
    Make sure consumers do not overwrite gpio flags for pins that have
    already been claimed.
    
    While adding support for gpio drivers to refuse a request using
    unsupported flags, the order of when the requested flag was checked and
    the new flags were applied was reversed to that consumers could
    overwrite flags for already requested gpios.
    
    This not only affects device-tree setups where two drivers could request
    the same gpio using conflicting configurations, but also allowed user
    space to clear gpio flags for already claimed pins simply by attempting
    to export them through the sysfs interface. By for example clearing the
    FLAG_ACTIVE_LOW flag this way, user space could effectively change the
    polarity of a signal.
    
    Reverting this change obviously prevents gpio drivers from doing sanity
    checks on the flags in their request callbacks. Fortunately only one
    recently added driver (gpio-tps65218 in v4.6) appears to do this, and a
    follow up patch could restore this functionality through a different
    interface.
    
    Cc: stable <stable@vger.kernel.org>     # 4.4
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index 3a5c7011ad3b..8b830996fe02 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -28,6 +28,10 @@ int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 	if (!desc && gpio_is_valid(gpio))
 		return -EPROBE_DEFER;
 
+	err = gpiod_request(desc, label);
+	if (err)
+		return err;
+
 	if (flags & GPIOF_OPEN_DRAIN)
 		set_bit(FLAG_OPEN_DRAIN, &desc->flags);
 
@@ -37,10 +41,6 @@ int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 	if (flags & GPIOF_ACTIVE_LOW)
 		set_bit(FLAG_ACTIVE_LOW, &desc->flags);
 
-	err = gpiod_request(desc, label);
-	if (err)
-		return err;
-
 	if (flags & GPIOF_DIR_IN)
 		err = gpiod_direction_input(desc);
 	else

commit 923b93e451db876d1479d3e4458fce14fec31d1c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Oct 13 00:20:20 2015 +0300

    gpiolib: Split GPIO flags parsing and GPIO configuration
    
    When requesting a GPIO through the legacy or the gpiod_* API the
    gpiochip request operation is first called and then the GPIO flags are
    parsed and the GPIO is configured. This prevents the gpiochip from
    rejecting the request if the flags are not supported by the device.
    
    To fix this split the parse-and-configure operation in two and parse
    flags before requesting the GPIO.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index 8b830996fe02..3a5c7011ad3b 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -28,10 +28,6 @@ int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 	if (!desc && gpio_is_valid(gpio))
 		return -EPROBE_DEFER;
 
-	err = gpiod_request(desc, label);
-	if (err)
-		return err;
-
 	if (flags & GPIOF_OPEN_DRAIN)
 		set_bit(FLAG_OPEN_DRAIN, &desc->flags);
 
@@ -41,6 +37,10 @@ int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 	if (flags & GPIOF_ACTIVE_LOW)
 		set_bit(FLAG_ACTIVE_LOW, &desc->flags);
 
+	err = gpiod_request(desc, label);
+	if (err)
+		return err;
+
 	if (flags & GPIOF_DIR_IN)
 		err = gpiod_direction_input(desc);
 	else

commit 0e9a5edf5d01356fa4a561772a25d97b3fd13de6
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Dec 2 23:15:05 2014 +0900

    gpio: fix deferred probe detection for legacy API
    
    Commit 14e85c0e69d5 ("gpio: remove gpio_descs global array") changed
    gpio_to_desc()'s behavior to return NULL not only for GPIOs numbers
    not in the valid range, but also for all GPIOs whose controller has not
    been probed yet. Although this behavior is more correct (nothing hints
    that these GPIO numbers will be populated later), this affects
    gpio_request() and gpio_request_one() which call gpiod_request() with a
    NULL descriptor, causing it to return -EINVAL instead of the expected
    -EPROBE_DEFER for a non-probed GPIO.
    
    gpiod_request() is only called with a descriptor obtained from
    gpio_to_desc() from these two functions, so address the issue there.
    
    Other ways to obtain GPIOs rely on well-defined mappings and can thus
    return -EPROBE_DEFER only for relevant GPIOs, and are thus not affected
    by this issue.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index 078ae6c2df79..8b830996fe02 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -24,6 +24,10 @@ int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 
 	desc = gpio_to_desc(gpio);
 
+	/* Compatibility: assume unavailable "valid" GPIOs will appear later */
+	if (!desc && gpio_is_valid(gpio))
+		return -EPROBE_DEFER;
+
 	err = gpiod_request(desc, label);
 	if (err)
 		return err;
@@ -62,7 +66,13 @@ EXPORT_SYMBOL_GPL(gpio_request_one);
 
 int gpio_request(unsigned gpio, const char *label)
 {
-	return gpiod_request(gpio_to_desc(gpio), label);
+	struct gpio_desc *desc = gpio_to_desc(gpio);
+
+	/* Compatibility: assume unavailable "valid" GPIOs will appear later */
+	if (!desc && gpio_is_valid(gpio))
+		return -EPROBE_DEFER;
+
+	return gpiod_request(desc, label);
 }
 EXPORT_SYMBOL_GPL(gpio_request);
 

commit c7caf86823c71fae652cc50c7d8dd0d2b5c41229
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Jul 24 14:51:02 2014 +0900

    gpio: remove gpio_ensure_requested()
    
    gpio_ensure_requested() has been introduced in Feb. 2008 by commit
    d2876d08d86f2 to force users of the GPIO API to explicitly request GPIOs
    before using them.
    
    Hopefully by now all GPIOs are correctly requested and this extra check
    can be omitted ; in any case the GPIO maintainers won't feel bad if
    machines start failing after 6 years of warnings.
    
    This patch removes that function from the dark ages.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index 0f9429b2522a..078ae6c2df79 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -5,64 +5,6 @@
 
 #include "gpiolib.h"
 
-/* Warn when drivers omit gpio_request() calls -- legal but ill-advised
- * when setting direction, and otherwise illegal.  Until board setup code
- * and drivers use explicit requests everywhere (which won't happen when
- * those calls have no teeth) we can't avoid autorequesting.  This nag
- * message should motivate switching to explicit requests... so should
- * the weaker cleanup after faults, compared to gpio_request().
- *
- * NOTE: the autorequest mechanism is going away; at this point it's
- * only "legal" in the sense that (old) code using it won't break yet,
- * but instead only triggers a WARN() stack dump.
- */
-static int gpio_ensure_requested(struct gpio_desc *desc)
-{
-	struct gpio_chip *chip = desc->chip;
-	unsigned long flags;
-	bool request = false;
-	int err = 0;
-
-	spin_lock_irqsave(&gpio_lock, flags);
-
-	if (WARN(test_and_set_bit(FLAG_REQUESTED, &desc->flags) == 0,
-			"autorequest GPIO-%d\n", desc_to_gpio(desc))) {
-		if (!try_module_get(chip->owner)) {
-			gpiod_err(desc, "%s: module can't be gotten\n",
-					__func__);
-			clear_bit(FLAG_REQUESTED, &desc->flags);
-			/* lose */
-			err = -EIO;
-			goto end;
-		}
-		desc->label = "[auto]";
-		/* caller must chip->request() w/o spinlock */
-		if (chip->request)
-			request = true;
-	}
-
-end:
-	spin_unlock_irqrestore(&gpio_lock, flags);
-
-	if (request) {
-		might_sleep_if(chip->can_sleep);
-		err = chip->request(chip, gpio_chip_hwgpio(desc));
-
-		if (err < 0) {
-			gpiod_dbg(desc, "%s: chip request fail, %d\n",
-					__func__, err);
-			spin_lock_irqsave(&gpio_lock, flags);
-
-			desc->label = NULL;
-			clear_bit(FLAG_REQUESTED, &desc->flags);
-
-			spin_unlock_irqrestore(&gpio_lock, flags);
-		}
-	}
-
-	return err;
-}
-
 void gpio_free(unsigned gpio)
 {
 	gpiod_free(gpio_to_desc(gpio));
@@ -158,51 +100,3 @@ void gpio_free_array(const struct gpio *array, size_t num)
 		gpio_free((array++)->gpio);
 }
 EXPORT_SYMBOL_GPL(gpio_free_array);
-
-int gpio_direction_input(unsigned gpio)
-{
-	struct gpio_desc *desc = gpio_to_desc(gpio);
-	int err;
-
-	if (!desc)
-		return -EINVAL;
-
-	err = gpio_ensure_requested(desc);
-	if (err < 0)
-		return err;
-
-	return gpiod_direction_input(desc);
-}
-EXPORT_SYMBOL_GPL(gpio_direction_input);
-
-int gpio_direction_output(unsigned gpio, int value)
-{
-	struct gpio_desc *desc = gpio_to_desc(gpio);
-	int err;
-
-	if (!desc)
-		return -EINVAL;
-
-	err = gpio_ensure_requested(desc);
-	if (err < 0)
-		return err;
-
-	return gpiod_direction_output_raw(desc, value);
-}
-EXPORT_SYMBOL_GPL(gpio_direction_output);
-
-int gpio_set_debounce(unsigned gpio, unsigned debounce)
-{
-	struct gpio_desc *desc = gpio_to_desc(gpio);
-	int err;
-
-	if (!desc)
-		return -EINVAL;
-
-	err = gpio_ensure_requested(desc);
-	if (err < 0)
-		return err;
-
-	return gpiod_set_debounce(desc, debounce);
-}
-EXPORT_SYMBOL_GPL(gpio_set_debounce);

commit d82da79722400c63cc70f4c9c2493e31561ea607
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Jul 22 16:17:43 2014 +0900

    gpio: move gpio_ensure_requested() into legacy C file
    
    gpio_ensure_requested() only makes sense when using the integer-based
    GPIO API, so make sure it is called from there instead of the gpiod
    API which we know cannot be called with a non-requested GPIO anyway.
    
    The uses of gpio_ensure_requested() in the gpiod API were kind of
    out-of-place anyway, so putting them in gpio-legacy.c helps clearing the
    code.
    
    Actually, considering the time this ensure_requested mechanism has been
    around, maybe we should just turn this patch into "remove
    gpio_ensure_requested()" if we know for sure that no user depend on it
    anymore?
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index 078ae6c2df79..0f9429b2522a 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -5,6 +5,64 @@
 
 #include "gpiolib.h"
 
+/* Warn when drivers omit gpio_request() calls -- legal but ill-advised
+ * when setting direction, and otherwise illegal.  Until board setup code
+ * and drivers use explicit requests everywhere (which won't happen when
+ * those calls have no teeth) we can't avoid autorequesting.  This nag
+ * message should motivate switching to explicit requests... so should
+ * the weaker cleanup after faults, compared to gpio_request().
+ *
+ * NOTE: the autorequest mechanism is going away; at this point it's
+ * only "legal" in the sense that (old) code using it won't break yet,
+ * but instead only triggers a WARN() stack dump.
+ */
+static int gpio_ensure_requested(struct gpio_desc *desc)
+{
+	struct gpio_chip *chip = desc->chip;
+	unsigned long flags;
+	bool request = false;
+	int err = 0;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	if (WARN(test_and_set_bit(FLAG_REQUESTED, &desc->flags) == 0,
+			"autorequest GPIO-%d\n", desc_to_gpio(desc))) {
+		if (!try_module_get(chip->owner)) {
+			gpiod_err(desc, "%s: module can't be gotten\n",
+					__func__);
+			clear_bit(FLAG_REQUESTED, &desc->flags);
+			/* lose */
+			err = -EIO;
+			goto end;
+		}
+		desc->label = "[auto]";
+		/* caller must chip->request() w/o spinlock */
+		if (chip->request)
+			request = true;
+	}
+
+end:
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	if (request) {
+		might_sleep_if(chip->can_sleep);
+		err = chip->request(chip, gpio_chip_hwgpio(desc));
+
+		if (err < 0) {
+			gpiod_dbg(desc, "%s: chip request fail, %d\n",
+					__func__, err);
+			spin_lock_irqsave(&gpio_lock, flags);
+
+			desc->label = NULL;
+			clear_bit(FLAG_REQUESTED, &desc->flags);
+
+			spin_unlock_irqrestore(&gpio_lock, flags);
+		}
+	}
+
+	return err;
+}
+
 void gpio_free(unsigned gpio)
 {
 	gpiod_free(gpio_to_desc(gpio));
@@ -100,3 +158,51 @@ void gpio_free_array(const struct gpio *array, size_t num)
 		gpio_free((array++)->gpio);
 }
 EXPORT_SYMBOL_GPL(gpio_free_array);
+
+int gpio_direction_input(unsigned gpio)
+{
+	struct gpio_desc *desc = gpio_to_desc(gpio);
+	int err;
+
+	if (!desc)
+		return -EINVAL;
+
+	err = gpio_ensure_requested(desc);
+	if (err < 0)
+		return err;
+
+	return gpiod_direction_input(desc);
+}
+EXPORT_SYMBOL_GPL(gpio_direction_input);
+
+int gpio_direction_output(unsigned gpio, int value)
+{
+	struct gpio_desc *desc = gpio_to_desc(gpio);
+	int err;
+
+	if (!desc)
+		return -EINVAL;
+
+	err = gpio_ensure_requested(desc);
+	if (err < 0)
+		return err;
+
+	return gpiod_direction_output_raw(desc, value);
+}
+EXPORT_SYMBOL_GPL(gpio_direction_output);
+
+int gpio_set_debounce(unsigned gpio, unsigned debounce)
+{
+	struct gpio_desc *desc = gpio_to_desc(gpio);
+	int err;
+
+	if (!desc)
+		return -EINVAL;
+
+	err = gpio_ensure_requested(desc);
+	if (err < 0)
+		return err;
+
+	return gpiod_set_debounce(desc, debounce);
+}
+EXPORT_SYMBOL_GPL(gpio_set_debounce);

commit d74be6dfea1b96cfb4bd79d9254fa9d21ed5f131
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Jul 22 16:17:42 2014 +0900

    gpio: remove gpiod_lock/unlock_as_irq()
    
    gpio_lock/unlock_as_irq() are working with (chip, offset) arguments and
    are thus not using the old integer namespace. Therefore, there is no
    reason to have gpiod variants of these functions working with
    descriptors, especially since the (chip, offset) tuple is more suitable
    to the users of these functions (GPIO drivers, whereas GPIO descriptors
    are targeted at GPIO consumers).
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index c684d94cdbb4..078ae6c2df79 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -100,15 +100,3 @@ void gpio_free_array(const struct gpio *array, size_t num)
 		gpio_free((array++)->gpio);
 }
 EXPORT_SYMBOL_GPL(gpio_free_array);
-
-int gpio_lock_as_irq(struct gpio_chip *chip, unsigned int offset)
-{
-	return gpiod_lock_as_irq(gpiochip_get_desc(chip, offset));
-}
-EXPORT_SYMBOL_GPL(gpio_lock_as_irq);
-
-void gpio_unlock_as_irq(struct gpio_chip *chip, unsigned int offset)
-{
-	return gpiod_unlock_as_irq(gpiochip_get_desc(chip, offset));
-}
-EXPORT_SYMBOL_GPL(gpio_unlock_as_irq);

commit 2be001739242fac1083f3b21898158492844699d
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Jul 21 11:12:16 2014 -0700

    gpio: Add support for GPIOF_ACTIVE_LOW to gpio_request_one functions
    
    The gpio include file and the gpio documentation declare and document
    GPIOF_ACTIVE_LOW as one of the flags to be passed to gpio_request_one
    and related functions. However, the flag is not evaluated or used.
    
    This can cause problems in at least two areas: First, the same API can
    be used to auto-export pins to user space. The missing support for
    GPIOF_ACTIVE_LOW results in unexpected behavior for such auto-exported
    pins. Second, the requested gpio pin can be convered for use by
    gpiod functions with gpio_to_desc(). While gpio API functions do not
    support GPIOF_ACTIVE_LOW, gpiod functions do, which again results in
    unexpected behavior.
    
    Check the flag in gpio_request_one and set the gpio internal flag
    FLAG_ACTIVE_LOW if it is set to address those problems.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index eb5a4e2cee85..c684d94cdbb4 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -34,6 +34,9 @@ int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 	if (flags & GPIOF_OPEN_SOURCE)
 		set_bit(FLAG_OPEN_SOURCE, &desc->flags);
 
+	if (flags & GPIOF_ACTIVE_LOW)
+		set_bit(FLAG_ACTIVE_LOW, &desc->flags);
+
 	if (flags & GPIOF_DIR_IN)
 		err = gpiod_direction_input(desc);
 	else

commit 122c94dec7f6909ff6999f6207b124e6db5d2ba8
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Jul 1 14:45:16 2014 +0900

    gpio: move integer GPIO support to its own file
    
    The old integer GPIO interface is, in effect, a privileged user of the
    gpiod interface. Reflect this fact further by moving legacy GPIO support
    into its own source file. This makes the code clearer and will allow us
    to disable legacy GPIO support in the (far) future.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
new file mode 100644
index 000000000000..eb5a4e2cee85
--- /dev/null
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -0,0 +1,111 @@
+#include <linux/gpio/consumer.h>
+#include <linux/gpio/driver.h>
+
+#include <linux/gpio.h>
+
+#include "gpiolib.h"
+
+void gpio_free(unsigned gpio)
+{
+	gpiod_free(gpio_to_desc(gpio));
+}
+EXPORT_SYMBOL_GPL(gpio_free);
+
+/**
+ * gpio_request_one - request a single GPIO with initial configuration
+ * @gpio:	the GPIO number
+ * @flags:	GPIO configuration as specified by GPIOF_*
+ * @label:	a literal description string of this GPIO
+ */
+int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
+{
+	struct gpio_desc *desc;
+	int err;
+
+	desc = gpio_to_desc(gpio);
+
+	err = gpiod_request(desc, label);
+	if (err)
+		return err;
+
+	if (flags & GPIOF_OPEN_DRAIN)
+		set_bit(FLAG_OPEN_DRAIN, &desc->flags);
+
+	if (flags & GPIOF_OPEN_SOURCE)
+		set_bit(FLAG_OPEN_SOURCE, &desc->flags);
+
+	if (flags & GPIOF_DIR_IN)
+		err = gpiod_direction_input(desc);
+	else
+		err = gpiod_direction_output_raw(desc,
+				(flags & GPIOF_INIT_HIGH) ? 1 : 0);
+
+	if (err)
+		goto free_gpio;
+
+	if (flags & GPIOF_EXPORT) {
+		err = gpiod_export(desc, flags & GPIOF_EXPORT_CHANGEABLE);
+		if (err)
+			goto free_gpio;
+	}
+
+	return 0;
+
+ free_gpio:
+	gpiod_free(desc);
+	return err;
+}
+EXPORT_SYMBOL_GPL(gpio_request_one);
+
+int gpio_request(unsigned gpio, const char *label)
+{
+	return gpiod_request(gpio_to_desc(gpio), label);
+}
+EXPORT_SYMBOL_GPL(gpio_request);
+
+/**
+ * gpio_request_array - request multiple GPIOs in a single call
+ * @array:	array of the 'struct gpio'
+ * @num:	how many GPIOs in the array
+ */
+int gpio_request_array(const struct gpio *array, size_t num)
+{
+	int i, err;
+
+	for (i = 0; i < num; i++, array++) {
+		err = gpio_request_one(array->gpio, array->flags, array->label);
+		if (err)
+			goto err_free;
+	}
+	return 0;
+
+err_free:
+	while (i--)
+		gpio_free((--array)->gpio);
+	return err;
+}
+EXPORT_SYMBOL_GPL(gpio_request_array);
+
+/**
+ * gpio_free_array - release multiple GPIOs in a single call
+ * @array:	array of the 'struct gpio'
+ * @num:	how many GPIOs in the array
+ */
+void gpio_free_array(const struct gpio *array, size_t num)
+{
+	while (num--)
+		gpio_free((array++)->gpio);
+}
+EXPORT_SYMBOL_GPL(gpio_free_array);
+
+int gpio_lock_as_irq(struct gpio_chip *chip, unsigned int offset)
+{
+	return gpiod_lock_as_irq(gpiochip_get_desc(chip, offset));
+}
+EXPORT_SYMBOL_GPL(gpio_lock_as_irq);
+
+void gpio_unlock_as_irq(struct gpio_chip *chip, unsigned int offset)
+{
+	return gpiod_unlock_as_irq(gpiochip_get_desc(chip, offset));
+}
+EXPORT_SYMBOL_GPL(gpio_unlock_as_irq);
