commit 8f710b5f8905a2662ed8384159ebc4769fe4e108
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Nov 6 14:11:42 2018 +0200

    gpio: msic: Convert to use SPDX identifier
    
    Reduce size of duplicated comments by switching to use SPDX identifier.
    
    No functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 4464a2f067ff..7e3c96e4ab2c 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Intel Medfield MSIC GPIO driver>
  * Copyright (c) 2011, Intel Corporation.
  *
  * Author: Mathias Nyman <mathias.nyman@linux.intel.com>
  * Based on intel_pmic_gpio.c
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
  */
 
 #include <linux/gpio/driver.h>

commit 2456c8b82428a366f8658a13f4befa7ecebdecc9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 4 14:26:25 2018 +0300

    gpio: msic: Sort headers alphabetically
    
    Sort header block alphabetically for easy maintenance.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 138569f8f16e..4464a2f067ff 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -20,13 +20,13 @@
  *
  */
 
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
 #include <linux/gpio/driver.h>
-#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
 #include <linux/mfd/intel_msic.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
 
 /* the offset for the mapping of global gpio pin to irq */
 #define MSIC_GPIO_IRQ_OFFSET	0x100

commit 1147575447f988e605c182fa940b1cc4d8c59dce
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 29 21:01:30 2019 +0200

    gpio: msic: Remove duplicate check in IRQ handler
    
    There is no need to check for non-zero pending since for_each_set_bit() does it
    on the first iteration.
    
    While here, drop redundant assignment.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 3b34dbecef99..138569f8f16e 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -237,20 +237,17 @@ static void msic_gpio_irq_handler(struct irq_desc *desc)
 	struct msic_gpio *mg = irq_data_get_irq_handler_data(data);
 	struct irq_chip *chip = irq_data_get_irq_chip(data);
 	struct intel_msic *msic = pdev_to_intel_msic(mg->pdev);
+	unsigned long pending;
 	int i;
 	int bitnr;
 	u8 pin;
-	unsigned long pending = 0;
 
 	for (i = 0; i < (mg->chip.ngpio / BITS_PER_BYTE); i++) {
 		intel_msic_irq_read(msic, INTEL_MSIC_GPIO0LVIRQ + i, &pin);
 		pending = pin;
 
-		if (pending) {
-			for_each_set_bit(bitnr, &pending, BITS_PER_BYTE)
-				generic_handle_irq(mg->irq_base +
-						   (i * BITS_PER_BYTE) + bitnr);
-		}
+		for_each_set_bit(bitnr, &pending, BITS_PER_BYTE)
+			generic_handle_irq(mg->irq_base + i * BITS_PER_BYTE + bitnr);
 	}
 	chip->irq_eoi(data);
 }

commit 99ef32adc5102d1fa5beabc3a88e6bf150ccab30
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Apr 13 15:32:17 2018 +0200

    gpio: msic: Include the right header
    
    This is a driver so only include <linux/gpio/driver.h>.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 6cb67595d15f..3b34dbecef99 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -24,7 +24,7 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 #include <linux/platform_device.h>
 #include <linux/mfd/intel_msic.h>
 

commit ca1f3ae3154ad6d08caa740c99be0d86644a4e44
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Aug 3 17:00:01 2017 -0500

    gpio: msic: fix error return code in platform_msic_gpio_probe()
    
    platform_get_irq() returns an error code, but the gpio-msic driver
    ignores it and always returns -EINVAL. This is not correct, and
    prevents -EPROBE_DEFER from being propagated properly.
    
    Notice that platform_get_irq() no longer returns 0 on error:
    https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e330b9a6bb35dc7097a4f02cb1ae7b6f96df92af
    
    Print and propagate the return value of platform_get_irq on failure.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 1b7ce7f85886..6cb67595d15f 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -265,8 +265,8 @@ static int platform_msic_gpio_probe(struct platform_device *pdev)
 	int i;
 
 	if (irq < 0) {
-		dev_err(dev, "no IRQ line\n");
-		return -EINVAL;
+		dev_err(dev, "no IRQ line: %d\n", irq);
+		return irq;
 	}
 
 	if (!pdata || !pdata->gpio_base) {

commit 98102880c750d38b3be355fbcbc85a181fa3298a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Aug 22 12:48:30 2016 -0400

    gpio: msic: drop unused MODULE_ tags from non-modular code
    
    The Kconfig currently controlling compilation of this code is:
    
    drivers/gpio/Kconfig:config GPIO_MSIC
    drivers/gpio/Kconfig:   bool "Intel MSIC mixed signal gpio support"
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the couple traces of modular infrastructure use, so that
    when reading the driver there is no doubt it is builtin-only.
    
    We delete the MODULE_LICENSE tag etc. since all that information
    is already contained at the top of the file in the comments.
    
    We don't replace module.h with init.h since the file already has that.
    
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: linux-gpio@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index d75649787e6c..1b7ce7f85886 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -20,7 +20,6 @@
  *
  */
 
-#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
@@ -328,9 +327,4 @@ static int __init platform_msic_gpio_init(void)
 {
 	return platform_driver_register(&platform_msic_gpio_driver);
 }
-
 subsys_initcall(platform_msic_gpio_init);
-
-MODULE_AUTHOR("Mathias Nyman <mathias.nyman@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Medfield MSIC GPIO driver");
-MODULE_LICENSE("GPL v2");

commit a772a26da7cf605ed33382d7822ebfac18c6b1ef
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Dec 7 10:37:39 2015 +0100

    gpio: msic: use gpiochip data pointer
    
    This makes the driver use the data pointer added to the gpio_chip
    to store a pointer to the state container instead of relying on
    container_of().
    
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 9a261acb0eed..d75649787e6c 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -179,7 +179,7 @@ static int msic_irq_type(struct irq_data *data, unsigned type)
 
 static int msic_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 {
-	struct msic_gpio *mg = container_of(chip, struct msic_gpio, chip);
+	struct msic_gpio *mg = gpiochip_get_data(chip);
 	return mg->irq_base + offset;
 }
 
@@ -297,7 +297,7 @@ static int platform_msic_gpio_probe(struct platform_device *pdev)
 
 	mutex_init(&mg->buslock);
 
-	retval = gpiochip_add(&mg->chip);
+	retval = gpiochip_add_data(&mg->chip, mg);
 	if (retval) {
 		dev_err(dev, "Adding MSIC gpio chip failed\n");
 		goto err;

commit db30aaef313b4d5a2f6151e61e4f3ab5e0affae4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Dec 21 11:21:47 2015 +0100

    gpio: msic: Be sure to clamp return value
    
    As we want gpio_chip .get() calls to be able to return negative
    error codes and propagate to drivers, we need to go over all
    drivers and make sure their return values are clamped to [0,1].
    We do this by using the ret = !!(val) design pattern.
    
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index fe9ef2bc981a..9a261acb0eed 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -143,7 +143,7 @@ static int msic_gpio_get(struct gpio_chip *chip, unsigned offset)
 	if (ret < 0)
 		return ret;
 
-	return r & MSIC_GPIO_DIN_MASK;
+	return !!(r & MSIC_GPIO_DIN_MASK);
 }
 
 static void msic_gpio_set(struct gpio_chip *chip, unsigned offset, int value)

commit 58383c78425e4ee1c077253cf297b641c861c02e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 4 09:56:26 2015 +0100

    gpio: change member .dev to .parent
    
    The name .dev in a struct is normally reserved for a struct device
    that is let us say a superclass to the thing described by the struct.
    struct gpio_chip stands out by confusingly using a struct device *dev
    to point to the parent device (such as a platform_device) that
    represents the hardware. As we want to give gpio_chip:s real devices,
    this is not working. We need to rename this member to parent.
    
    This was done by two coccinelle scripts, I guess it is possible to
    combine them into one, but I don't know such stuff. They look like
    this:
    
    @@
    struct gpio_chip *var;
    @@
    -var->dev
    +var->parent
    
    and:
    
    @@
    struct gpio_chip var;
    @@
    -var.dev
    +var.parent
    
    and:
    
    @@
    struct bgpio_chip *var;
    @@
    -var->gc.dev
    +var->gc.parent
    
    Plus a few instances of bgpio that I couldn't figure out how
    to teach Coccinelle to rewrite.
    
    This patch hits all over the place, but I *strongly* prefer this
    solution to any piecemal approaches that just exercise patch
    mechanics all over the place. It mainly hits drivers/gpio and
    drivers/pinctrl which is my own backyard anyway.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Alek Du <alek.du@intel.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 22523aae8abe..fe9ef2bc981a 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -293,7 +293,7 @@ static int platform_msic_gpio_probe(struct platform_device *pdev)
 	mg->chip.base = pdata->gpio_base;
 	mg->chip.ngpio = MSIC_NUM_GPIO;
 	mg->chip.can_sleep = true;
-	mg->chip.dev = dev;
+	mg->chip.parent = dev;
 
 	mutex_init(&mg->buslock);
 

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 7bcfb87a5fa6..22523aae8abe 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -232,7 +232,7 @@ static struct irq_chip msic_irqchip = {
 	.irq_bus_sync_unlock	= msic_bus_sync_unlock,
 };
 
-static void msic_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+static void msic_gpio_irq_handler(struct irq_desc *desc)
 {
 	struct irq_data *data = irq_desc_get_irq_data(desc);
 	struct msic_gpio *mg = irq_data_get_irq_handler_data(data);

commit 3fb250ed39b2f883b566826132e04626da5910aa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 21 20:16:06 2015 +0200

    gpio/msic: Fix race in installing chained IRQ handler
    
    Fix a race where a pending interrupt could be received and the handler
    called before the handler's data has been setup, by converting to
    irq_set_chained_handler_and_data().
    
    Search and conversion was done with coccinelle:
    
    @@
    expression E1, E2, E3;
    @@
    (
    -if (irq_set_chained_handler(E1, E3) != 0)
    -   BUG();
    |
    -irq_set_chained_handler(E1, E3);
    )
    -irq_set_handler_data(E1, E2);
    +irq_set_chained_handler_and_data(E1, E3, E2);
    
    @@
    expression E1, E2, E3;
    @@
    (
    -if (irq_set_chained_handler(E1, E3) != 0)
    -   BUG();
    ...
    |
    -irq_set_chained_handler(E1, E3);
    ...
    )
    -irq_set_handler_data(E1, E2);
    +irq_set_chained_handler_and_data(E1, E3, E2);
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: linux-gpio@vger.kernel.org

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 01acf0a8cdb1..7bcfb87a5fa6 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -309,8 +309,7 @@ static int platform_msic_gpio_probe(struct platform_device *pdev)
 					 &msic_irqchip,
 					 handle_simple_irq);
 	}
-	irq_set_chained_handler(mg->irq, msic_gpio_irq_handler);
-	irq_set_handler_data(mg->irq, mg);
+	irq_set_chained_handler_and_data(mg->irq, msic_gpio_irq_handler, mg);
 
 	return 0;
 err:

commit 4a3a950ee9cc76188f5be9088bc765889f7a61c5
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:31 2014 +0200

    gpio: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 8f70ded82a2b..01acf0a8cdb1 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -321,7 +321,6 @@ static int platform_msic_gpio_probe(struct platform_device *pdev)
 static struct platform_driver platform_msic_gpio_driver = {
 	.driver = {
 		.name		= "msic_gpio",
-		.owner		= THIS_MODULE,
 	},
 	.probe		= platform_msic_gpio_probe,
 };

commit 9fb1f39eb2d6707d265087ee186376e24995f55a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Dec 4 14:42:46 2013 +0100

    gpio/pinctrl: make gpio_chip members typed boolean
    
    This switches the two members of struct gpio_chip that were
    defined as unsigned foo:1 to bool, because that is indeed what
    they are. Switch all users in the gpio and pinctrl subsystems
    to assign these values with true/false instead of 0/1. The
    users outside these subsystems will survive since true/false
    is 1/0, atleast we set some kind of more strict typing example.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 69d60ab1d698..8f70ded82a2b 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -292,7 +292,7 @@ static int platform_msic_gpio_probe(struct platform_device *pdev)
 	mg->chip.to_irq = msic_gpio_to_irq;
 	mg->chip.base = pdata->gpio_base;
 	mg->chip.ngpio = MSIC_NUM_GPIO;
-	mg->chip.can_sleep = 1;
+	mg->chip.can_sleep = true;
 	mg->chip.dev = dev;
 
 	mutex_init(&mg->buslock);

commit e5428a682ca726249a89201c79ddd0599669c484
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 26 14:28:32 2013 +0100

    gpio: drop users of irq_set_chip_and_handler_name()
    
    Switch all users of irq_set_chip_and_handler_name() to simply
    use irq_set_chip_and_handler(), all just provide a boilerplate
    name like "demux" or "mux" - a fact which is anyway obvious
    from the hwirq number from the irqdomain now present in e.g.
    /proc/interrupts.
    
    Cc: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: David Cohen <david.a.cohen@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index d75eaa3a1dcc..69d60ab1d698 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -305,10 +305,9 @@ static int platform_msic_gpio_probe(struct platform_device *pdev)
 
 	for (i = 0; i < mg->chip.ngpio; i++) {
 		irq_set_chip_data(i + mg->irq_base, mg);
-		irq_set_chip_and_handler_name(i + mg->irq_base,
-					      &msic_irqchip,
-					      handle_simple_irq,
-					      "demux");
+		irq_set_chip_and_handler(i + mg->irq_base,
+					 &msic_irqchip,
+					 handle_simple_irq);
 	}
 	irq_set_chained_handler(mg->irq, msic_gpio_irq_handler);
 	irq_set_handler_data(mg->irq, mg);

commit e56aee1897fd27631c1cb28e12b0fb8f8f9736f7
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:08:05 2013 +0900

    gpio: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 27ea7b9257ff..d75eaa3a1dcc 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -259,7 +259,7 @@ static void msic_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 static int platform_msic_gpio_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct intel_msic_gpio_pdata *pdata = dev->platform_data;
+	struct intel_msic_gpio_pdata *pdata = dev_get_platdata(dev);
 	struct msic_gpio *mg;
 	int irq = platform_get_irq(pdev, 0);
 	int retval;

commit 3836309d93462bbf34851c078be6e5e77d888e3d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:22:34 2012 -0500

    gpio: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Peter Tyser <ptyser@xes-inc.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index b38986285868..27ea7b9257ff 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -256,7 +256,7 @@ static void msic_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 	chip->irq_eoi(data);
 }
 
-static int __devinit platform_msic_gpio_probe(struct platform_device *pdev)
+static int platform_msic_gpio_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct intel_msic_gpio_pdata *pdata = dev->platform_data;

commit f7da0bdbf585c0404fc89901ee4bdb806e70530f
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jul 24 18:35:16 2012 +0800

    gpio: msic: Fix calculating register address in msic_gpio_to_oreg()
    
    In the case offset is 20 ... 23, the equation to get the register should be:
            INTEL_MSIC_GPIO1HV0CTLO - offset + 20
    
    With above equation, we can get below mapping between offset and the register:
            offset is 20: INTEL_MSIC_GPIO1HV0CTLO
            offset is 21: INTEL_MSIC_GPIO1HV1CTLO
            offset is 22: INTEL_MSIC_GPIO1HV2CTLO
            offset is 23: INTEL_MSIC_GPIO1HV3CTLO
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
index 71a838f44501..b38986285868 100644
--- a/drivers/gpio/gpio-msic.c
+++ b/drivers/gpio/gpio-msic.c
@@ -99,7 +99,7 @@ static int msic_gpio_to_oreg(unsigned offset)
 	if (offset < 20)
 		return INTEL_MSIC_GPIO0HV0CTLO - offset + 16;
 
-	return INTEL_MSIC_GPIO1HV0CTLO + offset + 20;
+	return INTEL_MSIC_GPIO1HV0CTLO - offset + 20;
 }
 
 static int msic_gpio_direction_input(struct gpio_chip *chip, unsigned offset)

commit 25cf25073a4e1e0563c288908481f10f98acb19a
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Apr 24 11:02:49 2012 +0100

    gpio: add MSIC gpio driver
    
    Add gpio support for Intel MSIC chips found in Intel Medfield platforms.
    MSIC supports totally 24 GPIOs with 16 low voltage and 8 high voltage pins.
    Driver uses MSIC mfd interface for MSIC access.
    
    (Updated comment to indicate why locking is actually safe)
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/gpio/gpio-msic.c b/drivers/gpio/gpio-msic.c
new file mode 100644
index 000000000000..71a838f44501
--- /dev/null
+++ b/drivers/gpio/gpio-msic.c
@@ -0,0 +1,339 @@
+/*
+ * Intel Medfield MSIC GPIO driver>
+ * Copyright (c) 2011, Intel Corporation.
+ *
+ * Author: Mathias Nyman <mathias.nyman@linux.intel.com>
+ * Based on intel_pmic_gpio.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/intel_msic.h>
+
+/* the offset for the mapping of global gpio pin to irq */
+#define MSIC_GPIO_IRQ_OFFSET	0x100
+
+#define MSIC_GPIO_DIR_IN	0
+#define MSIC_GPIO_DIR_OUT	BIT(5)
+#define MSIC_GPIO_TRIG_FALL	BIT(1)
+#define MSIC_GPIO_TRIG_RISE	BIT(2)
+
+/* masks for msic gpio output GPIOxxxxCTLO registers */
+#define MSIC_GPIO_DIR_MASK	BIT(5)
+#define MSIC_GPIO_DRV_MASK	BIT(4)
+#define MSIC_GPIO_REN_MASK	BIT(3)
+#define MSIC_GPIO_RVAL_MASK	(BIT(2) | BIT(1))
+#define MSIC_GPIO_DOUT_MASK	BIT(0)
+
+/* masks for msic gpio input GPIOxxxxCTLI registers */
+#define MSIC_GPIO_GLBYP_MASK	BIT(5)
+#define MSIC_GPIO_DBNC_MASK	(BIT(4) | BIT(3))
+#define MSIC_GPIO_INTCNT_MASK	(BIT(2) | BIT(1))
+#define MSIC_GPIO_DIN_MASK	BIT(0)
+
+#define MSIC_NUM_GPIO		24
+
+struct msic_gpio {
+	struct platform_device	*pdev;
+	struct mutex		buslock;
+	struct gpio_chip	chip;
+	int			irq;
+	unsigned		irq_base;
+	unsigned long		trig_change_mask;
+	unsigned		trig_type;
+};
+
+/*
+ * MSIC has 24 gpios, 16 low voltage (1.2-1.8v) and 8 high voltage (3v).
+ * Both the high and low voltage gpios are divided in two banks.
+ * GPIOs are numbered with GPIO0LV0 as gpio_base in the following order:
+ * GPIO0LV0..GPIO0LV7: low voltage, bank 0, gpio_base
+ * GPIO1LV0..GPIO1LV7: low voltage, bank 1,  gpio_base + 8
+ * GPIO0HV0..GPIO0HV3: high voltage, bank 0, gpio_base + 16
+ * GPIO1HV0..GPIO1HV3: high voltage, bank 1, gpio_base + 20
+ */
+
+static int msic_gpio_to_ireg(unsigned offset)
+{
+	if (offset >= MSIC_NUM_GPIO)
+		return -EINVAL;
+
+	if (offset < 8)
+		return INTEL_MSIC_GPIO0LV0CTLI - offset;
+	if (offset < 16)
+		return INTEL_MSIC_GPIO1LV0CTLI - offset + 8;
+	if (offset < 20)
+		return INTEL_MSIC_GPIO0HV0CTLI - offset + 16;
+
+	return INTEL_MSIC_GPIO1HV0CTLI - offset + 20;
+}
+
+static int msic_gpio_to_oreg(unsigned offset)
+{
+	if (offset >= MSIC_NUM_GPIO)
+		return -EINVAL;
+
+	if (offset < 8)
+		return INTEL_MSIC_GPIO0LV0CTLO - offset;
+	if (offset < 16)
+		return INTEL_MSIC_GPIO1LV0CTLO - offset + 8;
+	if (offset < 20)
+		return INTEL_MSIC_GPIO0HV0CTLO - offset + 16;
+
+	return INTEL_MSIC_GPIO1HV0CTLO + offset + 20;
+}
+
+static int msic_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	int reg;
+
+	reg = msic_gpio_to_oreg(offset);
+	if (reg < 0)
+		return reg;
+
+	return intel_msic_reg_update(reg, MSIC_GPIO_DIR_IN, MSIC_GPIO_DIR_MASK);
+}
+
+static int msic_gpio_direction_output(struct gpio_chip *chip,
+			unsigned offset, int value)
+{
+	int reg;
+	unsigned mask;
+
+	value = (!!value) | MSIC_GPIO_DIR_OUT;
+	mask = MSIC_GPIO_DIR_MASK | MSIC_GPIO_DOUT_MASK;
+
+	reg = msic_gpio_to_oreg(offset);
+	if (reg < 0)
+		return reg;
+
+	return intel_msic_reg_update(reg, value, mask);
+}
+
+static int msic_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	u8 r;
+	int ret;
+	int reg;
+
+	reg = msic_gpio_to_ireg(offset);
+	if (reg < 0)
+		return reg;
+
+	ret = intel_msic_reg_read(reg, &r);
+	if (ret < 0)
+		return ret;
+
+	return r & MSIC_GPIO_DIN_MASK;
+}
+
+static void msic_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	int reg;
+
+	reg = msic_gpio_to_oreg(offset);
+	if (reg < 0)
+		return;
+
+	intel_msic_reg_update(reg, !!value , MSIC_GPIO_DOUT_MASK);
+}
+
+/*
+ * This is called from genirq with mg->buslock locked and
+ * irq_desc->lock held. We can not access the scu bus here, so we
+ * store the change and update in the bus_sync_unlock() function below
+ */
+static int msic_irq_type(struct irq_data *data, unsigned type)
+{
+	struct msic_gpio *mg = irq_data_get_irq_chip_data(data);
+	u32 gpio = data->irq - mg->irq_base;
+
+	if (gpio >= mg->chip.ngpio)
+		return -EINVAL;
+
+	/* mark for which gpio the trigger changed, protected by buslock */
+	mg->trig_change_mask |= (1 << gpio);
+	mg->trig_type = type;
+
+	return 0;
+}
+
+static int msic_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct msic_gpio *mg = container_of(chip, struct msic_gpio, chip);
+	return mg->irq_base + offset;
+}
+
+static void msic_bus_lock(struct irq_data *data)
+{
+	struct msic_gpio *mg = irq_data_get_irq_chip_data(data);
+	mutex_lock(&mg->buslock);
+}
+
+static void msic_bus_sync_unlock(struct irq_data *data)
+{
+	struct msic_gpio *mg = irq_data_get_irq_chip_data(data);
+	int offset;
+	int reg;
+	u8 trig = 0;
+
+	/* We can only get one change at a time as the buslock covers the
+	   entire transaction. The irq_desc->lock is dropped before we are
+	   called but that is fine */
+	if (mg->trig_change_mask) {
+		offset = __ffs(mg->trig_change_mask);
+
+		reg = msic_gpio_to_ireg(offset);
+		if (reg < 0)
+			goto out;
+
+		if (mg->trig_type & IRQ_TYPE_EDGE_RISING)
+			trig |= MSIC_GPIO_TRIG_RISE;
+		if (mg->trig_type & IRQ_TYPE_EDGE_FALLING)
+			trig |= MSIC_GPIO_TRIG_FALL;
+
+		intel_msic_reg_update(reg, trig, MSIC_GPIO_INTCNT_MASK);
+		mg->trig_change_mask = 0;
+	}
+out:
+	mutex_unlock(&mg->buslock);
+}
+
+/* Firmware does all the masking and unmasking for us, no masking here. */
+static void msic_irq_unmask(struct irq_data *data) { }
+
+static void msic_irq_mask(struct irq_data *data) { }
+
+static struct irq_chip msic_irqchip = {
+	.name			= "MSIC-GPIO",
+	.irq_mask		= msic_irq_mask,
+	.irq_unmask		= msic_irq_unmask,
+	.irq_set_type		= msic_irq_type,
+	.irq_bus_lock		= msic_bus_lock,
+	.irq_bus_sync_unlock	= msic_bus_sync_unlock,
+};
+
+static void msic_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+{
+	struct irq_data *data = irq_desc_get_irq_data(desc);
+	struct msic_gpio *mg = irq_data_get_irq_handler_data(data);
+	struct irq_chip *chip = irq_data_get_irq_chip(data);
+	struct intel_msic *msic = pdev_to_intel_msic(mg->pdev);
+	int i;
+	int bitnr;
+	u8 pin;
+	unsigned long pending = 0;
+
+	for (i = 0; i < (mg->chip.ngpio / BITS_PER_BYTE); i++) {
+		intel_msic_irq_read(msic, INTEL_MSIC_GPIO0LVIRQ + i, &pin);
+		pending = pin;
+
+		if (pending) {
+			for_each_set_bit(bitnr, &pending, BITS_PER_BYTE)
+				generic_handle_irq(mg->irq_base +
+						   (i * BITS_PER_BYTE) + bitnr);
+		}
+	}
+	chip->irq_eoi(data);
+}
+
+static int __devinit platform_msic_gpio_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct intel_msic_gpio_pdata *pdata = dev->platform_data;
+	struct msic_gpio *mg;
+	int irq = platform_get_irq(pdev, 0);
+	int retval;
+	int i;
+
+	if (irq < 0) {
+		dev_err(dev, "no IRQ line\n");
+		return -EINVAL;
+	}
+
+	if (!pdata || !pdata->gpio_base) {
+		dev_err(dev, "incorrect or missing platform data\n");
+		return -EINVAL;
+	}
+
+	mg = kzalloc(sizeof(*mg), GFP_KERNEL);
+	if (!mg)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, mg);
+
+	mg->pdev = pdev;
+	mg->irq = irq;
+	mg->irq_base = pdata->gpio_base + MSIC_GPIO_IRQ_OFFSET;
+	mg->chip.label = "msic_gpio";
+	mg->chip.direction_input = msic_gpio_direction_input;
+	mg->chip.direction_output = msic_gpio_direction_output;
+	mg->chip.get = msic_gpio_get;
+	mg->chip.set = msic_gpio_set;
+	mg->chip.to_irq = msic_gpio_to_irq;
+	mg->chip.base = pdata->gpio_base;
+	mg->chip.ngpio = MSIC_NUM_GPIO;
+	mg->chip.can_sleep = 1;
+	mg->chip.dev = dev;
+
+	mutex_init(&mg->buslock);
+
+	retval = gpiochip_add(&mg->chip);
+	if (retval) {
+		dev_err(dev, "Adding MSIC gpio chip failed\n");
+		goto err;
+	}
+
+	for (i = 0; i < mg->chip.ngpio; i++) {
+		irq_set_chip_data(i + mg->irq_base, mg);
+		irq_set_chip_and_handler_name(i + mg->irq_base,
+					      &msic_irqchip,
+					      handle_simple_irq,
+					      "demux");
+	}
+	irq_set_chained_handler(mg->irq, msic_gpio_irq_handler);
+	irq_set_handler_data(mg->irq, mg);
+
+	return 0;
+err:
+	kfree(mg);
+	return retval;
+}
+
+static struct platform_driver platform_msic_gpio_driver = {
+	.driver = {
+		.name		= "msic_gpio",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= platform_msic_gpio_probe,
+};
+
+static int __init platform_msic_gpio_init(void)
+{
+	return platform_driver_register(&platform_msic_gpio_driver);
+}
+
+subsys_initcall(platform_msic_gpio_init);
+
+MODULE_AUTHOR("Mathias Nyman <mathias.nyman@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Medfield MSIC GPIO driver");
+MODULE_LICENSE("GPL v2");
