commit 04fd1ca77918a2395d0dc73c9a68436fdfaa26de
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Mar 25 11:39:56 2020 +0100

    gpiolib: acpi: Add missing __init(const) markers to initcall-s
    
    The gpiolib ACPI code uses 2 initcall-s and the called function
    (and used DMI table) is missing __init(const) markers.
    
    This commit fixes this freeing up some extra memory once the kernel
    has completed booting.
    
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200325103956.109284-2-hdegoede@redhat.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 0017367e94ee..9276051663da 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1353,7 +1353,7 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 }
 
 /* Run deferred acpi_gpiochip_request_irqs() */
-static int acpi_gpio_handle_deferred_request_irqs(void)
+static int __init acpi_gpio_handle_deferred_request_irqs(void)
 {
 	struct acpi_gpio_chip *acpi_gpio, *tmp;
 
@@ -1371,7 +1371,7 @@ static int acpi_gpio_handle_deferred_request_irqs(void)
 /* We must use _sync so that this runs after the first deferred_probe run */
 late_initcall_sync(acpi_gpio_handle_deferred_request_irqs);
 
-static const struct dmi_system_id gpiolib_acpi_quirks[] = {
+static const struct dmi_system_id gpiolib_acpi_quirks[] __initconst = {
 	{
 		/*
 		 * The Minix Neo Z83-4 has a micro-USB-B id-pin handler for
@@ -1455,7 +1455,7 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 	{} /* Terminating entry */
 };
 
-static int acpi_gpio_setup_params(void)
+static int __init acpi_gpio_setup_params(void)
 {
 	const struct acpi_gpiolib_dmi_quirk *quirk = NULL;
 	const struct dmi_system_id *id;

commit 0c625ccfe6f754d0896b8881f5c85bcb81699f1f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Mar 2 12:12:25 2020 +0100

    gpiolib: acpi: Add quirk to ignore EC wakeups on HP x2 10 CHT + AXP288 model
    
    There are at least 3 models of the HP x2 10 models:
    
    Bay Trail SoC + AXP288 PMIC
    Cherry Trail SoC + AXP288 PMIC
    Cherry Trail SoC + TI PMIC
    
    Like on the other HP x2 10 models we need to ignore wakeup for ACPI GPIO
    events on the external embedded-controller pin to avoid spurious wakeups
    on the HP x2 10 CHT + AXP288 model too.
    
    This commit adds an extra DMI based quirk for the HP x2 10 CHT + AXP288
    model, ignoring wakeups for ACPI GPIO events on the EC interrupt pin
    on this model. This fixes spurious wakeups from suspend on this model.
    
    Fixes: aa23ca3d98f7 ("gpiolib: acpi: Add honor_wakeup module-option + quirk mechanism")
    Reported-and-tested-by: Marc Lehmann <schmorp@schmorp.de>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200302111225.6641-4-hdegoede@redhat.com
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d1ef060a5873..0017367e94ee 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1437,6 +1437,21 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 			.ignore_wake = "INT33FC:02@28",
 		},
 	},
+	{
+		/*
+		 * HP X2 10 models with Cherry Trail SoC + AXP288 PMIC use an
+		 * external embedded-controller connected via I2C + an ACPI GPIO
+		 * event handler on INT33FF:01 pin 0, causing spurious wakeups.
+		 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "HP"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion x2 Detachable"),
+			DMI_MATCH(DMI_BOARD_NAME, "813E"),
+		},
+		.driver_data = &(struct acpi_gpiolib_dmi_quirk) {
+			.ignore_wake = "INT33FF:01@0",
+		},
+	},
 	{} /* Terminating entry */
 };
 

commit 0e91506ba00730f088961a8d39f8693b0f8e3fea
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Mar 2 12:12:24 2020 +0100

    gpiolib: acpi: Add quirk to ignore EC wakeups on HP x2 10 BYT + AXP288 model
    
    Commit aa23ca3d98f7 ("gpiolib: acpi: Add honor_wakeup module-option +
    quirk mechanism") was added to deal with spurious wakeups on one specific
    model of the HP x2 10 series. In the mean time I have learned that there
    are at least 3 different HP x2 10 models:
    
    Bay Trail SoC + AXP288 PMIC
    Cherry Trail SoC + AXP288 PMIC
    Cherry Trail SoC + TI PMIC
    
    And the original quirk is only correct for (and only matches the)
    Cherry Trail SoC + TI PMIC model.
    
    The Bay Trail SoC + AXP288 PMIC model has different DMI strings, has
    the external EC interrupt on a different GPIO pin and only needs to ignore
    wakeups on the EC interrupt, the INT0002 device works fine on this model.
    
    This commit adds an extra DMI based quirk for the HP x2 10 BYT + AXP288
    model, ignoring wakeups for ACPI GPIO events on the EC interrupt pin
    on this model. This fixes spurious wakeups from suspend on this model.
    
    Fixes: aa23ca3d98f7 ("gpiolib: acpi: Add honor_wakeup module-option + quirk mechanism")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200302111225.6641-3-hdegoede@redhat.com
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 87bb0d3c69da..d1ef060a5873 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1422,6 +1422,21 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 			.ignore_wake = "INT33FF:01@0,INT0002:00@2",
 		},
 	},
+	{
+		/*
+		 * HP X2 10 models with Bay Trail SoC + AXP288 PMIC use an
+		 * external embedded-controller connected via I2C + an ACPI GPIO
+		 * event handler on INT33FC:02 pin 28, causing spurious wakeups.
+		 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion x2 Detachable"),
+			DMI_MATCH(DMI_BOARD_NAME, "815D"),
+		},
+		.driver_data = &(struct acpi_gpiolib_dmi_quirk) {
+			.ignore_wake = "INT33FC:02@28",
+		},
+	},
 	{} /* Terminating entry */
 };
 

commit 2ccb21f5516afef5e251184eeefbf36db90206d7
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Mar 2 12:12:23 2020 +0100

    gpiolib: acpi: Rework honor_wakeup option into an ignore_wake option
    
    Commit aa23ca3d98f7 ("gpiolib: acpi: Add honor_wakeup module-option +
    quirk mechanism") was added to deal with spurious wakeups on one specific
    model of the HP x2 10 series.
    
    The approach taken there was to add a bool controlling wakeup support for
    all ACPI GPIO events. This was sufficient for the specific HP x2 10 model
    the commit was trying to fix, but in the mean time other models have
    turned up which need a similar workaround to avoid spurious wakeups from
    suspend, but only for one of the pins on which the ACPI tables request
    ACPI GPIO events.
    
    Since the honor_wakeup option was added to be able to ignore wake events,
    the name was perhaps not the best, this commit renames it to ignore_wake
    and changes it to a string with the following format:
    gpiolib_acpi.ignore_wake=controller@pin[,controller@pin[,...]]
    
    This allows working around spurious wakeup issues on a per pin basis.
    
    This commit also reworks the existing quirk for the HP x2 10 so that
    it functions as before.
    
    Note:
    -This removes the honor_wakeup parameter. This has only been upstream for
     a short time and to the best of my knowledge there are no users using
     this module parameter.
    
    -The controller@pin[,controller@pin[,...]] syntax is based on an existing
     kernel module parameter using the same controller@pin format. That version
     uses ';' as separator, but in practice that is problematic because grub2
     cannot handle this without taking special care to escape the ';', so here
     we are using a ',' as separator instead which does not have this issue.
    
    Fixes: aa23ca3d98f7 ("gpiolib: acpi: Add honor_wakeup module-option + quirk mechanism")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200302111225.6641-2-hdegoede@redhat.com
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index a77edd31dd60..87bb0d3c69da 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -21,18 +21,21 @@
 #include "gpiolib.h"
 #include "gpiolib-acpi.h"
 
-#define QUIRK_NO_EDGE_EVENTS_ON_BOOT		0x01l
-#define QUIRK_NO_WAKEUP				0x02l
-
 static int run_edge_events_on_boot = -1;
 module_param(run_edge_events_on_boot, int, 0444);
 MODULE_PARM_DESC(run_edge_events_on_boot,
 		 "Run edge _AEI event-handlers at boot: 0=no, 1=yes, -1=auto");
 
-static int honor_wakeup = -1;
-module_param(honor_wakeup, int, 0444);
-MODULE_PARM_DESC(honor_wakeup,
-		 "Honor the ACPI wake-capable flag: 0=no, 1=yes, -1=auto");
+static char *ignore_wake;
+module_param(ignore_wake, charp, 0444);
+MODULE_PARM_DESC(ignore_wake,
+		 "controller@pin combos on which to ignore the ACPI wake flag "
+		 "ignore_wake=controller@pin[,controller@pin[,...]]");
+
+struct acpi_gpiolib_dmi_quirk {
+	bool no_edge_events_on_boot;
+	char *ignore_wake;
+};
 
 /**
  * struct acpi_gpio_event - ACPI GPIO event handler data
@@ -202,6 +205,57 @@ static void acpi_gpiochip_request_irqs(struct acpi_gpio_chip *acpi_gpio)
 		acpi_gpiochip_request_irq(acpi_gpio, event);
 }
 
+static bool acpi_gpio_in_ignore_list(const char *controller_in, int pin_in)
+{
+	const char *controller, *pin_str;
+	int len, pin;
+	char *endp;
+
+	controller = ignore_wake;
+	while (controller) {
+		pin_str = strchr(controller, '@');
+		if (!pin_str)
+			goto err;
+
+		len = pin_str - controller;
+		if (len == strlen(controller_in) &&
+		    strncmp(controller, controller_in, len) == 0) {
+			pin = simple_strtoul(pin_str + 1, &endp, 10);
+			if (*endp != 0 && *endp != ',')
+				goto err;
+
+			if (pin == pin_in)
+				return true;
+		}
+
+		controller = strchr(controller, ',');
+		if (controller)
+			controller++;
+	}
+
+	return false;
+err:
+	pr_err_once("Error invalid value for gpiolib_acpi.ignore_wake: %s\n",
+		    ignore_wake);
+	return false;
+}
+
+static bool acpi_gpio_irq_is_wake(struct device *parent,
+				  struct acpi_resource_gpio *agpio)
+{
+	int pin = agpio->pin_table[0];
+
+	if (agpio->wake_capable != ACPI_WAKE_CAPABLE)
+		return false;
+
+	if (acpi_gpio_in_ignore_list(dev_name(parent), pin)) {
+		dev_info(parent, "Ignoring wakeup on pin %d\n", pin);
+		return false;
+	}
+
+	return true;
+}
+
 /* Always returns AE_OK so that we keep looping over the resources */
 static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 					     void *context)
@@ -289,7 +343,7 @@ static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 	event->handle = evt_handle;
 	event->handler = handler;
 	event->irq = irq;
-	event->irq_is_wake = honor_wakeup && agpio->wake_capable == ACPI_WAKE_CAPABLE;
+	event->irq_is_wake = acpi_gpio_irq_is_wake(chip->parent, agpio);
 	event->pin = pin;
 	event->desc = desc;
 
@@ -1328,7 +1382,9 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 			DMI_MATCH(DMI_SYS_VENDOR, "MINIX"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Z83-4"),
 		},
-		.driver_data = (void *)QUIRK_NO_EDGE_EVENTS_ON_BOOT,
+		.driver_data = &(struct acpi_gpiolib_dmi_quirk) {
+			.no_edge_events_on_boot = true,
+		},
 	},
 	{
 		/*
@@ -1341,7 +1397,9 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Wortmann_AG"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "TERRA_PAD_1061"),
 		},
-		.driver_data = (void *)QUIRK_NO_EDGE_EVENTS_ON_BOOT,
+		.driver_data = &(struct acpi_gpiolib_dmi_quirk) {
+			.no_edge_events_on_boot = true,
+		},
 	},
 	{
 		/*
@@ -1360,33 +1418,31 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 			DMI_MATCH(DMI_SYS_VENDOR, "HP"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "HP x2 Detachable 10-p0XX"),
 		},
-		.driver_data = (void *)QUIRK_NO_WAKEUP,
+		.driver_data = &(struct acpi_gpiolib_dmi_quirk) {
+			.ignore_wake = "INT33FF:01@0,INT0002:00@2",
+		},
 	},
 	{} /* Terminating entry */
 };
 
 static int acpi_gpio_setup_params(void)
 {
+	const struct acpi_gpiolib_dmi_quirk *quirk = NULL;
 	const struct dmi_system_id *id;
-	long quirks = 0;
 
 	id = dmi_first_match(gpiolib_acpi_quirks);
 	if (id)
-		quirks = (long)id->driver_data;
+		quirk = id->driver_data;
 
 	if (run_edge_events_on_boot < 0) {
-		if (quirks & QUIRK_NO_EDGE_EVENTS_ON_BOOT)
+		if (quirk && quirk->no_edge_events_on_boot)
 			run_edge_events_on_boot = 0;
 		else
 			run_edge_events_on_boot = 1;
 	}
 
-	if (honor_wakeup < 0) {
-		if (quirks & QUIRK_NO_WAKEUP)
-			honor_wakeup = 0;
-		else
-			honor_wakeup = 1;
-	}
+	if (ignore_wake == NULL && quirk && quirk->ignore_wake)
+		ignore_wake = quirk->ignore_wake;
 
 	return 0;
 }

commit efaa87fa0947d525cf7c075316adde4e3ac7720b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Mar 2 12:12:22 2020 +0100

    gpiolib: acpi: Correct comment for HP x2 10 honor_wakeup quirk
    
    Commit aa23ca3d98f7 ("gpiolib: acpi: Add honor_wakeup module-option +
    quirk mechanism") added a quirk for some models of the HP x2 10 series.
    
    There are 2 issues with the comment describing the quirk:
    1) The comment claims the DMI quirk applies to all Cherry Trail based HP x2
       10 models. In the mean time I have learned that there are at least 3
       models of the HP x2 10 models:
    
       Bay Trail SoC + AXP288 PMIC
       Cherry Trail SoC + AXP288 PMIC
       Cherry Trail SoC + TI PMIC
    
       And this quirk's DMI matches only match the Cherry Trail SoC + TI PMIC
       SoC, which is good because we want a slightly different quirk for the
       others. This commit updates the comment to make it clear that the quirk
       is only for the Cherry Trail SoC + TI PMIC models.
    
    2) The comment says that it is ok to disable wakeup on all ACPI GPIO event
       handlers, because there is only the one for the embedded-controller
       events. This is not true, there also is a handler for the special
       INT0002 device which is related to USB wakeups. We need to also disable
       wakeups on that one because the device turns of the USB-keyboard built
       into the dock when closing the lid. The XHCI controller takes a while
       to notice this, so it only notices it when already suspended, causing
       a spurious wakeup because of this. So disabling wakeup on all handlers
       is the right thing to do, but not because there only is the one handler
       for the EC events. This commit updates the comment to correctly reflect
       this.
    
    Fixes: aa23ca3d98f7 ("gpiolib: acpi: Add honor_wakeup module-option + quirk mechanism")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200302111225.6641-1-hdegoede@redhat.com
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 31fee5e918b7..a77edd31dd60 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1345,12 +1345,14 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 	},
 	{
 		/*
-		 * Various HP X2 10 Cherry Trail models use an external
-		 * embedded-controller connected via I2C + an ACPI GPIO
-		 * event handler. The embedded controller generates various
-		 * spurious wakeup events when suspended. So disable wakeup
-		 * for its handler (it uses the only ACPI GPIO event handler).
-		 * This breaks wakeup when opening the lid, the user needs
+		 * HP X2 10 models with Cherry Trail SoC + TI PMIC use an
+		 * external embedded-controller connected via I2C + an ACPI GPIO
+		 * event handler on INT33FF:01 pin 0, causing spurious wakeups.
+		 * When suspending by closing the LID, the power to the USB
+		 * keyboard is turned off, causing INT0002 ACPI events to
+		 * trigger once the XHCI controller notices the keyboard is
+		 * gone. So INT0002 events cause spurious wakeups too. Ignoring
+		 * EC wakes breaks wakeup when opening the lid, the user needs
 		 * to press the power-button to wakeup the system. The
 		 * alternative is suspend simply not working, which is worse.
 		 */

commit aa23ca3d98f756d5b1e503fb140665fb24a41a38
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Jan 5 17:03:57 2020 +0100

    gpiolib: acpi: Add honor_wakeup module-option + quirk mechanism
    
    On some laptops enabling wakeup on the GPIO interrupts used for ACPI _AEI
    event handling causes spurious wakeups.
    
    This commit adds a new honor_wakeup option, defaulting to true (our current
    behavior), which can be used to disable wakeup on troublesome hardware
    to avoid these spurious wakeups.
    
    This is a workaround for an architectural problem with s2idle under Linux
    where we do not have any mechanism to immediately go back to sleep after
    wakeup events, other then for embedded-controller events using the standard
    ACPI EC interface, for details see:
    https://lore.kernel.org/linux-acpi/61450f9b-cbc6-0c09-8b3a-aff6bf9a0b3c@redhat.com/
    
    One series of laptops which is not able to suspend without this workaround
    is the HP x2 10 Cherry Trail models, this commit adds a DMI based quirk
    which makes sets honor_wakeup to false on these models.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200105160357.97154-3-hdegoede@redhat.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 2b47d906d536..31fee5e918b7 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -22,12 +22,18 @@
 #include "gpiolib-acpi.h"
 
 #define QUIRK_NO_EDGE_EVENTS_ON_BOOT		0x01l
+#define QUIRK_NO_WAKEUP				0x02l
 
 static int run_edge_events_on_boot = -1;
 module_param(run_edge_events_on_boot, int, 0444);
 MODULE_PARM_DESC(run_edge_events_on_boot,
 		 "Run edge _AEI event-handlers at boot: 0=no, 1=yes, -1=auto");
 
+static int honor_wakeup = -1;
+module_param(honor_wakeup, int, 0444);
+MODULE_PARM_DESC(honor_wakeup,
+		 "Honor the ACPI wake-capable flag: 0=no, 1=yes, -1=auto");
+
 /**
  * struct acpi_gpio_event - ACPI GPIO event handler data
  *
@@ -283,7 +289,7 @@ static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 	event->handle = evt_handle;
 	event->handler = handler;
 	event->irq = irq;
-	event->irq_is_wake = agpio->wake_capable == ACPI_WAKE_CAPABLE;
+	event->irq_is_wake = honor_wakeup && agpio->wake_capable == ACPI_WAKE_CAPABLE;
 	event->pin = pin;
 	event->desc = desc;
 
@@ -1337,6 +1343,23 @@ static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 		},
 		.driver_data = (void *)QUIRK_NO_EDGE_EVENTS_ON_BOOT,
 	},
+	{
+		/*
+		 * Various HP X2 10 Cherry Trail models use an external
+		 * embedded-controller connected via I2C + an ACPI GPIO
+		 * event handler. The embedded controller generates various
+		 * spurious wakeup events when suspended. So disable wakeup
+		 * for its handler (it uses the only ACPI GPIO event handler).
+		 * This breaks wakeup when opening the lid, the user needs
+		 * to press the power-button to wakeup the system. The
+		 * alternative is suspend simply not working, which is worse.
+		 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "HP"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HP x2 Detachable 10-p0XX"),
+		},
+		.driver_data = (void *)QUIRK_NO_WAKEUP,
+	},
 	{} /* Terminating entry */
 };
 
@@ -1356,6 +1379,13 @@ static int acpi_gpio_setup_params(void)
 			run_edge_events_on_boot = 1;
 	}
 
+	if (honor_wakeup < 0) {
+		if (quirks & QUIRK_NO_WAKEUP)
+			honor_wakeup = 0;
+		else
+			honor_wakeup = 1;
+	}
+
 	return 0;
 }
 

commit 1ad1b54099c231aed8f6f257065c1b322583f264
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Jan 5 17:03:56 2020 +0100

    gpiolib: acpi: Turn dmi_system_id table into a generic quirk table
    
    Turn the existing run_edge_events_on_boot_blacklist dmi_system_id table
    into a generic quirk table, storing the quirks in the driver_data ptr.
    
    This is a preparation patch for adding other types of (DMI based) quirks.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200105160357.97154-2-hdegoede@redhat.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d30e57dc755c..2b47d906d536 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -21,6 +21,8 @@
 #include "gpiolib.h"
 #include "gpiolib-acpi.h"
 
+#define QUIRK_NO_EDGE_EVENTS_ON_BOOT		0x01l
+
 static int run_edge_events_on_boot = -1;
 module_param(run_edge_events_on_boot, int, 0444);
 MODULE_PARM_DESC(run_edge_events_on_boot,
@@ -1309,7 +1311,7 @@ static int acpi_gpio_handle_deferred_request_irqs(void)
 /* We must use _sync so that this runs after the first deferred_probe run */
 late_initcall_sync(acpi_gpio_handle_deferred_request_irqs);
 
-static const struct dmi_system_id run_edge_events_on_boot_blacklist[] = {
+static const struct dmi_system_id gpiolib_acpi_quirks[] = {
 	{
 		/*
 		 * The Minix Neo Z83-4 has a micro-USB-B id-pin handler for
@@ -1319,7 +1321,8 @@ static const struct dmi_system_id run_edge_events_on_boot_blacklist[] = {
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "MINIX"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Z83-4"),
-		}
+		},
+		.driver_data = (void *)QUIRK_NO_EDGE_EVENTS_ON_BOOT,
 	},
 	{
 		/*
@@ -1331,15 +1334,23 @@ static const struct dmi_system_id run_edge_events_on_boot_blacklist[] = {
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Wortmann_AG"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "TERRA_PAD_1061"),
-		}
+		},
+		.driver_data = (void *)QUIRK_NO_EDGE_EVENTS_ON_BOOT,
 	},
 	{} /* Terminating entry */
 };
 
 static int acpi_gpio_setup_params(void)
 {
+	const struct dmi_system_id *id;
+	long quirks = 0;
+
+	id = dmi_first_match(gpiolib_acpi_quirks);
+	if (id)
+		quirks = (long)id->driver_data;
+
 	if (run_edge_events_on_boot < 0) {
-		if (dmi_check_system(run_edge_events_on_boot_blacklist))
+		if (quirks & QUIRK_NO_EDGE_EVENTS_ON_BOOT)
 			run_edge_events_on_boot = 0;
 		else
 			run_edge_events_on_boot = 1;

commit 99a0d9f5e87352c4bd8d01bc9b39f7091c12e4d4
Merge: 37323918cac2 41c4616bb81f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 1 17:56:50 2019 -0800

    Merge tag 'gpio-v5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v5.5 kernel cycle
    
      Core changes:
    
       - Expose pull up/down flags for the GPIO character device to
         userspace.
    
         After clear input from the RaspberryPi and Beagle communities, it
         has been established that prototyping, industrial automation and
         make communities strongly need this feature, and as we want people
         to use the character device, we have implemented the simple pull
         up/down interface for GPIO lines.
    
         This means we can specify that a (chip-specific) pull up/down
         resistor can be enabled, but does not offer fine-grained control
         such as cases where the resistance of the same pull resistor can be
         controlled (yet).
    
       - Introduce devm_fwnode_gpiod_get_index() and start to phase out the
         old symbol devm_fwnode_get_index_gpiod_from_child().
    
       - A bit of documentation clean-up work.
    
       - Introduce a define for GPIO line directions and deploy it in all
         GPIO drivers in the drivers/gpio directory.
    
       - Add a special callback to populate pin ranges when cooperating with
         the pin control subsystem and registering ranges as part of adding
         a gpiolib driver and a gpio_irq_chip driver at the same time. This
         is also deployed in the Intel Merrifield driver.
    
      New drivers:
    
       - RDA Micro GPIO controller.
    
       - XGS-iproc GPIO driver.
    
      Driver improvements:
    
       - Wake event and debounce support on the Tegra 186 driver.
    
       - Finalize the Aspeed SGPIO driver.
    
       - MPC8xxx uses a normal IRQ handler rather than a chained handler"
    
    * tag 'gpio-v5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (64 commits)
      gpio: Add TODO item for regmap helper
      Documentation: gpio: driver.rst: Fix warnings
      gpio: of: Fix bogus reference to gpiod_get_count()
      gpiolib: Grammar s/manager/managed/
      gpio: lynxpoint: Setup correct IRQ handlers
      MAINTAINERS: Replace my email by one @kernel.org
      gpiolib: acpi: Make acpi_gpiochip_alloc_event always return AE_OK
      gpio/mpc8xxx: fix qoriq GPIO reading
      gpio: mpc8xxx: Don't overwrite default irq_set_type callback
      gpiolib: acpi: Print pin number on acpi_gpiochip_alloc_event errors
      gpiolib: fix coding style in gpiod_hog()
      drm/bridge: ti-tfp410: switch to using fwnode_gpiod_get_index()
      gpio: merrifield: Pass irqchip when adding gpiochip
      gpio: merrifield: Add GPIO <-> pin mapping ranges via callback
      gpiolib: Introduce ->add_pin_ranges() callback
      gpio: mmio: remove untrue leftover comment
      gpio: em: Use platform_get_irq() to obtain interrupts
      gpio: tegra186: Add debounce support
      gpio: tegra186: Program interrupt route mapping
      gpio: tegra186: Derive register offsets from bank/port
      ...

commit d4fc46f1739d2e1a5c2a92a7b3e65f2426c9e9b5
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Nov 14 11:26:00 2019 +0100

    gpiolib: acpi: Make acpi_gpiochip_alloc_event always return AE_OK
    
    acpi_gpiochip_alloc_event is used to loop over all _AEI resources, if
    we fail to bind an event handler to one of them, that is not a reason to
    not try the other resources.
    
    This commit modifies acpi_gpiochip_alloc_event to always return AE_OK,
    so that we will always try to add an event handler for all _AEI resources.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20191114102600.34558-2-hdegoede@redhat.com
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 7b02ee2de0a0..943c46d617a2 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -194,6 +194,7 @@ static void acpi_gpiochip_request_irqs(struct acpi_gpio_chip *acpi_gpio)
 		acpi_gpiochip_request_irq(acpi_gpio, event);
 }
 
+/* Always returns AE_OK so that we keep looping over the resources */
 static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 					     void *context)
 {
@@ -233,7 +234,7 @@ static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 		dev_err(chip->parent,
 			"Failed to request GPIO for pin 0x%04X, err %ld\n",
 			pin, PTR_ERR(desc));
-		return AE_ERROR;
+		return AE_OK;
 	}
 
 	ret = gpiochip_lock_as_irq(chip, pin);
@@ -293,7 +294,7 @@ static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 fail_free_desc:
 	gpiochip_free_own_desc(desc);
 
-	return AE_ERROR;
+	return AE_OK;
 }
 
 /**

commit 3f86a7e090d1dfb974a9dc9d44049f9bff01e6a5
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Nov 14 11:25:59 2019 +0100

    gpiolib: acpi: Print pin number on acpi_gpiochip_alloc_event errors
    
    Print pin number and error-code on acpi_gpiochip_alloc_event errors,
    to help debugging these.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20191114102600.34558-1-hdegoede@redhat.com
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 609ed16ae933..7b02ee2de0a0 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -230,19 +230,25 @@ static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event",
 					 GPIO_ACTIVE_HIGH, GPIOD_IN);
 	if (IS_ERR(desc)) {
-		dev_err(chip->parent, "Failed to request GPIO\n");
+		dev_err(chip->parent,
+			"Failed to request GPIO for pin 0x%04X, err %ld\n",
+			pin, PTR_ERR(desc));
 		return AE_ERROR;
 	}
 
 	ret = gpiochip_lock_as_irq(chip, pin);
 	if (ret) {
-		dev_err(chip->parent, "Failed to lock GPIO as interrupt\n");
+		dev_err(chip->parent,
+			"Failed to lock GPIO pin 0x%04X as interrupt, err %d\n",
+			pin, ret);
 		goto fail_free_desc;
 	}
 
 	irq = gpiod_to_irq(desc);
 	if (irq < 0) {
-		dev_err(chip->parent, "Failed to translate GPIO to IRQ\n");
+		dev_err(chip->parent,
+			"Failed to translate GPIO pin 0x%04X to IRQ, err %d\n",
+			pin, irq);
 		goto fail_unlock_irq;
 	}
 

commit 2727315df3f5ffbebcb174eed3153944a858b66f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Nov 6 12:51:09 2019 +0100

    gpiolib: acpi: Add Terra Pad 1061 to the run_edge_events_on_boot_blacklist
    
    The Terra Pad 1061 has the usual micro-USB-B id-pin handler, but instead
    of controlling the actual micro-USB-B it turns the 5V boost for the
    tablet's USB-A connector and its keyboard-cover connector off.
    
    The actual micro-USB-B connector on the tablet is wired for charging only,
    and its id pin is *not* connected to the GPIO which is used for the
    (broken) id-pin event handler in the DSDT.
    
    While at it not only add a comment why the Terra Pad 1061 is on the
    blacklist, but also fix the missing comment for the Minix Neo Z83-4 entry.
    
    Fixes: 61f7f7c8f978 ("gpiolib: acpi: Add gpiolib_acpi_run_edge_events_on_boot option and blacklist")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 609ed16ae933..59ccfd24627d 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1304,11 +1304,28 @@ late_initcall_sync(acpi_gpio_handle_deferred_request_irqs);
 
 static const struct dmi_system_id run_edge_events_on_boot_blacklist[] = {
 	{
+		/*
+		 * The Minix Neo Z83-4 has a micro-USB-B id-pin handler for
+		 * a non existing micro-USB-B connector which puts the HDMI
+		 * DDC pins in GPIO mode, breaking HDMI support.
+		 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "MINIX"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Z83-4"),
 		}
 	},
+	{
+		/*
+		 * The Terra Pad 1061 has a micro-USB-B id-pin handler, which
+		 * instead of controlling the actual micro-USB-B turns the 5V
+		 * boost for its USB-A connector off. The actual micro-USB-B
+		 * connector is wired for charging only.
+		 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Wortmann_AG"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "TERRA_PAD_1061"),
+		}
+	},
 	{} /* Terminating entry */
 };
 

commit bbfe0d6b8b730af4954a0e0e741217eb3e1c58bc
Merge: 31dda85e49da 11c43bb022b3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 16 14:06:50 2019 -0700

    Merge tag 'gpio-v5.4-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of changes in the GPIO subsystem for the v5.4 kernel
      cycle.
    
      Core changes:
    
       - Support hierarchical GPIO irqchips.
    
         We now have three consumers that can use this: Intel IXP4xx,
         ThunderX and Qualcomm SPMI GPIO (in the pinctrl subsystem).
    
         The support code has been long in the making and hashed out so it
         should be easily adaptable for all hierarchical irqchip parents.
         The code only gets compiled in if hierarchical irqchip is used at
         the topmost irq controller at least, as the hierarchical irqchip
         requires strict hierarchy all the way up in the system.
    
       - Determine the need for a "valid_mask" for GPIO lines on the
         gpio_chip and conversely for the "valid_mask" for the GPIO
         interrupt chip interrupt lines by looking for a .init_valid_mask()
         callback in the main chip or GPIO interrupt chip respectively.
         Allocate it with bitmap_alloc().
    
       - Isolate the device tree/open firmware GPIO description code out in
         its own file properly.
    
       - Isolate the ACPI GPIO description code out in its own file
         properly.
    
       - Drop a whole lot of #ifdef:s in the main includes: it does not hurt
         to keep the include items around, and we get quicker and clearer
         compile failures if the appropriate kernel symbols are not selected
         for drivers.
    
      New/deleted drivers:
    
       - New driver for Aspeed SGPIO.
    
       - The KS8695 driver is deleted as the platform gets deleted from
         arch/arm in this kernel cycle.
    
       - The Cirrus Logic Madera driver now supports CS47L92 and CS47L15.
    
       - The Freescale MPC8xxx now supports LS1028A and LS1088A.
    
      Driver improvements:
    
       - We pass the GPIO irqchip intialization by directly filling in the
         struct instead of using set-up functions (the new way) for Intel
         MID, Lynxpoint, Merrifield, XLP, HLWD, Aspeed, ZX, VF610, TQMX86,
         MT7621, Zynq and EP93xx.
    
      Out-of-band changes:
    
       - Fix a GPIO header inclusion in Unicore - no response from
         maintainer.
    
       - Drop FMC subsystem from MAINTAINERS - was deleted in the GPIO tree
         last cycle so let's mop up the shards"
    
    * tag 'gpio-v5.4-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (82 commits)
      gpiolib: of: add a fallback for wlf,reset GPIO name
      gpio: htc-egpio: Remove unused exported htc_egpio_get_wakeup_irq()
      gpio: remove explicit comparison with 0
      gpio: creg-snps: use devm_platform_ioremap_resource() to simplify code
      gpio: devres: Switch to EXPORT_SYMBOL_GPL()
      gpio: of: Switch to EXPORT_SYMBOL_GPL()
      gpio: of: Make of_gpio_simple_xlate() private
      gpio: of: Make of_get_named_gpiod_flags() private
      gpio: aspeed: Add in ast2600 details to Aspeed driver
      gpio: aspeed: Use ngpio property from device tree if available
      gpio: aspeed: Setup irqchip dynamically
      gpio/aspeed: Fix incorrect number of banks
      gpio: aspeed: Update documentation with ast2600 controllers
      gpio: Initialize the irqchip valid_mask with a callback
      gpiolib: acpi: make acpi_can_fallback_to_crs() static
      gpio: Fix further merge errors
      gpio: Fix up merge collision in include file
      gpio: of: Normalize return code variable name
      gpio: gpiolib: Normalize return code variable name
      gpio: ep93xx: Pass irqchip when adding gpiochip
      ...

commit 61f7f7c8f978b1c0d80e43c83b7d110ca0496eb4
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Aug 27 22:28:35 2019 +0200

    gpiolib: acpi: Add gpiolib_acpi_run_edge_events_on_boot option and blacklist
    
    Another day; another DSDT bug we need to workaround...
    
    Since commit ca876c7483b6 ("gpiolib-acpi: make sure we trigger edge events
    at least once on boot") we call _AEI edge handlers at boot.
    
    In some rare cases this causes problems. One example of this is the Minix
    Neo Z83-4 mini PC, this device has a clear DSDT bug where it has some copy
    and pasted code for dealing with Micro USB-B connector host/device role
    switching, while the mini PC does not even have a micro-USB connector.
    This code, which should not be there, messes with the DDC data pin from
    the HDMI connector (switching it to GPIO mode) breaking HDMI support.
    
    To avoid problems like this, this commit adds a new
    gpiolib_acpi.run_edge_events_on_boot kernel commandline option, which
    allows disabling the running of _AEI edge event handlers at boot.
    
    The default value is -1/auto which uses a DMI based blacklist, the initial
    version of this blacklist contains the Neo Z83-4 fixing the HDMI breakage.
    
    Cc: stable@vger.kernel.org
    Cc: Daniel Drake <drake@endlessm.com>
    Cc: Ian W MORRISON <ianwmorrison@gmail.com>
    Reported-by: Ian W MORRISON <ianwmorrison@gmail.com>
    Suggested-by: Ian W MORRISON <ianwmorrison@gmail.com>
    Fixes: ca876c7483b6 ("gpiolib-acpi: make sure we trigger edge events at least once on boot")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20190827202835.213456-1-hdegoede@redhat.com
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Ian W MORRISON <ianwmorrison@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 39f2f9035c11..bda28eb82c3f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -7,6 +7,7 @@
  *          Mika Westerberg <mika.westerberg@linux.intel.com>
  */
 
+#include <linux/dmi.h>
 #include <linux/errno.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio/driver.h>
@@ -19,6 +20,11 @@
 
 #include "gpiolib.h"
 
+static int run_edge_events_on_boot = -1;
+module_param(run_edge_events_on_boot, int, 0444);
+MODULE_PARM_DESC(run_edge_events_on_boot,
+		 "Run edge _AEI event-handlers at boot: 0=no, 1=yes, -1=auto");
+
 /**
  * struct acpi_gpio_event - ACPI GPIO event handler data
  *
@@ -170,10 +176,13 @@ static void acpi_gpiochip_request_irq(struct acpi_gpio_chip *acpi_gpio,
 	event->irq_requested = true;
 
 	/* Make sure we trigger the initial state of edge-triggered IRQs */
-	value = gpiod_get_raw_value_cansleep(event->desc);
-	if (((event->irqflags & IRQF_TRIGGER_RISING) && value == 1) ||
-	    ((event->irqflags & IRQF_TRIGGER_FALLING) && value == 0))
-		event->handler(event->irq, event);
+	if (run_edge_events_on_boot &&
+	    (event->irqflags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))) {
+		value = gpiod_get_raw_value_cansleep(event->desc);
+		if (((event->irqflags & IRQF_TRIGGER_RISING) && value == 1) ||
+		    ((event->irqflags & IRQF_TRIGGER_FALLING) && value == 0))
+			event->handler(event->irq, event);
+	}
 }
 
 static void acpi_gpiochip_request_irqs(struct acpi_gpio_chip *acpi_gpio)
@@ -1283,3 +1292,28 @@ static int acpi_gpio_handle_deferred_request_irqs(void)
 }
 /* We must use _sync so that this runs after the first deferred_probe run */
 late_initcall_sync(acpi_gpio_handle_deferred_request_irqs);
+
+static const struct dmi_system_id run_edge_events_on_boot_blacklist[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "MINIX"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Z83-4"),
+		}
+	},
+	{} /* Terminating entry */
+};
+
+static int acpi_gpio_setup_params(void)
+{
+	if (run_edge_events_on_boot < 0) {
+		if (dmi_check_system(run_edge_events_on_boot_blacklist))
+			run_edge_events_on_boot = 0;
+		else
+			run_edge_events_on_boot = 1;
+	}
+
+	return 0;
+}
+
+/* Directly after dmi_setup() which runs as core_initcall() */
+postcore_initcall(acpi_gpio_setup_params);

commit 4f78d91c722345de94a3c72da49b9d0d49cb76b8
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Sep 4 10:26:24 2019 -0700

    gpiolib: acpi: make acpi_can_fallback_to_crs() static
    
    It is not used outside gpiolib-acpi.c module, so there is no need to
    export it.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Link: https://lore.kernel.org/r/20190904172624.GA76617@dtor-ws
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index fdee8afa5339..2b6fdc9947f7 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -728,6 +728,16 @@ static struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 	return ret ? ERR_PTR(ret) : lookup.desc;
 }
 
+static bool acpi_can_fallback_to_crs(struct acpi_device *adev,
+				     const char *con_id)
+{
+	/* Never allow fallback if the device has properties */
+	if (acpi_dev_has_props(adev) || adev->driver_gpios)
+		return false;
+
+	return con_id == NULL;
+}
+
 struct gpio_desc *acpi_find_gpio(struct device *dev,
 				 const char *con_id,
 				 unsigned int idx,
@@ -1264,15 +1274,6 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 	return count ? count : -ENOENT;
 }
 
-bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
-{
-	/* Never allow fallback if the device has properties */
-	if (acpi_dev_has_props(adev) || adev->driver_gpios)
-		return false;
-
-	return con_id == NULL;
-}
-
 /* Run deferred acpi_gpiochip_request_irqs() */
 static int acpi_gpio_handle_deferred_request_irqs(void)
 {

commit 2838bf941b120ec846a3903db13e319368d51b08
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jul 30 13:43:37 2019 +0300

    gpiolib-acpi: Move acpi_dev_add_driver_gpios() et al to consumer.h
    
    The API, which belongs to GPIO library, is foreign to ACPI headers. Earlier
    we moved out I²C out of the latter, and now it's time for
    acpi_dev_add_driver_gpios() et al.
    
    For time being the acpi_gpio_get_irq_resource() and acpi_dev_gpio_irq_get()
    are left untouched as they need more thought about.
    
    Note, it requires uninline acpi_dev_remove_driver_gpios() to keep purity of
    consumer.h.
    
    Cc: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Cc: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Cc: Jie Yang <yang.jie@linux.intel.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: alsa-devel@alsa-project.org (moderated list:INTEL ASoC DRIVERS)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190730104337.21235-3-andriy.shevchenko@linux.intel.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d54fc6e7c8a9..fdee8afa5339 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -383,6 +383,13 @@ int acpi_dev_add_driver_gpios(struct acpi_device *adev,
 }
 EXPORT_SYMBOL_GPL(acpi_dev_add_driver_gpios);
 
+void acpi_dev_remove_driver_gpios(struct acpi_device *adev)
+{
+	if (adev)
+		adev->driver_gpios = NULL;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_remove_driver_gpios);
+
 static void devm_acpi_dev_release_driver_gpios(struct device *dev, void *res)
 {
 	acpi_dev_remove_driver_gpios(ACPI_COMPANION(dev));

commit 77cb907abe6c4b399ad77f9b6c1d77d44a435de3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jul 30 13:43:36 2019 +0300

    gpiolib: acpi: Split ACPI stuff to gpiolib-acpi.h
    
    This is a follow up to the commit
    
      f626d6dfb709 ("gpio: of: Break out OF-only code")
    
    which broke down OF parts of GPIO library. Here we do the similar to ACPI.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190730104337.21235-2-andriy.shevchenko@linux.intel.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 39f2f9035c11..d54fc6e7c8a9 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -18,6 +18,7 @@
 #include <linux/pinctrl/pinctrl.h>
 
 #include "gpiolib.h"
+#include "gpiolib-acpi.h"
 
 /**
  * struct acpi_gpio_event - ACPI GPIO event handler data

commit 5923ea6c2ce626f0aa8a547d5b7e5fce705dd3dc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Apr 26 14:40:18 2019 +0200

    gpio: pass lookup and descriptor flags to request_own
    
    When a gpio_chip wants to request a descriptor from itself
    using gpiochip_request_own_desc() it needs to be able to specify
    fully how to use the descriptor, notably line inversion
    semantics. The workaround in the gpiolib.c can be removed
    and cases (such as SPI CS) where we need at times to request
    a GPIO with line inversion semantics directly on a chip for
    workarounds, can be fully supported with this call.
    
    Fix up some users of the API that weren't really using the
    last flag to set up the line as input or output properly
    but instead just calling direction setting explicitly
    after requesting the line.
    
    Cc: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index c9fc9e232aaf..39f2f9035c11 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -217,14 +217,13 @@ static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
 	if (!handler)
 		return AE_OK;
 
-	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event", 0);
+	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event",
+					 GPIO_ACTIVE_HIGH, GPIOD_IN);
 	if (IS_ERR(desc)) {
 		dev_err(chip->parent, "Failed to request GPIO\n");
 		return AE_ERROR;
 	}
 
-	gpiod_direction_input(desc);
-
 	ret = gpiochip_lock_as_irq(chip, pin);
 	if (ret) {
 		dev_err(chip->parent, "Failed to lock GPIO as interrupt\n");
@@ -951,6 +950,7 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 			const char *label = "ACPI:OpRegion";
 
 			desc = gpiochip_request_own_desc(chip, pin, label,
+							 GPIO_ACTIVE_HIGH,
 							 flags);
 			if (IS_ERR(desc)) {
 				status = AE_ERROR;

commit 2d3b6db122ce9aa0a0460e618516e6bfa8eef329
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 10 18:39:21 2019 +0300

    gpiolib: acpi: Respect pin bias setting
    
    For now, we don't take into account the pin bias settings supplied by ACPI.
    This change is targeting the mentioned gap.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 9c6ebaaa02fe..c9fc9e232aaf 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -528,6 +528,17 @@ acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, struct acpi_gpio_info *inf
 int acpi_gpio_update_gpiod_lookup_flags(unsigned long *lookupflags,
 					struct acpi_gpio_info *info)
 {
+	switch (info->pin_config) {
+	case ACPI_PIN_CONFIG_PULLUP:
+		*lookupflags |= GPIO_PULL_UP;
+		break;
+	case ACPI_PIN_CONFIG_PULLDOWN:
+		*lookupflags |= GPIO_PULL_DOWN;
+		break;
+	default:
+		break;
+	}
+
 	if (info->polarity == GPIO_ACTIVE_LOW)
 		*lookupflags |= GPIO_ACTIVE_LOW;
 
@@ -567,6 +578,7 @@ static int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)
 
 		lookup->desc = acpi_get_gpiod(agpio->resource_source.string_ptr,
 					      agpio->pin_table[pin_index]);
+		lookup->info.pin_config = agpio->pin_config;
 		lookup->info.gpioint = gpioint;
 
 		/*

commit 606be34440ee3e6da3799691fcab7b69e1ad06cd
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 10 18:39:20 2019 +0300

    gpiolib: acpi: Add acpi_gpio_update_gpiod_lookup_flags() helper
    
    This helper consolidates all settings of GPIO descriptor lookup flags and
    quirks in the future if any.
    
    No functional change intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 878c7a7dea8b..9c6ebaaa02fe 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -525,6 +525,15 @@ acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, struct acpi_gpio_info *inf
 	return ret;
 }
 
+int acpi_gpio_update_gpiod_lookup_flags(unsigned long *lookupflags,
+					struct acpi_gpio_info *info)
+{
+	if (info->polarity == GPIO_ACTIVE_LOW)
+		*lookupflags |= GPIO_ACTIVE_LOW;
+
+	return 0;
+}
+
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
@@ -745,10 +754,8 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 		return ERR_PTR(-ENOENT);
 	}
 
-	if (info.polarity == GPIO_ACTIVE_LOW)
-		*lookupflags |= GPIO_ACTIVE_LOW;
-
 	acpi_gpio_update_gpiod_flags(dflags, &info);
+	acpi_gpio_update_gpiod_lookup_flags(lookupflags, &info);
 	return desc;
 }
 

commit 24a49543336dbaecb83862a17f6a05d53ec2592f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 10 18:39:19 2019 +0300

    gpiolib: acpi: Set pin value, based on bias, more accurately
    
    ACPI GpioIo() resource may have different bias settings.
    For now, we distinguish only PullUp() setting in order to configure
    the initial state of a pin.
    
    Take into consideration the rest of the possible choices as well,
    i.e. PullDown, PullNone and PullDefault, when configuring the initial state
    of the pin.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 36cd9abe5e55..878c7a7dea8b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -444,8 +444,6 @@ static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
 static enum gpiod_flags
 acpi_gpio_to_gpiod_flags(const struct acpi_resource_gpio *agpio)
 {
-	bool pull_up = agpio->pin_config == ACPI_PIN_CONFIG_PULLUP;
-
 	switch (agpio->io_restriction) {
 	case ACPI_IO_RESTRICT_INPUT:
 		return GPIOD_IN;
@@ -454,16 +452,26 @@ acpi_gpio_to_gpiod_flags(const struct acpi_resource_gpio *agpio)
 		 * ACPI GPIO resources don't contain an initial value for the
 		 * GPIO. Therefore we deduce that value from the pull field
 		 * instead. If the pin is pulled up we assume default to be
-		 * high, otherwise low.
+		 * high, if it is pulled down we assume default to be low,
+		 * otherwise we leave pin untouched.
 		 */
-		return pull_up ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;
+		switch (agpio->pin_config) {
+		case ACPI_PIN_CONFIG_PULLUP:
+			return GPIOD_OUT_HIGH;
+		case ACPI_PIN_CONFIG_PULLDOWN:
+			return GPIOD_OUT_LOW;
+		default:
+			break;
+		}
 	default:
-		/*
-		 * Assume that the BIOS has configured the direction and pull
-		 * accordingly.
-		 */
-		return GPIOD_ASIS;
+		break;
 	}
+
+	/*
+	 * Assume that the BIOS has configured the direction and pull
+	 * accordingly.
+	 */
+	return GPIOD_ASIS;
 }
 
 static int

commit 80c8d927dacc436963af7c0da711578e8c122db8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 10 18:39:18 2019 +0300

    gpiolib: acpi: Change type of dflags
    
    Most of the code inside GPIO library is using enum gpiod_flags.
    Some of the function still operate with unsigned int.
    
    In order to be more consistent and better type checking, convert
    acpi_gpiochip_parse_own_gpio() to use enum gpiod_flags instead of
    unsigned int.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 6ee929d90a6a..36cd9abe5e55 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1001,7 +1001,7 @@ acpi_gpiochip_parse_own_gpio(struct acpi_gpio_chip *achip,
 			     struct fwnode_handle *fwnode,
 			     const char **name,
 			     unsigned long *lflags,
-			     unsigned int *dflags)
+			     enum gpiod_flags *dflags)
 {
 	struct gpio_chip *chip = achip->chip;
 	struct gpio_desc *desc;
@@ -1045,7 +1045,7 @@ static void acpi_gpiochip_scan_gpios(struct acpi_gpio_chip *achip)
 
 	device_for_each_child_node(chip->parent, fwnode) {
 		unsigned long lflags;
-		unsigned int dflags;
+		enum gpiod_flags dflags;
 		struct gpio_desc *desc;
 		const char *name;
 		int ret;

commit 2d6c06f5a4094ab4ea15b63af72d2dab74e9415a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 10 18:39:17 2019 +0300

    gpiolib: Introduce GPIO_LOOKUP_FLAGS_DEFAULT
    
    Since GPIO library operates with enumerator when it's subject to handle
    the GPIO lookup flags, it will be better to clearly see what default means.
    
    Thus, introduce GPIO_LOOKUP_FLAGS_DEFAULT entry to describe
    the default assumptions.
    
    While here, replace 0 by newly introduced constant.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 962bdd89cd8f..6ee929d90a6a 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -819,6 +819,7 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 			return PTR_ERR(desc);
 
 		if (info.gpioint && idx++ == index) {
+			unsigned long lflags = GPIO_LOOKUP_FLAGS_DEFAULT;
 			char label[32];
 			int irq;
 
@@ -830,7 +831,7 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 				return irq;
 
 			snprintf(label, sizeof(label), "GpioInt() %d", index);
-			ret = gpiod_configure_flags(desc, label, 0, info.flags);
+			ret = gpiod_configure_flags(desc, label, lflags, info.flags);
 			if (ret < 0)
 				return ret;
 
@@ -1007,7 +1008,7 @@ acpi_gpiochip_parse_own_gpio(struct acpi_gpio_chip *achip,
 	u32 gpios[2];
 	int ret;
 
-	*lflags = 0;
+	*lflags = GPIO_LOOKUP_FLAGS_DEFAULT;
 	*dflags = 0;
 	*name = NULL;
 

commit fed7026adc7c3a67f992d28d7a5309ff749d3776
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 10 18:39:16 2019 +0300

    gpiolib: Make use of enum gpio_lookup_flags consistent
    
    The library uses enum gpio_lookup_flags to define the possible
    characteristics of GPIO pin. Since enumerator listed only individual
    bits the common use of it is in a form of a bitmask of
    gpio_lookup_flags GPIO_* values. The more correct type for this is
    unsigned long.
    
    Due to above convert all users to use unsigned long instead of
    enum gpio_lookup_flags except enumerator definition.
    
    While here, make field and parameter descriptions consistent as well.
    
    Suggested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index e9ddf66f2d14..962bdd89cd8f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -696,7 +696,7 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 				 const char *con_id,
 				 unsigned int idx,
 				 enum gpiod_flags *dflags,
-				 enum gpio_lookup_flags *lookupflags)
+				 unsigned long *lookupflags)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
 	struct acpi_gpio_info info;
@@ -995,9 +995,12 @@ static void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)
 	}
 }
 
-static struct gpio_desc *acpi_gpiochip_parse_own_gpio(
-	struct acpi_gpio_chip *achip, struct fwnode_handle *fwnode,
-	const char **name, unsigned int *lflags, unsigned int *dflags)
+static struct gpio_desc *
+acpi_gpiochip_parse_own_gpio(struct acpi_gpio_chip *achip,
+			     struct fwnode_handle *fwnode,
+			     const char **name,
+			     unsigned long *lflags,
+			     unsigned int *dflags)
 {
 	struct gpio_chip *chip = achip->chip;
 	struct gpio_desc *desc;
@@ -1040,7 +1043,8 @@ static void acpi_gpiochip_scan_gpios(struct acpi_gpio_chip *achip)
 	struct fwnode_handle *fwnode;
 
 	device_for_each_child_node(chip->parent, fwnode) {
-		unsigned int lflags, dflags;
+		unsigned long lflags;
+		unsigned int dflags;
 		struct gpio_desc *desc;
 		const char *name;
 		int ret;

commit 85edcd01a902885fcb7bc02b7fc0f6e6a01b9386
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Mar 30 00:33:45 2019 +0300

    gpiolib: acpi: Fix references in kernel doc and amend
    
    This patch does the following bunch of changes:
     - append () to the functions for reference
     - convert gpiochip(s) -> GPIO chip(s)
     - add a note about returned error code type [acpi_find_gpio()]
     - move long summary to a description [acpi_gpio_count()]
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 30d0baf7ddae..e9ddf66f2d14 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -24,13 +24,13 @@
  *
  * @node:	  list-entry of the events list of the struct acpi_gpio_chip
  * @handle:	  handle of ACPI method to execute when the IRQ triggers
- * @handler:	  irq_handler to pass to request_irq when requesting the IRQ
- * @pin:	  GPIO pin number on the gpio_chip
- * @irq:	  Linux IRQ number for the event, for request_ / free_irq
- * @irqflags:     flags to pass to request_irq when requesting the IRQ
+ * @handler:	  handler function to pass to request_irq() when requesting the IRQ
+ * @pin:	  GPIO pin number on the struct gpio_chip
+ * @irq:	  Linux IRQ number for the event, for request_irq() / free_irq()
+ * @irqflags:	  flags to pass to request_irq() when requesting the IRQ
  * @irq_is_wake:  If the ACPI flags indicate the IRQ is a wakeup source
- * @irq_requested:True if request_irq has been done
- * @desc:	  gpio_desc for the GPIO pin for this event
+ * @irq_requested:True if request_irq() has been done
+ * @desc:	  struct gpio_desc for the GPIO pin for this event
  */
 struct acpi_gpio_event {
 	struct list_head node;
@@ -65,10 +65,10 @@ struct acpi_gpio_chip {
 };
 
 /*
- * For gpiochips which call acpi_gpiochip_request_interrupts() before late_init
+ * For GPIO chips which call acpi_gpiochip_request_interrupts() before late_init
  * (so builtin drivers) we register the ACPI GpioInt IRQ handlers from a
- * late_initcall_sync handler, so that other builtin drivers can register their
- * OpRegions before the event handlers can run.  This list contains gpiochips
+ * late_initcall_sync() handler, so that other builtin drivers can register their
+ * OpRegions before the event handlers can run. This list contains GPIO chips
  * for which the acpi_gpiochip_request_irqs() call has been deferred.
  */
 static DEFINE_MUTEX(acpi_gpio_deferred_req_irqs_lock);
@@ -90,7 +90,7 @@ static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
  *
  * Return: GPIO descriptor to use with Linux generic GPIO API, or ERR_PTR
  * error value. Specifically returns %-EPROBE_DEFER if the referenced GPIO
- * controller does not have gpiochip registered at the moment. This is to
+ * controller does not have GPIO chip registered at the moment. This is to
  * support probe deferral.
  */
 static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
@@ -287,9 +287,9 @@ static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
  *
  * ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
  * handled by ACPI event methods which need to be called from the GPIO
- * chip's interrupt handler. acpi_gpiochip_request_interrupts finds out which
- * gpio pins have acpi event methods and assigns interrupt handlers that calls
- * the acpi event methods for those pins.
+ * chip's interrupt handler. acpi_gpiochip_request_interrupts() finds out which
+ * GPIO pins have ACPI event methods and assigns interrupt handlers that calls
+ * the ACPI event methods for those pins.
  */
 void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 {
@@ -653,7 +653,7 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
  * that case @index is used to select the GPIO entry in the property value
  * (in case of multiple).
  *
- * If the GPIO cannot be translated or there is an error an ERR_PTR is
+ * If the GPIO cannot be translated or there is an error, an ERR_PTR is
  * returned.
  *
  * Note: if the GPIO resource has multiple entries in the pin list, this
@@ -751,10 +751,13 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
  * @index: index of GpioIo/GpioInt resource (starting from %0)
  * @info: info pointer to fill in (optional)
  *
- * If @fwnode is an ACPI device object, call %acpi_get_gpiod_by_index() for it.
- * Otherwise (ie. it is a data-only non-device object), use the property-based
+ * If @fwnode is an ACPI device object, call acpi_get_gpiod_by_index() for it.
+ * Otherwise (i.e. it is a data-only non-device object), use the property-based
  * GPIO lookup to get to the GPIO resource with the relevant information and use
  * that to obtain the GPIO descriptor to return.
+ *
+ * If the GPIO cannot be translated or there is an error an ERR_PTR is
+ * returned.
  */
 struct gpio_desc *acpi_node_get_gpiod(struct fwnode_handle *fwnode,
 				      const char *propname, int index,
@@ -1158,11 +1161,13 @@ static int acpi_find_gpio_count(struct acpi_resource *ares, void *data)
 }
 
 /**
- * acpi_gpio_count - return the number of GPIOs associated with a
- *		device / function or -ENOENT if no GPIO has been
- *		assigned to the requested function.
- * @dev:	GPIO consumer, can be NULL for system-global GPIOs
+ * acpi_gpio_count - count the GPIOs associated with a device / function
+ * @dev:	GPIO consumer, can be %NULL for system-global GPIOs
  * @con_id:	function within the GPIO consumer
+ *
+ * Return:
+ * The number of GPIOs associated with a device / function or %-ENOENT,
+ * if no GPIO has been assigned to the requested function.
  */
 int acpi_gpio_count(struct device *dev, const char *con_id)
 {

commit 3601fe43e8164f67a8de3de8e988bfcb3a94af46
Merge: cf2e8c544cd3 d01849f7deba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 8 10:09:53 2019 -0800

    Merge tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v5.1 cycle:
    
      Core changes:
    
       - The big change this time around is the irqchip handling in the
         qualcomm pin controllers, closely coupled with the gpiochip. This
         rework, in a classic fall-between-the-chairs fashion has been
         sidestepped for too long.
    
         The Qualcomm IRQchips using the SPMI and SSBI transport mechanisms
         have been rewritten to use hierarchical irqchip. This creates the
         base from which I intend to gradually pull support for hierarchical
         irqchips into the gpiolib irqchip helpers to cut down on duplicate
         code.
    
         We have too many hacks in the kernel because people have been
         working around the missing hierarchical irqchip for years, and once
         it was there, noone understood it for a while. We are now slowly
         adapting to using it.
    
         This is why this pull requests include changes to MFD, SPMI,
         IRQchip core and some ARM Device Trees pertaining to the Qualcomm
         chip family. Since Qualcomm have so many chips and such large
         deployments it is paramount that this platform gets this right, and
         now it (hopefully) does.
    
       - Core support for pull-up and pull-down configuration, also from the
         device tree. When a simple GPIO chip supports an "off or on" pull-up
         or pull-down resistor, we provide a way to set this up using
         machine descriptors or device tree.
    
         If more elaborate control of pull up/down (such as resistance shunt
         setting) is required, drivers should be phased over to use pin
         control. We do not yet provide a userspace ABI for this pull
         up-down setting but I suspect the makers are going to ask for it
         soon enough. PCA953x is the first user of this new API.
    
       - The GPIO mockup driver has been revamped after some discussion
         improving the IRQ simulator in the process.
    
         The idea is to make it possible to use the mockup for both testing
         and virtual prototyping, e.g. when you do not yet have a GPIO
         expander to play with but really want to get something to develop
         code around before hardware is available. It's neat. The blackbox
         testing usecase is currently making its way into kernelci.
    
       - ACPI GPIO core preserves non direction flags when updating flags.
    
       - A new device core helper for devm_platform_ioremap_resource() is
         funneled through the GPIO tree with Greg's ACK.
    
      New drivers:
    
       - TQ-Systems QTMX86 GPIO controllers (using port-mapped I/O)
    
       - Gateworks PLD GPIO driver (vaccumed up from OpenWrt)
    
       - AMD G-Series PCH (Platform Controller Hub) GPIO driver.
    
       - Fintek F81804 & F81966 subvariants.
    
       - PCA953x now supports NXP PCAL6416.
    
      Driver improvements:
    
       - IRQ support on the Nintendo Wii (Hollywood) GPIO.
    
       - get_direction() support for the MVEBU driver.
    
       - Set the right output level on SAMA5D2.
    
       - Drop the unused irq trigger setting on the Spreadtrum driver.
    
       - Wakeup support for PCA953x.
    
       - A slew of cleanups in the various Intel drivers"
    
    * tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (110 commits)
      gpio: gpio-omap: fix level interrupt idling
      gpio: amd-fch: Set proper output level for direction_output
      x86: apuv2: remove unused variable
      gpio: pca953x: Use PCA_LATCH_INT
      platform/x86: fix PCENGINES_APU2 Kconfig warning
      gpio: pca953x: Fix dereference of irq data in shutdown
      gpio: amd-fch: Fix type error found by sparse
      gpio: amd-fch: Drop const from resource
      gpio: mxc: add check to return defer probe if clock tree NOT ready
      gpio: ftgpio: Register per-instance irqchip
      gpio: ixp4xx: Add DT bindings
      x86: pcengines apuv2 gpio/leds/keys platform driver
      gpio: AMD G-Series PCH gpio driver
      drivers: depend on HAS_IOMEM for devm_platform_ioremap_resource()
      gpio: tqmx86: Set proper output level for direction_output
      gpio: sprd: Change to use SoC compatible string
      gpio: sprd: Use SoC compatible string instead of wildcard string
      gpio: of: Handle both enable-gpio{,s}
      gpio: of: Restrict enable-gpio quirk to regulator-gpio
      gpio: davinci: use devm_platform_ioremap_resource()
      ...

commit da2577fe63f865cd9dc785a42c29c0071f567a35
Merge: 542d0e583b7b a634090a0f24
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 6 14:10:46 2019 -0800

    Merge tag 'sound-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "We had again a busy development cycle with many new drivers as well as
      lots of core improvements / cleanups. Let's go for highlights:
    
      ALSA core:
    
       - PCM locking scheme was refactored for reducing a global rwlock
    
       - PCM suspend is handled in the device type PM ops now; lots of
         explicit calls were reduced by this action
    
       - Cleanups about PCM buffer preallocation calls
    
       - Kill NULL device object in memory allocations
    
       - Lots of procfs API cleanups
    
      ASoC core:
    
       - Support for only powering up channels that are actively being used
    
       - Cleanups / fixes of topology API
    
      ASoC drivers:
    
       - MediaTek BTCVSD for a Bluetooth radio chip, which is the first such
         driver we've had upstream!
    
       - Quite a few improvements to simplify the generic card drivers,
         especially the merge of the SCU cards into the main generic drivers
    
       - Lots of fixes for probing on Intel systems to follow more standard
         styles
    
       - A big refresh and cleanup of the Samsung drivers
    
       - New drivers: Asahi Kasei Microdevices AK4497, Cirrus Logic CS4341
         and CS35L26, Google ChromeOS embedded controllers, Ingenic JZ4725B,
         MediaTek BTCVSD, MT8183 and MT6358, NXP MICFIL, Rockchip RK3328,
         Spreadtrum DMA controllers, Qualcomm WCD9335, Xilinx S/PDIF and PCM
         formatters
    
      ALSA drivers:
    
       - Improvements of Tegra HD-audio controller driver for supporting new
         chips
    
       - HD-audio codec quirks for ALC294 S4 resume, ASUS laptop, Chrome
         headset button support and Dell workstations
    
       - Improved DSD support on USB-audio
    
       - Quirk for MOTU MicroBook II USB-audio
    
       - Support for Fireface UCX support and Solid State Logic Duende
         Classic/Mini"
    
    * tag 'sound-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (461 commits)
      ALSA: usb-audio: Add quirk for MOTU MicroBook II
      ASoC: stm32: i2s: skip useless write in slave mode
      ASoC: stm32: i2s: fix race condition in irq handler
      ASoC: stm32: i2s: remove useless callback
      ASoC: stm32: i2s: fix dma configuration
      ASoC: stm32: i2s: fix stream count management
      ASoC: stm32: i2s: fix 16 bit format support
      ASoC: stm32: i2s: fix IRQ clearing
      ASoC: qcom: Kconfig: fix dependency for sdm845
      ASoC: Intel: Boards: Add Maxim98373 support
      ASoC: rsnd: gen: fix SSI9 4/5/6/7 busif related register address
      ALSA: firewire-motu: fix construction of PCM frame for capture direction
      ALSA: bebob: use more identical mod_alias for Saffire Pro 10 I/O against Liquid Saffire 56
      ALSA: hda: Extend i915 component bind timeout
      ASoC: wm_adsp: Improve logging messages
      ASoC: wm_adsp: Add support for multiple compressed buffers
      ASoC: wm_adsp: Refactor compress stream initialisation
      ASoC: wm_adsp: Reorder some functions for improved clarity
      ASoC: wm_adsp: Factor out stripping padding from ADSP data
      ASoC: cs35l36: Fix an IS_ERR() vs NULL checking bug
      ...

commit 7db52b5ace8f2200707daca5019453848d4e7a00
Merge: 886ca88be6b3 6b31c01651c2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 4 11:15:30 2019 +0100

    Merge branch 'acpica'
    
    * acpica:
      ACPICA: Update version to 20190215
      ACPI/ACPICA: Trivial: fix spelling mistakes and fix whitespace formatting
      ACPICA: ACPI 6.3: add GTDT Revision 3 support
      ACPICA: ACPI 6.3: HMAT updates
      ACPICA: ACPI 6.3: PPTT add additional fields in Processor Structure Flags
      ACPICA: ACPI 6.3: add Error Disconnect Recover Notification value
      ACPICA: ACPI 6.3: MADT: add support for statistical profiling in GICC
      ACPICA: ACPI 6.3: add PCC operation region support for AML interpreter
      ACPICA: ACPI 6.3: SRAT: add Generic Affinity Structure subtable
      ACPICA: ACPI 6.3: Add Trigger order to PCC Identifier structure in PDTT
      ACPICA: ACPI 6.3: Adding predefined methods _NBS, _NCH, _NIC, _NIH, and _NIG
      ACPICA: Update/clarify messages for control method failures
      ACPICA: Debugger: Fix possible fault with the "test objects" command
      ACPICA: Interpreter: Emit warning for creation of a zero-length op region
      ACPICA: Remove legacy module-level code support
      ACPICA: Get rid of acpi_sleep_dispatch()
      ACPICA: Update version to 20190108
      ACPICA: All acpica: Update copyrights to 2019
      ACPICA: acpiexec: Add option to dump extra info for memory leaks
      ACPICA: Convert more ACPI errors to firmware errors

commit c163f90cc8620716b08ac7987c4c4ebf16444fd5
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Feb 15 13:36:19 2019 -0800

    ACPI/ACPICA: Trivial: fix spelling mistakes and fix whitespace formatting
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 48534bda73d3..22955de8b997 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -897,7 +897,7 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		 * event but only if the access here is ACPI_READ. In that
 		 * case we "borrow" the event GPIO instead.
 		 */
-		if (!found && agpio->sharable == ACPI_SHARED &&
+		if (!found && agpio->shareable == ACPI_SHARED &&
 		     function == ACPI_READ) {
 			struct acpi_gpio_event *event;
 

commit 8fab3d713ca36bf4ad4dadec0bf38f5e70b8999d
Merge: 760a160e8b89 68b7587baabf
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Feb 17 21:59:33 2019 +0100

    Merge tag 'gpio-v5.1-updates-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/brgl/linux into devel
    
    gpio updates for v5.1
    
    - support for a new variant of pca953x
    - documentation fix from Wolfram
    - some tegra186 name changes
    - two minor fixes for madera and altera-a10sr

commit 4d1f7a6eabd45639d9de22a8a004f3c208d13c1a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Feb 6 22:49:46 2019 +0200

    gpiolib: acpi: Introduce ACPI_GPIO_QUIRK_ONLY_GPIOIO
    
    New quirk enforces search for GPIO based on its type,
    i.e. iterate over GpioIo resources only.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 259cf6ab969b..4d291b75cb9f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -530,17 +530,24 @@ static int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)
 	if (ares->type != ACPI_RESOURCE_TYPE_GPIO)
 		return 1;
 
-	if (lookup->n++ == lookup->index && !lookup->desc) {
+	if (!lookup->desc) {
 		const struct acpi_resource_gpio *agpio = &ares->data.gpio;
-		int pin_index = lookup->pin_index;
+		bool gpioint = agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;
+		int pin_index;
 
+		if (lookup->info.quirks & ACPI_GPIO_QUIRK_ONLY_GPIOIO && gpioint)
+			lookup->index++;
+
+		if (lookup->n++ != lookup->index)
+			return 1;
+
+		pin_index = lookup->pin_index;
 		if (pin_index >= agpio->pin_table_length)
 			return 1;
 
 		lookup->desc = acpi_get_gpiod(agpio->resource_source.string_ptr,
 					      agpio->pin_table[pin_index]);
-		lookup->info.gpioint =
-			agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;
+		lookup->info.gpioint = gpioint;
 
 		/*
 		 * Polarity and triggering are only specified for GpioInt

commit 876811f7c34eff986462ed2def81f4ecfbcef2ec
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Jan 25 19:03:02 2019 +0200

    gpiolib: acpi: Correct kernel doc of struct acpi_gpio_event
    
    The checker complains during build
    
    gpiolib-acpi.c:45: warning: Function parameter or member 'irq_requested' not described in 'acpi_gpio_event'
    
    because the typo in the field description.
    
    Fix the name to have documentation up-to-date.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index f0763e0e02f1..3401823427f6 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -29,7 +29,7 @@
  * @irq:	  Linux IRQ number for the event, for request_ / free_irq
  * @irqflags:     flags to pass to request_irq when requesting the IRQ
  * @irq_is_wake:  If the ACPI flags indicate the IRQ is a wakeup source
- * @is_requested: True if request_irq has been done
+ * @irq_requested:True if request_irq has been done
  * @desc:	  gpio_desc for the GPIO pin for this event
  */
 struct acpi_gpio_event {

commit 72893f0c6bd399ce84e3c1c9fc69d234fe37d098
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Dec 31 21:55:21 2018 +0100

    gpiolib-acpi: Preserve non direction flags when updating gpiod_flags
    
    __acpi_gpio_update_gpiod_flags purpose is to make the gpiod_flags used
    when requesting a GPIO match the restrictions from the ACPI resource,
    as stored in acpi_gpio_info.flags.
    
    But acpi_gpio_info.flags only contains direction info, and the
    requester may have passed in special non-direction flags like
    GPIOD_FLAGS_BIT_NONEXCLUSIVE, which we currently clobber.
    
    This commit modifies __acpi_gpio_update_gpiod_flags to preserve these
    special flags, so that a requested of an ACPI GPIO can e.g. pass
    GPIOD_FLAGS_BIT_NONEXCLUSIV and have it work as intended.
    
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 48534bda73d3..f0763e0e02f1 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -474,6 +474,9 @@ acpi_gpio_to_gpiod_flags(const struct acpi_resource_gpio *agpio)
 static int
 __acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, enum gpiod_flags update)
 {
+	const enum gpiod_flags mask =
+		GPIOD_FLAGS_BIT_DIR_SET | GPIOD_FLAGS_BIT_DIR_OUT |
+		GPIOD_FLAGS_BIT_DIR_VAL;
 	int ret = 0;
 
 	/*
@@ -494,7 +497,7 @@ __acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, enum gpiod_flags update)
 		if (((*flags & GPIOD_FLAGS_BIT_DIR_SET) && (diff & GPIOD_FLAGS_BIT_DIR_OUT)) ||
 		    ((*flags & GPIOD_FLAGS_BIT_DIR_OUT) && (diff & GPIOD_FLAGS_BIT_DIR_VAL)))
 			ret = -EINVAL;
-		*flags = update;
+		*flags = (*flags & ~mask) | (update & mask);
 	}
 	return ret;
 }

commit 862523297778775a0543110dcbf2ca832782f675
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Nov 28 17:57:56 2018 +0100

    gpiolib-acpi: Remove unnecessary WARN_ON from acpi_gpiochip_free_interrupts
    
    acpi_gpiochip_alloc_event only continues allocating an event and adding
    it to the list if gpiochip_request_own_desc does not return an error.
    So events with an error desc are never placed on the events list and this
    check is really not necessary.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 48534bda73d3..259cf6ab969b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -357,8 +357,6 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	mutex_unlock(&acpi_gpio_deferred_req_irqs_lock);
 
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
-		struct gpio_desc *desc;
-
 		if (event->irq_requested) {
 			if (event->irq_is_wake)
 				disable_irq_wake(event->irq);
@@ -366,11 +364,8 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 			free_irq(event->irq, event);
 		}
 
-		desc = event->desc;
-		if (WARN_ON(IS_ERR(desc)))
-			continue;
 		gpiochip_unlock_as_irq(chip, event->pin);
-		gpiochip_free_own_desc(desc);
+		gpiochip_free_own_desc(event->desc);
 		list_del(&event->node);
 		kfree(event);
 	}

commit 24dc83635ffe3c93d8122099a83ee228c9b7e4f7
Merge: 7e59fad9c9d1 a7c23f8d154f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 20:00:21 2018 -0800

    Merge tag 'gpio-v4.21-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.21 kernel series.
    
      Core changes:
    
       - Some core changes are already in outside of this pull request as
         they came through the regulator tree, most notably
         devm_gpiod_unhinge() that removes devres refcount management from a
         GPIO descriptor. This is needed in subsystems such as regulators
         where the regulator core need to take over the reference counting
         and lifecycle management for a GPIO descriptor.
    
       - We dropped devm_gpiochip_remove() and devm_gpio_chip_match() as
         nothing needs it. We can bring it back if need be.
    
       - Add a global TODO so people see where we are going. This helps
         setting the direction now that we are two GPIO maintainers.
    
       - Handle the MMC CD/WP properties in the device tree core. (The bulk
         of patches activating this code is already merged through the
         MMC/SD tree.)
    
       - Augment gpiochip_request_own_desc() to pass a flag so we as
         gpiochips can request lines as active low or open drain etc even
         from ourselves.
    
      New drivers:
    
       - New driver for Cadence GPIO blocks.
    
       - New driver for Atmel SAMA5D2 PIOBU GPIO lines.
    
      Driver improvements:
    
       - A major refactoring of the PCA953x driver - this driver has been
         around for ages, and is now modernized to reduce code duplication
         that has stacked up and is using regmap to read write and cache
         registers.
    
       - Intel drivers are now maintained in a separate tree and start with
         a round of cleanups and unifications"
    
    * tag 'gpio-v4.21-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (99 commits)
      gpio: sama5d2-piobu: Depend on OF_GPIO
      gpio: Add Cadence GPIO driver
      dt-bindings: gpio: Add bindings for Cadence GPIO
      gpiolib-acpi: remove unused variable 'err', cleans up build warning
      gpio: mxs: read pin level directly instead of using .get
      gpio: aspeed: remove duplicated statement
      gpio: add driver for SAMA5D2 PIOBU pins
      dt-bindings: arm: atmel: describe SECUMOD usage as a GPIO controller
      gpio/mmc/of: Respect polarity in the device tree
      dt-bindings: gpio: rcar: Add r8a774c0 (RZ/G2E) support
      memory: omap-gpmc: Get the header of the enum
      ARM: omap1: Fix new user of gpiochip_request_own_desc()
      gpio: pca953x: Add regmap dependency for PCA953x driver
      gpio: raspberrypi-exp: decrease refcount on firmware dt node
      gpiolib: Fix return value of gpio_to_desc() stub if !GPIOLIB
      gpio: pca953x: Restore registers after suspend/resume cycle
      gpio: pca953x: Zap single use of pca953x_read_single()
      gpio: pca953x: Zap ad-hoc reg_output cache
      gpio: pca953x: Zap ad-hoc reg_direction cache
      gpio: pca953x: Perform basic regmap conversion
      ...

commit 6c905f91d8ae103cc0767267509a456f961a279d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Dec 18 12:28:02 2018 +0000

    gpiolib-acpi: remove unused variable 'err', cleans up build warning
    
    Variable err is defined but never used. Remove it. Cleans up warning:
    
    warning: unused variable ‘err’ [-Wunused-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 722a9befa8a9..d7ac8b9ab7c9 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -882,7 +882,6 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		if (!found) {
 			enum gpiod_flags flags = acpi_gpio_to_gpiod_flags(agpio);
 			const char *label = "ACPI:OpRegion";
-			int err;
 
 			desc = gpiochip_request_own_desc(chip, pin, label,
 							 flags);

commit 21abf103818a4735e80fb0ab03934bed8ae9a028
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 4 13:31:45 2018 +0200

    gpio: Pass a flag to gpiochip_request_own_desc()
    
    Before things go out of hand, make it possible to pass
    flags when requesting "own" descriptors from a gpio_chip.
    This is necessary if the chip wants to request a GPIO with
    active low semantics, for example.
    
    Cc: Janusz Krzysztofik <jmkrzyszt@gmail.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Roger Quadros <rogerq@ti.com>
    Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 55b72fbe1631..722a9befa8a9 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -167,7 +167,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	if (!handler)
 		return AE_OK;
 
-	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event");
+	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event", 0);
 	if (IS_ERR(desc)) {
 		dev_err(chip->parent, "Failed to request GPIO\n");
 		return AE_ERROR;
@@ -884,21 +884,14 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 			const char *label = "ACPI:OpRegion";
 			int err;
 
-			desc = gpiochip_request_own_desc(chip, pin, label);
+			desc = gpiochip_request_own_desc(chip, pin, label,
+							 flags);
 			if (IS_ERR(desc)) {
 				status = AE_ERROR;
 				mutex_unlock(&achip->conn_lock);
 				goto out;
 			}
 
-			err = gpiod_configure_flags(desc, label, 0, flags);
-			if (err < 0) {
-				status = AE_NOT_CONFIGURED;
-				gpiochip_free_own_desc(desc);
-				mutex_unlock(&achip->conn_lock);
-				goto out;
-			}
-
 			conn = kzalloc(sizeof(*conn), GFP_KERNEL);
 			if (!conn) {
 				status = AE_NO_MEMORY;

commit e59f5e08ece1060073d92c66ded52e1f2c43b5bb
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Nov 28 17:57:55 2018 +0100

    gpiolib-acpi: Only defer request_irq for GpioInt ACPI event handlers
    
    Commit 78d3a92edbfb ("gpiolib-acpi: Register GpioInt ACPI event handlers
    from a late_initcall") deferred the entire acpi_gpiochip_request_interrupt
    call for each event resource.
    
    This means it also delays the gpiochip_request_own_desc(..., "ACPI:Event")
    call. This is a problem if some AML code reads the GPIO pin before we
    run the deferred acpi_gpiochip_request_interrupt, because in that case
    acpi_gpio_adr_space_handler() will already have called
    gpiochip_request_own_desc(..., "ACPI:OpRegion") causing the call from
    acpi_gpiochip_request_interrupt to fail with -EBUSY and we will fail to
    register an event handler.
    
    acpi_gpio_adr_space_handler is prepared for acpi_gpiochip_request_interrupt
    already having claimed the pin, but the other way around does not work.
    
    One example of a problem this causes, is the event handler for the OTG
    ID pin on a Prowise PT301 tablet not registering, keeping the port stuck
    in whatever mode it was in during boot and e.g. only allowing charging
    after a reboot.
    
    This commit fixes this by only deferring the request_irq call and the
    initial run of edge-triggered IRQs instead of deferring all of
    acpi_gpiochip_request_interrupt.
    
    Cc: stable@vger.kernel.org
    Fixes: 78d3a92edbfb ("gpiolib-acpi: Register GpioInt ACPI event ...")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 55b72fbe1631..7f93954c58ea 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -19,11 +19,28 @@
 
 #include "gpiolib.h"
 
+/**
+ * struct acpi_gpio_event - ACPI GPIO event handler data
+ *
+ * @node:	  list-entry of the events list of the struct acpi_gpio_chip
+ * @handle:	  handle of ACPI method to execute when the IRQ triggers
+ * @handler:	  irq_handler to pass to request_irq when requesting the IRQ
+ * @pin:	  GPIO pin number on the gpio_chip
+ * @irq:	  Linux IRQ number for the event, for request_ / free_irq
+ * @irqflags:     flags to pass to request_irq when requesting the IRQ
+ * @irq_is_wake:  If the ACPI flags indicate the IRQ is a wakeup source
+ * @is_requested: True if request_irq has been done
+ * @desc:	  gpio_desc for the GPIO pin for this event
+ */
 struct acpi_gpio_event {
 	struct list_head node;
 	acpi_handle handle;
+	irq_handler_t handler;
 	unsigned int pin;
 	unsigned int irq;
+	unsigned long irqflags;
+	bool irq_is_wake;
+	bool irq_requested;
 	struct gpio_desc *desc;
 };
 
@@ -49,10 +66,10 @@ struct acpi_gpio_chip {
 
 /*
  * For gpiochips which call acpi_gpiochip_request_interrupts() before late_init
- * (so builtin drivers) we register the ACPI GpioInt event handlers from a
+ * (so builtin drivers) we register the ACPI GpioInt IRQ handlers from a
  * late_initcall_sync handler, so that other builtin drivers can register their
  * OpRegions before the event handlers can run.  This list contains gpiochips
- * for which the acpi_gpiochip_request_interrupts() has been deferred.
+ * for which the acpi_gpiochip_request_irqs() call has been deferred.
  */
 static DEFINE_MUTEX(acpi_gpio_deferred_req_irqs_lock);
 static LIST_HEAD(acpi_gpio_deferred_req_irqs_list);
@@ -133,8 +150,42 @@ bool acpi_gpio_get_irq_resource(struct acpi_resource *ares,
 }
 EXPORT_SYMBOL_GPL(acpi_gpio_get_irq_resource);
 
-static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
-						   void *context)
+static void acpi_gpiochip_request_irq(struct acpi_gpio_chip *acpi_gpio,
+				      struct acpi_gpio_event *event)
+{
+	int ret, value;
+
+	ret = request_threaded_irq(event->irq, NULL, event->handler,
+				   event->irqflags, "ACPI:Event", event);
+	if (ret) {
+		dev_err(acpi_gpio->chip->parent,
+			"Failed to setup interrupt handler for %d\n",
+			event->irq);
+		return;
+	}
+
+	if (event->irq_is_wake)
+		enable_irq_wake(event->irq);
+
+	event->irq_requested = true;
+
+	/* Make sure we trigger the initial state of edge-triggered IRQs */
+	value = gpiod_get_raw_value_cansleep(event->desc);
+	if (((event->irqflags & IRQF_TRIGGER_RISING) && value == 1) ||
+	    ((event->irqflags & IRQF_TRIGGER_FALLING) && value == 0))
+		event->handler(event->irq, event);
+}
+
+static void acpi_gpiochip_request_irqs(struct acpi_gpio_chip *acpi_gpio)
+{
+	struct acpi_gpio_event *event;
+
+	list_for_each_entry(event, &acpi_gpio->events, node)
+		acpi_gpiochip_request_irq(acpi_gpio, event);
+}
+
+static acpi_status acpi_gpiochip_alloc_event(struct acpi_resource *ares,
+					     void *context)
 {
 	struct acpi_gpio_chip *acpi_gpio = context;
 	struct gpio_chip *chip = acpi_gpio->chip;
@@ -143,8 +194,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	struct acpi_gpio_event *event;
 	irq_handler_t handler = NULL;
 	struct gpio_desc *desc;
-	unsigned long irqflags;
-	int ret, pin, irq, value;
+	int ret, pin, irq;
 
 	if (!acpi_gpio_get_irq_resource(ares, &agpio))
 		return AE_OK;
@@ -175,8 +225,6 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	gpiod_direction_input(desc);
 
-	value = gpiod_get_value_cansleep(desc);
-
 	ret = gpiochip_lock_as_irq(chip, pin);
 	if (ret) {
 		dev_err(chip->parent, "Failed to lock GPIO as interrupt\n");
@@ -189,64 +237,42 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 		goto fail_unlock_irq;
 	}
 
-	irqflags = IRQF_ONESHOT;
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event)
+		goto fail_unlock_irq;
+
+	event->irqflags = IRQF_ONESHOT;
 	if (agpio->triggering == ACPI_LEVEL_SENSITIVE) {
 		if (agpio->polarity == ACPI_ACTIVE_HIGH)
-			irqflags |= IRQF_TRIGGER_HIGH;
+			event->irqflags |= IRQF_TRIGGER_HIGH;
 		else
-			irqflags |= IRQF_TRIGGER_LOW;
+			event->irqflags |= IRQF_TRIGGER_LOW;
 	} else {
 		switch (agpio->polarity) {
 		case ACPI_ACTIVE_HIGH:
-			irqflags |= IRQF_TRIGGER_RISING;
+			event->irqflags |= IRQF_TRIGGER_RISING;
 			break;
 		case ACPI_ACTIVE_LOW:
-			irqflags |= IRQF_TRIGGER_FALLING;
+			event->irqflags |= IRQF_TRIGGER_FALLING;
 			break;
 		default:
-			irqflags |= IRQF_TRIGGER_RISING |
-				    IRQF_TRIGGER_FALLING;
+			event->irqflags |= IRQF_TRIGGER_RISING |
+					   IRQF_TRIGGER_FALLING;
 			break;
 		}
 	}
 
-	event = kzalloc(sizeof(*event), GFP_KERNEL);
-	if (!event)
-		goto fail_unlock_irq;
-
 	event->handle = evt_handle;
+	event->handler = handler;
 	event->irq = irq;
+	event->irq_is_wake = agpio->wake_capable == ACPI_WAKE_CAPABLE;
 	event->pin = pin;
 	event->desc = desc;
 
-	ret = request_threaded_irq(event->irq, NULL, handler, irqflags,
-				   "ACPI:Event", event);
-	if (ret) {
-		dev_err(chip->parent,
-			"Failed to setup interrupt handler for %d\n",
-			event->irq);
-		goto fail_free_event;
-	}
-
-	if (agpio->wake_capable == ACPI_WAKE_CAPABLE)
-		enable_irq_wake(irq);
-
 	list_add_tail(&event->node, &acpi_gpio->events);
 
-	/*
-	 * Make sure we trigger the initial state of the IRQ when using RISING
-	 * or FALLING.  Note we run the handlers on late_init, the AML code
-	 * may refer to OperationRegions from other (builtin) drivers which
-	 * may be probed after us.
-	 */
-	if (((irqflags & IRQF_TRIGGER_RISING) && value == 1) ||
-	    ((irqflags & IRQF_TRIGGER_FALLING) && value == 0))
-		handler(event->irq, event);
-
 	return AE_OK;
 
-fail_free_event:
-	kfree(event);
 fail_unlock_irq:
 	gpiochip_unlock_as_irq(chip, pin);
 fail_free_desc:
@@ -283,6 +309,9 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	if (ACPI_FAILURE(status))
 		return;
 
+	acpi_walk_resources(handle, "_AEI",
+			    acpi_gpiochip_alloc_event, acpi_gpio);
+
 	mutex_lock(&acpi_gpio_deferred_req_irqs_lock);
 	defer = !acpi_gpio_deferred_req_irqs_done;
 	if (defer)
@@ -293,8 +322,7 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	if (defer)
 		return;
 
-	acpi_walk_resources(handle, "_AEI",
-			    acpi_gpiochip_request_interrupt, acpi_gpio);
+	acpi_gpiochip_request_irqs(acpi_gpio);
 }
 EXPORT_SYMBOL_GPL(acpi_gpiochip_request_interrupts);
 
@@ -331,10 +359,13 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
 		struct gpio_desc *desc;
 
-		if (irqd_is_wakeup_set(irq_get_irq_data(event->irq)))
-			disable_irq_wake(event->irq);
+		if (event->irq_requested) {
+			if (event->irq_is_wake)
+				disable_irq_wake(event->irq);
+
+			free_irq(event->irq, event);
+		}
 
-		free_irq(event->irq, event);
 		desc = event->desc;
 		if (WARN_ON(IS_ERR(desc)))
 			continue;
@@ -1200,23 +1231,16 @@ bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
 	return con_id == NULL;
 }
 
-/* Run deferred acpi_gpiochip_request_interrupts() */
-static int acpi_gpio_handle_deferred_request_interrupts(void)
+/* Run deferred acpi_gpiochip_request_irqs() */
+static int acpi_gpio_handle_deferred_request_irqs(void)
 {
 	struct acpi_gpio_chip *acpi_gpio, *tmp;
 
 	mutex_lock(&acpi_gpio_deferred_req_irqs_lock);
 	list_for_each_entry_safe(acpi_gpio, tmp,
 				 &acpi_gpio_deferred_req_irqs_list,
-				 deferred_req_irqs_list_entry) {
-		acpi_handle handle;
-
-		handle = ACPI_HANDLE(acpi_gpio->chip->parent);
-		acpi_walk_resources(handle, "_AEI",
-				    acpi_gpiochip_request_interrupt, acpi_gpio);
-
-		list_del_init(&acpi_gpio->deferred_req_irqs_list_entry);
-	}
+				 deferred_req_irqs_list_entry)
+		acpi_gpiochip_request_irqs(acpi_gpio);
 
 	acpi_gpio_deferred_req_irqs_done = true;
 	mutex_unlock(&acpi_gpio_deferred_req_irqs_lock);
@@ -1224,4 +1248,4 @@ static int acpi_gpio_handle_deferred_request_interrupts(void)
 	return 0;
 }
 /* We must use _sync so that this runs after the first deferred_probe run */
-late_initcall_sync(acpi_gpio_handle_deferred_request_interrupts);
+late_initcall_sync(acpi_gpio_handle_deferred_request_irqs);

commit bd6bf7c10484f026505814b690104cdef27ed460
Merge: a41efc2a0f68 663569db6476
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 25 06:50:48 2018 -0700

    Merge tag 'pci-v4.20-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - Fix ASPM link_state teardown on removal (Lukas Wunner)
    
     - Fix misleading _OSC ASPM message (Sinan Kaya)
    
     - Make _OSC optional for PCI (Sinan Kaya)
    
     - Don't initialize ASPM link state when ACPI_FADT_NO_ASPM is set
       (Patrick Talbert)
    
     - Remove x86 and arm64 node-local allocation for host bridge structures
       (Punit Agrawal)
    
     - Pay attention to device-specific _PXM node values (Jonathan Cameron)
    
     - Support new Immediate Readiness bit (Felipe Balbi)
    
     - Differentiate between pciehp surprise and safe removal (Lukas Wunner)
    
     - Remove unnecessary pciehp includes (Lukas Wunner)
    
     - Drop pciehp hotplug_slot_ops wrappers (Lukas Wunner)
    
     - Tolerate PCIe Slot Presence Detect being hardwired to zero to
       workaround broken hardware, e.g., the Wilocity switch/wireless device
       (Lukas Wunner)
    
     - Unify pciehp controller & slot structs (Lukas Wunner)
    
     - Constify hotplug_slot_ops (Lukas Wunner)
    
     - Drop hotplug_slot_info (Lukas Wunner)
    
     - Embed hotplug_slot struct into users instead of allocating it
       separately (Lukas Wunner)
    
     - Initialize PCIe port service drivers directly instead of relying on
       initcall ordering (Keith Busch)
    
     - Restore PCI config state after a slot reset (Keith Busch)
    
     - Save/restore DPC config state along with other PCI config state
       (Keith Busch)
    
     - Reference count devices during AER handling to avoid race issue with
       concurrent hot removal (Keith Busch)
    
     - If an Upstream Port reports ERR_FATAL, don't try to read the Port's
       config space because it is probably unreachable (Keith Busch)
    
     - During error handling, use slot-specific reset instead of secondary
       bus reset to avoid link up/down issues on hotplug ports (Keith Busch)
    
     - Restore previous AER/DPC handling that does not remove and
       re-enumerate devices on ERR_FATAL (Keith Busch)
    
     - Notify all drivers that may be affected by error recovery resets
       (Keith Busch)
    
     - Always generate error recovery uevents, even if a driver doesn't have
       error callbacks (Keith Busch)
    
     - Make PCIe link active reporting detection generic (Keith Busch)
    
     - Support D3cold in PCIe hierarchies during system sleep and runtime,
       including hotplug and Thunderbolt ports (Mika Westerberg)
    
     - Handle hpmemsize/hpiosize kernel parameters uniformly, whether slots
       are empty or occupied (Jon Derrick)
    
     - Remove duplicated include from pci/pcie/err.c and unused variable
       from cpqphp (YueHaibing)
    
     - Remove driver pci_cleanup_aer_uncorrect_error_status() calls (Oza
       Pawandeep)
    
     - Uninline PCI bus accessors for better ftracing (Keith Busch)
    
     - Remove unused AER Root Port .error_resume method (Keith Busch)
    
     - Use kfifo in AER instead of a local version (Keith Busch)
    
     - Use threaded IRQ in AER bottom half (Keith Busch)
    
     - Use managed resources in AER core (Keith Busch)
    
     - Reuse pcie_port_find_device() for AER injection (Keith Busch)
    
     - Abstract AER interrupt handling to disconnect error injection (Keith
       Busch)
    
     - Refactor AER injection callbacks to simplify future improvments
       (Keith Busch)
    
     - Remove unused Netronome NFP32xx Device IDs (Jakub Kicinski)
    
     - Use bitmap_zalloc() for dma_alias_mask (Andy Shevchenko)
    
     - Add switch fall-through annotations (Gustavo A. R. Silva)
    
     - Remove unused Switchtec quirk variable (Joshua Abraham)
    
     - Fix pci.c kernel-doc warning (Randy Dunlap)
    
     - Remove trivial PCI wrappers for DMA APIs (Christoph Hellwig)
    
     - Add Intel GPU device IDs to spurious interrupt quirk (Bin Meng)
    
     - Run Switchtec DMA aliasing quirk only on NTB endpoints to avoid
       useless dmesg errors (Logan Gunthorpe)
    
     - Update Switchtec NTB documentation (Wesley Yung)
    
     - Remove redundant "default n" from Kconfig (Bartlomiej Zolnierkiewicz)
    
     - Avoid panic when drivers enable MSI/MSI-X twice (Tonghao Zhang)
    
     - Add PCI support for peer-to-peer DMA (Logan Gunthorpe)
    
     - Add sysfs group for PCI peer-to-peer memory statistics (Logan
       Gunthorpe)
    
     - Add PCI peer-to-peer DMA scatterlist mapping interface (Logan
       Gunthorpe)
    
     - Add PCI configfs/sysfs helpers for use by peer-to-peer users (Logan
       Gunthorpe)
    
     - Add PCI peer-to-peer DMA driver writer's documentation (Logan
       Gunthorpe)
    
     - Add block layer flag to indicate driver support for PCI peer-to-peer
       DMA (Logan Gunthorpe)
    
     - Map Infiniband scatterlists for peer-to-peer DMA if they contain P2P
       memory (Logan Gunthorpe)
    
     - Register nvme-pci CMB buffer as PCI peer-to-peer memory (Logan
       Gunthorpe)
    
     - Add nvme-pci support for PCI peer-to-peer memory in requests (Logan
       Gunthorpe)
    
     - Use PCI peer-to-peer memory in nvme (Stephen Bates, Steve Wise,
       Christoph Hellwig, Logan Gunthorpe)
    
     - Cache VF config space size to optimize enumeration of many VFs
       (KarimAllah Ahmed)
    
     - Remove unnecessary <linux/pci-ats.h> include (Bjorn Helgaas)
    
     - Fix VMD AERSID quirk Device ID matching (Jon Derrick)
    
     - Fix Cadence PHY handling during probe (Alan Douglas)
    
     - Signal Cadence Endpoint interrupts via AXI region 0 instead of last
       region (Alan Douglas)
    
     - Write Cadence Endpoint MSI interrupts with 32 bits of data (Alan
       Douglas)
    
     - Remove redundant controller tests for "device_type == pci" (Rob
       Herring)
    
     - Document R-Car E3 (R8A77990) bindings (Tho Vu)
    
     - Add device tree support for R-Car r8a7744 (Biju Das)
    
     - Drop unused mvebu PCIe capability code (Thomas Petazzoni)
    
     - Add shared PCI bridge emulation code (Thomas Petazzoni)
    
     - Convert mvebu to use shared PCI bridge emulation (Thomas Petazzoni)
    
     - Add aardvark Root Port emulation (Thomas Petazzoni)
    
     - Support 100MHz/200MHz refclocks for i.MX6 (Lucas Stach)
    
     - Add initial power management for i.MX7 (Leonard Crestez)
    
     - Add PME_Turn_Off support for i.MX7 (Leonard Crestez)
    
     - Fix qcom runtime power management error handling (Bjorn Andersson)
    
     - Update TI dra7xx unaligned access errata workaround for host mode as
       well as endpoint mode (Vignesh R)
    
     - Fix kirin section mismatch warning (Nathan Chancellor)
    
     - Remove iproc PAXC slot check to allow VF support (Jitendra Bhivare)
    
     - Quirk Keystone K2G to limit MRRS to 256 (Kishon Vijay Abraham I)
    
     - Update Keystone to use MRRS quirk for host bridge instead of open
       coding (Kishon Vijay Abraham I)
    
     - Refactor Keystone link establishment (Kishon Vijay Abraham I)
    
     - Simplify and speed up Keystone link training (Kishon Vijay Abraham I)
    
     - Remove unused Keystone host_init argument (Kishon Vijay Abraham I)
    
     - Merge Keystone driver files into one (Kishon Vijay Abraham I)
    
     - Remove redundant Keystone platform_set_drvdata() (Kishon Vijay
       Abraham I)
    
     - Rename Keystone functions for uniformity (Kishon Vijay Abraham I)
    
     - Add Keystone device control module DT binding (Kishon Vijay Abraham
       I)
    
     - Use SYSCON API to get Keystone control module device IDs (Kishon
       Vijay Abraham I)
    
     - Clean up Keystone PHY handling (Kishon Vijay Abraham I)
    
     - Use runtime PM APIs to enable Keystone clock (Kishon Vijay Abraham I)
    
     - Clean up Keystone config space access checks (Kishon Vijay Abraham I)
    
     - Get Keystone outbound window count from DT (Kishon Vijay Abraham I)
    
     - Clean up Keystone outbound window configuration (Kishon Vijay Abraham
       I)
    
     - Clean up Keystone DBI setup (Kishon Vijay Abraham I)
    
     - Clean up Keystone ks_pcie_link_up() (Kishon Vijay Abraham I)
    
     - Fix Keystone IRQ status checking (Kishon Vijay Abraham I)
    
     - Add debug messages for all Keystone errors (Kishon Vijay Abraham I)
    
     - Clean up Keystone includes and macros (Kishon Vijay Abraham I)
    
     - Fix Mediatek unchecked return value from devm_pci_remap_iospace()
       (Gustavo A. R. Silva)
    
     - Fix Mediatek endpoint/port matching logic (Honghui Zhang)
    
     - Change Mediatek Root Port Class Code to PCI_CLASS_BRIDGE_PCI (Honghui
       Zhang)
    
     - Remove redundant Mediatek PM domain check (Honghui Zhang)
    
     - Convert Mediatek to pci_host_probe() (Honghui Zhang)
    
     - Fix Mediatek MSI enablement (Honghui Zhang)
    
     - Add Mediatek system PM support for MT2712 and MT7622 (Honghui Zhang)
    
     - Add Mediatek loadable module support (Honghui Zhang)
    
     - Detach VMD resources after stopping root bus to prevent orphan
       resources (Jon Derrick)
    
     - Convert pcitest build process to that used by other tools (iio, perf,
       etc) (Gustavo Pimentel)
    
    * tag 'pci-v4.20-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (140 commits)
      PCI/AER: Refactor error injection fallbacks
      PCI/AER: Abstract AER interrupt handling
      PCI/AER: Reuse existing pcie_port_find_device() interface
      PCI/AER: Use managed resource allocations
      PCI: pcie: Remove redundant 'default n' from Kconfig
      PCI: aardvark: Implement emulated root PCI bridge config space
      PCI: mvebu: Convert to PCI emulated bridge config space
      PCI: mvebu: Drop unused PCI express capability code
      PCI: Introduce PCI bridge emulated config space common logic
      PCI: vmd: Detach resources after stopping root bus
      nvmet: Optionally use PCI P2P memory
      nvmet: Introduce helper functions to allocate and free request SGLs
      nvme-pci: Add support for P2P memory in requests
      nvme-pci: Use PCI p2pmem subsystem to manage the CMB
      IB/core: Ensure we map P2P memory correctly in rdma_rw_ctx_[init|destroy]()
      block: Add PCI P2P flag for request queue
      PCI/P2PDMA: Add P2P DMA driver writer's documentation
      docs-rst: Add a new directory for PCI documentation
      PCI/P2PDMA: Introduce configfs/sysfs enable attribute helpers
      PCI/P2PDMA: Add PCI p2pmem DMA mappings to adjust the bus offset
      ...

commit 114b5f8f7efc036dd7dd16efb0f218a88e6c6c02
Merge: b0b6a28bc4b2 40f5ff4f9f23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 23 08:45:05 2018 +0100

    Merge tag 'gpio-v4.20-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.20 series:
    
      Core changes:
    
       - A patch series from Hans Verkuil to make it possible to
         enable/disable IRQs on a GPIO line at runtime and drive GPIO lines
         as output without having to put/get them from scratch.
    
         The irqchip callbacks have been improved so that they can use only
         the fastpatch callbacks to enable/disable irqs like any normal
         irqchip, especially the gpiod_lock_as_irq() has been improved to be
         callable in fastpath context.
    
         A bunch of rework had to be done to achieve this but it is a big
         win since I never liked to restrict this to slowpath. The only call
         requireing slowpath was try_module_get() and this is kept at the
         .request_resources() slowpath callback. In the GPIO CEC driver this
         is a big win sine a single line is used for both outgoing and
         incoming traffic, and this needs to use IRQs for incoming traffic
         while actively driving the line for outgoing traffic.
    
       - Janusz Krzysztofik improved the GPIO array API to pass a "cookie"
         (struct gpio_array) and a bitmap for setting or getting multiple
         GPIO lines at once.
    
         This improvement orginated in a specific need to speed up an OMAP1
         driver and has led to a much better API and real performance gains
         when the state of the array can be used to bypass a lot of checks
         and code when we want things to go really fast.
    
         The previous code would minimize the number of calls down to the
         driver callbacks assuming the CPU speed was orders of magnitude
         faster than the I/O latency, but this assumption was wrong on
         several platforms: what we needed to do was to profile and improve
         the speed on the hot path of the array functions and this change is
         now completed.
    
       - Clean out the painful and hard to grasp BNF experiments from the
         device tree bindings. Future approaches are looking into using JSON
         schema for this purpose. (Rob Herring is floating a patch series.)
    
      New drivers:
    
       - The RCAR driver now supports r8a774a1 (RZ/G2M).
    
       - Synopsys GPIO via CREGs driver.
    
      Major improvements:
    
       - Modernization of the EP93xx driver to use irqdomain and other
         contemporary concepts.
    
       - The ingenic driver has been merged into the Ingenic pin control
         driver and removed from the GPIO subsystem.
    
       - Debounce support in the ftgpio010 driver"
    
    * tag 'gpio-v4.20-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (116 commits)
      gpio: Clarify kerneldoc on gpiochip_set_chained_irqchip()
      gpio: Remove unused 'irqchip' argument to gpiochip_set_cascaded_irqchip()
      gpio: Drop parent irq assignment during cascade setup
      mmc: pwrseq_simple: Fix incorrect handling of GPIO bitmap
      gpio: fix SNPS_CREG kconfig dependency warning
      gpiolib: Initialize gdev field before is used
      gpio: fix kernel-doc after devres.c file rename
      gpio: fix doc string for devm_gpiochip_add_data() to not talk about irq_chip
      gpio: syscon: Fix possible NULL ptr usage
      gpiolib: Show correct direction from the beginning
      pinctrl: msm: Use init_valid_mask exported function
      gpiolib: Add init_valid_mask exported function
      GPIO: add single-register GPIO via CREG driver
      dt-bindings: Document the Synopsys GPIO via CREG bindings
      gpio: mockup: use device properties instead of platform_data
      gpio: Slightly more helpful debugfs
      gpio: omap: Remove set but not used variable 'dev'
      gpio: omap: drop omap_gpio_list
      Accept partial 'gpio-line-names' property.
      gpio: omap: get rid of the conditional PM runtime calls
      ...

commit 5f5e4890d57a8af5da72c9d73a4efa9bad43a7a3
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:57:05 2018 -0500

    ACPI / property: Allow multiple property compatible _DSD entries
    
    It is possible to have _DSD entries where the data is compatible with
    device properties format but are using different GUID for various reasons.
    In addition to that there can be many such _DSD entries for a single device
    such as for PCIe root port used to host a Thunderbolt hierarchy:
    
        Scope (\_SB.PCI0.RP21)
        {
            Name (_DSD, Package () {
                ToUUID ("6211e2c0-58a3-4af3-90e1-927a4e0c55a4"),
                Package () {
                    Package () {"HotPlugSupportInD3", 1}
                },
    
                ToUUID ("efcc06cc-73ac-4bc3-bff0-76143807c389"),
                Package () {
                    Package () {"ExternalFacingPort", 1},
                    Package () {"UID", 0 }
                }
            })
        }
    
    More information about these new _DSD entries can be found in:
    
      https://docs.microsoft.com/en-us/windows-hardware/drivers/pci/dsd-for-pcie-root-ports
    
    To make these available for drivers via unified device property APIs,
    modify ACPI property core so that it supports multiple _DSD entries
    organized in a linked list. We also store GUID of each _DSD entry in struct
    acpi_device_properties in case there is need to differentiate between
    entries. The supported GUIDs are then listed in prp_guids array.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 8b9d7e42c600..f74aa0e60300 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1198,7 +1198,7 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
 {
 	/* Never allow fallback if the device has properties */
-	if (adev->data.properties || adev->driver_gpios)
+	if (acpi_dev_has_props(adev) || adev->driver_gpios)
 		return false;
 
 	return con_id == NULL;

commit dae5f0afcfc35ff64dfb65cddc6842ceeeca68c4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 25 09:08:48 2018 +0200

    gpio: Use SPDX header for core library
    
    Use the SPDX headers and cut down on boilerplate to indicate the
    license in the core gpiolib implementation.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 79271e08eea5..3fd3887d9ba8 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * ACPI helpers for GPIO API
  *
  * Copyright (C) 2012, Intel Corporation
  * Authors: Mathias Nyman <mathias.nyman@linux.intel.com>
  *          Mika Westerberg <mika.westerberg@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/errno.h>

commit f13a0b0bb46f07e5c154ae7944202d754007d362
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 13 14:05:26 2018 +0200

    gpio: Get rid of legacy header
    
    A bunch of core gpiolib files still include the <linux/gpio.h>
    legacy API header for no good reason. After this only the
    gpiolib-legacy.c file includes it, which is fine.
    
    The sysfs ABI code has a pointless wrapper function around
    gpio_to_desc() we can just loose.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index c48ed9d89ff5..79271e08eea5 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -11,7 +11,6 @@
  */
 
 #include <linux/errno.h>
-#include <linux/gpio.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio/driver.h>
 #include <linux/gpio/machine.h>

commit 78d3a92edbfb02e8cb83173cad84c3f2d5e1f070
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Aug 14 16:07:03 2018 +0200

    gpiolib-acpi: Register GpioInt ACPI event handlers from a late_initcall
    
    GpioInt ACPI event handlers may see there IRQ triggered immediately
    after requesting the IRQ (esp. level triggered ones). This means that they
    may run before any other (builtin) drivers have had a chance to register
    their OpRegion handlers, leading to errors like this:
    
    [    1.133274] ACPI Error: No handler for Region [PMOP] ((____ptrval____)) [UserDefinedRegion] (20180531/evregion-132)
    [    1.133286] ACPI Error: Region UserDefinedRegion (ID=141) has no handler (20180531/exfldio-265)
    [    1.133297] ACPI Error: Method parse/execution failed \_SB.GPO2._L01, AE_NOT_EXIST (20180531/psparse-516)
    
    We already defer the manual initial trigger of edge triggered interrupts
    by running it from a late_initcall handler, this commit replaces this with
    deferring the entire acpi_gpiochip_request_interrupts() call till then,
    fixing the problem of some OpRegions not being registered yet.
    
    Note that this removes the need to have a list of edge triggered handlers
    which need to run, since the entire acpi_gpiochip_request_interrupts() call
    is now delayed, acpi_gpiochip_request_interrupt() can call these directly
    now.
    
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index f9134f23c7e8..8b9d7e42c600 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -25,7 +25,6 @@
 
 struct acpi_gpio_event {
 	struct list_head node;
-	struct list_head initial_sync_list;
 	acpi_handle handle;
 	unsigned int pin;
 	unsigned int irq;
@@ -49,10 +48,19 @@ struct acpi_gpio_chip {
 	struct mutex conn_lock;
 	struct gpio_chip *chip;
 	struct list_head events;
+	struct list_head deferred_req_irqs_list_entry;
 };
 
-static LIST_HEAD(acpi_gpio_initial_sync_list);
-static DEFINE_MUTEX(acpi_gpio_initial_sync_list_lock);
+/*
+ * For gpiochips which call acpi_gpiochip_request_interrupts() before late_init
+ * (so builtin drivers) we register the ACPI GpioInt event handlers from a
+ * late_initcall_sync handler, so that other builtin drivers can register their
+ * OpRegions before the event handlers can run.  This list contains gpiochips
+ * for which the acpi_gpiochip_request_interrupts() has been deferred.
+ */
+static DEFINE_MUTEX(acpi_gpio_deferred_req_irqs_lock);
+static LIST_HEAD(acpi_gpio_deferred_req_irqs_list);
+static bool acpi_gpio_deferred_req_irqs_done;
 
 static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 {
@@ -89,21 +97,6 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	return gpiochip_get_desc(chip, pin);
 }
 
-static void acpi_gpio_add_to_initial_sync_list(struct acpi_gpio_event *event)
-{
-	mutex_lock(&acpi_gpio_initial_sync_list_lock);
-	list_add(&event->initial_sync_list, &acpi_gpio_initial_sync_list);
-	mutex_unlock(&acpi_gpio_initial_sync_list_lock);
-}
-
-static void acpi_gpio_del_from_initial_sync_list(struct acpi_gpio_event *event)
-{
-	mutex_lock(&acpi_gpio_initial_sync_list_lock);
-	if (!list_empty(&event->initial_sync_list))
-		list_del_init(&event->initial_sync_list);
-	mutex_unlock(&acpi_gpio_initial_sync_list_lock);
-}
-
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 {
 	struct acpi_gpio_event *event = data;
@@ -229,7 +222,6 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	event->irq = irq;
 	event->pin = pin;
 	event->desc = desc;
-	INIT_LIST_HEAD(&event->initial_sync_list);
 
 	ret = request_threaded_irq(event->irq, NULL, handler, irqflags,
 				   "ACPI:Event", event);
@@ -251,10 +243,9 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	 * may refer to OperationRegions from other (builtin) drivers which
 	 * may be probed after us.
 	 */
-	if (handler == acpi_gpio_irq_handler &&
-	    (((irqflags & IRQF_TRIGGER_RISING) && value == 1) ||
-	     ((irqflags & IRQF_TRIGGER_FALLING) && value == 0)))
-		acpi_gpio_add_to_initial_sync_list(event);
+	if (((irqflags & IRQF_TRIGGER_RISING) && value == 1) ||
+	    ((irqflags & IRQF_TRIGGER_FALLING) && value == 0))
+		handler(event->irq, event);
 
 	return AE_OK;
 
@@ -283,6 +274,7 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	struct acpi_gpio_chip *acpi_gpio;
 	acpi_handle handle;
 	acpi_status status;
+	bool defer;
 
 	if (!chip->parent || !chip->to_irq)
 		return;
@@ -295,6 +287,16 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	if (ACPI_FAILURE(status))
 		return;
 
+	mutex_lock(&acpi_gpio_deferred_req_irqs_lock);
+	defer = !acpi_gpio_deferred_req_irqs_done;
+	if (defer)
+		list_add(&acpi_gpio->deferred_req_irqs_list_entry,
+			 &acpi_gpio_deferred_req_irqs_list);
+	mutex_unlock(&acpi_gpio_deferred_req_irqs_lock);
+
+	if (defer)
+		return;
+
 	acpi_walk_resources(handle, "_AEI",
 			    acpi_gpiochip_request_interrupt, acpi_gpio);
 }
@@ -325,11 +327,14 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	if (ACPI_FAILURE(status))
 		return;
 
+	mutex_lock(&acpi_gpio_deferred_req_irqs_lock);
+	if (!list_empty(&acpi_gpio->deferred_req_irqs_list_entry))
+		list_del_init(&acpi_gpio->deferred_req_irqs_list_entry);
+	mutex_unlock(&acpi_gpio_deferred_req_irqs_lock);
+
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
 		struct gpio_desc *desc;
 
-		acpi_gpio_del_from_initial_sync_list(event);
-
 		if (irqd_is_wakeup_set(irq_get_irq_data(event->irq)))
 			disable_irq_wake(event->irq);
 
@@ -1052,6 +1057,7 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 
 	acpi_gpio->chip = chip;
 	INIT_LIST_HEAD(&acpi_gpio->events);
+	INIT_LIST_HEAD(&acpi_gpio->deferred_req_irqs_list_entry);
 
 	status = acpi_attach_data(handle, acpi_gpio_chip_dh, acpi_gpio);
 	if (ACPI_FAILURE(status)) {
@@ -1198,20 +1204,28 @@ bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
 	return con_id == NULL;
 }
 
-/* Sync the initial state of handlers after all builtin drivers have probed */
-static int acpi_gpio_initial_sync(void)
+/* Run deferred acpi_gpiochip_request_interrupts() */
+static int acpi_gpio_handle_deferred_request_interrupts(void)
 {
-	struct acpi_gpio_event *event, *ep;
+	struct acpi_gpio_chip *acpi_gpio, *tmp;
+
+	mutex_lock(&acpi_gpio_deferred_req_irqs_lock);
+	list_for_each_entry_safe(acpi_gpio, tmp,
+				 &acpi_gpio_deferred_req_irqs_list,
+				 deferred_req_irqs_list_entry) {
+		acpi_handle handle;
 
-	mutex_lock(&acpi_gpio_initial_sync_list_lock);
-	list_for_each_entry_safe(event, ep, &acpi_gpio_initial_sync_list,
-				 initial_sync_list) {
-		acpi_evaluate_object(event->handle, NULL, NULL, NULL);
-		list_del_init(&event->initial_sync_list);
+		handle = ACPI_HANDLE(acpi_gpio->chip->parent);
+		acpi_walk_resources(handle, "_AEI",
+				    acpi_gpiochip_request_interrupt, acpi_gpio);
+
+		list_del_init(&acpi_gpio->deferred_req_irqs_list_entry);
 	}
-	mutex_unlock(&acpi_gpio_initial_sync_list_lock);
+
+	acpi_gpio_deferred_req_irqs_done = true;
+	mutex_unlock(&acpi_gpio_deferred_req_irqs_lock);
 
 	return 0;
 }
 /* We must use _sync so that this runs after the first deferred_probe run */
-late_initcall_sync(acpi_gpio_initial_sync);
+late_initcall_sync(acpi_gpio_handle_deferred_request_interrupts);

commit 993b9bc5c47fda86f8ab4e53d68c6fea5ff2764a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Aug 13 19:00:27 2018 +0300

    gpiolib: acpi: Switch to cansleep version of GPIO library call
    
    The commit ca876c7483b6
    
      ("gpiolib-acpi: make sure we trigger edge events at least once on boot")
    
    added a initial value check for pin which is about to be locked as IRQ.
    Unfortunately, not all GPIO drivers can do that atomically. Thus,
    switch to cansleep version of the call. Otherwise we have a warning:
    
    ...
      WARNING: CPU: 2 PID: 1408 at drivers/gpio/gpiolib.c:2883 gpiod_get_value+0x46/0x50
    ...
      RIP: 0010:gpiod_get_value+0x46/0x50
    ...
    
    The change tested on Intel Broxton with Whiskey Cove PMIC GPIO controller.
    
    Fixes: ca876c7483b6 ("gpiolib-acpi: make sure we trigger edge events at least once on boot")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index c48ed9d89ff5..f9134f23c7e8 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -186,7 +186,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	gpiod_direction_input(desc);
 
-	value = gpiod_get_value(desc);
+	value = gpiod_get_value_cansleep(desc);
 
 	ret = gpiochip_lock_as_irq(chip, pin);
 	if (ret) {

commit 2c20443ec221dcb76484b30933593e8ecd836bbd
Merge: b018fc980055 76f7d6c07acd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 14 13:39:52 2018 -0700

    Merge tag 'acpi-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These revert two ACPICA commits that are not needed any more, rework
      the property graphs support in ACPI to be more aligned with the
      analogous DT code, add some new quirks and remove one that isn't
      needed any more, add a special platform driver to enumerate multiple
      I2C devices hooked up to the same device object in the ACPI tables and
      update the battery and button drivers.
    
      Specifics:
    
       - Revert two ACPICA commits that are not needed any more (Erik
         Schmauss).
    
       - Rework property graph support in the ACPI device properties
         framework to make it behave more like the analogous DT code and
         update the documentation of it (Sakari Ailus).
    
       - Change the default ACPI device status after initialization to
         ACPI_STA_DEFAULT instead of 0 (Hans de Goede).
    
       - Add a special platform driver for enumerating multiple I2C devices
         hooked up to the same object in the ACPI tables (Hans de Goede).
    
       - Fix the ACPI battery driver to avoid reporting full capacity on
         systems without support for that and clean it up (Hans de Goede,
         Dmitry Rozhkov, Lucas Rangit Magasweran).
    
       - Add two system wakeup quirks to the ACPI EC driver (Aaron Ma, Mika
         Westerberg).
    
       - Add the touchscreen on Dell Venue Pro 7139 to the list of "always
         present" devices to make it work (Tristian Celestin).
    
       - Revert a special tables handling quirk for Dell XPS 9570 and
         Precision M5530 which is not needed any more (Kai Heng Feng).
    
       - Add support for a new OEM _OSI string to allow system vendors to
         work around issues with NVidia HDMI audio (Alex Hung).
    
       - Prevent the ACPI button driver from reporting excessive system
         wakeup events and clean it up (Ravi Chandra Sadineni, Randy
         Dunlap).
    
       - Clean up two minor code style issues in the ACPI core and GHES
         handling on ARM64 (Dongjiu Geng, John Garry, Tom Todd)"
    
    * tag 'acpi-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (34 commits)
      platform/x86: Add ACPI i2c-multi-instantiate pseudo driver
      ACPI / x86: utils: Remove status workaround from acpi_device_always_present()
      ACPI / scan: Create platform device for fwnodes with multiple i2c devices
      ACPI / scan: Initialize status to ACPI_STA_DEFAULT
      ACPI / EC: Add another entry for Thinkpad X1 Carbon 6th
      ACPI: bus: Fix a pointer coding style issue
      arm64 / ACPI: clean the additional checks before calling ghes_notify_sea()
      ACPI / scan: Add static attribute to indirect_io_hosts[]
      ACPI / battery: Do not export energy_full[_design] on devices without full_charge_capacity
      ACPI / EC: Use ec_no_wakeup on ThinkPad X1 Yoga 3rd
      ACPI / battery: get rid of negations in conditions
      ACPI / battery: use specialized print macros
      ACPI / battery: reorder headers alphabetically
      ACPI / battery: drop inclusion of init.h
      ACPI: battery: remove redundant old_present check on insertion
      ACPI: property: graph: Update graph documentation to use generic references
      ACPI: property: graph: Improve graph documentation for port/ep numbering
      ACPI: property: graph: Fix graph documentation
      ACPI: property: Update documentation for hierarchical data extension 1.1
      ACPI: property: Document key numbering for hierarchical data extension refs
      ...

commit ca876c7483b697b498868b1f575997191b077885
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Thu Jul 12 17:25:06 2018 +0200

    gpiolib-acpi: make sure we trigger edge events at least once on boot
    
    On some systems using edge triggered ACPI Event Interrupts, the initial
    state at boot is not setup by the firmware, instead relying on the edge
    irq event handler running at least once to setup the initial state.
    
    2 known examples of this are:
    
    1) The Surface 3 has its _LID state controlled by an ACPI operation region
     triggered by a GPIO event:
    
     OperationRegion (GPOR, GeneralPurposeIo, Zero, One)
     Field (GPOR, ByteAcc, NoLock, Preserve)
     {
         Connection (
             GpioIo (Shared, PullNone, 0x0000, 0x0000, IoRestrictionNone,
                 "\\_SB.GPO0", 0x00, ResourceConsumer, ,
                 )
                 {   // Pin list
                     0x004C
                 }
         ),
         HELD,   1
     }
    
     Method (_E4C, 0, Serialized)  // _Exx: Edge-Triggered GPE
     {
         If ((HELD == One))
         {
             ^^LID.LIDB = One
         }
         Else
         {
             ^^LID.LIDB = Zero
             Notify (LID, 0x80) // Status Change
         }
    
         Notify (^^PCI0.SPI1.NTRG, One) // Device Check
     }
    
     Currently, the state of LIDB is wrong until the user actually closes or
     open the cover. We need to trigger the GPIO event once to update the
     internal ACPI state.
    
     Coincidentally, this also enables the Surface 2 integrated HID sensor hub
     which also requires an ACPI gpio operation region to start initialization.
    
    2) Various Bay Trail based tablets come with an external USB mux and
     TI T1210B USB phy to enable USB gadget mode. The mux is controlled by a
     GPIO which is controlled by an edge triggered ACPI Event Interrupt which
     monitors the micro-USB ID pin.
    
     When the tablet is connected to a PC (or no cable is plugged in), the ID
     pin is high and the tablet should be in gadget mode. But the GPIO
     controlling the mux is initialized by the firmware so that the USB data
     lines are muxed to the host controller.
    
     This means that if the user wants to use gadget mode, the user needs to
     first plug in a host-cable to force the ID pin low and then unplug it
     and connect the tablet to a PC, to get the ACPI event handler to run and
     switch the mux to device mode,
    
    This commit fixes both by running the event-handler once on boot.
    
    Note that the running of the event-handler is done from a late_initcall,
    this is done because the handler AML code may rely on OperationRegions
    registered by other builtin drivers. This avoids errors like these:
    
    [    0.133026] ACPI Error: No handler for Region [XSCG] ((____ptrval____)) [GenericSerialBus] (20180531/evregion-132)
    [    0.133036] ACPI Error: Region GenericSerialBus (ID=9) has no handler (20180531/exfldio-265)
    [    0.133046] ACPI Error: Method parse/execution failed \_SB.GPO2._E12, AE_NOT_EXIST (20180531/psparse-516)
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    [hdegoede: Document BYT USB mux reliance on initial trigger]
    [hdegoede: Run event handler from a late_initcall, rather then immediately]
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index e2232cbcec8b..addd9fecc198 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -25,6 +25,7 @@
 
 struct acpi_gpio_event {
 	struct list_head node;
+	struct list_head initial_sync_list;
 	acpi_handle handle;
 	unsigned int pin;
 	unsigned int irq;
@@ -50,6 +51,9 @@ struct acpi_gpio_chip {
 	struct list_head events;
 };
 
+static LIST_HEAD(acpi_gpio_initial_sync_list);
+static DEFINE_MUTEX(acpi_gpio_initial_sync_list_lock);
+
 static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 {
 	if (!gc->parent)
@@ -85,6 +89,21 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	return gpiochip_get_desc(chip, pin);
 }
 
+static void acpi_gpio_add_to_initial_sync_list(struct acpi_gpio_event *event)
+{
+	mutex_lock(&acpi_gpio_initial_sync_list_lock);
+	list_add(&event->initial_sync_list, &acpi_gpio_initial_sync_list);
+	mutex_unlock(&acpi_gpio_initial_sync_list_lock);
+}
+
+static void acpi_gpio_del_from_initial_sync_list(struct acpi_gpio_event *event)
+{
+	mutex_lock(&acpi_gpio_initial_sync_list_lock);
+	if (!list_empty(&event->initial_sync_list))
+		list_del_init(&event->initial_sync_list);
+	mutex_unlock(&acpi_gpio_initial_sync_list_lock);
+}
+
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 {
 	struct acpi_gpio_event *event = data;
@@ -136,7 +155,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	irq_handler_t handler = NULL;
 	struct gpio_desc *desc;
 	unsigned long irqflags;
-	int ret, pin, irq;
+	int ret, pin, irq, value;
 
 	if (!acpi_gpio_get_irq_resource(ares, &agpio))
 		return AE_OK;
@@ -167,6 +186,8 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	gpiod_direction_input(desc);
 
+	value = gpiod_get_value(desc);
+
 	ret = gpiochip_lock_as_irq(chip, pin);
 	if (ret) {
 		dev_err(chip->parent, "Failed to lock GPIO as interrupt\n");
@@ -208,6 +229,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	event->irq = irq;
 	event->pin = pin;
 	event->desc = desc;
+	INIT_LIST_HEAD(&event->initial_sync_list);
 
 	ret = request_threaded_irq(event->irq, NULL, handler, irqflags,
 				   "ACPI:Event", event);
@@ -222,6 +244,18 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 		enable_irq_wake(irq);
 
 	list_add_tail(&event->node, &acpi_gpio->events);
+
+	/*
+	 * Make sure we trigger the initial state of the IRQ when using RISING
+	 * or FALLING.  Note we run the handlers on late_init, the AML code
+	 * may refer to OperationRegions from other (builtin) drivers which
+	 * may be probed after us.
+	 */
+	if (handler == acpi_gpio_irq_handler &&
+	    (((irqflags & IRQF_TRIGGER_RISING) && value == 1) ||
+	     ((irqflags & IRQF_TRIGGER_FALLING) && value == 0)))
+		acpi_gpio_add_to_initial_sync_list(event);
+
 	return AE_OK;
 
 fail_free_event:
@@ -294,6 +328,8 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
 		struct gpio_desc *desc;
 
+		acpi_gpio_del_from_initial_sync_list(event);
+
 		if (irqd_is_wakeup_set(irq_get_irq_data(event->irq)))
 			disable_irq_wake(event->irq);
 
@@ -1158,3 +1194,21 @@ bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
 
 	return con_id == NULL;
 }
+
+/* Sync the initial state of handlers after all builtin drivers have probed */
+static int acpi_gpio_initial_sync(void)
+{
+	struct acpi_gpio_event *event, *ep;
+
+	mutex_lock(&acpi_gpio_initial_sync_list_lock);
+	list_for_each_entry_safe(event, ep, &acpi_gpio_initial_sync_list,
+				 initial_sync_list) {
+		acpi_evaluate_object(event->handle, NULL, NULL, NULL);
+		list_del_init(&event->initial_sync_list);
+	}
+	mutex_unlock(&acpi_gpio_initial_sync_list_lock);
+
+	return 0;
+}
+/* We must use _sync so that this runs after the first deferred_probe run */
+late_initcall_sync(acpi_gpio_initial_sync);

commit 977d5ad39f3ea12ac0bd51d75020cea5ecdca235
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jul 17 17:19:11 2018 +0300

    ACPI: Convert ACPI reference args to generic fwnode reference args
    
    Convert all users of struct acpi_reference_args to more generic
    fwnode_reference_args. This will
    
     1) avoid an ACPI specific references to device nodes with integer
        arguments as well as
    
     2) allow making references to nodes other than device nodes in ACPI.
    
    As a by-product, convert the fwnode interger arguments to u64. The
    arguments were 64-bit integers on ACPI but the fwnode arguments were
    just 32-bit.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index e2232cbcec8b..4e8fdae1cde4 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -353,7 +353,7 @@ EXPORT_SYMBOL_GPL(devm_acpi_dev_remove_driver_gpios);
 
 static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
 				      const char *name, int index,
-				      struct acpi_reference_args *args,
+				      struct fwnode_reference_args *args,
 				      unsigned int *quirks)
 {
 	const struct acpi_gpio_mapping *gm;
@@ -365,7 +365,7 @@ static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
 		if (!strcmp(name, gm->name) && gm->data && index < gm->size) {
 			const struct acpi_gpio_params *par = gm->data + index;
 
-			args->adev = adev;
+			args->fwnode = acpi_fwnode_handle(adev);
 			args->args[0] = par->crs_entry_index;
 			args->args[1] = par->line_index;
 			args->args[2] = par->active_low;
@@ -528,7 +528,7 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 				     const char *propname, int index,
 				     struct acpi_gpio_lookup *lookup)
 {
-	struct acpi_reference_args args;
+	struct fwnode_reference_args args;
 	unsigned int quirks = 0;
 	int ret;
 
@@ -549,6 +549,8 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	 * The property was found and resolved, so need to lookup the GPIO based
 	 * on returned args.
 	 */
+	if (!to_acpi_device_node(args.fwnode))
+		return -EINVAL;
 	if (args.nargs != 3)
 		return -EPROTO;
 
@@ -556,8 +558,9 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	lookup->pin_index = args.args[1];
 	lookup->active_low = !!args.args[2];
 
-	lookup->info.adev = args.adev;
+	lookup->info.adev = to_acpi_device_node(args.fwnode);
 	lookup->info.quirks = quirks;
+
 	return 0;
 }
 

commit ef991796be0e65b644fe60198bd1112830eff173
Merge: bf644990a796 02e389e63e35
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 2 14:22:53 2018 -0800

    Merge tag 'pinctrl-v4.16-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This is the bulk of pin control changes for the v4.16 kernel cycle.
      Like with GPIO it is actually a bit calm this time.
    
      Core changes:
    
       - After lengthy discussions and partly due to my ignorance, we have
         merged a patch making pinctrl_force_default() and
         pinctrl_force_sleep() reprogram the states into the hardware of any
         hogged pins, even if they are already in the desired state.
    
         This only apply to hogged pins since groups of pins owned by
         drivers need to be managed by each driver, lest they could not do
         things like runtime PM and put pins to sleeping state even if the
         system as a whole is not in sleep.
    
      New drivers:
    
       - New driver for the Microsemi Ocelot SoC. This is used in ethernet
         switches.
    
       - The X-Powers AXP209 GPIO driver was extended to also deal with pin
         control and moved over from the GPIO subsystem. This circuit is a
         mixed-mode integrated circuit which is part of AllWinner designs.
    
       - New subdriver for the Qualcomm MSM8998 SoC, core of a high end
         mobile devices (phones) chipset.
    
       - New subdriver for the ST Microelectronics STM32MP157 MPU and
         STM32F769 MCU from the STM32 family.
    
       - New subdriver for the MediaTek MT7622 SoC. This is used for
         routers, repeater, gateways and such network infrastructure.
    
       - New subdriver for the NXP (former Freescale) i.MX 6ULL. This SoC
         has multimedia features and target "smart devices", I guess in-car
         entertainment, in-flight entertainment, industrial control panels
         etc.
    
      General improvements:
    
       - Incremental improvements on the SH-PFC subdrivers for things like
         the CAN bus.
    
       - Enable the glitch filter on Baytrail GPIOs used for interrupts.
    
       - Proper handling of pins to GPIO ranges on the Semtec SX150X
    
       - An IRQ setup ordering fix on MCP23S08.
    
       - A good set of janitorial coding style fixes"
    
    * tag 'pinctrl-v4.16-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (102 commits)
      pinctrl: mcp23s08: fix irq setup order
      pinctrl: Forward declare struct device
      pinctrl: sunxi: Use of_clk_get_parent_count() instead of open coding
      pinctrl: stm32: add STM32F769 MCU support
      pinctrl: sx150x: Add a static gpio/pinctrl pin range mapping
      pinctrl: sx150x: Register pinctrl before adding the gpiochip
      pinctrl: sx150x: Unregister the pinctrl on release
      pinctrl: ingenic: Remove redundant dev_err call in ingenic_pinctrl_probe()
      pinctrl: sprd: Use seq_putc() in sprd_pinconf_group_dbg_show()
      pinctrl: pinmux: Use seq_putc() in pinmux_pins_show()
      pinctrl: abx500: Use seq_putc() in abx500_gpio_dbg_show()
      pinctrl: mediatek: mt7622: align error handling of mtk_hw_get_value call
      pinctrl: mediatek: mt7622: fix potential uninitialized value being returned
      pinctrl: uniphier: refactor drive strength get/set functions
      pinctrl: imx7ulp: constify struct imx_cfg_params_decode
      pinctrl: imx: constify struct imx_pinctrl_soc_info
      pinctrl: imx7d: simplify imx7d_pinctrl_probe
      pinctrl: imx: use struct imx_pinctrl_soc_info as a const
      pinctrl: sunxi-pinctrl: fix pin funtion can not be match correctly.
      pinctrl: qcom: Add msm8998 pinctrl driver
      ...

commit 9798f5178f5791f964562eccedcf4dabe02fd825
Merge: 50081e437872 d58f2bf261fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 12:25:27 2018 -0800

    Merge tag 'gpio-v4.16-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "The is the bulk of GPIO changes for the v4.16 kernel cycle. It is
      pretty calm this time around I think. I even got time to get to things
      like starting to clean up header includes.
    
      Core changes:
    
       - Disallow open drain and open source flags to be set simultaneously.
         This doesn't make electrical sense, and would the hardware actually
         respond to this setting, the result would be short circuit.
    
       - ACPI GPIO has a new core infrastructure for handling quirks. The
         quirks are there to deal with broken ACPI tables centrally instead
         of pushing the work to individual drivers. In the world of BIOS
         writers, the ACPI tables are perfect. Until they find a mistake in
         it. When such a mistake is found, we can patch it with a quirk. It
         should never happen, the problem is that it happens. So we
         accomodate for it.
    
       - Several documentation updates.
    
       - Revert the patch setting up initial direction state from reading
         the device. This was causing bad things for drivers that can't read
         status on all its pins. It is only affecting debugfs information
         quality.
    
       - Label descriptors with the device name if no explicit label is
         passed in.
    
       - Pave the ground for transitioning SPI and regulators to use GPIO
         descriptors by implementing some quirks in the device tree GPIO
         parsing code.
    
      New drivers:
    
       - New driver for the Access PCIe IDIO 24 family.
    
      Other:
    
       - Major refactorings and improvements to the GPIO mockup driver used
         for test and verification.
    
       - Moved the AXP209 driver over to pin control since it gained a pin
         control back-end. These patches will appear (with the same hashes)
         in the pin control pull request as well.
    
       - Convert the onewire GPIO driver w1-gpio to use descriptors. This is
         merged here since the W1 maintainers send very few pull requests
         and he ACKed it.
    
       - Start to clean up driver headers using <linux/gpio.h> to just use
         <linux/gpio/driver.h> as appropriate"
    
    * tag 'gpio-v4.16-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (103 commits)
      gpio: Timestamp events in hardirq handler
      gpio: Fix kernel stack leak to userspace
      gpio: Fix a documentation spelling mistake
      gpio: Documentation update
      gpiolib: remove redundant initialization of pointer desc
      gpio: of: Fix NPE from OF flags
      gpio: stmpe: Delete an unnecessary variable initialisation in stmpe_gpio_probe()
      gpio: stmpe: Move an assignment in stmpe_gpio_probe()
      gpio: stmpe: Improve a size determination in stmpe_gpio_probe()
      gpio: stmpe: Use seq_putc() in stmpe_dbg_show()
      gpio: No NULL owner
      gpio: stmpe: i2c transfer are forbiden in atomic context
      gpio: davinci: Include proper header
      gpio: da905x: Include proper header
      gpio: cs5535: Include proper header
      gpio: crystalcove: Include proper header
      gpio: bt8xx: Include proper header
      gpio: bcm-kona: Include proper header
      gpio: arizona: Include proper header
      gpio: amd8111: Include proper header
      ...

commit 822703354774ec935169cbbc8d503236bcb54fda
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Fri Dec 15 15:02:33 2017 +0100

    gpio: fix "gpio-line-names" property retrieval
    
    Following commit 9427ecbed46cc ("gpio: Rework of_gpiochip_set_names()
    to use device property accessors"), "gpio-line-names" DT property is
    not retrieved anymore when chip->parent is not set by the driver.
    This is due to OF based property reads having been replaced by device
    based property reads.
    
    This patch fixes that by making use of
    fwnode_property_read_string_array() instead of
    device_property_read_string_array() and handing over either
    of_fwnode_handle(chip->of_node) or dev_fwnode(chip->parent)
    to that function.
    
    Fixes: 9427ecbed46cc ("gpio: Rework of_gpiochip_set_names() to use device property accessors")
    Cc: stable@vger.kernel.org
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index eb4528c87c0b..d6f3d9ee1350 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1074,7 +1074,7 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 	}
 
 	if (!chip->names)
-		devprop_gpiochip_set_names(chip);
+		devprop_gpiochip_set_names(chip, dev_fwnode(chip->parent));
 
 	acpi_gpiochip_request_regions(acpi_gpio);
 	acpi_gpiochip_scan_gpios(acpi_gpio);

commit 1b2ca32ab0b8311da84fe692522266b32ad4315e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 10 15:40:33 2017 +0200

    gpiolib: acpi: Introduce NO_RESTRICTION quirk
    
    Allow to relax IoRestriction for certain cases.
    
    One of the use case is incorrectly cooked ACPI table where interrupt pin is
    defined with GpioIo() macro with IoRestrictionOutputOnly.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 711f64b9dd30..430a1475212d 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -496,11 +496,18 @@ int
 acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, struct acpi_gpio_info *info)
 {
 	struct device *dev = &info->adev->dev;
+	enum gpiod_flags old = *flags;
 	int ret;
 
-	ret = __acpi_gpio_update_gpiod_flags(flags, info->flags);
-	if (ret)
-		dev_dbg(dev, "Override GPIO initialization flags\n");
+	ret = __acpi_gpio_update_gpiod_flags(&old, info->flags);
+	if (info->quirks & ACPI_GPIO_QUIRK_NO_IO_RESTRICTION) {
+		if (ret)
+			dev_warn(dev, FW_BUG "GPIO not in correct mode, fixing\n");
+	} else {
+		if (ret)
+			dev_dbg(dev, "Override GPIO initialization flags\n");
+		*flags = old;
+	}
 
 	return ret;
 }

commit ce0929d222f8cb18a66611642dc0661d633ce192
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 10 15:40:32 2017 +0200

    gpiolib: acpi: Add quirks field to struct acpi_gpio_mapping
    
    Some broken ACPI tables might require quirks in the OS.
    Introduce quirks field in struct acpi_gpio_mapping.
    
    Propagate them to struct acpi_gpio_info for further use.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 88518afa26bd..711f64b9dd30 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -414,7 +414,8 @@ EXPORT_SYMBOL_GPL(devm_acpi_dev_remove_driver_gpios);
 
 static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
 				      const char *name, int index,
-				      struct acpi_reference_args *args)
+				      struct acpi_reference_args *args,
+				      unsigned int *quirks)
 {
 	const struct acpi_gpio_mapping *gm;
 
@@ -430,6 +431,8 @@ static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
 			args->args[1] = par->line_index;
 			args->args[2] = par->active_low;
 			args->nargs = 3;
+
+			*quirks = gm->quirks;
 			return true;
 		}
 
@@ -580,6 +583,7 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 				     struct acpi_gpio_lookup *lookup)
 {
 	struct acpi_reference_args args;
+	unsigned int quirks = 0;
 	int ret;
 
 	memset(&args, 0, sizeof(args));
@@ -591,7 +595,8 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 		if (!adev)
 			return ret;
 
-		if (!acpi_get_driver_gpio_data(adev, propname, index, &args))
+		if (!acpi_get_driver_gpio_data(adev, propname, index, &args,
+					       &quirks))
 			return ret;
 	}
 	/*
@@ -606,6 +611,7 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	lookup->active_low = !!args.args[2];
 
 	lookup->info.adev = args.adev;
+	lookup->info.quirks = quirks;
 	return 0;
 }
 

commit 5c34b6c1468d54df71e8f5b7b3275bac705e2c4c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 10 15:40:31 2017 +0200

    gpiolib: acpi: Consolidate debug output in acpi_gpio_update_gpiod_flags()
    
    We have the duplicated debug strings printed whenever
    acpi_gpio_update_gpiod_flags() fails. Instead of doing this by callers,
    move the debug output inside function.
    
    In one case convert almost useless pr_debug() to dev_dbg() where
    actual consumer of GPIO resource is disclosed.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 7d0664a3d1b9..88518afa26bd 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -461,8 +461,8 @@ acpi_gpio_to_gpiod_flags(const struct acpi_resource_gpio *agpio)
 	}
 }
 
-int
-acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, enum gpiod_flags update)
+static int
+__acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, enum gpiod_flags update)
 {
 	int ret = 0;
 
@@ -489,6 +489,19 @@ acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, enum gpiod_flags update)
 	return ret;
 }
 
+int
+acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, struct acpi_gpio_info *info)
+{
+	struct device *dev = &info->adev->dev;
+	int ret;
+
+	ret = __acpi_gpio_update_gpiod_flags(flags, info->flags);
+	if (ret)
+		dev_dbg(dev, "Override GPIO initialization flags\n");
+
+	return ret;
+}
+
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
@@ -661,7 +674,6 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 	struct acpi_gpio_info info;
 	struct gpio_desc *desc;
 	char propname[32];
-	int err;
 	int i;
 
 	/* Try first from _DSD */
@@ -700,10 +712,7 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 	if (info.polarity == GPIO_ACTIVE_LOW)
 		*lookupflags |= GPIO_ACTIVE_LOW;
 
-	err = acpi_gpio_update_gpiod_flags(dflags, info.flags);
-	if (err)
-		dev_dbg(dev, "Override GPIO initialization flags\n");
-
+	acpi_gpio_update_gpiod_flags(dflags, &info);
 	return desc;
 }
 

commit 5870cff47bb6aeb9f9e073cbfcecd6f0f0d3035b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 10 15:40:30 2017 +0200

    gpiolib: acpi: Move adev member to struct acpi_gpio_info
    
    The further improvements are based on this change since
    struct acpi_gpio_lookup is not available in some cases.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index f640445099ab..7d0664a3d1b9 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -494,7 +494,6 @@ struct acpi_gpio_lookup {
 	int index;
 	int pin_index;
 	bool active_low;
-	struct acpi_device *adev;
 	struct gpio_desc *desc;
 	int n;
 };
@@ -541,12 +540,13 @@ static int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)
 static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
 				     struct acpi_gpio_info *info)
 {
+	struct acpi_device *adev = lookup->info.adev;
 	struct list_head res_list;
 	int ret;
 
 	INIT_LIST_HEAD(&res_list);
 
-	ret = acpi_dev_get_resources(lookup->adev, &res_list,
+	ret = acpi_dev_get_resources(adev, &res_list,
 				     acpi_populate_gpio_lookup,
 				     lookup);
 	if (ret < 0)
@@ -592,7 +592,7 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	lookup->pin_index = args.args[1];
 	lookup->active_low = !!args.args[2];
 
-	lookup->adev = args.adev;
+	lookup->info.adev = args.adev;
 	return 0;
 }
 
@@ -640,11 +640,11 @@ static struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 			return ERR_PTR(ret);
 
 		dev_dbg(&adev->dev, "GPIO: _DSD returned %s %d %d %u\n",
-			dev_name(&lookup.adev->dev), lookup.index,
+			dev_name(&lookup.info.adev->dev), lookup.index,
 			lookup.pin_index, lookup.active_low);
 	} else {
 		dev_dbg(&adev->dev, "GPIO: looking up %d in _CRS\n", index);
-		lookup.adev = adev;
+		lookup.info.adev = adev;
 	}
 
 	ret = acpi_gpio_resource_lookup(&lookup, info);

commit 08be1a795de3bf9dab31affed5e495ff91a1744d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 10 15:40:29 2017 +0200

    gpiolib: acpi: Don't contaminate return parameter in case of error
    
    If error occurs, leave lookup parameter untouched.
    
    There is no functional change, since all current callers just bail out
    in case of error without using the assigned pieces.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 2a85d27eb028..f640445099ab 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -585,7 +585,6 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	 * The property was found and resolved, so need to lookup the GPIO based
 	 * on returned args.
 	 */
-	lookup->adev = args.adev;
 	if (args.nargs != 3)
 		return -EPROTO;
 
@@ -593,6 +592,7 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	lookup->pin_index = args.args[1];
 	lookup->active_low = !!args.args[2];
 
+	lookup->adev = args.adev;
 	return 0;
 }
 

commit f67a6c11f99a0b7015dea7378b5e82e371425710
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 10 15:40:28 2017 +0200

    gpiolib: acpi: Assign polarity when call acpi_populate_gpio_lookup()
    
    There is no need, since we preserve firmware settings, to override
    polarity for GpioInt() resources.
    
    While Documentation/gpio-properties.txt refers to any from GpioIo() /
    GpioInt() resources, the active_low flag has been introduced to fill the
    gap only for GpioIo() which lacks of that information.
    
    Moreover, in case of GpioInt() existed solution was broken anyway, it
    overrides only in one direction, i.e. from 0 to 1, otherwise it would be
    still 1 as defined in the resource macro.
    
    So, move the assignment to a right place and forbid to (semi-)override
    polarity for GpioInt() type of resources.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index eb4528c87c0b..2a85d27eb028 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -531,8 +531,8 @@ static int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)
 			lookup->info.triggering = agpio->triggering;
 		} else {
 			lookup->info.flags = acpi_gpio_to_gpiod_flags(agpio);
+			lookup->info.polarity = lookup->active_low;
 		}
-
 	}
 
 	return 1;
@@ -557,11 +557,8 @@ static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
 	if (!lookup->desc)
 		return -ENOENT;
 
-	if (info) {
+	if (info)
 		*info = lookup->info;
-		if (lookup->active_low)
-			info->polarity = lookup->active_low;
-	}
 	return 0;
 }
 

commit 03c4749dd6c7ff948a0ce59a44a1b97c015353c2
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Nov 27 16:54:42 2017 +0300

    gpio / ACPI: Drop unnecessary ACPI GPIO to Linux GPIO translation
    
    We added acpi_gpiochip_pin_to_gpio_offset() because there was a need to
    translate from ACPI GpioIo/GpioInt number to Linux GPIO number in the
    Cherryview pinctrl driver. This translation is necessary because
    Cherryview has gaps in the pin list and the driver used continuous GPIO
    number space in Linux side as follows:
    
      created GPIO range 0->7 ==> INT33FF:03 PIN 0->7
      created GPIO range 8->19 ==> INT33FF:03 PIN 15->26
      created GPIO range 20->25 ==> INT33FF:03 PIN 30->35
      created GPIO range 26->33 ==> INT33FF:03 PIN 45->52
      created GPIO range 34->43 ==> INT33FF:03 PIN 60->69
      created GPIO range 44->54 ==> INT33FF:03 PIN 75->85
    
    For example when ACPI GpioInt resource refers to GPIO 81 (SDMMC3_CD_B)
    we translate from pin 81 to the corresponding Linux GPIO number, which
    is 50. This number is then used when the GPIO is accessed through gpiolib.
    
    It turns out, this is not necessary at all. We can just pass 1:1 mapping
    between Linux GPIO numbers and pin numbers (including gaps) and the
    pinctrl core handles all the details automatically:
    
      created GPIO range 0->7 ==> INT33FF:03 PIN 0->7
      created GPIO range 15->26 ==> INT33FF:03 PIN 15->26
      created GPIO range 30->35 ==> INT33FF:03 PIN 30->35
      created GPIO range 45->52 ==> INT33FF:03 PIN 45->52
      created GPIO range 60->69 ==> INT33FF:03 PIN 60->69
      created GPIO range 75->85 ==> INT33FF:03 PIN 75->85
    
    Here GPIO 81 is exactly same than the hardware pin 81 (SDMMC3_CD_B).
    
    As an added bonus this simplifies both the ACPI GPIO core code and the
    Cherryview pinctrl driver.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index eb4528c87c0b..b77c544bf7e2 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -58,58 +58,6 @@ static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 	return ACPI_HANDLE(gc->parent) == data;
 }
 
-#ifdef CONFIG_PINCTRL
-/**
- * acpi_gpiochip_pin_to_gpio_offset() - translates ACPI GPIO to Linux GPIO
- * @gdev: GPIO device
- * @pin: ACPI GPIO pin number from GpioIo/GpioInt resource
- *
- * Function takes ACPI GpioIo/GpioInt pin number as a parameter and
- * translates it to a corresponding offset suitable to be passed to a
- * GPIO controller driver.
- *
- * Typically the returned offset is same as @pin, but if the GPIO
- * controller uses pin controller and the mapping is not contiguous the
- * offset might be different.
- */
-static int acpi_gpiochip_pin_to_gpio_offset(struct gpio_device *gdev, int pin)
-{
-	struct gpio_pin_range *pin_range;
-
-	/* If there are no ranges in this chip, use 1:1 mapping */
-	if (list_empty(&gdev->pin_ranges))
-		return pin;
-
-	list_for_each_entry(pin_range, &gdev->pin_ranges, node) {
-		const struct pinctrl_gpio_range *range = &pin_range->range;
-		int i;
-
-		if (range->pins) {
-			for (i = 0; i < range->npins; i++) {
-				if (range->pins[i] == pin)
-					return range->base + i - gdev->base;
-			}
-		} else {
-			if (pin >= range->pin_base &&
-			    pin < range->pin_base + range->npins) {
-				unsigned gpio_base;
-
-				gpio_base = range->base - gdev->base;
-				return gpio_base + pin - range->pin_base;
-			}
-		}
-	}
-
-	return -EINVAL;
-}
-#else
-static inline int acpi_gpiochip_pin_to_gpio_offset(struct gpio_device *gdev,
-						   int pin)
-{
-	return pin;
-}
-#endif
-
 /**
  * acpi_get_gpiod() - Translate ACPI GPIO pin to GPIO descriptor usable with GPIO API
  * @path:	ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
@@ -125,7 +73,6 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	struct gpio_chip *chip;
 	acpi_handle handle;
 	acpi_status status;
-	int offset;
 
 	status = acpi_get_handle(NULL, path, &handle);
 	if (ACPI_FAILURE(status))
@@ -135,11 +82,7 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	if (!chip)
 		return ERR_PTR(-EPROBE_DEFER);
 
-	offset = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
-	if (offset < 0)
-		return ERR_PTR(offset);
-
-	return gpiochip_get_desc(chip, offset);
+	return gpiochip_get_desc(chip, pin);
 }
 
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
@@ -216,10 +159,6 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	if (!handler)
 		return AE_OK;
 
-	pin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
-	if (pin < 0)
-		return AE_BAD_PARAMETER;
-
 	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event");
 	if (IS_ERR(desc)) {
 		dev_err(chip->parent, "Failed to request GPIO\n");
@@ -852,12 +791,6 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		struct gpio_desc *desc;
 		bool found;
 
-		pin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
-		if (pin < 0) {
-			status = AE_BAD_PARAMETER;
-			goto out;
-		}
-
 		mutex_lock(&achip->conn_lock);
 
 		found = false;
@@ -990,11 +923,7 @@ static struct gpio_desc *acpi_gpiochip_parse_own_gpio(
 	if (ret < 0)
 		return ERR_PTR(ret);
 
-	ret = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, gpios[0]);
-	if (ret < 0)
-		return ERR_PTR(ret);
-
-	desc = gpiochip_get_desc(chip, ret);
+	desc = gpiochip_get_desc(chip, gpios[0]);
 	if (IS_ERR(desc))
 		return desc;
 

commit e40a3ae1f794a35c4af3746291ed6fedc1fa0f6f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Sep 6 17:47:45 2017 +0200

    gpio: acpi: work around false-positive -Wstring-overflow warning
    
    gcc-7 notices that the pin_table is an array of 16-bit numbers,
    but fails to take the following range check into account:
    
    drivers/gpio/gpiolib-acpi.c: In function 'acpi_gpiochip_request_interrupt':
    drivers/gpio/gpiolib-acpi.c:206:24: warning: '%02X' directive writing between 2 and 4 bytes into a region of size 3 [-Wformat-overflow=]
       sprintf(ev_name, "_%c%02X",
                            ^~~~
    drivers/gpio/gpiolib-acpi.c:206:20: note: directive argument in the range [0, 65535]
       sprintf(ev_name, "_%c%02X",
                        ^~~~~~~~~
    drivers/gpio/gpiolib-acpi.c:206:3: note: 'sprintf' output between 5 and 7 bytes into a destination of size 5
       sprintf(ev_name, "_%c%02X",
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
        agpio->triggering == ACPI_EDGE_SENSITIVE ? 'E' : 'L',
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        pin);
        ~~~~
    
    As suggested by Andy, this changes the format string to have a fixed length.
    Since modifying the range check did not help, I also opened a bug against
    gcc, see link below.
    
    Fixes: 0d1c28a449c6 ("gpiolib-acpi: Add ACPI5 event model support to gpio.")
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://patchwork.kernel.org/patch/9840801/
    Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82123
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 4d2113530735..eb4528c87c0b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -203,7 +203,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	if (pin <= 255) {
 		char ev_name[5];
-		sprintf(ev_name, "_%c%02X",
+		sprintf(ev_name, "_%c%02hhX",
 			agpio->triggering == ACPI_EDGE_SENSITIVE ? 'E' : 'L',
 			pin);
 		if (ACPI_SUCCESS(acpi_get_handle(handle, ev_name, &evt_handle)))

commit db05c7ef5465341d8a73ebe70c39b7ba6ddf2f48
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 24 16:57:25 2017 +0200

    gpio: acpi: Fixup kerneldoc
    
    Fix up a parameter description to match the code and fix markup for a
    constant to prettify output.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index c9b42dd12dfa..4d2113530735 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -61,7 +61,7 @@ static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 #ifdef CONFIG_PINCTRL
 /**
  * acpi_gpiochip_pin_to_gpio_offset() - translates ACPI GPIO to Linux GPIO
- * @chip: GPIO chip
+ * @gdev: GPIO device
  * @pin: ACPI GPIO pin number from GpioIo/GpioInt resource
  *
  * Function takes ACPI GpioIo/GpioInt pin number as a parameter and
@@ -763,7 +763,7 @@ struct gpio_desc *acpi_node_get_gpiod(struct fwnode_handle *fwnode,
  * The function is idempotent, though each time it runs it will configure GPIO
  * pin direction according to the flags in GpioInt resource.
  *
- * Return: Linux IRQ number (>%0) on success, negative errno on failure.
+ * Return: Linux IRQ number (> %0) on success, negative errno on failure.
  */
 int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 {

commit c7d28eca1d58d335ff8de6f33559b221bdd029f9
Merge: dddd564dbb59 413058df4331
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 12:40:27 2017 -0700

    Merge tag 'gpio-v4.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.13 series.
    
      Some administrativa:
    
      I have a slew of 8250 serial patches and the new IOT2040 serial+GPIO
      driver coming in through this tree, along with a whole bunch of Exar
      8250 fixes. These are ACKed by Greg and also hit drivers/platform/*
      where they are ACKed by Andy Shevchenko.
    
      Speaking about drivers/platform/* there is also a bunch of ACPI stuff
      coming through that route, again ACKed by Andy.
    
      The MCP23S08 changes are coming in here as well. You already have the
      commits in your tree, so this is just a result of sharing an immutable
      branch between pin control and GPIO.
    
      Core:
       - Export add/remove for lookup tables so that modules can export GPIO
         descriptor tables.
       - Handle GPIO sleep states: it is now possible to flag that a GPIO
         line may loose its state during suspend/resume of the system to
         save power. This is used in the Wolfson Micro Arizona driver.
       - ACPI-based GPIO was tightened up a lot around the edges.
       - Use bitmap_fill() to speed up a loop.
    
      New drivers:
       - Exar XRA1403 SPI-based GPIO.
       - MVEBU driver now supports Armada 7K and 8K.
       - LP87565 PMIC GPIO.
       - Renesas R-CAR R8A7743 (RZ/G1M).
       - The new IOT2040 8250 serial/GPIO also comes in through this
         changeset.
    
      Substantial driver changes:
       - Seriously fix the Exar 8250 GPIO portions to work.
       - The MCP23S08 was moved out to a pin control driver.
       - Convert MEVEBU to use regmap for register access.
       - Drop Vulcan support from the Broadcom driver.
       - Serious cleanup and improvement of the mockup driver, giving us a
         better test coverage.
    
      Misc:
       - Lots of janitorial clean up.
       - A bunch of documentation fixes"
    
    * tag 'gpio-v4.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (70 commits)
      serial: exar: Add support for IOT2040 device
      gpio-exar/8250-exar: Make set of exported GPIOs configurable
      platform: Accept const properties
      serial: exar: Factor out platform hooks
      gpio-exar/8250-exar: Rearrange gpiochip parenthood
      gpio: exar: Fix iomap request
      gpio-exar/8250-exar: Do not even instantiate a GPIO device for Commtech cards
      serial: uapi: Add support for bus termination
      gpio: rcar: Add R8A7743 (RZ/G1M) support
      gpio: gpio-wcove: Fix GPIO control register offset calculation
      gpio: lp87565: Add support for GPIO
      gpio: dwapb: fix missing first irq for edgeboth irq type
      MAINTAINERS: Take maintainership for GPIO ACPI support
      gpio: exar: Fix reading of directions and values
      gpio: exar: Allocate resources on behalf of the platform device
      gpio-exar/8250-exar: Fix passing in of parent PCI device
      gpio: mockup: use devm_kcalloc() where applicable
      gpio: mockup: add myself as author
      gpio: mockup: improve the error message
      gpio: mockup: don't return magic numbers from probe()
      ...

commit c06632ea054c49510efacb42c52aab693c45b7ba
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jun 23 09:26:13 2017 +0200

    gpio: acpi: Skip _AEI entries without a handler rather then aborting the scan
    
    acpi_walk_resources will stop as soon as the callback passed in returns
    an error status. On a x86 tablet I have the first GpioInt in the _AEI
    resource list has no handler defined in the DSDT, causing
    acpi_walk_resources to abort scanning the rest of the resource list,
    which does define valid ACPI GPIO events.
    
    This commit changes the return for not finding a handler from
    AE_BAD_PARAMETER to AE_OK so that the rest of the resource list will
    get scanned normally in case of missing event handlers.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 2185232da823..8fa5fcd00e9a 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -201,7 +201,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 			handler = acpi_gpio_irq_handler_evt;
 	}
 	if (!handler)
-		return AE_BAD_PARAMETER;
+		return AE_OK;
 
 	pin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
 	if (pin < 0)

commit 25e3ef894eef419ee239da42edc6c1f8a4f1cfb5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 23 20:03:24 2017 +0300

    gpio: acpi: Split out acpi_gpio_get_irq_resource() helper
    
    The helper does retrieve pointer to struct acpi_resource_gpio from
    struct acpi_resource if it represents GpioInt() resource.
    
    It will be used by PNP code later on.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index e431222edc2b..6bea176b066c 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -165,6 +165,23 @@ static void acpi_gpio_chip_dh(acpi_handle handle, void *data)
 	/* The address of this function is used as a key. */
 }
 
+bool acpi_gpio_get_irq_resource(struct acpi_resource *ares,
+				struct acpi_resource_gpio **agpio)
+{
+	struct acpi_resource_gpio *gpio;
+
+	if (ares->type != ACPI_RESOURCE_TYPE_GPIO)
+		return false;
+
+	gpio = &ares->data.gpio;
+	if (gpio->connection_type != ACPI_RESOURCE_GPIO_TYPE_INT)
+		return false;
+
+	*agpio = gpio;
+	return true;
+}
+EXPORT_SYMBOL_GPL(acpi_gpio_get_irq_resource);
+
 static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 						   void *context)
 {
@@ -178,11 +195,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	unsigned long irqflags;
 	int ret, pin, irq;
 
-	if (ares->type != ACPI_RESOURCE_TYPE_GPIO)
-		return AE_OK;
-
-	agpio = &ares->data.gpio;
-	if (agpio->connection_type != ACPI_RESOURCE_GPIO_TYPE_INT)
+	if (!acpi_gpio_get_irq_resource(ares, &agpio))
 		return AE_OK;
 
 	handle = ACPI_HANDLE(chip->parent);

commit a31f5c3a68520ee6a2adee7d5f13f2e6ef209875
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 23 20:03:23 2017 +0300

    gpio: acpi: Override GPIO initialization flags
    
    This allows ACPI GPIO code to modify flags based on
    ACPI GpioIo() / GpioInt() resources.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index cb61e11558a5..e431222edc2b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -448,6 +448,34 @@ acpi_gpio_to_gpiod_flags(const struct acpi_resource_gpio *agpio)
 	}
 }
 
+int
+acpi_gpio_update_gpiod_flags(enum gpiod_flags *flags, enum gpiod_flags update)
+{
+	int ret = 0;
+
+	/*
+	 * Check if the BIOS has IoRestriction with explicitly set direction
+	 * and update @flags accordingly. Otherwise use whatever caller asked
+	 * for.
+	 */
+	if (update & GPIOD_FLAGS_BIT_DIR_SET) {
+		enum gpiod_flags diff = *flags ^ update;
+
+		/*
+		 * Check if caller supplied incompatible GPIO initialization
+		 * flags.
+		 *
+		 * Return %-EINVAL to notify that firmware has different
+		 * settings and we are going to use them.
+		 */
+		if (((*flags & GPIOD_FLAGS_BIT_DIR_SET) && (diff & GPIOD_FLAGS_BIT_DIR_OUT)) ||
+		    ((*flags & GPIOD_FLAGS_BIT_DIR_OUT) && (diff & GPIOD_FLAGS_BIT_DIR_VAL)))
+			ret = -EINVAL;
+		*flags = update;
+	}
+	return ret;
+}
+
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
@@ -485,8 +513,11 @@ static int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)
 		 * - ACPI_ACTIVE_HIGH == GPIO_ACTIVE_HIGH
 		 */
 		if (lookup->info.gpioint) {
+			lookup->info.flags = GPIOD_IN;
 			lookup->info.polarity = agpio->polarity;
 			lookup->info.triggering = agpio->triggering;
+		} else {
+			lookup->info.flags = acpi_gpio_to_gpiod_flags(agpio);
 		}
 
 	}
@@ -613,13 +644,14 @@ static struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 struct gpio_desc *acpi_find_gpio(struct device *dev,
 				 const char *con_id,
 				 unsigned int idx,
-				 enum gpiod_flags flags,
+				 enum gpiod_flags *dflags,
 				 enum gpio_lookup_flags *lookupflags)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
 	struct acpi_gpio_info info;
 	struct gpio_desc *desc;
 	char propname[32];
+	int err;
 	int i;
 
 	/* Try first from _DSD */
@@ -650,7 +682,7 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 	}
 
 	if (info.gpioint &&
-	    (flags == GPIOD_OUT_LOW || flags == GPIOD_OUT_HIGH)) {
+	    (*dflags == GPIOD_OUT_LOW || *dflags == GPIOD_OUT_HIGH)) {
 		dev_dbg(dev, "refusing GpioInt() entry when doing GPIOD_OUT_* lookup\n");
 		return ERR_PTR(-ENOENT);
 	}
@@ -658,6 +690,10 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 	if (info.polarity == GPIO_ACTIVE_LOW)
 		*lookupflags |= GPIO_ACTIVE_LOW;
 
+	err = acpi_gpio_update_gpiod_flags(dflags, info.flags);
+	if (err)
+		dev_dbg(dev, "Override GPIO initialization flags\n");
+
 	return desc;
 }
 
@@ -711,12 +747,16 @@ struct gpio_desc *acpi_node_get_gpiod(struct fwnode_handle *fwnode,
  * used to translate from the GPIO offset in the resource to the Linux IRQ
  * number.
  *
+ * The function is idempotent, though each time it runs it will configure GPIO
+ * pin direction according to the flags in GpioInt resource.
+ *
  * Return: Linux IRQ number (>%0) on success, negative errno on failure.
  */
 int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 {
 	int idx, i;
 	unsigned int irq_flags;
+	int ret;
 
 	for (i = 0, idx = 0; idx <= index; i++) {
 		struct acpi_gpio_info info;
@@ -729,6 +769,7 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 			return PTR_ERR(desc);
 
 		if (info.gpioint && idx++ == index) {
+			char label[32];
 			int irq;
 
 			if (IS_ERR(desc))
@@ -738,6 +779,11 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 			if (irq < 0)
 				return irq;
 
+			snprintf(label, sizeof(label), "GpioInt() %d", index);
+			ret = gpiod_configure_flags(desc, label, 0, info.flags);
+			if (ret < 0)
+				return ret;
+
 			irq_flags = acpi_dev_get_irq_type(info.triggering,
 							  info.polarity);
 

commit 2eca25af05481c7e462cbc077328e0eb3394d06b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 23 20:03:22 2017 +0300

    gpio: acpi: Factor out acpi_gpio_to_gpiod_flags() helper
    
    The helper function acpi_gpio_to_gpiod_flags() will be used later to configure
    pin properly whenever it's requested.
    
    While here, introduce a checking error code returned by gpiod_configure_flags()
    and bail out if it's not okay.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 740df0e9dcb3..cb61e11558a5 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -423,6 +423,31 @@ static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
 	return false;
 }
 
+static enum gpiod_flags
+acpi_gpio_to_gpiod_flags(const struct acpi_resource_gpio *agpio)
+{
+	bool pull_up = agpio->pin_config == ACPI_PIN_CONFIG_PULLUP;
+
+	switch (agpio->io_restriction) {
+	case ACPI_IO_RESTRICT_INPUT:
+		return GPIOD_IN;
+	case ACPI_IO_RESTRICT_OUTPUT:
+		/*
+		 * ACPI GPIO resources don't contain an initial value for the
+		 * GPIO. Therefore we deduce that value from the pull field
+		 * instead. If the pin is pulled up we assume default to be
+		 * high, otherwise low.
+		 */
+		return pull_up ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;
+	default:
+		/*
+		 * Assume that the BIOS has configured the direction and pull
+		 * accordingly.
+		 */
+		return GPIOD_ASIS;
+	}
+}
+
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
@@ -740,7 +765,6 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 	struct acpi_resource *ares;
 	int pin_index = (int)address;
 	acpi_status status;
-	bool pull_up;
 	int length;
 	int i;
 
@@ -755,7 +779,6 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 	}
 
 	agpio = &ares->data.gpio;
-	pull_up = agpio->pin_config == ACPI_PIN_CONFIG_PULLUP;
 
 	if (WARN_ON(agpio->io_restriction == ACPI_IO_RESTRICT_INPUT &&
 	    function == ACPI_WRITE)) {
@@ -806,35 +829,23 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		}
 
 		if (!found) {
-			desc = gpiochip_request_own_desc(chip, pin,
-							 "ACPI:OpRegion");
+			enum gpiod_flags flags = acpi_gpio_to_gpiod_flags(agpio);
+			const char *label = "ACPI:OpRegion";
+			int err;
+
+			desc = gpiochip_request_own_desc(chip, pin, label);
 			if (IS_ERR(desc)) {
 				status = AE_ERROR;
 				mutex_unlock(&achip->conn_lock);
 				goto out;
 			}
 
-			switch (agpio->io_restriction) {
-			case ACPI_IO_RESTRICT_INPUT:
-				gpiod_direction_input(desc);
-				break;
-			case ACPI_IO_RESTRICT_OUTPUT:
-				/*
-				 * ACPI GPIO resources don't contain an
-				 * initial value for the GPIO. Therefore we
-				 * deduce that value from the pull field
-				 * instead. If the pin is pulled up we
-				 * assume default to be high, otherwise
-				 * low.
-				 */
-				gpiod_direction_output(desc, pull_up);
-				break;
-			default:
-				/*
-				 * Assume that the BIOS has configured the
-				 * direction and pull accordingly.
-				 */
-				break;
+			err = gpiod_configure_flags(desc, label, 0, flags);
+			if (err < 0) {
+				status = AE_NOT_CONFIGURED;
+				gpiochip_free_own_desc(desc);
+				mutex_unlock(&achip->conn_lock);
+				goto out;
 			}
 
 			conn = kzalloc(sizeof(*conn), GFP_KERNEL);

commit 6fe9da42f1d98fdb4be1598e230aca97e66cf35d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 23 20:03:20 2017 +0300

    gpio: acpi: Synchronize acpi_find_gpio() and acpi_gpio_count()
    
    If we pass connection ID to the both functions and at the same time
    acpi_can_fallback_to_crs() returns false we will get different results,
    i.e. the number of GPIO resources returned by acpi_gpio_count() might be
    not correct.
    
    Fix this by calling acpi_can_fallback_to_crs() in acpi_gpio_count()
    before trying to fallback.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 0392d8ed332f..740df0e9dcb3 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1119,6 +1119,9 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 		struct list_head resource_list;
 		unsigned int crs_count = 0;
 
+		if (!acpi_can_fallback_to_crs(adev, con_id))
+			return count;
+
 		INIT_LIST_HEAD(&resource_list);
 		acpi_dev_get_resources(adev, &resource_list,
 				       acpi_find_gpio_count, &crs_count);

commit f10e4bf6632b5be11cea875b66ba959833a69258
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 23 20:03:19 2017 +0300

    gpio: acpi: Even more tighten up ACPI GPIO lookups
    
    The commit 10cf4899f8af ("gpiolib: tighten up ACPI legacy gpio lookups")
    prevents to getting same resource twice if the driver asks twice using
    different connection ID.
    
    But the whole idea of fallback might bring some problems. Imagine the case when
    we have two versions of BIOS/hardware where in one _DSD is introduced along
    with GPIO resources, but the other one uses just plain GPIO resource for
    another purpose
    
    Case 1:
    
        Device (DEVX)
        {
            ...
            Name (_CRS, ResourceTemplate ()
            {
                GpioIo (Exclusive, PullUp, 0, 0, IoRestrictionInputOnly,
                        "\\_SB.GPO0", 0, ResourceConsumer) {15}
            })
            Name (_DSD, Package ()
            {
                ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
                Package ()
                {
                    Package () {"some-gpios", Package() {^DEVX, 0, 0, 0 }},
                }
            })
        }
    
    Case 2:
    
        Device (DEVX)
        {
            ...
            Name (_CRS, ResourceTemplate ()
            {
                GpioIo (Exclusive, PullUp, 0, 0, IoRestrictionInputOnly,
                        "\\_SB.GPO0", 0, ResourceConsumer) {27}
            })
        }
    
    To prevent the possible misconfiguration tighten up even more GPIO ACPI lookups
    for case without connection ID provided.
    
    In the past the issue had been triggered by "use mctrl_gpio helpers" series
    [1,2].
    
    [1] commit 4ef03d328769 ("tty/serial/8250: use mctrl_gpio helpers")
    [2] https://patchwork.kernel.org/patch/9283745/
    
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Bastien Nocera <hadess@hadess.net>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 28f35a9de86b..0392d8ed332f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1129,45 +1129,11 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 	return count ? count : -ENOENT;
 }
 
-struct acpi_crs_lookup {
-	struct list_head node;
-	struct acpi_device *adev;
-	const char *con_id;
-};
-
-static DEFINE_MUTEX(acpi_crs_lookup_lock);
-static LIST_HEAD(acpi_crs_lookup_list);
-
 bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
 {
-	struct acpi_crs_lookup *l, *lookup = NULL;
-
 	/* Never allow fallback if the device has properties */
 	if (adev->data.properties || adev->driver_gpios)
 		return false;
 
-	mutex_lock(&acpi_crs_lookup_lock);
-
-	list_for_each_entry(l, &acpi_crs_lookup_list, node) {
-		if (l->adev == adev) {
-			lookup = l;
-			break;
-		}
-	}
-
-	if (!lookup) {
-		lookup = kmalloc(sizeof(*lookup), GFP_KERNEL);
-		if (lookup) {
-			lookup->adev = adev;
-			lookup->con_id = kstrdup(con_id, GFP_KERNEL);
-			list_add_tail(&lookup->node, &acpi_crs_lookup_list);
-		}
-	}
-
-	mutex_unlock(&acpi_crs_lookup_lock);
-
-	return lookup &&
-		((!lookup->con_id && !con_id) ||
-		 (lookup->con_id && con_id &&
-		  strcmp(lookup->con_id, con_id) == 0));
+	return con_id == NULL;
 }

commit fe06b56cbf9fd6392f31ba1c782a3134daef7c80
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 23 20:03:18 2017 +0300

    gpio: acpi: Do sanity check for GpioInt in acpi_find_gpio()
    
    Check that we don't ask for output direction on GpioInt resource
    in cases with or without _DSD defined.
    
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 055a8a255a40..28f35a9de86b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -622,12 +622,12 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 		desc = acpi_get_gpiod_by_index(adev, NULL, idx, &info);
 		if (IS_ERR(desc))
 			return desc;
+	}
 
-		if ((flags == GPIOD_OUT_LOW || flags == GPIOD_OUT_HIGH) &&
-		    info.gpioint) {
-			dev_dbg(dev, "refusing GpioInt() entry when doing GPIOD_OUT_* lookup\n");
-			return ERR_PTR(-ENOENT);
-		}
+	if (info.gpioint &&
+	    (flags == GPIOD_OUT_LOW || flags == GPIOD_OUT_HIGH)) {
+		dev_dbg(dev, "refusing GpioInt() entry when doing GPIOD_OUT_* lookup\n");
+		return ERR_PTR(-ENOENT);
 	}
 
 	if (info.polarity == GPIO_ACTIVE_LOW)

commit 9e66504a919439448dfc57052ddf01b96964bdf7
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 23 20:03:17 2017 +0300

    gpio: acpi: Align acpi_find_gpio() with DT version
    
    By some reason acpi_find_gpio() and acpi_gpio_count() have compared
    connection ID to "gpios" when tries to check if suffix is needed or not.
    
    Don't do any assumptions about what connection ID can be and, when defined,
    use it only with suffix as it's done in the device tree version.
    
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 2185232da823..055a8a255a40 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -599,7 +599,7 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 
 	/* Try first from _DSD */
 	for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {
-		if (con_id && strcmp(con_id, "gpios")) {
+		if (con_id) {
 			snprintf(propname, sizeof(propname), "%s-%s",
 				 con_id, gpio_suffixes[i]);
 		} else {
@@ -1089,7 +1089,7 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 
 	/* Try first from _DSD */
 	for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {
-		if (con_id && strcmp(con_id, "gpios"))
+		if (con_id)
 			snprintf(propname, sizeof(propname), "%s-%s",
 				 con_id, gpio_suffixes[i]);
 		else

commit 2bd80401743568ced7d303b008ae5298ce77e695
Merge: 99a7583de5ff b86c86aa9805
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 4 12:05:32 2017 -0700

    Merge tag 'gpio-v4.12-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.12 kernel cycle.
    
      Core changes:
    
       - Return NULL from gpiod_get_optional() when GPIOLIB is disabled.
         This was a much discussed change. It affects use cases where people
         write drivers that might or might not be using GPIO resources. I
         have decided that this is the lesser evil right now.
    
       - Make gpiod_count() behave consistently across different hardware
         descriptions.
    
       - Fix the syntax around open drain/open source to not infer active
         high/low semantics.
    
      New drivers:
    
       - A new single-register fixed-direction framework driver for hardware
         that have lines controlled by a single register that just work in
         one direction (out or in), including IRQ support.
    
       - Support the Fintek F71889A GPIO SuperIO controller.
    
       - Support the National NI 169445 MMIO GPIO.
    
       - Support for the X-Gene derivative of the DWC GPIO controller
    
       - Support for the Rohm BD9571MWV-M PMIC GPIO controller.
    
       - Refactor the Gemini GPIO driver to a generic Faraday FTGPIO driver
         and replace both the Gemini and the Moxa ART custom drivers with
         this driver.
    
      Driver improvements:
    
       - A whole slew of drivers have their spinlocks chaned to raw
         spinlocks as they provide irqchips, and thus we are progressing on
         realtime compliance.
    
       - Use devm_irq_alloc_descs() in a slew of drivers, getting managed
         resources.
    
       - Support for the embedded PWM controller inside the MVEBU driver.
    
       - Debounce, open source and open drain support for the Aspeed driver.
    
       - Misc smaller fixes like spelling and syntax and whatnot"
    
    * tag 'gpio-v4.12-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (77 commits)
      gpio: f7188x: Add a missing break
      gpio: omap: return error if requested debounce time is not possible
      gpio: Add ROHM BD9571MWV-M PMIC GPIO driver
      gpio: gpio-wcove: fix GPIO IRQ status mask
      gpio: DT bindings, move tca9554 from pcf857x to pca953x
      gpio: move tca9554 from pcf857x to pca953x
      gpio: arizona: Correct check whether the pin is an input
      gpio: Add XRA1403 DTS binding documentation
      dt-bindings: add exar to vendor prefixes list
      gpio: gpio-wcove: fix irq pending status bit width
      gpio: dwapb: use dwapb_read instead of readl_relaxed
      gpio: aspeed: Add open-source and open-drain support
      gpio: aspeed: Add debounce support
      gpio: aspeed: dt: Add optional clocks property
      gpio: aspeed: dt: Fix description alignment in bindings document
      gpio: mvebu: Add limited PWM support
      gpio: Use unsigned int for interrupt numbers
      gpio: f7188x: Add F71889A GPIO support.
      gpio: core: Decouple open drain/source flag with active low/high
      gpio: arizona: Correct handling for reading input GPIOs
      ...

commit 693bdaa164b40b7aa6018b98af6f7e40dbd52457
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Mar 23 13:21:38 2017 -0700

    ACPI / gpio: do not fall back to parsing _CRS when we get a deferral
    
    If, while locating GPIOs by name, we get probe deferral, we should
    immediately report it to caller rather than trying to fall back to parsing
    unnamed GPIOs from _CRS block.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-and-Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 8e318f449d23..2bd683e2be02 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -577,8 +577,10 @@ struct gpio_desc *acpi_find_gpio(struct device *dev,
 		}
 
 		desc = acpi_get_gpiod_by_index(adev, propname, idx, &info);
-		if (!IS_ERR(desc) || (PTR_ERR(desc) == -EPROBE_DEFER))
+		if (!IS_ERR(desc))
 			break;
+		if (PTR_ERR(desc) == -EPROBE_DEFER)
+			return ERR_CAST(desc);
 	}
 
 	/* Then from plain _CRS GPIOs */

commit 8a146fbe1f1461aebc9b8f06a0f22e1a8a4f0dd1
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Mar 24 11:08:47 2017 +0100

    gpio: acpi: Call enable_irq_wake for _IAE GpioInts with Wake set
    
    On Bay Trail / Cherry Trail systems with a LID switch, the LID switch is
    often connect to a gpioint handled by an _IAE event handler.
    Before this commit such systems would not wake up when opening the lid,
    requiring the powerbutton to be pressed after opening the lid to wakeup.
    
    Note that Bay Trail / Cherry Trail systems use suspend-to-idle, so
    the interrupts are generated anyway on those lines on lid switch changes,
    but they are treated by the IRQ subsystem as spurious while suspended if
    not marked as wakeup IRQs.
    
    This commit calls enable_irq_wake() for _IAE GpioInts with a valid
    event handler which have their Wake flag set. This fixes such systems
    not waking up when opening the lid.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 9b37a3692b3f..8e318f449d23 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -266,6 +266,9 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 		goto fail_free_event;
 	}
 
+	if (agpio->wake_capable == ACPI_WAKE_CAPABLE)
+		enable_irq_wake(irq);
+
 	list_add_tail(&event->node, &acpi_gpio->events);
 	return AE_OK;
 
@@ -339,6 +342,9 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
 		struct gpio_desc *desc;
 
+		if (irqd_is_wakeup_set(irq_get_irq_data(event->irq)))
+			disable_irq_wake(event->irq);
+
 		free_irq(event->irq, event);
 		desc = event->desc;
 		if (WARN_ON(IS_ERR(desc)))

commit 6798d7271cb44ba8354356a389047d84058a7828
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Mar 13 23:04:21 2017 +0100

    gpio: acpi: Ignore -EPROBE_DEFER for unselected gpioints
    
    When acpi_dev_gpio_irq_get gets called with an index of say 2, it should
    not care if acpi_get_gpiod for index 0 or 1 returns -EPROBE_DEFER.
    
    This allows drivers which request a gpioint with index > 0 to function
    if there is no gpiochip driver (loaded) for gpioints with a lower index.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index a5b84d40e60c..56a6b1be3a17 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -684,20 +684,24 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 {
 	int idx, i;
 	unsigned int irq_flags;
-	int ret = -ENOENT;
 
 	for (i = 0, idx = 0; idx <= index; i++) {
 		struct acpi_gpio_info info;
 		struct gpio_desc *desc;
 
 		desc = acpi_get_gpiod_by_index(adev, NULL, i, &info);
-		if (IS_ERR(desc)) {
-			ret = PTR_ERR(desc);
-			break;
-		}
+
+		/* Ignore -EPROBE_DEFER, it only matters if idx matches */
+		if (IS_ERR(desc) && PTR_ERR(desc) != -EPROBE_DEFER)
+			return PTR_ERR(desc);
+
 		if (info.gpioint && idx++ == index) {
-			int irq = gpiod_to_irq(desc);
+			int irq;
+
+			if (IS_ERR(desc))
+				return PTR_ERR(desc);
 
+			irq = gpiod_to_irq(desc);
 			if (irq < 0)
 				return irq;
 
@@ -713,7 +717,7 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 		}
 
 	}
-	return ret;
+	return -ENOENT;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_get);
 

commit 4ed55016d763325887461d43d0aec4010adcab65
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 20 18:15:46 2017 +0200

    gpio: acpi: Don't return 0 on acpi_gpio_count()
    
    It's unusual to have error checking like (ret <= 0) in cases when
    counting GPIO resources. In case when it's mandatory we propagate the
    error (-ENOENT), otherwise we don't use the result.
    
    This makes consistent behaviour across all possible variants called in
    gpiod_count().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 108331de440b..a5b84d40e60c 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1098,7 +1098,7 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 					break;
 				}
 		}
-		if (count >= 0)
+		if (count > 0)
 			break;
 	}
 
@@ -1114,7 +1114,7 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 		if (crs_count > 0)
 			count = crs_count;
 	}
-	return count;
+	return count ? count : -ENOENT;
 }
 
 struct acpi_crs_lookup {

commit 85c73d50e57eb8ad43955fe38714bc5fba1acd92
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 2 15:48:05 2017 +0200

    gpio: acpi: Add managed variant of acpi_dev_add_driver_gpios()
    
    Introduce device managed variant of acpi_dev_add_driver_gpios() and its
    counterpart acpi_dev_remove_driver_gpios().
    
    The functions in most cases are used in driver's ->probe() and
    ->remove() callbacks, that's why it's useful to have managed variant of
    them.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 9b37a3692b3f..108331de440b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -362,6 +362,37 @@ int acpi_dev_add_driver_gpios(struct acpi_device *adev,
 }
 EXPORT_SYMBOL_GPL(acpi_dev_add_driver_gpios);
 
+static void devm_acpi_dev_release_driver_gpios(struct device *dev, void *res)
+{
+	acpi_dev_remove_driver_gpios(ACPI_COMPANION(dev));
+}
+
+int devm_acpi_dev_add_driver_gpios(struct device *dev,
+				   const struct acpi_gpio_mapping *gpios)
+{
+	void *res;
+	int ret;
+
+	res = devres_alloc(devm_acpi_dev_release_driver_gpios, 0, GFP_KERNEL);
+	if (!res)
+		return -ENOMEM;
+
+	ret = acpi_dev_add_driver_gpios(ACPI_COMPANION(dev), gpios);
+	if (ret) {
+		devres_free(res);
+		return ret;
+	}
+	devres_add(dev, res);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_acpi_dev_add_driver_gpios);
+
+void devm_acpi_dev_remove_driver_gpios(struct device *dev)
+{
+	WARN_ON(devres_release(dev, devm_acpi_dev_release_driver_gpios, NULL, NULL));
+}
+EXPORT_SYMBOL_GPL(devm_acpi_dev_remove_driver_gpios);
+
 static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
 				      const char *name, int index,
 				      struct acpi_reference_args *args)

commit e567c35f4909b6e752f63412ed6038c4d9aa9ede
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 3 19:01:18 2017 +0200

    gpiolib: Update documentation of struct acpi_gpio_info
    
    It seems the code had been changed, but description left untouched.
    
    Update description of the struct acpi_gpio_info and relative comments
    accordingly.
    
    Fixes: commit 52044723cd27 ("ACPI / gpio: Add irq_type when a GPIO is used as an interrupt")
    Cc: Christophe RICARD <christophe.ricard@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index a3faefa44f68..9b37a3692b3f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -416,9 +416,8 @@ static int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)
 			agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;
 
 		/*
-		 * ActiveLow is only specified for GpioInt resource. If
-		 * GpioIo is used then the only way to set the flag is
-		 * to use _DSD "gpios" property.
+		 * Polarity and triggering are only specified for GpioInt
+		 * resource.
 		 * Note: we expect here:
 		 * - ACPI_ACTIVE_LOW == GPIO_ACTIVE_LOW
 		 * - ACPI_ACTIVE_HIGH == GPIO_ACTIVE_HIGH

commit 061ad5038ca5ac75419204b216bddc2806008ead
Merge: e7aa8c2eb11b acf1fcf77247
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 07:54:57 2016 -0800

    Merge tag 'gpio-v4.10-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Luinus Walleij:
     "Bulk GPIO changes for the v4.10 kernel cycle:
    
      Core changes:
    
       - Simplify threaded interrupt handling: instead of passing numbed
         parameters to gpiochip_irqchip_add_chained() we create a new call:
         gpiochip_irqchip_add_nested() so the two types are clearly
         semantically different. Also make sure that all nested chips call
         gpiochip_set_nested_irqchip() which is necessary for IRQ resend to
         work properly if it happens.
    
       - Return error on seek operations for the chardev.
    
       - Clamp values set as part of gpio[d]_direction_output() so that
         anything != 0 will be send down to the driver as "1" not the value
         passed in.
    
       - ACPI can now support naming of GPIO lines, hogs and holes in the
         GPIO lists.
    
      New drivers:
    
       - The SX150x driver was deemed unfit for the GPIO subsystem and was
         moved over to a combined GPIO+pinctrl driver in the pinctrl
         subsystem.
    
      New features:
    
       - Various cleanups to various drivers"
    
    * tag 'gpio-v4.10-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (49 commits)
      gpio: merrifield: Implement gpio_get_direction callback
      gpio: merrifield: Add support for hardware debouncer
      gpio: chardev: Return error for seek operations
      gpio: arizona: Tidy up probe error path
      gpio: arizona: Remove pointless set of platform drvdata
      gpio: pl061: delete platform data handling
      gpio: pl061: move platform data into driver
      gpio: pl061: rename variable from chip to pl061
      gpio: pl061: rename state container struct
      gpio: pl061: use local state for parent IRQ storage
      gpio: set explicit nesting on drivers
      gpio: simplify adding threaded interrupts
      gpio: vf610: use builtin_platform_driver
      gpio: axp209: use correct register for GPIO input status
      gpio: stmpe: fix interrupt handling bug
      gpio: em: depnd on ARCH_SHMOBILE
      gpio: zx: depend on ARCH_ZX
      gpio: x86: update config dependencies for x86 specific hardware
      gpio: mb86s7x: use builtin_platform_driver
      gpio: etraxfs: use builtin_platform_driver
      ...

commit c82064f26f44ea13f097dfb58d5ffd4359dcabbb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 8 14:40:06 2016 +0100

    ACPI / gpio: avoid warning for gpio hogging code
    
    The newly added acpi_gpiochip_scan_gpios function produces a few harmless
    warnings:
    
    drivers/gpio/gpiolib-acpi.c: In function ‘acpi_gpiochip_add’:
    drivers/gpio/gpiolib-acpi.c:925:7: error: ‘dflags’ may be used uninitialized in this function [-Werror=maybe-uninitialized]
    drivers/gpio/gpiolib-acpi.c:925:9: error: ‘lflags’ may be used uninitialized in this function [-Werror=maybe-uninitialized]
    
    The problem is that he compiler cannot know that a negative return value
    from fwnode_property_read_u32_array() or acpi_gpiochip_pin_to_gpio_offset()
    implies that the IS_ERR(gpio_desc) is true, as the value could in theory
    be below -MAX_ERRNO.
    
    The function already initializes its output values to zero, and moving
    that intialization a little higher up ensures that we can never have
    uninitialized data in the caller.
    
    Fixes: c80f1ba75df2 ("ACPI / gpio: Add hogging support")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 83fcfff19cd6..fec93b994fe9 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -866,6 +866,10 @@ static struct gpio_desc *acpi_gpiochip_parse_own_gpio(
 	u32 gpios[2];
 	int ret;
 
+	*lflags = 0;
+	*dflags = 0;
+	*name = NULL;
+
 	ret = fwnode_property_read_u32_array(fwnode, "gpios", gpios,
 					     ARRAY_SIZE(gpios));
 	if (ret < 0)
@@ -879,10 +883,6 @@ static struct gpio_desc *acpi_gpiochip_parse_own_gpio(
 	if (IS_ERR(desc))
 		return desc;
 
-	*lflags = 0;
-	*dflags = 0;
-	*name = NULL;
-
 	if (gpios[1])
 		*lflags |= GPIO_ACTIVE_LOW;
 

commit 550a9532b8093ef554947e5d24b469ffb1ff9930
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Sat Oct 29 16:13:12 2016 +0000

    ACPI / gpio: make acpi_gpiochip_parse_own_gpio static
    
    Fixes the following sparse warning:
    
    drivers/gpio/gpiolib-acpi.c:863:18: warning:
     symbol 'acpi_gpiochip_parse_own_gpio' was not declared. Should it be static?
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index aa879d5eaa19..83fcfff19cd6 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -857,9 +857,9 @@ static void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)
 	}
 }
 
-struct gpio_desc *acpi_gpiochip_parse_own_gpio(struct acpi_gpio_chip *achip,
-	struct fwnode_handle *fwnode, const char **name, unsigned int *lflags,
-	unsigned int *dflags)
+static struct gpio_desc *acpi_gpiochip_parse_own_gpio(
+	struct acpi_gpio_chip *achip, struct fwnode_handle *fwnode,
+	const char **name, unsigned int *lflags, unsigned int *dflags)
 {
 	struct gpio_chip *chip = achip->chip;
 	struct gpio_desc *desc;

commit 1b6998c96ccc60a61bdb812b4a55866224ab9708
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Sat Oct 29 16:11:57 2016 +0000

    ACPI / gpio: add missing fwnode_handle_put() in acpi_gpiochip_scan_gpios()
    
    fwnode_handle_put() should be used when terminating
    device_for_each_child_node() iteration with break or
    return to prevent stale device node references from
    being left behind.
    
    This is detected by Coccinelle semantic patch.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 53266ef12008..aa879d5eaa19 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -922,6 +922,7 @@ static void acpi_gpiochip_scan_gpios(struct acpi_gpio_chip *achip)
 		ret = gpiod_hog(desc, name, lflags, dflags);
 		if (ret) {
 			dev_err(chip->parent, "Failed to hog GPIO\n");
+			fwnode_handle_put(fwnode);
 			return;
 		}
 	}

commit 4035cc15b99f4f4a4e29081b82aca010137e33da
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 21 17:21:32 2016 +0300

    ACPI / gpio: Add support for naming GPIOs
    
    Now that we have the new helper function that sets nice names for GPIO
    lines based on "gpio-line-names" device property, we can take advantage of
    this in acpi_gpiochip_add().
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 4f46982ce982..53266ef12008 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -957,6 +957,9 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 		return;
 	}
 
+	if (!chip->names)
+		devprop_gpiochip_set_names(chip);
+
 	acpi_gpiochip_request_regions(acpi_gpio);
 	acpi_gpiochip_scan_gpios(acpi_gpio);
 	acpi_walk_dep_device_list(handle);

commit c80f1ba75df25837fb76044e06686b6587d33f6a
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 21 17:21:30 2016 +0300

    ACPI / gpio: Add hogging support
    
    GPIO hogging means that the GPIO controller can "hog" and configure certain
    GPIOs without need for a driver or userspace to do that. This is useful in
    open-connected boards where BIOS cannot possibly know beforehand which
    devices will be connected to the board.
    
    This adds GPIO hogging mechanism to ACPI analogous to Device Tree.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 700ea6ad609b..4f46982ce982 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -857,6 +857,76 @@ static void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)
 	}
 }
 
+struct gpio_desc *acpi_gpiochip_parse_own_gpio(struct acpi_gpio_chip *achip,
+	struct fwnode_handle *fwnode, const char **name, unsigned int *lflags,
+	unsigned int *dflags)
+{
+	struct gpio_chip *chip = achip->chip;
+	struct gpio_desc *desc;
+	u32 gpios[2];
+	int ret;
+
+	ret = fwnode_property_read_u32_array(fwnode, "gpios", gpios,
+					     ARRAY_SIZE(gpios));
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	ret = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, gpios[0]);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	desc = gpiochip_get_desc(chip, ret);
+	if (IS_ERR(desc))
+		return desc;
+
+	*lflags = 0;
+	*dflags = 0;
+	*name = NULL;
+
+	if (gpios[1])
+		*lflags |= GPIO_ACTIVE_LOW;
+
+	if (fwnode_property_present(fwnode, "input"))
+		*dflags |= GPIOD_IN;
+	else if (fwnode_property_present(fwnode, "output-low"))
+		*dflags |= GPIOD_OUT_LOW;
+	else if (fwnode_property_present(fwnode, "output-high"))
+		*dflags |= GPIOD_OUT_HIGH;
+	else
+		return ERR_PTR(-EINVAL);
+
+	fwnode_property_read_string(fwnode, "line-name", name);
+
+	return desc;
+}
+
+static void acpi_gpiochip_scan_gpios(struct acpi_gpio_chip *achip)
+{
+	struct gpio_chip *chip = achip->chip;
+	struct fwnode_handle *fwnode;
+
+	device_for_each_child_node(chip->parent, fwnode) {
+		unsigned int lflags, dflags;
+		struct gpio_desc *desc;
+		const char *name;
+		int ret;
+
+		if (!fwnode_property_present(fwnode, "gpio-hog"))
+			continue;
+
+		desc = acpi_gpiochip_parse_own_gpio(achip, fwnode, &name,
+						    &lflags, &dflags);
+		if (IS_ERR(desc))
+			continue;
+
+		ret = gpiod_hog(desc, name, lflags, dflags);
+		if (ret) {
+			dev_err(chip->parent, "Failed to hog GPIO\n");
+			return;
+		}
+	}
+}
+
 void acpi_gpiochip_add(struct gpio_chip *chip)
 {
 	struct acpi_gpio_chip *acpi_gpio;
@@ -888,6 +958,7 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 	}
 
 	acpi_gpiochip_request_regions(acpi_gpio);
+	acpi_gpiochip_scan_gpios(acpi_gpio);
 	acpi_walk_dep_device_list(handle);
 }
 

commit 6f7194a10bdba1588357342c6daaaeef98e0004f
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 21 17:21:29 2016 +0300

    ACPI / gpio: Allow holes in list of GPIOs for a device
    
    Make it possible to have an empty GPIOs in a GPIO list for device. For
    example a SPI master may use both GPIOs and native pins as chip selects and
    we need to be able to distinguish between the two.
    
    This makes it mandatory to have exactly 3 arguments for GPIOs and then
    converts gpiolib to use of __acpi_node_get_property_reference() instead. In
    addition we make acpi_gpio_package_count() to handle holes as well (this
    matches the DT version).
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 58ece201b8e6..700ea6ad609b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -468,7 +468,8 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	int ret;
 
 	memset(&args, 0, sizeof(args));
-	ret = acpi_node_get_property_reference(fwnode, propname, index, &args);
+	ret = __acpi_node_get_property_reference(fwnode, propname, index, 3,
+						 &args);
 	if (ret) {
 		struct acpi_device *adev = to_acpi_device_node(fwnode);
 
@@ -483,13 +484,13 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 	 * on returned args.
 	 */
 	lookup->adev = args.adev;
-	if (args.nargs >= 2) {
-		lookup->index = args.args[0];
-		lookup->pin_index = args.args[1];
-		/* 3rd argument, if present is used to specify active_low. */
-		if (args.nargs >= 3)
-			lookup->active_low = !!args.args[2];
-	}
+	if (args.nargs != 3)
+		return -EPROTO;
+
+	lookup->index = args.args[0];
+	lookup->pin_index = args.args[1];
+	lookup->active_low = !!args.args[2];
+
 	return 0;
 }
 
@@ -915,18 +916,27 @@ void acpi_gpiochip_remove(struct gpio_chip *chip)
 	kfree(acpi_gpio);
 }
 
-static unsigned int acpi_gpio_package_count(const union acpi_object *obj)
+static int acpi_gpio_package_count(const union acpi_object *obj)
 {
 	const union acpi_object *element = obj->package.elements;
 	const union acpi_object *end = element + obj->package.count;
 	unsigned int count = 0;
 
 	while (element < end) {
-		if (element->type == ACPI_TYPE_LOCAL_REFERENCE)
+		switch (element->type) {
+		case ACPI_TYPE_LOCAL_REFERENCE:
+			element += 3;
+			/* Fallthrough */
+		case ACPI_TYPE_INTEGER:
+			element++;
 			count++;
+			break;
 
-		element++;
+		default:
+			return -EPROTO;
+		}
 	}
+
 	return count;
 }
 

commit 67bf5156edc4f58241fd7c119ae145c552adddd6
Author: David Arcari <darcari@redhat.com>
Date:   Wed Oct 12 18:40:30 2016 +0200

    gpio / ACPI: fix returned error from acpi_dev_gpio_irq_get()
    
    acpi_dev_gpio_irq_get() currently ignores the error returned
    by acpi_get_gpiod_by_index() and overwrites it with -ENOENT.
    
    Problem is this error can be -EPROBE_DEFER, which just blows
    up some drivers when the module ordering is not correct.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: David Arcari <darcari@redhat.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 58ece201b8e6..72a4b326fd0d 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -653,14 +653,17 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 {
 	int idx, i;
 	unsigned int irq_flags;
+	int ret = -ENOENT;
 
 	for (i = 0, idx = 0; idx <= index; i++) {
 		struct acpi_gpio_info info;
 		struct gpio_desc *desc;
 
 		desc = acpi_get_gpiod_by_index(adev, NULL, i, &info);
-		if (IS_ERR(desc))
+		if (IS_ERR(desc)) {
+			ret = PTR_ERR(desc);
 			break;
+		}
 		if (info.gpioint && idx++ == index) {
 			int irq = gpiod_to_irq(desc);
 
@@ -679,7 +682,7 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 		}
 
 	}
-	return -ENOENT;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_get);
 

commit 031ba28a8197a08e67b12d7ec935b24eb3638345
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Oct 3 10:40:03 2016 +0200

    gpio: acpi: separation of concerns
    
    The generic GPIO library directly implement code for acpi_find_gpio()
    which is only used with CONFIG_ACPI. This was probably done because
    OF did the same thing, but I removed that so remove this too.
    
    Rename the internal acpi_find_gpio() in gpiolib-acpi.c to
    acpi_populate_gpio_lookup() which seems to be more appropriate anyway
    so as to avoid a namespace clash with the same function.
    
    Make the stub return -ENOENT rather than -ENOSYS (as that is for
    syscalls!).
    
    For some reason the sunxi pin control driver was including the private
    gpiolib header, it works just fine without it so remove that oneliner.
    
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index af514618d7fb..58ece201b8e6 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -14,6 +14,7 @@
 #include <linux/gpio.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio/driver.h>
+#include <linux/gpio/machine.h>
 #include <linux/export.h>
 #include <linux/acpi.h>
 #include <linux/interrupt.h>
@@ -395,7 +396,7 @@ struct acpi_gpio_lookup {
 	int n;
 };
 
-static int acpi_find_gpio(struct acpi_resource *ares, void *data)
+static int acpi_populate_gpio_lookup(struct acpi_resource *ares, void *data)
 {
 	struct acpi_gpio_lookup *lookup = data;
 
@@ -440,7 +441,8 @@ static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
 
 	INIT_LIST_HEAD(&res_list);
 
-	ret = acpi_dev_get_resources(lookup->adev, &res_list, acpi_find_gpio,
+	ret = acpi_dev_get_resources(lookup->adev, &res_list,
+				     acpi_populate_gpio_lookup,
 				     lookup);
 	if (ret < 0)
 		return ret;
@@ -513,7 +515,7 @@ static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
  * Note: if the GPIO resource has multiple entries in the pin list, this
  * function only returns the first.
  */
-struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
+static struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 					  const char *propname, int index,
 					  struct acpi_gpio_info *info)
 {
@@ -546,6 +548,55 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 	return ret ? ERR_PTR(ret) : lookup.desc;
 }
 
+struct gpio_desc *acpi_find_gpio(struct device *dev,
+				 const char *con_id,
+				 unsigned int idx,
+				 enum gpiod_flags flags,
+				 enum gpio_lookup_flags *lookupflags)
+{
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	struct acpi_gpio_info info;
+	struct gpio_desc *desc;
+	char propname[32];
+	int i;
+
+	/* Try first from _DSD */
+	for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {
+		if (con_id && strcmp(con_id, "gpios")) {
+			snprintf(propname, sizeof(propname), "%s-%s",
+				 con_id, gpio_suffixes[i]);
+		} else {
+			snprintf(propname, sizeof(propname), "%s",
+				 gpio_suffixes[i]);
+		}
+
+		desc = acpi_get_gpiod_by_index(adev, propname, idx, &info);
+		if (!IS_ERR(desc) || (PTR_ERR(desc) == -EPROBE_DEFER))
+			break;
+	}
+
+	/* Then from plain _CRS GPIOs */
+	if (IS_ERR(desc)) {
+		if (!acpi_can_fallback_to_crs(adev, con_id))
+			return ERR_PTR(-ENOENT);
+
+		desc = acpi_get_gpiod_by_index(adev, NULL, idx, &info);
+		if (IS_ERR(desc))
+			return desc;
+
+		if ((flags == GPIOD_OUT_LOW || flags == GPIOD_OUT_HIGH) &&
+		    info.gpioint) {
+			dev_dbg(dev, "refusing GpioInt() entry when doing GPIOD_OUT_* lookup\n");
+			return ERR_PTR(-ENOENT);
+		}
+	}
+
+	if (info.polarity == GPIO_ACTIVE_LOW)
+		*lookupflags |= GPIO_ACTIVE_LOW;
+
+	return desc;
+}
+
 /**
  * acpi_node_get_gpiod() - get a GPIO descriptor from ACPI resources
  * @fwnode: pointer to an ACPI firmware node to get the GPIO information from

commit 3f86a6359afc3f573ddbb9e423b44b282dec939c
Author: Rui Zhang <rui.zhang@intel.com>
Date:   Wed Jun 15 08:47:51 2016 +0200

    gpio: acpi: add _DEP support for Acer One 10
    
    On Acer One 10, the ACPI battery driver can not be probed because
    it depends on the GPIO controller as well as the I2C controller to work,
            Device (BATC)
            {
                Name (_HID, EisaId ("PNP0C0A") /* Control Method Battery */)
                ...
                Name (_DEP, Package (0x03)  // _DEP: Dependencies
                {
                    I2C1,
                    GPO2,
                    GPO0
                })
                ...
            }
    
    The I2C dependency also exists on other platforms and has been fixed by commit
    40e7fcb19293 ("ACPI: Add _DEP support to fix battery issue on Asus T100TA"),
    this patch resolves the GPIO dependency for Acer One 10.
    
    Link:https://bugzilla.kernel.org/show_bug.cgi?id=115191
    Tested-by: Stace A. Zacharov <stace75@gmail.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 2dc52585e3f2..af514618d7fb 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -836,6 +836,7 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 	}
 
 	acpi_gpiochip_request_regions(acpi_gpio);
+	acpi_walk_dep_device_list(handle);
 }
 
 void acpi_gpiochip_remove(struct gpio_chip *chip)

commit 7df89e92a56a3d2c8f84aa76c61471e4a7bc24f9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Apr 25 16:01:19 2016 +0300

    gpiolib-acpi: Duplicate con_id string when adding it to the crs lookup list
    
    Calling gpiod_get() from a module and then unloading the module leads to an
    oops due to acpi_can_fallback_to_crs() storing the pointer to the passed
    'con_id' string onto acpi_crs_lookup_list. The next guy to come along will then
    try to access the string but the memory may now be gone with the module.
    Make a copy of the passed string instead, and store the copy on the list.
    
    BUG: unable to handle kernel paging request at ffffffffa03e7855
    IP: [<ffffffff81338322>] strcmp+0x12/0x30
    PGD 2a07067 PUD 2a08063 PMD 74720067 PTE 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: i915(+) drm_kms_helper drm intel_gtt snd_hda_codec snd_hda_core i2c_algo_bit syscopya
    rea sysfillrect sysimgblt fb_sys_fops agpgart snd_soc_sst_bytcr_rt5640 coretemp hwmon intel_rapl intel_soc_dts_thermal
    punit_atom_debug snd_soc_rt5640 snd_soc_rl6231 serio snd_intel_sst_acpi snd_intel_sst_core video snd_soc_sst_mfld_platf
    orm snd_soc_sst_match backlight int3402_thermal processor_thermal_device int3403_thermal int3400_thermal acpi_thermal_r
    el snd_soc_core intel_soc_dts_iosf int340x_thermal_zone snd_compress i2c_hid hid snd_pcm snd_timer snd soundcore evdev
    sch_fq_codel efivarfs ipv6 autofs4 [last unloaded: drm]
    CPU: 2 PID: 3064 Comm: modprobe Tainted: G     U  W       4.6.0-rc3-ffrd-ipvr+ #302
    Hardware name: Intel Corp. VALLEYVIEW C0 PLATFORM/BYT-T FFD8, BIOS BLAKFF81.X64.0088.R10.1403240443 FFD8
    _X64_R_2014_13_1_00 03/24/2014
    task: ffff8800701cd200 ti: ffff880070034000 task.ti: ffff880070034000
    RIP: 0010:[<ffffffff81338322>]  [<ffffffff81338322>] strcmp+0x12/0x30
    RSP: 0000:ffff880070037748  EFLAGS: 00010286
    RAX: 0000000080000000 RBX: ffff88007a342800 RCX: 0000000000000006
    RDX: 0000000000000006 RSI: ffffffffa054f856 RDI: ffffffffa03e7856
    RBP: ffff880070037748 R08: 0000000000000000 R09: 0000000000000001
    R10: 0000000000000000 R11: 0000000000000000 R12: ffffffffa054f855
    R13: ffff88007281cae0 R14: 0000000000000010 R15: ffffffffffffffea
    FS:  00007faa51447700(0000) GS:ffff880079300000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: ffffffffa03e7855 CR3: 0000000041eba000 CR4: 00000000001006e0
    Stack:
     ffff880070037770 ffffffff8136ad28 ffffffffa054f855 0000000000000000
     ffff88007a0a2098 ffff8800700377e8 ffffffff8136852e ffff88007a342800
     00000007700377a0 ffff8800700377a0 ffffffff81412442 70672d6c656e6170
    Call Trace:
     [<ffffffff8136ad28>] acpi_can_fallback_to_crs+0x88/0x100
     [<ffffffff8136852e>] gpiod_get_index+0x25e/0x310
     [<ffffffff81412442>] ? mipi_dsi_attach+0x22/0x30
     [<ffffffff813685f2>] gpiod_get+0x12/0x20
     [<ffffffffa04fcf41>] intel_dsi_init+0x421/0x480 [i915]
     [<ffffffffa04d3783>] intel_modeset_init+0x853/0x16b0 [i915]
     [<ffffffffa0504864>] ? intel_setup_gmbus+0x214/0x260 [i915]
     [<ffffffffa0510158>] i915_driver_load+0xdc8/0x19b0 [i915]
     [<ffffffff8160fb53>] ? _raw_spin_unlock_irqrestore+0x43/0x70
     [<ffffffffa026b13b>] drm_dev_register+0xab/0xc0 [drm]
     [<ffffffffa026d7b3>] drm_get_pci_dev+0x93/0x1f0 [drm]
     [<ffffffff8160fb53>] ? _raw_spin_unlock_irqrestore+0x43/0x70
     [<ffffffffa043f1f4>] i915_pci_probe+0x34/0x50 [i915]
     [<ffffffff81379751>] pci_device_probe+0x91/0x100
     [<ffffffff8141a75a>] driver_probe_device+0x20a/0x2d0
     [<ffffffff8141a8be>] __driver_attach+0x9e/0xb0
     [<ffffffff8141a820>] ? driver_probe_device+0x2d0/0x2d0
     [<ffffffff81418439>] bus_for_each_dev+0x69/0xa0
     [<ffffffff8141a04e>] driver_attach+0x1e/0x20
     [<ffffffff81419c20>] bus_add_driver+0x1c0/0x240
     [<ffffffff8141b6d0>] driver_register+0x60/0xe0
     [<ffffffff81377d20>] __pci_register_driver+0x60/0x70
     [<ffffffffa026d9f4>] drm_pci_init+0xe4/0x110 [drm]
     [<ffffffff810ce04e>] ? trace_hardirqs_on+0xe/0x10
     [<ffffffffa02f1000>] ? 0xffffffffa02f1000
     [<ffffffffa02f1094>] i915_init+0x94/0x9b [i915]
     [<ffffffff810003bb>] do_one_initcall+0x8b/0x1c0
     [<ffffffff810eb616>] ? rcu_read_lock_sched_held+0x86/0x90
     [<ffffffff811de6d6>] ? kmem_cache_alloc_trace+0x1f6/0x270
     [<ffffffff81183826>] do_init_module+0x60/0x1dc
     [<ffffffff81115a8d>] load_module+0x1d0d/0x2390
     [<ffffffff811120b0>] ? __symbol_put+0x70/0x70
     [<ffffffff811f41b2>] ? kernel_read_file+0x92/0x120
     [<ffffffff811162f4>] SYSC_finit_module+0xa4/0xb0
     [<ffffffff8111631e>] SyS_finit_module+0xe/0x10
     [<ffffffff81001ff3>] do_syscall_64+0x63/0x350
     [<ffffffff816103da>] entry_SYSCALL64_slow_path+0x25/0x25
    Code: f7 48 8d 76 01 48 8d 52 01 0f b6 4e ff 84 c9 88 4a ff 75 ed 5d c3 0f 1f 00 55 48 89 e5 eb 04 84 c0
     74 18 48 8d 7f 01 48 8d 76 01 <0f> b6 47 ff 3a 46 ff 74 eb 19 c0 83 c8 01 5d c3 31 c0 5d c3 66
    RIP  [<ffffffff81338322>] strcmp+0x12/0x30
     RSP <ffff880070037748>
    CR2: ffffffffa03e7855
    
    v2: Make the copied con_id const
    
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: stable@vger.kernel.org
    Fixes: 10cf4899f8af ("gpiolib: tighten up ACPI legacy gpio lookups")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 682070d20f00..2dc52585e3f2 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -977,7 +977,7 @@ bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
 		lookup = kmalloc(sizeof(*lookup), GFP_KERNEL);
 		if (lookup) {
 			lookup->adev = adev;
-			lookup->con_id = con_id;
+			lookup->con_id = kstrdup(con_id, GFP_KERNEL);
 			list_add_tail(&lookup->node, &acpi_crs_lookup_list);
 		}
 	}

commit 20ec3e39fc12cf3a331ee73eb01d52bddcdd2fa4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 11 11:03:06 2016 +0100

    gpio: move the pin ranges into gpio_device
    
    Instead of keeping this reference to the pin ranges in the
    client driver-supplied gpio_chip, move it to the internal
    gpio_device as the drivers have no need to inspect this.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 540cbc88c7a2..682070d20f00 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -71,29 +71,29 @@ static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
  * controller uses pin controller and the mapping is not contiguous the
  * offset might be different.
  */
-static int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip, int pin)
+static int acpi_gpiochip_pin_to_gpio_offset(struct gpio_device *gdev, int pin)
 {
 	struct gpio_pin_range *pin_range;
 
 	/* If there are no ranges in this chip, use 1:1 mapping */
-	if (list_empty(&chip->pin_ranges))
+	if (list_empty(&gdev->pin_ranges))
 		return pin;
 
-	list_for_each_entry(pin_range, &chip->pin_ranges, node) {
+	list_for_each_entry(pin_range, &gdev->pin_ranges, node) {
 		const struct pinctrl_gpio_range *range = &pin_range->range;
 		int i;
 
 		if (range->pins) {
 			for (i = 0; i < range->npins; i++) {
 				if (range->pins[i] == pin)
-					return range->base + i - chip->base;
+					return range->base + i - gdev->base;
 			}
 		} else {
 			if (pin >= range->pin_base &&
 			    pin < range->pin_base + range->npins) {
 				unsigned gpio_base;
 
-				gpio_base = range->base - chip->base;
+				gpio_base = range->base - gdev->base;
 				return gpio_base + pin - range->pin_base;
 			}
 		}
@@ -102,7 +102,7 @@ static int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip, int pin)
 	return -EINVAL;
 }
 #else
-static inline int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip,
+static inline int acpi_gpiochip_pin_to_gpio_offset(struct gpio_device *gdev,
 						   int pin)
 {
 	return pin;
@@ -134,7 +134,7 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	if (!chip)
 		return ERR_PTR(-EPROBE_DEFER);
 
-	offset = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+	offset = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
 	if (offset < 0)
 		return ERR_PTR(offset);
 
@@ -202,7 +202,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	if (!handler)
 		return AE_BAD_PARAMETER;
 
-	pin = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+	pin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
 	if (pin < 0)
 		return AE_BAD_PARAMETER;
 
@@ -673,7 +673,7 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		struct gpio_desc *desc;
 		bool found;
 
-		pin = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+		pin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
 		if (pin < 0) {
 			status = AE_BAD_PARAMETER;
 			goto out;

commit 58cf279acac3080ce03eeea5ca268210b3165fe1
Merge: 6606b342febf c474e348778b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 17 12:32:01 2016 -0800

    Merge tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "Here is the bulk of GPIO changes for v4.5.
    
      Notably there are big refactorings mostly by myself, aimed at getting
      the gpio_chip into a shape that makes me believe I can proceed to
      preserve state for a proper userspace ABI (character device) that has
      already been proposed once, but resulted in the feedback that I need
      to go back and restructure stuff.  So I've been restructuring stuff.
      On the way I ran into brokenness (return code from the get_value()
      callback) and had to fix it.  Also, refactored generic GPIO to be
      simpler.
    
      Some of that is still waiting to trickle down from the subsystems all
      over the kernel that provide random gpio_chips, I've touched every
      single GPIO driver in the kernel now, oh man I didn't know I was
      responsible for so much...
    
      Apart from that we're churning along as usual.
    
      I took some effort to test and retest so it should merge nicely and we
      shook out a couple of bugs in -next.
    
      Infrastructural changes:
    
       - In struct gpio_chip, rename the .dev node to .parent to better
         reflect the fact that this is not the GPIO struct device
         abstraction.  We will add that soon so this would be totallt
         confusing.
    
       - It was noted that the driver .get_value() callbacks was sometimes
         reporting negative -ERR values to the gpiolib core, expecting them
         to be propagated to consumer gpiod_get_value() and gpio_get_value()
         calls.  This was not happening, so as there was a mess of drivers
         returning negative errors and some returning "anything else than
         zero" to indicate that a line was active.  As some would have bit
         31 set to indicate "line active" it clashed with negative error
         codes.  This is fixed by the largeish series clamping values in all
         drivers with !!value to [0,1] and then augmenting the code to
         propagate error codes to consumers.  (Includes some ACKed patches
         in other subsystems.)
    
       - Add a void *data pointer to struct gpio_chip.  The container_of()
         design pattern is indeed very nice, but we want to reform the
         struct gpio_chip to be a non-volative, stateless business, and keep
         states internal to the gpiolib to be able to hold on to the state
         when adding a proper userspace ABI (character device) further down
         the road.  To achieve this, drivers need a handle at the internal
         state that is not dependent on their struct gpio_chip() so we add
         gpiochip_add_data() and gpiochip_get_data() following the pattern
         of many other subsystems.  All the "use gpiochip data pointer"
         patches transforms drivers to this scheme.
    
       - The Generic GPIO chip header has been merged into the general
         <linux/gpio/driver.h> header, and the custom header for that
         removed.  Instead of having a separate mm_gpio_chip struct for
         these generic drivers, merge that into struct gpio_chip,
         simplifying the code and removing the need for separate and
         confusing includes.
    
      Misc improvements:
    
       - Stabilize the way GPIOs are looked up from the ACPI legacy
         specification.
    
       - Incremental driver features for PXA, PCA953X, Lantiq (patches from
         the OpenWRT community), RCAR, Zynq, PL061, 104-idi-48
    
      New drivers:
    
       - Add a GPIO chip to the ALSA SoC AC97 driver.
    
       - Add a new Broadcom NSP SoC driver (this lands in the pinctrl dir,
         but the branch is merged here too to account for infrastructural
         changes).
    
       - The sx150x driver now supports the sx1502"
    
    * tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (220 commits)
      gpio: generic: make bgpio_pdata always visible
      gpiolib: fix chip order in gpio list
      gpio: mpc8xxx: Do not use gpiochip_get_data() in mpc8xxx_gpio_save_regs()
      gpio: mm-lantiq: Do not use gpiochip_get_data() in ltq_mm_save_regs()
      gpio: brcmstb: Allow building driver for BMIPS_GENERIC
      gpio: brcmstb: Set endian flags for big-endian MIPS
      gpio: moxart: fix build regression
      gpio: xilinx: Do not use gpiochip_get_data() in xgpio_save_regs()
      leds: pca9532: use gpiochip data pointer
      leds: tca6507: use gpiochip data pointer
      hid: cp2112: use gpiochip data pointer
      bcma: gpio: use gpiochip data pointer
      avr32: gpio: use gpiochip data pointer
      video: fbdev: via: use gpiochip data pointer
      gpio: pch: Optimize pch_gpio_get()
      Revert "pinctrl: lantiq: Implement gpio_chip.to_irq"
      pinctrl: nsp-gpio: use gpiochip data pointer
      pinctrl: vt8500-wmt: use gpiochip data pointer
      pinctrl: exynos5440: use gpiochip data pointer
      pinctrl: at91-pio4: use gpiochip data pointer
      ...

commit 1c5ff2ab7bba6757e7663302c5905e6404de324a
Merge: d6a322774cb7 009f77383651
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 13 11:14:05 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input updates from Dmitry Torokhov:
     - new driver for eGalaxTouch serial touchscreen
     - new driver for TS-4800 touchscreen
     - an update for Goodix touchscreen driver
     - PS/2 mouse module was reworked to limit number of protocols we try on
       pass-through ports to speed up their detection time
     - wacom_w8001 touchscreen driver now reports pen and touch via separate
       instances of input devices
     - other driver changes
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (42 commits)
      Input: elantech - mark protocols v2 and v3 as semi-mt
      Input: wacom_w8001 - drop use of ABS_MT_TOOL_TYPE
      Input: gpio-keys - fix check for disabling unsupported keys
      Input: omap-keypad - remove dead check
      Input: ti_am335x_tsc - fix HWPEN interrupt handling
      Input: omap-keypad - set tasklet data earlier
      Input: rohm_bu21023 - fix handling of retrying firmware update
      Input: ALPS - report v3 pinnacle trackstick device only if is present
      Input: ALPS - detect trackstick presence for v7 protocol
      Input: pcap_ts - use to_delayed_work
      Input: bma150 - constify bma150_cfg structure
      Input: i8042 - add Fujitsu Lifebook U745 to the nomux list
      Input: egalax_ts_serial - fix potential NULL dereference on error
      Input: uinput - sanity check on ff_effects_max and EV_FF
      Input: uinput - rework ABS validation
      Input: uinput - add new UINPUT_DEV_SETUP and UI_ABS_SETUP ioctl
      Input: goodix - use "inverted_[xy]" flags instead of "rotated_screen"
      Input: goodix - add axis swapping and axis inversion support
      Input: goodix - use goodix_i2c_write_u8 instead of i2c_master_send
      Input: goodix - add power management support
      ...

commit 52044723cd27aed6dad655a3bdf6142a8239ce74
Author: Christophe RICARD <christophe.ricard@gmail.com>
Date:   Wed Dec 23 23:25:34 2015 +0100

    ACPI / gpio: Add irq_type when a GPIO is used as an interrupt
    
    When a GPIO is used as an interrupt in ACPI, the irq_type was not
    available for device driver.
    
    Make available polarity and triggering information in acpi_find_gpio by
    renaming acpi_gpio_info field active_low  to polarity and adding triggering
    field (edge/level).
    
    For sanity, in gpiolib.c replace info.active_low by
    "info.polarity == GPIO_ACTIVE_LOW".
    
    Set the irq_type if necessary in acpi_dev_gpio_irq_get.
    
    Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 16a7b6816744..cbbb67a6f1d6 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -417,10 +417,15 @@ static int acpi_find_gpio(struct acpi_resource *ares, void *data)
 		 * ActiveLow is only specified for GpioInt resource. If
 		 * GpioIo is used then the only way to set the flag is
 		 * to use _DSD "gpios" property.
+		 * Note: we expect here:
+		 * - ACPI_ACTIVE_LOW == GPIO_ACTIVE_LOW
+		 * - ACPI_ACTIVE_HIGH == GPIO_ACTIVE_HIGH
 		 */
-		if (lookup->info.gpioint)
-			lookup->info.active_low =
-				agpio->polarity == ACPI_ACTIVE_LOW;
+		if (lookup->info.gpioint) {
+			lookup->info.polarity = agpio->polarity;
+			lookup->info.triggering = agpio->triggering;
+		}
+
 	}
 
 	return 1;
@@ -447,7 +452,7 @@ static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
 	if (info) {
 		*info = lookup->info;
 		if (lookup->active_low)
-			info->active_low = lookup->active_low;
+			info->polarity = lookup->active_low;
 	}
 	return 0;
 }
@@ -595,6 +600,7 @@ struct gpio_desc *acpi_node_get_gpiod(struct fwnode_handle *fwnode,
 int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 {
 	int idx, i;
+	unsigned int irq_flags;
 
 	for (i = 0, idx = 0; idx <= index; i++) {
 		struct acpi_gpio_info info;
@@ -603,8 +609,23 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 		desc = acpi_get_gpiod_by_index(adev, NULL, i, &info);
 		if (IS_ERR(desc))
 			break;
-		if (info.gpioint && idx++ == index)
-			return gpiod_to_irq(desc);
+		if (info.gpioint && idx++ == index) {
+			int irq = gpiod_to_irq(desc);
+
+			if (irq < 0)
+				return irq;
+
+			irq_flags = acpi_dev_get_irq_type(info.triggering,
+							  info.polarity);
+
+			/* Set type if specified and different than the current one */
+			if (irq_flags != IRQ_TYPE_NONE &&
+			    irq_flags != irq_get_trigger_type(irq))
+				irq_set_irq_type(irq, irq_flags);
+
+			return irq;
+		}
+
 	}
 	return -ENOENT;
 }

commit 10cf4899f8affa468b9140f377857bfe3f563012
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Nov 11 11:45:30 2015 -0800

    gpiolib: tighten up ACPI legacy gpio lookups
    
    We should not fall back to the legacy unnamed gpio lookup style if the
    driver requests gpios with different names, because we'll give out the same
    gpio twice. Let's keep track of the names that were used for the device and
    only do the fallback for the first name used.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 16a7b6816744..7ab7bc3c9300 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -922,3 +922,46 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 	}
 	return count;
 }
+
+struct acpi_crs_lookup {
+	struct list_head node;
+	struct acpi_device *adev;
+	const char *con_id;
+};
+
+static DEFINE_MUTEX(acpi_crs_lookup_lock);
+static LIST_HEAD(acpi_crs_lookup_list);
+
+bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
+{
+	struct acpi_crs_lookup *l, *lookup = NULL;
+
+	/* Never allow fallback if the device has properties */
+	if (adev->data.properties || adev->driver_gpios)
+		return false;
+
+	mutex_lock(&acpi_crs_lookup_lock);
+
+	list_for_each_entry(l, &acpi_crs_lookup_list, node) {
+		if (l->adev == adev) {
+			lookup = l;
+			break;
+		}
+	}
+
+	if (!lookup) {
+		lookup = kmalloc(sizeof(*lookup), GFP_KERNEL);
+		if (lookup) {
+			lookup->adev = adev;
+			lookup->con_id = con_id;
+			list_add_tail(&lookup->node, &acpi_crs_lookup_list);
+		}
+	}
+
+	mutex_unlock(&acpi_crs_lookup_lock);
+
+	return lookup &&
+		((!lookup->con_id && !con_id) ||
+		 (lookup->con_id && con_id &&
+		  strcmp(lookup->con_id, con_id) == 0));
+}

commit 9c3c9bc9cc980d8981f75109f3921576daf75723
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Nov 11 11:45:30 2015 -0800

    gpiolib: tighten up ACPI legacy gpio lookups
    
    We should not fall back to the legacy unnamed gpio lookup style if the
    driver requests gpios with different names, because we'll give out the same
    gpio twice. Let's keep track of the names that were used for the device and
    only do the fallback for the first name used.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index e4620e14457f..07e571a1a377 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -925,3 +925,46 @@ int acpi_gpio_count(struct device *dev, const char *con_id)
 	}
 	return count;
 }
+
+struct acpi_crs_lookup {
+	struct list_head node;
+	struct acpi_device *adev;
+	const char *con_id;
+};
+
+static DEFINE_MUTEX(acpi_crs_lookup_lock);
+static LIST_HEAD(acpi_crs_lookup_list);
+
+bool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)
+{
+	struct acpi_crs_lookup *l, *lookup = NULL;
+
+	/* Never allow fallback if the device has properties */
+	if (adev->data.properties || adev->driver_gpios)
+		return false;
+
+	mutex_lock(&acpi_crs_lookup_lock);
+
+	list_for_each_entry(l, &acpi_crs_lookup_list, node) {
+		if (l->adev == adev) {
+			lookup = l;
+			break;
+		}
+	}
+
+	if (!lookup) {
+		lookup = kmalloc(sizeof(*lookup), GFP_KERNEL);
+		if (lookup) {
+			lookup->adev = adev;
+			lookup->con_id = con_id;
+			list_add_tail(&lookup->node, &acpi_crs_lookup_list);
+		}
+	}
+
+	mutex_unlock(&acpi_crs_lookup_lock);
+
+	return lookup &&
+		((!lookup->con_id && !con_id) ||
+		 (lookup->con_id && con_id &&
+		  strcmp(lookup->con_id, con_id) == 0));
+}

commit 58383c78425e4ee1c077253cf297b641c861c02e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 4 09:56:26 2015 +0100

    gpio: change member .dev to .parent
    
    The name .dev in a struct is normally reserved for a struct device
    that is let us say a superclass to the thing described by the struct.
    struct gpio_chip stands out by confusingly using a struct device *dev
    to point to the parent device (such as a platform_device) that
    represents the hardware. As we want to give gpio_chip:s real devices,
    this is not working. We need to rename this member to parent.
    
    This was done by two coccinelle scripts, I guess it is possible to
    combine them into one, but I don't know such stuff. They look like
    this:
    
    @@
    struct gpio_chip *var;
    @@
    -var->dev
    +var->parent
    
    and:
    
    @@
    struct gpio_chip var;
    @@
    -var.dev
    +var.parent
    
    and:
    
    @@
    struct bgpio_chip *var;
    @@
    -var->gc.dev
    +var->gc.parent
    
    Plus a few instances of bgpio that I couldn't figure out how
    to teach Coccinelle to rewrite.
    
    This patch hits all over the place, but I *strongly* prefer this
    solution to any piecemal approaches that just exercise patch
    mechanics all over the place. It mainly hits drivers/gpio and
    drivers/pinctrl which is my own backyard anyway.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Alek Du <alek.du@intel.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 16a7b6816744..e4620e14457f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -51,10 +51,10 @@ struct acpi_gpio_chip {
 
 static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 {
-	if (!gc->dev)
+	if (!gc->parent)
 		return false;
 
-	return ACPI_HANDLE(gc->dev) == data;
+	return ACPI_HANDLE(gc->parent) == data;
 }
 
 #ifdef CONFIG_PINCTRL
@@ -184,7 +184,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	if (agpio->connection_type != ACPI_RESOURCE_GPIO_TYPE_INT)
 		return AE_OK;
 
-	handle = ACPI_HANDLE(chip->dev);
+	handle = ACPI_HANDLE(chip->parent);
 	pin = agpio->pin_table[0];
 
 	if (pin <= 255) {
@@ -208,7 +208,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event");
 	if (IS_ERR(desc)) {
-		dev_err(chip->dev, "Failed to request GPIO\n");
+		dev_err(chip->parent, "Failed to request GPIO\n");
 		return AE_ERROR;
 	}
 
@@ -216,13 +216,13 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	ret = gpiochip_lock_as_irq(chip, pin);
 	if (ret) {
-		dev_err(chip->dev, "Failed to lock GPIO as interrupt\n");
+		dev_err(chip->parent, "Failed to lock GPIO as interrupt\n");
 		goto fail_free_desc;
 	}
 
 	irq = gpiod_to_irq(desc);
 	if (irq < 0) {
-		dev_err(chip->dev, "Failed to translate GPIO to IRQ\n");
+		dev_err(chip->parent, "Failed to translate GPIO to IRQ\n");
 		goto fail_unlock_irq;
 	}
 
@@ -259,7 +259,8 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	ret = request_threaded_irq(event->irq, NULL, handler, irqflags,
 				   "ACPI:Event", event);
 	if (ret) {
-		dev_err(chip->dev, "Failed to setup interrupt handler for %d\n",
+		dev_err(chip->parent,
+			"Failed to setup interrupt handler for %d\n",
 			event->irq);
 		goto fail_free_event;
 	}
@@ -293,10 +294,10 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	acpi_handle handle;
 	acpi_status status;
 
-	if (!chip->dev || !chip->to_irq)
+	if (!chip->parent || !chip->to_irq)
 		return;
 
-	handle = ACPI_HANDLE(chip->dev);
+	handle = ACPI_HANDLE(chip->parent);
 	if (!handle)
 		return;
 
@@ -323,10 +324,10 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	acpi_handle handle;
 	acpi_status status;
 
-	if (!chip->dev || !chip->to_irq)
+	if (!chip->parent || !chip->to_irq)
 		return;
 
-	handle = ACPI_HANDLE(chip->dev);
+	handle = ACPI_HANDLE(chip->parent);
 	if (!handle)
 		return;
 
@@ -748,7 +749,7 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 static void acpi_gpiochip_request_regions(struct acpi_gpio_chip *achip)
 {
 	struct gpio_chip *chip = achip->chip;
-	acpi_handle handle = ACPI_HANDLE(chip->dev);
+	acpi_handle handle = ACPI_HANDLE(chip->parent);
 	acpi_status status;
 
 	INIT_LIST_HEAD(&achip->conns);
@@ -757,20 +758,22 @@ static void acpi_gpiochip_request_regions(struct acpi_gpio_chip *achip)
 						    acpi_gpio_adr_space_handler,
 						    NULL, achip);
 	if (ACPI_FAILURE(status))
-		dev_err(chip->dev, "Failed to install GPIO OpRegion handler\n");
+		dev_err(chip->parent,
+		        "Failed to install GPIO OpRegion handler\n");
 }
 
 static void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)
 {
 	struct gpio_chip *chip = achip->chip;
-	acpi_handle handle = ACPI_HANDLE(chip->dev);
+	acpi_handle handle = ACPI_HANDLE(chip->parent);
 	struct acpi_gpio_connection *conn, *tmp;
 	acpi_status status;
 
 	status = acpi_remove_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,
 						   acpi_gpio_adr_space_handler);
 	if (ACPI_FAILURE(status)) {
-		dev_err(chip->dev, "Failed to remove GPIO OpRegion handler\n");
+		dev_err(chip->parent,
+			"Failed to remove GPIO OpRegion handler\n");
 		return;
 	}
 
@@ -787,16 +790,16 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 	acpi_handle handle;
 	acpi_status status;
 
-	if (!chip || !chip->dev)
+	if (!chip || !chip->parent)
 		return;
 
-	handle = ACPI_HANDLE(chip->dev);
+	handle = ACPI_HANDLE(chip->parent);
 	if (!handle)
 		return;
 
 	acpi_gpio = kzalloc(sizeof(*acpi_gpio), GFP_KERNEL);
 	if (!acpi_gpio) {
-		dev_err(chip->dev,
+		dev_err(chip->parent,
 			"Failed to allocate memory for ACPI GPIO chip\n");
 		return;
 	}
@@ -806,7 +809,7 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 
 	status = acpi_attach_data(handle, acpi_gpio_chip_dh, acpi_gpio);
 	if (ACPI_FAILURE(status)) {
-		dev_err(chip->dev, "Failed to attach ACPI GPIO chip\n");
+		dev_err(chip->parent, "Failed to attach ACPI GPIO chip\n");
 		kfree(acpi_gpio);
 		return;
 	}
@@ -820,16 +823,16 @@ void acpi_gpiochip_remove(struct gpio_chip *chip)
 	acpi_handle handle;
 	acpi_status status;
 
-	if (!chip || !chip->dev)
+	if (!chip || !chip->parent)
 		return;
 
-	handle = ACPI_HANDLE(chip->dev);
+	handle = ACPI_HANDLE(chip->parent);
 	if (!handle)
 		return;
 
 	status = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);
 	if (ACPI_FAILURE(status)) {
-		dev_warn(chip->dev, "Failed to retrieve ACPI GPIO chip\n");
+		dev_warn(chip->parent, "Failed to retrieve ACPI GPIO chip\n");
 		return;
 	}
 

commit 0d51ce9ca1116e8f4dc87cb51db8dd250327e9bb
Merge: 41ecf1404b34 1ab68460b1d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 4 18:10:13 2015 -0800

    Merge tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "Quite a new features are included this time.
    
      First off, the Collaborative Processor Performance Control interface
      (version 2) defined by ACPI will now be supported on ARM64 along with
      a cpufreq frontend for CPU performance scaling.
    
      Second, ACPI gets a new infrastructure for the early probing of IRQ
      chips and clock sources (along the lines of the existing similar
      mechanism for DT).
    
      Next, the ACPI core and the generic device properties API will now
      support a recently introduced hierarchical properties extension of the
      _DSD (Device Specific Data) ACPI device configuration object.  If the
      ACPI platform firmware uses that extension to organize device
      properties in a hierarchical way, the kernel will automatically handle
      it and make those properties available to device drivers via the
      generic device properties API.
    
      It also will be possible to build the ACPICA's AML interpreter
      debugger into the kernel now and use that to diagnose AML-related
      problems more efficiently.  In the future, this should make it
      possible to single-step AML execution and do similar things.
      Interesting stuff, although somewhat experimental at this point.
    
      Finally, the PM core gets a new mechanism that can be used by device
      drivers to distinguish between suspend-to-RAM (based on platform
      firmware support) and suspend-to-idle (or other variants of system
      suspend the platform firmware is not involved in) and possibly
      optimize their device suspend/resume handling accordingly.
    
      In addition to that, some existing features are re-organized quite
      substantially.
    
      First, the ACPI-based handling of PCI host bridges on x86 and ia64 is
      unified and the common code goes into the ACPI core (so as to reduce
      code duplication and eliminate non-essential differences between the
      two architectures in that area).
    
      Second, the Operating Performance Points (OPP) framework is
      reorganized to make the code easier to find and follow.
    
      Next, the cpufreq core's sysfs interface is reorganized to get rid of
      the "primary CPU" concept for configurations in which the same
      performance scaling settings are shared between multiple CPUs.
    
      Finally, some interfaces that aren't necessary any more are dropped
      from the generic power domains framework.
    
      On top of the above we have some minor extensions, cleanups and bug
      fixes in multiple places, as usual.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150930 (Bob Moore, Lv Zheng).
    
         The most significant change is to allow the AML debugger to be
         built into the kernel.  On top of that there is an update related
         to the NFIT table (the ACPI persistent memory interface) and a few
         fixes and cleanups.
    
       - ACPI CPPC2 (Collaborative Processor Performance Control v2) support
         along with a cpufreq frontend (Ashwin Chaugule).
    
         This can only be enabled on ARM64 at this point.
    
       - New ACPI infrastructure for the early probing of IRQ chips and
         clock sources (Marc Zyngier).
    
       - Support for a new hierarchical properties extension of the ACPI
         _DSD (Device Specific Data) device configuration object allowing
         the kernel to handle hierarchical properties (provided by the
         platform firmware this way) automatically and make them available
         to device drivers via the generic device properties interface
         (Rafael Wysocki).
    
       - Generic device properties API extension to obtain an index of
         certain string value in an array of strings, along the lines of
         of_property_match_string(), but working for all of the supported
         firmware node types, and support for the "dma-names" device
         property based on it (Mika Westerberg).
    
       - ACPI core fix to parse the MADT (Multiple APIC Description Table)
         entries in the order expected by platform firmware (and mandated by
         the specification) to avoid confusion on systems with more than 255
         logical CPUs (Lukasz Anaczkowski).
    
       - Consolidation of the ACPI-based handling of PCI host bridges on x86
         and ia64 (Jiang Liu).
    
       - ACPI core fixes to ensure that the correct IRQ number is used to
         represent the SCI (System Control Interrupt) in the cases when it
         has been re-mapped (Chen Yu).
    
       - New ACPI backlight quirk for Lenovo IdeaPad S405 (Hans de Goede).
    
       - ACPI EC driver fixes (Lv Zheng).
    
       - Assorted ACPI fixes and cleanups (Dan Carpenter, Insu Yun, Jiri
         Kosina, Rami Rosen, Rasmus Villemoes).
    
       - New mechanism in the PM core allowing drivers to check if the
         platform firmware is going to be involved in the upcoming system
         suspend or if it has been involved in the suspend the system is
         resuming from at the moment (Rafael Wysocki).
    
         This should allow drivers to optimize their suspend/resume handling
         in some cases and the changes include a couple of users of it (the
         i8042 input driver, PCI PM).
    
       - PCI PM fix to prevent runtime-suspended devices with PME enabled
         from being resumed during system suspend even if they aren't
         configured to wake up the system from sleep (Rafael Wysocki).
    
       - New mechanism to report the number of a wakeup IRQ that woke up the
         system from sleep last time (Alexandra Yates).
    
       - Removal of unused interfaces from the generic power domains
         framework and fixes related to latency measurements in that code
         (Ulf Hansson, Daniel Lezcano).
    
       - cpufreq core sysfs interface rework to make it handle CPUs that
         share performance scaling settings (represented by a common cpufreq
         policy object) more symmetrically (Viresh Kumar).
    
         This should help to simplify the CPU offline/online handling among
         other things.
    
       - cpufreq core fixes and cleanups (Viresh Kumar).
    
       - intel_pstate fixes related to the Turbo Activation Ratio (TAR)
         mechanism on client platforms which causes the turbo P-states range
         to vary depending on platform firmware settings (Srinivas
         Pandruvada).
    
       - intel_pstate sysfs interface fix (Prarit Bhargava).
    
       - Assorted cpufreq driver (imx, tegra20, powernv, integrator) fixes
         and cleanups (Bai Ping, Bartlomiej Zolnierkiewicz, Shilpasri G
         Bhat, Luis de Bethencourt).
    
       - cpuidle mvebu driver cleanups (Russell King).
    
       - OPP (Operating Performance Points) framework code reorganization to
         make it more maintainable (Viresh Kumar).
    
       - Intel Broxton support for the RAPL (Running Average Power Limits)
         power capping driver (Amy Wiles).
    
       - Assorted power management code fixes and cleanups (Dan Carpenter,
         Geert Uytterhoeven, Geliang Tang, Luis de Bethencourt, Rasmus
         Villemoes)"
    
    * tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (108 commits)
      cpufreq: postfix policy directory with the first CPU in related_cpus
      cpufreq: create cpu/cpufreq/policyX directories
      cpufreq: remove cpufreq_sysfs_{create|remove}_file()
      cpufreq: create cpu/cpufreq at boot time
      cpufreq: Use cpumask_copy instead of cpumask_or to copy a mask
      cpufreq: ondemand: Drop unnecessary locks from update_sampling_rate()
      PM / Domains: Merge measurements for PM QoS device latencies
      PM / Domains: Don't measure ->start|stop() latency in system PM callbacks
      PM / clk: Fix broken build due to non-matching code and header #ifdefs
      ACPI / Documentation: add copy_dsdt to ACPI format options
      ACPI / sysfs: correctly check failing memory allocation
      ACPI / video: Add a quirk to force native backlight on Lenovo IdeaPad S405
      ACPI / CPPC: Fix potential memory leak
      ACPI / CPPC: signedness bug in register_pcc_channel()
      ACPI / PAD: power_saving_thread() is not freezable
      ACPI / PM: Fix incorrect wakeup IRQ setting during suspend-to-idle
      ACPI: Using correct irq when waiting for events
      ACPI: Use correct IRQ when uninstalling ACPI interrupt handler
      cpuidle: mvebu: disable the bind/unbind attributes and use builtin_platform_driver
      cpuidle: mvebu: clean up multiple platform drivers
      ...

commit c103a10f690cc49054c52f493eeeff143d5f59e7
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 30 12:02:05 2015 +0200

    gpio / ACPI: Allow shared GPIO event to be read via operation region
    
    In Microsoft Surface3 the GPIO detecting lid state is shared between GPIO
    event and operation region. Below is simplied version of the DSDT from
    Surface3 including relevant parts:
    
        Scope (GPO0)
        {
            Name (_AEI, ResourceTemplate ()
            {
                GpioInt (Edge, ActiveBoth, Shared, PullNone, 0x0000,
                    "\\_SB.GPO0", 0x00, ResourceConsumer, ,
                    )
                    {   // Pin list
                        0x004C
                    }
            })
    
            OperationRegion (GPOR, GeneralPurposeIo, Zero, One)
            Field (GPOR, ByteAcc, NoLock, Preserve)
            {
                Connection (
                    GpioIo (Shared, PullNone, 0x0000, 0x0000,
                        IoRestrictionNone, "\\_SB.GPO0", 0x00,
                        ResourceConsumer,,)
                        {   // Pin list
                            0x004C
                        }
                ),
                HELD,   1
            }
    
            Method (_E4C, 0, Serialized)  // _Exx: Edge-Triggered GPE
            {
                If ((HELD == One))
                {
                    ^^LID.LIDB = One
                }
                Else
                {
                    ^^LID.LIDB = Zero
                    Notify (LID, 0x80) // Status Change
                }
    
                Notify (^^PCI0.SPI1.NTRG, One) // Device Check
            }
        }
    
    When GPIO 0x4c changes we call ASL method _E4C which tries to read HELD
    field (the same GPIO). This triggers following error on the console:
    
        ACPI Error: Method parse/execution failed [\_SB.GPO0._E4C]
            (Node ffff88013f4b4438), AE_ERROR (20150930/psparse-542)
    
    The error happens because ACPI GPIO operation region handler
    (acpi_gpio_adr_space_handler()) tries to acquire the very same GPIO which
    returns an error (-EBUSY) because the GPIO is already reserved for the GPIO
    event.
    
    Fix this so that we "borrow" the event GPIO if we find the GPIO belongs to
    an event. Allow this only for GPIOs that are read.
    
    To be able to go through acpi_gpio->events list for operation region access
    we need to make sure the list is properly initialized whenever GPIO chip is
    registered.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=106571
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 143a9bdbaa53..bbcac3af2a7a 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -304,7 +304,6 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	if (ACPI_FAILURE(status))
 		return;
 
-	INIT_LIST_HEAD(&acpi_gpio->events);
 	acpi_walk_resources(handle, "_AEI",
 			    acpi_gpiochip_request_interrupt, acpi_gpio);
 }
@@ -603,6 +602,25 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 				break;
 			}
 		}
+
+		/*
+		 * The same GPIO can be shared between operation region and
+		 * event but only if the access here is ACPI_READ. In that
+		 * case we "borrow" the event GPIO instead.
+		 */
+		if (!found && agpio->sharable == ACPI_SHARED &&
+		     function == ACPI_READ) {
+			struct acpi_gpio_event *event;
+
+			list_for_each_entry(event, &achip->events, node) {
+				if (event->pin == pin) {
+					desc = event->desc;
+					found = true;
+					break;
+				}
+			}
+		}
+
 		if (!found) {
 			desc = gpiochip_request_own_desc(chip, pin,
 							 "ACPI:OpRegion");
@@ -719,6 +737,7 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 	}
 
 	acpi_gpio->chip = chip;
+	INIT_LIST_HEAD(&acpi_gpio->events);
 
 	status = acpi_attach_data(handle, acpi_gpio_chip_dh, acpi_gpio);
 	if (ACPI_FAILURE(status)) {

commit 504a33749971c36c54ba5ccb1364872dee1f17a7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 27 04:42:33 2015 +0200

    ACPI / property: Extend device_get_next_child_node() to data-only nodes
    
    Make device_get_next_child_node() work with ACPI data-only subnodes
    introduced previously.
    
    Namely, replace acpi_get_next_child() with acpi_get_next_subnode()
    that can handle (and return) child device objects as well as child
    data-only subnodes of the given device and modify the ACPI part
    of the GPIO subsystem to handle data-only subnodes returned by it.
    
    To that end, introduce acpi_node_get_gpiod() taking a struct
    fwnode_handle pointer as the first argument.  That argument may
    point to an ACPI device object as well as to a data-only subnode
    and the function should do the right thing (ie. look for the matching
    GPIO descriptor correctly) in either case.
    
    Next, modify fwnode_get_named_gpiod() to use acpi_node_get_gpiod()
    instead of acpi_get_gpiod_by_index() which automatically causes
    devm_get_gpiod_from_child() to work with ACPI data-only subnodes
    that may be returned by device_get_next_child_node() which in turn
    is required by the users of that function (the gpio_keys_polled
    and gpio-leds drivers).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index a38cf16a5828..69a83626f1ae 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -453,7 +453,7 @@ static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
 	return 0;
 }
 
-static int acpi_gpio_property_lookup(struct acpi_device *adev,
+static int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,
 				     const char *propname, int index,
 				     struct acpi_gpio_lookup *lookup)
 {
@@ -461,10 +461,16 @@ static int acpi_gpio_property_lookup(struct acpi_device *adev,
 	int ret;
 
 	memset(&args, 0, sizeof(args));
-	ret = acpi_dev_get_property_reference(adev, propname, index, &args);
-	if (ret && !acpi_get_driver_gpio_data(adev, propname, index, &args))
-		return ret;
+	ret = acpi_node_get_property_reference(fwnode, propname, index, &args);
+	if (ret) {
+		struct acpi_device *adev = to_acpi_device_node(fwnode);
 
+		if (!adev)
+			return ret;
+
+		if (!acpi_get_driver_gpio_data(adev, propname, index, &args))
+			return ret;
+	}
 	/*
 	 * The property was found and resolved, so need to lookup the GPIO based
 	 * on returned args.
@@ -518,7 +524,8 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 	if (propname) {
 		dev_dbg(&adev->dev, "GPIO: looking up %s\n", propname);
 
-		ret = acpi_gpio_property_lookup(adev, propname, index, &lookup);
+		ret = acpi_gpio_property_lookup(acpi_fwnode_handle(adev),
+						propname, index, &lookup);
 		if (ret)
 			return ERR_PTR(ret);
 
@@ -534,6 +541,47 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 	return ret ? ERR_PTR(ret) : lookup.desc;
 }
 
+/**
+ * acpi_node_get_gpiod() - get a GPIO descriptor from ACPI resources
+ * @fwnode: pointer to an ACPI firmware node to get the GPIO information from
+ * @propname: Property name of the GPIO
+ * @index: index of GpioIo/GpioInt resource (starting from %0)
+ * @info: info pointer to fill in (optional)
+ *
+ * If @fwnode is an ACPI device object, call %acpi_get_gpiod_by_index() for it.
+ * Otherwise (ie. it is a data-only non-device object), use the property-based
+ * GPIO lookup to get to the GPIO resource with the relevant information and use
+ * that to obtain the GPIO descriptor to return.
+ */
+struct gpio_desc *acpi_node_get_gpiod(struct fwnode_handle *fwnode,
+				      const char *propname, int index,
+				      struct acpi_gpio_info *info)
+{
+	struct acpi_gpio_lookup lookup;
+	struct acpi_device *adev;
+	int ret;
+
+	adev = to_acpi_device_node(fwnode);
+	if (adev)
+		return acpi_get_gpiod_by_index(adev, propname, index, info);
+
+	if (!is_acpi_data_node(fwnode))
+		return ERR_PTR(-ENODEV);
+
+	if (!propname)
+		return ERR_PTR(-EINVAL);
+
+	memset(&lookup, 0, sizeof(lookup));
+	lookup.index = index;
+
+	ret = acpi_gpio_property_lookup(fwnode, propname, index, &lookup);
+	if (ret)
+		return ERR_PTR(ret);
+
+	ret = acpi_gpio_resource_lookup(&lookup, info);
+	return ret ? ERR_PTR(ret) : lookup.desc;
+}
+
 /**
  * acpi_dev_gpio_irq_get() - Find GpioInt and translate it to Linux IRQ number
  * @adev: pointer to a ACPI device to get IRQ from

commit d079524a33977dc08ea15650a21a1664a7313941
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 27 04:41:33 2015 +0200

    ACPI / gpio: Split acpi_get_gpiod_by_index()
    
    Split acpi_get_gpiod_by_index() into three smaller routines to
    allow the subsequent change of the generic firmware node properties
    code to be more strarightforward.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 143a9bdbaa53..a38cf16a5828 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -389,6 +389,8 @@ struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
 	int pin_index;
+	bool active_low;
+	struct acpi_device *adev;
 	struct gpio_desc *desc;
 	int n;
 };
@@ -425,6 +427,59 @@ static int acpi_find_gpio(struct acpi_resource *ares, void *data)
 	return 1;
 }
 
+static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
+				     struct acpi_gpio_info *info)
+{
+	struct list_head res_list;
+	int ret;
+
+	INIT_LIST_HEAD(&res_list);
+
+	ret = acpi_dev_get_resources(lookup->adev, &res_list, acpi_find_gpio,
+				     lookup);
+	if (ret < 0)
+		return ret;
+
+	acpi_dev_free_resource_list(&res_list);
+
+	if (!lookup->desc)
+		return -ENOENT;
+
+	if (info) {
+		*info = lookup->info;
+		if (lookup->active_low)
+			info->active_low = lookup->active_low;
+	}
+	return 0;
+}
+
+static int acpi_gpio_property_lookup(struct acpi_device *adev,
+				     const char *propname, int index,
+				     struct acpi_gpio_lookup *lookup)
+{
+	struct acpi_reference_args args;
+	int ret;
+
+	memset(&args, 0, sizeof(args));
+	ret = acpi_dev_get_property_reference(adev, propname, index, &args);
+	if (ret && !acpi_get_driver_gpio_data(adev, propname, index, &args))
+		return ret;
+
+	/*
+	 * The property was found and resolved, so need to lookup the GPIO based
+	 * on returned args.
+	 */
+	lookup->adev = args.adev;
+	if (args.nargs >= 2) {
+		lookup->index = args.args[0];
+		lookup->pin_index = args.args[1];
+		/* 3rd argument, if present is used to specify active_low. */
+		if (args.nargs >= 3)
+			lookup->active_low = !!args.args[2];
+	}
+	return 0;
+}
+
 /**
  * acpi_get_gpiod_by_index() - get a GPIO descriptor from device resources
  * @adev: pointer to a ACPI device to get GPIO from
@@ -452,8 +507,6 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 					  struct acpi_gpio_info *info)
 {
 	struct acpi_gpio_lookup lookup;
-	struct list_head resource_list;
-	bool active_low = false;
 	int ret;
 
 	if (!adev)
@@ -463,58 +516,22 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 	lookup.index = index;
 
 	if (propname) {
-		struct acpi_reference_args args;
-
 		dev_dbg(&adev->dev, "GPIO: looking up %s\n", propname);
 
-		memset(&args, 0, sizeof(args));
-		ret = acpi_dev_get_property_reference(adev, propname,
-						      index, &args);
-		if (ret) {
-			bool found = acpi_get_driver_gpio_data(adev, propname,
-							       index, &args);
-			if (!found)
-				return ERR_PTR(ret);
-		}
+		ret = acpi_gpio_property_lookup(adev, propname, index, &lookup);
+		if (ret)
+			return ERR_PTR(ret);
 
-		/*
-		 * The property was found and resolved so need to
-		 * lookup the GPIO based on returned args instead.
-		 */
-		adev = args.adev;
-		if (args.nargs >= 2) {
-			lookup.index = args.args[0];
-			lookup.pin_index = args.args[1];
-			/*
-			 * 3rd argument, if present is used to
-			 * specify active_low.
-			 */
-			if (args.nargs >= 3)
-				active_low = !!args.args[2];
-		}
-
-		dev_dbg(&adev->dev, "GPIO: _DSD returned %s %zd %llu %llu %llu\n",
-			dev_name(&adev->dev), args.nargs,
-			args.args[0], args.args[1], args.args[2]);
+		dev_dbg(&adev->dev, "GPIO: _DSD returned %s %d %d %u\n",
+			dev_name(&lookup.adev->dev), lookup.index,
+			lookup.pin_index, lookup.active_low);
 	} else {
 		dev_dbg(&adev->dev, "GPIO: looking up %d in _CRS\n", index);
+		lookup.adev = adev;
 	}
 
-	INIT_LIST_HEAD(&resource_list);
-	ret = acpi_dev_get_resources(adev, &resource_list, acpi_find_gpio,
-				     &lookup);
-	if (ret < 0)
-		return ERR_PTR(ret);
-
-	acpi_dev_free_resource_list(&resource_list);
-
-	if (lookup.desc && info) {
-		*info = lookup.info;
-		if (active_low)
-			info->active_low = active_low;
-	}
-
-	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
+	ret = acpi_gpio_resource_lookup(&lookup, info);
+	return ret ? ERR_PTR(ret) : lookup.desc;
 }
 
 /**

commit e1c05067c323fb92d27418fb3586171bd7ce2e12
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jul 7 10:14:59 2015 +0900

    treewide: fix typos in comment blocks
    
    Looks like the word "contiguous" is often mistyped.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 533fe5dbe6f8..143a9bdbaa53 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -68,7 +68,7 @@ static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
  * GPIO controller driver.
  *
  * Typically the returned offset is same as @pin, but if the GPIO
- * controller uses pin controller and the mapping is not contigous the
+ * controller uses pin controller and the mapping is not contiguous the
  * offset might be different.
  */
 static int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip, int pin)

commit f35bbf61ab772cc312f64dddd1c89ab161893cee
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Jun 10 16:05:05 2015 +0300

    gpio / ACPI: Return -EPROBE_DEFER if the gpiochip was not found
    
    If a driver requests a GPIO described in its _CRS but the GPIO host
    controller (gpiochip) driver providing the GPIO has not been loaded yet
    acpi_get_gpiod() returns -ENODEV which causes the calling driver to fail.
    
    If the gpiochip driver is loaded afterwards the driver requesting the GPIO
    will not notice this.
    
    Better approach is to return -EPROBE_DEFER in such case. Then when the
    gpiochip driver appears the driver requesting the GPIO will be probed
    again. This also aligns ACPI GPIO lookup code closer to DT as it does
    pretty much the same when no gpiochip driver was found.
    
    Reported-by: Tobias Diedrich <tobiasdiedrich@gmail.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Tobias Diedrich <ranma+kernel@tdiedrich.de>
    Reviewed-by: Amos Kong <kongjianjun@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 980a996d0169..533fe5dbe6f8 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -114,10 +114,11 @@ static inline int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip,
  * @path:	ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
  * @pin:	ACPI GPIO pin number (0-based, controller-relative)
  *
- * Returns GPIO descriptor to use with Linux generic GPIO API, or ERR_PTR
- * error value
+ * Return: GPIO descriptor to use with Linux generic GPIO API, or ERR_PTR
+ * error value. Specifically returns %-EPROBE_DEFER if the referenced GPIO
+ * controller does not have gpiochip registered at the moment. This is to
+ * support probe deferral.
  */
-
 static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 {
 	struct gpio_chip *chip;
@@ -131,7 +132,7 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 
 	chip = gpiochip_find(handle, acpi_gpiochip_find);
 	if (!chip)
-		return ERR_PTR(-ENODEV);
+		return ERR_PTR(-EPROBE_DEFER);
 
 	offset = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
 	if (offset < 0)

commit 2b528fff0905497c96566d671d47f2bbf3ae295c
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Wed Jun 10 17:12:07 2015 +0800

    GPIO / ACPI: export acpi_gpiochip_request(free)_interrupts for module use
    
    acpi_gpiochip_request(free)_interrupts can be used for modules,
    so export them. This also fixs a compile error when xgene-sb
    configured as kernel module.
    
    Fixes: 733cf014f020 "gpio: xgene: add ACPI support for APM X-Gene GPIO standby driver"
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 19b99d0c2bf0..980a996d0169 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -307,6 +307,7 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	acpi_walk_resources(handle, "_AEI",
 			    acpi_gpiochip_request_interrupt, acpi_gpio);
 }
+EXPORT_SYMBOL_GPL(acpi_gpiochip_request_interrupts);
 
 /**
  * acpi_gpiochip_free_interrupts() - Free GPIO ACPI event interrupts.
@@ -346,6 +347,7 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 		kfree(event);
 	}
 }
+EXPORT_SYMBOL_GPL(acpi_gpiochip_free_interrupts);
 
 int acpi_dev_add_driver_gpios(struct acpi_device *adev,
 			      const struct acpi_gpio_mapping *gpios)

commit 8becdc18c3e1f855cae5af266f6a1f5ce5af24fb
Merge: 3c1b5c9bd991 030bbdbf4c83
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue May 12 10:13:41 2015 +0200

    Merge tag 'v4.1-rc3' into devel
    
    Linux 4.1-rc3

commit c884fbd452147e952ae160e750553d00ea4dc4c9
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed May 6 13:29:06 2015 +0300

    gpio / ACPI: Add support for retrieving GpioInt resources from a device
    
    ACPI specification knows two types of GPIOs: GpioIo and GpioInt. The latter
    is used to describe that a given device interrupt line is connected to a
    specific GPIO pin. Typical ACPI _CRS entry for such device looks like
    below:
    
        Name (_CRS, ResourceTemplate ()
        {
            I2cSerialBus (0x004A, ControllerInitiated, 0x00061A80,
                          AddressingMode7Bit, "\\_SB.PCI0.I2C6",
                          0x00, ResourceConsumer)
            GpioIo (Exclusive, PullDefault, 0x0000, 0x0000,
                    IoRestrictionOutputOnly, "\\_SB.GPO0",
                    0x00, ResourceConsumer)
            {
                0x004B
            }
            GpioInt (Level, ActiveLow, Shared, PullDefault, 0x0000,
                     "\\_SB.GPO0", 0x00, ResourceConsumer)
            {
                0x004C
            }
        })
    
    Currently drivers need to request a GPIO corresponding to the right GpioInt
    and then translate that to Linux IRQ number. This adds unnecessary lines of
    boiler-plate code.
    
    We can ease this a bit by introducing acpi_dev_gpio_irq_get() analogous to
    of_irq_get(). This function translates given GpioInt resource under the
    device in question to the suitable Linux IRQ number.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d2303d50f561..bff29bb0a3fe 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -514,6 +514,35 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
 }
 
+/**
+ * acpi_dev_gpio_irq_get() - Find GpioInt and translate it to Linux IRQ number
+ * @adev: pointer to a ACPI device to get IRQ from
+ * @index: index of GpioInt resource (starting from %0)
+ *
+ * If the device has one or more GpioInt resources, this function can be
+ * used to translate from the GPIO offset in the resource to the Linux IRQ
+ * number.
+ *
+ * Return: Linux IRQ number (>%0) on success, negative errno on failure.
+ */
+int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
+{
+	int idx, i;
+
+	for (i = 0, idx = 0; idx <= index; i++) {
+		struct acpi_gpio_info info;
+		struct gpio_desc *desc;
+
+		desc = acpi_get_gpiod_by_index(adev, NULL, i, &info);
+		if (IS_ERR(desc))
+			break;
+		if (info.gpioint && idx++ == index)
+			return gpiod_to_irq(desc);
+	}
+	return -ENOENT;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_get);
+
 static acpi_status
 acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 			    u32 bits, u64 *value, void *handler_context,

commit a4811622fea15fdc78102069f573061fc87f3570
Author: Qipeng Zha <qipeng.zha@intel.com>
Date:   Fri Apr 10 06:25:10 2015 +0800

    gpiolib: change gpio pin from unsigned to signed in acpi callback
    
    The signed error will be wrongly used as valid gpio offset
    
    Reported-by: David Binderman <dcb314@hotmail.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Qipeng Zha <qipeng.zha@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d2303d50f561..725d16138b74 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -550,7 +550,7 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 
 	length = min(agpio->pin_table_length, (u16)(pin_index + bits));
 	for (i = pin_index; i < length; ++i) {
-		unsigned pin = agpio->pin_table[i];
+		int pin = agpio->pin_table[i];
 		struct acpi_gpio_connection *conn;
 		struct gpio_desc *desc;
 		bool found;

commit 510965dd4a0a59504ba38455f77339ea8b4c6a70
Merge: 40d7839879b4 03daa6f82f2b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 18 08:22:10 2015 -0400

    Merge tag 'gpio-v4.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.1 development cycle:
    
       - A new GPIO hogging mechanism has been added.  This can be used on
         boards that want to drive some GPIO line high, low, or set it as
         input on boot and then never touch it again.  For some embedded
         systems this is bliss and simplifies things to a great extent.
    
       - Some API cleanup and closure: gpiod_get_array() and
         gpiod_put_array() has been added to get and put GPIOs in bulk as
         was possible with the non-descriptor API.
    
       - Encapsulate cross-calls to the pin control subsystem in
         <linux/gpio/driver.h>.  Now this should be the only header any GPIO
         driver needs to include or something is wrong.  Cleanups
         restricting drivers to this include are welcomed if tested.
    
       - Sort the GPIO Kconfig and split it into submenus, as it was
         becoming and unstructured, illogical and unnavigatable mess.  I
         hope this is easier to follow.  Menus that require a certain
         subsystem like I2C can now be hidden nicely for example, still
         working on others.
    
       - New drivers:
    
           - New driver for the Altera Soft GPIO.
    
           - The F7188x driver now handles the F71869 and F71869A variants.
    
           - The MIPS Loongson driver has been moved to drivers/gpio for
             consolidation and cleanup.
    
       - Cleanups:
    
           - The MAX732x is converted to use the GPIOLIB_IRQCHIP
             infrastructure.
    
           - The PCF857x is converted to use the GPIOLIB_IRQCHIP
             infrastructure.
    
           - Radical cleanup of the OMAP driver.
    
       - Misc:
    
           - Enable the DWAPB GPIO for all architectures.  This is a "hard
             IP" block from Synopsys which has started to turn up in so
             diverse architectures as X86 Quark, ARC and a slew of ARM
             systems.  So even though it's not an expander, it's generic
             enough to be available for all.
    
           - We add a mock GPIO on Crystalcove PMIC after a long discussion
             with Daniel Vetter et al, tracing back to the shootout at the
             kernel summit where DRM drivers and sub-componentization was
             discussed.  In this case a mock GPIO is assumed to be the best
             compromise gaining some reuse of infrastructure without making
             DRM drivers overly complex at the same time.  Let's see"
    
    * tag 'gpio-v4.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (62 commits)
      Revert "gpio: sch: use uapi/linux/pci_ids.h directly"
      gpio: dwapb: remove dependencies
      gpio: dwapb: enable for ARC
      gpio: removing kfree remove functionality
      gpio: mvebu: Fix mask/unmask managment per irq chip type
      gpio: split GPIO drivers in submenus
      gpio: move MFD GPIO drivers under their own comment
      gpio: move BCM Kona Kconfig option
      gpio: arrange SPI Kconfig symbols alphabetically
      gpio: arrange PCI GPIO controllers alphabetically
      gpio: arrange I2C Kconfig symbols alphabetically
      gpio: arrange Kconfig symbols alphabetically
      gpio: ich: Implement get_direction function
      gpio: use (!foo) instead of (foo == NULL)
      gpio: arizona: drop owner assignment from platform_drivers
      gpio: max7300: remove 'ret' variable
      gpio: use devm_kzalloc
      gpio: sch: use uapi/linux/pci_ids.h directly
      gpio: x-gene: fix devm_ioremap_resource() check
      gpio: loongson: Add Loongson-3A/3B GPIO driver support
      ...

commit 1ecb016e18149a1ea3de7dfd98f60b4b03e5e855
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 10 23:10:01 2015 +0100

    gpio / ACPI: Use local variable instead of ACPI_HANDLE()
    
    In acpi_gpiochip_request_interrupts() the handle local
    variable already contains the value that we want to pass
    to acpi_walk_resources(), so it is better to use that
    variable instead of evaluating ACPI_HANDLE() once more
    for the same device.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index c4919966453d..e958f716df94 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -300,7 +300,7 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 		return;
 
 	INIT_LIST_HEAD(&acpi_gpio->events);
-	acpi_walk_resources(ACPI_HANDLE(chip->dev), "_AEI",
+	acpi_walk_resources(handle, "_AEI",
 			    acpi_gpiochip_request_interrupt, acpi_gpio);
 }
 

commit 4de60970abf9f49737f51ec6e7a1e3bcf6d36742
Author: qipeng.zha <qipeng.zha@intel.com>
Date:   Wed Mar 11 01:15:38 2015 +0800

    gpiolib: translate pin number in GPIO ACPI callbacks
    
    If GPIO driver use pin mapping, need to translate pin number
    between ACPI table and GPIO driver.
    
    This issue is found on one platform with Cherryview gpio
    controller, kernel is hang when executed _PS0 method of
    one ACPI device, since without this translation, it access
    invalid gpiodesc array.
    
    Verified it works again with this patch.
    
    Signed-off-by: qipeng.zha <qipeng.zha@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index c0929d938ced..df990f29757a 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -201,6 +201,10 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	if (!handler)
 		return AE_BAD_PARAMETER;
 
+	pin = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+	if (pin < 0)
+		return AE_BAD_PARAMETER;
+
 	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event");
 	if (IS_ERR(desc)) {
 		dev_err(chip->dev, "Failed to request GPIO\n");
@@ -551,6 +555,12 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		struct gpio_desc *desc;
 		bool found;
 
+		pin = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+		if (pin < 0) {
+			status = AE_BAD_PARAMETER;
+			goto out;
+		}
+
 		mutex_lock(&achip->conn_lock);
 
 		found = false;

commit 668585273246f67b0cdafa30dd2da2047a2e1290
Author: Rojhalat Ibrahim <imr@rtschenk.de>
Date:   Wed Feb 11 17:27:58 2015 +0100

    gpiolib: add gpiod_get_array and gpiod_put_array functions
    
    Introduce new functions for conveniently obtaining and disposing of
    an entire array of GPIOs with one function call.
    
    ACPI parts tested by Mika Westerberg, DT parts tested by Rojhalat
    Ibrahim.
    
    Change log:
    v5: move the ACPI functions to gpiolib-acpi.c
    v4: - use shorter names for members of struct gpio_descs
        - rename lut_gpio_count to platform_gpio_count for clarity
        - add check for successful memory allocation
        - use ERR_CAST()
    v3: - rebase on current linux-gpio devel branch
        - fix ACPI GPIO counting
        - allow for zero-sized arrays
        - make the flags argument mandatory for the new functions
        - clarify documentation
    v2: change interface
    
    Suggested-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Rojhalat Ibrahim <imr@rtschenk.de>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Rojhalat Ibrahim <imr@rtschenk.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index c0929d938ced..c4919966453d 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -712,3 +712,87 @@ void acpi_gpiochip_remove(struct gpio_chip *chip)
 	acpi_detach_data(handle, acpi_gpio_chip_dh);
 	kfree(acpi_gpio);
 }
+
+static unsigned int acpi_gpio_package_count(const union acpi_object *obj)
+{
+	const union acpi_object *element = obj->package.elements;
+	const union acpi_object *end = element + obj->package.count;
+	unsigned int count = 0;
+
+	while (element < end) {
+		if (element->type == ACPI_TYPE_LOCAL_REFERENCE)
+			count++;
+
+		element++;
+	}
+	return count;
+}
+
+static int acpi_find_gpio_count(struct acpi_resource *ares, void *data)
+{
+	unsigned int *count = data;
+
+	if (ares->type == ACPI_RESOURCE_TYPE_GPIO)
+		*count += ares->data.gpio.pin_table_length;
+
+	return 1;
+}
+
+/**
+ * acpi_gpio_count - return the number of GPIOs associated with a
+ *		device / function or -ENOENT if no GPIO has been
+ *		assigned to the requested function.
+ * @dev:	GPIO consumer, can be NULL for system-global GPIOs
+ * @con_id:	function within the GPIO consumer
+ */
+int acpi_gpio_count(struct device *dev, const char *con_id)
+{
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	const union acpi_object *obj;
+	const struct acpi_gpio_mapping *gm;
+	int count = -ENOENT;
+	int ret;
+	char propname[32];
+	unsigned int i;
+
+	/* Try first from _DSD */
+	for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {
+		if (con_id && strcmp(con_id, "gpios"))
+			snprintf(propname, sizeof(propname), "%s-%s",
+				 con_id, gpio_suffixes[i]);
+		else
+			snprintf(propname, sizeof(propname), "%s",
+				 gpio_suffixes[i]);
+
+		ret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,
+					    &obj);
+		if (ret == 0) {
+			if (obj->type == ACPI_TYPE_LOCAL_REFERENCE)
+				count = 1;
+			else if (obj->type == ACPI_TYPE_PACKAGE)
+				count = acpi_gpio_package_count(obj);
+		} else if (adev->driver_gpios) {
+			for (gm = adev->driver_gpios; gm->name; gm++)
+				if (strcmp(propname, gm->name) == 0) {
+					count = gm->size;
+					break;
+				}
+		}
+		if (count >= 0)
+			break;
+	}
+
+	/* Then from plain _CRS GPIOs */
+	if (count < 0) {
+		struct list_head resource_list;
+		unsigned int crs_count = 0;
+
+		INIT_LIST_HEAD(&resource_list);
+		acpi_dev_get_resources(adev, &resource_list,
+				       acpi_find_gpio_count, &crs_count);
+		acpi_dev_free_resource_list(&resource_list);
+		if (crs_count > 0)
+			count = crs_count;
+	}
+	return count;
+}

commit 980f3c344ff1cb4a8be9a169c6bde2dc74ca6288
Merge: 7d22286ff757 170680abd1eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 14:05:05 2014 -0800

    Merge tag 'gpio-v3.19-2' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull take two of the GPIO updates:
     "Same stuff as last time, now with a fixup patch for the previous
      compile error plus I ran a few extra rounds of compile-testing.
    
      This is the bulk of GPIO changes for the v3.19 series:
    
       - A new API that allows setting more than one GPIO at the time.  This
         is implemented for the new descriptor-based API only and makes it
         possible to e.g. toggle a clock and data line at the same time, if
         the hardware can do this with a single register write.  Both
         consumers and drivers need new calls, and the core will fall back
         to driving individual lines where needed.  Implemented for the
         MPC8xxx driver initially
    
       - Patched the mdio-mux-gpio and the serial mctrl driver that drives
         modems to use the new multiple-setting API to set several signals
         simultaneously
    
       - Get rid of the global GPIO descriptor array, and instead allocate
         descriptors dynamically for each GPIO on a certain GPIO chip.  This
         moves us closer to getting rid of the limitation of using the
         global, static GPIO numberspace
    
       - New driver and device tree bindings for 74xx ICs
    
       - New driver and device tree bindings for the VF610 Vybrid
    
       - Support the RCAR r8a7793 and r8a7794
    
       - Guidelines for GPIO device tree bindings trying to get things a bit
         more strict with the advent of combined device properties
    
       - Suspend/resume support for the MVEBU driver
    
       - A slew of minor fixes and improvements"
    
    * tag 'gpio-v3.19-2' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (33 commits)
      gpio: mcp23s08: fix up compilation error
      gpio: pl061: document gpio-ranges property for bindings file
      gpio: pl061: hook request if gpio-ranges avaiable
      gpio: mcp23s08: Add option to configure IRQ output polarity as active high
      gpio: fix deferred probe detection for legacy API
      serial: mctrl_gpio: use gpiod_set_array function
      mdio-mux-gpio: Use GPIO descriptor interface and new gpiod_set_array function
      gpio: remove const modifier from gpiod_get_direction()
      gpio: remove gpio_descs global array
      gpio: mxs: implement get_direction callback
      gpio: em: Use dynamic allocation of GPIOs
      gpio: Check if base is positive before calling gpio_is_valid()
      gpio: mcp23s08: Add simple IRQ support for SPI devices
      gpio: mcp23s08: request a shared interrupt
      gpio: mcp23s08: Do not free unrequested interrupt
      gpio: rcar: Add r8a7793 and r8a7794 support
      gpio-mpc8xxx: add mpc8xxx_gpio_set_multiple function
      gpiolib: allow simultaneous setting of multiple GPIO outputs
      gpio: mvebu: add suspend/resume support
      gpio: gpio-davinci: remove duplicate check on resource
      ..

commit c1b30e4d9466000c0e287e9245d4397da4d7d2f9
Merge: 92a578b064d0 853b6bf044dc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 10:43:14 2014 -0800

    Merge tag 'pinctrl-v3.19-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control changes from Linus Walleij:
     "Here is a stash of pin control changes I have collected for the v3.19
      series.  Mainly new hardware support, with Intels new embedded SoC as
      the especially interesting thing standing out, fully using the
      subsystem.
    
       - Force conversion of the ux500 pin control device trees and parsers
         to use the generic pin control bindings.
       - New driver and device tree bindings for the Qualcomm PMIC MPP pin
         controller and GPIO.
       - Some ACPI infrastructure for pin controllers.
       - New driver for the Intel CherryView/Braswell pin controller, the
         first Intel pin controller to fully take advantage of the pin
         control subsystem.
       - Support the Freescale i.MX VF610 variant.
       - Support the sunxi A80 variant.
       - Support the Samsung Exynos 4415 and Exynos 7 variants.
       - Split out Intel pin controllers to their own subdirectory.
       - A large slew of rockchip pin control updates, including
         suspend/resume support.
       - A large slew of Samsung Exynos pin controller updates.
       - Various minor updates and fixes"
    
    * tag 'pinctrl-v3.19-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (49 commits)
      pinctrl: at91: enhance (debugfs) at91_gpio_dbg_show
      pinctrl: meson: add device tree bindings documentation
      gpio: tz1090: Fix error handling of irq_of_parse_and_map
      pinctrl: tz1090-pinctrl.txt: Fix typo in binding
      pinctrl: pinconf-generic: Declare dt_params/conf_items const
      pinctrl: exynos: Add support for Exynos4415
      pinctrl: exynos: Add initial driver data for Exynos7
      pinctrl: exynos: Add irq_chip instance for Exynos7 wakeup interrupts
      pinctrl: exynos: Consolidate irq domain callbacks
      pinctrl: exynos: Generalize the eint16_31 demux code
      pinctrl: samsung: Separate per-bank init and runtime data
      pinctrl: samsung: Constify samsung_pin_ctrl struct
      pinctrl: samsung: Constify samsung_pin_bank_type struct
      pinctrl: samsung: Drop unused label field in samsung_pin_ctrl struct
      pinctrl: samsung: Make samsung_pinctrl_get_soc_data use ERR_PTR()
      pinctrl: Add Intel Cherryview/Braswell pin controller support
      gpio / ACPI: Add knowledge about pin controllers to acpi_get_gpiod()
      pinctrl: Fix path error in documentation
      pinctrl: rockchip: save and restore gpio6_c6 pinmux in suspend/resume
      pinctrl: rockchip: add suspend/resume functions
      ...

commit 60ba032ed76e851d30d4fa514847285252147d07
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 5 00:29:07 2014 +0100

    ACPI / property: Drop size_prop from acpi_dev_get_property_reference()
    
    The size_prop argument of the recently added function
    acpi_dev_get_property_reference() is not used by the only current
    caller of that function and is very unlikely to be used at any time
    going forward.
    
    Namely, for a property whose value is a list of items each containing
    a references to a device object possibly accompanied by some integers,
    the number of items in the list can always be computed as the number
    of elements of type ACPI_TYPE_LOCAL_REFERENCE in the property package.
    Thus it should never be necessary to provide an additional "cells"
    property with a value equal to the number of items in that list.  It
    also should never be necessary to provide a "cells" property specifying
    how many integers are supposed to be following each reference.
    
    For this reason, drop the size_prop argument from
    acpi_dev_get_property_reference() and update its caller accordingly.
    
    Link: http://marc.info/?l=linux-kernel&m=141511255610556&w=2
    Suggested-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 5a4d061e787e..ba98bb59a58f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -405,7 +405,7 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 		dev_dbg(&adev->dev, "GPIO: looking up %s\n", propname);
 
 		memset(&args, 0, sizeof(args));
-		ret = acpi_dev_get_property_reference(adev, propname, NULL,
+		ret = acpi_dev_get_property_reference(adev, propname,
 						      index, &args);
 		if (ret) {
 			bool found = acpi_get_driver_gpio_data(adev, propname,

commit f028d5242d7ecb0a1bfc80e7bd292201c8612641
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 3 23:39:41 2014 +0100

    ACPI / GPIO: Driver GPIO mappings for ACPI GPIOs
    
    Provide a way for device drivers using GPIOs described by ACPI
    GpioIo resources in _CRS to tell the GPIO subsystem what names
    (connection IDs) to associate with specific GPIO pins defined
    in there.
    
    To do that, a driver needs to define a mapping table as a
    NULL-terminated array of struct acpi_gpio_mapping objects
    that each contain a name, a pointer to an array of line data
    (struct acpi_gpio_params) objects and the size of that array.
    
    Each struct acpi_gpio_params object consists of three fields,
    crs_entry_index, line_index, active_low, representing the index of
    the target GpioIo()/GpioInt() resource in _CRS starting from zero,
    the index of the target line in that resource starting from zero,
    and the active-low flag for that line, respectively.
    
    Next, the mapping table needs to be passed as the second
    argument to acpi_dev_add_driver_gpios() that will register it with
    the ACPI device object pointed to by its first argument.  That
    should be done in the driver's .probe() routine.
    
    On removal, the driver should unregister its GPIO mapping table
    by calling acpi_dev_remove_driver_gpios() on the ACPI device
    object where that table was previously registered.
    
    Included are fixes from Mika Westerberg.
    
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 8aa6ca473748..5a4d061e787e 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -287,6 +287,41 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	}
 }
 
+int acpi_dev_add_driver_gpios(struct acpi_device *adev,
+			      const struct acpi_gpio_mapping *gpios)
+{
+	if (adev && gpios) {
+		adev->driver_gpios = gpios;
+		return 0;
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_add_driver_gpios);
+
+static bool acpi_get_driver_gpio_data(struct acpi_device *adev,
+				      const char *name, int index,
+				      struct acpi_reference_args *args)
+{
+	const struct acpi_gpio_mapping *gm;
+
+	if (!adev->driver_gpios)
+		return false;
+
+	for (gm = adev->driver_gpios; gm->name; gm++)
+		if (!strcmp(name, gm->name) && gm->data && index < gm->size) {
+			const struct acpi_gpio_params *par = gm->data + index;
+
+			args->adev = adev;
+			args->args[0] = par->crs_entry_index;
+			args->args[1] = par->line_index;
+			args->args[2] = par->active_low;
+			args->nargs = 3;
+			return true;
+		}
+
+	return false;
+}
+
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
@@ -372,8 +407,12 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
 		memset(&args, 0, sizeof(args));
 		ret = acpi_dev_get_property_reference(adev, propname, NULL,
 						      index, &args);
-		if (ret)
-			return ERR_PTR(ret);
+		if (ret) {
+			bool found = acpi_get_driver_gpio_data(adev, propname,
+							       index, &args);
+			if (!found)
+				return ERR_PTR(ret);
+		}
 
 		/*
 		 * The property was found and resolved so need to

commit 0d9a693cc8619b28f0eeb689a554647d42848fde
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Oct 29 15:41:01 2014 +0100

    gpio / ACPI: Add support for _DSD device properties
    
    With release of ACPI 5.1 and _DSD method we can finally name GPIOs (and
    other things as well) returned by _CRS. Previously we were only able to
    use integer index to find the corresponding GPIO, which is pretty error
    prone if the order changes.
    
    With _DSD we can now query GPIOs using name instead of an integer index,
    like the below example shows:
    
      // Bluetooth device with reset and shutdown GPIOs
      Device (BTH)
      {
          Name (_HID, ...)
    
          Name (_CRS, ResourceTemplate ()
          {
              GpioIo (Exclusive, PullUp, 0, 0, IoRestrictionInputOnly,
                      "\\_SB.GPO0", 0, ResourceConsumer) {15}
              GpioIo (Exclusive, PullUp, 0, 0, IoRestrictionInputOnly,
                      "\\_SB.GPO0", 0, ResourceConsumer) {27, 31}
          })
    
          Name (_DSD, Package ()
          {
              ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
              Package ()
              {
                  Package () {"reset-gpio", Package() {^BTH, 1, 1, 0 }},
                  Package () {"shutdown-gpio", Package() {^BTH, 0, 0, 0 }},
              }
          })
      }
    
    The format of the supported GPIO property is:
    
      Package () { "name", Package () { ref, index, pin, active_low }}
    
      ref - The device that has _CRS containing GpioIo()/GpioInt() resources,
            typically this is the device itself (BTH in our case).
      index - Index of the GpioIo()/GpioInt() resource in _CRS starting from zero.
      pin - Pin in the GpioIo()/GpioInt() resource. Typically this is zero.
      active_low - If 1 the GPIO is marked as active_low.
    
    Since ACPI GpioIo() resource does not have field saying whether it is
    active low or high, the "active_low" argument can be used here. Setting
    it to 1 marks the GPIO as active low.
    
    In our Bluetooth example the "reset-gpio" refers to the second GpioIo()
    resource, second pin in that resource with the GPIO number of 31.
    
    This patch implements necessary support to gpiolib for extracting GPIOs
    using _DSD device properties.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 05c6275da224..8aa6ca473748 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -290,6 +290,7 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
+	int pin_index;
 	struct gpio_desc *desc;
 	int n;
 };
@@ -303,13 +304,24 @@ static int acpi_find_gpio(struct acpi_resource *ares, void *data)
 
 	if (lookup->n++ == lookup->index && !lookup->desc) {
 		const struct acpi_resource_gpio *agpio = &ares->data.gpio;
+		int pin_index = lookup->pin_index;
+
+		if (pin_index >= agpio->pin_table_length)
+			return 1;
 
 		lookup->desc = acpi_get_gpiod(agpio->resource_source.string_ptr,
-					      agpio->pin_table[0]);
+					      agpio->pin_table[pin_index]);
 		lookup->info.gpioint =
 			agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;
-		lookup->info.active_low =
-			agpio->polarity == ACPI_ACTIVE_LOW;
+
+		/*
+		 * ActiveLow is only specified for GpioInt resource. If
+		 * GpioIo is used then the only way to set the flag is
+		 * to use _DSD "gpios" property.
+		 */
+		if (lookup->info.gpioint)
+			lookup->info.active_low =
+				agpio->polarity == ACPI_ACTIVE_LOW;
 	}
 
 	return 1;
@@ -317,40 +329,75 @@ static int acpi_find_gpio(struct acpi_resource *ares, void *data)
 
 /**
  * acpi_get_gpiod_by_index() - get a GPIO descriptor from device resources
- * @dev: pointer to a device to get GPIO from
+ * @adev: pointer to a ACPI device to get GPIO from
+ * @propname: Property name of the GPIO (optional)
  * @index: index of GpioIo/GpioInt resource (starting from %0)
  * @info: info pointer to fill in (optional)
  *
- * Function goes through ACPI resources for @dev and based on @index looks
+ * Function goes through ACPI resources for @adev and based on @index looks
  * up a GpioIo/GpioInt resource, translates it to the Linux GPIO descriptor,
  * and returns it. @index matches GpioIo/GpioInt resources only so if there
  * are total %3 GPIO resources, the index goes from %0 to %2.
  *
+ * If @propname is specified the GPIO is looked using device property. In
+ * that case @index is used to select the GPIO entry in the property value
+ * (in case of multiple).
+ *
  * If the GPIO cannot be translated or there is an error an ERR_PTR is
  * returned.
  *
  * Note: if the GPIO resource has multiple entries in the pin list, this
  * function only returns the first.
  */
-struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
+struct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,
+					  const char *propname, int index,
 					  struct acpi_gpio_info *info)
 {
 	struct acpi_gpio_lookup lookup;
 	struct list_head resource_list;
-	struct acpi_device *adev;
-	acpi_handle handle;
+	bool active_low = false;
 	int ret;
 
-	if (!dev)
-		return ERR_PTR(-EINVAL);
-
-	handle = ACPI_HANDLE(dev);
-	if (!handle || acpi_bus_get_device(handle, &adev))
+	if (!adev)
 		return ERR_PTR(-ENODEV);
 
 	memset(&lookup, 0, sizeof(lookup));
 	lookup.index = index;
 
+	if (propname) {
+		struct acpi_reference_args args;
+
+		dev_dbg(&adev->dev, "GPIO: looking up %s\n", propname);
+
+		memset(&args, 0, sizeof(args));
+		ret = acpi_dev_get_property_reference(adev, propname, NULL,
+						      index, &args);
+		if (ret)
+			return ERR_PTR(ret);
+
+		/*
+		 * The property was found and resolved so need to
+		 * lookup the GPIO based on returned args instead.
+		 */
+		adev = args.adev;
+		if (args.nargs >= 2) {
+			lookup.index = args.args[0];
+			lookup.pin_index = args.args[1];
+			/*
+			 * 3rd argument, if present is used to
+			 * specify active_low.
+			 */
+			if (args.nargs >= 3)
+				active_low = !!args.args[2];
+		}
+
+		dev_dbg(&adev->dev, "GPIO: _DSD returned %s %zd %llu %llu %llu\n",
+			dev_name(&adev->dev), args.nargs,
+			args.args[0], args.args[1], args.args[2]);
+	} else {
+		dev_dbg(&adev->dev, "GPIO: looking up %d in _CRS\n", index);
+	}
+
 	INIT_LIST_HEAD(&resource_list);
 	ret = acpi_dev_get_resources(adev, &resource_list, acpi_find_gpio,
 				     &lookup);
@@ -359,8 +406,11 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
 
 	acpi_dev_free_resource_list(&resource_list);
 
-	if (lookup.desc && info)
+	if (lookup.desc && info) {
 		*info = lookup.info;
+		if (active_low)
+			info->active_low = active_low;
+	}
 
 	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
 }

commit 354567e6084c0760dc1e3a164ce4e77c5a943acc
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Nov 3 13:01:32 2014 +0200

    gpio / ACPI: Add knowledge about pin controllers to acpi_get_gpiod()
    
    The GPIO resources (GpioIo/GpioInt) used in ACPI contain a GPIO number
    which is relative to the hardware GPIO controller. Typically this number
    can be translated directly to Linux GPIO number because the mapping is
    pretty much 1:1.
    
    However, when the GPIO driver is using pins exported by a pin controller
    driver via set of GPIO ranges, the mapping might not be 1:1 anymore and
    direct translation does not work.
    
    In such cases we need to translate the ACPI GPIO number to be suitable for
    the GPIO controller driver in question by checking all the pin controller
    GPIO ranges under the given device and using those to get the proper GPIO
    number.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 05c6275da224..5be637dffa73 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -11,12 +11,14 @@
  */
 
 #include <linux/errno.h>
+#include <linux/gpio.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio/driver.h>
 #include <linux/export.h>
 #include <linux/acpi.h>
 #include <linux/interrupt.h>
 #include <linux/mutex.h>
+#include <linux/pinctrl/pinctrl.h>
 
 #include "gpiolib.h"
 
@@ -55,6 +57,58 @@ static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 	return ACPI_HANDLE(gc->dev) == data;
 }
 
+#ifdef CONFIG_PINCTRL
+/**
+ * acpi_gpiochip_pin_to_gpio_offset() - translates ACPI GPIO to Linux GPIO
+ * @chip: GPIO chip
+ * @pin: ACPI GPIO pin number from GpioIo/GpioInt resource
+ *
+ * Function takes ACPI GpioIo/GpioInt pin number as a parameter and
+ * translates it to a corresponding offset suitable to be passed to a
+ * GPIO controller driver.
+ *
+ * Typically the returned offset is same as @pin, but if the GPIO
+ * controller uses pin controller and the mapping is not contigous the
+ * offset might be different.
+ */
+static int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip, int pin)
+{
+	struct gpio_pin_range *pin_range;
+
+	/* If there are no ranges in this chip, use 1:1 mapping */
+	if (list_empty(&chip->pin_ranges))
+		return pin;
+
+	list_for_each_entry(pin_range, &chip->pin_ranges, node) {
+		const struct pinctrl_gpio_range *range = &pin_range->range;
+		int i;
+
+		if (range->pins) {
+			for (i = 0; i < range->npins; i++) {
+				if (range->pins[i] == pin)
+					return range->base + i - chip->base;
+			}
+		} else {
+			if (pin >= range->pin_base &&
+			    pin < range->pin_base + range->npins) {
+				unsigned gpio_base;
+
+				gpio_base = range->base - chip->base;
+				return gpio_base + pin - range->pin_base;
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+#else
+static inline int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip,
+						   int pin)
+{
+	return pin;
+}
+#endif
+
 /**
  * acpi_get_gpiod() - Translate ACPI GPIO pin to GPIO descriptor usable with GPIO API
  * @path:	ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
@@ -69,6 +123,7 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	struct gpio_chip *chip;
 	acpi_handle handle;
 	acpi_status status;
+	int offset;
 
 	status = acpi_get_handle(NULL, path, &handle);
 	if (ACPI_FAILURE(status))
@@ -78,10 +133,11 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	if (!chip)
 		return ERR_PTR(-ENODEV);
 
-	if (pin < 0 || pin > chip->ngpio)
-		return ERR_PTR(-EINVAL);
+	offset = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+	if (offset < 0)
+		return ERR_PTR(offset);
 
-	return gpiochip_get_desc(chip, pin);
+	return gpiochip_get_desc(chip, offset);
 }
 
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)

commit e3a2e87893125bcd99bd7e1ddf9bfc421e492572
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Oct 23 17:27:07 2014 +0900

    gpio: rename gpio_lock_as_irq to gpiochip_lock_as_irq
    
    This function actually operates on a gpio_chip, so its prefix should
    reflect that fact for consistency with other functions defined in
    gpio/driver.h.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 05c6275da224..349a7552dd23 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -153,7 +153,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	gpiod_direction_input(desc);
 
-	ret = gpio_lock_as_irq(chip, pin);
+	ret = gpiochip_lock_as_irq(chip, pin);
 	if (ret) {
 		dev_err(chip->dev, "Failed to lock GPIO as interrupt\n");
 		goto fail_free_desc;
@@ -209,7 +209,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 fail_free_event:
 	kfree(event);
 fail_unlock_irq:
-	gpio_unlock_as_irq(chip, pin);
+	gpiochip_unlock_as_irq(chip, pin);
 fail_free_desc:
 	gpiochip_free_own_desc(desc);
 
@@ -280,7 +280,7 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 		desc = event->desc;
 		if (WARN_ON(IS_ERR(desc)))
 			continue;
-		gpio_unlock_as_irq(chip, event->pin);
+		gpiochip_unlock_as_irq(chip, event->pin);
 		gpiochip_free_own_desc(desc);
 		list_del(&event->node);
 		kfree(event);

commit ea584595fc85e65796335033dfca25ed655cd0ed
Merge: 782d59c5dfc5 a092e19b688b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 14:58:15 2014 -0400

    Merge tag 'gpio-v3.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO changes from Linus Walleij:
     "This is the bulk of GPIO changes for the v3.18 development cycle:
    
       - Increase the default ARCH_NR_GPIO from 256 to 512.  This was done
         to avoid having a custom <asm/gpio.h> header for the x86
         architecture - GPIO is custom and complicated enough as it is
         already! We want to move to a radix to store the descriptors going
         forward, and finally get rid of this fixed array size altogether.
    
       - Endgame patching of the gpio_remove() semantics initiated by
         Abdoulaye Berthe.  It is not accepted by the system that the
         removal of a GPIO chip fails during eg reboot or shutdown, and
         therefore the return value has now painfully been refactored away.
         For special cases like GPIO expanders on a hot-pluggable bus like
         USB, we may later add some gpiochip_try_remove() call, but for the
         cases we have now, return values are moot.
    
       - Some incremental refactoring of the gpiolib core and ACPI GPIO
         library for more descriptor usage.
    
       - Refactor the chained IRQ handler set-up method to handle also
         threaded, nested interrupts and set up the parent IRQ correctly.
         Switch STMPE and TC3589x drivers to use this registration method.
    
       - Add a .irq_not_threaded flag to the struct gpio_chip, so that also
         GPIO expanders that block but are still not using threaded IRQ
         handlers.
    
       - New drivers for the ARM64 X-Gene SoC GPIO controller.
    
       - The syscon GPIO driver has been improved to handle the "DSP GPIO"
         found on the TI Keystone 2 SoC:s.
    
       - ADNP driver switched to use gpiolib irqchip helpers.
    
       - Refactor the DWAPB driver to support being instantiated from and
         MFD cell (platform device).
    
       - Incremental feature improvement in the Zynq, MCP23S08, DWAPB, OMAP,
         Xilinx and Crystalcove drivers.
    
       - Various minor fixes"
    
    * tag 'gpio-v3.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (52 commits)
      gpio: pch: Build context save/restore only for PM
      pinctrl: abx500: get rid of unused variable
      gpio: ks8695: fix 'else should follow close brace '}''
      gpio: stmpe: add verbose debug code
      gpio: stmpe: fix up interrupt enable logic
      gpio: staticize xway_stp_init()
      gpio: handle also nested irqchips in the chained handler set-up
      gpio: set parent irq on chained handlers
      gpiolib: irqchip: use irq_find_mapping while removing irqchip
      gpio: crystalcove: support virtual GPIO
      pinctrl: bcm281xx: make Kconfig dependency more strict
      gpio: kona: enable only on BCM_MOBILE or for compile testing
      gpio, bcm-kona, LLVMLinux: Remove use of __initconst
      gpio: Fix ngpio in gpio-xilinx driver
      gpio: dwapb: fix pointer to integer cast
      gpio: xgene: Remove unneeded #ifdef CONFIG_OF guard
      gpio: xgene: Remove unneeded forward declation for struct xgene_gpio
      gpio: xgene: Fix missing spin_lock_init()
      gpio: ks8695: fix switch case indentation
      gpiolib: add irq_not_threaded flag to gpio_chip
      ...

commit c15d821ddb9dac9ac6b5beb75bf942f3bc3a4004
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Sep 23 10:35:54 2014 +0800

    gpio / ACPI: Use pin index and bit length
    
    Fix code when the operation region callback is for an gpio, which
    is not at index 0 and for partial pins in a GPIO definition.
    For example:
    Name (GMOD, ResourceTemplate ()
    {
            //3 Outputs that define the Power mode of the device
            GpioIo (Exclusive, PullDown, , , , "\\_SB.GPI2") {10, 11, 12}
            })
    }
    
    If opregion callback calls is for:
    - Set pin 10, then address = 0 and bit length = 1
    - Set pin 11, then address = 1 and bit length = 1
    - Set for both pin 11 and pin 12, then address = 1, bit length = 2
    
    This change requires updated ACPICA gpio operation handler code to
    send the pin index and bit length.
    
    Fixes: 473ed7be0da0 (gpio / ACPI: Add support for ACPI GPIO operation regions)
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: 3.15+ <stable@vger.kernel.org> # 3.15+: 75ec6e55f138 ACPICA: Update to GPIO region handler interface.
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d62eaaa75397..687476fb39e3 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -377,8 +377,10 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 	struct gpio_chip *chip = achip->chip;
 	struct acpi_resource_gpio *agpio;
 	struct acpi_resource *ares;
+	int pin_index = (int)address;
 	acpi_status status;
 	bool pull_up;
+	int length;
 	int i;
 
 	status = acpi_buffer_to_resource(achip->conn_info.connection,
@@ -400,7 +402,8 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		return AE_BAD_PARAMETER;
 	}
 
-	for (i = 0; i < agpio->pin_table_length; i++) {
+	length = min(agpio->pin_table_length, (u16)(pin_index + bits));
+	for (i = pin_index; i < length; ++i) {
 		unsigned pin = agpio->pin_table[i];
 		struct acpi_gpio_connection *conn;
 		struct gpio_desc *desc;

commit abdc08a3a263a20e49534a36291d657bf53dda5b
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Aug 19 10:06:09 2014 -0700

    gpio: change gpiochip_request_own_desc() prototype
    
    The current prototype of gpiochip_request_own_desc() requires to obtain
    a pointer to a descriptor. This is in contradiction to all other GPIO
    request schemes, and imposes an extra step of obtaining a descriptor to
    drivers. Most drivers actually cannot even perform that step since the
    function that does it (gpichip_get_desc()) is gpiolib-private.
    
    Change gpiochip_request_own_desc() to return a descriptor from a
    (chip, hwnum) tuple and update users of this function (currently
    gpiolib-acpi only).
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 84540025aa08..f9103e72e2a4 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -145,14 +145,8 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	if (!handler)
 		return AE_BAD_PARAMETER;
 
-	desc = gpiochip_get_desc(chip, pin);
+	desc = gpiochip_request_own_desc(chip, pin, "ACPI:Event");
 	if (IS_ERR(desc)) {
-		dev_err(chip->dev, "Failed to get GPIO descriptor\n");
-		return AE_ERROR;
-	}
-
-	ret = gpiochip_request_own_desc(desc, "ACPI:Event");
-	if (ret) {
 		dev_err(chip->dev, "Failed to request GPIO\n");
 		return AE_ERROR;
 	}
@@ -420,22 +414,14 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 			}
 		}
 		if (!found) {
-			int ret;
-
-			desc = gpiochip_get_desc(chip, pin);
+			desc = gpiochip_request_own_desc(chip, pin,
+							 "ACPI:OpRegion");
 			if (IS_ERR(desc)) {
 				status = AE_ERROR;
 				mutex_unlock(&achip->conn_lock);
 				goto out;
 			}
 
-			ret = gpiochip_request_own_desc(desc, "ACPI:OpRegion");
-			if (ret) {
-				status = AE_ERROR;
-				mutex_unlock(&achip->conn_lock);
-				goto out;
-			}
-
 			switch (agpio->io_restriction) {
 			case ACPI_IO_RESTRICT_INPUT:
 				gpiod_direction_input(desc);

commit e46cf32ced90d00972d5c3d9322cdb848d183338
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Aug 19 10:06:08 2014 -0700

    gpio: acpi: normalize use of gpiochip_get_desc()
    
    GPIO descriptors are changing from unique and permanent tokens to
    allocated resources. Therefore gpiochip_get_desc() cannot be used as a
    way to obtain a global GPIO descriptor anymore.
    
    This patch updates the gpiolib ACPI support code to keep and use the
    descriptor returned by a centralized call to gpiochip_get_desc().
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d62eaaa75397..84540025aa08 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -25,10 +25,12 @@ struct acpi_gpio_event {
 	acpi_handle handle;
 	unsigned int pin;
 	unsigned int irq;
+	struct gpio_desc *desc;
 };
 
 struct acpi_gpio_connection {
 	struct list_head node;
+	unsigned int pin;
 	struct gpio_desc *desc;
 };
 
@@ -197,6 +199,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 	event->handle = evt_handle;
 	event->irq = irq;
 	event->pin = pin;
+	event->desc = desc;
 
 	ret = request_threaded_irq(event->irq, NULL, handler, irqflags,
 				   "ACPI:Event", event);
@@ -280,7 +283,7 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 		struct gpio_desc *desc;
 
 		free_irq(event->irq, event);
-		desc = gpiochip_get_desc(chip, event->pin);
+		desc = event->desc;
 		if (WARN_ON(IS_ERR(desc)))
 			continue;
 		gpio_unlock_as_irq(chip, event->pin);
@@ -406,24 +409,26 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		struct gpio_desc *desc;
 		bool found;
 
-		desc = gpiochip_get_desc(chip, pin);
-		if (IS_ERR(desc)) {
-			status = AE_ERROR;
-			goto out;
-		}
-
 		mutex_lock(&achip->conn_lock);
 
 		found = false;
 		list_for_each_entry(conn, &achip->conns, node) {
-			if (conn->desc == desc) {
+			if (conn->pin == pin) {
 				found = true;
+				desc = conn->desc;
 				break;
 			}
 		}
 		if (!found) {
 			int ret;
 
+			desc = gpiochip_get_desc(chip, pin);
+			if (IS_ERR(desc)) {
+				status = AE_ERROR;
+				mutex_unlock(&achip->conn_lock);
+				goto out;
+			}
+
 			ret = gpiochip_request_own_desc(desc, "ACPI:OpRegion");
 			if (ret) {
 				status = AE_ERROR;
@@ -462,6 +467,7 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 				goto out;
 			}
 
+			conn->pin = pin;
 			conn->desc = desc;
 			list_add_tail(&conn->node, &achip->conns);
 		}

commit afa82fab5e136fc64eaf26db9b00c661286e1762
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Jul 25 09:54:48 2014 +0300

    gpio / ACPI: Move event handling registration to gpiolib irqchip helpers
    
    Since now we have irqchip helpers that the GPIO chip drivers are supposed
    to use if possible, we can move the registration of ACPI events to happen
    in these helpers. This seems to be more natural place and might encourage
    GPIO chip driver writers to take advantage of the irqchip helpers.
    
    We make the functions available to GPIO chip drivers via private gpiolib.h,
    just in case generic irqchip helpers are not suitable.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d2e8600df02c..d62eaaa75397 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -221,7 +221,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 /**
  * acpi_gpiochip_request_interrupts() - Register isr for gpio chip ACPI events
- * @acpi_gpio:      ACPI GPIO chip
+ * @chip:      GPIO chip
  *
  * ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
  * handled by ACPI event methods which need to be called from the GPIO
@@ -229,11 +229,21 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
  * gpio pins have acpi event methods and assigns interrupt handlers that calls
  * the acpi event methods for those pins.
  */
-static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
+void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 {
-	struct gpio_chip *chip = acpi_gpio->chip;
+	struct acpi_gpio_chip *acpi_gpio;
+	acpi_handle handle;
+	acpi_status status;
+
+	if (!chip->dev || !chip->to_irq)
+		return;
 
-	if (!chip->to_irq)
+	handle = ACPI_HANDLE(chip->dev);
+	if (!handle)
+		return;
+
+	status = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);
+	if (ACPI_FAILURE(status))
 		return;
 
 	INIT_LIST_HEAD(&acpi_gpio->events);
@@ -243,17 +253,27 @@ static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
 
 /**
  * acpi_gpiochip_free_interrupts() - Free GPIO ACPI event interrupts.
- * @acpi_gpio:      ACPI GPIO chip
+ * @chip:      GPIO chip
  *
  * Free interrupts associated with GPIO ACPI event method for the given
  * GPIO chip.
  */
-static void acpi_gpiochip_free_interrupts(struct acpi_gpio_chip *acpi_gpio)
+void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 {
+	struct acpi_gpio_chip *acpi_gpio;
 	struct acpi_gpio_event *event, *ep;
-	struct gpio_chip *chip = acpi_gpio->chip;
+	acpi_handle handle;
+	acpi_status status;
+
+	if (!chip->dev || !chip->to_irq)
+		return;
 
-	if (!chip->to_irq)
+	handle = ACPI_HANDLE(chip->dev);
+	if (!handle)
+		return;
+
+	status = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);
+	if (ACPI_FAILURE(status))
 		return;
 
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
@@ -525,7 +545,6 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 		return;
 	}
 
-	acpi_gpiochip_request_interrupts(acpi_gpio);
 	acpi_gpiochip_request_regions(acpi_gpio);
 }
 
@@ -549,7 +568,6 @@ void acpi_gpiochip_remove(struct gpio_chip *chip)
 	}
 
 	acpi_gpiochip_free_regions(acpi_gpio);
-	acpi_gpiochip_free_interrupts(acpi_gpio);
 
 	acpi_detach_data(handle, acpi_gpio_chip_dh);
 	kfree(acpi_gpio);

commit d74be6dfea1b96cfb4bd79d9254fa9d21ed5f131
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Jul 22 16:17:42 2014 +0900

    gpio: remove gpiod_lock/unlock_as_irq()
    
    gpio_lock/unlock_as_irq() are working with (chip, offset) arguments and
    are thus not using the old integer namespace. Therefore, there is no
    reason to have gpiod variants of these functions working with
    descriptors, especially since the (chip, offset) tuple is more suitable
    to the users of these functions (GPIO drivers, whereas GPIO descriptors
    are targeted at GPIO consumers).
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 4a987917c186..d2e8600df02c 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -157,7 +157,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 
 	gpiod_direction_input(desc);
 
-	ret = gpiod_lock_as_irq(desc);
+	ret = gpio_lock_as_irq(chip, pin);
 	if (ret) {
 		dev_err(chip->dev, "Failed to lock GPIO as interrupt\n");
 		goto fail_free_desc;
@@ -212,7 +212,7 @@ static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
 fail_free_event:
 	kfree(event);
 fail_unlock_irq:
-	gpiod_unlock_as_irq(desc);
+	gpio_unlock_as_irq(chip, pin);
 fail_free_desc:
 	gpiochip_free_own_desc(desc);
 
@@ -263,7 +263,7 @@ static void acpi_gpiochip_free_interrupts(struct acpi_gpio_chip *acpi_gpio)
 		desc = gpiochip_get_desc(chip, event->pin);
 		if (WARN_ON(IS_ERR(desc)))
 			continue;
-		gpiod_unlock_as_irq(desc);
+		gpio_unlock_as_irq(chip, event->pin);
 		gpiochip_free_own_desc(desc);
 		list_del(&event->node);
 		kfree(event);

commit dc62b56a68d3d6dd1044e1f7d0c8310339cb5b5f
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue May 20 17:07:38 2014 +0800

    gpio / ACPI: use *_cansleep version of gpiod_get/set APIs
    
    The GPIO operation region handler should be called where sleep is
    allowed, so we should use the *_cansleep version of gpiod_get/set APIs
    or we will get a warning message complaining invalid context if the GPIO
    chip has the cansleep flag set.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 401add28933f..4a987917c186 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -449,9 +449,10 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		mutex_unlock(&achip->conn_lock);
 
 		if (function == ACPI_WRITE)
-			gpiod_set_raw_value(desc, !!((1 << i) & *value));
+			gpiod_set_raw_value_cansleep(desc,
+						     !!((1 << i) & *value));
 		else
-			*value |= (u64)gpiod_get_raw_value(desc) << i;
+			*value |= (u64)gpiod_get_raw_value_cansleep(desc) << i;
 	}
 
 out:

commit b5539fa2d59d697b7b8e28b4d08da844ff60f7cf
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Apr 1 13:03:00 2014 +0300

    gpio / ACPI: Prevent potential wrap of GPIO value on OpRegion read
    
    Dan Carpenter's static code checker reports:
    
     The patch 473ed7be0da0: "gpio / ACPI: Add support for ACPI GPIO
     operation regions" from Mar 14, 2014, leads to the following static
     checker warning:
    
      drivers/gpio/gpiolib-acpi.c:454 acpi_gpio_adr_space_handler()
      warn: should 'gpiod_get_raw_value(desc) << i' be a 64 bit type?
    
    This is due the fact that *value is of type u64 and gpiod_get_raw_value()
    returns int. Since i can be larger than 31, it is possible that the value
    returned gets wrapped.
    
    Fix this by casting the return of gpiod_get_raw_value() to u64 first before
    shift.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index d5be56fe689e..401add28933f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -451,7 +451,7 @@ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
 		if (function == ACPI_WRITE)
 			gpiod_set_raw_value(desc, !!((1 << i) & *value));
 		else
-			*value |= gpiod_get_raw_value(desc) << i;
+			*value |= (u64)gpiod_get_raw_value(desc) << i;
 	}
 
 out:

commit e9595f84a6273dffc5b75564d9b12a77630c529e
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Mar 31 15:16:49 2014 +0300

    gpio / ACPI: Don't crash on NULL chip->dev
    
    Commit aa92b6f689ac (gpio / ACPI: Allocate ACPI specific data directly in
    acpi_gpiochip_add()) moved ACPI handle checking to acpi_gpiochip_add() but
    forgot to check whether chip->dev is NULL before dereferencing it.
    
    Since chip->dev pointer is optional we can end up with crash like following:
    
     BUG: unable to handle kernel NULL pointer dereference at 00000138
     IP: [<c126c2b3>] acpi_gpiochip_add+0x13/0x190
     *pde = 00000000
     Oops: 0000 [#1] PREEMPT SMP
     Modules linked in: ssb(+) ...
     CPU: 0 PID: 512 Comm: modprobe Tainted: G        W     3.14.0-rc7-next-20140324-t1 #24
     Hardware name: Dell Inc. Latitude D830                   /0UY141, BIOS A02 06/07/2007
     task: f5799900 ti: f543e000 task.ti: f543e000
     EIP: 0060:[<c126c2b3>] EFLAGS: 00010282 CPU: 0
     EIP is at acpi_gpiochip_add+0x13/0x190
     EAX: 00000000 EBX: f57824c4 ECX: 00000000 EDX: 00000000
     ESI: f57824c4 EDI: 00000010 EBP: f543fc54 ESP: f543fc40
      DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
     CR0: 8005003b CR2: 00000138 CR3: 355f8000 CR4: 000007d0
     Stack:
      f543fc5c fd1f7790 f57824c4 000000be 00000010 f543fc84 c1269f4e f543fc74
      fd1f78bd 00008002 f57822b0 f5782090 fd1f8400 00000286 fd1f9994 00000000
      f5782000 f543fc8c fd1f7e39 f543fcc8 fd1f0bd8 000000c0 00000000 00000000
     Call Trace:
      [<fd1f7790>] ? ssb_pcie_mdio_write+0xa0/0xd0 [ssb]
      [<c1269f4e>] gpiochip_add+0xee/0x300
      [<fd1f78bd>] ? ssb_pcicore_serdes_workaround+0xfd/0x140 [ssb]
      [<fd1f7e39>] ssb_gpio_init+0x89/0xa0 [ssb]
      [<fd1f0bd8>] ssb_attach_queued_buses+0xc8/0x2d0 [ssb]
      [<fd1f0f65>] ssb_bus_register+0x185/0x1f0 [ssb]
      [<fd1f3120>] ? ssb_pci_xtal+0x220/0x220 [ssb]
      [<fd1f106c>] ssb_bus_pcibus_register+0x2c/0x80 [ssb]
      [<fd1f40dc>] ssb_pcihost_probe+0x9c/0x110 [ssb]
      [<c1276c8f>] pci_device_probe+0x6f/0xc0
      [<c11bdb55>] ? sysfs_create_link+0x25/0x40
      [<c131d8b9>] driver_probe_device+0x79/0x360
      [<c1276512>] ? pci_match_device+0xb2/0xc0
      [<c131dc51>] __driver_attach+0x71/0x80
      [<c131dbe0>] ? __device_attach+0x40/0x40
      [<c131bd87>] bus_for_each_dev+0x47/0x80
      [<c131d3ae>] driver_attach+0x1e/0x20
      [<c131dbe0>] ? __device_attach+0x40/0x40
      [<c131d007>] bus_add_driver+0x157/0x230
      [<c131e219>] driver_register+0x59/0xe0
      ...
    
    Fix this by checking chip->dev pointer against NULL first. Also we can now
    remove redundant check in acpi_gpiochip_request/free_interrupts().
    
    Reported-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Sabrina Dubroca <sd@queasysnail.net>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Tested-by: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index bf0f8b476696..d5be56fe689e 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -233,7 +233,7 @@ static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
 {
 	struct gpio_chip *chip = acpi_gpio->chip;
 
-	if (!chip->dev || !chip->to_irq)
+	if (!chip->to_irq)
 		return;
 
 	INIT_LIST_HEAD(&acpi_gpio->events);
@@ -253,7 +253,7 @@ static void acpi_gpiochip_free_interrupts(struct acpi_gpio_chip *acpi_gpio)
 	struct acpi_gpio_event *event, *ep;
 	struct gpio_chip *chip = acpi_gpio->chip;
 
-	if (!chip->dev || !chip->to_irq)
+	if (!chip->to_irq)
 		return;
 
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
@@ -501,6 +501,9 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 	acpi_handle handle;
 	acpi_status status;
 
+	if (!chip || !chip->dev)
+		return;
+
 	handle = ACPI_HANDLE(chip->dev);
 	if (!handle)
 		return;
@@ -531,6 +534,9 @@ void acpi_gpiochip_remove(struct gpio_chip *chip)
 	acpi_handle handle;
 	acpi_status status;
 
+	if (!chip || !chip->dev)
+		return;
+
 	handle = ACPI_HANDLE(chip->dev);
 	if (!handle)
 		return;

commit 473ed7be0da041275d57ab0bde1c21a6f23e637f
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Mar 14 17:58:07 2014 +0200

    gpio / ACPI: Add support for ACPI GPIO operation regions
    
    GPIO operation regions is a new feature introduced in ACPI 5.0
    specification. This feature adds a way for platform ASL code to call back
    to OS GPIO driver and toggle GPIO pins.
    
    An example ASL code from Lenovo Miix 2 tablet with only relevant part
    listed:
    
     Device (\_SB.GPO0)
     {
         Name (AVBL, Zero)
         Method (_REG, 2, NotSerialized)
         {
             If (LEqual (Arg0, 0x08))
             {
                 // Marks the region available
                 Store (Arg1, AVBL)
             }
         }
    
         OperationRegion (GPOP, GeneralPurposeIo, Zero, 0x0C)
         Field (GPOP, ByteAcc, NoLock, Preserve)
         {
             Connection (
                 GpioIo (Exclusive, PullDefault, 0, 0, IoRestrictionOutputOnly,
                         "\\_SB.GPO0", 0x00, ResourceConsumer,,)
                 {
                     0x003B
                 }
             ),
             SHD3,   1,
         }
     }
    
     Device (SHUB)
     {
         Method (_PS0, 0, Serialized)
         {
             If (LEqual (\_SB.GPO0.AVBL, One))
             {
                 Store (One, \_SB.GPO0.SHD3)
                 Sleep (0x32)
             }
         }
         Method (_PS3, 0, Serialized)
         {
             If (LEqual (\_SB.GPO0.AVBL, One))
             {
                 Store (Zero, \_SB.GPO0.SHD3)
             }
         }
     }
    
    How this works is that whenever _PS0 or _PS3 method is run (typically when
    SHUB device is transitioned to D0 or D3 respectively), ASL code checks if
    the GPIO operation region is available (\_SB.GPO0.AVBL). If it is we go and
    store either 0 or 1 to \_SB.GPO0.SHD3.
    
    Now, when ACPICA notices ACPI GPIO operation region access (the store
    above) it will call acpi_gpio_adr_space_handler() that then toggles the
    GPIO accordingly using standard gpiolib interfaces.
    
    Implement the support by registering GPIO operation region handlers for all
    GPIO devices that have an ACPI handle. First time the GPIO is used by the
    ASL code we make sure that the GPIO stays requested until the GPIO chip
    driver itself is unloaded. If we find out that the GPIO is already
    requested we just toggle it according to the value got from ASL code.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 092ea4e5c9a8..bf0f8b476696 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -16,6 +16,7 @@
 #include <linux/export.h>
 #include <linux/acpi.h>
 #include <linux/interrupt.h>
+#include <linux/mutex.h>
 
 #include "gpiolib.h"
 
@@ -26,7 +27,20 @@ struct acpi_gpio_event {
 	unsigned int irq;
 };
 
+struct acpi_gpio_connection {
+	struct list_head node;
+	struct gpio_desc *desc;
+};
+
 struct acpi_gpio_chip {
+	/*
+	 * ACPICA requires that the first field of the context parameter
+	 * passed to acpi_install_address_space_handler() is large enough
+	 * to hold struct acpi_connection_info.
+	 */
+	struct acpi_connection_info conn_info;
+	struct list_head conns;
+	struct mutex conn_lock;
 	struct gpio_chip *chip;
 	struct list_head events;
 };
@@ -334,6 +348,153 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
 	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
 }
 
+static acpi_status
+acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
+			    u32 bits, u64 *value, void *handler_context,
+			    void *region_context)
+{
+	struct acpi_gpio_chip *achip = region_context;
+	struct gpio_chip *chip = achip->chip;
+	struct acpi_resource_gpio *agpio;
+	struct acpi_resource *ares;
+	acpi_status status;
+	bool pull_up;
+	int i;
+
+	status = acpi_buffer_to_resource(achip->conn_info.connection,
+					 achip->conn_info.length, &ares);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	if (WARN_ON(ares->type != ACPI_RESOURCE_TYPE_GPIO)) {
+		ACPI_FREE(ares);
+		return AE_BAD_PARAMETER;
+	}
+
+	agpio = &ares->data.gpio;
+	pull_up = agpio->pin_config == ACPI_PIN_CONFIG_PULLUP;
+
+	if (WARN_ON(agpio->io_restriction == ACPI_IO_RESTRICT_INPUT &&
+	    function == ACPI_WRITE)) {
+		ACPI_FREE(ares);
+		return AE_BAD_PARAMETER;
+	}
+
+	for (i = 0; i < agpio->pin_table_length; i++) {
+		unsigned pin = agpio->pin_table[i];
+		struct acpi_gpio_connection *conn;
+		struct gpio_desc *desc;
+		bool found;
+
+		desc = gpiochip_get_desc(chip, pin);
+		if (IS_ERR(desc)) {
+			status = AE_ERROR;
+			goto out;
+		}
+
+		mutex_lock(&achip->conn_lock);
+
+		found = false;
+		list_for_each_entry(conn, &achip->conns, node) {
+			if (conn->desc == desc) {
+				found = true;
+				break;
+			}
+		}
+		if (!found) {
+			int ret;
+
+			ret = gpiochip_request_own_desc(desc, "ACPI:OpRegion");
+			if (ret) {
+				status = AE_ERROR;
+				mutex_unlock(&achip->conn_lock);
+				goto out;
+			}
+
+			switch (agpio->io_restriction) {
+			case ACPI_IO_RESTRICT_INPUT:
+				gpiod_direction_input(desc);
+				break;
+			case ACPI_IO_RESTRICT_OUTPUT:
+				/*
+				 * ACPI GPIO resources don't contain an
+				 * initial value for the GPIO. Therefore we
+				 * deduce that value from the pull field
+				 * instead. If the pin is pulled up we
+				 * assume default to be high, otherwise
+				 * low.
+				 */
+				gpiod_direction_output(desc, pull_up);
+				break;
+			default:
+				/*
+				 * Assume that the BIOS has configured the
+				 * direction and pull accordingly.
+				 */
+				break;
+			}
+
+			conn = kzalloc(sizeof(*conn), GFP_KERNEL);
+			if (!conn) {
+				status = AE_NO_MEMORY;
+				gpiochip_free_own_desc(desc);
+				mutex_unlock(&achip->conn_lock);
+				goto out;
+			}
+
+			conn->desc = desc;
+			list_add_tail(&conn->node, &achip->conns);
+		}
+
+		mutex_unlock(&achip->conn_lock);
+
+		if (function == ACPI_WRITE)
+			gpiod_set_raw_value(desc, !!((1 << i) & *value));
+		else
+			*value |= gpiod_get_raw_value(desc) << i;
+	}
+
+out:
+	ACPI_FREE(ares);
+	return status;
+}
+
+static void acpi_gpiochip_request_regions(struct acpi_gpio_chip *achip)
+{
+	struct gpio_chip *chip = achip->chip;
+	acpi_handle handle = ACPI_HANDLE(chip->dev);
+	acpi_status status;
+
+	INIT_LIST_HEAD(&achip->conns);
+	mutex_init(&achip->conn_lock);
+	status = acpi_install_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,
+						    acpi_gpio_adr_space_handler,
+						    NULL, achip);
+	if (ACPI_FAILURE(status))
+		dev_err(chip->dev, "Failed to install GPIO OpRegion handler\n");
+}
+
+static void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)
+{
+	struct gpio_chip *chip = achip->chip;
+	acpi_handle handle = ACPI_HANDLE(chip->dev);
+	struct acpi_gpio_connection *conn, *tmp;
+	acpi_status status;
+
+	status = acpi_remove_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,
+						   acpi_gpio_adr_space_handler);
+	if (ACPI_FAILURE(status)) {
+		dev_err(chip->dev, "Failed to remove GPIO OpRegion handler\n");
+		return;
+	}
+
+	list_for_each_entry_safe_reverse(conn, tmp, &achip->conns, node) {
+		gpiochip_free_own_desc(conn->desc);
+		list_del(&conn->node);
+		kfree(conn);
+	}
+}
+
 void acpi_gpiochip_add(struct gpio_chip *chip)
 {
 	struct acpi_gpio_chip *acpi_gpio;
@@ -361,6 +522,7 @@ void acpi_gpiochip_add(struct gpio_chip *chip)
 	}
 
 	acpi_gpiochip_request_interrupts(acpi_gpio);
+	acpi_gpiochip_request_regions(acpi_gpio);
 }
 
 void acpi_gpiochip_remove(struct gpio_chip *chip)
@@ -379,6 +541,7 @@ void acpi_gpiochip_remove(struct gpio_chip *chip)
 		return;
 	}
 
+	acpi_gpiochip_free_regions(acpi_gpio);
 	acpi_gpiochip_free_interrupts(acpi_gpio);
 
 	acpi_detach_data(handle, acpi_gpio_chip_dh);

commit 6072b9dcf97870c9e840ad91862da7ff8ed680ee
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Mar 10 14:54:53 2014 +0200

    gpio / ACPI: Rework ACPI GPIO event handling
    
    The current ACPI GPIO event handling code was never tested against real
    hardware with functioning GPIO triggered events (at the time such hardware
    wasn't available). Thus it misses certain things like requesting the GPIOs
    properly, passing correct flags to the interrupt handler and so on.
    
    This patch reworks ACPI GPIO event handling so that we:
    
     1) Use struct acpi_gpio_event for all GPIO signaled events.
     2) Switch to use GPIO descriptor API and request GPIOs by calling
        gpiochip_request_own_desc() that we added in a previous patch.
     3) Pass proper flags from ACPI GPIO resource to request_threaded_irq().
    
    Also instead of open-coding the _AEI iteration loop we can use
    acpi_walk_resources(). This simplifies the code a bit and fixes memory leak
    that was caused by missing kfree() for buffer returned by
    acpi_get_event_resources().
    
    Since the remove path now calls gpiochip_free_own_desc() which takes GPIO
    spinlock we need to call acpi_gpiochip_remove() outside of that lock
    (analogous to acpi_gpiochip_add() path where the lock is released before
    those funtions are called).
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index be09e7526890..092ea4e5c9a8 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -70,9 +70,9 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 {
-	acpi_handle handle = data;
+	struct acpi_gpio_event *event = data;
 
-	acpi_evaluate_object(handle, NULL, NULL, NULL);
+	acpi_evaluate_object(event->handle, NULL, NULL, NULL);
 
 	return IRQ_HANDLED;
 }
@@ -91,111 +91,148 @@ static void acpi_gpio_chip_dh(acpi_handle handle, void *data)
 	/* The address of this function is used as a key. */
 }
 
-/**
- * acpi_gpiochip_request_interrupts() - Register isr for gpio chip ACPI events
- * @acpi_gpio:      ACPI GPIO chip
- *
- * ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
- * handled by ACPI event methods which need to be called from the GPIO
- * chip's interrupt handler. acpi_gpiochip_request_interrupts finds out which
- * gpio pins have acpi event methods and assigns interrupt handlers that calls
- * the acpi event methods for those pins.
- */
-static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
+static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,
+						   void *context)
 {
-	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_gpio_chip *acpi_gpio = context;
 	struct gpio_chip *chip = acpi_gpio->chip;
-	struct acpi_resource *res;
+	struct acpi_resource_gpio *agpio;
 	acpi_handle handle, evt_handle;
-	acpi_status status;
-	unsigned int pin;
-	int irq, ret;
-	char ev_name[5];
+	struct acpi_gpio_event *event;
+	irq_handler_t handler = NULL;
+	struct gpio_desc *desc;
+	unsigned long irqflags;
+	int ret, pin, irq;
 
-	if (!chip->dev || !chip->to_irq)
-		return;
+	if (ares->type != ACPI_RESOURCE_TYPE_GPIO)
+		return AE_OK;
+
+	agpio = &ares->data.gpio;
+	if (agpio->connection_type != ACPI_RESOURCE_GPIO_TYPE_INT)
+		return AE_OK;
 
 	handle = ACPI_HANDLE(chip->dev);
-	if (!handle)
-		return;
+	pin = agpio->pin_table[0];
+
+	if (pin <= 255) {
+		char ev_name[5];
+		sprintf(ev_name, "_%c%02X",
+			agpio->triggering == ACPI_EDGE_SENSITIVE ? 'E' : 'L',
+			pin);
+		if (ACPI_SUCCESS(acpi_get_handle(handle, ev_name, &evt_handle)))
+			handler = acpi_gpio_irq_handler;
+	}
+	if (!handler) {
+		if (ACPI_SUCCESS(acpi_get_handle(handle, "_EVT", &evt_handle)))
+			handler = acpi_gpio_irq_handler_evt;
+	}
+	if (!handler)
+		return AE_BAD_PARAMETER;
 
-	INIT_LIST_HEAD(&acpi_gpio->events);
+	desc = gpiochip_get_desc(chip, pin);
+	if (IS_ERR(desc)) {
+		dev_err(chip->dev, "Failed to get GPIO descriptor\n");
+		return AE_ERROR;
+	}
 
-	/*
-	 * If a GPIO interrupt has an ACPI event handler method, or _EVT is
-	 * present, set up an interrupt handler that calls the ACPI event
-	 * handler.
-	 */
-	for (res = buf.pointer;
-	     res && (res->type != ACPI_RESOURCE_TYPE_END_TAG);
-	     res = ACPI_NEXT_RESOURCE(res)) {
-		irq_handler_t handler = NULL;
-		void *data;
-
-		if (res->type != ACPI_RESOURCE_TYPE_GPIO ||
-		    res->data.gpio.connection_type !=
-		    ACPI_RESOURCE_GPIO_TYPE_INT)
-			continue;
+	ret = gpiochip_request_own_desc(desc, "ACPI:Event");
+	if (ret) {
+		dev_err(chip->dev, "Failed to request GPIO\n");
+		return AE_ERROR;
+	}
 
-		pin = res->data.gpio.pin_table[0];
-		if (pin > chip->ngpio)
-			continue;
+	gpiod_direction_input(desc);
 
-		irq = chip->to_irq(chip, pin);
-		if (irq < 0)
-			continue;
+	ret = gpiod_lock_as_irq(desc);
+	if (ret) {
+		dev_err(chip->dev, "Failed to lock GPIO as interrupt\n");
+		goto fail_free_desc;
+	}
 
-		if (pin <= 255) {
-			acpi_handle ev_handle;
+	irq = gpiod_to_irq(desc);
+	if (irq < 0) {
+		dev_err(chip->dev, "Failed to translate GPIO to IRQ\n");
+		goto fail_unlock_irq;
+	}
 
-			sprintf(ev_name, "_%c%02X",
-				res->data.gpio.triggering ? 'E' : 'L', pin);
-			status = acpi_get_handle(handle, ev_name, &ev_handle);
-			if (ACPI_SUCCESS(status)) {
-				handler = acpi_gpio_irq_handler;
-				data = ev_handle;
-			}
+	irqflags = IRQF_ONESHOT;
+	if (agpio->triggering == ACPI_LEVEL_SENSITIVE) {
+		if (agpio->polarity == ACPI_ACTIVE_HIGH)
+			irqflags |= IRQF_TRIGGER_HIGH;
+		else
+			irqflags |= IRQF_TRIGGER_LOW;
+	} else {
+		switch (agpio->polarity) {
+		case ACPI_ACTIVE_HIGH:
+			irqflags |= IRQF_TRIGGER_RISING;
+			break;
+		case ACPI_ACTIVE_LOW:
+			irqflags |= IRQF_TRIGGER_FALLING;
+			break;
+		default:
+			irqflags |= IRQF_TRIGGER_RISING |
+				    IRQF_TRIGGER_FALLING;
+			break;
 		}
-		if (!handler) {
-			struct acpi_gpio_event *event;
-
-			status = acpi_get_handle(handle, "_EVT", &evt_handle);
-			if (ACPI_FAILURE(status))
-				continue
+	}
 
-			event = kzalloc(sizeof(*event), GFP_KERNEL);
-			if (!event)
-				continue;
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event)
+		goto fail_unlock_irq;
 
-			list_add_tail(&event->node, &acpi_gpio->events);
-			event->handle = evt_handle;
-			event->pin = pin;
-			event->irq = irq;
-			handler = acpi_gpio_irq_handler_evt;
-			data = event;
-		}
-		if (!handler)
-			continue;
+	event->handle = evt_handle;
+	event->irq = irq;
+	event->pin = pin;
 
-		/* Assume BIOS sets the triggering, so no flags */
-		ret = devm_request_threaded_irq(chip->dev, irq, NULL, handler,
-						0, "GPIO-signaled-ACPI-event",
-						data);
-		if (ret)
-			dev_err(chip->dev,
-				"Failed to request IRQ %d ACPI event handler\n",
-				irq);
+	ret = request_threaded_irq(event->irq, NULL, handler, irqflags,
+				   "ACPI:Event", event);
+	if (ret) {
+		dev_err(chip->dev, "Failed to setup interrupt handler for %d\n",
+			event->irq);
+		goto fail_free_event;
 	}
+
+	list_add_tail(&event->node, &acpi_gpio->events);
+	return AE_OK;
+
+fail_free_event:
+	kfree(event);
+fail_unlock_irq:
+	gpiod_unlock_as_irq(desc);
+fail_free_desc:
+	gpiochip_free_own_desc(desc);
+
+	return AE_ERROR;
 }
 
 /**
- * acpi_gpiochip_free_interrupts() - Free GPIO _EVT ACPI event interrupts.
+ * acpi_gpiochip_request_interrupts() - Register isr for gpio chip ACPI events
  * @acpi_gpio:      ACPI GPIO chip
  *
- * Free interrupts associated with the _EVT method for the given GPIO chip.
+ * ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
+ * handled by ACPI event methods which need to be called from the GPIO
+ * chip's interrupt handler. acpi_gpiochip_request_interrupts finds out which
+ * gpio pins have acpi event methods and assigns interrupt handlers that calls
+ * the acpi event methods for those pins.
+ */
+static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
+{
+	struct gpio_chip *chip = acpi_gpio->chip;
+
+	if (!chip->dev || !chip->to_irq)
+		return;
+
+	INIT_LIST_HEAD(&acpi_gpio->events);
+	acpi_walk_resources(ACPI_HANDLE(chip->dev), "_AEI",
+			    acpi_gpiochip_request_interrupt, acpi_gpio);
+}
+
+/**
+ * acpi_gpiochip_free_interrupts() - Free GPIO ACPI event interrupts.
+ * @acpi_gpio:      ACPI GPIO chip
  *
- * The remaining ACPI event interrupts associated with the chip are freed
- * automatically.
+ * Free interrupts associated with GPIO ACPI event method for the given
+ * GPIO chip.
  */
 static void acpi_gpiochip_free_interrupts(struct acpi_gpio_chip *acpi_gpio)
 {
@@ -206,7 +243,14 @@ static void acpi_gpiochip_free_interrupts(struct acpi_gpio_chip *acpi_gpio)
 		return;
 
 	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
-		devm_free_irq(chip->dev, event->irq, event);
+		struct gpio_desc *desc;
+
+		free_irq(event->irq, event);
+		desc = gpiochip_get_desc(chip, event->pin);
+		if (WARN_ON(IS_ERR(desc)))
+			continue;
+		gpiod_unlock_as_irq(desc);
+		gpiochip_free_own_desc(desc);
 		list_del(&event->node);
 		kfree(event);
 	}

commit 4b01a14bac73352a9c7d7850ea4111fcb0c0a5bf
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Mar 10 14:54:52 2014 +0200

    gpio / ACPI: Rename acpi_gpio_evt_pin to acpi_gpio_event
    
    In order to consolidate _Exx, _Lxx and _EVT to use the same structure make
    the structure name to reflect that we are dealing with any event, not just
    _EVT.
    
    This is just rename, no functional changes.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 5c0cf1d76c8b..be09e7526890 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -19,16 +19,16 @@
 
 #include "gpiolib.h"
 
-struct acpi_gpio_evt_pin {
+struct acpi_gpio_event {
 	struct list_head node;
-	acpi_handle *evt_handle;
+	acpi_handle handle;
 	unsigned int pin;
 	unsigned int irq;
 };
 
 struct acpi_gpio_chip {
 	struct gpio_chip *chip;
-	struct list_head evt_pins;
+	struct list_head events;
 };
 
 static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
@@ -79,9 +79,9 @@ static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 
 static irqreturn_t acpi_gpio_irq_handler_evt(int irq, void *data)
 {
-	struct acpi_gpio_evt_pin *evt_pin = data;
+	struct acpi_gpio_event *event = data;
 
-	acpi_execute_simple_method(evt_pin->evt_handle, NULL, evt_pin->pin);
+	acpi_execute_simple_method(event->handle, NULL, event->pin);
 
 	return IRQ_HANDLED;
 }
@@ -119,7 +119,7 @@ static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
 	if (!handle)
 		return;
 
-	INIT_LIST_HEAD(&acpi_gpio->evt_pins);
+	INIT_LIST_HEAD(&acpi_gpio->events);
 
 	/*
 	 * If a GPIO interrupt has an ACPI event handler method, or _EVT is
@@ -157,22 +157,22 @@ static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
 			}
 		}
 		if (!handler) {
-			struct acpi_gpio_evt_pin *evt_pin;
+			struct acpi_gpio_event *event;
 
 			status = acpi_get_handle(handle, "_EVT", &evt_handle);
 			if (ACPI_FAILURE(status))
 				continue
 
-			evt_pin = kzalloc(sizeof(*evt_pin), GFP_KERNEL);
-			if (!evt_pin)
+			event = kzalloc(sizeof(*event), GFP_KERNEL);
+			if (!event)
 				continue;
 
-			list_add_tail(&evt_pin->node, &acpi_gpio->evt_pins);
-			evt_pin->evt_handle = evt_handle;
-			evt_pin->pin = pin;
-			evt_pin->irq = irq;
+			list_add_tail(&event->node, &acpi_gpio->events);
+			event->handle = evt_handle;
+			event->pin = pin;
+			event->irq = irq;
 			handler = acpi_gpio_irq_handler_evt;
-			data = evt_pin;
+			data = event;
 		}
 		if (!handler)
 			continue;
@@ -199,17 +199,16 @@ static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
  */
 static void acpi_gpiochip_free_interrupts(struct acpi_gpio_chip *acpi_gpio)
 {
-	struct acpi_gpio_evt_pin *evt_pin, *ep;
+	struct acpi_gpio_event *event, *ep;
 	struct gpio_chip *chip = acpi_gpio->chip;
 
 	if (!chip->dev || !chip->to_irq)
 		return;
 
-	list_for_each_entry_safe_reverse(evt_pin, ep, &acpi_gpio->evt_pins,
-					 node) {
-		devm_free_irq(chip->dev, evt_pin->irq, evt_pin);
-		list_del(&evt_pin->node);
-		kfree(evt_pin);
+	list_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {
+		devm_free_irq(chip->dev, event->irq, event);
+		list_del(&event->node);
+		kfree(event);
 	}
 }
 

commit aa92b6f689acf159120ce0753f36100c3b190b4d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Mar 10 14:54:51 2014 +0200

    gpio / ACPI: Allocate ACPI specific data directly in acpi_gpiochip_add()
    
    We are going to add more ACPI specific data to accompany GPIO chip so
    instead of allocating it per each use-case we allocate it once when
    acpi_gpiochip_add() is called and release it when acpi_gpiochip_remove() is
    called.
    
    Doing this allows us to add more ACPI specific data by merely adding new
    fields to struct acpi_gpio_chip.
    
    In addition we embed evt_pins member directly to the structure instead of
    having it as a pointer. This simplifies the code a bit since we don't need
    to check against NULL.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index b7db098ba060..5c0cf1d76c8b 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -26,6 +26,11 @@ struct acpi_gpio_evt_pin {
 	unsigned int irq;
 };
 
+struct acpi_gpio_chip {
+	struct gpio_chip *chip;
+	struct list_head evt_pins;
+};
+
 static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 {
 	if (!gc->dev)
@@ -81,14 +86,14 @@ static irqreturn_t acpi_gpio_irq_handler_evt(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static void acpi_gpio_evt_dh(acpi_handle handle, void *data)
+static void acpi_gpio_chip_dh(acpi_handle handle, void *data)
 {
 	/* The address of this function is used as a key. */
 }
 
 /**
  * acpi_gpiochip_request_interrupts() - Register isr for gpio chip ACPI events
- * @chip:      gpio chip
+ * @acpi_gpio:      ACPI GPIO chip
  *
  * ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
  * handled by ACPI event methods which need to be called from the GPIO
@@ -96,12 +101,12 @@ static void acpi_gpio_evt_dh(acpi_handle handle, void *data)
  * gpio pins have acpi event methods and assigns interrupt handlers that calls
  * the acpi event methods for those pins.
  */
-static void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
+static void acpi_gpiochip_request_interrupts(struct acpi_gpio_chip *acpi_gpio)
 {
 	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct gpio_chip *chip = acpi_gpio->chip;
 	struct acpi_resource *res;
 	acpi_handle handle, evt_handle;
-	struct list_head *evt_pins = NULL;
 	acpi_status status;
 	unsigned int pin;
 	int irq, ret;
@@ -114,23 +119,7 @@ static void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	if (!handle)
 		return;
 
-	status = acpi_get_event_resources(handle, &buf);
-	if (ACPI_FAILURE(status))
-		return;
-
-	status = acpi_get_handle(handle, "_EVT", &evt_handle);
-	if (ACPI_SUCCESS(status)) {
-		evt_pins = kzalloc(sizeof(*evt_pins), GFP_KERNEL);
-		if (evt_pins) {
-			INIT_LIST_HEAD(evt_pins);
-			status = acpi_attach_data(handle, acpi_gpio_evt_dh,
-						  evt_pins);
-			if (ACPI_FAILURE(status)) {
-				kfree(evt_pins);
-				evt_pins = NULL;
-			}
-		}
-	}
+	INIT_LIST_HEAD(&acpi_gpio->evt_pins);
 
 	/*
 	 * If a GPIO interrupt has an ACPI event handler method, or _EVT is
@@ -167,14 +156,18 @@ static void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 				data = ev_handle;
 			}
 		}
-		if (!handler && evt_pins) {
+		if (!handler) {
 			struct acpi_gpio_evt_pin *evt_pin;
 
+			status = acpi_get_handle(handle, "_EVT", &evt_handle);
+			if (ACPI_FAILURE(status))
+				continue
+
 			evt_pin = kzalloc(sizeof(*evt_pin), GFP_KERNEL);
 			if (!evt_pin)
 				continue;
 
-			list_add_tail(&evt_pin->node, evt_pins);
+			list_add_tail(&evt_pin->node, &acpi_gpio->evt_pins);
 			evt_pin->evt_handle = evt_handle;
 			evt_pin->pin = pin;
 			evt_pin->irq = irq;
@@ -197,39 +190,27 @@ static void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 
 /**
  * acpi_gpiochip_free_interrupts() - Free GPIO _EVT ACPI event interrupts.
- * @chip:      gpio chip
+ * @acpi_gpio:      ACPI GPIO chip
  *
  * Free interrupts associated with the _EVT method for the given GPIO chip.
  *
  * The remaining ACPI event interrupts associated with the chip are freed
  * automatically.
  */
-static void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
+static void acpi_gpiochip_free_interrupts(struct acpi_gpio_chip *acpi_gpio)
 {
-	acpi_handle handle;
-	acpi_status status;
-	struct list_head *evt_pins;
 	struct acpi_gpio_evt_pin *evt_pin, *ep;
+	struct gpio_chip *chip = acpi_gpio->chip;
 
 	if (!chip->dev || !chip->to_irq)
 		return;
 
-	handle = ACPI_HANDLE(chip->dev);
-	if (!handle)
-		return;
-
-	status = acpi_get_data(handle, acpi_gpio_evt_dh, (void **)&evt_pins);
-	if (ACPI_FAILURE(status))
-		return;
-
-	list_for_each_entry_safe_reverse(evt_pin, ep, evt_pins, node) {
+	list_for_each_entry_safe_reverse(evt_pin, ep, &acpi_gpio->evt_pins,
+					 node) {
 		devm_free_irq(chip->dev, evt_pin->irq, evt_pin);
 		list_del(&evt_pin->node);
 		kfree(evt_pin);
 	}
-
-	acpi_detach_data(handle, acpi_gpio_evt_dh);
-	kfree(evt_pins);
 }
 
 struct acpi_gpio_lookup {
@@ -312,10 +293,51 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
 
 void acpi_gpiochip_add(struct gpio_chip *chip)
 {
-	acpi_gpiochip_request_interrupts(chip);
+	struct acpi_gpio_chip *acpi_gpio;
+	acpi_handle handle;
+	acpi_status status;
+
+	handle = ACPI_HANDLE(chip->dev);
+	if (!handle)
+		return;
+
+	acpi_gpio = kzalloc(sizeof(*acpi_gpio), GFP_KERNEL);
+	if (!acpi_gpio) {
+		dev_err(chip->dev,
+			"Failed to allocate memory for ACPI GPIO chip\n");
+		return;
+	}
+
+	acpi_gpio->chip = chip;
+
+	status = acpi_attach_data(handle, acpi_gpio_chip_dh, acpi_gpio);
+	if (ACPI_FAILURE(status)) {
+		dev_err(chip->dev, "Failed to attach ACPI GPIO chip\n");
+		kfree(acpi_gpio);
+		return;
+	}
+
+	acpi_gpiochip_request_interrupts(acpi_gpio);
 }
 
 void acpi_gpiochip_remove(struct gpio_chip *chip)
 {
-	acpi_gpiochip_free_interrupts(chip);
+	struct acpi_gpio_chip *acpi_gpio;
+	acpi_handle handle;
+	acpi_status status;
+
+	handle = ACPI_HANDLE(chip->dev);
+	if (!handle)
+		return;
+
+	status = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);
+	if (ACPI_FAILURE(status)) {
+		dev_warn(chip->dev, "Failed to retrieve ACPI GPIO chip\n");
+		return;
+	}
+
+	acpi_gpiochip_free_interrupts(acpi_gpio);
+
+	acpi_detach_data(handle, acpi_gpio_chip_dh);
+	kfree(acpi_gpio);
 }

commit 390d82e312c56b75407a3606cbcde8c4bc7f10ae
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Sun Feb 9 17:43:55 2014 +0900

    gpiolib: ACPI: remove gpio_to_desc() usage
    
    gpio_to_desc() must die. Replace one of its usage by the
    newly-introduced gpiochip_get_desc() function.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 716ee9843110..b7db098ba060 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -60,7 +60,7 @@ static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 	if (pin < 0 || pin > chip->ngpio)
 		return ERR_PTR(-EINVAL);
 
-	return gpio_to_desc(chip->base + pin);
+	return gpiochip_get_desc(chip, pin);
 }
 
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)

commit 5ccff85276addfdaad0046390bc5624f7e44e614
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Jan 8 12:40:56 2014 +0200

    gpio / ACPI: get rid of acpi_gpio.h
    
    Now that all users of acpi_gpio.h have been moved to use either the GPIO
    descriptor interface or to the internal gpiolib.h we can get rid of
    acpi_gpio.h entirely.
    
    Once this is done the only interface to get GPIOs to drivers enumerated
    from ACPI namespace is the descriptor based interface.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 739b72b6731a..716ee9843110 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -12,11 +12,13 @@
 
 #include <linux/errno.h>
 #include <linux/gpio/consumer.h>
+#include <linux/gpio/driver.h>
 #include <linux/export.h>
-#include <linux/acpi_gpio.h>
 #include <linux/acpi.h>
 #include <linux/interrupt.h>
 
+#include "gpiolib.h"
+
 struct acpi_gpio_evt_pin {
 	struct list_head node;
 	acpi_handle *evt_handle;
@@ -307,7 +309,6 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
 
 	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
 }
-EXPORT_SYMBOL_GPL(acpi_get_gpiod_by_index);
 
 void acpi_gpiochip_add(struct gpio_chip *chip)
 {

commit 664e3e5ac64c8a1999e2d94bc307e5bcd17d3646
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Jan 8 12:40:54 2014 +0200

    gpio / ACPI: register to ACPI events automatically
    
    Instead of asking each driver to register to ACPI events we can just call
    acpi_gpiochip_register_interrupts() for each chip that has an ACPI handle.
    The function checks chip->to_irq and if it is set to NULL (a GPIO driver
    that doesn't do interrupts) the function does nothing.
    
    We also add the a new header drivers/gpio/gpiolib.h that is used for
    functions internal to gpiolib and add ACPI GPIO chip registering functions
    to that header.
    
    Once that is done we can remove call to acpi_gpiochip_register_interrupts()
    from its only user, pinctrl-baytrail.c
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 137d20c70afe..739b72b6731a 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -94,7 +94,7 @@ static void acpi_gpio_evt_dh(acpi_handle handle, void *data)
  * gpio pins have acpi event methods and assigns interrupt handlers that calls
  * the acpi event methods for those pins.
  */
-void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
+static void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 {
 	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
 	struct acpi_resource *res;
@@ -192,7 +192,6 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 				irq);
 	}
 }
-EXPORT_SYMBOL(acpi_gpiochip_request_interrupts);
 
 /**
  * acpi_gpiochip_free_interrupts() - Free GPIO _EVT ACPI event interrupts.
@@ -203,7 +202,7 @@ EXPORT_SYMBOL(acpi_gpiochip_request_interrupts);
  * The remaining ACPI event interrupts associated with the chip are freed
  * automatically.
  */
-void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
+static void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 {
 	acpi_handle handle;
 	acpi_status status;
@@ -230,7 +229,6 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
 	acpi_detach_data(handle, acpi_gpio_evt_dh);
 	kfree(evt_pins);
 }
-EXPORT_SYMBOL(acpi_gpiochip_free_interrupts);
 
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
@@ -310,3 +308,13 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
 	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
 }
 EXPORT_SYMBOL_GPL(acpi_get_gpiod_by_index);
+
+void acpi_gpiochip_add(struct gpio_chip *chip)
+{
+	acpi_gpiochip_request_interrupts(chip);
+}
+
+void acpi_gpiochip_remove(struct gpio_chip *chip)
+{
+	acpi_gpiochip_free_interrupts(chip);
+}

commit a00580c2809f44fd1d284bf2638395a261d28cc9
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Dec 10 12:00:27 2013 +0200

    gpio / ACPI: return -ENOENT when no mapping exists
    
    Doing this allows drivers to distinguish between a real error case (if
    there was an error when we tried to resolve the GPIO) and when the optional
    GPIO line was not available.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index ae0ffdce8bd5..137d20c70afe 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -307,6 +307,6 @@ struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
 	if (lookup.desc && info)
 		*info = lookup.info;
 
-	return lookup.desc ? lookup.desc : ERR_PTR(-ENODEV);
+	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
 }
 EXPORT_SYMBOL_GPL(acpi_get_gpiod_by_index);

commit e01f440a689aeb2d0e81c696fe2069f8d01d5d49
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Oct 10 11:01:10 2013 +0300

    gpiolib / ACPI: allow passing GPIOF_ACTIVE_LOW for GpioInt resources
    
    The ACPI GpioInt resources contain polarity field that is used to specify
    whether the interrupt is active high or low. Since gpiolib supports
    GPIOF_ACTIVE_LOW we can pass this information in the flags field in
    acpi_find_gpio(), analogous to the DeviceTree version.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 03187d0a3045..ae0ffdce8bd5 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -253,6 +253,8 @@ static int acpi_find_gpio(struct acpi_resource *ares, void *data)
 					      agpio->pin_table[0]);
 		lookup->info.gpioint =
 			agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;
+		lookup->info.active_low =
+			agpio->polarity == ACPI_ACTIVE_LOW;
 	}
 
 	return 1;

commit 936e15dd2128eb5aa71251766f1176552b45f43c
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Oct 10 11:01:08 2013 +0300

    gpiolib / ACPI: convert to gpiod interfaces
    
    The new GPIO descriptor based interface is now preferred over the old
    integer based one. This patch converts the ACPI GPIO helpers to use this
    new interface internally. In addition to that provide compatibility
    function acpi_get_gpio_by_index() that converts the returned GPIO
    descriptor to an integer.
    
    We also drop acpi_get_gpio() as it is not used anywhere outside
    gpiolib-acpi and even there we use acpi_get_gpiod() instead.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 1745ce5983d6..03187d0a3045 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -11,7 +11,7 @@
  */
 
 #include <linux/errno.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/export.h>
 #include <linux/acpi_gpio.h>
 #include <linux/acpi.h>
@@ -33,14 +33,15 @@ static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 }
 
 /**
- * acpi_get_gpio() - Translate ACPI GPIO pin to GPIO number usable with GPIO API
+ * acpi_get_gpiod() - Translate ACPI GPIO pin to GPIO descriptor usable with GPIO API
  * @path:	ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
  * @pin:	ACPI GPIO pin number (0-based, controller-relative)
  *
- * Returns GPIO number to use with Linux generic GPIO API, or errno error value
+ * Returns GPIO descriptor to use with Linux generic GPIO API, or ERR_PTR
+ * error value
  */
 
-int acpi_get_gpio(char *path, int pin)
+static struct gpio_desc *acpi_get_gpiod(char *path, int pin)
 {
 	struct gpio_chip *chip;
 	acpi_handle handle;
@@ -48,18 +49,17 @@ int acpi_get_gpio(char *path, int pin)
 
 	status = acpi_get_handle(NULL, path, &handle);
 	if (ACPI_FAILURE(status))
-		return -ENODEV;
+		return ERR_PTR(-ENODEV);
 
 	chip = gpiochip_find(handle, acpi_gpiochip_find);
 	if (!chip)
-		return -ENODEV;
+		return ERR_PTR(-ENODEV);
 
-	if (!gpio_is_valid(chip->base + pin))
-		return -EINVAL;
+	if (pin < 0 || pin > chip->ngpio)
+		return ERR_PTR(-EINVAL);
 
-	return chip->base + pin;
+	return gpio_to_desc(chip->base + pin);
 }
-EXPORT_SYMBOL_GPL(acpi_get_gpio);
 
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 {
@@ -235,7 +235,7 @@ EXPORT_SYMBOL(acpi_gpiochip_free_interrupts);
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
-	int gpio;
+	struct gpio_desc *desc;
 	int n;
 };
 
@@ -246,11 +246,11 @@ static int acpi_find_gpio(struct acpi_resource *ares, void *data)
 	if (ares->type != ACPI_RESOURCE_TYPE_GPIO)
 		return 1;
 
-	if (lookup->n++ == lookup->index && lookup->gpio < 0) {
+	if (lookup->n++ == lookup->index && !lookup->desc) {
 		const struct acpi_resource_gpio *agpio = &ares->data.gpio;
 
-		lookup->gpio = acpi_get_gpio(agpio->resource_source.string_ptr,
-					     agpio->pin_table[0]);
+		lookup->desc = acpi_get_gpiod(agpio->resource_source.string_ptr,
+					      agpio->pin_table[0]);
 		lookup->info.gpioint =
 			agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;
 	}
@@ -259,24 +259,24 @@ static int acpi_find_gpio(struct acpi_resource *ares, void *data)
 }
 
 /**
- * acpi_get_gpio_by_index() - get a GPIO number from device resources
+ * acpi_get_gpiod_by_index() - get a GPIO descriptor from device resources
  * @dev: pointer to a device to get GPIO from
  * @index: index of GpioIo/GpioInt resource (starting from %0)
  * @info: info pointer to fill in (optional)
  *
  * Function goes through ACPI resources for @dev and based on @index looks
- * up a GpioIo/GpioInt resource, translates it to the Linux GPIO number,
+ * up a GpioIo/GpioInt resource, translates it to the Linux GPIO descriptor,
  * and returns it. @index matches GpioIo/GpioInt resources only so if there
  * are total %3 GPIO resources, the index goes from %0 to %2.
  *
- * If the GPIO cannot be translated or there is an error, negative errno is
+ * If the GPIO cannot be translated or there is an error an ERR_PTR is
  * returned.
  *
  * Note: if the GPIO resource has multiple entries in the pin list, this
  * function only returns the first.
  */
-int acpi_get_gpio_by_index(struct device *dev, int index,
-			   struct acpi_gpio_info *info)
+struct gpio_desc *acpi_get_gpiod_by_index(struct device *dev, int index,
+					  struct acpi_gpio_info *info)
 {
 	struct acpi_gpio_lookup lookup;
 	struct list_head resource_list;
@@ -285,27 +285,26 @@ int acpi_get_gpio_by_index(struct device *dev, int index,
 	int ret;
 
 	if (!dev)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 
 	handle = ACPI_HANDLE(dev);
 	if (!handle || acpi_bus_get_device(handle, &adev))
-		return -ENODEV;
+		return ERR_PTR(-ENODEV);
 
 	memset(&lookup, 0, sizeof(lookup));
 	lookup.index = index;
-	lookup.gpio = -ENODEV;
 
 	INIT_LIST_HEAD(&resource_list);
 	ret = acpi_dev_get_resources(adev, &resource_list, acpi_find_gpio,
 				     &lookup);
 	if (ret < 0)
-		return ret;
+		return ERR_PTR(ret);
 
 	acpi_dev_free_resource_list(&resource_list);
 
-	if (lookup.gpio >= 0 && info)
+	if (lookup.desc && info)
 		*info = lookup.info;
 
-	return lookup.gpio;
+	return lookup.desc ? lookup.desc : ERR_PTR(-ENODEV);
 }
-EXPORT_SYMBOL_GPL(acpi_get_gpio_by_index);
+EXPORT_SYMBOL_GPL(acpi_get_gpiod_by_index);

commit 70b5341138dcb931df318afb51e8fb5310f9f095
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Oct 10 11:01:07 2013 +0300

    gpiolib / ACPI: move acpi_gpiochip_free_interrupts next to the request function
    
    It makes more sense to have these functions close to each other. No
    functional changes.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index f2beb728ed8f..1745ce5983d6 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -194,6 +194,44 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 }
 EXPORT_SYMBOL(acpi_gpiochip_request_interrupts);
 
+/**
+ * acpi_gpiochip_free_interrupts() - Free GPIO _EVT ACPI event interrupts.
+ * @chip:      gpio chip
+ *
+ * Free interrupts associated with the _EVT method for the given GPIO chip.
+ *
+ * The remaining ACPI event interrupts associated with the chip are freed
+ * automatically.
+ */
+void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
+{
+	acpi_handle handle;
+	acpi_status status;
+	struct list_head *evt_pins;
+	struct acpi_gpio_evt_pin *evt_pin, *ep;
+
+	if (!chip->dev || !chip->to_irq)
+		return;
+
+	handle = ACPI_HANDLE(chip->dev);
+	if (!handle)
+		return;
+
+	status = acpi_get_data(handle, acpi_gpio_evt_dh, (void **)&evt_pins);
+	if (ACPI_FAILURE(status))
+		return;
+
+	list_for_each_entry_safe_reverse(evt_pin, ep, evt_pins, node) {
+		devm_free_irq(chip->dev, evt_pin->irq, evt_pin);
+		list_del(&evt_pin->node);
+		kfree(evt_pin);
+	}
+
+	acpi_detach_data(handle, acpi_gpio_evt_dh);
+	kfree(evt_pins);
+}
+EXPORT_SYMBOL(acpi_gpiochip_free_interrupts);
+
 struct acpi_gpio_lookup {
 	struct acpi_gpio_info info;
 	int index;
@@ -271,41 +309,3 @@ int acpi_get_gpio_by_index(struct device *dev, int index,
 	return lookup.gpio;
 }
 EXPORT_SYMBOL_GPL(acpi_get_gpio_by_index);
-
-/**
- * acpi_gpiochip_free_interrupts() - Free GPIO _EVT ACPI event interrupts.
- * @chip:      gpio chip
- *
- * Free interrupts associated with the _EVT method for the given GPIO chip.
- *
- * The remaining ACPI event interrupts associated with the chip are freed
- * automatically.
- */
-void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
-{
-	acpi_handle handle;
-	acpi_status status;
-	struct list_head *evt_pins;
-	struct acpi_gpio_evt_pin *evt_pin, *ep;
-
-	if (!chip->dev || !chip->to_irq)
-		return;
-
-	handle = ACPI_HANDLE(chip->dev);
-	if (!handle)
-		return;
-
-	status = acpi_get_data(handle, acpi_gpio_evt_dh, (void **)&evt_pins);
-	if (ACPI_FAILURE(status))
-		return;
-
-	list_for_each_entry_safe_reverse(evt_pin, ep, evt_pins, node) {
-		devm_free_irq(chip->dev, evt_pin->irq, evt_pin);
-		list_del(&evt_pin->node);
-		kfree(evt_pin);
-	}
-
-	acpi_detach_data(handle, acpi_gpio_evt_dh);
-	kfree(evt_pins);
-}
-EXPORT_SYMBOL(acpi_gpiochip_free_interrupts);

commit 524c10818c32ed343d5d8af49c04589ab21e64d4
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Sep 3 08:31:50 2013 +0800

    gpiolib-acpi: convert acpi_evaluate_object() to acpi_execute_simple_method()
    
    acpi_execute_simple_method() is a new ACPI API introduced to invoke
    an ACPI control method that has single integer parameter and no return value.
    
    Convert acpi_evaluate_object() to acpi_execute_simple_method()
    in drivers/gpio/gpiolib-acpi.c
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 5c1ef2b3ef18..f2beb728ed8f 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -73,15 +73,8 @@ static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 static irqreturn_t acpi_gpio_irq_handler_evt(int irq, void *data)
 {
 	struct acpi_gpio_evt_pin *evt_pin = data;
-	struct acpi_object_list args;
-	union acpi_object arg;
 
-	arg.type = ACPI_TYPE_INTEGER;
-	arg.integer.value = evt_pin->pin;
-	args.count = 1;
-	args.pointer = &arg;
-
-	acpi_evaluate_object(evt_pin->evt_handle, NULL, &args, NULL);
+	acpi_execute_simple_method(evt_pin->evt_handle, NULL, evt_pin->pin);
 
 	return IRQ_HANDLED;
 }

commit 12028d2d216220618f76284af5f8ed510b11da55
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Apr 3 13:56:54 2013 +0300

    gpiolib-acpi: introduce acpi_get_gpio_by_index() helper
    
    Instead of open-coding ACPI GPIO resource lookup in each driver, we provide
    a helper function analogous to Device Tree version that allows drivers to
    specify which GPIO resource they are interested (using an index to the GPIO
    resources). The function then finds out the correct resource, translates
    the ACPI GPIO number to the corresponding Linux GPIO number and returns
    that.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 89336c4f82cd..5c1ef2b3ef18 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -201,6 +201,83 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 }
 EXPORT_SYMBOL(acpi_gpiochip_request_interrupts);
 
+struct acpi_gpio_lookup {
+	struct acpi_gpio_info info;
+	int index;
+	int gpio;
+	int n;
+};
+
+static int acpi_find_gpio(struct acpi_resource *ares, void *data)
+{
+	struct acpi_gpio_lookup *lookup = data;
+
+	if (ares->type != ACPI_RESOURCE_TYPE_GPIO)
+		return 1;
+
+	if (lookup->n++ == lookup->index && lookup->gpio < 0) {
+		const struct acpi_resource_gpio *agpio = &ares->data.gpio;
+
+		lookup->gpio = acpi_get_gpio(agpio->resource_source.string_ptr,
+					     agpio->pin_table[0]);
+		lookup->info.gpioint =
+			agpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;
+	}
+
+	return 1;
+}
+
+/**
+ * acpi_get_gpio_by_index() - get a GPIO number from device resources
+ * @dev: pointer to a device to get GPIO from
+ * @index: index of GpioIo/GpioInt resource (starting from %0)
+ * @info: info pointer to fill in (optional)
+ *
+ * Function goes through ACPI resources for @dev and based on @index looks
+ * up a GpioIo/GpioInt resource, translates it to the Linux GPIO number,
+ * and returns it. @index matches GpioIo/GpioInt resources only so if there
+ * are total %3 GPIO resources, the index goes from %0 to %2.
+ *
+ * If the GPIO cannot be translated or there is an error, negative errno is
+ * returned.
+ *
+ * Note: if the GPIO resource has multiple entries in the pin list, this
+ * function only returns the first.
+ */
+int acpi_get_gpio_by_index(struct device *dev, int index,
+			   struct acpi_gpio_info *info)
+{
+	struct acpi_gpio_lookup lookup;
+	struct list_head resource_list;
+	struct acpi_device *adev;
+	acpi_handle handle;
+	int ret;
+
+	if (!dev)
+		return -EINVAL;
+
+	handle = ACPI_HANDLE(dev);
+	if (!handle || acpi_bus_get_device(handle, &adev))
+		return -ENODEV;
+
+	memset(&lookup, 0, sizeof(lookup));
+	lookup.index = index;
+	lookup.gpio = -ENODEV;
+
+	INIT_LIST_HEAD(&resource_list);
+	ret = acpi_dev_get_resources(adev, &resource_list, acpi_find_gpio,
+				     &lookup);
+	if (ret < 0)
+		return ret;
+
+	acpi_dev_free_resource_list(&resource_list);
+
+	if (lookup.gpio >= 0 && info)
+		*info = lookup.info;
+
+	return lookup.gpio;
+}
+EXPORT_SYMBOL_GPL(acpi_get_gpio_by_index);
 
 /**
  * acpi_gpiochip_free_interrupts() - Free GPIO _EVT ACPI event interrupts.

commit 7fc7acb9a0b0ff3ffdf21818fe0735ebaf4fecb8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Apr 9 15:57:25 2013 +0200

    gpio / ACPI: Handle ACPI events in accordance with the spec
    
    Commit 0d1c28a (gpiolib-acpi: Add ACPI5 event model support to gpio.)
    that added support for ACPI events signalled through GPIO interrupts
    covered only GPIO pins whose numbers are less than or equal to 255.
    However, there may be GPIO pins with numbers greater than 255 and
    the ACPI spec (ACPI 5.0, Section 5.6.5.1) requires the _EVT method
    to be used for handling events corresponding to those pins.
    
    Moreover, according to the spec, _EVT is the default mechanism
    for handling all ACPI events signalled through GPIO interrupts,
    so if the _Exx/_Lxx method is not present for the given pin,
    _EVT should be used instead.  If present, though, _Exx/_Lxx take
    precedence over _EVT which shouldn't be executed in that case
    (ACPI 5.0, Section 5.6.5.3).
    
    Modify acpi_gpiochip_request_interrupts() to follow the spec as
    described above and add acpi_gpiochip_free_interrupts() needed
    to free interrupts associated with _EVT.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index a063eb04b6ce..89336c4f82cd 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -17,6 +17,13 @@
 #include <linux/acpi.h>
 #include <linux/interrupt.h>
 
+struct acpi_gpio_evt_pin {
+	struct list_head node;
+	acpi_handle *evt_handle;
+	unsigned int pin;
+	unsigned int irq;
+};
+
 static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 {
 	if (!gc->dev)
@@ -54,7 +61,6 @@ int acpi_get_gpio(char *path, int pin)
 }
 EXPORT_SYMBOL_GPL(acpi_get_gpio);
 
-
 static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 {
 	acpi_handle handle = data;
@@ -64,6 +70,27 @@ static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t acpi_gpio_irq_handler_evt(int irq, void *data)
+{
+	struct acpi_gpio_evt_pin *evt_pin = data;
+	struct acpi_object_list args;
+	union acpi_object arg;
+
+	arg.type = ACPI_TYPE_INTEGER;
+	arg.integer.value = evt_pin->pin;
+	args.count = 1;
+	args.pointer = &arg;
+
+	acpi_evaluate_object(evt_pin->evt_handle, NULL, &args, NULL);
+
+	return IRQ_HANDLED;
+}
+
+static void acpi_gpio_evt_dh(acpi_handle handle, void *data)
+{
+	/* The address of this function is used as a key. */
+}
+
 /**
  * acpi_gpiochip_request_interrupts() - Register isr for gpio chip ACPI events
  * @chip:      gpio chip
@@ -73,15 +100,13 @@ static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
  * chip's interrupt handler. acpi_gpiochip_request_interrupts finds out which
  * gpio pins have acpi event methods and assigns interrupt handlers that calls
  * the acpi event methods for those pins.
- *
- * Interrupts are automatically freed on driver detach
  */
-
 void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 {
 	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
 	struct acpi_resource *res;
-	acpi_handle handle, ev_handle;
+	acpi_handle handle, evt_handle;
+	struct list_head *evt_pins = NULL;
 	acpi_status status;
 	unsigned int pin;
 	int irq, ret;
@@ -98,13 +123,30 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	if (ACPI_FAILURE(status))
 		return;
 
-	/* If a gpio interrupt has an acpi event handler method, then
-	 * set up an interrupt handler that calls the acpi event handler
-	 */
+	status = acpi_get_handle(handle, "_EVT", &evt_handle);
+	if (ACPI_SUCCESS(status)) {
+		evt_pins = kzalloc(sizeof(*evt_pins), GFP_KERNEL);
+		if (evt_pins) {
+			INIT_LIST_HEAD(evt_pins);
+			status = acpi_attach_data(handle, acpi_gpio_evt_dh,
+						  evt_pins);
+			if (ACPI_FAILURE(status)) {
+				kfree(evt_pins);
+				evt_pins = NULL;
+			}
+		}
+	}
 
+	/*
+	 * If a GPIO interrupt has an ACPI event handler method, or _EVT is
+	 * present, set up an interrupt handler that calls the ACPI event
+	 * handler.
+	 */
 	for (res = buf.pointer;
 	     res && (res->type != ACPI_RESOURCE_TYPE_END_TAG);
 	     res = ACPI_NEXT_RESOURCE(res)) {
+		irq_handler_t handler = NULL;
+		void *data;
 
 		if (res->type != ACPI_RESOURCE_TYPE_GPIO ||
 		    res->data.gpio.connection_type !=
@@ -115,23 +157,42 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 		if (pin > chip->ngpio)
 			continue;
 
-		sprintf(ev_name, "_%c%02X",
-		res->data.gpio.triggering ? 'E' : 'L', pin);
-
-		status = acpi_get_handle(handle, ev_name, &ev_handle);
-		if (ACPI_FAILURE(status))
-			continue;
-
 		irq = chip->to_irq(chip, pin);
 		if (irq < 0)
 			continue;
 
+		if (pin <= 255) {
+			acpi_handle ev_handle;
+
+			sprintf(ev_name, "_%c%02X",
+				res->data.gpio.triggering ? 'E' : 'L', pin);
+			status = acpi_get_handle(handle, ev_name, &ev_handle);
+			if (ACPI_SUCCESS(status)) {
+				handler = acpi_gpio_irq_handler;
+				data = ev_handle;
+			}
+		}
+		if (!handler && evt_pins) {
+			struct acpi_gpio_evt_pin *evt_pin;
+
+			evt_pin = kzalloc(sizeof(*evt_pin), GFP_KERNEL);
+			if (!evt_pin)
+				continue;
+
+			list_add_tail(&evt_pin->node, evt_pins);
+			evt_pin->evt_handle = evt_handle;
+			evt_pin->pin = pin;
+			evt_pin->irq = irq;
+			handler = acpi_gpio_irq_handler_evt;
+			data = evt_pin;
+		}
+		if (!handler)
+			continue;
+
 		/* Assume BIOS sets the triggering, so no flags */
-		ret = devm_request_threaded_irq(chip->dev, irq, NULL,
-					  acpi_gpio_irq_handler,
-					  0,
-					  "GPIO-signaled-ACPI-event",
-					  ev_handle);
+		ret = devm_request_threaded_irq(chip->dev, irq, NULL, handler,
+						0, "GPIO-signaled-ACPI-event",
+						data);
 		if (ret)
 			dev_err(chip->dev,
 				"Failed to request IRQ %d ACPI event handler\n",
@@ -139,3 +200,42 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	}
 }
 EXPORT_SYMBOL(acpi_gpiochip_request_interrupts);
+
+
+/**
+ * acpi_gpiochip_free_interrupts() - Free GPIO _EVT ACPI event interrupts.
+ * @chip:      gpio chip
+ *
+ * Free interrupts associated with the _EVT method for the given GPIO chip.
+ *
+ * The remaining ACPI event interrupts associated with the chip are freed
+ * automatically.
+ */
+void acpi_gpiochip_free_interrupts(struct gpio_chip *chip)
+{
+	acpi_handle handle;
+	acpi_status status;
+	struct list_head *evt_pins;
+	struct acpi_gpio_evt_pin *evt_pin, *ep;
+
+	if (!chip->dev || !chip->to_irq)
+		return;
+
+	handle = ACPI_HANDLE(chip->dev);
+	if (!handle)
+		return;
+
+	status = acpi_get_data(handle, acpi_gpio_evt_dh, (void **)&evt_pins);
+	if (ACPI_FAILURE(status))
+		return;
+
+	list_for_each_entry_safe_reverse(evt_pin, ep, evt_pins, node) {
+		devm_free_irq(chip->dev, evt_pin->irq, evt_pin);
+		list_del(&evt_pin->node);
+		kfree(evt_pin);
+	}
+
+	acpi_detach_data(handle, acpi_gpio_evt_dh);
+	kfree(evt_pins);
+}
+EXPORT_SYMBOL(acpi_gpiochip_free_interrupts);

commit 1107ca104f0331627f6446bfefa2d4b0e673db18
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Feb 4 11:32:22 2013 +0200

    gpiolib-acpi: Fix error checks in interrupt requesting
    
    Print error message if requesting an interrupt fails.
    Use int instead of unsigned for interrupts in case of error values
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 54ce2269ed25..a063eb04b6ce 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -83,7 +83,8 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 	struct acpi_resource *res;
 	acpi_handle handle, ev_handle;
 	acpi_status status;
-	unsigned int pin, irq;
+	unsigned int pin;
+	int irq, ret;
 	char ev_name[5];
 
 	if (!chip->dev || !chip->to_irq)
@@ -126,11 +127,15 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
 			continue;
 
 		/* Assume BIOS sets the triggering, so no flags */
-		devm_request_threaded_irq(chip->dev, irq, NULL,
+		ret = devm_request_threaded_irq(chip->dev, irq, NULL,
 					  acpi_gpio_irq_handler,
 					  0,
 					  "GPIO-signaled-ACPI-event",
 					  ev_handle);
+		if (ret)
+			dev_err(chip->dev,
+				"Failed to request IRQ %d ACPI event handler\n",
+				irq);
 	}
 }
 EXPORT_SYMBOL(acpi_gpiochip_request_interrupts);

commit 0d1c28a449c6c23a126e3a08ee30914609aac227
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Jan 28 16:23:10 2013 +0200

    gpiolib-acpi: Add ACPI5 event model support to gpio.
    
    Add ability to handle ACPI events signalled by GPIO interrupts.
    
    ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
    handled by ACPI event methods which need to be called from the GPIO
    controller's interrupt handler. acpi_gpio_request_interrupt() finds out which
    gpio pins have acpi event methods and assigns interrupt handlers that calls
    the acpi event methods for those pins.
    
    Partially based on work by Rui Zhang <rui.zhang@intel.com>
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index cbad6e908d30..54ce2269ed25 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -15,6 +15,7 @@
 #include <linux/export.h>
 #include <linux/acpi_gpio.h>
 #include <linux/acpi.h>
+#include <linux/interrupt.h>
 
 static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
 {
@@ -52,3 +53,84 @@ int acpi_get_gpio(char *path, int pin)
 	return chip->base + pin;
 }
 EXPORT_SYMBOL_GPL(acpi_get_gpio);
+
+
+static irqreturn_t acpi_gpio_irq_handler(int irq, void *data)
+{
+	acpi_handle handle = data;
+
+	acpi_evaluate_object(handle, NULL, NULL, NULL);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * acpi_gpiochip_request_interrupts() - Register isr for gpio chip ACPI events
+ * @chip:      gpio chip
+ *
+ * ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
+ * handled by ACPI event methods which need to be called from the GPIO
+ * chip's interrupt handler. acpi_gpiochip_request_interrupts finds out which
+ * gpio pins have acpi event methods and assigns interrupt handlers that calls
+ * the acpi event methods for those pins.
+ *
+ * Interrupts are automatically freed on driver detach
+ */
+
+void acpi_gpiochip_request_interrupts(struct gpio_chip *chip)
+{
+	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_resource *res;
+	acpi_handle handle, ev_handle;
+	acpi_status status;
+	unsigned int pin, irq;
+	char ev_name[5];
+
+	if (!chip->dev || !chip->to_irq)
+		return;
+
+	handle = ACPI_HANDLE(chip->dev);
+	if (!handle)
+		return;
+
+	status = acpi_get_event_resources(handle, &buf);
+	if (ACPI_FAILURE(status))
+		return;
+
+	/* If a gpio interrupt has an acpi event handler method, then
+	 * set up an interrupt handler that calls the acpi event handler
+	 */
+
+	for (res = buf.pointer;
+	     res && (res->type != ACPI_RESOURCE_TYPE_END_TAG);
+	     res = ACPI_NEXT_RESOURCE(res)) {
+
+		if (res->type != ACPI_RESOURCE_TYPE_GPIO ||
+		    res->data.gpio.connection_type !=
+		    ACPI_RESOURCE_GPIO_TYPE_INT)
+			continue;
+
+		pin = res->data.gpio.pin_table[0];
+		if (pin > chip->ngpio)
+			continue;
+
+		sprintf(ev_name, "_%c%02X",
+		res->data.gpio.triggering ? 'E' : 'L', pin);
+
+		status = acpi_get_handle(handle, ev_name, &ev_handle);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		irq = chip->to_irq(chip, pin);
+		if (irq < 0)
+			continue;
+
+		/* Assume BIOS sets the triggering, so no flags */
+		devm_request_threaded_irq(chip->dev, irq, NULL,
+					  acpi_gpio_irq_handler,
+					  0,
+					  "GPIO-signaled-ACPI-event",
+					  ev_handle);
+	}
+}
+EXPORT_SYMBOL(acpi_gpiochip_request_interrupts);

commit e29482e8487954c87dc7b4fdbc53574bf1d4cce2
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Nov 30 12:37:36 2012 +0100

    gpio / ACPI: add ACPI support
    
    Add support for translating ACPI GPIO pin numbers to Linux GPIO API pins.
    Needs a gpio controller driver with the acpi handler hook set.
    
    Drivers can use acpi_get_gpio() to translate ACPI5 GpioIO and GpioInt
    resources to Linux GPIO's.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
new file mode 100644
index 000000000000..cbad6e908d30
--- /dev/null
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -0,0 +1,54 @@
+/*
+ * ACPI helpers for GPIO API
+ *
+ * Copyright (C) 2012, Intel Corporation
+ * Authors: Mathias Nyman <mathias.nyman@linux.intel.com>
+ *          Mika Westerberg <mika.westerberg@linux.intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/export.h>
+#include <linux/acpi_gpio.h>
+#include <linux/acpi.h>
+
+static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)
+{
+	if (!gc->dev)
+		return false;
+
+	return ACPI_HANDLE(gc->dev) == data;
+}
+
+/**
+ * acpi_get_gpio() - Translate ACPI GPIO pin to GPIO number usable with GPIO API
+ * @path:	ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
+ * @pin:	ACPI GPIO pin number (0-based, controller-relative)
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or errno error value
+ */
+
+int acpi_get_gpio(char *path, int pin)
+{
+	struct gpio_chip *chip;
+	acpi_handle handle;
+	acpi_status status;
+
+	status = acpi_get_handle(NULL, path, &handle);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	chip = gpiochip_find(handle, acpi_gpiochip_find);
+	if (!chip)
+		return -ENODEV;
+
+	if (!gpio_is_valid(chip->base + pin))
+		return -EINVAL;
+
+	return chip->base + pin;
+}
+EXPORT_SYMBOL_GPL(acpi_get_gpio);
