commit a8ff78f7f773142eb8a8befe5a95dd6858ebd635
Author: Tuowen Zhao <ztuowen@gmail.com>
Date:   Wed Oct 16 15:06:29 2019 -0600

    mfd: intel-lpss: Use devm_ioremap_uc for MMIO
    
    Some BIOS erroneously specifies write-combining BAR for intel-lpss-pci
    in MTRR. This will cause the system to hang during boot. If possible,
    this bug could be corrected with a firmware update.
    
    This patch use devm_ioremap_uc to overwrite/ignore the MTRR settings
    by forcing the use of strongly uncachable pages for intel-lpss.
    
    The BIOS bug is present on Dell XPS 13 7390 2-in-1:
    
    [    0.001734]   5 base 4000000000 mask 6000000000 write-combining
    
    4000000000-7fffffffff : PCI Bus 0000:00
      4000000000-400fffffff : 0000:00:02.0 (i915)
      4010000000-4010000fff : 0000:00:15.0 (intel-lpss-pci)
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=203485
    Cc: <stable@vger.kernel.org> # v4.19+
    Tested-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Tuowen Zhao <ztuowen@gmail.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Roman Gilg <subdiff@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index bfe4ff337581..b0f0781a6b9c 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -384,7 +384,7 @@ int intel_lpss_probe(struct device *dev,
 	if (!lpss)
 		return -ENOMEM;
 
-	lpss->priv = devm_ioremap(dev, info->mem->start + LPSS_PRIV_OFFSET,
+	lpss->priv = devm_ioremap_uc(dev, info->mem->start + LPSS_PRIV_OFFSET,
 				  LPSS_PRIV_SIZE);
 	if (!lpss->priv)
 		return -ENOMEM;

commit 569fac74627cc332a2097a7a4bfdc654b8e7f273
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Aug 21 11:37:12 2019 +0300

    mfd: intel-lpss: Use MODULE_SOFTDEP() instead of implicit request
    
    There is no need to handle optional module request in the driver
    when user space tools has that feature for ages.
    
    Replace custom code by MODULE_SOFTDEP() macro to let user space know
    that we would like to have the DMA driver loaded first, if any.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 3e16a1765142..bfe4ff337581 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -128,17 +128,6 @@ static const struct mfd_cell intel_lpss_spi_cell = {
 static DEFINE_IDA(intel_lpss_devid_ida);
 static struct dentry *intel_lpss_debugfs;
 
-static int intel_lpss_request_dma_module(const char *name)
-{
-	static bool intel_lpss_dma_requested;
-
-	if (intel_lpss_dma_requested)
-		return 0;
-
-	intel_lpss_dma_requested = true;
-	return request_module("%s", name);
-}
-
 static void intel_lpss_cache_ltr(struct intel_lpss *lpss)
 {
 	lpss->active_ltr = readl(lpss->priv + LPSS_PRIV_ACTIVELTR);
@@ -429,16 +418,6 @@ int intel_lpss_probe(struct device *dev,
 		dev_warn(dev, "Failed to create debugfs entries\n");
 
 	if (intel_lpss_has_idma(lpss)) {
-		/*
-		 * Ensure the DMA driver is loaded before the host
-		 * controller device appears, so that the host controller
-		 * driver can request its DMA channels as early as
-		 * possible.
-		 *
-		 * If the DMA module is not there that's OK as well.
-		 */
-		intel_lpss_request_dma_module(LPSS_IDMA64_DRIVER_NAME);
-
 		ret = mfd_add_devices(dev, lpss->devid, &intel_lpss_idma64_cell,
 				      1, info->mem, info->irq, NULL);
 		if (ret)
@@ -554,3 +533,11 @@ MODULE_AUTHOR("Heikki Krogerus <heikki.krogerus@linux.intel.com>");
 MODULE_AUTHOR("Jarkko Nikula <jarkko.nikula@linux.intel.com>");
 MODULE_DESCRIPTION("Intel LPSS core driver");
 MODULE_LICENSE("GPL v2");
+/*
+ * Ensure the DMA driver is loaded before the host controller device appears,
+ * so that the host controller driver can request its DMA channels as early
+ * as possible.
+ *
+ * If the DMA module is not there that's OK as well.
+ */
+MODULE_SOFTDEP("pre: platform:" LPSS_IDMA64_DRIVER_NAME);

commit cbd1c5c4d443c4a83c9c7eecc0561b9aeafddf50
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 16 20:33:42 2019 +0300

    mfd: intel-lpss: Consistently use GENMASK()
    
    Since we already are using BIT() macro, use GENMASK() as well for sake of
    consistency.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 277f48f1cc1c..3e16a1765142 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -47,10 +47,10 @@
 #define LPSS_PRIV_IDLELTR		0x14
 
 #define LPSS_PRIV_LTR_REQ		BIT(15)
-#define LPSS_PRIV_LTR_SCALE_MASK	0xc00
-#define LPSS_PRIV_LTR_SCALE_1US		0x800
-#define LPSS_PRIV_LTR_SCALE_32US	0xc00
-#define LPSS_PRIV_LTR_VALUE_MASK	0x3ff
+#define LPSS_PRIV_LTR_SCALE_MASK	GENMASK(11, 10)
+#define LPSS_PRIV_LTR_SCALE_1US		(2 << 10)
+#define LPSS_PRIV_LTR_SCALE_32US	(3 << 10)
+#define LPSS_PRIV_LTR_VALUE_MASK	GENMASK(9, 0)
 
 #define LPSS_PRIV_SSP_REG		0x20
 #define LPSS_PRIV_SSP_REG_DIS_DMA_FIN	BIT(0)
@@ -59,8 +59,8 @@
 
 #define LPSS_PRIV_CAPS			0xfc
 #define LPSS_PRIV_CAPS_NO_IDMA		BIT(8)
+#define LPSS_PRIV_CAPS_TYPE_MASK	GENMASK(7, 4)
 #define LPSS_PRIV_CAPS_TYPE_SHIFT	4
-#define LPSS_PRIV_CAPS_TYPE_MASK	(0xf << LPSS_PRIV_CAPS_TYPE_SHIFT)
 
 /* This matches the type field in CAPS register */
 enum intel_lpss_dev_type {

commit 8de262531f5fbb7458463224a7587429800c24bf
Merge: be8454afc50f 7efd105c27fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:18:40 2019 -0700

    Merge tag 'mfd-next-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd
    
    Pull MFD updates from Lee Jones:
     "Core Frameworks:
       - Set 'struct device' fwnode when registering a new device
    
      New Drivers:
       - Add support for ROHM BD70528 PMIC
    
      New Device Support:
       - Add support for LP87561 4-Phase Regulator to TI LP87565 PMIC
       - Add support for RK809 and RK817 to Rockchip RK808
       - Add support for Lid Angle to ChromeOS core
       - Add support for CS47L15 CODEC to Madera core
       - Add support for CS47L92 CODEC to Madera core
       - Add support for ChromeOS (legacy) Accelerometers in ChromeOS core
       - Add support for Add Intel Elkhart Lake PCH to Intel LPSS
    
      New Functionality:
       - Provide regulator supply information when registering; madera-core
       - Additional Device Tree support; lp87565, madera, cros-ec, rohm,bd71837-pmic
       - Allow over-riding power button press via Device Tree; rohm-bd718x7
       - Differentiate between running processors; cros_ec_dev
    
      Fix-ups:
       - Big header file update; cros_ec_commands.h
       - Split header per-subsystem; rohm-bd718x7
       - Remove superfluous code; menelaus, cs5535-mfd, cs47lXX-tables
       - Trivial; sorting, coding style; intel-lpss-pci
       - Only remove Power Off functionality if set locally; rk808
       - Make use for Power Off Prepare(); rk808
       - Fix spelling mistake in header guards; stmfx
       - Properly free IDA resources
       - SPDX fixups; cs47lXX-tables, madera
       - Error path fixups; hi655x-pmic
    
      Bug Fixes:
       - Add missing break in case() statement
       - Repair undefined behaviour when not initialising variables; arizona-core, madera-core
       - Fix reference to Device Tree documentation; madera"
    
    * tag 'mfd-next-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd: (45 commits)
      mfd: hi655x-pmic: Fix missing return value check for devm_regmap_init_mmio_clk
      mfd: madera: Fixup SPDX headers
      mfd: madera: Remove some unused registers and fix some defaults
      mfd: intel-lpss: Release IDA resources
      mfd: intel-lpss: Add Intel Elkhart Lake PCH PCI IDs
      mfd: cs5535-mfd: Remove ifdef OLPC noise
      mfd: stmfx: Fix macro definition spelling
      dt-bindings: mfd: Add link to ROHM BD71847 Datasheet
      MAINAINERS: Swap words in INTEL PMIC MULTIFUNCTION DEVICE DRIVERS
      mfd: cros_ec_dev: Register cros_ec_accel_legacy driver as a subdevice
      mfd: rk808: Prepare rk805 for poweroff
      mfd: rk808: Check pm_power_off pointer
      mfd: cros_ec: differentiate SCP from EC by feature bit
      dt-bindings: Add binding for cros-ec-rpmsg
      mfd: madera: Add Madera core support for CS47L92
      mfd: madera: Add Madera core support for CS47L15
      mfd: madera: Update DT bindings to add additional CODECs
      mfd: madera: Add supply mapping for MICVDD
      mfd: madera: Fix potential uninitialised use of variable
      mfd: madera: Fix bad reference to pinctrl.txt file
      ...

commit 02f36911c1b41fcd8779fa0c135aab0554333fa5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Jun 21 15:56:31 2019 +0300

    mfd: intel-lpss: Release IDA resources
    
    ida instances allocate some internal memory for ->free_bitmap
    in addition to the base 'struct ida'. Use ida_destroy() to release
    that memory at module_exit().
    
    Fixes: 4b45efe85263 ("mfd: Add support for Intel Sunrisepoint LPSS devices")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index fc6aa4c50144..2ba6df9d83af 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -546,6 +546,7 @@ module_init(intel_lpss_init);
 
 static void __exit intel_lpss_exit(void)
 {
+	ida_destroy(&intel_lpss_devid_ida);
 	debugfs_remove(intel_lpss_debugfs);
 }
 module_exit(intel_lpss_exit);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index fc6aa4c50144..a475cbd2b9ef 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Intel Sunrisepoint LPSS core support.
  *
@@ -7,10 +8,6 @@
  *          Mika Westerberg <mika.westerberg@linux.intel.com>
  *          Heikki Krogerus <heikki.krogerus@linux.intel.com>
  *          Jarkko Nikula <jarkko.nikula@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/clk.h>

commit 815d469d8c9a3360ee0a8b7857dd95352a6c7bde
Merge: 5f3ab27b9eb7 62e59c4e69b3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 16 19:05:35 2019 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull more clk framework updates from Stephen Boyd:
     "One more patch to remove io.h from clk-provider.h.
    
      We used to need this include when we had clk_readl() and clk_writel(),
      but those are gone now so this patch pushes the dependency out to the
      users of clk-provider.h"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux:
      clk: Remove io.h from clk-provider.h

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 50bffc3382d7..c75734b35888 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -18,6 +18,7 @@
 #include <linux/clk-provider.h>
 #include <linux/debugfs.h>
 #include <linux/idr.h>
+#include <linux/io.h>
 #include <linux/ioport.h>
 #include <linux/kernel.h>
 #include <linux/module.h>

commit ebcf5bb28241fe3ddc9e786e3816848a10f688b8
Merge: 414147d99b92 ed835136ee67
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 14 10:39:08 2019 -0700

    Merge tag 'mfd-next-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd
    
    Pull MFD updates from Lee Jones:
     "Core Framework:
       - Document (kerneldoc) core mfd_add_devices() API
    
      New Drivers:
       - Altera SOCFPGA System Manager
       - Maxim MAX77650/77651 PMIC
       - Maxim MAX77663 PMIC
       - ST Multi-Function eXpander (STMFX)
    
      New Device Support:
       - LEDs support in Intel Cherry Trail Whiskey Cove PMIC
       - RTC support in SAMSUNG Electronics S2MPA01 PMIC
       - SAM9X60 support in Atmel HLCDC (High-end LCD Controller)
       - USB X-Powers AXP 8xx PMICs
       - Integrated Sensor Hub (ISH) in ChromeOS EC
       - USB PD Logger in ChromeOS EC
       - AXP223 in X-Powers AXP series PMICs
       - Power Supply in X-Powers AXP 803 PMICs
       - Comet Lake in Intel Low Power Subsystem
       - Fingerprint MCU in ChromeOS EC
       - Touchpad MCU in ChromeOS EC
       - Move TI LM3532 support to LED
    
      New Functionality:
       - max77650, max77620: Add/extend DT support
       - max77620 power-off
       - syscon clocking
       - croc_ec host sleep event
    
      Fix-ups:
       - Trivial; Formatting, spelling, etc; Kconfig, sec-core, ab8500-debugfs
       - Remove unused functionality; rk808, da9063-*
       - SPDX conversion; da9063-*, atmel-*,
       - Adapt/add new register definitions; cs47l35-tables, cs47l90-tables, imx6q-iomuxc-gpr
       - Fix-up DT bindings; ti-lmu, cirrus,lochnagar
       - Simply obtaining driver data; ssbi, t7l66xb, tc6387xb, tc6393xb
    
      Bug Fixes:
       - Fix incorrect defined values; max77620, da9063
       - Fix device initialisation; twl6040
       - Reset device on init; intel-lpss
       - Fix build warnings when !OF; sun6i-prcm
       - Register OF match tables; tps65912-spi
       - Fix DMI matching; intel_quark_i2c_gpio"
    
    * tag 'mfd-next-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd: (65 commits)
      mfd: Use dev_get_drvdata() directly
      mfd: cros_ec: Instantiate properly CrOS Touchpad MCU device
      mfd: cros_ec: Instantiate properly CrOS FP MCU device
      mfd: cros_ec: Update the EC feature codes
      mfd: intel-lpss: Add Intel Comet Lake PCI IDs
      mfd: lochnagar: Add links to binding docs for sound and hwmon
      mfd: ab8500-debugfs: Fix a typo ("deubgfs")
      mfd: imx6sx: Add MQS register definition for iomuxc gpr
      dt-bindings: mfd: LMU: Fix lm3632 dt binding example
      mfd: intel_quark_i2c_gpio: Adjust IOT2000 matching
      mfd: da9063: Fix OTP control register names to match datasheets for DA9063/63L
      mfd: tps65912-spi: Add missing of table registration
      mfd: axp20x: Add USB power supply mfd cell to AXP803
      mfd: sun6i-prcm: Fix build warning for non-OF configurations
      mfd: intel-lpss: Set the device in reset state when init
      platform/chrome: Add support for v1 of host sleep event
      mfd: cros_ec: Add host_sleep_event_v1 command
      mfd: cros_ec: Instantiate the CrOS USB PD logger driver
      mfd: cs47l90: Make DAC_AEC_CONTROL_2 readable
      mfd: cs47l35: Make DAC_AEC_CONTROL_2 readable
      ...

commit dad06532292d77f37fbe831a02948a593500f682
Author: Binbin Wu <binbin.wu@intel.com>
Date:   Mon Apr 8 16:09:10 2019 +0800

    mfd: intel-lpss: Set the device in reset state when init
    
    In virtualized setup, when system reboots due to warm
    reset interrupt storm is seen.
    
    Call Trace:
    <IRQ>
    dump_stack+0x70/0xa5
    __report_bad_irq+0x2e/0xc0
    note_interrupt+0x248/0x290
    ? add_interrupt_randomness+0x30/0x220
    handle_irq_event_percpu+0x54/0x80
    handle_irq_event+0x39/0x60
    handle_fasteoi_irq+0x91/0x150
    handle_irq+0x108/0x180
    do_IRQ+0x52/0xf0
    common_interrupt+0xf/0xf
    </IRQ>
    RIP: 0033:0x76fc2cfabc1d
    Code: 24 28 bf 03 00 00 00 31 c0 48 8d 35 63 77 0e 00 48 8d 15 2e
    94 0e 00 4c 89 f9 49 89 d9 4c 89 d3 e8 b8 e2 01 00 48 8b 54 24 18
    <48> 89 ef 48 89 de 4c 89 e1 e8 d5 97 01 00 84 c0 74 2d 48 8b 04
    24
    RSP: 002b:00007ffd247c1fc0 EFLAGS: 00000293 ORIG_RAX: ffffffffffffffda
    RAX: 0000000000000000 RBX: 00007ffd247c1ff0 RCX: 000000000003d3ce
    RDX: 0000000000000000 RSI: 00007ffd247c1ff0 RDI: 000076fc2cbb6010
    RBP: 000076fc2cded010 R08: 00007ffd247c2210 R09: 00007ffd247c22a0
    R10: 000076fc29465470 R11: 0000000000000000 R12: 00007ffd247c1fc0
    R13: 000076fc2ce8e470 R14: 000076fc27ec9960 R15: 0000000000000414
    handlers:
    [<000000000d3fa913>] idma64_irq
    Disabling IRQ #27
    
    To avoid interrupt storm, set the device in reset state
    before bringing out the device from reset state.
    
    Changelog v2:
    - correct the subject line by adding "mfd: "
    
    Signed-off-by: Binbin Wu <binbin.wu@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 50bffc3382d7..ff3fba16e735 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -273,6 +273,9 @@ static void intel_lpss_init_dev(const struct intel_lpss *lpss)
 {
 	u32 value = LPSS_PRIV_SSP_REG_DIS_DMA_FIN;
 
+	/* Set the device in reset state */
+	writel(0, lpss->priv + LPSS_PRIV_RESETS);
+
 	intel_lpss_deassert_reset(lpss);
 
 	intel_lpss_set_remap_addr(lpss);

commit ffcfc20f7489ecc1b5fbde68dae14f72c47330ab
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Apr 9 18:02:19 2019 +0300

    dmaengine: idma64: Move driver name to the header
    
    There are two drivers that are relying on the iDMA 64-bit driver name
    to match. Instead of duplicating string in both of them, dedicate
    a header file and share it between users.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 50bffc3382d7..45221e092ecf 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -28,6 +28,8 @@
 #include <linux/seq_file.h>
 #include <linux/io-64-nonatomic-lo-hi.h>
 
+#include <linux/dma/idma64.h>
+
 #include "intel-lpss.h"
 
 #define LPSS_DEV_OFFSET		0x000
@@ -96,8 +98,6 @@ static const struct resource intel_lpss_idma64_resources[] = {
 	DEFINE_RES_IRQ(0),
 };
 
-#define LPSS_IDMA64_DRIVER_NAME		"idma64"
-
 /*
  * Cells needs to be ordered so that the iDMA is created first. This is
  * because we need to be sure the DMA is available when the host controller

commit f3b23e5ab43c3bc7fcf6c8f0e9293ee510bf3095
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Apr 24 18:05:12 2018 +0300

    mfd: intel-lpss: Correct names of RESETS register bits
    
    According to documentation the function has 2 bits for reset
    while iDMA 64-bit has only one.
    
    Rename it accordingly. Note, there is no functional change since
    we always handle them together.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 4bcf117a7ba8..50bffc3382d7 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -40,8 +40,8 @@
 
 /* Offsets from lpss->priv */
 #define LPSS_PRIV_RESETS		0x04
-#define LPSS_PRIV_RESETS_FUNC		BIT(2)
-#define LPSS_PRIV_RESETS_IDMA		0x3
+#define LPSS_PRIV_RESETS_IDMA		BIT(2)
+#define LPSS_PRIV_RESETS_FUNC		0x3
 
 #define LPSS_PRIV_ACTIVELTR		0x10
 #define LPSS_PRIV_IDLELTR		0x14

commit d28b62520830b2d0bffa2d98e81afc9f5e537e8b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Apr 24 18:00:10 2018 +0300

    mfd: intel-lpss: Program REMAP register in PIO mode
    
    According to documentation REMAP register has to be programmed in
    either DMA or PIO mode of the slice.
    
    Move the DMA capability check below to let REMAP register be programmed
    in PIO mode.
    
    Cc: stable@vger.kernel.org # 4.3+
    Fixes: 4b45efe85263 ("mfd: Add support for Intel Sunrisepoint LPSS devices")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 9e545eb6e8b4..4bcf117a7ba8 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -275,11 +275,11 @@ static void intel_lpss_init_dev(const struct intel_lpss *lpss)
 
 	intel_lpss_deassert_reset(lpss);
 
+	intel_lpss_set_remap_addr(lpss);
+
 	if (!intel_lpss_has_idma(lpss))
 		return;
 
-	intel_lpss_set_remap_addr(lpss);
-
 	/* Make sure that SPI multiblock DMA transfers are re-enabled */
 	if (lpss->type == LPSS_DEV_SPI)
 		writel(value, lpss->priv + LPSS_PRIV_SSP_REG);

commit 8425ec7faff005500aad89b9fc00e5ba91ac57b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 3 01:34:53 2018 +0100

    PM / mfd: intel-lpss: Use DPM_FLAG_SMART_SUSPEND
    
    Make the intel-lpss driver set DPM_FLAG_SMART_SUSPEND for its
    devices which will allow them to stay in runtime suspend during
    system suspend unless they need to be reconfigured for some reason.
    
    Also make it avoid resuming its child devices if they have
    DPM_FLAG_SMART_SUSPEND set to allow them to remain in runtime
    suspend during system suspend.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-for-MFD-by: Lee Jones <lee.jones@linaro.org>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 0e0ab9bb1530..9e545eb6e8b4 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -450,6 +450,8 @@ int intel_lpss_probe(struct device *dev,
 	if (ret)
 		goto err_remove_ltr;
 
+	dev_pm_set_driver_flags(dev, DPM_FLAG_SMART_SUSPEND);
+
 	return 0;
 
 err_remove_ltr:
@@ -478,7 +480,9 @@ EXPORT_SYMBOL_GPL(intel_lpss_remove);
 
 static int resume_lpss_device(struct device *dev, void *data)
 {
-	pm_runtime_resume(dev);
+	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND))
+		pm_runtime_resume(dev);
+
 	return 0;
 }
 

commit 0b471aaa0e1a8f3d06c76b52c3a903f817d7052e
Author: Furquan Shaikh <furquan@google.com>
Date:   Sun Jul 23 23:02:19 2017 -0700

    mfd: intel-lpss: Put I2C and SPI controllers into reset state on suspend
    
    Commit 274e43edcda6f ("mfd: intel-lpss: Do not put device in reset
    state on suspend") changed the behavior on suspend by not putting LPSS
    controllers into reset. This was done because S3/S0ix fail if UART
    device is put into reset and no_console_suspend flag is enabled.
    
    Because of the above change, I2C controller gets into a bad state if
    it observes that the I2C lines are pulled low when power to I2C device
    is cut off during suspend (generally, I2C lines are pulled to power
    rail of the I2C device in order to ensure that there is no leakage
    because of the pulls when device is turned off). This results in the
    controller timing out for all future I2C operations after resume. It
    is primarily because of the following sequence of operations:
    
    During suspend:
    1. I2C controller is disabled, but it is not put into reset.
    2. Power to I2C device is cut off.
    3. #2 results in the I2C lines being pulled low.
    
    ==> At this point the I2C controller gets into a bad state
    
    On resume:
    1. Power to I2C device is enabled.
    2. #2 results in the I2C lines being pulled high.
    3. I2C controller is enabled.
    
    However, even after enabling the I2C controller, all future I2C xfers
    fail since the controller is in a bad state and does not attempt to
    make any transactions and hence times out.
    
    In order to ensure that the controller does not get into a bad state,
    this change puts it into reset if the controller type is not
    UART. With this change, the order of operations is:
    
    During suspend:
    1. I2C controller is disabled and put into reset.
    2. Power to I2C device is cut off.
    3. #2 results in the I2C lines being pulled low.
    
    On resume:
    1. Power to I2C device is enabled.
    2. #2 results in the I2C lines being pulled high.
    3. I2C controller is enabled and taken out of reset.
    
    Signed-off-by: Furquan Shaikh <furquan@google.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 70c646b0097d..0e0ab9bb1530 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -502,6 +502,14 @@ int intel_lpss_suspend(struct device *dev)
 	for (i = 0; i < LPSS_PRIV_REG_COUNT; i++)
 		lpss->priv_ctx[i] = readl(lpss->priv + i * 4);
 
+	/*
+	 * If the device type is not UART, then put the controller into
+	 * reset. UART cannot be put into reset since S3/S0ix fail when
+	 * no_console_suspend flag is enabled.
+	 */
+	if (lpss->type != LPSS_DEV_UART)
+		writel(0, lpss->priv + LPSS_PRIV_RESETS);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(intel_lpss_suspend);

commit 274e43edcda6f709aa67e436b3123e45a6270923
Author: Azhar Shaikh <azhar.shaikh@intel.com>
Date:   Wed Oct 12 10:12:20 2016 -0700

    mfd: intel-lpss: Do not put device in reset state on suspend
    
    Commit 41a3da2b8e163 ("mfd: intel-lpss: Save register context on
    suspend") saved the register context while going to suspend and
    also put the device in reset state.
    
    Due to the resetting of device, system cannot enter S3/S0ix
    states when no_console_suspend flag is enabled. The system
    and serial console both hang. The resetting of device is not
    needed while going to suspend. Hence remove this code.
    
    Cc: stable@vger.kernel.org
    Fixes: 41a3da2b8e163 ("mfd: intel-lpss: Save register context on suspend")
    Signed-off-by: Azhar Shaikh <azhar.shaikh@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 41b113875d64..70c646b0097d 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -502,9 +502,6 @@ int intel_lpss_suspend(struct device *dev)
 	for (i = 0; i < LPSS_PRIV_REG_COUNT; i++)
 		lpss->priv_ctx[i] = readl(lpss->priv + i * 4);
 
-	/* Put the device into reset state */
-	writel(0, lpss->priv + LPSS_PRIV_RESETS);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(intel_lpss_suspend);

commit 6eb59af580dcffc6f6982ac8ef6d27a1a5f26b27
Merge: 4d230d4d030e b52207ef4ea5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 11:10:24 2016 -0700

    Merge tag 'mfd-for-linus-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd
    
    Pull MFD updates from Lee Jones:
     "New Drivers:
       - Add new driver for MAXIM MAX77620/MAX20024 PMIC
       - Add new driver for Hisilicon HI665X PMIC
    
      New Device Support:
       - Add support for AXP809 in axp20x-rsb
       - Add support for Power Supply in axp20x
    
      New core features:
       - devm_mfd_* managed resources
    
      Fix-ups:
       - Remove unused code (da9063-irq, wm8400-core, tps6105x,
         smsc-ece1099, twl4030-power)
       - Improve clean-up in error path (intel_quark_i2c_gpio)
       - Explicitly include headers (syscon.h)
       - Allow building as modules (max77693)
       - Use IS_ENABLED() instead of rolling your own (dm355evm_msp,
         wm8400-core)
       - DT adaptions (axp20x, hi655x, arizona, max77620)
       - Remove CLK_IS_ROOT flag (intel-lpss, intel_quark)
       - Move to gpiochip API (asic3, dm355evm_msp, htc-egpio, htc-i2cpld,
         sm501, tc6393xb, tps65010, ucb1x00, vexpress)
       - Make use of devm_mfd_* calls (act8945a, as3711, atmel-hlcdc,
         bcm590xx, hi6421-pmic-core, lp3943, menf21bmc, mt6397, rdc321x,
         rk808, rn5t618, rt5033, sky81452, stw481x, tps6507x, tps65217,
         wm8400)
    
      Bug Fixes"
       - Fix ACPI child matching (mfd-core)
       - Fix start-up ordering issues (mt6397-core, arizona-core)
       - Fix forgotten register state on resume (intel-lpss)
       - Fix Clock related issues (twl6040)
       - Fix scheduling whilst atomic (omap-usb-tll)
       - Kconfig changes (vexpress)"
    
    * tag 'mfd-for-linus-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd: (73 commits)
      mfd: hi655x: Add MFD driver for hi655x
      mfd: ab8500-debugfs: Trivial fix of spelling mistake on "between"
      mfd: vexpress: Add !ARCH_USES_GETTIMEOFFSET dependency
      mfd: Add device-tree binding doc for PMIC MAX77620/MAX20024
      mfd: max77620: Add core driver for MAX77620/MAX20024
      mfd: arizona: Add defines for GPSW values that can be used from DT
      mfd: omap-usb-tll: Fix scheduling while atomic BUG
      mfd: wm5110: ARIZONA_CLOCK_CONTROL should be volatile
      mfd: axp20x: Add a cell for the ac power_supply part of the axp20x PMICs
      mfd: intel_soc_pmic_core: Terminate panel control GPIO lookup table correctly
      mfd: wl1273-core: Use devm_mfd_add_devices() for mfd_device registration
      mfd: tps65910: Use devm_mfd_add_devices and devm_regmap_add_irq_chip
      mfd: sec: Use devm_mfd_add_devices and devm_regmap_add_irq_chip
      mfd: rc5t583: Use devm_mfd_add_devices and devm_request_threaded_irq
      mfd: max77686: Use devm_mfd_add_devices and devm_regmap_add_irq_chip
      mfd: as3722: Use devm_mfd_add_devices and devm_regmap_add_irq_chip
      mfd: twl4030-power: Remove driver path in file comment
      MAINTAINERS: Add entry for X-Powers AXP family PMIC drivers
      mfd: smsc-ece1099: Remove unnecessarily remove callback
      mfd: Use IS_ENABLED(CONFIG_FOO) instead of checking FOO || FOO_MODULE
      ...

commit 0f7e70e7da0a09d9d0a814f17272ea7da7855f64
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Apr 19 18:20:49 2016 -0700

    mfd: intel-lpss: Remove CLK_IS_ROOT
    
    This flag is a no-op now (see commit 47b0eeb3dc8a "clk: Deprecate
    CLK_IS_ROOT", 2016-02-02) so remove it.
    
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 807a3e3ec29a..98e59809a831 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -338,8 +338,8 @@ static int intel_lpss_register_clock(struct intel_lpss *lpss)
 		return 0;
 
 	/* Root clock */
-	clk = clk_register_fixed_rate(NULL, dev_name(lpss->dev), NULL,
-				      CLK_IS_ROOT, lpss->info->clk_rate);
+	clk = clk_register_fixed_rate(NULL, dev_name(lpss->dev), NULL, 0,
+				      lpss->info->clk_rate);
 	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 

commit 41a3da2b8e1639d983192e3650670df4ecc94cf7
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Apr 18 15:14:56 2016 +0300

    mfd: intel-lpss: Save register context on suspend
    
    All configurations are lost and the registers will have
    default values when the hardware is suspended and resumed,
    so saving the private register space context on suspend, and
    restoring it on resume.
    
    Fixes: 4b45efe85263 (mfd: Add support for Intel Sunrisepoint LPSS devices)
    Cc: stable@vger.kernel.org # v4.3+
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 1bbbe877ba7e..807a3e3ec29a 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -34,6 +34,7 @@
 #define LPSS_DEV_SIZE		0x200
 #define LPSS_PRIV_OFFSET	0x200
 #define LPSS_PRIV_SIZE		0x100
+#define LPSS_PRIV_REG_COUNT	(LPSS_PRIV_SIZE / 4)
 #define LPSS_IDMA64_OFFSET	0x800
 #define LPSS_IDMA64_SIZE	0x800
 
@@ -76,6 +77,7 @@ struct intel_lpss {
 	struct mfd_cell *cell;
 	struct device *dev;
 	void __iomem *priv;
+	u32 priv_ctx[LPSS_PRIV_REG_COUNT];
 	int devid;
 	u32 caps;
 	u32 active_ltr;
@@ -493,6 +495,16 @@ EXPORT_SYMBOL_GPL(intel_lpss_prepare);
 
 int intel_lpss_suspend(struct device *dev)
 {
+	struct intel_lpss *lpss = dev_get_drvdata(dev);
+	unsigned int i;
+
+	/* Save device context */
+	for (i = 0; i < LPSS_PRIV_REG_COUNT; i++)
+		lpss->priv_ctx[i] = readl(lpss->priv + i * 4);
+
+	/* Put the device into reset state */
+	writel(0, lpss->priv + LPSS_PRIV_RESETS);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(intel_lpss_suspend);
@@ -500,8 +512,13 @@ EXPORT_SYMBOL_GPL(intel_lpss_suspend);
 int intel_lpss_resume(struct device *dev)
 {
 	struct intel_lpss *lpss = dev_get_drvdata(dev);
+	unsigned int i;
 
-	intel_lpss_init_dev(lpss);
+	intel_lpss_deassert_reset(lpss);
+
+	/* Restore device context */
+	for (i = 0; i < LPSS_PRIV_REG_COUNT; i++)
+		writel(lpss->priv_ctx[i], lpss->priv + i * 4);
 
 	return 0;
 }

commit f4d05266032346531b9f889e26aa31a0cf2a9822
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Mar 29 14:52:23 2016 +0300

    device property: don't bother the drivers with struct property_set
    
    Since device_add_property_set() now always takes a copy of
    the property_set, and also since the fwnode type is always
    hard coded to be FWNODE_PDATA, there is no need for the
    drivers to deliver the entire struct property_set. The
    function can just create the instance of it on its own and
    bind the properties from the drivers to it on the spot.
    
    This renames device_add_property_set() to
    device_add_properties(). The function now takes struct
    property_entry as its parameter instead of struct
    property_set.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 1bbbe877ba7e..6352aaba96a4 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -407,7 +407,7 @@ int intel_lpss_probe(struct device *dev,
 	if (ret)
 		return ret;
 
-	lpss->cell->pset = info->pset;
+	lpss->cell->properties = info->properties;
 
 	intel_lpss_init_dev(lpss);
 

commit 84cb36cac581c915ef4e8b70abb73e084325df92
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Jan 22 16:48:46 2016 +0200

    mfd: intel-lpss: Remove clock tree on error path
    
    We forgot to remove the clock tree if something goes wrong in ->probe(). Add a
    call to intel_lpss_unregister_clock() on error path in ->probe() to fix the
    potential issue.
    
    Fixes: 4b45efe85263 (mfd: Add support for Intel Sunrisepoint LPSS devices)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 1743788f1595..1bbbe877ba7e 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -453,6 +453,7 @@ int intel_lpss_probe(struct device *dev,
 err_remove_ltr:
 	intel_lpss_debugfs_remove(lpss);
 	intel_lpss_ltr_hide(lpss);
+	intel_lpss_unregister_clock(lpss);
 
 err_clk_register:
 	ida_simple_remove(&intel_lpss_devid_ida, lpss->devid);

commit e15ad2154b6166804fc04487e0398c9aef9e7c97
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Nov 30 17:11:41 2015 +0200

    mfd: intel-lpss: Add support for passing device properties
    
    If the boot firmware does not support ACPI we need a way to pass device
    configuration information to the drivers. The unified device properties API
    already supports passing platform data via properties so let's take
    advantage of that and allow probe drivers to pass set of properties to the
    host controller driver.
    
    In order to do that we need to be able to modify the MFD cell corresponding
    the host controller, so make the core driver to take copy of the cell
    instead of using it directly. Then we can assign info->pset to the
    resulting copy of a cell and let the MFD core to assign that to the
    resulting device.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index 6255513f54c7..1743788f1595 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -24,6 +24,7 @@
 #include <linux/mfd/core.h>
 #include <linux/pm_qos.h>
 #include <linux/pm_runtime.h>
+#include <linux/property.h>
 #include <linux/seq_file.h>
 #include <linux/io-64-nonatomic-lo-hi.h>
 
@@ -72,7 +73,7 @@ struct intel_lpss {
 	enum intel_lpss_dev_type type;
 	struct clk *clk;
 	struct clk_lookup *clock;
-	const struct mfd_cell *cell;
+	struct mfd_cell *cell;
 	struct device *dev;
 	void __iomem *priv;
 	int devid;
@@ -217,6 +218,7 @@ static void intel_lpss_ltr_hide(struct intel_lpss *lpss)
 
 static int intel_lpss_assign_devs(struct intel_lpss *lpss)
 {
+	const struct mfd_cell *cell;
 	unsigned int type;
 
 	type = lpss->caps & LPSS_PRIV_CAPS_TYPE_MASK;
@@ -224,18 +226,22 @@ static int intel_lpss_assign_devs(struct intel_lpss *lpss)
 
 	switch (type) {
 	case LPSS_DEV_I2C:
-		lpss->cell = &intel_lpss_i2c_cell;
+		cell = &intel_lpss_i2c_cell;
 		break;
 	case LPSS_DEV_UART:
-		lpss->cell = &intel_lpss_uart_cell;
+		cell = &intel_lpss_uart_cell;
 		break;
 	case LPSS_DEV_SPI:
-		lpss->cell = &intel_lpss_spi_cell;
+		cell = &intel_lpss_spi_cell;
 		break;
 	default:
 		return -ENODEV;
 	}
 
+	lpss->cell = devm_kmemdup(lpss->dev, cell, sizeof(*cell), GFP_KERNEL);
+	if (!lpss->cell)
+		return -ENOMEM;
+
 	lpss->type = type;
 
 	return 0;
@@ -401,6 +407,8 @@ int intel_lpss_probe(struct device *dev,
 	if (ret)
 		return ret;
 
+	lpss->cell->pset = info->pset;
+
 	intel_lpss_init_dev(lpss);
 
 	lpss->devid = ida_simple_get(&intel_lpss_devid_ida, 0, 0, GFP_KERNEL);

commit 9cf5c095b65da63c08b928a7d0015d5d5dca8a66
Merge: 22402cd0af68 4008cb3ad223
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 14:22:15 2015 -0800

    Merge tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic
    
    Pull asm-generic cleanups from Arnd Bergmann:
     "The asm-generic changes for 4.4 are mostly a series from Christoph
      Hellwig to clean up various abuses of headers in there.  The patch to
      rename the io-64-nonatomic-*.h headers caused some conflicts with new
      users, so I added a workaround that we can remove in the next merge
      window.
    
      The only other patch is a warning fix from Marek Vasut"
    
    * tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic:
      asm-generic: temporarily add back asm-generic/io-64-nonatomic*.h
      asm-generic: cmpxchg: avoid warnings from macro-ized cmpxchg() implementations
      gpio-mxc: stop including <asm-generic/bug>
      n_tracesink: stop including <asm-generic/bug>
      n_tracerouter: stop including <asm-generic/bug>
      mlx5: stop including <asm-generic/kmap_types.h>
      hifn_795x: stop including <asm-generic/kmap_types.h>
      drbd: stop including <asm-generic/kmap_types.h>
      move count_zeroes.h out of asm-generic
      move io-64-nonatomic*.h out of asm-generic

commit 689d4453ed8212ab4a5d53982ac01cbe6531d18a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Sep 14 11:32:48 2015 +0300

    mfd: intel-lpss: Use writeq() helper
    
    There are already helper functions to do 64-bit I/O on 32-bit machines, thus we
    don't need to reinvent the wheel. In our case we can't use readq() / writeq()
    even on 64-bit kernel since there is a hardware limitation (OCP bus is a 32-bit
    bus).
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
index fdf4d5c1add2..001a7d7708ce 100644
--- a/drivers/mfd/intel-lpss.c
+++ b/drivers/mfd/intel-lpss.c
@@ -26,6 +26,8 @@
 #include <linux/pm_runtime.h>
 #include <linux/seq_file.h>
 
+#include <asm-generic/io-64-nonatomic-lo-hi.h>
+
 #include "intel-lpss.h"
 
 #define LPSS_DEV_OFFSET		0x000
@@ -52,8 +54,7 @@
 #define LPSS_PRIV_SSP_REG		0x20
 #define LPSS_PRIV_SSP_REG_DIS_DMA_FIN	BIT(0)
 
-#define LPSS_PRIV_REMAP_ADDR_LO		0x40
-#define LPSS_PRIV_REMAP_ADDR_HI		0x44
+#define LPSS_PRIV_REMAP_ADDR		0x40
 
 #define LPSS_PRIV_CAPS			0xfc
 #define LPSS_PRIV_CAPS_NO_IDMA		BIT(8)
@@ -250,12 +251,7 @@ static void intel_lpss_set_remap_addr(const struct intel_lpss *lpss)
 {
 	resource_size_t addr = lpss->info->mem->start;
 
-	writel(addr, lpss->priv + LPSS_PRIV_REMAP_ADDR_LO);
-#if BITS_PER_LONG > 32
-	writel(addr >> 32, lpss->priv + LPSS_PRIV_REMAP_ADDR_HI);
-#else
-	writel(0, lpss->priv + LPSS_PRIV_REMAP_ADDR_HI);
-#endif
+	lo_hi_writeq(addr, lpss->priv + LPSS_PRIV_REMAP_ADDR);
 }
 
 static void intel_lpss_deassert_reset(const struct intel_lpss *lpss)

commit 4b45efe8526359a11ca60a299bef3aebf413fd77
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jul 27 18:04:03 2015 +0300

    mfd: Add support for Intel Sunrisepoint LPSS devices
    
    The new coming Intel platforms such as Skylake will contain Sunrisepoint PCH.
    The main difference to the previous platforms is that the LPSS devices are
    compound devices where usually main (SPI, HSUART, or I2C) and DMA IPs are
    present.
    
    This patch brings the driver for such devices found on Sunrisepoint PCH.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel-lpss.c b/drivers/mfd/intel-lpss.c
new file mode 100644
index 000000000000..fdf4d5c1add2
--- /dev/null
+++ b/drivers/mfd/intel-lpss.c
@@ -0,0 +1,524 @@
+/*
+ * Intel Sunrisepoint LPSS core support.
+ *
+ * Copyright (C) 2015, Intel Corporation
+ *
+ * Authors: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
+ *          Mika Westerberg <mika.westerberg@linux.intel.com>
+ *          Heikki Krogerus <heikki.krogerus@linux.intel.com>
+ *          Jarkko Nikula <jarkko.nikula@linux.intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/debugfs.h>
+#include <linux/idr.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/core.h>
+#include <linux/pm_qos.h>
+#include <linux/pm_runtime.h>
+#include <linux/seq_file.h>
+
+#include "intel-lpss.h"
+
+#define LPSS_DEV_OFFSET		0x000
+#define LPSS_DEV_SIZE		0x200
+#define LPSS_PRIV_OFFSET	0x200
+#define LPSS_PRIV_SIZE		0x100
+#define LPSS_IDMA64_OFFSET	0x800
+#define LPSS_IDMA64_SIZE	0x800
+
+/* Offsets from lpss->priv */
+#define LPSS_PRIV_RESETS		0x04
+#define LPSS_PRIV_RESETS_FUNC		BIT(2)
+#define LPSS_PRIV_RESETS_IDMA		0x3
+
+#define LPSS_PRIV_ACTIVELTR		0x10
+#define LPSS_PRIV_IDLELTR		0x14
+
+#define LPSS_PRIV_LTR_REQ		BIT(15)
+#define LPSS_PRIV_LTR_SCALE_MASK	0xc00
+#define LPSS_PRIV_LTR_SCALE_1US		0x800
+#define LPSS_PRIV_LTR_SCALE_32US	0xc00
+#define LPSS_PRIV_LTR_VALUE_MASK	0x3ff
+
+#define LPSS_PRIV_SSP_REG		0x20
+#define LPSS_PRIV_SSP_REG_DIS_DMA_FIN	BIT(0)
+
+#define LPSS_PRIV_REMAP_ADDR_LO		0x40
+#define LPSS_PRIV_REMAP_ADDR_HI		0x44
+
+#define LPSS_PRIV_CAPS			0xfc
+#define LPSS_PRIV_CAPS_NO_IDMA		BIT(8)
+#define LPSS_PRIV_CAPS_TYPE_SHIFT	4
+#define LPSS_PRIV_CAPS_TYPE_MASK	(0xf << LPSS_PRIV_CAPS_TYPE_SHIFT)
+
+/* This matches the type field in CAPS register */
+enum intel_lpss_dev_type {
+	LPSS_DEV_I2C = 0,
+	LPSS_DEV_UART,
+	LPSS_DEV_SPI,
+};
+
+struct intel_lpss {
+	const struct intel_lpss_platform_info *info;
+	enum intel_lpss_dev_type type;
+	struct clk *clk;
+	struct clk_lookup *clock;
+	const struct mfd_cell *cell;
+	struct device *dev;
+	void __iomem *priv;
+	int devid;
+	u32 caps;
+	u32 active_ltr;
+	u32 idle_ltr;
+	struct dentry *debugfs;
+};
+
+static const struct resource intel_lpss_dev_resources[] = {
+	DEFINE_RES_MEM_NAMED(LPSS_DEV_OFFSET, LPSS_DEV_SIZE, "lpss_dev"),
+	DEFINE_RES_MEM_NAMED(LPSS_PRIV_OFFSET, LPSS_PRIV_SIZE, "lpss_priv"),
+	DEFINE_RES_IRQ(0),
+};
+
+static const struct resource intel_lpss_idma64_resources[] = {
+	DEFINE_RES_MEM(LPSS_IDMA64_OFFSET, LPSS_IDMA64_SIZE),
+	DEFINE_RES_IRQ(0),
+};
+
+#define LPSS_IDMA64_DRIVER_NAME		"idma64"
+
+/*
+ * Cells needs to be ordered so that the iDMA is created first. This is
+ * because we need to be sure the DMA is available when the host controller
+ * driver is probed.
+ */
+static const struct mfd_cell intel_lpss_idma64_cell = {
+	.name = LPSS_IDMA64_DRIVER_NAME,
+	.num_resources = ARRAY_SIZE(intel_lpss_idma64_resources),
+	.resources = intel_lpss_idma64_resources,
+};
+
+static const struct mfd_cell intel_lpss_i2c_cell = {
+	.name = "i2c_designware",
+	.num_resources = ARRAY_SIZE(intel_lpss_dev_resources),
+	.resources = intel_lpss_dev_resources,
+};
+
+static const struct mfd_cell intel_lpss_uart_cell = {
+	.name = "dw-apb-uart",
+	.num_resources = ARRAY_SIZE(intel_lpss_dev_resources),
+	.resources = intel_lpss_dev_resources,
+};
+
+static const struct mfd_cell intel_lpss_spi_cell = {
+	.name = "pxa2xx-spi",
+	.num_resources = ARRAY_SIZE(intel_lpss_dev_resources),
+	.resources = intel_lpss_dev_resources,
+};
+
+static DEFINE_IDA(intel_lpss_devid_ida);
+static struct dentry *intel_lpss_debugfs;
+
+static int intel_lpss_request_dma_module(const char *name)
+{
+	static bool intel_lpss_dma_requested;
+
+	if (intel_lpss_dma_requested)
+		return 0;
+
+	intel_lpss_dma_requested = true;
+	return request_module("%s", name);
+}
+
+static void intel_lpss_cache_ltr(struct intel_lpss *lpss)
+{
+	lpss->active_ltr = readl(lpss->priv + LPSS_PRIV_ACTIVELTR);
+	lpss->idle_ltr = readl(lpss->priv + LPSS_PRIV_IDLELTR);
+}
+
+static int intel_lpss_debugfs_add(struct intel_lpss *lpss)
+{
+	struct dentry *dir;
+
+	dir = debugfs_create_dir(dev_name(lpss->dev), intel_lpss_debugfs);
+	if (IS_ERR(dir))
+		return PTR_ERR(dir);
+
+	/* Cache the values into lpss structure */
+	intel_lpss_cache_ltr(lpss);
+
+	debugfs_create_x32("capabilities", S_IRUGO, dir, &lpss->caps);
+	debugfs_create_x32("active_ltr", S_IRUGO, dir, &lpss->active_ltr);
+	debugfs_create_x32("idle_ltr", S_IRUGO, dir, &lpss->idle_ltr);
+
+	lpss->debugfs = dir;
+	return 0;
+}
+
+static void intel_lpss_debugfs_remove(struct intel_lpss *lpss)
+{
+	debugfs_remove_recursive(lpss->debugfs);
+}
+
+static void intel_lpss_ltr_set(struct device *dev, s32 val)
+{
+	struct intel_lpss *lpss = dev_get_drvdata(dev);
+	u32 ltr;
+
+	/*
+	 * Program latency tolerance (LTR) accordingly what has been asked
+	 * by the PM QoS layer or disable it in case we were passed
+	 * negative value or PM_QOS_LATENCY_ANY.
+	 */
+	ltr = readl(lpss->priv + LPSS_PRIV_ACTIVELTR);
+
+	if (val == PM_QOS_LATENCY_ANY || val < 0) {
+		ltr &= ~LPSS_PRIV_LTR_REQ;
+	} else {
+		ltr |= LPSS_PRIV_LTR_REQ;
+		ltr &= ~LPSS_PRIV_LTR_SCALE_MASK;
+		ltr &= ~LPSS_PRIV_LTR_VALUE_MASK;
+
+		if (val > LPSS_PRIV_LTR_VALUE_MASK)
+			ltr |= LPSS_PRIV_LTR_SCALE_32US | val >> 5;
+		else
+			ltr |= LPSS_PRIV_LTR_SCALE_1US | val;
+	}
+
+	if (ltr == lpss->active_ltr)
+		return;
+
+	writel(ltr, lpss->priv + LPSS_PRIV_ACTIVELTR);
+	writel(ltr, lpss->priv + LPSS_PRIV_IDLELTR);
+
+	/* Cache the values into lpss structure */
+	intel_lpss_cache_ltr(lpss);
+}
+
+static void intel_lpss_ltr_expose(struct intel_lpss *lpss)
+{
+	lpss->dev->power.set_latency_tolerance = intel_lpss_ltr_set;
+	dev_pm_qos_expose_latency_tolerance(lpss->dev);
+}
+
+static void intel_lpss_ltr_hide(struct intel_lpss *lpss)
+{
+	dev_pm_qos_hide_latency_tolerance(lpss->dev);
+	lpss->dev->power.set_latency_tolerance = NULL;
+}
+
+static int intel_lpss_assign_devs(struct intel_lpss *lpss)
+{
+	unsigned int type;
+
+	type = lpss->caps & LPSS_PRIV_CAPS_TYPE_MASK;
+	type >>= LPSS_PRIV_CAPS_TYPE_SHIFT;
+
+	switch (type) {
+	case LPSS_DEV_I2C:
+		lpss->cell = &intel_lpss_i2c_cell;
+		break;
+	case LPSS_DEV_UART:
+		lpss->cell = &intel_lpss_uart_cell;
+		break;
+	case LPSS_DEV_SPI:
+		lpss->cell = &intel_lpss_spi_cell;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	lpss->type = type;
+
+	return 0;
+}
+
+static bool intel_lpss_has_idma(const struct intel_lpss *lpss)
+{
+	return (lpss->caps & LPSS_PRIV_CAPS_NO_IDMA) == 0;
+}
+
+static void intel_lpss_set_remap_addr(const struct intel_lpss *lpss)
+{
+	resource_size_t addr = lpss->info->mem->start;
+
+	writel(addr, lpss->priv + LPSS_PRIV_REMAP_ADDR_LO);
+#if BITS_PER_LONG > 32
+	writel(addr >> 32, lpss->priv + LPSS_PRIV_REMAP_ADDR_HI);
+#else
+	writel(0, lpss->priv + LPSS_PRIV_REMAP_ADDR_HI);
+#endif
+}
+
+static void intel_lpss_deassert_reset(const struct intel_lpss *lpss)
+{
+	u32 value = LPSS_PRIV_RESETS_FUNC | LPSS_PRIV_RESETS_IDMA;
+
+	/* Bring out the device from reset */
+	writel(value, lpss->priv + LPSS_PRIV_RESETS);
+}
+
+static void intel_lpss_init_dev(const struct intel_lpss *lpss)
+{
+	u32 value = LPSS_PRIV_SSP_REG_DIS_DMA_FIN;
+
+	intel_lpss_deassert_reset(lpss);
+
+	if (!intel_lpss_has_idma(lpss))
+		return;
+
+	intel_lpss_set_remap_addr(lpss);
+
+	/* Make sure that SPI multiblock DMA transfers are re-enabled */
+	if (lpss->type == LPSS_DEV_SPI)
+		writel(value, lpss->priv + LPSS_PRIV_SSP_REG);
+}
+
+static void intel_lpss_unregister_clock_tree(struct clk *clk)
+{
+	struct clk *parent;
+
+	while (clk) {
+		parent = clk_get_parent(clk);
+		clk_unregister(clk);
+		clk = parent;
+	}
+}
+
+static int intel_lpss_register_clock_divider(struct intel_lpss *lpss,
+					     const char *devname,
+					     struct clk **clk)
+{
+	char name[32];
+	struct clk *tmp = *clk;
+
+	snprintf(name, sizeof(name), "%s-enable", devname);
+	tmp = clk_register_gate(NULL, name, __clk_get_name(tmp), 0,
+				lpss->priv, 0, 0, NULL);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+
+	snprintf(name, sizeof(name), "%s-div", devname);
+	tmp = clk_register_fractional_divider(NULL, name, __clk_get_name(tmp),
+					      0, lpss->priv, 1, 15, 16, 15, 0,
+					      NULL);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+	*clk = tmp;
+
+	snprintf(name, sizeof(name), "%s-update", devname);
+	tmp = clk_register_gate(NULL, name, __clk_get_name(tmp),
+				CLK_SET_RATE_PARENT, lpss->priv, 31, 0, NULL);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+	*clk = tmp;
+
+	return 0;
+}
+
+static int intel_lpss_register_clock(struct intel_lpss *lpss)
+{
+	const struct mfd_cell *cell = lpss->cell;
+	struct clk *clk;
+	char devname[24];
+	int ret;
+
+	if (!lpss->info->clk_rate)
+		return 0;
+
+	/* Root clock */
+	clk = clk_register_fixed_rate(NULL, dev_name(lpss->dev), NULL,
+				      CLK_IS_ROOT, lpss->info->clk_rate);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	snprintf(devname, sizeof(devname), "%s.%d", cell->name, lpss->devid);
+
+	/*
+	 * Support for clock divider only if it has some preset value.
+	 * Otherwise we assume that the divider is not used.
+	 */
+	if (lpss->type != LPSS_DEV_I2C) {
+		ret = intel_lpss_register_clock_divider(lpss, devname, &clk);
+		if (ret)
+			goto err_clk_register;
+	}
+
+	ret = -ENOMEM;
+
+	/* Clock for the host controller */
+	lpss->clock = clkdev_create(clk, lpss->info->clk_con_id, "%s", devname);
+	if (!lpss->clock)
+		goto err_clk_register;
+
+	lpss->clk = clk;
+
+	return 0;
+
+err_clk_register:
+	intel_lpss_unregister_clock_tree(clk);
+
+	return ret;
+}
+
+static void intel_lpss_unregister_clock(struct intel_lpss *lpss)
+{
+	if (IS_ERR_OR_NULL(lpss->clk))
+		return;
+
+	clkdev_drop(lpss->clock);
+	intel_lpss_unregister_clock_tree(lpss->clk);
+}
+
+int intel_lpss_probe(struct device *dev,
+		     const struct intel_lpss_platform_info *info)
+{
+	struct intel_lpss *lpss;
+	int ret;
+
+	if (!info || !info->mem || info->irq <= 0)
+		return -EINVAL;
+
+	lpss = devm_kzalloc(dev, sizeof(*lpss), GFP_KERNEL);
+	if (!lpss)
+		return -ENOMEM;
+
+	lpss->priv = devm_ioremap(dev, info->mem->start + LPSS_PRIV_OFFSET,
+				  LPSS_PRIV_SIZE);
+	if (!lpss->priv)
+		return -ENOMEM;
+
+	lpss->info = info;
+	lpss->dev = dev;
+	lpss->caps = readl(lpss->priv + LPSS_PRIV_CAPS);
+
+	dev_set_drvdata(dev, lpss);
+
+	ret = intel_lpss_assign_devs(lpss);
+	if (ret)
+		return ret;
+
+	intel_lpss_init_dev(lpss);
+
+	lpss->devid = ida_simple_get(&intel_lpss_devid_ida, 0, 0, GFP_KERNEL);
+	if (lpss->devid < 0)
+		return lpss->devid;
+
+	ret = intel_lpss_register_clock(lpss);
+	if (ret)
+		goto err_clk_register;
+
+	intel_lpss_ltr_expose(lpss);
+
+	ret = intel_lpss_debugfs_add(lpss);
+	if (ret)
+		dev_warn(dev, "Failed to create debugfs entries\n");
+
+	if (intel_lpss_has_idma(lpss)) {
+		/*
+		 * Ensure the DMA driver is loaded before the host
+		 * controller device appears, so that the host controller
+		 * driver can request its DMA channels as early as
+		 * possible.
+		 *
+		 * If the DMA module is not there that's OK as well.
+		 */
+		intel_lpss_request_dma_module(LPSS_IDMA64_DRIVER_NAME);
+
+		ret = mfd_add_devices(dev, lpss->devid, &intel_lpss_idma64_cell,
+				      1, info->mem, info->irq, NULL);
+		if (ret)
+			dev_warn(dev, "Failed to add %s, fallback to PIO\n",
+				 LPSS_IDMA64_DRIVER_NAME);
+	}
+
+	ret = mfd_add_devices(dev, lpss->devid, lpss->cell,
+			      1, info->mem, info->irq, NULL);
+	if (ret)
+		goto err_remove_ltr;
+
+	return 0;
+
+err_remove_ltr:
+	intel_lpss_debugfs_remove(lpss);
+	intel_lpss_ltr_hide(lpss);
+
+err_clk_register:
+	ida_simple_remove(&intel_lpss_devid_ida, lpss->devid);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(intel_lpss_probe);
+
+void intel_lpss_remove(struct device *dev)
+{
+	struct intel_lpss *lpss = dev_get_drvdata(dev);
+
+	mfd_remove_devices(dev);
+	intel_lpss_debugfs_remove(lpss);
+	intel_lpss_ltr_hide(lpss);
+	intel_lpss_unregister_clock(lpss);
+	ida_simple_remove(&intel_lpss_devid_ida, lpss->devid);
+}
+EXPORT_SYMBOL_GPL(intel_lpss_remove);
+
+static int resume_lpss_device(struct device *dev, void *data)
+{
+	pm_runtime_resume(dev);
+	return 0;
+}
+
+int intel_lpss_prepare(struct device *dev)
+{
+	/*
+	 * Resume both child devices before entering system sleep. This
+	 * ensures that they are in proper state before they get suspended.
+	 */
+	device_for_each_child_reverse(dev, NULL, resume_lpss_device);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(intel_lpss_prepare);
+
+int intel_lpss_suspend(struct device *dev)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(intel_lpss_suspend);
+
+int intel_lpss_resume(struct device *dev)
+{
+	struct intel_lpss *lpss = dev_get_drvdata(dev);
+
+	intel_lpss_init_dev(lpss);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(intel_lpss_resume);
+
+static int __init intel_lpss_init(void)
+{
+	intel_lpss_debugfs = debugfs_create_dir("intel_lpss", NULL);
+	return 0;
+}
+module_init(intel_lpss_init);
+
+static void __exit intel_lpss_exit(void)
+{
+	debugfs_remove(intel_lpss_debugfs);
+}
+module_exit(intel_lpss_exit);
+
+MODULE_AUTHOR("Andy Shevchenko <andriy.shevchenko@linux.intel.com>");
+MODULE_AUTHOR("Mika Westerberg <mika.westerberg@linux.intel.com>");
+MODULE_AUTHOR("Heikki Krogerus <heikki.krogerus@linux.intel.com>");
+MODULE_AUTHOR("Jarkko Nikula <jarkko.nikula@linux.intel.com>");
+MODULE_DESCRIPTION("Intel LPSS core driver");
+MODULE_LICENSE("GPL v2");
