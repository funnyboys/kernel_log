commit 1f67b599f8b8f976d2ea1a447c0f5e768a78ae8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:10:57 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 464
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 11 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081202.373849232@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index cc9e563f23aa..67c9995bb1aa 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) ST-Ericsson SA 2010
  *
- * License Terms: GNU General Public License, version 2
  * Author: Hanumath Prasad <hanumath.prasad@stericsson.com> for ST-Ericsson
  * Author: Rabin Vincent <rabin.vincent@stericsson.com> for ST-Ericsson
  */

commit d87814a3e846aa23a1ae3519413841954d27fb40
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sat Oct 1 21:46:23 2016 +0200

    mfd: tc3589x: Improve function-level documentation
    
    Use the correct function name in one case and adjust a variable name to
    that of the corresponding function parameter in another case.
    
    Issue detected using Coccinelle (http://coccinelle.lip6.fr/)
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 274bf39968aa..cc9e563f23aa 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -53,7 +53,7 @@ int tc3589x_reg_read(struct tc3589x *tc3589x, u8 reg)
 EXPORT_SYMBOL_GPL(tc3589x_reg_read);
 
 /**
- * tc3589x_reg_read() - write a single TC3589x register
+ * tc3589x_reg_write() - write a single TC3589x register
  * @tc3589x:	Device to write to
  * @reg:	Register to read
  * @data:	Value to write
@@ -118,7 +118,7 @@ EXPORT_SYMBOL_GPL(tc3589x_block_write);
  * @tc3589x:	Device to write to
  * @reg:	Register to write
  * @mask:	Mask of bits to set
- * @values:	Value to set
+ * @val:	Value to set
  */
 int tc3589x_set_bits(struct tc3589x *tc3589x, u8 reg, u8 mask, u8 val)
 {

commit 9bd09f345e62257958342f712efef644494274fb
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 27 15:55:20 2015 -0500

    mfd: Kill off set_irq_flags usage
    
    set_irq_flags is ARM specific with custom flags which have genirq
    equivalents. Convert drivers to use the genirq interfaces directly, so we
    can kill off set_irq_flags. The translation of flags is as follows:
    
    IRQF_VALID -> !IRQ_NOREQUEST
    IRQF_PROBE -> !IRQ_NOPROBE
    IRQF_NOAUTOEN -> IRQ_NOAUTOEN
    
    For IRQs managed by an irqdomain, the irqdomain core code handles clearing
    and setting IRQ_NOREQUEST already, so there is no need to do this in
    .map() functions and we can simply remove the set_irq_flags calls. Some
    users also modify IRQ_NOPROBE and this has been maintained although it
    is not clear that is really needed. There appears to be a great deal of
    blind copy and paste of this code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 27e157908ce0..274bf39968aa 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -215,20 +215,13 @@ static int tc3589x_irq_map(struct irq_domain *d, unsigned int virq,
 	irq_set_chip_and_handler(virq, &dummy_irq_chip,
 				handle_edge_irq);
 	irq_set_nested_thread(virq, 1);
-#ifdef CONFIG_ARM
-	set_irq_flags(virq, IRQF_VALID);
-#else
 	irq_set_noprobe(virq);
-#endif
 
 	return 0;
 }
 
 static void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)
 {
-#ifdef CONFIG_ARM
-	set_irq_flags(virq, 0);
-#endif
 	irq_set_chip_and_handler(virq, NULL, NULL);
 	irq_set_chip_data(virq, NULL);
 }

commit 0e777366fb0eba6facc44f0604fe6adbaf21d604
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jul 10 14:05:40 2015 +0900

    mfd: Drop owner assignment from i2c_drivers
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 96d420dfc15d..27e157908ce0 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -492,7 +492,6 @@ MODULE_DEVICE_TABLE(i2c, tc3589x_id);
 static struct i2c_driver tc3589x_driver = {
 	.driver = {
 		.name	= "tc3589x",
-		.owner	= THIS_MODULE,
 		.pm	= &tc3589x_dev_pm_ops,
 		.of_match_table = of_match_ptr(tc3589x_match),
 	},

commit 7ce7b26f84cfcbcb04f526f56f685a56ccddf355
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Mon Apr 27 21:54:13 2015 +0900

    mfd: Constify regmap and irq configuration data
    
    Constify in various drivers configuration data which is not modified:
     - regmap_irq_chip,
     - individual regmap_irq's in array,
     - regmap_config,
     - irq_domain_ops,
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index cf356395c9e9..96d420dfc15d 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -233,7 +233,7 @@ static void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)
 	irq_set_chip_data(virq, NULL);
 }
 
-static struct irq_domain_ops tc3589x_irq_ops = {
+static const struct irq_domain_ops tc3589x_irq_ops = {
 	.map    = tc3589x_irq_map,
 	.unmap  = tc3589x_irq_unmap,
 	.xlate  = irq_domain_xlate_onecell,

commit 1422731dbc14063fc7083cb090108c0d95267361
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 19 15:52:45 2015 +0100

    mfd: tc3589x: Enforce device-tree only mode
    
    All systems using the TC3589x multifunction expander uses
    devicetree, so don't clutter the place with a lot of
    and assume it is there.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index aacb3720065c..cf356395c9e9 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -318,7 +318,6 @@ static int tc3589x_device_init(struct tc3589x *tc3589x)
 	return ret;
 }
 
-#ifdef CONFIG_OF
 static const struct of_device_id tc3589x_match[] = {
 	/* Legacy compatible string */
 	{ .compatible = "tc3589x", .data = (void *) TC3589X_UNKNOWN },
@@ -359,14 +358,6 @@ tc3589x_of_probe(struct device *dev, enum tc3589x_version *version)
 
 	return pdata;
 }
-#else
-static inline struct tc3589x_platform_data *
-tc3589x_of_probe(struct device *dev, enum tc3589x_version *version)
-{
-	dev_err(dev, "no device tree support\n");
-	return ERR_PTR(-ENODEV);
-}
-#endif
 
 static int tc3589x_probe(struct i2c_client *i2c,
 				   const struct i2c_device_id *id)

commit 90f2d0f7bf069b1a2798156b7dcc8e7d1e874406
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Oct 28 11:06:56 2014 +0100

    mfd: tc3589x: get rid of static base
    
    The TC3589x driver is now a device tree-only driver, so we want
    only dynamic IRQs and GPIO numbers from the tc3589x, no static
    assignments.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 0072e668c208..aacb3720065c 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -241,10 +241,8 @@ static struct irq_domain_ops tc3589x_irq_ops = {
 
 static int tc3589x_irq_init(struct tc3589x *tc3589x, struct device_node *np)
 {
-	int base = tc3589x->irq_base;
-
 	tc3589x->domain = irq_domain_add_simple(
-		np, TC3589x_NR_INTERNAL_IRQS, base,
+		np, TC3589x_NR_INTERNAL_IRQS, 0,
 		&tc3589x_irq_ops, tc3589x);
 
 	if (!tc3589x->domain) {
@@ -298,7 +296,7 @@ static int tc3589x_device_init(struct tc3589x *tc3589x)
 	if (blocks & TC3589x_BLOCK_GPIO) {
 		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_gpio,
 				      ARRAY_SIZE(tc3589x_dev_gpio), NULL,
-				      tc3589x->irq_base, tc3589x->domain);
+				      0, tc3589x->domain);
 		if (ret) {
 			dev_err(tc3589x->dev, "failed to add gpio child\n");
 			return ret;
@@ -309,7 +307,7 @@ static int tc3589x_device_init(struct tc3589x *tc3589x)
 	if (blocks & TC3589x_BLOCK_KEYPAD) {
 		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_keypad,
 				      ARRAY_SIZE(tc3589x_dev_keypad), NULL,
-				      tc3589x->irq_base, tc3589x->domain);
+				      0, tc3589x->domain);
 		if (ret) {
 			dev_err(tc3589x->dev, "failed to keypad child\n");
 			return ret;
@@ -404,7 +402,6 @@ static int tc3589x_probe(struct i2c_client *i2c,
 	tc3589x->dev = &i2c->dev;
 	tc3589x->i2c = i2c;
 	tc3589x->pdata = pdata;
-	tc3589x->irq_base = pdata->irq_base;
 
 	switch (version) {
 	case TC3589X_TC35893:

commit 627918ed1278c7274c29340779fff958afa2c3a5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jun 10 14:31:32 2014 +0200

    mfd: tc3589x: Translate onecell, not twocell
    
    Something changed in the OF parser in the v3.16 merge window
    making it be strict about passing the number of IRQ cells
    correctly and disturbing the irqdomain xlate function guard
    to crash when subdevices try to obtain IRQs like this:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at
    /home/linus/linux-stericsson/kernel/irq/irqdomain.c:676
    irq_domain_xlate_twocell+0x40/0x48()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted
     3.15.0-07915-gf6d059821ce9-dirty #46
    [<c0014660>] (unwind_backtrace)
     from [<c0011424>] (show_stack+0x10/0x14)
    [<c0011424>] (show_stack)
     from [<c0432630>] (dump_stack+0x9c/0xd4)
    [<c0432630>] (dump_stack)
     from [<c001d5c0>] (warn_slowpath_common+0x6c/0x88)
    [<c001d5c0>] (warn_slowpath_common)
     from [<c001d678>] (warn_slowpath_null+0x1c/0x24)
    [<c001d678>] (warn_slowpath_null)
     from [<c005acd0>] (irq_domain_xlate_twocell+0x40/0x48)
    [<c005acd0>] (irq_domain_xlate_twocell)
     from [<c005b658>] (irq_create_of_mapping+0x64/0x110)
    [<c005b658>] (irq_create_of_mapping)
     from [<c02e147c>] (of_irq_get+0x38/0x48)
    [<c02e147c>] (of_irq_get)
     from [<c01f8910>] (tc3589x_gpio_probe+0x38/0x1e4)
    [<c01f8910>] (tc3589x_gpio_probe)
     from [<c022eedc>] (platform_drv_probe+0x18/0x48)
    [<c022eedc>] (platform_drv_probe)
     from [<c022d80c>] (driver_probe_device+0x118/0x24c)
    [<c022d80c>] (driver_probe_device)
     from [<c022bf20>] (bus_for_each_drv+0x58/0x8c)
    [<c022bf20>] (bus_for_each_drv)
     from [<c022d6c4>] (device_attach+0x74/0x88)
    [<c022d6c4>] (device_attach)
     from [<c022cdac>] (bus_probe_device+0x84/0xa8)
    [<c022cdac>] (bus_probe_device)
     from [<c022b35c>] (device_add+0x440/0x520)
    [<c022b35c>] (device_add)
     from [<c022ec50>] (platform_device_add+0xb4/0x218)
    [<c022ec50>] (platform_device_add)
     from [<c0243508>] (mfd_add_device+0x220/0x31c)
    [<c0243508>] (mfd_add_device)
     from [<c02436a8>] (mfd_add_devices+0xa4/0x100)
    [<c02436a8>] (mfd_add_devices)
     from [<c024312c>] (tc3589x_probe+0x334/0x3c0)
    [<c024312c>] (tc3589x_probe)
     from [<c022d80c>] (driver_probe_device+0x118/0x24c)
    
    The TC3589x device trees specify the MFD core device
    as having one interrupt cell (cannot specify flags) so the
    twocell translation function is clearly wrong, changing it to
    onecell, as it should be, fixes the regression.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index bd83accc0f6d..0072e668c208 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -236,7 +236,7 @@ static void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)
 static struct irq_domain_ops tc3589x_irq_ops = {
 	.map    = tc3589x_irq_map,
 	.unmap  = tc3589x_irq_unmap,
-	.xlate  = irq_domain_xlate_twocell,
+	.xlate  = irq_domain_xlate_onecell,
 };
 
 static int tc3589x_irq_init(struct tc3589x *tc3589x, struct device_node *np)

commit a381b13e2aa064122325de9deaec51d6e4765ad7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Jan 23 13:43:28 2014 +0100

    mfd: tc3589x: Reform device tree probing
    
    This changes the following mechanisms in the TC3589x device tree
    probing path:
    
    - Use the .of_match_table in struct device_driver to match the
      device in the device tree.
    - Add matches for the proper compatible strings "toshiba,..."
      and all sub-variants, just as is done for the .id matches.
    - Move over all the allocation of platform data etc to the
      tc3589x_of_probe() function and follow the pattern of passing
      a platform data pointer back, or an error pointer on error,
      as found in the STMPE driver.
    - Match the new (proper) compatible strings for the GPIO and
      keypad MFD cells.
    - Use of_device_is_compatible() rather than just !strcmp()
      to discover which cells to instantiate.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 2cf636c267d9..bd83accc0f6d 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -13,8 +13,10 @@
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/mfd/core.h>
 #include <linux/mfd/tc3589x.h>
+#include <linux/err.h>
 
 /**
  * enum tc3589x_version - indicates the TC3589x version
@@ -160,7 +162,7 @@ static const struct mfd_cell tc3589x_dev_gpio[] = {
 		.name		= "tc3589x-gpio",
 		.num_resources	= ARRAY_SIZE(gpio_resources),
 		.resources	= &gpio_resources[0],
-		.of_compatible	= "tc3589x-gpio",
+		.of_compatible	= "toshiba,tc3589x-gpio",
 	},
 };
 
@@ -169,7 +171,7 @@ static const struct mfd_cell tc3589x_dev_keypad[] = {
 		.name           = "tc3589x-keypad",
 		.num_resources  = ARRAY_SIZE(keypad_resources),
 		.resources      = &keypad_resources[0],
-		.of_compatible	= "tc3589x-keypad",
+		.of_compatible	= "toshiba,tc3589x-keypad",
 	},
 };
 
@@ -318,45 +320,74 @@ static int tc3589x_device_init(struct tc3589x *tc3589x)
 	return ret;
 }
 
-static int tc3589x_of_probe(struct device_node *np,
-			struct tc3589x_platform_data *pdata)
+#ifdef CONFIG_OF
+static const struct of_device_id tc3589x_match[] = {
+	/* Legacy compatible string */
+	{ .compatible = "tc3589x", .data = (void *) TC3589X_UNKNOWN },
+	{ .compatible = "toshiba,tc35890", .data = (void *) TC3589X_TC35890 },
+	{ .compatible = "toshiba,tc35892", .data = (void *) TC3589X_TC35892 },
+	{ .compatible = "toshiba,tc35893", .data = (void *) TC3589X_TC35893 },
+	{ .compatible = "toshiba,tc35894", .data = (void *) TC3589X_TC35894 },
+	{ .compatible = "toshiba,tc35895", .data = (void *) TC3589X_TC35895 },
+	{ .compatible = "toshiba,tc35896", .data = (void *) TC3589X_TC35896 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, tc3589x_match);
+
+static struct tc3589x_platform_data *
+tc3589x_of_probe(struct device *dev, enum tc3589x_version *version)
 {
+	struct device_node *np = dev->of_node;
+	struct tc3589x_platform_data *pdata;
 	struct device_node *child;
+	const struct of_device_id *of_id;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	of_id = of_match_device(tc3589x_match, dev);
+	if (!of_id)
+		return ERR_PTR(-ENODEV);
+	*version = (enum tc3589x_version) of_id->data;
 
 	for_each_child_of_node(np, child) {
-		if (!strcmp(child->name, "tc3589x_gpio")) {
+		if (of_device_is_compatible(child, "toshiba,tc3589x-gpio"))
 			pdata->block |= TC3589x_BLOCK_GPIO;
-		}
-		if (!strcmp(child->name, "tc3589x_keypad")) {
+		if (of_device_is_compatible(child, "toshiba,tc3589x-keypad"))
 			pdata->block |= TC3589x_BLOCK_KEYPAD;
-		}
 	}
 
-	return 0;
+	return pdata;
 }
+#else
+static inline struct tc3589x_platform_data *
+tc3589x_of_probe(struct device *dev, enum tc3589x_version *version)
+{
+	dev_err(dev, "no device tree support\n");
+	return ERR_PTR(-ENODEV);
+}
+#endif
 
 static int tc3589x_probe(struct i2c_client *i2c,
 				   const struct i2c_device_id *id)
 {
-	struct tc3589x_platform_data *pdata = dev_get_platdata(&i2c->dev);
 	struct device_node *np = i2c->dev.of_node;
+	struct tc3589x_platform_data *pdata = dev_get_platdata(&i2c->dev);
 	struct tc3589x *tc3589x;
+	enum tc3589x_version version;
 	int ret;
 
 	if (!pdata) {
-		if (np) {
-			pdata = devm_kzalloc(&i2c->dev, sizeof(*pdata), GFP_KERNEL);
-			if (!pdata)
-				return -ENOMEM;
-
-			ret = tc3589x_of_probe(np, pdata);
-			if (ret)
-				return ret;
-		}
-		else {
+		pdata = tc3589x_of_probe(&i2c->dev, &version);
+		if (IS_ERR(pdata)) {
 			dev_err(&i2c->dev, "No platform data or DT found\n");
-			return -EINVAL;
+			return PTR_ERR(pdata);
 		}
+	} else {
+		/* When not probing from device tree we have this ID */
+		version = id->driver_data;
 	}
 
 	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA
@@ -375,7 +406,7 @@ static int tc3589x_probe(struct i2c_client *i2c,
 	tc3589x->pdata = pdata;
 	tc3589x->irq_base = pdata->irq_base;
 
-	switch (id->driver_data) {
+	switch (version) {
 	case TC3589X_TC35893:
 	case TC3589X_TC35895:
 	case TC3589X_TC35896:
@@ -471,9 +502,12 @@ static const struct i2c_device_id tc3589x_id[] = {
 MODULE_DEVICE_TABLE(i2c, tc3589x_id);
 
 static struct i2c_driver tc3589x_driver = {
-	.driver.name	= "tc3589x",
-	.driver.owner	= THIS_MODULE,
-	.driver.pm	= &tc3589x_dev_pm_ops,
+	.driver = {
+		.name	= "tc3589x",
+		.owner	= THIS_MODULE,
+		.pm	= &tc3589x_dev_pm_ops,
+		.of_match_table = of_match_ptr(tc3589x_match),
+	},
 	.probe		= tc3589x_probe,
 	.remove		= tc3589x_remove,
 	.id_table	= tc3589x_id,

commit afb580a944ce9fe8c31f96623ded7bb4b87412d3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Nov 18 14:33:03 2013 +0100

    mfd: toshiba: Constify struct mfd_cell where possible
    
    As of commit 03e361b25ee8dfb1fd9b890072c23c4aae01c6c7 ("mfd: Stop setting
    refcounting pointers in original mfd_cell arrays"), the "cell" parameter of
    mfd_add_devices() is "const" again. Hence make all cell data passed to
    mfd_add_devices() const where possible.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 87ea51dc6234..2cf636c267d9 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -155,7 +155,7 @@ static struct resource keypad_resources[] = {
 	},
 };
 
-static struct mfd_cell tc3589x_dev_gpio[] = {
+static const struct mfd_cell tc3589x_dev_gpio[] = {
 	{
 		.name		= "tc3589x-gpio",
 		.num_resources	= ARRAY_SIZE(gpio_resources),
@@ -164,7 +164,7 @@ static struct mfd_cell tc3589x_dev_gpio[] = {
 	},
 };
 
-static struct mfd_cell tc3589x_dev_keypad[] = {
+static const struct mfd_cell tc3589x_dev_keypad[] = {
 	{
 		.name           = "tc3589x-keypad",
 		.num_resources  = ARRAY_SIZE(keypad_resources),

commit e64c1eb47352d62f5bb06284bae72261d934faa8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Oct 18 11:51:45 2013 +0200

    mfd: tc3589x: Detect the precise version
    
    Instead of detecting the "tc3589x" and hard-coding the number of
    GPIO pins to 24, encode all the possible subtypes and set the
    number of GPIO pins from the type.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 70f4909fee13..87ea51dc6234 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -16,6 +16,19 @@
 #include <linux/mfd/core.h>
 #include <linux/mfd/tc3589x.h>
 
+/**
+ * enum tc3589x_version - indicates the TC3589x version
+ */
+enum tc3589x_version {
+	TC3589X_TC35890,
+	TC3589X_TC35892,
+	TC3589X_TC35893,
+	TC3589X_TC35894,
+	TC3589X_TC35895,
+	TC3589X_TC35896,
+	TC3589X_UNKNOWN,
+};
+
 #define TC3589x_CLKMODE_MODCTL_SLEEP		0x0
 #define TC3589x_CLKMODE_MODCTL_OPERATION	(1 << 0)
 
@@ -361,7 +374,21 @@ static int tc3589x_probe(struct i2c_client *i2c,
 	tc3589x->i2c = i2c;
 	tc3589x->pdata = pdata;
 	tc3589x->irq_base = pdata->irq_base;
-	tc3589x->num_gpio = id->driver_data;
+
+	switch (id->driver_data) {
+	case TC3589X_TC35893:
+	case TC3589X_TC35895:
+	case TC3589X_TC35896:
+		tc3589x->num_gpio = 20;
+		break;
+	case TC3589X_TC35890:
+	case TC3589X_TC35892:
+	case TC3589X_TC35894:
+	case TC3589X_UNKNOWN:
+	default:
+		tc3589x->num_gpio = 24;
+		break;
+	}
 
 	i2c_set_clientdata(i2c, tc3589x);
 
@@ -432,7 +459,13 @@ static int tc3589x_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(tc3589x_dev_pm_ops, tc3589x_suspend, tc3589x_resume);
 
 static const struct i2c_device_id tc3589x_id[] = {
-	{ "tc3589x", 24 },
+	{ "tc35890", TC3589X_TC35890 },
+	{ "tc35892", TC3589X_TC35892 },
+	{ "tc35893", TC3589X_TC35893 },
+	{ "tc35894", TC3589X_TC35894 },
+	{ "tc35895", TC3589X_TC35895 },
+	{ "tc35896", TC3589X_TC35896 },
+	{ "tc3589x", TC3589X_UNKNOWN },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, tc3589x_id);

commit 334a41ce9b753ec615e8c6c50ee07d6197190610
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:10:05 2013 +0900

    mfd: Use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 4cb92bb2aea2..70f4909fee13 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -325,7 +325,7 @@ static int tc3589x_of_probe(struct device_node *np,
 static int tc3589x_probe(struct i2c_client *i2c,
 				   const struct i2c_device_id *id)
 {
-	struct tc3589x_platform_data *pdata = i2c->dev.platform_data;
+	struct tc3589x_platform_data *pdata = dev_get_platdata(&i2c->dev);
 	struct device_node *np = i2c->dev.of_node;
 	struct tc3589x *tc3589x;
 	int ret;

commit 1383e00f79a7bd6333083a12b43481b6bf2bdcb4
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed Feb 20 18:31:52 2013 +0900

    mfd: tc3589x: Use devm_*() functions
    
    Use devm_*() functions to make cleanup paths more simple.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index ecc092c7f745..4cb92bb2aea2 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -350,7 +350,8 @@ static int tc3589x_probe(struct i2c_client *i2c,
 				     | I2C_FUNC_SMBUS_I2C_BLOCK))
 		return -EIO;
 
-	tc3589x = kzalloc(sizeof(struct tc3589x), GFP_KERNEL);
+	tc3589x = devm_kzalloc(&i2c->dev, sizeof(struct tc3589x),
+				GFP_KERNEL);
 	if (!tc3589x)
 		return -ENOMEM;
 
@@ -366,33 +367,27 @@ static int tc3589x_probe(struct i2c_client *i2c,
 
 	ret = tc3589x_chip_init(tc3589x);
 	if (ret)
-		goto out_free;
+		return ret;
 
 	ret = tc3589x_irq_init(tc3589x, np);
 	if (ret)
-		goto out_free;
+		return ret;
 
 	ret = request_threaded_irq(tc3589x->i2c->irq, NULL, tc3589x_irq,
 				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 				   "tc3589x", tc3589x);
 	if (ret) {
 		dev_err(tc3589x->dev, "failed to request IRQ: %d\n", ret);
-		goto out_free;
+		return ret;
 	}
 
 	ret = tc3589x_device_init(tc3589x);
 	if (ret) {
 		dev_err(tc3589x->dev, "failed to add child devices\n");
-		goto out_freeirq;
+		return ret;
 	}
 
 	return 0;
-
-out_freeirq:
-	free_irq(tc3589x->i2c->irq, tc3589x);
-out_free:
-	kfree(tc3589x);
-	return ret;
 }
 
 static int tc3589x_remove(struct i2c_client *client)
@@ -401,10 +396,6 @@ static int tc3589x_remove(struct i2c_client *client)
 
 	mfd_remove_devices(tc3589x->dev);
 
-	free_irq(tc3589x->i2c->irq, tc3589x);
-
-	kfree(tc3589x);
-
 	return 0;
 }
 

commit 1f0529b4d80ad02df637be67ed4f82e93b8db32f
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Wed Jan 2 14:40:14 2013 +0100

    mfd: tc3589x: Use simple irqdomain
    
    This fixes a regression in the TC3589x driver introduced in
    commit 15e27b1088245a2de3b7d09d39cd209212eb16af
    "mfd: Provide the tc3589x with its own IRQ domain"
    
    If a system with a TC3589x expander is booted and a base
    IRQ is passed from platform data, a legacy domain will
    be used. However, since the Ux500 is now switched to use
    SPARSE_IRQ, no descriptors get allocated on-the-fly,
    and we get a crash.
    
    Fix this by switching to using the simple irqdomain that
    will handle this uniformly and also allocates descriptors
    explicitly.
    
    Also fix two small whitespace errors in the vicinity while
    we're at it.
    
    Cc: stable@kernel.org
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index a06d66b929b1..ecc092c7f745 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -219,25 +219,18 @@ static void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)
 }
 
 static struct irq_domain_ops tc3589x_irq_ops = {
-        .map    = tc3589x_irq_map,
+	.map    = tc3589x_irq_map,
 	.unmap  = tc3589x_irq_unmap,
-        .xlate  = irq_domain_xlate_twocell,
+	.xlate  = irq_domain_xlate_twocell,
 };
 
 static int tc3589x_irq_init(struct tc3589x *tc3589x, struct device_node *np)
 {
 	int base = tc3589x->irq_base;
 
-	if (base) {
-		tc3589x->domain = irq_domain_add_legacy(
-			NULL, TC3589x_NR_INTERNAL_IRQS, base,
-			0, &tc3589x_irq_ops, tc3589x);
-	}
-	else {
-		tc3589x->domain = irq_domain_add_linear(
-			np, TC3589x_NR_INTERNAL_IRQS,
-			&tc3589x_irq_ops, tc3589x);
-	}
+	tc3589x->domain = irq_domain_add_simple(
+		np, TC3589x_NR_INTERNAL_IRQS, base,
+		&tc3589x_irq_ops, tc3589x);
 
 	if (!tc3589x->domain) {
 		dev_err(tc3589x->dev, "Failed to create irqdomain\n");

commit 4740f73fe5388ab5d22d552d2a0dacc62418a70c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:01 2012 -0500

    mfd: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Peter Tyser <ptyser@xes-inc.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: David Brown <davidb@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 7e197f788b0a..a06d66b929b1 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -402,7 +402,7 @@ static int tc3589x_probe(struct i2c_client *i2c,
 	return ret;
 }
 
-static int __devexit tc3589x_remove(struct i2c_client *client)
+static int tc3589x_remove(struct i2c_client *client)
 {
 	struct tc3589x *tc3589x = i2c_get_clientdata(client);
 

commit f791be492f76dea7b0641ed227a60eeb2fa7e255
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:04 2012 -0500

    mfd: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Peter Tyser <ptyser@xes-inc.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: David Brown <davidb@codeaurora.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 553ce956da6d..7e197f788b0a 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -282,7 +282,7 @@ static int tc3589x_chip_init(struct tc3589x *tc3589x)
 	return tc3589x_reg_write(tc3589x, TC3589x_RSTINTCLR, 0x1);
 }
 
-static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
+static int tc3589x_device_init(struct tc3589x *tc3589x)
 {
 	int ret = 0;
 	unsigned int blocks = tc3589x->pdata->block;
@@ -329,7 +329,7 @@ static int tc3589x_of_probe(struct device_node *np,
 	return 0;
 }
 
-static int __devinit tc3589x_probe(struct i2c_client *i2c,
+static int tc3589x_probe(struct i2c_client *i2c,
 				   const struct i2c_device_id *id)
 {
 	struct tc3589x_platform_data *pdata = i2c->dev.platform_data;

commit 84449216b01f9c2b4c9b1882f9d6abba07b7b7ca
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:20:24 2012 -0500

    mfd: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Peter Tyser <ptyser@xes-inc.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: David Brown <davidb@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 8f4c853ca116..553ce956da6d 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -458,7 +458,7 @@ static struct i2c_driver tc3589x_driver = {
 	.driver.owner	= THIS_MODULE,
 	.driver.pm	= &tc3589x_dev_pm_ops,
 	.probe		= tc3589x_probe,
-	.remove		= __devexit_p(tc3589x_remove),
+	.remove		= tc3589x_remove,
 	.id_table	= tc3589x_id,
 };
 

commit a435ae1d51e2f18414f2a87219fdbe068231e692
Author: Lee Jones <lee.jones@linaro.org>
Date:   Fri Sep 7 12:14:57 2012 +0100

    mfd: Enable the tc3589x for Device Tree
    
    Here we provide a means to probe and extract vital information
    from Device Tree when booting with it enabled. Without this
    patch sub-devices wouldn't be able to reference the tc3589x
    from Device Tree.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 2df44acaf907..8f4c853ca116 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -12,6 +12,7 @@
 #include <linux/irqdomain.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
+#include <linux/of.h>
 #include <linux/mfd/core.h>
 #include <linux/mfd/tc3589x.h>
 
@@ -146,6 +147,7 @@ static struct mfd_cell tc3589x_dev_gpio[] = {
 		.name		= "tc3589x-gpio",
 		.num_resources	= ARRAY_SIZE(gpio_resources),
 		.resources	= &gpio_resources[0],
+		.of_compatible	= "tc3589x-gpio",
 	},
 };
 
@@ -154,6 +156,7 @@ static struct mfd_cell tc3589x_dev_keypad[] = {
 		.name           = "tc3589x-keypad",
 		.num_resources  = ARRAY_SIZE(keypad_resources),
 		.resources      = &keypad_resources[0],
+		.of_compatible	= "tc3589x-keypad",
 	},
 };
 
@@ -221,7 +224,7 @@ static struct irq_domain_ops tc3589x_irq_ops = {
         .xlate  = irq_domain_xlate_twocell,
 };
 
-static int tc3589x_irq_init(struct tc3589x *tc3589x)
+static int tc3589x_irq_init(struct tc3589x *tc3589x, struct device_node *np)
 {
 	int base = tc3589x->irq_base;
 
@@ -232,7 +235,7 @@ static int tc3589x_irq_init(struct tc3589x *tc3589x)
 	}
 	else {
 		tc3589x->domain = irq_domain_add_linear(
-			NULL, TC3589x_NR_INTERNAL_IRQS,
+			np, TC3589x_NR_INTERNAL_IRQS,
 			&tc3589x_irq_ops, tc3589x);
 	}
 
@@ -309,13 +312,47 @@ static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
 	return ret;
 }
 
+static int tc3589x_of_probe(struct device_node *np,
+			struct tc3589x_platform_data *pdata)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(np, child) {
+		if (!strcmp(child->name, "tc3589x_gpio")) {
+			pdata->block |= TC3589x_BLOCK_GPIO;
+		}
+		if (!strcmp(child->name, "tc3589x_keypad")) {
+			pdata->block |= TC3589x_BLOCK_KEYPAD;
+		}
+	}
+
+	return 0;
+}
+
 static int __devinit tc3589x_probe(struct i2c_client *i2c,
 				   const struct i2c_device_id *id)
 {
 	struct tc3589x_platform_data *pdata = i2c->dev.platform_data;
+	struct device_node *np = i2c->dev.of_node;
 	struct tc3589x *tc3589x;
 	int ret;
 
+	if (!pdata) {
+		if (np) {
+			pdata = devm_kzalloc(&i2c->dev, sizeof(*pdata), GFP_KERNEL);
+			if (!pdata)
+				return -ENOMEM;
+
+			ret = tc3589x_of_probe(np, pdata);
+			if (ret)
+				return ret;
+		}
+		else {
+			dev_err(&i2c->dev, "No platform data or DT found\n");
+			return -EINVAL;
+		}
+	}
+
 	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA
 				     | I2C_FUNC_SMBUS_I2C_BLOCK))
 		return -EIO;
@@ -338,7 +375,7 @@ static int __devinit tc3589x_probe(struct i2c_client *i2c,
 	if (ret)
 		goto out_free;
 
-	ret = tc3589x_irq_init(tc3589x);
+	ret = tc3589x_irq_init(tc3589x, np);
 	if (ret)
 		goto out_free;
 

commit 15e27b1088245a2de3b7d09d39cd209212eb16af
Author: Lee Jones <lee.jones@linaro.org>
Date:   Fri Sep 7 12:14:56 2012 +0100

    mfd: Provide the tc3589x with its own IRQ domain
    
    In preparation for Device Tree enablement all IRQ controllers
    should control their own IRQ domain. This patch provides just
    that.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index b56ba6b43294..2df44acaf907 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/irqdomain.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/mfd/core.h>
@@ -168,8 +169,9 @@ static irqreturn_t tc3589x_irq(int irq, void *data)
 
 	while (status) {
 		int bit = __ffs(status);
+		int virq = irq_create_mapping(tc3589x->domain, bit);
 
-		handle_nested_irq(tc3589x->irq_base + bit);
+		handle_nested_irq(virq);
 		status &= ~(1 << bit);
 	}
 
@@ -186,38 +188,60 @@ static irqreturn_t tc3589x_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static int tc3589x_irq_init(struct tc3589x *tc3589x)
+static int tc3589x_irq_map(struct irq_domain *d, unsigned int virq,
+				irq_hw_number_t hwirq)
 {
-	int base = tc3589x->irq_base;
-	int irq;
+	struct tc3589x *tc3589x = d->host_data;
 
-	for (irq = base; irq < base + TC3589x_NR_INTERNAL_IRQS; irq++) {
-		irq_set_chip_data(irq, tc3589x);
-		irq_set_chip_and_handler(irq, &dummy_irq_chip,
-					 handle_edge_irq);
-		irq_set_nested_thread(irq, 1);
+	irq_set_chip_data(virq, tc3589x);
+	irq_set_chip_and_handler(virq, &dummy_irq_chip,
+				handle_edge_irq);
+	irq_set_nested_thread(virq, 1);
 #ifdef CONFIG_ARM
-		set_irq_flags(irq, IRQF_VALID);
+	set_irq_flags(virq, IRQF_VALID);
 #else
-		irq_set_noprobe(irq);
+	irq_set_noprobe(virq);
 #endif
-	}
 
 	return 0;
 }
 
-static void tc3589x_irq_remove(struct tc3589x *tc3589x)
+static void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)
 {
-	int base = tc3589x->irq_base;
-	int irq;
-
-	for (irq = base; irq < base + TC3589x_NR_INTERNAL_IRQS; irq++) {
 #ifdef CONFIG_ARM
-		set_irq_flags(irq, 0);
+	set_irq_flags(virq, 0);
 #endif
-		irq_set_chip_and_handler(irq, NULL, NULL);
-		irq_set_chip_data(irq, NULL);
+	irq_set_chip_and_handler(virq, NULL, NULL);
+	irq_set_chip_data(virq, NULL);
+}
+
+static struct irq_domain_ops tc3589x_irq_ops = {
+        .map    = tc3589x_irq_map,
+	.unmap  = tc3589x_irq_unmap,
+        .xlate  = irq_domain_xlate_twocell,
+};
+
+static int tc3589x_irq_init(struct tc3589x *tc3589x)
+{
+	int base = tc3589x->irq_base;
+
+	if (base) {
+		tc3589x->domain = irq_domain_add_legacy(
+			NULL, TC3589x_NR_INTERNAL_IRQS, base,
+			0, &tc3589x_irq_ops, tc3589x);
 	}
+	else {
+		tc3589x->domain = irq_domain_add_linear(
+			NULL, TC3589x_NR_INTERNAL_IRQS,
+			&tc3589x_irq_ops, tc3589x);
+	}
+
+	if (!tc3589x->domain) {
+		dev_err(tc3589x->dev, "Failed to create irqdomain\n");
+		return -ENOSYS;
+	}
+
+	return 0;
 }
 
 static int tc3589x_chip_init(struct tc3589x *tc3589x)
@@ -263,7 +287,7 @@ static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
 	if (blocks & TC3589x_BLOCK_GPIO) {
 		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_gpio,
 				      ARRAY_SIZE(tc3589x_dev_gpio), NULL,
-				      tc3589x->irq_base, NULL);
+				      tc3589x->irq_base, tc3589x->domain);
 		if (ret) {
 			dev_err(tc3589x->dev, "failed to add gpio child\n");
 			return ret;
@@ -274,7 +298,7 @@ static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
 	if (blocks & TC3589x_BLOCK_KEYPAD) {
 		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_keypad,
 				      ARRAY_SIZE(tc3589x_dev_keypad), NULL,
-				      tc3589x->irq_base, NULL);
+				      tc3589x->irq_base, tc3589x->domain);
 		if (ret) {
 			dev_err(tc3589x->dev, "failed to keypad child\n");
 			return ret;
@@ -323,7 +347,7 @@ static int __devinit tc3589x_probe(struct i2c_client *i2c,
 				   "tc3589x", tc3589x);
 	if (ret) {
 		dev_err(tc3589x->dev, "failed to request IRQ: %d\n", ret);
-		goto out_removeirq;
+		goto out_free;
 	}
 
 	ret = tc3589x_device_init(tc3589x);
@@ -336,8 +360,6 @@ static int __devinit tc3589x_probe(struct i2c_client *i2c,
 
 out_freeirq:
 	free_irq(tc3589x->i2c->irq, tc3589x);
-out_removeirq:
-	tc3589x_irq_remove(tc3589x);
 out_free:
 	kfree(tc3589x);
 	return ret;
@@ -350,7 +372,6 @@ static int __devexit tc3589x_remove(struct i2c_client *client)
 	mfd_remove_devices(tc3589x->dev);
 
 	free_irq(tc3589x->i2c->irq, tc3589x);
-	tc3589x_irq_remove(tc3589x);
 
 	kfree(tc3589x);
 

commit 55692af5eb587f7592d6c2713e1e0eeaab0f6c31
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 11 15:16:36 2012 +0800

    mfd: core: Push irqdomain mapping out into devices
    
    Currently the MFD core supports remapping MFD cell interrupts using an
    irqdomain but only if the MFD is being instantiated using device tree
    and only if the device tree bindings use the pattern of registering IPs
    in the device tree with compatible properties.  This will be actively
    harmful for drivers which support non-DT platforms and use this pattern
    for their DT bindings as it will mean that the core will silently change
    remapping behaviour and it is also limiting for drivers which don't do
    DT with this particular pattern.  There is also a potential fragility if
    there are interrupts not associated with MFD cells and all the cells are
    omitted from the device tree for some reason.
    
    Instead change the code to take an IRQ domain as an optional argument,
    allowing drivers to take the decision about the parent domain for their
    interrupts.  The one current user of this feature is ab8500-core, it has
    the domain lookup pushed out into the driver.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 048bf0532a09..b56ba6b43294 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -262,8 +262,8 @@ static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
 
 	if (blocks & TC3589x_BLOCK_GPIO) {
 		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_gpio,
-				ARRAY_SIZE(tc3589x_dev_gpio), NULL,
-				tc3589x->irq_base);
+				      ARRAY_SIZE(tc3589x_dev_gpio), NULL,
+				      tc3589x->irq_base, NULL);
 		if (ret) {
 			dev_err(tc3589x->dev, "failed to add gpio child\n");
 			return ret;
@@ -273,8 +273,8 @@ static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
 
 	if (blocks & TC3589x_BLOCK_KEYPAD) {
 		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_keypad,
-				ARRAY_SIZE(tc3589x_dev_keypad), NULL,
-				tc3589x->irq_base);
+				      ARRAY_SIZE(tc3589x_dev_keypad), NULL,
+				      tc3589x->irq_base, NULL);
 		if (ret) {
 			dev_err(tc3589x->dev, "failed to keypad child\n");
 			return ret;

commit 930bf02299943c67a52919a23a3eaf5ee9abbbe1
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Jul 2 17:19:52 2012 +0800

    mfd: Guard tc3589x PM methods with CONFIG_PM_SLEEP
    
    Guard PM methods with CONFIG_PM_SLEEP and get rid of some unneeded #ifdefs.
    This fixes below build warnings:
    
      CC      drivers/mfd/tc3589x.o
    drivers/mfd/tc3589x.c:361:12: warning: 'tc3589x_suspend' defined but not used [-Wunused-function]
    drivers/mfd/tc3589x.c:375:12: warning: 'tc3589x_resume' defined but not used [-Wunused-function]
    
    SIMPLE_DEV_PM_OPS already defines constant dev_pm_ops, thus also fix
    'duplicate const' sparse warning.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index de979742c6fc..048bf0532a09 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -357,7 +357,7 @@ static int __devexit tc3589x_remove(struct i2c_client *client)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int tc3589x_suspend(struct device *dev)
 {
 	struct tc3589x *tc3589x = dev_get_drvdata(dev);
@@ -385,11 +385,10 @@ static int tc3589x_resume(struct device *dev)
 
 	return ret;
 }
-
-static const SIMPLE_DEV_PM_OPS(tc3589x_dev_pm_ops, tc3589x_suspend,
-						tc3589x_resume);
 #endif
 
+static SIMPLE_DEV_PM_OPS(tc3589x_dev_pm_ops, tc3589x_suspend, tc3589x_resume);
+
 static const struct i2c_device_id tc3589x_id[] = {
 	{ "tc3589x", 24 },
 	{ }
@@ -399,9 +398,7 @@ MODULE_DEVICE_TABLE(i2c, tc3589x_id);
 static struct i2c_driver tc3589x_driver = {
 	.driver.name	= "tc3589x",
 	.driver.owner	= THIS_MODULE,
-#ifdef CONFIG_PM
 	.driver.pm	= &tc3589x_dev_pm_ops,
-#endif
 	.probe		= tc3589x_probe,
 	.remove		= __devexit_p(tc3589x_remove),
 	.id_table	= tc3589x_id,

commit 54d8e2c323b439e0e20ea44d17b875d9a43f7d66
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Aug 9 20:37:17 2011 +0200

    mfd: Add missing #ifdef around tc3589x PM block
    
    The CONFIG_PM code was unconditionally compiled in despite
    the dev_pm_ops only being included into the driver struct
    if used. Fix this by adding the missing #ifdef.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index c27e515b0722..de979742c6fc 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -357,6 +357,7 @@ static int __devexit tc3589x_remove(struct i2c_client *client)
 	return 0;
 }
 
+#ifdef CONFIG_PM
 static int tc3589x_suspend(struct device *dev)
 {
 	struct tc3589x *tc3589x = dev_get_drvdata(dev);
@@ -387,6 +388,7 @@ static int tc3589x_resume(struct device *dev)
 
 static const SIMPLE_DEV_PM_OPS(tc3589x_dev_pm_ops, tc3589x_suspend,
 						tc3589x_resume);
+#endif
 
 static const struct i2c_device_id tc3589x_id[] = {
 	{ "tc3589x", 24 },

commit d5bb122165981aed327845c32a9916d1b8ae0e4b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 25 11:12:32 2011 +0000

    mfd: Cleanup irq namespace
    
    Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 729dbeed2ce0..c27e515b0722 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -192,14 +192,14 @@ static int tc3589x_irq_init(struct tc3589x *tc3589x)
 	int irq;
 
 	for (irq = base; irq < base + TC3589x_NR_INTERNAL_IRQS; irq++) {
-		set_irq_chip_data(irq, tc3589x);
-		set_irq_chip_and_handler(irq, &dummy_irq_chip,
+		irq_set_chip_data(irq, tc3589x);
+		irq_set_chip_and_handler(irq, &dummy_irq_chip,
 					 handle_edge_irq);
-		set_irq_nested_thread(irq, 1);
+		irq_set_nested_thread(irq, 1);
 #ifdef CONFIG_ARM
 		set_irq_flags(irq, IRQF_VALID);
 #else
-		set_irq_noprobe(irq);
+		irq_set_noprobe(irq);
 #endif
 	}
 
@@ -215,8 +215,8 @@ static void tc3589x_irq_remove(struct tc3589x *tc3589x)
 #ifdef CONFIG_ARM
 		set_irq_flags(irq, 0);
 #endif
-		set_irq_chip_and_handler(irq, NULL, NULL);
-		set_irq_chip_data(irq, NULL);
+		irq_set_chip_and_handler(irq, NULL, NULL);
+		irq_set_chip_data(irq, NULL);
 	}
 }
 

commit 09c730a488c32c2cadb31cdb8dcc4df528441197
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Tue Dec 21 15:53:31 2010 +0530

    input/tc3589x: add tc3589x keypad support
    
    Add support for the keypad controller module found on the
    TC3589X devices. This driver default adds the support for
    TC35893 device.
    
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    [Some minor fixups for compilation]
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 112efd3c4940..729dbeed2ce0 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -132,6 +132,14 @@ static struct resource gpio_resources[] = {
 	},
 };
 
+static struct resource keypad_resources[] = {
+	{
+		.start  = TC3589x_INT_KBDIRQ,
+		.end    = TC3589x_INT_KBDIRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
 static struct mfd_cell tc3589x_dev_gpio[] = {
 	{
 		.name		= "tc3589x-gpio",
@@ -140,6 +148,14 @@ static struct mfd_cell tc3589x_dev_gpio[] = {
 	},
 };
 
+static struct mfd_cell tc3589x_dev_keypad[] = {
+	{
+		.name           = "tc3589x-keypad",
+		.num_resources  = ARRAY_SIZE(keypad_resources),
+		.resources      = &keypad_resources[0],
+	},
+};
+
 static irqreturn_t tc3589x_irq(int irq, void *data)
 {
 	struct tc3589x *tc3589x = data;
@@ -255,8 +271,18 @@ static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
 		dev_info(tc3589x->dev, "added gpio block\n");
 	}
 
-	return ret;
+	if (blocks & TC3589x_BLOCK_KEYPAD) {
+		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_keypad,
+				ARRAY_SIZE(tc3589x_dev_keypad), NULL,
+				tc3589x->irq_base);
+		if (ret) {
+			dev_err(tc3589x->dev, "failed to keypad child\n");
+			return ret;
+		}
+		dev_info(tc3589x->dev, "added keypad block\n");
+	}
 
+	return ret;
 }
 
 static int __devinit tc3589x_probe(struct i2c_client *i2c,

commit abda3a24a99998279fe890ea8a789ebe4d605d78
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Mon Dec 20 13:01:30 2010 +0100

    mfd: Use dummy_irq_chip for tc3589x
    
    This also converts tc3589x to the new irq API.
    
    Cc: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 32291fe4151c..112efd3c4940 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -170,17 +170,6 @@ static irqreturn_t tc3589x_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static void tc3589x_irq_dummy(unsigned int irq)
-{
-	/* No mask/unmask at this level */
-}
-
-static struct irq_chip tc3589x_irq_chip = {
-	.name	= "tc3589x",
-	.mask	= tc3589x_irq_dummy,
-	.unmask	= tc3589x_irq_dummy,
-};
-
 static int tc3589x_irq_init(struct tc3589x *tc3589x)
 {
 	int base = tc3589x->irq_base;
@@ -188,7 +177,7 @@ static int tc3589x_irq_init(struct tc3589x *tc3589x)
 
 	for (irq = base; irq < base + TC3589x_NR_INTERNAL_IRQS; irq++) {
 		set_irq_chip_data(irq, tc3589x);
-		set_irq_chip_and_handler(irq, &tc3589x_irq_chip,
+		set_irq_chip_and_handler(irq, &dummy_irq_chip,
 					 handle_edge_irq);
 		set_irq_nested_thread(irq, 1);
 #ifdef CONFIG_ARM

commit 593e9d70fb0f1ece1cf2a61c701dec35d8e41f8d
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Mon Dec 13 09:33:18 2010 +0530

    mfd/tc3589x: add suspend/resume support
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index f000d2ed23e0..32291fe4151c 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -14,6 +14,9 @@
 #include <linux/mfd/core.h>
 #include <linux/mfd/tc3589x.h>
 
+#define TC3589x_CLKMODE_MODCTL_SLEEP		0x0
+#define TC3589x_CLKMODE_MODCTL_OPERATION	(1 << 0)
+
 /**
  * tc3589x_reg_read() - read a single TC3589x register
  * @tc3589x:	Device to read from
@@ -339,6 +342,37 @@ static int __devexit tc3589x_remove(struct i2c_client *client)
 	return 0;
 }
 
+static int tc3589x_suspend(struct device *dev)
+{
+	struct tc3589x *tc3589x = dev_get_drvdata(dev);
+	struct i2c_client *client = tc3589x->i2c;
+	int ret = 0;
+
+	/* put the system to sleep mode */
+	if (!device_may_wakeup(&client->dev))
+		ret = tc3589x_reg_write(tc3589x, TC3589x_CLKMODE,
+				TC3589x_CLKMODE_MODCTL_SLEEP);
+
+	return ret;
+}
+
+static int tc3589x_resume(struct device *dev)
+{
+	struct tc3589x *tc3589x = dev_get_drvdata(dev);
+	struct i2c_client *client = tc3589x->i2c;
+	int ret = 0;
+
+	/* enable the system into operation */
+	if (!device_may_wakeup(&client->dev))
+		ret = tc3589x_reg_write(tc3589x, TC3589x_CLKMODE,
+				TC3589x_CLKMODE_MODCTL_OPERATION);
+
+	return ret;
+}
+
+static const SIMPLE_DEV_PM_OPS(tc3589x_dev_pm_ops, tc3589x_suspend,
+						tc3589x_resume);
+
 static const struct i2c_device_id tc3589x_id[] = {
 	{ "tc3589x", 24 },
 	{ }
@@ -348,6 +382,9 @@ MODULE_DEVICE_TABLE(i2c, tc3589x_id);
 static struct i2c_driver tc3589x_driver = {
 	.driver.name	= "tc3589x",
 	.driver.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+	.driver.pm	= &tc3589x_dev_pm_ops,
+#endif
 	.probe		= tc3589x_probe,
 	.remove		= __devexit_p(tc3589x_remove),
 	.id_table	= tc3589x_id,

commit 523bc3820f023169671e9726b8dc075669d14bec
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Mon Dec 13 09:33:17 2010 +0530

    mfd/tc3589x: undo gpio module reset during chip init
    
    Skip putting the GPIO module into a reset during the chip init.  This makes
    sure to preserve any existing GPIO configurations done by pre-kernel boot code.
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 708349a5c0e3..f000d2ed23e0 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -231,12 +231,15 @@ static int tc3589x_chip_init(struct tc3589x *tc3589x)
 
 	dev_info(tc3589x->dev, "manufacturer: %#x, version: %#x\n", manf, ver);
 
-	/* Put everything except the IRQ module into reset */
+	/*
+	 * Put everything except the IRQ module into reset;
+	 * also spare the GPIO module for any pin initialization
+	 * done during pre-kernel boot
+	 */
 	ret = tc3589x_reg_write(tc3589x, TC3589x_RSTCTRL,
 				TC3589x_RSTCTRL_TIMRST
 				| TC3589x_RSTCTRL_ROTRST
-				| TC3589x_RSTCTRL_KBDRST
-				| TC3589x_RSTCTRL_GPIRST);
+				| TC3589x_RSTCTRL_KBDRST);
 	if (ret < 0)
 		return ret;
 

commit bd77efd0cea80865d4cfcc1e4b62789c51a74b2d
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Mon Dec 13 09:33:16 2010 +0530

    mfd/tc3589x: fix random interrupt misses
    
    On the TC35892, a random delayed interrupt clear (GPIO IC) write locks up the
    child interrupts. In such a case, the original interrupt is active and not yet
    acknowledged. Re-check the IRQST bit for any pending interrupts and handle
    those.
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 0ed9669d95fa..708349a5c0e3 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -142,6 +142,7 @@ static irqreturn_t tc3589x_irq(int irq, void *data)
 	struct tc3589x *tc3589x = data;
 	int status;
 
+again:
 	status = tc3589x_reg_read(tc3589x, TC3589x_IRQST);
 	if (status < 0)
 		return IRQ_NONE;
@@ -156,9 +157,12 @@ static irqreturn_t tc3589x_irq(int irq, void *data)
 	/*
 	 * A dummy read or write (to any register) appears to be necessary to
 	 * have the last interrupt clear (for example, GPIO IC write) take
-	 * effect.
+	 * effect. In such a case, recheck for any interrupt which is still
+	 * pending.
 	 */
-	tc3589x_reg_read(tc3589x, TC3589x_IRQST);
+	status = tc3589x_reg_read(tc3589x, TC3589x_IRQST);
+	if (status)
+		goto again;
 
 	return IRQ_HANDLED;
 }

commit 611b7590afa6e6c6b0942b1d3efef17fbb348ef5
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Mon Dec 13 09:33:15 2010 +0530

    mfd/tc3589x: add block identifier for multiple child devices
    
    Add block identifier to be able to add multiple mfd clients
    to the mfd core
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index 7deff53181d1..0ed9669d95fa 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -129,7 +129,7 @@ static struct resource gpio_resources[] = {
 	},
 };
 
-static struct mfd_cell tc3589x_devs[] = {
+static struct mfd_cell tc3589x_dev_gpio[] = {
 	{
 		.name		= "tc3589x-gpio",
 		.num_resources	= ARRAY_SIZE(gpio_resources),
@@ -240,6 +240,26 @@ static int tc3589x_chip_init(struct tc3589x *tc3589x)
 	return tc3589x_reg_write(tc3589x, TC3589x_RSTINTCLR, 0x1);
 }
 
+static int __devinit tc3589x_device_init(struct tc3589x *tc3589x)
+{
+	int ret = 0;
+	unsigned int blocks = tc3589x->pdata->block;
+
+	if (blocks & TC3589x_BLOCK_GPIO) {
+		ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_gpio,
+				ARRAY_SIZE(tc3589x_dev_gpio), NULL,
+				tc3589x->irq_base);
+		if (ret) {
+			dev_err(tc3589x->dev, "failed to add gpio child\n");
+			return ret;
+		}
+		dev_info(tc3589x->dev, "added gpio block\n");
+	}
+
+	return ret;
+
+}
+
 static int __devinit tc3589x_probe(struct i2c_client *i2c,
 				   const struct i2c_device_id *id)
 {
@@ -281,11 +301,9 @@ static int __devinit tc3589x_probe(struct i2c_client *i2c,
 		goto out_removeirq;
 	}
 
-	ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_devs,
-			      ARRAY_SIZE(tc3589x_devs), NULL,
-			      tc3589x->irq_base);
+	ret = tc3589x_device_init(tc3589x);
 	if (ret) {
-		dev_err(tc3589x->dev, "failed to add children\n");
+		dev_err(tc3589x->dev, "failed to add child devices\n");
 		goto out_freeirq;
 	}
 

commit 20406ebff4a298e6e3abbc1717a90bb3e55dc820
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Mon Dec 13 09:33:14 2010 +0530

    mfd/tc3589x: rename tc35892 structs/registers to tc359x
    
    Most of the register layout, client IRQ numbers on the TC35892 is shared also
    by other variants. Make this generic as tc3589x
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
index f230235c3765..7deff53181d1 100644
--- a/drivers/mfd/tc3589x.c
+++ b/drivers/mfd/tc3589x.c
@@ -15,141 +15,141 @@
 #include <linux/mfd/tc3589x.h>
 
 /**
- * tc35892_reg_read() - read a single TC35892 register
- * @tc35892:	Device to read from
+ * tc3589x_reg_read() - read a single TC3589x register
+ * @tc3589x:	Device to read from
  * @reg:	Register to read
  */
-int tc35892_reg_read(struct tc35892 *tc35892, u8 reg)
+int tc3589x_reg_read(struct tc3589x *tc3589x, u8 reg)
 {
 	int ret;
 
-	ret = i2c_smbus_read_byte_data(tc35892->i2c, reg);
+	ret = i2c_smbus_read_byte_data(tc3589x->i2c, reg);
 	if (ret < 0)
-		dev_err(tc35892->dev, "failed to read reg %#x: %d\n",
+		dev_err(tc3589x->dev, "failed to read reg %#x: %d\n",
 			reg, ret);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(tc35892_reg_read);
+EXPORT_SYMBOL_GPL(tc3589x_reg_read);
 
 /**
- * tc35892_reg_read() - write a single TC35892 register
- * @tc35892:	Device to write to
+ * tc3589x_reg_read() - write a single TC3589x register
+ * @tc3589x:	Device to write to
  * @reg:	Register to read
  * @data:	Value to write
  */
-int tc35892_reg_write(struct tc35892 *tc35892, u8 reg, u8 data)
+int tc3589x_reg_write(struct tc3589x *tc3589x, u8 reg, u8 data)
 {
 	int ret;
 
-	ret = i2c_smbus_write_byte_data(tc35892->i2c, reg, data);
+	ret = i2c_smbus_write_byte_data(tc3589x->i2c, reg, data);
 	if (ret < 0)
-		dev_err(tc35892->dev, "failed to write reg %#x: %d\n",
+		dev_err(tc3589x->dev, "failed to write reg %#x: %d\n",
 			reg, ret);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(tc35892_reg_write);
+EXPORT_SYMBOL_GPL(tc3589x_reg_write);
 
 /**
- * tc35892_block_read() - read multiple TC35892 registers
- * @tc35892:	Device to read from
+ * tc3589x_block_read() - read multiple TC3589x registers
+ * @tc3589x:	Device to read from
  * @reg:	First register
  * @length:	Number of registers
  * @values:	Buffer to write to
  */
-int tc35892_block_read(struct tc35892 *tc35892, u8 reg, u8 length, u8 *values)
+int tc3589x_block_read(struct tc3589x *tc3589x, u8 reg, u8 length, u8 *values)
 {
 	int ret;
 
-	ret = i2c_smbus_read_i2c_block_data(tc35892->i2c, reg, length, values);
+	ret = i2c_smbus_read_i2c_block_data(tc3589x->i2c, reg, length, values);
 	if (ret < 0)
-		dev_err(tc35892->dev, "failed to read regs %#x: %d\n",
+		dev_err(tc3589x->dev, "failed to read regs %#x: %d\n",
 			reg, ret);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(tc35892_block_read);
+EXPORT_SYMBOL_GPL(tc3589x_block_read);
 
 /**
- * tc35892_block_write() - write multiple TC35892 registers
- * @tc35892:	Device to write to
+ * tc3589x_block_write() - write multiple TC3589x registers
+ * @tc3589x:	Device to write to
  * @reg:	First register
  * @length:	Number of registers
  * @values:	Values to write
  */
-int tc35892_block_write(struct tc35892 *tc35892, u8 reg, u8 length,
+int tc3589x_block_write(struct tc3589x *tc3589x, u8 reg, u8 length,
 			const u8 *values)
 {
 	int ret;
 
-	ret = i2c_smbus_write_i2c_block_data(tc35892->i2c, reg, length,
+	ret = i2c_smbus_write_i2c_block_data(tc3589x->i2c, reg, length,
 					     values);
 	if (ret < 0)
-		dev_err(tc35892->dev, "failed to write regs %#x: %d\n",
+		dev_err(tc3589x->dev, "failed to write regs %#x: %d\n",
 			reg, ret);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(tc35892_block_write);
+EXPORT_SYMBOL_GPL(tc3589x_block_write);
 
 /**
- * tc35892_set_bits() - set the value of a bitfield in a TC35892 register
- * @tc35892:	Device to write to
+ * tc3589x_set_bits() - set the value of a bitfield in a TC3589x register
+ * @tc3589x:	Device to write to
  * @reg:	Register to write
  * @mask:	Mask of bits to set
  * @values:	Value to set
  */
-int tc35892_set_bits(struct tc35892 *tc35892, u8 reg, u8 mask, u8 val)
+int tc3589x_set_bits(struct tc3589x *tc3589x, u8 reg, u8 mask, u8 val)
 {
 	int ret;
 
-	mutex_lock(&tc35892->lock);
+	mutex_lock(&tc3589x->lock);
 
-	ret = tc35892_reg_read(tc35892, reg);
+	ret = tc3589x_reg_read(tc3589x, reg);
 	if (ret < 0)
 		goto out;
 
 	ret &= ~mask;
 	ret |= val;
 
-	ret = tc35892_reg_write(tc35892, reg, ret);
+	ret = tc3589x_reg_write(tc3589x, reg, ret);
 
 out:
-	mutex_unlock(&tc35892->lock);
+	mutex_unlock(&tc3589x->lock);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(tc35892_set_bits);
+EXPORT_SYMBOL_GPL(tc3589x_set_bits);
 
 static struct resource gpio_resources[] = {
 	{
-		.start	= TC35892_INT_GPIIRQ,
-		.end	= TC35892_INT_GPIIRQ,
+		.start	= TC3589x_INT_GPIIRQ,
+		.end	= TC3589x_INT_GPIIRQ,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
 
-static struct mfd_cell tc35892_devs[] = {
+static struct mfd_cell tc3589x_devs[] = {
 	{
-		.name		= "tc35892-gpio",
+		.name		= "tc3589x-gpio",
 		.num_resources	= ARRAY_SIZE(gpio_resources),
 		.resources	= &gpio_resources[0],
 	},
 };
 
-static irqreturn_t tc35892_irq(int irq, void *data)
+static irqreturn_t tc3589x_irq(int irq, void *data)
 {
-	struct tc35892 *tc35892 = data;
+	struct tc3589x *tc3589x = data;
 	int status;
 
-	status = tc35892_reg_read(tc35892, TC35892_IRQST);
+	status = tc3589x_reg_read(tc3589x, TC3589x_IRQST);
 	if (status < 0)
 		return IRQ_NONE;
 
 	while (status) {
 		int bit = __ffs(status);
 
-		handle_nested_irq(tc35892->irq_base + bit);
+		handle_nested_irq(tc3589x->irq_base + bit);
 		status &= ~(1 << bit);
 	}
 
@@ -158,30 +158,30 @@ static irqreturn_t tc35892_irq(int irq, void *data)
 	 * have the last interrupt clear (for example, GPIO IC write) take
 	 * effect.
 	 */
-	tc35892_reg_read(tc35892, TC35892_IRQST);
+	tc3589x_reg_read(tc3589x, TC3589x_IRQST);
 
 	return IRQ_HANDLED;
 }
 
-static void tc35892_irq_dummy(unsigned int irq)
+static void tc3589x_irq_dummy(unsigned int irq)
 {
 	/* No mask/unmask at this level */
 }
 
-static struct irq_chip tc35892_irq_chip = {
-	.name	= "tc35892",
-	.mask	= tc35892_irq_dummy,
-	.unmask	= tc35892_irq_dummy,
+static struct irq_chip tc3589x_irq_chip = {
+	.name	= "tc3589x",
+	.mask	= tc3589x_irq_dummy,
+	.unmask	= tc3589x_irq_dummy,
 };
 
-static int tc35892_irq_init(struct tc35892 *tc35892)
+static int tc3589x_irq_init(struct tc3589x *tc3589x)
 {
-	int base = tc35892->irq_base;
+	int base = tc3589x->irq_base;
 	int irq;
 
-	for (irq = base; irq < base + TC35892_NR_INTERNAL_IRQS; irq++) {
-		set_irq_chip_data(irq, tc35892);
-		set_irq_chip_and_handler(irq, &tc35892_irq_chip,
+	for (irq = base; irq < base + TC3589x_NR_INTERNAL_IRQS; irq++) {
+		set_irq_chip_data(irq, tc3589x);
+		set_irq_chip_and_handler(irq, &tc3589x_irq_chip,
 					 handle_edge_irq);
 		set_irq_nested_thread(irq, 1);
 #ifdef CONFIG_ARM
@@ -194,12 +194,12 @@ static int tc35892_irq_init(struct tc35892 *tc35892)
 	return 0;
 }
 
-static void tc35892_irq_remove(struct tc35892 *tc35892)
+static void tc3589x_irq_remove(struct tc3589x *tc3589x)
 {
-	int base = tc35892->irq_base;
+	int base = tc3589x->irq_base;
 	int irq;
 
-	for (irq = base; irq < base + TC35892_NR_INTERNAL_IRQS; irq++) {
+	for (irq = base; irq < base + TC3589x_NR_INTERNAL_IRQS; irq++) {
 #ifdef CONFIG_ARM
 		set_irq_flags(irq, 0);
 #endif
@@ -208,138 +208,138 @@ static void tc35892_irq_remove(struct tc35892 *tc35892)
 	}
 }
 
-static int tc35892_chip_init(struct tc35892 *tc35892)
+static int tc3589x_chip_init(struct tc3589x *tc3589x)
 {
 	int manf, ver, ret;
 
-	manf = tc35892_reg_read(tc35892, TC35892_MANFCODE);
+	manf = tc3589x_reg_read(tc3589x, TC3589x_MANFCODE);
 	if (manf < 0)
 		return manf;
 
-	ver = tc35892_reg_read(tc35892, TC35892_VERSION);
+	ver = tc3589x_reg_read(tc3589x, TC3589x_VERSION);
 	if (ver < 0)
 		return ver;
 
-	if (manf != TC35892_MANFCODE_MAGIC) {
-		dev_err(tc35892->dev, "unknown manufacturer: %#x\n", manf);
+	if (manf != TC3589x_MANFCODE_MAGIC) {
+		dev_err(tc3589x->dev, "unknown manufacturer: %#x\n", manf);
 		return -EINVAL;
 	}
 
-	dev_info(tc35892->dev, "manufacturer: %#x, version: %#x\n", manf, ver);
+	dev_info(tc3589x->dev, "manufacturer: %#x, version: %#x\n", manf, ver);
 
 	/* Put everything except the IRQ module into reset */
-	ret = tc35892_reg_write(tc35892, TC35892_RSTCTRL,
-				TC35892_RSTCTRL_TIMRST
-				| TC35892_RSTCTRL_ROTRST
-				| TC35892_RSTCTRL_KBDRST
-				| TC35892_RSTCTRL_GPIRST);
+	ret = tc3589x_reg_write(tc3589x, TC3589x_RSTCTRL,
+				TC3589x_RSTCTRL_TIMRST
+				| TC3589x_RSTCTRL_ROTRST
+				| TC3589x_RSTCTRL_KBDRST
+				| TC3589x_RSTCTRL_GPIRST);
 	if (ret < 0)
 		return ret;
 
 	/* Clear the reset interrupt. */
-	return tc35892_reg_write(tc35892, TC35892_RSTINTCLR, 0x1);
+	return tc3589x_reg_write(tc3589x, TC3589x_RSTINTCLR, 0x1);
 }
 
-static int __devinit tc35892_probe(struct i2c_client *i2c,
+static int __devinit tc3589x_probe(struct i2c_client *i2c,
 				   const struct i2c_device_id *id)
 {
-	struct tc35892_platform_data *pdata = i2c->dev.platform_data;
-	struct tc35892 *tc35892;
+	struct tc3589x_platform_data *pdata = i2c->dev.platform_data;
+	struct tc3589x *tc3589x;
 	int ret;
 
 	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA
 				     | I2C_FUNC_SMBUS_I2C_BLOCK))
 		return -EIO;
 
-	tc35892 = kzalloc(sizeof(struct tc35892), GFP_KERNEL);
-	if (!tc35892)
+	tc3589x = kzalloc(sizeof(struct tc3589x), GFP_KERNEL);
+	if (!tc3589x)
 		return -ENOMEM;
 
-	mutex_init(&tc35892->lock);
+	mutex_init(&tc3589x->lock);
 
-	tc35892->dev = &i2c->dev;
-	tc35892->i2c = i2c;
-	tc35892->pdata = pdata;
-	tc35892->irq_base = pdata->irq_base;
-	tc35892->num_gpio = id->driver_data;
+	tc3589x->dev = &i2c->dev;
+	tc3589x->i2c = i2c;
+	tc3589x->pdata = pdata;
+	tc3589x->irq_base = pdata->irq_base;
+	tc3589x->num_gpio = id->driver_data;
 
-	i2c_set_clientdata(i2c, tc35892);
+	i2c_set_clientdata(i2c, tc3589x);
 
-	ret = tc35892_chip_init(tc35892);
+	ret = tc3589x_chip_init(tc3589x);
 	if (ret)
 		goto out_free;
 
-	ret = tc35892_irq_init(tc35892);
+	ret = tc3589x_irq_init(tc3589x);
 	if (ret)
 		goto out_free;
 
-	ret = request_threaded_irq(tc35892->i2c->irq, NULL, tc35892_irq,
+	ret = request_threaded_irq(tc3589x->i2c->irq, NULL, tc3589x_irq,
 				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-				   "tc35892", tc35892);
+				   "tc3589x", tc3589x);
 	if (ret) {
-		dev_err(tc35892->dev, "failed to request IRQ: %d\n", ret);
+		dev_err(tc3589x->dev, "failed to request IRQ: %d\n", ret);
 		goto out_removeirq;
 	}
 
-	ret = mfd_add_devices(tc35892->dev, -1, tc35892_devs,
-			      ARRAY_SIZE(tc35892_devs), NULL,
-			      tc35892->irq_base);
+	ret = mfd_add_devices(tc3589x->dev, -1, tc3589x_devs,
+			      ARRAY_SIZE(tc3589x_devs), NULL,
+			      tc3589x->irq_base);
 	if (ret) {
-		dev_err(tc35892->dev, "failed to add children\n");
+		dev_err(tc3589x->dev, "failed to add children\n");
 		goto out_freeirq;
 	}
 
 	return 0;
 
 out_freeirq:
-	free_irq(tc35892->i2c->irq, tc35892);
+	free_irq(tc3589x->i2c->irq, tc3589x);
 out_removeirq:
-	tc35892_irq_remove(tc35892);
+	tc3589x_irq_remove(tc3589x);
 out_free:
-	kfree(tc35892);
+	kfree(tc3589x);
 	return ret;
 }
 
-static int __devexit tc35892_remove(struct i2c_client *client)
+static int __devexit tc3589x_remove(struct i2c_client *client)
 {
-	struct tc35892 *tc35892 = i2c_get_clientdata(client);
+	struct tc3589x *tc3589x = i2c_get_clientdata(client);
 
-	mfd_remove_devices(tc35892->dev);
+	mfd_remove_devices(tc3589x->dev);
 
-	free_irq(tc35892->i2c->irq, tc35892);
-	tc35892_irq_remove(tc35892);
+	free_irq(tc3589x->i2c->irq, tc3589x);
+	tc3589x_irq_remove(tc3589x);
 
-	kfree(tc35892);
+	kfree(tc3589x);
 
 	return 0;
 }
 
-static const struct i2c_device_id tc35892_id[] = {
-	{ "tc35892", 24 },
+static const struct i2c_device_id tc3589x_id[] = {
+	{ "tc3589x", 24 },
 	{ }
 };
-MODULE_DEVICE_TABLE(i2c, tc35892_id);
+MODULE_DEVICE_TABLE(i2c, tc3589x_id);
 
-static struct i2c_driver tc35892_driver = {
-	.driver.name	= "tc35892",
+static struct i2c_driver tc3589x_driver = {
+	.driver.name	= "tc3589x",
 	.driver.owner	= THIS_MODULE,
-	.probe		= tc35892_probe,
-	.remove		= __devexit_p(tc35892_remove),
-	.id_table	= tc35892_id,
+	.probe		= tc3589x_probe,
+	.remove		= __devexit_p(tc3589x_remove),
+	.id_table	= tc3589x_id,
 };
 
-static int __init tc35892_init(void)
+static int __init tc3589x_init(void)
 {
-	return i2c_add_driver(&tc35892_driver);
+	return i2c_add_driver(&tc3589x_driver);
 }
-subsys_initcall(tc35892_init);
+subsys_initcall(tc3589x_init);
 
-static void __exit tc35892_exit(void)
+static void __exit tc3589x_exit(void)
 {
-	i2c_del_driver(&tc35892_driver);
+	i2c_del_driver(&tc3589x_driver);
 }
-module_exit(tc35892_exit);
+module_exit(tc3589x_exit);
 
 MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("TC35892 MFD core driver");
+MODULE_DESCRIPTION("TC3589x MFD core driver");
 MODULE_AUTHOR("Hanumath Prasad, Rabin Vincent");

commit f4e8afdc7ab1b5a0962be02a9dd15d29a81f4c53
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Mon Dec 13 09:33:13 2010 +0530

    mfd/tc35892: rename tc35892 core driver to tc3589x
    
    Rename the tc35892 core/gpio drivers to tc3589x to include
    new variants in the same mfd core
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
new file mode 100644
index 000000000000..f230235c3765
--- /dev/null
+++ b/drivers/mfd/tc3589x.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ *
+ * License Terms: GNU General Public License, version 2
+ * Author: Hanumath Prasad <hanumath.prasad@stericsson.com> for ST-Ericsson
+ * Author: Rabin Vincent <rabin.vincent@stericsson.com> for ST-Ericsson
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/tc3589x.h>
+
+/**
+ * tc35892_reg_read() - read a single TC35892 register
+ * @tc35892:	Device to read from
+ * @reg:	Register to read
+ */
+int tc35892_reg_read(struct tc35892 *tc35892, u8 reg)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(tc35892->i2c, reg);
+	if (ret < 0)
+		dev_err(tc35892->dev, "failed to read reg %#x: %d\n",
+			reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tc35892_reg_read);
+
+/**
+ * tc35892_reg_read() - write a single TC35892 register
+ * @tc35892:	Device to write to
+ * @reg:	Register to read
+ * @data:	Value to write
+ */
+int tc35892_reg_write(struct tc35892 *tc35892, u8 reg, u8 data)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(tc35892->i2c, reg, data);
+	if (ret < 0)
+		dev_err(tc35892->dev, "failed to write reg %#x: %d\n",
+			reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tc35892_reg_write);
+
+/**
+ * tc35892_block_read() - read multiple TC35892 registers
+ * @tc35892:	Device to read from
+ * @reg:	First register
+ * @length:	Number of registers
+ * @values:	Buffer to write to
+ */
+int tc35892_block_read(struct tc35892 *tc35892, u8 reg, u8 length, u8 *values)
+{
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(tc35892->i2c, reg, length, values);
+	if (ret < 0)
+		dev_err(tc35892->dev, "failed to read regs %#x: %d\n",
+			reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tc35892_block_read);
+
+/**
+ * tc35892_block_write() - write multiple TC35892 registers
+ * @tc35892:	Device to write to
+ * @reg:	First register
+ * @length:	Number of registers
+ * @values:	Values to write
+ */
+int tc35892_block_write(struct tc35892 *tc35892, u8 reg, u8 length,
+			const u8 *values)
+{
+	int ret;
+
+	ret = i2c_smbus_write_i2c_block_data(tc35892->i2c, reg, length,
+					     values);
+	if (ret < 0)
+		dev_err(tc35892->dev, "failed to write regs %#x: %d\n",
+			reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tc35892_block_write);
+
+/**
+ * tc35892_set_bits() - set the value of a bitfield in a TC35892 register
+ * @tc35892:	Device to write to
+ * @reg:	Register to write
+ * @mask:	Mask of bits to set
+ * @values:	Value to set
+ */
+int tc35892_set_bits(struct tc35892 *tc35892, u8 reg, u8 mask, u8 val)
+{
+	int ret;
+
+	mutex_lock(&tc35892->lock);
+
+	ret = tc35892_reg_read(tc35892, reg);
+	if (ret < 0)
+		goto out;
+
+	ret &= ~mask;
+	ret |= val;
+
+	ret = tc35892_reg_write(tc35892, reg, ret);
+
+out:
+	mutex_unlock(&tc35892->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tc35892_set_bits);
+
+static struct resource gpio_resources[] = {
+	{
+		.start	= TC35892_INT_GPIIRQ,
+		.end	= TC35892_INT_GPIIRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mfd_cell tc35892_devs[] = {
+	{
+		.name		= "tc35892-gpio",
+		.num_resources	= ARRAY_SIZE(gpio_resources),
+		.resources	= &gpio_resources[0],
+	},
+};
+
+static irqreturn_t tc35892_irq(int irq, void *data)
+{
+	struct tc35892 *tc35892 = data;
+	int status;
+
+	status = tc35892_reg_read(tc35892, TC35892_IRQST);
+	if (status < 0)
+		return IRQ_NONE;
+
+	while (status) {
+		int bit = __ffs(status);
+
+		handle_nested_irq(tc35892->irq_base + bit);
+		status &= ~(1 << bit);
+	}
+
+	/*
+	 * A dummy read or write (to any register) appears to be necessary to
+	 * have the last interrupt clear (for example, GPIO IC write) take
+	 * effect.
+	 */
+	tc35892_reg_read(tc35892, TC35892_IRQST);
+
+	return IRQ_HANDLED;
+}
+
+static void tc35892_irq_dummy(unsigned int irq)
+{
+	/* No mask/unmask at this level */
+}
+
+static struct irq_chip tc35892_irq_chip = {
+	.name	= "tc35892",
+	.mask	= tc35892_irq_dummy,
+	.unmask	= tc35892_irq_dummy,
+};
+
+static int tc35892_irq_init(struct tc35892 *tc35892)
+{
+	int base = tc35892->irq_base;
+	int irq;
+
+	for (irq = base; irq < base + TC35892_NR_INTERNAL_IRQS; irq++) {
+		set_irq_chip_data(irq, tc35892);
+		set_irq_chip_and_handler(irq, &tc35892_irq_chip,
+					 handle_edge_irq);
+		set_irq_nested_thread(irq, 1);
+#ifdef CONFIG_ARM
+		set_irq_flags(irq, IRQF_VALID);
+#else
+		set_irq_noprobe(irq);
+#endif
+	}
+
+	return 0;
+}
+
+static void tc35892_irq_remove(struct tc35892 *tc35892)
+{
+	int base = tc35892->irq_base;
+	int irq;
+
+	for (irq = base; irq < base + TC35892_NR_INTERNAL_IRQS; irq++) {
+#ifdef CONFIG_ARM
+		set_irq_flags(irq, 0);
+#endif
+		set_irq_chip_and_handler(irq, NULL, NULL);
+		set_irq_chip_data(irq, NULL);
+	}
+}
+
+static int tc35892_chip_init(struct tc35892 *tc35892)
+{
+	int manf, ver, ret;
+
+	manf = tc35892_reg_read(tc35892, TC35892_MANFCODE);
+	if (manf < 0)
+		return manf;
+
+	ver = tc35892_reg_read(tc35892, TC35892_VERSION);
+	if (ver < 0)
+		return ver;
+
+	if (manf != TC35892_MANFCODE_MAGIC) {
+		dev_err(tc35892->dev, "unknown manufacturer: %#x\n", manf);
+		return -EINVAL;
+	}
+
+	dev_info(tc35892->dev, "manufacturer: %#x, version: %#x\n", manf, ver);
+
+	/* Put everything except the IRQ module into reset */
+	ret = tc35892_reg_write(tc35892, TC35892_RSTCTRL,
+				TC35892_RSTCTRL_TIMRST
+				| TC35892_RSTCTRL_ROTRST
+				| TC35892_RSTCTRL_KBDRST
+				| TC35892_RSTCTRL_GPIRST);
+	if (ret < 0)
+		return ret;
+
+	/* Clear the reset interrupt. */
+	return tc35892_reg_write(tc35892, TC35892_RSTINTCLR, 0x1);
+}
+
+static int __devinit tc35892_probe(struct i2c_client *i2c,
+				   const struct i2c_device_id *id)
+{
+	struct tc35892_platform_data *pdata = i2c->dev.platform_data;
+	struct tc35892 *tc35892;
+	int ret;
+
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA
+				     | I2C_FUNC_SMBUS_I2C_BLOCK))
+		return -EIO;
+
+	tc35892 = kzalloc(sizeof(struct tc35892), GFP_KERNEL);
+	if (!tc35892)
+		return -ENOMEM;
+
+	mutex_init(&tc35892->lock);
+
+	tc35892->dev = &i2c->dev;
+	tc35892->i2c = i2c;
+	tc35892->pdata = pdata;
+	tc35892->irq_base = pdata->irq_base;
+	tc35892->num_gpio = id->driver_data;
+
+	i2c_set_clientdata(i2c, tc35892);
+
+	ret = tc35892_chip_init(tc35892);
+	if (ret)
+		goto out_free;
+
+	ret = tc35892_irq_init(tc35892);
+	if (ret)
+		goto out_free;
+
+	ret = request_threaded_irq(tc35892->i2c->irq, NULL, tc35892_irq,
+				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				   "tc35892", tc35892);
+	if (ret) {
+		dev_err(tc35892->dev, "failed to request IRQ: %d\n", ret);
+		goto out_removeirq;
+	}
+
+	ret = mfd_add_devices(tc35892->dev, -1, tc35892_devs,
+			      ARRAY_SIZE(tc35892_devs), NULL,
+			      tc35892->irq_base);
+	if (ret) {
+		dev_err(tc35892->dev, "failed to add children\n");
+		goto out_freeirq;
+	}
+
+	return 0;
+
+out_freeirq:
+	free_irq(tc35892->i2c->irq, tc35892);
+out_removeirq:
+	tc35892_irq_remove(tc35892);
+out_free:
+	kfree(tc35892);
+	return ret;
+}
+
+static int __devexit tc35892_remove(struct i2c_client *client)
+{
+	struct tc35892 *tc35892 = i2c_get_clientdata(client);
+
+	mfd_remove_devices(tc35892->dev);
+
+	free_irq(tc35892->i2c->irq, tc35892);
+	tc35892_irq_remove(tc35892);
+
+	kfree(tc35892);
+
+	return 0;
+}
+
+static const struct i2c_device_id tc35892_id[] = {
+	{ "tc35892", 24 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tc35892_id);
+
+static struct i2c_driver tc35892_driver = {
+	.driver.name	= "tc35892",
+	.driver.owner	= THIS_MODULE,
+	.probe		= tc35892_probe,
+	.remove		= __devexit_p(tc35892_remove),
+	.id_table	= tc35892_id,
+};
+
+static int __init tc35892_init(void)
+{
+	return i2c_add_driver(&tc35892_driver);
+}
+subsys_initcall(tc35892_init);
+
+static void __exit tc35892_exit(void)
+{
+	i2c_del_driver(&tc35892_driver);
+}
+module_exit(tc35892_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("TC35892 MFD core driver");
+MODULE_AUTHOR("Hanumath Prasad, Rabin Vincent");
