commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 2ab67386b4ef..65fcc58c02da 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * tps65010 - driver for tps6501x power management chips
  *
  * Copyright (C) 2004 Texas Instruments
  * Copyright (C) 2004-2005 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/kernel.h>

commit 9787076c43a86f3465d46aa344cc3e2f607ae72f
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Aug 14 18:34:23 2017 +0200

    mfd: tps65010: Move header file out of I2C realm
    
    include/linux/i2c is not for client devices. Move the header file to a
    more appropriate location.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index d829a6131f09..2ab67386b4ef 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -32,7 +32,7 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 
-#include <linux/i2c/tps65010.h>
+#include <linux/mfd/tps65010.h>
 
 #include <linux/gpio/driver.h>
 

commit 22e5e747e71f19ac3af60ce648f4c02c63ed3cc1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Mar 30 10:48:07 2016 +0200

    mfd: tps65010: Use gpiochip data pointer
    
    This makes the driver use the data pointer added to the gpio_chip
    to store a pointer to the state container instead of relying on
    container_of().
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 495e4518fc29..d829a6131f09 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -34,7 +34,7 @@
 
 #include <linux/i2c/tps65010.h>
 
-#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 
 
 /*-------------------------------------------------------------------------*/
@@ -477,7 +477,7 @@ tps65010_output(struct gpio_chip *chip, unsigned offset, int value)
 	if (offset < 4) {
 		struct tps65010		*tps;
 
-		tps = container_of(chip, struct tps65010, chip);
+		tps = gpiochip_get_data(chip);
 		if (!(tps->outmask & (1 << offset)))
 			return -EINVAL;
 		tps65010_set_gpio_out_value(offset + 1, value);
@@ -494,7 +494,7 @@ static int tps65010_gpio_get(struct gpio_chip *chip, unsigned offset)
 	int			value;
 	struct tps65010		*tps;
 
-	tps = container_of(chip, struct tps65010, chip);
+	tps = gpiochip_get_data(chip);
 
 	if (offset < 4) {
 		value = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);
@@ -651,7 +651,7 @@ static int tps65010_probe(struct i2c_client *client,
 		tps->chip.ngpio = 7;
 		tps->chip.can_sleep = 1;
 
-		status = gpiochip_add(&tps->chip);
+		status = gpiochip_add_data(&tps->chip, tps);
 		if (status < 0)
 			dev_err(&client->dev, "can't add gpiochip, err %d\n",
 					status);

commit dbc352b9f16de45277abf2e30d0317ce55fc1e57
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Mon Jan 11 21:46:49 2016 +0200

    mfd: tps65010: Fix init when the driver is built-in
    
    tps65010 driver's initcall cannot succeed when the driver is built-in,
    because it expects that the I2C probe is completed at initcall time;
    this cannot happen as MFD is initialized before I2C. Also on systems
    where the chip is not present there is unnecessary 30 ms delay during
    the boot.
    
    Instead of waiting for probe to finish, just register the I2C device.
    If some boards need retry mechanism for startup glitches, that should be
    done in the actual probe function. Also delete the driver banner message.
    
    The patch allows to use tps65010 again with OMAP1 (where it's required
    to be built-in) and enables e.g. USB and LED functionality on OMAP5912 OSK.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 83e615ed100a..495e4518fc29 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -1059,26 +1059,7 @@ EXPORT_SYMBOL(tps65013_set_low_pwr);
 
 static int __init tps_init(void)
 {
-	u32	tries = 3;
-	int	status = -ENODEV;
-
-	printk(KERN_INFO "%s: version %s\n", DRIVER_NAME, DRIVER_VERSION);
-
-	/* some boards have startup glitches */
-	while (tries--) {
-		status = i2c_add_driver(&tps65010_driver);
-		if (the_tps)
-			break;
-		i2c_del_driver(&tps65010_driver);
-		if (!tries) {
-			printk(KERN_ERR "%s: no chip?\n", DRIVER_NAME);
-			return -ENODEV;
-		}
-		pr_debug("%s: re-probe ...\n", DRIVER_NAME);
-		msleep(10);
-	}
-
-	return status;
+	return i2c_add_driver(&tps65010_driver);
 }
 /* NOTE:  this MUST be initialized before the other parts of the system
  * that rely on it ... but after the i2c bus on which this relies.

commit 58cf279acac3080ce03eeea5ca268210b3165fe1
Merge: 6606b342febf c474e348778b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 17 12:32:01 2016 -0800

    Merge tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "Here is the bulk of GPIO changes for v4.5.
    
      Notably there are big refactorings mostly by myself, aimed at getting
      the gpio_chip into a shape that makes me believe I can proceed to
      preserve state for a proper userspace ABI (character device) that has
      already been proposed once, but resulted in the feedback that I need
      to go back and restructure stuff.  So I've been restructuring stuff.
      On the way I ran into brokenness (return code from the get_value()
      callback) and had to fix it.  Also, refactored generic GPIO to be
      simpler.
    
      Some of that is still waiting to trickle down from the subsystems all
      over the kernel that provide random gpio_chips, I've touched every
      single GPIO driver in the kernel now, oh man I didn't know I was
      responsible for so much...
    
      Apart from that we're churning along as usual.
    
      I took some effort to test and retest so it should merge nicely and we
      shook out a couple of bugs in -next.
    
      Infrastructural changes:
    
       - In struct gpio_chip, rename the .dev node to .parent to better
         reflect the fact that this is not the GPIO struct device
         abstraction.  We will add that soon so this would be totallt
         confusing.
    
       - It was noted that the driver .get_value() callbacks was sometimes
         reporting negative -ERR values to the gpiolib core, expecting them
         to be propagated to consumer gpiod_get_value() and gpio_get_value()
         calls.  This was not happening, so as there was a mess of drivers
         returning negative errors and some returning "anything else than
         zero" to indicate that a line was active.  As some would have bit
         31 set to indicate "line active" it clashed with negative error
         codes.  This is fixed by the largeish series clamping values in all
         drivers with !!value to [0,1] and then augmenting the code to
         propagate error codes to consumers.  (Includes some ACKed patches
         in other subsystems.)
    
       - Add a void *data pointer to struct gpio_chip.  The container_of()
         design pattern is indeed very nice, but we want to reform the
         struct gpio_chip to be a non-volative, stateless business, and keep
         states internal to the gpiolib to be able to hold on to the state
         when adding a proper userspace ABI (character device) further down
         the road.  To achieve this, drivers need a handle at the internal
         state that is not dependent on their struct gpio_chip() so we add
         gpiochip_add_data() and gpiochip_get_data() following the pattern
         of many other subsystems.  All the "use gpiochip data pointer"
         patches transforms drivers to this scheme.
    
       - The Generic GPIO chip header has been merged into the general
         <linux/gpio/driver.h> header, and the custom header for that
         removed.  Instead of having a separate mm_gpio_chip struct for
         these generic drivers, merge that into struct gpio_chip,
         simplifying the code and removing the need for separate and
         confusing includes.
    
      Misc improvements:
    
       - Stabilize the way GPIOs are looked up from the ACPI legacy
         specification.
    
       - Incremental driver features for PXA, PCA953X, Lantiq (patches from
         the OpenWRT community), RCAR, Zynq, PL061, 104-idi-48
    
      New drivers:
    
       - Add a GPIO chip to the ALSA SoC AC97 driver.
    
       - Add a new Broadcom NSP SoC driver (this lands in the pinctrl dir,
         but the branch is merged here too to account for infrastructural
         changes).
    
       - The sx150x driver now supports the sx1502"
    
    * tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (220 commits)
      gpio: generic: make bgpio_pdata always visible
      gpiolib: fix chip order in gpio list
      gpio: mpc8xxx: Do not use gpiochip_get_data() in mpc8xxx_gpio_save_regs()
      gpio: mm-lantiq: Do not use gpiochip_get_data() in ltq_mm_save_regs()
      gpio: brcmstb: Allow building driver for BMIPS_GENERIC
      gpio: brcmstb: Set endian flags for big-endian MIPS
      gpio: moxart: fix build regression
      gpio: xilinx: Do not use gpiochip_get_data() in xgpio_save_regs()
      leds: pca9532: use gpiochip data pointer
      leds: tca6507: use gpiochip data pointer
      hid: cp2112: use gpiochip data pointer
      bcma: gpio: use gpiochip data pointer
      avr32: gpio: use gpiochip data pointer
      video: fbdev: via: use gpiochip data pointer
      gpio: pch: Optimize pch_gpio_get()
      Revert "pinctrl: lantiq: Implement gpio_chip.to_irq"
      pinctrl: nsp-gpio: use gpiochip data pointer
      pinctrl: vt8500-wmt: use gpiochip data pointer
      pinctrl: exynos5440: use gpiochip data pointer
      pinctrl: at91-pio4: use gpiochip data pointer
      ...

commit bf3de47f1af3dab8fb8c3a3bd21ada7de614b7de
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 22 15:48:13 2015 +0100

    mfd: tps65010: Be sure to clamp return value
    
    As we want gpio_chip .get() calls to be able to return negative
    error codes and propagate to drivers, we need to go over all
    drivers and make sure their return values are clamped to [0,1].
    We do this by using the ret = !!(val) design pattern.
    
    This also start to propagate the negative error code from the
    smbus call if there is one, as the last commit of this series
    will make the gpiolib core deal with that properly.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 448f0a182dc4..677a127619d4 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -499,11 +499,11 @@ static int tps65010_gpio_get(struct gpio_chip *chip, unsigned offset)
 	if (offset < 4) {
 		value = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);
 		if (value < 0)
-			return 0;
+			return value;
 		if (value & (1 << (offset + 4)))	/* output */
 			return !(value & (1 << offset));
 		else					/* input */
-			return (value & (1 << offset));
+			return !!(value & (1 << offset));
 	}
 
 	/* REVISIT we *could* report LED1/nPG and LED2 state ... */

commit 58383c78425e4ee1c077253cf297b641c861c02e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 4 09:56:26 2015 +0100

    gpio: change member .dev to .parent
    
    The name .dev in a struct is normally reserved for a struct device
    that is let us say a superclass to the thing described by the struct.
    struct gpio_chip stands out by confusingly using a struct device *dev
    to point to the parent device (such as a platform_device) that
    represents the hardware. As we want to give gpio_chip:s real devices,
    this is not working. We need to rename this member to parent.
    
    This was done by two coccinelle scripts, I guess it is possible to
    combine them into one, but I don't know such stuff. They look like
    this:
    
    @@
    struct gpio_chip *var;
    @@
    -var->dev
    +var->parent
    
    and:
    
    @@
    struct gpio_chip var;
    @@
    -var.dev
    +var.parent
    
    and:
    
    @@
    struct bgpio_chip *var;
    @@
    -var->gc.dev
    +var->gc.parent
    
    Plus a few instances of bgpio that I couldn't figure out how
    to teach Coccinelle to rewrite.
    
    This patch hits all over the place, but I *strongly* prefer this
    solution to any piecemal approaches that just exercise patch
    mechanics all over the place. It mainly hits drivers/gpio and
    drivers/pinctrl which is my own backyard anyway.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Alek Du <alek.du@intel.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 448f0a182dc4..b96847491277 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -638,7 +638,7 @@ static int tps65010_probe(struct i2c_client *client,
 		tps->outmask = board->outmask;
 
 		tps->chip.label = client->name;
-		tps->chip.dev = &client->dev;
+		tps->chip.parent = &client->dev;
 		tps->chip.owner = THIS_MODULE;
 
 		tps->chip.set = tps65010_gpio_set;

commit bb733707913389d77223fa3b2849b41ab540f69b
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Mar 9 10:47:15 2015 -0700

    mfd: tps65010: Remove incorrect __exit markups
    
    Even if bus is not hot-pluggable, the devices can be unbound from the
    driver via sysfs, so we should not be using __exit annotations on
    remove() methods. The only exception is drivers registered with
    platform_driver_probe() which specifically disables sysfs bind/unbind
    attributes.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 743fb524fc8a..448f0a182dc4 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -515,7 +515,7 @@ static int tps65010_gpio_get(struct gpio_chip *chip, unsigned offset)
 
 static struct tps65010 *the_tps;
 
-static int __exit tps65010_remove(struct i2c_client *client)
+static int tps65010_remove(struct i2c_client *client)
 {
 	struct tps65010		*tps = i2c_get_clientdata(client);
 	struct tps65010_board	*board = dev_get_platdata(&client->dev);
@@ -684,7 +684,7 @@ static struct i2c_driver tps65010_driver = {
 		.name	= "tps65010",
 	},
 	.probe	= tps65010_probe,
-	.remove	= __exit_p(tps65010_remove),
+	.remove	= tps65010_remove,
 	.id_table = tps65010_id,
 };
 

commit eac1dcbd3e211998fb8342902b3acee149a9271d
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Aug 20 16:05:54 2013 +0900

    mfd: tps65010: Use devm_*() functions
    
    Use devm_*() functions to make cleanup paths simpler.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 8114567e0695..743fb524fc8a 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -530,7 +530,6 @@ static int __exit tps65010_remove(struct i2c_client *client)
 		free_irq(client->irq, tps);
 	cancel_delayed_work_sync(&tps->work);
 	debugfs_remove(tps->file);
-	kfree(tps);
 	the_tps = NULL;
 	return 0;
 }
@@ -550,7 +549,7 @@ static int tps65010_probe(struct i2c_client *client,
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
 		return -EINVAL;
 
-	tps = kzalloc(sizeof *tps, GFP_KERNEL);
+	tps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);
 	if (!tps)
 		return -ENOMEM;
 
@@ -568,7 +567,7 @@ static int tps65010_probe(struct i2c_client *client,
 		if (status < 0) {
 			dev_dbg(&client->dev, "can't get IRQ %d, err %d\n",
 					client->irq, status);
-			goto fail1;
+			return status;
 		}
 		/* annoying race here, ideally we'd have an option
 		 * to claim the irq now and enable it later.
@@ -668,9 +667,6 @@ static int tps65010_probe(struct i2c_client *client,
 	}
 
 	return 0;
-fail1:
-	kfree(tps);
-	return status;
 }
 
 static const struct i2c_device_id tps65010_id[] = {

commit bb3d5934201607d8514c9a481bd68b2bd9e5510d
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Aug 9 18:25:02 2013 +0100

    mfd: tps65010: Use power efficient workqueue for power polling
    
    There is no need to use a per CPU workqueue to poll, especially with the
    5s delay used, so allow the scheduler to use any CPU.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 4d6769268739..8114567e0695 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -242,8 +242,8 @@ static int dbg_show(struct seq_file *s, void *_)
 	seq_printf(s, "mask2     %s\n", buf);
 	/* ignore ackint2 */
 
-	schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
-
+	queue_delayed_work(system_power_efficient_wq, &tps->work,
+			   POWER_POLL_DELAY);
 
 	/* VMAIN voltage, enable lowpower, etc */
 	value = i2c_smbus_read_byte_data(tps->client, TPS_VDCDC1);
@@ -400,7 +400,8 @@ static void tps65010_interrupt(struct tps65010 *tps)
 			&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC)))
 		poll = 1;
 	if (poll)
-		schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
+		queue_delayed_work(system_power_efficient_wq, &tps->work,
+				   POWER_POLL_DELAY);
 
 	/* also potentially gpio-in rise or fall */
 }
@@ -448,7 +449,7 @@ static irqreturn_t tps65010_irq(int irq, void *_tps)
 
 	disable_irq_nosync(irq);
 	set_bit(FLAG_IRQ_ENABLE, &tps->flags);
-	schedule_delayed_work(&tps->work, 0);
+	queue_delayed_work(system_power_efficient_wq, &tps->work, 0);
 	return IRQ_HANDLED;
 }
 
@@ -718,7 +719,8 @@ int tps65010_set_vbus_draw(unsigned mA)
 			&& test_and_set_bit(
 				FLAG_VBUS_CHANGED, &the_tps->flags)) {
 		/* gadget drivers call this in_irq() */
-		schedule_delayed_work(&the_tps->work, 0);
+		queue_delayed_work(system_power_efficient_wq, &the_tps->work,
+				   0);
 	}
 	local_irq_restore(flags);
 

commit 334a41ce9b753ec615e8c6c50ee07d6197190610
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:10:05 2013 +0900

    mfd: Use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index da2691f22e11..4d6769268739 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -517,7 +517,7 @@ static struct tps65010 *the_tps;
 static int __exit tps65010_remove(struct i2c_client *client)
 {
 	struct tps65010		*tps = i2c_get_clientdata(client);
-	struct tps65010_board	*board = client->dev.platform_data;
+	struct tps65010_board	*board = dev_get_platdata(&client->dev);
 
 	if (board && board->teardown) {
 		int status = board->teardown(client, board->context);
@@ -539,7 +539,7 @@ static int tps65010_probe(struct i2c_client *client,
 {
 	struct tps65010		*tps;
 	int			status;
-	struct tps65010_board	*board = client->dev.platform_data;
+	struct tps65010_board	*board = dev_get_platdata(&client->dev);
 
 	if (the_tps) {
 		dev_dbg(&client->dev, "only one tps6501x chip allowed\n");

commit 212436c2ac11bce48d40fae04147dc025f2775ca
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Tue Jul 17 13:23:36 2012 -0400

    mfd: remove IRQF_SAMPLE_RANDOM which is now a no-op
    
    With the changes in the random tree, IRQF_SAMPLE_RANDOM is now a
    no-op; interrupt randomness is now collected unconditionally in a very
    low-overhead fashion; see commit 775f4b297b.  The IRQF_SAMPLE_RANDOM
    flag was scheduled to be removed in 2009 on the
    feature-removal-schedule, so this patch is preparation for the final
    removal of this flag.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 93d5fdf020c7..da2691f22e11 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -563,8 +563,7 @@ static int tps65010_probe(struct i2c_client *client,
 	 */
 	if (client->irq > 0) {
 		status = request_irq(client->irq, tps65010_irq,
-			IRQF_SAMPLE_RANDOM | IRQF_TRIGGER_FALLING,
-			DRIVER_NAME, tps);
+				     IRQF_TRIGGER_FALLING, DRIVER_NAME, tps);
 		if (status < 0) {
 			dev_dbg(&client->dev, "can't get IRQ %d, err %d\n",
 					client->irq, status);

commit 77b22897da093e80c40f03e8d83bf23e756b9fba
Author: Axel Lin <axel.lin@gmail.com>
Date:   Wed Nov 10 15:49:41 2010 +0800

    mfd: Include <linux/gpio.h> instead of <asm/gpio.h>
    
    As warned by checkpatch.pl, use #include <linux/gpio.h> instead
    of <asm/gpio.h>.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 90187fe33e04..93d5fdf020c7 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -34,7 +34,7 @@
 
 #include <linux/i2c/tps65010.h>
 
-#include <asm/gpio.h>
+#include <linux/gpio.h>
 
 
 /*-------------------------------------------------------------------------*/

commit afdb32f2e463a195c104555ac9a8cdd39a2b6561
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Dec 24 16:00:17 2010 +0100

    mfd: update workqueue usages
    
    flush_scheduled_work() is deprecated and scheduled to be removed.
    
    * In menelaus, flush menelaus->work directly on probe failure.  Also,
      make sure the work isn't running on removal.
    
    * In tps65010, cancel_delayed_work() + flush_scheduled_work() ->
      cancel_delayed_work_sync().  While at it, remove unnecessary (void)
      casts on return value, and use schedule_delayed_work() and
      to_delayed_work() instead of using delayed_work's internal work
      field.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index d0016b67d125..90187fe33e04 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -242,7 +242,7 @@ static int dbg_show(struct seq_file *s, void *_)
 	seq_printf(s, "mask2     %s\n", buf);
 	/* ignore ackint2 */
 
-	(void) schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
+	schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
 
 
 	/* VMAIN voltage, enable lowpower, etc */
@@ -400,7 +400,7 @@ static void tps65010_interrupt(struct tps65010 *tps)
 			&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC)))
 		poll = 1;
 	if (poll)
-		(void) schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
+		schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
 
 	/* also potentially gpio-in rise or fall */
 }
@@ -410,7 +410,7 @@ static void tps65010_work(struct work_struct *work)
 {
 	struct tps65010		*tps;
 
-	tps = container_of(work, struct tps65010, work.work);
+	tps = container_of(to_delayed_work(work), struct tps65010, work);
 	mutex_lock(&tps->lock);
 
 	tps65010_interrupt(tps);
@@ -448,7 +448,7 @@ static irqreturn_t tps65010_irq(int irq, void *_tps)
 
 	disable_irq_nosync(irq);
 	set_bit(FLAG_IRQ_ENABLE, &tps->flags);
-	(void) schedule_work(&tps->work.work);
+	schedule_delayed_work(&tps->work, 0);
 	return IRQ_HANDLED;
 }
 
@@ -527,8 +527,7 @@ static int __exit tps65010_remove(struct i2c_client *client)
 	}
 	if (client->irq > 0)
 		free_irq(client->irq, tps);
-	cancel_delayed_work(&tps->work);
-	flush_scheduled_work();
+	cancel_delayed_work_sync(&tps->work);
 	debugfs_remove(tps->file);
 	kfree(tps);
 	the_tps = NULL;
@@ -720,7 +719,7 @@ int tps65010_set_vbus_draw(unsigned mA)
 			&& test_and_set_bit(
 				FLAG_VBUS_CHANGED, &the_tps->flags)) {
 		/* gadget drivers call this in_irq() */
-		(void) schedule_work(&the_tps->work.work);
+		schedule_delayed_work(&the_tps->work, 0);
 	}
 	local_irq_restore(flags);
 

commit fbae3fb1546e199ab0cd185348f8124411a1ca9d
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Thu Jun 3 11:33:58 2010 +0200

    i2c: Remove all i2c_set_clientdata(client, NULL) in drivers
    
    I2C drivers can use the clientdata-pointer to point to private data. As I2C
    devices are not really unregistered, but merely detached from their driver, it
    used to be the drivers obligation to clear this pointer during remove() or a
    failed probe(). As a couple of drivers forgot to do this, it was agreed that it
    was cleaner if the i2c-core does this clearance when appropriate, as there is
    no guarantee for the lifetime of the clientdata-pointer after remove() anyhow.
    This feature was added to the core with commit
    e4a7b9b04de15f6b63da5ccdd373ffa3057a3681 to fix the faulty drivers.
    
    As there is no need anymore to clear the clientdata-pointer, remove all current
    occurrences in the drivers to simplify the code and prevent confusion.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Richard Purdie <rpurdie@linux.intel.com>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 9b22a77f70f5..d0016b67d125 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -530,7 +530,6 @@ static int __exit tps65010_remove(struct i2c_client *client)
 	cancel_delayed_work(&tps->work);
 	flush_scheduled_work();
 	debugfs_remove(tps->file);
-	i2c_set_clientdata(client, NULL);
 	kfree(tps);
 	the_tps = NULL;
 	return 0;

commit f322d5f0097333343bfd92b47258ee997c889263
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Sat Mar 20 15:12:54 2010 +0100

    mfd: Fix dangling pointers
    
    Fix I2C-drivers which missed setting clientdata to NULL before freeing the
    structure it points to. Also fix drivers which do this _after_ the structure
    was freed already.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index e5955306c2fa..9b22a77f70f5 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -530,8 +530,8 @@ static int __exit tps65010_remove(struct i2c_client *client)
 	cancel_delayed_work(&tps->work);
 	flush_scheduled_work();
 	debugfs_remove(tps->file);
-	kfree(tps);
 	i2c_set_clientdata(client, NULL);
+	kfree(tps);
 	the_tps = NULL;
 	return 0;
 }

commit b45440c33a0bdd824b98e4a4c56767c50d3275eb
Author: Ben Dooks <ben@simtec.co.uk>
Date:   Mon Nov 2 16:52:30 2009 +0000

    mfd: Allow configuration of VDCDC2 for tps65010
    
    Add function to allow the configuation fo the VDCDC2 register by
    external users, to allow changing of the standard and low-power
    running modes.
    
    This is needed, for example, for the Simtec IM2440D20 where we need
    to use the low-power mode to shutdown the LDO/DCDC that are not needed
    during suspend (saving substantial power) and the runtime use of the
    low-power mode to change VCore.
    
    Signed-off-by: Ben Dooks <ben@simtec.co.uk>
    Signed-off-by: Simtec Linux Team <linux@simtec.co.uk>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index 755c4030ea31..e5955306c2fa 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -964,6 +964,34 @@ int tps65010_config_vregs1(unsigned value)
 }
 EXPORT_SYMBOL(tps65010_config_vregs1);
 
+int tps65010_config_vdcdc2(unsigned value)
+{
+	struct i2c_client *c;
+	int	 status;
+
+	if (!the_tps)
+		return -ENODEV;
+
+	c = the_tps->client;
+	mutex_lock(&the_tps->lock);
+
+	pr_debug("%s: vdcdc2 0x%02x\n", DRIVER_NAME,
+		 i2c_smbus_read_byte_data(c, TPS_VDCDC2));
+
+	status = i2c_smbus_write_byte_data(c, TPS_VDCDC2, value);
+
+	if (status != 0)
+		printk(KERN_ERR "%s: Failed to write vdcdc2 register\n",
+			DRIVER_NAME);
+	else
+		pr_debug("%s: vregs1 0x%02x\n", DRIVER_NAME,
+			 i2c_smbus_read_byte_data(c, TPS_VDCDC2));
+
+	mutex_unlock(&the_tps->lock);
+	return status;
+}
+EXPORT_SYMBOL(tps65010_config_vdcdc2);
+
 /*-------------------------------------------------------------------------*/
 /* tps65013_set_low_pwr parameter:
  * mode: ON or OFF

commit 848369926693778cd0f31bfca7fb951164715b4f
Author: Ben Dooks <ben@simtec.co.uk>
Date:   Mon Nov 2 16:52:20 2009 +0000

    mfd: Allow the board to choose any GPIO base for tps65010
    
    If the board does not care where the TPS turns up, then specifiying the
    value -1 to get gpiolib to dynamically allocate the base for the chip
    is valid.
    
    Change the test to look for != 0, so that any boards specifying zero
    will not end up with gpio that they didn't want.
    
    Signed-off-by: Ben Dooks <ben@simtec.co.uk>
    Signed-off-by: Simtec Liunx Team <linux@simtec.co.uk>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
index acf8b9d5f575..755c4030ea31 100644
--- a/drivers/mfd/tps65010.c
+++ b/drivers/mfd/tps65010.c
@@ -637,7 +637,7 @@ static int tps65010_probe(struct i2c_client *client,
 				tps, DEBUG_FOPS);
 
 	/* optionally register GPIOs */
-	if (board && board->base > 0) {
+	if (board && board->base != 0) {
 		tps->outmask = board->outmask;
 
 		tps->chip.label = client->name;

commit 87c13493e6a59c0da55c2824f0205f9ef941b760
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Mon Dec 22 12:16:27 2008 +0100

    mfd: move drivers/i2c/chips/tps65010.c to drivers/mfd
    
    Move the tps65010 driver from drivers/i2c/chips to drivers/mfd
    since it's more of a multi-function device than anything else,
    and since Jean is trying to vanish drivers/i2c/chips ASAP.
    
    One way to think of these chips are as the PMIC family most
    used with OMAP1 generation chips.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/tps65010.c b/drivers/mfd/tps65010.c
new file mode 100644
index 000000000000..acf8b9d5f575
--- /dev/null
+++ b/drivers/mfd/tps65010.c
@@ -0,0 +1,1072 @@
+/*
+ * tps65010 - driver for tps6501x power management chips
+ *
+ * Copyright (C) 2004 Texas Instruments
+ * Copyright (C) 2004-2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+
+#include <linux/i2c/tps65010.h>
+
+#include <asm/gpio.h>
+
+
+/*-------------------------------------------------------------------------*/
+
+#define	DRIVER_VERSION	"2 May 2005"
+#define	DRIVER_NAME	(tps65010_driver.driver.name)
+
+MODULE_DESCRIPTION("TPS6501x Power Management Driver");
+MODULE_LICENSE("GPL");
+
+static struct i2c_driver tps65010_driver;
+
+/*-------------------------------------------------------------------------*/
+
+/* This driver handles a family of multipurpose chips, which incorporate
+ * voltage regulators, lithium ion/polymer battery charging, GPIOs, LEDs,
+ * and other features often needed in portable devices like cell phones
+ * or digital cameras.
+ *
+ * The tps65011 and tps65013 have different voltage settings compared
+ * to tps65010 and tps65012.  The tps65013 has a NO_CHG status/irq.
+ * All except tps65010 have "wait" mode, possibly defaulted so that
+ * battery-insert != device-on.
+ *
+ * We could distinguish between some models by checking VDCDC1.UVLO or
+ * other registers, unless they've been changed already after powerup
+ * as part of board setup by a bootloader.
+ */
+enum tps_model {
+	TPS65010,
+	TPS65011,
+	TPS65012,
+	TPS65013,
+};
+
+struct tps65010 {
+	struct i2c_client	*client;
+	struct mutex		lock;
+	struct delayed_work	work;
+	struct dentry		*file;
+	unsigned		charging:1;
+	unsigned		por:1;
+	unsigned		model:8;
+	u16			vbus;
+	unsigned long		flags;
+#define	FLAG_VBUS_CHANGED	0
+#define	FLAG_IRQ_ENABLE		1
+
+	/* copies of last register state */
+	u8			chgstatus, regstatus, chgconf;
+	u8			nmask1, nmask2;
+
+	u8			outmask;
+	struct gpio_chip	chip;
+	struct platform_device	*leds;
+};
+
+#define	POWER_POLL_DELAY	msecs_to_jiffies(5000)
+
+/*-------------------------------------------------------------------------*/
+
+#if	defined(DEBUG) || defined(CONFIG_DEBUG_FS)
+
+static void dbg_chgstat(char *buf, size_t len, u8 chgstatus)
+{
+	snprintf(buf, len, "%02x%s%s%s%s%s%s%s%s\n",
+		chgstatus,
+		(chgstatus & TPS_CHG_USB) ? " USB" : "",
+		(chgstatus & TPS_CHG_AC) ? " AC" : "",
+		(chgstatus & TPS_CHG_THERM) ? " therm" : "",
+		(chgstatus & TPS_CHG_TERM) ? " done" :
+			((chgstatus & (TPS_CHG_USB|TPS_CHG_AC))
+				? " (charging)" : ""),
+		(chgstatus & TPS_CHG_TAPER_TMO) ? " taper_tmo" : "",
+		(chgstatus & TPS_CHG_CHG_TMO) ? " charge_tmo" : "",
+		(chgstatus & TPS_CHG_PRECHG_TMO) ? " prechg_tmo" : "",
+		(chgstatus & TPS_CHG_TEMP_ERR) ? " temp_err" : "");
+}
+
+static void dbg_regstat(char *buf, size_t len, u8 regstatus)
+{
+	snprintf(buf, len, "%02x %s%s%s%s%s%s%s%s\n",
+		regstatus,
+		(regstatus & TPS_REG_ONOFF) ? "off" : "(on)",
+		(regstatus & TPS_REG_COVER) ? " uncover" : "",
+		(regstatus & TPS_REG_UVLO) ? " UVLO" : "",
+		(regstatus & TPS_REG_NO_CHG) ? " NO_CHG" : "",
+		(regstatus & TPS_REG_PG_LD02) ? " ld02_bad" : "",
+		(regstatus & TPS_REG_PG_LD01) ? " ld01_bad" : "",
+		(regstatus & TPS_REG_PG_MAIN) ? " main_bad" : "",
+		(regstatus & TPS_REG_PG_CORE) ? " core_bad" : "");
+}
+
+static void dbg_chgconf(int por, char *buf, size_t len, u8 chgconfig)
+{
+	const char *hibit;
+
+	if (por)
+		hibit = (chgconfig & TPS_CHARGE_POR)
+				? "POR=69ms" : "POR=1sec";
+	else
+		hibit = (chgconfig & TPS65013_AUA) ? "AUA" : "";
+
+	snprintf(buf, len, "%02x %s%s%s AC=%d%% USB=%dmA %sCharge\n",
+		chgconfig, hibit,
+		(chgconfig & TPS_CHARGE_RESET) ? " reset" : "",
+		(chgconfig & TPS_CHARGE_FAST) ? " fast" : "",
+		({int p; switch ((chgconfig >> 3) & 3) {
+		case 3:		p = 100; break;
+		case 2:		p = 75; break;
+		case 1:		p = 50; break;
+		default:	p = 25; break;
+		}; p; }),
+		(chgconfig & TPS_VBUS_CHARGING)
+			? ((chgconfig & TPS_VBUS_500MA) ? 500 : 100)
+			: 0,
+		(chgconfig & TPS_CHARGE_ENABLE) ? "" : "No");
+}
+
+#endif
+
+#ifdef	DEBUG
+
+static void show_chgstatus(const char *label, u8 chgstatus)
+{
+	char buf [100];
+
+	dbg_chgstat(buf, sizeof buf, chgstatus);
+	pr_debug("%s: %s %s", DRIVER_NAME, label, buf);
+}
+
+static void show_regstatus(const char *label, u8 regstatus)
+{
+	char buf [100];
+
+	dbg_regstat(buf, sizeof buf, regstatus);
+	pr_debug("%s: %s %s", DRIVER_NAME, label, buf);
+}
+
+static void show_chgconfig(int por, const char *label, u8 chgconfig)
+{
+	char buf [100];
+
+	dbg_chgconf(por, buf, sizeof buf, chgconfig);
+	pr_debug("%s: %s %s", DRIVER_NAME, label, buf);
+}
+
+#else
+
+static inline void show_chgstatus(const char *label, u8 chgstatus) { }
+static inline void show_regstatus(const char *label, u8 chgstatus) { }
+static inline void show_chgconfig(int por, const char *label, u8 chgconfig) { }
+
+#endif
+
+#ifdef	CONFIG_DEBUG_FS
+
+static int dbg_show(struct seq_file *s, void *_)
+{
+	struct tps65010	*tps = s->private;
+	u8		value, v2;
+	unsigned	i;
+	char		buf[100];
+	const char	*chip;
+
+	switch (tps->model) {
+	case TPS65010:	chip = "tps65010"; break;
+	case TPS65011:	chip = "tps65011"; break;
+	case TPS65012:	chip = "tps65012"; break;
+	case TPS65013:	chip = "tps65013"; break;
+	default:	chip = NULL; break;
+	}
+	seq_printf(s, "driver  %s\nversion %s\nchip    %s\n\n",
+			DRIVER_NAME, DRIVER_VERSION, chip);
+
+	mutex_lock(&tps->lock);
+
+	/* FIXME how can we tell whether a battery is present?
+	 * likely involves a charge gauging chip (like BQ26501).
+	 */
+
+	seq_printf(s, "%scharging\n\n", tps->charging ? "" : "(not) ");
+
+
+	/* registers for monitoring battery charging and status; note
+	 * that reading chgstat and regstat may ack IRQs...
+	 */
+	value = i2c_smbus_read_byte_data(tps->client, TPS_CHGCONFIG);
+	dbg_chgconf(tps->por, buf, sizeof buf, value);
+	seq_printf(s, "chgconfig %s", buf);
+
+	value = i2c_smbus_read_byte_data(tps->client, TPS_CHGSTATUS);
+	dbg_chgstat(buf, sizeof buf, value);
+	seq_printf(s, "chgstat   %s", buf);
+	value = i2c_smbus_read_byte_data(tps->client, TPS_MASK1);
+	dbg_chgstat(buf, sizeof buf, value);
+	seq_printf(s, "mask1     %s", buf);
+	/* ignore ackint1 */
+
+	value = i2c_smbus_read_byte_data(tps->client, TPS_REGSTATUS);
+	dbg_regstat(buf, sizeof buf, value);
+	seq_printf(s, "regstat   %s", buf);
+	value = i2c_smbus_read_byte_data(tps->client, TPS_MASK2);
+	dbg_regstat(buf, sizeof buf, value);
+	seq_printf(s, "mask2     %s\n", buf);
+	/* ignore ackint2 */
+
+	(void) schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
+
+
+	/* VMAIN voltage, enable lowpower, etc */
+	value = i2c_smbus_read_byte_data(tps->client, TPS_VDCDC1);
+	seq_printf(s, "vdcdc1    %02x\n", value);
+
+	/* VCORE voltage, vibrator on/off */
+	value = i2c_smbus_read_byte_data(tps->client, TPS_VDCDC2);
+	seq_printf(s, "vdcdc2    %02x\n", value);
+
+	/* both LD0s, and their lowpower behavior */
+	value = i2c_smbus_read_byte_data(tps->client, TPS_VREGS1);
+	seq_printf(s, "vregs1    %02x\n\n", value);
+
+
+	/* LEDs and GPIOs */
+	value = i2c_smbus_read_byte_data(tps->client, TPS_LED1_ON);
+	v2 = i2c_smbus_read_byte_data(tps->client, TPS_LED1_PER);
+	seq_printf(s, "led1 %s, on=%02x, per=%02x, %d/%d msec\n",
+		(value & 0x80)
+			? ((v2 & 0x80) ? "on" : "off")
+			: ((v2 & 0x80) ? "blink" : "(nPG)"),
+		value, v2,
+		(value & 0x7f) * 10, (v2 & 0x7f) * 100);
+
+	value = i2c_smbus_read_byte_data(tps->client, TPS_LED2_ON);
+	v2 = i2c_smbus_read_byte_data(tps->client, TPS_LED2_PER);
+	seq_printf(s, "led2 %s, on=%02x, per=%02x, %d/%d msec\n",
+		(value & 0x80)
+			? ((v2 & 0x80) ? "on" : "off")
+			: ((v2 & 0x80) ? "blink" : "off"),
+		value, v2,
+		(value & 0x7f) * 10, (v2 & 0x7f) * 100);
+
+	value = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);
+	v2 = i2c_smbus_read_byte_data(tps->client, TPS_MASK3);
+	seq_printf(s, "defgpio %02x mask3 %02x\n", value, v2);
+
+	for (i = 0; i < 4; i++) {
+		if (value & (1 << (4 + i)))
+			seq_printf(s, "  gpio%d-out %s\n", i + 1,
+				(value & (1 << i)) ? "low" : "hi ");
+		else
+			seq_printf(s, "  gpio%d-in  %s %s %s\n", i + 1,
+				(value & (1 << i)) ? "hi " : "low",
+				(v2 & (1 << i)) ? "no-irq" : "irq",
+				(v2 & (1 << (4 + i))) ? "rising" : "falling");
+	}
+
+	mutex_unlock(&tps->lock);
+	return 0;
+}
+
+static int dbg_tps_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dbg_show, inode->i_private);
+}
+
+static const struct file_operations debug_fops = {
+	.open		= dbg_tps_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define	DEBUG_FOPS	&debug_fops
+
+#else
+#define	DEBUG_FOPS	NULL
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/* handle IRQS in a task context, so we can use I2C calls */
+static void tps65010_interrupt(struct tps65010 *tps)
+{
+	u8 tmp = 0, mask, poll;
+
+	/* IRQs won't trigger for certain events, but we can get
+	 * others by polling (normally, with external power applied).
+	 */
+	poll = 0;
+
+	/* regstatus irqs */
+	if (tps->nmask2) {
+		tmp = i2c_smbus_read_byte_data(tps->client, TPS_REGSTATUS);
+		mask = tmp ^ tps->regstatus;
+		tps->regstatus = tmp;
+		mask &= tps->nmask2;
+	} else
+		mask = 0;
+	if (mask) {
+		tps->regstatus =  tmp;
+		/* may need to shut something down ... */
+
+		/* "off" usually means deep sleep */
+		if (tmp & TPS_REG_ONOFF) {
+			pr_info("%s: power off button\n", DRIVER_NAME);
+#if 0
+			/* REVISIT:  this might need its own workqueue
+			 * plus tweaks including deadlock avoidance ...
+			 * also needs to get error handling and probably
+			 * an #ifdef CONFIG_HIBERNATION
+			 */
+			hibernate();
+#endif
+			poll = 1;
+		}
+	}
+
+	/* chgstatus irqs */
+	if (tps->nmask1) {
+		tmp = i2c_smbus_read_byte_data(tps->client, TPS_CHGSTATUS);
+		mask = tmp ^ tps->chgstatus;
+		tps->chgstatus = tmp;
+		mask &= tps->nmask1;
+	} else
+		mask = 0;
+	if (mask) {
+		unsigned	charging = 0;
+
+		show_chgstatus("chg/irq", tmp);
+		if (tmp & (TPS_CHG_USB|TPS_CHG_AC))
+			show_chgconfig(tps->por, "conf", tps->chgconf);
+
+		/* Unless it was turned off or disabled, we charge any
+		 * battery whenever there's power available for it
+		 * and the charger hasn't been disabled.
+		 */
+		if (!(tps->chgstatus & ~(TPS_CHG_USB|TPS_CHG_AC))
+				&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC))
+				&& (tps->chgconf & TPS_CHARGE_ENABLE)
+				) {
+			if (tps->chgstatus & TPS_CHG_USB) {
+				/* VBUS options are readonly until reconnect */
+				if (mask & TPS_CHG_USB)
+					set_bit(FLAG_VBUS_CHANGED, &tps->flags);
+				charging = 1;
+			} else if (tps->chgstatus & TPS_CHG_AC)
+				charging = 1;
+		}
+		if (charging != tps->charging) {
+			tps->charging = charging;
+			pr_info("%s: battery %scharging\n",
+				DRIVER_NAME, charging ? "" :
+				((tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC))
+					? "NOT " : "dis"));
+		}
+	}
+
+	/* always poll to detect (a) power removal, without tps65013
+	 * NO_CHG IRQ; or (b) restart of charging after stop.
+	 */
+	if ((tps->model != TPS65013 || !tps->charging)
+			&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC)))
+		poll = 1;
+	if (poll)
+		(void) schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
+
+	/* also potentially gpio-in rise or fall */
+}
+
+/* handle IRQs and polling using keventd for now */
+static void tps65010_work(struct work_struct *work)
+{
+	struct tps65010		*tps;
+
+	tps = container_of(work, struct tps65010, work.work);
+	mutex_lock(&tps->lock);
+
+	tps65010_interrupt(tps);
+
+	if (test_and_clear_bit(FLAG_VBUS_CHANGED, &tps->flags)) {
+		int	status;
+		u8	chgconfig, tmp;
+
+		chgconfig = i2c_smbus_read_byte_data(tps->client,
+					TPS_CHGCONFIG);
+		chgconfig &= ~(TPS_VBUS_500MA | TPS_VBUS_CHARGING);
+		if (tps->vbus == 500)
+			chgconfig |= TPS_VBUS_500MA | TPS_VBUS_CHARGING;
+		else if (tps->vbus >= 100)
+			chgconfig |= TPS_VBUS_CHARGING;
+
+		status = i2c_smbus_write_byte_data(tps->client,
+				TPS_CHGCONFIG, chgconfig);
+
+		/* vbus update fails unless VBUS is connected! */
+		tmp = i2c_smbus_read_byte_data(tps->client, TPS_CHGCONFIG);
+		tps->chgconf = tmp;
+		show_chgconfig(tps->por, "update vbus", tmp);
+	}
+
+	if (test_and_clear_bit(FLAG_IRQ_ENABLE, &tps->flags))
+		enable_irq(tps->client->irq);
+
+	mutex_unlock(&tps->lock);
+}
+
+static irqreturn_t tps65010_irq(int irq, void *_tps)
+{
+	struct tps65010		*tps = _tps;
+
+	disable_irq_nosync(irq);
+	set_bit(FLAG_IRQ_ENABLE, &tps->flags);
+	(void) schedule_work(&tps->work.work);
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* offsets 0..3 == GPIO1..GPIO4
+ * offsets 4..5 == LED1/nPG, LED2 (we set one of the non-BLINK modes)
+ * offset 6 == vibrator motor driver
+ */
+static void
+tps65010_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	if (offset < 4)
+		tps65010_set_gpio_out_value(offset + 1, value);
+	else if (offset < 6)
+		tps65010_set_led(offset - 3, value ? ON : OFF);
+	else
+		tps65010_set_vib(value);
+}
+
+static int
+tps65010_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	/* GPIOs may be input-only */
+	if (offset < 4) {
+		struct tps65010		*tps;
+
+		tps = container_of(chip, struct tps65010, chip);
+		if (!(tps->outmask & (1 << offset)))
+			return -EINVAL;
+		tps65010_set_gpio_out_value(offset + 1, value);
+	} else if (offset < 6)
+		tps65010_set_led(offset - 3, value ? ON : OFF);
+	else
+		tps65010_set_vib(value);
+
+	return 0;
+}
+
+static int tps65010_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	int			value;
+	struct tps65010		*tps;
+
+	tps = container_of(chip, struct tps65010, chip);
+
+	if (offset < 4) {
+		value = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);
+		if (value < 0)
+			return 0;
+		if (value & (1 << (offset + 4)))	/* output */
+			return !(value & (1 << offset));
+		else					/* input */
+			return (value & (1 << offset));
+	}
+
+	/* REVISIT we *could* report LED1/nPG and LED2 state ... */
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static struct tps65010 *the_tps;
+
+static int __exit tps65010_remove(struct i2c_client *client)
+{
+	struct tps65010		*tps = i2c_get_clientdata(client);
+	struct tps65010_board	*board = client->dev.platform_data;
+
+	if (board && board->teardown) {
+		int status = board->teardown(client, board->context);
+		if (status < 0)
+			dev_dbg(&client->dev, "board %s %s err %d\n",
+				"teardown", client->name, status);
+	}
+	if (client->irq > 0)
+		free_irq(client->irq, tps);
+	cancel_delayed_work(&tps->work);
+	flush_scheduled_work();
+	debugfs_remove(tps->file);
+	kfree(tps);
+	i2c_set_clientdata(client, NULL);
+	the_tps = NULL;
+	return 0;
+}
+
+static int tps65010_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
+{
+	struct tps65010		*tps;
+	int			status;
+	struct tps65010_board	*board = client->dev.platform_data;
+
+	if (the_tps) {
+		dev_dbg(&client->dev, "only one tps6501x chip allowed\n");
+		return -ENODEV;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -EINVAL;
+
+	tps = kzalloc(sizeof *tps, GFP_KERNEL);
+	if (!tps)
+		return -ENOMEM;
+
+	mutex_init(&tps->lock);
+	INIT_DELAYED_WORK(&tps->work, tps65010_work);
+	tps->client = client;
+	tps->model = id->driver_data;
+
+	/* the IRQ is active low, but many gpio lines can't support that
+	 * so this driver uses falling-edge triggers instead.
+	 */
+	if (client->irq > 0) {
+		status = request_irq(client->irq, tps65010_irq,
+			IRQF_SAMPLE_RANDOM | IRQF_TRIGGER_FALLING,
+			DRIVER_NAME, tps);
+		if (status < 0) {
+			dev_dbg(&client->dev, "can't get IRQ %d, err %d\n",
+					client->irq, status);
+			goto fail1;
+		}
+		/* annoying race here, ideally we'd have an option
+		 * to claim the irq now and enable it later.
+		 * FIXME genirq IRQF_NOAUTOEN now solves that ...
+		 */
+		disable_irq(client->irq);
+		set_bit(FLAG_IRQ_ENABLE, &tps->flags);
+	} else
+		dev_warn(&client->dev, "IRQ not configured!\n");
+
+
+	switch (tps->model) {
+	case TPS65010:
+	case TPS65012:
+		tps->por = 1;
+		break;
+	/* else CHGCONFIG.POR is replaced by AUA, enabling a WAIT mode */
+	}
+	tps->chgconf = i2c_smbus_read_byte_data(client, TPS_CHGCONFIG);
+	show_chgconfig(tps->por, "conf/init", tps->chgconf);
+
+	show_chgstatus("chg/init",
+		i2c_smbus_read_byte_data(client, TPS_CHGSTATUS));
+	show_regstatus("reg/init",
+		i2c_smbus_read_byte_data(client, TPS_REGSTATUS));
+
+	pr_debug("%s: vdcdc1 0x%02x, vdcdc2 %02x, vregs1 %02x\n", DRIVER_NAME,
+		i2c_smbus_read_byte_data(client, TPS_VDCDC1),
+		i2c_smbus_read_byte_data(client, TPS_VDCDC2),
+		i2c_smbus_read_byte_data(client, TPS_VREGS1));
+	pr_debug("%s: defgpio 0x%02x, mask3 0x%02x\n", DRIVER_NAME,
+		i2c_smbus_read_byte_data(client, TPS_DEFGPIO),
+		i2c_smbus_read_byte_data(client, TPS_MASK3));
+
+	i2c_set_clientdata(client, tps);
+	the_tps = tps;
+
+#if	defined(CONFIG_USB_GADGET) && !defined(CONFIG_USB_OTG)
+	/* USB hosts can't draw VBUS.  OTG devices could, later
+	 * when OTG infrastructure enables it.  USB peripherals
+	 * could be relying on VBUS while booting, though.
+	 */
+	tps->vbus = 100;
+#endif
+
+	/* unmask the "interesting" irqs, then poll once to
+	 * kickstart monitoring, initialize shadowed status
+	 * registers, and maybe disable VBUS draw.
+	 */
+	tps->nmask1 = ~0;
+	(void) i2c_smbus_write_byte_data(client, TPS_MASK1, ~tps->nmask1);
+
+	tps->nmask2 = TPS_REG_ONOFF;
+	if (tps->model == TPS65013)
+		tps->nmask2 |= TPS_REG_NO_CHG;
+	(void) i2c_smbus_write_byte_data(client, TPS_MASK2, ~tps->nmask2);
+
+	(void) i2c_smbus_write_byte_data(client, TPS_MASK3, 0x0f
+		| i2c_smbus_read_byte_data(client, TPS_MASK3));
+
+	tps65010_work(&tps->work.work);
+
+	tps->file = debugfs_create_file(DRIVER_NAME, S_IRUGO, NULL,
+				tps, DEBUG_FOPS);
+
+	/* optionally register GPIOs */
+	if (board && board->base > 0) {
+		tps->outmask = board->outmask;
+
+		tps->chip.label = client->name;
+		tps->chip.dev = &client->dev;
+		tps->chip.owner = THIS_MODULE;
+
+		tps->chip.set = tps65010_gpio_set;
+		tps->chip.direction_output = tps65010_output;
+
+		/* NOTE:  only partial support for inputs; nyet IRQs */
+		tps->chip.get = tps65010_gpio_get;
+
+		tps->chip.base = board->base;
+		tps->chip.ngpio = 7;
+		tps->chip.can_sleep = 1;
+
+		status = gpiochip_add(&tps->chip);
+		if (status < 0)
+			dev_err(&client->dev, "can't add gpiochip, err %d\n",
+					status);
+		else if (board->setup) {
+			status = board->setup(client, board->context);
+			if (status < 0) {
+				dev_dbg(&client->dev,
+					"board %s %s err %d\n",
+					"setup", client->name, status);
+				status = 0;
+			}
+		}
+	}
+
+	return 0;
+fail1:
+	kfree(tps);
+	return status;
+}
+
+static const struct i2c_device_id tps65010_id[] = {
+	{ "tps65010", TPS65010 },
+	{ "tps65011", TPS65011 },
+	{ "tps65012", TPS65012 },
+	{ "tps65013", TPS65013 },
+	{ "tps65014", TPS65011 },	/* tps65011 charging at 6.5V max */
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tps65010_id);
+
+static struct i2c_driver tps65010_driver = {
+	.driver = {
+		.name	= "tps65010",
+	},
+	.probe	= tps65010_probe,
+	.remove	= __exit_p(tps65010_remove),
+	.id_table = tps65010_id,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Draw from VBUS:
+ *   0 mA -- DON'T DRAW (might supply power instead)
+ * 100 mA -- usb unit load (slowest charge rate)
+ * 500 mA -- usb high power (fast battery charge)
+ */
+int tps65010_set_vbus_draw(unsigned mA)
+{
+	unsigned long	flags;
+
+	if (!the_tps)
+		return -ENODEV;
+
+	/* assumes non-SMP */
+	local_irq_save(flags);
+	if (mA >= 500)
+		mA = 500;
+	else if (mA >= 100)
+		mA = 100;
+	else
+		mA = 0;
+	the_tps->vbus = mA;
+	if ((the_tps->chgstatus & TPS_CHG_USB)
+			&& test_and_set_bit(
+				FLAG_VBUS_CHANGED, &the_tps->flags)) {
+		/* gadget drivers call this in_irq() */
+		(void) schedule_work(&the_tps->work.work);
+	}
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(tps65010_set_vbus_draw);
+
+/*-------------------------------------------------------------------------*/
+/* tps65010_set_gpio_out_value parameter:
+ * gpio:  GPIO1, GPIO2, GPIO3 or GPIO4
+ * value: LOW or HIGH
+ */
+int tps65010_set_gpio_out_value(unsigned gpio, unsigned value)
+{
+	int	 status;
+	unsigned defgpio;
+
+	if (!the_tps)
+		return -ENODEV;
+	if ((gpio < GPIO1) || (gpio > GPIO4))
+		return -EINVAL;
+
+	mutex_lock(&the_tps->lock);
+
+	defgpio = i2c_smbus_read_byte_data(the_tps->client, TPS_DEFGPIO);
+
+	/* Configure GPIO for output */
+	defgpio |= 1 << (gpio + 3);
+
+	/* Writing 1 forces a logic 0 on that GPIO and vice versa */
+	switch (value) {
+	case LOW:
+		defgpio |= 1 << (gpio - 1);    /* set GPIO low by writing 1 */
+		break;
+	/* case HIGH: */
+	default:
+		defgpio &= ~(1 << (gpio - 1)); /* set GPIO high by writing 0 */
+		break;
+	}
+
+	status = i2c_smbus_write_byte_data(the_tps->client,
+		TPS_DEFGPIO, defgpio);
+
+	pr_debug("%s: gpio%dout = %s, defgpio 0x%02x\n", DRIVER_NAME,
+		gpio, value ? "high" : "low",
+		i2c_smbus_read_byte_data(the_tps->client, TPS_DEFGPIO));
+
+	mutex_unlock(&the_tps->lock);
+	return status;
+}
+EXPORT_SYMBOL(tps65010_set_gpio_out_value);
+
+/*-------------------------------------------------------------------------*/
+/* tps65010_set_led parameter:
+ * led:  LED1 or LED2
+ * mode: ON, OFF or BLINK
+ */
+int tps65010_set_led(unsigned led, unsigned mode)
+{
+	int	 status;
+	unsigned led_on, led_per, offs;
+
+	if (!the_tps)
+		return -ENODEV;
+
+	if (led == LED1)
+		offs = 0;
+	else {
+		offs = 2;
+		led = LED2;
+	}
+
+	mutex_lock(&the_tps->lock);
+
+	pr_debug("%s: led%i_on   0x%02x\n", DRIVER_NAME, led,
+		i2c_smbus_read_byte_data(the_tps->client,
+				TPS_LED1_ON + offs));
+
+	pr_debug("%s: led%i_per  0x%02x\n", DRIVER_NAME, led,
+		i2c_smbus_read_byte_data(the_tps->client,
+				TPS_LED1_PER + offs));
+
+	switch (mode) {
+	case OFF:
+		led_on  = 1 << 7;
+		led_per = 0 << 7;
+		break;
+	case ON:
+		led_on  = 1 << 7;
+		led_per = 1 << 7;
+		break;
+	case BLINK:
+		led_on  = 0x30 | (0 << 7);
+		led_per = 0x08 | (1 << 7);
+		break;
+	default:
+		printk(KERN_ERR "%s: Wrong mode parameter for set_led()\n",
+		       DRIVER_NAME);
+		mutex_unlock(&the_tps->lock);
+		return -EINVAL;
+	}
+
+	status = i2c_smbus_write_byte_data(the_tps->client,
+			TPS_LED1_ON + offs, led_on);
+
+	if (status != 0) {
+		printk(KERN_ERR "%s: Failed to write led%i_on register\n",
+		       DRIVER_NAME, led);
+		mutex_unlock(&the_tps->lock);
+		return status;
+	}
+
+	pr_debug("%s: led%i_on   0x%02x\n", DRIVER_NAME, led,
+		i2c_smbus_read_byte_data(the_tps->client, TPS_LED1_ON + offs));
+
+	status = i2c_smbus_write_byte_data(the_tps->client,
+			TPS_LED1_PER + offs, led_per);
+
+	if (status != 0) {
+		printk(KERN_ERR "%s: Failed to write led%i_per register\n",
+		       DRIVER_NAME, led);
+		mutex_unlock(&the_tps->lock);
+		return status;
+	}
+
+	pr_debug("%s: led%i_per  0x%02x\n", DRIVER_NAME, led,
+		i2c_smbus_read_byte_data(the_tps->client,
+				TPS_LED1_PER + offs));
+
+	mutex_unlock(&the_tps->lock);
+
+	return status;
+}
+EXPORT_SYMBOL(tps65010_set_led);
+
+/*-------------------------------------------------------------------------*/
+/* tps65010_set_vib parameter:
+ * value: ON or OFF
+ */
+int tps65010_set_vib(unsigned value)
+{
+	int	 status;
+	unsigned vdcdc2;
+
+	if (!the_tps)
+		return -ENODEV;
+
+	mutex_lock(&the_tps->lock);
+
+	vdcdc2 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC2);
+	vdcdc2 &= ~(1 << 1);
+	if (value)
+		vdcdc2 |= (1 << 1);
+	status = i2c_smbus_write_byte_data(the_tps->client,
+		TPS_VDCDC2, vdcdc2);
+
+	pr_debug("%s: vibrator %s\n", DRIVER_NAME, value ? "on" : "off");
+
+	mutex_unlock(&the_tps->lock);
+	return status;
+}
+EXPORT_SYMBOL(tps65010_set_vib);
+
+/*-------------------------------------------------------------------------*/
+/* tps65010_set_low_pwr parameter:
+ * mode: ON or OFF
+ */
+int tps65010_set_low_pwr(unsigned mode)
+{
+	int	 status;
+	unsigned vdcdc1;
+
+	if (!the_tps)
+		return -ENODEV;
+
+	mutex_lock(&the_tps->lock);
+
+	pr_debug("%s: %s low_pwr, vdcdc1 0x%02x\n", DRIVER_NAME,
+		mode ? "enable" : "disable",
+		i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));
+
+	vdcdc1 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1);
+
+	switch (mode) {
+	case OFF:
+		vdcdc1 &= ~TPS_ENABLE_LP; /* disable ENABLE_LP bit */
+		break;
+	/* case ON: */
+	default:
+		vdcdc1 |= TPS_ENABLE_LP;  /* enable ENABLE_LP bit */
+		break;
+	}
+
+	status = i2c_smbus_write_byte_data(the_tps->client,
+			TPS_VDCDC1, vdcdc1);
+
+	if (status != 0)
+		printk(KERN_ERR "%s: Failed to write vdcdc1 register\n",
+			DRIVER_NAME);
+	else
+		pr_debug("%s: vdcdc1 0x%02x\n", DRIVER_NAME,
+			i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));
+
+	mutex_unlock(&the_tps->lock);
+
+	return status;
+}
+EXPORT_SYMBOL(tps65010_set_low_pwr);
+
+/*-------------------------------------------------------------------------*/
+/* tps65010_config_vregs1 parameter:
+ * value to be written to VREGS1 register
+ * Note: The complete register is written, set all bits you need
+ */
+int tps65010_config_vregs1(unsigned value)
+{
+	int	 status;
+
+	if (!the_tps)
+		return -ENODEV;
+
+	mutex_lock(&the_tps->lock);
+
+	pr_debug("%s: vregs1 0x%02x\n", DRIVER_NAME,
+			i2c_smbus_read_byte_data(the_tps->client, TPS_VREGS1));
+
+	status = i2c_smbus_write_byte_data(the_tps->client,
+			TPS_VREGS1, value);
+
+	if (status != 0)
+		printk(KERN_ERR "%s: Failed to write vregs1 register\n",
+			DRIVER_NAME);
+	else
+		pr_debug("%s: vregs1 0x%02x\n", DRIVER_NAME,
+			i2c_smbus_read_byte_data(the_tps->client, TPS_VREGS1));
+
+	mutex_unlock(&the_tps->lock);
+
+	return status;
+}
+EXPORT_SYMBOL(tps65010_config_vregs1);
+
+/*-------------------------------------------------------------------------*/
+/* tps65013_set_low_pwr parameter:
+ * mode: ON or OFF
+ */
+
+/* FIXME: Assumes AC or USB power is present. Setting AUA bit is not
+	required if power supply is through a battery */
+
+int tps65013_set_low_pwr(unsigned mode)
+{
+	int	 status;
+	unsigned vdcdc1, chgconfig;
+
+	if (!the_tps || the_tps->por)
+		return -ENODEV;
+
+	mutex_lock(&the_tps->lock);
+
+	pr_debug("%s: %s low_pwr, chgconfig 0x%02x vdcdc1 0x%02x\n",
+		DRIVER_NAME,
+		mode ? "enable" : "disable",
+		i2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG),
+		i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));
+
+	chgconfig = i2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG);
+	vdcdc1 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1);
+
+	switch (mode) {
+	case OFF:
+		chgconfig &= ~TPS65013_AUA; /* disable AUA bit */
+		vdcdc1 &= ~TPS_ENABLE_LP; /* disable ENABLE_LP bit */
+		break;
+	/* case ON: */
+	default:
+		chgconfig |= TPS65013_AUA;  /* enable AUA bit */
+		vdcdc1 |= TPS_ENABLE_LP;  /* enable ENABLE_LP bit */
+		break;
+	}
+
+	status = i2c_smbus_write_byte_data(the_tps->client,
+			TPS_CHGCONFIG, chgconfig);
+	if (status != 0) {
+		printk(KERN_ERR "%s: Failed to write chconfig register\n",
+	 DRIVER_NAME);
+		mutex_unlock(&the_tps->lock);
+		return status;
+	}
+
+	chgconfig = i2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG);
+	the_tps->chgconf = chgconfig;
+	show_chgconfig(0, "chgconf", chgconfig);
+
+	status = i2c_smbus_write_byte_data(the_tps->client,
+			TPS_VDCDC1, vdcdc1);
+
+	if (status != 0)
+		printk(KERN_ERR "%s: Failed to write vdcdc1 register\n",
+	 DRIVER_NAME);
+	else
+		pr_debug("%s: vdcdc1 0x%02x\n", DRIVER_NAME,
+			i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));
+
+	mutex_unlock(&the_tps->lock);
+
+	return status;
+}
+EXPORT_SYMBOL(tps65013_set_low_pwr);
+
+/*-------------------------------------------------------------------------*/
+
+static int __init tps_init(void)
+{
+	u32	tries = 3;
+	int	status = -ENODEV;
+
+	printk(KERN_INFO "%s: version %s\n", DRIVER_NAME, DRIVER_VERSION);
+
+	/* some boards have startup glitches */
+	while (tries--) {
+		status = i2c_add_driver(&tps65010_driver);
+		if (the_tps)
+			break;
+		i2c_del_driver(&tps65010_driver);
+		if (!tries) {
+			printk(KERN_ERR "%s: no chip?\n", DRIVER_NAME);
+			return -ENODEV;
+		}
+		pr_debug("%s: re-probe ...\n", DRIVER_NAME);
+		msleep(10);
+	}
+
+	return status;
+}
+/* NOTE:  this MUST be initialized before the other parts of the system
+ * that rely on it ... but after the i2c bus on which this relies.
+ * That is, much earlier than on PC-type systems, which don't often use
+ * I2C as a core system bus.
+ */
+subsys_initcall(tps_init);
+
+static void __exit tps_exit(void)
+{
+	i2c_del_driver(&tps65010_driver);
+}
+module_exit(tps_exit);
+
