commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 2a2756709f22..151c36ce7343 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * dm355evm_msp.c - driver for MSP430 firmware on DM355EVM board
  *
  * Copyright (C) 2008 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/init.h>

commit 0335a9554b4d6acc2d17efe752bff54ce59b57eb
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Aug 14 18:34:22 2017 +0200

    mfd: dm355evm_msp: Move header file out of I2C realm
    
    include/linux/i2c is not for client devices. Move the header file to a
    more appropriate location.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 86eca614507b..2a2756709f22 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -18,7 +18,7 @@
 #include <linux/gpio.h>
 #include <linux/leds.h>
 #include <linux/i2c.h>
-#include <linux/i2c/dm355evm_msp.h>
+#include <linux/mfd/dm355evm_msp.h>
 
 
 /*

commit 29090265a242765a0d84bd04ce90e0fa69d75602
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Aug 11 13:30:32 2016 +0200

    mfd: dm355evm_msp: Refactoring for add_child()
    
    Adjust jump targets according to the Linux coding style convention.
    Another check for the variable "status" can be omitted then at the end.
    
    Link: https://lkml.kernel.org/g/<20160628163146.GG29166@dell>
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 270e19c0bba1..86eca614507b 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -209,7 +209,7 @@ static struct device *add_child(struct i2c_client *client, const char *name,
 		status = platform_device_add_data(pdev, pdata, pdata_len);
 		if (status < 0) {
 			dev_dbg(&pdev->dev, "can't add platform_data\n");
-			goto err;
+			goto put_device;
 		}
 	}
 
@@ -222,19 +222,20 @@ static struct device *add_child(struct i2c_client *client, const char *name,
 		status = platform_device_add_resources(pdev, &r, 1);
 		if (status < 0) {
 			dev_dbg(&pdev->dev, "can't add irq\n");
-			goto err;
+			goto put_device;
 		}
 	}
 
 	status = platform_device_add(pdev);
+	if (status)
+		goto put_device;
 
-err:
-	if (status < 0) {
-		platform_device_put(pdev);
-		dev_err(&client->dev, "can't add %s dev\n", name);
-		return ERR_PTR(status);
-	}
 	return &pdev->dev;
+
+put_device:
+	platform_device_put(pdev);
+	dev_err(&client->dev, "failed to add device %s\n", name);
+	return ERR_PTR(status);
 }
 
 static int add_children(struct i2c_client *client)

commit d313cdde71ec9a5c327a515c37a0dca2cca00de5
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Jun 26 13:40:35 2016 +0200

    mfd: dm355evm_msp: Return directly after a failed platform_device_alloc() in add_child()
    
    The platform_device_put() function was called in one case by the
    add_child() function during error handling even if the passed
    variable "pdev" contained a null pointer.
    Return directly in this case.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 14661ec5ef7f..270e19c0bba1 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -199,11 +199,8 @@ static struct device *add_child(struct i2c_client *client, const char *name,
 	int			status;
 
 	pdev = platform_device_alloc(name, -1);
-	if (!pdev) {
-		dev_dbg(&client->dev, "can't alloc dev\n");
-		status = -ENOMEM;
-		goto err;
-	}
+	if (!pdev)
+		return ERR_PTR(-ENOMEM);
 
 	device_init_wakeup(&pdev->dev, can_wakeup);
 	pdev->dev.parent = &client->dev;

commit 5eb519f3f6df367d43ec0c6e063fd62943fe4dcf
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Wed Apr 20 13:45:46 2016 -0400

    mfd: Use IS_ENABLED(CONFIG_FOO) instead of checking FOO || FOO_MODULE
    
    The IS_ENABLED() macro checks if a Kconfig symbol has been enabled either
    built-in or as a module, use that macro instead of open coding the same.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index d7d59f8d9d06..14661ec5ef7f 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -33,25 +33,25 @@
  * This driver was tested with firmware revision A4.
  */
 
-#if defined(CONFIG_INPUT_DM355EVM) || defined(CONFIG_INPUT_DM355EVM_MODULE)
+#if IS_ENABLED(CONFIG_INPUT_DM355EVM)
 #define msp_has_keyboard()	true
 #else
 #define msp_has_keyboard()	false
 #endif
 
-#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
+#if IS_ENABLED(CONFIG_LEDS_GPIO)
 #define msp_has_leds()		true
 #else
 #define msp_has_leds()		false
 #endif
 
-#if defined(CONFIG_RTC_DRV_DM355EVM) || defined(CONFIG_RTC_DRV_DM355EVM_MODULE)
+#if IS_ENABLED(CONFIG_RTC_DRV_DM355EVM)
 #define msp_has_rtc()		true
 #else
 #define msp_has_rtc()		false
 #endif
 
-#if defined(CONFIG_VIDEO_TVP514X) || defined(CONFIG_VIDEO_TVP514X_MODULE)
+#if IS_ENABLED(CONFIG_VIDEO_TVP514X)
 #define msp_has_tvp()		true
 #else
 #define msp_has_tvp()		false

commit 4363765c851313d460db86f2d41d2eebca0d9c17
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Mar 30 10:48:02 2016 +0200

    mfd: dm355evm_msp: Switch to gpiochip_add_data()
    
    We're planning to remove the gpiochip_add() function to swith
    to gpiochip_add_data() with NULL for data argument.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index ec4438ed2faf..d7d59f8d9d06 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -260,7 +260,7 @@ static int add_children(struct i2c_client *client)
 
 	/* GPIO-ish stuff */
 	dm355evm_msp_gpio.parent = &client->dev;
-	status = gpiochip_add(&dm355evm_msp_gpio);
+	status = gpiochip_add_data(&dm355evm_msp_gpio, NULL);
 	if (status < 0)
 		return status;
 

commit 58cf279acac3080ce03eeea5ca268210b3165fe1
Merge: 6606b342febf c474e348778b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 17 12:32:01 2016 -0800

    Merge tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "Here is the bulk of GPIO changes for v4.5.
    
      Notably there are big refactorings mostly by myself, aimed at getting
      the gpio_chip into a shape that makes me believe I can proceed to
      preserve state for a proper userspace ABI (character device) that has
      already been proposed once, but resulted in the feedback that I need
      to go back and restructure stuff.  So I've been restructuring stuff.
      On the way I ran into brokenness (return code from the get_value()
      callback) and had to fix it.  Also, refactored generic GPIO to be
      simpler.
    
      Some of that is still waiting to trickle down from the subsystems all
      over the kernel that provide random gpio_chips, I've touched every
      single GPIO driver in the kernel now, oh man I didn't know I was
      responsible for so much...
    
      Apart from that we're churning along as usual.
    
      I took some effort to test and retest so it should merge nicely and we
      shook out a couple of bugs in -next.
    
      Infrastructural changes:
    
       - In struct gpio_chip, rename the .dev node to .parent to better
         reflect the fact that this is not the GPIO struct device
         abstraction.  We will add that soon so this would be totallt
         confusing.
    
       - It was noted that the driver .get_value() callbacks was sometimes
         reporting negative -ERR values to the gpiolib core, expecting them
         to be propagated to consumer gpiod_get_value() and gpio_get_value()
         calls.  This was not happening, so as there was a mess of drivers
         returning negative errors and some returning "anything else than
         zero" to indicate that a line was active.  As some would have bit
         31 set to indicate "line active" it clashed with negative error
         codes.  This is fixed by the largeish series clamping values in all
         drivers with !!value to [0,1] and then augmenting the code to
         propagate error codes to consumers.  (Includes some ACKed patches
         in other subsystems.)
    
       - Add a void *data pointer to struct gpio_chip.  The container_of()
         design pattern is indeed very nice, but we want to reform the
         struct gpio_chip to be a non-volative, stateless business, and keep
         states internal to the gpiolib to be able to hold on to the state
         when adding a proper userspace ABI (character device) further down
         the road.  To achieve this, drivers need a handle at the internal
         state that is not dependent on their struct gpio_chip() so we add
         gpiochip_add_data() and gpiochip_get_data() following the pattern
         of many other subsystems.  All the "use gpiochip data pointer"
         patches transforms drivers to this scheme.
    
       - The Generic GPIO chip header has been merged into the general
         <linux/gpio/driver.h> header, and the custom header for that
         removed.  Instead of having a separate mm_gpio_chip struct for
         these generic drivers, merge that into struct gpio_chip,
         simplifying the code and removing the need for separate and
         confusing includes.
    
      Misc improvements:
    
       - Stabilize the way GPIOs are looked up from the ACPI legacy
         specification.
    
       - Incremental driver features for PXA, PCA953X, Lantiq (patches from
         the OpenWRT community), RCAR, Zynq, PL061, 104-idi-48
    
      New drivers:
    
       - Add a GPIO chip to the ALSA SoC AC97 driver.
    
       - Add a new Broadcom NSP SoC driver (this lands in the pinctrl dir,
         but the branch is merged here too to account for infrastructural
         changes).
    
       - The sx150x driver now supports the sx1502"
    
    * tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (220 commits)
      gpio: generic: make bgpio_pdata always visible
      gpiolib: fix chip order in gpio list
      gpio: mpc8xxx: Do not use gpiochip_get_data() in mpc8xxx_gpio_save_regs()
      gpio: mm-lantiq: Do not use gpiochip_get_data() in ltq_mm_save_regs()
      gpio: brcmstb: Allow building driver for BMIPS_GENERIC
      gpio: brcmstb: Set endian flags for big-endian MIPS
      gpio: moxart: fix build regression
      gpio: xilinx: Do not use gpiochip_get_data() in xgpio_save_regs()
      leds: pca9532: use gpiochip data pointer
      leds: tca6507: use gpiochip data pointer
      hid: cp2112: use gpiochip data pointer
      bcma: gpio: use gpiochip data pointer
      avr32: gpio: use gpiochip data pointer
      video: fbdev: via: use gpiochip data pointer
      gpio: pch: Optimize pch_gpio_get()
      Revert "pinctrl: lantiq: Implement gpio_chip.to_irq"
      pinctrl: nsp-gpio: use gpiochip data pointer
      pinctrl: vt8500-wmt: use gpiochip data pointer
      pinctrl: exynos5440: use gpiochip data pointer
      pinctrl: at91-pio4: use gpiochip data pointer
      ...

commit fe0b486729e1ae837cf0afd1005d3c10a78f9807
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 22 15:47:31 2015 +0100

    mfd: dm355evm_mps: Be sure to clamp return value
    
    As we want gpio_chip .get() calls to be able to return negative
    error codes and propagate to drivers, we need to go over all
    drivers and make sure their return values are clamped to [0,1].
    We do this by using the ret = !!(val) design pattern.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 4c826f78acd0..bf3e0b21b247 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -147,7 +147,7 @@ static int msp_gpio_get(struct gpio_chip *chip, unsigned offset)
 		return status;
 	if (reg == DM355EVM_MSP_LED)
 		msp_led_cache = status;
-	return status & MSP_GPIO_MASK(offset);
+	return !!(status & MSP_GPIO_MASK(offset));
 }
 
 static int msp_gpio_out(struct gpio_chip *chip, unsigned offset, int value)

commit 58383c78425e4ee1c077253cf297b641c861c02e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 4 09:56:26 2015 +0100

    gpio: change member .dev to .parent
    
    The name .dev in a struct is normally reserved for a struct device
    that is let us say a superclass to the thing described by the struct.
    struct gpio_chip stands out by confusingly using a struct device *dev
    to point to the parent device (such as a platform_device) that
    represents the hardware. As we want to give gpio_chip:s real devices,
    this is not working. We need to rename this member to parent.
    
    This was done by two coccinelle scripts, I guess it is possible to
    combine them into one, but I don't know such stuff. They look like
    this:
    
    @@
    struct gpio_chip *var;
    @@
    -var->dev
    +var->parent
    
    and:
    
    @@
    struct gpio_chip var;
    @@
    -var.dev
    +var.parent
    
    and:
    
    @@
    struct bgpio_chip *var;
    @@
    -var->gc.dev
    +var->gc.parent
    
    Plus a few instances of bgpio that I couldn't figure out how
    to teach Coccinelle to rewrite.
    
    This patch hits all over the place, but I *strongly* prefer this
    solution to any piecemal approaches that just exercise patch
    mechanics all over the place. It mainly hits drivers/gpio and
    drivers/pinctrl which is my own backyard anyway.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Alek Du <alek.du@intel.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 4c826f78acd0..bc90efe01b59 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -259,7 +259,7 @@ static int add_children(struct i2c_client *client)
 	int		i;
 
 	/* GPIO-ish stuff */
-	dm355evm_msp_gpio.dev = &client->dev;
+	dm355evm_msp_gpio.parent = &client->dev;
 	status = gpiochip_add(&dm355evm_msp_gpio);
 	if (status < 0)
 		return status;

commit 016f42198b503e836d8b673858867658e5bf03b9
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Jul 21 13:06:42 2014 +0100

    mfd: dm355evm_msp: Fix checkpatch error: insert space after ','
    
    This is part of an effort to clean-up the MFD subsystem.
    
    ERROR: space required after that ',' (ctx:VxV)
    +#define MSP_GPIO(bit,reg)      ((DM355EVM_MSP_ ## reg) << 3 | (bit))
                         ^
    
    total: 1 errors, 0 warnings, 437 lines checked
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 7a55c0071fa8..4c826f78acd0 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -95,7 +95,7 @@ EXPORT_SYMBOL(dm355evm_msp_read);
  * Many of the msp430 pins are just used as fixed-direction GPIOs.
  * We could export a few more of them this way, if we wanted.
  */
-#define MSP_GPIO(bit,reg)	((DM355EVM_MSP_ ## reg) << 3 | (bit))
+#define MSP_GPIO(bit, reg)	((DM355EVM_MSP_ ## reg) << 3 | (bit))
 
 static const u8 msp_gpios[] = {
 	/* eight leds */

commit 334a41ce9b753ec615e8c6c50ee07d6197190610
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:10:05 2013 +0900

    mfd: Use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 7710227d284e..7a55c0071fa8 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -315,8 +315,8 @@ static int add_children(struct i2c_client *client)
 	}
 
 	/* MMC/SD inputs -- right after the last config input */
-	if (client->dev.platform_data) {
-		void (*mmcsd_setup)(unsigned) = client->dev.platform_data;
+	if (dev_get_platdata(&client->dev)) {
+		void (*mmcsd_setup)(unsigned) = dev_get_platdata(&client->dev);
 
 		mmcsd_setup(dm355evm_msp_gpio.base + 8 + 5);
 	}

commit 97f2bf519377598fd75ce281e595e3205e0f48f5
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Dec 1 09:49:07 2011 +0800

    mfd: Use gpio_request_one from dm355evm_msp
    
    Use gpio_request_one() instead of multiple gpiolib calls.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 8ad88da647b9..7710227d284e 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -308,8 +308,7 @@ static int add_children(struct i2c_client *client)
 	for (i = 0; i < ARRAY_SIZE(config_inputs); i++) {
 		int gpio = dm355evm_msp_gpio.base + config_inputs[i].offset;
 
-		gpio_request(gpio, config_inputs[i].label);
-		gpio_direction_input(gpio);
+		gpio_request_one(gpio, GPIOF_IN, config_inputs[i].label);
 
 		/* make it easy for userspace to see these */
 		gpio_export(gpio, false);

commit 4e36dd331423fce1f996d93b991453a1a702ca5c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 15:13:27 2011 -0400

    mfd: Add module.h to the implicit drivers/mfd users
    
    With the pending module.h cleanup, these files will fail to compile,
    unless they explicitly call out the include of this file.
    
    [omap-usb-host addition courtesy of Anand Gadiyar <gadiyar@ti.com>]
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 3d4a861976ca..8ad88da647b9 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -13,6 +13,7 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/module.h>
 #include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/leds.h>

commit 89a99e76f6888166edb145f576cc4a761ee0e0a9
Author: Vipin Bhandari <vipin.bhandari@ti.com>
Date:   Thu Jul 30 04:19:17 2009 -0400

    mfd: Correct ro and cd implemantion on DM355
    
    This patch corrects the support for MMCSD card detection
    and read only feature for SoC DM355.
    
    EVMDM355_ECP_VA4.pdf, from Spectrum digital, suggests that
    Bit 2 and 4 should be checked for card detection. However
    on the EVM, bits 1 and 3 gives this status, for MMC/SD
    instance 0 and 1 respectively. The pdf also suggests that
    Bit 1 and 3 should be checked for write protection. However
    on the EVM bits 2 and 4 gives this status.
    
    This document can be downloaded from
    http://c6000.spectrumdigital.com/evmdm355/reve/files/EVMDM355_ECP_VA4.pdf
    
    Signed-off-by: Vipin Bhandari <vipin.bhandari@ti.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 5b6e58a3ba46..3d4a861976ca 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -107,8 +107,16 @@ static const u8 msp_gpios[] = {
 	MSP_GPIO(2, SWITCH1), MSP_GPIO(3, SWITCH1),
 	MSP_GPIO(4, SWITCH1),
 	/* switches on MMC/SD sockets */
-	MSP_GPIO(1, SDMMC), MSP_GPIO(2, SDMMC),	/* mmc0 WP, nCD */
-	MSP_GPIO(3, SDMMC), MSP_GPIO(4, SDMMC),	/* mmc1 WP, nCD */
+	/*
+	 * Note: EVMDM355_ECP_VA4.pdf suggests that Bit 2 and 4 should be
+	 * checked for card detection. However on the EVM bit 1 and 3 gives
+	 * this status, for 0 and 1 instance respectively. The pdf also
+	 * suggests that Bit 1 and 3 should be checked for write protection.
+	 * However on the EVM bit 2 and 4 gives this status,for 0 and 1
+	 * instance respectively.
+	 */
+	MSP_GPIO(2, SDMMC), MSP_GPIO(1, SDMMC),	/* mmc0 WP, nCD */
+	MSP_GPIO(4, SDMMC), MSP_GPIO(3, SDMMC),	/* mmc1 WP, nCD */
 };
 
 #define MSP_GPIO_REG(offset)	(msp_gpios[(offset)] >> 3)

commit 00b8ac409cad653137f087e3ff69c020174cbc15
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Sun Jun 28 22:30:56 2009 -0700

    Input: dm355evm_keys - fix kconfig symbol names
    
    The keypad driver for the DM355 EVM got slightly broken as it merged,
    since it moved from input/keyboard to input/misc and its Kconfig
    symbol changed.  This patch copes with the changed Kconfig symbol.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 7ac12cb0be4a..5b6e58a3ba46 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -32,8 +32,7 @@
  * This driver was tested with firmware revision A4.
  */
 
-#if defined(CONFIG_KEYBOARD_DM355EVM) \
-		|| defined(CONFIG_KEYBOARD_DM355EVM_MODULE)
+#if defined(CONFIG_INPUT_DM355EVM) || defined(CONFIG_INPUT_DM355EVM_MODULE)
 #define msp_has_keyboard()	true
 #else
 #define msp_has_keyboard()	false

commit d1fdb4f6fbb155af88363bc949a35daa11872d9f
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Fri Jan 9 02:02:42 2009 +0100

    mfd: dm355 evm MMC/SD card detection
    
    Support card detect and writeprotect switches on DM355 EVM.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
index 4214b3f72426..7ac12cb0be4a 100644
--- a/drivers/mfd/dm355evm_msp.c
+++ b/drivers/mfd/dm355evm_msp.c
@@ -107,6 +107,9 @@ static const u8 msp_gpios[] = {
 	MSP_GPIO(0, SWITCH1), MSP_GPIO(1, SWITCH1),
 	MSP_GPIO(2, SWITCH1), MSP_GPIO(3, SWITCH1),
 	MSP_GPIO(4, SWITCH1),
+	/* switches on MMC/SD sockets */
+	MSP_GPIO(1, SDMMC), MSP_GPIO(2, SDMMC),	/* mmc0 WP, nCD */
+	MSP_GPIO(3, SDMMC), MSP_GPIO(4, SDMMC),	/* mmc1 WP, nCD */
 };
 
 #define MSP_GPIO_REG(offset)	(msp_gpios[(offset)] >> 3)
@@ -304,6 +307,13 @@ static int add_children(struct i2c_client *client)
 		gpio_export(gpio, false);
 	}
 
+	/* MMC/SD inputs -- right after the last config input */
+	if (client->dev.platform_data) {
+		void (*mmcsd_setup)(unsigned) = client->dev.platform_data;
+
+		mmcsd_setup(dm355evm_msp_gpio.base + 8 + 5);
+	}
+
 	/* RTC is a 32 bit counter, no alarm */
 	if (msp_has_rtc()) {
 		child = add_child(client, "rtc-dm355evm",

commit 0931a4c6dbfab03f2bfd22a9170130f7b155d53a
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Mon Dec 22 12:05:27 2008 +0100

    mfd: dm355evm msp430 driver
    
    Basic MFD framework for the MSP430 microcontroller firmware used
    on the dm355evm board:
    
     - Provides an interface for other drivers: register read/write
       utilities, and register declarations.
    
     - Directly exports:
         * Many signals through the GPIO framework
             + LEDs
             + SW6 through gpio sysfs
             + NTSC/nPAL jumper through gpio sysfs
             + ... more could be added later, e.g. MMC signals
         * Child devices:
            + LEDs, via leds-gpio child (and default triggers)
            + RTC, via rtc-dm355evm child device
            + Buttons and IR control, via dm355evm_keys
    
     - Supports power-off system call.  Use the reset button to power
       the board back up; the power supply LED will be on, but the
       MSP430 waits to re-activate the regulators.
    
     - On probe() this:
         * Announces firmware revision
         * Turns off the banked LEDs
         * Exports the resources noted above
         * Hooks the power-off support
         * Muxes tvp5146 -or- imager for video input
    
    Unless the new tvp514x driver (tracked for mainline) is configured,
    this assumes that some custom imager driver handles video-in.
    
    This completely ignores the registers reporting the output voltages
    on the various power supplies.  Someone could add a hwmon interface
    if that seems useful.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/dm355evm_msp.c b/drivers/mfd/dm355evm_msp.c
new file mode 100644
index 000000000000..4214b3f72426
--- /dev/null
+++ b/drivers/mfd/dm355evm_msp.c
@@ -0,0 +1,420 @@
+/*
+ * dm355evm_msp.c - driver for MSP430 firmware on DM355EVM board
+ *
+ * Copyright (C) 2008 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <linux/i2c.h>
+#include <linux/i2c/dm355evm_msp.h>
+
+
+/*
+ * The DM355 is a DaVinci chip with video support but no C64+ DSP.  Its
+ * EVM board has an MSP430 programmed with firmware for various board
+ * support functions.  This driver exposes some of them directly, and
+ * supports other drivers (e.g. RTC, input) for more complex access.
+ *
+ * Because this firmware is entirely board-specific, this file embeds
+ * knowledge that would be passed as platform_data in a generic driver.
+ *
+ * This driver was tested with firmware revision A4.
+ */
+
+#if defined(CONFIG_KEYBOARD_DM355EVM) \
+		|| defined(CONFIG_KEYBOARD_DM355EVM_MODULE)
+#define msp_has_keyboard()	true
+#else
+#define msp_has_keyboard()	false
+#endif
+
+#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
+#define msp_has_leds()		true
+#else
+#define msp_has_leds()		false
+#endif
+
+#if defined(CONFIG_RTC_DRV_DM355EVM) || defined(CONFIG_RTC_DRV_DM355EVM_MODULE)
+#define msp_has_rtc()		true
+#else
+#define msp_has_rtc()		false
+#endif
+
+#if defined(CONFIG_VIDEO_TVP514X) || defined(CONFIG_VIDEO_TVP514X_MODULE)
+#define msp_has_tvp()		true
+#else
+#define msp_has_tvp()		false
+#endif
+
+
+/*----------------------------------------------------------------------*/
+
+/* REVISIT for paranoia's sake, retry reads/writes on error */
+
+static struct i2c_client *msp430;
+
+/**
+ * dm355evm_msp_write - Writes a register in dm355evm_msp
+ * @value: the value to be written
+ * @reg: register address
+ *
+ * Returns result of operation - 0 is success, else negative errno
+ */
+int dm355evm_msp_write(u8 value, u8 reg)
+{
+	return i2c_smbus_write_byte_data(msp430, reg, value);
+}
+EXPORT_SYMBOL(dm355evm_msp_write);
+
+/**
+ * dm355evm_msp_read - Reads a register from dm355evm_msp
+ * @reg: register address
+ *
+ * Returns result of operation - value, or negative errno
+ */
+int dm355evm_msp_read(u8 reg)
+{
+	return i2c_smbus_read_byte_data(msp430, reg);
+}
+EXPORT_SYMBOL(dm355evm_msp_read);
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Many of the msp430 pins are just used as fixed-direction GPIOs.
+ * We could export a few more of them this way, if we wanted.
+ */
+#define MSP_GPIO(bit,reg)	((DM355EVM_MSP_ ## reg) << 3 | (bit))
+
+static const u8 msp_gpios[] = {
+	/* eight leds */
+	MSP_GPIO(0, LED), MSP_GPIO(1, LED),
+	MSP_GPIO(2, LED), MSP_GPIO(3, LED),
+	MSP_GPIO(4, LED), MSP_GPIO(5, LED),
+	MSP_GPIO(6, LED), MSP_GPIO(7, LED),
+	/* SW6 and the NTSC/nPAL jumper */
+	MSP_GPIO(0, SWITCH1), MSP_GPIO(1, SWITCH1),
+	MSP_GPIO(2, SWITCH1), MSP_GPIO(3, SWITCH1),
+	MSP_GPIO(4, SWITCH1),
+};
+
+#define MSP_GPIO_REG(offset)	(msp_gpios[(offset)] >> 3)
+#define MSP_GPIO_MASK(offset)	BIT(msp_gpios[(offset)] & 0x07)
+
+static int msp_gpio_in(struct gpio_chip *chip, unsigned offset)
+{
+	switch (MSP_GPIO_REG(offset)) {
+	case DM355EVM_MSP_SWITCH1:
+	case DM355EVM_MSP_SWITCH2:
+	case DM355EVM_MSP_SDMMC:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static u8 msp_led_cache;
+
+static int msp_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	int reg, status;
+
+	reg = MSP_GPIO_REG(offset);
+	status = dm355evm_msp_read(reg);
+	if (status < 0)
+		return status;
+	if (reg == DM355EVM_MSP_LED)
+		msp_led_cache = status;
+	return status & MSP_GPIO_MASK(offset);
+}
+
+static int msp_gpio_out(struct gpio_chip *chip, unsigned offset, int value)
+{
+	int mask, bits;
+
+	/* NOTE:  there are some other signals that could be
+	 * packaged as output GPIOs, but they aren't as useful
+	 * as the LEDs ... so for now we don't.
+	 */
+	if (MSP_GPIO_REG(offset) != DM355EVM_MSP_LED)
+		return -EINVAL;
+
+	mask = MSP_GPIO_MASK(offset);
+	bits = msp_led_cache;
+
+	bits &= ~mask;
+	if (value)
+		bits |= mask;
+	msp_led_cache = bits;
+
+	return dm355evm_msp_write(bits, DM355EVM_MSP_LED);
+}
+
+static void msp_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	msp_gpio_out(chip, offset, value);
+}
+
+static struct gpio_chip dm355evm_msp_gpio = {
+	.label			= "dm355evm_msp",
+	.owner			= THIS_MODULE,
+	.direction_input	= msp_gpio_in,
+	.get			= msp_gpio_get,
+	.direction_output	= msp_gpio_out,
+	.set			= msp_gpio_set,
+	.base			= -EINVAL,		/* dynamic assignment */
+	.ngpio			= ARRAY_SIZE(msp_gpios),
+	.can_sleep		= true,
+};
+
+/*----------------------------------------------------------------------*/
+
+static struct device *add_child(struct i2c_client *client, const char *name,
+		void *pdata, unsigned pdata_len,
+		bool can_wakeup, int irq)
+{
+	struct platform_device	*pdev;
+	int			status;
+
+	pdev = platform_device_alloc(name, -1);
+	if (!pdev) {
+		dev_dbg(&client->dev, "can't alloc dev\n");
+		status = -ENOMEM;
+		goto err;
+	}
+
+	device_init_wakeup(&pdev->dev, can_wakeup);
+	pdev->dev.parent = &client->dev;
+
+	if (pdata) {
+		status = platform_device_add_data(pdev, pdata, pdata_len);
+		if (status < 0) {
+			dev_dbg(&pdev->dev, "can't add platform_data\n");
+			goto err;
+		}
+	}
+
+	if (irq) {
+		struct resource r = {
+			.start = irq,
+			.flags = IORESOURCE_IRQ,
+		};
+
+		status = platform_device_add_resources(pdev, &r, 1);
+		if (status < 0) {
+			dev_dbg(&pdev->dev, "can't add irq\n");
+			goto err;
+		}
+	}
+
+	status = platform_device_add(pdev);
+
+err:
+	if (status < 0) {
+		platform_device_put(pdev);
+		dev_err(&client->dev, "can't add %s dev\n", name);
+		return ERR_PTR(status);
+	}
+	return &pdev->dev;
+}
+
+static int add_children(struct i2c_client *client)
+{
+	static const struct {
+		int offset;
+		char *label;
+	} config_inputs[] = {
+		/* 8 == right after the LEDs */
+		{ 8 + 0, "sw6_1", },
+		{ 8 + 1, "sw6_2", },
+		{ 8 + 2, "sw6_3", },
+		{ 8 + 3, "sw6_4", },
+		{ 8 + 4, "NTSC/nPAL", },
+	};
+
+	struct device	*child;
+	int		status;
+	int		i;
+
+	/* GPIO-ish stuff */
+	dm355evm_msp_gpio.dev = &client->dev;
+	status = gpiochip_add(&dm355evm_msp_gpio);
+	if (status < 0)
+		return status;
+
+	/* LED output */
+	if (msp_has_leds()) {
+#define GPIO_LED(l)	.name = l, .active_low = true
+		static struct gpio_led evm_leds[] = {
+			{ GPIO_LED("dm355evm::ds14"),
+				.default_trigger = "heartbeat", },
+			{ GPIO_LED("dm355evm::ds15"),
+				.default_trigger = "mmc0", },
+			{ GPIO_LED("dm355evm::ds16"),
+				/* could also be a CE-ATA drive */
+				.default_trigger = "mmc1", },
+			{ GPIO_LED("dm355evm::ds17"),
+				.default_trigger = "nand-disk", },
+			{ GPIO_LED("dm355evm::ds18"), },
+			{ GPIO_LED("dm355evm::ds19"), },
+			{ GPIO_LED("dm355evm::ds20"), },
+			{ GPIO_LED("dm355evm::ds21"), },
+		};
+#undef GPIO_LED
+
+		struct gpio_led_platform_data evm_led_data = {
+			.num_leds	= ARRAY_SIZE(evm_leds),
+			.leds		= evm_leds,
+		};
+
+		for (i = 0; i < ARRAY_SIZE(evm_leds); i++)
+			evm_leds[i].gpio = i + dm355evm_msp_gpio.base;
+
+		/* NOTE:  these are the only fully programmable LEDs
+		 * on the board, since GPIO-61/ds22 (and many signals
+		 * going to DC7) must be used for AEMIF address lines
+		 * unless the top 1 GB of NAND is unused...
+		 */
+		child = add_child(client, "leds-gpio",
+				&evm_led_data, sizeof(evm_led_data),
+				false, 0);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
+	/* configuration inputs */
+	for (i = 0; i < ARRAY_SIZE(config_inputs); i++) {
+		int gpio = dm355evm_msp_gpio.base + config_inputs[i].offset;
+
+		gpio_request(gpio, config_inputs[i].label);
+		gpio_direction_input(gpio);
+
+		/* make it easy for userspace to see these */
+		gpio_export(gpio, false);
+	}
+
+	/* RTC is a 32 bit counter, no alarm */
+	if (msp_has_rtc()) {
+		child = add_child(client, "rtc-dm355evm",
+				NULL, 0, false, 0);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
+	/* input from buttons and IR remote (uses the IRQ) */
+	if (msp_has_keyboard()) {
+		child = add_child(client, "dm355evm_keys",
+				NULL, 0, true, client->irq);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------*/
+
+static void dm355evm_command(unsigned command)
+{
+	int status;
+
+	status = dm355evm_msp_write(command, DM355EVM_MSP_COMMAND);
+	if (status < 0)
+		dev_err(&msp430->dev, "command %d failure %d\n",
+				command, status);
+}
+
+static void dm355evm_power_off(void)
+{
+	dm355evm_command(MSP_COMMAND_POWEROFF);
+}
+
+static int dm355evm_msp_remove(struct i2c_client *client)
+{
+	pm_power_off = NULL;
+	msp430 = NULL;
+	return 0;
+}
+
+static int
+dm355evm_msp_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int		status;
+	const char	*video = msp_has_tvp() ? "TVP5146" : "imager";
+
+	if (msp430)
+		return -EBUSY;
+	msp430 = client;
+
+	/* display revision status; doubles as sanity check */
+	status = dm355evm_msp_read(DM355EVM_MSP_FIRMREV);
+	if (status < 0)
+		goto fail;
+	dev_info(&client->dev, "firmware v.%02X, %s as video-in\n",
+			status, video);
+
+	/* mux video input:  either tvp5146 or some external imager */
+	status = dm355evm_msp_write(msp_has_tvp() ? 0 : MSP_VIDEO_IMAGER,
+			DM355EVM_MSP_VIDEO_IN);
+	if (status < 0)
+		dev_warn(&client->dev, "error %d muxing %s as video-in\n",
+			status, video);
+
+	/* init LED cache, and turn off the LEDs */
+	msp_led_cache = 0xff;
+	dm355evm_msp_write(msp_led_cache, DM355EVM_MSP_LED);
+
+	/* export capabilities we support */
+	status = add_children(client);
+	if (status < 0)
+		goto fail;
+
+	/* PM hookup */
+	pm_power_off = dm355evm_power_off;
+
+	return 0;
+
+fail:
+	/* FIXME remove children ... */
+	dm355evm_msp_remove(client);
+	return status;
+}
+
+static const struct i2c_device_id dm355evm_msp_ids[] = {
+	{ "dm355evm_msp", 0 },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(i2c, dm355evm_msp_ids);
+
+static struct i2c_driver dm355evm_msp_driver = {
+	.driver.name	= "dm355evm_msp",
+	.id_table	= dm355evm_msp_ids,
+	.probe		= dm355evm_msp_probe,
+	.remove		= dm355evm_msp_remove,
+};
+
+static int __init dm355evm_msp_init(void)
+{
+	return i2c_add_driver(&dm355evm_msp_driver);
+}
+subsys_initcall(dm355evm_msp_init);
+
+static void __exit dm355evm_msp_exit(void)
+{
+	i2c_del_driver(&dm355evm_msp_driver);
+}
+module_exit(dm355evm_msp_exit);
+
+MODULE_DESCRIPTION("Interface to MSP430 firmware on DM355EVM");
+MODULE_LICENSE("GPL");
