commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 1e0e20c0e082..6e1b38f9f26c 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Touchscreen driver for UCB1x00-based touchscreens
  *
  *  Copyright (C) 2001 Russell King, All Rights Reserved.
  *  Copyright (C) 2005 Pavel Machek
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * 21-Jan-2002 <jco@ict.es> :
  *
  * Added support for synchronous A/D mode. This mode is useful to

commit a3364409c4af8bae42d04def48dc11409787e503
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 21 14:58:28 2012 +0000

    MFD: ucb1x00: convert to use genirq
    
    Convert the ucb1x00 driver to use genirq's interrupt services, rather
    than its own private implementation.  This allows a wider range of
    drivers to use the GPIO interrupts (such as the gpio_keys driver)
    without being aware of the UCB1x00's private IRQ system.
    
    This prevents the UCB1x00 core driver from being built as a module,
    so adjust the configuration to add that restriction.
    
    Acked-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 742d0c7bbbc2..1e0e20c0e082 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -20,8 +20,9 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
-#include <linux/smp.h>
+#include <linux/interrupt.h>
 #include <linux/sched.h>
+#include <linux/spinlock.h>
 #include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/string.h>
@@ -41,6 +42,8 @@ struct ucb1x00_ts {
 	struct input_dev	*idev;
 	struct ucb1x00		*ucb;
 
+	spinlock_t		irq_lock;
+	unsigned		irq_disabled;
 	wait_queue_head_t	irq_wait;
 	struct task_struct	*rtask;
 	u16			x_res;
@@ -237,7 +240,12 @@ static int ucb1x00_thread(void *_ts)
 		if (ucb1x00_ts_pen_down(ts)) {
 			set_current_state(TASK_INTERRUPTIBLE);
 
-			ucb1x00_enable_irq(ts->ucb, UCB_IRQ_TSPX, machine_is_collie() ? UCB_RISING : UCB_FALLING);
+			spin_lock_irq(&ts->irq_lock);
+			if (ts->irq_disabled) {
+				ts->irq_disabled = 0;
+				enable_irq(ts->ucb->irq_base + UCB_IRQ_TSPX);
+			}
+			spin_unlock_irq(&ts->irq_lock);
 			ucb1x00_disable(ts->ucb);
 
 			/*
@@ -280,23 +288,37 @@ static int ucb1x00_thread(void *_ts)
  * We only detect touch screen _touches_ with this interrupt
  * handler, and even then we just schedule our task.
  */
-static void ucb1x00_ts_irq(int idx, void *id)
+static irqreturn_t ucb1x00_ts_irq(int irq, void *id)
 {
 	struct ucb1x00_ts *ts = id;
 
-	ucb1x00_disable_irq(ts->ucb, UCB_IRQ_TSPX, UCB_FALLING);
+	spin_lock(&ts->irq_lock);
+	ts->irq_disabled = 1;
+	disable_irq_nosync(ts->ucb->irq_base + UCB_IRQ_TSPX);
+	spin_unlock(&ts->irq_lock);
 	wake_up(&ts->irq_wait);
+
+	return IRQ_HANDLED;
 }
 
 static int ucb1x00_ts_open(struct input_dev *idev)
 {
 	struct ucb1x00_ts *ts = input_get_drvdata(idev);
+	unsigned long flags = 0;
 	int ret = 0;
 
 	BUG_ON(ts->rtask);
 
+	if (machine_is_collie())
+		flags = IRQF_TRIGGER_RISING;
+	else
+		flags = IRQF_TRIGGER_FALLING;
+
+	ts->irq_disabled = 0;
+
 	init_waitqueue_head(&ts->irq_wait);
-	ret = ucb1x00_hook_irq(ts->ucb, UCB_IRQ_TSPX, ucb1x00_ts_irq, ts);
+	ret = request_irq(ts->ucb->irq_base + UCB_IRQ_TSPX, ucb1x00_ts_irq,
+			  flags, "ucb1x00-ts", ts);
 	if (ret < 0)
 		goto out;
 
@@ -313,7 +335,7 @@ static int ucb1x00_ts_open(struct input_dev *idev)
 	if (!IS_ERR(ts->rtask)) {
 		ret = 0;
 	} else {
-		ucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);
+		free_irq(ts->ucb->irq_base + UCB_IRQ_TSPX, ts);
 		ts->rtask = NULL;
 		ret = -EFAULT;
 	}
@@ -333,7 +355,7 @@ static void ucb1x00_ts_close(struct input_dev *idev)
 		kthread_stop(ts->rtask);
 
 	ucb1x00_enable(ts->ucb);
-	ucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);
+	free_irq(ts->ucb->irq_base + UCB_IRQ_TSPX, ts);
 	ucb1x00_reg_write(ts->ucb, UCB_TS_CR, 0);
 	ucb1x00_disable(ts->ucb);
 }
@@ -358,6 +380,7 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	ts->ucb = dev->ucb;
 	ts->idev = idev;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
+	spin_lock_init(&ts->irq_lock);
 
 	idev->name       = "Touchscreen panel";
 	idev->id.product = ts->ucb->id;

commit 945f6310d3cf0523560b33b9ddb3271666141bd5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 21 09:30:27 2012 +0000

    MFD: ucb1x00-ts: provide input layer with device parent
    
    Provide the input layer struct device with its parent device, so
    that the input layer's device appears in the correct place in the
    device tree.  This also allows the input device to be visibily
    associated with its hardware.
    
    Acked-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index ec6ffb6e287d..742d0c7bbbc2 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -363,6 +363,7 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	idev->id.product = ts->ucb->id;
 	idev->open       = ucb1x00_ts_open;
 	idev->close      = ucb1x00_ts_close;
+	idev->dev.parent = &ts->ucb->dev;
 
 	idev->evbit[0]   = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);
 	idev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);

commit 7658e7f9a8122b0678e4b4280308560aa5444bd5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 12 19:04:43 2012 +0000

    MFD: mcp-sa11x0: remove DMA initializers and variables
    
    The dma_device_t variables are only ever written to by mcp-sa11x0 and
    never read.  As the old SA11x0 DMA support will be removed, remove
    these so that it no longer depends on the old SA11x0 DMA definitions.
    
    Acked-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 63a3cbdfa3f3..ec6ffb6e287d 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -32,7 +32,6 @@
 #include <linux/kthread.h>
 #include <linux/mfd/ucb1x00.h>
 
-#include <mach/dma.h>
 #include <mach/collie.h>
 #include <asm/mach-types.h>
 

commit 0af5e4c36e70cfd4ae96d3704a425c414f530f2a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Jan 22 20:58:55 2012 +0000

    MFD: ucb1x00-ts: fix resume failure
    
    If the ucb1x00 touchscreen is resumed while the touchscreen is being
    touched, the main thread stops responding.  This occurs because two
    things happen:
    
    1. When we suspended, we were woken up, and executed the loop.
       Finding that the touchscreen was not pressed, we prepare to
       schedule for a maximum timeout, before being stopped in
       try_to_freeze().
    
    2. an irq occurs, we disable the irq, and mark it as disabled,
       and wake the thread.  This wake occurs while the thread is
       still within __refrigerator()
    
    3. The thread is unfrozen, and __refrigerator() sets the threads
       state back to INTERRUPTIBLE.
    
    We then drop into schedule_timeout() with an infinite timeout and the
    IRQ disabled.  This prevents any further screen touches activating
    the thread.
    
    Fix this by using kthread_freezable_should_stop() which handles the
    freezing issues for us outside of the hotspot where the task state
    matters.  Include a flag to ignore the touchscreen until it is
    released to avoid sending unintended data to the application.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 38ffbd50a0d2..63a3cbdfa3f3 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -47,7 +47,6 @@ struct ucb1x00_ts {
 	u16			x_res;
 	u16			y_res;
 
-	unsigned int		restart:1;
 	unsigned int		adcsync:1;
 };
 
@@ -207,15 +206,17 @@ static int ucb1x00_thread(void *_ts)
 {
 	struct ucb1x00_ts *ts = _ts;
 	DECLARE_WAITQUEUE(wait, current);
+	bool frozen, ignore = false;
 	int valid = 0;
 
 	set_freezable();
 	add_wait_queue(&ts->irq_wait, &wait);
-	while (!kthread_should_stop()) {
+	while (!kthread_freezable_should_stop(&frozen)) {
 		unsigned int x, y, p;
 		signed long timeout;
 
-		ts->restart = 0;
+		if (frozen)
+			ignore = true;
 
 		ucb1x00_adc_enable(ts->ucb);
 
@@ -258,7 +259,7 @@ static int ucb1x00_thread(void *_ts)
 			 * space.  We therefore leave it to user space
 			 * to do any filtering they please.
 			 */
-			if (!ts->restart) {
+			if (!ignore) {
 				ucb1x00_ts_evt_add(ts, p, x, y);
 				valid = 1;
 			}
@@ -267,8 +268,6 @@ static int ucb1x00_thread(void *_ts)
 			timeout = HZ / 100;
 		}
 
-		try_to_freeze();
-
 		schedule_timeout(timeout);
 	}
 
@@ -340,26 +339,6 @@ static void ucb1x00_ts_close(struct input_dev *idev)
 	ucb1x00_disable(ts->ucb);
 }
 
-#ifdef CONFIG_PM
-static int ucb1x00_ts_resume(struct ucb1x00_dev *dev)
-{
-	struct ucb1x00_ts *ts = dev->priv;
-
-	if (ts->rtask != NULL) {
-		/*
-		 * Restart the TS thread to ensure the
-		 * TS interrupt mode is set up again
-		 * after sleep.
-		 */
-		ts->restart = 1;
-		wake_up(&ts->irq_wait);
-	}
-	return 0;
-}
-#else
-#define ucb1x00_ts_resume NULL
-#endif
-
 
 /*
  * Initialisation.
@@ -425,7 +404,6 @@ static void ucb1x00_ts_remove(struct ucb1x00_dev *dev)
 static struct ucb1x00_driver ucb1x00_ts_driver = {
 	.add		= ucb1x00_ts_add,
 	.remove		= ucb1x00_ts_remove,
-	.resume		= ucb1x00_ts_resume,
 };
 
 static int __init ucb1x00_ts_init(void)

commit 65f2e753f1eb09d3a7e2a0d16408a5433b4097b2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 20 17:38:58 2012 +0000

    Revert "ARM: sa11x0: Implement autoloading of codec and codec pdata for mcp bus."
    
    This reverts commit 5dd7bf59e0e8563265b3e5b33276099ef628fcc7.
    
    Conflicts:
    
            scripts/mod/file2alias.c
    
    This change is wrong on many levels.  First and foremost, it causes a
    regression.  On boot on Assabet, which this patch gives a codec id of
    'ucb1x00', it gives:
    
            ucb1x00 ID not found: 1005
    
    0x1005 is a valid ID for the UCB1300 device.
    
    Secondly, this patch is way over the top in terms of complexity.  The
    only device which has been seen to be connected with this MCP code is
    the UCB1x00 (UCB1200, UCB1300 etc) devices, and they all use the same
    driver.  Adding a match table, requiring the codec string to match the
    hardware ID read out of the ID register, etc is completely over the top
    when we can just read the hardware ID register.

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 40ec3c118868..38ffbd50a0d2 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -382,7 +382,7 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
 	idev->name       = "Touchscreen panel";
-	idev->id.product = ts->ucb->id->driver_data;
+	idev->id.product = ts->ucb->id;
 	idev->open       = ucb1x00_ts_open;
 	idev->close      = ucb1x00_ts_close;
 

commit 5dd7bf59e0e8563265b3e5b33276099ef628fcc7
Author: Jochen Friedrich <jochen@scram.de>
Date:   Sun Nov 27 22:00:54 2011 +0100

    ARM: sa11x0: Implement autoloading of codec and codec pdata for mcp bus.
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 38ffbd50a0d2..40ec3c118868 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -382,7 +382,7 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
 	idev->name       = "Touchscreen panel";
-	idev->id.product = ts->ucb->id;
+	idev->id.product = ts->ucb->id->driver_data;
 	idev->open       = ucb1x00_ts_open;
 	idev->close      = ucb1x00_ts_close;
 

commit de8c8b0683043e81d2001e446f2bcb143affb0b2
Author: Jochen Friedrich <jochen@scram.de>
Date:   Sun Jan 30 13:40:56 2011 +0100

    mfd: Add BTN_TOUCH event to ucb1x00-ts
    
    Add BTN_TOUCH event reporting to ucb1x00_ts touchscreen driver.
    This will make this touchscreen driver behave consistently wrt.
    BTN_TOUCH.
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 92b85e28a15e..38ffbd50a0d2 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -60,6 +60,7 @@ static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x
 	input_report_abs(idev, ABS_X, x);
 	input_report_abs(idev, ABS_Y, y);
 	input_report_abs(idev, ABS_PRESSURE, pressure);
+	input_report_key(idev, BTN_TOUCH, 1);
 	input_sync(idev);
 }
 
@@ -68,6 +69,7 @@ static inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)
 	struct input_dev *idev = ts->idev;
 
 	input_report_abs(idev, ABS_PRESSURE, 0);
+	input_report_key(idev, BTN_TOUCH, 0);
 	input_sync(idev);
 }
 
@@ -384,7 +386,8 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	idev->open       = ucb1x00_ts_open;
 	idev->close      = ucb1x00_ts_close;
 
-	__set_bit(EV_ABS, idev->evbit);
+	idev->evbit[0]   = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);
+	idev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
 
 	input_set_drvdata(idev, ts);
 

commit 9063f1f15eec35e5fd608879cef8be5728f2d12a
Author: Jochen Friedrich <jochen@scram.de>
Date:   Wed Jan 26 11:30:01 2011 +0100

    mfd: Fix NULL pointer due to non-initialized ucb1x00-ts absinfo
    
    Call input_set_abs_params instead of manually setting absbit only.
    This fixes this oops:
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000024
    Internal error: Oops: 41b67017 [#1]
    CPU: 0    Not tainted  (2.6.37 #4)
    pc : [<c016d1fc>]    lr : [<00000000>]    psr: 20000093
    sp : c19e5f30  ip : c19e5e6c  fp : c19e5f58
    r10: 00000000  r9 : c19e4000  r8 : 00000003
    r7 : 000001e4  r6 : 00000001  r5 : c1854400  r4 : 00000003
    r3 : 00000018  r2 : 00000018  r1 : 00000018  r0 : c185447c
    Flags: nzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: c1b6717f  Table: c1b6717f  DAC: 00000017
    Stack: (0xc19e5f30 to 0xc19e6000)
    5f20:                                     00000003 00000003 c1854400 00000013
    5f40: 00000001 000001e4 000001c5 c19e5f80 c19e5f5c c016d5e8 c016cf5c 000001e4
    5f60: c1854400 c18b5860 00000000 00000171 000001e4 c19e5fc4 c19e5f84 c01559a4
    5f80: c016d584 c18b5868 00000000 c1bb5c40 c0035afc c18b5868 c18b5868 c1a55d54
    5fa0: c18b5860 c0155750 00000013 00000000 00000000 00000000 c19e5ff4 c19e5fc8
    5fc0: c0050174 c015575c 00000000 c18b5860 00000000 c19e5fd4 c19e5fd4 c1a55d54
    5fe0: c00500f0 c003b464 00000000 c19e5ff8 c003b464 c00500fc 04000400 04000400
    Backtrace:
    Function entered at [<c016cf50>] from [<c016d5e8>]
    Function entered at [<c016d578>] from [<c01559a4>]
     r8:000001e4 r7:00000171 r6:00000000 r5:c18b5860 r4:c1854400
    Function entered at [<c0155750>] from [<c0050174>]
    Function entered at [<c00500f0>] from [<c003b464>]
     r6:c003b464 r5:c00500f0 r4:c1a55d54
    Code: e59520fc e1a03286 e0433186 e0822003 (e592000c)
    
    >>PC;  c016d1fc <input_handle_event+2ac/5a0>   <=====
    
    Trace; c016cf50 <input_handle_event+0/5a0>
    Trace; c016d5e8 <input_event+70/88>
    Trace; c016d578 <input_event+0/88>
    Trace; c01559a4 <ucb1x00_thread+254/2dc>
    Trace; c0155750 <ucb1x00_thread+0/2dc>
    Trace; c0050174 <kthread+84/8c>
    Trace; c00500f0 <kthread+0/8c>
    Trace; c003b464 <do_exit+0/624>
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    CC: stable@kernel.org
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 000cb414a78a..92b85e28a15e 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -385,12 +385,18 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	idev->close      = ucb1x00_ts_close;
 
 	__set_bit(EV_ABS, idev->evbit);
-	__set_bit(ABS_X, idev->absbit);
-	__set_bit(ABS_Y, idev->absbit);
-	__set_bit(ABS_PRESSURE, idev->absbit);
 
 	input_set_drvdata(idev, ts);
 
+	ucb1x00_adc_enable(ts->ucb);
+	ts->x_res = ucb1x00_ts_read_xres(ts);
+	ts->y_res = ucb1x00_ts_read_yres(ts);
+	ucb1x00_adc_disable(ts->ucb);
+
+	input_set_abs_params(idev, ABS_X, 0, ts->x_res, 0, 0);
+	input_set_abs_params(idev, ABS_Y, 0, ts->y_res, 0, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, 0, 0, 0);
+
 	err = input_register_device(idev);
 	if (err)
 		goto fail;

commit c8602edf3f9471466755329b78d309f2a01dd449
Author: Thomas Kunze <thommycheck@gmx.de>
Date:   Tue Feb 10 14:54:57 2009 +0100

    move drivers/mfd/*.h to include/linux/mfd
    
    So drivers like collie_battery driver can use
    those files easier.

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 61b7d3eb9a2f..000cb414a78a 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -30,12 +30,12 @@
 #include <linux/freezer.h>
 #include <linux/slab.h>
 #include <linux/kthread.h>
+#include <linux/mfd/ucb1x00.h>
 
 #include <mach/dma.h>
 #include <mach/collie.h>
 #include <asm/mach-types.h>
 
-#include "ucb1x00.h"
 
 
 struct ucb1x00_ts {

commit dcea83adc666061864b82c96e059dffe7268b512
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Nov 29 11:40:28 2008 +0000

    [ARM] Hide ISA DMA API when ISA_DMA_API is unset
    
    When ISA_DMA_API is unset, we're not implementing the ISA DMA API,
    so there's no point in publishing the prototypes via asm/dma.h, nor
    including the machine dependent parts of that API.
    
    This allows us to remove a lot of mach/dma.h files which don't contain
    any useful code.  Unfortunately though, some platforms put their own
    private non-ISA definitions into mach/dma.h, so we leave these behind
    and fix the appropriate #include statments.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 44762ca86a8d..61b7d3eb9a2f 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -31,7 +31,7 @@
 #include <linux/slab.h>
 #include <linux/kthread.h>
 
-#include <asm/dma.h>
+#include <mach/dma.h>
 #include <mach/collie.h>
 #include <asm/mach-types.h>
 

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index ad34e2d22524..44762ca86a8d 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -32,7 +32,7 @@
 #include <linux/kthread.h>
 
 #include <asm/dma.h>
-#include <asm/arch/collie.h>
+#include <mach/collie.h>
 #include <asm/mach-types.h>
 
 #include "ucb1x00.h"

commit f7440b0ecdeb3a04d07c546d02d29700d2a574b7
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Mon Apr 28 02:14:24 2008 -0700

    mfd: use shorter set_current_state()
    
    Since this routine declares a separate "tsk" pointer for no other reason than
    to call set_task_state(), get rid of it and just invoke set_current_state().
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 5e859486eaf8..ad34e2d22524 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -204,8 +204,7 @@ static inline int ucb1x00_ts_pen_down(struct ucb1x00_ts *ts)
 static int ucb1x00_thread(void *_ts)
 {
 	struct ucb1x00_ts *ts = _ts;
-	struct task_struct *tsk = current;
-	DECLARE_WAITQUEUE(wait, tsk);
+	DECLARE_WAITQUEUE(wait, current);
 	int valid = 0;
 
 	set_freezable();
@@ -234,7 +233,7 @@ static int ucb1x00_thread(void *_ts)
 
 
 		if (ucb1x00_ts_pen_down(ts)) {
-			set_task_state(tsk, TASK_INTERRUPTIBLE);
+			set_current_state(TASK_INTERRUPTIBLE);
 
 			ucb1x00_enable_irq(ts->ucb, UCB_IRQ_TSPX, machine_is_collie() ? UCB_RISING : UCB_FALLING);
 			ucb1x00_disable(ts->ucb);
@@ -262,7 +261,7 @@ static int ucb1x00_thread(void *_ts)
 				valid = 1;
 			}
 
-			set_task_state(tsk, TASK_INTERRUPTIBLE);
+			set_current_state(TASK_INTERRUPTIBLE);
 			timeout = HZ / 100;
 		}
 

commit d3135846f6c1858dbad6ccb780a42e6c98953e6d
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Apr 18 22:16:32 2008 -0400

    drivers: Remove unnecessary inclusions of asm/semaphore.h
    
    None of these files use any of the functionality promised by
    asm/semaphore.h.  It's possible that they rely on it dragging in some
    unrelated header file, but I can't build all these files, so we'll have
    fix any build failures as they come up.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index fdbaa776f249..5e859486eaf8 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -32,7 +32,6 @@
 #include <linux/kthread.h>
 
 #include <asm/dma.h>
-#include <asm/semaphore.h>
 #include <asm/arch/collie.h>
 #include <asm/mach-types.h>
 

commit 831441862956fffa17b9801db37e6ea1650b0f69
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jul 17 04:03:35 2007 -0700

    Freezer: make kernel threads nonfreezable by default
    
    Currently, the freezer treats all tasks as freezable, except for the kernel
    threads that explicitly set the PF_NOFREEZE flag for themselves.  This
    approach is problematic, since it requires every kernel thread to either
    set PF_NOFREEZE explicitly, or call try_to_freeze(), even if it doesn't
    care for the freezing of tasks at all.
    
    It seems better to only require the kernel threads that want to or need to
    be frozen to use some freezer-related code and to remove any
    freezer-related code from the other (nonfreezable) kernel threads, which is
    done in this patch.
    
    The patch causes all kernel threads to be nonfreezable by default (ie.  to
    have PF_NOFREEZE set by default) and introduces the set_freezable()
    function that should be called by the freezable kernel threads in order to
    unset PF_NOFREEZE.  It also makes all of the currently freezable kernel
    threads call set_freezable(), so it shouldn't cause any (intentional)
    change of behaviour to appear.  Additionally, it updates documentation to
    describe the freezing of tasks more accurately.
    
    [akpm@linux-foundation.org: build fixes]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 38e815a2e871..fdbaa776f249 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -209,6 +209,7 @@ static int ucb1x00_thread(void *_ts)
 	DECLARE_WAITQUEUE(wait, tsk);
 	int valid = 0;
 
+	set_freezable();
 	add_wait_queue(&ts->irq_wait, &wait);
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;

commit 0b662c64840fb281e5948ab6f9d60f84817277d0
Merge: 45efebf24921 1dfa2812404c
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Jun 4 13:27:33 2007 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: reduce raciness when input handlers disconnect
      Input: ucb1x00 - do not access input_dev->private directly
      Input: logips2pp - fix typo in Kconfig
      Input: db9 - do not ignore dev2 module parameter

commit 26be5a509af5f80c7012bd4f0478a94746c9c9d9
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Fri May 11 01:16:12 2007 -0400

    Input: ucb1x00 - do not access input_dev->private directly
    
    Use input_get_drvdata() and input_set_drvdata() helpers to do that.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index b023eae3c3ec..2d03bf791ceb 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -292,7 +292,7 @@ static void ucb1x00_ts_irq(int idx, void *id)
 
 static int ucb1x00_ts_open(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = idev->private;
+	struct ucb1x00_ts *ts = input_get_drvdata(idev);
 	int ret = 0;
 
 	BUG_ON(ts->rtask);
@@ -329,7 +329,7 @@ static int ucb1x00_ts_open(struct input_dev *idev)
  */
 static void ucb1x00_ts_close(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = idev->private;
+	struct ucb1x00_ts *ts = input_get_drvdata(idev);
 
 	if (ts->rtask)
 		kthread_stop(ts->rtask);
@@ -381,7 +381,6 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	ts->idev = idev;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
-	idev->private    = ts;
 	idev->name       = "Touchscreen panel";
 	idev->id.product = ts->ucb->id;
 	idev->open       = ucb1x00_ts_open;
@@ -392,6 +391,8 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	__set_bit(ABS_Y, idev->absbit);
 	__set_bit(ABS_PRESSURE, idev->absbit);
 
+	input_set_drvdata(idev, ts);
+
 	err = input_register_device(idev);
 	if (err)
 		goto fail;

commit 31f6e1bd3b58c9a67e5ea0c2d372fbf5fc9e326d
Merge: ad9ddd66c6e8 230ffc8e348e
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed May 23 08:11:43 2007 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: ads7846 - SPI_CPHA mode bugfix
      Input: ads7846 - document that it handles tsc2046 too
      Input: input-polldev - add module info
      Input: ucb1x00-ts - remove commented out code
      Input: ucb1400_ts - use sched_setscheduler()
      Input: ALPS - force stream mode
      Input: iforce - minor clean-ups
      Input: iforce - fix force feedback not working
      Input: adbhid - do not access input_dev->private directly
      Input: logips2pp - add type 72 (PS/2 TrackMan Marble)

commit 1124d5ca7b7296035c1cc5fc00fdbfa44603b2ac
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 14 23:52:22 2007 -0400

    Input: ucb1x00-ts - remove commented out code
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index ce1a48108210..b023eae3c3ec 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -208,16 +208,7 @@ static int ucb1x00_thread(void *_ts)
 	struct ucb1x00_ts *ts = _ts;
 	struct task_struct *tsk = current;
 	DECLARE_WAITQUEUE(wait, tsk);
-	int valid;
-
-	/*
-	 * We could run as a real-time thread.  However, thus far
-	 * this doesn't seem to be necessary.
-	 */
-//	tsk->policy = SCHED_FIFO;
-//	tsk->rt_priority = 1;
-
-	valid = 0;
+	int valid = 0;
 
 	add_wait_queue(&ts->irq_wait, &wait);
 	while (!kthread_should_stop()) {

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index ce1a48108210..cb8c264eaff0 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -21,7 +21,6 @@
 #include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/sched.h>
 #include <linux/completion.h>
 #include <linux/delay.h>

commit 7dfb71030f7636a0d65200158113c37764552f93
Author: Nigel Cunningham <ncunningham@linuxmail.org>
Date:   Wed Dec 6 20:34:23 2006 -0800

    [PATCH] Add include/linux/freezer.h and move definitions from sched.h
    
    Move process freezing functions from include/linux/sched.h to freezer.h, so
    that modifications to the freezer or the kernel configuration don't require
    recompiling just about everything.
    
    [akpm@osdl.org: fix ueagle driver]
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 82938ad6ddbd..ce1a48108210 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -28,7 +28,7 @@
 #include <linux/string.h>
 #include <linux/input.h>
 #include <linux/device.h>
-#include <linux/suspend.h>
+#include <linux/freezer.h>
 #include <linux/slab.h>
 #include <linux/kthread.h>
 

commit 08c67d2a5d1c97b7997dc9589f702d875c63de07
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Fri Sep 29 01:59:52 2006 -0700

    [PATCH] ucb1x00-ts: handle errors from input_register_device()
    
    ucb1x00-ts: handle errors from input_register_device()
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 02776814443e..82938ad6ddbd 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -58,6 +58,7 @@ static int adcsync;
 static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)
 {
 	struct input_dev *idev = ts->idev;
+
 	input_report_abs(idev, ABS_X, x);
 	input_report_abs(idev, ABS_Y, y);
 	input_report_abs(idev, ABS_PRESSURE, pressure);
@@ -67,6 +68,7 @@ static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x
 static inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)
 {
 	struct input_dev *idev = ts->idev;
+
 	input_report_abs(idev, ABS_PRESSURE, 0);
 	input_sync(idev);
 }
@@ -189,6 +191,7 @@ static inline unsigned int ucb1x00_ts_read_yres(struct ucb1x00_ts *ts)
 static inline int ucb1x00_ts_pen_down(struct ucb1x00_ts *ts)
 {
 	unsigned int val = ucb1x00_reg_read(ts->ucb, UCB_TS_CR);
+
 	if (machine_is_collie())
 		return (!(val & (UCB_TS_CR_TSPX_LOW)));
 	else
@@ -291,6 +294,7 @@ static int ucb1x00_thread(void *_ts)
 static void ucb1x00_ts_irq(int idx, void *id)
 {
 	struct ucb1x00_ts *ts = id;
+
 	ucb1x00_disable_irq(ts->ucb, UCB_IRQ_TSPX, UCB_FALLING);
 	wake_up(&ts->irq_wait);
 }
@@ -372,36 +376,43 @@ static int ucb1x00_ts_resume(struct ucb1x00_dev *dev)
 static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 {
 	struct ucb1x00_ts *ts;
+	struct input_dev *idev;
+	int err;
 
 	ts = kzalloc(sizeof(struct ucb1x00_ts), GFP_KERNEL);
-	if (!ts)
-		return -ENOMEM;
-
-	ts->idev = input_allocate_device();
-	if (!ts->idev) {
-		kfree(ts);
-		return -ENOMEM;
+	idev = input_allocate_device();
+	if (!ts || !idev) {
+		err = -ENOMEM;
+		goto fail;
 	}
 
 	ts->ucb = dev->ucb;
+	ts->idev = idev;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
-	ts->idev->private = ts;
-	ts->idev->name       = "Touchscreen panel";
-	ts->idev->id.product = ts->ucb->id;
-	ts->idev->open       = ucb1x00_ts_open;
-	ts->idev->close      = ucb1x00_ts_close;
+	idev->private    = ts;
+	idev->name       = "Touchscreen panel";
+	idev->id.product = ts->ucb->id;
+	idev->open       = ucb1x00_ts_open;
+	idev->close      = ucb1x00_ts_close;
 
-	__set_bit(EV_ABS, ts->idev->evbit);
-	__set_bit(ABS_X, ts->idev->absbit);
-	__set_bit(ABS_Y, ts->idev->absbit);
-	__set_bit(ABS_PRESSURE, ts->idev->absbit);
+	__set_bit(EV_ABS, idev->evbit);
+	__set_bit(ABS_X, idev->absbit);
+	__set_bit(ABS_Y, idev->absbit);
+	__set_bit(ABS_PRESSURE, idev->absbit);
 
-	input_register_device(ts->idev);
+	err = input_register_device(idev);
+	if (err)
+		goto fail;
 
 	dev->priv = ts;
 
 	return 0;
+
+ fail:
+	input_free_device(idev);
+	kfree(ts);
+	return err;
 }
 
 static void ucb1x00_ts_remove(struct ucb1x00_dev *dev)

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 79fd062ccb34..02776814443e 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -17,7 +17,6 @@
  * pin should provide pulses even when the LCD is blanked, otherwise
  * a pen touch needed to unblank the LCD will never be read.
  */
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>

commit 44fce35f29a7f2d976d9160bfbc55635b459a6a0
Author: Nicolas Kaiser <nikai@nikai.net>
Date:   Sun Jan 8 01:03:37 2006 -0800

    [PATCH] drivers/mfd: header included twice
    
    linux/delay.h included twice
    
    Signed-off-by: Nicolas Kaiser <nikai@nikai.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 551061c2eadf..79fd062ccb34 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -32,7 +32,6 @@
 #include <linux/suspend.h>
 #include <linux/slab.h>
 #include <linux/kthread.h>
-#include <linux/delay.h>
 
 #include <asm/dma.h>
 #include <asm/semaphore.h>

commit 1393c3edc307e0a2ec4274f67e342907ffd7deb5
Author: Nicolas Pitre <nico@cam.org>
Date:   Mon Dec 12 00:37:36 2005 -0800

    [PATCH] input: fix ucb1x00-ts breakage after conversion to dynamic input_dev allocation
    
    The bd622663192e8ebebb27dc1d9397f352a82d2495 commit broke the UCB1x00
    touchscreen driver since the idev structure was assumed to be into the ts
    structure, simply casting the former to the later in a couple places.
    
    This patch fixes those, and also cache the idev pointer between multiple
    calls to input_report_abs() to avoid growing the compiled code needlessly.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Cc: Dmitry Torokhov <dtor_core@ameritech.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index a984c0efabf0..551061c2eadf 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -59,16 +59,18 @@ static int adcsync;
 
 static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)
 {
-	input_report_abs(ts->idev, ABS_X, x);
-	input_report_abs(ts->idev, ABS_Y, y);
-	input_report_abs(ts->idev, ABS_PRESSURE, pressure);
-	input_sync(ts->idev);
+	struct input_dev *idev = ts->idev;
+	input_report_abs(idev, ABS_X, x);
+	input_report_abs(idev, ABS_Y, y);
+	input_report_abs(idev, ABS_PRESSURE, pressure);
+	input_sync(idev);
 }
 
 static inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)
 {
-	input_report_abs(ts->idev, ABS_PRESSURE, 0);
-	input_sync(ts->idev);
+	struct input_dev *idev = ts->idev;
+	input_report_abs(idev, ABS_PRESSURE, 0);
+	input_sync(idev);
 }
 
 /*
@@ -297,7 +299,7 @@ static void ucb1x00_ts_irq(int idx, void *id)
 
 static int ucb1x00_ts_open(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+	struct ucb1x00_ts *ts = idev->private;
 	int ret = 0;
 
 	BUG_ON(ts->rtask);
@@ -334,7 +336,7 @@ static int ucb1x00_ts_open(struct input_dev *idev)
  */
 static void ucb1x00_ts_close(struct input_dev *idev)
 {
-	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+	struct ucb1x00_ts *ts = idev->private;
 
 	if (ts->rtask)
 		kthread_stop(ts->rtask);
@@ -386,6 +388,7 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 	ts->ucb = dev->ucb;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
+	ts->idev->private = ts;
 	ts->idev->name       = "Touchscreen panel";
 	ts->idev->id.product = ts->ucb->id;
 	ts->idev->open       = ucb1x00_ts_open;

commit 1753298947afe5eb56da755bc057f1868f345ec1
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sun Oct 30 23:38:01 2005 +0000

    [ARM] Sharp sl-5500 touchscreen support
    
    This adds support for sharp zaurus sl-5500 touchscreen.  It introduces
    some not-too-nice ifs, but I guess copying whole ucb1x00-ts.c would be
    bad idea...
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 585cded3d365..a984c0efabf0 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -32,9 +32,12 @@
 #include <linux/suspend.h>
 #include <linux/slab.h>
 #include <linux/kthread.h>
+#include <linux/delay.h>
 
 #include <asm/dma.h>
 #include <asm/semaphore.h>
+#include <asm/arch/collie.h>
+#include <asm/mach-types.h>
 
 #include "ucb1x00.h"
 
@@ -85,12 +88,23 @@ static inline void ucb1x00_ts_mode_int(struct ucb1x00_ts *ts)
  */
 static inline unsigned int ucb1x00_ts_read_pressure(struct ucb1x00_ts *ts)
 {
-	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
-			UCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |
-			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |
-			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	if (machine_is_collie()) {
+		ucb1x00_io_write(ts->ucb, COLLIE_TC35143_GPIO_TBL_CHK, 0);
+		ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+				  UCB_TS_CR_TSPX_POW | UCB_TS_CR_TSMX_POW |
+				  UCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);
 
-	return ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);
+		udelay(55);
+
+		return ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_AD2, ts->adcsync);
+	} else {
+		ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+				  UCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |
+				  UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |
+				  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+
+		return ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);
+	}
 }
 
 /*
@@ -101,12 +115,16 @@ static inline unsigned int ucb1x00_ts_read_pressure(struct ucb1x00_ts *ts)
  */
 static inline unsigned int ucb1x00_ts_read_xpos(struct ucb1x00_ts *ts)
 {
-	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
-			UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
-			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
-	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
-			UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
-			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	if (machine_is_collie())
+		ucb1x00_io_write(ts->ucb, 0, COLLIE_TC35143_GPIO_TBL_CHK);
+	else {
+		ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+				  UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
+				  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+		ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+				  UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
+				  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	}
 	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
 			UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
 			UCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);
@@ -124,12 +142,17 @@ static inline unsigned int ucb1x00_ts_read_xpos(struct ucb1x00_ts *ts)
  */
 static inline unsigned int ucb1x00_ts_read_ypos(struct ucb1x00_ts *ts)
 {
-	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
-			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
-			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
-	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
-			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
-			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	if (machine_is_collie())
+		ucb1x00_io_write(ts->ucb, 0, COLLIE_TC35143_GPIO_TBL_CHK);
+	else {
+		ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+				  UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
+				  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+		ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+				  UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
+				  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	}
+
 	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
 			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
 			UCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);
@@ -163,6 +186,15 @@ static inline unsigned int ucb1x00_ts_read_yres(struct ucb1x00_ts *ts)
 	return ucb1x00_adc_read(ts->ucb, 0, ts->adcsync);
 }
 
+static inline int ucb1x00_ts_pen_down(struct ucb1x00_ts *ts)
+{
+	unsigned int val = ucb1x00_reg_read(ts->ucb, UCB_TS_CR);
+	if (machine_is_collie())
+		return (!(val & (UCB_TS_CR_TSPX_LOW)));
+	else
+		return (val & (UCB_TS_CR_TSPX_LOW | UCB_TS_CR_TSMX_LOW));
+}
+
 /*
  * This is a RT kernel thread that handles the ADC accesses
  * (mainly so we can use semaphores in the UCB1200 core code
@@ -186,7 +218,7 @@ static int ucb1x00_thread(void *_ts)
 
 	add_wait_queue(&ts->irq_wait, &wait);
 	while (!kthread_should_stop()) {
-		unsigned int x, y, p, val;
+		unsigned int x, y, p;
 		signed long timeout;
 
 		ts->restart = 0;
@@ -206,12 +238,12 @@ static int ucb1x00_thread(void *_ts)
 		msleep(10);
 
 		ucb1x00_enable(ts->ucb);
-		val = ucb1x00_reg_read(ts->ucb, UCB_TS_CR);
 
-		if (val & (UCB_TS_CR_TSPX_LOW | UCB_TS_CR_TSMX_LOW)) {
+
+		if (ucb1x00_ts_pen_down(ts)) {
 			set_task_state(tsk, TASK_INTERRUPTIBLE);
 
-			ucb1x00_enable_irq(ts->ucb, UCB_IRQ_TSPX, UCB_FALLING);
+			ucb1x00_enable_irq(ts->ucb, UCB_IRQ_TSPX, machine_is_collie() ? UCB_RISING : UCB_FALLING);
 			ucb1x00_disable(ts->ucb);
 
 			/*

commit bd622663192e8ebebb27dc1d9397f352a82d2495
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Thu Sep 15 02:01:48 2005 -0500

    [PATCH] Input: convert ucb1x00-ts to dynamic input_dev allocation
    
    Input: convert ucb1x00-ts to dynamic input_dev allocation
    
    This is required for input_dev sysfs integration
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index a260f83bcb02..585cded3d365 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -40,7 +40,7 @@
 
 
 struct ucb1x00_ts {
-	struct input_dev	idev;
+	struct input_dev	*idev;
 	struct ucb1x00		*ucb;
 
 	wait_queue_head_t	irq_wait;
@@ -56,16 +56,16 @@ static int adcsync;
 
 static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)
 {
-	input_report_abs(&ts->idev, ABS_X, x);
-	input_report_abs(&ts->idev, ABS_Y, y);
-	input_report_abs(&ts->idev, ABS_PRESSURE, pressure);
-	input_sync(&ts->idev);
+	input_report_abs(ts->idev, ABS_X, x);
+	input_report_abs(ts->idev, ABS_Y, y);
+	input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+	input_sync(ts->idev);
 }
 
 static inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)
 {
-	input_report_abs(&ts->idev, ABS_PRESSURE, 0);
-	input_sync(&ts->idev);
+	input_report_abs(ts->idev, ABS_PRESSURE, 0);
+	input_sync(ts->idev);
 }
 
 /*
@@ -341,26 +341,30 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 {
 	struct ucb1x00_ts *ts;
 
-	ts = kmalloc(sizeof(struct ucb1x00_ts), GFP_KERNEL);
+	ts = kzalloc(sizeof(struct ucb1x00_ts), GFP_KERNEL);
 	if (!ts)
 		return -ENOMEM;
 
-	memset(ts, 0, sizeof(struct ucb1x00_ts));
+	ts->idev = input_allocate_device();
+	if (!ts->idev) {
+		kfree(ts);
+		return -ENOMEM;
+	}
 
 	ts->ucb = dev->ucb;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
 
-	ts->idev.name       = "Touchscreen panel";
-	ts->idev.id.product = ts->ucb->id;
-	ts->idev.open       = ucb1x00_ts_open;
-	ts->idev.close      = ucb1x00_ts_close;
+	ts->idev->name       = "Touchscreen panel";
+	ts->idev->id.product = ts->ucb->id;
+	ts->idev->open       = ucb1x00_ts_open;
+	ts->idev->close      = ucb1x00_ts_close;
 
-	__set_bit(EV_ABS, ts->idev.evbit);
-	__set_bit(ABS_X, ts->idev.absbit);
-	__set_bit(ABS_Y, ts->idev.absbit);
-	__set_bit(ABS_PRESSURE, ts->idev.absbit);
+	__set_bit(EV_ABS, ts->idev->evbit);
+	__set_bit(ABS_X, ts->idev->absbit);
+	__set_bit(ABS_Y, ts->idev->absbit);
+	__set_bit(ABS_PRESSURE, ts->idev->absbit);
 
-	input_register_device(&ts->idev);
+	input_register_device(ts->idev);
 
 	dev->priv = ts;
 
@@ -370,7 +374,8 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 static void ucb1x00_ts_remove(struct ucb1x00_dev *dev)
 {
 	struct ucb1x00_ts *ts = dev->priv;
-	input_unregister_device(&ts->idev);
+
+	input_unregister_device(ts->idev);
 	kfree(ts);
 }
 

commit 6b9ea4213e3a9c9b8de29a001a2b8d8799cbc1c9
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 24 10:24:37 2005 +0100

    [MFD] Fix "bious one-bit signed bitfield" errors
    
    ucb1x00-ts declared a couple of one-bit 'int' bitfields.
    Make them unsigned.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index a851d65c7cfe..a260f83bcb02 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -48,8 +48,8 @@ struct ucb1x00_ts {
 	u16			x_res;
 	u16			y_res;
 
-	int			restart:1;
-	int			adcsync:1;
+	unsigned int		restart:1;
+	unsigned int		adcsync:1;
 };
 
 static int adcsync;

commit 5437775e0bc38d633c0a4b7660812f15b6693b69
Author: Pavel Machek <pavel@suse.cz>
Date:   Sun Sep 11 10:28:00 2005 +0100

    [MFD] Cleanups suggested by Dmitri, Vojtech and lists.
    
    These are small ucb1x00-ts cleanups, as suggested by Vojtech, Dmitri
    and the lists.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index 52e0699eeb8b..a851d65c7cfe 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -1,7 +1,8 @@
 /*
- *  linux/drivers/mfd/ucb1x00-ts.c
+ *  Touchscreen driver for UCB1x00-based touchscreens
  *
  *  Copyright (C) 2001 Russell King, All Rights Reserved.
+ *  Copyright (C) 2005 Pavel Machek
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -30,6 +31,7 @@
 #include <linux/device.h>
 #include <linux/suspend.h>
 #include <linux/slab.h>
+#include <linux/kthread.h>
 
 #include <asm/dma.h>
 #include <asm/semaphore.h>
@@ -42,10 +44,7 @@ struct ucb1x00_ts {
 	struct ucb1x00		*ucb;
 
 	wait_queue_head_t	irq_wait;
-	struct semaphore	sem;
-	struct completion	init_exit;
 	struct task_struct	*rtask;
-	int			use_count;
 	u16			x_res;
 	u16			y_res;
 
@@ -176,12 +175,6 @@ static int ucb1x00_thread(void *_ts)
 	DECLARE_WAITQUEUE(wait, tsk);
 	int valid;
 
-	ts->rtask = tsk;
-
-	daemonize("ktsd");
-	/* only want to receive SIGKILL */
-	allow_signal(SIGKILL);
-
 	/*
 	 * We could run as a real-time thread.  However, thus far
 	 * this doesn't seem to be necessary.
@@ -189,12 +182,10 @@ static int ucb1x00_thread(void *_ts)
 //	tsk->policy = SCHED_FIFO;
 //	tsk->rt_priority = 1;
 
-	complete(&ts->init_exit);
-
 	valid = 0;
 
 	add_wait_queue(&ts->irq_wait, &wait);
-	for (;;) {
+	while (!kthread_should_stop()) {
 		unsigned int x, y, p, val;
 		signed long timeout;
 
@@ -212,10 +203,7 @@ static int ucb1x00_thread(void *_ts)
 		ucb1x00_ts_mode_int(ts);
 		ucb1x00_adc_disable(ts->ucb);
 
-		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ / 100);
-		if (signal_pending(tsk))
-			break;
+		msleep(10);
 
 		ucb1x00_enable(ts->ucb);
 		val = ucb1x00_reg_read(ts->ucb, UCB_TS_CR);
@@ -256,14 +244,12 @@ static int ucb1x00_thread(void *_ts)
 		try_to_freeze();
 
 		schedule_timeout(timeout);
-		if (signal_pending(tsk))
-			break;
 	}
 
 	remove_wait_queue(&ts->irq_wait, &wait);
 
 	ts->rtask = NULL;
-	complete_and_exit(&ts->init_exit, 0);
+	return 0;
 }
 
 /*
@@ -282,14 +268,7 @@ static int ucb1x00_ts_open(struct input_dev *idev)
 	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
 	int ret = 0;
 
-	if (down_interruptible(&ts->sem))
-		return -EINTR;
-
-	if (ts->use_count++ != 0)
-		goto out;
-
-	if (ts->rtask)
-		panic("ucb1x00: rtask running?");
+	BUG_ON(ts->rtask);
 
 	init_waitqueue_head(&ts->irq_wait);
 	ret = ucb1x00_hook_irq(ts->ucb, UCB_IRQ_TSPX, ucb1x00_ts_irq, ts);
@@ -305,19 +284,16 @@ static int ucb1x00_ts_open(struct input_dev *idev)
 	ts->y_res = ucb1x00_ts_read_yres(ts);
 	ucb1x00_adc_disable(ts->ucb);
 
-	init_completion(&ts->init_exit);
-	ret = kernel_thread(ucb1x00_thread, ts, CLONE_KERNEL);
-	if (ret >= 0) {
-		wait_for_completion(&ts->init_exit);
+	ts->rtask = kthread_run(ucb1x00_thread, ts, "ktsd");
+	if (!IS_ERR(ts->rtask)) {
 		ret = 0;
 	} else {
 		ucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);
+		ts->rtask = NULL;
+		ret = -EFAULT;
 	}
 
  out:
-	if (ret)
-		ts->use_count--;
-	up(&ts->sem);
 	return ret;
 }
 
@@ -328,19 +304,13 @@ static void ucb1x00_ts_close(struct input_dev *idev)
 {
 	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
 
-	down(&ts->sem);
-	if (--ts->use_count == 0) {
-		if (ts->rtask) {
-			send_sig(SIGKILL, ts->rtask, 1);
-			wait_for_completion(&ts->init_exit);
-		}
+	if (ts->rtask)
+		kthread_stop(ts->rtask);
 
-		ucb1x00_enable(ts->ucb);
-		ucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);
-		ucb1x00_reg_write(ts->ucb, UCB_TS_CR, 0);
-		ucb1x00_disable(ts->ucb);
-	}
-	up(&ts->sem);
+	ucb1x00_enable(ts->ucb);
+	ucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR, 0);
+	ucb1x00_disable(ts->ucb);
 }
 
 #ifdef CONFIG_PM
@@ -379,7 +349,6 @@ static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
 
 	ts->ucb = dev->ucb;
 	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
-	init_MUTEX(&ts->sem);
 
 	ts->idev.name       = "Touchscreen panel";
 	ts->idev.id.product = ts->ucb->id;

commit acb45439a89c6830349c02405f00a7208db0a66b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Sep 11 10:26:57 2005 +0100

    [MFD] Add code UCB1200/UCB1300 touchscreen support
    
    Add support for Philips UCB1200 and UCB1300 touchscreen
    interfaces found on ARM devices.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
new file mode 100644
index 000000000000..52e0699eeb8b
--- /dev/null
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -0,0 +1,430 @@
+/*
+ *  linux/drivers/mfd/ucb1x00-ts.c
+ *
+ *  Copyright (C) 2001 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 21-Jan-2002 <jco@ict.es> :
+ *
+ * Added support for synchronous A/D mode. This mode is useful to
+ * avoid noise induced in the touchpanel by the LCD, provided that
+ * the UCB1x00 has a valid LCD sync signal routed to its ADCSYNC pin.
+ * It is important to note that the signal connected to the ADCSYNC
+ * pin should provide pulses even when the LCD is blanked, otherwise
+ * a pen touch needed to unblank the LCD will never be read.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/input.h>
+#include <linux/device.h>
+#include <linux/suspend.h>
+#include <linux/slab.h>
+
+#include <asm/dma.h>
+#include <asm/semaphore.h>
+
+#include "ucb1x00.h"
+
+
+struct ucb1x00_ts {
+	struct input_dev	idev;
+	struct ucb1x00		*ucb;
+
+	wait_queue_head_t	irq_wait;
+	struct semaphore	sem;
+	struct completion	init_exit;
+	struct task_struct	*rtask;
+	int			use_count;
+	u16			x_res;
+	u16			y_res;
+
+	int			restart:1;
+	int			adcsync:1;
+};
+
+static int adcsync;
+
+static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)
+{
+	input_report_abs(&ts->idev, ABS_X, x);
+	input_report_abs(&ts->idev, ABS_Y, y);
+	input_report_abs(&ts->idev, ABS_PRESSURE, pressure);
+	input_sync(&ts->idev);
+}
+
+static inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)
+{
+	input_report_abs(&ts->idev, ABS_PRESSURE, 0);
+	input_sync(&ts->idev);
+}
+
+/*
+ * Switch to interrupt mode.
+ */
+static inline void ucb1x00_ts_mode_int(struct ucb1x00_ts *ts)
+{
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |
+			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |
+			UCB_TS_CR_MODE_INT);
+}
+
+/*
+ * Switch to pressure mode, and read pressure.  We don't need to wait
+ * here, since both plates are being driven.
+ */
+static inline unsigned int ucb1x00_ts_read_pressure(struct ucb1x00_ts *ts)
+{
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |
+			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |
+			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+
+	return ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);
+}
+
+/*
+ * Switch to X position mode and measure Y plate.  We switch the plate
+ * configuration in pressure mode, then switch to position mode.  This
+ * gives a faster response time.  Even so, we need to wait about 55us
+ * for things to stabilise.
+ */
+static inline unsigned int ucb1x00_ts_read_xpos(struct ucb1x00_ts *ts)
+{
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
+			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
+			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
+			UCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);
+
+	udelay(55);
+
+	return ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);
+}
+
+/*
+ * Switch to Y position mode and measure X plate.  We switch the plate
+ * configuration in pressure mode, then switch to position mode.  This
+ * gives a faster response time.  Even so, we need to wait about 55us
+ * for things to stabilise.
+ */
+static inline unsigned int ucb1x00_ts_read_ypos(struct ucb1x00_ts *ts)
+{
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
+			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
+			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
+			UCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);
+
+	udelay(55);
+
+	return ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPX, ts->adcsync);
+}
+
+/*
+ * Switch to X plate resistance mode.  Set MX to ground, PX to
+ * supply.  Measure current.
+ */
+static inline unsigned int ucb1x00_ts_read_xres(struct ucb1x00_ts *ts)
+{
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |
+			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	return ucb1x00_adc_read(ts->ucb, 0, ts->adcsync);
+}
+
+/*
+ * Switch to Y plate resistance mode.  Set MY to ground, PY to
+ * supply.  Measure current.
+ */
+static inline unsigned int ucb1x00_ts_read_yres(struct ucb1x00_ts *ts)
+{
+	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
+			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |
+			UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);
+	return ucb1x00_adc_read(ts->ucb, 0, ts->adcsync);
+}
+
+/*
+ * This is a RT kernel thread that handles the ADC accesses
+ * (mainly so we can use semaphores in the UCB1200 core code
+ * to serialise accesses to the ADC).
+ */
+static int ucb1x00_thread(void *_ts)
+{
+	struct ucb1x00_ts *ts = _ts;
+	struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
+	int valid;
+
+	ts->rtask = tsk;
+
+	daemonize("ktsd");
+	/* only want to receive SIGKILL */
+	allow_signal(SIGKILL);
+
+	/*
+	 * We could run as a real-time thread.  However, thus far
+	 * this doesn't seem to be necessary.
+	 */
+//	tsk->policy = SCHED_FIFO;
+//	tsk->rt_priority = 1;
+
+	complete(&ts->init_exit);
+
+	valid = 0;
+
+	add_wait_queue(&ts->irq_wait, &wait);
+	for (;;) {
+		unsigned int x, y, p, val;
+		signed long timeout;
+
+		ts->restart = 0;
+
+		ucb1x00_adc_enable(ts->ucb);
+
+		x = ucb1x00_ts_read_xpos(ts);
+		y = ucb1x00_ts_read_ypos(ts);
+		p = ucb1x00_ts_read_pressure(ts);
+
+		/*
+		 * Switch back to interrupt mode.
+		 */
+		ucb1x00_ts_mode_int(ts);
+		ucb1x00_adc_disable(ts->ucb);
+
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ / 100);
+		if (signal_pending(tsk))
+			break;
+
+		ucb1x00_enable(ts->ucb);
+		val = ucb1x00_reg_read(ts->ucb, UCB_TS_CR);
+
+		if (val & (UCB_TS_CR_TSPX_LOW | UCB_TS_CR_TSMX_LOW)) {
+			set_task_state(tsk, TASK_INTERRUPTIBLE);
+
+			ucb1x00_enable_irq(ts->ucb, UCB_IRQ_TSPX, UCB_FALLING);
+			ucb1x00_disable(ts->ucb);
+
+			/*
+			 * If we spat out a valid sample set last time,
+			 * spit out a "pen off" sample here.
+			 */
+			if (valid) {
+				ucb1x00_ts_event_release(ts);
+				valid = 0;
+			}
+
+			timeout = MAX_SCHEDULE_TIMEOUT;
+		} else {
+			ucb1x00_disable(ts->ucb);
+
+			/*
+			 * Filtering is policy.  Policy belongs in user
+			 * space.  We therefore leave it to user space
+			 * to do any filtering they please.
+			 */
+			if (!ts->restart) {
+				ucb1x00_ts_evt_add(ts, p, x, y);
+				valid = 1;
+			}
+
+			set_task_state(tsk, TASK_INTERRUPTIBLE);
+			timeout = HZ / 100;
+		}
+
+		try_to_freeze();
+
+		schedule_timeout(timeout);
+		if (signal_pending(tsk))
+			break;
+	}
+
+	remove_wait_queue(&ts->irq_wait, &wait);
+
+	ts->rtask = NULL;
+	complete_and_exit(&ts->init_exit, 0);
+}
+
+/*
+ * We only detect touch screen _touches_ with this interrupt
+ * handler, and even then we just schedule our task.
+ */
+static void ucb1x00_ts_irq(int idx, void *id)
+{
+	struct ucb1x00_ts *ts = id;
+	ucb1x00_disable_irq(ts->ucb, UCB_IRQ_TSPX, UCB_FALLING);
+	wake_up(&ts->irq_wait);
+}
+
+static int ucb1x00_ts_open(struct input_dev *idev)
+{
+	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+	int ret = 0;
+
+	if (down_interruptible(&ts->sem))
+		return -EINTR;
+
+	if (ts->use_count++ != 0)
+		goto out;
+
+	if (ts->rtask)
+		panic("ucb1x00: rtask running?");
+
+	init_waitqueue_head(&ts->irq_wait);
+	ret = ucb1x00_hook_irq(ts->ucb, UCB_IRQ_TSPX, ucb1x00_ts_irq, ts);
+	if (ret < 0)
+		goto out;
+
+	/*
+	 * If we do this at all, we should allow the user to
+	 * measure and read the X and Y resistance at any time.
+	 */
+	ucb1x00_adc_enable(ts->ucb);
+	ts->x_res = ucb1x00_ts_read_xres(ts);
+	ts->y_res = ucb1x00_ts_read_yres(ts);
+	ucb1x00_adc_disable(ts->ucb);
+
+	init_completion(&ts->init_exit);
+	ret = kernel_thread(ucb1x00_thread, ts, CLONE_KERNEL);
+	if (ret >= 0) {
+		wait_for_completion(&ts->init_exit);
+		ret = 0;
+	} else {
+		ucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);
+	}
+
+ out:
+	if (ret)
+		ts->use_count--;
+	up(&ts->sem);
+	return ret;
+}
+
+/*
+ * Release touchscreen resources.  Disable IRQs.
+ */
+static void ucb1x00_ts_close(struct input_dev *idev)
+{
+	struct ucb1x00_ts *ts = (struct ucb1x00_ts *)idev;
+
+	down(&ts->sem);
+	if (--ts->use_count == 0) {
+		if (ts->rtask) {
+			send_sig(SIGKILL, ts->rtask, 1);
+			wait_for_completion(&ts->init_exit);
+		}
+
+		ucb1x00_enable(ts->ucb);
+		ucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);
+		ucb1x00_reg_write(ts->ucb, UCB_TS_CR, 0);
+		ucb1x00_disable(ts->ucb);
+	}
+	up(&ts->sem);
+}
+
+#ifdef CONFIG_PM
+static int ucb1x00_ts_resume(struct ucb1x00_dev *dev)
+{
+	struct ucb1x00_ts *ts = dev->priv;
+
+	if (ts->rtask != NULL) {
+		/*
+		 * Restart the TS thread to ensure the
+		 * TS interrupt mode is set up again
+		 * after sleep.
+		 */
+		ts->restart = 1;
+		wake_up(&ts->irq_wait);
+	}
+	return 0;
+}
+#else
+#define ucb1x00_ts_resume NULL
+#endif
+
+
+/*
+ * Initialisation.
+ */
+static int ucb1x00_ts_add(struct ucb1x00_dev *dev)
+{
+	struct ucb1x00_ts *ts;
+
+	ts = kmalloc(sizeof(struct ucb1x00_ts), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	memset(ts, 0, sizeof(struct ucb1x00_ts));
+
+	ts->ucb = dev->ucb;
+	ts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;
+	init_MUTEX(&ts->sem);
+
+	ts->idev.name       = "Touchscreen panel";
+	ts->idev.id.product = ts->ucb->id;
+	ts->idev.open       = ucb1x00_ts_open;
+	ts->idev.close      = ucb1x00_ts_close;
+
+	__set_bit(EV_ABS, ts->idev.evbit);
+	__set_bit(ABS_X, ts->idev.absbit);
+	__set_bit(ABS_Y, ts->idev.absbit);
+	__set_bit(ABS_PRESSURE, ts->idev.absbit);
+
+	input_register_device(&ts->idev);
+
+	dev->priv = ts;
+
+	return 0;
+}
+
+static void ucb1x00_ts_remove(struct ucb1x00_dev *dev)
+{
+	struct ucb1x00_ts *ts = dev->priv;
+	input_unregister_device(&ts->idev);
+	kfree(ts);
+}
+
+static struct ucb1x00_driver ucb1x00_ts_driver = {
+	.add		= ucb1x00_ts_add,
+	.remove		= ucb1x00_ts_remove,
+	.resume		= ucb1x00_ts_resume,
+};
+
+static int __init ucb1x00_ts_init(void)
+{
+	return ucb1x00_register_driver(&ucb1x00_ts_driver);
+}
+
+static void __exit ucb1x00_ts_exit(void)
+{
+	ucb1x00_unregister_driver(&ucb1x00_ts_driver);
+}
+
+module_param(adcsync, int, 0444);
+module_init(ucb1x00_ts_init);
+module_exit(ucb1x00_ts_exit);
+
+MODULE_AUTHOR("Russell King <rmk@arm.linux.org.uk>");
+MODULE_DESCRIPTION("UCB1x00 touchscreen driver");
+MODULE_LICENSE("GPL");
