commit 5da3f7673764906ce211497c8034ed764077f183
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Oct 2 17:28:32 2019 -0700

    mfd: arizona: Switch to using devm_gpiod_get()
    
    Now that gpiolib recognizes wlf,reset legacy GPIO and will handle it
    even if DTS uses it without -gpio[s] suffix, we can switch to more
    standard devm_gpiod_get() and later remove devm_gpiod_get_from_of_node().
    
    Note that we will lose "arizona /RESET" custom GPIO label, but since we
    do not set such custom label when using the modern binding, I opted to
    not having it here either.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4a31907a4525..f73cf76d1373 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -814,11 +814,7 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 	int ret, i;
 
 	/* Handle old non-standard DT binding */
-	pdata->reset = devm_gpiod_get_from_of_node(arizona->dev,
-						   arizona->dev->of_node,
-						   "wlf,reset", 0,
-						   GPIOD_OUT_LOW,
-						   "arizona /RESET");
+	pdata->reset = devm_gpiod_get(arizona->dev, "wlf,reset", GPIOD_OUT_LOW);
 	if (IS_ERR(pdata->reset)) {
 		ret = PTR_ERR(pdata->reset);
 

commit 8de262531f5fbb7458463224a7587429800c24bf
Merge: be8454afc50f 7efd105c27fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:18:40 2019 -0700

    Merge tag 'mfd-next-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd
    
    Pull MFD updates from Lee Jones:
     "Core Frameworks:
       - Set 'struct device' fwnode when registering a new device
    
      New Drivers:
       - Add support for ROHM BD70528 PMIC
    
      New Device Support:
       - Add support for LP87561 4-Phase Regulator to TI LP87565 PMIC
       - Add support for RK809 and RK817 to Rockchip RK808
       - Add support for Lid Angle to ChromeOS core
       - Add support for CS47L15 CODEC to Madera core
       - Add support for CS47L92 CODEC to Madera core
       - Add support for ChromeOS (legacy) Accelerometers in ChromeOS core
       - Add support for Add Intel Elkhart Lake PCH to Intel LPSS
    
      New Functionality:
       - Provide regulator supply information when registering; madera-core
       - Additional Device Tree support; lp87565, madera, cros-ec, rohm,bd71837-pmic
       - Allow over-riding power button press via Device Tree; rohm-bd718x7
       - Differentiate between running processors; cros_ec_dev
    
      Fix-ups:
       - Big header file update; cros_ec_commands.h
       - Split header per-subsystem; rohm-bd718x7
       - Remove superfluous code; menelaus, cs5535-mfd, cs47lXX-tables
       - Trivial; sorting, coding style; intel-lpss-pci
       - Only remove Power Off functionality if set locally; rk808
       - Make use for Power Off Prepare(); rk808
       - Fix spelling mistake in header guards; stmfx
       - Properly free IDA resources
       - SPDX fixups; cs47lXX-tables, madera
       - Error path fixups; hi655x-pmic
    
      Bug Fixes:
       - Add missing break in case() statement
       - Repair undefined behaviour when not initialising variables; arizona-core, madera-core
       - Fix reference to Device Tree documentation; madera"
    
    * tag 'mfd-next-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd: (45 commits)
      mfd: hi655x-pmic: Fix missing return value check for devm_regmap_init_mmio_clk
      mfd: madera: Fixup SPDX headers
      mfd: madera: Remove some unused registers and fix some defaults
      mfd: intel-lpss: Release IDA resources
      mfd: intel-lpss: Add Intel Elkhart Lake PCH PCI IDs
      mfd: cs5535-mfd: Remove ifdef OLPC noise
      mfd: stmfx: Fix macro definition spelling
      dt-bindings: mfd: Add link to ROHM BD71847 Datasheet
      MAINAINERS: Swap words in INTEL PMIC MULTIFUNCTION DEVICE DRIVERS
      mfd: cros_ec_dev: Register cros_ec_accel_legacy driver as a subdevice
      mfd: rk808: Prepare rk805 for poweroff
      mfd: rk808: Check pm_power_off pointer
      mfd: cros_ec: differentiate SCP from EC by feature bit
      dt-bindings: Add binding for cros-ec-rpmsg
      mfd: madera: Add Madera core support for CS47L92
      mfd: madera: Add Madera core support for CS47L15
      mfd: madera: Update DT bindings to add additional CODECs
      mfd: madera: Add supply mapping for MICVDD
      mfd: madera: Fix potential uninitialised use of variable
      mfd: madera: Fix bad reference to pinctrl.txt file
      ...

commit 5da6cbcd2f395981aa9bfc571ace99f1c786c985
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 20 10:06:25 2019 +0100

    mfd: arizona: Fix undefined behavior
    
    When the driver is used with a subdevice that is disabled in the
    kernel configuration, clang gets a little confused about the
    control flow and fails to notice that n_subdevs is only
    uninitialized when subdevs is NULL, and we check for that,
    leading to a false-positive warning:
    
    drivers/mfd/arizona-core.c:1423:19: error: variable 'n_subdevs' is uninitialized when used here
          [-Werror,-Wuninitialized]
                                  subdevs, n_subdevs, NULL, 0, NULL);
                                           ^~~~~~~~~
    drivers/mfd/arizona-core.c:999:15: note: initialize the variable 'n_subdevs' to silence this warning
            int n_subdevs, ret, i;
                         ^
                          = 0
    
    Ideally, we would rearrange the code to avoid all those early
    initializations and have an explicit exit in each disabled case,
    but it's much easier to chicken out and add one more initialization
    here to shut up the warning.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 27b61639cdc7..0ca0fc9a67fd 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -996,7 +996,7 @@ int arizona_dev_init(struct arizona *arizona)
 	unsigned int reg, val;
 	int (*apply_patch)(struct arizona *) = NULL;
 	const struct mfd_cell *subdevs = NULL;
-	int n_subdevs, ret, i;
+	int n_subdevs = 0, ret, i;
 
 	dev_set_drvdata(arizona->dev, arizona);
 	mutex_init(&arizona->clk_lock);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 27b61639cdc7..2bdc7b02157a 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Arizona core driver
  *
  * Copyright 2012 Wolfson Microelectronics plc
  *
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/clk.h>

commit 8e27a5638ab5c1b5434a0c22bc43ec6c3f7f5b6b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Sep 4 15:15:53 2018 +0100

    mfd: arizona: Make array mclk_name static, shrinks object size
    
    Don't populate the array mclk_name on the stack but instead make it
    static. Makes the object code smaller by 23 bytes:
    
    Before:
       text    data     bss     dec     hex filename
      38050   11604      64   49718    c236 linux/drivers/mfd/arizona-core.o
    
    After:
       text    data     bss     dec     hex filename
      38027   11604      64   49695    c21f linux/drivers/mfd/arizona-core.o
    
    (gcc version 8.2.0 x86_64)
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 057906e3c16e..27b61639cdc7 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -990,7 +990,7 @@ static const struct mfd_cell wm8998_devs[] = {
 
 int arizona_dev_init(struct arizona *arizona)
 {
-	const char * const mclk_name[] = { "mclk1", "mclk2" };
+	static const char * const mclk_name[] = { "mclk1", "mclk2" };
 	struct device *dev = arizona->dev;
 	const char *type_name = NULL;
 	unsigned int reg, val;

commit 6b269a41a4520f7eb639e61a45ebbb9c9267d5e0
Author: Sapthagiri Baratam <sapthagiri.baratam@cirrus.com>
Date:   Tue Aug 21 19:52:44 2018 +0530

    mfd: arizona: Correct calling of runtime_put_sync
    
    Don't call runtime_put_sync when clk32k_ref is ARIZONA_32KZ_MCLK2
    as there is no corresponding runtime_get_sync call.
    
    MCLK1 is not in the AoD power domain so if it is used as 32kHz clock
    source we need to hold a runtime PM reference to keep the device from
    going into low power mode.
    
    Fixes: cdd8da8cc66b ("mfd: arizona: Add gating of external MCLKn clocks")
    Signed-off-by: Sapthagiri Baratam <sapthagiri.baratam@cirrus.com>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 5f1e37d23943..057906e3c16e 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -52,8 +52,10 @@ int arizona_clk32k_enable(struct arizona *arizona)
 			if (ret != 0)
 				goto err_ref;
 			ret = clk_prepare_enable(arizona->mclk[ARIZONA_MCLK1]);
-			if (ret != 0)
-				goto err_pm;
+			if (ret != 0) {
+				pm_runtime_put_sync(arizona->dev);
+				goto err_ref;
+			}
 			break;
 		case ARIZONA_32KZ_MCLK2:
 			ret = clk_prepare_enable(arizona->mclk[ARIZONA_MCLK2]);
@@ -67,8 +69,6 @@ int arizona_clk32k_enable(struct arizona *arizona)
 					 ARIZONA_CLK_32K_ENA);
 	}
 
-err_pm:
-	pm_runtime_put_sync(arizona->dev);
 err_ref:
 	if (ret != 0)
 		arizona->clk32k_ref--;

commit f99fea949736b6a79cddaaaec7e3b8830fd81c93
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Thu Jun 28 16:49:35 2018 +0100

    mfd: arizona: Don't use regmap_read_poll_timeout
    
    Some Arizona CODECs have a small timing window where they will
    NAK an I2C transaction if it happens before the boot done bit is
    set. This can cause the read of the register containing the boot
    done bit to fail until it is set. Since regmap_read_poll_timeout
    will abort polling if a read fails it can't be reliably used to
    poll the boot done bit over I2C.
    
    Do a partial revert of ef84f885e037 ("mfd: arizona: Refactor
    arizona_poll_reg"), removing the regmap_read_poll_timeout but
    leaving the refactoring to make the arizona_poll_reg take more
    sensible arguments.
    
    Fixes: ef84f885e037 ("mfd: arizona: Refactor arizona_poll_reg")
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 83f1c5a516d9..5f1e37d23943 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -24,6 +24,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/machine.h>
 #include <linux/slab.h>
+#include <linux/ktime.h>
 #include <linux/platform_device.h>
 
 #include <linux/mfd/arizona/core.h>
@@ -236,22 +237,39 @@ static irqreturn_t arizona_overclocked(int irq, void *data)
 
 #define ARIZONA_REG_POLL_DELAY_US 7500
 
+static inline bool arizona_poll_reg_delay(ktime_t timeout)
+{
+	if (ktime_compare(ktime_get(), timeout) > 0)
+		return false;
+
+	usleep_range(ARIZONA_REG_POLL_DELAY_US / 2, ARIZONA_REG_POLL_DELAY_US);
+
+	return true;
+}
+
 static int arizona_poll_reg(struct arizona *arizona,
 			    int timeout_ms, unsigned int reg,
 			    unsigned int mask, unsigned int target)
 {
+	ktime_t timeout = ktime_add_us(ktime_get(), timeout_ms * USEC_PER_MSEC);
 	unsigned int val = 0;
 	int ret;
 
-	ret = regmap_read_poll_timeout(arizona->regmap,
-				       reg, val, ((val & mask) == target),
-				       ARIZONA_REG_POLL_DELAY_US,
-				       timeout_ms * 1000);
-	if (ret)
-		dev_err(arizona->dev, "Polling reg 0x%x timed out: %x\n",
-			reg, val);
+	do {
+		ret = regmap_read(arizona->regmap, reg, &val);
 
-	return ret;
+		if ((val & mask) == target)
+			return 0;
+	} while (arizona_poll_reg_delay(timeout));
+
+	if (ret) {
+		dev_err(arizona->dev, "Failed polling reg 0x%x: %d\n",
+			reg, ret);
+		return ret;
+	}
+
+	dev_err(arizona->dev, "Polling reg 0x%x timed out: %x\n", reg, val);
+	return -ETIMEDOUT;
 }
 
 static int arizona_wait_for_boot(struct arizona *arizona)

commit c18604660ad02324dfc21de5dfd0c8d15e9070a5
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Mon Mar 12 15:52:00 2018 +0000

    mfd: arizona: Update reset pin to use GPIOD
    
    Now GPIOD has support for both pdata systems and for non-standard DT
    bindings the Arizona reset GPIO can be converted to use it. Worth
    noting gpiod_set_raw_value_cansleep is used to match the behaviour
    of the old GPIOs. This is because the part is fairly widely used and
    it is unknown how many DTs are correctly setting active low through
    device tree, so to avoid breaking any existing users it is best to
    match the previous behaviour.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 77875250abe5..83f1c5a516d9 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -13,13 +13,12 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/err.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/interrupt.h>
 #include <linux/mfd/core.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
-#include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
@@ -279,7 +278,7 @@ static int arizona_wait_for_boot(struct arizona *arizona)
 static inline void arizona_enable_reset(struct arizona *arizona)
 {
 	if (arizona->pdata.reset)
-		gpio_set_value_cansleep(arizona->pdata.reset, 0);
+		gpiod_set_raw_value_cansleep(arizona->pdata.reset, 0);
 }
 
 static void arizona_disable_reset(struct arizona *arizona)
@@ -295,7 +294,7 @@ static void arizona_disable_reset(struct arizona *arizona)
 			break;
 		}
 
-		gpio_set_value_cansleep(arizona->pdata.reset, 1);
+		gpiod_set_raw_value_cansleep(arizona->pdata.reset, 1);
 		usleep_range(1000, 5000);
 	}
 }
@@ -799,14 +798,27 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 	struct arizona_pdata *pdata = &arizona->pdata;
 	int ret, i;
 
-	pdata->reset = of_get_named_gpio(arizona->dev->of_node, "wlf,reset", 0);
-	if (pdata->reset == -EPROBE_DEFER) {
-		return pdata->reset;
-	} else if (pdata->reset < 0) {
-		dev_err(arizona->dev, "Reset GPIO missing/malformed: %d\n",
-			pdata->reset);
+	/* Handle old non-standard DT binding */
+	pdata->reset = devm_gpiod_get_from_of_node(arizona->dev,
+						   arizona->dev->of_node,
+						   "wlf,reset", 0,
+						   GPIOD_OUT_LOW,
+						   "arizona /RESET");
+	if (IS_ERR(pdata->reset)) {
+		ret = PTR_ERR(pdata->reset);
 
-		pdata->reset = 0;
+		/*
+		 * Reset missing will be caught when other binding is read
+		 * but all other errors imply this binding is in use but has
+		 * encountered a problem so should be handled.
+		 */
+		if (ret == -EPROBE_DEFER)
+			return ret;
+		else if (ret != -ENOENT && ret != -ENOSYS)
+			dev_err(arizona->dev, "Reset GPIO malformed: %d\n",
+				ret);
+
+		pdata->reset = NULL;
 	}
 
 	ret = of_property_read_u32_array(arizona->dev->of_node,
@@ -1050,14 +1062,19 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_early;
 	}
 
-	if (arizona->pdata.reset) {
+	if (!arizona->pdata.reset) {
 		/* Start out with /RESET low to put the chip into reset */
-		ret = devm_gpio_request_one(arizona->dev, arizona->pdata.reset,
-					    GPIOF_DIR_OUT | GPIOF_INIT_LOW,
-					    "arizona /RESET");
-		if (ret != 0) {
-			dev_err(dev, "Failed to request /RESET: %d\n", ret);
-			goto err_dcvdd;
+		arizona->pdata.reset = devm_gpiod_get(arizona->dev, "reset",
+						      GPIOD_OUT_LOW);
+		if (IS_ERR(arizona->pdata.reset)) {
+			ret = PTR_ERR(arizona->pdata.reset);
+			if (ret == -EPROBE_DEFER)
+				goto err_dcvdd;
+
+			dev_err(arizona->dev,
+				"Reset GPIO missing/malformed: %d\n", ret);
+
+			arizona->pdata.reset = NULL;
 		}
 	}
 

commit 6000c99ee6e9876cb33275c752937d99f77cdb95
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Mon Sep 4 16:41:51 2017 +0100

    mfd: arizona: Remove audio related device tree code
    
    This code has now been moved to the audio subsystem so is no longer
    required in the MFD code.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 8d46e3ad9529..77875250abe5 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -797,12 +797,7 @@ EXPORT_SYMBOL_GPL(arizona_of_get_type);
 static int arizona_of_get_core_pdata(struct arizona *arizona)
 {
 	struct arizona_pdata *pdata = &arizona->pdata;
-	struct property *prop;
-	const __be32 *cur;
-	u32 val;
-	u32 pdm_val[ARIZONA_MAX_PDM_SPK];
 	int ret, i;
-	int count = 0;
 
 	pdata->reset = of_get_named_gpio(arizona->dev->of_node, "wlf,reset", 0);
 	if (pdata->reset == -EPROBE_DEFER) {
@@ -836,64 +831,6 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 			ret);
 	}
 
-	of_property_for_each_u32(arizona->dev->of_node, "wlf,inmode", prop,
-				 cur, val) {
-		if (count == ARRAY_SIZE(pdata->inmode))
-			break;
-
-		pdata->inmode[count] = val;
-		count++;
-	}
-
-	count = 0;
-	of_property_for_each_u32(arizona->dev->of_node, "wlf,dmic-ref", prop,
-				 cur, val) {
-		if (count == ARRAY_SIZE(pdata->dmic_ref))
-			break;
-
-		pdata->dmic_ref[count] = val;
-		count++;
-	}
-
-	count = 0;
-	of_property_for_each_u32(arizona->dev->of_node, "wlf,out-mono", prop,
-				 cur, val) {
-		if (count == ARRAY_SIZE(pdata->out_mono))
-			break;
-
-		pdata->out_mono[count] = !!val;
-		count++;
-	}
-
-	count = 0;
-	of_property_for_each_u32(arizona->dev->of_node,
-				 "wlf,max-channels-clocked",
-				 prop, cur, val) {
-		if (count == ARRAY_SIZE(pdata->max_channels_clocked))
-			break;
-
-		pdata->max_channels_clocked[count] = val;
-		count++;
-	}
-
-	ret = of_property_read_u32_array(arizona->dev->of_node,
-					 "wlf,spk-fmt",
-					 pdm_val,
-					 ARRAY_SIZE(pdm_val));
-
-	if (ret >= 0)
-		for (count = 0; count < ARRAY_SIZE(pdata->spk_fmt); ++count)
-			pdata->spk_fmt[count] = pdm_val[count];
-
-	ret = of_property_read_u32_array(arizona->dev->of_node,
-					 "wlf,spk-mute",
-					 pdm_val,
-					 ARRAY_SIZE(pdm_val));
-
-	if (ret >= 0)
-		for (count = 0; count < ARRAY_SIZE(pdata->spk_mute); ++count)
-			pdata->spk_mute[count] = pdm_val[count];
-
 	return 0;
 }
 
@@ -1026,7 +963,7 @@ int arizona_dev_init(struct arizona *arizona)
 	const char * const mclk_name[] = { "mclk1", "mclk2" };
 	struct device *dev = arizona->dev;
 	const char *type_name = NULL;
-	unsigned int reg, val, mask;
+	unsigned int reg, val;
 	int (*apply_patch)(struct arizona *) = NULL;
 	const struct mfd_cell *subdevs = NULL;
 	int n_subdevs, ret, i;
@@ -1429,73 +1366,6 @@ int arizona_dev_init(struct arizona *arizona)
 				   ARIZONA_MICB1_RATE, val);
 	}
 
-	for (i = 0; i < ARIZONA_MAX_INPUT; i++) {
-		/* Default for both is 0 so noop with defaults */
-		val = arizona->pdata.dmic_ref[i]
-			<< ARIZONA_IN1_DMIC_SUP_SHIFT;
-		if (arizona->pdata.inmode[i] & ARIZONA_INMODE_DMIC)
-			val |= 1 << ARIZONA_IN1_MODE_SHIFT;
-
-		switch (arizona->type) {
-		case WM8998:
-		case WM1814:
-			regmap_update_bits(arizona->regmap,
-				ARIZONA_ADC_DIGITAL_VOLUME_1L + (i * 8),
-				ARIZONA_IN1L_SRC_SE_MASK,
-				(arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
-					<< ARIZONA_IN1L_SRC_SE_SHIFT);
-
-			regmap_update_bits(arizona->regmap,
-				ARIZONA_ADC_DIGITAL_VOLUME_1R + (i * 8),
-				ARIZONA_IN1R_SRC_SE_MASK,
-				(arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
-					<< ARIZONA_IN1R_SRC_SE_SHIFT);
-
-			mask = ARIZONA_IN1_DMIC_SUP_MASK |
-				ARIZONA_IN1_MODE_MASK;
-			break;
-		default:
-			if (arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
-				val |= 1 << ARIZONA_IN1_SINGLE_ENDED_SHIFT;
-
-			mask = ARIZONA_IN1_DMIC_SUP_MASK |
-				ARIZONA_IN1_MODE_MASK |
-				ARIZONA_IN1_SINGLE_ENDED_MASK;
-			break;
-		}
-
-		regmap_update_bits(arizona->regmap,
-				   ARIZONA_IN1L_CONTROL + (i * 8),
-				   mask, val);
-	}
-
-	for (i = 0; i < ARIZONA_MAX_OUTPUT; i++) {
-		/* Default is 0 so noop with defaults */
-		if (arizona->pdata.out_mono[i])
-			val = ARIZONA_OUT1_MONO;
-		else
-			val = 0;
-
-		regmap_update_bits(arizona->regmap,
-				   ARIZONA_OUTPUT_PATH_CONFIG_1L + (i * 8),
-				   ARIZONA_OUT1_MONO, val);
-	}
-
-	for (i = 0; i < ARIZONA_MAX_PDM_SPK; i++) {
-		if (arizona->pdata.spk_mute[i])
-			regmap_update_bits(arizona->regmap,
-					   ARIZONA_PDM_SPK1_CTRL_1 + (i * 2),
-					   ARIZONA_SPK1_MUTE_ENDIAN_MASK |
-					   ARIZONA_SPK1_MUTE_SEQ1_MASK,
-					   arizona->pdata.spk_mute[i]);
-
-		if (arizona->pdata.spk_fmt[i])
-			regmap_update_bits(arizona->regmap,
-					   ARIZONA_PDM_SPK1_CTRL_2 + (i * 2),
-					   ARIZONA_SPK1_FMT_MASK,
-					   arizona->pdata.spk_fmt[i]);
-	}
-
 	pm_runtime_set_active(arizona->dev);
 	pm_runtime_enable(arizona->dev);
 

commit 27fef9f8ecb0495d302deba210606a32e54db37a
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Jun 6 09:46:33 2017 +0100

    mfd: arizona: Fix typo using hard-coded register
    
    A hardcoded register is accidentally used instead of the register
    address passed into the function. Correct this and use the appropriate
    variable. This would cause minor issues on wm5102, but all other
    devices using this driver would have been unaffected.
    
    Fixes: commit ef84f885e037 ("mfd: arizona: Refactor arizona_poll_reg")
    Reported-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 75488e65cd96..8d46e3ad9529 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -245,8 +245,7 @@ static int arizona_poll_reg(struct arizona *arizona,
 	int ret;
 
 	ret = regmap_read_poll_timeout(arizona->regmap,
-				       ARIZONA_INTERRUPT_RAW_STATUS_5, val,
-				       ((val & mask) == target),
+				       reg, val, ((val & mask) == target),
 				       ARIZONA_REG_POLL_DELAY_US,
 				       timeout_ms * 1000);
 	if (ret)

commit ef84f885e03763c963dbb5d36389d33ce50576f2
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Mar 15 14:58:38 2017 +0000

    mfd: arizona: Refactor arizona_poll_reg
    
    Currently, we specify the timeout in terms of the number of polls but it
    is more clear from a user of the functions perspective to specify the
    timeout directly in milliseconds, as such update the function to these new
    semantics.
    
    Additionally, arizona_poll_reg essentially hard-codes
    regmap_read_poll_timeout, update the implementation to use
    regmap_read_poll_timeout. We still keep arizona_poll_reg around as
    regmap_read_poll_timeout is a macro so rather than expand this for each
    caller keep it wrapped in arizona_poll_reg.
    
    Whilst we are doing this make the timeouts a little more generous as
    the previous system had a bit more slack as it was done as a delay per
    iteration of the loop whereas regmap_read_poll_timeout compares ktime's.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4cb34c36a0e5..75488e65cd96 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -235,29 +235,25 @@ static irqreturn_t arizona_overclocked(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+#define ARIZONA_REG_POLL_DELAY_US 7500
+
 static int arizona_poll_reg(struct arizona *arizona,
-			    int timeout, unsigned int reg,
+			    int timeout_ms, unsigned int reg,
 			    unsigned int mask, unsigned int target)
 {
 	unsigned int val = 0;
-	int ret, i;
-
-	for (i = 0; i < timeout; i++) {
-		ret = regmap_read(arizona->regmap, reg, &val);
-		if (ret != 0) {
-			dev_err(arizona->dev, "Failed to read reg 0x%x: %d\n",
-				reg, ret);
-			continue;
-		}
-
-		if ((val & mask) == target)
-			return 0;
+	int ret;
 
-		usleep_range(1000, 5000);
-	}
+	ret = regmap_read_poll_timeout(arizona->regmap,
+				       ARIZONA_INTERRUPT_RAW_STATUS_5, val,
+				       ((val & mask) == target),
+				       ARIZONA_REG_POLL_DELAY_US,
+				       timeout_ms * 1000);
+	if (ret)
+		dev_err(arizona->dev, "Polling reg 0x%x timed out: %x\n",
+			reg, val);
 
-	dev_err(arizona->dev, "Polling reg 0x%x timed out: %x\n", reg, val);
-	return -ETIMEDOUT;
+	return ret;
 }
 
 static int arizona_wait_for_boot(struct arizona *arizona)
@@ -269,7 +265,7 @@ static int arizona_wait_for_boot(struct arizona *arizona)
 	 * we won't race with the interrupt handler as it'll be blocked on
 	 * runtime resume.
 	 */
-	ret = arizona_poll_reg(arizona, 5, ARIZONA_INTERRUPT_RAW_STATUS_5,
+	ret = arizona_poll_reg(arizona, 30, ARIZONA_INTERRUPT_RAW_STATUS_5,
 			       ARIZONA_BOOT_DONE_STS, ARIZONA_BOOT_DONE_STS);
 
 	if (!ret)
@@ -339,7 +335,7 @@ static int arizona_enable_freerun_sysclk(struct arizona *arizona,
 			ret);
 		return ret;
 	}
-	ret = arizona_poll_reg(arizona, 25, ARIZONA_INTERRUPT_RAW_STATUS_5,
+	ret = arizona_poll_reg(arizona, 180, ARIZONA_INTERRUPT_RAW_STATUS_5,
 			       ARIZONA_FLL1_CLOCK_OK_STS,
 			       ARIZONA_FLL1_CLOCK_OK_STS);
 	if (ret)
@@ -403,7 +399,7 @@ static int wm5102_apply_hardware_patch(struct arizona *arizona)
 		goto err;
 	}
 
-	ret = arizona_poll_reg(arizona, 5, ARIZONA_WRITE_SEQUENCER_CTRL_1,
+	ret = arizona_poll_reg(arizona, 30, ARIZONA_WRITE_SEQUENCER_CTRL_1,
 			       ARIZONA_WSEQ_BUSY, 0);
 	if (ret)
 		regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,

commit f9657b8f75473ce0488c750677bfef46751dd5e1
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Mar 15 14:58:37 2017 +0000

    mfd: arizona: Display register addresses in hex
    
    Register addresses are normally displayed in hex throughout the Arizona
    driver. Update the arizona_poll_reg function to follow this convention.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e00f577db830..4cb34c36a0e5 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -245,7 +245,7 @@ static int arizona_poll_reg(struct arizona *arizona,
 	for (i = 0; i < timeout; i++) {
 		ret = regmap_read(arizona->regmap, reg, &val);
 		if (ret != 0) {
-			dev_err(arizona->dev, "Failed to read reg %u: %d\n",
+			dev_err(arizona->dev, "Failed to read reg 0x%x: %d\n",
 				reg, ret);
 			continue;
 		}
@@ -256,7 +256,7 @@ static int arizona_poll_reg(struct arizona *arizona,
 		usleep_range(1000, 5000);
 	}
 
-	dev_err(arizona->dev, "Polling reg %u timed out: %x\n", reg, val);
+	dev_err(arizona->dev, "Polling reg 0x%x timed out: %x\n", reg, val);
 	return -ETIMEDOUT;
 }
 

commit de4ea10ad7bd86445875bab25596016544f827ca
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Mar 15 14:58:36 2017 +0000

    mfd: arizona: Remove duplicate set of ret variable
    
    arizona_poll_reg already returns ETIMEDOUT if we don't see the expected
    register changes before the time out, so remove pointless local setting of
    ETIMEDOUT.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b6d4bc63c426..e00f577db830 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -342,10 +342,8 @@ static int arizona_enable_freerun_sysclk(struct arizona *arizona,
 	ret = arizona_poll_reg(arizona, 25, ARIZONA_INTERRUPT_RAW_STATUS_5,
 			       ARIZONA_FLL1_CLOCK_OK_STS,
 			       ARIZONA_FLL1_CLOCK_OK_STS);
-	if (ret) {
-		ret = -ETIMEDOUT;
+	if (ret)
 		goto err_fll;
-	}
 
 	ret = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, 0x0144);
 	if (ret) {
@@ -407,11 +405,9 @@ static int wm5102_apply_hardware_patch(struct arizona *arizona)
 
 	ret = arizona_poll_reg(arizona, 5, ARIZONA_WRITE_SEQUENCER_CTRL_1,
 			       ARIZONA_WSEQ_BUSY, 0);
-	if (ret) {
+	if (ret)
 		regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,
 			     ARIZONA_WSEQ_ABORT);
-		ret = -ETIMEDOUT;
-	}
 
 err:
 	err = arizona_disable_freerun_sysclk(arizona, &state);

commit fb36f77efec7c4371a8be0c73424fa2bf841e3b2
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Nov 14 17:15:56 2016 +0000

    mfd: arizona: Disable IRQs during driver remove
    
    As DCVDD will often be supplied by a child node of the MFD, we
    can't call mfd_remove_devices as the first step in arizona_dev_exit
    as might be expected (tidy up the children before we tidy up the
    MFD). We need to disable and put the DCVDD regulator before we call
    mfd_remove_devices, to prevent PM runtime from turning this back on we
    also need to disable the PM runtime before we do this. Finally we can
    not clean up the IRQs until all the MFD children have been removed, as
    they may have registered IRQs themselves.
    
    This creates a window of time where the interrupts are enabled but
    the PM runtime, on which the IRQ handler depends, is not available,
    any interrupts in this window will go unhandled and fill the log with
    failed to resume device messages. To avoid this we simply disable the
    main IRQ at the start of arizona_dev_exit, we don't need to actually
    handle any IRQs in this window as we are removing the driver.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 41767f7239bb..b6d4bc63c426 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1553,6 +1553,7 @@ EXPORT_SYMBOL_GPL(arizona_dev_init);
 
 int arizona_dev_exit(struct arizona *arizona)
 {
+	disable_irq(arizona->irq);
 	pm_runtime_disable(arizona->dev);
 
 	regulator_disable(arizona->dcvdd);

commit b8d336ed90f541097a2ce583be430bb3e895dfbd
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Sep 20 16:30:14 2016 +0100

    mfd: arizona: Handle probe deferral for reset GPIO
    
    The Arizona CODECs will generally function correctly without a reset line
    although it is strongly advised to have one, as such we do allow the system
    to boot if the reset gpio is missing or incorrectly specified.  However
    we should fail probe if we get a probe deferral request, this patch adds
    handling for this case.
    
    Reported-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index dcee48fc2e06..41767f7239bb 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -814,7 +814,9 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 	int count = 0;
 
 	pdata->reset = of_get_named_gpio(arizona->dev->of_node, "wlf,reset", 0);
-	if (pdata->reset < 0) {
+	if (pdata->reset == -EPROBE_DEFER) {
+		return pdata->reset;
+	} else if (pdata->reset < 0) {
 		dev_err(arizona->dev, "Reset GPIO missing/malformed: %d\n",
 			pdata->reset);
 
@@ -1041,11 +1043,14 @@ int arizona_dev_init(struct arizona *arizona)
 	dev_set_drvdata(arizona->dev, arizona);
 	mutex_init(&arizona->clk_lock);
 
-	if (dev_get_platdata(arizona->dev))
+	if (dev_get_platdata(arizona->dev)) {
 		memcpy(&arizona->pdata, dev_get_platdata(arizona->dev),
 		       sizeof(arizona->pdata));
-	else
-		arizona_of_get_core_pdata(arizona);
+	} else {
+		ret = arizona_of_get_core_pdata(arizona);
+		if (ret < 0)
+			return ret;
+	}
 
 	BUILD_BUG_ON(ARRAY_SIZE(arizona->mclk) != ARRAY_SIZE(mclk_name));
 	for (i = 0; i < ARRAY_SIZE(arizona->mclk); i++) {

commit 1961531d1a0a011c77bfaafc8412e84a919d1747
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Sep 20 16:30:13 2016 +0100

    mfd: arizona: Remove arizona_of_get_named_gpio helper function
    
    This function is only used in a single place and no new users will be
    added as all the devices other required GPIOs are already handled. As
    such just merge the code back into the calling function.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 672924d5ec9d..dcee48fc2e06 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -803,25 +803,6 @@ unsigned long arizona_of_get_type(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(arizona_of_get_type);
 
-int arizona_of_get_named_gpio(struct arizona *arizona, const char *prop,
-			      bool mandatory)
-{
-	int gpio;
-
-	gpio = of_get_named_gpio(arizona->dev->of_node, prop, 0);
-	if (gpio < 0) {
-		if (mandatory)
-			dev_err(arizona->dev,
-				"Mandatory DT gpio %s missing/malformed: %d\n",
-				prop, gpio);
-
-		gpio = 0;
-	}
-
-	return gpio;
-}
-EXPORT_SYMBOL_GPL(arizona_of_get_named_gpio);
-
 static int arizona_of_get_core_pdata(struct arizona *arizona)
 {
 	struct arizona_pdata *pdata = &arizona->pdata;
@@ -832,7 +813,13 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 	int ret, i;
 	int count = 0;
 
-	pdata->reset = arizona_of_get_named_gpio(arizona, "wlf,reset", true);
+	pdata->reset = of_get_named_gpio(arizona->dev->of_node, "wlf,reset", 0);
+	if (pdata->reset < 0) {
+		dev_err(arizona->dev, "Reset GPIO missing/malformed: %d\n",
+			pdata->reset);
+
+		pdata->reset = 0;
+	}
 
 	ret = of_property_read_u32_array(arizona->dev->of_node,
 					 "wlf,gpio-defaults",

commit f4c052622567f9ff4f226f0f33d792c5ed01ec7f
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Tue Sep 13 10:05:44 2016 +0100

    mfd: arizona: Add DT options for max_channels_clocked and PDM speaker config
    
    This patch adds DT settings for the max_channels_clocked, spk_fmt and
    spk_mute pdata.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4c18c8ef05d9..672924d5ec9d 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -828,6 +828,7 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 	struct property *prop;
 	const __be32 *cur;
 	u32 val;
+	u32 pdm_val[ARIZONA_MAX_PDM_SPK];
 	int ret, i;
 	int count = 0;
 
@@ -884,6 +885,35 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 		count++;
 	}
 
+	count = 0;
+	of_property_for_each_u32(arizona->dev->of_node,
+				 "wlf,max-channels-clocked",
+				 prop, cur, val) {
+		if (count == ARRAY_SIZE(pdata->max_channels_clocked))
+			break;
+
+		pdata->max_channels_clocked[count] = val;
+		count++;
+	}
+
+	ret = of_property_read_u32_array(arizona->dev->of_node,
+					 "wlf,spk-fmt",
+					 pdm_val,
+					 ARRAY_SIZE(pdm_val));
+
+	if (ret >= 0)
+		for (count = 0; count < ARRAY_SIZE(pdata->spk_fmt); ++count)
+			pdata->spk_fmt[count] = pdm_val[count];
+
+	ret = of_property_read_u32_array(arizona->dev->of_node,
+					 "wlf,spk-mute",
+					 pdm_val,
+					 ARRAY_SIZE(pdm_val));
+
+	if (ret >= 0)
+		for (count = 0; count < ARRAY_SIZE(pdata->spk_mute); ++count)
+			pdata->spk_mute[count] = pdm_val[count];
+
 	return 0;
 }
 

commit 3612b27cfb4a074c83cc74b928517aca2d872861
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Aug 30 10:33:10 2016 +0100

    mfd: arizona: Use suspend_noirq inplace of suspend_late
    
    As runtime PM doesn't function whilst processing system suspend/resume
    operations and the Arizona IRQ handlers need runtime PM to function
    we must disable IRQs during these operations. Whilst this is
    already done in the driver we are using suspend/suspend_late and
    resume/resume_noirq to do so which has two problems. Firstly, as
    suspend_late is before suspend_noirq that means we still have a
    small window where an IRQ can cause issues.  Secondly, if another
    suspend_late handler fails after ours has run then (as resume_noirq
    will not run) we will make unbalanced calls to enable_irq.
    
    This is all simply fixed by using the suspend_noirq callback rather
    than suspend_late. Whilst we are doing this tidy the code up a little,
    and use the appropriate helper macros.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index fcec650ca088..4c18c8ef05d9 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -750,7 +750,7 @@ static int arizona_suspend(struct device *dev)
 	return 0;
 }
 
-static int arizona_suspend_late(struct device *dev)
+static int arizona_suspend_noirq(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
 
@@ -774,7 +774,7 @@ static int arizona_resume(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
 
-	dev_dbg(arizona->dev, "Late resume, reenabling IRQ\n");
+	dev_dbg(arizona->dev, "Resume, reenabling IRQ\n");
 	enable_irq(arizona->irq);
 
 	return 0;
@@ -786,10 +786,8 @@ const struct dev_pm_ops arizona_pm_ops = {
 			   arizona_runtime_resume,
 			   NULL)
 	SET_SYSTEM_SLEEP_PM_OPS(arizona_suspend, arizona_resume)
-#ifdef CONFIG_PM_SLEEP
-	.suspend_late = arizona_suspend_late,
-	.resume_noirq = arizona_resume_noirq,
-#endif
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(arizona_suspend_noirq,
+				      arizona_resume_noirq)
 };
 EXPORT_SYMBOL_GPL(arizona_pm_ops);
 

commit 75d8a2b041f24ee5cb8b701c2cc62826b65dfb8c
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Aug 31 10:41:30 2016 +0100

    mfd: arizona: Add sensible return value to some error paths
    
    There are some cases in arizona_dev_init, such as where we don't
    recognise the chip ID, in which we head to the error path without
    setting a sensible error code in ret. This would lead to the chip
    silently failing probe, as it would still return 0. Fix this up by
    adding appropriate sets of the return value.
    
    Whilst adding these update the existing paths that do return an error
    when the chip is not recognised to use ENODEV, which seems like a better
    fit.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4fa0fae51006..fcec650ca088 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1061,7 +1061,7 @@ int arizona_dev_init(struct arizona *arizona)
 	default:
 		dev_err(arizona->dev, "Unknown device type %d\n",
 			arizona->type);
-		return -EINVAL;
+		return -ENODEV;
 	}
 
 	/* Mark DCVDD as external, LDO1 driver will clear if internal */
@@ -1147,6 +1147,7 @@ int arizona_dev_init(struct arizona *arizona)
 		break;
 	default:
 		dev_err(arizona->dev, "Unknown device ID: %x\n", reg);
+		ret = -ENODEV;
 		goto err_reset;
 	}
 
@@ -1306,12 +1307,14 @@ int arizona_dev_init(struct arizona *arizona)
 		break;
 	default:
 		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
+		ret = -ENODEV;
 		goto err_reset;
 	}
 
 	if (!subdevs) {
 		dev_err(arizona->dev,
 			"No kernel support for device ID %x\n", reg);
+		ret = -ENODEV;
 		goto err_reset;
 	}
 

commit cdd8da8cc66b3d205120560649e530978ccbc567
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri Sep 2 16:52:46 2016 +0100

    mfd: arizona: Add gating of external MCLKn clocks
    
    This patch adds requesting of the clocks supplied on MCLK1, MCLK2 pins,
    gating of the 32k clock is added to the arizona_clk32k_enable(),
    arizona_clk32k_disable() helpers.
    
    It's a temporary change until the CODEC's clock controller gets exposed
    through the clk API and is helpful for board configurations where the
    MCLK clocks are not provided by always on oscillators.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e4f97b3c824b..4fa0fae51006 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -10,6 +10,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/gpio.h>
@@ -49,7 +50,15 @@ int arizona_clk32k_enable(struct arizona *arizona)
 		case ARIZONA_32KZ_MCLK1:
 			ret = pm_runtime_get_sync(arizona->dev);
 			if (ret != 0)
-				goto out;
+				goto err_ref;
+			ret = clk_prepare_enable(arizona->mclk[ARIZONA_MCLK1]);
+			if (ret != 0)
+				goto err_pm;
+			break;
+		case ARIZONA_32KZ_MCLK2:
+			ret = clk_prepare_enable(arizona->mclk[ARIZONA_MCLK2]);
+			if (ret != 0)
+				goto err_ref;
 			break;
 		}
 
@@ -58,7 +67,9 @@ int arizona_clk32k_enable(struct arizona *arizona)
 					 ARIZONA_CLK_32K_ENA);
 	}
 
-out:
+err_pm:
+	pm_runtime_put_sync(arizona->dev);
+err_ref:
 	if (ret != 0)
 		arizona->clk32k_ref--;
 
@@ -83,6 +94,10 @@ int arizona_clk32k_disable(struct arizona *arizona)
 		switch (arizona->pdata.clk32k_src) {
 		case ARIZONA_32KZ_MCLK1:
 			pm_runtime_put_sync(arizona->dev);
+			clk_disable_unprepare(arizona->mclk[ARIZONA_MCLK1]);
+			break;
+		case ARIZONA_32KZ_MCLK2:
+			clk_disable_unprepare(arizona->mclk[ARIZONA_MCLK2]);
 			break;
 		}
 	}
@@ -1000,6 +1015,7 @@ static const struct mfd_cell wm8998_devs[] = {
 
 int arizona_dev_init(struct arizona *arizona)
 {
+	const char * const mclk_name[] = { "mclk1", "mclk2" };
 	struct device *dev = arizona->dev;
 	const char *type_name = NULL;
 	unsigned int reg, val, mask;
@@ -1016,6 +1032,16 @@ int arizona_dev_init(struct arizona *arizona)
 	else
 		arizona_of_get_core_pdata(arizona);
 
+	BUILD_BUG_ON(ARRAY_SIZE(arizona->mclk) != ARRAY_SIZE(mclk_name));
+	for (i = 0; i < ARRAY_SIZE(arizona->mclk); i++) {
+		arizona->mclk[i] = devm_clk_get(arizona->dev, mclk_name[i]);
+		if (IS_ERR(arizona->mclk[i])) {
+			dev_info(arizona->dev, "Failed to get %s: %ld\n",
+				 mclk_name[i], PTR_ERR(arizona->mclk[i]));
+			arizona->mclk[i] = NULL;
+		}
+	}
+
 	regcache_cache_only(arizona->regmap, true);
 
 	switch (arizona->type) {

commit d347792c315171fd89dda9d6cbebea756c29b3ea
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Jun 27 15:19:11 2016 +0100

    mfd: arizona: Add missing disable of PM runtime on probe error path
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index bf2717967597..e4f97b3c824b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1462,7 +1462,7 @@ int arizona_dev_init(struct arizona *arizona)
 	/* Set up for interrupts */
 	ret = arizona_irq_init(arizona);
 	if (ret != 0)
-		goto err_reset;
+		goto err_pm;
 
 	pm_runtime_set_autosuspend_delay(arizona->dev, 100);
 	pm_runtime_use_autosuspend(arizona->dev);
@@ -1486,6 +1486,8 @@ int arizona_dev_init(struct arizona *arizona)
 
 err_irq:
 	arizona_irq_exit(arizona);
+err_pm:
+	pm_runtime_disable(arizona->dev);
 err_reset:
 	arizona_enable_reset(arizona);
 	regulator_disable(arizona->dcvdd);

commit f83c218c1705a0d38fb9791bdee268c4092a37cb
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Fri Apr 15 13:18:47 2016 +0100

    mfd: arizona: Update device ordering to allow clean driver removal
    
    Since this commit:
    
    commit b9a8a271c38f ("mfd: make mfd_remove_devices() iterate in reverse
    order")
    
    The order in which the MFD children remove has been reversed, as our
    driver contains some dependencies between the devices we need to make
    some changes to ensure the driver unloads cleanly.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 5319f252790b..bf2717967597 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -908,12 +908,12 @@ static const char * const wm5102_supplies[] = {
 
 static const struct mfd_cell wm5102_devs[] = {
 	{ .name = "arizona-micsupp" },
+	{ .name = "arizona-gpio" },
 	{
 		.name = "arizona-extcon",
 		.parent_supplies = wm5102_supplies,
 		.num_parent_supplies = 1, /* We only need MICVDD */
 	},
-	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
 	{
@@ -925,12 +925,12 @@ static const struct mfd_cell wm5102_devs[] = {
 
 static const struct mfd_cell wm5110_devs[] = {
 	{ .name = "arizona-micsupp" },
+	{ .name = "arizona-gpio" },
 	{
 		.name = "arizona-extcon",
 		.parent_supplies = wm5102_supplies,
 		.num_parent_supplies = 1, /* We only need MICVDD */
 	},
-	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
 	{
@@ -966,12 +966,12 @@ static const char * const wm8997_supplies[] = {
 
 static const struct mfd_cell wm8997_devs[] = {
 	{ .name = "arizona-micsupp" },
+	{ .name = "arizona-gpio" },
 	{
 		.name = "arizona-extcon",
 		.parent_supplies = wm8997_supplies,
 		.num_parent_supplies = 1, /* We only need MICVDD */
 	},
-	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
 	{
@@ -982,12 +982,13 @@ static const struct mfd_cell wm8997_devs[] = {
 };
 
 static const struct mfd_cell wm8998_devs[] = {
+	{ .name = "arizona-micsupp" },
+	{ .name = "arizona-gpio" },
 	{
 		.name = "arizona-extcon",
 		.parent_supplies = wm5102_supplies,
 		.num_parent_supplies = 1, /* We only need MICVDD */
 	},
-	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
 	{
@@ -995,7 +996,6 @@ static const struct mfd_cell wm8998_devs[] = {
 		.parent_supplies = wm5102_supplies,
 		.num_parent_supplies = ARRAY_SIZE(wm5102_supplies),
 	},
-	{ .name = "arizona-micsupp" },
 };
 
 int arizona_dev_init(struct arizona *arizona)

commit b79a980f7161ca09855cc641091d1afe4ef08dd8
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Oct 28 12:42:30 2015 +0000

    mfd: arizona-core: msleep() is unreliable for anything <20ms use usleep_range() instead
    
    WARNING: msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt
    +               msleep(1);
    
    WARNING: msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt
    +                       msleep(5);
    
    WARNING: msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt
    +               msleep(1);
    
    WARNING: msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt
    +               msleep(1);
    
    total: 0 errors, 4 warnings, 1407 lines checked
    
    Cc: patches@opensource.wolfsonmicro.com
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4bb486679110..5319f252790b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -238,7 +238,7 @@ static int arizona_poll_reg(struct arizona *arizona,
 		if ((val & mask) == target)
 			return 0;
 
-		msleep(1);
+		usleep_range(1000, 5000);
 	}
 
 	dev_err(arizona->dev, "Polling reg %u timed out: %x\n", reg, val);
@@ -279,14 +279,14 @@ static void arizona_disable_reset(struct arizona *arizona)
 		case WM5110:
 		case WM8280:
 			/* Meet requirements for minimum reset duration */
-			msleep(5);
+			usleep_range(5000, 10000);
 			break;
 		default:
 			break;
 		}
 
 		gpio_set_value_cansleep(arizona->pdata.reset, 1);
-		msleep(1);
+		usleep_range(1000, 5000);
 	}
 }
 
@@ -1132,7 +1132,7 @@ int arizona_dev_init(struct arizona *arizona)
 			goto err_reset;
 		}
 
-		msleep(1);
+		usleep_range(1000, 5000);
 	}
 
 	/* Ensure device startup is complete */

commit f199d39349beabcb1a374cb02e0845a0ae84f3fd
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Dec 14 10:19:11 2015 +0000

    mfd: arizona: Add device tree binding to specify mono outputs
    
    Add device tree bindings to support specifying outputs from the chip as
    mono outputs. Whilst we are doing it change the out_mono pdata from a
    bool to an int, because Sparse gets upset about using ARRAY_SIZE on
    bools.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b9489a0d7fab..4bb486679110 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -861,6 +861,16 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 		count++;
 	}
 
+	count = 0;
+	of_property_for_each_u32(arizona->dev->of_node, "wlf,out-mono", prop,
+				 cur, val) {
+		if (count == ARRAY_SIZE(pdata->out_mono))
+			break;
+
+		pdata->out_mono[count] = !!val;
+		count++;
+	}
+
 	return 0;
 }
 

commit ea1f3339909d8973b41f09ef7275d7e49974b910
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Tue Nov 3 15:08:32 2015 +0000

    mfd: arizona: Support Cirrus Logic CS47L24 and WM1831
    
    This patch adds the regmap configuration tables and
    core MFD handling for the CS47L24 and WM1831 codecs.
    
    Note that compared to the other Arizona codecs, these devices
    do not have an LDO1 or micsupp regulators, extcon driver, or
    the DCVDD isolation control.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index d474732cc65c..b9489a0d7fab 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -598,6 +598,12 @@ static int arizona_runtime_resume(struct device *dev)
 			goto err;
 		}
 		break;
+	case WM1831:
+	case CS47L24:
+		ret = arizona_wait_for_boot(arizona);
+		if (ret != 0)
+			goto err;
+		break;
 	default:
 		ret = arizona_wait_for_boot(arizona);
 		if (ret != 0)
@@ -682,6 +688,9 @@ static int arizona_runtime_suspend(struct device *dev)
 			}
 		}
 		break;
+	case WM1831:
+	case CS47L24:
+		break;
 	default:
 		jd_active = arizona_is_jack_det_active(arizona);
 		if (jd_active < 0)
@@ -862,6 +871,8 @@ const struct of_device_id arizona_of_match[] = {
 	{ .compatible = "wlf,wm8997", .data = (void *)WM8997 },
 	{ .compatible = "wlf,wm8998", .data = (void *)WM8998 },
 	{ .compatible = "wlf,wm1814", .data = (void *)WM1814 },
+	{ .compatible = "wlf,wm1831", .data = (void *)WM1831 },
+	{ .compatible = "cirrus,cs47l24", .data = (void *)CS47L24 },
 	{},
 };
 EXPORT_SYMBOL_GPL(arizona_of_match);
@@ -919,6 +930,23 @@ static const struct mfd_cell wm5110_devs[] = {
 	},
 };
 
+static const char * const cs47l24_supplies[] = {
+	"MICVDD",
+	"CPVDD",
+	"SPKVDD",
+};
+
+static const struct mfd_cell cs47l24_devs[] = {
+	{ .name = "arizona-gpio" },
+	{ .name = "arizona-haptics" },
+	{ .name = "arizona-pwm" },
+	{
+		.name = "cs47l24-codec",
+		.parent_supplies = cs47l24_supplies,
+		.num_parent_supplies = ARRAY_SIZE(cs47l24_supplies),
+	},
+};
+
 static const char * const wm8997_supplies[] = {
 	"MICVDD",
 	"DBVDD2",
@@ -963,7 +991,7 @@ static const struct mfd_cell wm8998_devs[] = {
 int arizona_dev_init(struct arizona *arizona)
 {
 	struct device *dev = arizona->dev;
-	const char *type_name;
+	const char *type_name = NULL;
 	unsigned int reg, val, mask;
 	int (*apply_patch)(struct arizona *) = NULL;
 	const struct mfd_cell *subdevs = NULL;
@@ -987,6 +1015,8 @@ int arizona_dev_init(struct arizona *arizona)
 	case WM8997:
 	case WM8998:
 	case WM1814:
+	case WM1831:
+	case CS47L24:
 		for (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)
 			arizona->core_supplies[i].supply
 				= wm5102_core_supplies[i];
@@ -1001,11 +1031,18 @@ int arizona_dev_init(struct arizona *arizona)
 	/* Mark DCVDD as external, LDO1 driver will clear if internal */
 	arizona->external_dcvdd = true;
 
-	ret = mfd_add_devices(arizona->dev, -1, early_devs,
-			      ARRAY_SIZE(early_devs), NULL, 0, NULL);
-	if (ret != 0) {
-		dev_err(dev, "Failed to add early children: %d\n", ret);
-		return ret;
+	switch (arizona->type) {
+	case WM1831:
+	case CS47L24:
+		break; /* No LDO1 regulator */
+	default:
+		ret = mfd_add_devices(arizona->dev, -1, early_devs,
+				      ARRAY_SIZE(early_devs), NULL, 0, NULL);
+		if (ret != 0) {
+			dev_err(dev, "Failed to add early children: %d\n", ret);
+			return ret;
+		}
+		break;
 	}
 
 	ret = devm_regulator_bulk_get(dev, arizona->num_core_supplies,
@@ -1069,6 +1106,7 @@ int arizona_dev_init(struct arizona *arizona)
 	case 0x5102:
 	case 0x5110:
 	case 0x6349:
+	case 0x6363:
 	case 0x8997:
 		break;
 	default:
@@ -1167,6 +1205,30 @@ int arizona_dev_init(struct arizona *arizona)
 			n_subdevs = ARRAY_SIZE(wm5110_devs);
 		}
 		break;
+	case 0x6363:
+		if (IS_ENABLED(CONFIG_MFD_CS47L24)) {
+			switch (arizona->type) {
+			case CS47L24:
+				type_name = "CS47L24";
+				break;
+
+			case WM1831:
+				type_name = "WM1831";
+				break;
+
+			default:
+				dev_warn(arizona->dev,
+					 "CS47L24 registered as %d\n",
+					 arizona->type);
+				arizona->type = CS47L24;
+				break;
+			}
+
+			apply_patch = cs47l24_patch;
+			subdevs = cs47l24_devs;
+			n_subdevs = ARRAY_SIZE(cs47l24_devs);
+		}
+		break;
 	case 0x8997:
 		if (IS_ENABLED(CONFIG_MFD_WM8997)) {
 			type_name = "WM8997";

commit a05950a4453fcfb136ee1eff0bd0a3cfb46a401e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Oct 19 13:18:05 2015 +0300

    mfd: arizona: Signedness bug in arizona_runtime_suspend()
    
    The "jd_active" variable needs to be signed for the error handling to
    work.
    
    Fixes: 143e5887ae57 ('mfd: arizona: factor out checking of jack detection state')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4e49210f7a5b..d474732cc65c 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -628,7 +628,7 @@ static int arizona_runtime_resume(struct device *dev)
 static int arizona_runtime_suspend(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
-	unsigned int jd_active = 0;
+	int jd_active = 0;
 	int ret;
 
 	dev_dbg(arizona->dev, "Entering AoD mode\n");

commit b61c1ec058dabdcbddad7436bb4c009a8fa65b02
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Fri Oct 2 13:29:14 2015 +0100

    mfd: arizona: Remove use of codec build config #ifdefs
    
    Remove the use of #ifdefs around each case statement of the chip ID
    and type validation switches.
    
    We must ensure that the contained code still compiles to nothing if
    support for that codec was not built into the kernel, to prevent
    creation of link references to missing functions. So the ifdefs are
    replaced with a use of the IS_ENABLED() macro.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 39899bf18231..4e49210f7a5b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1128,82 +1128,95 @@ int arizona_dev_init(struct arizona *arizona)
 	arizona->rev &= ARIZONA_DEVICE_REVISION_MASK;
 
 	switch (reg) {
-#ifdef CONFIG_MFD_WM5102
 	case 0x5102:
-		type_name = "WM5102";
-		if (arizona->type != WM5102) {
-			dev_warn(arizona->dev, "WM5102 registered as %d\n",
-				 arizona->type);
-			arizona->type = WM5102;
+		if (IS_ENABLED(CONFIG_MFD_WM5102)) {
+			type_name = "WM5102";
+			if (arizona->type != WM5102) {
+				dev_warn(arizona->dev,
+					 "WM5102 registered as %d\n",
+					 arizona->type);
+				arizona->type = WM5102;
+			}
+
+			apply_patch = wm5102_patch;
+			arizona->rev &= 0x7;
+			subdevs = wm5102_devs;
+			n_subdevs = ARRAY_SIZE(wm5102_devs);
 		}
-		apply_patch = wm5102_patch;
-		arizona->rev &= 0x7;
-		subdevs = wm5102_devs;
-		n_subdevs = ARRAY_SIZE(wm5102_devs);
 		break;
-#endif
-#ifdef CONFIG_MFD_WM5110
 	case 0x5110:
-		switch (arizona->type) {
-		case WM5110:
-			type_name = "WM5110";
-			break;
-		case WM8280:
-			type_name = "WM8280";
-			break;
-		default:
-			type_name = "WM5110";
-			dev_warn(arizona->dev, "WM5110 registered as %d\n",
-				 arizona->type);
-			arizona->type = WM5110;
-			break;
+		if (IS_ENABLED(CONFIG_MFD_WM5110)) {
+			switch (arizona->type) {
+			case WM5110:
+				type_name = "WM5110";
+				break;
+			case WM8280:
+				type_name = "WM8280";
+				break;
+			default:
+				type_name = "WM5110";
+				dev_warn(arizona->dev,
+					 "WM5110 registered as %d\n",
+					 arizona->type);
+				arizona->type = WM5110;
+				break;
+			}
+
+			apply_patch = wm5110_patch;
+			subdevs = wm5110_devs;
+			n_subdevs = ARRAY_SIZE(wm5110_devs);
 		}
-		apply_patch = wm5110_patch;
-		subdevs = wm5110_devs;
-		n_subdevs = ARRAY_SIZE(wm5110_devs);
 		break;
-#endif
-#ifdef CONFIG_MFD_WM8997
 	case 0x8997:
-		type_name = "WM8997";
-		if (arizona->type != WM8997) {
-			dev_warn(arizona->dev, "WM8997 registered as %d\n",
-				 arizona->type);
-			arizona->type = WM8997;
+		if (IS_ENABLED(CONFIG_MFD_WM8997)) {
+			type_name = "WM8997";
+			if (arizona->type != WM8997) {
+				dev_warn(arizona->dev,
+					 "WM8997 registered as %d\n",
+					 arizona->type);
+				arizona->type = WM8997;
+			}
+
+			apply_patch = wm8997_patch;
+			subdevs = wm8997_devs;
+			n_subdevs = ARRAY_SIZE(wm8997_devs);
 		}
-		apply_patch = wm8997_patch;
-		subdevs = wm8997_devs;
-		n_subdevs = ARRAY_SIZE(wm8997_devs);
 		break;
-#endif
-#ifdef CONFIG_MFD_WM8998
 	case 0x6349:
-		switch (arizona->type) {
-		case WM8998:
-			type_name = "WM8998";
-			break;
-
-		case WM1814:
-			type_name = "WM1814";
-			break;
+		if (IS_ENABLED(CONFIG_MFD_WM8998)) {
+			switch (arizona->type) {
+			case WM8998:
+				type_name = "WM8998";
+				break;
+
+			case WM1814:
+				type_name = "WM1814";
+				break;
+
+			default:
+				type_name = "WM8998";
+				dev_warn(arizona->dev,
+					 "WM8998 registered as %d\n",
+					 arizona->type);
+				arizona->type = WM8998;
+			}
 
-		default:
-			type_name = "WM8998";
-			dev_warn(arizona->dev, "WM8998 registered as %d\n",
-				 arizona->type);
-			arizona->type = WM8998;
+			apply_patch = wm8998_patch;
+			subdevs = wm8998_devs;
+			n_subdevs = ARRAY_SIZE(wm8998_devs);
 		}
-
-		apply_patch = wm8998_patch;
-		subdevs = wm8998_devs;
-		n_subdevs = ARRAY_SIZE(wm8998_devs);
 		break;
-#endif
 	default:
 		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
 		goto err_reset;
 	}
 
+	if (!subdevs) {
+		dev_err(arizona->dev,
+			"No kernel support for device ID %x\n", reg);
+		goto err_reset;
+	}
+
 	dev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');
 
 	if (apply_patch) {

commit ae05ea36d1c9bdc76a4539277d96f5bdf3d39f02
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Fri Oct 2 13:29:13 2015 +0100

    mfd: arizona: Simplify adding subdevices
    
    The code was using a switch on the code type to execute
    one of several mfd_add_devices() calls. We're already
    switching on the code type earlier in the function to
    select the correct patch function so we can roll selection
    of the mfd device table into the same switch.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index c3f88e57fe4a..39899bf18231 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -24,6 +24,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/machine.h>
 #include <linux/slab.h>
+#include <linux/platform_device.h>
 
 #include <linux/mfd/arizona/core.h>
 #include <linux/mfd/arizona/registers.h>
@@ -965,7 +966,8 @@ int arizona_dev_init(struct arizona *arizona)
 	const char *type_name;
 	unsigned int reg, val, mask;
 	int (*apply_patch)(struct arizona *) = NULL;
-	int ret, i;
+	const struct mfd_cell *subdevs = NULL;
+	int n_subdevs, ret, i;
 
 	dev_set_drvdata(arizona->dev, arizona);
 	mutex_init(&arizona->clk_lock);
@@ -1136,6 +1138,8 @@ int arizona_dev_init(struct arizona *arizona)
 		}
 		apply_patch = wm5102_patch;
 		arizona->rev &= 0x7;
+		subdevs = wm5102_devs;
+		n_subdevs = ARRAY_SIZE(wm5102_devs);
 		break;
 #endif
 #ifdef CONFIG_MFD_WM5110
@@ -1155,6 +1159,8 @@ int arizona_dev_init(struct arizona *arizona)
 			break;
 		}
 		apply_patch = wm5110_patch;
+		subdevs = wm5110_devs;
+		n_subdevs = ARRAY_SIZE(wm5110_devs);
 		break;
 #endif
 #ifdef CONFIG_MFD_WM8997
@@ -1166,6 +1172,8 @@ int arizona_dev_init(struct arizona *arizona)
 			arizona->type = WM8997;
 		}
 		apply_patch = wm8997_patch;
+		subdevs = wm8997_devs;
+		n_subdevs = ARRAY_SIZE(wm8997_devs);
 		break;
 #endif
 #ifdef CONFIG_MFD_WM8998
@@ -1187,6 +1195,8 @@ int arizona_dev_init(struct arizona *arizona)
 		}
 
 		apply_patch = wm8998_patch;
+		subdevs = wm8998_devs;
+		n_subdevs = ARRAY_SIZE(wm8998_devs);
 		break;
 #endif
 	default:
@@ -1379,28 +1389,10 @@ int arizona_dev_init(struct arizona *arizona)
 	arizona_request_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, "Underclocked",
 			    arizona_underclocked, arizona);
 
-	switch (arizona->type) {
-	case WM5102:
-		ret = mfd_add_devices(arizona->dev, -1, wm5102_devs,
-				      ARRAY_SIZE(wm5102_devs), NULL, 0, NULL);
-		break;
-	case WM5110:
-	case WM8280:
-		ret = mfd_add_devices(arizona->dev, -1, wm5110_devs,
-				      ARRAY_SIZE(wm5110_devs), NULL, 0, NULL);
-		break;
-	case WM8997:
-		ret = mfd_add_devices(arizona->dev, -1, wm8997_devs,
-				      ARRAY_SIZE(wm8997_devs), NULL, 0, NULL);
-		break;
-	case WM8998:
-	case WM1814:
-		ret = mfd_add_devices(arizona->dev, -1, wm8998_devs,
-				      ARRAY_SIZE(wm8998_devs), NULL, 0, NULL);
-		break;
-	}
+	ret = mfd_add_devices(arizona->dev, PLATFORM_DEVID_NONE,
+			      subdevs, n_subdevs, NULL, 0, NULL);
 
-	if (ret != 0) {
+	if (ret) {
 		dev_err(arizona->dev, "Failed to add subdevices: %d\n", ret);
 		goto err_irq;
 	}

commit 161ad30bd2ec4be7269b2f8748fa4e5d5847191e
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Fri Oct 2 13:29:12 2015 +0100

    mfd: arizona: Downgrade type mismatch messages to dev_warn
    
    If the declared codec type doesn't match the detected type
    we issue a log message but carry on registering the device,
    so a dev_warn() is appropriate rather than a dev_err()
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e32d0d30e9cd..c3f88e57fe4a 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1130,8 +1130,8 @@ int arizona_dev_init(struct arizona *arizona)
 	case 0x5102:
 		type_name = "WM5102";
 		if (arizona->type != WM5102) {
-			dev_err(arizona->dev, "WM5102 registered as %d\n",
-				arizona->type);
+			dev_warn(arizona->dev, "WM5102 registered as %d\n",
+				 arizona->type);
 			arizona->type = WM5102;
 		}
 		apply_patch = wm5102_patch;
@@ -1149,8 +1149,8 @@ int arizona_dev_init(struct arizona *arizona)
 			break;
 		default:
 			type_name = "WM5110";
-			dev_err(arizona->dev, "WM5110 registered as %d\n",
-				arizona->type);
+			dev_warn(arizona->dev, "WM5110 registered as %d\n",
+				 arizona->type);
 			arizona->type = WM5110;
 			break;
 		}
@@ -1161,8 +1161,8 @@ int arizona_dev_init(struct arizona *arizona)
 	case 0x8997:
 		type_name = "WM8997";
 		if (arizona->type != WM8997) {
-			dev_err(arizona->dev, "WM8997 registered as %d\n",
-				arizona->type);
+			dev_warn(arizona->dev, "WM8997 registered as %d\n",
+				 arizona->type);
 			arizona->type = WM8997;
 		}
 		apply_patch = wm8997_patch;
@@ -1181,8 +1181,8 @@ int arizona_dev_init(struct arizona *arizona)
 
 		default:
 			type_name = "WM8998";
-			dev_err(arizona->dev, "WM8998 registered as %d\n",
-				arizona->type);
+			dev_warn(arizona->dev, "WM8998 registered as %d\n",
+				 arizona->type);
 			arizona->type = WM8998;
 		}
 

commit e3424273545bef85ebf959c90091d60ba3fc2efc
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Fri Oct 2 13:29:11 2015 +0100

    mfd: arizona: Factor out checking of jack detection state
    
    Currently runtime_suspend will fully power off the codec if
    the jack detection is not enabled. Not all future codecs will
    have jack detection so to prepare for these codecs this patch
    factors out the check so that it be called as needed in the
    existing codec-specific switch cases.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 29be2628352c..e32d0d30e9cd 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -487,6 +487,23 @@ static int arizona_connect_dcvdd(struct arizona *arizona)
 	return ret;
 }
 
+static int arizona_is_jack_det_active(struct arizona *arizona)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(arizona->regmap, ARIZONA_JACK_DETECT_ANALOGUE, &val);
+	if (ret) {
+		dev_err(arizona->dev,
+			"Failed to check jack det status: %d\n", ret);
+		return ret;
+	} else if (val & ARIZONA_JD1_ENA) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
 static int arizona_runtime_resume(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
@@ -610,20 +627,18 @@ static int arizona_runtime_resume(struct device *dev)
 static int arizona_runtime_suspend(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
-	unsigned int val;
+	unsigned int jd_active = 0;
 	int ret;
 
 	dev_dbg(arizona->dev, "Entering AoD mode\n");
 
-	ret = regmap_read(arizona->regmap, ARIZONA_JACK_DETECT_ANALOGUE, &val);
-	if (ret) {
-		dev_err(dev, "Failed to check jack det status: %d\n", ret);
-		return ret;
-	}
-
 	switch (arizona->type) {
 	case WM5110:
 	case WM8280:
+		jd_active = arizona_is_jack_det_active(arizona);
+		if (jd_active < 0)
+			return jd_active;
+
 		if (arizona->external_dcvdd) {
 			ret = arizona_isolate_dcvdd(arizona);
 			if (ret != 0)
@@ -645,13 +660,17 @@ static int arizona_runtime_suspend(struct device *dev)
 		}
 		break;
 	case WM5102:
+		jd_active = arizona_is_jack_det_active(arizona);
+		if (jd_active < 0)
+			return jd_active;
+
 		if (arizona->external_dcvdd) {
 			ret = arizona_isolate_dcvdd(arizona);
 			if (ret != 0)
 				return ret;
 		}
 
-		if (!(val & ARIZONA_JD1_ENA)) {
+		if (!jd_active) {
 			ret = regmap_write(arizona->regmap,
 					   ARIZONA_WRITE_SEQUENCER_CTRL_3, 0x0);
 			if (ret) {
@@ -663,6 +682,10 @@ static int arizona_runtime_suspend(struct device *dev)
 		}
 		break;
 	default:
+		jd_active = arizona_is_jack_det_active(arizona);
+		if (jd_active < 0)
+			return jd_active;
+
 		if (arizona->external_dcvdd) {
 			ret = arizona_isolate_dcvdd(arizona);
 			if (ret != 0)
@@ -676,7 +699,7 @@ static int arizona_runtime_suspend(struct device *dev)
 	regulator_disable(arizona->dcvdd);
 
 	/* Allow us to completely power down if no jack detection */
-	if (!(val & ARIZONA_JD1_ENA)) {
+	if (!jd_active) {
 		dev_dbg(arizona->dev, "Fully powering off\n");
 
 		arizona->has_fully_powered_off = true;

commit e7811147aafb3d6364b8d60223cbe6c323cdf725
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Fri Oct 2 13:29:10 2015 +0100

    mfd: arizona: Factor out DCVDD isolation control
    
    Currently DCVDD isolation is enabled and disabled for
    runtime_suspend and runtime_resume. Future codecs will not
    have the isolation control so to prepare for these codecs
    this patch factors out the isolation control allowing it to
    be called as needed in the existing codec-specific switch cases.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index acf354875338..29be2628352c 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -460,6 +460,33 @@ static int wm5102_clear_write_sequencer(struct arizona *arizona)
 }
 
 #ifdef CONFIG_PM
+static int arizona_isolate_dcvdd(struct arizona *arizona)
+{
+	int ret;
+
+	ret = regmap_update_bits(arizona->regmap,
+				 ARIZONA_ISOLATION_CONTROL,
+				 ARIZONA_ISOLATE_DCVDD1,
+				 ARIZONA_ISOLATE_DCVDD1);
+	if (ret != 0)
+		dev_err(arizona->dev, "Failed to isolate DCVDD: %d\n", ret);
+
+	return ret;
+}
+
+static int arizona_connect_dcvdd(struct arizona *arizona)
+{
+	int ret;
+
+	ret = regmap_update_bits(arizona->regmap,
+				 ARIZONA_ISOLATION_CONTROL,
+				 ARIZONA_ISOLATE_DCVDD1, 0);
+	if (ret != 0)
+		dev_err(arizona->dev, "Failed to connect DCVDD: %d\n", ret);
+
+	return ret;
+}
+
 static int arizona_runtime_resume(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
@@ -499,14 +526,9 @@ static int arizona_runtime_resume(struct device *dev)
 	switch (arizona->type) {
 	case WM5102:
 		if (arizona->external_dcvdd) {
-			ret = regmap_update_bits(arizona->regmap,
-						 ARIZONA_ISOLATION_CONTROL,
-						 ARIZONA_ISOLATE_DCVDD1, 0);
-			if (ret != 0) {
-				dev_err(arizona->dev,
-					"Failed to connect DCVDD: %d\n", ret);
+			ret = arizona_connect_dcvdd(arizona);
+			if (ret != 0)
 				goto err;
-			}
 		}
 
 		ret = wm5102_patch(arizona);
@@ -531,14 +553,9 @@ static int arizona_runtime_resume(struct device *dev)
 			goto err;
 
 		if (arizona->external_dcvdd) {
-			ret = regmap_update_bits(arizona->regmap,
-						 ARIZONA_ISOLATION_CONTROL,
-						 ARIZONA_ISOLATE_DCVDD1, 0);
-			if (ret) {
-				dev_err(arizona->dev,
-					"Failed to connect DCVDD: %d\n", ret);
+			ret = arizona_connect_dcvdd(arizona);
+			if (ret != 0)
 				goto err;
-			}
 		} else {
 			/*
 			 * As this is only called for the internal regulator
@@ -569,14 +586,9 @@ static int arizona_runtime_resume(struct device *dev)
 			goto err;
 
 		if (arizona->external_dcvdd) {
-			ret = regmap_update_bits(arizona->regmap,
-						 ARIZONA_ISOLATION_CONTROL,
-						 ARIZONA_ISOLATE_DCVDD1, 0);
-			if (ret != 0) {
-				dev_err(arizona->dev,
-					"Failed to connect DCVDD: %d\n", ret);
+			ret = arizona_connect_dcvdd(arizona);
+			if (ret != 0)
 				goto err;
-			}
 		}
 		break;
 	}
@@ -609,37 +621,36 @@ static int arizona_runtime_suspend(struct device *dev)
 		return ret;
 	}
 
-	if (arizona->external_dcvdd) {
-		ret = regmap_update_bits(arizona->regmap,
-					 ARIZONA_ISOLATION_CONTROL,
-					 ARIZONA_ISOLATE_DCVDD1,
-					 ARIZONA_ISOLATE_DCVDD1);
-		if (ret != 0) {
-			dev_err(arizona->dev, "Failed to isolate DCVDD: %d\n",
-				ret);
-			return ret;
-		}
-	}
-
 	switch (arizona->type) {
 	case WM5110:
 	case WM8280:
-		if (arizona->external_dcvdd)
-			break;
-
-		/*
-		 * As this is only called for the internal regulator
-		 * (where we know voltage ranges available) it is ok
-		 * to request an exact range.
-		 */
-		ret = regulator_set_voltage(arizona->dcvdd, 1175000, 1175000);
-		if (ret < 0) {
-			dev_err(arizona->dev,
-				"Failed to set suspend voltage: %d\n", ret);
-			return ret;
+		if (arizona->external_dcvdd) {
+			ret = arizona_isolate_dcvdd(arizona);
+			if (ret != 0)
+				return ret;
+		} else {
+			/*
+			 * As this is only called for the internal regulator
+			 * (where we know voltage ranges available) it is ok
+			 * to request an exact range.
+			 */
+			ret = regulator_set_voltage(arizona->dcvdd,
+						    1175000, 1175000);
+			if (ret < 0) {
+				dev_err(arizona->dev,
+					"Failed to set suspend voltage: %d\n",
+					ret);
+				return ret;
+			}
 		}
 		break;
 	case WM5102:
+		if (arizona->external_dcvdd) {
+			ret = arizona_isolate_dcvdd(arizona);
+			if (ret != 0)
+				return ret;
+		}
+
 		if (!(val & ARIZONA_JD1_ENA)) {
 			ret = regmap_write(arizona->regmap,
 					   ARIZONA_WRITE_SEQUENCER_CTRL_3, 0x0);
@@ -652,6 +663,11 @@ static int arizona_runtime_suspend(struct device *dev)
 		}
 		break;
 	default:
+		if (arizona->external_dcvdd) {
+			ret = arizona_isolate_dcvdd(arizona);
+			if (ret != 0)
+				return ret;
+		}
 		break;
 	}
 

commit a260fba1158241d168bf14eb7cd1176b29ad263c
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Tue Sep 29 13:26:02 2015 +0200

    mfd: arizona: Remove unneded ret variable
    
    The ret variable is not needed since is not used in the
    function. Remove the variable and just return 0 instead.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 44cfdbb295db..acf354875338 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -69,8 +69,6 @@ EXPORT_SYMBOL_GPL(arizona_clk32k_enable);
 
 int arizona_clk32k_disable(struct arizona *arizona)
 {
-	int ret = 0;
-
 	mutex_lock(&arizona->clk_lock);
 
 	BUG_ON(arizona->clk32k_ref <= 0);
@@ -90,7 +88,7 @@ int arizona_clk32k_disable(struct arizona *arizona)
 
 	mutex_unlock(&arizona->clk_lock);
 
-	return ret;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(arizona_clk32k_disable);
 

commit abebcdfb64f1b39eeeb14282d9cd4aad1ed86f8d
Merge: 670c039deeff d5f362a7b977
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 4 11:46:02 2015 -0700

    Merge tag 'sound-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "There are little changes in core part, but lots of development are
      found in drivers, especially ASoC.  The diffstat shows regmap-related
      changes for a slight API additions / changes, and that's all.
    
      Looking at the code size statistics, the most significant addition is
      for Intel Skylake.  (Note that SKL support is still underway, the
      codec driver is missing.) Also STI controller driver is a major
      addition as well as a few new codec drivers.
    
      In HD-audio side, there are fewer changes than the past.  The
      noticeable change is the support of ELD notification from i915
      graphics driver.  Thus this pull request carries a few changes in
      drm/i915.
    
      Other than that, USB-audio got a rewrite of runtime PM code.  It was
      initiated by lockdep warning, but resulted in a good cleanup in the
      end.
    
      Below are the highlights:
    
      Common:
       - Factoring out of AC'97 reset code from ASoC into the core helper
       - A few regmap API extensions (in case it's not pulled yet)
    
      ASoC:
       - New drivers for Cirrus CS4349, GTM601, InvenSense ICS43432, Realtek
         RT298 and ST STI controllers
       - Machine drivers for Rockchip systems with MAX98090 and RT5645 and
         RT5650
       - Initial driver support for Intel Skylake devices
       - Lots of rsnd cleanup and enhancements
       - A few DAPM fixes and cleanups
       - A large number of cleanups in various drivers (conversion and
         standardized to regmap, component) mostly by Lars-Peter and Axel
    
      HD-audio:
       - Extended HD-audio core for Intel Skylake controller support
       - Quirks for Dell headsets, Alienware 15
       - Clean up of pin-based quirk tables for Realtek codecs
       - ELD notifier implenetation for Intel HDMI/DP
    
      USB-audio:
       - Refactor runtime PM code to make lockdep happier"
    
    * tag 'sound-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (411 commits)
      drm/i915: Add locks around audio component bind/unbind
      drm/i915: Drop port_mst_index parameter from pin/eld callback
      ALSA: hda - Fix missing inline for dummy snd_hdac_set_codec_wakeup()
      ALSA: hda - Wake the codec up on pin/ELD notify events
      ALSA: hda - allow codecs to access the i915 pin/ELD callback
      drm/i915: Call audio pin/ELD notify function
      drm/i915: Add audio pin sense / ELD callback
      ASoC: zx296702-i2s: Fix resource leak when unload module
      ASoC: sti_uniperif: Ensure component is unregistered when unload module
      ASoC: au1x: psc-i2s: Convert to use devm_ioremap_resource
      ASoC: sh: dma-sh7760: Convert to devm_snd_soc_register_platform
      ASoC: spear_pcm: Use devm_snd_dmaengine_pcm_register to fix resource leak
      ALSA: fireworks/bebob/dice/oxfw: fix substreams counting at vmalloc failure
      ASoC: Clean up docbook warnings
      ASoC: txx9: Convert to devm_snd_soc_register_platform
      ASoC: pxa: Convert to devm_snd_soc_register_platform
      ASoC: nuc900: Convert to devm_snd_soc_register_platform
      ASoC: blackfin: Convert to devm_snd_soc_register_platform
      ASoC: au1x: Convert to devm_snd_soc_register_platform
      ASoC: qcom: Constify asoc_qcom_lpass_cpu_dai_ops
      ...

commit 8bd8fd0a29bfd5ad8e1976edd8c4c40cdb39aa4f
Merge: 352712274507 5a688c455066
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 4 11:35:03 2015 -0700

    Merge tag 'mfd-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd
    
    Pull MFD updates from Lee Jones:
     "New Device Support:
       - New Clocksource driver from ST
       - New MFD/ACPI/DMA drivers for Intel's Sunrisepoint PCH based platforms
       - Add support for Arizona WM8998 and WM1814
       - Add support for Dialog Semi DA9062 and DA9063
       - Add support for Kontron COMe-bBL6 and COMe-cBW6
       - Add support for X-Powers AXP152
       - Add support for Atmel, many
       - Add support for STMPE, many
       - Add support for USB in X-Powers AXP22X
    
      Core Frameworks:
       - New Base API to traverse devices and their children in reverse order
    
      Bug Fixes:
       - Fix race between runtime-suspend and IRQs
       - Obtain platform data form more reliable source
    
      Fix-ups:
       - Constifying things
       - Variable signage changes
       - Kconfig depends|selects changes
       - Make use of BIT() macro
       - Do not supply .owner attribute in *_driver structures
       - MAINTAINERS entries
       - Stop using set_irq_flags()
       - Start using irq_set_chained_handler_and_data()
       - Export DT device ID structures"
    
    * tag 'mfd-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd: (69 commits)
      mfd: jz4740-adc: Init mask cache in generic IRQ chip
      mfd: cros_ec: spi: Add OF match table
      mfd: stmpe: Add OF match table
      mfd: max77686: Split out regulator part from the DT binding
      mfd: Add DT binding for Maxim MAX77802 IC
      mfd: max77686: Use a generic name for the PMIC node in the example
      mfd: max77686: Don't suggest in binding to use a deprecated property
      mfd: Add MFD_CROS_EC dependencies
      mfd: cros_ec: Remove CROS_EC_PROTO dependency for SPI and I2C drivers
      mfd: axp20x: Add a cell for the usb power_supply part of the axp20x PMICs
      mfd: axp20x: Add missing registers, and mark more registers volatile
      mfd: arizona: Fixup some formatting/white space errors
      mfd: wm8994: Fix NULL pointer exception on missing pdata
      of: Add vendor prefix for Nuvoton
      mfd: mt6397: Implement wake handler and suspend/resume to handle wake up event
      mfd: atmel-hlcdc: Add support for new SoCs
      mfd: Export OF module alias information in missing drivers
      mfd: stw481x: Export I2C module alias information
      mfd: da9062: Support for the DA9063 OnKey in the DA9062 core
      mfd: max899x: Avoid redundant irq_data lookup
      ...

commit 532161e6ccbd1c5ac3a2ea9dc60c8e253cd22fa5
Merge: d781c23e9b46 1af2cc64b18c 41a5fefeff21 ac1125daf02b 1c0beb27443c a5afdc5bf539
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:55:54 2015 +0100

    Merge remote-tracking branches 'asoc/topic/rcar', 'asoc/topic/reg-default', 'asoc/topic/rl6231', 'asoc/topic/rockchip' and 'asoc/topic/rt286' into asoc-next

commit 3762aede11e516b7a392afdc1e070171e6f6cd00
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Aug 11 09:34:31 2015 +0100

    mfd: arizona: Fixup some formatting/white space errors
    
    Clear out a few checkpatch warnings and white space errors.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index bc814b023c05..908c69b359ca 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -30,7 +30,7 @@
 
 #include "arizona.h"
 
-static const char *wm5102_core_supplies[] = {
+static const char * const wm5102_core_supplies[] = {
 	"AVDD",
 	"DBVDD1",
 };
@@ -148,7 +148,7 @@ static irqreturn_t arizona_overclocked(int irq, void *data)
 	struct arizona *arizona = data;
 	unsigned int val[3];
 	int ret;
-	
+
 	ret = regmap_bulk_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_6,
 			       &val[0], 3);
 	if (ret != 0) {
@@ -567,9 +567,8 @@ static int arizona_runtime_resume(struct device *dev)
 		break;
 	default:
 		ret = arizona_wait_for_boot(arizona);
-		if (ret != 0) {
+		if (ret != 0)
 			goto err;
-		}
 
 		if (arizona->external_dcvdd) {
 			ret = regmap_update_bits(arizona->regmap,
@@ -776,8 +775,8 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 
 	ret = of_property_read_u32_array(arizona->dev->of_node,
 					 "wlf,gpio-defaults",
-					 arizona->pdata.gpio_defaults,
-					 ARRAY_SIZE(arizona->pdata.gpio_defaults));
+					 pdata->gpio_defaults,
+					 ARRAY_SIZE(pdata->gpio_defaults));
 	if (ret >= 0) {
 		/*
 		 * All values are literal except out of range values
@@ -785,11 +784,11 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 		 * data which uses 0 as chip default and out of range
 		 * as zero.
 		 */
-		for (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {
-			if (arizona->pdata.gpio_defaults[i] > 0xffff)
-				arizona->pdata.gpio_defaults[i] = 0;
-			else if (arizona->pdata.gpio_defaults[i] == 0)
-				arizona->pdata.gpio_defaults[i] = 0x10000;
+		for (i = 0; i < ARRAY_SIZE(pdata->gpio_defaults); i++) {
+			if (pdata->gpio_defaults[i] > 0xffff)
+				pdata->gpio_defaults[i] = 0;
+			else if (pdata->gpio_defaults[i] == 0)
+				pdata->gpio_defaults[i] = 0x10000;
 		}
 	} else {
 		dev_err(arizona->dev, "Failed to parse GPIO defaults: %d\n",
@@ -798,20 +797,20 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 
 	of_property_for_each_u32(arizona->dev->of_node, "wlf,inmode", prop,
 				 cur, val) {
-		if (count == ARRAY_SIZE(arizona->pdata.inmode))
+		if (count == ARRAY_SIZE(pdata->inmode))
 			break;
 
-		arizona->pdata.inmode[count] = val;
+		pdata->inmode[count] = val;
 		count++;
 	}
 
 	count = 0;
 	of_property_for_each_u32(arizona->dev->of_node, "wlf,dmic-ref", prop,
 				 cur, val) {
-		if (count == ARRAY_SIZE(arizona->pdata.dmic_ref))
+		if (count == ARRAY_SIZE(pdata->dmic_ref))
 			break;
 
-		arizona->pdata.dmic_ref[count] = val;
+		pdata->dmic_ref[count] = val;
 		count++;
 	}
 
@@ -839,7 +838,7 @@ static const struct mfd_cell early_devs[] = {
 	{ .name = "arizona-ldo1" },
 };
 
-static const char *wm5102_supplies[] = {
+static const char * const wm5102_supplies[] = {
 	"MICVDD",
 	"DBVDD2",
 	"DBVDD3",
@@ -882,7 +881,7 @@ static const struct mfd_cell wm5110_devs[] = {
 	},
 };
 
-static const char *wm8997_supplies[] = {
+static const char * const wm8997_supplies[] = {
 	"MICVDD",
 	"DBVDD2",
 	"CPVDD",

commit 6887b042c52ee05a405bae859f410c2f63b45339
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Fri Jul 3 16:16:35 2015 +0100

    mfd: arizona: Add support for WM8998 and WM1814
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e60bcd901d02..bc814b023c05 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -146,17 +146,31 @@ static irqreturn_t arizona_underclocked(int irq, void *data)
 static irqreturn_t arizona_overclocked(int irq, void *data)
 {
 	struct arizona *arizona = data;
-	unsigned int val[2];
+	unsigned int val[3];
 	int ret;
 	
 	ret = regmap_bulk_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_6,
-			       &val[0], 2);
+			       &val[0], 3);
 	if (ret != 0) {
 		dev_err(arizona->dev, "Failed to read overclock status: %d\n",
 			ret);
 		return IRQ_NONE;
 	}
 
+	switch (arizona->type) {
+	case WM8998:
+	case WM1814:
+		/* Some bits are shifted on WM8998,
+		 * rearrange to match the standard bit layout
+		 */
+		val[0] = ((val[0] & 0x60e0) >> 1) |
+			 ((val[0] & 0x1e00) >> 2) |
+			 (val[0] & 0x000f);
+		break;
+	default:
+		break;
+	}
+
 	if (val[0] & ARIZONA_PWM_OVERCLOCKED_STS)
 		dev_err(arizona->dev, "PWM overclocked\n");
 	if (val[0] & ARIZONA_FX_CORE_OVERCLOCKED_STS)
@@ -201,6 +215,9 @@ static irqreturn_t arizona_overclocked(int irq, void *data)
 	if (val[1] & ARIZONA_ISRC1_OVERCLOCKED_STS)
 		dev_err(arizona->dev, "ISRC1 overclocked\n");
 
+	if (val[2] & ARIZONA_SPDIF_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "SPDIF overclocked\n");
+
 	return IRQ_HANDLED;
 }
 
@@ -806,6 +823,8 @@ const struct of_device_id arizona_of_match[] = {
 	{ .compatible = "wlf,wm5110", .data = (void *)WM5110 },
 	{ .compatible = "wlf,wm8280", .data = (void *)WM8280 },
 	{ .compatible = "wlf,wm8997", .data = (void *)WM8997 },
+	{ .compatible = "wlf,wm8998", .data = (void *)WM8998 },
+	{ .compatible = "wlf,wm1814", .data = (void *)WM1814 },
 	{},
 };
 EXPORT_SYMBOL_GPL(arizona_of_match);
@@ -887,11 +906,28 @@ static const struct mfd_cell wm8997_devs[] = {
 	},
 };
 
+static const struct mfd_cell wm8998_devs[] = {
+	{
+		.name = "arizona-extcon",
+		.parent_supplies = wm5102_supplies,
+		.num_parent_supplies = 1, /* We only need MICVDD */
+	},
+	{ .name = "arizona-gpio" },
+	{ .name = "arizona-haptics" },
+	{ .name = "arizona-pwm" },
+	{
+		.name = "wm8998-codec",
+		.parent_supplies = wm5102_supplies,
+		.num_parent_supplies = ARRAY_SIZE(wm5102_supplies),
+	},
+	{ .name = "arizona-micsupp" },
+};
+
 int arizona_dev_init(struct arizona *arizona)
 {
 	struct device *dev = arizona->dev;
 	const char *type_name;
-	unsigned int reg, val;
+	unsigned int reg, val, mask;
 	int (*apply_patch)(struct arizona *) = NULL;
 	int ret, i;
 
@@ -911,6 +947,8 @@ int arizona_dev_init(struct arizona *arizona)
 	case WM5110:
 	case WM8280:
 	case WM8997:
+	case WM8998:
+	case WM1814:
 		for (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)
 			arizona->core_supplies[i].supply
 				= wm5102_core_supplies[i];
@@ -992,6 +1030,7 @@ int arizona_dev_init(struct arizona *arizona)
 	switch (reg) {
 	case 0x5102:
 	case 0x5110:
+	case 0x6349:
 	case 0x8997:
 		break;
 	default:
@@ -1092,6 +1131,27 @@ int arizona_dev_init(struct arizona *arizona)
 		}
 		apply_patch = wm8997_patch;
 		break;
+#endif
+#ifdef CONFIG_MFD_WM8998
+	case 0x6349:
+		switch (arizona->type) {
+		case WM8998:
+			type_name = "WM8998";
+			break;
+
+		case WM1814:
+			type_name = "WM1814";
+			break;
+
+		default:
+			type_name = "WM8998";
+			dev_err(arizona->dev, "WM8998 registered as %d\n",
+				arizona->type);
+			arizona->type = WM8998;
+		}
+
+		apply_patch = wm8998_patch;
+		break;
 #endif
 	default:
 		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
@@ -1208,14 +1268,38 @@ int arizona_dev_init(struct arizona *arizona)
 			<< ARIZONA_IN1_DMIC_SUP_SHIFT;
 		if (arizona->pdata.inmode[i] & ARIZONA_INMODE_DMIC)
 			val |= 1 << ARIZONA_IN1_MODE_SHIFT;
-		if (arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
-			val |= 1 << ARIZONA_IN1_SINGLE_ENDED_SHIFT;
+
+		switch (arizona->type) {
+		case WM8998:
+		case WM1814:
+			regmap_update_bits(arizona->regmap,
+				ARIZONA_ADC_DIGITAL_VOLUME_1L + (i * 8),
+				ARIZONA_IN1L_SRC_SE_MASK,
+				(arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
+					<< ARIZONA_IN1L_SRC_SE_SHIFT);
+
+			regmap_update_bits(arizona->regmap,
+				ARIZONA_ADC_DIGITAL_VOLUME_1R + (i * 8),
+				ARIZONA_IN1R_SRC_SE_MASK,
+				(arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
+					<< ARIZONA_IN1R_SRC_SE_SHIFT);
+
+			mask = ARIZONA_IN1_DMIC_SUP_MASK |
+				ARIZONA_IN1_MODE_MASK;
+			break;
+		default:
+			if (arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
+				val |= 1 << ARIZONA_IN1_SINGLE_ENDED_SHIFT;
+
+			mask = ARIZONA_IN1_DMIC_SUP_MASK |
+				ARIZONA_IN1_MODE_MASK |
+				ARIZONA_IN1_SINGLE_ENDED_MASK;
+			break;
+		}
 
 		regmap_update_bits(arizona->regmap,
 				   ARIZONA_IN1L_CONTROL + (i * 8),
-				   ARIZONA_IN1_DMIC_SUP_MASK |
-				   ARIZONA_IN1_MODE_MASK |
-				   ARIZONA_IN1_SINGLE_ENDED_MASK, val);
+				   mask, val);
 	}
 
 	for (i = 0; i < ARIZONA_MAX_OUTPUT; i++) {
@@ -1271,6 +1355,11 @@ int arizona_dev_init(struct arizona *arizona)
 		ret = mfd_add_devices(arizona->dev, -1, wm8997_devs,
 				      ARRAY_SIZE(wm8997_devs), NULL, 0, NULL);
 		break;
+	case WM8998:
+	case WM1814:
+		ret = mfd_add_devices(arizona->dev, -1, wm8998_devs,
+				      ARRAY_SIZE(wm8998_devs), NULL, 0, NULL);
+		break;
 	}
 
 	if (ret != 0) {

commit 16f6a0df1d319705abf068bd1ebada344ad9d04f
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Sun Jun 14 15:41:49 2015 +0100

    mfd: arizona: Fix race between runtime suspend and IRQs
    
    The function arizona_irq_thread (the threaded handler for the arizona
    IRQs) calls pm_runtime_get_sync at the start to ensure that the chip is
    active as we handle the IRQ. If the chip is part way through a runtime
    suspend when an IRQ arrives the PM core will wait for the suspend to
    complete, before resuming. However, since commit 4f0216409f7c
    ("mfd: arizona: Add better support for system suspend") the runtime
    suspend function may call disable_irq, if the chip is going to fully
    power off, which will try to wait for any outstanding IRQs to complete.
    This results in deadlock as the IRQ thread is waiting for the PM
    operation to complete and the PM thread is waiting for the IRQ to
    complete.
    
    To avoid this situation we use disable_irq_nosync, which allows the
    suspending thread to finish the suspend without waiting for the IRQ to
    complete. This is safe because if an IRQ is being processed it can only
    be blocked at the pm_runtime_get_sync at the start of the handler
    otherwise it wouldn't be possible to suspend.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index bebf58a06a6b..e60bcd901d02 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -651,7 +651,7 @@ static int arizona_runtime_suspend(struct device *dev)
 
 		arizona->has_fully_powered_off = true;
 
-		disable_irq(arizona->irq);
+		disable_irq_nosync(arizona->irq);
 		arizona_enable_reset(arizona);
 		regulator_bulk_disable(arizona->num_core_supplies,
 				       arizona->core_supplies);

commit 72e43164fd472f6c2659c8313b87da962322dbcf
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Sun Jun 14 15:41:50 2015 +0100

    mfd: arizona: Fix initialisation of the PM runtime
    
    The PM runtime core by default assumes a chip is suspended when runtime
    PM is enabled. Currently the arizona driver enables runtime PM when the
    chip is fully active and then disables the DCVDD regulator at the end of
    arizona_dev_init. This however has several problems, firstly the if we
    reach the end of arizona_dev_init, we did not properly follow all the
    proceedures for shutting down the chip, and most notably we never marked
    the chip as cache only so any writes occurring between then and the next
    PM runtime resume will be lost. Secondly, if we are already resumed when
    we reach the end of dev_init, then at best we get unbalanced regulator
    enable/disables at work we lose DCVDD whilst we need it.
    
    Additionally, since the commit 4f0216409f7c ("mfd: arizona: Add better
    support for system suspend"), the PM runtime operations may
    disable/enable the IRQ, so the IRQs must now be enabled before we call
    any PM operations.
    
    This patch adds a call to pm_runtime_set_active to inform the PM core
    that the device is starting up active and moves the PM enabling to
    around the IRQ initialisation to avoid any PM callbacks happening until
    the IRQs are initialised.
    
    Cc: stable@vger.kernel.org # v3.5+
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e60bcd901d02..a72ddb295078 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1141,10 +1141,6 @@ int arizona_dev_init(struct arizona *arizona)
 			     arizona->pdata.gpio_defaults[i]);
 	}
 
-	pm_runtime_set_autosuspend_delay(arizona->dev, 100);
-	pm_runtime_use_autosuspend(arizona->dev);
-	pm_runtime_enable(arizona->dev);
-
 	/* Chip default */
 	if (!arizona->pdata.clk32k_src)
 		arizona->pdata.clk32k_src = ARIZONA_32KZ_MCLK2;
@@ -1245,11 +1241,17 @@ int arizona_dev_init(struct arizona *arizona)
 					   arizona->pdata.spk_fmt[i]);
 	}
 
+	pm_runtime_set_active(arizona->dev);
+	pm_runtime_enable(arizona->dev);
+
 	/* Set up for interrupts */
 	ret = arizona_irq_init(arizona);
 	if (ret != 0)
 		goto err_reset;
 
+	pm_runtime_set_autosuspend_delay(arizona->dev, 100);
+	pm_runtime_use_autosuspend(arizona->dev);
+
 	arizona_request_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, "CLKGEN error",
 			    arizona_clkgen_err, arizona);
 	arizona_request_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, "Overclocked",
@@ -1278,10 +1280,6 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_irq;
 	}
 
-#ifdef CONFIG_PM
-	regulator_disable(arizona->dcvdd);
-#endif
-
 	return 0;
 
 err_irq:

commit 111509294b9efafe0353423c8180e03db810bdb5
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Sun Jun 14 15:41:49 2015 +0100

    mfd: arizona: Fix race between runtime suspend and IRQs
    
    The function arizona_irq_thread (the threaded handler for the arizona
    IRQs) calls pm_runtime_get_sync at the start to ensure that the chip is
    active as we handle the IRQ. If the chip is part way through a runtime
    suspend when an IRQ arrives the PM core will wait for the suspend to
    complete, before resuming. However, since commit 4f0216409f7c
    ("mfd: arizona: Add better support for system suspend") the runtime
    suspend function may call disable_irq, if the chip is going to fully
    power off, which will try to wait for any outstanding IRQs to complete.
    This results in deadlock as the IRQ thread is waiting for the PM
    operation to complete and the PM thread is waiting for the IRQ to
    complete.
    
    To avoid this situation we use disable_irq_nosync, which allows the
    suspending thread to finish the suspend without waiting for the IRQ to
    complete. This is safe because if an IRQ is being processed it can only
    be blocked at the pm_runtime_get_sync at the start of the handler
    otherwise it wouldn't be possible to suspend.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index bebf58a06a6b..e60bcd901d02 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -651,7 +651,7 @@ static int arizona_runtime_suspend(struct device *dev)
 
 		arizona->has_fully_powered_off = true;
 
-		disable_irq(arizona->irq);
+		disable_irq_nosync(arizona->irq);
 		arizona_enable_reset(arizona);
 		regulator_bulk_disable(arizona->num_core_supplies,
 				       arizona->core_supplies);

commit 8019ff6cfc0440415fcfb6352c58c3951e6ab053
Author: Nariman Poushin <nariman@opensource.wolfsonmicro.com>
Date:   Thu Jul 16 16:36:21 2015 +0100

    regmap: Use reg_sequence for multi_reg_write / register_patch
    
    Separate the functionality using sequences of register writes from the
    functions that take register defaults. This change renames the arguments
    in order to support the extension of reg_sequence to take an optional
    delay to be applied after any given register in a sequence is written.
    This avoids adding an int to all register defaults, which could
    substantially increase memory usage for regmaps with large default tables.
    
    This also updates all the clients of multi_reg_write/register_patch.
    
    Signed-off-by: Nariman Poushin <nariman@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index bebf58a06a6b..66d50be11960 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -392,7 +392,7 @@ static int wm5102_apply_hardware_patch(struct arizona *arizona)
  * Register patch to some of the CODECs internal write sequences
  * to ensure a clean exit from the low power sleep state.
  */
-static const struct reg_default wm5110_sleep_patch[] = {
+static const struct reg_sequence wm5110_sleep_patch[] = {
 	{ 0x337A, 0xC100 },
 	{ 0x337B, 0x0041 },
 	{ 0x3300, 0xA210 },

commit fc027d138b79537e5353f3d3bad2bcaac787cd17
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Fri May 1 16:15:12 2015 +0100

    mfd: arizona: Split INx_MODE into two fields
    
    Later arizona silicon has the single/differential selector
    in a different register, and IN1_MODE only selects between
    analogue or digital. Prepare for this by splitting the
    INx_MODE definition into two fields.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index cb8a1b2f07f1..bebf58a06a6b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1206,12 +1206,16 @@ int arizona_dev_init(struct arizona *arizona)
 		/* Default for both is 0 so noop with defaults */
 		val = arizona->pdata.dmic_ref[i]
 			<< ARIZONA_IN1_DMIC_SUP_SHIFT;
-		val |= arizona->pdata.inmode[i] << ARIZONA_IN1_MODE_SHIFT;
+		if (arizona->pdata.inmode[i] & ARIZONA_INMODE_DMIC)
+			val |= 1 << ARIZONA_IN1_MODE_SHIFT;
+		if (arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)
+			val |= 1 << ARIZONA_IN1_SINGLE_ENDED_SHIFT;
 
 		regmap_update_bits(arizona->regmap,
 				   ARIZONA_IN1L_CONTROL + (i * 8),
 				   ARIZONA_IN1_DMIC_SUP_MASK |
-				   ARIZONA_IN1_MODE_MASK, val);
+				   ARIZONA_IN1_MODE_MASK |
+				   ARIZONA_IN1_SINGLE_ENDED_MASK, val);
 	}
 
 	for (i = 0; i < ARIZONA_MAX_OUTPUT; i++) {

commit 121c075c1f845c2e75d61a4e7aac92d05d2def6e
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:10 2015 +0100

    mfd: wm5110: Add delay before releasing reset line
    
    On the wm5110 it is important the reset line is held for slightly longer
    to ensure the device starts up well. This patch adds a 5mS delay for
    this.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4f38ce654558..cb8a1b2f07f1 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -259,6 +259,16 @@ static inline void arizona_enable_reset(struct arizona *arizona)
 static void arizona_disable_reset(struct arizona *arizona)
 {
 	if (arizona->pdata.reset) {
+		switch (arizona->type) {
+		case WM5110:
+		case WM8280:
+			/* Meet requirements for minimum reset duration */
+			msleep(5);
+			break;
+		default:
+			break;
+		}
+
 		gpio_set_value_cansleep(arizona->pdata.reset, 1);
 		msleep(1);
 	}

commit e6cb73410a6db70eab266f15b7e25053a45b842d
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:09 2015 +0100

    mfd: arizona: Add better support for system suspend
    
    Allow the chip to completely power off if we enter runtime suspend and
    there is no jack detection active. This is helpful for systems where
    system suspend might remove the supplies to the CODEC, without informing
    us. Note the powering off is done in runtime suspend rather than system
    suspend, because we need to hold reset until the first time DCVDD is
    powered anyway (which would be in runtime resume), and we might as well
    save the extra power.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 93024acc145e..4f38ce654558 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -442,12 +442,33 @@ static int arizona_runtime_resume(struct device *dev)
 
 	dev_dbg(arizona->dev, "Leaving AoD mode\n");
 
+	if (arizona->has_fully_powered_off) {
+		dev_dbg(arizona->dev, "Re-enabling core supplies\n");
+
+		ret = regulator_bulk_enable(arizona->num_core_supplies,
+					    arizona->core_supplies);
+		if (ret) {
+			dev_err(dev, "Failed to enable core supplies: %d\n",
+				ret);
+			return ret;
+		}
+	}
+
 	ret = regulator_enable(arizona->dcvdd);
 	if (ret != 0) {
 		dev_err(arizona->dev, "Failed to enable DCVDD: %d\n", ret);
+		if (arizona->has_fully_powered_off)
+			regulator_bulk_disable(arizona->num_core_supplies,
+					       arizona->core_supplies);
 		return ret;
 	}
 
+	if (arizona->has_fully_powered_off) {
+		arizona_disable_reset(arizona);
+		enable_irq(arizona->irq);
+		arizona->has_fully_powered_off = false;
+	}
+
 	regcache_cache_only(arizona->regmap, false);
 
 	switch (arizona->type) {
@@ -508,6 +529,14 @@ static int arizona_runtime_resume(struct device *dev)
 				goto err;
 			}
 		}
+
+		ret = wm5110_apply_sleep_patch(arizona);
+		if (ret) {
+			dev_err(arizona->dev,
+				"Failed to re-apply sleep patch: %d\n",
+				ret);
+			goto err;
+		}
 		break;
 	default:
 		ret = arizona_wait_for_boot(arizona);
@@ -545,10 +574,17 @@ static int arizona_runtime_resume(struct device *dev)
 static int arizona_runtime_suspend(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
+	unsigned int val;
 	int ret;
 
 	dev_dbg(arizona->dev, "Entering AoD mode\n");
 
+	ret = regmap_read(arizona->regmap, ARIZONA_JACK_DETECT_ANALOGUE, &val);
+	if (ret) {
+		dev_err(dev, "Failed to check jack det status: %d\n", ret);
+		return ret;
+	}
+
 	if (arizona->external_dcvdd) {
 		ret = regmap_update_bits(arizona->regmap,
 					 ARIZONA_ISOLATION_CONTROL,
@@ -559,33 +595,58 @@ static int arizona_runtime_suspend(struct device *dev)
 				ret);
 			return ret;
 		}
-	} else {
-		switch (arizona->type) {
-		case WM5110:
-		case WM8280:
-			/*
-			 * As this is only called for the internal regulator
-			 * (where we know voltage ranges available) it is ok
-			 * to request an exact range.
-			 */
-			ret = regulator_set_voltage(arizona->dcvdd,
-						    1175000, 1175000);
-			if (ret < 0) {
+	}
+
+	switch (arizona->type) {
+	case WM5110:
+	case WM8280:
+		if (arizona->external_dcvdd)
+			break;
+
+		/*
+		 * As this is only called for the internal regulator
+		 * (where we know voltage ranges available) it is ok
+		 * to request an exact range.
+		 */
+		ret = regulator_set_voltage(arizona->dcvdd, 1175000, 1175000);
+		if (ret < 0) {
+			dev_err(arizona->dev,
+				"Failed to set suspend voltage: %d\n", ret);
+			return ret;
+		}
+		break;
+	case WM5102:
+		if (!(val & ARIZONA_JD1_ENA)) {
+			ret = regmap_write(arizona->regmap,
+					   ARIZONA_WRITE_SEQUENCER_CTRL_3, 0x0);
+			if (ret) {
 				dev_err(arizona->dev,
-					"Failed to set suspend voltage: %d\n",
+					"Failed to clear write sequencer: %d\n",
 					ret);
 				return ret;
 			}
-			break;
-		default:
-			break;
 		}
+		break;
+	default:
+		break;
 	}
 
 	regcache_cache_only(arizona->regmap, true);
 	regcache_mark_dirty(arizona->regmap);
 	regulator_disable(arizona->dcvdd);
 
+	/* Allow us to completely power down if no jack detection */
+	if (!(val & ARIZONA_JD1_ENA)) {
+		dev_dbg(arizona->dev, "Fully powering off\n");
+
+		arizona->has_fully_powered_off = true;
+
+		disable_irq(arizona->irq);
+		arizona_enable_reset(arizona);
+		regulator_bulk_disable(arizona->num_core_supplies,
+				       arizona->core_supplies);
+	}
+
 	return 0;
 }
 #endif

commit 96129a0eaa3f5232f433812972c7bf38004ebf6b
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:08 2015 +0100

    mfd: wm5110: Set DCVDD voltage to 1.175V before entering sleep mode
    
    The low power sleep mode on wm5110 requires that the LDO1 regulator be
    set to 1.175V prior to entering sleep, then returned to 1.2V after
    exiting sleep mode. This patch apply these regulator settings.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index c80ab7910615..93024acc145e 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -478,6 +478,37 @@ static int arizona_runtime_resume(struct device *dev)
 			goto err;
 		}
 		break;
+	case WM5110:
+	case WM8280:
+		ret = arizona_wait_for_boot(arizona);
+		if (ret)
+			goto err;
+
+		if (arizona->external_dcvdd) {
+			ret = regmap_update_bits(arizona->regmap,
+						 ARIZONA_ISOLATION_CONTROL,
+						 ARIZONA_ISOLATE_DCVDD1, 0);
+			if (ret) {
+				dev_err(arizona->dev,
+					"Failed to connect DCVDD: %d\n", ret);
+				goto err;
+			}
+		} else {
+			/*
+			 * As this is only called for the internal regulator
+			 * (where we know voltage ranges available) it is ok
+			 * to request an exact range.
+			 */
+			ret = regulator_set_voltage(arizona->dcvdd,
+						    1200000, 1200000);
+			if (ret < 0) {
+				dev_err(arizona->dev,
+					"Failed to set resume voltage: %d\n",
+					ret);
+				goto err;
+			}
+		}
+		break;
 	default:
 		ret = arizona_wait_for_boot(arizona);
 		if (ret != 0) {
@@ -528,6 +559,27 @@ static int arizona_runtime_suspend(struct device *dev)
 				ret);
 			return ret;
 		}
+	} else {
+		switch (arizona->type) {
+		case WM5110:
+		case WM8280:
+			/*
+			 * As this is only called for the internal regulator
+			 * (where we know voltage ranges available) it is ok
+			 * to request an exact range.
+			 */
+			ret = regulator_set_voltage(arizona->dcvdd,
+						    1175000, 1175000);
+			if (ret < 0) {
+				dev_err(arizona->dev,
+					"Failed to set suspend voltage: %d\n",
+					ret);
+				return ret;
+			}
+			break;
+		default:
+			break;
+		}
 	}
 
 	regcache_cache_only(arizona->regmap, true);

commit 882bc46813177640cfe01fb4f9b3e7af60201512
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:06 2015 +0100

    mfd: wm5110: Add register patch required for low power sleep
    
    Some register settings must be applied before the first time low power
    sleep mode is entered on the wm5110 to ensure optimium performance.
    These settings require SYSCLK to be enabled whilst they are being
    applied. This patch applies the settings using the recently factored out
    boot time SYSCLK functionality.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b5a7e0efcf3e..c80ab7910615 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -378,6 +378,35 @@ static int wm5102_apply_hardware_patch(struct arizona *arizona)
 	return ret ?: err;
 }
 
+/*
+ * Register patch to some of the CODECs internal write sequences
+ * to ensure a clean exit from the low power sleep state.
+ */
+static const struct reg_default wm5110_sleep_patch[] = {
+	{ 0x337A, 0xC100 },
+	{ 0x337B, 0x0041 },
+	{ 0x3300, 0xA210 },
+	{ 0x3301, 0x050C },
+};
+
+static int wm5110_apply_sleep_patch(struct arizona *arizona)
+{
+	struct arizona_sysclk_state state;
+	int err, ret;
+
+	ret = arizona_enable_freerun_sysclk(arizona, &state);
+	if (ret)
+		return ret;
+
+	ret = regmap_multi_reg_write_bypassed(arizona->regmap,
+					      wm5110_sleep_patch,
+					      ARRAY_SIZE(wm5110_sleep_patch));
+
+	err = arizona_disable_freerun_sysclk(arizona, &state);
+
+	return ret ?: err;
+}
+
 static int wm5102_clear_write_sequencer(struct arizona *arizona)
 {
 	int ret;
@@ -966,6 +995,16 @@ int arizona_dev_init(struct arizona *arizona)
 				goto err_reset;
 			}
 			break;
+		case WM5110:
+		case WM8280:
+			ret = wm5110_apply_sleep_patch(arizona);
+			if (ret) {
+				dev_err(arizona->dev,
+					"Failed to apply sleep patch: %d\n",
+					ret);
+				goto err_reset;
+			}
+			break;
 		default:
 			break;
 		}

commit 3850e3ee86c90e22767907fbd7505a717300c533
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:05 2015 +0100

    mfd: arizona: Factor out SYSCLK enable from wm5102 hardware patch
    
    wm5102 applies a custom hardware boot sequence, for this the SYSCLK
    needs to be enabled. This patch factors out the code that enables
    SYSCLK for this sequence such that it can be used for other boot time
    operations that require SYSCLK.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 326a4afdd832..b5a7e0efcf3e 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -264,19 +264,25 @@ static void arizona_disable_reset(struct arizona *arizona)
 	}
 }
 
-static int wm5102_apply_hardware_patch(struct arizona *arizona)
+struct arizona_sysclk_state {
+	unsigned int fll;
+	unsigned int sysclk;
+};
+
+static int arizona_enable_freerun_sysclk(struct arizona *arizona,
+					 struct arizona_sysclk_state *state)
 {
-	unsigned int fll, sysclk;
 	int ret, err;
 
 	/* Cache existing FLL and SYSCLK settings */
-	ret = regmap_read(arizona->regmap, ARIZONA_FLL1_CONTROL_1, &fll);
+	ret = regmap_read(arizona->regmap, ARIZONA_FLL1_CONTROL_1, &state->fll);
 	if (ret) {
 		dev_err(arizona->dev, "Failed to cache FLL settings: %d\n",
 			ret);
 		return ret;
 	}
-	ret = regmap_read(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, &sysclk);
+	ret = regmap_read(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1,
+			  &state->sysclk);
 	if (ret) {
 		dev_err(arizona->dev, "Failed to cache SYSCLK settings: %d\n",
 			ret);
@@ -306,14 +312,58 @@ static int wm5102_apply_hardware_patch(struct arizona *arizona)
 		goto err_fll;
 	}
 
+	return 0;
+
+err_fll:
+	err = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, state->fll);
+	if (err)
+		dev_err(arizona->dev,
+			"Failed to re-apply old FLL settings: %d\n", err);
+
+	return ret;
+}
+
+static int arizona_disable_freerun_sysclk(struct arizona *arizona,
+					  struct arizona_sysclk_state *state)
+{
+	int ret;
+
+	ret = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1,
+			   state->sysclk);
+	if (ret) {
+		dev_err(arizona->dev,
+			"Failed to re-apply old SYSCLK settings: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, state->fll);
+	if (ret) {
+		dev_err(arizona->dev,
+			"Failed to re-apply old FLL settings: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int wm5102_apply_hardware_patch(struct arizona *arizona)
+{
+	struct arizona_sysclk_state state;
+	int err, ret;
+
+	ret = arizona_enable_freerun_sysclk(arizona, &state);
+	if (ret)
+		return ret;
+
 	/* Start the write sequencer and wait for it to finish */
 	ret = regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,
 			   ARIZONA_WSEQ_ENA | ARIZONA_WSEQ_START | 160);
 	if (ret) {
 		dev_err(arizona->dev, "Failed to start write sequencer: %d\n",
 			ret);
-		goto err_sysclk;
+		goto err;
 	}
+
 	ret = arizona_poll_reg(arizona, 5, ARIZONA_WRITE_SEQUENCER_CTRL_1,
 			       ARIZONA_WSEQ_BUSY, 0);
 	if (ret) {
@@ -322,21 +372,8 @@ static int wm5102_apply_hardware_patch(struct arizona *arizona)
 		ret = -ETIMEDOUT;
 	}
 
-err_sysclk:
-	err = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, sysclk);
-	if (err) {
-		dev_err(arizona->dev,
-			"Failed to re-apply old SYSCLK settings: %d\n",
-			err);
-	}
-
-err_fll:
-	err = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, fll);
-	if (err) {
-		dev_err(arizona->dev,
-			"Failed to re-apply old FLL settings: %d\n",
-			err);
-	}
+err:
+	err = arizona_disable_freerun_sysclk(arizona, &state);
 
 	return ret ?: err;
 }

commit 0be068a077a06fa3382ab6d8d290078967bb8f64
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:04 2015 +0100

    mfd: arizona: Fix formating/style issues in arizona_apply_hardware_patch
    
    In preparation for some refactoring fixup some minor style, formating
    and code clarity issues.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 0df12995ed1b..326a4afdd832 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -264,20 +264,20 @@ static void arizona_disable_reset(struct arizona *arizona)
 	}
 }
 
-static int arizona_apply_hardware_patch(struct arizona* arizona)
+static int wm5102_apply_hardware_patch(struct arizona *arizona)
 {
 	unsigned int fll, sysclk;
 	int ret, err;
 
 	/* Cache existing FLL and SYSCLK settings */
 	ret = regmap_read(arizona->regmap, ARIZONA_FLL1_CONTROL_1, &fll);
-	if (ret != 0) {
+	if (ret) {
 		dev_err(arizona->dev, "Failed to cache FLL settings: %d\n",
 			ret);
 		return ret;
 	}
 	ret = regmap_read(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, &sysclk);
-	if (ret != 0) {
+	if (ret) {
 		dev_err(arizona->dev, "Failed to cache SYSCLK settings: %d\n",
 			ret);
 		return ret;
@@ -286,7 +286,7 @@ static int arizona_apply_hardware_patch(struct arizona* arizona)
 	/* Start up SYSCLK using the FLL in free running mode */
 	ret = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1,
 			ARIZONA_FLL1_ENA | ARIZONA_FLL1_FREERUN);
-	if (ret != 0) {
+	if (ret) {
 		dev_err(arizona->dev,
 			"Failed to start FLL in freerunning mode: %d\n",
 			ret);
@@ -295,36 +295,36 @@ static int arizona_apply_hardware_patch(struct arizona* arizona)
 	ret = arizona_poll_reg(arizona, 25, ARIZONA_INTERRUPT_RAW_STATUS_5,
 			       ARIZONA_FLL1_CLOCK_OK_STS,
 			       ARIZONA_FLL1_CLOCK_OK_STS);
-	if (ret != 0) {
+	if (ret) {
 		ret = -ETIMEDOUT;
 		goto err_fll;
 	}
 
 	ret = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, 0x0144);
-	if (ret != 0) {
+	if (ret) {
 		dev_err(arizona->dev, "Failed to start SYSCLK: %d\n", ret);
 		goto err_fll;
 	}
 
 	/* Start the write sequencer and wait for it to finish */
 	ret = regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,
-			ARIZONA_WSEQ_ENA | ARIZONA_WSEQ_START | 160);
-	if (ret != 0) {
+			   ARIZONA_WSEQ_ENA | ARIZONA_WSEQ_START | 160);
+	if (ret) {
 		dev_err(arizona->dev, "Failed to start write sequencer: %d\n",
 			ret);
 		goto err_sysclk;
 	}
 	ret = arizona_poll_reg(arizona, 5, ARIZONA_WRITE_SEQUENCER_CTRL_1,
 			       ARIZONA_WSEQ_BUSY, 0);
-	if (ret != 0) {
+	if (ret) {
 		regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,
-				ARIZONA_WSEQ_ABORT);
+			     ARIZONA_WSEQ_ABORT);
 		ret = -ETIMEDOUT;
 	}
 
 err_sysclk:
 	err = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, sysclk);
-	if (err != 0) {
+	if (err) {
 		dev_err(arizona->dev,
 			"Failed to re-apply old SYSCLK settings: %d\n",
 			err);
@@ -332,16 +332,13 @@ static int arizona_apply_hardware_patch(struct arizona* arizona)
 
 err_fll:
 	err = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, fll);
-	if (err != 0) {
+	if (err) {
 		dev_err(arizona->dev,
 			"Failed to re-apply old FLL settings: %d\n",
 			err);
 	}
 
-	if (ret != 0)
-		return ret;
-	else
-		return err;
+	return ret ?: err;
 }
 
 static int wm5102_clear_write_sequencer(struct arizona *arizona)
@@ -407,8 +404,8 @@ static int arizona_runtime_resume(struct device *dev)
 			goto err;
 		}
 
-		ret = arizona_apply_hardware_patch(arizona);
-		if (ret != 0) {
+		ret = wm5102_apply_hardware_patch(arizona);
+		if (ret) {
 			dev_err(arizona->dev,
 				"Failed to apply hardware patch: %d\n",
 				ret);
@@ -924,8 +921,8 @@ int arizona_dev_init(struct arizona *arizona)
 
 		switch (arizona->type) {
 		case WM5102:
-			ret = arizona_apply_hardware_patch(arizona);
-			if (ret != 0) {
+			ret = wm5102_apply_hardware_patch(arizona);
+			if (ret) {
 				dev_err(arizona->dev,
 					"Failed to apply hardware patch: %d\n",
 					ret);

commit 1c1c6bba57f51331f64f32d0ce9a0f9883041205
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:03 2015 +0100

    mfd: wm5102: Ensure we always boot the device fully
    
    The wm5102 uses a custom boot sequence and the standard boot sequence is
    disabled. However, the standard boot sequence must be run at least once
    after a cold boot (caused by either a hard reset or removal of AVDD).
    Unfortunately the register WRITE_SEQUENCER_CTRL_3 is not affected by the
    hardware reset. This means if the device has been previously booted but
    the AVDD supply has never been removed, arizona_dev_init will reset the
    chip but the boot sequence will not run, which can cause numerous
    problems. The solution is to manually clear this register and then boot
    the chip again, which is what this patch does.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index f30d92538584..0df12995ed1b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -344,6 +344,33 @@ static int arizona_apply_hardware_patch(struct arizona* arizona)
 		return err;
 }
 
+static int wm5102_clear_write_sequencer(struct arizona *arizona)
+{
+	int ret;
+
+	ret = regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_3,
+			   0x0);
+	if (ret) {
+		dev_err(arizona->dev,
+			"Failed to clear write sequencer state: %d\n", ret);
+		return ret;
+	}
+
+	arizona_enable_reset(arizona);
+	regulator_disable(arizona->dcvdd);
+
+	msleep(20);
+
+	ret = regulator_enable(arizona->dcvdd);
+	if (ret) {
+		dev_err(arizona->dev, "Failed to re-enable DCVDD: %d\n", ret);
+		return ret;
+	}
+	arizona_disable_reset(arizona);
+
+	return 0;
+}
+
 #ifdef CONFIG_PM
 static int arizona_runtime_resume(struct device *dev)
 {
@@ -802,21 +829,24 @@ int arizona_dev_init(struct arizona *arizona)
 	case WM5102:
 		ret = regmap_read(arizona->regmap,
 				  ARIZONA_WRITE_SEQUENCER_CTRL_3, &val);
-		if (ret != 0)
+		if (ret) {
 			dev_err(dev,
 				"Failed to check write sequencer state: %d\n",
 				ret);
-		else if (val & 0x01)
-			break;
-		/* Fall through */
-	default:
-		ret = arizona_wait_for_boot(arizona);
-		if (ret != 0) {
-			dev_err(arizona->dev,
-				"Device failed initial boot: %d\n", ret);
-			goto err_reset;
+		} else if (val & 0x01) {
+			ret = wm5102_clear_write_sequencer(arizona);
+			if (ret)
+				return ret;
 		}
 		break;
+	default:
+		break;
+	}
+
+	ret = arizona_wait_for_boot(arizona);
+	if (ret) {
+		dev_err(arizona->dev, "Device failed initial boot: %d\n", ret);
+		goto err_reset;
 	}
 
 	/* Read the device ID information & do device specific stuff */

commit 2229875dc00f38b95d04fecfc67858ba2221a563
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:02 2015 +0100

    mfd: arizona: Factor out hard reset into helper functions
    
    This patch adds functions for enabling and disabling the physical reset
    line. This will be helpful in future refactoring.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 915cc28585d2..f30d92538584 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -250,6 +250,20 @@ static int arizona_wait_for_boot(struct arizona *arizona)
 	return ret;
 }
 
+static inline void arizona_enable_reset(struct arizona *arizona)
+{
+	if (arizona->pdata.reset)
+		gpio_set_value_cansleep(arizona->pdata.reset, 0);
+}
+
+static void arizona_disable_reset(struct arizona *arizona)
+{
+	if (arizona->pdata.reset) {
+		gpio_set_value_cansleep(arizona->pdata.reset, 1);
+		msleep(1);
+	}
+}
+
 static int arizona_apply_hardware_patch(struct arizona* arizona)
 {
 	unsigned int fll, sysclk;
@@ -751,10 +765,7 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_enable;
 	}
 
-	if (arizona->pdata.reset) {
-		gpio_set_value_cansleep(arizona->pdata.reset, 1);
-		msleep(1);
-	}
+	arizona_disable_reset(arizona);
 
 	regcache_cache_only(arizona->regmap, false);
 
@@ -1046,8 +1057,7 @@ int arizona_dev_init(struct arizona *arizona)
 err_irq:
 	arizona_irq_exit(arizona);
 err_reset:
-	if (arizona->pdata.reset)
-		gpio_set_value_cansleep(arizona->pdata.reset, 0);
+	arizona_enable_reset(arizona);
 	regulator_disable(arizona->dcvdd);
 err_enable:
 	regulator_bulk_disable(arizona->num_core_supplies,
@@ -1072,8 +1082,7 @@ int arizona_dev_exit(struct arizona *arizona)
 	arizona_free_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, arizona);
 	arizona_free_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, arizona);
 	arizona_irq_exit(arizona);
-	if (arizona->pdata.reset)
-		gpio_set_value_cansleep(arizona->pdata.reset, 0);
+	arizona_enable_reset(arizona);
 
 	regulator_bulk_disable(arizona->num_core_supplies,
 			       arizona->core_supplies);

commit 5f056bf04201dc533f5d10acf028435ede0a1442
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 11 13:58:01 2015 +0100

    mfd: arizona: Use devres to manage reset GPIO
    
    This also handily fixes a leak of the GPIO in arizona_dev_exit.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index aed43a549f77..915cc28585d2 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -728,9 +728,9 @@ int arizona_dev_init(struct arizona *arizona)
 
 	if (arizona->pdata.reset) {
 		/* Start out with /RESET low to put the chip into reset */
-		ret = gpio_request_one(arizona->pdata.reset,
-				       GPIOF_DIR_OUT | GPIOF_INIT_LOW,
-				       "arizona /RESET");
+		ret = devm_gpio_request_one(arizona->dev, arizona->pdata.reset,
+					    GPIOF_DIR_OUT | GPIOF_INIT_LOW,
+					    "arizona /RESET");
 		if (ret != 0) {
 			dev_err(dev, "Failed to request /RESET: %d\n", ret);
 			goto err_dcvdd;
@@ -1046,10 +1046,8 @@ int arizona_dev_init(struct arizona *arizona)
 err_irq:
 	arizona_irq_exit(arizona);
 err_reset:
-	if (arizona->pdata.reset) {
+	if (arizona->pdata.reset)
 		gpio_set_value_cansleep(arizona->pdata.reset, 0);
-		gpio_free(arizona->pdata.reset);
-	}
 	regulator_disable(arizona->dcvdd);
 err_enable:
 	regulator_bulk_disable(arizona->num_core_supplies,

commit b375e9f90ff8dc645c9d6a57f08d59f0db6aaab3
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Apr 22 14:34:48 2015 +0100

    mfd: arizona: Remove redundant register sync
    
    This soft reset used to be located after the register patch had been
    applied, but has since moved to before the patch is applied. At the new
    location there is no requirement to do a register sync as no register
    writes will have happened yet.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 6ca6dfab50eb..aed43a549f77 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -777,8 +777,6 @@ int arizona_dev_init(struct arizona *arizona)
 
 	/* If we have a /RESET GPIO we'll already be reset */
 	if (!arizona->pdata.reset) {
-		regcache_mark_dirty(arizona->regmap);
-
 		ret = regmap_write(arizona->regmap, ARIZONA_SOFTWARE_RESET, 0);
 		if (ret != 0) {
 			dev_err(dev, "Failed to reset device: %d\n", ret);
@@ -786,12 +784,6 @@ int arizona_dev_init(struct arizona *arizona)
 		}
 
 		msleep(1);
-
-		ret = regcache_sync(arizona->regmap);
-		if (ret != 0) {
-			dev_err(dev, "Failed to sync device: %d\n", ret);
-			goto err_reset;
-		}
 	}
 
 	/* Ensure device startup is complete */

commit e7ad27cac94c6eb609d43b0f968dce8ff804fa7c
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Mar 3 15:04:53 2015 +0000

    mfd: arizona: Add DT binding for the DMIC reference voltages
    
    Add a DT binding that lets the DMIC reference voltage source be
    specified for each input.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 9f819989683b..6ca6dfab50eb 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -561,6 +561,16 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 		count++;
 	}
 
+	count = 0;
+	of_property_for_each_u32(arizona->dev->of_node, "wlf,dmic-ref", prop,
+				 cur, val) {
+		if (count == ARRAY_SIZE(arizona->pdata.dmic_ref))
+			break;
+
+		arizona->pdata.dmic_ref[count] = val;
+		count++;
+	}
+
 	return 0;
 }
 

commit e5d4ef0d731664b3fe204f4e5e87f5756e848fb1
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Sat Jan 17 15:21:22 2015 +0000

    mfd: arizona: Add support for WM8280/WM8281
    
    This adds support for the Wolfson Microelectronics WM8280 and WM8281
    codecs.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    [Lee: Minor fixup to remove potentially uninitialised variable. ]
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 09ba8f186e6a..9f819989683b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -567,6 +567,7 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 const struct of_device_id arizona_of_match[] = {
 	{ .compatible = "wlf,wm5102", .data = (void *)WM5102 },
 	{ .compatible = "wlf,wm5110", .data = (void *)WM5110 },
+	{ .compatible = "wlf,wm8280", .data = (void *)WM8280 },
 	{ .compatible = "wlf,wm8997", .data = (void *)WM8997 },
 	{},
 };
@@ -671,6 +672,7 @@ int arizona_dev_init(struct arizona *arizona)
 	switch (arizona->type) {
 	case WM5102:
 	case WM5110:
+	case WM8280:
 	case WM8997:
 		for (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)
 			arizona->core_supplies[i].supply
@@ -834,11 +836,19 @@ int arizona_dev_init(struct arizona *arizona)
 #endif
 #ifdef CONFIG_MFD_WM5110
 	case 0x5110:
-		type_name = "WM5110";
-		if (arizona->type != WM5110) {
+		switch (arizona->type) {
+		case WM5110:
+			type_name = "WM5110";
+			break;
+		case WM8280:
+			type_name = "WM8280";
+			break;
+		default:
+			type_name = "WM5110";
 			dev_err(arizona->dev, "WM5110 registered as %d\n",
 				arizona->type);
 			arizona->type = WM5110;
+			break;
 		}
 		apply_patch = wm5110_patch;
 		break;
@@ -1010,6 +1020,7 @@ int arizona_dev_init(struct arizona *arizona)
 				      ARRAY_SIZE(wm5102_devs), NULL, 0, NULL);
 		break;
 	case WM5110:
+	case WM8280:
 		ret = mfd_add_devices(arizona->dev, -1, wm5110_devs,
 				      ARRAY_SIZE(wm5110_devs), NULL, 0, NULL);
 		break;

commit 48bb9fe4b3b361570f3619086a22d9bf9dd4c980
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 5 03:04:12 2014 +0100

    MFD / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so #ifdef blocks
    depending on CONFIG_PM_RUNTIME may now be changed to depend on
    CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM everywhere under
    drivers/mfd/.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index bce7c0784b6b..09ba8f186e6a 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -330,7 +330,7 @@ static int arizona_apply_hardware_patch(struct arizona* arizona)
 		return err;
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int arizona_runtime_resume(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
@@ -1024,7 +1024,7 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_irq;
 	}
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 	regulator_disable(arizona->dcvdd);
 #endif
 

commit 71d134b9fa3b435649aca893f79811afc7e4f1f1
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Sep 24 10:37:11 2014 +0100

    mfd: arizona: Correct mask to allow setting micbias external cap
    
    Currently the mask for the external capacitor bit is missing when
    writing the MICBIAS config meaning it will never be set this patch fixes
    this.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 72b3202c6674..bce7c0784b6b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -947,6 +947,7 @@ int arizona_dev_init(struct arizona *arizona)
 		regmap_update_bits(arizona->regmap,
 				   ARIZONA_MIC_BIAS_CTRL_1 + i,
 				   ARIZONA_MICB1_LVL_MASK |
+				   ARIZONA_MICB1_EXT_CAP |
 				   ARIZONA_MICB1_DISCH |
 				   ARIZONA_MICB1_BYPASS |
 				   ARIZONA_MICB1_RATE, val);

commit 7be180cc7a0c5768a984126d9468afc82dcf93a2
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Sep 24 10:37:10 2014 +0100

    Revert "mfd: wm5102: Manually apply register patch"
    
    This reverts commit d9d03496f6f904a3588bdb8b215853bc4e50132c.
    
    It seems this commit was applied twice, once through ASoC and once
    through MFD:
    
    commit 4c9bb8bc352a14c9613c77bc3f1e9038cd086b9b
    mfd: wm5102: Manually apply register patch
    
    commit d9d03496f6f904a3588bdb8b215853bc4e50132c
    mfd: wm5102: Manually apply register patch
    
    This has lead to a small piece of duplicate code. It is harmless hence
    how it has gone unoticed for so long. This patch reverts one of the two
    commits removing the unneeded code.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 4afb232b5cde..72b3202c6674 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -393,18 +393,6 @@ static int arizona_runtime_resume(struct device *dev)
 		break;
 	}
 
-	switch (arizona->type) {
-	case WM5102:
-		ret = wm5102_patch(arizona);
-		if (ret != 0) {
-			dev_err(arizona->dev, "Failed to apply patch: %d\n",
-				ret);
-			goto err;
-		}
-	default:
-		break;
-	}
-
 	ret = regcache_sync(arizona->regmap);
 	if (ret != 0) {
 		dev_err(arizona->dev, "Failed to restore register cache\n");

commit cc47aed9a1ef8eadd7bf14e32117896777b5cc41
Author: Inha Song <ideal.song@samsung.com>
Date:   Sat Aug 30 11:27:18 2014 +0900

    mfd: arizona: Add support for INn_Mode register control
    
    Some boards need to set the INn_MODE[1:0] register to change
    the input signal patch. This wlf,inmode property is optional.
    If present, values must be specified less than or equal to
    the number of input singals. If values less than the number
    of input signals, elements that has not been specifed are set
    to 0 by default.
    
    Example:
       - wlf,inmode = <2 0 2>;      /* IN1, IN3 use DMIC */
    
    Signed-off-by: Inha Song <ideal.song@samsung.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 7eabc36b97c1..4afb232b5cde 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -534,7 +534,11 @@ EXPORT_SYMBOL_GPL(arizona_of_get_named_gpio);
 static int arizona_of_get_core_pdata(struct arizona *arizona)
 {
 	struct arizona_pdata *pdata = &arizona->pdata;
+	struct property *prop;
+	const __be32 *cur;
+	u32 val;
 	int ret, i;
+	int count = 0;
 
 	pdata->reset = arizona_of_get_named_gpio(arizona, "wlf,reset", true);
 
@@ -560,6 +564,15 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 			ret);
 	}
 
+	of_property_for_each_u32(arizona->dev->of_node, "wlf,inmode", prop,
+				 cur, val) {
+		if (count == ARRAY_SIZE(arizona->pdata.inmode))
+			break;
+
+		arizona->pdata.inmode[count] = val;
+		count++;
+	}
+
 	return 0;
 }
 

commit 48018943eb906d81e48f40675c17b92abfeafcf1
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Aug 13 11:42:46 2014 +0100

    mfd: wm5102: Mark register write sequencer control 3 readable
    
    During init the core checks if the wm5102 has finished starting by reading
    register 0x19 and looking at the value. This read always fails since this
    is not a readable register, mark it as being one. While we're at it provide
    a constant for the register name (as supplied by Charles Keepax).
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 10a0cb90619a..7eabc36b97c1 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -784,7 +784,8 @@ int arizona_dev_init(struct arizona *arizona)
 	/* Ensure device startup is complete */
 	switch (arizona->type) {
 	case WM5102:
-		ret = regmap_read(arizona->regmap, 0x19, &val);
+		ret = regmap_read(arizona->regmap,
+				  ARIZONA_WRITE_SEQUENCER_CTRL_3, &val);
 		if (ret != 0)
 			dev_err(dev,
 				"Failed to check write sequencer state: %d\n",

commit 6e440d27aa2212c714c8b061dea2d64cff0bc482
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Jul 15 11:21:49 2014 +0100

    mfd: arizona: Add missing handling for ISRC3 under/overclocked
    
    Some parts have a third ISRC, this patch adds handling for the under and
    overclocked interrupts from this ISRC.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index cf3689f7e984..10a0cb90619a 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -123,6 +123,8 @@ static irqreturn_t arizona_underclocked(int irq, void *data)
 		dev_err(arizona->dev, "AIF2 underclocked\n");
 	if (val & ARIZONA_AIF1_UNDERCLOCKED_STS)
 		dev_err(arizona->dev, "AIF1 underclocked\n");
+	if (val & ARIZONA_ISRC3_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "ISRC3 underclocked\n");
 	if (val & ARIZONA_ISRC2_UNDERCLOCKED_STS)
 		dev_err(arizona->dev, "ISRC2 underclocked\n");
 	if (val & ARIZONA_ISRC1_UNDERCLOCKED_STS)
@@ -192,6 +194,8 @@ static irqreturn_t arizona_overclocked(int irq, void *data)
 		dev_err(arizona->dev, "ASRC sync WARP overclocked\n");
 	if (val[1] & ARIZONA_ADSP2_1_OVERCLOCKED_STS)
 		dev_err(arizona->dev, "DSP1 overclocked\n");
+	if (val[1] & ARIZONA_ISRC3_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ISRC3 overclocked\n");
 	if (val[1] & ARIZONA_ISRC2_OVERCLOCKED_STS)
 		dev_err(arizona->dev, "ISRC2 overclocked\n");
 	if (val[1] & ARIZONA_ISRC1_OVERCLOCKED_STS)

commit 5fc6c39653f1c34de3f2357d50ba5baff6b6e482
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Fri Jul 25 16:24:44 2014 +0100

    mfd: arizona: Map MICVDD from extcon device to the Arizona core
    
    The extcon driver should be able to get its regulator against rather
    than against the main arizona device, we must add a supply mapping
    allowing the regulator to be located. This patch does so.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e0d415efb24d..cf3689f7e984 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -578,17 +578,21 @@ static const struct mfd_cell early_devs[] = {
 };
 
 static const char *wm5102_supplies[] = {
+	"MICVDD",
 	"DBVDD2",
 	"DBVDD3",
 	"CPVDD",
 	"SPKVDDL",
 	"SPKVDDR",
-	"MICVDD",
 };
 
 static const struct mfd_cell wm5102_devs[] = {
 	{ .name = "arizona-micsupp" },
-	{ .name = "arizona-extcon" },
+	{
+		.name = "arizona-extcon",
+		.parent_supplies = wm5102_supplies,
+		.num_parent_supplies = 1, /* We only need MICVDD */
+	},
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
@@ -601,7 +605,11 @@ static const struct mfd_cell wm5102_devs[] = {
 
 static const struct mfd_cell wm5110_devs[] = {
 	{ .name = "arizona-micsupp" },
-	{ .name = "arizona-extcon" },
+	{
+		.name = "arizona-extcon",
+		.parent_supplies = wm5102_supplies,
+		.num_parent_supplies = 1, /* We only need MICVDD */
+	},
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
@@ -621,7 +629,11 @@ static const char *wm8997_supplies[] = {
 
 static const struct mfd_cell wm8997_devs[] = {
 	{ .name = "arizona-micsupp" },
-	{ .name = "arizona-extcon" },
+	{
+		.name = "arizona-extcon",
+		.parent_supplies = wm8997_supplies,
+		.num_parent_supplies = 1, /* We only need MICVDD */
+	},
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },

commit 996c2d4f5834402daabd126bbbc55fd7683d558d
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Fri Jul 25 16:24:43 2014 +0100

    mfd: arizona: Add MICVDD to mapped regulators for wm8997
    
    The previous update adding MICVDD to the regulator mappings:
    
    mfd: arizona: Add MICVDD to mapped regulators
    
    Only added the mapping for wm5102 and wm5110 but wm8997 also has a
    MICVDD supply that needs to be mapped back to the main Arizona device.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e9c3563766a6..e0d415efb24d 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -613,6 +613,7 @@ static const struct mfd_cell wm5110_devs[] = {
 };
 
 static const char *wm8997_supplies[] = {
+	"MICVDD",
 	"DBVDD2",
 	"CPVDD",
 	"SPKVDD",

commit 942786e6e647cef94cf96dcd836d343be55fc452
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Jul 2 14:28:46 2014 +0100

    mfd: arizona: Rid data size incompatibility warn when building for 64bit
    
    Extinguishes:
    
    ../drivers/mfd/arizona-core.c: In function ‘arizona_of_get_type’:
    ../drivers/mfd/arizona-core.c:505:10:
            warning: cast from pointer to integer of different size
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b4f22e7b87f2..e9c3563766a6 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -497,12 +497,12 @@ const struct dev_pm_ops arizona_pm_ops = {
 EXPORT_SYMBOL_GPL(arizona_pm_ops);
 
 #ifdef CONFIG_OF
-int arizona_of_get_type(struct device *dev)
+unsigned long arizona_of_get_type(struct device *dev)
 {
 	const struct of_device_id *id = of_match_device(arizona_of_match, dev);
 
 	if (id)
-		return (int)id->data;
+		return (unsigned long)id->data;
 	else
 		return 0;
 }

commit 0c2d0ffbb8e485b632871e0cb5e67f04ac4fb559
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Jun 19 16:04:23 2014 +0100

    mfd: arizona: Add comment to explain non-devm regulator_get
    
    To avoid someone attempting to change this regulator_get back into a
    devm_regulator_get put a comment in explaining that devres can't be used
    here as the regulator will be destroyed before devres calls
    regulator_put.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 27936fe89434..b4f22e7b87f2 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -683,6 +683,12 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_early;
 	}
 
+	/**
+	 * Don't use devres here because the only device we have to get
+	 * against is the MFD device and DCVDD will likely be supplied by
+	 * one of its children. Meaning that the regulator will be
+	 * destroyed by the time devres calls regulator put.
+	 */
 	arizona->dcvdd = regulator_get(arizona->dev, "DCVDD");
 	if (IS_ERR(arizona->dcvdd)) {
 		ret = PTR_ERR(arizona->dcvdd);

commit 4420286e047e087f5879a1c652653808b32717db
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Jun 2 09:50:42 2014 +0100

    mfd: arizona: Use num_core_supplies in arizona_dev_exit
    
    Currently we call regulator_bulk_disable with
    ARRAY_SIZE(arizona->core_supplies), however this array may be larger
    than the number of supplies actually used by the chip we are dealing
    with. Use the provided num_core_supplies member instead, so that we only
    disable supplies which actually exist.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index fee6a1ee3a0f..27936fe89434 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1038,7 +1038,7 @@ int arizona_dev_exit(struct arizona *arizona)
 	if (arizona->pdata.reset)
 		gpio_set_value_cansleep(arizona->pdata.reset, 0);
 
-	regulator_bulk_disable(ARRAY_SIZE(arizona->core_supplies),
+	regulator_bulk_disable(arizona->num_core_supplies,
 			       arizona->core_supplies);
 	return 0;
 }

commit e6021511f11e71d0e77e5c31f5b0722a80c3545c
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Jun 2 09:50:41 2014 +0100

    mfd: arizona: Don't use devres for DCVDD
    
    Currently the Arizona core uses a devm_regulator_get against its own
    device node to obtain DCVDD. The Arizona core is an MFD device and DCVDD
    is usually supplied by a child node (arizona-ldo1) of the core. As
    devres destruction for the MFD device will run after all its children
    have been destroyed, the regulator will be destroyed before devres
    calls regulator_put. This causes a warning from both the destruction of
    the child node, as the regulator is still open, and from the put of the
    regulator as the regulator device has already been destroyed.
    
    This patch handles the regulator get and put without devres to avoid
    this issue.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 9df02502326a..fee6a1ee3a0f 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -683,7 +683,7 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_early;
 	}
 
-	arizona->dcvdd = devm_regulator_get(arizona->dev, "DCVDD");
+	arizona->dcvdd = regulator_get(arizona->dev, "DCVDD");
 	if (IS_ERR(arizona->dcvdd)) {
 		ret = PTR_ERR(arizona->dcvdd);
 		dev_err(dev, "Failed to request DCVDD: %d\n", ret);
@@ -697,7 +697,7 @@ int arizona_dev_init(struct arizona *arizona)
 				       "arizona /RESET");
 		if (ret != 0) {
 			dev_err(dev, "Failed to request /RESET: %d\n", ret);
-			goto err_early;
+			goto err_dcvdd;
 		}
 	}
 
@@ -706,7 +706,7 @@ int arizona_dev_init(struct arizona *arizona)
 	if (ret != 0) {
 		dev_err(dev, "Failed to enable core supplies: %d\n",
 			ret);
-		goto err_early;
+		goto err_dcvdd;
 	}
 
 	ret = regulator_enable(arizona->dcvdd);
@@ -1015,6 +1015,8 @@ int arizona_dev_init(struct arizona *arizona)
 err_enable:
 	regulator_bulk_disable(arizona->num_core_supplies,
 			       arizona->core_supplies);
+err_dcvdd:
+	regulator_put(arizona->dcvdd);
 err_early:
 	mfd_remove_devices(dev);
 	return ret;
@@ -1026,6 +1028,7 @@ int arizona_dev_exit(struct arizona *arizona)
 	pm_runtime_disable(arizona->dev);
 
 	regulator_disable(arizona->dcvdd);
+	regulator_put(arizona->dcvdd);
 
 	mfd_remove_devices(arizona->dev);
 	arizona_free_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, arizona);

commit df6b3352d88560459d4a4926b36409334332f2cb
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Jun 2 09:50:40 2014 +0100

    mfd: arizona: Disable DCVDD before we destroy the MFD
    
    As DCVDD is probably supplied by a child of the MFD device move its
    disable to before we destroy the MFD children as the regulator likely
    won't exist after that.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 9d71ebccc8b0..9df02502326a 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1025,6 +1025,8 @@ int arizona_dev_exit(struct arizona *arizona)
 {
 	pm_runtime_disable(arizona->dev);
 
+	regulator_disable(arizona->dcvdd);
+
 	mfd_remove_devices(arizona->dev);
 	arizona_free_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, arizona);
 	arizona_free_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, arizona);
@@ -1032,7 +1034,7 @@ int arizona_dev_exit(struct arizona *arizona)
 	arizona_irq_exit(arizona);
 	if (arizona->pdata.reset)
 		gpio_set_value_cansleep(arizona->pdata.reset, 0);
-	regulator_disable(arizona->dcvdd);
+
 	regulator_bulk_disable(ARRAY_SIZE(arizona->core_supplies),
 			       arizona->core_supplies);
 	return 0;

commit b804020adadae5ebe82850bd82e29f224d044164
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Jun 2 09:50:39 2014 +0100

    mfd: arizona: Disable PM runtime at start of driver removal
    
    We don't want to trigger any PM runtime operations whilst we are tearing
    down the driver, as things the suspend and resume callbacks rely on
    might already have been destroyed. So disable PM runtime for the device
    as the first step arizona_dev_exit.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index cfc191abae4a..9d71ebccc8b0 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -1023,11 +1023,12 @@ EXPORT_SYMBOL_GPL(arizona_dev_init);
 
 int arizona_dev_exit(struct arizona *arizona)
 {
+	pm_runtime_disable(arizona->dev);
+
 	mfd_remove_devices(arizona->dev);
 	arizona_free_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, arizona);
 	arizona_free_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, arizona);
 	arizona_free_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, arizona);
-	pm_runtime_disable(arizona->dev);
 	arizona_irq_exit(arizona);
 	if (arizona->pdata.reset)
 		gpio_set_value_cansleep(arizona->pdata.reset, 0);

commit 058c89019ff029ca0ac45d94397c4d979c93cf4a
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon May 19 17:35:27 2014 +0100

    mfd: arizona: Add MICVDD to mapped regulators
    
    Currently, MICVDD only binds because it is both the regulator name and
    the consumer name and we will always match against the regulator name
    regardless of the consumer device. If the regulator was renamed using
    the init_data ASoC will no longer be able to locate the supply, as it
    will be looking on the CODEC device where as the MICVDD consumer is on
    the Arizona device. Add a mapping as we do for the other regulators.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 07e6e27be23c..cfc191abae4a 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -583,6 +583,7 @@ static const char *wm5102_supplies[] = {
 	"CPVDD",
 	"SPKVDDL",
 	"SPKVDDR",
+	"MICVDD",
 };
 
 static const struct mfd_cell wm5102_devs[] = {

commit 4a8c475f5fd5c1271dba36a453d666d5ed473aa6
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Apr 16 10:01:38 2014 +0100

    regulator: arizona-ldo1: Move setup processing from arizona-core
    
    It is more idiomatic to process things relating to the regulator in its
    driver. This patch moves both processing of device tree relating to the
    regulator and checking if the regulator is external from arizona-core
    into the regulator driver.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 37b5e1447d02..07e6e27be23c 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -533,7 +533,6 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 	int ret, i;
 
 	pdata->reset = arizona_of_get_named_gpio(arizona, "wlf,reset", true);
-	pdata->ldoena = arizona_of_get_named_gpio(arizona, "wlf,ldoena", true);
 
 	ret = of_property_read_u32_array(arizona->dev->of_node,
 					 "wlf,gpio-defaults",
@@ -665,6 +664,9 @@ int arizona_dev_init(struct arizona *arizona)
 		return -EINVAL;
 	}
 
+	/* Mark DCVDD as external, LDO1 driver will clear if internal */
+	arizona->external_dcvdd = true;
+
 	ret = mfd_add_devices(arizona->dev, -1, early_devs,
 			      ARRAY_SIZE(early_devs), NULL, 0, NULL);
 	if (ret != 0) {
@@ -864,14 +866,6 @@ int arizona_dev_init(struct arizona *arizona)
 			     arizona->pdata.gpio_defaults[i]);
 	}
 
-	/*
-	 * LDO1 can only be used to supply DCVDD so if it has no
-	 * consumers then DCVDD is supplied externally.
-	 */
-	if (arizona->pdata.ldo1 &&
-	    arizona->pdata.ldo1->num_consumer_supplies == 0)
-		arizona->external_dcvdd = true;
-
 	pm_runtime_set_autosuspend_delay(arizona->dev, 100);
 	pm_runtime_use_autosuspend(arizona->dev);
 	pm_runtime_enable(arizona->dev);

commit e4fcb1d6148284a10c314fce2a488cf19ce886f6
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Apr 16 10:01:37 2014 +0100

    mfd: arizona: Factor out read of device tree GPIOs
    
    This patch factors out the reading of GPIOs for the Arizona devices
    into a helper function.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 1c3ae57082ed..37b5e1447d02 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -508,19 +508,32 @@ int arizona_of_get_type(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(arizona_of_get_type);
 
+int arizona_of_get_named_gpio(struct arizona *arizona, const char *prop,
+			      bool mandatory)
+{
+	int gpio;
+
+	gpio = of_get_named_gpio(arizona->dev->of_node, prop, 0);
+	if (gpio < 0) {
+		if (mandatory)
+			dev_err(arizona->dev,
+				"Mandatory DT gpio %s missing/malformed: %d\n",
+				prop, gpio);
+
+		gpio = 0;
+	}
+
+	return gpio;
+}
+EXPORT_SYMBOL_GPL(arizona_of_get_named_gpio);
+
 static int arizona_of_get_core_pdata(struct arizona *arizona)
 {
+	struct arizona_pdata *pdata = &arizona->pdata;
 	int ret, i;
 
-	arizona->pdata.reset = of_get_named_gpio(arizona->dev->of_node,
-						 "wlf,reset", 0);
-	if (arizona->pdata.reset < 0)
-		arizona->pdata.reset = 0;
-
-	arizona->pdata.ldoena = of_get_named_gpio(arizona->dev->of_node,
-						  "wlf,ldoena", 0);
-	if (arizona->pdata.ldoena < 0)
-		arizona->pdata.ldoena = 0;
+	pdata->reset = arizona_of_get_named_gpio(arizona, "wlf,reset", true);
+	pdata->ldoena = arizona_of_get_named_gpio(arizona, "wlf,ldoena", true);
 
 	ret = of_property_read_u32_array(arizona->dev->of_node,
 					 "wlf,gpio-defaults",

commit 1c18d2ca104c36fc2ce147cce053c62f61d2ea68
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Feb 25 13:45:52 2014 +0000

    mfd: arizona: Use new regmap features for manual register patch
    
    On the wm5102 the register patches are applied manually, rather than by
    the regmap core. This application is wrapped in calls to
    regcache_cache_bypass. However, this is dangerous as other threads may
    be accessing the hardware at the same time as the pm_runtime operations
    and if they do so during the period whilst cache_bypass is enabled those
    writes will miss the cache when they shouldn't.
    
    Apply the register patch using the new regmap_multi_reg_write_bypassed
    function to avoid this problem. Also remove the call to
    regcache_cache_bypass from the hardware patch application as it is
    unneeded there and creates a similar window for writes to miss the
    cache.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index a45aab9f6bb1..1c3ae57082ed 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -251,8 +251,6 @@ static int arizona_apply_hardware_patch(struct arizona* arizona)
 	unsigned int fll, sysclk;
 	int ret, err;
 
-	regcache_cache_bypass(arizona->regmap, true);
-
 	/* Cache existing FLL and SYSCLK settings */
 	ret = regmap_read(arizona->regmap, ARIZONA_FLL1_CONTROL_1, &fll);
 	if (ret != 0) {
@@ -322,8 +320,6 @@ static int arizona_apply_hardware_patch(struct arizona* arizona)
 			err);
 	}
 
-	regcache_cache_bypass(arizona->regmap, false);
-
 	if (ret != 0)
 		return ret;
 	else

commit 5ac98553afe41ffb5513fa8aac6df699a70231a3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Nov 18 14:33:06 2013 +0100

    mfd: Constify struct mfd_cell where possible
    
    As of commit 03e361b25ee8dfb1fd9b890072c23c4aae01c6c7 ("mfd: Stop setting
    refcounting pointers in original mfd_cell arrays"), the "cell" parameter of
    mfd_add_devices() is "const" again. Hence make all cell data passed to
    mfd_add_devices() const where possible.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 75e180ceecf3..a45aab9f6bb1 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -565,7 +565,7 @@ static inline int arizona_of_get_core_pdata(struct arizona *arizona)
 }
 #endif
 
-static struct mfd_cell early_devs[] = {
+static const struct mfd_cell early_devs[] = {
 	{ .name = "arizona-ldo1" },
 };
 
@@ -577,7 +577,7 @@ static const char *wm5102_supplies[] = {
 	"SPKVDDR",
 };
 
-static struct mfd_cell wm5102_devs[] = {
+static const struct mfd_cell wm5102_devs[] = {
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
@@ -590,7 +590,7 @@ static struct mfd_cell wm5102_devs[] = {
 	},
 };
 
-static struct mfd_cell wm5110_devs[] = {
+static const struct mfd_cell wm5110_devs[] = {
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
@@ -609,7 +609,7 @@ static const char *wm8997_supplies[] = {
 	"SPKVDD",
 };
 
-static struct mfd_cell wm8997_devs[] = {
+static const struct mfd_cell wm8997_devs[] = {
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },

commit db0b2d01163cc3050eb52a979541e0d16553be48
Merge: 16cd9d1c0f14 90b128ed1557
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 15 16:37:40 2013 -0800

    Merge tag 'mfd-3.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sameo/mfd-next
    
    Pull MFD updates from Samuel Ortiz:
     "For the 3.13 merge window we have a couple of new drivers for the AMS
      AS3722 PMIC and for STMicroelectronics STw481x PMIC.
    
      Although this is a smaller update than usual, we also have:
    
       - Device tree support for the max77693 driver
    
       - linux/of.h inclusion for all DT compatible MFD drivers, to avoid
         build breakage in the future
    
       - Support for Intel Wildcat Point-LP PCH through the lpc_ich driver
    
       - A small arizona update for new wm5110 DSP registers and a few fixes
    
       - A small palmas update as well, including an of_device table
         addition and a few minor fixes
    
       - Two small mfd-core changes, one including a memory leak fix for
         when mfd_add_device() fails
    
       - Our usual round of minor cleanups and janitorial fixes"
    
    * tag 'mfd-3.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sameo/mfd-next: (63 commits)
      Documentation: mfd: Update s2mps11.txt
      mfd: pm8921: Potential NULL dereference in pm8921_remove()
      mfd: Fix memory leak in mfd_add_devices()
      mfd: Stop setting refcounting pointers in original mfd_cell arrays
      mfd: wm5110: Enable micd clamp functionality
      mfd: lpc_ich: Add Device IDs for Intel Wildcat Point-LP PCH
      mfd: max77693: Fix up bug of wrong interrupt number
      mfd: as3722: Don't export the regmap config
      mfd: twl6040: Remove obsolete cleanup for i2c clientdata
      mfd: tps65910: Remove warning during dt node parsing
      mfd: lpc_sch: Ignore resource conflicts when adding mfd cells
      mfd: ti_am335x_tscadc: Avoid possible deadlock of reg_lock
      mfd: syscon: Return -ENOSYS if CONFIG_MFD_SYSCON is not enabled
      mfd: Add support for ams AS3722 PMIC
      mfd: max77693: Include linux/of.h header
      mfd: tc3589x: Detect the precise version
      mfd: omap-usb: prepare/unprepare clock while enable/disable
      mfd: max77686: Include linux/of.h header
      mfd: max8907: Include linux/of.h header
      mfd: max8997: Include linux/of.h header
      ...

commit 91c739359ac9946a8e74a9640527a3f1034a76a7
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Oct 3 16:16:01 2013 +0100

    mfd: arizona: Correct handling of device tree gpio defaults
    
    When setting GPIO defaults we are required to make a distinction
    between writing 0x0000 to the registers and leaving them untouched.
    
    When we receive between 0x0000 and 0xFFFF (inclusive) from either
    Platform Data or Device Tree, we should write the provided
    configuration to the device. Conversely, when we receive >0xFFFF we
    should leave the device configuration at its default setting.
    
    This patch fixes a bug and ensures that configuration 0x0000 isn't
    mistakenly written when the intention was to keep the default one.
    
    Reported-by: Heather Lomond <heather.lomond@wolfsonmicro.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index a2f5beff99d7..ba808b744238 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -540,7 +540,7 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 		for (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {
 			if (arizona->pdata.gpio_defaults[i] > 0xffff)
 				arizona->pdata.gpio_defaults[i] = 0;
-			if (arizona->pdata.gpio_defaults[i] == 0)
+			else if (arizona->pdata.gpio_defaults[i] == 0)
 				arizona->pdata.gpio_defaults[i] = 0x10000;
 		}
 	} else {

commit 22d7dc8aba3bf34fdf324f43718c238075cc7cf7
Author: Lee Jones <lee.jones@linaro.org>
Date:   Fri Sep 27 14:25:55 2013 +0100

    mfd: arizona: Only attempt to parse DT if platform data was not passed
    
    If platform data is passed when probing the device then it should take
    precedence over Device Tree. This patch saves cycles in the pdata case
    and prevents error messages when DT is not passed.
    
    Reported-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 5ac3aa48473b..a2f5beff99d7 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -607,11 +607,11 @@ int arizona_dev_init(struct arizona *arizona)
 	dev_set_drvdata(arizona->dev, arizona);
 	mutex_init(&arizona->clk_lock);
 
-	arizona_of_get_core_pdata(arizona);
-
 	if (dev_get_platdata(arizona->dev))
 		memcpy(&arizona->pdata, dev_get_platdata(arizona->dev),
 		       sizeof(arizona->pdata));
+	else
+		arizona_of_get_core_pdata(arizona);
 
 	regcache_cache_only(arizona->regmap, true);
 

commit 32dadef2190efd2e06331825b11881daf100d6d9
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Oct 15 20:14:22 2013 +0100

    mfd: arizona: Specify supply mappings for Arizona CODECs
    
    The CODEC power supplies should be looked up on the Arizona device as
    they will be created here by device tree also update the only user of
    non-device tree bindings.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 5ac3aa48473b..022b1863d36c 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -569,13 +569,25 @@ static struct mfd_cell early_devs[] = {
 	{ .name = "arizona-ldo1" },
 };
 
+static const char *wm5102_supplies[] = {
+	"DBVDD2",
+	"DBVDD3",
+	"CPVDD",
+	"SPKVDDL",
+	"SPKVDDR",
+};
+
 static struct mfd_cell wm5102_devs[] = {
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
-	{ .name = "wm5102-codec" },
+	{
+		.name = "wm5102-codec",
+		.parent_supplies = wm5102_supplies,
+		.num_parent_supplies = ARRAY_SIZE(wm5102_supplies),
+	},
 };
 
 static struct mfd_cell wm5110_devs[] = {
@@ -584,7 +596,17 @@ static struct mfd_cell wm5110_devs[] = {
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
-	{ .name = "wm5110-codec" },
+	{
+		.name = "wm5110-codec",
+		.parent_supplies = wm5102_supplies,
+		.num_parent_supplies = ARRAY_SIZE(wm5102_supplies),
+	},
+};
+
+static const char *wm8997_supplies[] = {
+	"DBVDD2",
+	"CPVDD",
+	"SPKVDD",
 };
 
 static struct mfd_cell wm8997_devs[] = {
@@ -593,7 +615,11 @@ static struct mfd_cell wm8997_devs[] = {
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
 	{ .name = "arizona-pwm" },
-	{ .name = "wm8997-codec" },
+	{
+		.name = "wm8997-codec",
+		.parent_supplies = wm8997_supplies,
+		.num_parent_supplies = ARRAY_SIZE(wm8997_supplies),
+	},
 };
 
 int arizona_dev_init(struct arizona *arizona)

commit e293e847275b2d1a4768ca25f0933a70b2383016
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Aug 6 17:18:35 2013 +0100

    mfd: arizona: Move regulator disable to after marking cache only
    
    If we disable DCVDD before we mark the cache as cache only, we might
    attempt to write to the chip whilst it is powered down and lose a write.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 89a115301a0c..5ac3aa48473b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -438,9 +438,9 @@ static int arizona_runtime_suspend(struct device *dev)
 		}
 	}
 
-	regulator_disable(arizona->dcvdd);
 	regcache_cache_only(arizona->regmap, true);
 	regcache_mark_dirty(arizona->regmap);
+	regulator_disable(arizona->dcvdd);
 
 	return 0;
 }

commit dc7d48635dd3c3fd5360238f7d2c697ff13abe7b
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Jun 13 09:43:29 2013 +0100

    mfd: arizona: Integrate wm8997 into Arizona mfd
    
    The wm8997 is a compact, high-performance audio hub CODEC with SLIMbus
    interfacing, for smartphones, tablets and other portable audio devices
    based on the Arizona platform.
    
    This patch integrates the wm8997 into the Arizona mfd.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 74b4481754fd..89a115301a0c 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -554,6 +554,7 @@ static int arizona_of_get_core_pdata(struct arizona *arizona)
 const struct of_device_id arizona_of_match[] = {
 	{ .compatible = "wlf,wm5102", .data = (void *)WM5102 },
 	{ .compatible = "wlf,wm5110", .data = (void *)WM5110 },
+	{ .compatible = "wlf,wm8997", .data = (void *)WM8997 },
 	{},
 };
 EXPORT_SYMBOL_GPL(arizona_of_match);
@@ -586,6 +587,15 @@ static struct mfd_cell wm5110_devs[] = {
 	{ .name = "wm5110-codec" },
 };
 
+static struct mfd_cell wm8997_devs[] = {
+	{ .name = "arizona-micsupp" },
+	{ .name = "arizona-extcon" },
+	{ .name = "arizona-gpio" },
+	{ .name = "arizona-haptics" },
+	{ .name = "arizona-pwm" },
+	{ .name = "wm8997-codec" },
+};
+
 int arizona_dev_init(struct arizona *arizona)
 {
 	struct device *dev = arizona->dev;
@@ -608,6 +618,7 @@ int arizona_dev_init(struct arizona *arizona)
 	switch (arizona->type) {
 	case WM5102:
 	case WM5110:
+	case WM8997:
 		for (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)
 			arizona->core_supplies[i].supply
 				= wm5102_core_supplies[i];
@@ -683,6 +694,7 @@ int arizona_dev_init(struct arizona *arizona)
 	switch (reg) {
 	case 0x5102:
 	case 0x5110:
+	case 0x8997:
 		break;
 	default:
 		dev_err(arizona->dev, "Unknown device ID: %x\n", reg);
@@ -767,6 +779,17 @@ int arizona_dev_init(struct arizona *arizona)
 		}
 		apply_patch = wm5110_patch;
 		break;
+#endif
+#ifdef CONFIG_MFD_WM8997
+	case 0x8997:
+		type_name = "WM8997";
+		if (arizona->type != WM8997) {
+			dev_err(arizona->dev, "WM8997 registered as %d\n",
+				arizona->type);
+			arizona->type = WM8997;
+		}
+		apply_patch = wm8997_patch;
+		break;
 #endif
 	default:
 		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
@@ -934,6 +957,10 @@ int arizona_dev_init(struct arizona *arizona)
 		ret = mfd_add_devices(arizona->dev, -1, wm5110_devs,
 				      ARRAY_SIZE(wm5110_devs), NULL, 0, NULL);
 		break;
+	case WM8997:
+		ret = mfd_add_devices(arizona->dev, -1, wm8997_devs,
+				      ARRAY_SIZE(wm8997_devs), NULL, 0, NULL);
+		break;
 	}
 
 	if (ret != 0) {

commit f773fc6dca4619bdf8da767eaba101a83b766059
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue May 21 14:56:58 2013 +0100

    mfd: arizona: Change fast_start pdata name to better reflect functionality
    
    The bit in the register enables MICBIAS fast startup when clear not when
    set. This patch changes the name of this pdata option to soft_start to
    better match the functionality. We rename rather than invert the
    handling to keep the same default functionality, which is fast start
    active.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 437f199fe5f2..74b4481754fd 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -860,7 +860,7 @@ int arizona_dev_init(struct arizona *arizona)
 		if (arizona->pdata.micbias[i].discharge)
 			val |= ARIZONA_MICB1_DISCH;
 
-		if (arizona->pdata.micbias[i].fast_start)
+		if (arizona->pdata.micbias[i].soft_start)
 			val |= ARIZONA_MICB1_RATE;
 
 		if (arizona->pdata.micbias[i].bypass)

commit 5927467d0ca274bc3b8eed9fd5db964bbde56e1c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 23 19:44:16 2013 +0100

    mfd: arizona: Support use of external DCVDD
    
    When the device is used with an external DCVDD supply instead of the
    internal LDO1 then an extra step is required when suspending and resuming
    the device.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index d8d30c0a488d..437f199fe5f2 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -22,6 +22,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
 #include <linux/slab.h>
 
 #include <linux/mfd/arizona/core.h>
@@ -347,6 +348,17 @@ static int arizona_runtime_resume(struct device *dev)
 
 	switch (arizona->type) {
 	case WM5102:
+		if (arizona->external_dcvdd) {
+			ret = regmap_update_bits(arizona->regmap,
+						 ARIZONA_ISOLATION_CONTROL,
+						 ARIZONA_ISOLATE_DCVDD1, 0);
+			if (ret != 0) {
+				dev_err(arizona->dev,
+					"Failed to connect DCVDD: %d\n", ret);
+				goto err;
+			}
+		}
+
 		ret = wm5102_patch(arizona);
 		if (ret != 0) {
 			dev_err(arizona->dev, "Failed to apply patch: %d\n",
@@ -368,6 +380,16 @@ static int arizona_runtime_resume(struct device *dev)
 			goto err;
 		}
 
+		if (arizona->external_dcvdd) {
+			ret = regmap_update_bits(arizona->regmap,
+						 ARIZONA_ISOLATION_CONTROL,
+						 ARIZONA_ISOLATE_DCVDD1, 0);
+			if (ret != 0) {
+				dev_err(arizona->dev,
+					"Failed to connect DCVDD: %d\n", ret);
+				goto err;
+			}
+		}
 		break;
 	}
 
@@ -400,9 +422,22 @@ static int arizona_runtime_resume(struct device *dev)
 static int arizona_runtime_suspend(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
+	int ret;
 
 	dev_dbg(arizona->dev, "Entering AoD mode\n");
 
+	if (arizona->external_dcvdd) {
+		ret = regmap_update_bits(arizona->regmap,
+					 ARIZONA_ISOLATION_CONTROL,
+					 ARIZONA_ISOLATE_DCVDD1,
+					 ARIZONA_ISOLATE_DCVDD1);
+		if (ret != 0) {
+			dev_err(arizona->dev, "Failed to isolate DCVDD: %d\n",
+				ret);
+			return ret;
+		}
+	}
+
 	regulator_disable(arizona->dcvdd);
 	regcache_cache_only(arizona->regmap, true);
 	regcache_mark_dirty(arizona->regmap);
@@ -771,6 +806,14 @@ int arizona_dev_init(struct arizona *arizona)
 			     arizona->pdata.gpio_defaults[i]);
 	}
 
+	/*
+	 * LDO1 can only be used to supply DCVDD so if it has no
+	 * consumers then DCVDD is supplied externally.
+	 */
+	if (arizona->pdata.ldo1 &&
+	    arizona->pdata.ldo1->num_consumer_supplies == 0)
+		arizona->external_dcvdd = true;
+
 	pm_runtime_set_autosuspend_delay(arizona->dev, 100);
 	pm_runtime_use_autosuspend(arizona->dev);
 	pm_runtime_enable(arizona->dev);

commit d781009ca6bb5b9711c74700242855e0a70ee7a3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 25 00:11:27 2013 +0000

    mfd: Add device tree bindings for Arizona class devices
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 549db0ad7257..d8d30c0a488d 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -16,6 +16,9 @@
 #include <linux/interrupt.h>
 #include <linux/mfd/core.h>
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
@@ -462,6 +465,70 @@ const struct dev_pm_ops arizona_pm_ops = {
 };
 EXPORT_SYMBOL_GPL(arizona_pm_ops);
 
+#ifdef CONFIG_OF
+int arizona_of_get_type(struct device *dev)
+{
+	const struct of_device_id *id = of_match_device(arizona_of_match, dev);
+
+	if (id)
+		return (int)id->data;
+	else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(arizona_of_get_type);
+
+static int arizona_of_get_core_pdata(struct arizona *arizona)
+{
+	int ret, i;
+
+	arizona->pdata.reset = of_get_named_gpio(arizona->dev->of_node,
+						 "wlf,reset", 0);
+	if (arizona->pdata.reset < 0)
+		arizona->pdata.reset = 0;
+
+	arizona->pdata.ldoena = of_get_named_gpio(arizona->dev->of_node,
+						  "wlf,ldoena", 0);
+	if (arizona->pdata.ldoena < 0)
+		arizona->pdata.ldoena = 0;
+
+	ret = of_property_read_u32_array(arizona->dev->of_node,
+					 "wlf,gpio-defaults",
+					 arizona->pdata.gpio_defaults,
+					 ARRAY_SIZE(arizona->pdata.gpio_defaults));
+	if (ret >= 0) {
+		/*
+		 * All values are literal except out of range values
+		 * which are chip default, translate into platform
+		 * data which uses 0 as chip default and out of range
+		 * as zero.
+		 */
+		for (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {
+			if (arizona->pdata.gpio_defaults[i] > 0xffff)
+				arizona->pdata.gpio_defaults[i] = 0;
+			if (arizona->pdata.gpio_defaults[i] == 0)
+				arizona->pdata.gpio_defaults[i] = 0x10000;
+		}
+	} else {
+		dev_err(arizona->dev, "Failed to parse GPIO defaults: %d\n",
+			ret);
+	}
+
+	return 0;
+}
+
+const struct of_device_id arizona_of_match[] = {
+	{ .compatible = "wlf,wm5102", .data = (void *)WM5102 },
+	{ .compatible = "wlf,wm5110", .data = (void *)WM5110 },
+	{},
+};
+EXPORT_SYMBOL_GPL(arizona_of_match);
+#else
+static inline int arizona_of_get_core_pdata(struct arizona *arizona)
+{
+	return 0;
+}
+#endif
+
 static struct mfd_cell early_devs[] = {
 	{ .name = "arizona-ldo1" },
 };
@@ -495,6 +562,8 @@ int arizona_dev_init(struct arizona *arizona)
 	dev_set_drvdata(arizona->dev, arizona);
 	mutex_init(&arizona->clk_lock);
 
+	arizona_of_get_core_pdata(arizona);
+
 	if (dev_get_platdata(arizona->dev))
 		memcpy(&arizona->pdata, dev_get_platdata(arizona->dev),
 		       sizeof(arizona->pdata));

commit 67c992969172473e129984a51ceb77950a2aa16c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 10 12:40:26 2013 +0100

    mfd: arizona: Disable interrupts during suspend
    
    We aren't able to handle interrupts after the device has suspended since
    we need to runtime resume it in order to do so but the controller may not
    be available any more. Handle this in the same way as we handle a similar
    issue on resume.
    
    Reported-by: Chuansheng Liu <chuansheng.liu@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 8002e2d2f6fe..549db0ad7257 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -409,6 +409,26 @@ static int arizona_runtime_suspend(struct device *dev)
 #endif
 
 #ifdef CONFIG_PM_SLEEP
+static int arizona_suspend(struct device *dev)
+{
+	struct arizona *arizona = dev_get_drvdata(dev);
+
+	dev_dbg(arizona->dev, "Suspend, disabling IRQ\n");
+	disable_irq(arizona->irq);
+
+	return 0;
+}
+
+static int arizona_suspend_late(struct device *dev)
+{
+	struct arizona *arizona = dev_get_drvdata(dev);
+
+	dev_dbg(arizona->dev, "Late suspend, reenabling IRQ\n");
+	enable_irq(arizona->irq);
+
+	return 0;
+}
+
 static int arizona_resume_noirq(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
@@ -434,8 +454,9 @@ const struct dev_pm_ops arizona_pm_ops = {
 	SET_RUNTIME_PM_OPS(arizona_runtime_suspend,
 			   arizona_runtime_resume,
 			   NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(NULL, arizona_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(arizona_suspend, arizona_resume)
 #ifdef CONFIG_PM_SLEEP
+	.suspend_late = arizona_suspend_late,
 	.resume_noirq = arizona_resume_noirq,
 #endif
 };

commit 1d017b6b36675574ec8a6f7dbcd3fd3bec2dc03f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 26 12:16:26 2013 +0000

    mfd: arizona: Add missing cleanup on remove
    
    We'd forgotten to disable /RESET or the regulators. Practically speaking
    this code is unlikely to ever be run.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 25bfd1ec1a65..8002e2d2f6fe 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -839,6 +839,11 @@ int arizona_dev_exit(struct arizona *arizona)
 	arizona_free_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, arizona);
 	pm_runtime_disable(arizona->dev);
 	arizona_irq_exit(arizona);
+	if (arizona->pdata.reset)
+		gpio_set_value_cansleep(arizona->pdata.reset, 0);
+	regulator_disable(arizona->dcvdd);
+	regulator_bulk_disable(ARRAY_SIZE(arizona->core_supplies),
+			       arizona->core_supplies);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(arizona_dev_exit);

commit d9d03496f6f904a3588bdb8b215853bc4e50132c
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Mar 26 18:01:49 2013 +0000

    mfd: wm5102: Manually apply register patch
    
    Future updates will require us to manually apply the register patch for
    wm5102.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 81907f9fc92e..25bfd1ec1a65 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -368,6 +368,18 @@ static int arizona_runtime_resume(struct device *dev)
 		break;
 	}
 
+	switch (arizona->type) {
+	case WM5102:
+		ret = wm5102_patch(arizona);
+		if (ret != 0) {
+			dev_err(arizona->dev, "Failed to apply patch: %d\n",
+				ret);
+			goto err;
+		}
+	default:
+		break;
+	}
+
 	ret = regcache_sync(arizona->regmap);
 	if (ret != 0) {
 		dev_err(arizona->dev, "Failed to restore register cache\n");

commit ca76ceb8b9ca1466be9b6de5e4c0fb19b37417ee
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 9 16:04:35 2013 +0100

    mfd: arizona: Read the device identification information after boot
    
    Future devices may not fully report the device identification information
    until their boot sequence is complete so defer acting on these until that
    has finished.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 6ab03043fd60..81907f9fc92e 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -536,51 +536,22 @@ int arizona_dev_init(struct arizona *arizona)
 
 	regcache_cache_only(arizona->regmap, false);
 
+	/* Verify that this is a chip we know about */
 	ret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);
 	if (ret != 0) {
 		dev_err(dev, "Failed to read ID register: %d\n", ret);
 		goto err_reset;
 	}
 
-	ret = regmap_read(arizona->regmap, ARIZONA_DEVICE_REVISION,
-			  &arizona->rev);
-	if (ret != 0) {
-		dev_err(dev, "Failed to read revision register: %d\n", ret);
-		goto err_reset;
-	}
-	arizona->rev &= ARIZONA_DEVICE_REVISION_MASK;
-
 	switch (reg) {
-#ifdef CONFIG_MFD_WM5102
 	case 0x5102:
-		type_name = "WM5102";
-		if (arizona->type != WM5102) {
-			dev_err(arizona->dev, "WM5102 registered as %d\n",
-				arizona->type);
-			arizona->type = WM5102;
-		}
-		apply_patch = wm5102_patch;
-		arizona->rev &= 0x7;
-		break;
-#endif
-#ifdef CONFIG_MFD_WM5110
 	case 0x5110:
-		type_name = "WM5110";
-		if (arizona->type != WM5110) {
-			dev_err(arizona->dev, "WM5110 registered as %d\n",
-				arizona->type);
-			arizona->type = WM5110;
-		}
-		apply_patch = wm5110_patch;
 		break;
-#endif
 	default:
-		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
+		dev_err(arizona->dev, "Unknown device ID: %x\n", reg);
 		goto err_reset;
 	}
 
-	dev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');
-
 	/* If we have a /RESET GPIO we'll already be reset */
 	if (!arizona->pdata.reset) {
 		regcache_mark_dirty(arizona->regmap);
@@ -600,6 +571,7 @@ int arizona_dev_init(struct arizona *arizona)
 		}
 	}
 
+	/* Ensure device startup is complete */
 	switch (arizona->type) {
 	case WM5102:
 		ret = regmap_read(arizona->regmap, 0x19, &val);
@@ -620,6 +592,52 @@ int arizona_dev_init(struct arizona *arizona)
 		break;
 	}
 
+	/* Read the device ID information & do device specific stuff */
+	ret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);
+	if (ret != 0) {
+		dev_err(dev, "Failed to read ID register: %d\n", ret);
+		goto err_reset;
+	}
+
+	ret = regmap_read(arizona->regmap, ARIZONA_DEVICE_REVISION,
+			  &arizona->rev);
+	if (ret != 0) {
+		dev_err(dev, "Failed to read revision register: %d\n", ret);
+		goto err_reset;
+	}
+	arizona->rev &= ARIZONA_DEVICE_REVISION_MASK;
+
+	switch (reg) {
+#ifdef CONFIG_MFD_WM5102
+	case 0x5102:
+		type_name = "WM5102";
+		if (arizona->type != WM5102) {
+			dev_err(arizona->dev, "WM5102 registered as %d\n",
+				arizona->type);
+			arizona->type = WM5102;
+		}
+		apply_patch = wm5102_patch;
+		arizona->rev &= 0x7;
+		break;
+#endif
+#ifdef CONFIG_MFD_WM5110
+	case 0x5110:
+		type_name = "WM5110";
+		if (arizona->type != WM5110) {
+			dev_err(arizona->dev, "WM5110 registered as %d\n",
+				arizona->type);
+			arizona->type = WM5110;
+		}
+		apply_patch = wm5110_patch;
+		break;
+#endif
+	default:
+		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
+		goto err_reset;
+	}
+
+	dev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');
+
 	if (apply_patch) {
 		ret = apply_patch(arizona);
 		if (ret != 0) {

commit d955cba86d32e9b4b6fe7611b4c41b7bbe286183
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Apr 3 09:45:29 2013 +0100

    mfd: wm5102: Don't wait for boot when boot sequencer is disabled
    
    As we are using a custom boot sequence we don't need to wait for the
    standard boot sequence in device init when the normal write sequence is
    disabled.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 41856b4c0d17..6ab03043fd60 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -600,10 +600,24 @@ int arizona_dev_init(struct arizona *arizona)
 		}
 	}
 
-	ret = arizona_wait_for_boot(arizona);
-	if (ret != 0) {
-		dev_err(arizona->dev, "Device failed initial boot: %d\n", ret);
-		goto err_reset;
+	switch (arizona->type) {
+	case WM5102:
+		ret = regmap_read(arizona->regmap, 0x19, &val);
+		if (ret != 0)
+			dev_err(dev,
+				"Failed to check write sequencer state: %d\n",
+				ret);
+		else if (val & 0x01)
+			break;
+		/* Fall through */
+	default:
+		ret = arizona_wait_for_boot(arizona);
+		if (ret != 0) {
+			dev_err(arizona->dev,
+				"Device failed initial boot: %d\n", ret);
+			goto err_reset;
+		}
+		break;
 	}
 
 	if (apply_patch) {

commit c25feaa53cca696321540ca0f8564bf484224cac
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Apr 3 12:53:37 2013 +0100

    mfd: arizona: Wait for internal clocks to startup after reset
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index ae10af798843..41856b4c0d17 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -529,8 +529,10 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_enable;
 	}
 
-	if (arizona->pdata.reset)
+	if (arizona->pdata.reset) {
 		gpio_set_value_cansleep(arizona->pdata.reset, 1);
+		msleep(1);
+	}
 
 	regcache_cache_only(arizona->regmap, false);
 
@@ -589,6 +591,8 @@ int arizona_dev_init(struct arizona *arizona)
 			goto err_reset;
 		}
 
+		msleep(1);
+
 		ret = regcache_sync(arizona->regmap);
 		if (ret != 0) {
 			dev_err(dev, "Failed to sync device: %d\n", ret);

commit 87d3af4ac0554afc2e86069d7578f74b12f3f67a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 26 12:15:26 2013 +0000

    mfd: arizona: Hold device in reset while ramping supplies
    
    Acquire the /RESET GPIO before we enable regulators and hold the device
    in reset while the regulators power up in order to improve robustness
    during the initial power up.
    
    Also fix the error path so that the device is left in reset while we're
    at it.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 7d1abe7ce83f..ae10af798843 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -504,6 +504,17 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_early;
 	}
 
+	if (arizona->pdata.reset) {
+		/* Start out with /RESET low to put the chip into reset */
+		ret = gpio_request_one(arizona->pdata.reset,
+				       GPIOF_DIR_OUT | GPIOF_INIT_LOW,
+				       "arizona /RESET");
+		if (ret != 0) {
+			dev_err(dev, "Failed to request /RESET: %d\n", ret);
+			goto err_early;
+		}
+	}
+
 	ret = regulator_bulk_enable(arizona->num_core_supplies,
 				    arizona->core_supplies);
 	if (ret != 0) {
@@ -518,18 +529,8 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_enable;
 	}
 
-	if (arizona->pdata.reset) {
-		/* Start out with /RESET low to put the chip into reset */
-		ret = gpio_request_one(arizona->pdata.reset,
-				       GPIOF_DIR_OUT | GPIOF_INIT_LOW,
-				       "arizona /RESET");
-		if (ret != 0) {
-			dev_err(dev, "Failed to request /RESET: %d\n", ret);
-			goto err_dcvdd;
-		}
-
+	if (arizona->pdata.reset)
 		gpio_set_value_cansleep(arizona->pdata.reset, 1);
-	}
 
 	regcache_cache_only(arizona->regmap, false);
 
@@ -769,10 +770,9 @@ int arizona_dev_init(struct arizona *arizona)
 	arizona_irq_exit(arizona);
 err_reset:
 	if (arizona->pdata.reset) {
-		gpio_set_value_cansleep(arizona->pdata.reset, 1);
+		gpio_set_value_cansleep(arizona->pdata.reset, 0);
 		gpio_free(arizona->pdata.reset);
 	}
-err_dcvdd:
 	regulator_disable(arizona->dcvdd);
 err_enable:
 	regulator_bulk_disable(arizona->num_core_supplies,

commit 12bb68ed459e52187c7e70cb6dd4bfcc672cc171
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Mar 27 09:49:40 2013 +0000

    mfd: wm5102: Deactivate standard boot sequence
    
    This patch deactivates the standard, currently noop, boot sequence
    because we now have facilities in place for running a custom boot
    sequence.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index d6b40df64c4a..7d1abe7ce83f 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -342,11 +342,6 @@ static int arizona_runtime_resume(struct device *dev)
 
 	regcache_cache_only(arizona->regmap, false);
 
-	ret = arizona_wait_for_boot(arizona);
-	if (ret != 0) {
-		goto err;
-	}
-
 	switch (arizona->type) {
 	case WM5102:
 		ret = wm5102_patch(arizona);
@@ -365,6 +360,11 @@ static int arizona_runtime_resume(struct device *dev)
 		}
 		break;
 	default:
+		ret = arizona_wait_for_boot(arizona);
+		if (ret != 0) {
+			goto err;
+		}
+
 		break;
 	}
 

commit e80436bbb241abbf2168c65622fb98d9378432fa
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Mar 26 18:46:15 2013 +0000

    mfd: arizona: Add a hardware patch mechanism
    
    This patch adds facilities for apply a register patch contained within
    the chip using the write sequencer.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b09b119d4966..d6b40df64c4a 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -242,6 +242,90 @@ static int arizona_wait_for_boot(struct arizona *arizona)
 	return ret;
 }
 
+static int arizona_apply_hardware_patch(struct arizona* arizona)
+{
+	unsigned int fll, sysclk;
+	int ret, err;
+
+	regcache_cache_bypass(arizona->regmap, true);
+
+	/* Cache existing FLL and SYSCLK settings */
+	ret = regmap_read(arizona->regmap, ARIZONA_FLL1_CONTROL_1, &fll);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to cache FLL settings: %d\n",
+			ret);
+		return ret;
+	}
+	ret = regmap_read(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, &sysclk);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to cache SYSCLK settings: %d\n",
+			ret);
+		return ret;
+	}
+
+	/* Start up SYSCLK using the FLL in free running mode */
+	ret = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1,
+			ARIZONA_FLL1_ENA | ARIZONA_FLL1_FREERUN);
+	if (ret != 0) {
+		dev_err(arizona->dev,
+			"Failed to start FLL in freerunning mode: %d\n",
+			ret);
+		return ret;
+	}
+	ret = arizona_poll_reg(arizona, 25, ARIZONA_INTERRUPT_RAW_STATUS_5,
+			       ARIZONA_FLL1_CLOCK_OK_STS,
+			       ARIZONA_FLL1_CLOCK_OK_STS);
+	if (ret != 0) {
+		ret = -ETIMEDOUT;
+		goto err_fll;
+	}
+
+	ret = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, 0x0144);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to start SYSCLK: %d\n", ret);
+		goto err_fll;
+	}
+
+	/* Start the write sequencer and wait for it to finish */
+	ret = regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,
+			ARIZONA_WSEQ_ENA | ARIZONA_WSEQ_START | 160);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to start write sequencer: %d\n",
+			ret);
+		goto err_sysclk;
+	}
+	ret = arizona_poll_reg(arizona, 5, ARIZONA_WRITE_SEQUENCER_CTRL_1,
+			       ARIZONA_WSEQ_BUSY, 0);
+	if (ret != 0) {
+		regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,
+				ARIZONA_WSEQ_ABORT);
+		ret = -ETIMEDOUT;
+	}
+
+err_sysclk:
+	err = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, sysclk);
+	if (err != 0) {
+		dev_err(arizona->dev,
+			"Failed to re-apply old SYSCLK settings: %d\n",
+			err);
+	}
+
+err_fll:
+	err = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, fll);
+	if (err != 0) {
+		dev_err(arizona->dev,
+			"Failed to re-apply old FLL settings: %d\n",
+			err);
+	}
+
+	regcache_cache_bypass(arizona->regmap, false);
+
+	if (ret != 0)
+		return ret;
+	else
+		return err;
+}
+
 #ifdef CONFIG_PM_RUNTIME
 static int arizona_runtime_resume(struct device *dev)
 {
@@ -271,6 +355,17 @@ static int arizona_runtime_resume(struct device *dev)
 				ret);
 			goto err;
 		}
+
+		ret = arizona_apply_hardware_patch(arizona);
+		if (ret != 0) {
+			dev_err(arizona->dev,
+				"Failed to apply hardware patch: %d\n",
+				ret);
+			goto err;
+		}
+		break;
+	default:
+		break;
 	}
 
 	ret = regcache_sync(arizona->regmap);
@@ -513,6 +608,20 @@ int arizona_dev_init(struct arizona *arizona)
 				ret);
 			goto err_reset;
 		}
+
+		switch (arizona->type) {
+		case WM5102:
+			ret = arizona_apply_hardware_patch(arizona);
+			if (ret != 0) {
+				dev_err(arizona->dev,
+					"Failed to apply hardware patch: %d\n",
+					ret);
+				goto err_reset;
+			}
+			break;
+		default:
+			break;
+		}
 	}
 
 	for (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {

commit 9d53dfdc82503b819f7b854e627a555cc65224e3
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Mar 26 17:38:45 2013 +0000

    mfd: arizona: Factor out register polling
    
    Factor out the polling of the interrupt status register whilst we wait
    for boot done to allow the polling to be reused in other situations.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b71bf7ba4cfa..b09b119d4966 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -196,42 +196,50 @@ static irqreturn_t arizona_overclocked(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static int arizona_wait_for_boot(struct arizona *arizona)
+static int arizona_poll_reg(struct arizona *arizona,
+			    int timeout, unsigned int reg,
+			    unsigned int mask, unsigned int target)
 {
-	unsigned int reg;
+	unsigned int val = 0;
 	int ret, i;
 
-	/*
-	 * We can't use an interrupt as we need to runtime resume to do so,
-	 * we won't race with the interrupt handler as it'll be blocked on
-	 * runtime resume.
-	 */
-	for (i = 0; i < 5; i++) {
-		msleep(1);
-
-		ret = regmap_read(arizona->regmap,
-				  ARIZONA_INTERRUPT_RAW_STATUS_5, &reg);
+	for (i = 0; i < timeout; i++) {
+		ret = regmap_read(arizona->regmap, reg, &val);
 		if (ret != 0) {
-			dev_err(arizona->dev, "Failed to read boot state: %d\n",
-				ret);
+			dev_err(arizona->dev, "Failed to read reg %u: %d\n",
+				reg, ret);
 			continue;
 		}
 
-		if (reg & ARIZONA_BOOT_DONE_STS)
-			break;
+		if ((val & mask) == target)
+			return 0;
+
+		msleep(1);
 	}
 
-	if (reg & ARIZONA_BOOT_DONE_STS) {
+	dev_err(arizona->dev, "Polling reg %u timed out: %x\n", reg, val);
+	return -ETIMEDOUT;
+}
+
+static int arizona_wait_for_boot(struct arizona *arizona)
+{
+	int ret;
+
+	/*
+	 * We can't use an interrupt as we need to runtime resume to do so,
+	 * we won't race with the interrupt handler as it'll be blocked on
+	 * runtime resume.
+	 */
+	ret = arizona_poll_reg(arizona, 5, ARIZONA_INTERRUPT_RAW_STATUS_5,
+			       ARIZONA_BOOT_DONE_STS, ARIZONA_BOOT_DONE_STS);
+
+	if (!ret)
 		regmap_write(arizona->regmap, ARIZONA_INTERRUPT_STATUS_5,
 			     ARIZONA_BOOT_DONE_STS);
-	} else {
-		dev_err(arizona->dev, "Device boot timed out: %x\n", reg);
-		return -ETIMEDOUT;
-	}
 
 	pm_runtime_mark_last_busy(arizona->dev);
 
-	return 0;
+	return ret;
 }
 
 #ifdef CONFIG_PM_RUNTIME

commit 4c9bb8bc352a14c9613c77bc3f1e9038cd086b9b
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Mar 26 18:01:49 2013 +0000

    mfd: wm5102: Manually apply register patch
    
    Future updates will require us to manually apply the register patch for
    wm5102.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index f12057145990..b71bf7ba4cfa 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -255,6 +255,16 @@ static int arizona_runtime_resume(struct device *dev)
 		goto err;
 	}
 
+	switch (arizona->type) {
+	case WM5102:
+		ret = wm5102_patch(arizona);
+		if (ret != 0) {
+			dev_err(arizona->dev, "Failed to apply patch: %d\n",
+				ret);
+			goto err;
+		}
+	}
+
 	ret = regcache_sync(arizona->regmap);
 	if (ret != 0) {
 		dev_err(arizona->dev, "Failed to restore register cache\n");

commit c6d6bfb186add845d3f9a7f5809bc5b302579308
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 26 11:14:52 2013 +0000

    mfd: wm5102: Only use the lowest three bits of device revision
    
    Only the lowest three bits contain device revision for WM5102, the high
    bits have been repurposed.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 1eb963c5cd22..f12057145990 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -444,6 +444,7 @@ int arizona_dev_init(struct arizona *arizona)
 			arizona->type = WM5102;
 		}
 		apply_patch = wm5102_patch;
+		arizona->rev &= 0x7;
 		break;
 #endif
 #ifdef CONFIG_MFD_WM5110

commit 767c6dc032d5a28765654db20c7badf1ec6e7387
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 19 19:04:46 2013 +0100

    mfd: arizona: Unconditionally enable 32kHz clock
    
    If we have a directly provided 32kHz clock unconditionally enable it,
    substantial chip functionality relies on it so dynamic management is
    not worthwhile.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index c2c969391291..1eb963c5cd22 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -518,6 +518,7 @@ int arizona_dev_init(struct arizona *arizona)
 		regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,
 				   ARIZONA_CLK_32K_SRC_MASK,
 				   arizona->pdata.clk32k_src - 1);
+		arizona_clk32k_enable(arizona);
 		break;
 	case ARIZONA_32KZ_NONE:
 		regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,

commit 247fa1920deeb1064e36c0a34410f4d63503b3d4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 19 14:47:47 2013 +0100

    mfd: arizona: Fully support the use of MCLK1 as the 32kHz clock source
    
    MCLK1 is not in the AoD power domain so if it is used as the 32kHz clock
    source we need to hold a runtime PM reference to keep the device from going
    into low power mode.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index dd679e8601da..c2c969391291 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -39,11 +39,21 @@ int arizona_clk32k_enable(struct arizona *arizona)
 
 	arizona->clk32k_ref++;
 
-	if (arizona->clk32k_ref == 1)
+	if (arizona->clk32k_ref == 1) {
+		switch (arizona->pdata.clk32k_src) {
+		case ARIZONA_32KZ_MCLK1:
+			ret = pm_runtime_get_sync(arizona->dev);
+			if (ret != 0)
+				goto out;
+			break;
+		}
+
 		ret = regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,
 					 ARIZONA_CLK_32K_ENA,
 					 ARIZONA_CLK_32K_ENA);
+	}
 
+out:
 	if (ret != 0)
 		arizona->clk32k_ref--;
 
@@ -63,10 +73,17 @@ int arizona_clk32k_disable(struct arizona *arizona)
 
 	arizona->clk32k_ref--;
 
-	if (arizona->clk32k_ref == 0)
+	if (arizona->clk32k_ref == 0) {
 		regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,
 				   ARIZONA_CLK_32K_ENA, 0);
 
+		switch (arizona->pdata.clk32k_src) {
+		case ARIZONA_32KZ_MCLK1:
+			pm_runtime_put_sync(arizona->dev);
+			break;
+		}
+	}
+
 	mutex_unlock(&arizona->clk_lock);
 
 	return ret;

commit 544c7aadd7d4309ed01fcd787d393db67eb7eaea
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 29 18:44:41 2013 +0800

    mfd: arizona: Support configuring MICBIASes into bypass mode
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 0962c558dc02..dd679e8601da 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -514,10 +514,16 @@ int arizona_dev_init(struct arizona *arizona)
 	}
 
 	for (i = 0; i < ARIZONA_MAX_MICBIAS; i++) {
-		if (!arizona->pdata.micbias[i].mV)
+		if (!arizona->pdata.micbias[i].mV &&
+		    !arizona->pdata.micbias[i].bypass)
 			continue;
 
+		/* Apply default for bypass mode */
+		if (!arizona->pdata.micbias[i].mV)
+			arizona->pdata.micbias[i].mV = 2800;
+
 		val = (arizona->pdata.micbias[i].mV - 1500) / 100;
+
 		val <<= ARIZONA_MICB1_LVL_SHIFT;
 
 		if (arizona->pdata.micbias[i].ext_cap)
@@ -529,10 +535,14 @@ int arizona_dev_init(struct arizona *arizona)
 		if (arizona->pdata.micbias[i].fast_start)
 			val |= ARIZONA_MICB1_RATE;
 
+		if (arizona->pdata.micbias[i].bypass)
+			val |= ARIZONA_MICB1_BYPASS;
+
 		regmap_update_bits(arizona->regmap,
 				   ARIZONA_MIC_BIAS_CTRL_1 + i,
 				   ARIZONA_MICB1_LVL_MASK |
 				   ARIZONA_MICB1_DISCH |
+				   ARIZONA_MICB1_BYPASS |
 				   ARIZONA_MICB1_RATE, val);
 	}
 

commit 4816bd1c6d5589135523b4263be2e1b8b8c97599
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jan 14 15:50:38 2013 +0900

    mfd: arizona: Clean up on failed runtime resume
    
    Make sure that we don't leave the device enabled needlessly.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b562c7bf8a46..0962c558dc02 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -235,18 +235,21 @@ static int arizona_runtime_resume(struct device *dev)
 
 	ret = arizona_wait_for_boot(arizona);
 	if (ret != 0) {
-		regulator_disable(arizona->dcvdd);
-		return ret;
+		goto err;
 	}
 
 	ret = regcache_sync(arizona->regmap);
 	if (ret != 0) {
 		dev_err(arizona->dev, "Failed to restore register cache\n");
-		regulator_disable(arizona->dcvdd);
-		return ret;
+		goto err;
 	}
 
 	return 0;
+
+err:
+	regcache_cache_only(arizona->regmap, true);
+	regulator_disable(arizona->dcvdd);
+	return ret;
 }
 
 static int arizona_runtime_suspend(struct device *dev)

commit 3d91f8282c66d9edafa3980385324ce6a48edcda
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 29 00:47:37 2013 +0800

    mfd: arizona: Provide platform data for MICBIAS configuration
    
    Allow the MICBIAS voltages and other attributes to be configured by the
    platform.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 317ba0a4ea25..b562c7bf8a46 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -510,6 +510,29 @@ int arizona_dev_init(struct arizona *arizona)
 		goto err_reset;
 	}
 
+	for (i = 0; i < ARIZONA_MAX_MICBIAS; i++) {
+		if (!arizona->pdata.micbias[i].mV)
+			continue;
+
+		val = (arizona->pdata.micbias[i].mV - 1500) / 100;
+		val <<= ARIZONA_MICB1_LVL_SHIFT;
+
+		if (arizona->pdata.micbias[i].ext_cap)
+			val |= ARIZONA_MICB1_EXT_CAP;
+
+		if (arizona->pdata.micbias[i].discharge)
+			val |= ARIZONA_MICB1_DISCH;
+
+		if (arizona->pdata.micbias[i].fast_start)
+			val |= ARIZONA_MICB1_RATE;
+
+		regmap_update_bits(arizona->regmap,
+				   ARIZONA_MIC_BIAS_CTRL_1 + i,
+				   ARIZONA_MICB1_LVL_MASK |
+				   ARIZONA_MICB1_DISCH |
+				   ARIZONA_MICB1_RATE, val);
+	}
+
 	for (i = 0; i < ARIZONA_MAX_INPUT; i++) {
 		/* Default for both is 0 so noop with defaults */
 		val = arizona->pdata.dmic_ref[i]

commit 648a98808c6319dde03b64550dc64a61aaccc2b4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jan 28 00:32:53 2013 +0800

    mfd: arizona: Clarify mixer underclocking error
    
    If the mixer is underclocked it will drop a sample so log that error
    more directly.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 9c994b69b063..317ba0a4ea25 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -115,7 +115,7 @@ static irqreturn_t arizona_underclocked(int irq, void *data)
 	if (val & ARIZONA_ADC_UNDERCLOCKED_STS)
 		dev_err(arizona->dev, "ADC underclocked\n");
 	if (val & ARIZONA_MIXER_UNDERCLOCKED_STS)
-		dev_err(arizona->dev, "Mixer underclocked\n");
+		dev_err(arizona->dev, "Mixer dropped sample\n");
 
 	return IRQ_HANDLED;
 }

commit dc781d0e10fca29123ddde45429d777725c0fde5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jan 27 12:07:32 2013 +0800

    mfd: arizona: Disable interrupts during resume
    
    Runtime power management does not function during system suspend but the
    Arizona devices need to use runtime power management to power up the device
    in order to handle interrupts. Try to avoid interrupts firing during
    resume by disabling the primary IRQ before interrupts are reenabled on
    resume and only reenabling it again during main resume.
    
    The goal is to avoid issues in the situation where an interrupt is asserted
    during resume (eg, due to it being the wake source) and the interrupt
    handling gets scheduled prior to the device being able to handle runtime
    PM.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 1ab02a7d2b05..9c994b69b063 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -263,10 +263,36 @@ static int arizona_runtime_suspend(struct device *dev)
 }
 #endif
 
+#ifdef CONFIG_PM_SLEEP
+static int arizona_resume_noirq(struct device *dev)
+{
+	struct arizona *arizona = dev_get_drvdata(dev);
+
+	dev_dbg(arizona->dev, "Early resume, disabling IRQ\n");
+	disable_irq(arizona->irq);
+
+	return 0;
+}
+
+static int arizona_resume(struct device *dev)
+{
+	struct arizona *arizona = dev_get_drvdata(dev);
+
+	dev_dbg(arizona->dev, "Late resume, reenabling IRQ\n");
+	enable_irq(arizona->irq);
+
+	return 0;
+}
+#endif
+
 const struct dev_pm_ops arizona_pm_ops = {
 	SET_RUNTIME_PM_OPS(arizona_runtime_suspend,
 			   arizona_runtime_resume,
 			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(NULL, arizona_resume)
+#ifdef CONFIG_PM_SLEEP
+	.resume_noirq = arizona_resume_noirq,
+#endif
 };
 EXPORT_SYMBOL_GPL(arizona_pm_ops);
 

commit d7768111a98bcf865e1e14d8c663789f6e21393d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 20 15:38:03 2012 +0000

    mfd: arizona: Register MICVDD supply first to ensure no retries
    
    Not strictly required as probe deferral will take care of everything but
    it makes boot a little smoother.
    
    Reported-by: Ryo Tsutsui <Ryo.Tsutsui@wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 222c03a5ddc0..1ab02a7d2b05 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -275,19 +275,19 @@ static struct mfd_cell early_devs[] = {
 };
 
 static struct mfd_cell wm5102_devs[] = {
+	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
-	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-pwm" },
 	{ .name = "wm5102-codec" },
 };
 
 static struct mfd_cell wm5110_devs[] = {
+	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
 	{ .name = "arizona-haptics" },
-	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-pwm" },
 	{ .name = "wm5110-codec" },
 };

commit 9270bdf5405668ca5d75ace1d7872e2762162c47
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jan 4 17:16:12 2013 +0000

    mfd: arizona: Check errors from regcache_sync()
    
    If the control bus is unrelabile we may hit errors during regcache_sync(),
    especially given that it tends to be one the most dense bursts of I/O in
    many systems.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index bc8a3edb6bbf..222c03a5ddc0 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -239,7 +239,12 @@ static int arizona_runtime_resume(struct device *dev)
 		return ret;
 	}
 
-	regcache_sync(arizona->regmap);
+	ret = regcache_sync(arizona->regmap);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to restore register cache\n");
+		regulator_disable(arizona->dcvdd);
+		return ret;
+	}
 
 	return 0;
 }

commit 2dfea3803dcf70983d14ce1dcbb3e97a7459a28b
Merge: aed606e3bc1f 1881b68b8961
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 16 18:55:20 2012 -0800

    Merge tag 'mfd-3.8-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sameo/mfd-2.6
    
    Pull MFS update from Samuel Ortiz:
     "This is the MFD patch set for the 3.8 merge window.
    
      We have several new drivers, most of the time coming with their sub
      devices drivers:
    
       - Austria Microsystem's AS3711
       - Nano River's viperboard
       - TI's TPS80031, AM335x TS/ADC,
       - Realtek's MMC/memstick card reader
       - Nokia's retu
    
      We also got some notable cleanups and improvements:
    
       - tps6586x got converted to IRQ domains.
       - tps65910 and tps65090 moved to the regmap IRQ API.
       - STMPE is now Device Tree aware.
       - A general twl6040 and twl-core cleanup, with moves to the regmap
         I/O and IRQ APIs and a conversion to the recently added PWM
         framework.
       - sta2x11 gained regmap support.
    
      Then the rest is mostly tiny cleanups and fixes, among which we have
      Mark's wm5xxx and wm8xxx patchset."
    
    Far amount of annoying but largely trivial conflicts.  Many due to
    __devinit/exit removal, others due to one or two of the new drivers also
    having come in through another tree.
    
    * tag 'mfd-3.8-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sameo/mfd-2.6: (119 commits)
      mfd: tps6507x: Convert to devm_kzalloc
      mfd: stmpe: Update DT support for stmpe driver
      mfd: wm5102: Add readback of DSP status 3 register
      mfd: arizona: Log if we fail to create the primary IRQ domain
      mfd: tps80031: MFD_TPS80031 needs to select REGMAP_IRQ
      mfd: tps80031: Add terminating entry for tps80031_id_table
      mfd: sta2x11: Fix potential NULL pointer dereference in __sta2x11_mfd_mask()
      mfd: wm5102: Add tuning for revision B
      mfd: arizona: Defer patch initialistation until after first device boot
      mfd: tps65910: Fix wrong ack_base register
      mfd: tps65910: Remove unused data
      mfd: stmpe: Get rid of irq_invert_polarity
      mfd: ab8500-core: Fix invalid free of devm_ allocated data
      mfd: wm5102: Mark DSP memory regions as volatile
      mfd: wm5102: Correct default for LDO1_CONTROL_2
      mfd: arizona: Register haptics devices
      mfd: wm8994: Make current device behaviour the default
      mfd: tps65090: MFD_TPS65090 needs to select REGMAP_IRQ
      mfd: Fix stmpe.c build when OF is not enabled
      mfd: jz4740-adc: Use devm_kzalloc
      ...

commit 046e7d685bc370fd4c879ab6635ad3f69e6673d1
Merge: fe504c5c745a 6eb827d23577
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 11:51:23 2012 -0800

    Merge tag 'sound-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This update contains a fairly wide range of changes all over in sound
      subdirectory, mainly because of UAPI header moves by David and __dev*
      annotation removals by Bill.  Other highlights are:
    
       - Introduced the support for wallclock timestamps in ALSA PCM core
    
       - Add the poll loop implementation for HD-audio jack detection
    
       - Yet more VGA-switcheroo fixes for HD-audio
    
       - New VIA HD-audio codec support
    
       - More fixes on resource management in USB audio and MIDI drivers
    
       - More quirks for USB-audio ASUS Xonar U3, Reloop Play, Focusrite,
         Roland VG-99, etc
    
       - Add support for FastTrack C400 usb-audio
    
       - Clean ups in many drivers regarding firmware loading
    
       - Add PSC724 Ultiimate Edge support to ice1712
    
       - A few hdspm driver updates
    
       - New Stanton SCS.1d/1m FireWire driver
    
       - Standardisation of the logging in ASoC codes
    
       - DT and dmaengine support for ASoC Atmel
    
       - Support for Wolfson ADSP cores
    
       - New drivers for Freescale/iVeia P1022 and Maxim MAX98090
    
       - Lots of other ASoC driver fixes and developments"
    
    Fix up trivial conflicts.  And go out on a limb and assume the dts file
    'status' field of one of the conflicting things was supposed to be
    "disabled", not "disable" like in pretty much all other cases.
    
    * tag 'sound-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (341 commits)
      ALSA: hda - Move runtime PM check to runtime_idle callback
      ALSA: hda - Add stereo-dmic fixup for Acer Aspire One 522
      ALSA: hda - Avoid doubly suspend after vga switcheroo
      ALSA: usb-audio: Enable S/PDIF on the ASUS Xonar U3
      ALSA: hda - Check validity of CORB/RIRB WP reads
      ALSA: hda - use usleep_range in link reset and change timeout check
      ALSA: HDA: VIA: Add support for codec VT1808.
      ALSA: HDA: VIA Add support for codec VT1705CF.
      ASoC: codecs: remove __dev* attributes
      ASoC: utils: remove __dev* attributes
      ASoC: ux500: remove __dev* attributes
      ASoC: txx9: remove __dev* attributes
      ASoC: tegra: remove __dev* attributes
      ASoC: spear: remove __dev* attributes
      ASoC: sh: remove __dev* attributes
      ASoC: s6000: remove __dev* attributes
      ASoC: OMAP: remove __dev* attributes
      ASoC: nuc900: remove __dev* attributes
      ASoC: mxs: remove __dev* attributes
      ASoC: kirkwood: remove __dev* attributes
      ...

commit cff2f741b8ee8a70b208830e330de053efd4fc45
Merge: b0885d01f9ab 92e9e6d1f984
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 11 13:13:55 2012 -0800

    Merge tag 'driver-core-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg Kroah-Hartman:
     "Here's the large driver core updates for 3.8-rc1.
    
      The biggest thing here is the various __dev* marking removals.  This
      is going to be a pain for the merge with different subsystem trees, I
      know, but all of the patches included here have been ACKed by their
      various subsystem maintainers, as they wanted them to go through here.
    
      If this is too much of a pain, I can pull all of them out of this tree
      and just send you one with the other fixes/updates and then, after
      3.8-rc1 is out, do the rest of the removals to ensure we catch them
      all, it's up to you.  The merges should all be trivial, and Stephen
      has been doing them all in linux-next for a few weeks now quite
      easily.
    
      Other than the __dev* marking removals, there's nothing major here,
      some firmware loading updates and other minor things in the driver
      core.
    
      All of these have (much to Stephen's annoyance), been in linux-next
      for a while.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fixed up trivial conflicts in drivers/gpio/gpio-{em,stmpe}.c due to gpio
    update.
    
    * tag 'driver-core-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (93 commits)
      modpost.c: Stop checking __dev* section mismatches
      init.h: Remove __dev* sections from the kernel
      acpi: remove use of __devinit
      PCI: Remove __dev* markings
      PCI: Always build setup-bus when PCI is enabled
      PCI: Move pci_uevent into pci-driver.c
      PCI: Remove CONFIG_HOTPLUG ifdefs
      unicore32/PCI: Remove CONFIG_HOTPLUG ifdefs
      sh/PCI: Remove CONFIG_HOTPLUG ifdefs
      powerpc/PCI: Remove CONFIG_HOTPLUG ifdefs
      mips/PCI: Remove CONFIG_HOTPLUG ifdefs
      microblaze/PCI: Remove CONFIG_HOTPLUG ifdefs
      dma: remove use of __devinit
      dma: remove use of __devexit_p
      firewire: remove use of __devinitdata
      firewire: remove use of __devinit
      leds: remove use of __devexit
      leds: remove use of __devinit
      leds: remove use of __devexit_p
      mmc: remove use of __devexit
      ...

commit 62d62b59bd100b8f146ea941dad273656371a386
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Dec 2 11:41:46 2012 +0900

    mfd: arizona: Defer patch initialistation until after first device boot
    
    Make sure that we don't race with the initial device boot by only doing
    the initialisation after we've waited for the boot to complete.
    
    The runtime PM code already waits for the boot to complete before it
    syncs the register patches so in most systems if a race does occur we will
    power down very soon afterwards and recover anyway.
    
    Reported-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 75619711a9e7..f59773da8adf 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -292,6 +292,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 	struct device *dev = arizona->dev;
 	const char *type_name;
 	unsigned int reg, val;
+	int (*apply_patch)(struct arizona *) = NULL;
 	int ret, i;
 
 	dev_set_drvdata(arizona->dev, arizona);
@@ -391,7 +392,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 				arizona->type);
 			arizona->type = WM5102;
 		}
-		ret = wm5102_patch(arizona);
+		apply_patch = wm5102_patch;
 		break;
 #endif
 #ifdef CONFIG_MFD_WM5110
@@ -402,7 +403,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 				arizona->type);
 			arizona->type = WM5110;
 		}
-		ret = wm5110_patch(arizona);
+		apply_patch = wm5110_patch;
 		break;
 #endif
 	default:
@@ -412,9 +413,6 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 
 	dev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');
 
-	if (ret != 0)
-		dev_err(arizona->dev, "Failed to apply patch: %d\n", ret);
-
 	/* If we have a /RESET GPIO we'll already be reset */
 	if (!arizona->pdata.reset) {
 		ret = regmap_write(arizona->regmap, ARIZONA_SOFTWARE_RESET, 0);
@@ -430,6 +428,15 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		goto err_reset;
 	}
 
+	if (apply_patch) {
+		ret = apply_patch(arizona);
+		if (ret != 0) {
+			dev_err(arizona->dev, "Failed to apply patch: %d\n",
+				ret);
+			goto err_reset;
+		}
+	}
+
 	for (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {
 		if (!arizona->pdata.gpio_defaults[i])
 			continue;

commit b2e2558edf5e68f4efbdec0e09152050b9d79c07
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 27 17:37:13 2012 +0000

    mfd: arizona: Register haptics devices
    
    Both WM5102 and WM5110 support haptics, register the device.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 1b48f2094806..75619711a9e7 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -272,6 +272,7 @@ static struct mfd_cell early_devs[] = {
 static struct mfd_cell wm5102_devs[] = {
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
+	{ .name = "arizona-haptics" },
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-pwm" },
 	{ .name = "wm5102-codec" },
@@ -280,6 +281,7 @@ static struct mfd_cell wm5102_devs[] = {
 static struct mfd_cell wm5110_devs[] = {
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
+	{ .name = "arizona-haptics" },
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-pwm" },
 	{ .name = "wm5110-codec" },

commit 4740f73fe5388ab5d22d552d2a0dacc62418a70c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:01 2012 -0500

    mfd: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Peter Tyser <ptyser@xes-inc.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: David Brown <davidb@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 47e711674739..12fdabfb569e 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -553,7 +553,7 @@ int arizona_dev_init(struct arizona *arizona)
 }
 EXPORT_SYMBOL_GPL(arizona_dev_init);
 
-int __devexit arizona_dev_exit(struct arizona *arizona)
+int arizona_dev_exit(struct arizona *arizona)
 {
 	mfd_remove_devices(arizona->dev);
 	arizona_free_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, arizona);

commit f791be492f76dea7b0641ed227a60eeb2fa7e255
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:04 2012 -0500

    mfd: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Peter Tyser <ptyser@xes-inc.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: David Brown <davidb@codeaurora.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 1b48f2094806..47e711674739 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -285,7 +285,7 @@ static struct mfd_cell wm5110_devs[] = {
 	{ .name = "wm5110-codec" },
 };
 
-int __devinit arizona_dev_init(struct arizona *arizona)
+int arizona_dev_init(struct arizona *arizona)
 {
 	struct device *dev = arizona->dev;
 	const char *type_name;

commit 503b1cac5c7bb94b267c831d0a7966a18d38365e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 27 17:36:38 2012 +0000

    mfd: arizona: Register haptics devices
    
    Both WM5102 and WM5110 support haptics, register the device.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 1b48f2094806..75619711a9e7 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -272,6 +272,7 @@ static struct mfd_cell early_devs[] = {
 static struct mfd_cell wm5102_devs[] = {
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
+	{ .name = "arizona-haptics" },
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-pwm" },
 	{ .name = "wm5102-codec" },
@@ -280,6 +281,7 @@ static struct mfd_cell wm5102_devs[] = {
 static struct mfd_cell wm5110_devs[] = {
 	{ .name = "arizona-extcon" },
 	{ .name = "arizona-gpio" },
+	{ .name = "arizona-haptics" },
 	{ .name = "arizona-micsupp" },
 	{ .name = "arizona-pwm" },
 	{ .name = "wm5110-codec" },

commit 46b9d13aaec19dfbd5882a999e8ed85fc97a751e
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Nov 20 14:49:10 2012 +0900

    mfd: arizona: Sync regcache after reset
    
    In the absence of a physical reset line the chip is reset by writing the
    first register, which is done after the register patch has been applied.
    This patch synchronises the register cache after the reset to preserve
    any register changes that had been applied.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 202bf55c3cc9..f4f9bf84bc7b 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -415,11 +415,19 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 
 	/* If we have a /RESET GPIO we'll already be reset */
 	if (!arizona->pdata.reset) {
+		regcache_mark_dirty(arizona->regmap);
+
 		ret = regmap_write(arizona->regmap, ARIZONA_SOFTWARE_RESET, 0);
 		if (ret != 0) {
 			dev_err(dev, "Failed to reset device: %d\n", ret);
 			goto err_reset;
 		}
+
+		ret = regcache_sync(arizona->regmap);
+		if (ret != 0) {
+			dev_err(dev, "Failed to sync device: %d\n", ret);
+			goto err_reset;
+		}
 	}
 
 	ret = arizona_wait_for_boot(arizona);

commit 3ebef34d5cf658752d000001d2a6a5defe8cf3a9
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Nov 20 13:46:20 2012 +0900

    mfd: arizona: Correctly report when AIF2/AIF1 is underclocked
    
    In the interrupt handler for an underclocked event, whilst checking for
    the source of the interrupt, AIF3 was checked twice and AIF1 was not
    checked. This change correctly checks the AIF1 underclocked bit and
    reports the correct error messages for all cases.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 166254bba4c2..202bf55c3cc9 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -96,11 +96,11 @@ static irqreturn_t arizona_underclocked(int irq, void *data)
 		return IRQ_NONE;
 	}
 
-	if (val & ARIZONA_AIF3_UNDERCLOCKED_STS)
-		dev_err(arizona->dev, "AIF3 underclocked\n");
 	if (val & ARIZONA_AIF3_UNDERCLOCKED_STS)
 		dev_err(arizona->dev, "AIF3 underclocked\n");
 	if (val & ARIZONA_AIF2_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "AIF2 underclocked\n");
+	if (val & ARIZONA_AIF1_UNDERCLOCKED_STS)
 		dev_err(arizona->dev, "AIF1 underclocked\n");
 	if (val & ARIZONA_ISRC2_UNDERCLOCKED_STS)
 		dev_err(arizona->dev, "ISRC2 underclocked\n");

commit 78566afd8647654b2fb11c3ae13b3d8fe96a8cfe
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Nov 20 13:46:19 2012 +0900

    mfd: arizona: Use correct array for ARRAY_SIZE in mfd_add_devices call
    
    wm5102_devs array was used for ARRAY_SIZE whilst adding the wm5110
    devices. This change corrects this to get the size from the wm5110_devs
    array. As both arrays are the same size no issues should have been
    caused by this bug.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 1b48f2094806..166254bba4c2 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -520,7 +520,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		break;
 	case WM5110:
 		ret = mfd_add_devices(arizona->dev, -1, wm5110_devs,
-				      ARRAY_SIZE(wm5102_devs), NULL, 0, NULL);
+				      ARRAY_SIZE(wm5110_devs), NULL, 0, NULL);
 		break;
 	}
 

commit 0848c94fb4a5cc213a7fb0fb3a5721ad6e16f096
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 11 15:16:36 2012 +0800

    mfd: core: Push irqdomain mapping out into devices
    
    Currently the MFD core supports remapping MFD cell interrupts using an
    irqdomain but only if the MFD is being instantiated using device tree
    and only if the device tree bindings use the pattern of registering IPs
    in the device tree with compatible properties.  This will be actively
    harmful for drivers which support non-DT platforms and use this pattern
    for their DT bindings as it will mean that the core will silently change
    remapping behaviour and it is also limiting for drivers which don't do
    DT with this particular pattern.  There is also a potential fragility if
    there are interrupts not associated with MFD cells and all the cells are
    omitted from the device tree for some reason.
    
    Instead change the code to take an IRQ domain as an optional argument,
    allowing drivers to take the decision about the parent domain for their
    interrupts.  The one current user of this feature is ab8500-core, it has
    the domain lookup pushed out into the driver.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index c7983e862549..1b48f2094806 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -316,7 +316,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 	}
 
 	ret = mfd_add_devices(arizona->dev, -1, early_devs,
-			      ARRAY_SIZE(early_devs), NULL, 0);
+			      ARRAY_SIZE(early_devs), NULL, 0, NULL);
 	if (ret != 0) {
 		dev_err(dev, "Failed to add early children: %d\n", ret);
 		return ret;
@@ -516,11 +516,11 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 	switch (arizona->type) {
 	case WM5102:
 		ret = mfd_add_devices(arizona->dev, -1, wm5102_devs,
-				      ARRAY_SIZE(wm5102_devs), NULL, 0);
+				      ARRAY_SIZE(wm5102_devs), NULL, 0, NULL);
 		break;
 	case WM5110:
 		ret = mfd_add_devices(arizona->dev, -1, wm5110_devs,
-				      ARRAY_SIZE(wm5102_devs), NULL, 0);
+				      ARRAY_SIZE(wm5102_devs), NULL, 0, NULL);
 		break;
 	}
 

commit 508c829994446fcb5d93cbc910bb45378ab28050
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jul 20 17:09:12 2012 +0100

    mfd: Add debug trace on entering and leaving arizone runtime suspend
    
    There doesn't appear to be any useful diagnostic information from the
    core.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 6e70d3defc7e..c7983e862549 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -223,6 +223,8 @@ static int arizona_runtime_resume(struct device *dev)
 	struct arizona *arizona = dev_get_drvdata(dev);
 	int ret;
 
+	dev_dbg(arizona->dev, "Leaving AoD mode\n");
+
 	ret = regulator_enable(arizona->dcvdd);
 	if (ret != 0) {
 		dev_err(arizona->dev, "Failed to enable DCVDD: %d\n", ret);
@@ -246,6 +248,8 @@ static int arizona_runtime_suspend(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
 
+	dev_dbg(arizona->dev, "Entering AoD mode\n");
+
 	regulator_disable(arizona->dcvdd);
 	regcache_cache_only(arizona->regmap, true);
 	regcache_mark_dirty(arizona->regmap);

commit e102befe7a254f7b827fecc19eba0c5af03d1bf3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jul 10 12:37:58 2012 +0100

    mfd: Initial support for the WM5110
    
    The WM5110 is a highly-integrated low-power audio system for smartphones,
    tablets and other portable audio devices. It combines an advanced DSP
    feature set with a flexible, high-performance audio hub CODEC.
    
    The support is based on the Arizona core driver.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index b35680dcd8c1..6e70d3defc7e 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -273,6 +273,14 @@ static struct mfd_cell wm5102_devs[] = {
 	{ .name = "wm5102-codec" },
 };
 
+static struct mfd_cell wm5110_devs[] = {
+	{ .name = "arizona-extcon" },
+	{ .name = "arizona-gpio" },
+	{ .name = "arizona-micsupp" },
+	{ .name = "arizona-pwm" },
+	{ .name = "wm5110-codec" },
+};
+
 int __devinit arizona_dev_init(struct arizona *arizona)
 {
 	struct device *dev = arizona->dev;
@@ -291,6 +299,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 
 	switch (arizona->type) {
 	case WM5102:
+	case WM5110:
 		for (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)
 			arizona->core_supplies[i].supply
 				= wm5102_core_supplies[i];
@@ -378,6 +387,17 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		}
 		ret = wm5102_patch(arizona);
 		break;
+#endif
+#ifdef CONFIG_MFD_WM5110
+	case 0x5110:
+		type_name = "WM5110";
+		if (arizona->type != WM5110) {
+			dev_err(arizona->dev, "WM5110 registered as %d\n",
+				arizona->type);
+			arizona->type = WM5110;
+		}
+		ret = wm5110_patch(arizona);
+		break;
 #endif
 	default:
 		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
@@ -494,6 +514,10 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		ret = mfd_add_devices(arizona->dev, -1, wm5102_devs,
 				      ARRAY_SIZE(wm5102_devs), NULL, 0);
 		break;
+	case WM5110:
+		ret = mfd_add_devices(arizona->dev, -1, wm5110_devs,
+				      ARRAY_SIZE(wm5102_devs), NULL, 0);
+		break;
 	}
 
 	if (ret != 0) {

commit 2a51da04fef56ec83f790bf0746e90fe40215a92
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jul 9 19:33:14 2012 +0100

    mfd: Add support for multiple arizona PDM speaker outputs
    
    The registers have stride 2 so we can write the loop properly now.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index ffa011f4677e..b35680dcd8c1 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -462,18 +462,17 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 				   ARIZONA_OUT1_MONO, val);
 	}
 
-	BUILD_BUG_ON(ARIZONA_MAX_PDM_SPK > 1);
 	for (i = 0; i < ARIZONA_MAX_PDM_SPK; i++) {
 		if (arizona->pdata.spk_mute[i])
 			regmap_update_bits(arizona->regmap,
-					   ARIZONA_PDM_SPK1_CTRL_1,
+					   ARIZONA_PDM_SPK1_CTRL_1 + (i * 2),
 					   ARIZONA_SPK1_MUTE_ENDIAN_MASK |
 					   ARIZONA_SPK1_MUTE_SEQ1_MASK,
 					   arizona->pdata.spk_mute[i]);
 
 		if (arizona->pdata.spk_fmt[i])
 			regmap_update_bits(arizona->regmap,
-					   ARIZONA_PDM_SPK1_CTRL_2,
+					   ARIZONA_PDM_SPK1_CTRL_2 + (i * 2),
 					   ARIZONA_SPK1_FMT_MASK,
 					   arizona->pdata.spk_fmt[i]);
 	}

commit af65a361d543100962c03cc4cdb7333b14c9d119
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jul 9 11:56:43 2012 +0100

    mfd: Error out if initial arizona boot fails
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 5cbacf6e2bf7..ffa011f4677e 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -398,7 +398,11 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		}
 	}
 
-	arizona_wait_for_boot(arizona);
+	ret = arizona_wait_for_boot(arizona);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Device failed initial boot: %d\n", ret);
+		goto err_reset;
+	}
 
 	for (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {
 		if (!arizona->pdata.gpio_defaults[i])

commit 3a36a0db5b0f77ff71a9df23db9f4044e04590d8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jul 9 00:45:53 2012 +0200

    mfd: Don't free unallocated arizona supplies on error
    
    ARRAY_SIZE() may be larger than the number of supplies actually used.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 7f837edfbfb7..5cbacf6e2bf7 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -514,7 +514,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 err_dcvdd:
 	regulator_disable(arizona->dcvdd);
 err_enable:
-	regulator_bulk_disable(ARRAY_SIZE(arizona->core_supplies),
+	regulator_bulk_disable(arizona->num_core_supplies,
 			       arizona->core_supplies);
 err_early:
 	mfd_remove_devices(dev);

commit 863df8d5f1a1a92016e24c80947cb3509b8aaa48
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 5 20:35:31 2012 +0100

    mfd: Add missing WM5102 ifdefs
    
    References to the WM5102 tables need to be guarded.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 03aef6750a9d..7f837edfbfb7 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -368,6 +368,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 	arizona->rev &= ARIZONA_DEVICE_REVISION_MASK;
 
 	switch (reg) {
+#ifdef CONFIG_MFD_WM5102
 	case 0x5102:
 		type_name = "WM5102";
 		if (arizona->type != WM5102) {
@@ -377,7 +378,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		}
 		ret = wm5102_patch(arizona);
 		break;
-
+#endif
 	default:
 		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
 		goto err_reset;

commit cfe775ce62d83168125299714739aebc1018211e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 5 20:35:30 2012 +0100

    mfd: Treat arizona register read errors as non-fatal during resume
    
    We're testing for a specific value and while SPI does not detect I/O
    errors I2C can.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index e1308b5214ba..03aef6750a9d 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -197,7 +197,7 @@ static int arizona_wait_for_boot(struct arizona *arizona)
 		if (ret != 0) {
 			dev_err(arizona->dev, "Failed to read boot state: %d\n",
 				ret);
-			return ret;
+			continue;
 		}
 
 		if (reg & ARIZONA_BOOT_DONE_STS)

commit 5879f5710e684af662635770561112ce3f25ea8c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 5 20:35:29 2012 +0100

    mfd: Release arizona DCVDD if we fail to resume the device
    
    Ensures we don't leak the enable we just did.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index c8946a889a78..e1308b5214ba 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -232,8 +232,10 @@ static int arizona_runtime_resume(struct device *dev)
 	regcache_cache_only(arizona->regmap, false);
 
 	ret = arizona_wait_for_boot(arizona);
-	if (ret != 0)
+	if (ret != 0) {
+		regulator_disable(arizona->dcvdd);
 		return ret;
+	}
 
 	regcache_sync(arizona->regmap);
 

commit 59db96913c9d94fe74002df494eb80e4a5ca4087
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jul 9 00:31:36 2012 +0200

    mfd: Move arizona digital core supply management to the regulator API
    
    Rather than open coding the enable GPIO control in the MFD core use the
    API to push the management on to the regulator driver. The immediate
    advantage is slight for most systems but this will in future allow device
    configurations where an external regulator is used for DCVDD.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
index 42cb28b2b5c8..c8946a889a78 100644
--- a/drivers/mfd/arizona-core.c
+++ b/drivers/mfd/arizona-core.c
@@ -11,6 +11,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/interrupt.h>
 #include <linux/mfd/core.h>
@@ -28,7 +29,6 @@
 static const char *wm5102_core_supplies[] = {
 	"AVDD",
 	"DBVDD1",
-	"DCVDD",
 };
 
 int arizona_clk32k_enable(struct arizona *arizona)
@@ -223,8 +223,11 @@ static int arizona_runtime_resume(struct device *dev)
 	struct arizona *arizona = dev_get_drvdata(dev);
 	int ret;
 
-	if (arizona->pdata.ldoena)
-		gpio_set_value_cansleep(arizona->pdata.ldoena, 1);
+	ret = regulator_enable(arizona->dcvdd);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to enable DCVDD: %d\n", ret);
+		return ret;
+	}
 
 	regcache_cache_only(arizona->regmap, false);
 
@@ -241,11 +244,9 @@ static int arizona_runtime_suspend(struct device *dev)
 {
 	struct arizona *arizona = dev_get_drvdata(dev);
 
-	if (arizona->pdata.ldoena) {
-		gpio_set_value_cansleep(arizona->pdata.ldoena, 0);
-		regcache_cache_only(arizona->regmap, true);
-		regcache_mark_dirty(arizona->regmap);
-	}
+	regulator_disable(arizona->dcvdd);
+	regcache_cache_only(arizona->regmap, true);
+	regcache_mark_dirty(arizona->regmap);
 
 	return 0;
 }
@@ -314,6 +315,13 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		goto err_early;
 	}
 
+	arizona->dcvdd = devm_regulator_get(arizona->dev, "DCVDD");
+	if (IS_ERR(arizona->dcvdd)) {
+		ret = PTR_ERR(arizona->dcvdd);
+		dev_err(dev, "Failed to request DCVDD: %d\n", ret);
+		goto err_early;
+	}
+
 	ret = regulator_bulk_enable(arizona->num_core_supplies,
 				    arizona->core_supplies);
 	if (ret != 0) {
@@ -322,6 +330,12 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		goto err_early;
 	}
 
+	ret = regulator_enable(arizona->dcvdd);
+	if (ret != 0) {
+		dev_err(dev, "Failed to enable DCVDD: %d\n", ret);
+		goto err_enable;
+	}
+
 	if (arizona->pdata.reset) {
 		/* Start out with /RESET low to put the chip into reset */
 		ret = gpio_request_one(arizona->pdata.reset,
@@ -329,35 +343,25 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 				       "arizona /RESET");
 		if (ret != 0) {
 			dev_err(dev, "Failed to request /RESET: %d\n", ret);
-			goto err_enable;
+			goto err_dcvdd;
 		}
 
 		gpio_set_value_cansleep(arizona->pdata.reset, 1);
 	}
 
-	if (arizona->pdata.ldoena) {
-		ret = gpio_request_one(arizona->pdata.ldoena,
-				       GPIOF_DIR_OUT | GPIOF_INIT_HIGH,
-				       "arizona LDOENA");
-		if (ret != 0) {
-			dev_err(dev, "Failed to request LDOENA: %d\n", ret);
-			goto err_reset;
-		}
-	}
-
 	regcache_cache_only(arizona->regmap, false);
 
 	ret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);
 	if (ret != 0) {
 		dev_err(dev, "Failed to read ID register: %d\n", ret);
-		goto err_ldoena;
+		goto err_reset;
 	}
 
 	ret = regmap_read(arizona->regmap, ARIZONA_DEVICE_REVISION,
 			  &arizona->rev);
 	if (ret != 0) {
 		dev_err(dev, "Failed to read revision register: %d\n", ret);
-		goto err_ldoena;
+		goto err_reset;
 	}
 	arizona->rev &= ARIZONA_DEVICE_REVISION_MASK;
 
@@ -374,7 +378,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 
 	default:
 		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
-		goto err_ldoena;
+		goto err_reset;
 	}
 
 	dev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');
@@ -387,7 +391,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		ret = regmap_write(arizona->regmap, ARIZONA_SOFTWARE_RESET, 0);
 		if (ret != 0) {
 			dev_err(dev, "Failed to reset device: %d\n", ret);
-			goto err_ldoena;
+			goto err_reset;
 		}
 	}
 
@@ -424,7 +428,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		dev_err(arizona->dev, "Invalid 32kHz clock source: %d\n",
 			arizona->pdata.clk32k_src);
 		ret = -EINVAL;
-		goto err_ldoena;
+		goto err_reset;
 	}
 
 	for (i = 0; i < ARIZONA_MAX_INPUT; i++) {
@@ -470,7 +474,7 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 	/* Set up for interrupts */
 	ret = arizona_irq_init(arizona);
 	if (ret != 0)
-		goto err_ldoena;
+		goto err_reset;
 
 	arizona_request_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, "CLKGEN error",
 			    arizona_clkgen_err, arizona);
@@ -491,20 +495,21 @@ int __devinit arizona_dev_init(struct arizona *arizona)
 		goto err_irq;
 	}
 
+#ifdef CONFIG_PM_RUNTIME
+	regulator_disable(arizona->dcvdd);
+#endif
+
 	return 0;
 
 err_irq:
 	arizona_irq_exit(arizona);
-err_ldoena:
-	if (arizona->pdata.ldoena) {
-		gpio_set_value_cansleep(arizona->pdata.ldoena, 0);
-		gpio_free(arizona->pdata.ldoena);
-	}
 err_reset:
 	if (arizona->pdata.reset) {
 		gpio_set_value_cansleep(arizona->pdata.reset, 1);
 		gpio_free(arizona->pdata.reset);
 	}
+err_dcvdd:
+	regulator_disable(arizona->dcvdd);
 err_enable:
 	regulator_bulk_disable(ARRAY_SIZE(arizona->core_supplies),
 			       arizona->core_supplies);

commit 3cc72986947501a6a8fd12330e0963b59ed2f964
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jun 19 16:31:53 2012 +0100

    mfd: arizona: Core driver
    
    Several forthcoming Wolfson devices are based on a common platform
    known as Arizona allowing a great deal of reuse of driver code. This
    patch adds core support for these devices.
    
    In order to handle systems which do not use the generic clock API a
    simple wrapper for the 32kHz clock domain in the devices is provided.
    Once the generic clock API is widely available this code will be moved
    over to use that.
    
    For simplicity some WM5102 specific code is included in the core driver,
    the effort involved in splitting the device out isn't worth it.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c
new file mode 100644
index 000000000000..42cb28b2b5c8
--- /dev/null
+++ b/drivers/mfd/arizona-core.c
@@ -0,0 +1,527 @@
+/*
+ * Arizona core driver
+ *
+ * Copyright 2012 Wolfson Microelectronics plc
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/core.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+#include <linux/mfd/arizona/core.h>
+#include <linux/mfd/arizona/registers.h>
+
+#include "arizona.h"
+
+static const char *wm5102_core_supplies[] = {
+	"AVDD",
+	"DBVDD1",
+	"DCVDD",
+};
+
+int arizona_clk32k_enable(struct arizona *arizona)
+{
+	int ret = 0;
+
+	mutex_lock(&arizona->clk_lock);
+
+	arizona->clk32k_ref++;
+
+	if (arizona->clk32k_ref == 1)
+		ret = regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,
+					 ARIZONA_CLK_32K_ENA,
+					 ARIZONA_CLK_32K_ENA);
+
+	if (ret != 0)
+		arizona->clk32k_ref--;
+
+	mutex_unlock(&arizona->clk_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(arizona_clk32k_enable);
+
+int arizona_clk32k_disable(struct arizona *arizona)
+{
+	int ret = 0;
+
+	mutex_lock(&arizona->clk_lock);
+
+	BUG_ON(arizona->clk32k_ref <= 0);
+
+	arizona->clk32k_ref--;
+
+	if (arizona->clk32k_ref == 0)
+		regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,
+				   ARIZONA_CLK_32K_ENA, 0);
+
+	mutex_unlock(&arizona->clk_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(arizona_clk32k_disable);
+
+static irqreturn_t arizona_clkgen_err(int irq, void *data)
+{
+	struct arizona *arizona = data;
+
+	dev_err(arizona->dev, "CLKGEN error\n");
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t arizona_underclocked(int irq, void *data)
+{
+	struct arizona *arizona = data;
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_8,
+			  &val);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to read underclock status: %d\n",
+			ret);
+		return IRQ_NONE;
+	}
+
+	if (val & ARIZONA_AIF3_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "AIF3 underclocked\n");
+	if (val & ARIZONA_AIF3_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "AIF3 underclocked\n");
+	if (val & ARIZONA_AIF2_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "AIF1 underclocked\n");
+	if (val & ARIZONA_ISRC2_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "ISRC2 underclocked\n");
+	if (val & ARIZONA_ISRC1_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "ISRC1 underclocked\n");
+	if (val & ARIZONA_FX_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "FX underclocked\n");
+	if (val & ARIZONA_ASRC_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "ASRC underclocked\n");
+	if (val & ARIZONA_DAC_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "DAC underclocked\n");
+	if (val & ARIZONA_ADC_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "ADC underclocked\n");
+	if (val & ARIZONA_MIXER_UNDERCLOCKED_STS)
+		dev_err(arizona->dev, "Mixer underclocked\n");
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t arizona_overclocked(int irq, void *data)
+{
+	struct arizona *arizona = data;
+	unsigned int val[2];
+	int ret;
+	
+	ret = regmap_bulk_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_6,
+			       &val[0], 2);
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to read overclock status: %d\n",
+			ret);
+		return IRQ_NONE;
+	}
+
+	if (val[0] & ARIZONA_PWM_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "PWM overclocked\n");
+	if (val[0] & ARIZONA_FX_CORE_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "FX core overclocked\n");
+	if (val[0] & ARIZONA_DAC_SYS_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "DAC SYS overclocked\n");
+	if (val[0] & ARIZONA_DAC_WARP_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "DAC WARP overclocked\n");
+	if (val[0] & ARIZONA_ADC_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ADC overclocked\n");
+	if (val[0] & ARIZONA_MIXER_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "Mixer overclocked\n");
+	if (val[0] & ARIZONA_AIF3_SYNC_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "AIF3 overclocked\n");
+	if (val[0] & ARIZONA_AIF2_SYNC_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "AIF2 overclocked\n");
+	if (val[0] & ARIZONA_AIF1_SYNC_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "AIF1 overclocked\n");
+	if (val[0] & ARIZONA_PAD_CTRL_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "Pad control overclocked\n");
+
+	if (val[1] & ARIZONA_SLIMBUS_SUBSYS_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "Slimbus subsystem overclocked\n");
+	if (val[1] & ARIZONA_SLIMBUS_ASYNC_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "Slimbus async overclocked\n");
+	if (val[1] & ARIZONA_SLIMBUS_SYNC_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "Slimbus sync overclocked\n");
+	if (val[1] & ARIZONA_ASRC_ASYNC_SYS_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ASRC async system overclocked\n");
+	if (val[1] & ARIZONA_ASRC_ASYNC_WARP_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ASRC async WARP overclocked\n");
+	if (val[1] & ARIZONA_ASRC_SYNC_SYS_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ASRC sync system overclocked\n");
+	if (val[1] & ARIZONA_ASRC_SYNC_WARP_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ASRC sync WARP overclocked\n");
+	if (val[1] & ARIZONA_ADSP2_1_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "DSP1 overclocked\n");
+	if (val[1] & ARIZONA_ISRC2_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ISRC2 overclocked\n");
+	if (val[1] & ARIZONA_ISRC1_OVERCLOCKED_STS)
+		dev_err(arizona->dev, "ISRC1 overclocked\n");
+
+	return IRQ_HANDLED;
+}
+
+static int arizona_wait_for_boot(struct arizona *arizona)
+{
+	unsigned int reg;
+	int ret, i;
+
+	/*
+	 * We can't use an interrupt as we need to runtime resume to do so,
+	 * we won't race with the interrupt handler as it'll be blocked on
+	 * runtime resume.
+	 */
+	for (i = 0; i < 5; i++) {
+		msleep(1);
+
+		ret = regmap_read(arizona->regmap,
+				  ARIZONA_INTERRUPT_RAW_STATUS_5, &reg);
+		if (ret != 0) {
+			dev_err(arizona->dev, "Failed to read boot state: %d\n",
+				ret);
+			return ret;
+		}
+
+		if (reg & ARIZONA_BOOT_DONE_STS)
+			break;
+	}
+
+	if (reg & ARIZONA_BOOT_DONE_STS) {
+		regmap_write(arizona->regmap, ARIZONA_INTERRUPT_STATUS_5,
+			     ARIZONA_BOOT_DONE_STS);
+	} else {
+		dev_err(arizona->dev, "Device boot timed out: %x\n", reg);
+		return -ETIMEDOUT;
+	}
+
+	pm_runtime_mark_last_busy(arizona->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int arizona_runtime_resume(struct device *dev)
+{
+	struct arizona *arizona = dev_get_drvdata(dev);
+	int ret;
+
+	if (arizona->pdata.ldoena)
+		gpio_set_value_cansleep(arizona->pdata.ldoena, 1);
+
+	regcache_cache_only(arizona->regmap, false);
+
+	ret = arizona_wait_for_boot(arizona);
+	if (ret != 0)
+		return ret;
+
+	regcache_sync(arizona->regmap);
+
+	return 0;
+}
+
+static int arizona_runtime_suspend(struct device *dev)
+{
+	struct arizona *arizona = dev_get_drvdata(dev);
+
+	if (arizona->pdata.ldoena) {
+		gpio_set_value_cansleep(arizona->pdata.ldoena, 0);
+		regcache_cache_only(arizona->regmap, true);
+		regcache_mark_dirty(arizona->regmap);
+	}
+
+	return 0;
+}
+#endif
+
+const struct dev_pm_ops arizona_pm_ops = {
+	SET_RUNTIME_PM_OPS(arizona_runtime_suspend,
+			   arizona_runtime_resume,
+			   NULL)
+};
+EXPORT_SYMBOL_GPL(arizona_pm_ops);
+
+static struct mfd_cell early_devs[] = {
+	{ .name = "arizona-ldo1" },
+};
+
+static struct mfd_cell wm5102_devs[] = {
+	{ .name = "arizona-extcon" },
+	{ .name = "arizona-gpio" },
+	{ .name = "arizona-micsupp" },
+	{ .name = "arizona-pwm" },
+	{ .name = "wm5102-codec" },
+};
+
+int __devinit arizona_dev_init(struct arizona *arizona)
+{
+	struct device *dev = arizona->dev;
+	const char *type_name;
+	unsigned int reg, val;
+	int ret, i;
+
+	dev_set_drvdata(arizona->dev, arizona);
+	mutex_init(&arizona->clk_lock);
+
+	if (dev_get_platdata(arizona->dev))
+		memcpy(&arizona->pdata, dev_get_platdata(arizona->dev),
+		       sizeof(arizona->pdata));
+
+	regcache_cache_only(arizona->regmap, true);
+
+	switch (arizona->type) {
+	case WM5102:
+		for (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)
+			arizona->core_supplies[i].supply
+				= wm5102_core_supplies[i];
+		arizona->num_core_supplies = ARRAY_SIZE(wm5102_core_supplies);
+		break;
+	default:
+		dev_err(arizona->dev, "Unknown device type %d\n",
+			arizona->type);
+		return -EINVAL;
+	}
+
+	ret = mfd_add_devices(arizona->dev, -1, early_devs,
+			      ARRAY_SIZE(early_devs), NULL, 0);
+	if (ret != 0) {
+		dev_err(dev, "Failed to add early children: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_regulator_bulk_get(dev, arizona->num_core_supplies,
+				      arizona->core_supplies);
+	if (ret != 0) {
+		dev_err(dev, "Failed to request core supplies: %d\n",
+			ret);
+		goto err_early;
+	}
+
+	ret = regulator_bulk_enable(arizona->num_core_supplies,
+				    arizona->core_supplies);
+	if (ret != 0) {
+		dev_err(dev, "Failed to enable core supplies: %d\n",
+			ret);
+		goto err_early;
+	}
+
+	if (arizona->pdata.reset) {
+		/* Start out with /RESET low to put the chip into reset */
+		ret = gpio_request_one(arizona->pdata.reset,
+				       GPIOF_DIR_OUT | GPIOF_INIT_LOW,
+				       "arizona /RESET");
+		if (ret != 0) {
+			dev_err(dev, "Failed to request /RESET: %d\n", ret);
+			goto err_enable;
+		}
+
+		gpio_set_value_cansleep(arizona->pdata.reset, 1);
+	}
+
+	if (arizona->pdata.ldoena) {
+		ret = gpio_request_one(arizona->pdata.ldoena,
+				       GPIOF_DIR_OUT | GPIOF_INIT_HIGH,
+				       "arizona LDOENA");
+		if (ret != 0) {
+			dev_err(dev, "Failed to request LDOENA: %d\n", ret);
+			goto err_reset;
+		}
+	}
+
+	regcache_cache_only(arizona->regmap, false);
+
+	ret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);
+	if (ret != 0) {
+		dev_err(dev, "Failed to read ID register: %d\n", ret);
+		goto err_ldoena;
+	}
+
+	ret = regmap_read(arizona->regmap, ARIZONA_DEVICE_REVISION,
+			  &arizona->rev);
+	if (ret != 0) {
+		dev_err(dev, "Failed to read revision register: %d\n", ret);
+		goto err_ldoena;
+	}
+	arizona->rev &= ARIZONA_DEVICE_REVISION_MASK;
+
+	switch (reg) {
+	case 0x5102:
+		type_name = "WM5102";
+		if (arizona->type != WM5102) {
+			dev_err(arizona->dev, "WM5102 registered as %d\n",
+				arizona->type);
+			arizona->type = WM5102;
+		}
+		ret = wm5102_patch(arizona);
+		break;
+
+	default:
+		dev_err(arizona->dev, "Unknown device ID %x\n", reg);
+		goto err_ldoena;
+	}
+
+	dev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');
+
+	if (ret != 0)
+		dev_err(arizona->dev, "Failed to apply patch: %d\n", ret);
+
+	/* If we have a /RESET GPIO we'll already be reset */
+	if (!arizona->pdata.reset) {
+		ret = regmap_write(arizona->regmap, ARIZONA_SOFTWARE_RESET, 0);
+		if (ret != 0) {
+			dev_err(dev, "Failed to reset device: %d\n", ret);
+			goto err_ldoena;
+		}
+	}
+
+	arizona_wait_for_boot(arizona);
+
+	for (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {
+		if (!arizona->pdata.gpio_defaults[i])
+			continue;
+
+		regmap_write(arizona->regmap, ARIZONA_GPIO1_CTRL + i,
+			     arizona->pdata.gpio_defaults[i]);
+	}
+
+	pm_runtime_set_autosuspend_delay(arizona->dev, 100);
+	pm_runtime_use_autosuspend(arizona->dev);
+	pm_runtime_enable(arizona->dev);
+
+	/* Chip default */
+	if (!arizona->pdata.clk32k_src)
+		arizona->pdata.clk32k_src = ARIZONA_32KZ_MCLK2;
+
+	switch (arizona->pdata.clk32k_src) {
+	case ARIZONA_32KZ_MCLK1:
+	case ARIZONA_32KZ_MCLK2:
+		regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,
+				   ARIZONA_CLK_32K_SRC_MASK,
+				   arizona->pdata.clk32k_src - 1);
+		break;
+	case ARIZONA_32KZ_NONE:
+		regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,
+				   ARIZONA_CLK_32K_SRC_MASK, 2);
+		break;
+	default:
+		dev_err(arizona->dev, "Invalid 32kHz clock source: %d\n",
+			arizona->pdata.clk32k_src);
+		ret = -EINVAL;
+		goto err_ldoena;
+	}
+
+	for (i = 0; i < ARIZONA_MAX_INPUT; i++) {
+		/* Default for both is 0 so noop with defaults */
+		val = arizona->pdata.dmic_ref[i]
+			<< ARIZONA_IN1_DMIC_SUP_SHIFT;
+		val |= arizona->pdata.inmode[i] << ARIZONA_IN1_MODE_SHIFT;
+
+		regmap_update_bits(arizona->regmap,
+				   ARIZONA_IN1L_CONTROL + (i * 8),
+				   ARIZONA_IN1_DMIC_SUP_MASK |
+				   ARIZONA_IN1_MODE_MASK, val);
+	}
+
+	for (i = 0; i < ARIZONA_MAX_OUTPUT; i++) {
+		/* Default is 0 so noop with defaults */
+		if (arizona->pdata.out_mono[i])
+			val = ARIZONA_OUT1_MONO;
+		else
+			val = 0;
+
+		regmap_update_bits(arizona->regmap,
+				   ARIZONA_OUTPUT_PATH_CONFIG_1L + (i * 8),
+				   ARIZONA_OUT1_MONO, val);
+	}
+
+	BUILD_BUG_ON(ARIZONA_MAX_PDM_SPK > 1);
+	for (i = 0; i < ARIZONA_MAX_PDM_SPK; i++) {
+		if (arizona->pdata.spk_mute[i])
+			regmap_update_bits(arizona->regmap,
+					   ARIZONA_PDM_SPK1_CTRL_1,
+					   ARIZONA_SPK1_MUTE_ENDIAN_MASK |
+					   ARIZONA_SPK1_MUTE_SEQ1_MASK,
+					   arizona->pdata.spk_mute[i]);
+
+		if (arizona->pdata.spk_fmt[i])
+			regmap_update_bits(arizona->regmap,
+					   ARIZONA_PDM_SPK1_CTRL_2,
+					   ARIZONA_SPK1_FMT_MASK,
+					   arizona->pdata.spk_fmt[i]);
+	}
+
+	/* Set up for interrupts */
+	ret = arizona_irq_init(arizona);
+	if (ret != 0)
+		goto err_ldoena;
+
+	arizona_request_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, "CLKGEN error",
+			    arizona_clkgen_err, arizona);
+	arizona_request_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, "Overclocked",
+			    arizona_overclocked, arizona);
+	arizona_request_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, "Underclocked",
+			    arizona_underclocked, arizona);
+
+	switch (arizona->type) {
+	case WM5102:
+		ret = mfd_add_devices(arizona->dev, -1, wm5102_devs,
+				      ARRAY_SIZE(wm5102_devs), NULL, 0);
+		break;
+	}
+
+	if (ret != 0) {
+		dev_err(arizona->dev, "Failed to add subdevices: %d\n", ret);
+		goto err_irq;
+	}
+
+	return 0;
+
+err_irq:
+	arizona_irq_exit(arizona);
+err_ldoena:
+	if (arizona->pdata.ldoena) {
+		gpio_set_value_cansleep(arizona->pdata.ldoena, 0);
+		gpio_free(arizona->pdata.ldoena);
+	}
+err_reset:
+	if (arizona->pdata.reset) {
+		gpio_set_value_cansleep(arizona->pdata.reset, 1);
+		gpio_free(arizona->pdata.reset);
+	}
+err_enable:
+	regulator_bulk_disable(ARRAY_SIZE(arizona->core_supplies),
+			       arizona->core_supplies);
+err_early:
+	mfd_remove_devices(dev);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(arizona_dev_init);
+
+int __devexit arizona_dev_exit(struct arizona *arizona)
+{
+	mfd_remove_devices(arizona->dev);
+	arizona_free_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, arizona);
+	arizona_free_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, arizona);
+	arizona_free_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, arizona);
+	pm_runtime_disable(arizona->dev);
+	arizona_irq_exit(arizona);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(arizona_dev_exit);
