commit 4181bc8f6fab150f197a696861599502727e0e95
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Apr 16 11:15:43 2020 +0300

    mfd: intel_soc_pmic_bxtwc: Convert to use new SCU IPC API
    
    Convert the Intel Broxton Whiskey Cover PMIC driver to use the new SCU
    IPC API. This allows us to get rid of the PMC IPC implementation which
    is now covered in SCU IPC driver. We drop the error log if the IPC
    command fails because intel_scu_ipc_dev_command() does that already.
    
    Also move PMIC specific IPC message constants to the PMIC driver from
    the intel_pmc_ipc.h header.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 739cfb5b69fe..eba89780dbe7 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -15,7 +15,7 @@
 #include <linux/mfd/intel_soc_pmic_bxtwc.h>
 #include <linux/module.h>
 
-#include <asm/intel_pmc_ipc.h>
+#include <asm/intel_scu_ipc.h>
 
 /* PMIC device registers */
 #define REG_ADDR_MASK		0xFF00
@@ -58,6 +58,10 @@
 /* Whiskey Cove PMIC share same ACPI ID between different platforms */
 #define BROXTON_PMIC_WC_HRV	4
 
+#define PMC_PMIC_ACCESS		0xFF
+#define PMC_PMIC_READ		0x0
+#define PMC_PMIC_WRITE		0x1
+
 enum bxtwc_irqs {
 	BXTWC_PWRBTN_LVL1_IRQ = 0,
 	BXTWC_TMU_LVL1_IRQ,
@@ -288,13 +292,12 @@ static int regmap_ipc_byte_reg_read(void *context, unsigned int reg,
 
 	ipc_in[0] = reg;
 	ipc_in[1] = i2c_addr;
-	ret = intel_pmc_ipc_command(PMC_IPC_PMIC_ACCESS,
-			PMC_IPC_PMIC_ACCESS_READ,
-			ipc_in, sizeof(ipc_in), (u32 *)ipc_out, 1);
-	if (ret) {
-		dev_err(pmic->dev, "Failed to read from PMIC\n");
+	ret = intel_scu_ipc_dev_command(pmic->scu, PMC_PMIC_ACCESS,
+					PMC_PMIC_READ, ipc_in, sizeof(ipc_in),
+					ipc_out, sizeof(ipc_out));
+	if (ret)
 		return ret;
-	}
+
 	*val = ipc_out[0];
 
 	return 0;
@@ -303,7 +306,6 @@ static int regmap_ipc_byte_reg_read(void *context, unsigned int reg,
 static int regmap_ipc_byte_reg_write(void *context, unsigned int reg,
 				       unsigned int val)
 {
-	int ret;
 	int i2c_addr;
 	u8 ipc_in[3];
 	struct intel_soc_pmic *pmic = context;
@@ -321,15 +323,9 @@ static int regmap_ipc_byte_reg_write(void *context, unsigned int reg,
 	ipc_in[0] = reg;
 	ipc_in[1] = i2c_addr;
 	ipc_in[2] = val;
-	ret = intel_pmc_ipc_command(PMC_IPC_PMIC_ACCESS,
-			PMC_IPC_PMIC_ACCESS_WRITE,
-			ipc_in, sizeof(ipc_in), NULL, 0);
-	if (ret) {
-		dev_err(pmic->dev, "Failed to write to PMIC\n");
-		return ret;
-	}
-
-	return 0;
+	return intel_scu_ipc_dev_command(pmic->scu, PMC_PMIC_ACCESS,
+					 PMC_PMIC_WRITE, ipc_in, sizeof(ipc_in),
+					 NULL, 0);
 }
 
 /* sysfs interfaces to r/w PMIC registers, required by initial script */
@@ -457,6 +453,10 @@ static int bxtwc_probe(struct platform_device *pdev)
 	dev_set_drvdata(&pdev->dev, pmic);
 	pmic->dev = &pdev->dev;
 
+	pmic->scu = devm_intel_scu_ipc_dev_get(&pdev->dev);
+	if (!pmic->scu)
+		return -EPROBE_DEFER;
+
 	pmic->regmap = devm_regmap_init(&pdev->dev, NULL, pmic,
 					&bxtwc_regmap_config);
 	if (IS_ERR(pmic->regmap)) {

commit 802d9bd4fac70be2ea61fa83660a87a57d06bab0
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:27 2019 -0700

    mfd: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 6310c3bdb991..739cfb5b69fe 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -450,10 +450,8 @@ static int bxtwc_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	ret = platform_get_irq(pdev, 0);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Invalid IRQ\n");
+	if (ret < 0)
 		return ret;
-	}
 	pmic->irq = ret;
 
 	dev_set_drvdata(&pdev->dev, pmic);

commit 26c7e05a69d3843abb0e5389e7f538cd175c0f09
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Aug 30 19:52:54 2018 +0300

    mfd: Convert Intel PMIC drivers to use SPDX identifier
    1;5201;0c
    Reduce size of duplicated comments by switching to use SPDX identifier.
    
    No functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index c878724497a9..6310c3bdb991 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -1,16 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * MFD core driver for Intel Broxton Whiskey Cove PMIC
  *
  * Copyright (C) 2015 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
  */
 
 #include <linux/acpi.h>

commit 51eeee8e4e41b110b1afa374a9e7a532f4fb3e24
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Aug 30 19:52:53 2018 +0300

    mfd: Sort headers alphabetically for Intel PMIC drivers
    
    Sort headers alphabetically for better maintenance.
    
    No functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 9ca1f8c015de..c878724497a9 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -13,15 +13,16 @@
  * more details.
  */
 
-#include <linux/module.h>
 #include <linux/acpi.h>
-#include <linux/err.h>
 #include <linux/delay.h>
+#include <linux/err.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/mfd/core.h>
 #include <linux/mfd/intel_soc_pmic.h>
 #include <linux/mfd/intel_soc_pmic_bxtwc.h>
+#include <linux/module.h>
+
 #include <asm/intel_pmc_ipc.h>
 
 /* PMIC device registers */

commit 9f8ddee1dab836ca758ca8fc555ab5a3aaa5d3fd
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Aug 30 19:52:52 2018 +0300

    mfd: intel_soc_pmic_bxtwc: Chain power button IRQs as well
    
    Power button IRQ actually has a second level of interrupts to
    distinguish between UI and POWER buttons. Moreover, current
    implementation looks awkward in approach to handle second level IRQs by
    first level related IRQ chip.
    
    To address above issues, split power button IRQ to be chained as well.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 15bc052704a6..9ca1f8c015de 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -31,8 +31,8 @@
 
 /* Interrupt Status Registers */
 #define BXTWC_IRQLVL1		0x4E02
-#define BXTWC_PWRBTNIRQ		0x4E03
 
+#define BXTWC_PWRBTNIRQ		0x4E03
 #define BXTWC_THRM0IRQ		0x4E04
 #define BXTWC_THRM1IRQ		0x4E05
 #define BXTWC_THRM2IRQ		0x4E06
@@ -47,10 +47,9 @@
 
 /* Interrupt MASK Registers */
 #define BXTWC_MIRQLVL1		0x4E0E
-#define BXTWC_MPWRTNIRQ		0x4E0F
-
 #define BXTWC_MIRQLVL1_MCHGR	BIT(5)
 
+#define BXTWC_MPWRBTNIRQ	0x4E0F
 #define BXTWC_MTHRM0IRQ		0x4E12
 #define BXTWC_MTHRM1IRQ		0x4E13
 #define BXTWC_MTHRM2IRQ		0x4E14
@@ -66,9 +65,7 @@
 /* Whiskey Cove PMIC share same ACPI ID between different platforms */
 #define BROXTON_PMIC_WC_HRV	4
 
-/* Manage in two IRQ chips since mask registers are not consecutive */
 enum bxtwc_irqs {
-	/* Level 1 */
 	BXTWC_PWRBTN_LVL1_IRQ = 0,
 	BXTWC_TMU_LVL1_IRQ,
 	BXTWC_THRM_LVL1_IRQ,
@@ -77,9 +74,11 @@ enum bxtwc_irqs {
 	BXTWC_CHGR_LVL1_IRQ,
 	BXTWC_GPIO_LVL1_IRQ,
 	BXTWC_CRIT_LVL1_IRQ,
+};
 
-	/* Level 2 */
-	BXTWC_PWRBTN_IRQ,
+enum bxtwc_irqs_pwrbtn {
+	BXTWC_PWRBTN_IRQ = 0,
+	BXTWC_UIBTN_IRQ,
 };
 
 enum bxtwc_irqs_bcu {
@@ -113,7 +112,10 @@ static const struct regmap_irq bxtwc_regmap_irqs[] = {
 	REGMAP_IRQ_REG(BXTWC_CHGR_LVL1_IRQ, 0, BIT(5)),
 	REGMAP_IRQ_REG(BXTWC_GPIO_LVL1_IRQ, 0, BIT(6)),
 	REGMAP_IRQ_REG(BXTWC_CRIT_LVL1_IRQ, 0, BIT(7)),
-	REGMAP_IRQ_REG(BXTWC_PWRBTN_IRQ, 1, 0x03),
+};
+
+static const struct regmap_irq bxtwc_regmap_irqs_pwrbtn[] = {
+	REGMAP_IRQ_REG(BXTWC_PWRBTN_IRQ, 0, 0x01),
 };
 
 static const struct regmap_irq bxtwc_regmap_irqs_bcu[] = {
@@ -125,7 +127,7 @@ static const struct regmap_irq bxtwc_regmap_irqs_adc[] = {
 };
 
 static const struct regmap_irq bxtwc_regmap_irqs_chgr[] = {
-	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 0, BIT(5)),
+	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 0, 0x20),
 	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 0, 0x1f),
 	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 1, 0x1f),
 };
@@ -144,7 +146,16 @@ static struct regmap_irq_chip bxtwc_regmap_irq_chip = {
 	.mask_base = BXTWC_MIRQLVL1,
 	.irqs = bxtwc_regmap_irqs,
 	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs),
-	.num_regs = 2,
+	.num_regs = 1,
+};
+
+static struct regmap_irq_chip bxtwc_regmap_irq_chip_pwrbtn = {
+	.name = "bxtwc_irq_chip_pwrbtn",
+	.status_base = BXTWC_PWRBTNIRQ,
+	.mask_base = BXTWC_MPWRBTNIRQ,
+	.irqs = bxtwc_regmap_irqs_pwrbtn,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_pwrbtn),
+	.num_regs = 1,
 };
 
 static struct regmap_irq_chip bxtwc_regmap_irq_chip_tmu = {
@@ -472,6 +483,16 @@ static int bxtwc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = bxtwc_add_chained_irq_chip(pmic, pmic->irq_chip_data,
+					 BXTWC_PWRBTN_LVL1_IRQ,
+					 IRQF_ONESHOT,
+					 &bxtwc_regmap_irq_chip_pwrbtn,
+					 &pmic->irq_chip_data_pwrbtn);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add PWRBTN IRQ chip\n");
+		return ret;
+	}
+
 	ret = bxtwc_add_chained_irq_chip(pmic, pmic->irq_chip_data,
 					 BXTWC_TMU_LVL1_IRQ,
 					 IRQF_ONESHOT,

commit 57129044f5044dcd73c22d91491906104bd331fd
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Jun 5 12:08:05 2017 -0700

    mfd: intel_soc_pmic_bxtwc: Use chained IRQs for second level IRQ chips
    
    Whishkey cove PMIC has support to mask/unmask interrupts at two levels.
    At first level we can mask/unmask interrupt domains like TMU, GPIO, ADC,
    CHGR, BCU THERMAL and PWRBTN and at second level, it provides facility
    to mask/unmask individual interrupts belong each of this domain. For
    example, in case of TMU, at first level we have TMU interrupt domain,
    and at second level we have two interrupts, wake alarm, system alarm that
    belong to the TMU interrupt domain.
    
    Currently, in this driver all first level IRQs are registered as part of
    IRQ chip(bxtwc_regmap_irq_chip). By default, after you register the IRQ
    chip from your driver, all IRQs in that chip will masked and can only be
    enabled if that IRQ is requested using request_irq() call. This is the
    default Linux IRQ behavior model. And whenever a dependent device that
    belongs to PMIC requests only the second level IRQ and not explicitly
    unmask the first level IRQ, then in essence the second level IRQ will
    still be disabled. For example, if TMU device driver request wake_alarm
    IRQ and not explicitly unmask TMU level 1 IRQ then according to the default
    Linux IRQ model,  wake_alarm IRQ will still be disabled. So the proper
    solution to fix this issue is to use the chained IRQ chip concept. We
    should chain all the second level chip IRQs to the corresponding first
    level IRQ. To do this, we need to create separate IRQ chips for every
    group of second level IRQs.
    
    In case of TMU, when adding second level IRQ chip, instead of using PMIC
    IRQ we should use the corresponding first level IRQ. So the following
    code will change from
    
    ret = regmap_add_irq_chip(pmic->regmap, pmic->irq, ...)
    
    to,
    
    virq = regmap_irq_get_virq(&pmic->irq_chip_data, BXTWC_TMU_LVL1_IRQ);
    
    ret = regmap_add_irq_chip(pmic->regmap, virq, ...)
    
    In case of Whiskey Cove Type-C driver, Since USBC IRQ is moved under
    charger level2 IRQ chip. We should use charger IRQ chip(irq_chip_data_chgr)
    to get the USBC virtual IRQ number.
    
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Revieved-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index feeda6ed546c..15bc052704a6 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -82,20 +82,28 @@ enum bxtwc_irqs {
 	BXTWC_PWRBTN_IRQ,
 };
 
-enum bxtwc_irqs_level2 {
-	/* Level 2 */
+enum bxtwc_irqs_bcu {
 	BXTWC_BCU_IRQ = 0,
-	BXTWC_ADC_IRQ,
-	BXTWC_USBC_IRQ,
+};
+
+enum bxtwc_irqs_adc {
+	BXTWC_ADC_IRQ = 0,
+};
+
+enum bxtwc_irqs_chgr {
+	BXTWC_USBC_IRQ = 0,
 	BXTWC_CHGR0_IRQ,
 	BXTWC_CHGR1_IRQ,
-	BXTWC_CRIT_IRQ,
 };
 
 enum bxtwc_irqs_tmu {
 	BXTWC_TMU_IRQ = 0,
 };
 
+enum bxtwc_irqs_crit {
+	BXTWC_CRIT_IRQ = 0,
+};
+
 static const struct regmap_irq bxtwc_regmap_irqs[] = {
 	REGMAP_IRQ_REG(BXTWC_PWRBTN_LVL1_IRQ, 0, BIT(0)),
 	REGMAP_IRQ_REG(BXTWC_TMU_LVL1_IRQ, 0, BIT(1)),
@@ -108,19 +116,28 @@ static const struct regmap_irq bxtwc_regmap_irqs[] = {
 	REGMAP_IRQ_REG(BXTWC_PWRBTN_IRQ, 1, 0x03),
 };
 
-static const struct regmap_irq bxtwc_regmap_irqs_level2[] = {
+static const struct regmap_irq bxtwc_regmap_irqs_bcu[] = {
 	REGMAP_IRQ_REG(BXTWC_BCU_IRQ, 0, 0x1f),
-	REGMAP_IRQ_REG(BXTWC_ADC_IRQ, 1, 0xff),
-	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 2, BIT(5)),
-	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 2, 0x1f),
-	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 3, 0x1f),
-	REGMAP_IRQ_REG(BXTWC_CRIT_IRQ, 6, 0x03),
+};
+
+static const struct regmap_irq bxtwc_regmap_irqs_adc[] = {
+	REGMAP_IRQ_REG(BXTWC_ADC_IRQ, 0, 0xff),
+};
+
+static const struct regmap_irq bxtwc_regmap_irqs_chgr[] = {
+	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 0, BIT(5)),
+	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 0, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 1, 0x1f),
 };
 
 static const struct regmap_irq bxtwc_regmap_irqs_tmu[] = {
 	REGMAP_IRQ_REG(BXTWC_TMU_IRQ, 0, 0x06),
 };
 
+static const struct regmap_irq bxtwc_regmap_irqs_crit[] = {
+	REGMAP_IRQ_REG(BXTWC_CRIT_IRQ, 0, 0x03),
+};
+
 static struct regmap_irq_chip bxtwc_regmap_irq_chip = {
 	.name = "bxtwc_irq_chip",
 	.status_base = BXTWC_IRQLVL1,
@@ -130,15 +147,6 @@ static struct regmap_irq_chip bxtwc_regmap_irq_chip = {
 	.num_regs = 2,
 };
 
-static struct regmap_irq_chip bxtwc_regmap_irq_chip_level2 = {
-	.name = "bxtwc_irq_chip_level2",
-	.status_base = BXTWC_BCUIRQ,
-	.mask_base = BXTWC_MBCUIRQ,
-	.irqs = bxtwc_regmap_irqs_level2,
-	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_level2),
-	.num_regs = 10,
-};
-
 static struct regmap_irq_chip bxtwc_regmap_irq_chip_tmu = {
 	.name = "bxtwc_irq_chip_tmu",
 	.status_base = BXTWC_TMUIRQ,
@@ -148,6 +156,42 @@ static struct regmap_irq_chip bxtwc_regmap_irq_chip_tmu = {
 	.num_regs = 1,
 };
 
+static struct regmap_irq_chip bxtwc_regmap_irq_chip_bcu = {
+	.name = "bxtwc_irq_chip_bcu",
+	.status_base = BXTWC_BCUIRQ,
+	.mask_base = BXTWC_MBCUIRQ,
+	.irqs = bxtwc_regmap_irqs_bcu,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_bcu),
+	.num_regs = 1,
+};
+
+static struct regmap_irq_chip bxtwc_regmap_irq_chip_adc = {
+	.name = "bxtwc_irq_chip_adc",
+	.status_base = BXTWC_ADCIRQ,
+	.mask_base = BXTWC_MADCIRQ,
+	.irqs = bxtwc_regmap_irqs_adc,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_adc),
+	.num_regs = 1,
+};
+
+static struct regmap_irq_chip bxtwc_regmap_irq_chip_chgr = {
+	.name = "bxtwc_irq_chip_chgr",
+	.status_base = BXTWC_CHGR0IRQ,
+	.mask_base = BXTWC_MCHGR0IRQ,
+	.irqs = bxtwc_regmap_irqs_chgr,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_chgr),
+	.num_regs = 2,
+};
+
+static struct regmap_irq_chip bxtwc_regmap_irq_chip_crit = {
+	.name = "bxtwc_irq_chip_crit",
+	.status_base = BXTWC_CRITIRQ,
+	.mask_base = BXTWC_MCRITIRQ,
+	.irqs = bxtwc_regmap_irqs_crit,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_crit),
+	.num_regs = 1,
+};
+
 static struct resource gpio_resources[] = {
 	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO_LVL1_IRQ, "GPIO"),
 };
@@ -357,6 +401,26 @@ static const struct regmap_config bxtwc_regmap_config = {
 	.reg_read = regmap_ipc_byte_reg_read,
 };
 
+static int bxtwc_add_chained_irq_chip(struct intel_soc_pmic *pmic,
+				struct regmap_irq_chip_data *pdata,
+				int pirq, int irq_flags,
+				const struct regmap_irq_chip *chip,
+				struct regmap_irq_chip_data **data)
+{
+	int irq;
+
+	irq = regmap_irq_get_virq(pdata, pirq);
+	if (irq < 0) {
+		dev_err(pmic->dev,
+			"Failed to get parent vIRQ(%d) for chip %s, ret:%d\n",
+			pirq, chip->name, irq);
+		return irq;
+	}
+
+	return devm_regmap_add_irq_chip(pmic->dev, pmic->regmap, irq, irq_flags,
+					0, chip, data);
+}
+
 static int bxtwc_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -408,21 +472,65 @@ static int bxtwc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = devm_regmap_add_irq_chip(&pdev->dev, pmic->regmap, pmic->irq,
-				       IRQF_ONESHOT | IRQF_SHARED,
-				       0, &bxtwc_regmap_irq_chip_level2,
-				       &pmic->irq_chip_data_level2);
+	ret = bxtwc_add_chained_irq_chip(pmic, pmic->irq_chip_data,
+					 BXTWC_TMU_LVL1_IRQ,
+					 IRQF_ONESHOT,
+					 &bxtwc_regmap_irq_chip_tmu,
+					 &pmic->irq_chip_data_tmu);
 	if (ret) {
-		dev_err(&pdev->dev, "Failed to add secondary IRQ chip\n");
+		dev_err(&pdev->dev, "Failed to add TMU IRQ chip\n");
 		return ret;
 	}
 
-	ret = devm_regmap_add_irq_chip(&pdev->dev, pmic->regmap, pmic->irq,
-				       IRQF_ONESHOT | IRQF_SHARED,
-				       0, &bxtwc_regmap_irq_chip_tmu,
-				       &pmic->irq_chip_data_tmu);
+	/* Add chained IRQ handler for BCU IRQs */
+	ret = bxtwc_add_chained_irq_chip(pmic, pmic->irq_chip_data,
+					 BXTWC_BCU_LVL1_IRQ,
+					 IRQF_ONESHOT,
+					 &bxtwc_regmap_irq_chip_bcu,
+					 &pmic->irq_chip_data_bcu);
+
+
 	if (ret) {
-		dev_err(&pdev->dev, "Failed to add TMU IRQ chip\n");
+		dev_err(&pdev->dev, "Failed to add BUC IRQ chip\n");
+		return ret;
+	}
+
+	/* Add chained IRQ handler for ADC IRQs */
+	ret = bxtwc_add_chained_irq_chip(pmic, pmic->irq_chip_data,
+					 BXTWC_ADC_LVL1_IRQ,
+					 IRQF_ONESHOT,
+					 &bxtwc_regmap_irq_chip_adc,
+					 &pmic->irq_chip_data_adc);
+
+
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add ADC IRQ chip\n");
+		return ret;
+	}
+
+	/* Add chained IRQ handler for CHGR IRQs */
+	ret = bxtwc_add_chained_irq_chip(pmic, pmic->irq_chip_data,
+					 BXTWC_CHGR_LVL1_IRQ,
+					 IRQF_ONESHOT,
+					 &bxtwc_regmap_irq_chip_chgr,
+					 &pmic->irq_chip_data_chgr);
+
+
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add CHGR IRQ chip\n");
+		return ret;
+	}
+
+	/* Add chained IRQ handler for CRIT IRQs */
+	ret = bxtwc_add_chained_irq_chip(pmic, pmic->irq_chip_data,
+					 BXTWC_CRIT_LVL1_IRQ,
+					 IRQF_ONESHOT,
+					 &bxtwc_regmap_irq_chip_crit,
+					 &pmic->irq_chip_data_crit);
+
+
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add CRIT IRQ chip\n");
 		return ret;
 	}
 

commit 5131f072e5bff3a6a1da6b8f4882b6747e8c2a49
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Jun 5 12:08:04 2017 -0700

    mfd: intel_soc_pmic_bxtwc: Utilize devm_* functions in driver probe
    
    Cleanup the resource allocation/free code in probe function by using
    devm_* calls.
    
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index af11c43c27d2..feeda6ed546c 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -399,45 +399,44 @@ static int bxtwc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = regmap_add_irq_chip(pmic->regmap, pmic->irq,
-				  IRQF_ONESHOT | IRQF_SHARED,
-				  0, &bxtwc_regmap_irq_chip,
-				  &pmic->irq_chip_data);
+	ret = devm_regmap_add_irq_chip(&pdev->dev, pmic->regmap, pmic->irq,
+				       IRQF_ONESHOT | IRQF_SHARED,
+				       0, &bxtwc_regmap_irq_chip,
+				       &pmic->irq_chip_data);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to add IRQ chip\n");
 		return ret;
 	}
 
-	ret = regmap_add_irq_chip(pmic->regmap, pmic->irq,
-				  IRQF_ONESHOT | IRQF_SHARED,
-				  0, &bxtwc_regmap_irq_chip_level2,
-				  &pmic->irq_chip_data_level2);
+	ret = devm_regmap_add_irq_chip(&pdev->dev, pmic->regmap, pmic->irq,
+				       IRQF_ONESHOT | IRQF_SHARED,
+				       0, &bxtwc_regmap_irq_chip_level2,
+				       &pmic->irq_chip_data_level2);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to add secondary IRQ chip\n");
-		goto err_irq_chip_level2;
+		return ret;
 	}
 
-	ret = regmap_add_irq_chip(pmic->regmap, pmic->irq,
-				  IRQF_ONESHOT | IRQF_SHARED,
-				  0, &bxtwc_regmap_irq_chip_tmu,
-				  &pmic->irq_chip_data_tmu);
+	ret = devm_regmap_add_irq_chip(&pdev->dev, pmic->regmap, pmic->irq,
+				       IRQF_ONESHOT | IRQF_SHARED,
+				       0, &bxtwc_regmap_irq_chip_tmu,
+				       &pmic->irq_chip_data_tmu);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to add TMU IRQ chip\n");
-		goto err_irq_chip_tmu;
+		return ret;
 	}
 
-	ret = mfd_add_devices(&pdev->dev, PLATFORM_DEVID_NONE, bxt_wc_dev,
-			      ARRAY_SIZE(bxt_wc_dev), NULL, 0,
-			      NULL);
+	ret = devm_mfd_add_devices(&pdev->dev, PLATFORM_DEVID_NONE, bxt_wc_dev,
+				   ARRAY_SIZE(bxt_wc_dev), NULL, 0, NULL);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to add devices\n");
-		goto err_mfd;
+		return ret;
 	}
 
 	ret = sysfs_create_group(&pdev->dev.kobj, &bxtwc_group);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to create sysfs group %d\n", ret);
-		goto err_sysfs;
+		return ret;
 	}
 
 	/*
@@ -451,28 +450,11 @@ static int bxtwc_probe(struct platform_device *pdev)
 				BXTWC_MIRQLVL1_MCHGR, 0);
 
 	return 0;
-
-err_sysfs:
-	mfd_remove_devices(&pdev->dev);
-err_mfd:
-	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_tmu);
-err_irq_chip_tmu:
-	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_level2);
-err_irq_chip_level2:
-	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data);
-
-	return ret;
 }
 
 static int bxtwc_remove(struct platform_device *pdev)
 {
-	struct intel_soc_pmic *pmic = dev_get_drvdata(&pdev->dev);
-
 	sysfs_remove_group(&pdev->dev.kobj, &bxtwc_group);
-	mfd_remove_devices(&pdev->dev);
-	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data);
-	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_level2);
-	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_tmu);
 
 	return 0;
 }

commit a1d28c5991137f789162f412764dd7471aca6ec0
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Jun 5 12:08:03 2017 -0700

    mfd: intel_soc_pmic_bxtwc: Remove second level IRQ for gpio device
    
    Currently all PMIC GPIO domain IRQs are consumed by the same
    device(bxt_wcove_gpio), so there is no need to export them as
    separate interrupts. We can just export only the first level
    GPIO IRQ(BXTWC_GPIO_LVL1_IRQ) as an IRQ resource and let the
    GPIO device driver(bxt_wcove_gpio) handle the GPIO sub domain
    IRQs based on status value of GPIO level2 interrupt status
    register. Also, just using only the first level IRQ will eliminate
    the bug involved in requesting only the second level IRQ and not
    explicitly enable the first level IRQ. For more info on this
    issue please read the details at,
    
    https://lkml.org/lkml/2017/2/27/148
    
    This patch also makes relevant change in Whiskey cove GPIO driver to
    use only first level PMIC GPIO IRQ.
    
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-for-MFD-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 7c1ed27c7720..af11c43c27d2 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -89,8 +89,6 @@ enum bxtwc_irqs_level2 {
 	BXTWC_USBC_IRQ,
 	BXTWC_CHGR0_IRQ,
 	BXTWC_CHGR1_IRQ,
-	BXTWC_GPIO0_IRQ,
-	BXTWC_GPIO1_IRQ,
 	BXTWC_CRIT_IRQ,
 };
 
@@ -116,8 +114,6 @@ static const struct regmap_irq bxtwc_regmap_irqs_level2[] = {
 	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 2, BIT(5)),
 	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 2, 0x1f),
 	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 3, 0x1f),
-	REGMAP_IRQ_REG(BXTWC_GPIO0_IRQ, 4, 0xff),
-	REGMAP_IRQ_REG(BXTWC_GPIO1_IRQ, 5, 0x3f),
 	REGMAP_IRQ_REG(BXTWC_CRIT_IRQ, 6, 0x03),
 };
 
@@ -153,8 +149,7 @@ static struct regmap_irq_chip bxtwc_regmap_irq_chip_tmu = {
 };
 
 static struct resource gpio_resources[] = {
-	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO0_IRQ, "GPIO0"),
-	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO1_IRQ, "GPIO1"),
+	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO_LVL1_IRQ, "GPIO"),
 };
 
 static struct resource adc_resources[] = {

commit c4949630fe437bc15346abbd1a92dee8e80a85d4
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Jun 5 12:08:02 2017 -0700

    mfd: intel_soc_pmic_bxtwc: Remove thermal second level IRQs
    
    Since all second level thermal IRQs are consumed by the same
    device(bxt_wcove_thermal), there is no need to expose them as separate
    interrupts. We can just export only the first level IRQs for thermal and
    let the device(bxt_wcove_thermal) driver handle the second level IRQs
    based on thermal interrupt status register. Also, just using only the
    first level IRQ will eliminate the bug involved in requesting only the
    second level IRQ and not explicitly enable the first level IRQ. For
    more info on this issue please read the details at,
    
    https://lkml.org/lkml/2017/2/27/148
    
    This patch also makes relevant change in bxt_wcove_thermal driver to use
    only first level PMIC thermal IRQ.
    
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 7cbaf1eda3f8..7c1ed27c7720 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -84,10 +84,7 @@ enum bxtwc_irqs {
 
 enum bxtwc_irqs_level2 {
 	/* Level 2 */
-	BXTWC_THRM0_IRQ = 0,
-	BXTWC_THRM1_IRQ,
-	BXTWC_THRM2_IRQ,
-	BXTWC_BCU_IRQ,
+	BXTWC_BCU_IRQ = 0,
 	BXTWC_ADC_IRQ,
 	BXTWC_USBC_IRQ,
 	BXTWC_CHGR0_IRQ,
@@ -114,17 +111,14 @@ static const struct regmap_irq bxtwc_regmap_irqs[] = {
 };
 
 static const struct regmap_irq bxtwc_regmap_irqs_level2[] = {
-	REGMAP_IRQ_REG(BXTWC_THRM0_IRQ, 0, 0xff),
-	REGMAP_IRQ_REG(BXTWC_THRM1_IRQ, 1, 0xbf),
-	REGMAP_IRQ_REG(BXTWC_THRM2_IRQ, 2, 0xff),
-	REGMAP_IRQ_REG(BXTWC_BCU_IRQ, 3, 0x1f),
-	REGMAP_IRQ_REG(BXTWC_ADC_IRQ, 4, 0xff),
-	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 5, BIT(5)),
-	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 5, 0x1f),
-	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 6, 0x1f),
-	REGMAP_IRQ_REG(BXTWC_GPIO0_IRQ, 7, 0xff),
-	REGMAP_IRQ_REG(BXTWC_GPIO1_IRQ, 8, 0x3f),
-	REGMAP_IRQ_REG(BXTWC_CRIT_IRQ, 9, 0x03),
+	REGMAP_IRQ_REG(BXTWC_BCU_IRQ, 0, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_ADC_IRQ, 1, 0xff),
+	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 2, BIT(5)),
+	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 2, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 3, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_GPIO0_IRQ, 4, 0xff),
+	REGMAP_IRQ_REG(BXTWC_GPIO1_IRQ, 5, 0x3f),
+	REGMAP_IRQ_REG(BXTWC_CRIT_IRQ, 6, 0x03),
 };
 
 static const struct regmap_irq bxtwc_regmap_irqs_tmu[] = {
@@ -142,8 +136,8 @@ static struct regmap_irq_chip bxtwc_regmap_irq_chip = {
 
 static struct regmap_irq_chip bxtwc_regmap_irq_chip_level2 = {
 	.name = "bxtwc_irq_chip_level2",
-	.status_base = BXTWC_THRM0IRQ,
-	.mask_base = BXTWC_MTHRM0IRQ,
+	.status_base = BXTWC_BCUIRQ,
+	.mask_base = BXTWC_MBCUIRQ,
 	.irqs = bxtwc_regmap_irqs_level2,
 	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_level2),
 	.num_regs = 10,
@@ -177,9 +171,7 @@ static struct resource charger_resources[] = {
 };
 
 static struct resource thermal_resources[] = {
-	DEFINE_RES_IRQ(BXTWC_THRM0_IRQ),
-	DEFINE_RES_IRQ(BXTWC_THRM1_IRQ),
-	DEFINE_RES_IRQ(BXTWC_THRM2_IRQ),
+	DEFINE_RES_IRQ(BXTWC_THRM_LVL1_IRQ),
 };
 
 static struct resource bcu_resources[] = {

commit 4533d8551b7dc594f5d203c1dc6c1527a21ad61d
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Jun 5 12:08:01 2017 -0700

    mfd: intel_soc_pmic_bxtwc: Fix TMU interrupt index
    
    TMU interrupts are registered as a separate interrupt chip, and
    hence it should start its interrupt index(BXTWC_TMU_IRQ) number
    from 0. But currently, BXTWC_TMU_IRQ is defined as part of enum
    bxtwc_irqs_level2 and its index value is 11. Since this index
    value is used when calculating .num_irqs of regmap_irq_chip_tmu,
    it incorrectly reports number of IRQs as 12 instead of actual
    value of 1.
    
    This patch fixes this issue by creating new enum of tmu IRQs and
    resetting its starting index to 0.
    
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 8c3cbf63c6ad..7cbaf1eda3f8 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -95,7 +95,10 @@ enum bxtwc_irqs_level2 {
 	BXTWC_GPIO0_IRQ,
 	BXTWC_GPIO1_IRQ,
 	BXTWC_CRIT_IRQ,
-	BXTWC_TMU_IRQ,
+};
+
+enum bxtwc_irqs_tmu {
+	BXTWC_TMU_IRQ = 0,
 };
 
 static const struct regmap_irq bxtwc_regmap_irqs[] = {

commit b4ccc4d2e82f7c7f8304f44544bdefcd16234582
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Thu Mar 30 16:35:40 2017 -0700

    mfd: bxtwc: Remove unnecessary i2c_addr checks in ipc calls
    
    In the following code block, BXTWC_DEVICE1_ADDR value is
    already fixed and hence there no need to check for
    if (!i2c_addr) in every ipc read/write calls. Even if this
    check is required it can be moved to probe function.
    
    i2c_addr = BXTWC_DEVICE1_ADDR;
    if (!i2c_addr) {
            dev_err(pmic->dev, "I2C address not set\n");
            return -EINVAL;
    }
    
    This patch remove this extra check and adds some NULL
    parameter checks.
    
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 1496a862baa6..8c3cbf63c6ad 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -238,15 +238,14 @@ static int regmap_ipc_byte_reg_read(void *context, unsigned int reg,
 	u8 ipc_out[4];
 	struct intel_soc_pmic *pmic = context;
 
+	if (!pmic)
+		return -EINVAL;
+
 	if (reg & REG_ADDR_MASK)
 		i2c_addr = (reg & REG_ADDR_MASK) >> REG_ADDR_SHIFT;
-	else {
+	else
 		i2c_addr = BXTWC_DEVICE1_ADDR;
-		if (!i2c_addr) {
-			dev_err(pmic->dev, "I2C address not set\n");
-			return -EINVAL;
-		}
-	}
+
 	reg &= REG_OFFSET_MASK;
 
 	ipc_in[0] = reg;
@@ -271,15 +270,14 @@ static int regmap_ipc_byte_reg_write(void *context, unsigned int reg,
 	u8 ipc_in[3];
 	struct intel_soc_pmic *pmic = context;
 
+	if (!pmic)
+		return -EINVAL;
+
 	if (reg & REG_ADDR_MASK)
 		i2c_addr = (reg & REG_ADDR_MASK) >> REG_ADDR_SHIFT;
-	else {
+	else
 		i2c_addr = BXTWC_DEVICE1_ADDR;
-		if (!i2c_addr) {
-			dev_err(pmic->dev, "I2C address not set\n");
-			return -EINVAL;
-		}
-	}
+
 	reg &= REG_OFFSET_MASK;
 
 	ipc_in[0] = reg;

commit 0c227c51b98c03c6e7fb4f342f930cf576292064
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 17 17:37:15 2017 +0200

    mfd: intel_soc_pmic_bxtwc: Rename header to follow c-file
    
    For better understanding of relationship between headers and modules
    rename:
            intel_bxtwc.h -> intel_soc_pmic_bxtwc.h
    
    While here, remove file name from the file itself.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index c71db687b7ca..1496a862baa6 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -20,8 +20,8 @@
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/mfd/core.h>
-#include <linux/mfd/intel_bxtwc.h>
 #include <linux/mfd/intel_soc_pmic.h>
+#include <linux/mfd/intel_soc_pmic_bxtwc.h>
 #include <asm/intel_pmc_ipc.h>
 
 /* PMIC device registers */

commit f1e34ad849ad78770af067fd8e409e61b018f9d0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 17 17:37:14 2017 +0200

    mfd: intel_soc_pmic_bxtwc: Move inclusion to c-file
    
    There is no need to include intel_soc_pmic.h into header which doesn't
    require it.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 699c8c7c9052..c71db687b7ca 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -21,6 +21,7 @@
 #include <linux/kernel.h>
 #include <linux/mfd/core.h>
 #include <linux/mfd/intel_bxtwc.h>
+#include <linux/mfd/intel_soc_pmic.h>
 #include <asm/intel_pmc_ipc.h>
 
 /* PMIC device registers */

commit ac5a28b0d3d173ba0a581342416ed339f2c3be3d
Merge: b0b3a37b908b 93559191e71b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 19 08:16:26 2016 -0800

    Merge tag 'mfd-for-linus-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd
    
    Pull MFD updates from Lee Jones:
     "New Device Support
       - Add support for Ricoh RC5T619 PMIC to rn5t618
       - Add support for PM8821 PMIC to qcom-pm8xxx
    
      New Functionality:
       - Add support for GPIO to lpc_ich
       - Add support for GPADC to sun4i
       - Add ability for rk808 to shutdown
    
      Fix-ups:
       - Simplify/strip unnecessary code; tps65218, palmas, tps65217
       - Device Tree binding updates; tps65218, altera-a10sr
       - Provide/export device ID info; tps65218, axp20x-i2c, hi655x-pmic,
         fsl-imx25-tsadc, intel_soc_pmic_bxtwc
       - Use MFD API instead of of_platform_populate(); tps65218
       - Generalise name-space; pm8xxx
       - Supply/edit regmap configuration; axp20x, cs47l24-tables, axp20x
       - Enable compile testing; max77620, max77686, exynos-lpass,
         abx500-core
       - Coding style issues; wm8994-core, wm5102-tables
       - Supply endian support; syscon
       - Remove module support; ab3100-core, ab8500-debugfs, ab8500-gpadc,
         abx500-core
    
      Bug Fixes:
       - Fix ordering issues; wm8994
       - Fix dependencies (build-time/run-time); exynos_lpass, sun4i-gpadc
       - Fix compiler warnings; sun4i-gpadc
       - Fix leaks; mfd-core
       - Fix page fault during module unload; tps65217"
    
    * tag 'mfd-for-linus-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd: (49 commits)
      mfd: tps65217: Support an interrupt pin as the system wakeup
      mfd: tps65217: Make an interrupt handler simpler
      mfd: tps65217: Update register interrupt mask bits instead of writing operation
      mfd: tps65217: Specify the IRQ name
      mfd: tps65217: Fix page fault on unloading modules
      mfd: palmas: Remove redundant check in palmas_power_off
      mfd: arizona: Disable IRQs during driver remove
      mfd: pm8xxx: add support to pm8821
      mfd: intel-lpss: Try to enable Memory-Write-Invalidate
      mfd: rn5t618: Add Ricoh RC5T619 PMIC support
      mfd: axp20x: Add address extension registers for AXP806 regmap
      mfd: intel_soc_pmic_bxtwc: Fix a typo in MODULE_DEVICE_TABLE()
      mfd: core: Fix device reference leak in mfd_clone_cell
      mfd: bcm590xx: Simplify a test
      mfd: sun4i-gpadc: Select regmap-irq
      mfd: abx500-core: drop unused MODULE_ tags from non-modular code
      mfd: ab8500: make sysctrl explicitly non-modular
      mfd: ab8500-gpadc: Make it explicitly non-modular
      mfd: ab8500-debugfs: Make it explicitly non-modular
      mfd: ab8500-core: Make it explicitly non-modular
      ...

commit 8421c60446290c0fef1858a806261871a40ebf76
Merge: f7dd3b1734ea 83da6b59919a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 18 15:45:33 2016 -0800

    Merge tag 'platform-drivers-x86-v4.10-2' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86
    
    Pull more x86 platform driver updates from Darren Hart:
     "Move and add registration for the mlx-platform driver. Introduce
      button and lid drivers for the surface3 (different from the
      surface3-pro). Add BXT PMIC TMU support. Add Y700 to existing
      ideapad-laptop quirk.
    
      Summary:
    
      ideapad-laptop:
       - Add Y700 15-ACZ to no_hw_rfkill DMI list
    
      surface3_button:
       - Introduce button support for the Surface 3
    
      surface3-wmi:
       - Add custom surface3 platform device for controlling LID
       - Balance locking on error path
    
      mlx-platform:
       - Add mlxcpld-hotplug driver registration
       - Fix semicolon.cocci warnings
       - Move module from arch/x86
    
      platform/x86:
       - Add Whiskey Cove PMIC TMU support"
    
    * tag 'platform-drivers-x86-v4.10-2' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86:
      platform/x86: surface3-wmi: Balance locking on error path
      platform/x86: Add Whiskey Cove PMIC TMU support
      platform/x86: ideapad-laptop: Add Y700 15-ACZ to no_hw_rfkill DMI list
      platform/x86: Introduce button support for the Surface 3
      platform/x86: Add custom surface3 platform device for controlling LID
      platform/x86: mlx-platform: Add mlxcpld-hotplug driver registration
      platform/x86: mlx-platform: Fix semicolon.cocci warnings
      platform/x86: mlx-platform: Move module from arch/x86

commit 957ae5098185e763b5c06be6c3b4b6e98c048712
Author: Nilesh Bacchewar <nilesh.bacchewar@intel.com>
Date:   Mon Nov 7 12:11:47 2016 -0800

    platform/x86: Add Whiskey Cove PMIC TMU support
    
    This adds TMU (Time Management Unit) support for Intel BXT platform.
    It enables the alarm wake-up functionality in the TMU unit of Whiskey Cove
    PMIC.
    
    Signed-off-by: Nilesh Bacchewar <nilesh.bacchewar@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [andy: resolve merge conflict in Kconfig]
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 43e54b7e908f..92aba02042f0 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -42,6 +42,7 @@
 #define BXTWC_GPIOIRQ0		0x4E0B
 #define BXTWC_GPIOIRQ1		0x4E0C
 #define BXTWC_CRITIRQ		0x4E0D
+#define BXTWC_TMUIRQ		0x4FB6
 
 /* Interrupt MASK Registers */
 #define BXTWC_MIRQLVL1		0x4E0E
@@ -59,6 +60,7 @@
 #define BXTWC_MGPIO0IRQ		0x4E19
 #define BXTWC_MGPIO1IRQ		0x4E1A
 #define BXTWC_MCRITIRQ		0x4E1B
+#define BXTWC_MTMUIRQ		0x4FB7
 
 /* Whiskey Cove PMIC share same ACPI ID between different platforms */
 #define BROXTON_PMIC_WC_HRV	4
@@ -91,6 +93,7 @@ enum bxtwc_irqs_level2 {
 	BXTWC_GPIO0_IRQ,
 	BXTWC_GPIO1_IRQ,
 	BXTWC_CRIT_IRQ,
+	BXTWC_TMU_IRQ,
 };
 
 static const struct regmap_irq bxtwc_regmap_irqs[] = {
@@ -118,6 +121,10 @@ static const struct regmap_irq bxtwc_regmap_irqs_level2[] = {
 	REGMAP_IRQ_REG(BXTWC_CRIT_IRQ, 9, 0x03),
 };
 
+static const struct regmap_irq bxtwc_regmap_irqs_tmu[] = {
+	REGMAP_IRQ_REG(BXTWC_TMU_IRQ, 0, 0x06),
+};
+
 static struct regmap_irq_chip bxtwc_regmap_irq_chip = {
 	.name = "bxtwc_irq_chip",
 	.status_base = BXTWC_IRQLVL1,
@@ -136,6 +143,15 @@ static struct regmap_irq_chip bxtwc_regmap_irq_chip_level2 = {
 	.num_regs = 10,
 };
 
+static struct regmap_irq_chip bxtwc_regmap_irq_chip_tmu = {
+	.name = "bxtwc_irq_chip_tmu",
+	.status_base = BXTWC_TMUIRQ,
+	.mask_base = BXTWC_MTMUIRQ,
+	.irqs = bxtwc_regmap_irqs_tmu,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_tmu),
+	.num_regs = 1,
+};
+
 static struct resource gpio_resources[] = {
 	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO0_IRQ, "GPIO0"),
 	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO1_IRQ, "GPIO1"),
@@ -164,6 +180,10 @@ static struct resource bcu_resources[] = {
 	DEFINE_RES_IRQ_NAMED(BXTWC_BCU_IRQ, "BCU"),
 };
 
+static struct resource tmu_resources[] = {
+	DEFINE_RES_IRQ_NAMED(BXTWC_TMU_IRQ, "TMU"),
+};
+
 static struct mfd_cell bxt_wc_dev[] = {
 	{
 		.name = "bxt_wcove_gpadc",
@@ -190,6 +210,12 @@ static struct mfd_cell bxt_wc_dev[] = {
 		.num_resources = ARRAY_SIZE(bcu_resources),
 		.resources = bcu_resources,
 	},
+	{
+		.name = "bxt_wcove_tmu",
+		.num_resources = ARRAY_SIZE(tmu_resources),
+		.resources = tmu_resources,
+	},
+
 	{
 		.name = "bxt_wcove_gpio",
 		.num_resources = ARRAY_SIZE(gpio_resources),
@@ -400,6 +426,15 @@ static int bxtwc_probe(struct platform_device *pdev)
 		goto err_irq_chip_level2;
 	}
 
+	ret = regmap_add_irq_chip(pmic->regmap, pmic->irq,
+				  IRQF_ONESHOT | IRQF_SHARED,
+				  0, &bxtwc_regmap_irq_chip_tmu,
+				  &pmic->irq_chip_data_tmu);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add TMU IRQ chip\n");
+		goto err_irq_chip_tmu;
+	}
+
 	ret = mfd_add_devices(&pdev->dev, PLATFORM_DEVID_NONE, bxt_wc_dev,
 			      ARRAY_SIZE(bxt_wc_dev), NULL, 0,
 			      NULL);
@@ -429,6 +464,8 @@ static int bxtwc_probe(struct platform_device *pdev)
 err_sysfs:
 	mfd_remove_devices(&pdev->dev);
 err_mfd:
+	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_tmu);
+err_irq_chip_tmu:
 	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_level2);
 err_irq_chip_level2:
 	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data);
@@ -444,6 +481,7 @@ static int bxtwc_remove(struct platform_device *pdev)
 	mfd_remove_devices(&pdev->dev);
 	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data);
 	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_level2);
+	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_tmu);
 
 	return 0;
 }

commit f57576e73cc4808af3b097b1fdedfa7d0f6378a4
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Tue Nov 1 15:59:50 2016 +0000

    mfd: intel_soc_pmic_bxtwc: Fix a typo in MODULE_DEVICE_TABLE()
    
    Fix a typo in MODULE_DEVICE_TABLE(). 'pmic_acpi_ids' should be
    'bxtwc_acpi_ids'.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 43e54b7e908f..9f9c04364254 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -479,7 +479,7 @@ static const struct acpi_device_id bxtwc_acpi_ids[] = {
 	{ "INT34D3", },
 	{ }
 };
-MODULE_DEVICE_TABLE(acpi, pmic_acpi_ids);
+MODULE_DEVICE_TABLE(acpi, bxtwc_acpi_ids);
 
 static struct platform_driver bxtwc_driver = {
 	.probe = bxtwc_probe,

commit 9600702082b29fd3f8a6d744df74ad4c48d4a432
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Oct 17 10:32:13 2016 +0300

    mfd: intel_soc_pmic_bxtwc: Fix usbc interrupt
    
    The wcove USB Type-C driver is currently being flooded with
    interrupts that are not targeted to it. The reason for that
    is because all CHRG first level interrupts are mapped to it.
    This fixes the issue by introducing separate irq for the
    usbc device, and mapping only USB Type-C PHY interrupts to
    it.
    
    Fixes: 9c6235c86332 ("mfd: intel_soc_pmic_bxtwc: Add bxt_wcove_usbc device")
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 43e54b7e908f..f9a8c5203873 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -86,6 +86,7 @@ enum bxtwc_irqs_level2 {
 	BXTWC_THRM2_IRQ,
 	BXTWC_BCU_IRQ,
 	BXTWC_ADC_IRQ,
+	BXTWC_USBC_IRQ,
 	BXTWC_CHGR0_IRQ,
 	BXTWC_CHGR1_IRQ,
 	BXTWC_GPIO0_IRQ,
@@ -111,7 +112,8 @@ static const struct regmap_irq bxtwc_regmap_irqs_level2[] = {
 	REGMAP_IRQ_REG(BXTWC_THRM2_IRQ, 2, 0xff),
 	REGMAP_IRQ_REG(BXTWC_BCU_IRQ, 3, 0x1f),
 	REGMAP_IRQ_REG(BXTWC_ADC_IRQ, 4, 0xff),
-	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 5, 0x3f),
+	REGMAP_IRQ_REG(BXTWC_USBC_IRQ, 5, BIT(5)),
+	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 5, 0x1f),
 	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 6, 0x1f),
 	REGMAP_IRQ_REG(BXTWC_GPIO0_IRQ, 7, 0xff),
 	REGMAP_IRQ_REG(BXTWC_GPIO1_IRQ, 8, 0x3f),
@@ -146,7 +148,7 @@ static struct resource adc_resources[] = {
 };
 
 static struct resource usbc_resources[] = {
-	DEFINE_RES_IRQ_NAMED(BXTWC_CHGR0_IRQ, "USBC"),
+	DEFINE_RES_IRQ(BXTWC_USBC_IRQ),
 };
 
 static struct resource charger_resources[] = {

commit 9c6235c8633210cc2da0882e2e9d6ff90aa37503
Author: Bin Gao <bin.gao@linux.intel.com>
Date:   Wed Jul 20 17:33:56 2016 -0700

    mfd: intel_soc_pmic_bxtwc: Add bxt_wcove_usbc device
    
    The Intel Whiskey Cove PMIC includes several function units, e.g.
    ADC, thermal, USB Type-C, GPIO, etc. The corresponding device has
    to be created in the mfd driver(intel_soc_pmic_bxtwc.c). This change
    adds the USB Type-c device.
    
    Signed-off-by: Bin Gao <bin.gao@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index b9428767e615..43e54b7e908f 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -47,6 +47,8 @@
 #define BXTWC_MIRQLVL1		0x4E0E
 #define BXTWC_MPWRTNIRQ		0x4E0F
 
+#define BXTWC_MIRQLVL1_MCHGR	BIT(5)
+
 #define BXTWC_MTHRM0IRQ		0x4E12
 #define BXTWC_MTHRM1IRQ		0x4E13
 #define BXTWC_MTHRM2IRQ		0x4E14
@@ -109,7 +111,7 @@ static const struct regmap_irq bxtwc_regmap_irqs_level2[] = {
 	REGMAP_IRQ_REG(BXTWC_THRM2_IRQ, 2, 0xff),
 	REGMAP_IRQ_REG(BXTWC_BCU_IRQ, 3, 0x1f),
 	REGMAP_IRQ_REG(BXTWC_ADC_IRQ, 4, 0xff),
-	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 5, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 5, 0x3f),
 	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 6, 0x1f),
 	REGMAP_IRQ_REG(BXTWC_GPIO0_IRQ, 7, 0xff),
 	REGMAP_IRQ_REG(BXTWC_GPIO1_IRQ, 8, 0x3f),
@@ -143,6 +145,10 @@ static struct resource adc_resources[] = {
 	DEFINE_RES_IRQ_NAMED(BXTWC_ADC_IRQ, "ADC"),
 };
 
+static struct resource usbc_resources[] = {
+	DEFINE_RES_IRQ_NAMED(BXTWC_CHGR0_IRQ, "USBC"),
+};
+
 static struct resource charger_resources[] = {
 	DEFINE_RES_IRQ_NAMED(BXTWC_CHGR0_IRQ, "CHARGER"),
 	DEFINE_RES_IRQ_NAMED(BXTWC_CHGR1_IRQ, "CHARGER1"),
@@ -169,6 +175,11 @@ static struct mfd_cell bxt_wc_dev[] = {
 		.num_resources = ARRAY_SIZE(thermal_resources),
 		.resources = thermal_resources,
 	},
+	{
+		.name = "bxt_wcove_usbc",
+		.num_resources = ARRAY_SIZE(usbc_resources),
+		.resources = usbc_resources,
+	},
 	{
 		.name = "bxt_wcove_ext_charger",
 		.num_resources = ARRAY_SIZE(charger_resources),
@@ -403,6 +414,16 @@ static int bxtwc_probe(struct platform_device *pdev)
 		goto err_sysfs;
 	}
 
+	/*
+	 * There is known hw bug. Upon reset BIT 5 of register
+	 * BXTWC_CHGR_LVL1_IRQ is 0 which is the expected value. However,
+	 * later it's set to 1(masked) automatically by hardware. So we
+	 * have the software workaround here to unmaksed it in order to let
+	 * charger interrutp work.
+	 */
+	regmap_update_bits(pmic->regmap, BXTWC_MIRQLVL1,
+				BXTWC_MIRQLVL1_MCHGR, 0);
+
 	return 0;
 
 err_sysfs:

commit f3a654c5198b1de3e6241ab6a9d5c52295504970
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Sep 28 12:56:36 2015 +0300

    mfd: intel_soc_pmic_bxtwc: 64 bit bug in bxtwc_val_store()
    
    The call to kstrtoul() will corrupt memory on 64 bit systems because an
    int is 4 bytes and a long is 8.
    
    Also it's not a good idea to let users trigger a dev_err() because it
    just ends up flooding /var/log/messages so I removed the printk.
    
    Fixes: 2ddd2086ea9c ('mfd: add Intel Broxton Whiskey Cove PMIC driver')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
index 40acaff2e1c3..b9428767e615 100644
--- a/drivers/mfd/intel_soc_pmic_bxtwc.c
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -297,10 +297,9 @@ static ssize_t bxtwc_val_store(struct device *dev,
 	unsigned int val;
 	struct intel_soc_pmic *pmic = dev_get_drvdata(dev);
 
-	if (kstrtoul(buf, 0, (unsigned long *)&val)) {
-		dev_err(dev, "Invalid register value\n");
-		return -EINVAL;
-	}
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
 
 	ret = regmap_write(pmic->regmap, bxtwc_reg_addr, val);
 	if (ret) {

commit 39d047c0b1c812e9f0014e7100e372e61f2de3de
Author: Qipeng Zha <qipeng.zha@intel.com>
Date:   Tue Sep 15 00:39:19 2015 +0800

    mfd: add Intel Broxton Whiskey Cove PMIC driver
    
    Add MFD core driver for Intel Broxton Whiskey Cove PMIC,
    which is specially accessed by hardware IPC, not a generic
    I2C device
    
    Signed-off-by: Qipeng Zha <qipeng.zha@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/intel_soc_pmic_bxtwc.c b/drivers/mfd/intel_soc_pmic_bxtwc.c
new file mode 100644
index 000000000000..40acaff2e1c3
--- /dev/null
+++ b/drivers/mfd/intel_soc_pmic_bxtwc.c
@@ -0,0 +1,478 @@
+/*
+ * MFD core driver for Intel Broxton Whiskey Cove PMIC
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/intel_bxtwc.h>
+#include <asm/intel_pmc_ipc.h>
+
+/* PMIC device registers */
+#define REG_ADDR_MASK		0xFF00
+#define REG_ADDR_SHIFT		8
+#define REG_OFFSET_MASK		0xFF
+
+/* Interrupt Status Registers */
+#define BXTWC_IRQLVL1		0x4E02
+#define BXTWC_PWRBTNIRQ		0x4E03
+
+#define BXTWC_THRM0IRQ		0x4E04
+#define BXTWC_THRM1IRQ		0x4E05
+#define BXTWC_THRM2IRQ		0x4E06
+#define BXTWC_BCUIRQ		0x4E07
+#define BXTWC_ADCIRQ		0x4E08
+#define BXTWC_CHGR0IRQ		0x4E09
+#define BXTWC_CHGR1IRQ		0x4E0A
+#define BXTWC_GPIOIRQ0		0x4E0B
+#define BXTWC_GPIOIRQ1		0x4E0C
+#define BXTWC_CRITIRQ		0x4E0D
+
+/* Interrupt MASK Registers */
+#define BXTWC_MIRQLVL1		0x4E0E
+#define BXTWC_MPWRTNIRQ		0x4E0F
+
+#define BXTWC_MTHRM0IRQ		0x4E12
+#define BXTWC_MTHRM1IRQ		0x4E13
+#define BXTWC_MTHRM2IRQ		0x4E14
+#define BXTWC_MBCUIRQ		0x4E15
+#define BXTWC_MADCIRQ		0x4E16
+#define BXTWC_MCHGR0IRQ		0x4E17
+#define BXTWC_MCHGR1IRQ		0x4E18
+#define BXTWC_MGPIO0IRQ		0x4E19
+#define BXTWC_MGPIO1IRQ		0x4E1A
+#define BXTWC_MCRITIRQ		0x4E1B
+
+/* Whiskey Cove PMIC share same ACPI ID between different platforms */
+#define BROXTON_PMIC_WC_HRV	4
+
+/* Manage in two IRQ chips since mask registers are not consecutive */
+enum bxtwc_irqs {
+	/* Level 1 */
+	BXTWC_PWRBTN_LVL1_IRQ = 0,
+	BXTWC_TMU_LVL1_IRQ,
+	BXTWC_THRM_LVL1_IRQ,
+	BXTWC_BCU_LVL1_IRQ,
+	BXTWC_ADC_LVL1_IRQ,
+	BXTWC_CHGR_LVL1_IRQ,
+	BXTWC_GPIO_LVL1_IRQ,
+	BXTWC_CRIT_LVL1_IRQ,
+
+	/* Level 2 */
+	BXTWC_PWRBTN_IRQ,
+};
+
+enum bxtwc_irqs_level2 {
+	/* Level 2 */
+	BXTWC_THRM0_IRQ = 0,
+	BXTWC_THRM1_IRQ,
+	BXTWC_THRM2_IRQ,
+	BXTWC_BCU_IRQ,
+	BXTWC_ADC_IRQ,
+	BXTWC_CHGR0_IRQ,
+	BXTWC_CHGR1_IRQ,
+	BXTWC_GPIO0_IRQ,
+	BXTWC_GPIO1_IRQ,
+	BXTWC_CRIT_IRQ,
+};
+
+static const struct regmap_irq bxtwc_regmap_irqs[] = {
+	REGMAP_IRQ_REG(BXTWC_PWRBTN_LVL1_IRQ, 0, BIT(0)),
+	REGMAP_IRQ_REG(BXTWC_TMU_LVL1_IRQ, 0, BIT(1)),
+	REGMAP_IRQ_REG(BXTWC_THRM_LVL1_IRQ, 0, BIT(2)),
+	REGMAP_IRQ_REG(BXTWC_BCU_LVL1_IRQ, 0, BIT(3)),
+	REGMAP_IRQ_REG(BXTWC_ADC_LVL1_IRQ, 0, BIT(4)),
+	REGMAP_IRQ_REG(BXTWC_CHGR_LVL1_IRQ, 0, BIT(5)),
+	REGMAP_IRQ_REG(BXTWC_GPIO_LVL1_IRQ, 0, BIT(6)),
+	REGMAP_IRQ_REG(BXTWC_CRIT_LVL1_IRQ, 0, BIT(7)),
+	REGMAP_IRQ_REG(BXTWC_PWRBTN_IRQ, 1, 0x03),
+};
+
+static const struct regmap_irq bxtwc_regmap_irqs_level2[] = {
+	REGMAP_IRQ_REG(BXTWC_THRM0_IRQ, 0, 0xff),
+	REGMAP_IRQ_REG(BXTWC_THRM1_IRQ, 1, 0xbf),
+	REGMAP_IRQ_REG(BXTWC_THRM2_IRQ, 2, 0xff),
+	REGMAP_IRQ_REG(BXTWC_BCU_IRQ, 3, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_ADC_IRQ, 4, 0xff),
+	REGMAP_IRQ_REG(BXTWC_CHGR0_IRQ, 5, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_CHGR1_IRQ, 6, 0x1f),
+	REGMAP_IRQ_REG(BXTWC_GPIO0_IRQ, 7, 0xff),
+	REGMAP_IRQ_REG(BXTWC_GPIO1_IRQ, 8, 0x3f),
+	REGMAP_IRQ_REG(BXTWC_CRIT_IRQ, 9, 0x03),
+};
+
+static struct regmap_irq_chip bxtwc_regmap_irq_chip = {
+	.name = "bxtwc_irq_chip",
+	.status_base = BXTWC_IRQLVL1,
+	.mask_base = BXTWC_MIRQLVL1,
+	.irqs = bxtwc_regmap_irqs,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs),
+	.num_regs = 2,
+};
+
+static struct regmap_irq_chip bxtwc_regmap_irq_chip_level2 = {
+	.name = "bxtwc_irq_chip_level2",
+	.status_base = BXTWC_THRM0IRQ,
+	.mask_base = BXTWC_MTHRM0IRQ,
+	.irqs = bxtwc_regmap_irqs_level2,
+	.num_irqs = ARRAY_SIZE(bxtwc_regmap_irqs_level2),
+	.num_regs = 10,
+};
+
+static struct resource gpio_resources[] = {
+	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO0_IRQ, "GPIO0"),
+	DEFINE_RES_IRQ_NAMED(BXTWC_GPIO1_IRQ, "GPIO1"),
+};
+
+static struct resource adc_resources[] = {
+	DEFINE_RES_IRQ_NAMED(BXTWC_ADC_IRQ, "ADC"),
+};
+
+static struct resource charger_resources[] = {
+	DEFINE_RES_IRQ_NAMED(BXTWC_CHGR0_IRQ, "CHARGER"),
+	DEFINE_RES_IRQ_NAMED(BXTWC_CHGR1_IRQ, "CHARGER1"),
+};
+
+static struct resource thermal_resources[] = {
+	DEFINE_RES_IRQ(BXTWC_THRM0_IRQ),
+	DEFINE_RES_IRQ(BXTWC_THRM1_IRQ),
+	DEFINE_RES_IRQ(BXTWC_THRM2_IRQ),
+};
+
+static struct resource bcu_resources[] = {
+	DEFINE_RES_IRQ_NAMED(BXTWC_BCU_IRQ, "BCU"),
+};
+
+static struct mfd_cell bxt_wc_dev[] = {
+	{
+		.name = "bxt_wcove_gpadc",
+		.num_resources = ARRAY_SIZE(adc_resources),
+		.resources = adc_resources,
+	},
+	{
+		.name = "bxt_wcove_thermal",
+		.num_resources = ARRAY_SIZE(thermal_resources),
+		.resources = thermal_resources,
+	},
+	{
+		.name = "bxt_wcove_ext_charger",
+		.num_resources = ARRAY_SIZE(charger_resources),
+		.resources = charger_resources,
+	},
+	{
+		.name = "bxt_wcove_bcu",
+		.num_resources = ARRAY_SIZE(bcu_resources),
+		.resources = bcu_resources,
+	},
+	{
+		.name = "bxt_wcove_gpio",
+		.num_resources = ARRAY_SIZE(gpio_resources),
+		.resources = gpio_resources,
+	},
+	{
+		.name = "bxt_wcove_region",
+	},
+};
+
+static int regmap_ipc_byte_reg_read(void *context, unsigned int reg,
+				    unsigned int *val)
+{
+	int ret;
+	int i2c_addr;
+	u8 ipc_in[2];
+	u8 ipc_out[4];
+	struct intel_soc_pmic *pmic = context;
+
+	if (reg & REG_ADDR_MASK)
+		i2c_addr = (reg & REG_ADDR_MASK) >> REG_ADDR_SHIFT;
+	else {
+		i2c_addr = BXTWC_DEVICE1_ADDR;
+		if (!i2c_addr) {
+			dev_err(pmic->dev, "I2C address not set\n");
+			return -EINVAL;
+		}
+	}
+	reg &= REG_OFFSET_MASK;
+
+	ipc_in[0] = reg;
+	ipc_in[1] = i2c_addr;
+	ret = intel_pmc_ipc_command(PMC_IPC_PMIC_ACCESS,
+			PMC_IPC_PMIC_ACCESS_READ,
+			ipc_in, sizeof(ipc_in), (u32 *)ipc_out, 1);
+	if (ret) {
+		dev_err(pmic->dev, "Failed to read from PMIC\n");
+		return ret;
+	}
+	*val = ipc_out[0];
+
+	return 0;
+}
+
+static int regmap_ipc_byte_reg_write(void *context, unsigned int reg,
+				       unsigned int val)
+{
+	int ret;
+	int i2c_addr;
+	u8 ipc_in[3];
+	struct intel_soc_pmic *pmic = context;
+
+	if (reg & REG_ADDR_MASK)
+		i2c_addr = (reg & REG_ADDR_MASK) >> REG_ADDR_SHIFT;
+	else {
+		i2c_addr = BXTWC_DEVICE1_ADDR;
+		if (!i2c_addr) {
+			dev_err(pmic->dev, "I2C address not set\n");
+			return -EINVAL;
+		}
+	}
+	reg &= REG_OFFSET_MASK;
+
+	ipc_in[0] = reg;
+	ipc_in[1] = i2c_addr;
+	ipc_in[2] = val;
+	ret = intel_pmc_ipc_command(PMC_IPC_PMIC_ACCESS,
+			PMC_IPC_PMIC_ACCESS_WRITE,
+			ipc_in, sizeof(ipc_in), NULL, 0);
+	if (ret) {
+		dev_err(pmic->dev, "Failed to write to PMIC\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+/* sysfs interfaces to r/w PMIC registers, required by initial script */
+static unsigned long bxtwc_reg_addr;
+static ssize_t bxtwc_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%lx\n", bxtwc_reg_addr);
+}
+
+static ssize_t bxtwc_reg_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (kstrtoul(buf, 0, &bxtwc_reg_addr)) {
+		dev_err(dev, "Invalid register address\n");
+		return -EINVAL;
+	}
+	return (ssize_t)count;
+}
+
+static ssize_t bxtwc_val_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int ret;
+	unsigned int val;
+	struct intel_soc_pmic *pmic = dev_get_drvdata(dev);
+
+	ret = regmap_read(pmic->regmap, bxtwc_reg_addr, &val);
+	if (ret < 0) {
+		dev_err(dev, "Failed to read 0x%lx\n", bxtwc_reg_addr);
+		return -EIO;
+	}
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t bxtwc_val_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned int val;
+	struct intel_soc_pmic *pmic = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 0, (unsigned long *)&val)) {
+		dev_err(dev, "Invalid register value\n");
+		return -EINVAL;
+	}
+
+	ret = regmap_write(pmic->regmap, bxtwc_reg_addr, val);
+	if (ret) {
+		dev_err(dev, "Failed to write value 0x%02x to address 0x%lx",
+			val, bxtwc_reg_addr);
+		return -EIO;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(addr, S_IWUSR | S_IRUSR, bxtwc_reg_show, bxtwc_reg_store);
+static DEVICE_ATTR(val, S_IWUSR | S_IRUSR, bxtwc_val_show, bxtwc_val_store);
+static struct attribute *bxtwc_attrs[] = {
+	&dev_attr_addr.attr,
+	&dev_attr_val.attr,
+	NULL
+};
+
+static const struct attribute_group bxtwc_group = {
+	.attrs = bxtwc_attrs,
+};
+
+static const struct regmap_config bxtwc_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_write = regmap_ipc_byte_reg_write,
+	.reg_read = regmap_ipc_byte_reg_read,
+};
+
+static int bxtwc_probe(struct platform_device *pdev)
+{
+	int ret;
+	acpi_handle handle;
+	acpi_status status;
+	unsigned long long hrv;
+	struct intel_soc_pmic *pmic;
+
+	handle = ACPI_HANDLE(&pdev->dev);
+	status = acpi_evaluate_integer(handle, "_HRV", NULL, &hrv);
+	if (ACPI_FAILURE(status)) {
+		dev_err(&pdev->dev, "Failed to get PMIC hardware revision\n");
+		return -ENODEV;
+	}
+	if (hrv != BROXTON_PMIC_WC_HRV) {
+		dev_err(&pdev->dev, "Invalid PMIC hardware revision: %llu\n",
+			hrv);
+		return -ENODEV;
+	}
+
+	pmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);
+	if (!pmic)
+		return -ENOMEM;
+
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Invalid IRQ\n");
+		return ret;
+	}
+	pmic->irq = ret;
+
+	dev_set_drvdata(&pdev->dev, pmic);
+	pmic->dev = &pdev->dev;
+
+	pmic->regmap = devm_regmap_init(&pdev->dev, NULL, pmic,
+					&bxtwc_regmap_config);
+	if (IS_ERR(pmic->regmap)) {
+		ret = PTR_ERR(pmic->regmap);
+		dev_err(&pdev->dev, "Failed to initialise regmap: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_add_irq_chip(pmic->regmap, pmic->irq,
+				  IRQF_ONESHOT | IRQF_SHARED,
+				  0, &bxtwc_regmap_irq_chip,
+				  &pmic->irq_chip_data);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add IRQ chip\n");
+		return ret;
+	}
+
+	ret = regmap_add_irq_chip(pmic->regmap, pmic->irq,
+				  IRQF_ONESHOT | IRQF_SHARED,
+				  0, &bxtwc_regmap_irq_chip_level2,
+				  &pmic->irq_chip_data_level2);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add secondary IRQ chip\n");
+		goto err_irq_chip_level2;
+	}
+
+	ret = mfd_add_devices(&pdev->dev, PLATFORM_DEVID_NONE, bxt_wc_dev,
+			      ARRAY_SIZE(bxt_wc_dev), NULL, 0,
+			      NULL);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add devices\n");
+		goto err_mfd;
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &bxtwc_group);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to create sysfs group %d\n", ret);
+		goto err_sysfs;
+	}
+
+	return 0;
+
+err_sysfs:
+	mfd_remove_devices(&pdev->dev);
+err_mfd:
+	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_level2);
+err_irq_chip_level2:
+	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data);
+
+	return ret;
+}
+
+static int bxtwc_remove(struct platform_device *pdev)
+{
+	struct intel_soc_pmic *pmic = dev_get_drvdata(&pdev->dev);
+
+	sysfs_remove_group(&pdev->dev.kobj, &bxtwc_group);
+	mfd_remove_devices(&pdev->dev);
+	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data);
+	regmap_del_irq_chip(pmic->irq, pmic->irq_chip_data_level2);
+
+	return 0;
+}
+
+static void bxtwc_shutdown(struct platform_device *pdev)
+{
+	struct intel_soc_pmic *pmic = dev_get_drvdata(&pdev->dev);
+
+	disable_irq(pmic->irq);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int bxtwc_suspend(struct device *dev)
+{
+	struct intel_soc_pmic *pmic = dev_get_drvdata(dev);
+
+	disable_irq(pmic->irq);
+
+	return 0;
+}
+
+static int bxtwc_resume(struct device *dev)
+{
+	struct intel_soc_pmic *pmic = dev_get_drvdata(dev);
+
+	enable_irq(pmic->irq);
+	return 0;
+}
+#endif
+static SIMPLE_DEV_PM_OPS(bxtwc_pm_ops, bxtwc_suspend, bxtwc_resume);
+
+static const struct acpi_device_id bxtwc_acpi_ids[] = {
+	{ "INT34D3", },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, pmic_acpi_ids);
+
+static struct platform_driver bxtwc_driver = {
+	.probe = bxtwc_probe,
+	.remove	= bxtwc_remove,
+	.shutdown = bxtwc_shutdown,
+	.driver	= {
+		.name	= "BXTWC PMIC",
+		.pm     = &bxtwc_pm_ops,
+		.acpi_match_table = ACPI_PTR(bxtwc_acpi_ids),
+	},
+};
+
+module_platform_driver(bxtwc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Qipeng Zha<qipeng.zha@intel.com>");
