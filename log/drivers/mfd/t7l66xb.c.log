commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index e9cfb147345e..70da0c4ae457 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *
  * Toshiba T7L66XB core mfd support
@@ -5,10 +6,6 @@
  * Copyright (c) 2005, 2007, 2008 Ian Molton
  * Copyright (c) 2008 Dmitry Baryshkov
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * T7L66 features:
  *
  * Supported in this driver:

commit ed835136ee679dc528333c454ca4d1543c5aab76
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Thu May 9 22:23:39 2019 +0800

    mfd: Use dev_get_drvdata() directly
    
    Using dev_get_drvdata directly.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 43d8683266de..e9cfb147345e 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -82,8 +82,7 @@ struct t7l66xb {
 
 static int t7l66xb_mmc_enable(struct platform_device *mmc)
 {
-	struct platform_device *dev = to_platform_device(mmc->dev.parent);
-	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	struct t7l66xb *t7l66xb = dev_get_drvdata(mmc->dev.parent);
 	unsigned long flags;
 	u8 dev_ctl;
 	int ret;
@@ -108,8 +107,7 @@ static int t7l66xb_mmc_enable(struct platform_device *mmc)
 
 static int t7l66xb_mmc_disable(struct platform_device *mmc)
 {
-	struct platform_device *dev = to_platform_device(mmc->dev.parent);
-	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	struct t7l66xb *t7l66xb = dev_get_drvdata(mmc->dev.parent);
 	unsigned long flags;
 	u8 dev_ctl;
 
@@ -128,16 +126,14 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 
 static void t7l66xb_mmc_pwr(struct platform_device *mmc, int state)
 {
-	struct platform_device *dev = to_platform_device(mmc->dev.parent);
-	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	struct t7l66xb *t7l66xb = dev_get_drvdata(mmc->dev.parent);
 
 	tmio_core_mmc_pwr(t7l66xb->scr + 0x200, 0, state);
 }
 
 static void t7l66xb_mmc_clk_div(struct platform_device *mmc, int state)
 {
-	struct platform_device *dev = to_platform_device(mmc->dev.parent);
-	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	struct t7l66xb *t7l66xb = dev_get_drvdata(mmc->dev.parent);
 
 	tmio_core_mmc_clk_div(t7l66xb->scr + 0x200, 0, state);
 }

commit b62d8dbe419893b7aee5fac282e1da8c811cfcfb
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Aug 8 15:24:56 2017 +0530

    mfd: t7l66xb: Handle return value of clk_prepare_enable
    
    clk_prepare_enable() can fail here and we must check its return value.
    we must disable clock, if t7l66xb_probe is not successful.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 22c811396edc..43d8683266de 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -86,8 +86,11 @@ static int t7l66xb_mmc_enable(struct platform_device *mmc)
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	unsigned long flags;
 	u8 dev_ctl;
+	int ret;
 
-	clk_prepare_enable(t7l66xb->clk32k);
+	ret = clk_prepare_enable(t7l66xb->clk32k);
+	if (ret)
+		return ret;
 
 	raw_spin_lock_irqsave(&t7l66xb->lock, flags);
 
@@ -286,8 +289,12 @@ static int t7l66xb_resume(struct platform_device *dev)
 {
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	struct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);
+	int ret;
+
+	ret = clk_prepare_enable(t7l66xb->clk48m);
+	if (ret)
+		return ret;
 
-	clk_prepare_enable(t7l66xb->clk48m);
 	if (pdata && pdata->resume)
 		pdata->resume(dev);
 
@@ -361,7 +368,9 @@ static int t7l66xb_probe(struct platform_device *dev)
 		goto err_ioremap;
 	}
 
-	clk_prepare_enable(t7l66xb->clk48m);
+	ret = clk_prepare_enable(t7l66xb->clk48m);
+	if (ret)
+		goto err_clk_enable;
 
 	if (pdata->enable)
 		pdata->enable(dev);
@@ -386,6 +395,8 @@ static int t7l66xb_probe(struct platform_device *dev)
 		return 0;
 
 	t7l66xb_detach_irq(dev);
+	clk_disable_unprepare(t7l66xb->clk48m);
+err_clk_enable:
 	iounmap(t7l66xb->scr);
 err_ioremap:
 	release_resource(&t7l66xb->rscr);

commit 9fe8c2dfe165f18873042d25ef430e18c97b1dae
Author: Julia Cartwright <julia@ni.com>
Date:   Tue Mar 21 17:43:05 2017 -0500

    mfd: t7l66xb: Make use of raw_spinlock variants
    
    The t7l66xb mfd driver currently implements an irq_chip for handling
    interrupts; due to how irq_chip handling is done, it's necessary for the
    irq_chip methods to be invoked from hardirq context, even on a a
    real-time kernel.  Because the spinlock_t type becomes a "sleeping"
    spinlock w/ RT kernels, it is not suitable to be used with irq_chips.
    
    A quick audit of the operations under the lock reveal that they do only
    minimal, bounded work, and are therefore safe to do under a raw spinlock.
    
    Signed-off-by: Julia Cartwright <julia@ni.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 94bd89cb1f06..22c811396edc 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -69,7 +69,7 @@ static const struct resource t7l66xb_mmc_resources[] = {
 struct t7l66xb {
 	void __iomem		*scr;
 	/* Lock to protect registers requiring read/modify/write ops. */
-	spinlock_t		lock;
+	raw_spinlock_t		lock;
 
 	struct resource		rscr;
 	struct clk		*clk48m;
@@ -89,13 +89,13 @@ static int t7l66xb_mmc_enable(struct platform_device *mmc)
 
 	clk_prepare_enable(t7l66xb->clk32k);
 
-	spin_lock_irqsave(&t7l66xb->lock, flags);
+	raw_spin_lock_irqsave(&t7l66xb->lock, flags);
 
 	dev_ctl = tmio_ioread8(t7l66xb->scr + SCR_DEV_CTL);
 	dev_ctl |= SCR_DEV_CTL_MMC;
 	tmio_iowrite8(dev_ctl, t7l66xb->scr + SCR_DEV_CTL);
 
-	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+	raw_spin_unlock_irqrestore(&t7l66xb->lock, flags);
 
 	tmio_core_mmc_enable(t7l66xb->scr + 0x200, 0,
 		t7l66xb_mmc_resources[0].start & 0xfffe);
@@ -110,13 +110,13 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 	unsigned long flags;
 	u8 dev_ctl;
 
-	spin_lock_irqsave(&t7l66xb->lock, flags);
+	raw_spin_lock_irqsave(&t7l66xb->lock, flags);
 
 	dev_ctl = tmio_ioread8(t7l66xb->scr + SCR_DEV_CTL);
 	dev_ctl &= ~SCR_DEV_CTL_MMC;
 	tmio_iowrite8(dev_ctl, t7l66xb->scr + SCR_DEV_CTL);
 
-	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+	raw_spin_unlock_irqrestore(&t7l66xb->lock, flags);
 
 	clk_disable_unprepare(t7l66xb->clk32k);
 
@@ -206,11 +206,11 @@ static void t7l66xb_irq_mask(struct irq_data *data)
 	unsigned long			flags;
 	u8 imr;
 
-	spin_lock_irqsave(&t7l66xb->lock, flags);
+	raw_spin_lock_irqsave(&t7l66xb->lock, flags);
 	imr = tmio_ioread8(t7l66xb->scr + SCR_IMR);
 	imr |= 1 << (data->irq - t7l66xb->irq_base);
 	tmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);
-	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+	raw_spin_unlock_irqrestore(&t7l66xb->lock, flags);
 }
 
 static void t7l66xb_irq_unmask(struct irq_data *data)
@@ -219,11 +219,11 @@ static void t7l66xb_irq_unmask(struct irq_data *data)
 	unsigned long flags;
 	u8 imr;
 
-	spin_lock_irqsave(&t7l66xb->lock, flags);
+	raw_spin_lock_irqsave(&t7l66xb->lock, flags);
 	imr = tmio_ioread8(t7l66xb->scr + SCR_IMR);
 	imr &= ~(1 << (data->irq - t7l66xb->irq_base));
 	tmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);
-	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+	raw_spin_unlock_irqrestore(&t7l66xb->lock, flags);
 }
 
 static struct irq_chip t7l66xb_chip = {
@@ -321,7 +321,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 	if (!t7l66xb)
 		return -ENOMEM;
 
-	spin_lock_init(&t7l66xb->lock);
+	raw_spin_lock_init(&t7l66xb->lock);
 
 	platform_set_drvdata(dev, t7l66xb);
 

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 16fc1adc4fa3..94bd89cb1f06 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -185,7 +185,7 @@ static struct mfd_cell t7l66xb_cells[] = {
 /*--------------------------------------------------------------------------*/
 
 /* Handle the T7L66XB interrupt mux */
-static void t7l66xb_irq(unsigned int irq, struct irq_desc *desc)
+static void t7l66xb_irq(struct irq_desc *desc)
 {
 	struct t7l66xb *t7l66xb = irq_desc_get_handler_data(desc);
 	unsigned int isr;

commit 1e84aa445893a608445af2fda5d8a03c0a86af84
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jul 13 20:44:56 2015 +0000

    mfd: Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc
    
    Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc while we
    already have a pointer to corresponding irq_desc.
    
    Do the same change to avoid the pattern "irq_get_chip_data(data->irq)".
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index cc28103222c0..16fc1adc4fa3 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -187,7 +187,7 @@ static struct mfd_cell t7l66xb_cells[] = {
 /* Handle the T7L66XB interrupt mux */
 static void t7l66xb_irq(unsigned int irq, struct irq_desc *desc)
 {
-	struct t7l66xb *t7l66xb = irq_get_handler_data(irq);
+	struct t7l66xb *t7l66xb = irq_desc_get_handler_data(desc);
 	unsigned int isr;
 	unsigned int i, irq_base;
 

commit de7c9e0da9ca5962ed562296eaa521e5cc492322
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 13 20:44:52 2015 +0000

    mfd: t7l66xb: Consolidate chained IRQ handler install/remove
    
    Chained irq handlers usually set up handler data as well. We now have
    a function to set both under irq_desc->lock. Replace the two calls
    with one.
    
    Search and conversion was done with coccinelle.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 96d82980ead4..cc28103222c0 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -249,8 +249,7 @@ static void t7l66xb_attach_irq(struct platform_device *dev)
 	}
 
 	irq_set_irq_type(t7l66xb->irq, IRQ_TYPE_EDGE_FALLING);
-	irq_set_handler_data(t7l66xb->irq, t7l66xb);
-	irq_set_chained_handler(t7l66xb->irq, t7l66xb_irq);
+	irq_set_chained_handler_and_data(t7l66xb->irq, t7l66xb_irq, t7l66xb);
 }
 
 static void t7l66xb_detach_irq(struct platform_device *dev)
@@ -260,8 +259,7 @@ static void t7l66xb_detach_irq(struct platform_device *dev)
 
 	irq_base = t7l66xb->irq_base;
 
-	irq_set_chained_handler(t7l66xb->irq, NULL);
-	irq_set_handler_data(t7l66xb->irq, NULL);
+	irq_set_chained_handler_and_data(t7l66xb->irq, NULL, NULL);
 
 	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
 		irq_set_chip(irq, NULL);

commit 9bd09f345e62257958342f712efef644494274fb
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 27 15:55:20 2015 -0500

    mfd: Kill off set_irq_flags usage
    
    set_irq_flags is ARM specific with custom flags which have genirq
    equivalents. Convert drivers to use the genirq interfaces directly, so we
    can kill off set_irq_flags. The translation of flags is as follows:
    
    IRQF_VALID -> !IRQ_NOREQUEST
    IRQF_PROBE -> !IRQ_NOPROBE
    IRQF_NOAUTOEN -> IRQ_NOAUTOEN
    
    For IRQs managed by an irqdomain, the irqdomain core code handles clearing
    and setting IRQ_NOREQUEST already, so there is no need to do this in
    .map() functions and we can simply remove the set_irq_flags calls. Some
    users also modify IRQ_NOPROBE and this has been maintained although it
    is not clear that is really needed. There appears to be a great deal of
    blind copy and paste of this code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 854b05f840bb..96d82980ead4 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -246,9 +246,6 @@ static void t7l66xb_attach_irq(struct platform_device *dev)
 	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
 		irq_set_chip_and_handler(irq, &t7l66xb_chip, handle_level_irq);
 		irq_set_chip_data(irq, t7l66xb);
-#ifdef CONFIG_ARM
-		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
-#endif
 	}
 
 	irq_set_irq_type(t7l66xb->irq, IRQ_TYPE_EDGE_FALLING);
@@ -267,9 +264,6 @@ static void t7l66xb_detach_irq(struct platform_device *dev)
 	irq_set_handler_data(t7l66xb->irq, NULL);
 
 	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
-#ifdef CONFIG_ARM
-		set_irq_flags(irq, 0);
-#endif
 		irq_set_chip(irq, NULL);
 		irq_set_chip_data(irq, NULL);
 	}

commit 78b7d84c8f6e49f68d7b63c4d67242d4c1bfbadd
Author: Maninder Singh <maninder1.s@samsung.com>
Date:   Thu Jul 2 08:52:58 2015 +0530

    mfd: t7l66xb: Remove unnecessary pdata check
    
     o Making pdata NULL check to (!pdata) as coding standard
            and all other checks in file.
     o Removing redundant check of pdata, because we already
            check for pdata, and also derefernced before this check.
    
    Signed-off-by: Maninder Singh <maninder1.s@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index c09fb5dccd50..854b05f840bb 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -318,7 +318,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 	struct resource *iomem, *rscr;
 	int ret;
 
-	if (pdata == NULL)
+	if (!pdata)
 		return -EINVAL;
 
 	iomem = platform_get_resource(dev, IORESOURCE_MEM, 0);
@@ -371,7 +371,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 
 	clk_prepare_enable(t7l66xb->clk48m);
 
-	if (pdata && pdata->enable)
+	if (pdata->enable)
 		pdata->enable(dev);
 
 	/* Mask all interrupts */

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 71d679b84ce8ca3207e547488f70c259575d2f2f
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Mon Nov 17 18:07:42 2014 +0300

    mfd: t7l66xb: prepare/unprepare clocks
    
    Change clk_enable/disable() calls to clk_prepare_enable() and
    clk_disable_unprepare().
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 9e04a7485981..439d905bb219 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -87,7 +87,7 @@ static int t7l66xb_mmc_enable(struct platform_device *mmc)
 	unsigned long flags;
 	u8 dev_ctl;
 
-	clk_enable(t7l66xb->clk32k);
+	clk_prepare_enable(t7l66xb->clk32k);
 
 	spin_lock_irqsave(&t7l66xb->lock, flags);
 
@@ -118,7 +118,7 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 
 	spin_unlock_irqrestore(&t7l66xb->lock, flags);
 
-	clk_disable(t7l66xb->clk32k);
+	clk_disable_unprepare(t7l66xb->clk32k);
 
 	return 0;
 }
@@ -285,7 +285,7 @@ static int t7l66xb_suspend(struct platform_device *dev, pm_message_t state)
 
 	if (pdata && pdata->suspend)
 		pdata->suspend(dev);
-	clk_disable(t7l66xb->clk48m);
+	clk_disable_unprepare(t7l66xb->clk48m);
 
 	return 0;
 }
@@ -295,7 +295,7 @@ static int t7l66xb_resume(struct platform_device *dev)
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	struct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);
 
-	clk_enable(t7l66xb->clk48m);
+	clk_prepare_enable(t7l66xb->clk48m);
 	if (pdata && pdata->resume)
 		pdata->resume(dev);
 
@@ -369,7 +369,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 		goto err_ioremap;
 	}
 
-	clk_enable(t7l66xb->clk48m);
+	clk_prepare_enable(t7l66xb->clk48m);
 
 	if (pdata && pdata->enable)
 		pdata->enable(dev);
@@ -414,9 +414,9 @@ static int t7l66xb_remove(struct platform_device *dev)
 	int ret;
 
 	ret = pdata->disable(dev);
-	clk_disable(t7l66xb->clk48m);
+	clk_disable_unprepare(t7l66xb->clk48m);
 	clk_put(t7l66xb->clk48m);
-	clk_disable(t7l66xb->clk32k);
+	clk_disable_unprepare(t7l66xb->clk32k);
 	clk_put(t7l66xb->clk32k);
 	t7l66xb_detach_irq(dev);
 	iounmap(t7l66xb->scr);

commit 78a835416ad6d5b0d67f264d592906fade309ea2
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:53 2014 +0200

    mfd: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 9e04a7485981..3bb12e791982 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -431,7 +431,6 @@ static int t7l66xb_remove(struct platform_device *dev)
 static struct platform_driver t7l66xb_platform_driver = {
 	.driver = {
 		.name	= "t7l66xb",
-		.owner	= THIS_MODULE,
 	},
 	.suspend	= t7l66xb_suspend,
 	.resume		= t7l66xb_resume,

commit 334a41ce9b753ec615e8c6c50ee07d6197190610
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:10:05 2013 +0900

    mfd: Use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index a21bff283a98..9e04a7485981 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -281,7 +281,7 @@ static void t7l66xb_detach_irq(struct platform_device *dev)
 static int t7l66xb_suspend(struct platform_device *dev, pm_message_t state)
 {
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
-	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+	struct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);
 
 	if (pdata && pdata->suspend)
 		pdata->suspend(dev);
@@ -293,7 +293,7 @@ static int t7l66xb_suspend(struct platform_device *dev, pm_message_t state)
 static int t7l66xb_resume(struct platform_device *dev)
 {
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
-	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+	struct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);
 
 	clk_enable(t7l66xb->clk48m);
 	if (pdata && pdata->resume)
@@ -313,7 +313,7 @@ static int t7l66xb_resume(struct platform_device *dev)
 
 static int t7l66xb_probe(struct platform_device *dev)
 {
-	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+	struct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);
 	struct t7l66xb *t7l66xb;
 	struct resource *iomem, *rscr;
 	int ret;
@@ -409,7 +409,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 
 static int t7l66xb_remove(struct platform_device *dev)
 {
-	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+	struct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	int ret;
 

commit 3b69f59bef86498e38d8153cc08138de74da8ea6
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon May 6 13:12:24 2013 +0900

    mfd: t7l66xb: Remove unnecessary platform_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure, since commit 0998d0631001288a5974afc0b2a5f568bcdecb4d
    (device-core: Ensure drvdata = NULL when no driver is bound).
    Thus, it is not needed to manually clear the device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index b32940ec9034..a21bff283a98 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -422,7 +422,6 @@ static int t7l66xb_remove(struct platform_device *dev)
 	iounmap(t7l66xb->scr);
 	release_resource(&t7l66xb->rscr);
 	mfd_remove_devices(&dev->dev);
-	platform_set_drvdata(dev, NULL);
 	kfree(t7l66xb);
 
 	return ret;

commit 0848c94fb4a5cc213a7fb0fb3a5721ad6e16f096
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 11 15:16:36 2012 +0800

    mfd: core: Push irqdomain mapping out into devices
    
    Currently the MFD core supports remapping MFD cell interrupts using an
    irqdomain but only if the MFD is being instantiated using device tree
    and only if the device tree bindings use the pattern of registering IPs
    in the device tree with compatible properties.  This will be actively
    harmful for drivers which support non-DT platforms and use this pattern
    for their DT bindings as it will mean that the core will silently change
    remapping behaviour and it is also limiting for drivers which don't do
    DT with this particular pattern.  There is also a potential fragility if
    there are interrupts not associated with MFD cells and all the cells are
    omitted from the device tree for some reason.
    
    Instead change the code to take an IRQ domain as an optional argument,
    allowing drivers to take the decision about the parent domain for their
    interrupts.  The one current user of this feature is ab8500-core, it has
    the domain lookup pushed out into the driver.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 2d9e8799e733..b32940ec9034 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -388,7 +388,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 
 	ret = mfd_add_devices(&dev->dev, dev->id,
 			      t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),
-			      iomem, t7l66xb->irq_base);
+			      iomem, t7l66xb->irq_base, NULL);
 
 	if (!ret)
 		return 0;

commit 65349d60d27e850c94544567c91ab1be3e4c0777
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 23 22:58:34 2011 +0000

    mfd: Convert MFD drivers to use module_platform_driver
    
    Factors out some boilerplate code for drivers doing the default thing
    for platform driver registration. Drivers using platform_driver_probe
    or an initcall other than module_init can't be converted.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 91ad21ef7721..2d9e8799e733 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -442,21 +442,7 @@ static struct platform_driver t7l66xb_platform_driver = {
 
 /*--------------------------------------------------------------------------*/
 
-static int __init t7l66xb_init(void)
-{
-	int retval = 0;
-
-	retval = platform_driver_register(&t7l66xb_platform_driver);
-	return retval;
-}
-
-static void __exit t7l66xb_exit(void)
-{
-	platform_driver_unregister(&t7l66xb_platform_driver);
-}
-
-module_init(t7l66xb_init);
-module_exit(t7l66xb_exit);
+module_platform_driver(t7l66xb_platform_driver);
 
 MODULE_DESCRIPTION("Toshiba T7L66XB core driver");
 MODULE_LICENSE("GPL v2");

commit 7dc00a0d14992d0083fefccad7839ac837ea55bc
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Apr 6 12:20:49 2011 +0200

    mtd: Use platform_data to retrieve tmio_nand platform bits
    
    With the addition of the platform device mfd_cell pointer, we can now
    cleanly pass the sub device drivers platform data pointers through the
    regular device platform_data one, and get rid of mfd_get_data().
    
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Acked-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 5ef0b8fba107..91ad21ef7721 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -383,7 +383,8 @@ static int t7l66xb_probe(struct platform_device *dev)
 
 	t7l66xb_attach_irq(dev);
 
-	t7l66xb_cells[T7L66XB_CELL_NAND].mfd_data = pdata->nand_data;
+	t7l66xb_cells[T7L66XB_CELL_NAND].platform_data = pdata->nand_data;
+	t7l66xb_cells[T7L66XB_CELL_NAND].pdata_size = sizeof(*pdata->nand_data);
 
 	ret = mfd_add_devices(&dev->dev, dev->id,
 			      t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),

commit ec71974f2a3ae052cdbb57a92ce3c3b34ebd7b5d
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Apr 6 11:38:14 2011 +0200

    mmc: Use device platform_data to retrieve tmio_mmc platform bits
    
    With the addition of the platform device mfd_cell pointer, we can now
    cleanly pass the sub device drivers platform data pointers through the
    regular device platform_data one, and get rid of mfd_get_data()
    
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Philipp Zabel <philipp.zabel@gmail.com>
    Acked-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 42830e692964..5ef0b8fba107 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -170,7 +170,8 @@ static struct mfd_cell t7l66xb_cells[] = {
 		.name = "tmio-mmc",
 		.enable = t7l66xb_mmc_enable,
 		.disable = t7l66xb_mmc_disable,
-		.mfd_data = &t7166xb_mmc_data,
+		.platform_data = &t7166xb_mmc_data,
+		.pdata_size    = sizeof(t7166xb_mmc_data),
 		.num_resources = ARRAY_SIZE(t7l66xb_mmc_resources),
 		.resources = t7l66xb_mmc_resources,
 	},

commit d6f7ce9f7fde069424e6400c31717ef34aab7e5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 25 11:12:35 2011 +0000

    mfd: Fold irq_set_chip/irq_set_handler
    
    Use the combined irq_set_chip_and_handler() function
    instead. Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 2e1fca4715ed..42830e692964 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -243,9 +243,8 @@ static void t7l66xb_attach_irq(struct platform_device *dev)
 	irq_base = t7l66xb->irq_base;
 
 	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
-		irq_set_chip(irq, &t7l66xb_chip);
+		irq_set_chip_and_handler(irq, &t7l66xb_chip, handle_level_irq);
 		irq_set_chip_data(irq, t7l66xb);
-		irq_set_handler(irq, handle_level_irq);
 #ifdef CONFIG_ARM
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 #endif

commit d5bb122165981aed327845c32a9916d1b8ae0e4b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 25 11:12:32 2011 +0000

    mfd: Cleanup irq namespace
    
    Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index af57fc706a4c..2e1fca4715ed 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -186,7 +186,7 @@ static struct mfd_cell t7l66xb_cells[] = {
 /* Handle the T7L66XB interrupt mux */
 static void t7l66xb_irq(unsigned int irq, struct irq_desc *desc)
 {
-	struct t7l66xb *t7l66xb = get_irq_data(irq);
+	struct t7l66xb *t7l66xb = irq_get_handler_data(irq);
 	unsigned int isr;
 	unsigned int i, irq_base;
 
@@ -243,17 +243,17 @@ static void t7l66xb_attach_irq(struct platform_device *dev)
 	irq_base = t7l66xb->irq_base;
 
 	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
-		set_irq_chip(irq, &t7l66xb_chip);
-		set_irq_chip_data(irq, t7l66xb);
-		set_irq_handler(irq, handle_level_irq);
+		irq_set_chip(irq, &t7l66xb_chip);
+		irq_set_chip_data(irq, t7l66xb);
+		irq_set_handler(irq, handle_level_irq);
 #ifdef CONFIG_ARM
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 #endif
 	}
 
-	set_irq_type(t7l66xb->irq, IRQ_TYPE_EDGE_FALLING);
-	set_irq_data(t7l66xb->irq, t7l66xb);
-	set_irq_chained_handler(t7l66xb->irq, t7l66xb_irq);
+	irq_set_irq_type(t7l66xb->irq, IRQ_TYPE_EDGE_FALLING);
+	irq_set_handler_data(t7l66xb->irq, t7l66xb);
+	irq_set_chained_handler(t7l66xb->irq, t7l66xb_irq);
 }
 
 static void t7l66xb_detach_irq(struct platform_device *dev)
@@ -263,15 +263,15 @@ static void t7l66xb_detach_irq(struct platform_device *dev)
 
 	irq_base = t7l66xb->irq_base;
 
-	set_irq_chained_handler(t7l66xb->irq, NULL);
-	set_irq_data(t7l66xb->irq, NULL);
+	irq_set_chained_handler(t7l66xb->irq, NULL);
+	irq_set_handler_data(t7l66xb->irq, NULL);
 
 	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
 #ifdef CONFIG_ARM
 		set_irq_flags(irq, 0);
 #endif
-		set_irq_chip(irq, NULL);
-		set_irq_chip_data(irq, NULL);
+		irq_set_chip(irq, NULL);
+		irq_set_chip_data(irq, NULL);
 	}
 }
 

commit d9d01f4b2697b410625fce288bd1196927994093
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 17 19:07:30 2011 -0800

    mtd: Use mfd_data instead of driver_data for tmio_nand
    
    Use mfd_data for passing information from mfd drivers to mfd
    clients.  The mfd_cell's driver_data field is being phased out.
    
    Clients that were using driver_data now access .mfd_data
    via mfd_get_data().  This changes tmio-nand only; mfd drivers with
    other cells are not modified.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 3c9e38940dbe..af57fc706a4c 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -383,7 +383,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 
 	t7l66xb_attach_irq(dev);
 
-	t7l66xb_cells[T7L66XB_CELL_NAND].driver_data = pdata->nand_data;
+	t7l66xb_cells[T7L66XB_CELL_NAND].mfd_data = pdata->nand_data;
 
 	ret = mfd_add_devices(&dev->dev, dev->id,
 			      t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),

commit 4f95bf404870cccb08ff6d59e1986d43aee5efb6
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 17 19:07:29 2011 -0800

    mmc: Use mfd_data instead of driver_data for tmio-mmc
    
    Use mfd_data for passing information from mfd drivers to mfd
    clients.  The mfd_cell's driver_data field is being phased out.
    
    Clients that were using driver_data now access .mfd_data
    via mfd_get_data().  This changes tmio-mmc only; mfd drivers with
    other cells are not modified.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index b9c1e4c630a8..3c9e38940dbe 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -170,7 +170,7 @@ static struct mfd_cell t7l66xb_cells[] = {
 		.name = "tmio-mmc",
 		.enable = t7l66xb_mmc_enable,
 		.disable = t7l66xb_mmc_disable,
-		.driver_data = &t7166xb_mmc_data,
+		.mfd_data = &t7166xb_mmc_data,
 		.num_resources = ARRAY_SIZE(t7l66xb_mmc_resources),
 		.resources = t7l66xb_mmc_resources,
 	},

commit a23090ada44889322fe39142fb58ebc5794f709c
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Feb 17 19:07:16 2011 -0800

    mfd: mfd_cell is now implicitly available to t7166xb drivers
    
    No need to explicitly set the cell's platform_data/data_size.
    
    Modify clients to use mfd_get_cell helper function instead of
    accessing platform_data directly.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 9caeb4ac6ea6..b9c1e4c630a8 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -384,15 +384,6 @@ static int t7l66xb_probe(struct platform_device *dev)
 	t7l66xb_attach_irq(dev);
 
 	t7l66xb_cells[T7L66XB_CELL_NAND].driver_data = pdata->nand_data;
-	t7l66xb_cells[T7L66XB_CELL_NAND].platform_data =
-		&t7l66xb_cells[T7L66XB_CELL_NAND];
-	t7l66xb_cells[T7L66XB_CELL_NAND].data_size =
-		sizeof(t7l66xb_cells[T7L66XB_CELL_NAND]);
-
-	t7l66xb_cells[T7L66XB_CELL_MMC].platform_data =
-		&t7l66xb_cells[T7L66XB_CELL_MMC];
-	t7l66xb_cells[T7L66XB_CELL_MMC].data_size =
-		sizeof(t7l66xb_cells[T7L66XB_CELL_MMC]);
 
 	ret = mfd_add_devices(&dev->dev, dev->id,
 			      t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),

commit a4e7feadcc2aa5754f5ebfe67b9f07b5fddede51
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Dec 12 12:18:58 2010 +0000

    mfd: Convert t7166xb driver to new irq_ API
    
    The genirq core is being updated to pass struct irq_data rather than an
    irq number to irq_chip operations. Update the t7166xb driver to the new
    APIs.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Ian Molton <ian@mnementh.co.uk>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 006c121f3f0d..9caeb4ac6ea6 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -199,37 +199,37 @@ static void t7l66xb_irq(unsigned int irq, struct irq_desc *desc)
 				generic_handle_irq(irq_base + i);
 }
 
-static void t7l66xb_irq_mask(unsigned int irq)
+static void t7l66xb_irq_mask(struct irq_data *data)
 {
-	struct t7l66xb *t7l66xb = get_irq_chip_data(irq);
+	struct t7l66xb *t7l66xb = irq_data_get_irq_chip_data(data);
 	unsigned long			flags;
 	u8 imr;
 
 	spin_lock_irqsave(&t7l66xb->lock, flags);
 	imr = tmio_ioread8(t7l66xb->scr + SCR_IMR);
-	imr |= 1 << (irq - t7l66xb->irq_base);
+	imr |= 1 << (data->irq - t7l66xb->irq_base);
 	tmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);
 	spin_unlock_irqrestore(&t7l66xb->lock, flags);
 }
 
-static void t7l66xb_irq_unmask(unsigned int irq)
+static void t7l66xb_irq_unmask(struct irq_data *data)
 {
-	struct t7l66xb *t7l66xb = get_irq_chip_data(irq);
+	struct t7l66xb *t7l66xb = irq_data_get_irq_chip_data(data);
 	unsigned long flags;
 	u8 imr;
 
 	spin_lock_irqsave(&t7l66xb->lock, flags);
 	imr = tmio_ioread8(t7l66xb->scr + SCR_IMR);
-	imr &= ~(1 << (irq - t7l66xb->irq_base));
+	imr &= ~(1 << (data->irq - t7l66xb->irq_base));
 	tmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);
 	spin_unlock_irqrestore(&t7l66xb->lock, flags);
 }
 
 static struct irq_chip t7l66xb_chip = {
-	.name	= "t7l66xb",
-	.ack	= t7l66xb_irq_mask,
-	.mask	= t7l66xb_irq_mask,
-	.unmask	= t7l66xb_irq_unmask,
+	.name		= "t7l66xb",
+	.irq_ack	= t7l66xb_irq_mask,
+	.irq_mask	= t7l66xb_irq_mask,
+	.irq_unmask	= t7l66xb_irq_unmask,
 };
 
 /*--------------------------------------------------------------------------*/

commit d2d272a965baeb3d78f843374bc48f0cbce8ac3d
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Jul 1 17:43:50 2010 +0800

    mfd: Properly free t7l66xb clk32k clock source
    
    This patch includes below fixes to properly free clk32k clock source:
    1. remove a redundant clk_put in t7l66xb_probe error path
    2. add missing clk_disable(t7l66xb->clk32k) and clk_put(t7l66xb->clk32k)
       to properly free the clock source.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 5041d33adf0b..006c121f3f0d 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -350,7 +350,6 @@ static int t7l66xb_probe(struct platform_device *dev)
 	t7l66xb->clk48m = clk_get(&dev->dev, "CLK_CK48M");
 	if (IS_ERR(t7l66xb->clk48m)) {
 		ret = PTR_ERR(t7l66xb->clk48m);
-		clk_put(t7l66xb->clk32k);
 		goto err_clk48m_get;
 	}
 
@@ -425,6 +424,8 @@ static int t7l66xb_remove(struct platform_device *dev)
 	ret = pdata->disable(dev);
 	clk_disable(t7l66xb->clk48m);
 	clk_put(t7l66xb->clk48m);
+	clk_disable(t7l66xb->clk32k);
+	clk_put(t7l66xb->clk32k);
 	t7l66xb_detach_irq(dev);
 	iounmap(t7l66xb->scr);
 	release_resource(&t7l66xb->rscr);

commit 9ad285d6db6e04c1c51c79152d2214fffefc92ab
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Fri Mar 19 12:46:28 2010 +0100

    mfd: Check t7l66 platform_data pointer
    
    We should check for pdata being not NULL before dereferencing it.
    
    Reported-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index da6383a934ac..5041d33adf0b 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -318,6 +318,9 @@ static int t7l66xb_probe(struct platform_device *dev)
 	struct resource *iomem, *rscr;
 	int ret;
 
+	if (pdata == NULL)
+		return -EINVAL;
+
 	iomem = platform_get_resource(dev, IORESOURCE_MEM, 0);
 	if (!iomem)
 		return -EINVAL;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 26d9176fca91..da6383a934ac 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 #include <linux/irq.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>

commit 0e820ab60118e06db62ef4e55b6dd96db807a34e
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Dec 22 21:31:43 2009 +0100

    mfd: Correct use after free for t7l66xb
    
    The structure t7l66xb should not be freed before the subsequent references
    to its fields in the arguments to clk_put.  Furthermore, this structure is
    allocated near the beginning of the function, and a goto to the label
    err_noirq appears after a successful allocation, so it would seem that the
    kfree should be moved down below this label.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression x,e;
    identifier f;
    iterator I;
    statement S;
    @@
    
    *kfree(x);
    ... when != &x
        when != x = e
        when != I(x,...) S
    *x->f
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index e0bbddd7aac2..26d9176fca91 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -403,12 +403,12 @@ static int t7l66xb_probe(struct platform_device *dev)
 err_ioremap:
 	release_resource(&t7l66xb->rscr);
 err_request_scr:
-	kfree(t7l66xb);
 	clk_put(t7l66xb->clk48m);
 err_clk48m_get:
 	clk_put(t7l66xb->clk32k);
 err_clk32k_get:
 err_noirq:
+	kfree(t7l66xb);
 	return ret;
 }
 

commit c02e6a5ff43d24d73cf7830c2925e213fc72e037
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jan 5 19:58:34 2010 +0100

    mfd: Use resource_size() for t7l66xb
    
    Use resource_size() for ioremap.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index bcf4687d4af5..e0bbddd7aac2 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -360,7 +360,7 @@ static int t7l66xb_probe(struct platform_device *dev)
 	if (ret)
 		goto err_request_scr;
 
-	t7l66xb->scr = ioremap(rscr->start, rscr->end - rscr->start + 1);
+	t7l66xb->scr = ioremap(rscr->start, resource_size(rscr));
 	if (!t7l66xb->scr) {
 		ret = -ENOMEM;
 		goto err_ioremap;

commit 64e8867ba8098b69889c1af94997a5ba2348fb26
Author: Ian Molton <ian@mnementh.co.uk>
Date:   Wed Jan 6 13:51:48 2010 +0100

    mfd: tmio_mmc hardware abstraction for CNF area
    
    This patch abstracts out the CNF area code from tmio_mmc which
    is not present in all hardware that can use this driver. This
    is required so that we can support non-toshiba based hardware.
    
    ASIC3 support by Philipp Zabel
    
    Signed-off-by: Ian Molton <ian@mnementh.co.uk>
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 0a255c1f1ce7..bcf4687d4af5 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -38,6 +38,19 @@ enum {
 	T7L66XB_CELL_MMC,
 };
 
+static const struct resource t7l66xb_mmc_resources[] = {
+	{
+		.start = 0x800,
+		.end	= 0x9ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IRQ_T7L66XB_MMC,
+		.end	= IRQ_T7L66XB_MMC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
 #define SCR_REVID	0x08		/* b Revision ID	*/
 #define SCR_IMR		0x42		/* b Interrupt Mask	*/
 #define SCR_DEV_CTL	0xe0		/* b Device control	*/
@@ -83,6 +96,9 @@ static int t7l66xb_mmc_enable(struct platform_device *mmc)
 
 	spin_unlock_irqrestore(&t7l66xb->lock, flags);
 
+	tmio_core_mmc_enable(t7l66xb->scr + 0x200, 0,
+		t7l66xb_mmc_resources[0].start & 0xfffe);
+
 	return 0;
 }
 
@@ -106,28 +122,28 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 	return 0;
 }
 
+static void t7l66xb_mmc_pwr(struct platform_device *mmc, int state)
+{
+	struct platform_device *dev = to_platform_device(mmc->dev.parent);
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+
+	tmio_core_mmc_pwr(t7l66xb->scr + 0x200, 0, state);
+}
+
+static void t7l66xb_mmc_clk_div(struct platform_device *mmc, int state)
+{
+	struct platform_device *dev = to_platform_device(mmc->dev.parent);
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+
+	tmio_core_mmc_clk_div(t7l66xb->scr + 0x200, 0, state);
+}
+
 /*--------------------------------------------------------------------------*/
 
 static struct tmio_mmc_data t7166xb_mmc_data = {
 	.hclk = 24000000,
-};
-
-static const struct resource t7l66xb_mmc_resources[] = {
-	{
-		.start = 0x800,
-		.end	= 0x9ff,
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x200,
-		.end	= 0x2ff,
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = IRQ_T7L66XB_MMC,
-		.end	= IRQ_T7L66XB_MMC,
-		.flags = IORESOURCE_IRQ,
-	},
+	.set_pwr = t7l66xb_mmc_pwr,
+	.set_clk_div = t7l66xb_mmc_clk_div,
 };
 
 static const struct resource t7l66xb_nand_resources[] = {
@@ -282,6 +298,9 @@ static int t7l66xb_resume(struct platform_device *dev)
 	if (pdata && pdata->resume)
 		pdata->resume(dev);
 
+	tmio_core_mmc_enable(t7l66xb->scr + 0x200, 0,
+		t7l66xb_mmc_resources[0].start & 0xfffe);
+
 	return 0;
 }
 #else

commit 4d3792e054f706f73837769a0e5607b3b7ad25a2
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Mon Jun 15 15:43:31 2009 +0200

    mfd: fix tmio related warnings
    
    We can not have .driver_data as const since platform_set_drvdata() doesnt take
    a const.
    The hclk mmc_data field can be const though.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 875f7a875734..0a255c1f1ce7 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -108,7 +108,7 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 
 /*--------------------------------------------------------------------------*/
 
-static const struct tmio_mmc_data t7166xb_mmc_data = {
+static struct tmio_mmc_data t7166xb_mmc_data = {
 	.hclk = 24000000,
 };
 

commit f0e46cc4971f6be96010d9248e0fc076b229d989
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Thu Jun 4 20:12:31 2009 +0200

    MFD,mmc: tmio_mmc: make HCLK configurable
    
    The Toshiba parts all have a 24 MHz HCLK, but HTC ASIC3 has a 24.576 MHz HCLK
    and AMD Imageon w228x's HCLK is 80 MHz. With this patch, the MFD driver
    provides the HCLK frequency to tmio_mmc via mfd_cell->driver_data.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Acked-by: Ian Molton <ian@mnementh.co.uk>
    Acked-by: Samuel Ortiz <sameo@openedhand.com>
    Signed-off-by: Pierre Ossman <pierre@ossman.eu>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index e9f4323dd2cb..875f7a875734 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -108,6 +108,10 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 
 /*--------------------------------------------------------------------------*/
 
+static const struct tmio_mmc_data t7166xb_mmc_data = {
+	.hclk = 24000000,
+};
+
 static const struct resource t7l66xb_mmc_resources[] = {
 	{
 		.start = 0x800,
@@ -149,6 +153,7 @@ static struct mfd_cell t7l66xb_cells[] = {
 		.name = "tmio-mmc",
 		.enable = t7l66xb_mmc_enable,
 		.disable = t7l66xb_mmc_disable,
+		.driver_data = &t7166xb_mmc_data,
 		.num_resources = ARRAY_SIZE(t7l66xb_mmc_resources),
 		.resources = t7l66xb_mmc_resources,
 	},

commit 3446d4bb93b4d8c7c5b667dd0271669f012fb166
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Tue Feb 17 10:11:42 2009 +0100

    mfd: Storage class should be before const qualifier
    
    The C99 specification states in section 6.11.5:
    
    The placement of a storage-class specifier other than at the beginning
    of the declaration specifiers in a declaration is an obsolescent
    feature.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 9f7024c0f8ec..e9f4323dd2cb 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -108,7 +108,7 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 
 /*--------------------------------------------------------------------------*/
 
-const static struct resource t7l66xb_mmc_resources[] = {
+static const struct resource t7l66xb_mmc_resources[] = {
 	{
 		.start = 0x800,
 		.end	= 0x9ff,
@@ -126,7 +126,7 @@ const static struct resource t7l66xb_mmc_resources[] = {
 	},
 };
 
-const static struct resource t7l66xb_nand_resources[] = {
+static const struct resource t7l66xb_nand_resources[] = {
 	{
 		.start	= 0xc00,
 		.end	= 0xc07,

commit 7acb706ca97fce84bda4a902a33de2f3dae10260
Author: Ian Molton <spyro@f2s.com>
Date:   Thu Oct 9 20:06:09 2008 +0200

    mfd: update TMIO drivers to use the clock API
    
    This patch updates the remaining two TMIO drivers to use the clock API
    rather than callback hooks into platform code.
    
    Signed-off-by: Ian Molton <spyro@f2s.com>
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 49a0fffc02af..9f7024c0f8ec 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -24,8 +24,10 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/err.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/mfd/core.h>
 #include <linux/mfd/tmio.h>
@@ -56,6 +58,8 @@ struct t7l66xb {
 	spinlock_t		lock;
 
 	struct resource		rscr;
+	struct clk		*clk48m;
+	struct clk		*clk32k;
 	int			irq;
 	int			irq_base;
 };
@@ -65,13 +69,11 @@ struct t7l66xb {
 static int t7l66xb_mmc_enable(struct platform_device *mmc)
 {
 	struct platform_device *dev = to_platform_device(mmc->dev.parent);
-	struct t7l66xb_platform_data   *pdata = dev->dev.platform_data;
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	unsigned long flags;
 	u8 dev_ctl;
 
-	if (pdata->enable_clk32k)
-		pdata->enable_clk32k(dev);
+	clk_enable(t7l66xb->clk32k);
 
 	spin_lock_irqsave(&t7l66xb->lock, flags);
 
@@ -87,7 +89,6 @@ static int t7l66xb_mmc_enable(struct platform_device *mmc)
 static int t7l66xb_mmc_disable(struct platform_device *mmc)
 {
 	struct platform_device *dev = to_platform_device(mmc->dev.parent);
-	struct t7l66xb_platform_data   *pdata = dev->dev.platform_data;
 	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	unsigned long flags;
 	u8 dev_ctl;
@@ -100,8 +101,7 @@ static int t7l66xb_mmc_disable(struct platform_device *mmc)
 
 	spin_unlock_irqrestore(&t7l66xb->lock, flags);
 
-	if (pdata->disable_clk32k)
-		pdata->disable_clk32k(dev);
+	clk_disable(t7l66xb->clk32k);
 
 	return 0;
 }
@@ -258,18 +258,22 @@ static void t7l66xb_detach_irq(struct platform_device *dev)
 #ifdef CONFIG_PM
 static int t7l66xb_suspend(struct platform_device *dev, pm_message_t state)
 {
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
 
 	if (pdata && pdata->suspend)
 		pdata->suspend(dev);
+	clk_disable(t7l66xb->clk48m);
 
 	return 0;
 }
 
 static int t7l66xb_resume(struct platform_device *dev)
 {
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
 	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
 
+	clk_enable(t7l66xb->clk48m);
 	if (pdata && pdata->resume)
 		pdata->resume(dev);
 
@@ -309,6 +313,19 @@ static int t7l66xb_probe(struct platform_device *dev)
 
 	t7l66xb->irq_base = pdata->irq_base;
 
+	t7l66xb->clk32k = clk_get(&dev->dev, "CLK_CK32K");
+	if (IS_ERR(t7l66xb->clk32k)) {
+		ret = PTR_ERR(t7l66xb->clk32k);
+		goto err_clk32k_get;
+	}
+
+	t7l66xb->clk48m = clk_get(&dev->dev, "CLK_CK48M");
+	if (IS_ERR(t7l66xb->clk48m)) {
+		ret = PTR_ERR(t7l66xb->clk48m);
+		clk_put(t7l66xb->clk32k);
+		goto err_clk48m_get;
+	}
+
 	rscr = &t7l66xb->rscr;
 	rscr->name = "t7l66xb-core";
 	rscr->start = iomem->start;
@@ -325,6 +342,8 @@ static int t7l66xb_probe(struct platform_device *dev)
 		goto err_ioremap;
 	}
 
+	clk_enable(t7l66xb->clk48m);
+
 	if (pdata && pdata->enable)
 		pdata->enable(dev);
 
@@ -359,9 +378,13 @@ static int t7l66xb_probe(struct platform_device *dev)
 	iounmap(t7l66xb->scr);
 err_ioremap:
 	release_resource(&t7l66xb->rscr);
-err_noirq:
 err_request_scr:
 	kfree(t7l66xb);
+	clk_put(t7l66xb->clk48m);
+err_clk48m_get:
+	clk_put(t7l66xb->clk32k);
+err_clk32k_get:
+err_noirq:
 	return ret;
 }
 
@@ -372,7 +395,8 @@ static int t7l66xb_remove(struct platform_device *dev)
 	int ret;
 
 	ret = pdata->disable(dev);
-
+	clk_disable(t7l66xb->clk48m);
+	clk_put(t7l66xb->clk48m);
 	t7l66xb_detach_irq(dev);
 	iounmap(t7l66xb->scr);
 	release_resource(&t7l66xb->rscr);

commit 8a4fbe013fb6a2a65a4eddcddb888ebe38d0270d
Author: Ian Molton <spyro@f2s.com>
Date:   Mon Aug 4 18:06:18 2008 +0200

    mfd: t7l66 MMC platform data
    
    The tmio MMC driver needs the cell to be passed as a platform data.
    
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 2d715fcea76f..49a0fffc02af 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -343,6 +343,11 @@ static int t7l66xb_probe(struct platform_device *dev)
 	t7l66xb_cells[T7L66XB_CELL_NAND].data_size =
 		sizeof(t7l66xb_cells[T7L66XB_CELL_NAND]);
 
+	t7l66xb_cells[T7L66XB_CELL_MMC].platform_data =
+		&t7l66xb_cells[T7L66XB_CELL_MMC];
+	t7l66xb_cells[T7L66XB_CELL_MMC].data_size =
+		sizeof(t7l66xb_cells[T7L66XB_CELL_MMC]);
+
 	ret = mfd_add_devices(&dev->dev, dev->id,
 			      t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),
 			      iomem, t7l66xb->irq_base);

commit 56bf2bda0651ca368a259468e4f309c71ed35c35
Author: Samuel Ortiz <sameo@openedhand.com>
Date:   Fri Aug 1 00:16:13 2008 +0200

    mfd: Fix 7l66 and 6387 according to the new mfd-core API
    
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
index 5be42054f739..2d715fcea76f 100644
--- a/drivers/mfd/t7l66xb.c
+++ b/drivers/mfd/t7l66xb.c
@@ -338,9 +338,14 @@ static int t7l66xb_probe(struct platform_device *dev)
 	t7l66xb_attach_irq(dev);
 
 	t7l66xb_cells[T7L66XB_CELL_NAND].driver_data = pdata->nand_data;
+	t7l66xb_cells[T7L66XB_CELL_NAND].platform_data =
+		&t7l66xb_cells[T7L66XB_CELL_NAND];
+	t7l66xb_cells[T7L66XB_CELL_NAND].data_size =
+		sizeof(t7l66xb_cells[T7L66XB_CELL_NAND]);
 
-	ret = mfd_add_devices(dev, t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),
-		iomem, t7l66xb->irq_base);
+	ret = mfd_add_devices(&dev->dev, dev->id,
+			      t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),
+			      iomem, t7l66xb->irq_base);
 
 	if (!ret)
 		return 0;
@@ -366,7 +371,7 @@ static int t7l66xb_remove(struct platform_device *dev)
 	t7l66xb_detach_irq(dev);
 	iounmap(t7l66xb->scr);
 	release_resource(&t7l66xb->rscr);
-	mfd_remove_devices(dev);
+	mfd_remove_devices(&dev->dev);
 	platform_set_drvdata(dev, NULL);
 	kfree(t7l66xb);
 

commit 1f192015ca5b2f4d0a79c191f03f64e72fd8fc29
Author: Ian Molton <spyro@f2s.com>
Date:   Tue Jul 15 15:09:43 2008 +0100

    mfd: driver for the T7L66XB TMIO SoC
    
    This patchset provides support for the core functinality of the T7L66XB
    SoC from Toshiba. Supported in this patchset is the IRQ MUX, MMC controller
    and NAND flash controller.
    
    Signed-off-by: Ian Molton <spyro@f2s.com>
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>

diff --git a/drivers/mfd/t7l66xb.c b/drivers/mfd/t7l66xb.c
new file mode 100644
index 000000000000..5be42054f739
--- /dev/null
+++ b/drivers/mfd/t7l66xb.c
@@ -0,0 +1,409 @@
+/*
+ *
+ * Toshiba T7L66XB core mfd support
+ *
+ * Copyright (c) 2005, 2007, 2008 Ian Molton
+ * Copyright (c) 2008 Dmitry Baryshkov
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * T7L66 features:
+ *
+ * Supported in this driver:
+ * SD/MMC
+ * SM/NAND flash controller
+ *
+ * As yet not supported
+ * GPIO interface (on NAND pins)
+ * Serial interface
+ * TFT 'interface converter'
+ * PCMCIA interface logic
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/tmio.h>
+#include <linux/mfd/t7l66xb.h>
+
+enum {
+	T7L66XB_CELL_NAND,
+	T7L66XB_CELL_MMC,
+};
+
+#define SCR_REVID	0x08		/* b Revision ID	*/
+#define SCR_IMR		0x42		/* b Interrupt Mask	*/
+#define SCR_DEV_CTL	0xe0		/* b Device control	*/
+#define SCR_ISR		0xe1		/* b Interrupt Status	*/
+#define SCR_GPO_OC	0xf0		/* b GPO output control	*/
+#define SCR_GPO_OS	0xf1		/* b GPO output enable	*/
+#define SCR_GPI_S	0xf2		/* w GPI status		*/
+#define SCR_APDC	0xf8		/* b Active pullup down ctrl */
+
+#define SCR_DEV_CTL_USB		BIT(0)	/* USB enable		*/
+#define SCR_DEV_CTL_MMC		BIT(1)	/* MMC enable		*/
+
+/*--------------------------------------------------------------------------*/
+
+struct t7l66xb {
+	void __iomem		*scr;
+	/* Lock to protect registers requiring read/modify/write ops. */
+	spinlock_t		lock;
+
+	struct resource		rscr;
+	int			irq;
+	int			irq_base;
+};
+
+/*--------------------------------------------------------------------------*/
+
+static int t7l66xb_mmc_enable(struct platform_device *mmc)
+{
+	struct platform_device *dev = to_platform_device(mmc->dev.parent);
+	struct t7l66xb_platform_data   *pdata = dev->dev.platform_data;
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	unsigned long flags;
+	u8 dev_ctl;
+
+	if (pdata->enable_clk32k)
+		pdata->enable_clk32k(dev);
+
+	spin_lock_irqsave(&t7l66xb->lock, flags);
+
+	dev_ctl = tmio_ioread8(t7l66xb->scr + SCR_DEV_CTL);
+	dev_ctl |= SCR_DEV_CTL_MMC;
+	tmio_iowrite8(dev_ctl, t7l66xb->scr + SCR_DEV_CTL);
+
+	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+
+	return 0;
+}
+
+static int t7l66xb_mmc_disable(struct platform_device *mmc)
+{
+	struct platform_device *dev = to_platform_device(mmc->dev.parent);
+	struct t7l66xb_platform_data   *pdata = dev->dev.platform_data;
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	unsigned long flags;
+	u8 dev_ctl;
+
+	spin_lock_irqsave(&t7l66xb->lock, flags);
+
+	dev_ctl = tmio_ioread8(t7l66xb->scr + SCR_DEV_CTL);
+	dev_ctl &= ~SCR_DEV_CTL_MMC;
+	tmio_iowrite8(dev_ctl, t7l66xb->scr + SCR_DEV_CTL);
+
+	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+
+	if (pdata->disable_clk32k)
+		pdata->disable_clk32k(dev);
+
+	return 0;
+}
+
+/*--------------------------------------------------------------------------*/
+
+const static struct resource t7l66xb_mmc_resources[] = {
+	{
+		.start = 0x800,
+		.end	= 0x9ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x200,
+		.end	= 0x2ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IRQ_T7L66XB_MMC,
+		.end	= IRQ_T7L66XB_MMC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+const static struct resource t7l66xb_nand_resources[] = {
+	{
+		.start	= 0xc00,
+		.end	= 0xc07,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= 0x0100,
+		.end	= 0x01ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_T7L66XB_NAND,
+		.end	= IRQ_T7L66XB_NAND,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mfd_cell t7l66xb_cells[] = {
+	[T7L66XB_CELL_MMC] = {
+		.name = "tmio-mmc",
+		.enable = t7l66xb_mmc_enable,
+		.disable = t7l66xb_mmc_disable,
+		.num_resources = ARRAY_SIZE(t7l66xb_mmc_resources),
+		.resources = t7l66xb_mmc_resources,
+	},
+	[T7L66XB_CELL_NAND] = {
+		.name = "tmio-nand",
+		.num_resources = ARRAY_SIZE(t7l66xb_nand_resources),
+		.resources = t7l66xb_nand_resources,
+	},
+};
+
+/*--------------------------------------------------------------------------*/
+
+/* Handle the T7L66XB interrupt mux */
+static void t7l66xb_irq(unsigned int irq, struct irq_desc *desc)
+{
+	struct t7l66xb *t7l66xb = get_irq_data(irq);
+	unsigned int isr;
+	unsigned int i, irq_base;
+
+	irq_base = t7l66xb->irq_base;
+
+	while ((isr = tmio_ioread8(t7l66xb->scr + SCR_ISR) &
+				~tmio_ioread8(t7l66xb->scr + SCR_IMR)))
+		for (i = 0; i < T7L66XB_NR_IRQS; i++)
+			if (isr & (1 << i))
+				generic_handle_irq(irq_base + i);
+}
+
+static void t7l66xb_irq_mask(unsigned int irq)
+{
+	struct t7l66xb *t7l66xb = get_irq_chip_data(irq);
+	unsigned long			flags;
+	u8 imr;
+
+	spin_lock_irqsave(&t7l66xb->lock, flags);
+	imr = tmio_ioread8(t7l66xb->scr + SCR_IMR);
+	imr |= 1 << (irq - t7l66xb->irq_base);
+	tmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);
+	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+}
+
+static void t7l66xb_irq_unmask(unsigned int irq)
+{
+	struct t7l66xb *t7l66xb = get_irq_chip_data(irq);
+	unsigned long flags;
+	u8 imr;
+
+	spin_lock_irqsave(&t7l66xb->lock, flags);
+	imr = tmio_ioread8(t7l66xb->scr + SCR_IMR);
+	imr &= ~(1 << (irq - t7l66xb->irq_base));
+	tmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);
+	spin_unlock_irqrestore(&t7l66xb->lock, flags);
+}
+
+static struct irq_chip t7l66xb_chip = {
+	.name	= "t7l66xb",
+	.ack	= t7l66xb_irq_mask,
+	.mask	= t7l66xb_irq_mask,
+	.unmask	= t7l66xb_irq_unmask,
+};
+
+/*--------------------------------------------------------------------------*/
+
+/* Install the IRQ handler */
+static void t7l66xb_attach_irq(struct platform_device *dev)
+{
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	unsigned int irq, irq_base;
+
+	irq_base = t7l66xb->irq_base;
+
+	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
+		set_irq_chip(irq, &t7l66xb_chip);
+		set_irq_chip_data(irq, t7l66xb);
+		set_irq_handler(irq, handle_level_irq);
+#ifdef CONFIG_ARM
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+#endif
+	}
+
+	set_irq_type(t7l66xb->irq, IRQ_TYPE_EDGE_FALLING);
+	set_irq_data(t7l66xb->irq, t7l66xb);
+	set_irq_chained_handler(t7l66xb->irq, t7l66xb_irq);
+}
+
+static void t7l66xb_detach_irq(struct platform_device *dev)
+{
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	unsigned int irq, irq_base;
+
+	irq_base = t7l66xb->irq_base;
+
+	set_irq_chained_handler(t7l66xb->irq, NULL);
+	set_irq_data(t7l66xb->irq, NULL);
+
+	for (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {
+#ifdef CONFIG_ARM
+		set_irq_flags(irq, 0);
+#endif
+		set_irq_chip(irq, NULL);
+		set_irq_chip_data(irq, NULL);
+	}
+}
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+static int t7l66xb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+
+	if (pdata && pdata->suspend)
+		pdata->suspend(dev);
+
+	return 0;
+}
+
+static int t7l66xb_resume(struct platform_device *dev)
+{
+	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+
+	if (pdata && pdata->resume)
+		pdata->resume(dev);
+
+	return 0;
+}
+#else
+#define t7l66xb_suspend NULL
+#define t7l66xb_resume	NULL
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+static int t7l66xb_probe(struct platform_device *dev)
+{
+	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+	struct t7l66xb *t7l66xb;
+	struct resource *iomem, *rscr;
+	int ret;
+
+	iomem = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!iomem)
+		return -EINVAL;
+
+	t7l66xb = kzalloc(sizeof *t7l66xb, GFP_KERNEL);
+	if (!t7l66xb)
+		return -ENOMEM;
+
+	spin_lock_init(&t7l66xb->lock);
+
+	platform_set_drvdata(dev, t7l66xb);
+
+	ret = platform_get_irq(dev, 0);
+	if (ret >= 0)
+		t7l66xb->irq = ret;
+	else
+		goto err_noirq;
+
+	t7l66xb->irq_base = pdata->irq_base;
+
+	rscr = &t7l66xb->rscr;
+	rscr->name = "t7l66xb-core";
+	rscr->start = iomem->start;
+	rscr->end = iomem->start + 0xff;
+	rscr->flags = IORESOURCE_MEM;
+
+	ret = request_resource(iomem, rscr);
+	if (ret)
+		goto err_request_scr;
+
+	t7l66xb->scr = ioremap(rscr->start, rscr->end - rscr->start + 1);
+	if (!t7l66xb->scr) {
+		ret = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	if (pdata && pdata->enable)
+		pdata->enable(dev);
+
+	/* Mask all interrupts */
+	tmio_iowrite8(0xbf, t7l66xb->scr + SCR_IMR);
+
+	printk(KERN_INFO "%s rev %d @ 0x%08lx, irq %d\n",
+		dev->name, tmio_ioread8(t7l66xb->scr + SCR_REVID),
+		(unsigned long)iomem->start, t7l66xb->irq);
+
+	t7l66xb_attach_irq(dev);
+
+	t7l66xb_cells[T7L66XB_CELL_NAND].driver_data = pdata->nand_data;
+
+	ret = mfd_add_devices(dev, t7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),
+		iomem, t7l66xb->irq_base);
+
+	if (!ret)
+		return 0;
+
+	t7l66xb_detach_irq(dev);
+	iounmap(t7l66xb->scr);
+err_ioremap:
+	release_resource(&t7l66xb->rscr);
+err_noirq:
+err_request_scr:
+	kfree(t7l66xb);
+	return ret;
+}
+
+static int t7l66xb_remove(struct platform_device *dev)
+{
+	struct t7l66xb_platform_data *pdata = dev->dev.platform_data;
+	struct t7l66xb *t7l66xb = platform_get_drvdata(dev);
+	int ret;
+
+	ret = pdata->disable(dev);
+
+	t7l66xb_detach_irq(dev);
+	iounmap(t7l66xb->scr);
+	release_resource(&t7l66xb->rscr);
+	mfd_remove_devices(dev);
+	platform_set_drvdata(dev, NULL);
+	kfree(t7l66xb);
+
+	return ret;
+
+}
+
+static struct platform_driver t7l66xb_platform_driver = {
+	.driver = {
+		.name	= "t7l66xb",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= t7l66xb_suspend,
+	.resume		= t7l66xb_resume,
+	.probe		= t7l66xb_probe,
+	.remove		= t7l66xb_remove,
+};
+
+/*--------------------------------------------------------------------------*/
+
+static int __init t7l66xb_init(void)
+{
+	int retval = 0;
+
+	retval = platform_driver_register(&t7l66xb_platform_driver);
+	return retval;
+}
+
+static void __exit t7l66xb_exit(void)
+{
+	platform_driver_unregister(&t7l66xb_platform_driver);
+}
+
+module_init(t7l66xb_init);
+module_exit(t7l66xb_exit);
+
+MODULE_DESCRIPTION("Toshiba T7L66XB core driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Ian Molton");
+MODULE_ALIAS("platform:t7l66xb");
