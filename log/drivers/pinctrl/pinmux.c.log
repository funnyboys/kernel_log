commit 6ba2fd391ac58c1a26874f10c3054a1ea4aca2d0
Author: Alexandre Torgue <alexandre.torgue@st.com>
Date:   Wed Dec 4 15:41:06 2019 +0100

    pinctrl: pinmux: fix a possible null pointer in pinmux_can_be_used_for_gpio
    
    This commit adds a check on ops pointer to avoid a kernel panic when
    ops->strict is used. Indeed, on some pinctrl driver (at least for
    pinctrl-stmfx) the pinmux ops is not implemented. Let's assume than gpio
    can be used in this case.
    
    Fixes: 472a61e777fe ("pinctrl/gpio: Take MUX usage into account")
    Signed-off-by: Alexandre Torgue <alexandre.torgue@st.com>
    Link: https://lore.kernel.org/r/20191204144106.10876-1-alexandre.torgue@st.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index e914f6efd39e..9503ddf2edc7 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -85,7 +85,7 @@ bool pinmux_can_be_used_for_gpio(struct pinctrl_dev *pctldev, unsigned pin)
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 
 	/* Can't inspect pin, assume it can be used */
-	if (!desc)
+	if (!desc || !ops)
 		return true;
 
 	if (ops->strict && desc->mux_usecount)

commit 472a61e777fe78cdcb6cb6f25efee0ae9f629aca
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Wed Aug 14 14:00:35 2019 +0300

    pinctrl/gpio: Take MUX usage into account
    
    The user space like gpioinfo only see the GPIO usage but not the
    MUX usage (e.g. I2C or SPI usage) of a pin. As a user we want
    to know which pin is free/safe to use. So take the MUX usage of
    strict pinmux controllers into account to get a more realistic
    view for ioctl GPIO_GET_LINEINFO_IOCTL.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Tested-by: Ramon Fried <rfried.dev@gmail.com>
    Signed-off-by: Ramon Fried <rfried.dev@gmail.com>
    Link: https://lore.kernel.org/r/20190814110035.13451-1-ramon.fried@linux.intel.com
    Acked-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 020e54f843f9..e914f6efd39e 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -70,6 +70,30 @@ int pinmux_validate_map(const struct pinctrl_map *map, int i)
 	return 0;
 }
 
+/**
+ * pinmux_can_be_used_for_gpio() - check if a specific pin
+ *	is either muxed to a different function or used as gpio.
+ *
+ * @pin: the pin number in the global pin space
+ *
+ * Controllers not defined as strict will always return true,
+ * menaning that the gpio can be used.
+ */
+bool pinmux_can_be_used_for_gpio(struct pinctrl_dev *pctldev, unsigned pin)
+{
+	struct pin_desc *desc = pin_desc_get(pctldev, pin);
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+
+	/* Can't inspect pin, assume it can be used */
+	if (!desc)
+		return true;
+
+	if (ops->strict && desc->mux_usecount)
+		return false;
+
+	return !(ops->strict && !!desc->gpio_owner);
+}
+
 /**
  * pin_request() - request a single pin to be muxed in, typically for GPIO
  * @pin: the pin number in the global pin space

commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 4d0cc1889dd9..020e54f843f9 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Core driver for the pin muxing portions of the pin control subsystem
  *
@@ -8,8 +9,6 @@
  * Author: Linus Walleij <linus.walleij@linaro.org>
  *
  * Copyright (C) 2012 NVIDIA CORPORATION. All rights reserved.
- *
- * License terms: GNU General Public License (GPL) version 2
  */
 #define pr_fmt(fmt) "pinmux core: " fmt
 

commit 0819dc72ea70a90ad2a070e76708ee53bac47caa
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Fri Nov 30 11:36:17 2018 -0500

    pinctrl: Change to use DEFINE_SHOW_ATTRIBUTE macro
    
    Use DEFINE_SHOW_ATTRIBUTE macro to simplify the code.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 5780442c068b..4d0cc1889dd9 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -644,37 +644,16 @@ void pinmux_show_setting(struct seq_file *s,
 		   setting->data.mux.func);
 }
 
-static int pinmux_functions_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, pinmux_functions_show, inode->i_private);
-}
-
-static int pinmux_pins_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, pinmux_pins_show, inode->i_private);
-}
-
-static const struct file_operations pinmux_functions_ops = {
-	.open		= pinmux_functions_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static const struct file_operations pinmux_pins_ops = {
-	.open		= pinmux_pins_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(pinmux_functions);
+DEFINE_SHOW_ATTRIBUTE(pinmux_pins);
 
 void pinmux_init_device_debugfs(struct dentry *devroot,
 			 struct pinctrl_dev *pctldev)
 {
 	debugfs_create_file("pinmux-functions", S_IFREG | S_IRUGO,
-			    devroot, pctldev, &pinmux_functions_ops);
+			    devroot, pctldev, &pinmux_functions_fops);
 	debugfs_create_file("pinmux-pins", S_IFREG | S_IRUGO,
-			    devroot, pctldev, &pinmux_pins_ops);
+			    devroot, pctldev, &pinmux_pins_fops);
 }
 
 #endif /* CONFIG_DEBUG_FS */

commit f913cfce4ee49a3382a9ff95696f49a46e56e974
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 5 02:10:15 2018 -0700

    pinctrl: pinmux: Return selector to the pinctrl driver
    
    We must return the selector from pinmux_generic_add_function() so
    pin controller device drivers can remove the right group if needed
    for deferred probe for example. And we now must make sure that a
    proper name is passed so we can use it to check if the entry already
    exists.
    
    Note that fixes are also needed for the pin controller drivers to
    use the selector value.
    
    Fixes: a76edc89b100 ("pinctrl: core: Add generic pinctrl functions for
    managing groups")
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Cc: Christ van Willegen <cvwillegen@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@linaro.org>
    Cc: Jacopo Mondi <jacopo+renesas@jmondi.org>
    Cc: Paul Cercueil <paul@crapouillou.net>
    Cc: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-By: H. Nikolaus Schaller <hns@goldelico.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index d7c5b4abd741..5780442c068b 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -307,7 +307,6 @@ static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,
 		selector++;
 	}
 
-	dev_err(pctldev->dev, "function '%s' not supported\n", function);
 	return -EINVAL;
 }
 
@@ -774,6 +773,16 @@ int pinmux_generic_add_function(struct pinctrl_dev *pctldev,
 				void *data)
 {
 	struct function_desc *function;
+	int selector;
+
+	if (!name)
+		return -EINVAL;
+
+	selector = pinmux_func_name_to_selector(pctldev, name);
+	if (selector >= 0)
+		return selector;
+
+	selector = pctldev->num_functions;
 
 	function = devm_kzalloc(pctldev->dev, sizeof(*function), GFP_KERNEL);
 	if (!function)
@@ -784,12 +793,11 @@ int pinmux_generic_add_function(struct pinctrl_dev *pctldev,
 	function->num_group_names = num_groups;
 	function->data = data;
 
-	radix_tree_insert(&pctldev->pin_function_tree, pctldev->num_functions,
-			  function);
+	radix_tree_insert(&pctldev->pin_function_tree, selector, function);
 
 	pctldev->num_functions++;
 
-	return 0;
+	return selector;
 }
 EXPORT_SYMBOL_GPL(pinmux_generic_add_function);
 

commit c969cb2f70aedf2159bc64073d012618506ef18f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jun 15 15:23:07 2018 +0200

    pinctrl: Cut unused sysfs includes
    
    We simply don't use sysfs.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index b8e9bda8ec98..d7c5b4abd741 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -22,7 +22,6 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/string.h>
-#include <linux/sysfs.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/pinctrl/machine.h>

commit ffd10c2ec771dde7005d29a255d943152311006d
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 13 11:33:47 2018 +0100

    pinctrl: pinmux: Use seq_putc() in pinmux_pins_show()
    
    A single character (line break) should be put into a sequence.
    Thus use the corresponding function "seq_putc".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 82b18ef44ee4..b8e9bda8ec98 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -617,7 +617,7 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 				   pctlops->get_group_name(pctldev,
 					desc->mux_setting->group));
 		else
-			seq_printf(s, "\n");
+			seq_putc(s, '\n');
 	}
 
 	mutex_unlock(&pctldev->mutex);

commit b67ecdec45b43a0c17a2e66e4d72303dfa3a8a96
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jan 5 19:52:26 2018 +0900

    pinctrl: remove redundant mux_setting clear in pinmux_disable_setting()
    
    desc->mux_setting is set to NULL in pin_free() called just below.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 55502fc4479c..82b18ef44ee4 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -493,8 +493,6 @@ void pinmux_disable_setting(const struct pinctrl_setting *setting)
 			continue;
 		}
 		if (desc->mux_setting == &(setting->data.mux)) {
-			desc->mux_setting = NULL;
-			/* And release the pin */
 			pin_free(pctldev, pins[i], NULL);
 		} else {
 			const char *gname;

commit 906a2a3955ff7eb67fe812448b08eb43904d3b2d
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Aug 4 13:52:05 2017 +0900

    pinctrl: add __rcu annotations to fix sparse warnings
    
    Sparse reports "warning: incorrect type in assignment (different
    address spaces)".
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 36d5da9dc587..55502fc4479c 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -833,7 +833,7 @@ EXPORT_SYMBOL_GPL(pinmux_generic_remove_function);
 void pinmux_generic_free_functions(struct pinctrl_dev *pctldev)
 {
 	struct radix_tree_iter iter;
-	void **slot;
+	void __rcu **slot;
 
 	radix_tree_for_each_slot(slot, &pctldev->pin_function_tree, &iter, 0)
 		radix_tree_delete(&pctldev->pin_function_tree, iter.index);

commit 3f713b7c223ebe5094973ce6e0272bd97363b552
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Aug 4 11:22:31 2017 +0900

    pinctrl: move const qualifier before struct
    
    Update subsystem wide for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 16b3ae5e4f44..36d5da9dc587 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -61,7 +61,7 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 	return 0;
 }
 
-int pinmux_validate_map(struct pinctrl_map const *map, int i)
+int pinmux_validate_map(const struct pinctrl_map *map, int i)
 {
 	if (!map->data.mux.function) {
 		pr_err("failed to register map %s (%d): no function given\n",
@@ -312,7 +312,7 @@ static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,
 	return -EINVAL;
 }
 
-int pinmux_map_to_setting(struct pinctrl_map const *map,
+int pinmux_map_to_setting(const struct pinctrl_map *map,
 			  struct pinctrl_setting *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
@@ -372,12 +372,12 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 	return 0;
 }
 
-void pinmux_free_setting(struct pinctrl_setting const *setting)
+void pinmux_free_setting(const struct pinctrl_setting *setting)
 {
 	/* This function is currently unused */
 }
 
-int pinmux_enable_setting(struct pinctrl_setting const *setting)
+int pinmux_enable_setting(const struct pinctrl_setting *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
@@ -458,7 +458,7 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 	return ret;
 }
 
-void pinmux_disable_setting(struct pinctrl_setting const *setting)
+void pinmux_disable_setting(const struct pinctrl_setting *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
@@ -627,7 +627,7 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	return 0;
 }
 
-void pinmux_show_map(struct seq_file *s, struct pinctrl_map const *map)
+void pinmux_show_map(struct seq_file *s, const struct pinctrl_map *map)
 {
 	seq_printf(s, "group %s\nfunction %s\n",
 		map->data.mux.group ? map->data.mux.group : "(default)",
@@ -635,7 +635,7 @@ void pinmux_show_map(struct seq_file *s, struct pinctrl_map const *map)
 }
 
 void pinmux_show_setting(struct seq_file *s,
-			 struct pinctrl_setting const *setting)
+			 const struct pinctrl_setting *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;

commit 664b7c4728821767e0228ee161bab87db2be58f1
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri May 12 08:47:57 2017 -0700

    pinctrl: core: Fix warning by removing bogus code
    
    Andre Przywara <andre.przywara@arm.com> noticed that we can get the
    following warning with -EPROBE_DEFER:
    
    "WARNING: CPU: 1 PID: 89 at drivers/base/dd.c:349
    driver_probe_device+0x2ac/0x2e8"
    
    Let's fix the issue by removing the indices as suggested by
    Tejun Heo <tj@kernel.org>. All we have to do here is kill the radix
    tree.
    
    I probably ended up with the indices after grepping for removal
    of all entries using radix_tree_for_each_slot() and the first
    match found was gmap_radix_tree_free(). Anyways, no need for
    indices here, and we can just do remove all the entries using
    radix_tree_for_each_slot() along how the item_kill_tree() test
    case does.
    
    Fixes: c7059c5ac70a ("pinctrl: core: Add generic pinctrl functions for managing groups")
    Fixes: a76edc89b100 ("pinctrl: core: Add generic pinctrl functions for managing groups")
    Reported-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Andre Przywara <andre.przywara@arm.com>
    Tested-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 9fd6d9087dc5..16b3ae5e4f44 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -826,30 +826,17 @@ EXPORT_SYMBOL_GPL(pinmux_generic_remove_function);
  * pinmux_generic_free_functions() - removes all functions
  * @pctldev: pin controller device
  *
- * Note that the caller must take care of locking.
+ * Note that the caller must take care of locking. The pinctrl
+ * functions are allocated with devm_kzalloc() so no need to free
+ * them here.
  */
 void pinmux_generic_free_functions(struct pinctrl_dev *pctldev)
 {
 	struct radix_tree_iter iter;
-	struct function_desc *function;
-	unsigned long *indices;
 	void **slot;
-	int i = 0;
-
-	indices = devm_kzalloc(pctldev->dev, sizeof(*indices) *
-			       pctldev->num_functions, GFP_KERNEL);
-	if (!indices)
-		return;
 
 	radix_tree_for_each_slot(slot, &pctldev->pin_function_tree, &iter, 0)
-		indices[i++] = iter.index;
-
-	for (i = 0; i < pctldev->num_functions; i++) {
-		function = radix_tree_lookup(&pctldev->pin_function_tree,
-					     indices[i]);
-		radix_tree_delete(&pctldev->pin_function_tree, indices[i]);
-		devm_kfree(pctldev->dev, function);
-	}
+		radix_tree_delete(&pctldev->pin_function_tree, iter.index);
 
 	pctldev->num_functions = 0;
 }

commit 6bffa7e1631d55b56f4de82510157fe8fa97e359
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Apr 3 10:32:42 2017 +0200

    pinctrl: pinmux: Fix kerneldoc for pinmux_generic_add_function()
    
    Correct the incorrect function name and description.
    
    Fixes: a76edc89b100e4fe ("pinctrl: core: Add generic pinctrl functions for managing groups")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 29ad3151abec..9fd6d9087dc5 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -763,7 +763,7 @@ struct function_desc *pinmux_generic_get_function(struct pinctrl_dev *pctldev,
 EXPORT_SYMBOL_GPL(pinmux_generic_get_function);
 
 /**
- * pinmux_generic_get_function_groups() - gets the function groups
+ * pinmux_generic_add_function() - adds a function group
  * @pctldev: pin controller device
  * @name: name of the function
  * @groups: array of pin groups

commit a76edc89b100e4fefb2a5c00cd8cd557437659e7
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 27 09:20:01 2016 -0800

    pinctrl: core: Add generic pinctrl functions for managing groups
    
    We can add generic helpers for function handling for cases where the pin
    controller driver does not need to use static arrays.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    [Renamed the Kconfig item and moved things around]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 9373146f3afc..29ad3151abec 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -682,3 +682,176 @@ void pinmux_init_device_debugfs(struct dentry *devroot,
 }
 
 #endif /* CONFIG_DEBUG_FS */
+
+#ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS
+
+/**
+ * pinmux_generic_get_function_count() - returns number of functions
+ * @pctldev: pin controller device
+ */
+int pinmux_generic_get_function_count(struct pinctrl_dev *pctldev)
+{
+	return pctldev->num_functions;
+}
+EXPORT_SYMBOL_GPL(pinmux_generic_get_function_count);
+
+/**
+ * pinmux_generic_get_function_name() - returns the function name
+ * @pctldev: pin controller device
+ * @selector: function number
+ */
+const char *
+pinmux_generic_get_function_name(struct pinctrl_dev *pctldev,
+				 unsigned int selector)
+{
+	struct function_desc *function;
+
+	function = radix_tree_lookup(&pctldev->pin_function_tree,
+				     selector);
+	if (!function)
+		return NULL;
+
+	return function->name;
+}
+EXPORT_SYMBOL_GPL(pinmux_generic_get_function_name);
+
+/**
+ * pinmux_generic_get_function_groups() - gets the function groups
+ * @pctldev: pin controller device
+ * @selector: function number
+ * @groups: array of pin groups
+ * @num_groups: number of pin groups
+ */
+int pinmux_generic_get_function_groups(struct pinctrl_dev *pctldev,
+				       unsigned int selector,
+				       const char * const **groups,
+				       unsigned * const num_groups)
+{
+	struct function_desc *function;
+
+	function = radix_tree_lookup(&pctldev->pin_function_tree,
+				     selector);
+	if (!function) {
+		dev_err(pctldev->dev, "%s could not find function%i\n",
+			__func__, selector);
+		return -EINVAL;
+	}
+	*groups = function->group_names;
+	*num_groups = function->num_group_names;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pinmux_generic_get_function_groups);
+
+/**
+ * pinmux_generic_get_function() - returns a function based on the number
+ * @pctldev: pin controller device
+ * @group_selector: function number
+ */
+struct function_desc *pinmux_generic_get_function(struct pinctrl_dev *pctldev,
+						  unsigned int selector)
+{
+	struct function_desc *function;
+
+	function = radix_tree_lookup(&pctldev->pin_function_tree,
+				     selector);
+	if (!function)
+		return NULL;
+
+	return function;
+}
+EXPORT_SYMBOL_GPL(pinmux_generic_get_function);
+
+/**
+ * pinmux_generic_get_function_groups() - gets the function groups
+ * @pctldev: pin controller device
+ * @name: name of the function
+ * @groups: array of pin groups
+ * @num_groups: number of pin groups
+ * @data: pin controller driver specific data
+ */
+int pinmux_generic_add_function(struct pinctrl_dev *pctldev,
+				const char *name,
+				const char **groups,
+				const unsigned int num_groups,
+				void *data)
+{
+	struct function_desc *function;
+
+	function = devm_kzalloc(pctldev->dev, sizeof(*function), GFP_KERNEL);
+	if (!function)
+		return -ENOMEM;
+
+	function->name = name;
+	function->group_names = groups;
+	function->num_group_names = num_groups;
+	function->data = data;
+
+	radix_tree_insert(&pctldev->pin_function_tree, pctldev->num_functions,
+			  function);
+
+	pctldev->num_functions++;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pinmux_generic_add_function);
+
+/**
+ * pinmux_generic_remove_function() - removes a numbered function
+ * @pctldev: pin controller device
+ * @selector: function number
+ *
+ * Note that the caller must take care of locking.
+ */
+int pinmux_generic_remove_function(struct pinctrl_dev *pctldev,
+				   unsigned int selector)
+{
+	struct function_desc *function;
+
+	function = radix_tree_lookup(&pctldev->pin_function_tree,
+				     selector);
+	if (!function)
+		return -ENOENT;
+
+	radix_tree_delete(&pctldev->pin_function_tree, selector);
+	devm_kfree(pctldev->dev, function);
+
+	pctldev->num_functions--;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pinmux_generic_remove_function);
+
+/**
+ * pinmux_generic_free_functions() - removes all functions
+ * @pctldev: pin controller device
+ *
+ * Note that the caller must take care of locking.
+ */
+void pinmux_generic_free_functions(struct pinctrl_dev *pctldev)
+{
+	struct radix_tree_iter iter;
+	struct function_desc *function;
+	unsigned long *indices;
+	void **slot;
+	int i = 0;
+
+	indices = devm_kzalloc(pctldev->dev, sizeof(*indices) *
+			       pctldev->num_functions, GFP_KERNEL);
+	if (!indices)
+		return;
+
+	radix_tree_for_each_slot(slot, &pctldev->pin_function_tree, &iter, 0)
+		indices[i++] = iter.index;
+
+	for (i = 0; i < pctldev->num_functions; i++) {
+		function = radix_tree_lookup(&pctldev->pin_function_tree,
+					     indices[i]);
+		radix_tree_delete(&pctldev->pin_function_tree, indices[i]);
+		devm_kfree(pctldev->dev, function);
+	}
+
+	pctldev->num_functions = 0;
+}
+
+#endif /* CONFIG_GENERIC_PINMUX_FUNCTIONS */

commit b1eb8fabc83becdcc3b813f1fe6194f610fe7e9b
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Sun Dec 25 02:59:28 2016 +0200

    pinctrl: simplify check for pin request conflicts
    
    This is a non-functional change, which deletes code duplication in two
    of four if-if branches by reordering the checks. Functional identity
    of the code change can be shown by running through the whole truth table
    of boolean arguments.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index ece702881946..9373146f3afc 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -99,37 +99,24 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	dev_dbg(pctldev->dev, "request pin %d (%s) for %s\n",
 		pin, desc->name, owner);
 
-	if (gpio_range) {
-		/* There's no need to support multiple GPIO requests */
-		if (desc->gpio_owner) {
-			dev_err(pctldev->dev,
-				"pin %s already requested by %s; cannot claim for %s\n",
-				desc->name, desc->gpio_owner, owner);
-			goto out;
-		}
-		if (ops->strict && desc->mux_usecount &&
-		    strcmp(desc->mux_owner, owner)) {
-			dev_err(pctldev->dev,
-				"pin %s already requested by %s; cannot claim for %s\n",
-				desc->name, desc->mux_owner, owner);
-			goto out;
-		}
+	if ((!gpio_range || ops->strict) &&
+	    desc->mux_usecount && strcmp(desc->mux_owner, owner)) {
+		dev_err(pctldev->dev,
+			"pin %s already requested by %s; cannot claim for %s\n",
+			desc->name, desc->mux_owner, owner);
+		goto out;
+	}
+
+	if ((gpio_range || ops->strict) && desc->gpio_owner) {
+		dev_err(pctldev->dev,
+			"pin %s already requested by %s; cannot claim for %s\n",
+			desc->name, desc->gpio_owner, owner);
+		goto out;
+	}
 
+	if (gpio_range) {
 		desc->gpio_owner = owner;
 	} else {
-		if (desc->mux_usecount && strcmp(desc->mux_owner, owner)) {
-			dev_err(pctldev->dev,
-				"pin %s already requested by %s; cannot claim for %s\n",
-				desc->name, desc->mux_owner, owner);
-			goto out;
-		}
-		if (ops->strict && desc->gpio_owner) {
-			dev_err(pctldev->dev,
-				"pin %s already requested by %s; cannot claim for %s\n",
-				desc->name, desc->gpio_owner, owner);
-			goto out;
-		}
-
 		desc->mux_usecount++;
 		if (desc->mux_usecount > 1)
 			return 0;

commit 1fb1f0540deae634d454f917e3d45c27b69521a8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 25 20:14:13 2016 +0900

    pinctrl: return -ENOMEM instead of -EINVAL for kasprintf() failure
    
    -ENOMEM is more suitable error code because kasprintf() fails
    in case of memory shortage.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index d94d76ca5651..ece702881946 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -256,7 +256,7 @@ int pinmux_request_gpio(struct pinctrl_dev *pctldev,
 	/* Conjure some name stating what chip and pin this is taken by */
 	owner = kasprintf(GFP_KERNEL, "%s:%d", range->name, gpio);
 	if (!owner)
-		return -EINVAL;
+		return -ENOMEM;
 
 	ret = pin_request(pctldev, pin, owner, range);
 	if (ret < 0)

commit cf9d994dcf00c09c73eb686e239ab6449a248719
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue May 24 14:26:26 2016 +0900

    pinctrl: do not care about blank pin name
    
    If a pin name is not specified in struct pinctrl_pin_desc,
    pinctrl_register_one_pin() dynamically assigns its name.
    So, desc->name is always a valid pointer here.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index c223a9ef1fe1..d94d76ca5651 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -606,23 +606,17 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 		if (pmxops->strict) {
 			if (desc->mux_owner)
 				seq_printf(s, "pin %d (%s): device %s%s",
-					   pin,
-					   desc->name ? desc->name : "unnamed",
-					   desc->mux_owner,
+					   pin, desc->name, desc->mux_owner,
 					   is_hog ? " (HOG)" : "");
 			else if (desc->gpio_owner)
 				seq_printf(s, "pin %d (%s): GPIO %s",
-					   pin,
-					   desc->name ? desc->name : "unnamed",
-					   desc->gpio_owner);
+					   pin, desc->name, desc->gpio_owner);
 			else
 				seq_printf(s, "pin %d (%s): UNCLAIMED",
-					   pin,
-					   desc->name ? desc->name : "unnamed");
+					   pin, desc->name);
 		} else {
 			/* For non-strict controllers */
-			seq_printf(s, "pin %d (%s): %s %s%s", pin,
-				   desc->name ? desc->name : "unnamed",
+			seq_printf(s, "pin %d (%s): %s %s%s", pin, desc->name,
 				   desc->mux_owner ? desc->mux_owner
 				   : "(MUX UNCLAIMED)",
 				   desc->gpio_owner ? desc->gpio_owner

commit dff4359448126936bf9b341ad7a1a7b6e0b6e95b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 17 14:22:20 2016 -0700

    pinctrl: convert to use match_string() helper
    
    The new helper returns index of the mathing string in an array.  We
    would use it here.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 29984b36926a..c223a9ef1fe1 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -334,7 +334,6 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 	unsigned num_groups;
 	int ret;
 	const char *group;
-	int i;
 
 	if (!pmxops) {
 		dev_err(pctldev->dev, "does not support mux function\n");
@@ -363,19 +362,13 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 		return -EINVAL;
 	}
 	if (map->data.mux.group) {
-		bool found = false;
 		group = map->data.mux.group;
-		for (i = 0; i < num_groups; i++) {
-			if (!strcmp(group, groups[i])) {
-				found = true;
-				break;
-			}
-		}
-		if (!found) {
+		ret = match_string(groups, num_groups, group);
+		if (ret < 0) {
 			dev_err(pctldev->dev,
 				"invalid group \"%s\" for function \"%s\"\n",
 				group, map->data.mux.function);
-			return -EINVAL;
+			return ret;
 		}
 	} else {
 		group = groups[0];

commit 163dc9f39a26b41fc49319fce4145b35f9705789
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sat Aug 1 13:22:38 2015 +0900

    pinctrl: join lines that can be a single line within 80 columns
    
    There is no reason to break a line shorter than 80 columns.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 67e08cb315c4..29984b36926a 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -313,8 +313,7 @@ static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,
 
 	/* See if this pctldev has this function */
 	while (selector < nfuncs) {
-		const char *fname = ops->get_function_name(pctldev,
-							   selector);
+		const char *fname = ops->get_function_name(pctldev, selector);
 
 		if (!strcmp(function, fname))
 			return selector;

commit e324957096dbf5bbf1491231c9912c3f5d0bc216
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jul 21 15:25:27 2015 +0900

    pinctrl: use dev_err() to show message in pinmux_func_name_to_selector()
    
    Use dev_err() rather than pr_err() to display the error message.
    
    pinctrl_dev_get_name(pctldev) is no longer necessary because
    dev_err() shows which device the message is related to.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index e7ae890dcf1a..67e08cb315c4 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -322,8 +322,7 @@ static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,
 		selector++;
 	}
 
-	pr_err("%s does not support function %s\n",
-	       pinctrl_dev_get_name(pctldev), function);
+	dev_err(pctldev->dev, "function '%s' not supported\n", function);
 	return -EINVAL;
 }
 

commit 9d7ebbbf2264c4ad3c8d50fcb84952126184a7ad
Author: Ludovic Desroches <ludovic.desroches@atmel.com>
Date:   Mon Jun 8 17:16:37 2015 +0200

    pinctrl: don't print unavailable function groups
    
    There is no reason to try to print groups associated to a function if
    get_function_groups returns an error. Moreover, it can lead to a NULL
    pointer dereference error.
    
    Signed-off-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 77f82b23f7be..e7ae890dcf1a 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -557,9 +557,12 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 
 		ret = pmxops->get_function_groups(pctldev, func_selector,
 						  &groups, &num_groups);
-		if (ret)
+		if (ret) {
 			seq_printf(s, "function %s: COULD NOT GET GROUPS\n",
 				   func);
+			func_selector++;
+			continue;
+		}
 
 		seq_printf(s, "function: %s, groups = [ ", func);
 		for (i = 0; i < num_groups; i++)

commit 815088550342904acd68f43436e1b4d1d78b77c1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 28 10:11:19 2015 +0200

    pinctrl: improve debugfs for strict controllers
    
    If we know we are using a strict pin controller (one that cannot
    mix device functions+group use and GPIO) we can be a bit more
    specific in debugfs, just print either device-function-group
    or GPIO consumer for the pin. Let's do that to be helpful.
    
    Cc: Sonic Zhang <sonic.zhang@analog.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index c58c168b06c2..77f82b23f7be 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -585,7 +585,12 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 		return 0;
 
 	seq_puts(s, "Pinmux settings per pin\n");
-	seq_puts(s, "Format: pin (name): mux_owner gpio_owner hog?\n");
+	if (pmxops->strict)
+		seq_puts(s,
+		 "Format: pin (name): mux_owner|gpio_owner (strict) hog?\n");
+	else
+		seq_puts(s,
+		"Format: pin (name): mux_owner gpio_owner hog?\n");
 
 	mutex_lock(&pctldev->mutex);
 
@@ -604,14 +609,34 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 		    !strcmp(desc->mux_owner, pinctrl_dev_get_name(pctldev)))
 			is_hog = true;
 
-		seq_printf(s, "pin %d (%s): %s %s%s", pin,
-			   desc->name ? desc->name : "unnamed",
-			   desc->mux_owner ? desc->mux_owner
-				: "(MUX UNCLAIMED)",
-			   desc->gpio_owner ? desc->gpio_owner
-				: "(GPIO UNCLAIMED)",
-			   is_hog ? " (HOG)" : "");
+		if (pmxops->strict) {
+			if (desc->mux_owner)
+				seq_printf(s, "pin %d (%s): device %s%s",
+					   pin,
+					   desc->name ? desc->name : "unnamed",
+					   desc->mux_owner,
+					   is_hog ? " (HOG)" : "");
+			else if (desc->gpio_owner)
+				seq_printf(s, "pin %d (%s): GPIO %s",
+					   pin,
+					   desc->name ? desc->name : "unnamed",
+					   desc->gpio_owner);
+			else
+				seq_printf(s, "pin %d (%s): UNCLAIMED",
+					   pin,
+					   desc->name ? desc->name : "unnamed");
+		} else {
+			/* For non-strict controllers */
+			seq_printf(s, "pin %d (%s): %s %s%s", pin,
+				   desc->name ? desc->name : "unnamed",
+				   desc->mux_owner ? desc->mux_owner
+				   : "(MUX UNCLAIMED)",
+				   desc->gpio_owner ? desc->gpio_owner
+				   : "(GPIO UNCLAIMED)",
+				   is_hog ? " (HOG)" : "");
+		}
 
+		/* If mux: print function+group claiming the pin */
 		if (desc->mux_setting)
 			seq_printf(s, " function %s group %s\n",
 				   pmxops->get_function_name(pctldev,

commit 8c4c2016345feefcd289ce2479eb70286d30825a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed May 6 14:19:13 2015 +0200

    pinctrl: move strict option to pinmux_ops
    
    While the pinmux_ops are ideally just a vtable for pin mux
    calls, the "strict" setting belongs so intuitively with the
    pin multiplexing that we should move it here anyway. Putting
    it in the top pinctrl_desc makes no sense.
    
    Cc: Sonic Zhang <sonic.zhang@analog.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 2546fa783464..c58c168b06c2 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -107,7 +107,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 				desc->name, desc->gpio_owner, owner);
 			goto out;
 		}
-		if (pctldev->desc->strict && desc->mux_usecount &&
+		if (ops->strict && desc->mux_usecount &&
 		    strcmp(desc->mux_owner, owner)) {
 			dev_err(pctldev->dev,
 				"pin %s already requested by %s; cannot claim for %s\n",
@@ -123,7 +123,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 				desc->name, desc->mux_owner, owner);
 			goto out;
 		}
-		if (pctldev->desc->strict && desc->gpio_owner) {
+		if (ops->strict && desc->gpio_owner) {
 			dev_err(pctldev->dev,
 				"pin %s already requested by %s; cannot claim for %s\n",
 				desc->name, desc->gpio_owner, owner);

commit fa76a3db7093a527333c380df82a0f158d9b8299
Author: Sonic Zhang <sonic.zhang@analog.com>
Date:   Thu Apr 9 11:13:07 2015 +0800

    pinctrl: allow exlusive GPIO/mux pin allocation
    
    Disallow simultaneous use of the the GPIO and peripheral mux
    functions by setting a flag "strict" in struct pinctrl_desc.
    
    The blackfin pinmux and gpio controller doesn't allow user to
    set up a pin for both GPIO and peripheral function. So, add flag
    strict in struct pinctrl_desc to check both gpio_owner and
    mux_owner before approving the pin request.
    
    v2-changes:
    - if strict flag is set, check gpio_owner and mux_onwer in if and
      else clause
    
    v3-changes:
    - add kerneldoc for this struct
    - augment Documentation/pinctrl.txt
    
    Signed-off-by: Sonic Zhang <sonic.zhang@analog.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index b874458dcb88..2546fa783464 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -107,6 +107,13 @@ static int pin_request(struct pinctrl_dev *pctldev,
 				desc->name, desc->gpio_owner, owner);
 			goto out;
 		}
+		if (pctldev->desc->strict && desc->mux_usecount &&
+		    strcmp(desc->mux_owner, owner)) {
+			dev_err(pctldev->dev,
+				"pin %s already requested by %s; cannot claim for %s\n",
+				desc->name, desc->mux_owner, owner);
+			goto out;
+		}
 
 		desc->gpio_owner = owner;
 	} else {
@@ -116,6 +123,12 @@ static int pin_request(struct pinctrl_dev *pctldev,
 				desc->name, desc->mux_owner, owner);
 			goto out;
 		}
+		if (pctldev->desc->strict && desc->gpio_owner) {
+			dev_err(pctldev->dev,
+				"pin %s already requested by %s; cannot claim for %s\n",
+				desc->name, desc->gpio_owner, owner);
+			goto out;
+		}
 
 		desc->mux_usecount++;
 		if (desc->mux_usecount > 1)

commit 03e9f0cac5da6af85758276cb4624caf5911f2b9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 3 13:02:56 2014 +0200

    pinctrl: clean up after enable refactoring
    
    commit 2243a87d90b42eb38bc281957df3e57c712b5e56
    "pinctrl: avoid duplicated calling enable_pinmux_setting for a pin"
    removed the .disable callback from the struct pinmux_ops,
    making the .enable() callback the only remaining callback.
    
    However .enable() is a bad name as it seems to imply that a
    muxing can also be disabled. Rename the callback to .set_mux()
    and also take this opportunity to clean out any remaining
    mentions of .disable() from the documentation.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Acked-by: Fan Wu <fwu@marvell.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index c055daf9a80f..b874458dcb88 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -41,7 +41,7 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 	    !ops->get_functions_count ||
 	    !ops->get_function_name ||
 	    !ops->get_function_groups ||
-	    !ops->enable) {
+	    !ops->set_mux) {
 		dev_err(pctldev->dev, "pinmux ops lacks necessary functions\n");
 		return -EINVAL;
 	}
@@ -445,15 +445,15 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 		desc->mux_setting = &(setting->data.mux);
 	}
 
-	ret = ops->enable(pctldev, setting->data.mux.func,
-			  setting->data.mux.group);
+	ret = ops->set_mux(pctldev, setting->data.mux.func,
+			   setting->data.mux.group);
 
 	if (ret)
-		goto err_enable;
+		goto err_set_mux;
 
 	return 0;
 
-err_enable:
+err_set_mux:
 	for (i = 0; i < num_pins; i++) {
 		desc = pin_desc_get(pctldev, pins[i]);
 		if (desc)

commit 2243a87d90b42eb38bc281957df3e57c712b5e56
Author: Fan Wu <fwu@marvell.com>
Date:   Mon Jun 9 09:37:56 2014 +0800

    pinctrl: avoid duplicated calling enable_pinmux_setting for a pin
    
    What the patch does:
    1. Call pinmux_disable_setting ahead of pinmux_enable_setting
      each time pinctrl_select_state is called
    2. Remove the HW disable operation in pinmux_disable_setting function.
    3. Remove the disable ops in struct pinmux_ops
    4. Remove all the disable ops users in current code base.
    
    Notes:
    1. Great thanks for the suggestion from Linus, Tony Lindgren and
       Stephen Warren and Everyone that shared comments on this patch.
    2. The patch also includes comment fixes from Stephen Warren.
    
    The reason why we do this:
    1. To avoid duplicated calling of the enable_setting operation
       without disabling operation inbetween which will let the pin
       descriptor desc->mux_usecount increase monotonously.
    2. The HW pin disable operation is not useful for any of the
       existing platforms.
       And this can be used to avoid the HW glitch after using the
       item #1 modification.
    
    In the following case, the issue can be reproduced:
    1. There is a driver that need to switch pin state dynamically,
       e.g. between "sleep" and "default" state
    2. The pin setting configuration in a DTS node may be like this:
    
      component a {
            pinctrl-names = "default", "sleep";
            pinctrl-0 = <&a_grp_setting &c_grp_setting>;
            pinctrl-1 = <&b_grp_setting &c_grp_setting>;
      }
    
      The "c_grp_setting" config node is totally identical, maybe like
      following one:
    
      c_grp_setting: c_grp_setting {
            pinctrl-single,pins = <GPIO48 AF6>;
      }
    
    3. When switching the pin state in the following official pinctrl
       sequence:
            pin = pinctrl_get();
            state = pinctrl_lookup_state(wanted_state);
            pinctrl_select_state(state);
            pinctrl_put();
    
    Test Result:
    1. The switch is completed as expected, that is: the device's
       pin configuration is changed according to the description in the
       "wanted_state" group setting
    2. The "desc->mux_usecount" of the corresponding pins in "c_group"
       is increased without being decreased, because the "desc" is for
       each physical pin while the setting is for each setting node
       in the DTS.
       Thus, if the "c_grp_setting" in pinctrl-0 is not disabled ahead
       of enabling "c_grp_setting" in pinctrl-1, the desc->mux_usecount
       will keep increasing without any chance to be decreased.
    
    According to the comments in the original code, only the setting,
    in old state but not in new state, will be "disabled" (calling
    pinmux_disable_setting), which is correct logic but not intact. We
    still need consider case that the setting is in both old state
    and new state. We can do this in the following two ways:
    
    1. Avoid to "enable"(calling pinmux_enable_setting) the "same pin
       setting" repeatedly
    2. "Disable"(calling pinmux_disable_setting) the "same pin setting",
       actually two setting instances, ahead of enabling them.
    
    Analysis:
    1. The solution #2 is better because it can avoid too much
       iteration.
    2. If we disable all of the settings in the old state and one of
       the setting(s) exist in the new state, the pins mux function
       change may happen when some SoC vendors defined the
       "pinctrl-single,function-off"
       in their DTS file.
       old_setting => disabled_setting => new_setting.
    3. In the pinmux framework, when a pin state is switched, the
       setting in the old state should be marked as "disabled".
    
    Conclusion:
    1. To Remove the HW disabling operation to above the glitch mentioned
       above.
    2. Handle the issue mentioned above by disabling all of the settings
       in old state and then enable the all of the settings in new state.
    
    Signed-off-by: Fan Wu <fwu@marvell.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Maxime Coquelin <maxime.coquelin@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 051e8592990e..c055daf9a80f 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -471,7 +471,6 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	int ret = 0;
 	const unsigned *pins = NULL;
 	unsigned num_pins = 0;
@@ -518,9 +517,6 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 				 pins[i], desc->name, gname);
 		}
 	}
-
-	if (ops->disable)
-		ops->disable(pctldev, setting->data.mux.func, setting->data.mux.group);
 }
 
 #ifdef CONFIG_DEBUG_FS

commit e5b3b2d9ed202697a937c282f9c4d93b1e3e0848
Author: Antoine Ténart <antoine.tenart@free-electrons.com>
Date:   Thu Apr 10 15:07:50 2014 +0200

    pinctrl: allows not to define the get_group_pins operation
    
    When using a group only pinctrl driver, which does not have any
    information on the pins it is useless to define a get_group_pins
    always returning an empty list of pins.
    
    When not using get_group_pin[1], a driver must implement it so
    pins = NULL and num_pins = 0. This patch makes it the default
    behaviour if not defined in the pinctrl driver when used in
    pinmux enable and disable funtions and in pinctrl_groups_show.
    
    It also adds a check in pinctrl_get_group_pins and return -EINVAL if
    not defined. This function is called in the gpiolib when adding when
    pingroup range. It cannot be used if no group is defined, so this seams
    reasonable.
    
    [1] get_group_pin(struct pinctrl_dev *pctldev,
                      unsigned selector,
                      const unsigned **pins,
                      unsigned *num_pins);
    
    Signed-off-by: Antoine TÃ©nart <antoine.tenart@free-electrons.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 9248ce4efed4..051e8592990e 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -391,14 +391,16 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
-	int ret;
-	const unsigned *pins;
-	unsigned num_pins;
+	int ret = 0;
+	const unsigned *pins = NULL;
+	unsigned num_pins = 0;
 	int i;
 	struct pin_desc *desc;
 
-	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
-				      &pins, &num_pins);
+	if (pctlops->get_group_pins)
+		ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
+					      &pins, &num_pins);
+
 	if (ret) {
 		const char *gname;
 
@@ -470,14 +472,15 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
-	int ret;
-	const unsigned *pins;
-	unsigned num_pins;
+	int ret = 0;
+	const unsigned *pins = NULL;
+	unsigned num_pins = 0;
 	int i;
 	struct pin_desc *desc;
 
-	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
-				      &pins, &num_pins);
+	if (pctlops->get_group_pins)
+		ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
+					      &pins, &num_pins);
 	if (ret) {
 		const char *gname;
 

commit 808e657c5c709844074d47a4284c746070b0772c
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Tue Oct 29 04:50:45 2013 +0100

    pinctrl: remove minor dead code
    
    This removes a test whether the 'desc' variable is NULL.
    This possibility has already been eliminated by the
    below test earlier in the loop:
    
                    if (desc == NULL) {
                            dev_warn(pctldev->dev,
                                     "could not get pin desc for pin %d\n",
                                     pins[i]);
                            continue;
                    }
    
    Found with Coverity: CID #1090078
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 9d144a263dc2..9248ce4efed4 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -505,16 +505,14 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 			pin_free(pctldev, pins[i], NULL);
 		} else {
 			const char *gname;
-			const char *pname;
 
-			pname = desc ? desc->name : "non-existing";
 			gname = pctlops->get_group_name(pctldev,
 						setting->data.mux.group);
 			dev_warn(pctldev->dev,
 				 "not freeing pin %d (%s) as part of "
 				 "deactivating group %s - it is already "
 				 "used for some other setting",
-				 pins[i], pname, gname);
+				 pins[i], desc->name, gname);
 		}
 	}
 

commit 1c8e794432c2ee752599bf114f3e8bd683674e3d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Aug 14 18:23:33 2013 +0200

    pinctrl: improve warning messages
    
    Print out the affected group name on activation of pin mux
    settings, and warn if you cannot free a pin that should have
    been part of a certain setting.
    
    ChangeLog v1->v2:
    - Also print the pin name in the error messages.
    
    Cc: Sonic Zhang <sonic.zhang@analog.com>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 5f5158856ea9..9d144a263dc2 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -400,10 +400,14 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
 				      &pins, &num_pins);
 	if (ret) {
+		const char *gname;
+
 		/* errors only affect debug data, so just warn */
+		gname = pctlops->get_group_name(pctldev,
+						setting->data.mux.group);
 		dev_warn(pctldev->dev,
-			 "could not get pins for group selector %d\n",
-			 setting->data.mux.group);
+			 "could not get pins for group %s\n",
+			 gname);
 		num_pins = 0;
 	}
 
@@ -411,9 +415,18 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 	for (i = 0; i < num_pins; i++) {
 		ret = pin_request(pctldev, pins[i], setting->dev_name, NULL);
 		if (ret) {
+			const char *gname;
+			const char *pname;
+
+			desc = pin_desc_get(pctldev, pins[i]);
+			pname = desc ? desc->name : "non-existing";
+			gname = pctlops->get_group_name(pctldev,
+						setting->data.mux.group);
 			dev_err(pctldev->dev,
-				"could not request pin %d on device %s\n",
-				pins[i], pinctrl_dev_get_name(pctldev));
+				"could not request pin %d (%s) from group %s "
+				" on device %s\n",
+				pins[i], pname, gname,
+				pinctrl_dev_get_name(pctldev));
 			goto err_pin_request;
 		}
 	}
@@ -466,10 +479,14 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
 				      &pins, &num_pins);
 	if (ret) {
+		const char *gname;
+
 		/* errors only affect debug data, so just warn */
+		gname = pctlops->get_group_name(pctldev,
+						setting->data.mux.group);
 		dev_warn(pctldev->dev,
-			 "could not get pins for group selector %d\n",
-			 setting->data.mux.group);
+			 "could not get pins for group %s\n",
+			 gname);
 		num_pins = 0;
 	}
 
@@ -486,6 +503,18 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 			desc->mux_setting = NULL;
 			/* And release the pin */
 			pin_free(pctldev, pins[i], NULL);
+		} else {
+			const char *gname;
+			const char *pname;
+
+			pname = desc ? desc->name : "non-existing";
+			gname = pctlops->get_group_name(pctldev,
+						setting->data.mux.group);
+			dev_warn(pctldev->dev,
+				 "not freeing pin %d (%s) as part of "
+				 "deactivating group %s - it is already "
+				 "used for some other setting",
+				 pins[i], pname, gname);
 		}
 	}
 

commit 744f0a9adb6a3478c9753eef56b0614ee69f969e
Author: Sonic Zhang <sonic.zhang@analog.com>
Date:   Wed Aug 14 13:26:43 2013 +0800

    pinctrl: pinmux: Don't free pins requested by other devices in pinmux_disable_setting.
    
    One peripheral may share part of its pins with the 2nd
    peripheral and the other pins with the 3rd. If it requests all pins
    when part of them has already be requested and owned by the 2nd
    peripheral, this request fails and pinmux_disable_setting() is called.
    The pinmux_disable_setting() frees all pins of the first peripheral
    without checking if the pin is owned by itself or the 2nd, which
    results in the malfunction of the 2nd peripheral driver.
    
    Signed-off-by: Sonic Zhang <sonic.zhang@analog.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 88cc5095d0c9..5f5158856ea9 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -482,13 +482,13 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 				 pins[i]);
 			continue;
 		}
-		desc->mux_setting = NULL;
+		if (desc->mux_setting == &(setting->data.mux)) {
+			desc->mux_setting = NULL;
+			/* And release the pin */
+			pin_free(pctldev, pins[i], NULL);
+		}
 	}
 
-	/* And release the pins */
-	for (i = 0; i < num_pins; i++)
-		pin_free(pctldev, pins[i], NULL);
-
 	if (ops->disable)
 		ops->disable(pctldev, setting->data.mux.func, setting->data.mux.group);
 }

commit 42fed7ba44e4e8c1fb27b28ad14490cb1daff3c7
Author: Patrice Chotard <patrice.chotard@st.com>
Date:   Thu Apr 11 11:01:27 2013 +0200

    pinctrl: move subsystem mutex to pinctrl_dev struct
    
    This mutex avoids deadlock in case of use of multiple pin
    controllers. Before this modification, by using a global
    mutex, deadlock appeared when, for example, a call to
    pinctrl_pins_show() locked the pinctrl_mutex, called the
    ops->pin_dbg_show of a particular pin controller. If this
    pin controller needs I2C access to retrieve configuration
    information and I2C driver is using pinctrl to drive its
    pins, a call to pinctrl_select_state() try to lock again
    pinctrl_mutex which leads to a deadlock.
    
    Notice that the mutex grab from the two direction functions
    was moved into pinctrl_gpio_direction().
    
    For several cases, we can't replace pinctrl_mutex by
    pctldev->mutex, because at this stage, pctldev is
    not accessible :
            - pinctrl_get()/pinctrl_put()
            - pinctrl_register_maps()
    
    So add respectively pinctrl_list_mutex and
    pinctrl_maps_mutex in order to protect
    pinctrl_list and pinctrl_maps list instead.
    
    Reintroduce pinctrldev_list_mutex in
    find_pinctrl_by_of_node(),
    pinctrl_find_and_add_gpio_range()
    pinctrl_request_gpio(), pinctrl_free_gpio(),
    pinctrl_gpio_direction(), pinctrl_devices_show(),
    pinctrl_register() and pinctrl_unregister() to
    protect pinctrldev_list.
    
    Changes v2->v3:
    - Fix a missing EXPORT_SYMBOL_GPL() for pinctrl_select_state().
    
    Changes v1->v2:
    - pinctrl_select_state_locked() is removed, all lock mechanism
      is located inside pinctrl_select_state(). When parsing
      the state->setting list, take the per-pin-controller driver
      lock. (Patrice).
    - Introduce pinctrldev_list_mutex to protect pinctrldev_list
      in all functions which parse or modify pictrldev_list.
      (Patrice).
    - move find_pinctrl_by_of_node() from pinctrl/devicetree.c to
      pinctrl/core.c in order to protect pinctrldev_list.
      (Patrice).
    - Sink mutex:es into some functions and remove some _locked
      variants down to where the lists are actually accessed to
      make things simpler. (Linus)
    - Drop *all* mutexes completely from pinctrl_lookup_state()
      and pinctrl_select_state() - no relevant mutex was taken
      and it was unclear what this was protecting against. (Linus)
    
    Reported by : Seraphin Bonnaffe <seraphin.bonnaffe@stericsson.com>
    Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index bd83c8b01cd1..88cc5095d0c9 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -506,7 +506,7 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 	if (!pmxops)
 		return 0;
 
-	mutex_lock(&pinctrl_mutex);
+	mutex_lock(&pctldev->mutex);
 	nfuncs = pmxops->get_functions_count(pctldev);
 	while (func_selector < nfuncs) {
 		const char *func = pmxops->get_function_name(pctldev,
@@ -530,7 +530,7 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 		func_selector++;
 	}
 
-	mutex_unlock(&pinctrl_mutex);
+	mutex_unlock(&pctldev->mutex);
 
 	return 0;
 }
@@ -548,7 +548,7 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	seq_puts(s, "Pinmux settings per pin\n");
 	seq_puts(s, "Format: pin (name): mux_owner gpio_owner hog?\n");
 
-	mutex_lock(&pinctrl_mutex);
+	mutex_lock(&pctldev->mutex);
 
 	/* The pin number can be retrived from the pin controller descriptor */
 	for (i = 0; i < pctldev->desc->npins; i++) {
@@ -583,7 +583,7 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 			seq_printf(s, "\n");
 	}
 
-	mutex_unlock(&pinctrl_mutex);
+	mutex_unlock(&pctldev->mutex);
 
 	return 0;
 }

commit 740924a267e85de09707ea158bbf594b4d8bae01
Author: Richard Genoud <richard.genoud@gmail.com>
Date:   Thu Mar 21 12:21:47 2013 +0100

    pinmux: forbid mux_usecount to be set at UINT_MAX
    
    If pin_free is called on a pin already freed, mux_usecount is set to
    UINT_MAX which is really a bad idea.
    
    This will issue a warning, so that we can correct the code responsible
    for the double free.
    
    Signed-off-by: Richard Genoud <richard.genoud@gmail.com>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 1a00658b3ea0..bd83c8b01cd1 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -194,6 +194,11 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 	}
 
 	if (!gpio_range) {
+		/*
+		 * A pin should not be freed more times than allocated.
+		 */
+		if (WARN_ON(!desc->mux_usecount))
+			return NULL;
 		desc->mux_usecount--;
 		if (desc->mux_usecount)
 			return NULL;

commit e38d457de7be63e6ced1ea254aa51466deb1fef0
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat Nov 10 21:53:20 2012 +0800

    pinctrl: pinmux: Release all taken pins in pinmux_enable_setting error paths
    
    Currently pinmux_enable_setting does not release all taken pins if
    ops->enable() returns error. This patch ensures all taken pins are
    released in any error paths.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 0ef01ee2835f..1a00658b3ea0 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -409,11 +409,7 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 			dev_err(pctldev->dev,
 				"could not request pin %d on device %s\n",
 				pins[i], pinctrl_dev_get_name(pctldev));
-			/* On error release all taken pins */
-			i--; /* this pin just failed */
-			for (; i >= 0; i--)
-				pin_free(pctldev, pins[i], NULL);
-			return -ENODEV;
+			goto err_pin_request;
 		}
 	}
 
@@ -429,8 +425,26 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 		desc->mux_setting = &(setting->data.mux);
 	}
 
-	return ops->enable(pctldev, setting->data.mux.func,
-			   setting->data.mux.group);
+	ret = ops->enable(pctldev, setting->data.mux.func,
+			  setting->data.mux.group);
+
+	if (ret)
+		goto err_enable;
+
+	return 0;
+
+err_enable:
+	for (i = 0; i < num_pins; i++) {
+		desc = pin_desc_get(pctldev, pins[i]);
+		if (desc)
+			desc->mux_setting = NULL;
+	}
+err_pin_request:
+	/* On error release all taken pins */
+	while (--i >= 0)
+		pin_free(pctldev, pins[i], NULL);
+
+	return ret;
 }
 
 void pinmux_disable_setting(struct pinctrl_setting const *setting)

commit 1a78958dc212f3698fdc543857af80155cb30f7f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 17 20:51:54 2012 +0200

    pinctrl: reserve pins when states are activated
    
    This switches the way that pins are reserved for multiplexing:
    
    We used to do this when the map was parsed, at the creation of
    the settings inside the pinctrl handle, in pinmux_map_to_setting().
    
    However this does not work for us, because we want to use the
    same set of pins with different devices at different times: the
    current code assumes that the pin groups in a pinmux state will
    only be used with one single device, albeit different groups can
    be active at different times. For example if a single I2C driver
    block is used to drive two different busses located on two
    pin groups A and B, then the pins for all possible states of a
    function are reserved when fetching the pinctrl handle: the
    I2C bus can choose either set A or set B by a mux state at
    runtime, but all pins in both group A and B (the superset) are
    effectively reserved for that I2C function and mapped to the
    device. Another device can never get in and use the pins in
    group A, even if the device/function is using group B at the
    moment.
    
    Instead: let use reserve the pins when the state is activated
    and drop them when the state is disabled, i.e. when we move to
    another state. This way different devices/functions can use the
    same pins at different times.
    
    We know that this is an odd way of doing things, but we really
    need to switch e.g. an SD-card slot to become a tracing output
    sink at runtime: we plug in a special "tracing card" then mux
    the pins that used to be an SD slot around to the tracing
    unit and push out tracing data there instead of SD-card
    traffic.
    
    As a side effect pinmux_free_setting() is unused but the stubs
    are kept for future additions of code.
    
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Loic Pallardy <loic.pallardy@st.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Jean Nicolas Graux <jean-nicolas.graux@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 9301a7a95eff..0ef01ee2835f 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -314,14 +314,11 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
-	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
 	char const * const *groups;
 	unsigned num_groups;
 	int ret;
 	const char *group;
 	int i;
-	const unsigned *pins;
-	unsigned num_pins;
 
 	if (!pmxops) {
 		dev_err(pctldev->dev, "does not support mux function\n");
@@ -376,53 +373,12 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 	}
 	setting->data.mux.group = ret;
 
-	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group, &pins,
-				      &num_pins);
-	if (ret) {
-		dev_err(pctldev->dev,
-			"could not get pins for device %s group selector %d\n",
-			pinctrl_dev_get_name(pctldev), setting->data.mux.group);
-			return -ENODEV;
-	}
-
-	/* Try to allocate all pins in this group, one by one */
-	for (i = 0; i < num_pins; i++) {
-		ret = pin_request(pctldev, pins[i], map->dev_name, NULL);
-		if (ret) {
-			dev_err(pctldev->dev,
-				"could not request pin %d on device %s\n",
-				pins[i], pinctrl_dev_get_name(pctldev));
-			/* On error release all taken pins */
-			i--; /* this pin just failed */
-			for (; i >= 0; i--)
-				pin_free(pctldev, pins[i], NULL);
-			return -ENODEV;
-		}
-	}
-
 	return 0;
 }
 
 void pinmux_free_setting(struct pinctrl_setting const *setting)
 {
-	struct pinctrl_dev *pctldev = setting->pctldev;
-	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	const unsigned *pins;
-	unsigned num_pins;
-	int ret;
-	int i;
-
-	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
-				      &pins, &num_pins);
-	if (ret) {
-		dev_err(pctldev->dev,
-			"could not get pins for device %s group selector %d\n",
-			pinctrl_dev_get_name(pctldev), setting->data.mux.group);
-		return;
-	}
-
-	for (i = 0; i < num_pins; i++)
-		pin_free(pctldev, pins[i], NULL);
+	/* This function is currently unused */
 }
 
 int pinmux_enable_setting(struct pinctrl_setting const *setting)
@@ -446,6 +402,22 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 		num_pins = 0;
 	}
 
+	/* Try to allocate all pins in this group, one by one */
+	for (i = 0; i < num_pins; i++) {
+		ret = pin_request(pctldev, pins[i], setting->dev_name, NULL);
+		if (ret) {
+			dev_err(pctldev->dev,
+				"could not request pin %d on device %s\n",
+				pins[i], pinctrl_dev_get_name(pctldev));
+			/* On error release all taken pins */
+			i--; /* this pin just failed */
+			for (; i >= 0; i--)
+				pin_free(pctldev, pins[i], NULL);
+			return -ENODEV;
+		}
+	}
+
+	/* Now that we have acquired the pins, encode the mux setting */
 	for (i = 0; i < num_pins; i++) {
 		desc = pin_desc_get(pctldev, pins[i]);
 		if (desc == NULL) {
@@ -482,6 +454,7 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 		num_pins = 0;
 	}
 
+	/* Flag the descs that no setting is active */
 	for (i = 0; i < num_pins; i++) {
 		desc = pin_desc_get(pctldev, pins[i]);
 		if (desc == NULL) {
@@ -493,6 +466,10 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 		desc->mux_setting = NULL;
 	}
 
+	/* And release the pins */
+	for (i = 0; i < num_pins; i++)
+		pin_free(pctldev, pins[i], NULL);
+
 	if (ops->disable)
 		ops->disable(pctldev, setting->data.mux.func, setting->data.mux.group);
 }

commit 23a895aee6081c144ffcc61eaf52dc62e10b3bd1
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Sep 13 21:48:14 2012 +0200

    pinctrl: use kasprintf() in pinmux_request_gpio()
    
    Instead of using a temporary buffer, snprintf() and kstrdup(), just
    use kasprintf() that does the same thing in just oneline.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Colin Cross <ccross@google.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 3d5ac73bd5a7..9301a7a95eff 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -232,14 +232,11 @@ int pinmux_request_gpio(struct pinctrl_dev *pctldev,
 			struct pinctrl_gpio_range *range,
 			unsigned pin, unsigned gpio)
 {
-	char gpiostr[16];
 	const char *owner;
 	int ret;
 
 	/* Conjure some name stating what chip and pin this is taken by */
-	snprintf(gpiostr, 15, "%s:%d", range->name, gpio);
-
-	owner = kstrdup(gpiostr, GFP_KERNEL);
+	owner = kasprintf(GFP_KERNEL, "%s:%d", range->name, gpio);
 	if (!owner)
 		return -EINVAL;
 

commit 02b50ce4cb1b6aff7d9f1c0c5b4ceb44107bacb4
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Mon May 14 19:06:37 2012 +0800

    pinctrl: make pinmux disable function optional
    
    Some SoCs may not have pinmux disable function in HW.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 220fa492c9f0..3d5ac73bd5a7 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -41,8 +41,7 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 	    !ops->get_functions_count ||
 	    !ops->get_function_name ||
 	    !ops->get_function_groups ||
-	    !ops->enable ||
-	    !ops->disable) {
+	    !ops->enable) {
 		dev_err(pctldev->dev, "pinmux ops lacks necessary functions\n");
 		return -EINVAL;
 	}
@@ -497,7 +496,8 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 		desc->mux_setting = NULL;
 	}
 
-	ops->disable(pctldev, setting->data.mux.func, setting->data.mux.group);
+	if (ops->disable)
+		ops->disable(pctldev, setting->data.mux.func, setting->data.mux.group);
 }
 
 #ifdef CONFIG_DEBUG_FS

commit d4705316c18d371eb404d0ae5dcf51ce6e341d0f
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue May 1 11:14:15 2012 -0600

    pinctrl: add more info to error msgs in pin_request
    
    Additionally print which pin the request failed for, which entity already
    claimed it, and what entity was trying to claim it.
    
    Remove duplicate device name from a debug message.
    
    Clean up some indentation.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 2df753508eca..220fa492c9f0 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -92,7 +92,8 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
 		dev_err(pctldev->dev,
-			"pin is not registered so it cannot be requested\n");
+			"pin %d is not registered so it cannot be requested\n",
+			pin);
 		goto out;
 	}
 
@@ -103,7 +104,8 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		/* There's no need to support multiple GPIO requests */
 		if (desc->gpio_owner) {
 			dev_err(pctldev->dev,
-				"pin already requested\n");
+				"pin %s already requested by %s; cannot claim for %s\n",
+				desc->name, desc->gpio_owner, owner);
 			goto out;
 		}
 
@@ -111,7 +113,8 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	} else {
 		if (desc->mux_usecount && strcmp(desc->mux_owner, owner)) {
 			dev_err(pctldev->dev,
-				"pin already requested\n");
+				"pin %s already requested by %s; cannot claim for %s\n",
+				desc->name, desc->mux_owner, owner);
 			goto out;
 		}
 
@@ -144,8 +147,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		status = 0;
 
 	if (status) {
-		dev_err(pctldev->dev, "request on device %s failed for pin %d\n",
-		       pctldev->desc->name, pin);
+		dev_err(pctldev->dev, "request() failed for pin %d\n", pin);
 		module_put(pctldev->owner);
 	}
 
@@ -162,7 +164,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 out:
 	if (status)
 		dev_err(pctldev->dev, "pin-%d (%s) status %d\n",
-		       pin, owner, status);
+			pin, owner, status);
 
 	return status;
 }

commit ad6e1107baa2e7fda55c2020c25127eab9c0122b
Author: John Crispin <blogic@openwrt.org>
Date:   Thu Apr 26 16:47:11 2012 +0200

    pinctrl: enhance reporting of errors when loading from DT
    
    There are a few places in the api where the code simply returns -EINVAL when
    it finds an error. An example is pinmux_map_to_setting() which now reports an
    error if we try to match a group with a function that it does not support.
    
    The reporting of errors in pinconf_check_ops and pinmux_check_ops now has the
    same style and is located inside the according functions and not the calling
    code.
    
    When the map is found in the DT but the default state can not be selected we
    get an error to know that the code at least tried.
    
    The patch also removes a stray word from one comment and a "->" from another
    for the sake of consistency.
    
    Finally we replace a few pr_err/debug() calls with dev_err/dbg().
    
    Thanks go to Stephen Warren for reviewing the patch and enhancing the reporting
    inside pinmux_map_to_setting().
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 7cd0c7d0f2cf..2df753508eca 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -42,9 +42,10 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 	    !ops->get_function_name ||
 	    !ops->get_function_groups ||
 	    !ops->enable ||
-	    !ops->disable)
+	    !ops->disable) {
+		dev_err(pctldev->dev, "pinmux ops lacks necessary functions\n");
 		return -EINVAL;
-
+	}
 	/* Check that all functions registered have names */
 	nfuncs = ops->get_functions_count(pctldev);
 	while (selector < nfuncs) {
@@ -143,7 +144,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		status = 0;
 
 	if (status) {
-		dev_err(pctldev->dev, "->request on device %s failed for pin %d\n",
+		dev_err(pctldev->dev, "request on device %s failed for pin %d\n",
 		       pctldev->desc->name, pin);
 		module_put(pctldev->owner);
 	}
@@ -330,17 +331,26 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 	}
 
 	ret = pinmux_func_name_to_selector(pctldev, map->data.mux.function);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(pctldev->dev, "invalid function %s in map table\n",
+			map->data.mux.function);
 		return ret;
+	}
 	setting->data.mux.func = ret;
 
 	ret = pmxops->get_function_groups(pctldev, setting->data.mux.func,
 					  &groups, &num_groups);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(pctldev->dev, "can't query groups for function %s\n",
+			map->data.mux.function);
 		return ret;
-	if (!num_groups)
+	}
+	if (!num_groups) {
+		dev_err(pctldev->dev,
+			"function %s can't be selected on any group\n",
+			map->data.mux.function);
 		return -EINVAL;
-
+	}
 	if (map->data.mux.group) {
 		bool found = false;
 		group = map->data.mux.group;
@@ -350,15 +360,22 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 				break;
 			}
 		}
-		if (!found)
+		if (!found) {
+			dev_err(pctldev->dev,
+				"invalid group \"%s\" for function \"%s\"\n",
+				group, map->data.mux.function);
 			return -EINVAL;
+		}
 	} else {
 		group = groups[0];
 	}
 
 	ret = pinctrl_get_group_selector(pctldev, group);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(pctldev->dev, "invalid group %s in map table\n",
+			map->data.mux.group);
 		return ret;
+	}
 	setting->data.mux.group = ret;
 
 	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group, &pins,
@@ -375,7 +392,7 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 		ret = pin_request(pctldev, pins[i], map->dev_name, NULL);
 		if (ret) {
 			dev_err(pctldev->dev,
-				"could not get request pin %d on device %s\n",
+				"could not request pin %d on device %s\n",
 				pins[i], pinctrl_dev_get_name(pctldev));
 			/* On error release all taken pins */
 			i--; /* this pin just failed */

commit 15f70e1b9a1a6351c252cb8892272cc4601818c7
Author: John Crispin <blogic@openwrt.org>
Date:   Mon Apr 23 19:01:58 2012 +0200

    pinctrl: fix signed vs unsigned conditionals inside pinmux_map_to_setting
    
    pinmux_map_to_setting() uses setting->data.mux.func/group to store the return
    code of pinmux_func_name_to_selector/pinctrl_get_group_selector(). However,
    struct pinctrl_setting_mux defines these elements as unsigned, resulting in all
    error codes getting lost. The conditionals following the assignments will always
    evaluate to false thus breaking the error paths.
    
    This bug can be triggered by loading a pinmux group map from the devicetree
    with an invalid function/group string.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index fa0357bd88ff..7cd0c7d0f2cf 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -329,10 +329,10 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 		return -EINVAL;
 	}
 
-	setting->data.mux.func =
-		pinmux_func_name_to_selector(pctldev, map->data.mux.function);
-	if (setting->data.mux.func < 0)
-		return setting->data.mux.func;
+	ret = pinmux_func_name_to_selector(pctldev, map->data.mux.function);
+	if (ret < 0)
+		return ret;
+	setting->data.mux.func = ret;
 
 	ret = pmxops->get_function_groups(pctldev, setting->data.mux.func,
 					  &groups, &num_groups);
@@ -356,9 +356,10 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 		group = groups[0];
 	}
 
-	setting->data.mux.group = pinctrl_get_group_selector(pctldev, group);
-	if (setting->data.mux.group < 0)
-		return setting->data.mux.group;
+	ret = pinctrl_get_group_selector(pctldev, group);
+	if (ret < 0)
+		return ret;
+	setting->data.mux.group = ret;
 
 	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group, &pins,
 				      &num_pins);

commit d0bd8df56ebffe4a5ca42e27aca2a1243c70ed53
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Tue Apr 17 15:00:45 2012 +0800

    pinctrl: show pin name when request pins
    
    Pin name is more useful to users.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index c494c37bf167..fa0357bd88ff 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -88,8 +88,6 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	int status = -EINVAL;
 
-	dev_dbg(pctldev->dev, "request pin %d for %s\n", pin, owner);
-
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
 		dev_err(pctldev->dev,
@@ -97,6 +95,9 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		goto out;
 	}
 
+	dev_dbg(pctldev->dev, "request pin %d (%s) for %s\n",
+		pin, desc->name, owner);
+
 	if (gpio_range) {
 		/* There's no need to support multiple GPIO requests */
 		if (desc->gpio_owner) {

commit ad8bb720c23a80233e45ed31d67458f5e5b7ab31
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Tue Apr 10 12:41:34 2012 +0800

    pinctrl: add some error checking for user interfaces
    
    This patch can avoid kernel oops in case the mux or config
    function is not supported by driver.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 8849830e5190..c494c37bf167 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -323,6 +323,11 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 	const unsigned *pins;
 	unsigned num_pins;
 
+	if (!pmxops) {
+		dev_err(pctldev->dev, "does not support mux function\n");
+		return -EINVAL;
+	}
+
 	setting->data.mux.func =
 		pinmux_func_name_to_selector(pctldev, map->data.mux.function);
 	if (setting->data.mux.func < 0)
@@ -481,11 +486,14 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 {
 	struct pinctrl_dev *pctldev = s->private;
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
-	unsigned nfuncs = pmxops->get_functions_count(pctldev);
+	unsigned nfuncs;
 	unsigned func_selector = 0;
 
-	mutex_lock(&pinctrl_mutex);
+	if (!pmxops)
+		return 0;
 
+	mutex_lock(&pinctrl_mutex);
+	nfuncs = pmxops->get_functions_count(pctldev);
 	while (func_selector < nfuncs) {
 		const char *func = pmxops->get_function_name(pctldev,
 							  func_selector);
@@ -520,6 +528,9 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
 	unsigned i, pin;
 
+	if (!pmxops)
+		return 0;
+
 	seq_puts(s, "Pinmux settings per pin\n");
 	seq_puts(s, "Format: pin (name): mux_owner gpio_owner hog?\n");
 

commit a1d31f71e6ed2f714830df8885ec07dfe1f6632e
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Fri Apr 6 20:18:09 2012 +0800

    pinctrl: fix pinmux_check_ops error checking
    
    Do not use get_functions_count before checking.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 375b214780e9..8849830e5190 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -33,11 +33,12 @@
 int pinmux_check_ops(struct pinctrl_dev *pctldev)
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
-	unsigned nfuncs = ops->get_functions_count(pctldev);
+	unsigned nfuncs;
 	unsigned selector = 0;
 
 	/* Check that we implement required operations */
-	if (!ops->get_functions_count ||
+	if (!ops ||
+	    !ops->get_functions_count ||
 	    !ops->get_function_name ||
 	    !ops->get_function_groups ||
 	    !ops->enable ||
@@ -45,11 +46,12 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 		return -EINVAL;
 
 	/* Check that all functions registered have names */
+	nfuncs = ops->get_functions_count(pctldev);
 	while (selector < nfuncs) {
 		const char *fname = ops->get_function_name(pctldev,
 							   selector);
 		if (!fname) {
-			pr_err("pinmux ops has no name for function%u\n",
+			dev_err(pctldev->dev, "pinmux ops has no name for function%u\n",
 				selector);
 			return -EINVAL;
 		}

commit d1e90e9e7467dbfe521b25ba79f520bf676ebc36
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Fri Mar 30 11:25:40 2012 +0530

    pinctrl: replace list_*() with get_*_count()
    
    Most of the SoC drivers implement list_groups() and list_functions()
    routines for pinctrl and pinmux. These routines continue returning
    zero until the selector argument is greater than total count of
    available groups or functions.
    
    This patch replaces these list_*() routines with get_*_count()
    routines, which returns the number of available selection for SoC
    driver. pinctrl layer will use this value to check the range it can
    choose.
    
    This patch fixes all user drivers for this change. There are other
    routines in user drivers, which have checks to check validity of
    selector passed to them. It is also no more required and hence
    removed.
    
    Documentation updated as well.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    [Folded in fix and fixed a minor merge artifact manually]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 4e62783a573a..375b214780e9 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -33,10 +33,11 @@
 int pinmux_check_ops(struct pinctrl_dev *pctldev)
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	unsigned nfuncs = ops->get_functions_count(pctldev);
 	unsigned selector = 0;
 
 	/* Check that we implement required operations */
-	if (!ops->list_functions ||
+	if (!ops->get_functions_count ||
 	    !ops->get_function_name ||
 	    !ops->get_function_groups ||
 	    !ops->enable ||
@@ -44,7 +45,7 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 		return -EINVAL;
 
 	/* Check that all functions registered have names */
-	while (ops->list_functions(pctldev, selector) >= 0) {
+	while (selector < nfuncs) {
 		const char *fname = ops->get_function_name(pctldev,
 							   selector);
 		if (!fname) {
@@ -287,10 +288,11 @@ static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,
 					const char *function)
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	unsigned nfuncs = ops->get_functions_count(pctldev);
 	unsigned selector = 0;
 
 	/* See if this pctldev has this function */
-	while (ops->list_functions(pctldev, selector) >= 0) {
+	while (selector < nfuncs) {
 		const char *fname = ops->get_function_name(pctldev,
 							   selector);
 
@@ -477,11 +479,12 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 {
 	struct pinctrl_dev *pctldev = s->private;
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
+	unsigned nfuncs = pmxops->get_functions_count(pctldev);
 	unsigned func_selector = 0;
 
 	mutex_lock(&pinctrl_mutex);
 
-	while (pmxops->list_functions(pctldev, func_selector) >= 0) {
+	while (func_selector < nfuncs) {
 		const char *func = pmxops->get_function_name(pctldev,
 							  func_selector);
 		const char * const *groups;

commit 652162d469a73450a66b6c8049b16c2b7828fa24
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Mar 5 17:22:15 2012 -0700

    pinctrl: allow concurrent gpio and mux function ownership of pins
    
    Per recent updates to Documentation/gpio.txt, gpiolib drivers should
    inform pinctrl when a GPIO is requested. pinctrl then marks that pin as
    in-use for that GPIO function.
    
    When an SoC muxes pins in a group, it's quite possible for the group to
    contain e.g. 6 pins, but only 4 of them actually be needed by the HW
    module that's mux'd to them. In this case, the other 2 pins could be
    used as GPIOs. However, pinctrl marks all the pins within the group as
    in-use by the selected mux function. To allow the expected gpiolib
    interaction, separate the concepts of pin ownership into two parts: One
    for the mux function and one for GPIO usage. Finally, allow those two
    ownerships to exist in parallel.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 86e401754116..4e62783a573a 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -94,17 +94,28 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		goto out;
 	}
 
-	if (desc->usecount && strcmp(desc->owner, owner)) {
-		dev_err(pctldev->dev,
-			"pin already requested\n");
-		goto out;
-	}
+	if (gpio_range) {
+		/* There's no need to support multiple GPIO requests */
+		if (desc->gpio_owner) {
+			dev_err(pctldev->dev,
+				"pin already requested\n");
+			goto out;
+		}
 
-	desc->usecount++;
-	if (desc->usecount > 1)
-		return 0;
+		desc->gpio_owner = owner;
+	} else {
+		if (desc->mux_usecount && strcmp(desc->mux_owner, owner)) {
+			dev_err(pctldev->dev,
+				"pin already requested\n");
+			goto out;
+		}
 
-	desc->owner = owner;
+		desc->mux_usecount++;
+		if (desc->mux_usecount > 1)
+			return 0;
+
+		desc->mux_owner = owner;
+	}
 
 	/* Let each pin increase references to this module */
 	if (!try_module_get(pctldev->owner)) {
@@ -135,9 +146,13 @@ static int pin_request(struct pinctrl_dev *pctldev,
 
 out_free_pin:
 	if (status) {
-		desc->usecount--;
-		if (!desc->usecount)
-			desc->owner = NULL;
+		if (gpio_range) {
+			desc->gpio_owner = NULL;
+		} else {
+			desc->mux_usecount--;
+			if (!desc->mux_usecount)
+				desc->mux_owner = NULL;
+		}
 	}
 out:
 	if (status)
@@ -172,9 +187,11 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 		return NULL;
 	}
 
-	desc->usecount--;
-	if (desc->usecount)
-		return NULL;
+	if (!gpio_range) {
+		desc->mux_usecount--;
+		if (desc->mux_usecount)
+			return NULL;
+	}
 
 	/*
 	 * If there is no kind of request function for the pin we just assume
@@ -185,9 +202,15 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 	else if (ops->free)
 		ops->free(pctldev, pin);
 
-	owner = desc->owner;
-	desc->owner = NULL;
-	desc->mux_setting = NULL;
+	if (gpio_range) {
+		owner = desc->gpio_owner;
+		desc->gpio_owner = NULL;
+	} else {
+		owner = desc->mux_owner;
+		desc->mux_owner = NULL;
+		desc->mux_setting = NULL;
+	}
+
 	module_put(pctldev->owner);
 
 	return owner;
@@ -493,7 +516,7 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	unsigned i, pin;
 
 	seq_puts(s, "Pinmux settings per pin\n");
-	seq_puts(s, "Format: pin (name): owner\n");
+	seq_puts(s, "Format: pin (name): mux_owner gpio_owner hog?\n");
 
 	mutex_lock(&pinctrl_mutex);
 
@@ -508,13 +531,16 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 		if (desc == NULL)
 			continue;
 
-		if (desc->owner &&
-		    !strcmp(desc->owner, pinctrl_dev_get_name(pctldev)))
+		if (desc->mux_owner &&
+		    !strcmp(desc->mux_owner, pinctrl_dev_get_name(pctldev)))
 			is_hog = true;
 
-		seq_printf(s, "pin %d (%s): %s%s", pin,
+		seq_printf(s, "pin %d (%s): %s %s%s", pin,
 			   desc->name ? desc->name : "unnamed",
-			   desc->owner ? desc->owner : "UNCLAIMED",
+			   desc->mux_owner ? desc->mux_owner
+				: "(MUX UNCLAIMED)",
+			   desc->gpio_owner ? desc->gpio_owner
+				: "(GPIO UNCLAIMED)",
 			   is_hog ? " (HOG)" : "");
 
 		if (desc->mux_setting)

commit ba110d90c08d9676370db9a62792f57ade5b3bbf
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:49 2012 -0700

    pinctrl: Show selected function and group in pinmux-pins debugfs
    
    Until recently, the pinctrl pinmux-pins debugfs file displayed the
    selected function for each owned pin. This feature was removed during
    restructing in support of recent API rework. This change restoreds this
    feature, and also displays the group that the function was selected on,
    in case a pin is a member of multiple groups.
    
    Based on work by: Linus Walleij <linus.walleij@linaro.org>
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 4852ebe5712e..86e401754116 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -187,6 +187,7 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 
 	owner = desc->owner;
 	desc->owner = NULL;
+	desc->mux_setting = NULL;
 	module_put(pctldev->owner);
 
 	return owner;
@@ -378,7 +379,34 @@ void pinmux_free_setting(struct pinctrl_setting const *setting)
 int pinmux_enable_setting(struct pinctrl_setting const *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	int ret;
+	const unsigned *pins;
+	unsigned num_pins;
+	int i;
+	struct pin_desc *desc;
+
+	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
+				      &pins, &num_pins);
+	if (ret) {
+		/* errors only affect debug data, so just warn */
+		dev_warn(pctldev->dev,
+			 "could not get pins for group selector %d\n",
+			 setting->data.mux.group);
+		num_pins = 0;
+	}
+
+	for (i = 0; i < num_pins; i++) {
+		desc = pin_desc_get(pctldev, pins[i]);
+		if (desc == NULL) {
+			dev_warn(pctldev->dev,
+				 "could not get pin desc for pin %d\n",
+				 pins[i]);
+			continue;
+		}
+		desc->mux_setting = &(setting->data.mux);
+	}
 
 	return ops->enable(pctldev, setting->data.mux.func,
 			   setting->data.mux.group);
@@ -387,7 +415,34 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 void pinmux_disable_setting(struct pinctrl_setting const *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	int ret;
+	const unsigned *pins;
+	unsigned num_pins;
+	int i;
+	struct pin_desc *desc;
+
+	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
+				      &pins, &num_pins);
+	if (ret) {
+		/* errors only affect debug data, so just warn */
+		dev_warn(pctldev->dev,
+			 "could not get pins for group selector %d\n",
+			 setting->data.mux.group);
+		num_pins = 0;
+	}
+
+	for (i = 0; i < num_pins; i++) {
+		desc = pin_desc_get(pctldev, pins[i]);
+		if (desc == NULL) {
+			dev_warn(pctldev->dev,
+				 "could not get pin desc for pin %d\n",
+				 pins[i]);
+			continue;
+		}
+		desc->mux_setting = NULL;
+	}
 
 	ops->disable(pctldev, setting->data.mux.func, setting->data.mux.group);
 }
@@ -433,6 +488,8 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 static int pinmux_pins_show(struct seq_file *s, void *what)
 {
 	struct pinctrl_dev *pctldev = s->private;
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
 	unsigned i, pin;
 
 	seq_puts(s, "Pinmux settings per pin\n");
@@ -455,10 +512,19 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 		    !strcmp(desc->owner, pinctrl_dev_get_name(pctldev)))
 			is_hog = true;
 
-		seq_printf(s, "pin %d (%s): %s%s\n", pin,
+		seq_printf(s, "pin %d (%s): %s%s", pin,
 			   desc->name ? desc->name : "unnamed",
 			   desc->owner ? desc->owner : "UNCLAIMED",
 			   is_hog ? " (HOG)" : "");
+
+		if (desc->mux_setting)
+			seq_printf(s, " function %s group %s\n",
+				   pmxops->get_function_name(pctldev,
+					desc->mux_setting->func),
+				   pctlops->get_group_name(pctldev,
+					desc->mux_setting->group));
+		else
+			seq_printf(s, "\n");
 	}
 
 	mutex_unlock(&pinctrl_mutex);

commit 1e2082b520721734c358f776d34a069867214c8e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:48 2012 -0700

    pinctrl: enhance mapping table to support pin config operations
    
    The pinctrl mapping table can now contain entries to:
    * Set the mux function of a pin group
    * Apply a set of pin config options to a pin or a group
    
    This allows pinctrl_select_state() to apply pin configs settings as well
    as mux settings.
    
    v3: Fix find_pinctrl() to iterate over the correct list.
       s/_MUX_CONFIGS_/_CONFIGS_/ in mapping table macros.
       Fix documentation to use correct mapping table macro.
    v2: Added numerous extra PIN_MAP_*() special-case macros.
       Fixed kerneldoc typo. Delete pinctrl_get_pin_id() and
       replace it with pin_get_from_name(). Various minor fixes.
       Updates due to rebase.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 56ca42e6a6ec..4852ebe5712e 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -58,6 +58,17 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 	return 0;
 }
 
+int pinmux_validate_map(struct pinctrl_map const *map, int i)
+{
+	if (!map->data.mux.function) {
+		pr_err("failed to register map %s (%d): no function given\n",
+		       map->name, i);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 /**
  * pin_request() - request a single pin to be muxed in, typically for GPIO
  * @pin: the pin number in the global pin space
@@ -284,21 +295,21 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 	const unsigned *pins;
 	unsigned num_pins;
 
-	setting->func_selector =
-		pinmux_func_name_to_selector(pctldev, map->function);
-	if (setting->func_selector < 0)
-		return setting->func_selector;
+	setting->data.mux.func =
+		pinmux_func_name_to_selector(pctldev, map->data.mux.function);
+	if (setting->data.mux.func < 0)
+		return setting->data.mux.func;
 
-	ret = pmxops->get_function_groups(pctldev, setting->func_selector,
+	ret = pmxops->get_function_groups(pctldev, setting->data.mux.func,
 					  &groups, &num_groups);
 	if (ret < 0)
 		return ret;
 	if (!num_groups)
 		return -EINVAL;
 
-	if (map->group) {
+	if (map->data.mux.group) {
 		bool found = false;
-		group = map->group;
+		group = map->data.mux.group;
 		for (i = 0; i < num_groups; i++) {
 			if (!strcmp(group, groups[i])) {
 				found = true;
@@ -311,17 +322,16 @@ int pinmux_map_to_setting(struct pinctrl_map const *map,
 		group = groups[0];
 	}
 
-	setting->group_selector =
-		pinctrl_get_group_selector(pctldev, group);
-	if (setting->group_selector < 0)
-		return setting->group_selector;
+	setting->data.mux.group = pinctrl_get_group_selector(pctldev, group);
+	if (setting->data.mux.group < 0)
+		return setting->data.mux.group;
 
-	ret = pctlops->get_group_pins(pctldev, setting->group_selector,
-				      &pins, &num_pins);
+	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group, &pins,
+				      &num_pins);
 	if (ret) {
 		dev_err(pctldev->dev,
 			"could not get pins for device %s group selector %d\n",
-			pinctrl_dev_get_name(pctldev), setting->group_selector);
+			pinctrl_dev_get_name(pctldev), setting->data.mux.group);
 			return -ENODEV;
 	}
 
@@ -352,12 +362,12 @@ void pinmux_free_setting(struct pinctrl_setting const *setting)
 	int ret;
 	int i;
 
-	ret = pctlops->get_group_pins(pctldev, setting->group_selector,
+	ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
 				      &pins, &num_pins);
 	if (ret) {
 		dev_err(pctldev->dev,
 			"could not get pins for device %s group selector %d\n",
-			pinctrl_dev_get_name(pctldev), setting->group_selector);
+			pinctrl_dev_get_name(pctldev), setting->data.mux.group);
 		return;
 	}
 
@@ -370,8 +380,8 @@ int pinmux_enable_setting(struct pinctrl_setting const *setting)
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 
-	return ops->enable(pctldev, setting->func_selector,
-			   setting->group_selector);
+	return ops->enable(pctldev, setting->data.mux.func,
+			   setting->data.mux.group);
 }
 
 void pinmux_disable_setting(struct pinctrl_setting const *setting)
@@ -379,7 +389,7 @@ void pinmux_disable_setting(struct pinctrl_setting const *setting)
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 
-	ops->disable(pctldev, setting->func_selector, setting->group_selector);
+	ops->disable(pctldev, setting->data.mux.func, setting->data.mux.group);
 }
 
 #ifdef CONFIG_DEBUG_FS
@@ -456,18 +466,25 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	return 0;
 }
 
-void pinmux_dbg_show(struct seq_file *s, struct pinctrl_setting const *setting)
+void pinmux_show_map(struct seq_file *s, struct pinctrl_map const *map)
+{
+	seq_printf(s, "group %s\nfunction %s\n",
+		map->data.mux.group ? map->data.mux.group : "(default)",
+		map->data.mux.function);
+}
+
+void pinmux_show_setting(struct seq_file *s,
+			 struct pinctrl_setting const *setting)
 {
 	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
 
-	seq_printf(s, "controller: %s group: %s (%u) function: %s (%u)\n",
-		   pinctrl_dev_get_name(pctldev),
-		   pctlops->get_group_name(pctldev, setting->group_selector),
-		   setting->group_selector,
-		   pmxops->get_function_name(pctldev, setting->func_selector),
-		   setting->func_selector);
+	seq_printf(s, "group: %s (%u) function: %s (%u)\n",
+		   pctlops->get_group_name(pctldev, setting->data.mux.group),
+		   setting->data.mux.group,
+		   pmxops->get_function_name(pctldev, setting->data.mux.func),
+		   setting->data.mux.func);
 }
 
 static int pinmux_functions_open(struct inode *inode, struct file *file)

commit 0e3db173e2b9fd3b82246516e72c17763eb5f98d
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:46 2012 -0700

    pinctrl: add usecount to pins for muxing
    
    Multiple mapping table entries could reference the same pin, and hence
    "own" it. This would be unusual now that pinctrl_get() represents a single
    state for a client device, but in the future when it represents all known
    states for a device, this is quite likely. Implement reference counting
    for pin ownership to handle this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index f0fb98d252e8..56ca42e6a6ec 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -83,11 +83,16 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		goto out;
 	}
 
-	if (desc->owner && strcmp(desc->owner, owner)) {
+	if (desc->usecount && strcmp(desc->owner, owner)) {
 		dev_err(pctldev->dev,
 			"pin already requested\n");
 		goto out;
 	}
+
+	desc->usecount++;
+	if (desc->usecount > 1)
+		return 0;
+
 	desc->owner = owner;
 
 	/* Let each pin increase references to this module */
@@ -111,12 +116,18 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	else
 		status = 0;
 
-	if (status)
+	if (status) {
 		dev_err(pctldev->dev, "->request on device %s failed for pin %d\n",
 		       pctldev->desc->name, pin);
+		module_put(pctldev->owner);
+	}
+
 out_free_pin:
-	if (status)
-		desc->owner = NULL;
+	if (status) {
+		desc->usecount--;
+		if (!desc->usecount)
+			desc->owner = NULL;
+	}
 out:
 	if (status)
 		dev_err(pctldev->dev, "pin-%d (%s) status %d\n",
@@ -150,6 +161,10 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 		return NULL;
 	}
 
+	desc->usecount--;
+	if (desc->usecount)
+		return NULL;
+
 	/*
 	 * If there is no kind of request function for the pin we just assume
 	 * we got it by default and proceed.

commit 7ecdb16fe63e5b356335ebdc236adfb48cef31e1
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:45 2012 -0700

    pinctrl: refactor struct pinctrl handling in core.c vs pinmux.c
    
    This change separates two aspects of struct pinctrl:
    
    a) The data representation of the parsed mapping table, into:
    
       1) The top-level struct pinctrl object, a single entity returned
          by pinctrl_get().
    
       2) The parsed version of each mapping table entry, struct
          pinctrl_setting, of which there is one per mapping table entry.
    
    b) The code that handles this; the code for (1) above is in core.c, and
       the code to parse/execute each entry in (2) above is in pinmux.c, while
       the iteration over multiple settings is lifted to core.c.
    
    This will allow the following future changes:
    
    1) pinctrl_get() API rework, so that struct pinctrl represents all states
       for the device, and the device can select between them without calling
       put()/get() again.
    
    2) To support that, a struct pinctrl_state object will be inserted into
       the data model between the struct pinctrl and struct pinctrl_setting.
    
    3) The mapping table will be extended to allow specification of pin config
       settings too. To support this, struct pinctrl_setting will be enhanced
       to store either mux settings or config settings, and functions will be
       added to pinconf.c to parse/execute pin configuration settings.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 7342c26f4246..f0fb98d252e8 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -7,6 +7,8 @@
  *
  * Author: Linus Walleij <linus.walleij@linaro.org>
  *
+ * Copyright (C) 2012 NVIDIA CORPORATION. All rights reserved.
+ *
  * License terms: GNU General Public License (GPL) version 2
  */
 #define pr_fmt(fmt) "pinmux core: " fmt
@@ -28,19 +30,6 @@
 #include "core.h"
 #include "pinmux.h"
 
-/**
- * struct pinmux_group - group list item for pinmux groups
- * @node: pinmux group list node
- * @func_selector: the function selector for the pinmux device handling
- *	this pinmux
- * @group_selector: the group selector for this group
- */
-struct pinmux_group {
-	struct list_head node;
-	unsigned func_selector;
-	unsigned group_selector;
-};
-
 int pinmux_check_ops(struct pinctrl_dev *pctldev)
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
@@ -244,164 +233,8 @@ int pinmux_gpio_direction(struct pinctrl_dev *pctldev,
 	return ret;
 }
 
-/**
- * acquire_pins() - acquire all the pins for a certain function on a pinmux
- * @pctldev: the device to take the pins on
- * @owner: a representation of the owner of this pin; typically the device
- *	name that controls its mux function
- * @group_selector: the group selector containing the pins to acquire
- */
-static int acquire_pins(struct pinctrl_dev *pctldev,
-			const char *owner,
-			unsigned group_selector)
-{
-	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	const unsigned *pins;
-	unsigned num_pins;
-	int ret;
-	int i;
-
-	ret = pctlops->get_group_pins(pctldev, group_selector,
-				      &pins, &num_pins);
-	if (ret)
-		return ret;
-
-	dev_dbg(pctldev->dev, "requesting the %u pins from group %u\n",
-		num_pins, group_selector);
-
-	/* Try to allocate all pins in this group, one by one */
-	for (i = 0; i < num_pins; i++) {
-		ret = pin_request(pctldev, pins[i], owner, NULL);
-		if (ret) {
-			dev_err(pctldev->dev,
-				"could not get request pin %d on device %s - conflicting mux mappings?\n",
-				pins[i],
-				pinctrl_dev_get_name(pctldev));
-			/* On error release all taken pins */
-			i--; /* this pin just failed */
-			for (; i >= 0; i--)
-				pin_free(pctldev, pins[i], NULL);
-			return -ENODEV;
-		}
-	}
-	return 0;
-}
-
-/**
- * release_pins() - release pins taken by earlier acquirement
- * @pctldev: the device to free the pins on
- * @group_selector: the group selector containing the pins to free
- */
-static void release_pins(struct pinctrl_dev *pctldev,
-			 unsigned group_selector)
-{
-	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	const unsigned *pins;
-	unsigned num_pins;
-	int ret;
-	int i;
-
-	ret = pctlops->get_group_pins(pctldev, group_selector,
-				      &pins, &num_pins);
-	if (ret) {
-		dev_err(pctldev->dev, "could not get pins to release for group selector %d\n",
-			group_selector);
-		return;
-	}
-	for (i = 0; i < num_pins; i++)
-		pin_free(pctldev, pins[i], NULL);
-}
-
-/**
- * pinmux_check_pin_group() - check function and pin group combo
- * @pctldev: device to check the pin group vs function for
- * @func_selector: the function selector to check the pin group for, we have
- *	already looked this up in the calling function
- * @pin_group: the pin group to match to the function
- *
- * This function will check that the pinmux driver can supply the
- * selected pin group for a certain function, returns the group selector if
- * the group and function selector will work fine together, else returns
- * negative
- */
-static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
-				  unsigned func_selector,
-				  const char *pin_group)
-{
-	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
-	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	int ret;
-
-	/*
-	 * If the driver does not support different pin groups for the
-	 * functions, we only support group 0, and assume this exists.
-	 */
-	if (!pctlops || !pctlops->list_groups)
-		return 0;
-
-	/*
-	 * Passing NULL (no specific group) will select the first and
-	 * hopefully only group of pins available for this function.
-	 */
-	if (!pin_group) {
-		char const * const *groups;
-		unsigned num_groups;
-
-		ret = pmxops->get_function_groups(pctldev, func_selector,
-						  &groups, &num_groups);
-		if (ret)
-			return ret;
-		if (num_groups < 1)
-			return -EINVAL;
-		ret = pinctrl_get_group_selector(pctldev, groups[0]);
-		if (ret < 0) {
-			dev_err(pctldev->dev,
-				"function %s wants group %s but the pin controller does not seem to have that group\n",
-				pmxops->get_function_name(pctldev, func_selector),
-				groups[0]);
-			return ret;
-		}
-
-		if (num_groups > 1)
-			dev_dbg(pctldev->dev,
-				"function %s support more than one group, default-selecting first group %s (%d)\n",
-				pmxops->get_function_name(pctldev, func_selector),
-				groups[0],
-				ret);
-
-		return ret;
-	}
-
-	dev_dbg(pctldev->dev,
-		"check if we have pin group %s on controller %s\n",
-		pin_group, pinctrl_dev_get_name(pctldev));
-
-	ret = pinctrl_get_group_selector(pctldev, pin_group);
-	if (ret < 0) {
-		dev_dbg(pctldev->dev,
-			"%s does not support pin group %s with function %s\n",
-			pinctrl_dev_get_name(pctldev),
-			pin_group,
-			pmxops->get_function_name(pctldev, func_selector));
-	}
-	return ret;
-}
-
-/**
- * pinmux_search_function() - check pin control driver for a certain function
- * @pctldev: device to check for function and position
- * @map: function map containing the function and position to look for
- * @func_selector: returns the applicable function selector if found
- * @group_selector: returns the applicable group selector if found
- *
- * This will search the pinmux driver for an applicable
- * function with a specific pin group, returns 0 if these can be mapped
- * negative otherwise
- */
-static int pinmux_search_function(struct pinctrl_dev *pctldev,
-				  struct pinctrl_map const *map,
-				  unsigned *func_selector,
-				  unsigned *group_selector)
+static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,
+					const char *function)
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	unsigned selector = 0;
@@ -410,155 +243,128 @@ static int pinmux_search_function(struct pinctrl_dev *pctldev,
 	while (ops->list_functions(pctldev, selector) >= 0) {
 		const char *fname = ops->get_function_name(pctldev,
 							   selector);
-		int ret;
 
-		if (!strcmp(map->function, fname)) {
-			/* Found the function, check pin group */
-			ret = pinmux_check_pin_group(pctldev, selector,
-						     map->group);
-			if (ret < 0)
-				return ret;
+		if (!strcmp(function, fname))
+			return selector;
 
-			/* This function and group selector can be used */
-			*func_selector = selector;
-			*group_selector = ret;
-			return 0;
-
-		}
 		selector++;
 	}
 
 	pr_err("%s does not support function %s\n",
-	       pinctrl_dev_get_name(pctldev), map->function);
+	       pinctrl_dev_get_name(pctldev), function);
 	return -EINVAL;
 }
 
-/**
- * pinmux_enable_muxmap() - enable a map entry for a certain pinmux
- */
-static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
-				struct pinctrl *p,
-				struct device *dev,
-				const char *devname,
-				struct pinctrl_map const *map)
+int pinmux_map_to_setting(struct pinctrl_map const *map,
+			  struct pinctrl_setting *setting)
 {
-	unsigned func_selector;
-	unsigned group_selector;
-	struct pinmux_group *grp;
+	struct pinctrl_dev *pctldev = setting->pctldev;
+	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+	char const * const *groups;
+	unsigned num_groups;
 	int ret;
+	const char *group;
+	int i;
+	const unsigned *pins;
+	unsigned num_pins;
 
-	/*
-	 * Note that we're not locking the pinmux mutex here, because
-	 * this is only called at pinmux initialization time when it
-	 * has not been added to any list and thus is not reachable
-	 * by anyone else.
-	 */
+	setting->func_selector =
+		pinmux_func_name_to_selector(pctldev, map->function);
+	if (setting->func_selector < 0)
+		return setting->func_selector;
 
-	if (p->pctldev && p->pctldev != pctldev) {
-		dev_err(pctldev->dev,
-			"different pin control devices given for device %s, function %s\n",
-			devname, map->function);
+	ret = pmxops->get_function_groups(pctldev, setting->func_selector,
+					  &groups, &num_groups);
+	if (ret < 0)
+		return ret;
+	if (!num_groups)
 		return -EINVAL;
+
+	if (map->group) {
+		bool found = false;
+		group = map->group;
+		for (i = 0; i < num_groups; i++) {
+			if (!strcmp(group, groups[i])) {
+				found = true;
+				break;
+			}
+		}
+		if (!found)
+			return -EINVAL;
+	} else {
+		group = groups[0];
 	}
-	p->dev = dev;
-	p->pctldev = pctldev;
 
-	/* Now go into the driver and try to match a function and group */
-	ret = pinmux_search_function(pctldev, map, &func_selector,
-				     &group_selector);
-	if (ret < 0)
-		return ret;
+	setting->group_selector =
+		pinctrl_get_group_selector(pctldev, group);
+	if (setting->group_selector < 0)
+		return setting->group_selector;
 
-	/* Now add this group selector, we may have many of them */
-	grp = kmalloc(sizeof(*grp), GFP_KERNEL);
-	if (!grp)
-		return -ENOMEM;
-	grp->func_selector = func_selector;
-	grp->group_selector = group_selector;
-	ret = acquire_pins(pctldev, devname, group_selector);
+	ret = pctlops->get_group_pins(pctldev, setting->group_selector,
+				      &pins, &num_pins);
 	if (ret) {
-		kfree(grp);
-		return ret;
+		dev_err(pctldev->dev,
+			"could not get pins for device %s group selector %d\n",
+			pinctrl_dev_get_name(pctldev), setting->group_selector);
+			return -ENODEV;
+	}
+
+	/* Try to allocate all pins in this group, one by one */
+	for (i = 0; i < num_pins; i++) {
+		ret = pin_request(pctldev, pins[i], map->dev_name, NULL);
+		if (ret) {
+			dev_err(pctldev->dev,
+				"could not get request pin %d on device %s\n",
+				pins[i], pinctrl_dev_get_name(pctldev));
+			/* On error release all taken pins */
+			i--; /* this pin just failed */
+			for (; i >= 0; i--)
+				pin_free(pctldev, pins[i], NULL);
+			return -ENODEV;
+		}
 	}
-	list_add_tail(&grp->node, &p->groups);
 
 	return 0;
 }
 
-/**
- * pinmux_apply_muxmap() - apply a certain mux mapping entry
- */
-int pinmux_apply_muxmap(struct pinctrl_dev *pctldev,
-			struct pinctrl *p,
-			struct device *dev,
-			const char *devname,
-			struct pinctrl_map const *map)
+void pinmux_free_setting(struct pinctrl_setting const *setting)
 {
+	struct pinctrl_dev *pctldev = setting->pctldev;
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+	const unsigned *pins;
+	unsigned num_pins;
 	int ret;
+	int i;
 
-	ret = pinmux_enable_muxmap(pctldev, p, dev,
-				   devname, map);
+	ret = pctlops->get_group_pins(pctldev, setting->group_selector,
+				      &pins, &num_pins);
 	if (ret) {
-		pinmux_put(p);
-		return ret;
+		dev_err(pctldev->dev,
+			"could not get pins for device %s group selector %d\n",
+			pinctrl_dev_get_name(pctldev), setting->group_selector);
+		return;
 	}
 
-	return 0;
-}
-
-/**
- * pinmux_put() - free up the pinmux portions of a pin controller handle
- */
-void pinmux_put(struct pinctrl *p)
-{
-	struct list_head *node, *tmp;
-
-	list_for_each_safe(node, tmp, &p->groups) {
-		struct pinmux_group *grp =
-			list_entry(node, struct pinmux_group, node);
-		/* Release all pins taken by this group */
-		release_pins(p->pctldev, grp->group_selector);
-		list_del(node);
-		kfree(grp);
-	}
+	for (i = 0; i < num_pins; i++)
+		pin_free(pctldev, pins[i], NULL);
 }
 
-/**
- * pinmux_enable() - enable the pinmux portion of a pin control handle
- */
-int pinmux_enable(struct pinctrl *p)
+int pinmux_enable_setting(struct pinctrl_setting const *setting)
 {
-	struct pinctrl_dev *pctldev = p->pctldev;
+	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
-	struct pinmux_group *grp;
-	int ret;
 
-	list_for_each_entry(grp, &p->groups, node) {
-		ret = ops->enable(pctldev, grp->func_selector,
-				  grp->group_selector);
-		if (ret)
-			/*
-			 * TODO: call disable() on all groups we called
-			 * enable() on to this point?
-			 */
-			return ret;
-	}
-	return 0;
+	return ops->enable(pctldev, setting->func_selector,
+			   setting->group_selector);
 }
 
-/**
- * pinmux_disable() - disable the pinmux portions of a pin control handle
- */
-void pinmux_disable(struct pinctrl *p)
+void pinmux_disable_setting(struct pinctrl_setting const *setting)
 {
-	struct pinctrl_dev *pctldev = p->pctldev;
+	struct pinctrl_dev *pctldev = setting->pctldev;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
-	struct pinmux_group *grp;
 
-	list_for_each_entry(grp, &p->groups, node) {
-		ops->disable(pctldev, grp->func_selector,
-			     grp->group_selector);
-	}
+	ops->disable(pctldev, setting->func_selector, setting->group_selector);
 }
 
 #ifdef CONFIG_DEBUG_FS
@@ -635,30 +441,18 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	return 0;
 }
 
-void pinmux_dbg_show(struct seq_file *s, struct pinctrl *p)
+void pinmux_dbg_show(struct seq_file *s, struct pinctrl_setting const *setting)
 {
-	struct pinctrl_dev *pctldev = p->pctldev;
-	const struct pinmux_ops *pmxops;
-	const struct pinctrl_ops *pctlops;
-	struct pinmux_group *grp;
-	const char *sep = "";
-
-	pmxops = pctldev->desc->pmxops;
-	pctlops = pctldev->desc->pctlops;
-
-	seq_printf(s, " groups: [");
-	list_for_each_entry(grp, &p->groups, node) {
-		seq_printf(s, "%s%s (%u)=%s (%u)",
-			   sep,
-			   pctlops->get_group_name(pctldev,
-						   grp->group_selector),
-			   grp->group_selector,
-			   pmxops->get_function_name(pctldev,
-						     grp->func_selector),
-			   grp->func_selector);
-		sep = ", ";
-	}
-	seq_printf(s, " ]");
+	struct pinctrl_dev *pctldev = setting->pctldev;
+	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+
+	seq_printf(s, "controller: %s group: %s (%u) function: %s (%u)\n",
+		   pinctrl_dev_get_name(pctldev),
+		   pctlops->get_group_name(pctldev, setting->group_selector),
+		   setting->group_selector,
+		   pmxops->get_function_name(pctldev, setting->func_selector),
+		   setting->func_selector);
 }
 
 static int pinmux_functions_open(struct inode *inode, struct file *file)

commit 57b676f9c1b7cd84397fe5a86c9bd2788ac4bd32
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:44 2012 -0700

    pinctrl: fix and simplify locking
    
    There are many problems with the current pinctrl locking:
    
    struct pinctrl_dev's gpio_ranges_lock isn't effective;
    pinctrl_match_gpio_range() only holds this lock while searching for a gpio
    range, but the found range is return and manipulated after releading the
    lock. This could allow pinctrl_remove_gpio_range() for that range while it
    is in use, and the caller may very well delete the range after removing it,
    causing pinctrl code to touch the now-free range object.
    
    Solving this requires the introduction of a higher-level lock, at least
    a lock per pin controller, which both gpio range registration and
    pinctrl_get()/put() will acquire.
    
    There is missing locking on HW programming; pin controllers may pack the
    configuration for different pins/groups/config options/... into one
    register, and hence have to read-modify-write the register. This needs to
    be protected, but currently isn't. Related, a future change will add a
    "complete" op to the pin controller drivers, the idea being that each
    state's programming will be programmed into the pinctrl driver followed
    by the "complete" call, which may e.g. flush a register cache to HW. For
    this to work, it must not be possible to interleave the pinctrl driver
    calls for different devices.
    
    As above, solving this requires the introduction of a higher-level lock,
    at least a lock per pin controller, which will be held for the duration
    of any pinctrl_enable()/disable() call.
    
    However, each pinctrl mapping table entry may affect a different pin
    controller if necessary. Hence, with a per-pin-controller lock, almost
    any pinctrl API may need to acquire multiple locks, one per controller.
    To avoid deadlock, these would need to be acquired in the same order in
    all cases. This is extremely difficult to implement in the case of
    pinctrl_get(), which doesn't know which pin controllers to lock until it
    has parsed the entire mapping table, since it contains somewhat arbitrary
    data.
    
    The simplest solution here is to introduce a single lock that covers all
    pin controllers at once. This will be acquired by all pinctrl APIs.
    
    This then makes struct pinctrl's mutex irrelevant, since that single lock
    will always be held whenever this mutex is currently held.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index f409f161ea1d..7342c26f4246 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -19,8 +19,6 @@
 #include <linux/radix-tree.h>
 #include <linux/err.h>
 #include <linux/list.h>
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/sysfs.h>
 #include <linux/debugfs.h>
@@ -96,15 +94,12 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		goto out;
 	}
 
-	spin_lock(&desc->lock);
 	if (desc->owner && strcmp(desc->owner, owner)) {
-		spin_unlock(&desc->lock);
 		dev_err(pctldev->dev,
 			"pin already requested\n");
 		goto out;
 	}
 	desc->owner = owner;
-	spin_unlock(&desc->lock);
 
 	/* Let each pin increase references to this module */
 	if (!try_module_get(pctldev->owner)) {
@@ -131,11 +126,8 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		dev_err(pctldev->dev, "->request on device %s failed for pin %d\n",
 		       pctldev->desc->name, pin);
 out_free_pin:
-	if (status) {
-		spin_lock(&desc->lock);
+	if (status)
 		desc->owner = NULL;
-		spin_unlock(&desc->lock);
-	}
 out:
 	if (status)
 		dev_err(pctldev->dev, "pin-%d (%s) status %d\n",
@@ -178,10 +170,8 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 	else if (ops->free)
 		ops->free(pctldev, pin);
 
-	spin_lock(&desc->lock);
 	owner = desc->owner;
 	desc->owner = NULL;
-	spin_unlock(&desc->lock);
 	module_put(pctldev->owner);
 
 	return owner;
@@ -580,6 +570,8 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
 	unsigned func_selector = 0;
 
+	mutex_lock(&pinctrl_mutex);
+
 	while (pmxops->list_functions(pctldev, func_selector) >= 0) {
 		const char *func = pmxops->get_function_name(pctldev,
 							  func_selector);
@@ -600,9 +592,10 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 		seq_puts(s, "]\n");
 
 		func_selector++;
-
 	}
 
+	mutex_unlock(&pinctrl_mutex);
+
 	return 0;
 }
 
@@ -614,6 +607,8 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	seq_puts(s, "Pinmux settings per pin\n");
 	seq_puts(s, "Format: pin (name): owner\n");
 
+	mutex_lock(&pinctrl_mutex);
+
 	/* The pin number can be retrived from the pin controller descriptor */
 	for (i = 0; i < pctldev->desc->npins; i++) {
 		struct pin_desc *desc;
@@ -635,6 +630,8 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 			   is_hog ? " (HOG)" : "");
 	}
 
+	mutex_unlock(&pinctrl_mutex);
+
 	return 0;
 }
 

commit d4e3198736d9d64e4ba4d2b46ab75cbcf5d0a4e0
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Mar 1 18:48:31 2012 -0700

    pinctrl: enhance pinctrl_get() to handle multiple functions
    
    At present, pinctrl_get() assumes that all matching mapping table entries
    have the same "function" value, albeit potentially applied to different
    pins/groups.
    
    This change removes this restriction; pinctrl_get() can now handle a set
    of mapping tables where different functions are applied to the various
    pins/groups.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 2a405618b448..f409f161ea1d 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -33,10 +33,13 @@
 /**
  * struct pinmux_group - group list item for pinmux groups
  * @node: pinmux group list node
+ * @func_selector: the function selector for the pinmux device handling
+ *	this pinmux
  * @group_selector: the group selector for this group
  */
 struct pinmux_group {
 	struct list_head node;
+	unsigned func_selector;
 	unsigned group_selector;
 };
 
@@ -476,24 +479,11 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	if (ret < 0)
 		return ret;
 
-	/*
-	 * If the function selector is already set, it needs to be identical,
-	 * we support several groups with one function but not several
-	 * functions with one or several groups in the same pinmux.
-	 */
-	if (p->func_selector != UINT_MAX &&
-	    p->func_selector != func_selector) {
-		dev_err(pctldev->dev,
-			"dual function defines in the map for device %s\n",
-		       devname);
-		return -EINVAL;
-	}
-	p->func_selector = func_selector;
-
 	/* Now add this group selector, we may have many of them */
 	grp = kmalloc(sizeof(*grp), GFP_KERNEL);
 	if (!grp)
 		return -ENOMEM;
+	grp->func_selector = func_selector;
 	grp->group_selector = group_selector;
 	ret = acquire_pins(pctldev, devname, group_selector);
 	if (ret) {
@@ -554,7 +544,7 @@ int pinmux_enable(struct pinctrl *p)
 	int ret;
 
 	list_for_each_entry(grp, &p->groups, node) {
-		ret = ops->enable(pctldev, p->func_selector,
+		ret = ops->enable(pctldev, grp->func_selector,
 				  grp->group_selector);
 		if (ret)
 			/*
@@ -576,7 +566,7 @@ void pinmux_disable(struct pinctrl *p)
 	struct pinmux_group *grp;
 
 	list_for_each_entry(grp, &p->groups, node) {
-		ops->disable(pctldev, p->func_selector,
+		ops->disable(pctldev, grp->func_selector,
 			     grp->group_selector);
 	}
 }
@@ -654,21 +644,22 @@ void pinmux_dbg_show(struct seq_file *s, struct pinctrl *p)
 	const struct pinmux_ops *pmxops;
 	const struct pinctrl_ops *pctlops;
 	struct pinmux_group *grp;
+	const char *sep = "";
 
 	pmxops = pctldev->desc->pmxops;
 	pctlops = pctldev->desc->pctlops;
 
-	seq_printf(s, " function: %s (%u),",
-		   pmxops->get_function_name(pctldev,
-					     p->func_selector),
-		   p->func_selector);
-
 	seq_printf(s, " groups: [");
 	list_for_each_entry(grp, &p->groups, node) {
-		seq_printf(s, " %s (%u)",
+		seq_printf(s, "%s%s (%u)=%s (%u)",
+			   sep,
 			   pctlops->get_group_name(pctldev,
 						   grp->group_selector),
-			   grp->group_selector);
+			   grp->group_selector,
+			   pmxops->get_function_name(pctldev,
+						     grp->func_selector),
+			   grp->func_selector);
+		sep = ", ";
 	}
 	seq_printf(s, " ]");
 }

commit 1cf94c45ca31c0ad563e72b095782346cba26b6c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 24 06:53:04 2012 +0100

    pinctrl: make the pinmux-pins more helpful
    
    The debugfs file pinmux-pins used to tell which function was
    enabled but now states simply which device owns the pin. Being
    owned by the pinctrl driver itself means just that it's hogged
    so be a bit more helpful by printing that.
    
    ChangeLog v1->v2:
    - Preserve the self-referential owner field, just clarify that
      when the pin controller states itself as owner this means
      that it's hogged.
    
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 98b89d6cffb0..2a405618b448 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -626,8 +626,8 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 
 	/* The pin number can be retrived from the pin controller descriptor */
 	for (i = 0; i < pctldev->desc->npins; i++) {
-
 		struct pin_desc *desc;
+		bool is_hog = false;
 
 		pin = pctldev->desc->pins[i].number;
 		desc = pin_desc_get(pctldev, pin);
@@ -635,9 +635,14 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 		if (desc == NULL)
 			continue;
 
-		seq_printf(s, "pin %d (%s): %s\n", pin,
+		if (desc->owner &&
+		    !strcmp(desc->owner, pinctrl_dev_get_name(pctldev)))
+			is_hog = true;
+
+		seq_printf(s, "pin %d (%s): %s%s\n", pin,
 			   desc->name ? desc->name : "unnamed",
-			   desc->owner ? desc->owner : "UNCLAIMED");
+			   desc->owner ? desc->owner : "UNCLAIMED",
+			   is_hog ? " (HOG)" : "");
 	}
 
 	return 0;

commit 02f5b98951c631a3c4b3cc398dd2b14d274a6155
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Feb 22 14:26:00 2012 -0700

    pinctrl: allocate sizeof(*p) instead of sizeof(struct foo)
    
    This hopefully makes it harder to take the sizeof the wrong type.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 288789750f96..98b89d6cffb0 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -491,7 +491,7 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	p->func_selector = func_selector;
 
 	/* Now add this group selector, we may have many of them */
-	grp = kmalloc(sizeof(struct pinmux_group), GFP_KERNEL);
+	grp = kmalloc(sizeof(*grp), GFP_KERNEL);
 	if (!grp)
 		return -ENOMEM;
 	grp->group_selector = group_selector;

commit 3cc70ed32cd6c5cb57de17bde615148ed7eda88f
Author: Stephen Warren <swarren@nvidia.com>
Date:   Sun Feb 19 23:45:44 2012 -0700

    pinctrl: record a pin owner, not mux function, when requesting pins
    
    When pins are requested/acquired/got, some device becomes the owner of
    their mux setting. At this point, it isn't certain which mux function
    will be selected for the pin, since this may vary between each of the
    device's states in the pinctrl mapping table. As such, we should record
    the owning device, not what we think the initial mux setting will be,
    when requesting pins.
    
    This doesn't make a lot of difference right now since pinctrl_get gets
    only one single device/state combination, but this will make a difference
    when pinctrl_get gets all states, and pinctrl_select_state can switch
    between states.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index ea31c4655667..288789750f96 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -71,21 +71,20 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 /**
  * pin_request() - request a single pin to be muxed in, typically for GPIO
  * @pin: the pin number in the global pin space
- * @function: a functional name to give to this pin, passed to the driver
- *	so it knows what function to mux in, e.g. the string "gpioNN"
- *	means that you want to mux in the pin for use as GPIO number NN
+ * @owner: a representation of the owner of this pin; typically the device
+ *	name that controls its mux function, or the requested GPIO name
  * @gpio_range: the range matching the GPIO pin if this is a request for a
  *	single GPIO pin
  */
 static int pin_request(struct pinctrl_dev *pctldev,
-		       int pin, const char *function,
+		       int pin, const char *owner,
 		       struct pinctrl_gpio_range *gpio_range)
 {
 	struct pin_desc *desc;
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	int status = -EINVAL;
 
-	dev_dbg(pctldev->dev, "request pin %d for %s\n", pin, function);
+	dev_dbg(pctldev->dev, "request pin %d for %s\n", pin, owner);
 
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
@@ -94,19 +93,14 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		goto out;
 	}
 
-	if (!function) {
-		dev_err(pctldev->dev, "no function name given\n");
-		return -EINVAL;
-	}
-
 	spin_lock(&desc->lock);
-	if (desc->mux_function) {
+	if (desc->owner && strcmp(desc->owner, owner)) {
 		spin_unlock(&desc->lock);
 		dev_err(pctldev->dev,
 			"pin already requested\n");
 		goto out;
 	}
-	desc->mux_function = function;
+	desc->owner = owner;
 	spin_unlock(&desc->lock);
 
 	/* Let each pin increase references to this module */
@@ -136,13 +130,13 @@ static int pin_request(struct pinctrl_dev *pctldev,
 out_free_pin:
 	if (status) {
 		spin_lock(&desc->lock);
-		desc->mux_function = NULL;
+		desc->owner = NULL;
 		spin_unlock(&desc->lock);
 	}
 out:
 	if (status)
 		dev_err(pctldev->dev, "pin-%d (%s) status %d\n",
-		       pin, function ? : "?", status);
+		       pin, owner, status);
 
 	return status;
 }
@@ -154,8 +148,8 @@ static int pin_request(struct pinctrl_dev *pctldev,
  * @gpio_range: the range matching the GPIO pin if this is a request for a
  *	single GPIO pin
  *
- * This function returns a pointer to the function name in use. This is used
- * for callers that dynamically allocate a function name so it can be freed
+ * This function returns a pointer to the previous owner. This is used
+ * for callers that dynamically allocate an owner name so it can be freed
  * once the pin is free. This is done for GPIO request functions.
  */
 static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
@@ -163,7 +157,7 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	struct pin_desc *desc;
-	const char *func;
+	const char *owner;
 
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
@@ -182,12 +176,12 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 		ops->free(pctldev, pin);
 
 	spin_lock(&desc->lock);
-	func = desc->mux_function;
-	desc->mux_function = NULL;
+	owner = desc->owner;
+	desc->owner = NULL;
 	spin_unlock(&desc->lock);
 	module_put(pctldev->owner);
 
-	return func;
+	return owner;
 }
 
 /**
@@ -201,19 +195,19 @@ int pinmux_request_gpio(struct pinctrl_dev *pctldev,
 			unsigned pin, unsigned gpio)
 {
 	char gpiostr[16];
-	const char *function;
+	const char *owner;
 	int ret;
 
 	/* Conjure some name stating what chip and pin this is taken by */
 	snprintf(gpiostr, 15, "%s:%d", range->name, gpio);
 
-	function = kstrdup(gpiostr, GFP_KERNEL);
-	if (!function)
+	owner = kstrdup(gpiostr, GFP_KERNEL);
+	if (!owner)
 		return -EINVAL;
 
-	ret = pin_request(pctldev, pin, function, range);
+	ret = pin_request(pctldev, pin, owner, range);
 	if (ret < 0)
-		kfree(function);
+		kfree(owner);
 
 	return ret;
 }
@@ -227,10 +221,10 @@ int pinmux_request_gpio(struct pinctrl_dev *pctldev,
 void pinmux_free_gpio(struct pinctrl_dev *pctldev, unsigned pin,
 		      struct pinctrl_gpio_range *range)
 {
-	const char *func;
+	const char *owner;
 
-	func = pin_free(pctldev, pin, range);
-	kfree(func);
+	owner = pin_free(pctldev, pin, range);
+	kfree(owner);
 }
 
 /**
@@ -260,17 +254,15 @@ int pinmux_gpio_direction(struct pinctrl_dev *pctldev,
 /**
  * acquire_pins() - acquire all the pins for a certain function on a pinmux
  * @pctldev: the device to take the pins on
- * @func_selector: the function selector to acquire the pins for
+ * @owner: a representation of the owner of this pin; typically the device
+ *	name that controls its mux function
  * @group_selector: the group selector containing the pins to acquire
  */
 static int acquire_pins(struct pinctrl_dev *pctldev,
-			unsigned func_selector,
+			const char *owner,
 			unsigned group_selector)
 {
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
-	const char *func = pmxops->get_function_name(pctldev,
-						     func_selector);
 	const unsigned *pins;
 	unsigned num_pins;
 	int ret;
@@ -286,11 +278,11 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 
 	/* Try to allocate all pins in this group, one by one */
 	for (i = 0; i < num_pins; i++) {
-		ret = pin_request(pctldev, pins[i], func, NULL);
+		ret = pin_request(pctldev, pins[i], owner, NULL);
 		if (ret) {
 			dev_err(pctldev->dev,
-				"could not get pin %d for function %s on device %s - conflicting mux mappings?\n",
-				pins[i], func ? : "(undefined)",
+				"could not get request pin %d on device %s - conflicting mux mappings?\n",
+				pins[i],
 				pinctrl_dev_get_name(pctldev));
 			/* On error release all taken pins */
 			i--; /* this pin just failed */
@@ -503,7 +495,7 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	if (!grp)
 		return -ENOMEM;
 	grp->group_selector = group_selector;
-	ret = acquire_pins(pctldev, func_selector, group_selector);
+	ret = acquire_pins(pctldev, devname, group_selector);
 	if (ret) {
 		kfree(grp);
 		return ret;
@@ -630,7 +622,7 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	unsigned i, pin;
 
 	seq_puts(s, "Pinmux settings per pin\n");
-	seq_puts(s, "Format: pin (name): pinmuxfunction\n");
+	seq_puts(s, "Format: pin (name): owner\n");
 
 	/* The pin number can be retrived from the pin controller descriptor */
 	for (i = 0; i < pctldev->desc->npins; i++) {
@@ -645,8 +637,7 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 
 		seq_printf(s, "pin %d (%s): %s\n", pin,
 			   desc->name ? desc->name : "unnamed",
-			   desc->mux_function ? desc->mux_function
-					      : "UNCLAIMED");
+			   desc->owner ? desc->owner : "UNCLAIMED");
 	}
 
 	return 0;

commit 03665e0f248d6b7542f72cd7c4ec521109f283c7
Author: Stephen Warren <swarren@nvidia.com>
Date:   Sun Feb 19 23:45:45 2012 -0700

    pinctrl: Re-order pinmux.[ch] to match each-other
    
    Modify the two files so that the order of function prototypes in the
    header matches the order of implementations in the .c file.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 5a09cd202208..ea31c4655667 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -40,6 +40,34 @@ struct pinmux_group {
 	unsigned group_selector;
 };
 
+int pinmux_check_ops(struct pinctrl_dev *pctldev)
+{
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	unsigned selector = 0;
+
+	/* Check that we implement required operations */
+	if (!ops->list_functions ||
+	    !ops->get_function_name ||
+	    !ops->get_function_groups ||
+	    !ops->enable ||
+	    !ops->disable)
+		return -EINVAL;
+
+	/* Check that all functions registered have names */
+	while (ops->list_functions(pctldev, selector) >= 0) {
+		const char *fname = ops->get_function_name(pctldev,
+							   selector);
+		if (!fname) {
+			pr_err("pinmux ops has no name for function%u\n",
+				selector);
+			return -EINVAL;
+		}
+		selector++;
+	}
+
+	return 0;
+}
+
 /**
  * pin_request() - request a single pin to be muxed in, typically for GPIO
  * @pin: the pin number in the global pin space
@@ -561,34 +589,6 @@ void pinmux_disable(struct pinctrl *p)
 	}
 }
 
-int pinmux_check_ops(struct pinctrl_dev *pctldev)
-{
-	const struct pinmux_ops *ops = pctldev->desc->pmxops;
-	unsigned selector = 0;
-
-	/* Check that we implement required operations */
-	if (!ops->list_functions ||
-	    !ops->get_function_name ||
-	    !ops->get_function_groups ||
-	    !ops->enable ||
-	    !ops->disable)
-		return -EINVAL;
-
-	/* Check that all functions registered have names */
-	while (ops->list_functions(pctldev, selector) >= 0) {
-		const char *fname = ops->get_function_name(pctldev,
-							   selector);
-		if (!fname) {
-			pr_err("pinmux ops has no name for function%u\n",
-				selector);
-			return -EINVAL;
-		}
-		selector++;
-	}
-
-	return 0;
-}
-
 #ifdef CONFIG_DEBUG_FS
 
 /* Called from pincontrol core */

commit 8b9c139f166cd55d76728a5910fa862a4e16e833
Author: Stephen Warren <swarren@nvidia.com>
Date:   Sun Feb 19 23:45:42 2012 -0700

    pinctrl: use list_add_tail instead of list_add
    
    This mostly makes debugfs files print things in the order that they
    were added or acquired, which just feels a little more consistent.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index fe4a00751c60..5a09cd202208 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -480,7 +480,7 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 		kfree(grp);
 		return ret;
 	}
-	list_add(&grp->node, &p->groups);
+	list_add_tail(&grp->node, &p->groups);
 
 	return 0;
 }

commit befe5bdfbb698b3bc57c58d0bd7ca3391c9275ed
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 19:47:48 2012 +0100

    pinctrl: factor pin control handles over to the core
    
    This moves the per-devices struct pinctrl handles and device map
    over from the pinmux part of the subsystem to the core pinctrl part.
    This makes the device handles core infrastructure with the goal of
    using these handles also for pin configuration, so that device
    drivers (or boards etc) will need one and only one handle to the
    pin control core.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 773835d18f55..fe4a00751c60 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -28,14 +28,7 @@
 #include <linux/pinctrl/machine.h>
 #include <linux/pinctrl/pinmux.h>
 #include "core.h"
-
-/* List of pin controller handles */
-static DEFINE_MUTEX(pinctrl_list_mutex);
-static LIST_HEAD(pinctrl_list);
-
-/* Global pinctrl maps */
-static struct pinctrl_map *pinctrl_maps;
-static unsigned pinctrl_maps_num;
+#include "pinmux.h"
 
 /**
  * struct pinmux_group - group list item for pinmux groups
@@ -47,43 +40,6 @@ struct pinmux_group {
 	unsigned group_selector;
 };
 
-/**
- * struct pinctrl - per-device pin control state holder
- * @node: global list node
- * @dev: the device using this pin control handle
- * @usecount: the number of active users of this pin controller setting, used
- *	to keep track of nested use cases
- * @pctldev: pin control device handling this pin control handle
- * @func_selector: the function selector for the pinmux device handling
- *	this pinmux
- * @groups: the group selectors for the pinmux device and
- *	selector combination handling this pinmux, this is a list that
- *	will be traversed on all pinmux operations such as
- *	get/put/enable/disable
- * @mutex: a lock for the pinmux state holder
- */
-struct pinctrl {
-	struct list_head node;
-	struct device *dev;
-	unsigned usecount;
-	struct pinctrl_dev *pctldev;
-	unsigned func_selector;
-	struct list_head groups;
-	struct mutex mutex;
-};
-
-/**
- * struct pinctrl_hog - a list item to stash control hogs
- * @node: pin control hog list node
- * @map: map entry responsible for this hogging
- * @pmx: the pin control hogged by this item
- */
-struct pinctrl_hog {
-	struct list_head node;
-	struct pinctrl_map const *map;
-	struct pinctrl *p;
-};
-
 /**
  * pin_request() - request a single pin to be muxed in, typically for GPIO
  * @pin: the pin number in the global pin space
@@ -207,28 +163,18 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 }
 
 /**
- * pinctrl_request_gpio() - request a single pin to be used in as GPIO
- * @gpio: the GPIO pin number from the GPIO subsystem number space
- *
- * This function should *ONLY* be used from gpiolib-based GPIO drivers,
- * as part of their gpio_request() semantics, platforms and individual drivers
- * shall *NOT* request GPIO pins to be muxed in.
+ * pinmux_request_gpio() - request pinmuxing for a GPIO pin
+ * @pctldev: pin controller device affected
+ * @pin: the pin to mux in for GPIO
+ * @range: the applicable GPIO range
  */
-int pinctrl_request_gpio(unsigned gpio)
+int pinmux_request_gpio(struct pinctrl_dev *pctldev,
+			struct pinctrl_gpio_range *range,
+			unsigned pin, unsigned gpio)
 {
 	char gpiostr[16];
 	const char *function;
-	struct pinctrl_dev *pctldev;
-	struct pinctrl_gpio_range *range;
 	int ret;
-	int pin;
-
-	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
-	if (ret)
-		return -EINVAL;
-
-	/* Convert to the pin controllers number space */
-	pin = gpio - range->base + range->pin_base;
 
 	/* Conjure some name stating what chip and pin this is taken by */
 	snprintf(gpiostr, 15, "%s:%d", range->name, gpio);
@@ -243,53 +189,38 @@ int pinctrl_request_gpio(unsigned gpio)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(pinctrl_request_gpio);
 
 /**
- * pinctrl_free_gpio() - free control on a single pin, currently used as GPIO
- * @gpio: the GPIO pin number from the GPIO subsystem number space
- *
- * This function should *ONLY* be used from gpiolib-based GPIO drivers,
- * as part of their gpio_free() semantics, platforms and individual drivers
- * shall *NOT* request GPIO pins to be muxed out.
+ * pinmux_free_gpio() - release a pin from GPIO muxing
+ * @pctldev: the pin controller device for the pin
+ * @pin: the affected currently GPIO-muxed in pin
+ * @range: applicable GPIO range
  */
-void pinctrl_free_gpio(unsigned gpio)
+void pinmux_free_gpio(struct pinctrl_dev *pctldev, unsigned pin,
+		      struct pinctrl_gpio_range *range)
 {
-	struct pinctrl_dev *pctldev;
-	struct pinctrl_gpio_range *range;
-	int ret;
-	int pin;
 	const char *func;
 
-	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
-	if (ret)
-		return;
-
-	/* Convert to the pin controllers number space */
-	pin = gpio - range->base + range->pin_base;
-
 	func = pin_free(pctldev, pin, range);
 	kfree(func);
 }
-EXPORT_SYMBOL_GPL(pinctrl_free_gpio);
 
-static int pinctrl_gpio_direction(unsigned gpio, bool input)
+/**
+ * pinmux_gpio_direction() - set the direction of a single muxed-in GPIO pin
+ * @pctldev: the pin controller handling this pin
+ * @range: applicable GPIO range
+ * @pin: the affected GPIO pin in this controller
+ * @input: true if we set the pin as input, false for output
+ */
+int pinmux_gpio_direction(struct pinctrl_dev *pctldev,
+			  struct pinctrl_gpio_range *range,
+			  unsigned pin, bool input)
 {
-	struct pinctrl_dev *pctldev;
-	struct pinctrl_gpio_range *range;
 	const struct pinmux_ops *ops;
 	int ret;
-	int pin;
-
-	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
-	if (ret)
-		return ret;
 
 	ops = pctldev->desc->pmxops;
 
-	/* Convert to the pin controllers number space */
-	pin = gpio - range->base + range->pin_base;
-
 	if (ops->gpio_set_direction)
 		ret = ops->gpio_set_direction(pctldev, range, pin, input);
 	else
@@ -298,112 +229,6 @@ static int pinctrl_gpio_direction(unsigned gpio, bool input)
 	return ret;
 }
 
-/**
- * pinctrl_gpio_direction_input() - request a GPIO pin to go into input mode
- * @gpio: the GPIO pin number from the GPIO subsystem number space
- *
- * This function should *ONLY* be used from gpiolib-based GPIO drivers,
- * as part of their gpio_direction_input() semantics, platforms and individual
- * drivers shall *NOT* touch pin control GPIO calls.
- */
-int pinctrl_gpio_direction_input(unsigned gpio)
-{
-	return pinctrl_gpio_direction(gpio, true);
-}
-EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);
-
-/**
- * pinctrl_gpio_direction_output() - request a GPIO pin to go into output mode
- * @gpio: the GPIO pin number from the GPIO subsystem number space
- *
- * This function should *ONLY* be used from gpiolib-based GPIO drivers,
- * as part of their gpio_direction_output() semantics, platforms and individual
- * drivers shall *NOT* touch pin control GPIO calls.
- */
-int pinctrl_gpio_direction_output(unsigned gpio)
-{
-	return pinctrl_gpio_direction(gpio, false);
-}
-EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
-
-/**
- * pinctrl_register_mappings() - register a set of pin controller mappings
- * @maps: the pincontrol mappings table to register, this should be marked with
- *	__initdata so it can be discarded after boot, this function will
- *	perform a shallow copy for the mapping entries.
- * @num_maps: the number of maps in the mapping table
- *
- * Only call this once during initialization of your machine, the function is
- * tagged as __init and won't be callable after init has completed. The map
- * passed into this function will be owned by the pinmux core and cannot be
- * freed.
- */
-int __init pinctrl_register_mappings(struct pinctrl_map const *maps,
-				     unsigned num_maps)
-{
-	void *tmp_maps;
-	int i;
-
-	pr_debug("add %d pinmux maps\n", num_maps);
-
-	/* First sanity check the new mapping */
-	for (i = 0; i < num_maps; i++) {
-		if (!maps[i].name) {
-			pr_err("failed to register map %d: no map name given\n",
-					i);
-			return -EINVAL;
-		}
-
-		if (!maps[i].ctrl_dev_name) {
-			pr_err("failed to register map %s (%d): no pin control device given\n",
-			       maps[i].name, i);
-			return -EINVAL;
-		}
-
-		if (!maps[i].function) {
-			pr_err("failed to register map %s (%d): no function ID given\n",
-					maps[i].name, i);
-			return -EINVAL;
-		}
-
-		if (!maps[i].dev_name)
-			pr_debug("add system map %s function %s with no device\n",
-				 maps[i].name,
-				 maps[i].function);
-		else
-			pr_debug("register map %s, function %s\n",
-				 maps[i].name,
-				 maps[i].function);
-	}
-
-	/*
-	 * Make a copy of the map array - string pointers will end up in the
-	 * kernel const section anyway so these do not need to be deep copied.
-	 */
-	if (!pinctrl_maps_num) {
-		/* On first call, just copy them */
-		tmp_maps = kmemdup(maps,
-				   sizeof(struct pinctrl_map) * num_maps,
-				   GFP_KERNEL);
-		if (!tmp_maps)
-			return -ENOMEM;
-	} else {
-		/* Subsequent calls, reallocate array to new size */
-		size_t oldsize = sizeof(struct pinctrl_map) * pinctrl_maps_num;
-		size_t newsize = sizeof(struct pinctrl_map) * num_maps;
-
-		tmp_maps = krealloc(pinctrl_maps,
-				    oldsize + newsize, GFP_KERNEL);
-		if (!tmp_maps)
-			return -ENOMEM;
-		memcpy((tmp_maps + oldsize), maps, newsize);
-	}
-
-	pinctrl_maps = tmp_maps;
-	pinctrl_maps_num += num_maps;
-	return 0;
-}
-
 /**
  * acquire_pins() - acquire all the pins for a certain function on a pinmux
  * @pctldev: the device to take the pins on
@@ -660,227 +485,81 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	return 0;
 }
 
-static void pinmux_free_groups(struct pinctrl *p)
-{
-	struct list_head *node, *tmp;
-
-	list_for_each_safe(node, tmp, &p->groups) {
-		struct pinmux_group *grp =
-			list_entry(node, struct pinmux_group, node);
-		/* Release all pins taken by this group */
-		release_pins(p->pctldev, grp->group_selector);
-		list_del(node);
-		kfree(grp);
-	}
-}
-
 /**
- * pinctrl_get() - retrieves the pin controller handle for a certain device
- * @dev: the device to get the pin controller handle for
- * @name: an optional specific control mapping name or NULL, the name is only
- *	needed if you want to have more than one mapping per device, or if you
- *	need an anonymous pin control (not tied to any specific device)
+ * pinmux_apply_muxmap() - apply a certain mux mapping entry
  */
-struct pinctrl *pinctrl_get(struct device *dev, const char *name)
+int pinmux_apply_muxmap(struct pinctrl_dev *pctldev,
+			struct pinctrl *p,
+			struct device *dev,
+			const char *devname,
+			struct pinctrl_map const *map)
 {
-	struct pinctrl_map const *map = NULL;
-	struct pinctrl_dev *pctldev = NULL;
-	const char *devname = NULL;
-	struct pinctrl *p;
-	bool found_map;
-	unsigned num_maps = 0;
-	int ret = -ENODEV;
-	int i;
-
-	/* We must have dev or ID or both */
-	if (!dev && !name)
-		return ERR_PTR(-EINVAL);
-
-	if (dev)
-		devname = dev_name(dev);
-
-	pr_debug("get mux %s for device %s\n", name,
-		 devname ? devname : "(none)");
-
-	/*
-	 * create the state cookie holder struct pinmux for each
-	 * mapping, this is what consumers will get when requesting
-	 * a pinmux handle with pinmux_get()
-	 */
-	p = kzalloc(sizeof(struct pinctrl), GFP_KERNEL);
-	if (p == NULL)
-		return ERR_PTR(-ENOMEM);
-	mutex_init(&p->mutex);
-	p->func_selector = UINT_MAX;
-	INIT_LIST_HEAD(&p->groups);
-
-	/* Iterate over the pin control maps to locate the right ones */
-	for (i = 0; i < pinctrl_maps_num; i++) {
-		map = &pinctrl_maps[i];
-		found_map = false;
-
-		/*
-		 * First, try to find the pctldev given in the map
-		 */
-		pctldev = get_pinctrl_dev_from_devname(map->ctrl_dev_name);
-		if (!pctldev) {
-			pr_warning("could not find a pinctrl device for pinmux function %s, fishy, they shall all have one\n",
-				   map->function);
-			pr_warning("given pinctrl device name: %s",
-				   map->ctrl_dev_name);
-
-			/* Continue to check the other mappings anyway... */
-			continue;
-		}
-
-		pr_debug("in map, found pctldev %s to handle function %s",
-			 dev_name(pctldev->dev), map->function);
-
-
-		/*
-		 * If we're looking for a specific named map, this must match,
-		 * else we loop and look for the next.
-		 */
-		if (name != NULL) {
-			if (map->name == NULL)
-				continue;
-			if (strcmp(map->name, name))
-				continue;
-		}
-
-		/*
-		 * This is for the case where no device name is given, we
-		 * already know that the function name matches from above
-		 * code.
-		 */
-		if (!map->dev_name && (name != NULL))
-			found_map = true;
-
-		/* If the mapping has a device set up it must match */
-		if (map->dev_name &&
-		    (!devname || !strcmp(map->dev_name, devname)))
-			/* MATCH! */
-			found_map = true;
-
-		/* If this map is applicable, then apply it */
-		if (found_map) {
-			ret = pinmux_enable_muxmap(pctldev, p, dev,
-						   devname, map);
-			if (ret) {
-				pinmux_free_groups(p);
-				kfree(p);
-				return ERR_PTR(ret);
-			}
-			num_maps++;
-		}
-	}
-
+	int ret;
 
-	/* We should have atleast one map, right */
-	if (!num_maps) {
-		pr_err("could not find any mux maps for device %s, ID %s\n",
-		       devname ? devname : "(anonymous)",
-		       name ? name : "(undefined)");
-		kfree(p);
-		return ERR_PTR(-EINVAL);
+	ret = pinmux_enable_muxmap(pctldev, p, dev,
+				   devname, map);
+	if (ret) {
+		pinmux_put(p);
+		return ret;
 	}
 
-	pr_debug("found %u mux maps for device %s, UD %s\n",
-		 num_maps,
-		 devname ? devname : "(anonymous)",
-		 name ? name : "(undefined)");
-
-	/* Add the pinmux to the global list */
-	mutex_lock(&pinctrl_list_mutex);
-	list_add(&p->node, &pinctrl_list);
-	mutex_unlock(&pinctrl_list_mutex);
-
-	return p;
+	return 0;
 }
-EXPORT_SYMBOL_GPL(pinctrl_get);
 
 /**
- * pinctrl_put() - release a previously claimed pin control handle
- * @p: a pin control handle previously claimed by pinctrl_get()
+ * pinmux_put() - free up the pinmux portions of a pin controller handle
  */
-void pinctrl_put(struct pinctrl *p)
+void pinmux_put(struct pinctrl *p)
 {
-	if (p == NULL)
-		return;
-
-	mutex_lock(&p->mutex);
-	if (p->usecount)
-		pr_warn("releasing pin control handle with active users!\n");
-	/* Free the groups and all acquired pins */
-	pinmux_free_groups(p);
-	mutex_unlock(&p->mutex);
-
-	/* Remove from list */
-	mutex_lock(&pinctrl_list_mutex);
-	list_del(&p->node);
-	mutex_unlock(&pinctrl_list_mutex);
+	struct list_head *node, *tmp;
 
-	kfree(p);
+	list_for_each_safe(node, tmp, &p->groups) {
+		struct pinmux_group *grp =
+			list_entry(node, struct pinmux_group, node);
+		/* Release all pins taken by this group */
+		release_pins(p->pctldev, grp->group_selector);
+		list_del(node);
+		kfree(grp);
+	}
 }
-EXPORT_SYMBOL_GPL(pinctrl_put);
 
 /**
- * pinctrl_enable() - enable a certain pin controller setting
- * @p: the pin control handle to enable, previously claimed by pinctrl_get()
+ * pinmux_enable() - enable the pinmux portion of a pin control handle
  */
-int pinctrl_enable(struct pinctrl *p)
+int pinmux_enable(struct pinctrl *p)
 {
-	int ret = 0;
+	struct pinctrl_dev *pctldev = p->pctldev;
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	struct pinmux_group *grp;
+	int ret;
 
-	if (p == NULL)
-		return -EINVAL;
-	mutex_lock(&p->mutex);
-	if (p->usecount++ == 0) {
-		struct pinctrl_dev *pctldev = p->pctldev;
-		const struct pinmux_ops *ops = pctldev->desc->pmxops;
-		struct pinmux_group *grp;
-
-		list_for_each_entry(grp, &p->groups, node) {
-			ret = ops->enable(pctldev, p->func_selector,
-					  grp->group_selector);
-			if (ret) {
-				/*
-				 * TODO: call disable() on all groups we called
-				 * enable() on to this point?
-				 */
-				p->usecount--;
-				break;
-			}
-		}
+	list_for_each_entry(grp, &p->groups, node) {
+		ret = ops->enable(pctldev, p->func_selector,
+				  grp->group_selector);
+		if (ret)
+			/*
+			 * TODO: call disable() on all groups we called
+			 * enable() on to this point?
+			 */
+			return ret;
 	}
-	mutex_unlock(&p->mutex);
-	return ret;
+	return 0;
 }
-EXPORT_SYMBOL_GPL(pinctrl_enable);
 
 /**
- * pinctrl_disable() - disable a certain pin control setting
- * @p: the pin control handle to disable, previously claimed by pinctrl_get()
+ * pinmux_disable() - disable the pinmux portions of a pin control handle
  */
-void pinctrl_disable(struct pinctrl *p)
+void pinmux_disable(struct pinctrl *p)
 {
-	if (p == NULL)
-		return;
-
-	mutex_lock(&p->mutex);
-	if (--p->usecount == 0) {
-		struct pinctrl_dev *pctldev = p->pctldev;
-		const struct pinmux_ops *ops = pctldev->desc->pmxops;
-		struct pinmux_group *grp;
+	struct pinctrl_dev *pctldev = p->pctldev;
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	struct pinmux_group *grp;
 
-		list_for_each_entry(grp, &p->groups, node) {
-			ops->disable(pctldev, p->func_selector,
-				     grp->group_selector);
-		}
+	list_for_each_entry(grp, &p->groups, node) {
+		ops->disable(pctldev, p->func_selector,
+			     grp->group_selector);
 	}
-	mutex_unlock(&p->mutex);
 }
-EXPORT_SYMBOL_GPL(pinctrl_disable);
 
 int pinmux_check_ops(struct pinctrl_dev *pctldev)
 {
@@ -910,116 +589,6 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 	return 0;
 }
 
-/* Hog a single map entry and add to the hoglist */
-static int pinctrl_hog_map(struct pinctrl_dev *pctldev,
-			   struct pinctrl_map const *map)
-{
-	struct pinctrl_hog *hog;
-	struct pinctrl *p;
-	int ret;
-
-	if (map->dev_name) {
-		/*
-		 * TODO: the day we have device tree support, we can
-		 * traverse the device tree and hog to specific device nodes
-		 * without any problems, so then we can hog pinmuxes for
-		 * all devices that just want a static pin mux at this point.
-		 */
-		dev_err(pctldev->dev, "map %s wants to hog a non-system pinmux, this is not going to work\n",
-				map->name);
-		return -EINVAL;
-	}
-
-	hog = kzalloc(sizeof(struct pinctrl_hog), GFP_KERNEL);
-	if (!hog)
-		return -ENOMEM;
-
-	p = pinctrl_get(NULL, map->name);
-	if (IS_ERR(p)) {
-		kfree(hog);
-		dev_err(pctldev->dev,
-			"could not get the %s pin control mapping for hogging\n",
-			map->name);
-		return PTR_ERR(p);
-	}
-
-	ret = pinctrl_enable(p);
-	if (ret) {
-		pinctrl_put(p);
-		kfree(hog);
-		dev_err(pctldev->dev,
-			"could not enable the %s pin control mapping for hogging\n",
-			map->name);
-		return ret;
-	}
-
-	hog->map = map;
-	hog->p = p;
-
-	dev_info(pctldev->dev, "hogged map %s, function %s\n", map->name,
-		 map->function);
-	mutex_lock(&pctldev->pinctrl_hogs_lock);
-	list_add(&hog->node, &pctldev->pinctrl_hogs);
-	mutex_unlock(&pctldev->pinctrl_hogs_lock);
-
-	return 0;
-}
-
-/**
- * pinctrl_hog_maps() - hog specific map entries on controller device
- * @pctldev: the pin control device to hog entries on
- *
- * When the pin controllers are registered, there may be some specific pinmux
- * map entries that need to be hogged, i.e. get+enabled until the system shuts
- * down.
- */
-int pinctrl_hog_maps(struct pinctrl_dev *pctldev)
-{
-	struct device *dev = pctldev->dev;
-	const char *devname = dev_name(dev);
-	int ret;
-	int i;
-
-	INIT_LIST_HEAD(&pctldev->pinctrl_hogs);
-	mutex_init(&pctldev->pinctrl_hogs_lock);
-
-	for (i = 0; i < pinctrl_maps_num; i++) {
-		struct pinctrl_map const *map = &pinctrl_maps[i];
-
-		if (!map->hog_on_boot)
-			continue;
-
-		if (map->ctrl_dev_name &&
-		    !strcmp(map->ctrl_dev_name, devname)) {
-			/* OK time to hog! */
-			ret = pinctrl_hog_map(pctldev, map);
-			if (ret)
-				return ret;
-		}
-	}
-	return 0;
-}
-
-/**
- * pinctrl_unhog_maps() - unhog specific map entries on controller device
- * @pctldev: the pin control device to unhog entries on
- */
-void pinctrl_unhog_maps(struct pinctrl_dev *pctldev)
-{
-	struct list_head *node, *tmp;
-
-	mutex_lock(&pctldev->pinctrl_hogs_lock);
-	list_for_each_safe(node, tmp, &pctldev->pinctrl_hogs) {
-		struct pinctrl_hog *hog =
-			list_entry(node, struct pinctrl_hog, node);
-		pinctrl_disable(hog->p);
-		pinctrl_put(hog->p);
-		list_del(node);
-		kfree(hog);
-	}
-	mutex_unlock(&pctldev->pinctrl_hogs_lock);
-}
-
 #ifdef CONFIG_DEBUG_FS
 
 /* Called from pincontrol core */
@@ -1083,83 +652,29 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 	return 0;
 }
 
-static int pinmux_hogs_show(struct seq_file *s, void *what)
-{
-	struct pinctrl_dev *pctldev = s->private;
-	struct pinctrl_hog *hog;
-
-	seq_puts(s, "Pin control map hogs held by device\n");
-
-	list_for_each_entry(hog, &pctldev->pinctrl_hogs, node)
-		seq_printf(s, "%s\n", hog->map->name);
-
-	return 0;
-}
-
-static int pinmux_show(struct seq_file *s, void *what)
+void pinmux_dbg_show(struct seq_file *s, struct pinctrl *p)
 {
-	struct pinctrl *p;
-
-	seq_puts(s, "Requested pinmuxes and their maps:\n");
-	list_for_each_entry(p, &pinctrl_list, node) {
-		struct pinctrl_dev *pctldev = p->pctldev;
-		const struct pinmux_ops *pmxops;
-		const struct pinctrl_ops *pctlops;
-		struct pinmux_group *grp;
-
-		if (!pctldev) {
-			seq_puts(s, "NO PIN CONTROLLER DEVICE\n");
-			continue;
-		}
-
-		pmxops = pctldev->desc->pmxops;
-		pctlops = pctldev->desc->pctlops;
-
-		seq_printf(s, "device: %s function: %s (%u),",
-			   pinctrl_dev_get_name(p->pctldev),
-			   pmxops->get_function_name(pctldev,
-				   p->func_selector),
-			   p->func_selector);
-
-		seq_printf(s, " groups: [");
-		list_for_each_entry(grp, &p->groups, node) {
-			seq_printf(s, " %s (%u)",
-				   pctlops->get_group_name(pctldev,
-					   grp->group_selector),
-				   grp->group_selector);
-		}
-		seq_printf(s, " ]");
+	struct pinctrl_dev *pctldev = p->pctldev;
+	const struct pinmux_ops *pmxops;
+	const struct pinctrl_ops *pctlops;
+	struct pinmux_group *grp;
 
-		seq_printf(s, " users: %u map-> %s\n",
-			   p->usecount,
-			   p->dev ? dev_name(p->dev) : "(system)");
-	}
+	pmxops = pctldev->desc->pmxops;
+	pctlops = pctldev->desc->pctlops;
 
-	return 0;
-}
-
-static int pinctrl_maps_show(struct seq_file *s, void *what)
-{
-	int i;
+	seq_printf(s, " function: %s (%u),",
+		   pmxops->get_function_name(pctldev,
+					     p->func_selector),
+		   p->func_selector);
 
-	seq_puts(s, "Pinctrl maps:\n");
-
-	for (i = 0; i < pinctrl_maps_num; i++) {
-		struct pinctrl_map const *map = &pinctrl_maps[i];
-
-		seq_printf(s, "%s:\n", map->name);
-		if (map->dev_name)
-			seq_printf(s, "  device: %s\n",
-				   map->dev_name);
-		else
-			seq_printf(s, "  SYSTEM MUX\n");
-		seq_printf(s, "  controlling device %s\n",
-			   map->ctrl_dev_name);
-		seq_printf(s, "  function: %s\n", map->function);
-		seq_printf(s, "  group: %s\n", map->group ? map->group :
-			   "(default)");
+	seq_printf(s, " groups: [");
+	list_for_each_entry(grp, &p->groups, node) {
+		seq_printf(s, " %s (%u)",
+			   pctlops->get_group_name(pctldev,
+						   grp->group_selector),
+			   grp->group_selector);
 	}
-	return 0;
+	seq_printf(s, " ]");
 }
 
 static int pinmux_functions_open(struct inode *inode, struct file *file)
@@ -1172,21 +687,6 @@ static int pinmux_pins_open(struct inode *inode, struct file *file)
 	return single_open(file, pinmux_pins_show, inode->i_private);
 }
 
-static int pinmux_hogs_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, pinmux_hogs_show, inode->i_private);
-}
-
-static int pinmux_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, pinmux_show, NULL);
-}
-
-static int pinctrl_maps_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, pinctrl_maps_show, NULL);
-}
-
 static const struct file_operations pinmux_functions_ops = {
 	.open		= pinmux_functions_open,
 	.read		= seq_read,
@@ -1201,27 +701,6 @@ static const struct file_operations pinmux_pins_ops = {
 	.release	= single_release,
 };
 
-static const struct file_operations pinmux_hogs_ops = {
-	.open		= pinmux_hogs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static const struct file_operations pinmux_ops = {
-	.open		= pinmux_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static const struct file_operations pinctrl_maps_ops = {
-	.open		= pinctrl_maps_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
 void pinmux_init_device_debugfs(struct dentry *devroot,
 			 struct pinctrl_dev *pctldev)
 {
@@ -1229,16 +708,6 @@ void pinmux_init_device_debugfs(struct dentry *devroot,
 			    devroot, pctldev, &pinmux_functions_ops);
 	debugfs_create_file("pinmux-pins", S_IFREG | S_IRUGO,
 			    devroot, pctldev, &pinmux_pins_ops);
-	debugfs_create_file("pinmux-hogs", S_IFREG | S_IRUGO,
-			    devroot, pctldev, &pinmux_hogs_ops);
-}
-
-void pinmux_init_debugfs(struct dentry *subsys_root)
-{
-	debugfs_create_file("pinmuxes", S_IFREG | S_IRUGO,
-			    subsys_root, NULL, &pinmux_ops);
-	debugfs_create_file("pinctrl-maps", S_IFREG | S_IRUGO,
-			    subsys_root, NULL, &pinctrl_maps_ops);
 }
 
 #endif /* CONFIG_DEBUG_FS */

commit e93bcee00c43e2bd4037291262111016f4c05793
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 07:23:28 2012 +0100

    pinctrl: move generic functions to the pinctrl_ namespace
    
    Since we want to use the former pinmux handles and mapping tables for
    generic control involving both muxing and configuration we begin
    refactoring by renaming them from pinmux_* to pinctrl_*.
    
    ChangeLog v1->v2:
    - Also rename the PINMUX_* macros in machine.h to PIN_ as indicated
      in the documentation so as to reflect the generic nature of these
      mapping entries from now on.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 1311f1d22002..773835d18f55 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -1,7 +1,7 @@
 /*
  * Core driver for the pin muxing portions of the pin control subsystem
  *
- * Copyright (C) 2011 ST-Ericsson SA
+ * Copyright (C) 2011-2012 ST-Ericsson SA
  * Written on behalf of Linaro for ST-Ericsson
  * Based on bits of regulator core, gpio core and clk core
  *
@@ -29,13 +29,13 @@
 #include <linux/pinctrl/pinmux.h>
 #include "core.h"
 
-/* List of pinmuxes */
-static DEFINE_MUTEX(pinmux_list_mutex);
-static LIST_HEAD(pinmux_list);
+/* List of pin controller handles */
+static DEFINE_MUTEX(pinctrl_list_mutex);
+static LIST_HEAD(pinctrl_list);
 
-/* Global pinmux maps */
-static struct pinmux_map *pinmux_maps;
-static unsigned pinmux_maps_num;
+/* Global pinctrl maps */
+static struct pinctrl_map *pinctrl_maps;
+static unsigned pinctrl_maps_num;
 
 /**
  * struct pinmux_group - group list item for pinmux groups
@@ -48,12 +48,12 @@ struct pinmux_group {
 };
 
 /**
- * struct pinmux - per-device pinmux state holder
+ * struct pinctrl - per-device pin control state holder
  * @node: global list node
- * @dev: the device using this pinmux
- * @usecount: the number of active users of this mux setting, used to keep
- *	track of nested use cases
- * @pctldev: pin control device handling this pinmux
+ * @dev: the device using this pin control handle
+ * @usecount: the number of active users of this pin controller setting, used
+ *	to keep track of nested use cases
+ * @pctldev: pin control device handling this pin control handle
  * @func_selector: the function selector for the pinmux device handling
  *	this pinmux
  * @groups: the group selectors for the pinmux device and
@@ -62,7 +62,7 @@ struct pinmux_group {
  *	get/put/enable/disable
  * @mutex: a lock for the pinmux state holder
  */
-struct pinmux {
+struct pinctrl {
 	struct list_head node;
 	struct device *dev;
 	unsigned usecount;
@@ -73,15 +73,15 @@ struct pinmux {
 };
 
 /**
- * struct pinmux_hog - a list item to stash mux hogs
- * @node: pinmux hog list node
+ * struct pinctrl_hog - a list item to stash control hogs
+ * @node: pin control hog list node
  * @map: map entry responsible for this hogging
- * @pmx: the pinmux hogged by this item
+ * @pmx: the pin control hogged by this item
  */
-struct pinmux_hog {
+struct pinctrl_hog {
 	struct list_head node;
-	struct pinmux_map const *map;
-	struct pinmux *pmx;
+	struct pinctrl_map const *map;
+	struct pinctrl *p;
 };
 
 /**
@@ -207,14 +207,14 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 }
 
 /**
- * pinmux_request_gpio() - request a single pin to be muxed in as GPIO
+ * pinctrl_request_gpio() - request a single pin to be used in as GPIO
  * @gpio: the GPIO pin number from the GPIO subsystem number space
  *
  * This function should *ONLY* be used from gpiolib-based GPIO drivers,
  * as part of their gpio_request() semantics, platforms and individual drivers
  * shall *NOT* request GPIO pins to be muxed in.
  */
-int pinmux_request_gpio(unsigned gpio)
+int pinctrl_request_gpio(unsigned gpio)
 {
 	char gpiostr[16];
 	const char *function;
@@ -243,17 +243,17 @@ int pinmux_request_gpio(unsigned gpio)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(pinmux_request_gpio);
+EXPORT_SYMBOL_GPL(pinctrl_request_gpio);
 
 /**
- * pinmux_free_gpio() - free a single pin, currently used as GPIO
+ * pinctrl_free_gpio() - free control on a single pin, currently used as GPIO
  * @gpio: the GPIO pin number from the GPIO subsystem number space
  *
  * This function should *ONLY* be used from gpiolib-based GPIO drivers,
  * as part of their gpio_free() semantics, platforms and individual drivers
  * shall *NOT* request GPIO pins to be muxed out.
  */
-void pinmux_free_gpio(unsigned gpio)
+void pinctrl_free_gpio(unsigned gpio)
 {
 	struct pinctrl_dev *pctldev;
 	struct pinctrl_gpio_range *range;
@@ -271,9 +271,9 @@ void pinmux_free_gpio(unsigned gpio)
 	func = pin_free(pctldev, pin, range);
 	kfree(func);
 }
-EXPORT_SYMBOL_GPL(pinmux_free_gpio);
+EXPORT_SYMBOL_GPL(pinctrl_free_gpio);
 
-static int pinmux_gpio_direction(unsigned gpio, bool input)
+static int pinctrl_gpio_direction(unsigned gpio, bool input)
 {
 	struct pinctrl_dev *pctldev;
 	struct pinctrl_gpio_range *range;
@@ -299,36 +299,36 @@ static int pinmux_gpio_direction(unsigned gpio, bool input)
 }
 
 /**
- * pinmux_gpio_direction_input() - request a GPIO pin to go into input mode
+ * pinctrl_gpio_direction_input() - request a GPIO pin to go into input mode
  * @gpio: the GPIO pin number from the GPIO subsystem number space
  *
  * This function should *ONLY* be used from gpiolib-based GPIO drivers,
  * as part of their gpio_direction_input() semantics, platforms and individual
- * drivers shall *NOT* touch pinmux GPIO calls.
+ * drivers shall *NOT* touch pin control GPIO calls.
  */
-int pinmux_gpio_direction_input(unsigned gpio)
+int pinctrl_gpio_direction_input(unsigned gpio)
 {
-	return pinmux_gpio_direction(gpio, true);
+	return pinctrl_gpio_direction(gpio, true);
 }
-EXPORT_SYMBOL_GPL(pinmux_gpio_direction_input);
+EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);
 
 /**
- * pinmux_gpio_direction_output() - request a GPIO pin to go into output mode
+ * pinctrl_gpio_direction_output() - request a GPIO pin to go into output mode
  * @gpio: the GPIO pin number from the GPIO subsystem number space
  *
  * This function should *ONLY* be used from gpiolib-based GPIO drivers,
  * as part of their gpio_direction_output() semantics, platforms and individual
- * drivers shall *NOT* touch pinmux GPIO calls.
+ * drivers shall *NOT* touch pin control GPIO calls.
  */
-int pinmux_gpio_direction_output(unsigned gpio)
+int pinctrl_gpio_direction_output(unsigned gpio)
 {
-	return pinmux_gpio_direction(gpio, false);
+	return pinctrl_gpio_direction(gpio, false);
 }
-EXPORT_SYMBOL_GPL(pinmux_gpio_direction_output);
+EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
 
 /**
- * pinmux_register_mappings() - register a set of pinmux mappings
- * @maps: the pinmux mappings table to register, this should be marked with
+ * pinctrl_register_mappings() - register a set of pin controller mappings
+ * @maps: the pincontrol mappings table to register, this should be marked with
  *	__initdata so it can be discarded after boot, this function will
  *	perform a shallow copy for the mapping entries.
  * @num_maps: the number of maps in the mapping table
@@ -338,8 +338,8 @@ EXPORT_SYMBOL_GPL(pinmux_gpio_direction_output);
  * passed into this function will be owned by the pinmux core and cannot be
  * freed.
  */
-int __init pinmux_register_mappings(struct pinmux_map const *maps,
-				    unsigned num_maps)
+int __init pinctrl_register_mappings(struct pinctrl_map const *maps,
+				     unsigned num_maps)
 {
 	void *tmp_maps;
 	int i;
@@ -380,26 +380,27 @@ int __init pinmux_register_mappings(struct pinmux_map const *maps,
 	 * Make a copy of the map array - string pointers will end up in the
 	 * kernel const section anyway so these do not need to be deep copied.
 	 */
-	if (!pinmux_maps_num) {
+	if (!pinctrl_maps_num) {
 		/* On first call, just copy them */
 		tmp_maps = kmemdup(maps,
-				   sizeof(struct pinmux_map) * num_maps,
+				   sizeof(struct pinctrl_map) * num_maps,
 				   GFP_KERNEL);
 		if (!tmp_maps)
 			return -ENOMEM;
 	} else {
 		/* Subsequent calls, reallocate array to new size */
-		size_t oldsize = sizeof(struct pinmux_map) * pinmux_maps_num;
-		size_t newsize = sizeof(struct pinmux_map) * num_maps;
+		size_t oldsize = sizeof(struct pinctrl_map) * pinctrl_maps_num;
+		size_t newsize = sizeof(struct pinctrl_map) * num_maps;
 
-		tmp_maps = krealloc(pinmux_maps, oldsize + newsize, GFP_KERNEL);
+		tmp_maps = krealloc(pinctrl_maps,
+				    oldsize + newsize, GFP_KERNEL);
 		if (!tmp_maps)
 			return -ENOMEM;
 		memcpy((tmp_maps + oldsize), maps, newsize);
 	}
 
-	pinmux_maps = tmp_maps;
-	pinmux_maps_num += num_maps;
+	pinctrl_maps = tmp_maps;
+	pinctrl_maps_num += num_maps;
 	return 0;
 }
 
@@ -560,7 +561,7 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
  * negative otherwise
  */
 static int pinmux_search_function(struct pinctrl_dev *pctldev,
-				  struct pinmux_map const *map,
+				  struct pinctrl_map const *map,
 				  unsigned *func_selector,
 				  unsigned *group_selector)
 {
@@ -598,10 +599,10 @@ static int pinmux_search_function(struct pinctrl_dev *pctldev,
  * pinmux_enable_muxmap() - enable a map entry for a certain pinmux
  */
 static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
-				struct pinmux *pmx,
+				struct pinctrl *p,
 				struct device *dev,
 				const char *devname,
-				struct pinmux_map const *map)
+				struct pinctrl_map const *map)
 {
 	unsigned func_selector;
 	unsigned group_selector;
@@ -615,14 +616,14 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	 * by anyone else.
 	 */
 
-	if (pmx->pctldev && pmx->pctldev != pctldev) {
+	if (p->pctldev && p->pctldev != pctldev) {
 		dev_err(pctldev->dev,
 			"different pin control devices given for device %s, function %s\n",
 			devname, map->function);
 		return -EINVAL;
 	}
-	pmx->dev = dev;
-	pmx->pctldev = pctldev;
+	p->dev = dev;
+	p->pctldev = pctldev;
 
 	/* Now go into the driver and try to match a function and group */
 	ret = pinmux_search_function(pctldev, map, &func_selector,
@@ -635,14 +636,14 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	 * we support several groups with one function but not several
 	 * functions with one or several groups in the same pinmux.
 	 */
-	if (pmx->func_selector != UINT_MAX &&
-	    pmx->func_selector != func_selector) {
+	if (p->func_selector != UINT_MAX &&
+	    p->func_selector != func_selector) {
 		dev_err(pctldev->dev,
 			"dual function defines in the map for device %s\n",
 		       devname);
 		return -EINVAL;
 	}
-	pmx->func_selector = func_selector;
+	p->func_selector = func_selector;
 
 	/* Now add this group selector, we may have many of them */
 	grp = kmalloc(sizeof(struct pinmux_group), GFP_KERNEL);
@@ -654,38 +655,38 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 		kfree(grp);
 		return ret;
 	}
-	list_add(&grp->node, &pmx->groups);
+	list_add(&grp->node, &p->groups);
 
 	return 0;
 }
 
-static void pinmux_free_groups(struct pinmux *pmx)
+static void pinmux_free_groups(struct pinctrl *p)
 {
 	struct list_head *node, *tmp;
 
-	list_for_each_safe(node, tmp, &pmx->groups) {
+	list_for_each_safe(node, tmp, &p->groups) {
 		struct pinmux_group *grp =
 			list_entry(node, struct pinmux_group, node);
 		/* Release all pins taken by this group */
-		release_pins(pmx->pctldev, grp->group_selector);
+		release_pins(p->pctldev, grp->group_selector);
 		list_del(node);
 		kfree(grp);
 	}
 }
 
 /**
- * pinmux_get() - retrieves the pinmux for a certain device
- * @dev: the device to get the pinmux for
- * @name: an optional specific mux mapping name or NULL, the name is only
+ * pinctrl_get() - retrieves the pin controller handle for a certain device
+ * @dev: the device to get the pin controller handle for
+ * @name: an optional specific control mapping name or NULL, the name is only
  *	needed if you want to have more than one mapping per device, or if you
- *	need an anonymous pinmux (not tied to any specific device)
+ *	need an anonymous pin control (not tied to any specific device)
  */
-struct pinmux *pinmux_get(struct device *dev, const char *name)
+struct pinctrl *pinctrl_get(struct device *dev, const char *name)
 {
-	struct pinmux_map const *map = NULL;
+	struct pinctrl_map const *map = NULL;
 	struct pinctrl_dev *pctldev = NULL;
 	const char *devname = NULL;
-	struct pinmux *pmx;
+	struct pinctrl *p;
 	bool found_map;
 	unsigned num_maps = 0;
 	int ret = -ENODEV;
@@ -706,16 +707,16 @@ struct pinmux *pinmux_get(struct device *dev, const char *name)
 	 * mapping, this is what consumers will get when requesting
 	 * a pinmux handle with pinmux_get()
 	 */
-	pmx = kzalloc(sizeof(struct pinmux), GFP_KERNEL);
-	if (pmx == NULL)
+	p = kzalloc(sizeof(struct pinctrl), GFP_KERNEL);
+	if (p == NULL)
 		return ERR_PTR(-ENOMEM);
-	mutex_init(&pmx->mutex);
-	pmx->func_selector = UINT_MAX;
-	INIT_LIST_HEAD(&pmx->groups);
+	mutex_init(&p->mutex);
+	p->func_selector = UINT_MAX;
+	INIT_LIST_HEAD(&p->groups);
 
-	/* Iterate over the pinmux maps to locate the right ones */
-	for (i = 0; i < pinmux_maps_num; i++) {
-		map = &pinmux_maps[i];
+	/* Iterate over the pin control maps to locate the right ones */
+	for (i = 0; i < pinctrl_maps_num; i++) {
+		map = &pinctrl_maps[i];
 		found_map = false;
 
 		/*
@@ -763,11 +764,11 @@ struct pinmux *pinmux_get(struct device *dev, const char *name)
 
 		/* If this map is applicable, then apply it */
 		if (found_map) {
-			ret = pinmux_enable_muxmap(pctldev, pmx, dev,
+			ret = pinmux_enable_muxmap(pctldev, p, dev,
 						   devname, map);
 			if (ret) {
-				pinmux_free_groups(pmx);
-				kfree(pmx);
+				pinmux_free_groups(p);
+				kfree(p);
 				return ERR_PTR(ret);
 			}
 			num_maps++;
@@ -780,7 +781,7 @@ struct pinmux *pinmux_get(struct device *dev, const char *name)
 		pr_err("could not find any mux maps for device %s, ID %s\n",
 		       devname ? devname : "(anonymous)",
 		       name ? name : "(undefined)");
-		kfree(pmx);
+		kfree(p);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -790,96 +791,96 @@ struct pinmux *pinmux_get(struct device *dev, const char *name)
 		 name ? name : "(undefined)");
 
 	/* Add the pinmux to the global list */
-	mutex_lock(&pinmux_list_mutex);
-	list_add(&pmx->node, &pinmux_list);
-	mutex_unlock(&pinmux_list_mutex);
+	mutex_lock(&pinctrl_list_mutex);
+	list_add(&p->node, &pinctrl_list);
+	mutex_unlock(&pinctrl_list_mutex);
 
-	return pmx;
+	return p;
 }
-EXPORT_SYMBOL_GPL(pinmux_get);
+EXPORT_SYMBOL_GPL(pinctrl_get);
 
 /**
- * pinmux_put() - release a previously claimed pinmux
- * @pmx: a pinmux previously claimed by pinmux_get()
+ * pinctrl_put() - release a previously claimed pin control handle
+ * @p: a pin control handle previously claimed by pinctrl_get()
  */
-void pinmux_put(struct pinmux *pmx)
+void pinctrl_put(struct pinctrl *p)
 {
-	if (pmx == NULL)
+	if (p == NULL)
 		return;
 
-	mutex_lock(&pmx->mutex);
-	if (pmx->usecount)
-		pr_warn("releasing pinmux with active users!\n");
+	mutex_lock(&p->mutex);
+	if (p->usecount)
+		pr_warn("releasing pin control handle with active users!\n");
 	/* Free the groups and all acquired pins */
-	pinmux_free_groups(pmx);
-	mutex_unlock(&pmx->mutex);
+	pinmux_free_groups(p);
+	mutex_unlock(&p->mutex);
 
 	/* Remove from list */
-	mutex_lock(&pinmux_list_mutex);
-	list_del(&pmx->node);
-	mutex_unlock(&pinmux_list_mutex);
+	mutex_lock(&pinctrl_list_mutex);
+	list_del(&p->node);
+	mutex_unlock(&pinctrl_list_mutex);
 
-	kfree(pmx);
+	kfree(p);
 }
-EXPORT_SYMBOL_GPL(pinmux_put);
+EXPORT_SYMBOL_GPL(pinctrl_put);
 
 /**
- * pinmux_enable() - enable a certain pinmux setting
- * @pmx: the pinmux to enable, previously claimed by pinmux_get()
+ * pinctrl_enable() - enable a certain pin controller setting
+ * @p: the pin control handle to enable, previously claimed by pinctrl_get()
  */
-int pinmux_enable(struct pinmux *pmx)
+int pinctrl_enable(struct pinctrl *p)
 {
 	int ret = 0;
 
-	if (pmx == NULL)
+	if (p == NULL)
 		return -EINVAL;
-	mutex_lock(&pmx->mutex);
-	if (pmx->usecount++ == 0) {
-		struct pinctrl_dev *pctldev = pmx->pctldev;
+	mutex_lock(&p->mutex);
+	if (p->usecount++ == 0) {
+		struct pinctrl_dev *pctldev = p->pctldev;
 		const struct pinmux_ops *ops = pctldev->desc->pmxops;
 		struct pinmux_group *grp;
 
-		list_for_each_entry(grp, &pmx->groups, node) {
-			ret = ops->enable(pctldev, pmx->func_selector,
+		list_for_each_entry(grp, &p->groups, node) {
+			ret = ops->enable(pctldev, p->func_selector,
 					  grp->group_selector);
 			if (ret) {
 				/*
 				 * TODO: call disable() on all groups we called
 				 * enable() on to this point?
 				 */
-				pmx->usecount--;
+				p->usecount--;
 				break;
 			}
 		}
 	}
-	mutex_unlock(&pmx->mutex);
+	mutex_unlock(&p->mutex);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(pinmux_enable);
+EXPORT_SYMBOL_GPL(pinctrl_enable);
 
 /**
- * pinmux_disable() - disable a certain pinmux setting
- * @pmx: the pinmux to disable, previously claimed by pinmux_get()
+ * pinctrl_disable() - disable a certain pin control setting
+ * @p: the pin control handle to disable, previously claimed by pinctrl_get()
  */
-void pinmux_disable(struct pinmux *pmx)
+void pinctrl_disable(struct pinctrl *p)
 {
-	if (pmx == NULL)
+	if (p == NULL)
 		return;
 
-	mutex_lock(&pmx->mutex);
-	if (--pmx->usecount == 0) {
-		struct pinctrl_dev *pctldev = pmx->pctldev;
+	mutex_lock(&p->mutex);
+	if (--p->usecount == 0) {
+		struct pinctrl_dev *pctldev = p->pctldev;
 		const struct pinmux_ops *ops = pctldev->desc->pmxops;
 		struct pinmux_group *grp;
 
-		list_for_each_entry(grp, &pmx->groups, node) {
-			ops->disable(pctldev, pmx->func_selector,
+		list_for_each_entry(grp, &p->groups, node) {
+			ops->disable(pctldev, p->func_selector,
 				     grp->group_selector);
 		}
 	}
-	mutex_unlock(&pmx->mutex);
+	mutex_unlock(&p->mutex);
 }
-EXPORT_SYMBOL_GPL(pinmux_disable);
+EXPORT_SYMBOL_GPL(pinctrl_disable);
 
 int pinmux_check_ops(struct pinctrl_dev *pctldev)
 {
@@ -910,11 +911,11 @@ int pinmux_check_ops(struct pinctrl_dev *pctldev)
 }
 
 /* Hog a single map entry and add to the hoglist */
-static int pinmux_hog_map(struct pinctrl_dev *pctldev,
-			  struct pinmux_map const *map)
+static int pinctrl_hog_map(struct pinctrl_dev *pctldev,
+			   struct pinctrl_map const *map)
 {
-	struct pinmux_hog *hog;
-	struct pinmux *pmx;
+	struct pinctrl_hog *hog;
+	struct pinctrl *p;
 	int ret;
 
 	if (map->dev_name) {
@@ -929,61 +930,61 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
 		return -EINVAL;
 	}
 
-	hog = kzalloc(sizeof(struct pinmux_hog), GFP_KERNEL);
+	hog = kzalloc(sizeof(struct pinctrl_hog), GFP_KERNEL);
 	if (!hog)
 		return -ENOMEM;
 
-	pmx = pinmux_get(NULL, map->name);
-	if (IS_ERR(pmx)) {
+	p = pinctrl_get(NULL, map->name);
+	if (IS_ERR(p)) {
 		kfree(hog);
 		dev_err(pctldev->dev,
-			"could not get the %s pinmux mapping for hogging\n",
+			"could not get the %s pin control mapping for hogging\n",
 			map->name);
-		return PTR_ERR(pmx);
+		return PTR_ERR(p);
 	}
 
-	ret = pinmux_enable(pmx);
+	ret = pinctrl_enable(p);
 	if (ret) {
-		pinmux_put(pmx);
+		pinctrl_put(p);
 		kfree(hog);
 		dev_err(pctldev->dev,
-			"could not enable the %s pinmux mapping for hogging\n",
+			"could not enable the %s pin control mapping for hogging\n",
 			map->name);
 		return ret;
 	}
 
 	hog->map = map;
-	hog->pmx = pmx;
+	hog->p = p;
 
 	dev_info(pctldev->dev, "hogged map %s, function %s\n", map->name,
 		 map->function);
-	mutex_lock(&pctldev->pinmux_hogs_lock);
-	list_add(&hog->node, &pctldev->pinmux_hogs);
-	mutex_unlock(&pctldev->pinmux_hogs_lock);
+	mutex_lock(&pctldev->pinctrl_hogs_lock);
+	list_add(&hog->node, &pctldev->pinctrl_hogs);
+	mutex_unlock(&pctldev->pinctrl_hogs_lock);
 
 	return 0;
 }
 
 /**
- * pinmux_hog_maps() - hog specific map entries on controller device
+ * pinctrl_hog_maps() - hog specific map entries on controller device
  * @pctldev: the pin control device to hog entries on
  *
  * When the pin controllers are registered, there may be some specific pinmux
  * map entries that need to be hogged, i.e. get+enabled until the system shuts
  * down.
  */
-int pinmux_hog_maps(struct pinctrl_dev *pctldev)
+int pinctrl_hog_maps(struct pinctrl_dev *pctldev)
 {
 	struct device *dev = pctldev->dev;
 	const char *devname = dev_name(dev);
 	int ret;
 	int i;
 
-	INIT_LIST_HEAD(&pctldev->pinmux_hogs);
-	mutex_init(&pctldev->pinmux_hogs_lock);
+	INIT_LIST_HEAD(&pctldev->pinctrl_hogs);
+	mutex_init(&pctldev->pinctrl_hogs_lock);
 
-	for (i = 0; i < pinmux_maps_num; i++) {
-		struct pinmux_map const *map = &pinmux_maps[i];
+	for (i = 0; i < pinctrl_maps_num; i++) {
+		struct pinctrl_map const *map = &pinctrl_maps[i];
 
 		if (!map->hog_on_boot)
 			continue;
@@ -991,7 +992,7 @@ int pinmux_hog_maps(struct pinctrl_dev *pctldev)
 		if (map->ctrl_dev_name &&
 		    !strcmp(map->ctrl_dev_name, devname)) {
 			/* OK time to hog! */
-			ret = pinmux_hog_map(pctldev, map);
+			ret = pinctrl_hog_map(pctldev, map);
 			if (ret)
 				return ret;
 		}
@@ -1000,23 +1001,23 @@ int pinmux_hog_maps(struct pinctrl_dev *pctldev)
 }
 
 /**
- * pinmux_unhog_maps() - unhog specific map entries on controller device
+ * pinctrl_unhog_maps() - unhog specific map entries on controller device
  * @pctldev: the pin control device to unhog entries on
  */
-void pinmux_unhog_maps(struct pinctrl_dev *pctldev)
+void pinctrl_unhog_maps(struct pinctrl_dev *pctldev)
 {
 	struct list_head *node, *tmp;
 
-	mutex_lock(&pctldev->pinmux_hogs_lock);
-	list_for_each_safe(node, tmp, &pctldev->pinmux_hogs) {
-		struct pinmux_hog *hog =
-			list_entry(node, struct pinmux_hog, node);
-		pinmux_disable(hog->pmx);
-		pinmux_put(hog->pmx);
+	mutex_lock(&pctldev->pinctrl_hogs_lock);
+	list_for_each_safe(node, tmp, &pctldev->pinctrl_hogs) {
+		struct pinctrl_hog *hog =
+			list_entry(node, struct pinctrl_hog, node);
+		pinctrl_disable(hog->p);
+		pinctrl_put(hog->p);
 		list_del(node);
 		kfree(hog);
 	}
-	mutex_unlock(&pctldev->pinmux_hogs_lock);
+	mutex_unlock(&pctldev->pinctrl_hogs_lock);
 }
 
 #ifdef CONFIG_DEBUG_FS
@@ -1085,11 +1086,11 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 static int pinmux_hogs_show(struct seq_file *s, void *what)
 {
 	struct pinctrl_dev *pctldev = s->private;
-	struct pinmux_hog *hog;
+	struct pinctrl_hog *hog;
 
-	seq_puts(s, "Pinmux map hogs held by device\n");
+	seq_puts(s, "Pin control map hogs held by device\n");
 
-	list_for_each_entry(hog, &pctldev->pinmux_hogs, node)
+	list_for_each_entry(hog, &pctldev->pinctrl_hogs, node)
 		seq_printf(s, "%s\n", hog->map->name);
 
 	return 0;
@@ -1097,11 +1098,11 @@ static int pinmux_hogs_show(struct seq_file *s, void *what)
 
 static int pinmux_show(struct seq_file *s, void *what)
 {
-	struct pinmux *pmx;
+	struct pinctrl *p;
 
 	seq_puts(s, "Requested pinmuxes and their maps:\n");
-	list_for_each_entry(pmx, &pinmux_list, node) {
-		struct pinctrl_dev *pctldev = pmx->pctldev;
+	list_for_each_entry(p, &pinctrl_list, node) {
+		struct pinctrl_dev *pctldev = p->pctldev;
 		const struct pinmux_ops *pmxops;
 		const struct pinctrl_ops *pctlops;
 		struct pinmux_group *grp;
@@ -1115,13 +1116,13 @@ static int pinmux_show(struct seq_file *s, void *what)
 		pctlops = pctldev->desc->pctlops;
 
 		seq_printf(s, "device: %s function: %s (%u),",
-			   pinctrl_dev_get_name(pmx->pctldev),
+			   pinctrl_dev_get_name(p->pctldev),
 			   pmxops->get_function_name(pctldev,
-				   pmx->func_selector),
-			   pmx->func_selector);
+				   p->func_selector),
+			   p->func_selector);
 
 		seq_printf(s, " groups: [");
-		list_for_each_entry(grp, &pmx->groups, node) {
+		list_for_each_entry(grp, &p->groups, node) {
 			seq_printf(s, " %s (%u)",
 				   pctlops->get_group_name(pctldev,
 					   grp->group_selector),
@@ -1130,21 +1131,21 @@ static int pinmux_show(struct seq_file *s, void *what)
 		seq_printf(s, " ]");
 
 		seq_printf(s, " users: %u map-> %s\n",
-			   pmx->usecount,
-			   pmx->dev ? dev_name(pmx->dev) : "(system)");
+			   p->usecount,
+			   p->dev ? dev_name(p->dev) : "(system)");
 	}
 
 	return 0;
 }
 
-static int pinmux_maps_show(struct seq_file *s, void *what)
+static int pinctrl_maps_show(struct seq_file *s, void *what)
 {
 	int i;
 
-	seq_puts(s, "Pinmux maps:\n");
+	seq_puts(s, "Pinctrl maps:\n");
 
-	for (i = 0; i < pinmux_maps_num; i++) {
-		struct pinmux_map const *map = &pinmux_maps[i];
+	for (i = 0; i < pinctrl_maps_num; i++) {
+		struct pinctrl_map const *map = &pinctrl_maps[i];
 
 		seq_printf(s, "%s:\n", map->name);
 		if (map->dev_name)
@@ -1181,9 +1182,9 @@ static int pinmux_open(struct inode *inode, struct file *file)
 	return single_open(file, pinmux_show, NULL);
 }
 
-static int pinmux_maps_open(struct inode *inode, struct file *file)
+static int pinctrl_maps_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, pinmux_maps_show, NULL);
+	return single_open(file, pinctrl_maps_show, NULL);
 }
 
 static const struct file_operations pinmux_functions_ops = {
@@ -1214,8 +1215,8 @@ static const struct file_operations pinmux_ops = {
 	.release	= single_release,
 };
 
-static const struct file_operations pinmux_maps_ops = {
-	.open		= pinmux_maps_open,
+static const struct file_operations pinctrl_maps_ops = {
+	.open		= pinctrl_maps_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= single_release,
@@ -1236,8 +1237,8 @@ void pinmux_init_debugfs(struct dentry *subsys_root)
 {
 	debugfs_create_file("pinmuxes", S_IFREG | S_IRUGO,
 			    subsys_root, NULL, &pinmux_ops);
-	debugfs_create_file("pinmux-maps", S_IFREG | S_IRUGO,
-			    subsys_root, NULL, &pinmux_maps_ops);
+	debugfs_create_file("pinctrl-maps", S_IFREG | S_IRUGO,
+			    subsys_root, NULL, &pinctrl_maps_ops);
 }
 
 #endif /* CONFIG_DEBUG_FS */

commit 9dfac4fd7f8cdcdf734dff2ccc7ca467f53f1cfd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 1 18:02:47 2012 +0100

    pinctrl: delete raw device pointers in pinmux maps
    
    After discussion with Mark Brown in an unrelated thread about
    ADC lookups, it came to my knowledge that the ability to pass
    a struct device * in the regulator consumers is just a
    historical artifact, and not really recommended. Since there
    are no in-kernel users of these pointers, we just kill them
    right now, before someone starts to use them.
    
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 7c3193f7a044..1311f1d22002 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -354,7 +354,7 @@ int __init pinmux_register_mappings(struct pinmux_map const *maps,
 			return -EINVAL;
 		}
 
-		if (!maps[i].ctrl_dev && !maps[i].ctrl_dev_name) {
+		if (!maps[i].ctrl_dev_name) {
 			pr_err("failed to register map %s (%d): no pin control device given\n",
 			       maps[i].name, i);
 			return -EINVAL;
@@ -366,7 +366,7 @@ int __init pinmux_register_mappings(struct pinmux_map const *maps,
 			return -EINVAL;
 		}
 
-		if (!maps[i].dev && !maps[i].dev_name)
+		if (!maps[i].dev_name)
 			pr_debug("add system map %s function %s with no device\n",
 				 maps[i].name,
 				 maps[i].function);
@@ -721,20 +721,12 @@ struct pinmux *pinmux_get(struct device *dev, const char *name)
 		/*
 		 * First, try to find the pctldev given in the map
 		 */
-		pctldev = get_pinctrl_dev_from_dev(map->ctrl_dev,
-						   map->ctrl_dev_name);
+		pctldev = get_pinctrl_dev_from_devname(map->ctrl_dev_name);
 		if (!pctldev) {
-			const char *devname = NULL;
-
-			if (map->ctrl_dev)
-				devname = dev_name(map->ctrl_dev);
-			else if (map->ctrl_dev_name)
-				devname = map->ctrl_dev_name;
-
 			pr_warning("could not find a pinctrl device for pinmux function %s, fishy, they shall all have one\n",
 				   map->function);
 			pr_warning("given pinctrl device name: %s",
-				   devname ? devname : "UNDEFINED");
+				   map->ctrl_dev_name);
 
 			/* Continue to check the other mappings anyway... */
 			continue;
@@ -925,7 +917,7 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
 	struct pinmux *pmx;
 	int ret;
 
-	if (map->dev || map->dev_name) {
+	if (map->dev_name) {
 		/*
 		 * TODO: the day we have device tree support, we can
 		 * traverse the device tree and hog to specific device nodes
@@ -996,9 +988,8 @@ int pinmux_hog_maps(struct pinctrl_dev *pctldev)
 		if (!map->hog_on_boot)
 			continue;
 
-		if ((map->ctrl_dev == dev) ||
-			(map->ctrl_dev_name &&
-				!strcmp(map->ctrl_dev_name, devname))) {
+		if (map->ctrl_dev_name &&
+		    !strcmp(map->ctrl_dev_name, devname)) {
 			/* OK time to hog! */
 			ret = pinmux_hog_map(pctldev, map);
 			if (ret)
@@ -1156,14 +1147,12 @@ static int pinmux_maps_show(struct seq_file *s, void *what)
 		struct pinmux_map const *map = &pinmux_maps[i];
 
 		seq_printf(s, "%s:\n", map->name);
-		if (map->dev || map->dev_name)
+		if (map->dev_name)
 			seq_printf(s, "  device: %s\n",
-				   map->dev ? dev_name(map->dev) :
 				   map->dev_name);
 		else
 			seq_printf(s, "  SYSTEM MUX\n");
 		seq_printf(s, "  controlling device %s\n",
-			   map->ctrl_dev ? dev_name(map->ctrl_dev) :
 			   map->ctrl_dev_name);
 		seq_printf(s, "  function: %s\n", map->function);
 		seq_printf(s, "  group: %s\n", map->group ? map->group :

commit b9130b776ee481acbc27a7e56d98df75680de369
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 24 16:28:08 2012 -0800

    pinctrl: add checks for empty function names
    
    This is needed as otherwise we can get the following when
    dealing with buggy data in a pinmux driver for
    pinmux_search_function:
    
    Unable to handle kernel NULL pointer dereference at virtual
    address 00000000
    ...
    PC is at strcmp+0xc/0x34
    LR is at pinmux_get+0x350/0x8f4
    ...
    
    As we need pctldev initialized to call ops->list_functions,
    let's initialize it before check_ops calls and pass the
    pctldev to the check_ops functions. Do this for both pinmux
    and pinconf check_ops functions.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 3ffa9324ed82..7c3193f7a044 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -889,8 +889,11 @@ void pinmux_disable(struct pinmux *pmx)
 }
 EXPORT_SYMBOL_GPL(pinmux_disable);
 
-int pinmux_check_ops(const struct pinmux_ops *ops)
+int pinmux_check_ops(struct pinctrl_dev *pctldev)
 {
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	unsigned selector = 0;
+
 	/* Check that we implement required operations */
 	if (!ops->list_functions ||
 	    !ops->get_function_name ||
@@ -899,6 +902,18 @@ int pinmux_check_ops(const struct pinmux_ops *ops)
 	    !ops->disable)
 		return -EINVAL;
 
+	/* Check that all functions registered have names */
+	while (ops->list_functions(pctldev, selector) >= 0) {
+		const char *fname = ops->get_function_name(pctldev,
+							   selector);
+		if (!fname) {
+			pr_err("pinmux ops has no name for function%u\n",
+				selector);
+			return -EINVAL;
+		}
+		selector++;
+	}
+
 	return 0;
 }
 

commit 9e2551e10b5c7ba550849bd9ed519e498cc30e68
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 20 07:43:53 2012 -0800

    pinctrl: fix pinmux_hog_maps when ctrl_dev_name is not set
    
    The ctrl_dev_name is optional for struct pinmux_map assuming
    that ctrl_dev is set. Without this patch we can get:
    
    Unable to handle kernel NULL pointer dereference at virtual
    address 00000000
    ...
    (pinmux_hog_maps+0xa4/0x20c)
    (pinctrl_register+0x2a4/0x378)
    ...
    
    Fix this by adding adding a test for map->ctrl_dev.
    Additionally move the test for map->ctrl_dev earlier
    to optimize out the loop a bit.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index f4f8c7e4b1c8..3ffa9324ed82 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -978,9 +978,12 @@ int pinmux_hog_maps(struct pinctrl_dev *pctldev)
 	for (i = 0; i < pinmux_maps_num; i++) {
 		struct pinmux_map const *map = &pinmux_maps[i];
 
-		if (((map->ctrl_dev == dev) ||
-		     !strcmp(map->ctrl_dev_name, devname)) &&
-		    map->hog_on_boot) {
+		if (!map->hog_on_boot)
+			continue;
+
+		if ((map->ctrl_dev == dev) ||
+			(map->ctrl_dev_name &&
+				!strcmp(map->ctrl_dev_name, devname))) {
 			/* OK time to hog! */
 			ret = pinmux_hog_map(pctldev, map);
 			if (ret)

commit de849eecd0addaa6bf60f2f7be36b30abf9ff2ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 20 08:17:33 2012 -0800

    pinctrl: fix some pinmux typos
    
    Fix some pinmux typos so implementing pinmux drivers
    is a bit easier.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 0b22037965b9..f4f8c7e4b1c8 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -53,11 +53,6 @@ struct pinmux_group {
  * @dev: the device using this pinmux
  * @usecount: the number of active users of this mux setting, used to keep
  *	track of nested use cases
- * @pins: an array of discrete physical pins used in this mapping, taken
- *	from the global pin enumeration space (copied from pinmux map)
- * @num_pins: the number of pins in this mapping array, i.e. the number of
- *	elements in .pins so we can iterate over that array (copied from
- *	pinmux map)
  * @pctldev: pin control device handling this pinmux
  * @func_selector: the function selector for the pinmux device handling
  *	this pinmux
@@ -409,7 +404,7 @@ int __init pinmux_register_mappings(struct pinmux_map const *maps,
 }
 
 /**
- * acquire_pins() - acquire all the pins for a certain funcion on a pinmux
+ * acquire_pins() - acquire all the pins for a certain function on a pinmux
  * @pctldev: the device to take the pins on
  * @func_selector: the function selector to acquire the pins for
  * @group_selector: the group selector containing the pins to acquire
@@ -455,7 +450,7 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 
 /**
  * release_pins() - release pins taken by earlier acquirement
- * @pctldev: the device to free the pinx on
+ * @pctldev: the device to free the pins on
  * @group_selector: the group selector containing the pins to free
  */
 static void release_pins(struct pinctrl_dev *pctldev,

commit f9d41d7cb5a3a4fe9585d47e518d779d2aef8c94
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Jan 19 22:42:48 2012 +0100

    pinctrl: unbreak error messages
    
    It's better to not line break error messages to allow easier grepping
    for them even when the line gets >80 chars. Additionally some minor
    reformating is done.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index a76a348321bb..0b22037965b9 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -152,8 +152,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		status = 0;
 
 	if (status)
-		dev_err(pctldev->dev, "->request on device %s failed "
-		       "for pin %d\n",
+		dev_err(pctldev->dev, "->request on device %s failed for pin %d\n",
 		       pctldev->desc->name, pin);
 out_free_pin:
 	if (status) {
@@ -355,21 +354,20 @@ int __init pinmux_register_mappings(struct pinmux_map const *maps,
 	/* First sanity check the new mapping */
 	for (i = 0; i < num_maps; i++) {
 		if (!maps[i].name) {
-			pr_err("failed to register map %d: "
-			       "no map name given\n", i);
+			pr_err("failed to register map %d: no map name given\n",
+					i);
 			return -EINVAL;
 		}
 
 		if (!maps[i].ctrl_dev && !maps[i].ctrl_dev_name) {
-			pr_err("failed to register map %s (%d): "
-			       "no pin control device given\n",
+			pr_err("failed to register map %s (%d): no pin control device given\n",
 			       maps[i].name, i);
 			return -EINVAL;
 		}
 
 		if (!maps[i].function) {
-			pr_err("failed to register map %s (%d): "
-			       "no function ID given\n", maps[i].name, i);
+			pr_err("failed to register map %s (%d): no function ID given\n",
+					maps[i].name, i);
 			return -EINVAL;
 		}
 
@@ -442,8 +440,7 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 		ret = pin_request(pctldev, pins[i], func, NULL);
 		if (ret) {
 			dev_err(pctldev->dev,
-				"could not get pin %d for function %s "
-				"on device %s - conflicting mux mappings?\n",
+				"could not get pin %d for function %s on device %s - conflicting mux mappings?\n",
 				pins[i], func ? : "(undefined)",
 				pinctrl_dev_get_name(pctldev));
 			/* On error release all taken pins */
@@ -473,8 +470,7 @@ static void release_pins(struct pinctrl_dev *pctldev,
 	ret = pctlops->get_group_pins(pctldev, group_selector,
 				      &pins, &num_pins);
 	if (ret) {
-		dev_err(pctldev->dev, "could not get pins to release for "
-			"group selector %d\n",
+		dev_err(pctldev->dev, "could not get pins to release for group selector %d\n",
 			group_selector);
 		return;
 	}
@@ -526,8 +522,7 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
 		ret = pinctrl_get_group_selector(pctldev, groups[0]);
 		if (ret < 0) {
 			dev_err(pctldev->dev,
-				"function %s wants group %s but the pin "
-				"controller does not seem to have that group\n",
+				"function %s wants group %s but the pin controller does not seem to have that group\n",
 				pmxops->get_function_name(pctldev, func_selector),
 				groups[0]);
 			return ret;
@@ -535,8 +530,7 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
 
 		if (num_groups > 1)
 			dev_dbg(pctldev->dev,
-				"function %s support more than one group, "
-				"default-selecting first group %s (%d)\n",
+				"function %s support more than one group, default-selecting first group %s (%d)\n",
 				pmxops->get_function_name(pctldev, func_selector),
 				groups[0],
 				ret);
@@ -628,10 +622,8 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 
 	if (pmx->pctldev && pmx->pctldev != pctldev) {
 		dev_err(pctldev->dev,
-			"different pin control devices given for device %s, "
-			"function %s\n",
-			devname,
-			map->function);
+			"different pin control devices given for device %s, function %s\n",
+			devname, map->function);
 		return -EINVAL;
 	}
 	pmx->dev = dev;
@@ -695,7 +687,6 @@ static void pinmux_free_groups(struct pinmux *pmx)
  */
 struct pinmux *pinmux_get(struct device *dev, const char *name)
 {
-
 	struct pinmux_map const *map = NULL;
 	struct pinctrl_dev *pctldev = NULL;
 	const char *devname = NULL;
@@ -745,8 +736,7 @@ struct pinmux *pinmux_get(struct device *dev, const char *name)
 			else if (map->ctrl_dev_name)
 				devname = map->ctrl_dev_name;
 
-			pr_warning("could not find a pinctrl device for pinmux "
-				   "function %s, fishy, they shall all have one\n",
+			pr_warning("could not find a pinctrl device for pinmux function %s, fishy, they shall all have one\n",
 				   map->function);
 			pr_warning("given pinctrl device name: %s",
 				   devname ? devname : "UNDEFINED");
@@ -932,8 +922,8 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
 		 * without any problems, so then we can hog pinmuxes for
 		 * all devices that just want a static pin mux at this point.
 		 */
-		dev_err(pctldev->dev, "map %s wants to hog a non-system "
-			"pinmux, this is not going to work\n", map->name);
+		dev_err(pctldev->dev, "map %s wants to hog a non-system pinmux, this is not going to work\n",
+				map->name);
 		return -EINVAL;
 	}
 
@@ -1122,13 +1112,15 @@ static int pinmux_show(struct seq_file *s, void *what)
 
 		seq_printf(s, "device: %s function: %s (%u),",
 			   pinctrl_dev_get_name(pmx->pctldev),
-			   pmxops->get_function_name(pctldev, pmx->func_selector),
+			   pmxops->get_function_name(pctldev,
+				   pmx->func_selector),
 			   pmx->func_selector);
 
 		seq_printf(s, " groups: [");
 		list_for_each_entry(grp, &pmx->groups, node) {
 			seq_printf(s, " %s (%u)",
-				   pctlops->get_group_name(pctldev, grp->group_selector),
+				   pctlops->get_group_name(pctldev,
+					   grp->group_selector),
 				   grp->group_selector);
 		}
 		seq_printf(s, " ]");

commit 706e8520e8450a631ca6f798f8c811faf56f0a59
Author: Chanho Park <chanho61.park@samsung.com>
Date:   Tue Jan 3 16:47:50 2012 +0900

    pinctrl: correct a offset while enumerating pins
    
    This patch modifies a offset while enumerating pins to support a
    partial pin space. If we use a pin number for enumerating pins,
    the pin space always starts with zero base. Indeed, we always check
    the pin is in the pin space. An extreme example, there is only two pins.
    One is 0. Another is 1000. We always enumerate whole offsets until 1000.
    For solving this problem, we use the offset of the pin array instead
    of the zero-based pin number.
    
    Signed-off-by: Chanho Park <chanho61.park@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    [Restored sparse pin space comment]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 0916222dd7d2..a76a348321bb 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -1063,18 +1063,19 @@ static int pinmux_functions_show(struct seq_file *s, void *what)
 static int pinmux_pins_show(struct seq_file *s, void *what)
 {
 	struct pinctrl_dev *pctldev = s->private;
-	unsigned pin;
+	unsigned i, pin;
 
 	seq_puts(s, "Pinmux settings per pin\n");
 	seq_puts(s, "Format: pin (name): pinmuxfunction\n");
 
-	/* The highest pin number need to be included in the loop, thus <= */
-	for (pin = 0; pin <= pctldev->desc->maxpin; pin++) {
+	/* The pin number can be retrived from the pin controller descriptor */
+	for (i = 0; i < pctldev->desc->npins; i++) {
 
 		struct pin_desc *desc;
 
+		pin = pctldev->desc->pins[i].number;
 		desc = pin_desc_get(pctldev, pin);
-		/* Pin space may be sparse */
+		/* Skip if we cannot search the pin */
 		if (desc == NULL)
 			continue;
 

commit e6337c3c96a7ee5cfd5e7afed825f894d4576f58
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Tue Dec 20 17:51:59 2011 +0800

    pinctrl: some typo fixes
    
    Minor copyedits.
    
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 3bcc64137ddc..0916222dd7d2 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -342,7 +342,7 @@ EXPORT_SYMBOL_GPL(pinmux_gpio_direction_output);
  * Only call this once during initialization of your machine, the function is
  * tagged as __init and won't be callable after init has completed. The map
  * passed into this function will be owned by the pinmux core and cannot be
- * free:d.
+ * freed.
  */
 int __init pinmux_register_mappings(struct pinmux_map const *maps,
 				    unsigned num_maps)

commit 51cd24ee625c348654114032499914d0311e5832
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Dec 9 16:59:05 2011 -0700

    pinctrl: don't create a device for each pin controller
    
    Pin controllers should already be instantiated as a device, so there's
    no need for the pinctrl core to create a new struct device for each
    controller.
    
    This allows the controller's real name to be used in the mux mapping
    table, rather than e.g. "pinctrl.0", "pinctrl.1", etc.
    
    This necessitates removal of the PINMUX_MAP_PRIMARY*() macros, since
    their sole purpose was to hard-code the .ctrl_dev_name field to be
    "pinctrl.0".
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index a11681b4bd91..3bcc64137ddc 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -106,24 +106,24 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	int status = -EINVAL;
 
-	dev_dbg(&pctldev->dev, "request pin %d for %s\n", pin, function);
+	dev_dbg(pctldev->dev, "request pin %d for %s\n", pin, function);
 
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"pin is not registered so it cannot be requested\n");
 		goto out;
 	}
 
 	if (!function) {
-		dev_err(&pctldev->dev, "no function name given\n");
+		dev_err(pctldev->dev, "no function name given\n");
 		return -EINVAL;
 	}
 
 	spin_lock(&desc->lock);
 	if (desc->mux_function) {
 		spin_unlock(&desc->lock);
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"pin already requested\n");
 		goto out;
 	}
@@ -132,7 +132,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 
 	/* Let each pin increase references to this module */
 	if (!try_module_get(pctldev->owner)) {
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"could not increase module refcount for pin %d\n",
 			pin);
 		status = -EINVAL;
@@ -152,7 +152,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		status = 0;
 
 	if (status)
-		dev_err(&pctldev->dev, "->request on device %s failed "
+		dev_err(pctldev->dev, "->request on device %s failed "
 		       "for pin %d\n",
 		       pctldev->desc->name, pin);
 out_free_pin:
@@ -163,7 +163,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	}
 out:
 	if (status)
-		dev_err(&pctldev->dev, "pin-%d (%s) status %d\n",
+		dev_err(pctldev->dev, "pin-%d (%s) status %d\n",
 		       pin, function ? : "?", status);
 
 	return status;
@@ -189,7 +189,7 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"pin is not registered so it cannot be freed\n");
 		return NULL;
 	}
@@ -434,14 +434,14 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 	if (ret)
 		return ret;
 
-	dev_dbg(&pctldev->dev, "requesting the %u pins from group %u\n",
+	dev_dbg(pctldev->dev, "requesting the %u pins from group %u\n",
 		num_pins, group_selector);
 
 	/* Try to allocate all pins in this group, one by one */
 	for (i = 0; i < num_pins; i++) {
 		ret = pin_request(pctldev, pins[i], func, NULL);
 		if (ret) {
-			dev_err(&pctldev->dev,
+			dev_err(pctldev->dev,
 				"could not get pin %d for function %s "
 				"on device %s - conflicting mux mappings?\n",
 				pins[i], func ? : "(undefined)",
@@ -473,7 +473,7 @@ static void release_pins(struct pinctrl_dev *pctldev,
 	ret = pctlops->get_group_pins(pctldev, group_selector,
 				      &pins, &num_pins);
 	if (ret) {
-		dev_err(&pctldev->dev, "could not get pins to release for "
+		dev_err(pctldev->dev, "could not get pins to release for "
 			"group selector %d\n",
 			group_selector);
 		return;
@@ -525,7 +525,7 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
 			return -EINVAL;
 		ret = pinctrl_get_group_selector(pctldev, groups[0]);
 		if (ret < 0) {
-			dev_err(&pctldev->dev,
+			dev_err(pctldev->dev,
 				"function %s wants group %s but the pin "
 				"controller does not seem to have that group\n",
 				pmxops->get_function_name(pctldev, func_selector),
@@ -534,7 +534,7 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
 		}
 
 		if (num_groups > 1)
-			dev_dbg(&pctldev->dev,
+			dev_dbg(pctldev->dev,
 				"function %s support more than one group, "
 				"default-selecting first group %s (%d)\n",
 				pmxops->get_function_name(pctldev, func_selector),
@@ -544,13 +544,13 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
 		return ret;
 	}
 
-	dev_dbg(&pctldev->dev,
+	dev_dbg(pctldev->dev,
 		"check if we have pin group %s on controller %s\n",
 		pin_group, pinctrl_dev_get_name(pctldev));
 
 	ret = pinctrl_get_group_selector(pctldev, pin_group);
 	if (ret < 0) {
-		dev_dbg(&pctldev->dev,
+		dev_dbg(pctldev->dev,
 			"%s does not support pin group %s with function %s\n",
 			pinctrl_dev_get_name(pctldev),
 			pin_group,
@@ -627,7 +627,7 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	 */
 
 	if (pmx->pctldev && pmx->pctldev != pctldev) {
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"different pin control devices given for device %s, "
 			"function %s\n",
 			devname,
@@ -650,7 +650,7 @@ static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
 	 */
 	if (pmx->func_selector != UINT_MAX &&
 	    pmx->func_selector != func_selector) {
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"dual function defines in the map for device %s\n",
 		       devname);
 		return -EINVAL;
@@ -756,7 +756,7 @@ struct pinmux *pinmux_get(struct device *dev, const char *name)
 		}
 
 		pr_debug("in map, found pctldev %s to handle function %s",
-			 dev_name(&pctldev->dev), map->function);
+			 dev_name(pctldev->dev), map->function);
 
 
 		/*
@@ -932,7 +932,7 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
 		 * without any problems, so then we can hog pinmuxes for
 		 * all devices that just want a static pin mux at this point.
 		 */
-		dev_err(&pctldev->dev, "map %s wants to hog a non-system "
+		dev_err(pctldev->dev, "map %s wants to hog a non-system "
 			"pinmux, this is not going to work\n", map->name);
 		return -EINVAL;
 	}
@@ -944,7 +944,7 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
 	pmx = pinmux_get(NULL, map->name);
 	if (IS_ERR(pmx)) {
 		kfree(hog);
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"could not get the %s pinmux mapping for hogging\n",
 			map->name);
 		return PTR_ERR(pmx);
@@ -954,7 +954,7 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
 	if (ret) {
 		pinmux_put(pmx);
 		kfree(hog);
-		dev_err(&pctldev->dev,
+		dev_err(pctldev->dev,
 			"could not enable the %s pinmux mapping for hogging\n",
 			map->name);
 		return ret;
@@ -963,7 +963,7 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
 	hog->map = map;
 	hog->pmx = pmx;
 
-	dev_info(&pctldev->dev, "hogged map %s, function %s\n", map->name,
+	dev_info(pctldev->dev, "hogged map %s, function %s\n", map->name,
 		 map->function);
 	mutex_lock(&pctldev->pinmux_hogs_lock);
 	list_add(&hog->node, &pctldev->pinmux_hogs);
@@ -982,7 +982,7 @@ static int pinmux_hog_map(struct pinctrl_dev *pctldev,
  */
 int pinmux_hog_maps(struct pinctrl_dev *pctldev)
 {
-	struct device *dev = &pctldev->dev;
+	struct device *dev = pctldev->dev;
 	const char *devname = dev_name(dev);
 	int ret;
 	int i;

commit 59b099b04981917ee7fbd88b6f50eeaffc9f33cd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 30 13:28:14 2011 +0100

    pinctrl: make it possible to add multiple maps
    
    Since we now anyway make a copy of the platform-supplied pinmux
    map, we can just as well make it possible to call the function
    adding maps several times, so as to simplify cases (as PXA) where
    several sets of disparate mappings need to be added depending on
    target platform.
    
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: Arnd Bergmann <arnd@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index f6e7d583998c..a11681b4bd91 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -33,7 +33,7 @@
 static DEFINE_MUTEX(pinmux_list_mutex);
 static LIST_HEAD(pinmux_list);
 
-/* Global pinmux maps, we allow one set only */
+/* Global pinmux maps */
 static struct pinmux_map *pinmux_maps;
 static unsigned pinmux_maps_num;
 
@@ -347,48 +347,30 @@ EXPORT_SYMBOL_GPL(pinmux_gpio_direction_output);
 int __init pinmux_register_mappings(struct pinmux_map const *maps,
 				    unsigned num_maps)
 {
-	int ret = 0;
+	void *tmp_maps;
 	int i;
 
-	if (pinmux_maps_num != 0) {
-		pr_err("pinmux mappings already registered, you can only "
-		       "register one set of maps\n");
-		return -EINVAL;
-	}
-
 	pr_debug("add %d pinmux maps\n", num_maps);
 
-	/*
-	 * Make a copy of the map array - string pointers will end up in the
-	 * kernel const section anyway so these do not need to be deep copied.
-	 */
-	pinmux_maps = kmemdup(maps, sizeof(struct pinmux_map) * num_maps,
-			      GFP_KERNEL);
-	if (!pinmux_maps)
-		return -ENOMEM;
-
+	/* First sanity check the new mapping */
 	for (i = 0; i < num_maps; i++) {
-		/* Sanity check the mapping while copying it */
 		if (!maps[i].name) {
 			pr_err("failed to register map %d: "
 			       "no map name given\n", i);
-			ret = -EINVAL;
-			goto err_out_free;
+			return -EINVAL;
 		}
 
 		if (!maps[i].ctrl_dev && !maps[i].ctrl_dev_name) {
 			pr_err("failed to register map %s (%d): "
 			       "no pin control device given\n",
 			       maps[i].name, i);
-			ret = -EINVAL;
-			goto err_out_free;
+			return -EINVAL;
 		}
 
 		if (!maps[i].function) {
 			pr_err("failed to register map %s (%d): "
 			       "no function ID given\n", maps[i].name, i);
-			ret = -EINVAL;
-			goto err_out_free;
+			return -EINVAL;
 		}
 
 		if (!maps[i].dev && !maps[i].dev_name)
@@ -399,17 +381,33 @@ int __init pinmux_register_mappings(struct pinmux_map const *maps,
 			pr_debug("register map %s, function %s\n",
 				 maps[i].name,
 				 maps[i].function);
+	}
 
-		pinmux_maps_num++;
+	/*
+	 * Make a copy of the map array - string pointers will end up in the
+	 * kernel const section anyway so these do not need to be deep copied.
+	 */
+	if (!pinmux_maps_num) {
+		/* On first call, just copy them */
+		tmp_maps = kmemdup(maps,
+				   sizeof(struct pinmux_map) * num_maps,
+				   GFP_KERNEL);
+		if (!tmp_maps)
+			return -ENOMEM;
+	} else {
+		/* Subsequent calls, reallocate array to new size */
+		size_t oldsize = sizeof(struct pinmux_map) * pinmux_maps_num;
+		size_t newsize = sizeof(struct pinmux_map) * num_maps;
+
+		tmp_maps = krealloc(pinmux_maps, oldsize + newsize, GFP_KERNEL);
+		if (!tmp_maps)
+			return -ENOMEM;
+		memcpy((tmp_maps + oldsize), maps, newsize);
 	}
 
+	pinmux_maps = tmp_maps;
+	pinmux_maps_num += num_maps;
 	return 0;
-
-err_out_free:
-	kfree(pinmux_maps);
-	pinmux_maps = NULL;
-	pinmux_maps_num = 0;
-	return ret;
 }
 
 /**

commit 97607d157c133ab18dfcd77fa836e37fa950a44a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 29 12:52:39 2011 +0100

    pinctrl: make a copy of pinmux map
    
    This makes a deep copy of the pinmux function map instead of
    keeping the copy supplied from the platform around. This makes
    it possible to tag the platforms map with __initdata as is also
    done as part of this patch.
    
    Rationale: a certain target platform (PXA) has numerous
    pinmux maps, many of which will be lying around unused after
    boot in a multi-platform binary. Instead, deep-copy the one
    we're going to use and tag them all __initdata so they go away
    after boot.
    
    ChangeLog v1->v2:
    - Fixup the deep copy, missed a few items on the struct,
      plus mark bool member non-const since we're making runtime
      copies if this stuff now.
    ChangeLog v2->v3:
    - Make a shallow copy (just copy the array of map structs)
      as Arnd noticed, string constants never get discarded by the
      kernel anyway, so these pointers may be safely copied over.
    
    Reviewed-by: Arnd Bergmann <arnd.bergmann@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index f3e4f031fe1c..f6e7d583998c 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -21,6 +21,7 @@
 #include <linux/list.h>
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
+#include <linux/string.h>
 #include <linux/sysfs.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
@@ -33,7 +34,7 @@ static DEFINE_MUTEX(pinmux_list_mutex);
 static LIST_HEAD(pinmux_list);
 
 /* Global pinmux maps, we allow one set only */
-static struct pinmux_map const *pinmux_maps;
+static struct pinmux_map *pinmux_maps;
 static unsigned pinmux_maps_num;
 
 /**
@@ -333,7 +334,9 @@ EXPORT_SYMBOL_GPL(pinmux_gpio_direction_output);
 
 /**
  * pinmux_register_mappings() - register a set of pinmux mappings
- * @maps: the pinmux mappings table to register
+ * @maps: the pinmux mappings table to register, this should be marked with
+ *	__initdata so it can be discarded after boot, this function will
+ *	perform a shallow copy for the mapping entries.
  * @num_maps: the number of maps in the mapping table
  *
  * Only call this once during initialization of your machine, the function is
@@ -344,32 +347,48 @@ EXPORT_SYMBOL_GPL(pinmux_gpio_direction_output);
 int __init pinmux_register_mappings(struct pinmux_map const *maps,
 				    unsigned num_maps)
 {
+	int ret = 0;
 	int i;
 
-	if (pinmux_maps != NULL) {
+	if (pinmux_maps_num != 0) {
 		pr_err("pinmux mappings already registered, you can only "
 		       "register one set of maps\n");
 		return -EINVAL;
 	}
 
 	pr_debug("add %d pinmux maps\n", num_maps);
+
+	/*
+	 * Make a copy of the map array - string pointers will end up in the
+	 * kernel const section anyway so these do not need to be deep copied.
+	 */
+	pinmux_maps = kmemdup(maps, sizeof(struct pinmux_map) * num_maps,
+			      GFP_KERNEL);
+	if (!pinmux_maps)
+		return -ENOMEM;
+
 	for (i = 0; i < num_maps; i++) {
-		/* Sanity check the mapping */
+		/* Sanity check the mapping while copying it */
 		if (!maps[i].name) {
 			pr_err("failed to register map %d: "
 			       "no map name given\n", i);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto err_out_free;
 		}
+
 		if (!maps[i].ctrl_dev && !maps[i].ctrl_dev_name) {
 			pr_err("failed to register map %s (%d): "
 			       "no pin control device given\n",
 			       maps[i].name, i);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto err_out_free;
 		}
+
 		if (!maps[i].function) {
 			pr_err("failed to register map %s (%d): "
 			       "no function ID given\n", maps[i].name, i);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto err_out_free;
 		}
 
 		if (!maps[i].dev && !maps[i].dev_name)
@@ -380,12 +399,17 @@ int __init pinmux_register_mappings(struct pinmux_map const *maps,
 			pr_debug("register map %s, function %s\n",
 				 maps[i].name,
 				 maps[i].function);
-	}
 
-	pinmux_maps = maps;
-	pinmux_maps_num = num_maps;
+		pinmux_maps_num++;
+	}
 
 	return 0;
+
+err_out_free:
+	kfree(pinmux_maps);
+	pinmux_maps = NULL;
+	pinmux_maps_num = 0;
+	return ret;
 }
 
 /**

commit 542e704f3ffee1dc4539c9e8191e4dc215220f5e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Nov 14 10:06:22 2011 +0100

    pinctrl: GPIO direction support for muxing
    
    When requesting a single GPIO pin to be muxed in, some controllers
    will need to poke a different value into the control register
    depending on whether the pin will be used for GPIO output or GPIO
    input. So create pinmux counterparts to gpio_direction_[input|output]
    in the pinctrl framework.
    
    ChangeLog v1->v2:
    - This also amends the documentation to make it clear the this
      function and associated machinery is *ONLY* intended as a backend
      to gpiolib machinery, not for everyone and his dog to start playing
      around with pins.
    ChangeLog v2->v3:
    - Don't pass an argument to the common request function, instead
      provide pinmux_* counterparts to the gpio_direction_[input|output]
      calls, simpler and anyone can understand it.
    ChangeLog v3->v4:
    - Fix numerous spelling mistakes and dangling text in documentation.
      Add Ack and Rewewed-by.
    
    Cc: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Thomas Abraham <thomas.abraham@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 92aa13ee2208..f3e4f031fe1c 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -214,6 +214,10 @@ static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 /**
  * pinmux_request_gpio() - request a single pin to be muxed in as GPIO
  * @gpio: the GPIO pin number from the GPIO subsystem number space
+ *
+ * This function should *ONLY* be used from gpiolib-based GPIO drivers,
+ * as part of their gpio_request() semantics, platforms and individual drivers
+ * shall *NOT* request GPIO pins to be muxed in.
  */
 int pinmux_request_gpio(unsigned gpio)
 {
@@ -249,6 +253,10 @@ EXPORT_SYMBOL_GPL(pinmux_request_gpio);
 /**
  * pinmux_free_gpio() - free a single pin, currently used as GPIO
  * @gpio: the GPIO pin number from the GPIO subsystem number space
+ *
+ * This function should *ONLY* be used from gpiolib-based GPIO drivers,
+ * as part of their gpio_free() semantics, platforms and individual drivers
+ * shall *NOT* request GPIO pins to be muxed out.
  */
 void pinmux_free_gpio(unsigned gpio)
 {
@@ -270,6 +278,59 @@ void pinmux_free_gpio(unsigned gpio)
 }
 EXPORT_SYMBOL_GPL(pinmux_free_gpio);
 
+static int pinmux_gpio_direction(unsigned gpio, bool input)
+{
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_gpio_range *range;
+	const struct pinmux_ops *ops;
+	int ret;
+	int pin;
+
+	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
+	if (ret)
+		return ret;
+
+	ops = pctldev->desc->pmxops;
+
+	/* Convert to the pin controllers number space */
+	pin = gpio - range->base + range->pin_base;
+
+	if (ops->gpio_set_direction)
+		ret = ops->gpio_set_direction(pctldev, range, pin, input);
+	else
+		ret = 0;
+
+	return ret;
+}
+
+/**
+ * pinmux_gpio_direction_input() - request a GPIO pin to go into input mode
+ * @gpio: the GPIO pin number from the GPIO subsystem number space
+ *
+ * This function should *ONLY* be used from gpiolib-based GPIO drivers,
+ * as part of their gpio_direction_input() semantics, platforms and individual
+ * drivers shall *NOT* touch pinmux GPIO calls.
+ */
+int pinmux_gpio_direction_input(unsigned gpio)
+{
+	return pinmux_gpio_direction(gpio, true);
+}
+EXPORT_SYMBOL_GPL(pinmux_gpio_direction_input);
+
+/**
+ * pinmux_gpio_direction_output() - request a GPIO pin to go into output mode
+ * @gpio: the GPIO pin number from the GPIO subsystem number space
+ *
+ * This function should *ONLY* be used from gpiolib-based GPIO drivers,
+ * as part of their gpio_direction_output() semantics, platforms and individual
+ * drivers shall *NOT* touch pinmux GPIO calls.
+ */
+int pinmux_gpio_direction_output(unsigned gpio)
+{
+	return pinmux_gpio_direction(gpio, false);
+}
+EXPORT_SYMBOL_GPL(pinmux_gpio_direction_output);
+
 /**
  * pinmux_register_mappings() - register a set of pinmux mappings
  * @maps: the pinmux mappings table to register

commit 3c739ad0df5eb41cd7adad879eda6aa09879eb76
Author: Chanho Park <chanho61.park@samsung.com>
Date:   Fri Nov 11 18:47:58 2011 +0900

    pinctrl: add a pin_base for sparse gpio-ranges
    
    This patch enables mapping a base offset of gpio ranges with
    a pin offset even if does'nt matched. A base of pinctrl_gpio_range
    means a base offset of gpio. However, we cannot convert gpio to pin
    number for sparse gpio ranges just only using a gpio base offset.
    We can convert a gpio to real pin number(even if not matched) using
    a new pin_base which means a base pin offset of requested gpio range.
    Now, the pin control subsystem passes the pin base offset to the
    pinmux driver.
    
    For example, let's assume below two gpio ranges in the system.
    
    static struct pinctrl_gpio_range gpio_range_a = {
        .name = "chip a",
        .id = 0,
        .base = 32,
        .pin_base = 32,
        .npins = 16,
        .gc = &chip_a;
    };
    
    static struct pinctrl_gpio_range gpio_range_b = {
        .name = "chip b",
        .id = 0,
        .base = 48,
        .pin_base = 64,
        .npins = 8,
        .gc = &chip_b;
    };
    
    We can calucalate a exact pin ranges even if doesn't matched with gpio ranges.
    
    chip a:
        gpio-range : [32 .. 47]
        pin-range  : [32 .. 47]
    chip b:
        gpio-range : [48 .. 55]
        pin-range  : [64 .. 71]
    
    Signed-off-by: Chanho Park <chanho61.park@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index ee3aba78c3dd..92aa13ee2208 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -229,7 +229,7 @@ int pinmux_request_gpio(unsigned gpio)
 		return -EINVAL;
 
 	/* Convert to the pin controllers number space */
-	pin = gpio - range->base;
+	pin = gpio - range->base + range->pin_base;
 
 	/* Conjure some name stating what chip and pin this is taken by */
 	snprintf(gpiostr, 15, "%s:%d", range->name, gpio);
@@ -263,7 +263,7 @@ void pinmux_free_gpio(unsigned gpio)
 		return;
 
 	/* Convert to the pin controllers number space */
-	pin = gpio - range->base;
+	pin = gpio - range->base + range->pin_base;
 
 	func = pin_free(pctldev, pin, range);
 	kfree(func);

commit 336cdba09a5df706402628fb20b7660d186aff6c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Nov 10 09:27:41 2011 +0100

    pinctrl: documentation update
    
    Update the docs removing an obsolete __refdata tag and document
    the mysterious return value of pin_free(). And fixes up some various
    confusions in the pinctrl documentation.
    
    Reported-by: Rajendra Nayak <rnayak@ti.com>
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Reported-by: Thomas Abraham <thomas.abraham@linaro.org>
    Reported-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index c77aee5508fb..ee3aba78c3dd 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -174,6 +174,10 @@ static int pin_request(struct pinctrl_dev *pctldev,
  * @pin: the pin to free
  * @gpio_range: the range matching the GPIO pin if this is a request for a
  *	single GPIO pin
+ *
+ * This function returns a pointer to the function name in use. This is used
+ * for callers that dynamically allocate a function name so it can be freed
+ * once the pin is free. This is done for GPIO request functions.
  */
 static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
 			    struct pinctrl_gpio_range *gpio_range)
@@ -919,7 +923,7 @@ int pinmux_hog_maps(struct pinctrl_dev *pctldev)
 }
 
 /**
- * pinmux_hog_maps() - unhog specific map entries on controller device
+ * pinmux_unhog_maps() - unhog specific map entries on controller device
  * @pctldev: the pin control device to unhog entries on
  */
 void pinmux_unhog_maps(struct pinctrl_dev *pctldev)

commit 3712a3c488987849613a4ad74129e67e40b12b38
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Oct 21 12:25:53 2011 -0600

    pinctrl: add explicit gpio_disable_free pinmux_op
    
    Some pinctrl drivers (Tegra at least) program a pin to be a GPIO in a
    completely different manner than they select which function to mux out of
    that pin. In order to support a single "free" pinmux_op, the driver would
    need to maintain a per-pin state of requested-for-gpio vs. requested-for-
    function. However, that's a lot of work when the core already has explicit
    separate paths for gpio request/free and function request/free.
    
    So, add a gpio_disable_free op to struct pinmux_ops, and make pin_free()
    call it when appropriate.
    
    When doing this, I noticed that when calling pin_request():
    
        !!gpio == (gpio_range != NULL)
    
    ... and so I collapsed those two parameters in both pin_request(), and
    when adding writing the new code in pin_free().
    
    Also, for pin_free():
    
        !!free_func == (gpio_range != NULL)
    
    However, I didn't want pin_free() to know about the GPIO function naming
    special case, so instead, I reworked pin_free() to always return the pin's
    previously requested function, and now pinmux_free_gpio() calls
    kfree(function). This is much more balanced with the allocation having
    been performed in pinmux_request_gpio().
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 17c3931d5ef0..c77aee5508fb 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -94,12 +94,11 @@ struct pinmux_hog {
  * @function: a functional name to give to this pin, passed to the driver
  *	so it knows what function to mux in, e.g. the string "gpioNN"
  *	means that you want to mux in the pin for use as GPIO number NN
- * @gpio: if this request concerns a single GPIO pin
  * @gpio_range: the range matching the GPIO pin if this is a request for a
  *	single GPIO pin
  */
 static int pin_request(struct pinctrl_dev *pctldev,
-		       int pin, const char *function, bool gpio,
+		       int pin, const char *function,
 		       struct pinctrl_gpio_range *gpio_range)
 {
 	struct pin_desc *desc;
@@ -143,7 +142,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	 * If there is no kind of request function for the pin we just assume
 	 * we got it by default and proceed.
 	 */
-	if (gpio && ops->gpio_request_enable)
+	if (gpio_range && ops->gpio_request_enable)
 		/* This requests and enables a single GPIO pin */
 		status = ops->gpio_request_enable(pctldev, gpio_range, pin);
 	else if (ops->request)
@@ -173,29 +172,39 @@ static int pin_request(struct pinctrl_dev *pctldev,
  * pin_free() - release a single muxed in pin so something else can be muxed
  * @pctldev: pin controller device handling this pin
  * @pin: the pin to free
- * @free_func: whether to free the pin's assigned function name string
+ * @gpio_range: the range matching the GPIO pin if this is a request for a
+ *	single GPIO pin
  */
-static void pin_free(struct pinctrl_dev *pctldev, int pin, int free_func)
+static const char *pin_free(struct pinctrl_dev *pctldev, int pin,
+			    struct pinctrl_gpio_range *gpio_range)
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	struct pin_desc *desc;
+	const char *func;
 
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
 		dev_err(&pctldev->dev,
 			"pin is not registered so it cannot be freed\n");
-		return;
+		return NULL;
 	}
 
-	if (ops->free)
+	/*
+	 * If there is no kind of request function for the pin we just assume
+	 * we got it by default and proceed.
+	 */
+	if (gpio_range && ops->gpio_disable_free)
+		ops->gpio_disable_free(pctldev, gpio_range, pin);
+	else if (ops->free)
 		ops->free(pctldev, pin);
 
 	spin_lock(&desc->lock);
-	if (free_func)
-		kfree(desc->mux_function);
+	func = desc->mux_function;
 	desc->mux_function = NULL;
 	spin_unlock(&desc->lock);
 	module_put(pctldev->owner);
+
+	return func;
 }
 
 /**
@@ -225,7 +234,7 @@ int pinmux_request_gpio(unsigned gpio)
 	if (!function)
 		return -EINVAL;
 
-	ret = pin_request(pctldev, pin, function, true, range);
+	ret = pin_request(pctldev, pin, function, range);
 	if (ret < 0)
 		kfree(function);
 
@@ -243,6 +252,7 @@ void pinmux_free_gpio(unsigned gpio)
 	struct pinctrl_gpio_range *range;
 	int ret;
 	int pin;
+	const char *func;
 
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 	if (ret)
@@ -251,7 +261,8 @@ void pinmux_free_gpio(unsigned gpio)
 	/* Convert to the pin controllers number space */
 	pin = gpio - range->base;
 
-	pin_free(pctldev, pin, true);
+	func = pin_free(pctldev, pin, range);
+	kfree(func);
 }
 EXPORT_SYMBOL_GPL(pinmux_free_gpio);
 
@@ -341,7 +352,7 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 
 	/* Try to allocate all pins in this group, one by one */
 	for (i = 0; i < num_pins; i++) {
-		ret = pin_request(pctldev, pins[i], func, false, NULL);
+		ret = pin_request(pctldev, pins[i], func, NULL);
 		if (ret) {
 			dev_err(&pctldev->dev,
 				"could not get pin %d for function %s "
@@ -351,7 +362,7 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 			/* On error release all taken pins */
 			i--; /* this pin just failed */
 			for (; i >= 0; i--)
-				pin_free(pctldev, pins[i], false);
+				pin_free(pctldev, pins[i], NULL);
 			return -ENODEV;
 		}
 	}
@@ -381,7 +392,7 @@ static void release_pins(struct pinctrl_dev *pctldev,
 		return;
 	}
 	for (i = 0; i < num_pins; i++)
-		pin_free(pctldev, pins[i], false);
+		pin_free(pctldev, pins[i], NULL);
 }
 
 /**

commit d2f6a1c6fb0e510a24ccac066eefbcfd0c932858
Author: Marek Belisko <marek.belisko@open-nandra.com>
Date:   Wed Oct 26 22:57:20 2011 +0200

    pinctrl: remove double pin validity check.
    
    Function pin_is_valid just call pin_desc_get which is in pin_request
    call some line below. Remove pin_is_valid() check.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Marek Belisko <marek.belisko@open-nandra.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 72b760bc880a..17c3931d5ef0 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -108,16 +108,6 @@ static int pin_request(struct pinctrl_dev *pctldev,
 
 	dev_dbg(&pctldev->dev, "request pin %d for %s\n", pin, function);
 
-	if (!pin_is_valid(pctldev, pin)) {
-		dev_err(&pctldev->dev, "pin is invalid\n");
-		return -EINVAL;
-	}
-
-	if (!function) {
-		dev_err(&pctldev->dev, "no function name given\n");
-		return -EINVAL;
-	}
-
 	desc = pin_desc_get(pctldev, pin);
 	if (desc == NULL) {
 		dev_err(&pctldev->dev,
@@ -125,6 +115,11 @@ static int pin_request(struct pinctrl_dev *pctldev,
 		goto out;
 	}
 
+	if (!function) {
+		dev_err(&pctldev->dev, "no function name given\n");
+		return -EINVAL;
+	}
+
 	spin_lock(&desc->lock);
 	if (desc->mux_function) {
 		spin_unlock(&desc->lock);

commit 7afde8baa83b9ac409a6db86f27a41878aa6b33f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 19 17:07:16 2011 +0200

    pinctrl: move group lookup to core
    
    Now also the core needs to look up pin groups so move the lookup
    function there and expose it in the internal header.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index f2c84a90df14..72b760bc880a 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -389,37 +389,6 @@ static void release_pins(struct pinctrl_dev *pctldev,
 		pin_free(pctldev, pins[i], false);
 }
 
-/**
- * pinmux_get_group_selector() - returns the group selector for a group
- * @pctldev: the pin controller handling the group
- * @pin_group: the pin group to look up
- */
-static int pinmux_get_group_selector(struct pinctrl_dev *pctldev,
-				     const char *pin_group)
-{
-	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	unsigned group_selector = 0;
-
-	while (pctlops->list_groups(pctldev, group_selector) >= 0) {
-		const char *gname = pctlops->get_group_name(pctldev,
-							    group_selector);
-		if (!strcmp(gname, pin_group)) {
-			dev_dbg(&pctldev->dev,
-				"found group selector %u for %s\n",
-				group_selector,
-				pin_group);
-			return group_selector;
-		}
-
-		group_selector++;
-	}
-
-	dev_err(&pctldev->dev, "does not have pin group %s\n",
-		pin_group);
-
-	return -EINVAL;
-}
-
 /**
  * pinmux_check_pin_group() - check function and pin group combo
  * @pctldev: device to check the pin group vs function for
@@ -461,7 +430,7 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
 			return ret;
 		if (num_groups < 1)
 			return -EINVAL;
-		ret = pinmux_get_group_selector(pctldev, groups[0]);
+		ret = pinctrl_get_group_selector(pctldev, groups[0]);
 		if (ret < 0) {
 			dev_err(&pctldev->dev,
 				"function %s wants group %s but the pin "
@@ -486,7 +455,7 @@ static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
 		"check if we have pin group %s on controller %s\n",
 		pin_group, pinctrl_dev_get_name(pctldev));
 
-	ret = pinmux_get_group_selector(pctldev, pin_group);
+	ret = pinctrl_get_group_selector(pctldev, pin_group);
 	if (ret < 0) {
 		dev_dbg(&pctldev->dev,
 			"%s does not support pin group %s with function %s\n",

commit cc96ffbb744bff2826aa9e62b14bb599b1f15fc3
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Dec 8 15:52:15 2011 +0100

    pinctrl: remove two unused global variables
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index a5467f8709e9..f2c84a90df14 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -32,10 +32,6 @@
 static DEFINE_MUTEX(pinmux_list_mutex);
 static LIST_HEAD(pinmux_list);
 
-/* List of pinmux hogs */
-static DEFINE_MUTEX(pinmux_hoglist_mutex);
-static LIST_HEAD(pinmux_hoglist);
-
 /* Global pinmux maps, we allow one set only */
 static struct pinmux_map const *pinmux_maps;
 static unsigned pinmux_maps_num;

commit 5d2eaf8090874f8e65388e82f7e91f9cef74885e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Oct 19 16:19:28 2011 -0600

    pinctrl: Don't copy function name when requesting a pin
    
    Instead, store a pointer to the currently assigned function.
    
    This allows us to delete the mux_requested variable from pin_desc; a pin
    is requested if its currently assigned function is non-NULL.
    
    When a pin is requested as a GPIO rather than a regular function, the
    assigned function name is dynamically constructed. In this case, we have
    to kstrdup() the dynamically constructed name, so that mux_function doesn't
    pointed at stack data. This requires pin_free to be told whether to free
    the mux_function pointer or not.
    
    This removes the hard-coded maximum function name length.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 90fb00d9a8a2..a5467f8709e9 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -130,14 +130,13 @@ static int pin_request(struct pinctrl_dev *pctldev,
 	}
 
 	spin_lock(&desc->lock);
-	if (desc->mux_requested) {
+	if (desc->mux_function) {
 		spin_unlock(&desc->lock);
 		dev_err(&pctldev->dev,
 			"pin already requested\n");
 		goto out;
 	}
-	desc->mux_requested = true;
-	strncpy(desc->mux_function, function, sizeof(desc->mux_function));
+	desc->mux_function = function;
 	spin_unlock(&desc->lock);
 
 	/* Let each pin increase references to this module */
@@ -168,8 +167,7 @@ static int pin_request(struct pinctrl_dev *pctldev,
 out_free_pin:
 	if (status) {
 		spin_lock(&desc->lock);
-		desc->mux_requested = false;
-		desc->mux_function[0] = '\0';
+		desc->mux_function = NULL;
 		spin_unlock(&desc->lock);
 	}
 out:
@@ -184,8 +182,9 @@ static int pin_request(struct pinctrl_dev *pctldev,
  * pin_free() - release a single muxed in pin so something else can be muxed
  * @pctldev: pin controller device handling this pin
  * @pin: the pin to free
+ * @free_func: whether to free the pin's assigned function name string
  */
-static void pin_free(struct pinctrl_dev *pctldev, int pin)
+static void pin_free(struct pinctrl_dev *pctldev, int pin, int free_func)
 {
 	const struct pinmux_ops *ops = pctldev->desc->pmxops;
 	struct pin_desc *desc;
@@ -201,8 +200,9 @@ static void pin_free(struct pinctrl_dev *pctldev, int pin)
 		ops->free(pctldev, pin);
 
 	spin_lock(&desc->lock);
-	desc->mux_requested = false;
-	desc->mux_function[0] = '\0';
+	if (free_func)
+		kfree(desc->mux_function);
+	desc->mux_function = NULL;
 	spin_unlock(&desc->lock);
 	module_put(pctldev->owner);
 }
@@ -214,6 +214,7 @@ static void pin_free(struct pinctrl_dev *pctldev, int pin)
 int pinmux_request_gpio(unsigned gpio)
 {
 	char gpiostr[16];
+	const char *function;
 	struct pinctrl_dev *pctldev;
 	struct pinctrl_gpio_range *range;
 	int ret;
@@ -229,7 +230,15 @@ int pinmux_request_gpio(unsigned gpio)
 	/* Conjure some name stating what chip and pin this is taken by */
 	snprintf(gpiostr, 15, "%s:%d", range->name, gpio);
 
-	return pin_request(pctldev, pin, gpiostr, true, range);
+	function = kstrdup(gpiostr, GFP_KERNEL);
+	if (!function)
+		return -EINVAL;
+
+	ret = pin_request(pctldev, pin, function, true, range);
+	if (ret < 0)
+		kfree(function);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(pinmux_request_gpio);
 
@@ -251,7 +260,7 @@ void pinmux_free_gpio(unsigned gpio)
 	/* Convert to the pin controllers number space */
 	pin = gpio - range->base;
 
-	pin_free(pctldev, pin);
+	pin_free(pctldev, pin, true);
 }
 EXPORT_SYMBOL_GPL(pinmux_free_gpio);
 
@@ -351,7 +360,7 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 			/* On error release all taken pins */
 			i--; /* this pin just failed */
 			for (; i >= 0; i--)
-				pin_free(pctldev, pins[i]);
+				pin_free(pctldev, pins[i], false);
 			return -ENODEV;
 		}
 	}
@@ -381,7 +390,7 @@ static void release_pins(struct pinctrl_dev *pctldev,
 		return;
 	}
 	for (i = 0; i < num_pins; i++)
-		pin_free(pctldev, pins[i]);
+		pin_free(pctldev, pins[i], false);
 }
 
 /**
@@ -1013,7 +1022,8 @@ static int pinmux_pins_show(struct seq_file *s, void *what)
 
 		seq_printf(s, "pin %d (%s): %s\n", pin,
 			   desc->name ? desc->name : "unnamed",
-			   desc->mux_requested ? desc->mux_function : "UNCLAIMED");
+			   desc->mux_function ? desc->mux_function
+					      : "UNCLAIMED");
 	}
 
 	return 0;

commit a5818a8bd095a08cfb1871b63af9c8bed103e4b9
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Oct 19 16:19:25 2011 -0600

    pinctrl: get_group_pins() const fixes
    
    get_group_pins() "returns" a pointer to an array of const objects, through
    a pointer parameter. Fix the prototype so what's pointed at by the returned
    pointer is const, rather than the function parameter being const.
    
    This also allows the removal of a cast in each of the two current pinmux
    drivers.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 6544d98b2cf8..90fb00d9a8a2 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -326,7 +326,7 @@ static int acquire_pins(struct pinctrl_dev *pctldev,
 	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
 	const char *func = pmxops->get_function_name(pctldev,
 						     func_selector);
-	unsigned *pins;
+	const unsigned *pins;
 	unsigned num_pins;
 	int ret;
 	int i;
@@ -367,7 +367,7 @@ static void release_pins(struct pinctrl_dev *pctldev,
 			 unsigned group_selector)
 {
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
-	unsigned *pins;
+	const unsigned *pins;
 	unsigned num_pins;
 	int ret;
 	int i;

commit 2744e8afb3b76343e7eb8197e8b3e085036010a5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon May 2 20:50:54 2011 +0200

    drivers: create a pin control subsystem
    
    This creates a subsystem for handling of pin control devices.
    These are devices that control different aspects of package
    pins.
    
    Currently it handles pinmuxing, i.e. assigning electronic
    functions to groups of pins on primarily PGA and BGA type of
    chip packages which are common in embedded systems.
    
    The plan is to also handle other I/O pin control aspects
    such as biasing, driving, input properties such as
    schmitt-triggering, load capacitance etc within this
    subsystem, to remove a lot of ARM arch code as well as
    feature-creepy GPIO drivers which are implementing the same
    thing over and over again.
    
    This is being done to depopulate the arch/arm/* directory
    of such custom drivers and try to abstract the infrastructure
    they all need. See the Documentation/pinctrl.txt file that is
    part of this patch for more details.
    
    ChangeLog v1->v2:
    
    - Various minor fixes from Joe's and Stephens review comments
    - Added a pinmux_config() that can invoke custom configuration
      with arbitrary data passed in or out to/from the pinmux driver
    
    ChangeLog v2->v3:
    
    - Renamed subsystem folder to "pinctrl" since we will likely
      want to keep other pin control such as biasing in this
      subsystem too, so let us keep to something generic even though
      we're mainly doing pinmux now.
    - As a consequence, register pins as an abstract entity separate
      from the pinmux. The muxing functions will claim pins out of the
      pin pool and make sure they do not collide. Pins can now be
      named by the pinctrl core.
    - Converted the pin lookup from a static array into a radix tree,
      I agreed with Grant Likely to try to avoid any static allocation
      (which is crap for device tree stuff) so I just rewrote this
      to be dynamic, just like irq number descriptors. The
      platform-wide definition of number of pins goes away - this is
      now just the sum total of the pins registered to the subsystem.
    - Make sure mappings with only a function name and no device
      works properly.
    
    ChangeLog v3->v4:
    
    - Define a number space per controller instead of globally,
      Stephen and Grant requested the same thing so now maps need to
      define target controller, and the radix tree of pin descriptors
      is a property on each pin controller device.
    - Add a compulsory pinctrl device entry to the pinctrl mapping
      table. This must match the pinctrl device, like "pinctrl.0"
    - Split the file core.c in two: core.c and pinmux.c where the
      latter carry all pinmux stuff, the core is for generic pin
      control, and use local headers to access functionality between
      files. It is now possible to implement a "blank" pin controller
      without pinmux capabilities. This split will make new additions
      like pindrive.c, pinbias.c etc possible for combined drivers
      and chunks of functionality which is a GoodThing(TM).
    - Rewrite the interaction with the GPIO subsystem - the pin
      controller descriptor now handles this by defining an offset
      into the GPIO numberspace for its handled pin range. This is
      used to look up the apropriate pin controller for a GPIO pin.
      Then that specific GPIO range is matched 1-1 for the target
      controller instance.
    - Fixed a number of review comments from Joe Perches.
    - Broke out a header file pinctrl.h for the core pin handling
      stuff that will be reused by other stuff than pinmux.
    - Fixed some erroneous EXPORT() stuff.
    - Remove mispatched U300 Kconfig and Makefile entries
    - Fixed a number of review comments from Stephen Warren, not all
      of them - still WIP. But I think the new mapping that will
      specify which function goes to which pin mux controller address
      50% of your concerns (else beat me up).
    
    ChangeLog v4->v5:
    
    - Defined a "position" for each function, so the pin controller now
      tracks a function in a certain position, and the pinmux maps define
      what position you want the function in. (Feedback from Stephen
      Warren and Sascha Hauer).
    - Since we now need to request a combined function+position from
      the machine mapping table that connect mux settings to drivers,
      it was extended with a position field and a name field. The
      name field is now used if you e.g. need to switch between two
      mux map settings at runtime.
    - Switched from a class device to using struct bus_type for this
      subsystem. Verified sysfs functionality: seems to work fine.
      (Feedback from Arnd Bergmann and Greg Kroah-Hartman)
    - Define a per pincontroller list of GPIO ranges from the GPIO
      pin space that can be handled by the pin controller. These can
      be added one by one at runtime. (Feedback from Barry Song)
    - Expanded documentation of regulator_[get|enable|disable|put]
      semantics.
    - Fixed a number of review comments from Barry Song. (Thanks!)
    
    ChangeLog v5->v6:
    
    - Create an abstract pin group concept that can sort pins into
      named and enumerated groups no matter what the use of these
      groups may be, one possible usecase is a group of pins being
      muxed in or so. The intention is however to also use these
      groups for other pin control activities.
    - Make it compulsory for pinmux functions to associate with
      at least one group, so the abstract pin group concept is used
      to define the groups of pins affected by a pinmux function.
      The pinmux driver interface has been altered so as to enforce
      a function to list applicable groups per function.
    - Provide an optional .group entry in the pinmux machine map
      so the map can select beteween different available groups
      to be used with a certain function.
    - Consequent changes all over the place so that e.g. debugfs
      present reasonable information about the world.
    - Drop the per-pin mux (*config) function in the pinmux_ops
      struct - I was afraid that this would start to be used for
      things totally unrelated to muxing, we can introduce that to
      the generic struct pinctrl_ops if needed. I want to keep
      muxing orthogonal to other pin control subjects and not mix
      these things up.
    
    ChangeLog v6->v7:
    
    - Make it possible to have several map entries matching the
      same device, pin controller and function, but using
      a different group, and alter the semantics so that
      pinmux_get() will pick all matching map entries, and
      store the associated groups in a list. The list will
      then be iterated over at pinmux_enable()/pinmux_disable()
      and corresponding driver functions called for each
      defined group. Notice that you're only allowed to map
      multiple *groups* to the same
      { device, pin controller, function } triplet, attempts
      to map the same device to multiple pin controllers will
      for example fail. This is hopefully the crucial feature
      requested by Stephen Warren.
    - Add a pinmux hogging field to the pinmux mapping entries,
      and enable the pinmux core to hog pinmux map entries.
      This currently only works for pinmuxes without assigned
      devices as it looks now, but with device trees we can
      look up the corresponding struct device * entries when
      we register the pinmux driver, and have it hog each
      pinmux map in turn, for a simple approach to
      non-dynamic pin muxing. This addresses an issue from
      Grant Likely that the machine should take care of as
      much of the pinmux setup as possible, not the devices.
      By supplying a list of hogs, it can now instruct the
      core to take care of any static mappings.
    - Switch pinmux group retrieveal function to grab an
      array of strings representing the groups rather than an
      array of unsigned and rewrite accordingly.
    - Alter debugfs to show the grouplist handled by each
      pinmux. Also add a list of hogs.
    - Dynamically allocate a struct pinmux at pinmux_get() and
      free it at pinmux_put(), then add these to the global
      list of pinmuxes active as we go along.
    - Go over the list of pinmux maps at pinmux_get() time
      and repeatedly apply matches.
    - Retrieve applicable groups per function from the driver
      as a string array rather than a unsigned array, then
      lookup the enumerators.
    - Make the device to pinmux map a singleton - only allow the
      mapping table to be registered once and even tag the
      registration function with __init so it surely won't be
      abused.
    - Create a separate debugfs file to view the pinmux map at
      runtime.
    - Introduce a spin lock to the pin descriptor struct, lock it
      when modifying pin status entries. Reported by Stijn Devriendt.
    - Fix up the documentation after review from Stephen Warren.
    - Let the GPIO ranges give names as const char * instead of some
      fixed-length string.
    - add a function to unregister GPIO ranges to mirror the
      registration function.
    - Privatized the struct pinctrl_device and removed it from the
      <linux/pinctrl/pinctrl.h> API, the drivers do not need to know
      the members of this struct. It is now in the local header
      "core.h".
    - Rename the concept of "anonymous" mux maps to "system" muxes
      and add convenience macros and documentation.
    
    ChangeLog v7->v8:
    
    - Delete the leftover pinmux_config() function from the
     <linux/pinctrl/pinmux.h> header.
    - Fix a race condition found by Stijn Devriendt in pin_request()
    
    ChangeLog v8->v9:
    
    - Drop the bus_type and the sysfs attributes and all, we're not on
      the clear about how this should be used for e.g. userspace
      interfaces so let us save this for the future.
    - Use the right name in MAINTAINERS, PIN CONTROL rather than
      PINMUX
    - Don't kfree() the device state holder, let the .remove() callback
      handle this.
    - Fix up numerous kerneldoc headers to have one line for the function
      description and more verbose documentation below the parameters
    
    ChangeLog v9->v10:
    - pinctrl: EXPORT_SYMBOL needs export.h, folded in a patch
      from Steven Rothwell
    - fix pinctrl_register error handling, folded in a patch from
      Axel Lin
    - Various fixes to documentation text so that it's consistent.
    - Removed pointless comment from drivers/Kconfig
    - Removed dependency on SYSFS since we removed the bus in
      v9.
    - Renamed hopelessly abbreviated pctldev_* functions to the
      more verbose pinctrl_dev_*
    - Drop mutex properly when looking up GPIO ranges
    - Return NULL instead of ERR_PTR() errors on registration of
      pin controllers, using cast pointers is fragile. We can
      live without the detailed error codes for sure.
    
    Cc: Stijn Devriendt <highguy@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Barry Song <21cnbao@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
new file mode 100644
index 000000000000..6544d98b2cf8
--- /dev/null
+++ b/drivers/pinctrl/pinmux.c
@@ -0,0 +1,1180 @@
+/*
+ * Core driver for the pin muxing portions of the pin control subsystem
+ *
+ * Copyright (C) 2011 ST-Ericsson SA
+ * Written on behalf of Linaro for ST-Ericsson
+ * Based on bits of regulator core, gpio core and clk core
+ *
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+#define pr_fmt(fmt) "pinmux core: " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/radix-tree.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinmux.h>
+#include "core.h"
+
+/* List of pinmuxes */
+static DEFINE_MUTEX(pinmux_list_mutex);
+static LIST_HEAD(pinmux_list);
+
+/* List of pinmux hogs */
+static DEFINE_MUTEX(pinmux_hoglist_mutex);
+static LIST_HEAD(pinmux_hoglist);
+
+/* Global pinmux maps, we allow one set only */
+static struct pinmux_map const *pinmux_maps;
+static unsigned pinmux_maps_num;
+
+/**
+ * struct pinmux_group - group list item for pinmux groups
+ * @node: pinmux group list node
+ * @group_selector: the group selector for this group
+ */
+struct pinmux_group {
+	struct list_head node;
+	unsigned group_selector;
+};
+
+/**
+ * struct pinmux - per-device pinmux state holder
+ * @node: global list node
+ * @dev: the device using this pinmux
+ * @usecount: the number of active users of this mux setting, used to keep
+ *	track of nested use cases
+ * @pins: an array of discrete physical pins used in this mapping, taken
+ *	from the global pin enumeration space (copied from pinmux map)
+ * @num_pins: the number of pins in this mapping array, i.e. the number of
+ *	elements in .pins so we can iterate over that array (copied from
+ *	pinmux map)
+ * @pctldev: pin control device handling this pinmux
+ * @func_selector: the function selector for the pinmux device handling
+ *	this pinmux
+ * @groups: the group selectors for the pinmux device and
+ *	selector combination handling this pinmux, this is a list that
+ *	will be traversed on all pinmux operations such as
+ *	get/put/enable/disable
+ * @mutex: a lock for the pinmux state holder
+ */
+struct pinmux {
+	struct list_head node;
+	struct device *dev;
+	unsigned usecount;
+	struct pinctrl_dev *pctldev;
+	unsigned func_selector;
+	struct list_head groups;
+	struct mutex mutex;
+};
+
+/**
+ * struct pinmux_hog - a list item to stash mux hogs
+ * @node: pinmux hog list node
+ * @map: map entry responsible for this hogging
+ * @pmx: the pinmux hogged by this item
+ */
+struct pinmux_hog {
+	struct list_head node;
+	struct pinmux_map const *map;
+	struct pinmux *pmx;
+};
+
+/**
+ * pin_request() - request a single pin to be muxed in, typically for GPIO
+ * @pin: the pin number in the global pin space
+ * @function: a functional name to give to this pin, passed to the driver
+ *	so it knows what function to mux in, e.g. the string "gpioNN"
+ *	means that you want to mux in the pin for use as GPIO number NN
+ * @gpio: if this request concerns a single GPIO pin
+ * @gpio_range: the range matching the GPIO pin if this is a request for a
+ *	single GPIO pin
+ */
+static int pin_request(struct pinctrl_dev *pctldev,
+		       int pin, const char *function, bool gpio,
+		       struct pinctrl_gpio_range *gpio_range)
+{
+	struct pin_desc *desc;
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	int status = -EINVAL;
+
+	dev_dbg(&pctldev->dev, "request pin %d for %s\n", pin, function);
+
+	if (!pin_is_valid(pctldev, pin)) {
+		dev_err(&pctldev->dev, "pin is invalid\n");
+		return -EINVAL;
+	}
+
+	if (!function) {
+		dev_err(&pctldev->dev, "no function name given\n");
+		return -EINVAL;
+	}
+
+	desc = pin_desc_get(pctldev, pin);
+	if (desc == NULL) {
+		dev_err(&pctldev->dev,
+			"pin is not registered so it cannot be requested\n");
+		goto out;
+	}
+
+	spin_lock(&desc->lock);
+	if (desc->mux_requested) {
+		spin_unlock(&desc->lock);
+		dev_err(&pctldev->dev,
+			"pin already requested\n");
+		goto out;
+	}
+	desc->mux_requested = true;
+	strncpy(desc->mux_function, function, sizeof(desc->mux_function));
+	spin_unlock(&desc->lock);
+
+	/* Let each pin increase references to this module */
+	if (!try_module_get(pctldev->owner)) {
+		dev_err(&pctldev->dev,
+			"could not increase module refcount for pin %d\n",
+			pin);
+		status = -EINVAL;
+		goto out_free_pin;
+	}
+
+	/*
+	 * If there is no kind of request function for the pin we just assume
+	 * we got it by default and proceed.
+	 */
+	if (gpio && ops->gpio_request_enable)
+		/* This requests and enables a single GPIO pin */
+		status = ops->gpio_request_enable(pctldev, gpio_range, pin);
+	else if (ops->request)
+		status = ops->request(pctldev, pin);
+	else
+		status = 0;
+
+	if (status)
+		dev_err(&pctldev->dev, "->request on device %s failed "
+		       "for pin %d\n",
+		       pctldev->desc->name, pin);
+out_free_pin:
+	if (status) {
+		spin_lock(&desc->lock);
+		desc->mux_requested = false;
+		desc->mux_function[0] = '\0';
+		spin_unlock(&desc->lock);
+	}
+out:
+	if (status)
+		dev_err(&pctldev->dev, "pin-%d (%s) status %d\n",
+		       pin, function ? : "?", status);
+
+	return status;
+}
+
+/**
+ * pin_free() - release a single muxed in pin so something else can be muxed
+ * @pctldev: pin controller device handling this pin
+ * @pin: the pin to free
+ */
+static void pin_free(struct pinctrl_dev *pctldev, int pin)
+{
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	struct pin_desc *desc;
+
+	desc = pin_desc_get(pctldev, pin);
+	if (desc == NULL) {
+		dev_err(&pctldev->dev,
+			"pin is not registered so it cannot be freed\n");
+		return;
+	}
+
+	if (ops->free)
+		ops->free(pctldev, pin);
+
+	spin_lock(&desc->lock);
+	desc->mux_requested = false;
+	desc->mux_function[0] = '\0';
+	spin_unlock(&desc->lock);
+	module_put(pctldev->owner);
+}
+
+/**
+ * pinmux_request_gpio() - request a single pin to be muxed in as GPIO
+ * @gpio: the GPIO pin number from the GPIO subsystem number space
+ */
+int pinmux_request_gpio(unsigned gpio)
+{
+	char gpiostr[16];
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_gpio_range *range;
+	int ret;
+	int pin;
+
+	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
+	if (ret)
+		return -EINVAL;
+
+	/* Convert to the pin controllers number space */
+	pin = gpio - range->base;
+
+	/* Conjure some name stating what chip and pin this is taken by */
+	snprintf(gpiostr, 15, "%s:%d", range->name, gpio);
+
+	return pin_request(pctldev, pin, gpiostr, true, range);
+}
+EXPORT_SYMBOL_GPL(pinmux_request_gpio);
+
+/**
+ * pinmux_free_gpio() - free a single pin, currently used as GPIO
+ * @gpio: the GPIO pin number from the GPIO subsystem number space
+ */
+void pinmux_free_gpio(unsigned gpio)
+{
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_gpio_range *range;
+	int ret;
+	int pin;
+
+	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
+	if (ret)
+		return;
+
+	/* Convert to the pin controllers number space */
+	pin = gpio - range->base;
+
+	pin_free(pctldev, pin);
+}
+EXPORT_SYMBOL_GPL(pinmux_free_gpio);
+
+/**
+ * pinmux_register_mappings() - register a set of pinmux mappings
+ * @maps: the pinmux mappings table to register
+ * @num_maps: the number of maps in the mapping table
+ *
+ * Only call this once during initialization of your machine, the function is
+ * tagged as __init and won't be callable after init has completed. The map
+ * passed into this function will be owned by the pinmux core and cannot be
+ * free:d.
+ */
+int __init pinmux_register_mappings(struct pinmux_map const *maps,
+				    unsigned num_maps)
+{
+	int i;
+
+	if (pinmux_maps != NULL) {
+		pr_err("pinmux mappings already registered, you can only "
+		       "register one set of maps\n");
+		return -EINVAL;
+	}
+
+	pr_debug("add %d pinmux maps\n", num_maps);
+	for (i = 0; i < num_maps; i++) {
+		/* Sanity check the mapping */
+		if (!maps[i].name) {
+			pr_err("failed to register map %d: "
+			       "no map name given\n", i);
+			return -EINVAL;
+		}
+		if (!maps[i].ctrl_dev && !maps[i].ctrl_dev_name) {
+			pr_err("failed to register map %s (%d): "
+			       "no pin control device given\n",
+			       maps[i].name, i);
+			return -EINVAL;
+		}
+		if (!maps[i].function) {
+			pr_err("failed to register map %s (%d): "
+			       "no function ID given\n", maps[i].name, i);
+			return -EINVAL;
+		}
+
+		if (!maps[i].dev && !maps[i].dev_name)
+			pr_debug("add system map %s function %s with no device\n",
+				 maps[i].name,
+				 maps[i].function);
+		else
+			pr_debug("register map %s, function %s\n",
+				 maps[i].name,
+				 maps[i].function);
+	}
+
+	pinmux_maps = maps;
+	pinmux_maps_num = num_maps;
+
+	return 0;
+}
+
+/**
+ * acquire_pins() - acquire all the pins for a certain funcion on a pinmux
+ * @pctldev: the device to take the pins on
+ * @func_selector: the function selector to acquire the pins for
+ * @group_selector: the group selector containing the pins to acquire
+ */
+static int acquire_pins(struct pinctrl_dev *pctldev,
+			unsigned func_selector,
+			unsigned group_selector)
+{
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
+	const char *func = pmxops->get_function_name(pctldev,
+						     func_selector);
+	unsigned *pins;
+	unsigned num_pins;
+	int ret;
+	int i;
+
+	ret = pctlops->get_group_pins(pctldev, group_selector,
+				      &pins, &num_pins);
+	if (ret)
+		return ret;
+
+	dev_dbg(&pctldev->dev, "requesting the %u pins from group %u\n",
+		num_pins, group_selector);
+
+	/* Try to allocate all pins in this group, one by one */
+	for (i = 0; i < num_pins; i++) {
+		ret = pin_request(pctldev, pins[i], func, false, NULL);
+		if (ret) {
+			dev_err(&pctldev->dev,
+				"could not get pin %d for function %s "
+				"on device %s - conflicting mux mappings?\n",
+				pins[i], func ? : "(undefined)",
+				pinctrl_dev_get_name(pctldev));
+			/* On error release all taken pins */
+			i--; /* this pin just failed */
+			for (; i >= 0; i--)
+				pin_free(pctldev, pins[i]);
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+/**
+ * release_pins() - release pins taken by earlier acquirement
+ * @pctldev: the device to free the pinx on
+ * @group_selector: the group selector containing the pins to free
+ */
+static void release_pins(struct pinctrl_dev *pctldev,
+			 unsigned group_selector)
+{
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+	unsigned *pins;
+	unsigned num_pins;
+	int ret;
+	int i;
+
+	ret = pctlops->get_group_pins(pctldev, group_selector,
+				      &pins, &num_pins);
+	if (ret) {
+		dev_err(&pctldev->dev, "could not get pins to release for "
+			"group selector %d\n",
+			group_selector);
+		return;
+	}
+	for (i = 0; i < num_pins; i++)
+		pin_free(pctldev, pins[i]);
+}
+
+/**
+ * pinmux_get_group_selector() - returns the group selector for a group
+ * @pctldev: the pin controller handling the group
+ * @pin_group: the pin group to look up
+ */
+static int pinmux_get_group_selector(struct pinctrl_dev *pctldev,
+				     const char *pin_group)
+{
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+	unsigned group_selector = 0;
+
+	while (pctlops->list_groups(pctldev, group_selector) >= 0) {
+		const char *gname = pctlops->get_group_name(pctldev,
+							    group_selector);
+		if (!strcmp(gname, pin_group)) {
+			dev_dbg(&pctldev->dev,
+				"found group selector %u for %s\n",
+				group_selector,
+				pin_group);
+			return group_selector;
+		}
+
+		group_selector++;
+	}
+
+	dev_err(&pctldev->dev, "does not have pin group %s\n",
+		pin_group);
+
+	return -EINVAL;
+}
+
+/**
+ * pinmux_check_pin_group() - check function and pin group combo
+ * @pctldev: device to check the pin group vs function for
+ * @func_selector: the function selector to check the pin group for, we have
+ *	already looked this up in the calling function
+ * @pin_group: the pin group to match to the function
+ *
+ * This function will check that the pinmux driver can supply the
+ * selected pin group for a certain function, returns the group selector if
+ * the group and function selector will work fine together, else returns
+ * negative
+ */
+static int pinmux_check_pin_group(struct pinctrl_dev *pctldev,
+				  unsigned func_selector,
+				  const char *pin_group)
+{
+	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
+	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
+	int ret;
+
+	/*
+	 * If the driver does not support different pin groups for the
+	 * functions, we only support group 0, and assume this exists.
+	 */
+	if (!pctlops || !pctlops->list_groups)
+		return 0;
+
+	/*
+	 * Passing NULL (no specific group) will select the first and
+	 * hopefully only group of pins available for this function.
+	 */
+	if (!pin_group) {
+		char const * const *groups;
+		unsigned num_groups;
+
+		ret = pmxops->get_function_groups(pctldev, func_selector,
+						  &groups, &num_groups);
+		if (ret)
+			return ret;
+		if (num_groups < 1)
+			return -EINVAL;
+		ret = pinmux_get_group_selector(pctldev, groups[0]);
+		if (ret < 0) {
+			dev_err(&pctldev->dev,
+				"function %s wants group %s but the pin "
+				"controller does not seem to have that group\n",
+				pmxops->get_function_name(pctldev, func_selector),
+				groups[0]);
+			return ret;
+		}
+
+		if (num_groups > 1)
+			dev_dbg(&pctldev->dev,
+				"function %s support more than one group, "
+				"default-selecting first group %s (%d)\n",
+				pmxops->get_function_name(pctldev, func_selector),
+				groups[0],
+				ret);
+
+		return ret;
+	}
+
+	dev_dbg(&pctldev->dev,
+		"check if we have pin group %s on controller %s\n",
+		pin_group, pinctrl_dev_get_name(pctldev));
+
+	ret = pinmux_get_group_selector(pctldev, pin_group);
+	if (ret < 0) {
+		dev_dbg(&pctldev->dev,
+			"%s does not support pin group %s with function %s\n",
+			pinctrl_dev_get_name(pctldev),
+			pin_group,
+			pmxops->get_function_name(pctldev, func_selector));
+	}
+	return ret;
+}
+
+/**
+ * pinmux_search_function() - check pin control driver for a certain function
+ * @pctldev: device to check for function and position
+ * @map: function map containing the function and position to look for
+ * @func_selector: returns the applicable function selector if found
+ * @group_selector: returns the applicable group selector if found
+ *
+ * This will search the pinmux driver for an applicable
+ * function with a specific pin group, returns 0 if these can be mapped
+ * negative otherwise
+ */
+static int pinmux_search_function(struct pinctrl_dev *pctldev,
+				  struct pinmux_map const *map,
+				  unsigned *func_selector,
+				  unsigned *group_selector)
+{
+	const struct pinmux_ops *ops = pctldev->desc->pmxops;
+	unsigned selector = 0;
+
+	/* See if this pctldev has this function */
+	while (ops->list_functions(pctldev, selector) >= 0) {
+		const char *fname = ops->get_function_name(pctldev,
+							   selector);
+		int ret;
+
+		if (!strcmp(map->function, fname)) {
+			/* Found the function, check pin group */
+			ret = pinmux_check_pin_group(pctldev, selector,
+						     map->group);
+			if (ret < 0)
+				return ret;
+
+			/* This function and group selector can be used */
+			*func_selector = selector;
+			*group_selector = ret;
+			return 0;
+
+		}
+		selector++;
+	}
+
+	pr_err("%s does not support function %s\n",
+	       pinctrl_dev_get_name(pctldev), map->function);
+	return -EINVAL;
+}
+
+/**
+ * pinmux_enable_muxmap() - enable a map entry for a certain pinmux
+ */
+static int pinmux_enable_muxmap(struct pinctrl_dev *pctldev,
+				struct pinmux *pmx,
+				struct device *dev,
+				const char *devname,
+				struct pinmux_map const *map)
+{
+	unsigned func_selector;
+	unsigned group_selector;
+	struct pinmux_group *grp;
+	int ret;
+
+	/*
+	 * Note that we're not locking the pinmux mutex here, because
+	 * this is only called at pinmux initialization time when it
+	 * has not been added to any list and thus is not reachable
+	 * by anyone else.
+	 */
+
+	if (pmx->pctldev && pmx->pctldev != pctldev) {
+		dev_err(&pctldev->dev,
+			"different pin control devices given for device %s, "
+			"function %s\n",
+			devname,
+			map->function);
+		return -EINVAL;
+	}
+	pmx->dev = dev;
+	pmx->pctldev = pctldev;
+
+	/* Now go into the driver and try to match a function and group */
+	ret = pinmux_search_function(pctldev, map, &func_selector,
+				     &group_selector);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * If the function selector is already set, it needs to be identical,
+	 * we support several groups with one function but not several
+	 * functions with one or several groups in the same pinmux.
+	 */
+	if (pmx->func_selector != UINT_MAX &&
+	    pmx->func_selector != func_selector) {
+		dev_err(&pctldev->dev,
+			"dual function defines in the map for device %s\n",
+		       devname);
+		return -EINVAL;
+	}
+	pmx->func_selector = func_selector;
+
+	/* Now add this group selector, we may have many of them */
+	grp = kmalloc(sizeof(struct pinmux_group), GFP_KERNEL);
+	if (!grp)
+		return -ENOMEM;
+	grp->group_selector = group_selector;
+	ret = acquire_pins(pctldev, func_selector, group_selector);
+	if (ret) {
+		kfree(grp);
+		return ret;
+	}
+	list_add(&grp->node, &pmx->groups);
+
+	return 0;
+}
+
+static void pinmux_free_groups(struct pinmux *pmx)
+{
+	struct list_head *node, *tmp;
+
+	list_for_each_safe(node, tmp, &pmx->groups) {
+		struct pinmux_group *grp =
+			list_entry(node, struct pinmux_group, node);
+		/* Release all pins taken by this group */
+		release_pins(pmx->pctldev, grp->group_selector);
+		list_del(node);
+		kfree(grp);
+	}
+}
+
+/**
+ * pinmux_get() - retrieves the pinmux for a certain device
+ * @dev: the device to get the pinmux for
+ * @name: an optional specific mux mapping name or NULL, the name is only
+ *	needed if you want to have more than one mapping per device, or if you
+ *	need an anonymous pinmux (not tied to any specific device)
+ */
+struct pinmux *pinmux_get(struct device *dev, const char *name)
+{
+
+	struct pinmux_map const *map = NULL;
+	struct pinctrl_dev *pctldev = NULL;
+	const char *devname = NULL;
+	struct pinmux *pmx;
+	bool found_map;
+	unsigned num_maps = 0;
+	int ret = -ENODEV;
+	int i;
+
+	/* We must have dev or ID or both */
+	if (!dev && !name)
+		return ERR_PTR(-EINVAL);
+
+	if (dev)
+		devname = dev_name(dev);
+
+	pr_debug("get mux %s for device %s\n", name,
+		 devname ? devname : "(none)");
+
+	/*
+	 * create the state cookie holder struct pinmux for each
+	 * mapping, this is what consumers will get when requesting
+	 * a pinmux handle with pinmux_get()
+	 */
+	pmx = kzalloc(sizeof(struct pinmux), GFP_KERNEL);
+	if (pmx == NULL)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&pmx->mutex);
+	pmx->func_selector = UINT_MAX;
+	INIT_LIST_HEAD(&pmx->groups);
+
+	/* Iterate over the pinmux maps to locate the right ones */
+	for (i = 0; i < pinmux_maps_num; i++) {
+		map = &pinmux_maps[i];
+		found_map = false;
+
+		/*
+		 * First, try to find the pctldev given in the map
+		 */
+		pctldev = get_pinctrl_dev_from_dev(map->ctrl_dev,
+						   map->ctrl_dev_name);
+		if (!pctldev) {
+			const char *devname = NULL;
+
+			if (map->ctrl_dev)
+				devname = dev_name(map->ctrl_dev);
+			else if (map->ctrl_dev_name)
+				devname = map->ctrl_dev_name;
+
+			pr_warning("could not find a pinctrl device for pinmux "
+				   "function %s, fishy, they shall all have one\n",
+				   map->function);
+			pr_warning("given pinctrl device name: %s",
+				   devname ? devname : "UNDEFINED");
+
+			/* Continue to check the other mappings anyway... */
+			continue;
+		}
+
+		pr_debug("in map, found pctldev %s to handle function %s",
+			 dev_name(&pctldev->dev), map->function);
+
+
+		/*
+		 * If we're looking for a specific named map, this must match,
+		 * else we loop and look for the next.
+		 */
+		if (name != NULL) {
+			if (map->name == NULL)
+				continue;
+			if (strcmp(map->name, name))
+				continue;
+		}
+
+		/*
+		 * This is for the case where no device name is given, we
+		 * already know that the function name matches from above
+		 * code.
+		 */
+		if (!map->dev_name && (name != NULL))
+			found_map = true;
+
+		/* If the mapping has a device set up it must match */
+		if (map->dev_name &&
+		    (!devname || !strcmp(map->dev_name, devname)))
+			/* MATCH! */
+			found_map = true;
+
+		/* If this map is applicable, then apply it */
+		if (found_map) {
+			ret = pinmux_enable_muxmap(pctldev, pmx, dev,
+						   devname, map);
+			if (ret) {
+				pinmux_free_groups(pmx);
+				kfree(pmx);
+				return ERR_PTR(ret);
+			}
+			num_maps++;
+		}
+	}
+
+
+	/* We should have atleast one map, right */
+	if (!num_maps) {
+		pr_err("could not find any mux maps for device %s, ID %s\n",
+		       devname ? devname : "(anonymous)",
+		       name ? name : "(undefined)");
+		kfree(pmx);
+		return ERR_PTR(-EINVAL);
+	}
+
+	pr_debug("found %u mux maps for device %s, UD %s\n",
+		 num_maps,
+		 devname ? devname : "(anonymous)",
+		 name ? name : "(undefined)");
+
+	/* Add the pinmux to the global list */
+	mutex_lock(&pinmux_list_mutex);
+	list_add(&pmx->node, &pinmux_list);
+	mutex_unlock(&pinmux_list_mutex);
+
+	return pmx;
+}
+EXPORT_SYMBOL_GPL(pinmux_get);
+
+/**
+ * pinmux_put() - release a previously claimed pinmux
+ * @pmx: a pinmux previously claimed by pinmux_get()
+ */
+void pinmux_put(struct pinmux *pmx)
+{
+	if (pmx == NULL)
+		return;
+
+	mutex_lock(&pmx->mutex);
+	if (pmx->usecount)
+		pr_warn("releasing pinmux with active users!\n");
+	/* Free the groups and all acquired pins */
+	pinmux_free_groups(pmx);
+	mutex_unlock(&pmx->mutex);
+
+	/* Remove from list */
+	mutex_lock(&pinmux_list_mutex);
+	list_del(&pmx->node);
+	mutex_unlock(&pinmux_list_mutex);
+
+	kfree(pmx);
+}
+EXPORT_SYMBOL_GPL(pinmux_put);
+
+/**
+ * pinmux_enable() - enable a certain pinmux setting
+ * @pmx: the pinmux to enable, previously claimed by pinmux_get()
+ */
+int pinmux_enable(struct pinmux *pmx)
+{
+	int ret = 0;
+
+	if (pmx == NULL)
+		return -EINVAL;
+	mutex_lock(&pmx->mutex);
+	if (pmx->usecount++ == 0) {
+		struct pinctrl_dev *pctldev = pmx->pctldev;
+		const struct pinmux_ops *ops = pctldev->desc->pmxops;
+		struct pinmux_group *grp;
+
+		list_for_each_entry(grp, &pmx->groups, node) {
+			ret = ops->enable(pctldev, pmx->func_selector,
+					  grp->group_selector);
+			if (ret) {
+				/*
+				 * TODO: call disable() on all groups we called
+				 * enable() on to this point?
+				 */
+				pmx->usecount--;
+				break;
+			}
+		}
+	}
+	mutex_unlock(&pmx->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pinmux_enable);
+
+/**
+ * pinmux_disable() - disable a certain pinmux setting
+ * @pmx: the pinmux to disable, previously claimed by pinmux_get()
+ */
+void pinmux_disable(struct pinmux *pmx)
+{
+	if (pmx == NULL)
+		return;
+
+	mutex_lock(&pmx->mutex);
+	if (--pmx->usecount == 0) {
+		struct pinctrl_dev *pctldev = pmx->pctldev;
+		const struct pinmux_ops *ops = pctldev->desc->pmxops;
+		struct pinmux_group *grp;
+
+		list_for_each_entry(grp, &pmx->groups, node) {
+			ops->disable(pctldev, pmx->func_selector,
+				     grp->group_selector);
+		}
+	}
+	mutex_unlock(&pmx->mutex);
+}
+EXPORT_SYMBOL_GPL(pinmux_disable);
+
+int pinmux_check_ops(const struct pinmux_ops *ops)
+{
+	/* Check that we implement required operations */
+	if (!ops->list_functions ||
+	    !ops->get_function_name ||
+	    !ops->get_function_groups ||
+	    !ops->enable ||
+	    !ops->disable)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* Hog a single map entry and add to the hoglist */
+static int pinmux_hog_map(struct pinctrl_dev *pctldev,
+			  struct pinmux_map const *map)
+{
+	struct pinmux_hog *hog;
+	struct pinmux *pmx;
+	int ret;
+
+	if (map->dev || map->dev_name) {
+		/*
+		 * TODO: the day we have device tree support, we can
+		 * traverse the device tree and hog to specific device nodes
+		 * without any problems, so then we can hog pinmuxes for
+		 * all devices that just want a static pin mux at this point.
+		 */
+		dev_err(&pctldev->dev, "map %s wants to hog a non-system "
+			"pinmux, this is not going to work\n", map->name);
+		return -EINVAL;
+	}
+
+	hog = kzalloc(sizeof(struct pinmux_hog), GFP_KERNEL);
+	if (!hog)
+		return -ENOMEM;
+
+	pmx = pinmux_get(NULL, map->name);
+	if (IS_ERR(pmx)) {
+		kfree(hog);
+		dev_err(&pctldev->dev,
+			"could not get the %s pinmux mapping for hogging\n",
+			map->name);
+		return PTR_ERR(pmx);
+	}
+
+	ret = pinmux_enable(pmx);
+	if (ret) {
+		pinmux_put(pmx);
+		kfree(hog);
+		dev_err(&pctldev->dev,
+			"could not enable the %s pinmux mapping for hogging\n",
+			map->name);
+		return ret;
+	}
+
+	hog->map = map;
+	hog->pmx = pmx;
+
+	dev_info(&pctldev->dev, "hogged map %s, function %s\n", map->name,
+		 map->function);
+	mutex_lock(&pctldev->pinmux_hogs_lock);
+	list_add(&hog->node, &pctldev->pinmux_hogs);
+	mutex_unlock(&pctldev->pinmux_hogs_lock);
+
+	return 0;
+}
+
+/**
+ * pinmux_hog_maps() - hog specific map entries on controller device
+ * @pctldev: the pin control device to hog entries on
+ *
+ * When the pin controllers are registered, there may be some specific pinmux
+ * map entries that need to be hogged, i.e. get+enabled until the system shuts
+ * down.
+ */
+int pinmux_hog_maps(struct pinctrl_dev *pctldev)
+{
+	struct device *dev = &pctldev->dev;
+	const char *devname = dev_name(dev);
+	int ret;
+	int i;
+
+	INIT_LIST_HEAD(&pctldev->pinmux_hogs);
+	mutex_init(&pctldev->pinmux_hogs_lock);
+
+	for (i = 0; i < pinmux_maps_num; i++) {
+		struct pinmux_map const *map = &pinmux_maps[i];
+
+		if (((map->ctrl_dev == dev) ||
+		     !strcmp(map->ctrl_dev_name, devname)) &&
+		    map->hog_on_boot) {
+			/* OK time to hog! */
+			ret = pinmux_hog_map(pctldev, map);
+			if (ret)
+				return ret;
+		}
+	}
+	return 0;
+}
+
+/**
+ * pinmux_hog_maps() - unhog specific map entries on controller device
+ * @pctldev: the pin control device to unhog entries on
+ */
+void pinmux_unhog_maps(struct pinctrl_dev *pctldev)
+{
+	struct list_head *node, *tmp;
+
+	mutex_lock(&pctldev->pinmux_hogs_lock);
+	list_for_each_safe(node, tmp, &pctldev->pinmux_hogs) {
+		struct pinmux_hog *hog =
+			list_entry(node, struct pinmux_hog, node);
+		pinmux_disable(hog->pmx);
+		pinmux_put(hog->pmx);
+		list_del(node);
+		kfree(hog);
+	}
+	mutex_unlock(&pctldev->pinmux_hogs_lock);
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+/* Called from pincontrol core */
+static int pinmux_functions_show(struct seq_file *s, void *what)
+{
+	struct pinctrl_dev *pctldev = s->private;
+	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
+	unsigned func_selector = 0;
+
+	while (pmxops->list_functions(pctldev, func_selector) >= 0) {
+		const char *func = pmxops->get_function_name(pctldev,
+							  func_selector);
+		const char * const *groups;
+		unsigned num_groups;
+		int ret;
+		int i;
+
+		ret = pmxops->get_function_groups(pctldev, func_selector,
+						  &groups, &num_groups);
+		if (ret)
+			seq_printf(s, "function %s: COULD NOT GET GROUPS\n",
+				   func);
+
+		seq_printf(s, "function: %s, groups = [ ", func);
+		for (i = 0; i < num_groups; i++)
+			seq_printf(s, "%s ", groups[i]);
+		seq_puts(s, "]\n");
+
+		func_selector++;
+
+	}
+
+	return 0;
+}
+
+static int pinmux_pins_show(struct seq_file *s, void *what)
+{
+	struct pinctrl_dev *pctldev = s->private;
+	unsigned pin;
+
+	seq_puts(s, "Pinmux settings per pin\n");
+	seq_puts(s, "Format: pin (name): pinmuxfunction\n");
+
+	/* The highest pin number need to be included in the loop, thus <= */
+	for (pin = 0; pin <= pctldev->desc->maxpin; pin++) {
+
+		struct pin_desc *desc;
+
+		desc = pin_desc_get(pctldev, pin);
+		/* Pin space may be sparse */
+		if (desc == NULL)
+			continue;
+
+		seq_printf(s, "pin %d (%s): %s\n", pin,
+			   desc->name ? desc->name : "unnamed",
+			   desc->mux_requested ? desc->mux_function : "UNCLAIMED");
+	}
+
+	return 0;
+}
+
+static int pinmux_hogs_show(struct seq_file *s, void *what)
+{
+	struct pinctrl_dev *pctldev = s->private;
+	struct pinmux_hog *hog;
+
+	seq_puts(s, "Pinmux map hogs held by device\n");
+
+	list_for_each_entry(hog, &pctldev->pinmux_hogs, node)
+		seq_printf(s, "%s\n", hog->map->name);
+
+	return 0;
+}
+
+static int pinmux_show(struct seq_file *s, void *what)
+{
+	struct pinmux *pmx;
+
+	seq_puts(s, "Requested pinmuxes and their maps:\n");
+	list_for_each_entry(pmx, &pinmux_list, node) {
+		struct pinctrl_dev *pctldev = pmx->pctldev;
+		const struct pinmux_ops *pmxops;
+		const struct pinctrl_ops *pctlops;
+		struct pinmux_group *grp;
+
+		if (!pctldev) {
+			seq_puts(s, "NO PIN CONTROLLER DEVICE\n");
+			continue;
+		}
+
+		pmxops = pctldev->desc->pmxops;
+		pctlops = pctldev->desc->pctlops;
+
+		seq_printf(s, "device: %s function: %s (%u),",
+			   pinctrl_dev_get_name(pmx->pctldev),
+			   pmxops->get_function_name(pctldev, pmx->func_selector),
+			   pmx->func_selector);
+
+		seq_printf(s, " groups: [");
+		list_for_each_entry(grp, &pmx->groups, node) {
+			seq_printf(s, " %s (%u)",
+				   pctlops->get_group_name(pctldev, grp->group_selector),
+				   grp->group_selector);
+		}
+		seq_printf(s, " ]");
+
+		seq_printf(s, " users: %u map-> %s\n",
+			   pmx->usecount,
+			   pmx->dev ? dev_name(pmx->dev) : "(system)");
+	}
+
+	return 0;
+}
+
+static int pinmux_maps_show(struct seq_file *s, void *what)
+{
+	int i;
+
+	seq_puts(s, "Pinmux maps:\n");
+
+	for (i = 0; i < pinmux_maps_num; i++) {
+		struct pinmux_map const *map = &pinmux_maps[i];
+
+		seq_printf(s, "%s:\n", map->name);
+		if (map->dev || map->dev_name)
+			seq_printf(s, "  device: %s\n",
+				   map->dev ? dev_name(map->dev) :
+				   map->dev_name);
+		else
+			seq_printf(s, "  SYSTEM MUX\n");
+		seq_printf(s, "  controlling device %s\n",
+			   map->ctrl_dev ? dev_name(map->ctrl_dev) :
+			   map->ctrl_dev_name);
+		seq_printf(s, "  function: %s\n", map->function);
+		seq_printf(s, "  group: %s\n", map->group ? map->group :
+			   "(default)");
+	}
+	return 0;
+}
+
+static int pinmux_functions_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pinmux_functions_show, inode->i_private);
+}
+
+static int pinmux_pins_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pinmux_pins_show, inode->i_private);
+}
+
+static int pinmux_hogs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pinmux_hogs_show, inode->i_private);
+}
+
+static int pinmux_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pinmux_show, NULL);
+}
+
+static int pinmux_maps_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pinmux_maps_show, NULL);
+}
+
+static const struct file_operations pinmux_functions_ops = {
+	.open		= pinmux_functions_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations pinmux_pins_ops = {
+	.open		= pinmux_pins_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations pinmux_hogs_ops = {
+	.open		= pinmux_hogs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations pinmux_ops = {
+	.open		= pinmux_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations pinmux_maps_ops = {
+	.open		= pinmux_maps_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+void pinmux_init_device_debugfs(struct dentry *devroot,
+			 struct pinctrl_dev *pctldev)
+{
+	debugfs_create_file("pinmux-functions", S_IFREG | S_IRUGO,
+			    devroot, pctldev, &pinmux_functions_ops);
+	debugfs_create_file("pinmux-pins", S_IFREG | S_IRUGO,
+			    devroot, pctldev, &pinmux_pins_ops);
+	debugfs_create_file("pinmux-hogs", S_IFREG | S_IRUGO,
+			    devroot, pctldev, &pinmux_hogs_ops);
+}
+
+void pinmux_init_debugfs(struct dentry *subsys_root)
+{
+	debugfs_create_file("pinmuxes", S_IFREG | S_IRUGO,
+			    subsys_root, NULL, &pinmux_ops);
+	debugfs_create_file("pinmux-maps", S_IFREG | S_IRUGO,
+			    subsys_root, NULL, &pinmux_maps_ops);
+}
+
+#endif /* CONFIG_DEBUG_FS */
