commit 6793baa31d684f2cace0e2ee4af4bdbc993dbed8
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Feb 12 10:02:00 2020 +0100

    pinctrl: sh-pfc: gpio: Return early in gpio_pin_to_irq()
    
    As of commit 4adeabd042422cee ("pinctrl: sh-pfc: Remove hardcoded IRQ
    numbers"), only a single operation needs to be performed after finding
    the wanted pin.  Hence decrease the needed attention span of the casual
    reader by replacing the goto by a direct return.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200212090200.11106-1-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 8213e118aa40..9c6e931ae766 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -205,14 +205,11 @@ static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 
 		for (k = 0; gpios[k] >= 0; k++) {
 			if (gpios[k] == offset)
-				goto found;
+				return pfc->irqs[i];
 		}
 	}
 
 	return 0;
-
-found:
-	return pfc->irqs[i];
 }
 
 static int gpio_pin_setup(struct sh_pfc_chip *chip)

commit 1d0f9e1e1e46939ae52804917647982b43754996
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Nov 13 11:18:09 2019 +0100

    pinctrl: sh-pfc: Make legacy function GPIO handling less fragile
    
    If there are no function GPIOs, sh_pfc_register_gpiochip() returns early
    with a success indicator.  This is fragile, as new code may be added
    after the #ifdef block, which won't be executed in case of early return.
    
    Invert the logic, so the code always continues until the end of the
    function on success.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20191113101809.28600-1-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 5a55b8da7919..8213e118aa40 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -386,12 +386,11 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	}
 
 	/* Register the function GPIOs chip. */
-	if (pfc->info->nr_func_gpios == 0)
-		return 0;
-
-	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup, NULL);
-	if (IS_ERR(chip))
-		return PTR_ERR(chip);
+	if (pfc->info->nr_func_gpios) {
+		chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup, NULL);
+		if (IS_ERR(chip))
+			return PTR_ERR(chip);
+	}
 #endif /* CONFIG_PINCTRL_SH_FUNC_GPIO */
 
 	return 0;

commit df62267ddec54d93b6e280ba57052e7ecf3633f4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Aug 14 09:20:32 2019 +0200

    pinctrl: sh-pfc: Include the right header
    
    This is a GPIO driver, use the appropriate header
    <linux/gpio/driver.h> rather than the legacy <linux/gpio.h>
    header.
    
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 64c09aa374ae..5a55b8da7919 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -7,7 +7,7 @@
  */
 
 #include <linux/device.h>
-#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/pinctrl/consumer.h>

commit 6da53cfa0f8300c85c7b63c9a6951400474a142c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jul 31 11:41:16 2019 +0200

    pinctrl: sh-pfc: Use dev_notice_once() instead of open-coding
    
    At the time of commit 9a643c9a11259955 ("sh-pfc: Convert message
    printing from pr_* to dev_*"), the dev_*_once() variants didn't exist
    yet, so the once behavior was open-coded.
    
    Since commit e135303bd5bebcd2 ("device: Add dev_<level>_once variants")
    they do, so "revert" to the good practice of using a helper.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Ulrich Hecht <uli+renesas@fpond.eu>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 97c1332c1045..64c09aa374ae 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -255,18 +255,13 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
 #ifdef CONFIG_PINCTRL_SH_FUNC_GPIO
 static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 {
-	static bool __print_once;
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
 	unsigned int mark = pfc->info->func_gpios[offset].enum_id;
 	unsigned long flags;
 	int ret;
 
-	if (!__print_once) {
-		dev_notice(pfc->dev,
-			   "Use of GPIO API for function requests is deprecated."
-			   " Convert to pinctrl\n");
-		__print_once = true;
-	}
+	dev_notice_once(pfc->dev,
+			"Use of GPIO API for function requests is deprecated, convert to pinctrl\n");
 
 	if (mark == 0)
 		return -EINVAL;

commit 0ace959614bc2bbea9efde24b150f6c5513f1980
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Jan 21 17:05:45 2019 +0100

    pinctrl: sh-pfc: Introduce PINCTRL_SH_FUNC_GPIO helper symbol
    
    Pinctrl drivers for SuperH platforms use legacy function GPIOs.
    Currently this support is compiled in based on the SUPERH platform
    dependency, which hinders the introduction of compile-testing support
    for the affected pinctrl drivers.
    
    Introduce a new Kconfig symbol PINCTRL_SH_FUNC_GPIO, which is
    auto-selected when needed.  This symbol in turn selects
    PINCTRL_SH_PFC_GPIO, to reduce the number of per-driver selects.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 4f3a34ee1cd4..97c1332c1045 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -252,7 +252,7 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
  * Function GPIOs
  */
 
-#ifdef CONFIG_SUPERH
+#ifdef CONFIG_PINCTRL_SH_FUNC_GPIO
 static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 {
 	static bool __print_once;
@@ -292,7 +292,7 @@ static int gpio_function_setup(struct sh_pfc_chip *chip)
 
 	return 0;
 }
-#endif
+#endif /* CONFIG_PINCTRL_SH_FUNC_GPIO */
 
 /* -----------------------------------------------------------------------------
  * Register/unregister
@@ -369,7 +369,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	if (IS_ENABLED(CONFIG_OF) && pfc->dev->of_node)
 		return 0;
 
-#ifdef CONFIG_SUPERH
+#ifdef CONFIG_PINCTRL_SH_FUNC_GPIO
 	/*
 	 * Register the GPIO to pin mappings. As pins with GPIO ports
 	 * must come first in the ranges, skip the pins without GPIO
@@ -397,7 +397,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup, NULL);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);
-#endif /* CONFIG_SUPERH */
+#endif /* CONFIG_PINCTRL_SH_FUNC_GPIO */
 
 	return 0;
 }

commit 63b6d7e762cb434a71588e1a824207f4d65a6745
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Sep 7 02:13:29 2018 +0000

    pinctrl: sh-pfc: Convert to SPDX identifiers
    
    This patch updates license to use SPDX-License-Identifier
    instead of verbose license text.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 6ffdc6beb203..4f3a34ee1cd4 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * SuperH Pin Function Controller GPIO driver.
  *
  * Copyright (C) 2008 Magnus Damm
  * Copyright (C) 2009 - 2012 Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 
 #include <linux/device.h>

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 946d9be50b62..6ffdc6beb203 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -107,7 +107,7 @@ static int gpio_setup_data_regs(struct sh_pfc_chip *chip)
 	for (i = 0; pfc->info->data_regs[i].reg_width; ++i)
 		;
 
-	chip->regs = devm_kzalloc(pfc->dev, i * sizeof(*chip->regs),
+	chip->regs = devm_kcalloc(pfc->dev, i, sizeof(*chip->regs),
 				  GFP_KERNEL);
 	if (chip->regs == NULL)
 		return -ENOMEM;
@@ -224,8 +224,9 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
 	struct gpio_chip *gc = &chip->gpio_chip;
 	int ret;
 
-	chip->pins = devm_kzalloc(pfc->dev, pfc->info->nr_pins *
-				  sizeof(*chip->pins), GFP_KERNEL);
+	chip->pins = devm_kcalloc(pfc->dev,
+				  pfc->info->nr_pins, sizeof(*chip->pins),
+				  GFP_KERNEL);
 	if (chip->pins == NULL)
 		return -ENOMEM;
 

commit a9a1d2a7827c9cf780966d0879c73ef5a91380e9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Sep 22 11:02:10 2017 +0200

    pinctrl/gpio: Unify namespace for cross-calls
    
    The pinctrl_request_gpio() and pinctrl_free_gpio() break the nice
    namespacing in the other cross-calls like pinctrl_gpio_foo().
    Just rename them and all references so we have one namespace
    with all cross-calls under pinctrl_gpio_*().
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 6b5422766f13..946d9be50b62 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -139,12 +139,12 @@ static int gpio_pin_request(struct gpio_chip *gc, unsigned offset)
 	if (idx < 0 || pfc->info->pins[idx].enum_id == 0)
 		return -EINVAL;
 
-	return pinctrl_request_gpio(offset);
+	return pinctrl_gpio_request(offset);
 }
 
 static void gpio_pin_free(struct gpio_chip *gc, unsigned offset)
 {
-	return pinctrl_free_gpio(offset);
+	return pinctrl_gpio_free(offset);
 }
 
 static void gpio_pin_set_value(struct sh_pfc_chip *chip, unsigned offset,

commit c29e2f2cb6ceb574ac9bc2f324a13f0e6b08115a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jun 10 11:22:44 2016 +0200

    pinctrl: sh-pfc: Convert to devm_gpiochip_add_data()
    
    This allows to remove the .remove() callback, and all functions and data
    it needed for its own bookkeeping.
    
    Suggested-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 97dff6a09ff0..6b5422766f13 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -318,7 +318,7 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *),
 	if (ret < 0)
 		return ERR_PTR(ret);
 
-	ret = gpiochip_add_data(&chip->gpio_chip, chip);
+	ret = devm_gpiochip_add_data(pfc->dev, &chip->gpio_chip, chip);
 	if (unlikely(ret < 0))
 		return ERR_PTR(ret);
 
@@ -399,18 +399,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup, NULL);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);
-
-	pfc->func = chip;
 #endif /* CONFIG_SUPERH */
 
 	return 0;
 }
-
-int sh_pfc_unregister_gpiochip(struct sh_pfc *pfc)
-{
-	gpiochip_remove(&pfc->gpio->gpio_chip);
-#ifdef CONFIG_SUPERH
-	gpiochip_remove(&pfc->func->gpio_chip);
-#endif
-	return 0;
-}

commit 9697643ff3edca036e8843235cd6e4d598a50e63
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed May 4 10:21:53 2016 +0200

    pinctrl: sh-pfc: Let gpio_chip.to_irq() return zero on error
    
    Currrently the gpio_chip.to_irq() callback returns -ENOSYS on error,
    which causes bad interactions with the serial_mctrl_gpio helpers.
    
    mctrl_gpio_init() returns -ENOSYS if GPIOLIB is not enabled, which is
    intended to be ignored by its callers. However, ignoring -ENOSYS when it
    was caused by a gpiod_to_irq() failure will lead to a crash later:
    
        Unable to handle kernel paging request at virtual address ffffffde
        ...
        PC is at mctrl_gpio_set+0x14/0x78
    
    Fix this by returning zero instead, like gpiochip_to_irq() does.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index a6681b8b17c3..97dff6a09ff0 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -212,7 +212,7 @@ static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 		}
 	}
 
-	return -ENOSYS;
+	return 0;
 
 found:
 	return pfc->irqs[i];

commit 7cb093c4bce3a145cc1586d4464cd362376c2cc6
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 8 10:24:54 2015 +0100

    pinctrl: sh-pfc: use gpiochip data pointer
    
    This makes the driver use the data pointer added to the gpio_chip
    to store a pointer to the state container instead of relying on
    container_of().
    
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index cdb2460a7b00..a6681b8b17c3 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -38,14 +38,10 @@ struct sh_pfc_chip {
 	struct sh_pfc_gpio_pin		*pins;
 };
 
-static struct sh_pfc_chip *gpio_to_pfc_chip(struct gpio_chip *gc)
-{
-	return container_of(gc, struct sh_pfc_chip, gpio_chip);
-}
-
 static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 {
-	return gpio_to_pfc_chip(gc)->pfc;
+	struct sh_pfc_chip *chip = gpiochip_get_data(gc);
+	return chip->pfc;
 }
 
 static void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int offset,
@@ -178,14 +174,14 @@ static int gpio_pin_direction_input(struct gpio_chip *gc, unsigned offset)
 static int gpio_pin_direction_output(struct gpio_chip *gc, unsigned offset,
 				    int value)
 {
-	gpio_pin_set_value(gpio_to_pfc_chip(gc), offset, value);
+	gpio_pin_set_value(gpiochip_get_data(gc), offset, value);
 
 	return pinctrl_gpio_direction_output(offset);
 }
 
 static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 {
-	struct sh_pfc_chip *chip = gpio_to_pfc_chip(gc);
+	struct sh_pfc_chip *chip = gpiochip_get_data(gc);
 	struct sh_pfc_gpio_data_reg *reg;
 	unsigned int bit;
 	unsigned int pos;
@@ -199,7 +195,7 @@ static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 
 static void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)
 {
-	gpio_pin_set_value(gpio_to_pfc_chip(gc), offset, value);
+	gpio_pin_set_value(gpiochip_get_data(gc), offset, value);
 }
 
 static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
@@ -322,7 +318,7 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *),
 	if (ret < 0)
 		return ERR_PTR(ret);
 
-	ret = gpiochip_add(&chip->gpio_chip);
+	ret = gpiochip_add_data(&chip->gpio_chip, chip);
 	if (unlikely(ret < 0))
 		return ERR_PTR(ret);
 

commit 58383c78425e4ee1c077253cf297b641c861c02e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 4 09:56:26 2015 +0100

    gpio: change member .dev to .parent
    
    The name .dev in a struct is normally reserved for a struct device
    that is let us say a superclass to the thing described by the struct.
    struct gpio_chip stands out by confusingly using a struct device *dev
    to point to the parent device (such as a platform_device) that
    represents the hardware. As we want to give gpio_chip:s real devices,
    this is not working. We need to rename this member to parent.
    
    This was done by two coccinelle scripts, I guess it is possible to
    combine them into one, but I don't know such stuff. They look like
    this:
    
    @@
    struct gpio_chip *var;
    @@
    -var->dev
    +var->parent
    
    and:
    
    @@
    struct gpio_chip var;
    @@
    -var.dev
    +var.parent
    
    and:
    
    @@
    struct bgpio_chip *var;
    @@
    -var->gc.dev
    +var->gc.parent
    
    Plus a few instances of bgpio that I couldn't figure out how
    to teach Coccinelle to rewrite.
    
    This patch hits all over the place, but I *strongly* prefer this
    solution to any piecemal approaches that just exercise patch
    mechanics all over the place. It mainly hits drivers/gpio and
    drivers/pinctrl which is my own backyard anyway.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Alek Du <alek.du@intel.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index db3f09aa8993..cdb2460a7b00 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -246,7 +246,7 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
 	gc->to_irq = gpio_pin_to_irq;
 
 	gc->label = pfc->info->name;
-	gc->dev = pfc->dev;
+	gc->parent = pfc->dev;
 	gc->owner = THIS_MODULE;
 	gc->base = 0;
 	gc->ngpio = pfc->nr_gpio_pins;

commit 4adeabd042422ceecd7605961d785c5c3edab9e1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Sep 22 10:08:13 2015 +0300

    pinctrl: sh-pfc: Remove hardcoded IRQ numbers
    
    Now that all ARM-based Renesas SoCs use multiplatform kernels only the
    hardcoded IRQ numbers can be dropped as they're dynamically allocated.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index a917c62f0712..db3f09aa8993 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -219,10 +219,7 @@ static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 	return -ENOSYS;
 
 found:
-	if (pfc->num_irqs)
-		return pfc->irqs[i];
-	else
-		return pfc->info->gpio_irq[i].irq;
+	return pfc->irqs[i];
 }
 
 static int gpio_pin_setup(struct sh_pfc_chip *chip)
@@ -363,7 +360,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 		return 0;
 
 	/* If we have IRQ resources make sure their number is correct. */
-	if (pfc->num_irqs && pfc->num_irqs != pfc->info->gpio_irq_size) {
+	if (pfc->num_irqs != pfc->info->gpio_irq_size) {
 		dev_err(pfc->dev, "invalid number of IRQ resources\n");
 		return -EINVAL;
 	}

commit 90d066130f69533fb16b395be3de613903575e69
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Aug 27 22:07:23 2015 +0200

    pinctrl: sh-pfc: Get rid of CONFIG_ARCH_SHMOBILE_LEGACY
    
    Shmobile is all multiplatform these days, so get rid of the reference to
    CONFIG_ARCH_SHMOBILE_LEGACY.
    
    Move the legacy code to do the non-DT mapping between GPIOs and pins
    inside the existing #ifdef CONFIG_SUPERH section.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 685b3c24627d..a917c62f0712 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -341,7 +341,6 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	struct sh_pfc_chip *chip;
 	phys_addr_t address;
 	unsigned int i;
-	int ret;
 
 	if (pfc->info->data_regs == NULL)
 		return 0;
@@ -379,29 +378,27 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	if (IS_ENABLED(CONFIG_OF) && pfc->dev->of_node)
 		return 0;
 
-	if (IS_ENABLED(CONFIG_SUPERH) ||
-	    IS_ENABLED(CONFIG_ARCH_SHMOBILE_LEGACY)) {
-		/*
-		 * Register the GPIO to pin mappings. As pins with GPIO ports
-		 * must come first in the ranges, skip the pins without GPIO
-		 * ports by stopping at the first range that contains such a
-		 * pin.
-		 */
-		for (i = 0; i < pfc->nr_ranges; ++i) {
-			const struct sh_pfc_pin_range *range = &pfc->ranges[i];
-
-			if (range->start >= pfc->nr_gpio_pins)
-				break;
-
-			ret = gpiochip_add_pin_range(&chip->gpio_chip,
-				dev_name(pfc->dev), range->start, range->start,
-				range->end - range->start + 1);
-			if (ret < 0)
-				return ret;
-		}
+#ifdef CONFIG_SUPERH
+	/*
+	 * Register the GPIO to pin mappings. As pins with GPIO ports
+	 * must come first in the ranges, skip the pins without GPIO
+	 * ports by stopping at the first range that contains such a
+	 * pin.
+	 */
+	for (i = 0; i < pfc->nr_ranges; ++i) {
+		const struct sh_pfc_pin_range *range = &pfc->ranges[i];
+		int ret;
+
+		if (range->start >= pfc->nr_gpio_pins)
+			break;
+
+		ret = gpiochip_add_pin_range(&chip->gpio_chip,
+			dev_name(pfc->dev), range->start, range->start,
+			range->end - range->start + 1);
+		if (ret < 0)
+			return ret;
 	}
 
-#ifdef CONFIG_SUPERH
 	/* Register the function GPIOs chip. */
 	if (pfc->info->nr_func_gpios == 0)
 		return 0;

commit 56f891b46d37e8c7b04db660d6e9ad05e586203c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Aug 4 15:55:19 2015 +0200

    pinctrl: sh-pfc: Confine legacy function GPIOs to SH
    
    Legacy function GPIOs are no longer used on ARM since commit
    a27c5cd1a08cc95c ("sh-pfc: sh73a0: Remove function GPIOs").
    Extract its setup code into a separate function, and make all function
    GPIO related code and data depend on CONFIG_SUPERH.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index e46439030914..685b3c24627d 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -261,6 +261,7 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
  * Function GPIOs
  */
 
+#ifdef CONFIG_SUPERH
 static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 {
 	static bool __print_once;
@@ -300,6 +301,7 @@ static int gpio_function_setup(struct sh_pfc_chip *chip)
 
 	return 0;
 }
+#endif
 
 /* -----------------------------------------------------------------------------
  * Register/unregister
@@ -399,6 +401,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 		}
 	}
 
+#ifdef CONFIG_SUPERH
 	/* Register the function GPIOs chip. */
 	if (pfc->info->nr_func_gpios == 0)
 		return 0;
@@ -408,6 +411,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 		return PTR_ERR(chip);
 
 	pfc->func = chip;
+#endif /* CONFIG_SUPERH */
 
 	return 0;
 }
@@ -415,7 +419,8 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 int sh_pfc_unregister_gpiochip(struct sh_pfc *pfc)
 {
 	gpiochip_remove(&pfc->gpio->gpio_chip);
+#ifdef CONFIG_SUPERH
 	gpiochip_remove(&pfc->func->gpio_chip);
-
+#endif
 	return 0;
 }

commit 57106e5ca55bea70e3e296a3e7546aefe0d1dabe
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Aug 4 15:55:18 2015 +0200

    pinctrl: sh-pfc: Remove empty gpio_function_free()
    
    gpio_chip.free() is optional, and can just be left unimplemented.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index b380e3f17b12..e46439030914 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -286,17 +286,12 @@ static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 	return ret;
 }
 
-static void gpio_function_free(struct gpio_chip *gc, unsigned offset)
-{
-}
-
 static int gpio_function_setup(struct sh_pfc_chip *chip)
 {
 	struct sh_pfc *pfc = chip->pfc;
 	struct gpio_chip *gc = &chip->gpio_chip;
 
 	gc->request = gpio_function_request;
-	gc->free = gpio_function_free;
 
 	gc->label = pfc->info->name;
 	gc->owner = THIS_MODULE;

commit 18fab3995e8a6c4e3ffe2adced0ffa76eebdc989
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Aug 4 15:55:17 2015 +0200

    pinctrl: sh-pfc: Stop calling gpiochip_add_pin_range() on DT platforms
    
    On platforms where the PFC/GPIO controller is instantiated from DT, the
    mapping between GPIOs and pins is set up using the "gpio-ranges"
    property in DT.
    
    Hence stop setting up the mapping from C code on DT platforms.
    This code is still used for SH or ARM-legacy platforms.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index ba353735ecf2..b380e3f17b12 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -379,22 +379,29 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 
 	pfc->gpio = chip;
 
-	/* Register the GPIO to pin mappings. As pins with GPIO ports must come
-	 * first in the ranges, skip the pins without GPIO ports by stopping at
-	 * the first range that contains such a pin.
-	 */
-	for (i = 0; i < pfc->nr_ranges; ++i) {
-		const struct sh_pfc_pin_range *range = &pfc->ranges[i];
-
-		if (range->start >= pfc->nr_gpio_pins)
-			break;
+	if (IS_ENABLED(CONFIG_OF) && pfc->dev->of_node)
+		return 0;
 
-		ret = gpiochip_add_pin_range(&chip->gpio_chip,
-					     dev_name(pfc->dev),
-					     range->start, range->start,
-					     range->end - range->start + 1);
-		if (ret < 0)
-			return ret;
+	if (IS_ENABLED(CONFIG_SUPERH) ||
+	    IS_ENABLED(CONFIG_ARCH_SHMOBILE_LEGACY)) {
+		/*
+		 * Register the GPIO to pin mappings. As pins with GPIO ports
+		 * must come first in the ranges, skip the pins without GPIO
+		 * ports by stopping at the first range that contains such a
+		 * pin.
+		 */
+		for (i = 0; i < pfc->nr_ranges; ++i) {
+			const struct sh_pfc_pin_range *range = &pfc->ranges[i];
+
+			if (range->start >= pfc->nr_gpio_pins)
+				break;
+
+			ret = gpiochip_add_pin_range(&chip->gpio_chip,
+				dev_name(pfc->dev), range->start, range->start,
+				range->end - range->start + 1);
+			if (ret < 0)
+				return ret;
+		}
 	}
 
 	/* Register the function GPIOs chip. */

commit 1f34de05e75a26e8f4dfe7566fe80309aabf10b7
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Mar 12 11:09:16 2015 +0100

    pinctrl: sh-pfc: Use u32 to store register addresses
    
    Currently all PFC registers lie in low 32-bit address space. Hence use
    u32 instead of unsigned long to store PFC register addresses in pinctrl
    tables.  All calculations of virtual addresses use a phys_addr_t
    intermediate, so we know where to add an offset if the 32-bit assumption
    ever becomes false.
    
    While this doesn't impact 32-bit builds, it would save ca. 7 KiB on a
    64-bit shmobile_defconfig kernel.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 5d3a35ce0912..ba353735ecf2 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -62,7 +62,8 @@ static void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int offset,
 static u32 gpio_read_data_reg(struct sh_pfc_chip *chip,
 			      const struct pinmux_data_reg *dreg)
 {
-	void __iomem *mem = dreg->reg - chip->mem->phys + chip->mem->virt;
+	phys_addr_t address = dreg->reg;
+	void __iomem *mem = address - chip->mem->phys + chip->mem->virt;
 
 	return sh_pfc_read_raw_reg(mem, dreg->reg_width);
 }
@@ -70,7 +71,8 @@ static u32 gpio_read_data_reg(struct sh_pfc_chip *chip,
 static void gpio_write_data_reg(struct sh_pfc_chip *chip,
 				const struct pinmux_data_reg *dreg, u32 value)
 {
-	void __iomem *mem = dreg->reg - chip->mem->phys + chip->mem->virt;
+	phys_addr_t address = dreg->reg;
+	void __iomem *mem = address - chip->mem->phys + chip->mem->virt;
 
 	sh_pfc_write_raw_reg(mem, dreg->reg_width, value);
 }
@@ -340,6 +342,7 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *),
 int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 {
 	struct sh_pfc_chip *chip;
+	phys_addr_t address;
 	unsigned int i;
 	int ret;
 
@@ -351,11 +354,12 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	 * that covers the data registers. In that case don't try to handle
 	 * GPIOs.
 	 */
+	address = pfc->info->data_regs[0].reg;
 	for (i = 0; i < pfc->num_windows; ++i) {
 		struct sh_pfc_window *window = &pfc->windows[i];
 
-		if (pfc->info->data_regs[0].reg >= window->phys &&
-		    pfc->info->data_regs[0].reg < window->phys + window->size)
+		if (address >= window->phys &&
+		    address < window->phys + window->size)
 			break;
 	}
 

commit 17c7cbb0e7b7a877f1ce2063d7f869801b24cd6a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Mar 12 11:09:15 2015 +0100

    pinctrl: sh-pfc: Use reg_width instead of reg as sentinel
    
    All other loops over sh_pfc_soc_info.data_regs[] use
    pinmux_data_reg.regwidth as the sentinel, which is safer as zero is
    never a valid regwidth value (reg could be zero if we start using it to
    store an offset).
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index aa2fc77a1925..5d3a35ce0912 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -84,7 +84,7 @@ static void gpio_setup_data_reg(struct sh_pfc_chip *chip, unsigned idx)
 	unsigned int bit;
 	unsigned int i;
 
-	for (i = 0, dreg = pfc->info->data_regs; dreg->reg; ++i, ++dreg) {
+	for (i = 0, dreg = pfc->info->data_regs; dreg->reg_width; ++i, ++dreg) {
 		for (bit = 0; bit < dreg->reg_width; bit++) {
 			if (dreg->enum_ids[bit] == pin->enum_id) {
 				gpio_pin->dreg = i;

commit cef28a289482175b26f7a5ae4a1337c792cea9c5
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Mar 12 11:09:14 2015 +0100

    pinctrl: sh-pfc: Use unsigned int for register/field widths and offsets
    
    As register and field widths and offsets are in the range 1..32, use
    unsigned int (mostly replacing unsigned long) to store them in local
    variables and for passing them around.
    
    Move to one variable per line, move variables to the beginning of the
    block where they are used, and drop superfluous initializations while we
    are at it.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index f2bb7d7398cd..aa2fc77a1925 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -153,8 +153,8 @@ static void gpio_pin_set_value(struct sh_pfc_chip *chip, unsigned offset,
 			       int value)
 {
 	struct sh_pfc_gpio_data_reg *reg;
-	unsigned long pos;
 	unsigned int bit;
+	unsigned int pos;
 
 	gpio_get_data_reg(chip, offset, &reg, &bit);
 
@@ -185,8 +185,8 @@ static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc_chip *chip = gpio_to_pfc_chip(gc);
 	struct sh_pfc_gpio_data_reg *reg;
-	unsigned long pos;
 	unsigned int bit;
+	unsigned int pos;
 
 	gpio_get_data_reg(chip, offset, &reg, &bit);
 

commit fc88936ad307dc57cd26cb53455a57e2dd0813b9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Feb 27 18:38:04 2015 +0100

    pinctrl: sh-pfc: Use u32 to store register data
    
    As PFC registers are either 8, 16, or 32 bits wide, use u32 (mostly
    replacing unsigned long) to store (parts of) register values and masks.
    
    Switch the shadow register operations from {set,clear}_bit() to plain C
    bit operations, as the former can operate on long data only.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 80f641ee4dea..f2bb7d7398cd 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -21,7 +21,7 @@
 
 struct sh_pfc_gpio_data_reg {
 	const struct pinmux_data_reg *info;
-	unsigned long shadow;
+	u32 shadow;
 };
 
 struct sh_pfc_gpio_pin {
@@ -59,8 +59,8 @@ static void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int offset,
 	*bit = gpio_pin->dbit;
 }
 
-static unsigned long gpio_read_data_reg(struct sh_pfc_chip *chip,
-					const struct pinmux_data_reg *dreg)
+static u32 gpio_read_data_reg(struct sh_pfc_chip *chip,
+			      const struct pinmux_data_reg *dreg)
 {
 	void __iomem *mem = dreg->reg - chip->mem->phys + chip->mem->virt;
 
@@ -68,8 +68,7 @@ static unsigned long gpio_read_data_reg(struct sh_pfc_chip *chip,
 }
 
 static void gpio_write_data_reg(struct sh_pfc_chip *chip,
-				const struct pinmux_data_reg *dreg,
-				unsigned long value)
+				const struct pinmux_data_reg *dreg, u32 value)
 {
 	void __iomem *mem = dreg->reg - chip->mem->phys + chip->mem->virt;
 
@@ -162,9 +161,9 @@ static void gpio_pin_set_value(struct sh_pfc_chip *chip, unsigned offset,
 	pos = reg->info->reg_width - (bit + 1);
 
 	if (value)
-		set_bit(pos, &reg->shadow);
+		reg->shadow |= BIT(pos);
 	else
-		clear_bit(pos, &reg->shadow);
+		reg->shadow &= ~BIT(pos);
 
 	gpio_write_data_reg(chip, reg->info, reg->shadow);
 }

commit b4e7c55dabf611cf5cccd1554fec06f72e1c9faf
Author: abdoulaye berthe <berthe.ab@gmail.com>
Date:   Sat Jul 12 22:30:13 2014 +0200

    pinctrl: remove all usage of gpio_remove ret val in driver/pinctl
    
    Signed-off-by: abdoulaye berthe <berthe.ab@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index a9288ab01f7b..80f641ee4dea 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -409,11 +409,8 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 
 int sh_pfc_unregister_gpiochip(struct sh_pfc *pfc)
 {
-	int err;
-	int ret;
-
-	ret = gpiochip_remove(&pfc->gpio->gpio_chip);
-	err = gpiochip_remove(&pfc->func->gpio_chip);
+	gpiochip_remove(&pfc->gpio->gpio_chip);
+	gpiochip_remove(&pfc->func->gpio_chip);
 
-	return ret < 0 ? ret : err;
+	return 0;
 }

commit 6d5bddd5258c11f58cc6a6d17cd97ce5ad39a270
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Dec 16 20:25:15 2013 +0100

    pinctrl: sh-pfc: Constify IRQ GPIOs arrays
    
    The arrays are never modified, make them const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 63480815e1af..a9288ab01f7b 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -207,7 +207,7 @@ static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 	unsigned int i, k;
 
 	for (i = 0; i < pfc->info->gpio_irq_size; i++) {
-		short *gpios = pfc->info->gpio_irq[i].gpios;
+		const short *gpios = pfc->info->gpio_irq[i].gpios;
 
 		for (k = 0; gpios[k] >= 0; k++) {
 			if (gpios[k] == offset)

commit 70c8f01a357ac74d223a632659787396fef1e649
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Dec 11 04:26:26 2013 +0100

    sh-pfc: Support GPIO to IRQ mapping specified IRQ resources
    
    On non-DT platforms IRQ controllers associated with the GPIOs have a
    fixed IRQ base value known at compile time. The sh-pfc driver translates
    GPIO number to IRQ numbers using a hardcoded table. This mechanism
    breaks on DT platforms, as the IRQ base values are dynamic in that case.
    
    Fix this by specifying IRQs associated with GPIOs in IRQ resources,
    populated automatically from the device tree. When IRQ resources are
    specified the driver requires one IRQ resource per GPIO able to generate
    an interrupt, and uses the translation table to compute the IRQ resource
    offset instead of the IRQ number.
    
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 6a21349fb116..63480815e1af 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -211,11 +211,17 @@ static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 
 		for (k = 0; gpios[k] >= 0; k++) {
 			if (gpios[k] == offset)
-				return pfc->info->gpio_irq[i].irq;
+				goto found;
 		}
 	}
 
 	return -ENOSYS;
+
+found:
+	if (pfc->num_irqs)
+		return pfc->irqs[i];
+	else
+		return pfc->info->gpio_irq[i].irq;
 }
 
 static int gpio_pin_setup(struct sh_pfc_chip *chip)
@@ -357,6 +363,12 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	if (i == pfc->num_windows)
 		return 0;
 
+	/* If we have IRQ resources make sure their number is correct. */
+	if (pfc->num_irqs && pfc->num_irqs != pfc->info->gpio_irq_size) {
+		dev_err(pfc->dev, "invalid number of IRQ resources\n");
+		return -EINVAL;
+	}
+
 	/* Register the real GPIOs chip. */
 	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup, &pfc->windows[i]);
 	if (IS_ERR(chip))

commit 5b46ac3a7723636082ec6234289517ca5b9c65af
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Dec 11 04:26:25 2013 +0100

    sh-pfc: Rename sh_pfc window field to windows
    
    There's more than one window, name the field windows.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index c24be810f56c..6a21349fb116 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -347,7 +347,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	 * GPIOs.
 	 */
 	for (i = 0; i < pfc->num_windows; ++i) {
-		struct sh_pfc_window *window = &pfc->window[i];
+		struct sh_pfc_window *window = &pfc->windows[i];
 
 		if (pfc->info->data_regs[0].reg >= window->phys &&
 		    pfc->info->data_regs[0].reg < window->phys + window->size)
@@ -358,7 +358,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 		return 0;
 
 	/* Register the real GPIOs chip. */
-	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup, &pfc->window[i]);
+	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup, &pfc->windows[i]);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);
 

commit 316b2550015dc8d26fb1395826533e9ef3434da9
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Dec 11 04:26:22 2013 +0100

    sh-pfc: Terminate gpios array by -1
    
    0 is a valid GPIO value, use -1 to terminate the gpios array in IRQ
    lists.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 3d30e6ecdf4a..c24be810f56c 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -207,9 +207,9 @@ static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 	unsigned int i, k;
 
 	for (i = 0; i < pfc->info->gpio_irq_size; i++) {
-		unsigned short *gpios = pfc->info->gpio_irq[i].gpios;
+		short *gpios = pfc->info->gpio_irq[i].gpios;
 
-		for (k = 0; gpios[k]; k++) {
+		for (k = 0; gpios[k] >= 0; k++) {
 			if (gpios[k] == offset)
 				return pfc->info->gpio_irq[i].irq;
 		}

commit 8d72a7fc8dd74d41ec5f37b70797679e910007e0
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Dec 11 04:26:21 2013 +0100

    sh-pfc: Turn unsigned indices into unsigned int
    
    Some indices take positive values only, make them unsigned.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 04bf52b64fb3..3d30e6ecdf4a 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -204,7 +204,7 @@ static void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)
 static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	int i, k;
+	unsigned int i, k;
 
 	for (i = 0; i < pfc->info->gpio_irq_size; i++) {
 		unsigned short *gpios = pfc->info->gpio_irq[i].gpios;

commit 4f82e3ee724f1712f9e84b8802e24ea096a6089f
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 21:10:54 2013 +0200

    sh-pfc: Support pins not associated with a GPIO port
    
    Pins with selectable functions but without a GPIO port can't be named
    PORT_# or GP_#_#. Add a SH_PFC_PIN_NAMED macro to declare such pins in
    the pinmux pins array, naming them with the PIN_ prefix followed by the
    pin physical position.
    
    In order to make sure not to register those pins as GPIOs, add a
    SH_PFC_PIN_CFG_NO_GPIO pin flag to denote pins without a GPIO port.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 78fcb8029afd..04bf52b64fb3 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -364,10 +364,16 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 
 	pfc->gpio = chip;
 
-	/* Register the GPIO to pin mappings. */
+	/* Register the GPIO to pin mappings. As pins with GPIO ports must come
+	 * first in the ranges, skip the pins without GPIO ports by stopping at
+	 * the first range that contains such a pin.
+	 */
 	for (i = 0; i < pfc->nr_ranges; ++i) {
 		const struct sh_pfc_pin_range *range = &pfc->ranges[i];
 
+		if (range->start >= pfc->nr_gpio_pins)
+			break;
+
 		ret = gpiochip_add_pin_range(&chip->gpio_chip,
 					     dev_name(pfc->dev),
 					     range->start, range->start,

commit acac8ed5e2aa2c0d364d06f364fd9ed0dc27d28a
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 18:38:30 2013 +0200

    sh-pfc: Compute pin ranges automatically
    
    Remove the manually specified ranges from PFC SoC data and compute the
    ranges automatically. This prevents ranges from being out-of-sync with
    pins definitions.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 7661be5054a0..78fcb8029afd 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -334,10 +334,7 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *),
 
 int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 {
-	const struct pinmux_range *ranges;
-	struct pinmux_range def_range;
 	struct sh_pfc_chip *chip;
-	unsigned int nr_ranges;
 	unsigned int i;
 	int ret;
 
@@ -368,23 +365,13 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	pfc->gpio = chip;
 
 	/* Register the GPIO to pin mappings. */
-	if (pfc->info->ranges == NULL) {
-		def_range.begin = 0;
-		def_range.end = pfc->info->nr_pins - 1;
-		ranges = &def_range;
-		nr_ranges = 1;
-	} else {
-		ranges = pfc->info->ranges;
-		nr_ranges = pfc->info->nr_ranges;
-	}
-
-	for (i = 0; i < nr_ranges; ++i) {
-		const struct pinmux_range *range = &ranges[i];
+	for (i = 0; i < pfc->nr_ranges; ++i) {
+		const struct sh_pfc_pin_range *range = &pfc->ranges[i];
 
 		ret = gpiochip_add_pin_range(&chip->gpio_chip,
 					     dev_name(pfc->dev),
-					     range->begin, range->begin,
-					     range->end - range->begin + 1);
+					     range->start, range->start,
+					     range->end - range->start + 1);
 		if (ret < 0)
 			return ret;
 	}

commit 28818fa5dadfd458fa7e17c8be26b2d7edffa8bf
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 13:48:56 2013 +0200

    sh-pfc: Rename struct sh_pfc nr_pins field to nr_gpio_pins
    
    The field contains the number of pins with an associated GPIO port. This
    is currently equal to the total number of pins but will be modified when
    adding support for pins without a GPIO port. Rename the field
    accordingly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 87ae38b97a38..7661be5054a0 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -245,7 +245,7 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
 	gc->dev = pfc->dev;
 	gc->owner = THIS_MODULE;
 	gc->base = 0;
-	gc->ngpio = pfc->nr_pins;
+	gc->ngpio = pfc->nr_gpio_pins;
 
 	return 0;
 }
@@ -293,7 +293,7 @@ static int gpio_function_setup(struct sh_pfc_chip *chip)
 
 	gc->label = pfc->info->name;
 	gc->owner = THIS_MODULE;
-	gc->base = pfc->nr_pins;
+	gc->base = pfc->nr_gpio_pins;
 	gc->ngpio = pfc->info->nr_func_gpios;
 
 	return 0;

commit 757b055a65c5e0f84185012ef45cc2e15a337b63
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 13:25:08 2013 +0200

    sh-pfc: Rename gpio arguments to be consistent with the rest of the code
    
    The gpio_get_data_reg() and gpio_setup_data_reg() functions both take an
    argument named gpio. The argument contains a GPIO offset for the first
    function and a pin index for the second one. Rename them to offset and
    idx respectively to match the rest of the code.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 3620bd84ae93..87ae38b97a38 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -48,11 +48,11 @@ static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 	return gpio_to_pfc_chip(gc)->pfc;
 }
 
-static void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int gpio,
+static void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int offset,
 			      struct sh_pfc_gpio_data_reg **reg,
 			      unsigned int *bit)
 {
-	int idx = sh_pfc_get_pin_index(chip->pfc, gpio);
+	int idx = sh_pfc_get_pin_index(chip->pfc, offset);
 	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[idx];
 
 	*reg = &chip->regs[gpio_pin->dreg];
@@ -76,11 +76,11 @@ static void gpio_write_data_reg(struct sh_pfc_chip *chip,
 	sh_pfc_write_raw_reg(mem, dreg->reg_width, value);
 }
 
-static void gpio_setup_data_reg(struct sh_pfc_chip *chip, unsigned gpio)
+static void gpio_setup_data_reg(struct sh_pfc_chip *chip, unsigned idx)
 {
 	struct sh_pfc *pfc = chip->pfc;
-	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[gpio];
-	const struct sh_pfc_pin *pin = &pfc->info->pins[gpio];
+	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[idx];
+	const struct sh_pfc_pin *pin = &pfc->info->pins[idx];
 	const struct pinmux_data_reg *dreg;
 	unsigned int bit;
 	unsigned int i;

commit a1a3580cb322f71cc5aa7e9180ffb6df609b530d
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 13:36:39 2013 +0200

    sh-pfc: Don't overallocate memory for the GPIO chip pins array
    
    The GPIO driver uses an array of sh_pfc_gpio_pin structures to store
    per-GPIO pin data. The array size is miscomputed at allocation time by
    using the number of the last pin instead of the number of pins. When the
    pin space contains holes this leads to memory overallocation. Fix it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index d37efa7dcf90..3620bd84ae93 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -224,8 +224,8 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
 	struct gpio_chip *gc = &chip->gpio_chip;
 	int ret;
 
-	chip->pins = devm_kzalloc(pfc->dev, pfc->nr_pins * sizeof(*chip->pins),
-				  GFP_KERNEL);
+	chip->pins = devm_kzalloc(pfc->dev, pfc->info->nr_pins *
+				  sizeof(*chip->pins), GFP_KERNEL);
 	if (chip->pins == NULL)
 		return -ENOMEM;
 

commit ceef91dcc0bca0a39c54d2f0071848b6d5c66b88
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 03:19:44 2013 +0100

    sh-pfc: Skip gpiochip registration when no GPIO resource is found
    
    Boards/platforms that register dedicated GPIO devices will not supply a
    memory resource for GPIOs. Try to locate the GPIO memory resource at
    initialization time, and skip registration of the gpiochip if the
    resource can't be found.
    
    This is a temporary modification to ease the transition to separate GPIO
    drivers. It should be reverted when all boards and platforms will have
    been moved.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 317cebb0ee4d..d37efa7dcf90 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -101,24 +101,9 @@ static void gpio_setup_data_reg(struct sh_pfc_chip *chip, unsigned gpio)
 static int gpio_setup_data_regs(struct sh_pfc_chip *chip)
 {
 	struct sh_pfc *pfc = chip->pfc;
-	unsigned long addr = pfc->info->data_regs[0].reg;
 	const struct pinmux_data_reg *dreg;
 	unsigned int i;
 
-	/* Find the window that contain the GPIO registers. */
-	for (i = 0; i < pfc->num_windows; ++i) {
-		struct sh_pfc_window *window = &pfc->window[i];
-
-		if (addr >= window->phys && addr < window->phys + window->size)
-			break;
-	}
-
-	if (i == pfc->num_windows)
-		return -EINVAL;
-
-	/* GPIO data registers must be in the first memory resource. */
-	chip->mem = &pfc->window[i];
-
 	/* Count the number of data registers, allocate memory and initialize
 	 * them.
 	 */
@@ -319,7 +304,8 @@ static int gpio_function_setup(struct sh_pfc_chip *chip)
  */
 
 static struct sh_pfc_chip *
-sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *))
+sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *),
+		    struct sh_pfc_window *mem)
 {
 	struct sh_pfc_chip *chip;
 	int ret;
@@ -328,6 +314,7 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *))
 	if (unlikely(!chip))
 		return ERR_PTR(-ENOMEM);
 
+	chip->mem = mem;
 	chip->pfc = pfc;
 
 	ret = setup(chip);
@@ -357,8 +344,24 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	if (pfc->info->data_regs == NULL)
 		return 0;
 
+	/* Find the memory window that contain the GPIO registers. Boards that
+	 * register a separate GPIO device will not supply a memory resource
+	 * that covers the data registers. In that case don't try to handle
+	 * GPIOs.
+	 */
+	for (i = 0; i < pfc->num_windows; ++i) {
+		struct sh_pfc_window *window = &pfc->window[i];
+
+		if (pfc->info->data_regs[0].reg >= window->phys &&
+		    pfc->info->data_regs[0].reg < window->phys + window->size)
+			break;
+	}
+
+	if (i == pfc->num_windows)
+		return 0;
+
 	/* Register the real GPIOs chip. */
-	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup);
+	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup, &pfc->window[i]);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);
 
@@ -390,7 +393,7 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	if (pfc->info->nr_func_gpios == 0)
 		return 0;
 
-	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup);
+	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup, NULL);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);
 

commit 1a4fd58f76cf331c93daaa1667daa25db297d0d4
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 03:19:44 2013 +0100

    sh-pfc: Make GPIO support optional
    
    When implemented as a separate IP block, GPIOs should be handled by a
    separate driver. To make this possible GPIO support needs to be optional
    in the sh-pfc driver.
    
    If no GPIO data registers are supplied in the SoC information structure
    skip registration of the gpiochip.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 7a54ec79518b..317cebb0ee4d 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -354,6 +354,9 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	unsigned int i;
 	int ret;
 
+	if (pfc->info->data_regs == NULL)
+		return 0;
+
 	/* Register the real GPIOs chip. */
 	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup);
 	if (IS_ERR(chip))

commit 542a564d2ddbd2c37536b4dff8e45fa0fc239bcc
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Mar 7 14:31:57 2013 +0100

    sh-pfc: Make function GPIOs support optional
    
    The target is to get rid of function GPIOs completely. To reach this,
    make function GPIOs support optional by skipping the function GPIO chip
    registration if no function GPIOS are defined in SoC data.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index d7acb06d888c..7a54ec79518b 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -384,6 +384,9 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	}
 
 	/* Register the function GPIOs chip. */
+	if (pfc->info->nr_func_gpios == 0)
+		return 0;
+
 	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);

commit 9a643c9a11259955ec6961f9a2509604c6df1cd9
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 18:00:02 2013 +0100

    sh-pfc: Convert message printing from pr_* to dev_*
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index e299f14bc50a..d7acb06d888c 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -9,8 +9,6 @@
  * for more details.
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME " gpio: " fmt
-
 #include <linux/device.h>
 #include <linux/gpio.h>
 #include <linux/init.h>
@@ -273,12 +271,18 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
 
 static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 {
+	static bool __print_once;
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
 	unsigned int mark = pfc->info->func_gpios[offset].enum_id;
 	unsigned long flags;
 	int ret;
 
-	pr_notice_once("Use of GPIO API for function requests is deprecated, convert to pinctrl\n");
+	if (!__print_once) {
+		dev_notice(pfc->dev,
+			   "Use of GPIO API for function requests is deprecated."
+			   " Convert to pinctrl\n");
+		__print_once = true;
+	}
 
 	if (mark == 0)
 		return -EINVAL;
@@ -334,9 +338,9 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *))
 	if (unlikely(ret < 0))
 		return ERR_PTR(ret);
 
-	pr_info("%s handling gpio %u -> %u\n",
-		chip->gpio_chip.label, chip->gpio_chip.base,
-		chip->gpio_chip.base + chip->gpio_chip.ngpio - 1);
+	dev_info(pfc->dev, "%s handling gpio %u -> %u\n",
+		 chip->gpio_chip.label, chip->gpio_chip.base,
+		 chip->gpio_chip.base + chip->gpio_chip.ngpio - 1);
 
 	return chip;
 }

commit b705c054255ae3264aa02d46347e9cfbcf26523a
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 16:38:23 2013 +0100

    sh-pfc: Use proper error codes
    
    Return proper error codes instead of -1, and propagate the error codes.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 480beae2ee67..e299f14bc50a 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -276,22 +276,17 @@ static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
 	unsigned int mark = pfc->info->func_gpios[offset].enum_id;
 	unsigned long flags;
-	int ret = -EINVAL;
+	int ret;
 
 	pr_notice_once("Use of GPIO API for function requests is deprecated, convert to pinctrl\n");
 
 	if (mark == 0)
-		return ret;
+		return -EINVAL;
 
 	spin_lock_irqsave(&pfc->lock, flags);
-
-	if (sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION))
-		goto done;
-
-	ret = 0;
-
-done:
+	ret = sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION);
 	spin_unlock_irqrestore(&pfc->lock, flags);
+
 	return ret;
 }
 

commit cd3c1beecfeb757b16904386ea474d3c272de4ee
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 18:47:05 2013 +0100

    sh-pfc: Constify all SoC data
    
    None of the SoC data need to be modified. Constify it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 761a0dad0450..480beae2ee67 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -82,7 +82,7 @@ static void gpio_setup_data_reg(struct sh_pfc_chip *chip, unsigned gpio)
 {
 	struct sh_pfc *pfc = chip->pfc;
 	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[gpio];
-	struct sh_pfc_pin *pin = &pfc->info->pins[gpio];
+	const struct sh_pfc_pin *pin = &pfc->info->pins[gpio];
 	const struct pinmux_data_reg *dreg;
 	unsigned int bit;
 	unsigned int i;

commit 861601de101215494e2cc7918e8633d63da490ef
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 15:29:14 2013 +0100

    sh-pfc: Remove configuration dry-run and free
    
    The purpose of the dry-run is to ensure that a pin about to be
    configured isn't in use. However, the current implementation is a no-op.
    This proves that the dry-run isn't essential. Remove it.
    
    Freeing configuration then becomes a no-op as well. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index ce074b22f426..761a0dad0450 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -285,10 +285,7 @@ static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 
 	spin_lock_irqsave(&pfc->lock, flags);
 
-	if (sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION, GPIO_CFG_DRYRUN))
-		goto done;
-
-	if (sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION, GPIO_CFG_REQ))
+	if (sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION))
 		goto done;
 
 	ret = 0;
@@ -300,15 +297,6 @@ static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 
 static void gpio_function_free(struct gpio_chip *gc, unsigned offset)
 {
-	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	unsigned int mark = pfc->info->func_gpios[offset].enum_id;
-	unsigned long flags;
-
-	spin_lock_irqsave(&pfc->lock, flags);
-
-	sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION, GPIO_CFG_FREE);
-
-	spin_unlock_irqrestore(&pfc->lock, flags);
 }
 
 static int gpio_function_setup(struct sh_pfc_chip *chip)

commit 1a0039dce269317a843d4fc85c4a3430b484bc2d
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Mar 8 17:43:54 2013 +0100

    sh-pfc: Don't modify sh_pfc_pin SoC data
    
    The sh_pfc_pin structure supplied in SoC data contains information about
    pin configuration and name. It's abused to store GPIO data registers
    information and pin config type. Move those fields out of the
    pinmux_data_reg structure into the new sh_pfc_gpio_pin and
    sh_pfc_pin_config structures.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 55eaf75decff..ce074b22f426 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -26,12 +26,18 @@ struct sh_pfc_gpio_data_reg {
 	unsigned long shadow;
 };
 
+struct sh_pfc_gpio_pin {
+	u8 dbit;
+	u8 dreg;
+};
+
 struct sh_pfc_chip {
-	struct sh_pfc		*pfc;
-	struct gpio_chip	gpio_chip;
+	struct sh_pfc			*pfc;
+	struct gpio_chip		gpio_chip;
 
-	struct sh_pfc_window	*mem;
+	struct sh_pfc_window		*mem;
 	struct sh_pfc_gpio_data_reg	*regs;
+	struct sh_pfc_gpio_pin		*pins;
 };
 
 static struct sh_pfc_chip *gpio_to_pfc_chip(struct gpio_chip *gc)
@@ -48,13 +54,11 @@ static void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int gpio,
 			      struct sh_pfc_gpio_data_reg **reg,
 			      unsigned int *bit)
 {
-	struct sh_pfc_pin *gpiop = sh_pfc_get_pin(chip->pfc, gpio);
-	unsigned int reg_idx;
+	int idx = sh_pfc_get_pin_index(chip->pfc, gpio);
+	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[idx];
 
-	reg_idx = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;
-
-	*reg = &chip->regs[reg_idx];
-	*bit = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
+	*reg = &chip->regs[gpio_pin->dreg];
+	*bit = gpio_pin->dbit;
 }
 
 static unsigned long gpio_read_data_reg(struct sh_pfc_chip *chip,
@@ -74,20 +78,20 @@ static void gpio_write_data_reg(struct sh_pfc_chip *chip,
 	sh_pfc_write_raw_reg(mem, dreg->reg_width, value);
 }
 
-static void gpio_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
+static void gpio_setup_data_reg(struct sh_pfc_chip *chip, unsigned gpio)
 {
-	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
+	struct sh_pfc *pfc = chip->pfc;
+	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[gpio];
+	struct sh_pfc_pin *pin = &pfc->info->pins[gpio];
 	const struct pinmux_data_reg *dreg;
 	unsigned int bit;
 	unsigned int i;
 
 	for (i = 0, dreg = pfc->info->data_regs; dreg->reg; ++i, ++dreg) {
 		for (bit = 0; bit < dreg->reg_width; bit++) {
-			if (dreg->enum_ids[bit] == gpiop->enum_id) {
-				gpiop->flags &= ~PINMUX_FLAG_DREG;
-				gpiop->flags |= i << PINMUX_FLAG_DREG_SHIFT;
-				gpiop->flags &= ~PINMUX_FLAG_DBIT;
-				gpiop->flags |= bit << PINMUX_FLAG_DBIT_SHIFT;
+			if (dreg->enum_ids[bit] == pin->enum_id) {
+				gpio_pin->dreg = i;
+				gpio_pin->dbit = bit;
 				return;
 			}
 		}
@@ -137,7 +141,7 @@ static int gpio_setup_data_regs(struct sh_pfc_chip *chip)
 		if (pfc->info->pins[i].enum_id == 0)
 			continue;
 
-		gpio_setup_data_reg(pfc, i);
+		gpio_setup_data_reg(chip, i);
 	}
 
 	return 0;
@@ -150,9 +154,9 @@ static int gpio_setup_data_regs(struct sh_pfc_chip *chip)
 static int gpio_pin_request(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	struct sh_pfc_pin *pin = sh_pfc_get_pin(pfc, offset);
+	int idx = sh_pfc_get_pin_index(pfc, offset);
 
-	if (pin == NULL || pin->enum_id == 0)
+	if (idx < 0 || pfc->info->pins[idx].enum_id == 0)
 		return -EINVAL;
 
 	return pinctrl_request_gpio(offset);
@@ -237,6 +241,11 @@ static int gpio_pin_setup(struct sh_pfc_chip *chip)
 	struct gpio_chip *gc = &chip->gpio_chip;
 	int ret;
 
+	chip->pins = devm_kzalloc(pfc->dev, pfc->nr_pins * sizeof(*chip->pins),
+				  GFP_KERNEL);
+	if (chip->pins == NULL)
+		return -ENOMEM;
+
 	ret = gpio_setup_data_regs(chip);
 	if (ret < 0)
 		return ret;

commit 51cb226b359bc48fed4a92b9bbd9af34640b1be8
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 18:34:32 2013 +0100

    sh-pfc: Don't modify pinmux_data_reg SoC data
    
    The pinmux_data_reg structure supplied in SoC data contains information
    about data registers. It's abused to store per-device mapped iomem and
    shadow values. Move those fields out of the pinmux_data_reg structure
    into the per-device sh_pfc_chip structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index b370d2865041..55eaf75decff 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -21,11 +21,17 @@
 
 #include "core.h"
 
+struct sh_pfc_gpio_data_reg {
+	const struct pinmux_data_reg *info;
+	unsigned long shadow;
+};
+
 struct sh_pfc_chip {
 	struct sh_pfc		*pfc;
 	struct gpio_chip	gpio_chip;
 
 	struct sh_pfc_window	*mem;
+	struct sh_pfc_gpio_data_reg	*regs;
 };
 
 static struct sh_pfc_chip *gpio_to_pfc_chip(struct gpio_chip *gc)
@@ -38,13 +44,16 @@ static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 	return gpio_to_pfc_chip(gc)->pfc;
 }
 
-static void gpio_get_data_reg(struct sh_pfc *pfc, unsigned int gpio,
-			      struct pinmux_data_reg **dr, unsigned int *bit)
+static void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int gpio,
+			      struct sh_pfc_gpio_data_reg **reg,
+			      unsigned int *bit)
 {
-	struct sh_pfc_pin *gpiop = sh_pfc_get_pin(pfc, gpio);
+	struct sh_pfc_pin *gpiop = sh_pfc_get_pin(chip->pfc, gpio);
+	unsigned int reg_idx;
 
-	*dr = pfc->info->data_regs
-	    + ((gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT);
+	reg_idx = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;
+
+	*reg = &chip->regs[reg_idx];
 	*bit = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
 }
 
@@ -91,7 +100,7 @@ static int gpio_setup_data_regs(struct sh_pfc_chip *chip)
 {
 	struct sh_pfc *pfc = chip->pfc;
 	unsigned long addr = pfc->info->data_regs[0].reg;
-	struct pinmux_data_reg *dreg;
+	const struct pinmux_data_reg *dreg;
 	unsigned int i;
 
 	/* Find the window that contain the GPIO registers. */
@@ -108,8 +117,21 @@ static int gpio_setup_data_regs(struct sh_pfc_chip *chip)
 	/* GPIO data registers must be in the first memory resource. */
 	chip->mem = &pfc->window[i];
 
-	for (dreg = pfc->info->data_regs; dreg->reg; ++dreg)
-		dreg->reg_shadow = gpio_read_data_reg(chip, dreg);
+	/* Count the number of data registers, allocate memory and initialize
+	 * them.
+	 */
+	for (i = 0; pfc->info->data_regs[i].reg_width; ++i)
+		;
+
+	chip->regs = devm_kzalloc(pfc->dev, i * sizeof(*chip->regs),
+				  GFP_KERNEL);
+	if (chip->regs == NULL)
+		return -ENOMEM;
+
+	for (i = 0, dreg = pfc->info->data_regs; dreg->reg_width; ++i, ++dreg) {
+		chip->regs[i].info = dreg;
+		chip->regs[i].shadow = gpio_read_data_reg(chip, dreg);
+	}
 
 	for (i = 0; i < pfc->info->nr_pins; i++) {
 		if (pfc->info->pins[i].enum_id == 0)
@@ -144,20 +166,20 @@ static void gpio_pin_free(struct gpio_chip *gc, unsigned offset)
 static void gpio_pin_set_value(struct sh_pfc_chip *chip, unsigned offset,
 			       int value)
 {
-	struct pinmux_data_reg *dreg;
+	struct sh_pfc_gpio_data_reg *reg;
 	unsigned long pos;
 	unsigned int bit;
 
-	gpio_get_data_reg(chip->pfc, offset, &dreg, &bit);
+	gpio_get_data_reg(chip, offset, &reg, &bit);
 
-	pos = dreg->reg_width - (bit + 1);
+	pos = reg->info->reg_width - (bit + 1);
 
 	if (value)
-		set_bit(pos, &dreg->reg_shadow);
+		set_bit(pos, &reg->shadow);
 	else
-		clear_bit(pos, &dreg->reg_shadow);
+		clear_bit(pos, &reg->shadow);
 
-	gpio_write_data_reg(chip, dreg, dreg->reg_shadow);
+	gpio_write_data_reg(chip, reg->info, reg->shadow);
 }
 
 static int gpio_pin_direction_input(struct gpio_chip *gc, unsigned offset)
@@ -176,15 +198,15 @@ static int gpio_pin_direction_output(struct gpio_chip *gc, unsigned offset,
 static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc_chip *chip = gpio_to_pfc_chip(gc);
-	struct pinmux_data_reg *dreg;
+	struct sh_pfc_gpio_data_reg *reg;
 	unsigned long pos;
 	unsigned int bit;
 
-	gpio_get_data_reg(chip->pfc, offset, &dreg, &bit);
+	gpio_get_data_reg(chip, offset, &reg, &bit);
 
-	pos = dreg->reg_width - (bit + 1);
+	pos = reg->info->reg_width - (bit + 1);
 
-	return (gpio_read_data_reg(chip, dreg) >> pos) & 1;
+	return (gpio_read_data_reg(chip, reg->info) >> pos) & 1;
 }
 
 static void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)

commit e51d5343ffc4b81172178e51e6ca2ee00da67045
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Feb 17 00:26:33 2013 +0100

    sh-pfc: Don't map data registers individually
    
    All data registers are located in the same memory resource. Locate the
    mapped resource at initializat time and use it directly instead of
    computing a mapped address for each register. This gets rid of the
    mapped_reg field of the pinmux_data_reg structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 027c77762d8f..b370d2865041 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -24,6 +24,8 @@
 struct sh_pfc_chip {
 	struct sh_pfc		*pfc;
 	struct gpio_chip	gpio_chip;
+
+	struct sh_pfc_window	*mem;
 };
 
 static struct sh_pfc_chip *gpio_to_pfc_chip(struct gpio_chip *gc)
@@ -46,59 +48,77 @@ static void gpio_get_data_reg(struct sh_pfc *pfc, unsigned int gpio,
 	*bit = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
 }
 
-static void gpio_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
+static unsigned long gpio_read_data_reg(struct sh_pfc_chip *chip,
+					const struct pinmux_data_reg *dreg)
 {
-	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
-	struct pinmux_data_reg *data_reg;
-	int k, n;
+	void __iomem *mem = dreg->reg - chip->mem->phys + chip->mem->virt;
 
-	k = 0;
-	while (1) {
-		data_reg = pfc->info->data_regs + k;
+	return sh_pfc_read_raw_reg(mem, dreg->reg_width);
+}
 
-		if (!data_reg->reg_width)
-			break;
+static void gpio_write_data_reg(struct sh_pfc_chip *chip,
+				const struct pinmux_data_reg *dreg,
+				unsigned long value)
+{
+	void __iomem *mem = dreg->reg - chip->mem->phys + chip->mem->virt;
 
-		data_reg->mapped_reg = sh_pfc_phys_to_virt(pfc, data_reg->reg);
+	sh_pfc_write_raw_reg(mem, dreg->reg_width, value);
+}
 
-		for (n = 0; n < data_reg->reg_width; n++) {
-			if (data_reg->enum_ids[n] == gpiop->enum_id) {
+static void gpio_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
+{
+	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
+	const struct pinmux_data_reg *dreg;
+	unsigned int bit;
+	unsigned int i;
+
+	for (i = 0, dreg = pfc->info->data_regs; dreg->reg; ++i, ++dreg) {
+		for (bit = 0; bit < dreg->reg_width; bit++) {
+			if (dreg->enum_ids[bit] == gpiop->enum_id) {
 				gpiop->flags &= ~PINMUX_FLAG_DREG;
-				gpiop->flags |= (k << PINMUX_FLAG_DREG_SHIFT);
+				gpiop->flags |= i << PINMUX_FLAG_DREG_SHIFT;
 				gpiop->flags &= ~PINMUX_FLAG_DBIT;
-				gpiop->flags |= (n << PINMUX_FLAG_DBIT_SHIFT);
+				gpiop->flags |= bit << PINMUX_FLAG_DBIT_SHIFT;
 				return;
 			}
 		}
-		k++;
 	}
 
 	BUG();
 }
 
-static void gpio_setup_data_regs(struct sh_pfc *pfc)
+static int gpio_setup_data_regs(struct sh_pfc_chip *chip)
 {
-	struct pinmux_data_reg *drp;
-	int k;
+	struct sh_pfc *pfc = chip->pfc;
+	unsigned long addr = pfc->info->data_regs[0].reg;
+	struct pinmux_data_reg *dreg;
+	unsigned int i;
 
-	for (k = 0; k < pfc->info->nr_pins; k++) {
-		if (pfc->info->pins[k].enum_id == 0)
-			continue;
+	/* Find the window that contain the GPIO registers. */
+	for (i = 0; i < pfc->num_windows; ++i) {
+		struct sh_pfc_window *window = &pfc->window[i];
 
-		gpio_setup_data_reg(pfc, k);
+		if (addr >= window->phys && addr < window->phys + window->size)
+			break;
 	}
 
-	k = 0;
-	while (1) {
-		drp = pfc->info->data_regs + k;
+	if (i == pfc->num_windows)
+		return -EINVAL;
 
-		if (!drp->reg_width)
-			break;
+	/* GPIO data registers must be in the first memory resource. */
+	chip->mem = &pfc->window[i];
+
+	for (dreg = pfc->info->data_regs; dreg->reg; ++dreg)
+		dreg->reg_shadow = gpio_read_data_reg(chip, dreg);
+
+	for (i = 0; i < pfc->info->nr_pins; i++) {
+		if (pfc->info->pins[i].enum_id == 0)
+			continue;
 
-		drp->reg_shadow = sh_pfc_read_raw_reg(drp->mapped_reg,
-						      drp->reg_width);
-		k++;
+		gpio_setup_data_reg(pfc, i);
 	}
+
+	return 0;
 }
 
 /* -----------------------------------------------------------------------------
@@ -121,22 +141,23 @@ static void gpio_pin_free(struct gpio_chip *gc, unsigned offset)
 	return pinctrl_free_gpio(offset);
 }
 
-static void gpio_pin_set_value(struct sh_pfc *pfc, unsigned offset, int value)
+static void gpio_pin_set_value(struct sh_pfc_chip *chip, unsigned offset,
+			       int value)
 {
-	struct pinmux_data_reg *dr;
+	struct pinmux_data_reg *dreg;
 	unsigned long pos;
 	unsigned int bit;
 
-	gpio_get_data_reg(pfc, offset, &dr, &bit);
+	gpio_get_data_reg(chip->pfc, offset, &dreg, &bit);
 
-	pos = dr->reg_width - (bit + 1);
+	pos = dreg->reg_width - (bit + 1);
 
 	if (value)
-		set_bit(pos, &dr->reg_shadow);
+		set_bit(pos, &dreg->reg_shadow);
 	else
-		clear_bit(pos, &dr->reg_shadow);
+		clear_bit(pos, &dreg->reg_shadow);
 
-	sh_pfc_write_raw_reg(dr->mapped_reg, dr->reg_width, dr->reg_shadow);
+	gpio_write_data_reg(chip, dreg, dreg->reg_shadow);
 }
 
 static int gpio_pin_direction_input(struct gpio_chip *gc, unsigned offset)
@@ -147,28 +168,28 @@ static int gpio_pin_direction_input(struct gpio_chip *gc, unsigned offset)
 static int gpio_pin_direction_output(struct gpio_chip *gc, unsigned offset,
 				    int value)
 {
-	gpio_pin_set_value(gpio_to_pfc(gc), offset, value);
+	gpio_pin_set_value(gpio_to_pfc_chip(gc), offset, value);
 
 	return pinctrl_gpio_direction_output(offset);
 }
 
 static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 {
-	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	struct pinmux_data_reg *dr;
+	struct sh_pfc_chip *chip = gpio_to_pfc_chip(gc);
+	struct pinmux_data_reg *dreg;
 	unsigned long pos;
 	unsigned int bit;
 
-	gpio_get_data_reg(pfc, offset, &dr, &bit);
+	gpio_get_data_reg(chip->pfc, offset, &dreg, &bit);
 
-	pos = dr->reg_width - (bit + 1);
+	pos = dreg->reg_width - (bit + 1);
 
-	return (sh_pfc_read_raw_reg(dr->mapped_reg, dr->reg_width) >> pos) & 1;
+	return (gpio_read_data_reg(chip, dreg) >> pos) & 1;
 }
 
 static void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)
 {
-	gpio_pin_set_value(gpio_to_pfc(gc), offset, value);
+	gpio_pin_set_value(gpio_to_pfc_chip(gc), offset, value);
 }
 
 static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
@@ -188,10 +209,15 @@ static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 	return -ENOSYS;
 }
 
-static void gpio_pin_setup(struct sh_pfc_chip *chip)
+static int gpio_pin_setup(struct sh_pfc_chip *chip)
 {
 	struct sh_pfc *pfc = chip->pfc;
 	struct gpio_chip *gc = &chip->gpio_chip;
+	int ret;
+
+	ret = gpio_setup_data_regs(chip);
+	if (ret < 0)
+		return ret;
 
 	gc->request = gpio_pin_request;
 	gc->free = gpio_pin_free;
@@ -206,6 +232,8 @@ static void gpio_pin_setup(struct sh_pfc_chip *chip)
 	gc->owner = THIS_MODULE;
 	gc->base = 0;
 	gc->ngpio = pfc->nr_pins;
+
+	return 0;
 }
 
 /* -----------------------------------------------------------------------------
@@ -252,7 +280,7 @@ static void gpio_function_free(struct gpio_chip *gc, unsigned offset)
 	spin_unlock_irqrestore(&pfc->lock, flags);
 }
 
-static void gpio_function_setup(struct sh_pfc_chip *chip)
+static int gpio_function_setup(struct sh_pfc_chip *chip)
 {
 	struct sh_pfc *pfc = chip->pfc;
 	struct gpio_chip *gc = &chip->gpio_chip;
@@ -264,6 +292,8 @@ static void gpio_function_setup(struct sh_pfc_chip *chip)
 	gc->owner = THIS_MODULE;
 	gc->base = pfc->nr_pins;
 	gc->ngpio = pfc->info->nr_func_gpios;
+
+	return 0;
 }
 
 /* -----------------------------------------------------------------------------
@@ -271,7 +301,7 @@ static void gpio_function_setup(struct sh_pfc_chip *chip)
  */
 
 static struct sh_pfc_chip *
-sh_pfc_add_gpiochip(struct sh_pfc *pfc, void(*setup)(struct sh_pfc_chip *))
+sh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *))
 {
 	struct sh_pfc_chip *chip;
 	int ret;
@@ -282,7 +312,9 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, void(*setup)(struct sh_pfc_chip *))
 
 	chip->pfc = pfc;
 
-	setup(chip);
+	ret = setup(chip);
+	if (ret < 0)
+		return ERR_PTR(ret);
 
 	ret = gpiochip_add(&chip->gpio_chip);
 	if (unlikely(ret < 0))
@@ -304,8 +336,6 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	unsigned int i;
 	int ret;
 
-	gpio_setup_data_regs(pfc);
-
 	/* Register the real GPIOs chip. */
 	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup);
 	if (IS_ERR(chip))

commit 41f1219fae987f97787677d3a91c2f33ca9bab98
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Feb 15 02:04:55 2013 +0100

    sh-pfc: Move GPIO registers access functions to gpio.c
    
    Move the sh_pfc_setup_data_regs(), sh_pfc_setup_data_reg(),
    sh_pfc_get_data_reg(), sh_pfc_read_bit() and sh_pfc_write_bit()
    function to gpio.c as they belong to the GPIO implementation. Inline
    sh_pfc_read_bit() and sh_pfc_write_bit() in their only call location.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 806e2dd62137..027c77762d8f 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -36,6 +36,71 @@ static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 	return gpio_to_pfc_chip(gc)->pfc;
 }
 
+static void gpio_get_data_reg(struct sh_pfc *pfc, unsigned int gpio,
+			      struct pinmux_data_reg **dr, unsigned int *bit)
+{
+	struct sh_pfc_pin *gpiop = sh_pfc_get_pin(pfc, gpio);
+
+	*dr = pfc->info->data_regs
+	    + ((gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT);
+	*bit = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
+}
+
+static void gpio_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
+{
+	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
+	struct pinmux_data_reg *data_reg;
+	int k, n;
+
+	k = 0;
+	while (1) {
+		data_reg = pfc->info->data_regs + k;
+
+		if (!data_reg->reg_width)
+			break;
+
+		data_reg->mapped_reg = sh_pfc_phys_to_virt(pfc, data_reg->reg);
+
+		for (n = 0; n < data_reg->reg_width; n++) {
+			if (data_reg->enum_ids[n] == gpiop->enum_id) {
+				gpiop->flags &= ~PINMUX_FLAG_DREG;
+				gpiop->flags |= (k << PINMUX_FLAG_DREG_SHIFT);
+				gpiop->flags &= ~PINMUX_FLAG_DBIT;
+				gpiop->flags |= (n << PINMUX_FLAG_DBIT_SHIFT);
+				return;
+			}
+		}
+		k++;
+	}
+
+	BUG();
+}
+
+static void gpio_setup_data_regs(struct sh_pfc *pfc)
+{
+	struct pinmux_data_reg *drp;
+	int k;
+
+	for (k = 0; k < pfc->info->nr_pins; k++) {
+		if (pfc->info->pins[k].enum_id == 0)
+			continue;
+
+		gpio_setup_data_reg(pfc, k);
+	}
+
+	k = 0;
+	while (1) {
+		drp = pfc->info->data_regs + k;
+
+		if (!drp->reg_width)
+			break;
+
+		drp->reg_shadow = sh_pfc_read_raw_reg(drp->mapped_reg,
+						      drp->reg_width);
+		k++;
+	}
+}
+
 /* -----------------------------------------------------------------------------
  * Pin GPIOs
  */
@@ -59,10 +124,19 @@ static void gpio_pin_free(struct gpio_chip *gc, unsigned offset)
 static void gpio_pin_set_value(struct sh_pfc *pfc, unsigned offset, int value)
 {
 	struct pinmux_data_reg *dr;
-	int bit;
+	unsigned long pos;
+	unsigned int bit;
 
-	sh_pfc_get_data_reg(pfc, offset, &dr, &bit);
-	sh_pfc_write_bit(dr, bit, value);
+	gpio_get_data_reg(pfc, offset, &dr, &bit);
+
+	pos = dr->reg_width - (bit + 1);
+
+	if (value)
+		set_bit(pos, &dr->reg_shadow);
+	else
+		clear_bit(pos, &dr->reg_shadow);
+
+	sh_pfc_write_raw_reg(dr->mapped_reg, dr->reg_width, dr->reg_shadow);
 }
 
 static int gpio_pin_direction_input(struct gpio_chip *gc, unsigned offset)
@@ -82,10 +156,14 @@ static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
 	struct pinmux_data_reg *dr;
-	int bit;
+	unsigned long pos;
+	unsigned int bit;
 
-	sh_pfc_get_data_reg(pfc, offset, &dr, &bit);
-	return sh_pfc_read_bit(dr, bit);
+	gpio_get_data_reg(pfc, offset, &dr, &bit);
+
+	pos = dr->reg_width - (bit + 1);
+
+	return (sh_pfc_read_raw_reg(dr->mapped_reg, dr->reg_width) >> pos) & 1;
 }
 
 static void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)
@@ -226,6 +304,8 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	unsigned int i;
 	int ret;
 
+	gpio_setup_data_regs(pfc);
+
 	/* Register the real GPIOs chip. */
 	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup);
 	if (IS_ERR(chip))

commit 63d573835f835aab4c44d0e0342cf5976fb14b35
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Feb 15 01:33:38 2013 +0100

    sh-pfc: Add support for sparse pin numbers
    
    The PFC driver assumes that the value of the GPIO_PORTxxx enumeration
    names are equal to the port number. This isn't true when the port number
    space is sparse, as with the SH73A0.
    
    Fix the issue by adding support for pin numbers ranges specified through
    SoC data. When no range is specified the driver considers that the PFC
    implements a single contiguous range for all pins.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 32a9c7870a16..806e2dd62137 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -45,7 +45,7 @@ static int gpio_pin_request(struct gpio_chip *gc, unsigned offset)
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
 	struct sh_pfc_pin *pin = sh_pfc_get_pin(pfc, offset);
 
-	if (pin->enum_id == 0)
+	if (pin == NULL || pin->enum_id == 0)
 		return -EINVAL;
 
 	return pinctrl_request_gpio(offset);
@@ -127,7 +127,7 @@ static void gpio_pin_setup(struct sh_pfc_chip *chip)
 	gc->dev = pfc->dev;
 	gc->owner = THIS_MODULE;
 	gc->base = 0;
-	gc->ngpio = pfc->info->nr_pins;
+	gc->ngpio = pfc->nr_pins;
 }
 
 /* -----------------------------------------------------------------------------
@@ -184,7 +184,7 @@ static void gpio_function_setup(struct sh_pfc_chip *chip)
 
 	gc->label = pfc->info->name;
 	gc->owner = THIS_MODULE;
-	gc->base = pfc->info->nr_pins;
+	gc->base = pfc->nr_pins;
 	gc->ngpio = pfc->info->nr_func_gpios;
 }
 
@@ -219,20 +219,43 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, void(*setup)(struct sh_pfc_chip *))
 
 int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 {
+	const struct pinmux_range *ranges;
+	struct pinmux_range def_range;
 	struct sh_pfc_chip *chip;
+	unsigned int nr_ranges;
+	unsigned int i;
 	int ret;
 
+	/* Register the real GPIOs chip. */
 	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);
 
 	pfc->gpio = chip;
 
-	ret = gpiochip_add_pin_range(&chip->gpio_chip, dev_name(pfc->dev), 0, 0,
-				     chip->gpio_chip.ngpio);
-	if (ret < 0)
-		return ret;
+	/* Register the GPIO to pin mappings. */
+	if (pfc->info->ranges == NULL) {
+		def_range.begin = 0;
+		def_range.end = pfc->info->nr_pins - 1;
+		ranges = &def_range;
+		nr_ranges = 1;
+	} else {
+		ranges = pfc->info->ranges;
+		nr_ranges = pfc->info->nr_ranges;
+	}
+
+	for (i = 0; i < nr_ranges; ++i) {
+		const struct pinmux_range *range = &ranges[i];
+
+		ret = gpiochip_add_pin_range(&chip->gpio_chip,
+					     dev_name(pfc->dev),
+					     range->begin, range->begin,
+					     range->end - range->begin + 1);
+		if (ret < 0)
+			return ret;
+	}
 
+	/* Register the function GPIOs chip. */
 	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);

commit 247127f90ba1fcc234008e00e937537a89eef9ca
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Mar 8 00:45:12 2013 +0100

    sh-pfc: Replace pinctrl_add_gpio_range() with gpiochip_add_pin_range()
    
    Adding a GPIO range to a pinctrl device logically belongs to the GPIO
    driver. Switch to the right API.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 45090d8381a2..32a9c7870a16 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -220,6 +220,7 @@ sh_pfc_add_gpiochip(struct sh_pfc *pfc, void(*setup)(struct sh_pfc_chip *))
 int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 {
 	struct sh_pfc_chip *chip;
+	int ret;
 
 	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup);
 	if (IS_ERR(chip))
@@ -227,6 +228,11 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 
 	pfc->gpio = chip;
 
+	ret = gpiochip_add_pin_range(&chip->gpio_chip, dev_name(pfc->dev), 0, 0,
+				     chip->gpio_chip.ngpio);
+	if (ret < 0)
+		return ret;
+
 	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup);
 	if (IS_ERR(chip))
 		return PTR_ERR(chip);

commit 934cb02bab9003bf65afe73e9146a1ea63b26c40
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Feb 14 22:35:09 2013 +0100

    sh-pfc: Add function to retrieve a pin instance from its pin number
    
    This prepares support for sparse pin numbering. The function currently
    just performs and indexed lookup in the pins array.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index db9af4e548a0..45090d8381a2 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -43,8 +43,9 @@ static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 static int gpio_pin_request(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
+	struct sh_pfc_pin *pin = sh_pfc_get_pin(pfc, offset);
 
-	if (pfc->info->pins[offset].enum_id == 0)
+	if (pin->enum_id == 0)
 		return -EINVAL;
 
 	return pinctrl_request_gpio(offset);

commit 0b73ee5d534cc6dcb96efb9eac4cf96b40910911
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Feb 14 22:12:11 2013 +0100

    sh-pfc: Simplify the sh_pfc_gpio_is_pin() logic
    
    The function is guaranteed to be called with a gpio number smaller than
    nr_pins. The condition can the be simplified, and the function inlined.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 3ad938fd7ecc..db9af4e548a0 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -42,6 +42,11 @@ static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 
 static int gpio_pin_request(struct gpio_chip *gc, unsigned offset)
 {
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+
+	if (pfc->info->pins[offset].enum_id == 0)
+		return -EINVAL;
+
 	return pinctrl_request_gpio(offset);
 }
 
@@ -52,12 +57,10 @@ static void gpio_pin_free(struct gpio_chip *gc, unsigned offset)
 
 static void gpio_pin_set_value(struct sh_pfc *pfc, unsigned offset, int value)
 {
-	struct pinmux_data_reg *dr = NULL;
-	int bit = 0;
-
-	if (sh_pfc_get_data_reg(pfc, offset, &dr, &bit) != 0)
-		BUG();
+	struct pinmux_data_reg *dr;
+	int bit;
 
+	sh_pfc_get_data_reg(pfc, offset, &dr, &bit);
 	sh_pfc_write_bit(dr, bit, value);
 }
 
@@ -77,12 +80,10 @@ static int gpio_pin_direction_output(struct gpio_chip *gc, unsigned offset,
 static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	struct pinmux_data_reg *dr = NULL;
-	int bit = 0;
-
-	if (sh_pfc_get_data_reg(pfc, offset, &dr, &bit) != 0)
-		return -EINVAL;
+	struct pinmux_data_reg *dr;
+	int bit;
 
+	sh_pfc_get_data_reg(pfc, offset, &dr, &bit);
 	return sh_pfc_read_bit(dr, bit);
 }
 

commit a68fdca9b0447a0e7a85ee378510509be8b70d90
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Feb 14 17:36:56 2013 +0100

    sh-pfc: Use pinmux identifiers in the pin muxing API
    
    The PFC core exposes a sh_pfc_config_gpio() function that configures
    pinmuxing for a given GPIO (either a real GPIO or a function GPIO).
    Handling of real and function GPIOs belong to the GPIO layer, move the
    GPIO number to mark translation to the caller and rename the function to
    sh_pfc_config_mux().
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 454c965ea555..3ad938fd7ecc 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -135,23 +135,21 @@ static void gpio_pin_setup(struct sh_pfc_chip *chip)
 static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	unsigned int gpio = gc->base + offset;
+	unsigned int mark = pfc->info->func_gpios[offset].enum_id;
 	unsigned long flags;
 	int ret = -EINVAL;
 
 	pr_notice_once("Use of GPIO API for function requests is deprecated, convert to pinctrl\n");
 
-	if (pfc->info->func_gpios[offset].enum_id == 0)
+	if (mark == 0)
 		return ret;
 
 	spin_lock_irqsave(&pfc->lock, flags);
 
-	if (sh_pfc_config_gpio(pfc, gpio, PINMUX_TYPE_FUNCTION,
-			       GPIO_CFG_DRYRUN))
+	if (sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION, GPIO_CFG_DRYRUN))
 		goto done;
 
-	if (sh_pfc_config_gpio(pfc, gpio, PINMUX_TYPE_FUNCTION,
-			       GPIO_CFG_REQ))
+	if (sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION, GPIO_CFG_REQ))
 		goto done;
 
 	ret = 0;
@@ -164,12 +162,12 @@ static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
 static void gpio_function_free(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	unsigned int gpio = gc->base + offset;
+	unsigned int mark = pfc->info->func_gpios[offset].enum_id;
 	unsigned long flags;
 
 	spin_lock_irqsave(&pfc->lock, flags);
 
-	sh_pfc_config_gpio(pfc, gpio, PINMUX_TYPE_FUNCTION, GPIO_CFG_FREE);
+	sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION, GPIO_CFG_FREE);
 
 	spin_unlock_irqrestore(&pfc->lock, flags);
 }

commit c07f54f604b3b458f10452b60fe21c549218bf02
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Jan 3 14:12:14 2013 +0100

    sh-pfc: Look up IRQ table entries by GPIO number
    
    Instead of converting the GPIO number to an enum_id and looking up IRQ
    table entries by enum_id, replace the pinmux_irq enum_ids field with a
    gpios field and lookup entries using the GPIO number.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 82fcb5f9faf0..454c965ea555 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -94,23 +94,14 @@ static void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)
 static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	pinmux_enum_t enum_id;
-	pinmux_enum_t *enum_ids;
-	int i, k, pos;
-
-	pos = 0;
-	enum_id = 0;
-	while (1) {
-		pos = sh_pfc_gpio_to_enum(pfc, offset, pos, &enum_id);
-		if (pos <= 0 || !enum_id)
-			break;
-
-		for (i = 0; i < pfc->info->gpio_irq_size; i++) {
-			enum_ids = pfc->info->gpio_irq[i].enum_ids;
-			for (k = 0; enum_ids[k]; k++) {
-				if (enum_ids[k] == enum_id)
-					return pfc->info->gpio_irq[i].irq;
-			}
+	int i, k;
+
+	for (i = 0; i < pfc->info->gpio_irq_size; i++) {
+		unsigned short *gpios = pfc->info->gpio_irq[i].gpios;
+
+		for (k = 0; gpios[k]; k++) {
+			if (gpios[k] == offset)
+				return pfc->info->gpio_irq[i].irq;
 		}
 	}
 

commit 16883814eca229506cd2a4e447b2b5a2338fa35e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Dec 6 14:49:25 2012 +0100

    sh-pfc: Split pins and functions into separate gpio_chip instances
    
    Register two GPIO chips, one for the real GPIOs and one for the function
    GPIOs.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 2a99bef281ad..82fcb5f9faf0 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -36,112 +36,62 @@ static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 	return gpio_to_pfc_chip(gc)->pfc;
 }
 
-static int sh_gpio_request(struct gpio_chip *gc, unsigned offset)
-{
-	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	unsigned long flags;
-	int ret = -EINVAL;
-
-	if (offset < pfc->info->nr_pins)
-		return pinctrl_request_gpio(offset);
-
-	pr_notice_once("Use of GPIO API for function requests is deprecated, convert to pinctrl\n");
-
-	spin_lock_irqsave(&pfc->lock, flags);
-
-	if (!sh_pfc_gpio_is_function(pfc, offset))
-		goto done;
-
-	if (sh_pfc_config_gpio(pfc, offset, PINMUX_TYPE_FUNCTION,
-			       GPIO_CFG_DRYRUN))
-		goto done;
-
-	if (sh_pfc_config_gpio(pfc, offset, PINMUX_TYPE_FUNCTION,
-			       GPIO_CFG_REQ))
-		goto done;
-
-	ret = 0;
-
-done:
-	spin_unlock_irqrestore(&pfc->lock, flags);
-	return ret;
-}
+/* -----------------------------------------------------------------------------
+ * Pin GPIOs
+ */
 
-static void sh_gpio_free(struct gpio_chip *gc, unsigned offset)
+static int gpio_pin_request(struct gpio_chip *gc, unsigned offset)
 {
-	struct sh_pfc *pfc = gpio_to_pfc(gc);
-	unsigned long flags;
-
-	if (offset < pfc->info->nr_pins)
-		return pinctrl_free_gpio(offset);
-
-	spin_lock_irqsave(&pfc->lock, flags);
-
-	sh_pfc_config_gpio(pfc, offset, PINMUX_TYPE_FUNCTION, GPIO_CFG_FREE);
-
-	spin_unlock_irqrestore(&pfc->lock, flags);
+	return pinctrl_request_gpio(offset);
 }
 
-static void sh_gpio_set_value(struct sh_pfc *pfc, unsigned gpio, int value)
+static void gpio_pin_free(struct gpio_chip *gc, unsigned offset)
 {
-	struct pinmux_data_reg *dr = NULL;
-	int bit = 0;
-
-	if (sh_pfc_get_data_reg(pfc, gpio, &dr, &bit) != 0)
-		BUG();
-	else
-		sh_pfc_write_bit(dr, bit, value);
+	return pinctrl_free_gpio(offset);
 }
 
-static int sh_gpio_get_value(struct sh_pfc *pfc, unsigned gpio)
+static void gpio_pin_set_value(struct sh_pfc *pfc, unsigned offset, int value)
 {
 	struct pinmux_data_reg *dr = NULL;
 	int bit = 0;
 
-	if (sh_pfc_get_data_reg(pfc, gpio, &dr, &bit) != 0)
-		return -EINVAL;
+	if (sh_pfc_get_data_reg(pfc, offset, &dr, &bit) != 0)
+		BUG();
 
-	return sh_pfc_read_bit(dr, bit);
+	sh_pfc_write_bit(dr, bit, value);
 }
 
-static int sh_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
+static int gpio_pin_direction_input(struct gpio_chip *gc, unsigned offset)
 {
-	struct sh_pfc *pfc = gpio_to_pfc(gc);
-
-	if (offset >= pfc->info->nr_pins) {
-		/* Function GPIOs can only be requested, never configured. */
-		return -EINVAL;
-	}
-
 	return pinctrl_gpio_direction_input(offset);
 }
 
-static int sh_gpio_direction_output(struct gpio_chip *gc, unsigned offset,
+static int gpio_pin_direction_output(struct gpio_chip *gc, unsigned offset,
 				    int value)
 {
-	struct sh_pfc *pfc = gpio_to_pfc(gc);
-
-	if (offset >= pfc->info->nr_pins) {
-		/* Function GPIOs can only be requested, never configured. */
-		return -EINVAL;
-	}
-
-	sh_gpio_set_value(gpio_to_pfc(gc), offset, value);
+	gpio_pin_set_value(gpio_to_pfc(gc), offset, value);
 
 	return pinctrl_gpio_direction_output(offset);
 }
 
-static int sh_gpio_get(struct gpio_chip *gc, unsigned offset)
+static int gpio_pin_get(struct gpio_chip *gc, unsigned offset)
 {
-	return sh_gpio_get_value(gpio_to_pfc(gc), offset);
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+	struct pinmux_data_reg *dr = NULL;
+	int bit = 0;
+
+	if (sh_pfc_get_data_reg(pfc, offset, &dr, &bit) != 0)
+		return -EINVAL;
+
+	return sh_pfc_read_bit(dr, bit);
 }
 
-static void sh_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+static void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)
 {
-	sh_gpio_set_value(gpio_to_pfc(gc), offset, value);
+	gpio_pin_set_value(gpio_to_pfc(gc), offset, value);
 }
 
-static int sh_gpio_to_irq(struct gpio_chip *gc, unsigned offset)
+static int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
 	pinmux_enum_t enum_id;
@@ -167,60 +117,141 @@ static int sh_gpio_to_irq(struct gpio_chip *gc, unsigned offset)
 	return -ENOSYS;
 }
 
-static void sh_pfc_gpio_setup(struct sh_pfc_chip *chip)
+static void gpio_pin_setup(struct sh_pfc_chip *chip)
 {
 	struct sh_pfc *pfc = chip->pfc;
 	struct gpio_chip *gc = &chip->gpio_chip;
 
-	gc->request = sh_gpio_request;
-	gc->free = sh_gpio_free;
-	gc->direction_input = sh_gpio_direction_input;
-	gc->get = sh_gpio_get;
-	gc->direction_output = sh_gpio_direction_output;
-	gc->set = sh_gpio_set;
-	gc->to_irq = sh_gpio_to_irq;
+	gc->request = gpio_pin_request;
+	gc->free = gpio_pin_free;
+	gc->direction_input = gpio_pin_direction_input;
+	gc->get = gpio_pin_get;
+	gc->direction_output = gpio_pin_direction_output;
+	gc->set = gpio_pin_set;
+	gc->to_irq = gpio_pin_to_irq;
 
 	gc->label = pfc->info->name;
+	gc->dev = pfc->dev;
 	gc->owner = THIS_MODULE;
 	gc->base = 0;
-	gc->ngpio = pfc->info->nr_pins + pfc->info->nr_func_gpios;
+	gc->ngpio = pfc->info->nr_pins;
 }
 
-int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
+/* -----------------------------------------------------------------------------
+ * Function GPIOs
+ */
+
+static int gpio_function_request(struct gpio_chip *gc, unsigned offset)
+{
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+	unsigned int gpio = gc->base + offset;
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	pr_notice_once("Use of GPIO API for function requests is deprecated, convert to pinctrl\n");
+
+	if (pfc->info->func_gpios[offset].enum_id == 0)
+		return ret;
+
+	spin_lock_irqsave(&pfc->lock, flags);
+
+	if (sh_pfc_config_gpio(pfc, gpio, PINMUX_TYPE_FUNCTION,
+			       GPIO_CFG_DRYRUN))
+		goto done;
+
+	if (sh_pfc_config_gpio(pfc, gpio, PINMUX_TYPE_FUNCTION,
+			       GPIO_CFG_REQ))
+		goto done;
+
+	ret = 0;
+
+done:
+	spin_unlock_irqrestore(&pfc->lock, flags);
+	return ret;
+}
+
+static void gpio_function_free(struct gpio_chip *gc, unsigned offset)
+{
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+	unsigned int gpio = gc->base + offset;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pfc->lock, flags);
+
+	sh_pfc_config_gpio(pfc, gpio, PINMUX_TYPE_FUNCTION, GPIO_CFG_FREE);
+
+	spin_unlock_irqrestore(&pfc->lock, flags);
+}
+
+static void gpio_function_setup(struct sh_pfc_chip *chip)
+{
+	struct sh_pfc *pfc = chip->pfc;
+	struct gpio_chip *gc = &chip->gpio_chip;
+
+	gc->request = gpio_function_request;
+	gc->free = gpio_function_free;
+
+	gc->label = pfc->info->name;
+	gc->owner = THIS_MODULE;
+	gc->base = pfc->info->nr_pins;
+	gc->ngpio = pfc->info->nr_func_gpios;
+}
+
+/* -----------------------------------------------------------------------------
+ * Register/unregister
+ */
+
+static struct sh_pfc_chip *
+sh_pfc_add_gpiochip(struct sh_pfc *pfc, void(*setup)(struct sh_pfc_chip *))
 {
 	struct sh_pfc_chip *chip;
 	int ret;
 
 	chip = devm_kzalloc(pfc->dev, sizeof(*chip), GFP_KERNEL);
 	if (unlikely(!chip))
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 
 	chip->pfc = pfc;
 
-	sh_pfc_gpio_setup(chip);
+	setup(chip);
 
 	ret = gpiochip_add(&chip->gpio_chip);
 	if (unlikely(ret < 0))
-		return ret;
+		return ERR_PTR(ret);
+
+	pr_info("%s handling gpio %u -> %u\n",
+		chip->gpio_chip.label, chip->gpio_chip.base,
+		chip->gpio_chip.base + chip->gpio_chip.ngpio - 1);
+
+	return chip;
+}
+
+int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
+{
+	struct sh_pfc_chip *chip;
+
+	chip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup);
+	if (IS_ERR(chip))
+		return PTR_ERR(chip);
 
 	pfc->gpio = chip;
 
-	pr_info("%s handling gpio 0 -> %u\n",
-		pfc->info->name,
-		pfc->info->nr_pins + pfc->info->nr_func_gpios - 1);
+	chip = sh_pfc_add_gpiochip(pfc, gpio_function_setup);
+	if (IS_ERR(chip))
+		return PTR_ERR(chip);
+
+	pfc->func = chip;
 
 	return 0;
 }
 
 int sh_pfc_unregister_gpiochip(struct sh_pfc *pfc)
 {
-	struct sh_pfc_chip *chip = pfc->gpio;
+	int err;
 	int ret;
 
-	ret = gpiochip_remove(&chip->gpio_chip);
-	if (unlikely(ret < 0))
-		return ret;
+	ret = gpiochip_remove(&pfc->gpio->gpio_chip);
+	err = gpiochip_remove(&pfc->func->gpio_chip);
 
-	pfc->gpio = NULL;
-	return 0;
+	return ret < 0 ? ret : err;
 }

commit a373ed0aa229f06e7d699797669b664ef39d97c1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Nov 29 13:24:07 2012 +0100

    sh-pfc: Split pins and functions definition tables
    
    Split the GPIOs table into a pins table for real GPIOs and a functions
    table for function GPIOs.
    
    Only register pins with the pinctrl core. The function GPIOs remain
    accessible as GPIOs.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 8f01113d0ecb..2a99bef281ad 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -183,7 +183,7 @@ static void sh_pfc_gpio_setup(struct sh_pfc_chip *chip)
 	gc->label = pfc->info->name;
 	gc->owner = THIS_MODULE;
 	gc->base = 0;
-	gc->ngpio = pfc->info->nr_gpios;
+	gc->ngpio = pfc->info->nr_pins + pfc->info->nr_func_gpios;
 }
 
 int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
@@ -206,7 +206,8 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	pfc->gpio = chip;
 
 	pr_info("%s handling gpio 0 -> %u\n",
-		pfc->info->name, pfc->info->nr_gpios - 1);
+		pfc->info->name,
+		pfc->info->nr_pins + pfc->info->nr_func_gpios - 1);
 
 	return 0;
 }

commit 24d6b36e91b0503cd1c88b34fa793c0c65fa767d
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Nov 29 18:00:32 2012 +0100

    sh-pfc: Don't needlessly check GPIO type in sh_gpio_free()
    
    The GPIO type is always PINMUX_TYPE_FUNCTION when freeing a function
    GPIO. Hardcode the type value.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 80a50d8a50e7..8f01113d0ecb 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -71,16 +71,13 @@ static void sh_gpio_free(struct gpio_chip *gc, unsigned offset)
 {
 	struct sh_pfc *pfc = gpio_to_pfc(gc);
 	unsigned long flags;
-	int pinmux_type;
 
 	if (offset < pfc->info->nr_pins)
 		return pinctrl_free_gpio(offset);
 
 	spin_lock_irqsave(&pfc->lock, flags);
 
-	pinmux_type = pfc->info->gpios[offset].flags & PINMUX_FLAG_TYPE;
-
-	sh_pfc_config_gpio(pfc, offset, pinmux_type, GPIO_CFG_FREE);
+	sh_pfc_config_gpio(pfc, offset, PINMUX_TYPE_FUNCTION, GPIO_CFG_FREE);
 
 	spin_unlock_irqrestore(&pfc->lock, flags);
 }

commit 2119f7c9afaf4c5fe88e9ffec1f34c5bc6b02f78
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Nov 29 13:03:53 2012 +0100

    sh-pfc: Shrink the pinctrl GPIO range to include real GPIOs only
    
    As a step towards GPIO function removal, shorten the GPIO range
    registered with the pinctrl core. Function GPIOs are now handled in the
    GPIO handlers directly instead of going through the pinctrl API.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index f46f06997b99..80a50d8a50e7 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -38,12 +38,51 @@ static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
 
 static int sh_gpio_request(struct gpio_chip *gc, unsigned offset)
 {
-	return pinctrl_request_gpio(offset);
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (offset < pfc->info->nr_pins)
+		return pinctrl_request_gpio(offset);
+
+	pr_notice_once("Use of GPIO API for function requests is deprecated, convert to pinctrl\n");
+
+	spin_lock_irqsave(&pfc->lock, flags);
+
+	if (!sh_pfc_gpio_is_function(pfc, offset))
+		goto done;
+
+	if (sh_pfc_config_gpio(pfc, offset, PINMUX_TYPE_FUNCTION,
+			       GPIO_CFG_DRYRUN))
+		goto done;
+
+	if (sh_pfc_config_gpio(pfc, offset, PINMUX_TYPE_FUNCTION,
+			       GPIO_CFG_REQ))
+		goto done;
+
+	ret = 0;
+
+done:
+	spin_unlock_irqrestore(&pfc->lock, flags);
+	return ret;
 }
 
 static void sh_gpio_free(struct gpio_chip *gc, unsigned offset)
 {
-	pinctrl_free_gpio(offset);
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+	unsigned long flags;
+	int pinmux_type;
+
+	if (offset < pfc->info->nr_pins)
+		return pinctrl_free_gpio(offset);
+
+	spin_lock_irqsave(&pfc->lock, flags);
+
+	pinmux_type = pfc->info->gpios[offset].flags & PINMUX_FLAG_TYPE;
+
+	sh_pfc_config_gpio(pfc, offset, pinmux_type, GPIO_CFG_FREE);
+
+	spin_unlock_irqrestore(&pfc->lock, flags);
 }
 
 static void sh_gpio_set_value(struct sh_pfc *pfc, unsigned gpio, int value)
@@ -70,12 +109,26 @@ static int sh_gpio_get_value(struct sh_pfc *pfc, unsigned gpio)
 
 static int sh_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
 {
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+
+	if (offset >= pfc->info->nr_pins) {
+		/* Function GPIOs can only be requested, never configured. */
+		return -EINVAL;
+	}
+
 	return pinctrl_gpio_direction_input(offset);
 }
 
 static int sh_gpio_direction_output(struct gpio_chip *gc, unsigned offset,
 				    int value)
 {
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+
+	if (offset >= pfc->info->nr_pins) {
+		/* Function GPIOs can only be requested, never configured. */
+		return -EINVAL;
+	}
+
 	sh_gpio_set_value(gpio_to_pfc(gc), offset, value);
 
 	return pinctrl_gpio_direction_output(offset);

commit d7a7ca5781fa2ac40319acc7125c487db5b26d91
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Nov 28 17:51:00 2012 +0100

    sh-pfc: Replace first_gpio and last_gpio with nr_gpios
    
    The SoC information first_gpio field is always equal to 0, and the
    last_gpio field is the index of the last entry in the pinmux_gpios
    array. Replace the first_gpio and last_gpio fields by a nr_gpios field,
    and initialize it to ARRAY_SIZE(pinmux_gpios).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index a535075c8b69..f46f06997b99 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -130,12 +130,10 @@ static void sh_pfc_gpio_setup(struct sh_pfc_chip *chip)
 	gc->set = sh_gpio_set;
 	gc->to_irq = sh_gpio_to_irq;
 
-	WARN_ON(pfc->info->first_gpio != 0); /* needs testing */
-
 	gc->label = pfc->info->name;
 	gc->owner = THIS_MODULE;
-	gc->base = pfc->info->first_gpio;
-	gc->ngpio = (pfc->info->last_gpio - pfc->info->first_gpio) + 1;
+	gc->base = 0;
+	gc->ngpio = pfc->info->nr_gpios;
 }
 
 int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
@@ -157,9 +155,8 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 
 	pfc->gpio = chip;
 
-	pr_info("%s handling gpio %d -> %d\n",
-		pfc->info->name, pfc->info->first_gpio,
-		pfc->info->last_gpio);
+	pr_info("%s handling gpio 0 -> %u\n",
+		pfc->info->name, pfc->info->nr_gpios - 1);
 
 	return 0;
 }

commit c3323806a67c0c656e27956b7340e37ba6c6968b
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:55 2012 +0100

    sh-pfc: Move sh_pfc.h from include/linux/ to driver directory
    
    The header file isn't used by arch code anymore. Make it private to the
    driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index 3cbdfea1dec0..a535075c8b69 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -16,7 +16,6 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/pinctrl/consumer.h>
-#include <linux/sh_pfc.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 

commit 19bb7fe36950ff74ce322cc29f6f4e025999f1f0
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:20 2012 +0100

    sh-pfc: Support pinmux info in driver data instead of platform data
    
    Pinmux information should be provided by the pinmux driver, not arch
    code. Make it possible to do so by supporting pinmux information passed
    through the driver_data field in the platform ID table. Platform data
    will remain supported until all arch code has been converted.
    
    Rename the sh_pfc_platform_data structure to sh_pfc_soc_info to reflect
    this.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
index a0454f321710..3cbdfea1dec0 100644
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -106,11 +106,11 @@ static int sh_gpio_to_irq(struct gpio_chip *gc, unsigned offset)
 		if (pos <= 0 || !enum_id)
 			break;
 
-		for (i = 0; i < pfc->pdata->gpio_irq_size; i++) {
-			enum_ids = pfc->pdata->gpio_irq[i].enum_ids;
+		for (i = 0; i < pfc->info->gpio_irq_size; i++) {
+			enum_ids = pfc->info->gpio_irq[i].enum_ids;
 			for (k = 0; enum_ids[k]; k++) {
 				if (enum_ids[k] == enum_id)
-					return pfc->pdata->gpio_irq[i].irq;
+					return pfc->info->gpio_irq[i].irq;
 			}
 		}
 	}
@@ -131,12 +131,12 @@ static void sh_pfc_gpio_setup(struct sh_pfc_chip *chip)
 	gc->set = sh_gpio_set;
 	gc->to_irq = sh_gpio_to_irq;
 
-	WARN_ON(pfc->pdata->first_gpio != 0); /* needs testing */
+	WARN_ON(pfc->info->first_gpio != 0); /* needs testing */
 
-	gc->label = pfc->pdata->name;
+	gc->label = pfc->info->name;
 	gc->owner = THIS_MODULE;
-	gc->base = pfc->pdata->first_gpio;
-	gc->ngpio = (pfc->pdata->last_gpio - pfc->pdata->first_gpio) + 1;
+	gc->base = pfc->info->first_gpio;
+	gc->ngpio = (pfc->info->last_gpio - pfc->info->first_gpio) + 1;
 }
 
 int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
@@ -159,8 +159,8 @@ int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
 	pfc->gpio = chip;
 
 	pr_info("%s handling gpio %d -> %d\n",
-		pfc->pdata->name, pfc->pdata->first_gpio,
-		pfc->pdata->last_gpio);
+		pfc->info->name, pfc->info->first_gpio,
+		pfc->info->last_gpio);
 
 	return 0;
 }

commit 6e54d8d252ed09ae148af6565971974af9a96e10
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:19 2012 +0100

    sh-pfc: Move driver from drivers/sh/ to drivers/pinctrl/
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/gpio.c b/drivers/pinctrl/sh-pfc/gpio.c
new file mode 100644
index 000000000000..a0454f321710
--- /dev/null
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@ -0,0 +1,179 @@
+/*
+ * SuperH Pin Function Controller GPIO driver.
+ *
+ * Copyright (C) 2008 Magnus Damm
+ * Copyright (C) 2009 - 2012 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME " gpio: " fmt
+
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/sh_pfc.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "core.h"
+
+struct sh_pfc_chip {
+	struct sh_pfc		*pfc;
+	struct gpio_chip	gpio_chip;
+};
+
+static struct sh_pfc_chip *gpio_to_pfc_chip(struct gpio_chip *gc)
+{
+	return container_of(gc, struct sh_pfc_chip, gpio_chip);
+}
+
+static struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)
+{
+	return gpio_to_pfc_chip(gc)->pfc;
+}
+
+static int sh_gpio_request(struct gpio_chip *gc, unsigned offset)
+{
+	return pinctrl_request_gpio(offset);
+}
+
+static void sh_gpio_free(struct gpio_chip *gc, unsigned offset)
+{
+	pinctrl_free_gpio(offset);
+}
+
+static void sh_gpio_set_value(struct sh_pfc *pfc, unsigned gpio, int value)
+{
+	struct pinmux_data_reg *dr = NULL;
+	int bit = 0;
+
+	if (sh_pfc_get_data_reg(pfc, gpio, &dr, &bit) != 0)
+		BUG();
+	else
+		sh_pfc_write_bit(dr, bit, value);
+}
+
+static int sh_gpio_get_value(struct sh_pfc *pfc, unsigned gpio)
+{
+	struct pinmux_data_reg *dr = NULL;
+	int bit = 0;
+
+	if (sh_pfc_get_data_reg(pfc, gpio, &dr, &bit) != 0)
+		return -EINVAL;
+
+	return sh_pfc_read_bit(dr, bit);
+}
+
+static int sh_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	return pinctrl_gpio_direction_input(offset);
+}
+
+static int sh_gpio_direction_output(struct gpio_chip *gc, unsigned offset,
+				    int value)
+{
+	sh_gpio_set_value(gpio_to_pfc(gc), offset, value);
+
+	return pinctrl_gpio_direction_output(offset);
+}
+
+static int sh_gpio_get(struct gpio_chip *gc, unsigned offset)
+{
+	return sh_gpio_get_value(gpio_to_pfc(gc), offset);
+}
+
+static void sh_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	sh_gpio_set_value(gpio_to_pfc(gc), offset, value);
+}
+
+static int sh_gpio_to_irq(struct gpio_chip *gc, unsigned offset)
+{
+	struct sh_pfc *pfc = gpio_to_pfc(gc);
+	pinmux_enum_t enum_id;
+	pinmux_enum_t *enum_ids;
+	int i, k, pos;
+
+	pos = 0;
+	enum_id = 0;
+	while (1) {
+		pos = sh_pfc_gpio_to_enum(pfc, offset, pos, &enum_id);
+		if (pos <= 0 || !enum_id)
+			break;
+
+		for (i = 0; i < pfc->pdata->gpio_irq_size; i++) {
+			enum_ids = pfc->pdata->gpio_irq[i].enum_ids;
+			for (k = 0; enum_ids[k]; k++) {
+				if (enum_ids[k] == enum_id)
+					return pfc->pdata->gpio_irq[i].irq;
+			}
+		}
+	}
+
+	return -ENOSYS;
+}
+
+static void sh_pfc_gpio_setup(struct sh_pfc_chip *chip)
+{
+	struct sh_pfc *pfc = chip->pfc;
+	struct gpio_chip *gc = &chip->gpio_chip;
+
+	gc->request = sh_gpio_request;
+	gc->free = sh_gpio_free;
+	gc->direction_input = sh_gpio_direction_input;
+	gc->get = sh_gpio_get;
+	gc->direction_output = sh_gpio_direction_output;
+	gc->set = sh_gpio_set;
+	gc->to_irq = sh_gpio_to_irq;
+
+	WARN_ON(pfc->pdata->first_gpio != 0); /* needs testing */
+
+	gc->label = pfc->pdata->name;
+	gc->owner = THIS_MODULE;
+	gc->base = pfc->pdata->first_gpio;
+	gc->ngpio = (pfc->pdata->last_gpio - pfc->pdata->first_gpio) + 1;
+}
+
+int sh_pfc_register_gpiochip(struct sh_pfc *pfc)
+{
+	struct sh_pfc_chip *chip;
+	int ret;
+
+	chip = devm_kzalloc(pfc->dev, sizeof(*chip), GFP_KERNEL);
+	if (unlikely(!chip))
+		return -ENOMEM;
+
+	chip->pfc = pfc;
+
+	sh_pfc_gpio_setup(chip);
+
+	ret = gpiochip_add(&chip->gpio_chip);
+	if (unlikely(ret < 0))
+		return ret;
+
+	pfc->gpio = chip;
+
+	pr_info("%s handling gpio %d -> %d\n",
+		pfc->pdata->name, pfc->pdata->first_gpio,
+		pfc->pdata->last_gpio);
+
+	return 0;
+}
+
+int sh_pfc_unregister_gpiochip(struct sh_pfc *pfc)
+{
+	struct sh_pfc_chip *chip = pfc->gpio;
+	int ret;
+
+	ret = gpiochip_remove(&chip->gpio_chip);
+	if (unlikely(ret < 0))
+		return ret;
+
+	pfc->gpio = NULL;
+	return 0;
+}
