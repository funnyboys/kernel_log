commit 4ecc7ff82ecfdf44997ed2a1016945fc8f6fca3e
Author: Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>
Date:   Sun May 3 22:46:46 2020 +0100

    pinctrl: sh-pfc: r8a7790: Add r8a7742 PFC support
    
    Renesas RZ/G1H (R8A7742) is pin compatible with R-Car H2 (R8A7790),
    however it doesn't have several automotive specific peripherals. Add
    automotive-specific pin groups/functions along with common pin
    groups/functions for supporting both r8a7790 and r8a7742 SoC.
    
    Signed-off-by: Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>
    Reviewed-by: Marian-Cristian Rotariu <marian-cristian.rotariu.rb@bp.renesas.com>
    Link: https://lore.kernel.org/r/1588542414-14826-3-git-send-email-prabhakar.mahadev-lad.rj@bp.renesas.com
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a2e19efa26e3..f368383cba61 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -485,6 +485,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7740_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7742
+	{
+		.compatible = "renesas,pfc-r8a7742",
+		.data = &r8a7742_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7743
 	{
 		.compatible = "renesas,pfc-r8a7743",

commit 92c44680c5c6f1342288f6626da4008d416d8e40
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:27 2020 +0100

    pinctrl: sh-pfc: checker: Add function GPIO checks
    
    Add checks for legacy function GPIO descriptors:
      1. Function GPIOs must have a name,
      2. Names must be unique,
      3. Enum ID values must be unique.
    
    This exposes bugs like those fixed in
      - commit 884caadad128efad ("pinctrl: sh-pfc: sh7734: Fix duplicate
        TCLK1_B"),
      - commit 55b1cb1f03ad5eea ("pinctrl: sh-pfc: sh7264: Fix CAN function
        GPIOs"),
      - commit 02aeb2f21530c98f ("pinctrl: sh-pfc: sh7269: Fix CAN function
        GPIOs"),
      - commit db9c07272c8245a2 ("sh: sh7264: Remove bogus SSU GPIO function
        definitions"),
      - commit b4fba344a2930769 ("sh: sh7269: Remove bogus SSU GPIO function
        definitions").
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-14-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index da2baa9446ce..a2e19efa26e3 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -1012,6 +1012,26 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 				       info->data_regs[i].enum_ids,
 				       info->data_regs[i].reg_width);
 	}
+
+#ifdef CONFIG_PINCTRL_SH_FUNC_GPIO
+	/* Check function GPIOs */
+	for (i = 0; i < info->nr_func_gpios; i++) {
+		const struct pinmux_func *func = &info->func_gpios[i];
+
+		if (!func->name) {
+			sh_pfc_err("empty function gpio %u\n", i);
+			continue;
+		}
+		for (j = 0; j < i; j++) {
+			if (same_name(func->name, info->func_gpios[j].name))
+				sh_pfc_err("func_gpio %s: name conflict\n",
+					   func->name);
+		}
+		if (sh_pfc_check_enum(drvname, func->enum_id))
+			sh_pfc_err("%s enum_id %u conflict\n", func->name,
+				   func->enum_id);
+	}
+#endif
 }
 
 static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)

commit 0e6cd847a420e21f6e0d476c355127a7cbcb4a5d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:26 2020 +0100

    pinctrl: sh-pfc: checker: Add data register checks
    
    Add checks for data register descriptors:
      1. Register addresses must be unique.
      2. Enum ID values must be unique.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-13-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 42432db4fc0b..da2baa9446ce 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -1004,6 +1004,14 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	/* Check ioctrl registers */
 	for (i = 0; info->ioctrl_regs && info->ioctrl_regs[i].reg; i++)
 		sh_pfc_check_reg(drvname, info->ioctrl_regs[i].reg);
+
+	/* Check data registers */
+	for (i = 0; info->data_regs && info->data_regs[i].reg; i++) {
+		sh_pfc_check_reg(drvname, info->data_regs[i].reg);
+		sh_pfc_check_reg_enums(drvname, info->data_regs[i].reg,
+				       info->data_regs[i].enum_ids,
+				       info->data_regs[i].reg_width);
+	}
 }
 
 static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)

commit 4bd7d16a309e034ec92b13840bae5668918ddd5b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:25 2020 +0100

    pinctrl: sh-pfc: checker: Add ioctrl register checks
    
    Add checks for generic control register descriptors:
      1. Register addresses must be unique.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-12-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index fcd11d83ee41..42432db4fc0b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -1000,6 +1000,10 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	/* Check bias registers */
 	for (i = 0; info->bias_regs && info->bias_regs[i].puen; i++)
 		sh_pfc_check_bias_reg(info, &info->bias_regs[i]);
+
+	/* Check ioctrl registers */
+	for (i = 0; info->ioctrl_regs && info->ioctrl_regs[i].reg; i++)
+		sh_pfc_check_reg(drvname, info->ioctrl_regs[i].reg);
 }
 
 static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)

commit 8990cd297f1508904d3773f6a2c5af531e8649ca
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:24 2020 +0100

    pinctrl: sh-pfc: checker: Add bias register checks
    
    Add checks for bias register descriptors:
      1. Pull-up and optional pull-down register addresses must be unique,
      2. Referred pins must exist.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-11-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 8304832e7c39..fcd11d83ee41 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -888,6 +888,18 @@ static void __init sh_pfc_check_drive_reg(const struct sh_pfc_soc_info *info,
 	}
 }
 
+static void __init sh_pfc_check_bias_reg(const struct sh_pfc_soc_info *info,
+					 const struct pinmux_bias_reg *bias)
+{
+	unsigned int i;
+
+	sh_pfc_check_reg(info->name, bias->puen);
+	if (bias->pud)
+		sh_pfc_check_reg(info->name, bias->pud);
+	for (i = 0; i < ARRAY_SIZE(bias->pins); i++)
+		sh_pfc_check_pin(info, bias->puen, bias->pins[i]);
+}
+
 static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 {
 	const char *drvname = info->name;
@@ -984,6 +996,10 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	/* Check drive strength registers */
 	for (i = 0; info->drive_regs && info->drive_regs[i].reg; i++)
 		sh_pfc_check_drive_reg(info, &info->drive_regs[i]);
+
+	/* Check bias registers */
+	for (i = 0; info->bias_regs && info->bias_regs[i].puen; i++)
+		sh_pfc_check_bias_reg(info, &info->bias_regs[i]);
 }
 
 static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)

commit 08df16e07ad0a1ec0ccf9a154014cb80e82c773e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:23 2020 +0100

    pinctrl: sh-pfc: checker: Add drive strength register checks
    
    Add checks for drive strength register descriptors:
      1. Register addresses must be unique,
      2. Register fields must be non-overlapping,
      3. Referred pins must exist.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-10-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b67584d65ecc..8304832e7c39 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -814,6 +814,23 @@ static void __init sh_pfc_check_reg_enums(const char *drvname, u32 reg,
 	}
 }
 
+static void __init sh_pfc_check_pin(const struct sh_pfc_soc_info *info,
+				    u32 reg, unsigned int pin)
+{
+	const char *drvname = info->name;
+	unsigned int i;
+
+	if (pin == SH_PFC_PIN_NONE)
+		return;
+
+	for (i = 0; i < info->nr_pins; i++) {
+		if (pin == info->pins[i].pin)
+			return;
+	}
+
+	sh_pfc_err("reg 0x%x: pin %u not found\n", reg, pin);
+}
+
 static void __init sh_pfc_check_cfg_reg(const char *drvname,
 					const struct pinmux_cfg_reg *cfg_reg)
 {
@@ -847,6 +864,30 @@ static void __init sh_pfc_check_cfg_reg(const char *drvname,
 	sh_pfc_check_reg_enums(drvname, cfg_reg->reg, cfg_reg->enum_ids, n);
 }
 
+static void __init sh_pfc_check_drive_reg(const struct sh_pfc_soc_info *info,
+					  const struct pinmux_drive_reg *drive)
+{
+	const char *drvname = info->name;
+	unsigned long seen = 0, mask;
+	unsigned int i;
+
+	sh_pfc_check_reg(info->name, drive->reg);
+	for (i = 0; i < ARRAY_SIZE(drive->fields); i++) {
+		const struct pinmux_drive_reg_field *field = &drive->fields[i];
+
+		if (!field->pin && !field->offset && !field->size)
+			continue;
+
+		mask = GENMASK(field->offset + field->size, field->offset);
+		if (mask & seen)
+			sh_pfc_err("drive_reg 0x%x: field %u overlap\n",
+				   drive->reg, i);
+		seen |= mask;
+
+		sh_pfc_check_pin(info, drive->reg, field->pin);
+	}
+}
+
 static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 {
 	const char *drvname = info->name;
@@ -939,6 +980,10 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	/* Check config register descriptions */
 	for (i = 0; info->cfg_regs && info->cfg_regs[i].reg; i++)
 		sh_pfc_check_cfg_reg(drvname, &info->cfg_regs[i]);
+
+	/* Check drive strength registers */
+	for (i = 0; info->drive_regs && info->drive_regs[i].reg; i++)
+		sh_pfc_check_drive_reg(info, &info->drive_regs[i]);
 }
 
 static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)

commit 40c8e4aad4e1575e101576aab1313f99ed3df49d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:22 2020 +0100

    pinctrl: sh-pfc: checker: Improve pin group checks
    
    Improve the checks for pin group descriptors:
      1. Introduce a local variable for the current group, to make the
         checks easier to read,
      2. Pin group names must be unique.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-9-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index fd649ab8ad1a..b67584d65ecc 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -916,15 +916,22 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	}
 
 	for (i = 0; i < info->nr_groups; i++) {
-		if (!info->groups[i].name) {
+		const struct sh_pfc_pin_group *group = &info->groups[i];
+
+		if (!group->name) {
 			sh_pfc_err("empty group %u\n", i);
 			continue;
 		}
+		for (j = 0; j < i; j++) {
+			if (same_name(group->name, info->groups[j].name))
+				sh_pfc_err("group %s: name conflict\n",
+					   group->name);
+		}
 		if (!refcnts[i])
-			sh_pfc_err("orphan group %s\n", info->groups[i].name);
+			sh_pfc_err("orphan group %s\n", group->name);
 		else if (refcnts[i] > 1)
 			sh_pfc_warn("group %s referenced by %u functions\n",
-				    info->groups[i].name, refcnts[i]);
+				    group->name, refcnts[i]);
 	}
 
 	kfree(refcnts);

commit a95b077db4fcf5aeeaf74372e31d684df29cb033
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:21 2020 +0100

    pinctrl: sh-pfc: checker: Improve pin function checks
    
    Improve the checks for pin function descriptors:
      1. Merge declaration and assignment of the local variable for the
         current pin function,
      2. Pin function names must be unique.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-8-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index be7afc48703d..fd649ab8ad1a 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -849,7 +849,6 @@ static void __init sh_pfc_check_cfg_reg(const char *drvname,
 
 static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 {
-	const struct sh_pfc_function *func;
 	const char *drvname = info->name;
 	unsigned int *refcnts;
 	unsigned int i, j, k;
@@ -890,11 +889,17 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 		return;
 
 	for (i = 0; i < info->nr_functions; i++) {
-		func = &info->functions[i];
+		const struct sh_pfc_function *func = &info->functions[i];
+
 		if (!func->name) {
 			sh_pfc_err("empty function %u\n", i);
 			continue;
 		}
+		for (j = 0; j < i; j++) {
+			if (same_name(func->name, info->functions[j].name))
+				sh_pfc_err("function %s: name conflict\n",
+					   func->name);
+		}
 		for (j = 0; j < func->nr_groups; j++) {
 			for (k = 0; k < info->nr_groups; k++) {
 				if (same_name(func->groups[j],

commit 4ef30dc72d0a3b3087078379b8e6d666a3c24270
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:20 2020 +0100

    pinctrl: sh-pfc: checker: Improve pin checks
    
    Improve the checks for pin descriptors:
      1. Introduce local variables for the current pin, to make the checks
         easier to read,
      2. Pins must have a name,
      3. Fix double printing of identical pin names.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-7-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 6c6eb791f145..be7afc48703d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -860,25 +860,27 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 
 	/* Check pins */
 	for (i = 0; i < info->nr_pins; i++) {
+		const struct sh_pfc_pin *pin = &info->pins[i];
+
+		if (!pin->name) {
+			sh_pfc_err("empty pin %u\n", i);
+			continue;
+		}
 		for (j = 0; j < i; j++) {
-			if (same_name(info->pins[i].name, info->pins[j].name))
-				sh_pfc_err("pin %s/%s: name conflict\n",
-					   info->pins[i].name,
-					   info->pins[j].name);
+			const struct sh_pfc_pin *pin2 = &info->pins[j];
+
+			if (same_name(pin->name, pin2->name))
+				sh_pfc_err("pin %s: name conflict\n",
+					   pin->name);
 
-			if (info->pins[i].pin != (u16)-1 &&
-			    info->pins[i].pin == info->pins[j].pin)
+			if (pin->pin != (u16)-1 && pin->pin == pin2->pin)
 				sh_pfc_err("pin %s/%s: pin %u conflict\n",
-					   info->pins[i].name,
-					   info->pins[j].name,
-					   info->pins[i].pin);
+					   pin->name, pin2->name, pin->pin);
 
-			if (info->pins[i].enum_id &&
-			    info->pins[i].enum_id == info->pins[j].enum_id)
+			if (pin->enum_id && pin->enum_id == pin2->enum_id)
 				sh_pfc_err("pin %s/%s: enum_id %u conflict\n",
-					   info->pins[i].name,
-					   info->pins[j].name,
-					   info->pins[i].enum_id);
+					   pin->name, pin2->name,
+					   pin->enum_id);
 		}
 	}
 

commit 12d057bad683b1c60476681ecc835c858018df60
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:19 2020 +0100

    pinctrl: sh-pfc: checker: Add check for enum ID conflicts
    
    Add a helper to verify that enum IDs are unique, and use it to validate
    the enum ID arrays in config register descriptors.
    
    This exposes bugs like those fixed in:
      - commit 805f635703b2562b ("pinctrl: sh-pfc: r8a7778: Fix duplicate
        SDSELF_B and SD1_CLK_B"),
      - commit 884caadad128efad ("pinctrl: sh-pfc: sh7734: Fix duplicate
        TCLK1_B"),
      - commit 2a069a92811fb35b ("pinctrl: sh-pfc: sh7264: Fix Port K I/O
        Register 0 definition").
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-6-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 69a6ec6aa334..6c6eb791f145 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -727,11 +727,14 @@ static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
 
 #ifdef DEBUG
 #define SH_PFC_MAX_REGS		300
+#define SH_PFC_MAX_ENUMS	3000
 
 static unsigned int sh_pfc_errors __initdata = 0;
 static unsigned int sh_pfc_warnings __initdata = 0;
 static u32 *sh_pfc_regs __initdata = NULL;
 static u32 sh_pfc_num_regs __initdata = 0;
+static u16 *sh_pfc_enums __initdata = NULL;
+static u32 sh_pfc_num_enums __initdata = 0;
 
 #define sh_pfc_err(fmt, ...)					\
 	do {							\
@@ -781,6 +784,36 @@ static void __init sh_pfc_check_reg(const char *drvname, u32 reg)
 	sh_pfc_regs[sh_pfc_num_regs++] = reg;
 }
 
+static int __init sh_pfc_check_enum(const char *drvname, u16 enum_id)
+{
+	unsigned int i;
+
+	for (i = 0; i < sh_pfc_num_enums; i++) {
+		if (enum_id == sh_pfc_enums[i])
+			return -EINVAL;
+	}
+
+	if (sh_pfc_num_enums == SH_PFC_MAX_ENUMS) {
+		pr_warn_once("%s: Please increase SH_PFC_MAX_ENUMS\n", drvname);
+		return 0;
+	}
+
+	sh_pfc_enums[sh_pfc_num_enums++] = enum_id;
+	return 0;
+}
+
+static void __init sh_pfc_check_reg_enums(const char *drvname, u32 reg,
+					  const u16 *enums, unsigned int n)
+{
+	unsigned int i;
+
+	for (i = 0; i < n; i++) {
+		if (enums[i] && sh_pfc_check_enum(drvname, enums[i]))
+			sh_pfc_err("reg 0x%x enum_id %u conflict\n", reg,
+				   enums[i]);
+	}
+}
+
 static void __init sh_pfc_check_cfg_reg(const char *drvname,
 					const struct pinmux_cfg_reg *cfg_reg)
 {
@@ -789,8 +822,9 @@ static void __init sh_pfc_check_cfg_reg(const char *drvname,
 	sh_pfc_check_reg(drvname, cfg_reg->reg);
 
 	if (cfg_reg->field_width) {
-		/* Checked at build time */
-		return;
+		n = cfg_reg->reg_width / cfg_reg->field_width;
+		/* Skip field checks (done at build time) */
+		goto check_enum_ids;
 	}
 
 	for (i = 0, n = 0, rw = 0; (fw = cfg_reg->var_field_width[i]); i++) {
@@ -808,6 +842,9 @@ static void __init sh_pfc_check_cfg_reg(const char *drvname,
 	if (n != cfg_reg->nr_enum_ids)
 		sh_pfc_err("reg 0x%x: enum_ids[] has %u instead of %u values\n",
 			   cfg_reg->reg, cfg_reg->nr_enum_ids, n);
+
+check_enum_ids:
+	sh_pfc_check_reg_enums(drvname, cfg_reg->reg, cfg_reg->enum_ids, n);
 }
 
 static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
@@ -819,6 +856,7 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 
 	pr_info("Checking %s\n", drvname);
 	sh_pfc_num_regs = 0;
+	sh_pfc_num_enums = 0;
 
 	/* Check pins */
 	for (i = 0; i < info->nr_pins; i++) {
@@ -898,6 +936,11 @@ static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)
 	if (!sh_pfc_regs)
 		return;
 
+	sh_pfc_enums = kcalloc(SH_PFC_MAX_ENUMS, sizeof(*sh_pfc_enums),
+			      GFP_KERNEL);
+	if (!sh_pfc_enums)
+		goto free_regs;
+
 	pr_warn("Checking builtin pinmux tables\n");
 
 	for (i = 0; pdrv->id_table[i].name[0]; i++)
@@ -911,6 +954,8 @@ static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)
 	pr_warn("Detected %u errors and %u warnings\n", sh_pfc_errors,
 		sh_pfc_warnings);
 
+	kfree(sh_pfc_enums);
+free_regs:
 	kfree(sh_pfc_regs);
 }
 

commit 3c26186472726fd22234fa63a6bc7c08112a4152
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:18 2020 +0100

    pinctrl: sh-pfc: checker: Add check for config register conflicts
    
    Add a helper to verify that register addresses are unique, and use it to
    validate config register descriptors.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-5-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index aad3f62c583f..69a6ec6aa334 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -726,8 +726,12 @@ static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
 #endif /* CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW */
 
 #ifdef DEBUG
+#define SH_PFC_MAX_REGS		300
+
 static unsigned int sh_pfc_errors __initdata = 0;
 static unsigned int sh_pfc_warnings __initdata = 0;
+static u32 *sh_pfc_regs __initdata = NULL;
+static u32 sh_pfc_num_regs __initdata = 0;
 
 #define sh_pfc_err(fmt, ...)					\
 	do {							\
@@ -759,11 +763,31 @@ static bool __init same_name(const char *a, const char *b)
 	return !strcmp(a, b);
 }
 
+static void __init sh_pfc_check_reg(const char *drvname, u32 reg)
+{
+	unsigned int i;
+
+	for (i = 0; i < sh_pfc_num_regs; i++)
+		if (reg == sh_pfc_regs[i]) {
+			sh_pfc_err("reg 0x%x conflict\n", reg);
+			return;
+		}
+
+	if (sh_pfc_num_regs == SH_PFC_MAX_REGS) {
+		pr_warn_once("%s: Please increase SH_PFC_MAX_REGS\n", drvname);
+		return;
+	}
+
+	sh_pfc_regs[sh_pfc_num_regs++] = reg;
+}
+
 static void __init sh_pfc_check_cfg_reg(const char *drvname,
 					const struct pinmux_cfg_reg *cfg_reg)
 {
 	unsigned int i, n, rw, fw;
 
+	sh_pfc_check_reg(drvname, cfg_reg->reg);
+
 	if (cfg_reg->field_width) {
 		/* Checked at build time */
 		return;
@@ -794,6 +818,7 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	unsigned int i, j, k;
 
 	pr_info("Checking %s\n", drvname);
+	sh_pfc_num_regs = 0;
 
 	/* Check pins */
 	for (i = 0; i < info->nr_pins; i++) {
@@ -868,6 +893,11 @@ static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)
 {
 	unsigned int i;
 
+	sh_pfc_regs = kcalloc(SH_PFC_MAX_REGS, sizeof(*sh_pfc_regs),
+			      GFP_KERNEL);
+	if (!sh_pfc_regs)
+		return;
+
 	pr_warn("Checking builtin pinmux tables\n");
 
 	for (i = 0; pdrv->id_table[i].name[0]; i++)
@@ -880,6 +910,8 @@ static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)
 
 	pr_warn("Detected %u errors and %u warnings\n", sh_pfc_errors,
 		sh_pfc_warnings);
+
+	kfree(sh_pfc_regs);
 }
 
 #else /* !DEBUG */

commit 1251887c0c78fe7fee1eb1e13546c86a75368cef
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:17 2020 +0100

    pinctrl: sh-pfc: checker: Add helper for safe name comparison
    
    Add a helper to check if two strings are identical, skipping NULL
    pointers.  This simplifies callers.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-4-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index d0b87a024516..aad3f62c583f 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -751,6 +751,14 @@ static bool __init is0s(const u16 *enum_ids, unsigned int n)
 	return true;
 }
 
+static bool __init same_name(const char *a, const char *b)
+{
+	if (!a || !b)
+		return false;
+
+	return !strcmp(a, b);
+}
+
 static void __init sh_pfc_check_cfg_reg(const char *drvname,
 					const struct pinmux_cfg_reg *cfg_reg)
 {
@@ -790,7 +798,7 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	/* Check pins */
 	for (i = 0; i < info->nr_pins; i++) {
 		for (j = 0; j < i; j++) {
-			if (!strcmp(info->pins[i].name, info->pins[j].name))
+			if (same_name(info->pins[i].name, info->pins[j].name))
 				sh_pfc_err("pin %s/%s: name conflict\n",
 					   info->pins[i].name,
 					   info->pins[j].name);
@@ -824,9 +832,8 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 		}
 		for (j = 0; j < func->nr_groups; j++) {
 			for (k = 0; k < info->nr_groups; k++) {
-				if (info->groups[k].name &&
-				    !strcmp(func->groups[j],
-					    info->groups[k].name)) {
+				if (same_name(func->groups[j],
+					      info->groups[k].name)) {
 					refcnts[k]++;
 					break;
 				}

commit c3f8dcee7a0cfe2a94103c6213d74eac99122f01
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:16 2020 +0100

    pinctrl: sh-pfc: checker: Add helpers for reporting
    
    Add helpers to report errors and warnings, and to increase the
    corresponding counters.  This simplifies callers.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-3-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a565effbff12..d0b87a024516 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -729,6 +729,17 @@ static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
 static unsigned int sh_pfc_errors __initdata = 0;
 static unsigned int sh_pfc_warnings __initdata = 0;
 
+#define sh_pfc_err(fmt, ...)					\
+	do {							\
+		pr_err("%s: " fmt, drvname, ##__VA_ARGS__);	\
+		sh_pfc_errors++;				\
+	} while (0)
+#define sh_pfc_warn(fmt, ...)					\
+	do {							\
+		pr_warn("%s: " fmt, drvname, ##__VA_ARGS__);	\
+		sh_pfc_warnings++;				\
+	} while (0)
+
 static bool __init is0s(const u16 *enum_ids, unsigned int n)
 {
 	unsigned int i;
@@ -751,26 +762,20 @@ static void __init sh_pfc_check_cfg_reg(const char *drvname,
 	}
 
 	for (i = 0, n = 0, rw = 0; (fw = cfg_reg->var_field_width[i]); i++) {
-		if (fw > 3 && is0s(&cfg_reg->enum_ids[n], 1 << fw)) {
-			pr_warn("%s: reg 0x%x: reserved field [%u:%u] can be split to reduce table size\n",
-				drvname, cfg_reg->reg, rw, rw + fw - 1);
-			sh_pfc_warnings++;
-		}
+		if (fw > 3 && is0s(&cfg_reg->enum_ids[n], 1 << fw))
+			sh_pfc_warn("reg 0x%x: reserved field [%u:%u] can be split to reduce table size\n",
+				    cfg_reg->reg, rw, rw + fw - 1);
 		n += 1 << fw;
 		rw += fw;
 	}
 
-	if (rw != cfg_reg->reg_width) {
-		pr_err("%s: reg 0x%x: var_field_width declares %u instead of %u bits\n",
-		       drvname, cfg_reg->reg, rw, cfg_reg->reg_width);
-		sh_pfc_errors++;
-	}
+	if (rw != cfg_reg->reg_width)
+		sh_pfc_err("reg 0x%x: var_field_width declares %u instead of %u bits\n",
+			   cfg_reg->reg, rw, cfg_reg->reg_width);
 
-	if (n != cfg_reg->nr_enum_ids) {
-		pr_err("%s: reg 0x%x: enum_ids[] has %u instead of %u values\n",
-		       drvname, cfg_reg->reg, cfg_reg->nr_enum_ids, n);
-		sh_pfc_errors++;
-	}
+	if (n != cfg_reg->nr_enum_ids)
+		sh_pfc_err("reg 0x%x: enum_ids[] has %u instead of %u values\n",
+			   cfg_reg->reg, cfg_reg->nr_enum_ids, n);
 }
 
 static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
@@ -785,29 +790,24 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	/* Check pins */
 	for (i = 0; i < info->nr_pins; i++) {
 		for (j = 0; j < i; j++) {
-			if (!strcmp(info->pins[i].name, info->pins[j].name)) {
-				pr_err("%s: pin %s/%s: name conflict\n",
-				       drvname, info->pins[i].name,
-				       info->pins[j].name);
-				sh_pfc_errors++;
-			}
+			if (!strcmp(info->pins[i].name, info->pins[j].name))
+				sh_pfc_err("pin %s/%s: name conflict\n",
+					   info->pins[i].name,
+					   info->pins[j].name);
 
 			if (info->pins[i].pin != (u16)-1 &&
-			    info->pins[i].pin == info->pins[j].pin) {
-				pr_err("%s: pin %s/%s: pin %u conflict\n",
-				       drvname, info->pins[i].name,
-				       info->pins[j].name, info->pins[i].pin);
-				sh_pfc_errors++;
-			}
+			    info->pins[i].pin == info->pins[j].pin)
+				sh_pfc_err("pin %s/%s: pin %u conflict\n",
+					   info->pins[i].name,
+					   info->pins[j].name,
+					   info->pins[i].pin);
 
 			if (info->pins[i].enum_id &&
-			    info->pins[i].enum_id == info->pins[j].enum_id) {
-				pr_err("%s: pin %s/%s: enum_id %u conflict\n",
-				       drvname, info->pins[i].name,
-				       info->pins[j].name,
-				       info->pins[i].enum_id);
-				sh_pfc_errors++;
-			}
+			    info->pins[i].enum_id == info->pins[j].enum_id)
+				sh_pfc_err("pin %s/%s: enum_id %u conflict\n",
+					   info->pins[i].name,
+					   info->pins[j].name,
+					   info->pins[i].enum_id);
 		}
 	}
 
@@ -819,8 +819,7 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	for (i = 0; i < info->nr_functions; i++) {
 		func = &info->functions[i];
 		if (!func->name) {
-			pr_err("%s: empty function %u\n", drvname, i);
-			sh_pfc_errors++;
+			sh_pfc_err("empty function %u\n", i);
 			continue;
 		}
 		for (j = 0; j < func->nr_groups; j++) {
@@ -833,29 +832,22 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 				}
 			}
 
-			if (k == info->nr_groups) {
-				pr_err("%s: function %s: group %s not found\n",
-				       drvname, func->name, func->groups[j]);
-				sh_pfc_errors++;
-			}
+			if (k == info->nr_groups)
+				sh_pfc_err("function %s: group %s not found\n",
+					   func->name, func->groups[j]);
 		}
 	}
 
 	for (i = 0; i < info->nr_groups; i++) {
 		if (!info->groups[i].name) {
-			pr_err("%s: empty group %u\n", drvname, i);
-			sh_pfc_errors++;
+			sh_pfc_err("empty group %u\n", i);
 			continue;
 		}
-		if (!refcnts[i]) {
-			pr_err("%s: orphan group %s\n", drvname,
-			       info->groups[i].name);
-			sh_pfc_errors++;
-		} else if (refcnts[i] > 1) {
-			pr_warn("%s: group %s referenced by %u functions\n",
-				drvname, info->groups[i].name, refcnts[i]);
-			sh_pfc_warnings++;
-		}
+		if (!refcnts[i])
+			sh_pfc_err("orphan group %s\n", info->groups[i].name);
+		else if (refcnts[i] > 1)
+			sh_pfc_warn("group %s referenced by %u functions\n",
+				    info->groups[i].name, refcnts[i]);
 	}
 
 	kfree(refcnts);

commit 264716935ed2c10adddbf6fe65214534346062fe
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jan 10 14:19:15 2020 +0100

    pinctrl: sh-pfc: checker: Move data before code
    
    Restructure the checker to move all data definitions to the top, before
    the code.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200110131927.1029-2-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 82209116955b..a565effbff12 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -726,6 +726,9 @@ static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
 #endif /* CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW */
 
 #ifdef DEBUG
+static unsigned int sh_pfc_errors __initdata = 0;
+static unsigned int sh_pfc_warnings __initdata = 0;
+
 static bool __init is0s(const u16 *enum_ids, unsigned int n)
 {
 	unsigned int i;
@@ -737,9 +740,6 @@ static bool __init is0s(const u16 *enum_ids, unsigned int n)
 	return true;
 }
 
-static unsigned int sh_pfc_errors __initdata = 0;
-static unsigned int sh_pfc_warnings __initdata = 0;
-
 static void __init sh_pfc_check_cfg_reg(const char *drvname,
 					const struct pinmux_cfg_reg *cfg_reg)
 {

commit f2bc07562748c23609743ded0630ec965f9e4fec
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Dec 30 09:31:56 2019 +0100

    pinctrl: sh-pfc: Split R-Car H3 support in two independent drivers
    
    Despite using the same compatible values ("r8a7795"-based) because of
    historical reasons, R-Car H3 ES1.x (R8A77950) and R-Car H3 ES2.0+
    (R8A77951) are really different SoCs, with different part numbers, and
    with different Pin Function Controller blocks.
    
    Reflect this in the pinctrl configuration, by replacing the existing
    CONFIG_PINCTRL_PFC_R8A7795 symbol by two new config symbols:
    CONFIG_PINCTRL_PFC_R8A77950 and CONFIG_PINCTRL_PFC_R8A77951.  The latter
    are selected automatically, depending on the soon-to-be-introduced
    corresponding SoC-specific config options, and on the current common
    config option, to relax dependencies.
    
    Rename the individual pin control driver source files from
    pfc-r8a7795-es1.c to pfc-r8a77950.c, and from pfc-r8a7795.c to
    pfc-r8a77951.c, and make them truly independent.
    As both SoCs share the same compatible value, special care must be taken
    to match them to the correct pin control driver, if support for it is
    included in the running kernel.
    
    This will allow making support for early R-Car H3 revisions optional,
    the largest share of which is taken by the pin control driver.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Tested-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Link: https://lore.kernel.org/r/20191230083156.19191-1-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 65e52688f091..82209116955b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -23,6 +23,7 @@
 #include <linux/platform_device.h>
 #include <linux/psci.h>
 #include <linux/slab.h>
+#include <linux/sys_soc.h>
 
 #include "core.h"
 
@@ -568,18 +569,18 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7794_pinmux_info,
 	},
 #endif
-#ifdef CONFIG_PINCTRL_PFC_R8A7795
+/* Both r8a7795 entries must be present to make sanity checks work */
+#ifdef CONFIG_PINCTRL_PFC_R8A77950
 	{
 		.compatible = "renesas,pfc-r8a7795",
-		.data = &r8a7795_pinmux_info,
+		.data = &r8a77950_pinmux_info,
 	},
-#ifdef DEBUG
+#endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77951
 	{
-		/* For sanity checks only (nothing matches against this) */
-		.compatible = "renesas,pfc-r8a77950",	/* R-Car H3 ES1.0 */
-		.data = &r8a7795es1_pinmux_info,
+		.compatible = "renesas,pfc-r8a7795",
+		.data = &r8a77951_pinmux_info,
 	},
-#endif /* DEBUG */
 #endif
 #ifdef CONFIG_PINCTRL_PFC_R8A77960
 	{
@@ -886,19 +887,49 @@ static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)
 static inline void sh_pfc_check_driver(struct platform_driver *pdrv) {}
 #endif /* !DEBUG */
 
+#ifdef CONFIG_OF
+static const void *sh_pfc_quirk_match(void)
+{
+#if defined(CONFIG_PINCTRL_PFC_R8A77950) || \
+    defined(CONFIG_PINCTRL_PFC_R8A77951)
+	const struct soc_device_attribute *match;
+	static const struct soc_device_attribute quirks[] = {
+		{
+			.soc_id = "r8a7795", .revision = "ES1.*",
+			.data = &r8a77950_pinmux_info,
+		},
+		{
+			.soc_id = "r8a7795",
+			.data = &r8a77951_pinmux_info,
+		},
+
+		{ /* sentinel */ }
+	};
+
+	match = soc_device_match(quirks);
+	if (match)
+		return match->data ?: ERR_PTR(-ENODEV);
+#endif /* CONFIG_PINCTRL_PFC_R8A77950 || CONFIG_PINCTRL_PFC_R8A77951 */
+
+	return NULL;
+}
+#endif /* CONFIG_OF */
+
 static int sh_pfc_probe(struct platform_device *pdev)
 {
-#ifdef CONFIG_OF
-	struct device_node *np = pdev->dev.of_node;
-#endif
 	const struct sh_pfc_soc_info *info;
 	struct sh_pfc *pfc;
 	int ret;
 
 #ifdef CONFIG_OF
-	if (np)
-		info = of_device_get_match_data(&pdev->dev);
-	else
+	if (pdev->dev.of_node) {
+		info = sh_pfc_quirk_match();
+		if (IS_ERR(info))
+			return PTR_ERR(info);
+
+		if (!info)
+			info = of_device_get_match_data(&pdev->dev);
+	} else
 #endif
 		info = (const void *)platform_get_device_id(pdev)->driver_data;
 

commit 708c69e9eaccffc944858c6fbb38f600926e1fcf
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 23 14:29:55 2019 +0200

    pinctrl: sh-pfc: r8a7796: Add R8A77961 PFC support
    
    Add support for the Pin Function Controller in the R-Car M3-W+
    (R8A77961) SoC.
    
    R-Car M3-W+ is pin compatible with R-Car M3-W (R8A77960), which allows
    for both SoCs to share a driver.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Link: https://lore.kernel.org/r/20191023122955.12420-4-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 3aab444b2fca..65e52688f091 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -587,6 +587,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a77960_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77961
+	{
+		.compatible = "renesas,pfc-r8a77961",
+		.data = &r8a77961_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A77965
 	{
 		.compatible = "renesas,pfc-r8a77965",

commit d15ca3a321a2ba16e716b23fa552ff27f2f722ec
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 23 14:29:54 2019 +0200

    pinctrl: sh-pfc: Rename PINCTRL_PFC_R8A7796 to PINCTRL_PFC_R8A77960
    
    Rename CONFIG_PINCTRL_PFC_R8A7796 for R-Car M3-W (R8A77960) to
    CONFIG_PINCTRL_PFC_R8A77960, to avoid confusion with R-Car M3-W+
    (R8A77961), which will use CONFIG_PINCTRL_PFC_R8A77961.
    
    Extend the dependency of CONFIG_PINCTRL_PFC_R8A77960 from
    CONFIG_ARCH_R8A7796 to CONFIG_ARCH_R8A77960, to relax dependencies for a
    future rename of the SoC configuration symbol.
    
    Rename r8a7796_pinmux_info to r8a77960_pinmux_info, as it contains an
    r8a77960-based name.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Link: https://lore.kernel.org/r/20191023122955.12420-3-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index fd879a1599b1..3aab444b2fca 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -581,10 +581,10 @@ static const struct of_device_id sh_pfc_of_table[] = {
 	},
 #endif /* DEBUG */
 #endif
-#ifdef CONFIG_PINCTRL_PFC_R8A7796
+#ifdef CONFIG_PINCTRL_PFC_R8A77960
 	{
 		.compatible = "renesas,pfc-r8a7796",
-		.data = &r8a7796_pinmux_info,
+		.data = &r8a77960_pinmux_info,
 	},
 #endif
 #ifdef CONFIG_PINCTRL_PFC_R8A77965

commit ad7fe1a1a35994a201497443b5140bf54b074cca
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 16 16:26:01 2019 +0200

    pinctrl: sh-pfc: Do not use platform_get_irq() to count interrupts
    
    As platform_get_irq() now prints an error when the interrupt does not
    exist, counting interrupts by looping until failure causes the printing
    of scary messages like:
    
        sh-pfc e6060000.pin-controller: IRQ index 0 not found
    
    Fix this by using the platform_irq_count() helper instead.
    
    Fixes: 7723f4c5ecdb8d83 ("driver core: platform: Add an error message to platform_get_irq*()")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Tested-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Link: https://lore.kernel.org/r/20191016142601.28255-1-geert+renesas@glider.be

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index f8cbd33b4511..fd879a1599b1 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -29,12 +29,12 @@
 static int sh_pfc_map_resources(struct sh_pfc *pfc,
 				struct platform_device *pdev)
 {
-	unsigned int num_windows, num_irqs;
 	struct sh_pfc_window *windows;
 	unsigned int *irqs = NULL;
+	unsigned int num_windows;
 	struct resource *res;
 	unsigned int i;
-	int irq;
+	int num_irqs;
 
 	/* Count the MEM and IRQ resources. */
 	for (num_windows = 0;; num_windows++) {
@@ -42,17 +42,13 @@ static int sh_pfc_map_resources(struct sh_pfc *pfc,
 		if (!res)
 			break;
 	}
-	for (num_irqs = 0;; num_irqs++) {
-		irq = platform_get_irq(pdev, num_irqs);
-		if (irq == -EPROBE_DEFER)
-			return irq;
-		if (irq < 0)
-			break;
-	}
-
 	if (num_windows == 0)
 		return -EINVAL;
 
+	num_irqs = platform_irq_count(pdev);
+	if (num_irqs < 0)
+		return num_irqs;
+
 	/* Allocate memory windows and IRQs arrays. */
 	windows = devm_kcalloc(pfc->dev, num_windows, sizeof(*windows),
 			       GFP_KERNEL);

commit 271ff378a30086952eb9df1471006dff9a6b5f92
Author: Biju Das <biju.das@bp.renesas.com>
Date:   Thu Sep 19 09:17:16 2019 +0100

    pinctrl: sh-pfc: r8a77965: Add R8A774B1 PFC support
    
    Renesas RZ/G2N (r8a774b1) is pin compatible with R-Car M3-N (r8a77965),
    however it doesn't have several automotive specific peripherals. Add
    a r8a77965 specific pin groups/functions along with common pin
    groups/functions for supporting both r8a77965 and r8a774b1 SoC.
    
    Signed-off-by: Biju Das <biju.das@bp.renesas.com>
    Link: https://lore.kernel.org/r/1568881036-4404-9-git-send-email-biju.das@bp.renesas.com
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b8640ad41bef..f8cbd33b4511 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -518,6 +518,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a774a1_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A774B1
+	{
+		.compatible = "renesas,pfc-r8a774b1",
+		.data = &r8a774b1_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A774C0
 	{
 		.compatible = "renesas,pfc-r8a774c0",

commit 542ffc9e026a3f736eeaa041823d406510f40a12
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Mar 27 11:41:36 2019 +0100

    pinctrl: sh-pfc: Validate pin tables at runtime
    
    Extend the run-time debug code with checks to ensure there are no
    conflicting pin names, numbers, or enumeration values.
    
    This helps catching bugs early.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b4ba98156485..b8640ad41bef 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -773,6 +773,35 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 
 	pr_info("Checking %s\n", drvname);
 
+	/* Check pins */
+	for (i = 0; i < info->nr_pins; i++) {
+		for (j = 0; j < i; j++) {
+			if (!strcmp(info->pins[i].name, info->pins[j].name)) {
+				pr_err("%s: pin %s/%s: name conflict\n",
+				       drvname, info->pins[i].name,
+				       info->pins[j].name);
+				sh_pfc_errors++;
+			}
+
+			if (info->pins[i].pin != (u16)-1 &&
+			    info->pins[i].pin == info->pins[j].pin) {
+				pr_err("%s: pin %s/%s: pin %u conflict\n",
+				       drvname, info->pins[i].name,
+				       info->pins[j].name, info->pins[i].pin);
+				sh_pfc_errors++;
+			}
+
+			if (info->pins[i].enum_id &&
+			    info->pins[i].enum_id == info->pins[j].enum_id) {
+				pr_err("%s: pin %s/%s: enum_id %u conflict\n",
+				       drvname, info->pins[i].name,
+				       info->pins[j].name,
+				       info->pins[i].enum_id);
+				sh_pfc_errors++;
+			}
+		}
+	}
+
 	/* Check groups and functions */
 	refcnts = kcalloc(info->nr_groups, sizeof(*refcnts), GFP_KERNEL);
 	if (!refcnts)

commit 3dd5fd79f07103f7cda30567f8bf85a854796dd6
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Apr 25 10:33:55 2019 +0200

    pinctrl: sh-pfc: Add check for empty pinmux groups/functions
    
    The pinmux groups and functions arrays may contain two parts, to ease
    supporting SoCs that expose pin subsets of other related SoCs.  Both
    parts need to be declared with explicit sizes, which thus need to be
    updated when adding support for more groups and functions.
    
    If a size is too small, the compiler will detect this at build time
    ("excess elements in array initializer").
    If a size is too large, this may go undetected (for pin groups), lead to
    pin controller registration failures (for pin functions: "pinmux ops has
    no name for functionN"), or crash the optional run-time debug code (for
    pin groups).
    
    Extend the run-time debug code with checks to detect this, to help
    catching bugs early.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 3507bab78eed..b4ba98156485 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -780,9 +780,15 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 
 	for (i = 0; i < info->nr_functions; i++) {
 		func = &info->functions[i];
+		if (!func->name) {
+			pr_err("%s: empty function %u\n", drvname, i);
+			sh_pfc_errors++;
+			continue;
+		}
 		for (j = 0; j < func->nr_groups; j++) {
 			for (k = 0; k < info->nr_groups; k++) {
-				if (!strcmp(func->groups[j],
+				if (info->groups[k].name &&
+				    !strcmp(func->groups[j],
 					    info->groups[k].name)) {
 					refcnts[k]++;
 					break;
@@ -798,6 +804,11 @@ static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 	}
 
 	for (i = 0; i < info->nr_groups; i++) {
+		if (!info->groups[i].name) {
+			pr_err("%s: empty group %u\n", drvname, i);
+			sh_pfc_errors++;
+			continue;
+		}
 		if (!refcnts[i]) {
 			pr_err("%s: orphan group %s\n", drvname,
 			       info->groups[i].name);

commit 80cde64f68ff09617f89e78dfadf5a6873be87a8
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Apr 25 10:54:11 2019 +0200

    pinctrl: sh-pfc: Mark run-time debug code __init
    
    All run-time debug code is called from sh_pfc_init(), which is __init.
    
    Fixes: 6161b39a14380815 ("pinctrl: sh-pfc: Validate pinmux tables at runtime when debugging")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 8a57a68aa6b1..3507bab78eed 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -717,7 +717,7 @@ static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
 #endif /* CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW */
 
 #ifdef DEBUG
-static bool is0s(const u16 *enum_ids, unsigned int n)
+static bool __init is0s(const u16 *enum_ids, unsigned int n)
 {
 	unsigned int i;
 
@@ -728,11 +728,11 @@ static bool is0s(const u16 *enum_ids, unsigned int n)
 	return true;
 }
 
-static unsigned int sh_pfc_errors;
-static unsigned int sh_pfc_warnings;
+static unsigned int sh_pfc_errors __initdata = 0;
+static unsigned int sh_pfc_warnings __initdata = 0;
 
-static void sh_pfc_check_cfg_reg(const char *drvname,
-				 const struct pinmux_cfg_reg *cfg_reg)
+static void __init sh_pfc_check_cfg_reg(const char *drvname,
+					const struct pinmux_cfg_reg *cfg_reg)
 {
 	unsigned int i, n, rw, fw;
 
@@ -764,7 +764,7 @@ static void sh_pfc_check_cfg_reg(const char *drvname,
 	}
 }
 
-static void sh_pfc_check_info(const struct sh_pfc_soc_info *info)
+static void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 {
 	const struct sh_pfc_function *func;
 	const char *drvname = info->name;
@@ -816,7 +816,7 @@ static void sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 		sh_pfc_check_cfg_reg(drvname, &info->cfg_regs[i]);
 }
 
-static void sh_pfc_check_driver(const struct platform_driver *pdrv)
+static void __init sh_pfc_check_driver(const struct platform_driver *pdrv)
 {
 	unsigned int i;
 

commit 5f304f8c87c71572da4ee514eb2ec50f8f4d2e26
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Apr 25 10:51:46 2019 +0200

    pinctrl: sh-pfc: Correct printk level of group reference warning
    
    Improve wording while at it.
    
    Fixes: 6161b39a14380815 ("pinctrl: sh-pfc: Validate pinmux tables at runtime when debugging")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 3f989f5cb021..8a57a68aa6b1 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -803,8 +803,8 @@ static void sh_pfc_check_info(const struct sh_pfc_soc_info *info)
 			       info->groups[i].name);
 			sh_pfc_errors++;
 		} else if (refcnts[i] > 1) {
-			pr_err("%s: group %s referred by %u functions\n",
-			       drvname, info->groups[i].name, refcnts[i]);
+			pr_warn("%s: group %s referenced by %u functions\n",
+				drvname, info->groups[i].name, refcnts[i]);
 			sh_pfc_warnings++;
 		}
 	}

commit fa4d36712f20e2425171ab1f62341ebb6416d3ea
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Dec 13 15:48:45 2018 +0100

    pinctrl: sh-pfc: Validate enum IDs for regs with variable-width fields
    
    Add a run-time check to the PINMUX_CFG_REG_VAR() macro, to ensure the
    number of provided enum IDs is correct.  This cannot be done at build
    time, as the number of values depends on the variable-width fields in
    the config register.
    
    This helps catching bugs early.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 2ceed2f5ac08..3f989f5cb021 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -756,6 +756,12 @@ static void sh_pfc_check_cfg_reg(const char *drvname,
 		       drvname, cfg_reg->reg, rw, cfg_reg->reg_width);
 		sh_pfc_errors++;
 	}
+
+	if (n != cfg_reg->nr_enum_ids) {
+		pr_err("%s: reg 0x%x: enum_ids[] has %u instead of %u values\n",
+		       drvname, cfg_reg->reg, cfg_reg->nr_enum_ids, n);
+		sh_pfc_errors++;
+	}
 }
 
 static void sh_pfc_check_info(const struct sh_pfc_soc_info *info)

commit 6161b39a14380815f22851c753c00acf81cfa62a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Dec 13 15:48:45 2018 +0100

    pinctrl: sh-pfc: Validate pinmux tables at runtime when debugging
    
    Perform some basic sanity checks on all built-in pinmux tables when
    DEBUG is defined, to help catching bugs early.
    
    For now the following checks are included:
      - Check register and field widths in descriptors for config registers
        with variable-width fields,
      - Check relations between pin groups and functions:
          - All pin functions must refer to existing pin groups,
          - All pin groups must be referred to by a pin function,
          - Warn if a pin group is referred to by multiple pin functions
            (which is OK for backwards-compatibility aliases),
      - Provide suggestions for reducing table sizes: reserved fields of
        more than 3 bits can better be split in smaller subfields, as the
        storage need is proportional to the square of the width of the
        (sub)field,
    
    Note that a dummy non-matching entry is added to the DT match table for
    checking r8a7795es1_pinmux_info, as R-Car H3 ES1.0 is matched using
    soc_device_match() in r8a7795_pinmux_init(), instead of by the DT match
    table.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index f1cfcc8c6544..2ceed2f5ac08 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -571,6 +571,13 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.compatible = "renesas,pfc-r8a7795",
 		.data = &r8a7795_pinmux_info,
 	},
+#ifdef DEBUG
+	{
+		/* For sanity checks only (nothing matches against this) */
+		.compatible = "renesas,pfc-r8a77950",	/* R-Car H3 ES1.0 */
+		.data = &r8a7795es1_pinmux_info,
+	},
+#endif /* DEBUG */
 #endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7796
 	{
@@ -709,6 +716,122 @@ static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
 #define DEV_PM_OPS	NULL
 #endif /* CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW */
 
+#ifdef DEBUG
+static bool is0s(const u16 *enum_ids, unsigned int n)
+{
+	unsigned int i;
+
+	for (i = 0; i < n; i++)
+		if (enum_ids[i])
+			return false;
+
+	return true;
+}
+
+static unsigned int sh_pfc_errors;
+static unsigned int sh_pfc_warnings;
+
+static void sh_pfc_check_cfg_reg(const char *drvname,
+				 const struct pinmux_cfg_reg *cfg_reg)
+{
+	unsigned int i, n, rw, fw;
+
+	if (cfg_reg->field_width) {
+		/* Checked at build time */
+		return;
+	}
+
+	for (i = 0, n = 0, rw = 0; (fw = cfg_reg->var_field_width[i]); i++) {
+		if (fw > 3 && is0s(&cfg_reg->enum_ids[n], 1 << fw)) {
+			pr_warn("%s: reg 0x%x: reserved field [%u:%u] can be split to reduce table size\n",
+				drvname, cfg_reg->reg, rw, rw + fw - 1);
+			sh_pfc_warnings++;
+		}
+		n += 1 << fw;
+		rw += fw;
+	}
+
+	if (rw != cfg_reg->reg_width) {
+		pr_err("%s: reg 0x%x: var_field_width declares %u instead of %u bits\n",
+		       drvname, cfg_reg->reg, rw, cfg_reg->reg_width);
+		sh_pfc_errors++;
+	}
+}
+
+static void sh_pfc_check_info(const struct sh_pfc_soc_info *info)
+{
+	const struct sh_pfc_function *func;
+	const char *drvname = info->name;
+	unsigned int *refcnts;
+	unsigned int i, j, k;
+
+	pr_info("Checking %s\n", drvname);
+
+	/* Check groups and functions */
+	refcnts = kcalloc(info->nr_groups, sizeof(*refcnts), GFP_KERNEL);
+	if (!refcnts)
+		return;
+
+	for (i = 0; i < info->nr_functions; i++) {
+		func = &info->functions[i];
+		for (j = 0; j < func->nr_groups; j++) {
+			for (k = 0; k < info->nr_groups; k++) {
+				if (!strcmp(func->groups[j],
+					    info->groups[k].name)) {
+					refcnts[k]++;
+					break;
+				}
+			}
+
+			if (k == info->nr_groups) {
+				pr_err("%s: function %s: group %s not found\n",
+				       drvname, func->name, func->groups[j]);
+				sh_pfc_errors++;
+			}
+		}
+	}
+
+	for (i = 0; i < info->nr_groups; i++) {
+		if (!refcnts[i]) {
+			pr_err("%s: orphan group %s\n", drvname,
+			       info->groups[i].name);
+			sh_pfc_errors++;
+		} else if (refcnts[i] > 1) {
+			pr_err("%s: group %s referred by %u functions\n",
+			       drvname, info->groups[i].name, refcnts[i]);
+			sh_pfc_warnings++;
+		}
+	}
+
+	kfree(refcnts);
+
+	/* Check config register descriptions */
+	for (i = 0; info->cfg_regs && info->cfg_regs[i].reg; i++)
+		sh_pfc_check_cfg_reg(drvname, &info->cfg_regs[i]);
+}
+
+static void sh_pfc_check_driver(const struct platform_driver *pdrv)
+{
+	unsigned int i;
+
+	pr_warn("Checking builtin pinmux tables\n");
+
+	for (i = 0; pdrv->id_table[i].name[0]; i++)
+		sh_pfc_check_info((void *)pdrv->id_table[i].driver_data);
+
+#ifdef CONFIG_OF
+	for (i = 0; pdrv->driver.of_match_table[i].compatible[0]; i++)
+		sh_pfc_check_info(pdrv->driver.of_match_table[i].data);
+#endif
+
+	pr_warn("Detected %u errors and %u warnings\n", sh_pfc_errors,
+		sh_pfc_warnings);
+}
+
+#else /* !DEBUG */
+static inline void sh_pfc_check_driver(struct platform_driver *pdrv) {}
+#endif /* !DEBUG */
+
 static int sh_pfc_probe(struct platform_device *pdev)
 {
 #ifdef CONFIG_OF
@@ -840,6 +963,7 @@ static struct platform_driver sh_pfc_driver = {
 
 static int __init sh_pfc_init(void)
 {
+	sh_pfc_check_driver(&sh_pfc_driver);
 	return platform_driver_register(&sh_pfc_driver);
 }
 postcore_initcall(sh_pfc_init);

commit ce16e8dd0db2701265e6dfdb4fbed632b6ff61c2
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Dec 13 15:20:13 2018 +0100

    pinctrl: sh-pfc: Print actual field width for variable-width fields
    
    The debug code in sh_pfc_write_config_reg() prints the width of the
    field being modified.
    
    However, registers with a variable-width field layout are identified by
    pinmux_cfg_reg.field_width being zero, hence zeroes are printed instead
    of the actual field widths.
    
    Fix this by printing the Hamming weight of the field mask instead, which
    is correct for both fixed-width and variable-width fields.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a10f7050a74f..f1cfcc8c6544 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -221,7 +221,7 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 	dev_dbg(pfc->dev, "write_reg addr = %x, value = 0x%x, field = %u, "
 		"r_width = %u, f_width = %u\n",
-		crp->reg, value, field, crp->reg_width, crp->field_width);
+		crp->reg, value, field, crp->reg_width, hweight32(mask));
 
 	mask = ~(mask << pos);
 	value = value << pos;

commit 9f2b76a2db3c43872048cbca1269f3fc5fbcd75d
Author: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
Date:   Wed Sep 12 14:31:02 2018 +0100

    pinctrl: sh-pfc: r8a77990: Add R8A774C0 PFC support
    
    Renesas RZ/G2E (a.k.a. r8a774c0) is pin compatible with R-Car
    E3 (a.k.a. r8a77990), however it doesn't have several automotive
    specific peripherals. Add a r8a77990 specific pin groups/functions
    along with common pin groups/functions for supporting both r8a77990
    and r8a774c0 SoCs.
    
    Signed-off-by: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
    Reviewed-by: Biju Das <biju.das@bp.renesas.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 891bdb26ddf9..a10f7050a74f 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -518,6 +518,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a774a1_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A774C0
+	{
+		.compatible = "renesas,pfc-r8a774c0",
+		.data = &r8a774c0_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7778
 	{
 		.compatible = "renesas,pfc-r8a7778",

commit d7097b97e91362ded242e5516f8d97b985f60941
Author: Biju Das <biju.das@bp.renesas.com>
Date:   Tue Sep 11 11:30:05 2018 +0100

    pinctrl: sh-pfc: r8a7791: Add r8a7744 support
    
    Renesas RZ/G1N (R8A7744) is pin compatible with R-Car M2-W/N (R8A7791/3)
    and RZ/G1M.
    
    Signed-off-by: Biju Das <biju.das@bp.renesas.com>
    Reviewed-by: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a222c74e9afa..891bdb26ddf9 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -494,6 +494,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7743_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7744
+	{
+		.compatible = "renesas,pfc-r8a7744",
+		.data = &r8a7744_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7745
 	{
 		.compatible = "renesas,pfc-r8a7745",

commit 63b6d7e762cb434a71588e1a824207f4d65a6745
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Sep 7 02:13:29 2018 +0000

    pinctrl: sh-pfc: Convert to SPDX identifiers
    
    This patch updates license to use SPDX-License-Identifier
    instead of verbose license text.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 012247138d91..a222c74e9afa 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Pin Control and GPIO driver for SuperH Pin Function Controller.
  *
@@ -5,10 +6,6 @@
  *
  * Copyright (C) 2008 Magnus Damm
  * Copyright (C) 2009 - 2012 Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 
 #define DRV_NAME "sh-pfc"

commit 91d627a779a16a247f7da30a6538bccd30804b2b
Author: Biju Das <biju.das@bp.renesas.com>
Date:   Mon Aug 13 14:52:32 2018 +0100

    pinctrl: sh-pfc: r8a7796: Add R8A774A1 PFC support
    
    Renesas RZ/G2M (r8a774a1) is pin compatible with R-Car M3-W (r8a7796),
    however it doesn't have several automotive specific peripherals. Add
    an r8a7796 specific pin groups/functions along with common pin
    groups/functions for supporting both r8a7796 and r8a774a1 SoCs.
    
    Signed-off-by: Biju Das <biju.das@bp.renesas.com>
    Reviewed-by: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index c671c3c4aca6..012247138d91 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -509,6 +509,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a77470_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A774A1
+	{
+		.compatible = "renesas,pfc-r8a774a1",
+		.data = &r8a774a1_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7778
 	{
 		.compatible = "renesas,pfc-r8a7778",

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index eb06981538b4..c671c3c4aca6 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -57,7 +57,7 @@ static int sh_pfc_map_resources(struct sh_pfc *pfc,
 		return -EINVAL;
 
 	/* Allocate memory windows and IRQs arrays. */
-	windows = devm_kzalloc(pfc->dev, num_windows * sizeof(*windows),
+	windows = devm_kcalloc(pfc->dev, num_windows, sizeof(*windows),
 			       GFP_KERNEL);
 	if (windows == NULL)
 		return -ENOMEM;
@@ -66,7 +66,7 @@ static int sh_pfc_map_resources(struct sh_pfc *pfc,
 	pfc->windows = windows;
 
 	if (num_irqs) {
-		irqs = devm_kzalloc(pfc->dev, num_irqs * sizeof(*irqs),
+		irqs = devm_kcalloc(pfc->dev, num_irqs, sizeof(*irqs),
 				    GFP_KERNEL);
 		if (irqs == NULL)
 			return -ENOMEM;
@@ -444,7 +444,7 @@ static int sh_pfc_init_ranges(struct sh_pfc *pfc)
 	}
 
 	pfc->nr_ranges = nr_ranges;
-	pfc->ranges = devm_kzalloc(pfc->dev, sizeof(*pfc->ranges) * nr_ranges,
+	pfc->ranges = devm_kcalloc(pfc->dev, nr_ranges, sizeof(*pfc->ranges),
 				   GFP_KERNEL);
 	if (pfc->ranges == NULL)
 		return -ENOMEM;

commit 6d4036a1e3b3ac0f3eebda5a0bbc6d78ebc14389
Author: Takeshi Kihara <takeshi.kihara.df@renesas.com>
Date:   Fri May 11 12:22:23 2018 +0900

    pinctrl: sh-pfc: Initial R8A77990 PFC support
    
    This patch adds initial pinctrl driver to support for the R8A77990 SoC.
    
    Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b069fe3bf75d..eb06981538b4 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -581,6 +581,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a77980_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77990
+	{
+		.compatible = "renesas,pfc-r8a77990",
+		.data = &r8a77990_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A77995
 	{
 		.compatible = "renesas,pfc-r8a77995",

commit 73dacc3403436fc246258c0933e35b6e809640ac
Author: Biju Das <biju.das@bp.renesas.com>
Date:   Tue Apr 24 12:03:08 2018 +0100

    pinctrl: sh-pfc: Add r8a77470 PFC support
    
    Add PFC support for the R8A77470 SoC including pin groups for
    some on-chip devices such as SCIF and MMC.
    
    Signed-off-by: Biju Das <biju.das@bp.renesas.com>
    Reviewed-by: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 74861b7b5b0d..b069fe3bf75d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -503,6 +503,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7745_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77470
+	{
+		.compatible = "renesas,pfc-r8a77470",
+		.data = &r8a77470_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7778
 	{
 		.compatible = "renesas,pfc-r8a7778",

commit f59125248a691dfef62f0450ce7b0238b63b6dbd
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Thu Mar 8 22:14:32 2018 +0300

    pinctrl: sh-pfc: Add R8A77980 PFC support
    
    Add the PFC support for the R8A77980 SoC including pin groups for some
    on-chip devices such as AVB, CAN-FD, GETHER, [H]SCIF, I2C, INTC-EX, MMC,
    MSIOF, PWM, and VIN...
    
    Based on the original (and large) patch by Vladimir Barinov.
    
    Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 7461af941659..74861b7b5b0d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -569,6 +569,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a77970_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77980
+	{
+		.compatible = "renesas,pfc-r8a77980",
+		.data = &r8a77980_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A77995
 	{
 		.compatible = "renesas,pfc-r8a77995",

commit 490e687eb8b274b5d942e1cf61fb01392b86ecce
Author: Jacopo Mondi <jacopo+renesas@jmondi.org>
Date:   Tue Feb 20 16:12:07 2018 +0100

    pinctrl: sh-pfc: Initial R-Car M3-N support
    
    Add initial PFC support for R-Car M3-N (r8a77965) SoC.
    No groups or functions defined, just pin and registers enumeration.
    
    Signed-off-by: Jacopo Mondi <jacopo+renesas@jmondi.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index e9eb7a7c6fac..7461af941659 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -557,6 +557,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7796_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77965
+	{
+		.compatible = "renesas,pfc-r8a77965",
+		.data = &r8a77965_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A77970
 	{
 		.compatible = "renesas,pfc-r8a77970",

commit b92ac66a1819602b1427ac72d4a70c10ba7640ad
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Fri Nov 10 20:59:01 2017 +0300

    pinctrl: sh-pfc: Add R8A77970 PFC support
    
    Add the PFC support for the R8A77970 SoC including pin groups for some
    on-chip devices such as CAN-FD, [H]SCIF, I2C, INTC-EX, MMC, MSIOF, PWM,
    VIN...
    
    Based on the original (and large) patch by Daisuke Matsushita
    <daisuke.matsushita.ns@hitachi.com>.
    
    Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-by: Rob Herring <robh@kernel.org>
    [geert: Drop EtherAVB for now]
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index cf4ae4bc9115..e9eb7a7c6fac 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -557,6 +557,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7796_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77970
+	{
+		.compatible = "renesas,pfc-r8a77970",
+		.data = &r8a77970_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A77995
 	{
 		.compatible = "renesas,pfc-r8a77995",

commit 8843797df383ac7ed7cf4f87cc18a4ec6d929b60
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Sep 29 14:17:18 2017 +0200

    pinctrl: sh-pfc: Save/restore registers for PSCI system suspend
    
    During PSCI system suspend, R-Car Gen3 SoCs are powered down, and their
    pinctrl register state is lost.  Note that as the boot loader skips most
    initialization after system resume, pinctrl register state differs from
    the state encountered during normal system boot, too.
    
    To fix this, save all GPIO and peripheral function select, module
    select, drive strength control, bias, and other I/O control registers
    during system suspend, and restore them during system resume.
    
    Note that to avoid overhead on platforms not needing it, the
    suspend/resume code has a build time dependency on sleep and PSCI
    support, and a runtime dependency on PSCI.
    
    Inspired by a patch in the BSP by Hien Dang.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 2fe5fd6c5d17..cf4ae4bc9115 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -24,6 +24,7 @@
 #include <linux/of_device.h>
 #include <linux/pinctrl/machine.h>
 #include <linux/platform_device.h>
+#include <linux/psci.h>
 #include <linux/slab.h>
 
 #include "core.h"
@@ -572,6 +573,97 @@ static const struct of_device_id sh_pfc_of_table[] = {
 };
 #endif
 
+#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_ARM_PSCI_FW)
+static void sh_pfc_nop_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)
+{
+}
+
+static void sh_pfc_save_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)
+{
+	pfc->saved_regs[idx] = sh_pfc_read(pfc, reg);
+}
+
+static void sh_pfc_restore_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)
+{
+	sh_pfc_write(pfc, reg, pfc->saved_regs[idx]);
+}
+
+static unsigned int sh_pfc_walk_regs(struct sh_pfc *pfc,
+	void (*do_reg)(struct sh_pfc *pfc, u32 reg, unsigned int idx))
+{
+	unsigned int i, n = 0;
+
+	if (pfc->info->cfg_regs)
+		for (i = 0; pfc->info->cfg_regs[i].reg; i++)
+			do_reg(pfc, pfc->info->cfg_regs[i].reg, n++);
+
+	if (pfc->info->drive_regs)
+		for (i = 0; pfc->info->drive_regs[i].reg; i++)
+			do_reg(pfc, pfc->info->drive_regs[i].reg, n++);
+
+	if (pfc->info->bias_regs)
+		for (i = 0; pfc->info->bias_regs[i].puen; i++) {
+			do_reg(pfc, pfc->info->bias_regs[i].puen, n++);
+			if (pfc->info->bias_regs[i].pud)
+				do_reg(pfc, pfc->info->bias_regs[i].pud, n++);
+		}
+
+	if (pfc->info->ioctrl_regs)
+		for (i = 0; pfc->info->ioctrl_regs[i].reg; i++)
+			do_reg(pfc, pfc->info->ioctrl_regs[i].reg, n++);
+
+	return n;
+}
+
+static int sh_pfc_suspend_init(struct sh_pfc *pfc)
+{
+	unsigned int n;
+
+	/* This is the best we can do to check for the presence of PSCI */
+	if (!psci_ops.cpu_suspend)
+		return 0;
+
+	n = sh_pfc_walk_regs(pfc, sh_pfc_nop_reg);
+	if (!n)
+		return 0;
+
+	pfc->saved_regs = devm_kmalloc_array(pfc->dev, n,
+					     sizeof(*pfc->saved_regs),
+					     GFP_KERNEL);
+	if (!pfc->saved_regs)
+		return -ENOMEM;
+
+	dev_dbg(pfc->dev, "Allocated space to save %u regs\n", n);
+	return 0;
+}
+
+static int sh_pfc_suspend_noirq(struct device *dev)
+{
+	struct sh_pfc *pfc = dev_get_drvdata(dev);
+
+	if (pfc->saved_regs)
+		sh_pfc_walk_regs(pfc, sh_pfc_save_reg);
+	return 0;
+}
+
+static int sh_pfc_resume_noirq(struct device *dev)
+{
+	struct sh_pfc *pfc = dev_get_drvdata(dev);
+
+	if (pfc->saved_regs)
+		sh_pfc_walk_regs(pfc, sh_pfc_restore_reg);
+	return 0;
+}
+
+static const struct dev_pm_ops sh_pfc_pm  = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(sh_pfc_suspend_noirq, sh_pfc_resume_noirq)
+};
+#define DEV_PM_OPS	&sh_pfc_pm
+#else
+static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
+#define DEV_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW */
+
 static int sh_pfc_probe(struct platform_device *pdev)
 {
 #ifdef CONFIG_OF
@@ -610,6 +702,10 @@ static int sh_pfc_probe(struct platform_device *pdev)
 		info = pfc->info;
 	}
 
+	ret = sh_pfc_suspend_init(pfc);
+	if (ret)
+		return ret;
+
 	/* Enable dummy states for those platforms without pinctrl support */
 	if (!of_have_populated_dt())
 		pinctrl_provide_dummies();
@@ -693,6 +789,7 @@ static struct platform_driver sh_pfc_driver = {
 	.driver		= {
 		.name	= DRV_NAME,
 		.of_match_table = of_match_ptr(sh_pfc_of_table),
+		.pm     = DEV_PM_OPS,
 	},
 };
 

commit 1860bb134fc29dee0aeb912ae20799119b920df9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Sep 29 17:12:39 2017 +0200

    pinctrl: sh-pfc: Remove obsolete sh_pfc_pin_to_bias_info()
    
    All users of sh_pfc_pin_to_bias_info() and the related data structures
    have been converted to sh_pfc_pin_to_bias_reg(), so those can be
    removed.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 01c408a3dee4..2fe5fd6c5d17 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -389,21 +389,6 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	return 0;
 }
 
-const struct sh_pfc_bias_info *
-sh_pfc_pin_to_bias_info(const struct sh_pfc_bias_info *info,
-			unsigned int num, unsigned int pin)
-{
-	unsigned int i;
-
-	for (i = 0; i < num; i++)
-		if (info[i].pin == pin)
-			return &info[i];
-
-	WARN_ONCE(1, "Pin %u is not in bias info list\n", pin);
-
-	return NULL;
-}
-
 const struct pinmux_bias_reg *
 sh_pfc_pin_to_bias_reg(const struct sh_pfc *pfc, unsigned int pin,
 		       unsigned int *bit)

commit acdb12453910d86dce3baa95c12178893c0aa32d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Sep 29 15:44:38 2017 +0200

    pinctrl: sh-pfc: Add sh_pfc_pin_to_bias_reg() helper
    
    Add a helper to look up bias registers and bit number for a specific
    pin, using the generic bias register description.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 8b422ac07e57..01c408a3dee4 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -404,6 +404,26 @@ sh_pfc_pin_to_bias_info(const struct sh_pfc_bias_info *info,
 	return NULL;
 }
 
+const struct pinmux_bias_reg *
+sh_pfc_pin_to_bias_reg(const struct sh_pfc *pfc, unsigned int pin,
+		       unsigned int *bit)
+{
+	unsigned int i, j;
+
+	for (i = 0; pfc->info->bias_regs[i].puen; i++) {
+		for (j = 0; j < ARRAY_SIZE(pfc->info->bias_regs[i].pins); j++) {
+			if (pfc->info->bias_regs[i].pins[j] == pin) {
+				*bit = j;
+				return &pfc->info->bias_regs[i];
+			}
+		}
+	}
+
+	WARN_ONCE(1, "Pin %u is not in bias info list\n", pin);
+
+	return NULL;
+}
+
 static int sh_pfc_init_ranges(struct sh_pfc *pfc)
 {
 	struct sh_pfc_pin_range *range;

commit e16a2c7aced8422cda2b7f13ea3f3daccb150db6
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Sep 29 11:03:11 2017 +0200

    pinctrl: sh-pfc: Drop width parameter of sh_pfc_{read,write}_reg()
    
    On modern Renesas SoCs, all PFC registers are 32-bit, and all callers of
    sh_pfc_{read,write}_reg() already operate on 32-bit registers only.
    Hence make the 32-bit width implicit, and rename the functions to
    sh_pfc_{read,write}() to shorten lines.
    
    All accesses to 8-bit or 16-bit registers are still done using
    sh_pfc_{read,write}_raw_reg().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 9cdbaeab2cf1..8b422ac07e57 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -175,19 +175,19 @@ void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned int reg_width,
 	BUG();
 }
 
-u32 sh_pfc_read_reg(struct sh_pfc *pfc, u32 reg, unsigned int width)
+u32 sh_pfc_read(struct sh_pfc *pfc, u32 reg)
 {
-	return sh_pfc_read_raw_reg(sh_pfc_phys_to_virt(pfc, reg), width);
+	return sh_pfc_read_raw_reg(sh_pfc_phys_to_virt(pfc, reg), 32);
 }
 
-void sh_pfc_write_reg(struct sh_pfc *pfc, u32 reg, unsigned int width, u32 data)
+void sh_pfc_write(struct sh_pfc *pfc, u32 reg, u32 data)
 {
 	if (pfc->info->unlock_reg)
 		sh_pfc_write_raw_reg(
 			sh_pfc_phys_to_virt(pfc, pfc->info->unlock_reg), 32,
 			~data);
 
-	sh_pfc_write_raw_reg(sh_pfc_phys_to_virt(pfc, reg), width, data);
+	sh_pfc_write_raw_reg(sh_pfc_phys_to_virt(pfc, reg), 32, data);
 }
 
 static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,

commit 35406b1fd68dec6d8b1badd69fcfb65646745dfd
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Sep 29 10:08:56 2017 +0200

    pinctrl: sh-pfc: Remove matching on plain sh-pfc platform device
    
    As of commit 8682b3c522c639f3 ("sh-pfc: Remove platform device
    registration"), plain "sh-pfc" platform devices are no longer created.
    Hence remove their match entry, and the now obsolete checks for missing
    device IDs and driver data.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 0c5e952461fd..9cdbaeab2cf1 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -569,7 +569,6 @@ static const struct of_device_id sh_pfc_of_table[] = {
 
 static int sh_pfc_probe(struct platform_device *pdev)
 {
-	const struct platform_device_id *platid = platform_get_device_id(pdev);
 #ifdef CONFIG_OF
 	struct device_node *np = pdev->dev.of_node;
 #endif
@@ -582,10 +581,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 		info = of_device_get_match_data(&pdev->dev);
 	else
 #endif
-		info = platid ? (const void *)platid->driver_data : NULL;
-
-	if (info == NULL)
-		return -ENODEV;
+		info = (const void *)platform_get_device_id(pdev)->driver_data;
 
 	pfc = devm_kzalloc(&pdev->dev, sizeof(*pfc), GFP_KERNEL);
 	if (pfc == NULL)
@@ -683,7 +679,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_SHX3
 	{ "pfc-shx3", (kernel_ulong_t)&shx3_pinmux_info },
 #endif
-	{ "sh-pfc", 0 },
 	{ },
 };
 

commit 794a6711764658a1adc0fed95abed628ea72091d
Author: Takeshi Kihara <takeshi.kihara.df@renesas.com>
Date:   Wed Aug 9 21:19:41 2017 +0900

    pinctrl: sh-pfc: Initial R8A77995 PFC support
    
    This patch adds initial pinctrl driver to support for the R8A77995 SoC.
    
    Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    [geert: whitespace]
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index e72391d5e57d..0c5e952461fd 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -551,6 +551,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7796_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A77995
+	{
+		.compatible = "renesas,pfc-r8a77995",
+		.data = &r8a77995_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{
 		.compatible = "renesas,pfc-sh73a0",

commit c8bac70f079bb3ecaf9a716f141f3d85cef27231
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Fri Apr 28 21:52:35 2017 +0300

    pinctrl: sh-pfc: r8a7794: Add R8A7745 support
    
    Renesas RZ/G1E (R8A7745) is pin compatible with R-Car E2 (R8A7794),
    however it doesn't have several automotive specific peripherals.
    Annotate all the items that only exist on the R-Car SoCs...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-by: Rob Herring <robh@kernel.org>
    [geert: Drop annotations, as they are implied by pin groups/functions]
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index fd1fec61cdff..e72391d5e57d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -491,6 +491,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7743_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7745
+	{
+		.compatible = "renesas,pfc-r8a7745",
+		.data = &r8a7745_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7778
 	{
 		.compatible = "renesas,pfc-r8a7778",

commit 8df62701496d26b2c2578502e704a7a84993b2ba
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Thu Apr 20 21:46:08 2017 +0300

    pinctrl: sh-pfc: r8a7791: Add R8A7743 support
    
    Renesas RZ/G1M (R8A7743) is pin compatible with R-Car M2-W/N (R8A7791/3),
    however it doesn't have several automotive specific peripherals.  Annotate
    all the items that only exist on the R-Car SoCs and only supply the pin
    groups/functions existing on a given SoC...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-by: Rob Herring <robh@kernel.org>
    [geert: Drop annotations, as they are implied by pin groups/functions]
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 4a5a0feb931b..fd1fec61cdff 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -485,6 +485,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7740_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7743
+	{
+		.compatible = "renesas,pfc-r8a7743",
+		.data = &r8a7743_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7778
 	{
 		.compatible = "renesas,pfc-r8a7778",

commit 3091ae775fae17084013021d01513bc1ad274e6a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Mar 9 19:20:48 2017 +0100

    pinctrl: sh-pfc: Update info pointer after SoC-specific init
    
    Update the sh_pfc_soc_info pointer after calling the SoC-specific
    initialization function, as it may have been updated to e.g. handle
    different SoC revisions.  This makes sure the correct subdriver name is
    printed later.
    
    Fixes: 0c151062f32c9db8 ("sh-pfc: Add support for SoC-specific initialization")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index cf80ce1dd7ce..4a5a0feb931b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -586,6 +586,9 @@ static int sh_pfc_probe(struct platform_device *pdev)
 		ret = info->ops->init(pfc);
 		if (ret < 0)
 			return ret;
+
+		/* .init() may have overridden pfc->info */
+		info = pfc->info;
 	}
 
 	/* Enable dummy states for those platforms without pinctrl support */

commit c314c9f15aa5f43f0e5c0e2602cc65798dbd1598
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Sat Nov 12 17:04:25 2016 +0100

    pinctrl: sh-pfc: Add helper to handle bias lookup table
    
    On some SoC there are no simple mapping of pins to bias register bits
    and a lookup table is needed. This logic is already implemented in some
    SoC specific drivers that could benefit from a generic implementation.
    
    Add helpers to deal with the lookup which later can be used by the SoC
    specific drivers. The logic used to lookup are different from the one it
    aims to replace, this is intentional. This new method reduces the memory
    consumption at the cost of increased CPU usage and fix a bug where a
    WARN() would incorrectly be triggered if the register offset is 0.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index f3a8897d4e8f..cf80ce1dd7ce 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -389,6 +389,21 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	return 0;
 }
 
+const struct sh_pfc_bias_info *
+sh_pfc_pin_to_bias_info(const struct sh_pfc_bias_info *info,
+			unsigned int num, unsigned int pin)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; i++)
+		if (info[i].pin == pin)
+			return &info[i];
+
+	WARN_ONCE(1, "Pin %u is not in bias info list\n", pin);
+
+	return NULL;
+}
+
 static int sh_pfc_init_ranges(struct sh_pfc *pfc)
 {
 	struct sh_pfc_pin_range *range;

commit f9aece7344bd81ce16bafc15f8e90ef0dbd18714
Author: Takeshi Kihara <takeshi.kihara.df@renesas.com>
Date:   Thu Aug 18 15:12:32 2016 +0200

    pinctrl: sh-pfc: Initial R8A7796 PFC support
    
    This patch adds initial pinctrl driver to support for the R8A7796 SoC.
    
    Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
    [uli: rebased on top of renesas-drivers]
    Signed-off-by: Ulrich Hecht <ulrich.hecht+renesas@gmail.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index d74169edf35d..f3a8897d4e8f 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -518,6 +518,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7795_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7796
+	{
+		.compatible = "renesas,pfc-r8a7796",
+		.data = &r8a7796_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{
 		.compatible = "renesas,pfc-sh73a0",

commit 2cf59e0c200de79cd2a8f87ba06c87fa24060e2d
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Thu Jun 30 00:21:08 2016 +0300

    pinctrl: sh-pfc: Add R8A7792 PFC support
    
    Add the PFC support for the R8A7792 SoC including pin groups for some
    on-chip devices such as SCIF, INTC, and LBSC...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    [geert: s/LSBC/LBSC/]
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a3b82041b6a2..d74169edf35d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -494,6 +494,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7791_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7792
+	{
+		.compatible = "renesas,pfc-r8a7792",
+		.data = &r8a7792_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7793
 	{
 		.compatible = "renesas,pfc-r8a7793",

commit c29e2f2cb6ceb574ac9bc2f324a13f0e6b08115a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jun 10 11:22:44 2016 +0200

    pinctrl: sh-pfc: Convert to devm_gpiochip_add_data()
    
    This allows to remove the .remove() callback, and all functions and data
    it needed for its own bookkeeping.
    
    Suggested-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 9b9cee06ec59..a3b82041b6a2 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -598,15 +598,6 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int sh_pfc_remove(struct platform_device *pdev)
-{
-#ifdef CONFIG_PINCTRL_SH_PFC_GPIO
-	sh_pfc_unregister_gpiochip(platform_get_drvdata(pdev));
-#endif
-
-	return 0;
-}
-
 static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
@@ -650,7 +641,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 
 static struct platform_driver sh_pfc_driver = {
 	.probe		= sh_pfc_probe,
-	.remove		= sh_pfc_remove,
 	.id_table	= sh_pfc_id_table,
 	.driver		= {
 		.name	= DRV_NAME,

commit a37571a29eca963562ff5a9233db4a5c73c72cf9
Merge: a0d3c7c5c07c 0d5358330c20
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 12:50:56 2016 -0700

    Merge tag 'pinctrl-v4.7-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This kernel cycle was quite calm when it comes to pin control and
      there is really just one major change, and that is the introduction of
      devm_pinctrl_register() managed resources.
    
      Apart from that linear development, details below.
    
      Core changes:
    
       - Add the devm_pinctrl_register() API and switch all applicable
         drivers to use it, saving lots of lines of code all over the place.
    
      New drivers:
    
       - driver for the Broadcom NS2 SoC
    
       - subdriver for the PXA25x SoCs
    
       - subdriver for the AMLogic Meson GXBB SoC
    
      Driver improvements:
    
       - the Intel Baytrail driver now properly supports pin control
    
       - Nomadik, Rockchip, Broadcom BCM2835 support the .get_direction()
         callback in the GPIO portions
    
       - continued development and stabilization of several SH-PFC SoC
         subdrivers: r8a7795, r8a7790, r8a7794 etc"
    
    * tag 'pinctrl-v4.7-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (85 commits)
      Revert "pinctrl: tegra: avoid parked_reg and parked_bank"
      pinctrl: meson: Fix eth_tx_en bit index
      pinctrl: tegra: avoid parked_reg and parked_bank
      pinctrl: tegra: Correctly check the supported configuration
      pinctrl: amlogic: Add support for Amlogic Meson GXBB SoC
      pinctrl: rockchip: fix pull setting error for rk3399
      pinctrl: stm32: Implement .pin_config_dbg_show()
      pinctrl: nomadik: hide nmk_gpio_get_mode when unused
      pinctrl: ns2: rename pinctrl_utils_dt_free_map
      pinctrl: at91: Merge clk_prepare and clk_enable into clk_prepare_enable
      pinctrl: at91: Make at91_gpio_template const
      pinctrl: baytrail: fix some error handling in debugfs
      pinctrl: ns2: add pinmux driver support for Broadcom NS2 SoC
      pinctrl: sirf/atlas7: trivial fix of spelling mistake on flagged
      pinctrl: sh-pfc: Kill unused variable in sh_pfc_remove()
      pinctrl: nomadik: implement .get_direction()
      pinctrl: nomadik: use BIT() with offsets consequently
      pinctrl: exynos5440: Use off-stack memory for pinctrl_gpio_range
      pinctrl: zynq: Use devm_pinctrl_register() for pinctrl registration
      pinctrl: u300: Use devm_pinctrl_register() for pinctrl registration
      ...

commit 1acd010152138644f63d743e165161edc780fc32
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 26 12:30:26 2016 +0200

    pinctrl: sh-pfc: Kill unused variable in sh_pfc_remove()
    
    If CONFIG_PINCTRL_SH_PFC_GPIO=n:
    
        drivers/pinctrl/sh-pfc/core.c: In function 'sh_pfc_remove':
        drivers/pinctrl/sh-pfc/core.c:649:17: warning: unused variable 'pfc' [-Wunused-variable]
    
    Fixes: 67ec8d7b48463904 ("pinctrl: ish-pfc: Use devm_pinctrl_register() for pinctrl registration")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 9a085cbb9d18..da2bf7933906 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -598,10 +598,8 @@ static int sh_pfc_probe(struct platform_device *pdev)
 
 static int sh_pfc_remove(struct platform_device *pdev)
 {
-	struct sh_pfc *pfc = platform_get_drvdata(pdev);
-
 #ifdef CONFIG_PINCTRL_SH_PFC_GPIO
-	sh_pfc_unregister_gpiochip(pfc);
+	sh_pfc_unregister_gpiochip(platform_get_drvdata(pdev));
 #endif
 
 	return 0;

commit 67ec8d7b484639040b7a75b289a2a1d1763e3430
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Sun Feb 28 14:37:47 2016 +0530

    pinctrl: ish-pfc: Use devm_pinctrl_register() for pinctrl registration
    
    Use devm_pinctrl_register() for pin control registration.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: linux-renesas-soc@vger.kernel.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 0497bbb8a8e7..9a085cbb9d18 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -603,7 +603,6 @@ static int sh_pfc_remove(struct platform_device *pdev)
 #ifdef CONFIG_PINCTRL_SH_PFC_GPIO
 	sh_pfc_unregister_gpiochip(pfc);
 #endif
-	sh_pfc_unregister_pinctrl(pfc);
 
 	return 0;
 }

commit 0129801be4b87226bf502f18f5a9eabd356d1058
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Mar 7 19:40:57 2016 +0100

    pinctrl: sh-pfc: only use dummy states for non-DT platforms
    
    If pinctrl_provide_dummies() is used unconditionally, then the dummy
    state will be used even on DT platforms when the "init" state was
    intentionally left out. Instead of "default", the dummy "init" state
    will then be used during probe. Thus, when probing an I2C controller on
    cold boot, communication triggered by bus notifiers broke because the
    pins were not initialized.
    
    Do it like OMAP2: use the dummy state only for non-DT platforms.
    
    Cc: stable@vger.kernel.org
    Fixes: ef0eebc05130 ("drivers/pinctrl: Add the concept of an "init" state")
    Reported-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index dc3609f0c60b..ee0c1f2567d9 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -546,7 +546,9 @@ static int sh_pfc_probe(struct platform_device *pdev)
 			return ret;
 	}
 
-	pinctrl_provide_dummies();
+	/* Enable dummy states for those platforms without pinctrl support */
+	if (!of_have_populated_dt())
+		pinctrl_provide_dummies();
 
 	ret = sh_pfc_init_ranges(pfc);
 	if (ret < 0)

commit 3caa7d8c3f03ad6f1b66f10f67dc68cb3af55fe1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Mar 23 16:06:00 2016 +0200

    pinctrl: sh-pfc: Add drive strength support
    
    Add support for the drive-strengh pin configuration using the generic
    pinconf DT bindings.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index dc3609f0c60b..0497bbb8a8e7 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -175,6 +175,21 @@ void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned int reg_width,
 	BUG();
 }
 
+u32 sh_pfc_read_reg(struct sh_pfc *pfc, u32 reg, unsigned int width)
+{
+	return sh_pfc_read_raw_reg(sh_pfc_phys_to_virt(pfc, reg), width);
+}
+
+void sh_pfc_write_reg(struct sh_pfc *pfc, u32 reg, unsigned int width, u32 data)
+{
+	if (pfc->info->unlock_reg)
+		sh_pfc_write_raw_reg(
+			sh_pfc_phys_to_virt(pfc, pfc->info->unlock_reg), 32,
+			~data);
+
+	sh_pfc_write_raw_reg(sh_pfc_phys_to_virt(pfc, reg), width, data);
+}
+
 static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 				     const struct pinmux_cfg_reg *crp,
 				     unsigned int in_pos,

commit 331207af11964954f51ec44689b93977ac0c6843
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Mar 1 17:38:46 2016 +0100

    pinctrl: sh-pfc: core: don't open code of_device_get_match_data()
    
    This change will also make Coverity happy by avoiding a theoretical NULL
    pointer dereference; yet another reason is to use the above helper function
    to tighten the code and make it more readable.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index c05f701f30ef..dc3609f0c60b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -519,7 +519,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 
 #ifdef CONFIG_OF
 	if (np)
-		info = of_match_device(sh_pfc_of_table, &pdev->dev)->data;
+		info = of_device_get_match_data(&pdev->dev);
 	else
 #endif
 		info = platid ? (const void *)platid->driver_data : NULL;

commit a43647b6d8f43b1dab717a90c2b8fe2b34129b41
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Feb 29 15:48:40 2016 -0500

    pinctrl: sh-pfc: make explicitly non-modular
    
    The Kconfig / Makefile currently controlling compilation of this code is:
    
    drivers/pinctrl/sh-pfc/Makefile:obj-$(CONFIG_PINCTRL_SH_PFC)    += sh-pfc.o
    drivers/pinctrl/sh-pfc/Makefile:sh-pfc-objs                     = core.o pinctrl.o
    
    drivers/pinctrl/sh-pfc/Kconfig:config PINCTRL_SH_PFC
    drivers/pinctrl/sh-pfc/Kconfig: def_bool y
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the modular code that is essentially orphaned, so that
    when reading the driver there is no doubt it is builtin-only.
    
    Since module_init already wasn't being used in this code, the init
    ordering remains unchanged with this commit.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    We also delete the MODULE_LICENSE tag etc. since all that information
    was (or is now) contained at the top of the file in the comments.
    
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-gpio@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 0c2d14c504aa..c05f701f30ef 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -1,5 +1,7 @@
 /*
- * SuperH Pin Function Controller support.
+ * Pin Control and GPIO driver for SuperH Pin Function Controller.
+ *
+ * Authors: Magnus Damm, Paul Mundt, Laurent Pinchart
  *
  * Copyright (C) 2008 Magnus Damm
  * Copyright (C) 2009 - 2012 Paul Mundt
@@ -17,7 +19,7 @@
 #include <linux/io.h>
 #include <linux/ioport.h>
 #include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/init.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/pinctrl/machine.h>
@@ -503,7 +505,6 @@ static const struct of_device_id sh_pfc_of_table[] = {
 #endif
 	{ },
 };
-MODULE_DEVICE_TABLE(of, sh_pfc_of_table);
 #endif
 
 static int sh_pfc_probe(struct platform_device *pdev)
@@ -632,7 +633,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 	{ "sh-pfc", 0 },
 	{ },
 };
-MODULE_DEVICE_TABLE(platform, sh_pfc_id_table);
 
 static struct platform_driver sh_pfc_driver = {
 	.probe		= sh_pfc_probe,
@@ -649,13 +649,3 @@ static int __init sh_pfc_init(void)
 	return platform_driver_register(&sh_pfc_driver);
 }
 postcore_initcall(sh_pfc_init);
-
-static void __exit sh_pfc_exit(void)
-{
-	platform_driver_unregister(&sh_pfc_driver);
-}
-module_exit(sh_pfc_exit);
-
-MODULE_AUTHOR("Magnus Damm, Paul Mundt, Laurent Pinchart");
-MODULE_DESCRIPTION("Pin Control and GPIO driver for SuperH pin function controller");
-MODULE_LICENSE("GPL v2");

commit abc60d483788c0b9363371764c9cb35ee9c6781d
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Wed Feb 17 17:15:49 2016 +0900

    pinctrl: sh-pfc: Rework PFC GPIO support
    
    The sh-pfc pinctrl driver is currently handling SoC-specific
    PFC hardware blocks on ARM64, ARM and SH architectures.
    
    For older SoCs using SH cores and some 32-bit ARM SoCs the PFC
    hardware also provides GPIO functionality. On the majority of
    32-bit ARM SoCs from Renesas and so far all ARM64 SoCs the GPIO
    feature is provided by separate hardware blocks.
    
    So far GPIO support in the PFC driver has been compiled-in for
    the majority of the SoCs, but with this patch applied the SoCs
    with PFC support may select from one of the following:
     - CONFIG_PINCTRL_SH_PFC - Used if PFC lacks GPIO hardware
     - CONFIG_PINCTRL_SH_PFC_GPIO - Used if PFC includes GPIO support
    
    This patch results in the following changes:
     - The GPIO functionality is only compiled-in on relevant SoCs
     - The number of lines of code is reduced
    
    Build tested using the following configurations:
     - r8a7795 -> CONFIG_PINCTRL_SH_PFC_GPIO=n -> OK (ARM64)
     - r8a7790 -> CONFIG_PINCTRL_SH_PFC_GPIO=n -> OK (ARM)
     - r8a7790 + r8a7740 -> CONFIG_PINCTRL_SH_PFC_GPIO=y -> OK (ARM)
     - r8a7740 -> CONFIG_PINCTRL_SH_PFC_GPIO=y -> OK (ARM)
     - sh7751 -> CONFIG_PINCTRL_SH_PFC=n -> OK (SH rts7751r2d1)
     - sh7724 -> CONFIG_PINCTRL_SH_PFC_GPIO=y -> OK (SH ecovec24)
    
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    [geert: s/def_bool n/bool/]
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 181ea98a63b7..0c2d14c504aa 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -558,7 +558,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	if (unlikely(ret != 0))
 		return ret;
 
-#ifdef CONFIG_GPIO_SH_PFC
+#ifdef CONFIG_PINCTRL_SH_PFC_GPIO
 	/*
 	 * Then the GPIO chip
 	 */
@@ -584,7 +584,7 @@ static int sh_pfc_remove(struct platform_device *pdev)
 {
 	struct sh_pfc *pfc = platform_get_drvdata(pdev);
 
-#ifdef CONFIG_GPIO_SH_PFC
+#ifdef CONFIG_PINCTRL_SH_PFC_GPIO
 	sh_pfc_unregister_gpiochip(pfc);
 #endif
 	sh_pfc_unregister_pinctrl(pfc);

commit 660c40bd9837854b3d3cc75e6ddb41cc8ac32a1d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Sep 25 11:29:01 2015 +0200

    pinctrl: sh-pfc: Remove obsolete r8a7778 platform_device_id entry
    
    Since the removal of the r8a7778 legacy SoC code in commit
    4baadb9e05c68962 ("ARM: shmobile: r8a7778: remove obsolete setup code"),
    r8a7778 is only supported in generic DT-only ARM multi-platform builds.
    The driver doesn't need to match platform devices by name anymore, hence
    remove the corresponding platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index c6be17f1621a..181ea98a63b7 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -593,9 +593,6 @@ static int sh_pfc_remove(struct platform_device *pdev)
 }
 
 static const struct platform_device_id sh_pfc_id_table[] = {
-#ifdef CONFIG_PINCTRL_PFC_R8A7778
-	{ "pfc-r8a7778", (kernel_ulong_t)&r8a7778_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
 #endif

commit 5eb6fc210ea2f988731f54eda0497d0518b89347
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Sep 25 11:27:19 2015 +0200

    pinctrl: sh-pfc: Remove obsolete r8a7779 platform_device_id entry
    
    Since the removal of the r8a7779 legacy SoC code in commit
    c99cd90d98a98aa1 ("ARM: shmobile: r8a7779: Remove legacy SoC code"),
    r8a7779 is only supported in generic DT-only ARM multi-platform builds.
    The driver doesn't need to match platform devices by name anymore, hence
    remove the corresponding platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index e6a5174d3acb..c6be17f1621a 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -596,9 +596,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7778
 	{ "pfc-r8a7778", (kernel_ulong_t)&r8a7778_pinmux_info },
 #endif
-#ifdef CONFIG_PINCTRL_PFC_R8A7779
-	{ "pfc-r8a7779", (kernel_ulong_t)&r8a7779_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
 #endif

commit b8b47d678a5f0b5826044242780a988f8af50b22
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Sep 21 16:27:23 2015 +0200

    pinctrl: sh-pfc: Rename .gpio_data[] to .pinmux_data[]
    
    The sh_pfc_soc_info.gpio_data[] array contains not only GPIO data, but
    also various other pinmux-related data (functions and marks).
    Every single driver already calls its local array pinmux_data[].
    Hence rename the sh_pfc_soc_info member to "pinmux_data".
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index bcf3017318db..e6a5174d3acb 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -272,7 +272,7 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, u16 enum_id,
 static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, u16 mark, int pos,
 			      u16 *enum_idp)
 {
-	const u16 *data = pfc->info->gpio_data;
+	const u16 *data = pfc->info->pinmux_data;
 	unsigned int k;
 
 	if (pos) {
@@ -280,7 +280,7 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, u16 mark, int pos,
 		return pos + 1;
 	}
 
-	for (k = 0; k < pfc->info->gpio_data_size; k++) {
+	for (k = 0; k < pfc->info->pinmux_data_size; k++) {
 		if (data[k] == mark) {
 			*enum_idp = data[k + 1];
 			return k + 1;

commit 0b0ffc96dbe30fa9d966a6f8a9ce9f276fd4007f
Author: Takeshi Kihara <takeshi.kihara.df@renesas.com>
Date:   Thu Sep 3 02:51:49 2015 +0000

    pinctrl: sh-pfc: Initial R8A7795 PFC support
    
    Add PFC base support for the R8A7795 SoC.
    
    Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
    [Morimoto-san: updated]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index fb9c44805234..bcf3017318db 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -489,6 +489,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7794_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7795
+	{
+		.compatible = "renesas,pfc-r8a7795",
+		.data = &r8a7795_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{
 		.compatible = "renesas,pfc-sh73a0",

commit 03c42c3e5216e2777f8ae819d6a076e94dcdfbdd
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jul 14 13:56:55 2015 +0200

    pinctrl: sh-pfc: Remove obsolete r8a7740 platform_device_id entry
    
    Since the removal of the r8a7740 legacy SoC code in commit
    44d88c754e57a6d9 ("ARM: shmobile: Remove legacy SoC code for R-Mobile
    A1"), r8a7740 is only supported in generic DT-only ARM multi-platform
    builds.  The driver doesn't need to match platform devices by name
    anymore, hence remove the corresponding platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 23b2b3be26fd..fb9c44805234 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -587,9 +587,6 @@ static int sh_pfc_remove(struct platform_device *pdev)
 }
 
 static const struct platform_device_id sh_pfc_id_table[] = {
-#ifdef CONFIG_PINCTRL_PFC_R8A7740
-	{ "pfc-r8a7740", (kernel_ulong_t)&r8a7740_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7778
 	{ "pfc-r8a7778", (kernel_ulong_t)&r8a7778_pinmux_info },
 #endif

commit 39ad6ff12cd54607b64642562ad850bb09176734
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jul 14 13:56:53 2015 +0200

    pinctrl: sh-pfc: Remove obsolete sh73a0 platform_device_id entry
    
    Since the removal of the sh73a0 legacy SoC code in commit
    9a9863987bf7307f ("ARM: shmobile: Remove legacy SoC code for SH-Mobile
    AG5"), sh73a0 is only supported in generic DT-only ARM multi-platform
    builds.  The driver doesn't need to match platform devices by name
    anymore, hence remove the corresponding platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 979623895904..23b2b3be26fd 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -605,9 +605,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_SH7269
 	{ "pfc-sh7269", (kernel_ulong_t)&sh7269_pinmux_info },
 #endif
-#ifdef CONFIG_PINCTRL_PFC_SH73A0
-	{ "pfc-sh73a0", (kernel_ulong_t)&sh73a0_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7720
 	{ "pfc-sh7720", (kernel_ulong_t)&sh7720_pinmux_info },
 #endif

commit c7977ec4a33633c8e8d9267dd014356cf857351c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jun 25 11:39:53 2015 +0200

    pinctrl: sh-pfc: Convert to platform_get_*()
    
    If the pin function controller (which can be a GPIO controller) is
    instantiated before the interrupt controllers, due to the ordering in
    the DTS, the irq domains for the interrupt controllers referenced by its
    "interrupts-extended" property cannot be found yet:
    
        irq: no irq domain found for /interrupt-controller@e61c0000 !
    
    As the sh-pfc driver accesses the platform device's resources directly,
    it cannot find the (optional) IRQ resources, and thinks no interrupts
    are available. This may lead to failures later, when GPIOs are used as
    interupts:
    
        gpio-keys keyboard: Unable to claim irq 0; error -22
        gpio-keys: probe of keyboard failed with error -22
    
    To fix this, add support for deferred probing to sh-pfc, by converting
    the driver from direct platform device resource access to using the
    platform_get_resource() and platform_get_irq() helpers.
    
    Note that while this fixes the root cause worked around by commit
    e4ba0a9bddff3ba5 ("ARM: shmobile: r8a73a4: Move pfc node to work around
    probe ordering bug"), I strongly recommend against reverting the
    workaround now, as this would lead to lots of probe deferrals in drivers
    relying on pinctrl. This may be reconsidered once the DT code starts
    taking into account phandle dependencies during device instantation.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 865d235612c5..979623895904 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -29,24 +29,25 @@
 static int sh_pfc_map_resources(struct sh_pfc *pfc,
 				struct platform_device *pdev)
 {
-	unsigned int num_windows = 0;
-	unsigned int num_irqs = 0;
+	unsigned int num_windows, num_irqs;
 	struct sh_pfc_window *windows;
 	unsigned int *irqs = NULL;
 	struct resource *res;
 	unsigned int i;
+	int irq;
 
 	/* Count the MEM and IRQ resources. */
-	for (i = 0; i < pdev->num_resources; ++i) {
-		switch (resource_type(&pdev->resource[i])) {
-		case IORESOURCE_MEM:
-			num_windows++;
+	for (num_windows = 0;; num_windows++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, num_windows);
+		if (!res)
 			break;
-
-		case IORESOURCE_IRQ:
-			num_irqs++;
+	}
+	for (num_irqs = 0;; num_irqs++) {
+		irq = platform_get_irq(pdev, num_irqs);
+		if (irq == -EPROBE_DEFER)
+			return irq;
+		if (irq < 0)
 			break;
-		}
 	}
 
 	if (num_windows == 0)
@@ -72,22 +73,17 @@ static int sh_pfc_map_resources(struct sh_pfc *pfc,
 	}
 
 	/* Fill them. */
-	for (i = 0, res = pdev->resource; i < pdev->num_resources; i++, res++) {
-		switch (resource_type(res)) {
-		case IORESOURCE_MEM:
-			windows->phys = res->start;
-			windows->size = resource_size(res);
-			windows->virt = devm_ioremap_resource(pfc->dev, res);
-			if (IS_ERR(windows->virt))
-				return -ENOMEM;
-			windows++;
-			break;
-
-		case IORESOURCE_IRQ:
-			*irqs++ = res->start;
-			break;
-		}
+	for (i = 0; i < num_windows; i++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		windows->phys = res->start;
+		windows->size = resource_size(res);
+		windows->virt = devm_ioremap_resource(pfc->dev, res);
+		if (IS_ERR(windows->virt))
+			return -ENOMEM;
+		windows++;
 	}
+	for (i = 0; i < num_irqs; i++)
+		*irqs++ = platform_get_irq(pdev, i);
 
 	return 0;
 }

commit 43c4436e2f1890a7b28dc0f0d901866cda99a08c
Author: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
Date:   Sat Jun 6 01:34:48 2015 +0300

    pinctrl: sh-pfc: add R8A7794 PFC support
    
    Add PFC support for  the  R8A7794 SoC  including pin groups for some
    on-chip devices such as ETH, I2C, INTC, MSIOF, QSPI, [H]SCIF...
    
    Sergei: squashed together several patches, fixed the MLB_CLK typo,
    added IRQ4.. IRQ9 pin groups, fixed IRQn comments, added ETH B pin
    group names, removed stray new line and fixed typos in the  comments
    in the pinmux_config_regs[] initializer, removed the platform device
    ID, took into account limited number of signals in the GPIO1/5/6
    controllers, added reasonable and removed unreasonable
    copyrights, modified the bindings document, renamed, added changelog.
    
    Changes in version 5:
    - resolved rejects, refreshed the patch;
    - added Laurent Pinchart's ACK.
    
    Changes in version 4:
    - reused the PORT_GP_26() macro to #define PORT_GP_28().
    
    Changes in version 3:
    - removed the platform device ID;
    - added PORT_GP_26() and PORT_GP_28() macros, used them for GPIO1/5/6 in the
      CPU_ALL_PORT() macro.
    
    Changes in version 2:
    - rebased the patch.
    
    Signed-off-by: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 96556362b28f..865d235612c5 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -487,6 +487,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7793_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7794
+	{
+		.compatible = "renesas,pfc-r8a7794",
+		.data = &r8a7794_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{
 		.compatible = "renesas,pfc-sh73a0",

commit 19e1e98fbf68d398bab944244f883ae14535b196
Author: Ulrich Hecht <ulrich.hecht+renesas@gmail.com>
Date:   Tue May 12 11:13:19 2015 +0200

    pinctrl: sh-pfc: Add r8a7793 support
    
    Regarding pin control, r8a7791 and r8a7793 are identical, so it is
    sufficient to add an sh_pfc_soc_info structure to enable r8a7793 support.
    
    Signed-off-by: Ulrich Hecht <ulrich.hecht+renesas@gmail.com>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 287a3d048a5e..96556362b28f 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -481,6 +481,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7791_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7793
+	{
+		.compatible = "renesas,pfc-r8a7793",
+		.data = &r8a7793_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{
 		.compatible = "renesas,pfc-sh73a0",

commit 592be8d3c1110ae12082399c39eef18ec15c0d1d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 28 12:15:07 2015 +0200

    pinctrl: sh-pfc: Remove r8a73a4 platform_device_id entry
    
    As of commit 9d07d414d4c33d86 ("ARM: shmobile: r8a73a4: ape6evm: Remove
    legacy platform"), r8a73a4 is only supported in generic DT-only ARM
    multi-platform builds.  The driver doesn't need to match platform
    devices by name anymore, hence remove the corresponding
    platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 7b2c9495c383..287a3d048a5e 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -579,9 +579,6 @@ static int sh_pfc_remove(struct platform_device *pdev)
 }
 
 static const struct platform_device_id sh_pfc_id_table[] = {
-#ifdef CONFIG_PINCTRL_PFC_R8A73A4
-	{ "pfc-r8a73a4", (kernel_ulong_t)&r8a73a4_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7740
 	{ "pfc-r8a7740", (kernel_ulong_t)&r8a7740_pinmux_info },
 #endif

commit 9895afae1b8b0fa8d7fecea47f61cdc55059eb43
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Mar 10 12:14:40 2015 +0100

    pinctrl: sh-pfc: Remove r8a7790 platform_device_id entry
    
    The r8a7790 platform is now DT-only, the driver doesn't need to match
    platform devices by name anymore. Remove the corresponding
    platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 6885ea5e39e7..7b2c9495c383 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -591,9 +591,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7779
 	{ "pfc-r8a7779", (kernel_ulong_t)&r8a7779_pinmux_info },
 #endif
-#ifdef CONFIG_PINCTRL_PFC_R8A7790
-	{ "pfc-r8a7790", (kernel_ulong_t)&r8a7790_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
 #endif

commit 889439cddc9118cdfb645e5c35fd4abc0d1ebbac
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Mar 10 12:14:39 2015 +0100

    pinctrl: sh-pfc: Remove emev2 platform_device_id entry
    
    The emev2 platform is now DT-only, the driver doesn't need to match
    platform devices by name anymore. Remove the corresponding
    platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 1b6dc6922915..6885ea5e39e7 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -579,9 +579,6 @@ static int sh_pfc_remove(struct platform_device *pdev)
 }
 
 static const struct platform_device_id sh_pfc_id_table[] = {
-#ifdef CONFIG_PINCTRL_PFC_EMEV2
-	{ "pfc-emev2", (kernel_ulong_t)&emev2_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A73A4
 	{ "pfc-r8a73a4", (kernel_ulong_t)&r8a73a4_pinmux_info },
 #endif

commit 1f34de05e75a26e8f4dfe7566fe80309aabf10b7
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Mar 12 11:09:16 2015 +0100

    pinctrl: sh-pfc: Use u32 to store register addresses
    
    Currently all PFC registers lie in low 32-bit address space. Hence use
    u32 instead of unsigned long to store PFC register addresses in pinctrl
    tables.  All calculations of virtual addresses use a phys_addr_t
    intermediate, so we know where to add an offset if the 32-bit assumption
    ever becomes false.
    
    While this doesn't impact 32-bit builds, it would save ca. 7 KiB on a
    64-bit shmobile_defconfig kernel.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index c33e2474a867..1b6dc6922915 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -92,10 +92,10 @@ static int sh_pfc_map_resources(struct sh_pfc *pfc,
 	return 0;
 }
 
-static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
-					 unsigned long address)
+static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc, u32 reg)
 {
 	struct sh_pfc_window *window;
+	phys_addr_t address = reg;
 	unsigned int i;
 
 	/* scan through physical windows and convert address */
@@ -208,7 +208,7 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
 
-	dev_dbg(pfc->dev, "write_reg addr = %lx, value = 0x%x, field = %u, "
+	dev_dbg(pfc->dev, "write_reg addr = %x, value = 0x%x, field = %u, "
 		"r_width = %u, f_width = %u\n",
 		crp->reg, value, field, crp->reg_width, crp->field_width);
 

commit cef28a289482175b26f7a5ae4a1337c792cea9c5
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Mar 12 11:09:14 2015 +0100

    pinctrl: sh-pfc: Use unsigned int for register/field widths and offsets
    
    As register and field widths and offsets are in the range 1..32, use
    unsigned int (mostly replacing unsigned long) to store them in local
    variables and for passing them around.
    
    Move to one variable per line, move variables to the beginning of the
    block where they are used, and drop superfluous initializations while we
    are at it.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 5591baf9738b..c33e2474a867 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -144,7 +144,7 @@ static int sh_pfc_enum_in_range(u16 enum_id, const struct pinmux_range *r)
 	return 1;
 }
 
-u32 sh_pfc_read_raw_reg(void __iomem *mapped_reg, unsigned long reg_width)
+u32 sh_pfc_read_raw_reg(void __iomem *mapped_reg, unsigned int reg_width)
 {
 	switch (reg_width) {
 	case 8:
@@ -159,7 +159,7 @@ u32 sh_pfc_read_raw_reg(void __iomem *mapped_reg, unsigned long reg_width)
 	return 0;
 }
 
-void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned long reg_width,
+void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned int reg_width,
 			  u32 data)
 {
 	switch (reg_width) {
@@ -179,9 +179,9 @@ void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned long reg_width,
 
 static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 				     const struct pinmux_cfg_reg *crp,
-				     unsigned long in_pos,
+				     unsigned int in_pos,
 				     void __iomem **mapped_regp, u32 *maskp,
-				     unsigned long *posp)
+				     unsigned int *posp)
 {
 	unsigned int k;
 
@@ -200,15 +200,15 @@ static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 
 static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 				    const struct pinmux_cfg_reg *crp,
-				    unsigned long field, u32 value)
+				    unsigned int field, u32 value)
 {
 	void __iomem *mapped_reg;
-	unsigned long pos;
+	unsigned int pos;
 	u32 mask, data;
 
 	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
 
-	dev_dbg(pfc->dev, "write_reg addr = %lx, value = 0x%x, field = %ld, "
+	dev_dbg(pfc->dev, "write_reg addr = %lx, value = 0x%x, field = %u, "
 		"r_width = %u, f_width = %u\n",
 		crp->reg, value, field, crp->reg_width, crp->field_width);
 
@@ -228,27 +228,28 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 }
 
 static int sh_pfc_get_config_reg(struct sh_pfc *pfc, u16 enum_id,
-				 const struct pinmux_cfg_reg **crp, int *fieldp,
-				 u32 *valuep)
+				 const struct pinmux_cfg_reg **crp,
+				 unsigned int *fieldp, u32 *valuep)
 {
-	const struct pinmux_cfg_reg *config_reg;
-	unsigned long r_width, f_width, curr_width;
-	unsigned int k, m, pos, bit_pos;
-	u32 ncomb, n;
+	unsigned int k = 0;
 
-	k = 0;
 	while (1) {
-		config_reg = pfc->info->cfg_regs + k;
-
-		r_width = config_reg->reg_width;
-		f_width = config_reg->field_width;
+		const struct pinmux_cfg_reg *config_reg =
+			pfc->info->cfg_regs + k;
+		unsigned int r_width = config_reg->reg_width;
+		unsigned int f_width = config_reg->field_width;
+		unsigned int curr_width;
+		unsigned int bit_pos;
+		unsigned int pos = 0;
+		unsigned int m = 0;
 
 		if (!r_width)
 			break;
 
-		pos = 0;
-		m = 0;
 		for (bit_pos = 0; bit_pos < r_width; bit_pos += curr_width) {
+			u32 ncomb;
+			u32 n;
+
 			if (f_width)
 				curr_width = f_width;
 			else
@@ -297,12 +298,8 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, u16 mark, int pos,
 
 int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 {
-	const struct pinmux_cfg_reg *cr = NULL;
-	u16 enum_id;
 	const struct pinmux_range *range;
-	int in_range, pos, field;
-	u32 value;
-	int ret;
+	int pos = 0;
 
 	switch (pinmux_type) {
 	case PINMUX_TYPE_GPIO:
@@ -322,13 +319,15 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 		return -EINVAL;
 	}
 
-	pos = 0;
-	enum_id = 0;
-	field = 0;
-	value = 0;
-
 	/* Iterate over all the configuration fields we need to update. */
 	while (1) {
+		const struct pinmux_cfg_reg *cr;
+		unsigned int field;
+		u16 enum_id;
+		u32 value;
+		int in_range;
+		int ret;
+
 		pos = sh_pfc_mark_to_enum(pfc, mark, pos, &enum_id);
 		if (pos < 0)
 			return pos;

commit dc70071550c2b8b1185d086b0f1954dfbc63aee2
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Mar 12 11:09:13 2015 +0100

    pinctrl: sh-pfc: Store register/field widths in u8 instead of unsigned long
    
    Register and field widths are in the range 1..32. Storing them in the
    pinctrl data in (arrays of) unsigned long wastes space.
    
    This decreases the size of a (32-bit) shmobile_defconfig kernel
    supporting 7 SoCs by 26460 bytes.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 895a41e2f30a..5591baf9738b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -209,7 +209,7 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
 
 	dev_dbg(pfc->dev, "write_reg addr = %lx, value = 0x%x, field = %ld, "
-		"r_width = %ld, f_width = %ld\n",
+		"r_width = %u, f_width = %u\n",
 		crp->reg, value, field, crp->reg_width, crp->field_width);
 
 	mask = ~(mask << pos);

commit fc88936ad307dc57cd26cb53455a57e2dd0813b9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Feb 27 18:38:04 2015 +0100

    pinctrl: sh-pfc: Use u32 to store register data
    
    As PFC registers are either 8, 16, or 32 bits wide, use u32 (mostly
    replacing unsigned long) to store (parts of) register values and masks.
    
    Switch the shadow register operations from {set,clear}_bit() to plain C
    bit operations, as the former can operate on long data only.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index e2c442b64a2c..895a41e2f30a 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -144,8 +144,7 @@ static int sh_pfc_enum_in_range(u16 enum_id, const struct pinmux_range *r)
 	return 1;
 }
 
-unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
-				  unsigned long reg_width)
+u32 sh_pfc_read_raw_reg(void __iomem *mapped_reg, unsigned long reg_width)
 {
 	switch (reg_width) {
 	case 8:
@@ -161,7 +160,7 @@ unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
 }
 
 void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned long reg_width,
-			  unsigned long data)
+			  u32 data)
 {
 	switch (reg_width) {
 	case 8:
@@ -181,8 +180,7 @@ void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned long reg_width,
 static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 				     const struct pinmux_cfg_reg *crp,
 				     unsigned long in_pos,
-				     void __iomem **mapped_regp,
-				     unsigned long *maskp,
+				     void __iomem **mapped_regp, u32 *maskp,
 				     unsigned long *posp)
 {
 	unsigned int k;
@@ -202,14 +200,15 @@ static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 
 static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 				    const struct pinmux_cfg_reg *crp,
-				    unsigned long field, unsigned long value)
+				    unsigned long field, u32 value)
 {
 	void __iomem *mapped_reg;
-	unsigned long mask, pos, data;
+	unsigned long pos;
+	u32 mask, data;
 
 	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
 
-	dev_dbg(pfc->dev, "write_reg addr = %lx, value = %ld, field = %ld, "
+	dev_dbg(pfc->dev, "write_reg addr = %lx, value = 0x%x, field = %ld, "
 		"r_width = %ld, f_width = %ld\n",
 		crp->reg, value, field, crp->reg_width, crp->field_width);
 
@@ -230,11 +229,12 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 static int sh_pfc_get_config_reg(struct sh_pfc *pfc, u16 enum_id,
 				 const struct pinmux_cfg_reg **crp, int *fieldp,
-				 int *valuep)
+				 u32 *valuep)
 {
 	const struct pinmux_cfg_reg *config_reg;
-	unsigned long r_width, f_width, curr_width, ncomb;
-	unsigned int k, m, n, pos, bit_pos;
+	unsigned long r_width, f_width, curr_width;
+	unsigned int k, m, pos, bit_pos;
+	u32 ncomb, n;
 
 	k = 0;
 	while (1) {
@@ -300,7 +300,8 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	const struct pinmux_cfg_reg *cr = NULL;
 	u16 enum_id;
 	const struct pinmux_range *range;
-	int in_range, pos, field, value;
+	int in_range, pos, field;
+	u32 value;
 	int ret;
 
 	switch (pinmux_type) {

commit eaef1279fa349db0cbec953e745d91db019a729e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Feb 15 18:01:41 2015 +0200

    pinctrl: sh-pfc: Remove r8a7791 platform_device_id entry
    
    The r8a7791 platform is now DT-only, the driver doesn't need to match
    platform devices by name anymore. Remove the corresponding
    platform_device_id entry.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a56280814a3f..e2c442b64a2c 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -597,9 +597,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7790
 	{ "pfc-r8a7790", (kernel_ulong_t)&r8a7790_pinmux_info },
 #endif
-#ifdef CONFIG_PINCTRL_PFC_R8A7791
-	{ "pfc-r8a7791", (kernel_ulong_t)&r8a7791_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
 #endif

commit 62476634d79f1185b8a252ef2ec8d5def86e3fc3
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Mon Jan 26 15:20:01 2015 +0900

    pinctrl: sh-pfc: sh7372: Remove PFC support
    
    Remove sh7372 PFC support as part of the sh7372 and Mackerel
    legacy code removal.
    
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b92057d72e3d..a56280814a3f 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -481,12 +481,6 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7791_pinmux_info,
 	},
 #endif
-#ifdef CONFIG_PINCTRL_PFC_SH7372
-	{
-		.compatible = "renesas,pfc-sh7372",
-		.data = &sh7372_pinmux_info,
-	},
-#endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{
 		.compatible = "renesas,pfc-sh73a0",
@@ -615,9 +609,6 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_SH7269
 	{ "pfc-sh7269", (kernel_ulong_t)&sh7269_pinmux_info },
 #endif
-#ifdef CONFIG_PINCTRL_PFC_SH7372
-	{ "pfc-sh7372", (kernel_ulong_t)&sh7372_pinmux_info },
-#endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{ "pfc-sh73a0", (kernel_ulong_t)&sh73a0_pinmux_info },
 #endif

commit 1e7d5d849cf4f0c51abb85d6b9a3181cebaf82c5
Author: Niklas Söderlund <niso@kth.se>
Date:   Sun Jan 25 14:49:52 2015 +0100

    sh-pfc: Add emev2 pinmux support
    
    Add PFC support for the EMMA Mobile EV2 SoC including pin groups for
    on-chip devices.
    
    Signed-off-by: Niklas SÃ¶derlund <niso@kth.se>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 66dc62d2156c..b92057d72e3d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -439,6 +439,12 @@ static int sh_pfc_init_ranges(struct sh_pfc *pfc)
 
 #ifdef CONFIG_OF
 static const struct of_device_id sh_pfc_of_table[] = {
+#ifdef CONFIG_PINCTRL_PFC_EMEV2
+	{
+		.compatible = "renesas,pfc-emev2",
+		.data = &emev2_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A73A4
 	{
 		.compatible = "renesas,pfc-r8a73a4",
@@ -579,6 +585,9 @@ static int sh_pfc_remove(struct platform_device *pdev)
 }
 
 static const struct platform_device_id sh_pfc_id_table[] = {
+#ifdef CONFIG_PINCTRL_PFC_EMEV2
+	{ "pfc-emev2", (kernel_ulong_t)&emev2_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A73A4
 	{ "pfc-r8a73a4", (kernel_ulong_t)&r8a73a4_pinmux_info },
 #endif

commit 569c65c08a7ed67019683950409a6c10243711f5
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:24 2014 +0200

    pinctrl: sh-pfc: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 6572c233f73d..66dc62d2156c 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -650,7 +650,6 @@ static struct platform_driver sh_pfc_driver = {
 	.id_table	= sh_pfc_id_table,
 	.driver		= {
 		.name	= DRV_NAME,
-		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(sh_pfc_of_table),
 	},
 };

commit 0a332c96c29c84cd9205c29dfa1add4667456059
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Sep 11 00:55:55 2014 +0300

    pinctrl: sh-pfc: sh73a0: Remove unnecessary SoC data allocation
    
    The SoC data structure allocated at init time only holds a regulator
    pointer that is only used in the init function. Replace it with a local
    variable and get rid of the SoC data structure allocation altogether.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b9b464d0578c..6572c233f73d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -542,7 +542,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	 */
 	ret = sh_pfc_register_pinctrl(pfc);
 	if (unlikely(ret != 0))
-		goto error;
+		return ret;
 
 #ifdef CONFIG_GPIO_SH_PFC
 	/*
@@ -564,11 +564,6 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	dev_info(pfc->dev, "%s support registered\n", info->name);
 
 	return 0;
-
-error:
-	if (info->ops && info->ops->exit)
-		info->ops->exit(pfc);
-	return ret;
 }
 
 static int sh_pfc_remove(struct platform_device *pdev)
@@ -580,9 +575,6 @@ static int sh_pfc_remove(struct platform_device *pdev)
 #endif
 	sh_pfc_unregister_pinctrl(pfc);
 
-	if (pfc->info->ops && pfc->info->ops->exit)
-		pfc->info->ops->exit(pfc);
-
 	return 0;
 }
 

commit 70c8f01a357ac74d223a632659787396fef1e649
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Dec 11 04:26:26 2013 +0100

    sh-pfc: Support GPIO to IRQ mapping specified IRQ resources
    
    On non-DT platforms IRQ controllers associated with the GPIOs have a
    fixed IRQ base value known at compile time. The sh-pfc driver translates
    GPIO number to IRQ numbers using a hardcoded table. This mechanism
    breaks on DT platforms, as the IRQ base values are dynamic in that case.
    
    Fix this by specifying IRQs associated with GPIOs in IRQ resources,
    populated automatically from the device tree. When IRQ resources are
    specified the driver requires one IRQ resource per GPIO able to generate
    an interrupt, and uses the translation table to compute the IRQ resource
    offset instead of the IRQ number.
    
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 7831f078a5ef..b9b464d0578c 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -26,30 +26,67 @@
 
 #include "core.h"
 
-static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
+static int sh_pfc_map_resources(struct sh_pfc *pfc,
+				struct platform_device *pdev)
 {
+	unsigned int num_windows = 0;
+	unsigned int num_irqs = 0;
+	struct sh_pfc_window *windows;
+	unsigned int *irqs = NULL;
 	struct resource *res;
-	unsigned int k;
+	unsigned int i;
+
+	/* Count the MEM and IRQ resources. */
+	for (i = 0; i < pdev->num_resources; ++i) {
+		switch (resource_type(&pdev->resource[i])) {
+		case IORESOURCE_MEM:
+			num_windows++;
+			break;
+
+		case IORESOURCE_IRQ:
+			num_irqs++;
+			break;
+		}
+	}
 
-	if (pdev->num_resources == 0)
+	if (num_windows == 0)
 		return -EINVAL;
 
-	pfc->windows = devm_kzalloc(pfc->dev, pdev->num_resources *
-				    sizeof(*pfc->windows), GFP_NOWAIT);
-	if (!pfc->windows)
+	/* Allocate memory windows and IRQs arrays. */
+	windows = devm_kzalloc(pfc->dev, num_windows * sizeof(*windows),
+			       GFP_KERNEL);
+	if (windows == NULL)
 		return -ENOMEM;
 
-	pfc->num_windows = pdev->num_resources;
+	pfc->num_windows = num_windows;
+	pfc->windows = windows;
 
-	for (k = 0, res = pdev->resource; k < pdev->num_resources; k++, res++) {
-		WARN_ON(resource_type(res) != IORESOURCE_MEM);
-		pfc->windows[k].phys = res->start;
-		pfc->windows[k].size = resource_size(res);
-		pfc->windows[k].virt =
-			devm_ioremap_nocache(pfc->dev, res->start,
-					     resource_size(res));
-		if (!pfc->windows[k].virt)
+	if (num_irqs) {
+		irqs = devm_kzalloc(pfc->dev, num_irqs * sizeof(*irqs),
+				    GFP_KERNEL);
+		if (irqs == NULL)
 			return -ENOMEM;
+
+		pfc->num_irqs = num_irqs;
+		pfc->irqs = irqs;
+	}
+
+	/* Fill them. */
+	for (i = 0, res = pdev->resource; i < pdev->num_resources; i++, res++) {
+		switch (resource_type(res)) {
+		case IORESOURCE_MEM:
+			windows->phys = res->start;
+			windows->size = resource_size(res);
+			windows->virt = devm_ioremap_resource(pfc->dev, res);
+			if (IS_ERR(windows->virt))
+				return -ENOMEM;
+			windows++;
+			break;
+
+		case IORESOURCE_IRQ:
+			*irqs++ = res->start;
+			break;
+		}
 	}
 
 	return 0;
@@ -482,7 +519,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	pfc->info = info;
 	pfc->dev = &pdev->dev;
 
-	ret = sh_pfc_ioremap(pfc, pdev);
+	ret = sh_pfc_map_resources(pfc, pdev);
 	if (unlikely(ret < 0))
 		return ret;
 

commit 5b46ac3a7723636082ec6234289517ca5b9c65af
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Dec 11 04:26:25 2013 +0100

    sh-pfc: Rename sh_pfc window field to windows
    
    There's more than one window, name the field windows.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 06e648bf3a1b..7831f078a5ef 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -34,20 +34,21 @@ static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
 	if (pdev->num_resources == 0)
 		return -EINVAL;
 
-	pfc->window = devm_kzalloc(pfc->dev, pdev->num_resources *
-				   sizeof(*pfc->window), GFP_NOWAIT);
-	if (!pfc->window)
+	pfc->windows = devm_kzalloc(pfc->dev, pdev->num_resources *
+				    sizeof(*pfc->windows), GFP_NOWAIT);
+	if (!pfc->windows)
 		return -ENOMEM;
 
 	pfc->num_windows = pdev->num_resources;
 
 	for (k = 0, res = pdev->resource; k < pdev->num_resources; k++, res++) {
 		WARN_ON(resource_type(res) != IORESOURCE_MEM);
-		pfc->window[k].phys = res->start;
-		pfc->window[k].size = resource_size(res);
-		pfc->window[k].virt = devm_ioremap_nocache(pfc->dev, res->start,
-							   resource_size(res));
-		if (!pfc->window[k].virt)
+		pfc->windows[k].phys = res->start;
+		pfc->windows[k].size = resource_size(res);
+		pfc->windows[k].virt =
+			devm_ioremap_nocache(pfc->dev, res->start,
+					     resource_size(res));
+		if (!pfc->windows[k].virt)
 			return -ENOMEM;
 	}
 
@@ -62,7 +63,7 @@ static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
 
 	/* scan through physical windows and convert address */
 	for (i = 0; i < pfc->num_windows; i++) {
-		window = pfc->window + i;
+		window = pfc->windows + i;
 
 		if (address < window->phys)
 			continue;

commit 8d72a7fc8dd74d41ec5f37b70797679e910007e0
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Dec 11 04:26:21 2013 +0100

    sh-pfc: Turn unsigned indices into unsigned int
    
    Some indices take positive values only, make them unsigned.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index d77ece5217f0..06e648bf3a1b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -29,7 +29,7 @@
 static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
 {
 	struct resource *res;
-	int k;
+	unsigned int k;
 
 	if (pdev->num_resources == 0)
 		return -EINVAL;
@@ -147,7 +147,7 @@ static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 				     unsigned long *maskp,
 				     unsigned long *posp)
 {
-	int k;
+	unsigned int k;
 
 	*mapped_regp = sh_pfc_phys_to_virt(pfc, crp->reg);
 
@@ -196,7 +196,7 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, u16 enum_id,
 {
 	const struct pinmux_cfg_reg *config_reg;
 	unsigned long r_width, f_width, curr_width, ncomb;
-	int k, m, n, pos, bit_pos;
+	unsigned int k, m, n, pos, bit_pos;
 
 	k = 0;
 	while (1) {
@@ -238,7 +238,7 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, u16 mark, int pos,
 			      u16 *enum_idp)
 {
 	const u16 *data = pfc->info->gpio_data;
-	int k;
+	unsigned int k;
 
 	if (pos) {
 		*enum_idp = data[pos + 1];

commit 5088451962389924b9f05e22e6956f5c1a515d1a
Author: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
Date:   Thu Oct 17 06:46:05 2013 +0900

    pinctrl: sh-pfc: r8a7791 PFC support
    
    Add PFC support for the r8a7791 SoC V2 including pin groups for
    on-chip devices such as MSIOF, SCIF, USB, MMC, SDHI, DU.
    
    Signed-off-by: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
    Signed-off-by: Kunihito Higashiyama <kunihito.higashiyama.ur@renesas.com>
    Signed-off-by: Yoshikazu Fujikawa <yoshikazu.fujikawa.ue@renesas.com>
    Signed-off-by: Nobuyuki HIRAI <nobuyuki.hirai.xe@renesas.com>
    Signed-off-by: Shinobu Uehara <shinobu.uehara.xc@renesas.com>
    Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
    Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
    [damm@opensource.se: Forward ported to upstream, minor fixes]
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 738f14f65cff..d77ece5217f0 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -431,6 +431,12 @@ static const struct of_device_id sh_pfc_of_table[] = {
 		.data = &r8a7790_pinmux_info,
 	},
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7791
+	{
+		.compatible = "renesas,pfc-r8a7791",
+		.data = &r8a7791_pinmux_info,
+	},
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7372
 	{
 		.compatible = "renesas,pfc-sh7372",
@@ -558,6 +564,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7790
 	{ "pfc-r8a7790", (kernel_ulong_t)&r8a7790_pinmux_info },
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7791
+	{ "pfc-r8a7791", (kernel_ulong_t)&r8a7791_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
 #endif

commit db8ed174295f33e7c3441557a0caf296399ddea5
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Aug 22 11:00:55 2013 +0900

    pinctrl: sh-pfc: remove unnecessary platform_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure. Thus, it is not needed to manually clear the
    device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 9e66614bbbb3..738f14f65cff 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -539,8 +539,6 @@ static int sh_pfc_remove(struct platform_device *pdev)
 	if (pfc->info->ops && pfc->info->ops->exit)
 		pfc->info->ops->exit(pfc);
 
-	platform_set_drvdata(pdev, NULL);
-
 	return 0;
 }
 

commit 4f82e3ee724f1712f9e84b8802e24ea096a6089f
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 21:10:54 2013 +0200

    sh-pfc: Support pins not associated with a GPIO port
    
    Pins with selectable functions but without a GPIO port can't be named
    PORT_# or GP_#_#. Add a SH_PFC_PIN_NAMED macro to declare such pins in
    the pinmux pins array, naming them with the PIN_ prefix followed by the
    pin physical position.
    
    In order to make sure not to register those pins as GPIOs, add a
    SH_PFC_PIN_CFG_NO_GPIO pin flag to denote pins without a GPIO port.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index cb47bcee0aab..9e66614bbbb3 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -362,7 +362,10 @@ static int sh_pfc_init_ranges(struct sh_pfc *pfc)
 		return 0;
 	}
 
-	/* Count, allocate and fill the ranges. */
+	/* Count, allocate and fill the ranges. The PFC SoC data pins array must
+	 * be sorted by pin numbers, and pins without a GPIO port must come
+	 * last.
+	 */
 	for (i = 1, nr_ranges = 1; i < pfc->info->nr_pins; ++i) {
 		if (pfc->info->pins[i-1].pin != pfc->info->pins[i].pin - 1)
 			nr_ranges++;
@@ -378,15 +381,20 @@ static int sh_pfc_init_ranges(struct sh_pfc *pfc)
 	range->start = pfc->info->pins[0].pin;
 
 	for (i = 1; i < pfc->info->nr_pins; ++i) {
-		if (pfc->info->pins[i-1].pin != pfc->info->pins[i].pin - 1) {
-			range->end = pfc->info->pins[i-1].pin;
-			range++;
-			range->start = pfc->info->pins[i].pin;
-		}
+		if (pfc->info->pins[i-1].pin == pfc->info->pins[i].pin - 1)
+			continue;
+
+		range->end = pfc->info->pins[i-1].pin;
+		if (!(pfc->info->pins[i-1].configs & SH_PFC_PIN_CFG_NO_GPIO))
+			pfc->nr_gpio_pins = range->end + 1;
+
+		range++;
+		range->start = pfc->info->pins[i].pin;
 	}
 
 	range->end = pfc->info->pins[i-1].pin;
-	pfc->nr_gpio_pins = range->end + 1;
+	if (!(pfc->info->pins[i-1].configs & SH_PFC_PIN_CFG_NO_GPIO))
+		pfc->nr_gpio_pins = range->end + 1;
 
 	return 0;
 }

commit acac8ed5e2aa2c0d364d06f364fd9ed0dc27d28a
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 18:38:30 2013 +0200

    sh-pfc: Compute pin ranges automatically
    
    Remove the manually specified ranges from PFC SoC data and compute the
    ranges automatically. This prevents ranges from being out-of-sync with
    pins definitions.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 96b02246796a..cb47bcee0aab 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -82,17 +82,14 @@ int sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin)
 	unsigned int offset;
 	unsigned int i;
 
-	if (pfc->info->ranges == NULL)
-		return pin;
-
-	for (i = 0, offset = 0; i < pfc->info->nr_ranges; ++i) {
-		const struct pinmux_range *range = &pfc->info->ranges[i];
+	for (i = 0, offset = 0; i < pfc->nr_ranges; ++i) {
+		const struct sh_pfc_pin_range *range = &pfc->ranges[i];
 
 		if (pin <= range->end)
-			return pin >= range->begin
-			     ? offset + pin - range->begin : -1;
+			return pin >= range->start
+			     ? offset + pin - range->start : -1;
 
-		offset += range->end - range->begin + 1;
+		offset += range->end - range->start + 1;
 	}
 
 	return -EINVAL;
@@ -341,6 +338,59 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	return 0;
 }
 
+static int sh_pfc_init_ranges(struct sh_pfc *pfc)
+{
+	struct sh_pfc_pin_range *range;
+	unsigned int nr_ranges;
+	unsigned int i;
+
+	if (pfc->info->pins[0].pin == (u16)-1) {
+		/* Pin number -1 denotes that the SoC doesn't report pin numbers
+		 * in its pin arrays yet. Consider the pin numbers range as
+		 * continuous and allocate a single range.
+		 */
+		pfc->nr_ranges = 1;
+		pfc->ranges = devm_kzalloc(pfc->dev, sizeof(*pfc->ranges),
+					   GFP_KERNEL);
+		if (pfc->ranges == NULL)
+			return -ENOMEM;
+
+		pfc->ranges->start = 0;
+		pfc->ranges->end = pfc->info->nr_pins - 1;
+		pfc->nr_gpio_pins = pfc->info->nr_pins;
+
+		return 0;
+	}
+
+	/* Count, allocate and fill the ranges. */
+	for (i = 1, nr_ranges = 1; i < pfc->info->nr_pins; ++i) {
+		if (pfc->info->pins[i-1].pin != pfc->info->pins[i].pin - 1)
+			nr_ranges++;
+	}
+
+	pfc->nr_ranges = nr_ranges;
+	pfc->ranges = devm_kzalloc(pfc->dev, sizeof(*pfc->ranges) * nr_ranges,
+				   GFP_KERNEL);
+	if (pfc->ranges == NULL)
+		return -ENOMEM;
+
+	range = pfc->ranges;
+	range->start = pfc->info->pins[0].pin;
+
+	for (i = 1; i < pfc->info->nr_pins; ++i) {
+		if (pfc->info->pins[i-1].pin != pfc->info->pins[i].pin - 1) {
+			range->end = pfc->info->pins[i-1].pin;
+			range++;
+			range->start = pfc->info->pins[i].pin;
+		}
+	}
+
+	range->end = pfc->info->pins[i-1].pin;
+	pfc->nr_gpio_pins = range->end + 1;
+
+	return 0;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id sh_pfc_of_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A73A4
@@ -431,6 +481,10 @@ static int sh_pfc_probe(struct platform_device *pdev)
 
 	pinctrl_provide_dummies();
 
+	ret = sh_pfc_init_ranges(pfc);
+	if (ret < 0)
+		return ret;
+
 	/*
 	 * Initialize pinctrl bindings first
 	 */

commit 533743dccb517b0331eccc111e3c2b8f021559b5
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jul 15 13:03:20 2013 +0200

    sh-pfc: Replace pinmux_enum_id typedef with u16
    
    The typedef only conceals the real variable type without bringing any
    additional value (see Documentation/CodingStyle, section 5.b). Moreover,
    it polutes the pinmux namespace. Replace it with the integer type it
    used to hide.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 1c8597cf57be..96b02246796a 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -98,8 +98,7 @@ int sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin)
 	return -EINVAL;
 }
 
-static int sh_pfc_enum_in_range(pinmux_enum_t enum_id,
-				const struct pinmux_range *r)
+static int sh_pfc_enum_in_range(u16 enum_id, const struct pinmux_range *r)
 {
 	if (enum_id < r->begin)
 		return 0;
@@ -194,7 +193,7 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 	sh_pfc_write_raw_reg(mapped_reg, crp->reg_width, data);
 }
 
-static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
+static int sh_pfc_get_config_reg(struct sh_pfc *pfc, u16 enum_id,
 				 const struct pinmux_cfg_reg **crp, int *fieldp,
 				 int *valuep)
 {
@@ -238,10 +237,10 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 	return -EINVAL;
 }
 
-static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
-			      pinmux_enum_t *enum_idp)
+static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, u16 mark, int pos,
+			      u16 *enum_idp)
 {
-	const pinmux_enum_t *data = pfc->info->gpio_data;
+	const u16 *data = pfc->info->gpio_data;
 	int k;
 
 	if (pos) {
@@ -264,7 +263,7 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
 int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 {
 	const struct pinmux_cfg_reg *cr = NULL;
-	pinmux_enum_t enum_id;
+	u16 enum_id;
 	const struct pinmux_range *range;
 	int in_range, pos, field, value;
 	int ret;

commit 75906431564c85738189a000e6e81c29123c61da
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Jul 16 02:01:00 2013 +0200

    sh-pfc: Remove unused input_pd and input_pu ranges
    
    The ranges are not used anymore, remove them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index f3fc66b24370..1c8597cf57be 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -283,14 +283,6 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 		range = &pfc->info->input;
 		break;
 
-	case PINMUX_TYPE_INPUT_PULLUP:
-		range = &pfc->info->input_pu;
-		break;
-
-	case PINMUX_TYPE_INPUT_PULLDOWN:
-		range = &pfc->info->input_pd;
-		break;
-
 	default:
 		return -EINVAL;
 	}

commit 3dbde57ad941c55345fd7fac0ee3f70f204b02d8
Merge: a6e6d863cf68 2207a4e1ca6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 11:48:03 2013 -0700

    Merge tag 'pinctrl-for-v3.11-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control changes from Linus Walleij:
    
     - A large slew of improvements of the Genric pin configuration support,
       and deployment in four different platforms: Rockchip, Super-H PFC,
       ABx500 and TZ1090.  Support BIAS_BUS_HOLD, get device tree parsing
       and debugfs support into shape.
    
     - We also have device tree support with generic naming conventions for
       the generic pin configuration.
    
     - Delete the unused and confusing direct pinconf API.  Now state
       transitions is *the* way to control pins and multiplexing.
    
     - New drivers for Rockchip, TZ1090, and TZ1090 PDC.
    
     - Two pin control states related to power management are now handled in
       the device core: "sleep" and "idle", removing a lot of boilerplate
       code in drivers.  We do not yet know if this is the final word for
       pin PM, but it already make things a lot easier to handle.
    
     - Handle sparse GPIO ranges passing a list of disparate pins, and
       utilize these in the new BayTrail (x86 Atom SoC) driver.
    
     - Make the sunxi (AllWinner) driver handle external interrupts.
    
     - Make it possible for pinctrl-single to handle the case where several
       pins are managed by a single register, and augment it to handle sleep
       modes.
    
     - Cleanups and improvements for the abx500 drivers.
    
     - Move Sirf pin control drivers to their own directory, support
       save/restore of context and add support for the SiRFatlas6 SoC.
    
     - PMU muxing for the Dove pinctrl driver.
    
     - Finalization and support for VF610 in the i.MX6 pinctrl driver.
    
     - Smoothen out various Exynos rough edges.
    
     - Generic cleanups of various kinds.
    
    * tag 'pinctrl-for-v3.11-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (82 commits)
      pinctrl: vt8500: wmt: remove redundant dev_err call in wmt_pinctrl_probe()
      pinctrl: remove bindings for pinconf options needing more thought
      pinctrl: remove slew-rate parameter from tz1090
      pinctrl: set unit for debounce time pinconfig to usec
      pinctrl: more clarifications for generic pull configs
      pinctrl: rip out the direct pinconf API
      pinctrl-tz1090-pdc: add TZ1090 PDC pinctrl driver
      pinctrl-tz1090: add TZ1090 pinctrl driver
      pinctrl: samsung: Staticize drvdata_list
      pinctrl: rockchip: Add missing irq_gc_unlock() call before return error
      pinctrl: abx500: rework error path
      pinctrl: abx500: suppress hardcoded value
      pinctrl: abx500: factorize code
      pinctrl: abx500: fix abx500_gpio_get()
      pinctrl: abx500: fix abx500_pin_config_set()
      pinctrl: abx500: Add device tree support
      sh-pfc: Guard DT parsing with #ifdef CONFIG_OF
      pinctrl: add Intel BayTrail GPIO/pinctrl support
      pinctrl: fix pinconf_ops::pin_config_dbg_parse_modify kerneldoc
      pinctrl: Staticize local symbols
      ...
    
    Conflicts:
            drivers/net/ethernet/ti/davinci_mdio.c
            drivers/pinctrl/Makefile

commit fe1c9a822ce72c6ec8476a2501c412265ee2172c
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jun 17 20:50:02 2013 +0200

    sh-pfc: Add DT support
    
    Support device instantiation through the device tree. The compatible
    property is used to select the SoC pinmux information.
    
    Set the gpio_chip device field to the PFC device to enable automatic
    GPIO OF support.
    
    Cc: devicetree-discuss@lists.ozlabs.org
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 13f40c59ebfb..4eea849a1ad8 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -18,6 +18,8 @@
 #include <linux/ioport.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/pinctrl/machine.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
@@ -348,13 +350,72 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static const struct of_device_id sh_pfc_of_table[] = {
+#ifdef CONFIG_PINCTRL_PFC_R8A73A4
+	{
+		.compatible = "renesas,pfc-r8a73a4",
+		.data = &r8a73a4_pinmux_info,
+	},
+#endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7740
+	{
+		.compatible = "renesas,pfc-r8a7740",
+		.data = &r8a7740_pinmux_info,
+	},
+#endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7778
+	{
+		.compatible = "renesas,pfc-r8a7778",
+		.data = &r8a7778_pinmux_info,
+	},
+#endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7779
+	{
+		.compatible = "renesas,pfc-r8a7779",
+		.data = &r8a7779_pinmux_info,
+	},
+#endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7790
+	{
+		.compatible = "renesas,pfc-r8a7790",
+		.data = &r8a7790_pinmux_info,
+	},
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7372
+	{
+		.compatible = "renesas,pfc-sh7372",
+		.data = &sh7372_pinmux_info,
+	},
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH73A0
+	{
+		.compatible = "renesas,pfc-sh73a0",
+		.data = &sh73a0_pinmux_info,
+	},
+#endif
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sh_pfc_of_table);
+#endif
+
 static int sh_pfc_probe(struct platform_device *pdev)
 {
+	const struct platform_device_id *platid = platform_get_device_id(pdev);
+#ifdef CONFIG_OF
+	struct device_node *np = pdev->dev.of_node;
+#endif
 	const struct sh_pfc_soc_info *info;
 	struct sh_pfc *pfc;
 	int ret;
 
-	info = (void *)pdev->id_entry->driver_data;
+#ifdef CONFIG_OF
+	if (np)
+		info = of_match_device(sh_pfc_of_table, &pdev->dev)->data;
+	else
+#endif
+		info = platid ? (const void *)platid->driver_data : NULL;
+
 	if (info == NULL)
 		return -ENODEV;
 
@@ -480,6 +541,7 @@ static struct platform_driver sh_pfc_driver = {
 	.driver		= {
 		.name	= DRV_NAME,
 		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(sh_pfc_of_table),
 	},
 };
 

commit 3a7f520e63727e14de9567515d8727c2c01fedb4
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Jun 17 20:50:01 2013 +0200

    sh-pfc: Remove support for platform data
    
    Platform data isn't used, support can thus be removed.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b551336924a5..13f40c59ebfb 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -354,8 +354,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	struct sh_pfc *pfc;
 	int ret;
 
-	info = pdev->id_entry->driver_data
-	      ? (void *)pdev->id_entry->driver_data : pdev->dev.platform_data;
+	info = (void *)pdev->id_entry->driver_data;
 	if (info == NULL)
 		return -ENODEV;
 

commit 0c151062f32c9db819c2ca3081d6f98194d61e78
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Apr 21 20:21:57 2013 +0200

    sh-pfc: Add support for SoC-specific initialization
    
    Add two optional init and exit SoC operations and call them from the
    core at probe and remove time.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 4540ce384ee5..3b2fd43ff294 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -372,6 +372,12 @@ static int sh_pfc_probe(struct platform_device *pdev)
 
 	spin_lock_init(&pfc->lock);
 
+	if (info->ops && info->ops->init) {
+		ret = info->ops->init(pfc);
+		if (ret < 0)
+			return ret;
+	}
+
 	pinctrl_provide_dummies();
 
 	/*
@@ -379,7 +385,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	 */
 	ret = sh_pfc_register_pinctrl(pfc);
 	if (unlikely(ret != 0))
-		return ret;
+		goto error;
 
 #ifdef CONFIG_GPIO_SH_PFC
 	/*
@@ -401,6 +407,11 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	dev_info(pfc->dev, "%s support registered\n", info->name);
 
 	return 0;
+
+error:
+	if (info->ops && info->ops->exit)
+		info->ops->exit(pfc);
+	return ret;
 }
 
 static int sh_pfc_remove(struct platform_device *pdev)
@@ -412,6 +423,9 @@ static int sh_pfc_remove(struct platform_device *pdev)
 #endif
 	sh_pfc_unregister_pinctrl(pfc);
 
+	if (pfc->info->ops && pfc->info->ops->exit)
+		pfc->info->ops->exit(pfc);
+
 	platform_set_drvdata(pdev, NULL);
 
 	return 0;

commit 87f8c988636db0d477bb63fddfaefb5be9b1c386
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 12 05:37:20 2013 +0000

    sh-pfc: Add r8a7778 pinmux support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index db0d6f7adc9f..4540ce384ee5 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -424,6 +424,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7740
 	{ "pfc-r8a7740", (kernel_ulong_t)&r8a7740_pinmux_info },
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7778
+	{ "pfc-r8a7778", (kernel_ulong_t)&r8a7778_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7779
 	{ "pfc-r8a7779", (kernel_ulong_t)&r8a7779_pinmux_info },
 #endif

commit 58c229e18b7754dfe505f3bc1688feb28c84f42a
Author: Koji Matsuoka <koji.matsuoka.xm@rms.renesas.com>
Date:   Mon Apr 8 11:08:53 2013 +0900

    sh-pfc: Initial r8a7790 PFC support
    
    Add initial PFC support for the r8a7790 SoC.
    
    At this point only GPIO interface is supported, move to
    newer interfaces planned as incremental changes.
    
    Original authors is Koji Matsuoka-san, thanks for him
    and his team for the heavy lifting. Adjusted by Magnus
    to work together with updated code in drivers/pinctrl.
    
    Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@rms.renesas.com>
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index b551336924a5..db0d6f7adc9f 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -427,6 +427,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7779
 	{ "pfc-r8a7779", (kernel_ulong_t)&r8a7779_pinmux_info },
 #endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7790
+	{ "pfc-r8a7790", (kernel_ulong_t)&r8a7790_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
 #endif

commit c98f6c21afaf4692886cea0f5b63ead9945d85cc
Author: Magnus Damm <damm@opensource.se>
Date:   Tue Mar 26 22:49:49 2013 +0900

    sh-pfc: Add r8a73a4 pinmux support
    
    Add initial PFC support for the r8a73a4 SoC.
    
    At this point only GPIO interface is supported, move to newer interfaces
    planned as incremental changes.
    
    Original authors are Morimoto-san with help from Yoshii-san, thanks to
    them for the heavy lifting. Adjusted by Magnus to work together with
    updated code in drivers/pinctrl.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Takashi Yoshii <takashi.yoshii.zj@renesas.com>
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index ced9a95aa1fc..b551336924a5 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -418,6 +418,9 @@ static int sh_pfc_remove(struct platform_device *pdev)
 }
 
 static const struct platform_device_id sh_pfc_id_table[] = {
+#ifdef CONFIG_PINCTRL_PFC_R8A73A4
+	{ "pfc-r8a73a4", (kernel_ulong_t)&r8a73a4_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7740
 	{ "pfc-r8a7740", (kernel_ulong_t)&r8a7740_pinmux_info },
 #endif

commit e3c470510babd8ed385f1e09ec616787022b77b1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 17:30:25 2013 +0100

    sh-pfc: Configure pins as GPIOs at request time when handled externally
    
    When a GPIO is handled by a separate driver the pinmux
    gpio_set_direction() handler won't be called. The pin mux type then need
    to be configured to GPIO at request time.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 97e6ea3147e0..ced9a95aa1fc 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -268,7 +268,7 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	int ret;
 
 	switch (pinmux_type) {
-
+	case PINMUX_TYPE_GPIO:
 	case PINMUX_TYPE_FUNCTION:
 		range = NULL;
 		break;
@@ -297,6 +297,8 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	enum_id = 0;
 	field = 0;
 	value = 0;
+
+	/* Iterate over all the configuration fields we need to update. */
 	while (1) {
 		pos = sh_pfc_mark_to_enum(pfc, mark, pos, &enum_id);
 		if (pos < 0)
@@ -305,18 +307,20 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 		if (!enum_id)
 			break;
 
-		/* first check if this is a function enum */
+		/* Check if the configuration field selects a function. If it
+		 * doesn't, skip the field if it's not applicable to the
+		 * requested pinmux type.
+		 */
 		in_range = sh_pfc_enum_in_range(enum_id, &pfc->info->function);
 		if (!in_range) {
-			/* not a function enum */
-			if (range) {
-				/*
-				 * other range exists, so this pin is
-				 * a regular GPIO pin that now is being
-				 * bound to a specific direction.
-				 *
-				 * for this case we only allow function enums
-				 * and the enums that match the other range.
+			if (pinmux_type == PINMUX_TYPE_FUNCTION) {
+				/* Functions are allowed to modify all
+				 * fields.
+				 */
+				in_range = 1;
+			} else if (pinmux_type != PINMUX_TYPE_GPIO) {
+				/* Input/output types can only modify fields
+				 * that correspond to their respective ranges.
 				 */
 				in_range = sh_pfc_enum_in_range(enum_id, range);
 
@@ -327,17 +331,8 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 				 */
 				if (in_range && enum_id == range->force)
 					continue;
-			} else {
-				/*
-				 * no other range exists, so this pin
-				 * must then be of the function type.
-				 *
-				 * allow function type pins to select
-				 * any combination of function/in/out
-				 * in their MARK lists.
-				 */
-				in_range = 1;
 			}
+			/* GPIOs are only allowed to modify function fields. */
 		}
 
 		if (!in_range)

commit 1960d58003b735555bb2dc56699530d606698574
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Mar 26 01:44:52 2013 +0100

    sh-pfc: Fix compiler warning when BUG()
    
    The sh_pfc_phys_to_virt() function ends with a BUG() statement without a
    return. When CONFIG_BUG isn't set the function will thus have no return
    value. Fix it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index feef89792568..97e6ea3147e0 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -72,6 +72,7 @@ static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
 	}
 
 	BUG();
+	return NULL;
 }
 
 int sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin)

commit 9a643c9a11259955ec6961f9a2509604c6df1cd9
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 18:00:02 2013 +0100

    sh-pfc: Convert message printing from pr_* to dev_*
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a04c497deccd..feef89792568 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -10,7 +10,6 @@
  */
 
 #define DRV_NAME "sh-pfc"
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/bitops.h>
 #include <linux/err.h>
@@ -173,9 +172,9 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
 
-	pr_debug("write_reg addr = %lx, value = %ld, field = %ld, "
-		 "r_width = %ld, f_width = %ld\n",
-		 crp->reg, value, field, crp->reg_width, crp->field_width);
+	dev_dbg(pfc->dev, "write_reg addr = %lx, value = %ld, field = %ld, "
+		"r_width = %ld, f_width = %ld\n",
+		crp->reg, value, field, crp->reg_width, crp->field_width);
 
 	mask = ~(mask << pos);
 	value = value << pos;
@@ -254,7 +253,8 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
 		}
 	}
 
-	pr_err("cannot locate data/mark enum_id for mark %d\n", mark);
+	dev_err(pfc->dev, "cannot locate data/mark enum_id for mark %d\n",
+		mark);
 	return -EINVAL;
 }
 
@@ -396,13 +396,13 @@ static int sh_pfc_probe(struct platform_device *pdev)
 		 * PFC state as it is, given that there are already
 		 * extant users of it that have succeeded by this point.
 		 */
-		pr_notice("failed to init GPIO chip, ignoring...\n");
+		dev_notice(pfc->dev, "failed to init GPIO chip, ignoring...\n");
 	}
 #endif
 
 	platform_set_drvdata(pdev, pfc);
 
-	pr_info("%s support registered\n", info->name);
+	dev_info(pfc->dev, "%s support registered\n", info->name);
 
 	return 0;
 }

commit b705c054255ae3264aa02d46347e9cfbcf26523a
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 16:38:23 2013 +0100

    sh-pfc: Use proper error codes
    
    Return proper error codes instead of -1, and propagate the error codes.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 3a949465e88e..a04c497deccd 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -93,7 +93,7 @@ int sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin)
 		offset += range->end - range->begin + 1;
 	}
 
-	return -1;
+	return -EINVAL;
 }
 
 static int sh_pfc_enum_in_range(pinmux_enum_t enum_id,
@@ -233,7 +233,7 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 		k++;
 	}
 
-	return -1;
+	return -EINVAL;
 }
 
 static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
@@ -255,7 +255,7 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
 	}
 
 	pr_err("cannot locate data/mark enum_id for mark %d\n", mark);
-	return -1;
+	return -EINVAL;
 }
 
 int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
@@ -264,6 +264,7 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	pinmux_enum_t enum_id;
 	const struct pinmux_range *range;
 	int in_range, pos, field, value;
+	int ret;
 
 	switch (pinmux_type) {
 
@@ -288,7 +289,7 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 		break;
 
 	default:
-		return -1;
+		return -EINVAL;
 	}
 
 	pos = 0;
@@ -297,8 +298,8 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 	value = 0;
 	while (1) {
 		pos = sh_pfc_mark_to_enum(pfc, mark, pos, &enum_id);
-		if (pos <= 0)
-			return -1;
+		if (pos < 0)
+			return pos;
 
 		if (!enum_id)
 			break;
@@ -341,9 +342,9 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 		if (!in_range)
 			continue;
 
-		if (sh_pfc_get_config_reg(pfc, enum_id, &cr,
-					  &field, &value) != 0)
-			return -1;
+		ret = sh_pfc_get_config_reg(pfc, enum_id, &cr, &field, &value);
+		if (ret < 0)
+			return ret;
 
 		sh_pfc_write_config_reg(pfc, cr, field, value);
 	}

commit cd3c1beecfeb757b16904386ea474d3c272de4ee
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 18:47:05 2013 +0100

    sh-pfc: Constify all SoC data
    
    None of the SoC data need to be modified. Constify it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index e2864ec900f4..3a949465e88e 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -96,7 +96,8 @@ int sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin)
 	return -1;
 }
 
-static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
+static int sh_pfc_enum_in_range(pinmux_enum_t enum_id,
+				const struct pinmux_range *r)
 {
 	if (enum_id < r->begin)
 		return 0;
@@ -142,7 +143,7 @@ void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned long reg_width,
 }
 
 static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
-				     struct pinmux_cfg_reg *crp,
+				     const struct pinmux_cfg_reg *crp,
 				     unsigned long in_pos,
 				     void __iomem **mapped_regp,
 				     unsigned long *maskp,
@@ -164,7 +165,7 @@ static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 }
 
 static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
-				    struct pinmux_cfg_reg *crp,
+				    const struct pinmux_cfg_reg *crp,
 				    unsigned long field, unsigned long value)
 {
 	void __iomem *mapped_reg;
@@ -192,10 +193,10 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 }
 
 static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
-				 struct pinmux_cfg_reg **crp, int *fieldp,
+				 const struct pinmux_cfg_reg **crp, int *fieldp,
 				 int *valuep)
 {
-	struct pinmux_cfg_reg *config_reg;
+	const struct pinmux_cfg_reg *config_reg;
 	unsigned long r_width, f_width, curr_width, ncomb;
 	int k, m, n, pos, bit_pos;
 
@@ -238,7 +239,7 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
 			      pinmux_enum_t *enum_idp)
 {
-	pinmux_enum_t *data = pfc->info->gpio_data;
+	const pinmux_enum_t *data = pfc->info->gpio_data;
 	int k;
 
 	if (pos) {
@@ -259,9 +260,9 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
 
 int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 {
-	struct pinmux_cfg_reg *cr = NULL;
+	const struct pinmux_cfg_reg *cr = NULL;
 	pinmux_enum_t enum_id;
-	struct pinmux_range *range;
+	const struct pinmux_range *range;
 	int in_range, pos, field, value;
 
 	switch (pinmux_type) {
@@ -352,7 +353,7 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 
 static int sh_pfc_probe(struct platform_device *pdev)
 {
-	struct sh_pfc_soc_info *info;
+	const struct sh_pfc_soc_info *info;
 	struct sh_pfc *pfc;
 	int ret;
 

commit 861601de101215494e2cc7918e8633d63da490ef
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Mar 10 15:29:14 2013 +0100

    sh-pfc: Remove configuration dry-run and free
    
    The purpose of the dry-run is to ensure that a pin about to be
    configured isn't in use. However, the current implementation is a no-op.
    This proves that the dry-run isn't essential. Remove it.
    
    Freeing configuration then becomes a no-op as well. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 19735012ffb4..e2864ec900f4 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -163,22 +163,6 @@ static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 	}
 }
 
-static int sh_pfc_read_config_reg(struct sh_pfc *pfc,
-				  struct pinmux_cfg_reg *crp,
-				  unsigned long field)
-{
-	void __iomem *mapped_reg;
-	unsigned long mask, pos;
-
-	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
-
-	pr_debug("read_reg: addr = %lx, field = %ld, "
-		 "r_width = %ld, f_width = %ld\n",
-		 crp->reg, field, crp->reg_width, crp->field_width);
-
-	return (sh_pfc_read_raw_reg(mapped_reg, crp->reg_width) >> pos) & mask;
-}
-
 static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 				    struct pinmux_cfg_reg *crp,
 				    unsigned long field, unsigned long value)
@@ -209,7 +193,7 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 				 struct pinmux_cfg_reg **crp, int *fieldp,
-				 int *valuep, unsigned long **cntp)
+				 int *valuep)
 {
 	struct pinmux_cfg_reg *config_reg;
 	unsigned long r_width, f_width, curr_width, ncomb;
@@ -239,7 +223,6 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 					*crp = config_reg;
 					*fieldp = m;
 					*valuep = n;
-					*cntp = &config_reg->cnt[m];
 					return 0;
 				}
 			}
@@ -274,14 +257,12 @@ static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
 	return -1;
 }
 
-int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type,
-		      int cfg_mode)
+int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)
 {
 	struct pinmux_cfg_reg *cr = NULL;
 	pinmux_enum_t enum_id;
 	struct pinmux_range *range;
 	int in_range, pos, field, value;
-	unsigned long *cntp;
 
 	switch (pinmux_type) {
 
@@ -306,7 +287,7 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type,
 		break;
 
 	default:
-		goto out_err;
+		return -1;
 	}
 
 	pos = 0;
@@ -316,7 +297,7 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type,
 	while (1) {
 		pos = sh_pfc_mark_to_enum(pfc, mark, pos, &enum_id);
 		if (pos <= 0)
-			goto out_err;
+			return -1;
 
 		if (!enum_id)
 			break;
@@ -360,30 +341,13 @@ int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type,
 			continue;
 
 		if (sh_pfc_get_config_reg(pfc, enum_id, &cr,
-					  &field, &value, &cntp) != 0)
-			goto out_err;
-
-		switch (cfg_mode) {
-		case GPIO_CFG_DRYRUN:
-			if (!*cntp ||
-			    (sh_pfc_read_config_reg(pfc, cr, field) != value))
-				continue;
-			break;
-
-		case GPIO_CFG_REQ:
-			sh_pfc_write_config_reg(pfc, cr, field, value);
-			*cntp = *cntp + 1;
-			break;
+					  &field, &value) != 0)
+			return -1;
 
-		case GPIO_CFG_FREE:
-			*cntp = *cntp - 1;
-			break;
-		}
+		sh_pfc_write_config_reg(pfc, cr, field, value);
 	}
 
 	return 0;
- out_err:
-	return -1;
 }
 
 static int sh_pfc_probe(struct platform_device *pdev)

commit 1a0039dce269317a843d4fc85c4a3430b484bc2d
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Mar 8 17:43:54 2013 +0100

    sh-pfc: Don't modify sh_pfc_pin SoC data
    
    The sh_pfc_pin structure supplied in SoC data contains information about
    pin configuration and name. It's abused to store GPIO data registers
    information and pin config type. Move those fields out of the
    pinmux_data_reg structure into the new sh_pfc_gpio_pin and
    sh_pfc_pin_config structures.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index cadfb376cb21..19735012ffb4 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -75,26 +75,25 @@ static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
 	BUG();
 }
 
-struct sh_pfc_pin *sh_pfc_get_pin(struct sh_pfc *pfc, unsigned int pin)
+int sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin)
 {
 	unsigned int offset;
 	unsigned int i;
 
 	if (pfc->info->ranges == NULL)
-		return &pfc->info->pins[pin];
+		return pin;
 
 	for (i = 0, offset = 0; i < pfc->info->nr_ranges; ++i) {
 		const struct pinmux_range *range = &pfc->info->ranges[i];
 
 		if (pin <= range->end)
 			return pin >= range->begin
-			     ? &pfc->info->pins[offset + pin - range->begin]
-			     : NULL;
+			     ? offset + pin - range->begin : -1;
 
 		offset += range->end - range->begin + 1;
 	}
 
-	return NULL;
+	return -1;
 }
 
 static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
@@ -393,11 +392,6 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	struct sh_pfc *pfc;
 	int ret;
 
-	/*
-	 * Ensure that the type encoding fits
-	 */
-	BUILD_BUG_ON(PINMUX_FLAG_TYPE > ((1 << PINMUX_FLAG_DBIT_SHIFT) - 1));
-
 	info = pdev->id_entry->driver_data
 	      ? (void *)pdev->id_entry->driver_data : pdev->dev.platform_data;
 	if (info == NULL)

commit bee9f22ba196b0fa3b07507f685eb92b2075e1d1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 23:39:07 2013 +0100

    sh-pfc: Drop unused support for 1:1 physical to virtual memory mappings
    
    Now that all PFC platform devices provide memory resources support for
    registers without an associated memory resource isn't used anymore. Drop
    it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index e847d1683546..cadfb376cb21 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -30,10 +30,8 @@ static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
 	struct resource *res;
 	int k;
 
-	if (pdev->num_resources == 0) {
-		pfc->num_windows = 0;
-		return 0;
-	}
+	if (pdev->num_resources == 0)
+		return -EINVAL;
 
 	pfc->window = devm_kzalloc(pfc->dev, pdev->num_resources *
 				   sizeof(*pfc->window), GFP_NOWAIT);
@@ -59,11 +57,11 @@ static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
 					 unsigned long address)
 {
 	struct sh_pfc_window *window;
-	int k;
+	unsigned int i;
 
 	/* scan through physical windows and convert address */
-	for (k = 0; k < pfc->num_windows; k++) {
-		window = pfc->window + k;
+	for (i = 0; i < pfc->num_windows; i++) {
+		window = pfc->window + i;
 
 		if (address < window->phys)
 			continue;
@@ -74,8 +72,7 @@ static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
 		return window->virt + (address - window->phys);
 	}
 
-	/* no windows defined, register must be 1:1 mapped virt:phys */
-	return (void __iomem *)address;
+	BUG();
 }
 
 struct sh_pfc_pin *sh_pfc_get_pin(struct sh_pfc *pfc, unsigned int pin)

commit e51d5343ffc4b81172178e51e6ca2ee00da67045
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Feb 17 00:26:33 2013 +0100

    sh-pfc: Don't map data registers individually
    
    All data registers are located in the same memory resource. Locate the
    mapped resource at initializat time and use it directly instead of
    computing a mapped address for each register. This gets rid of the
    mapped_reg field of the pinmux_data_reg structure.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 49fde283decd..e847d1683546 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -55,7 +55,8 @@ static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
 	return 0;
 }
 
-void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc, unsigned long address)
+static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
+					 unsigned long address)
 {
 	struct sh_pfc_window *window;
 	int k;

commit 41f1219fae987f97787677d3a91c2f33ca9bab98
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Feb 15 02:04:55 2013 +0100

    sh-pfc: Move GPIO registers access functions to gpio.c
    
    Move the sh_pfc_setup_data_regs(), sh_pfc_setup_data_reg(),
    sh_pfc_get_data_reg(), sh_pfc_read_bit() and sh_pfc_write_bit()
    function to gpio.c as they belong to the GPIO implementation. Inline
    sh_pfc_read_bit() and sh_pfc_write_bit() in their only call location.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 798248261f30..49fde283decd 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -55,8 +55,7 @@ static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
 	return 0;
 }
 
-static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
-					 unsigned long address)
+void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc, unsigned long address)
 {
 	struct sh_pfc_window *window;
 	int k;
@@ -111,8 +110,8 @@ static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
 	return 1;
 }
 
-static unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
-					 unsigned long reg_width)
+unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
+				  unsigned long reg_width)
 {
 	switch (reg_width) {
 	case 8:
@@ -127,8 +126,8 @@ static unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
 	return 0;
 }
 
-static void sh_pfc_write_raw_reg(void __iomem *mapped_reg,
-				 unsigned long reg_width, unsigned long data)
+void sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned long reg_width,
+			  unsigned long data)
 {
 	switch (reg_width) {
 	case 8:
@@ -145,37 +144,6 @@ static void sh_pfc_write_raw_reg(void __iomem *mapped_reg,
 	BUG();
 }
 
-int sh_pfc_read_bit(struct pinmux_data_reg *dr, unsigned long in_pos)
-{
-	unsigned long pos;
-
-	pos = dr->reg_width - (in_pos + 1);
-
-	pr_debug("read_bit: addr = %lx, pos = %ld, "
-		 "r_width = %ld\n", dr->reg, pos, dr->reg_width);
-
-	return (sh_pfc_read_raw_reg(dr->mapped_reg, dr->reg_width) >> pos) & 1;
-}
-
-void sh_pfc_write_bit(struct pinmux_data_reg *dr, unsigned long in_pos,
-		      unsigned long value)
-{
-	unsigned long pos;
-
-	pos = dr->reg_width - (in_pos + 1);
-
-	pr_debug("write_bit addr = %lx, value = %d, pos = %ld, "
-		 "r_width = %ld\n",
-		 dr->reg, !!value, pos, dr->reg_width);
-
-	if (value)
-		set_bit(pos, &dr->reg_shadow);
-	else
-		clear_bit(pos, &dr->reg_shadow);
-
-	sh_pfc_write_raw_reg(dr->mapped_reg, dr->reg_width, dr->reg_shadow);
-}
-
 static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
 				     struct pinmux_cfg_reg *crp,
 				     unsigned long in_pos,
@@ -242,73 +210,6 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 	sh_pfc_write_raw_reg(mapped_reg, crp->reg_width, data);
 }
 
-static void sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
-{
-	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
-	struct pinmux_data_reg *data_reg;
-	int k, n;
-
-	k = 0;
-	while (1) {
-		data_reg = pfc->info->data_regs + k;
-
-		if (!data_reg->reg_width)
-			break;
-
-		data_reg->mapped_reg = sh_pfc_phys_to_virt(pfc, data_reg->reg);
-
-		for (n = 0; n < data_reg->reg_width; n++) {
-			if (data_reg->enum_ids[n] == gpiop->enum_id) {
-				gpiop->flags &= ~PINMUX_FLAG_DREG;
-				gpiop->flags |= (k << PINMUX_FLAG_DREG_SHIFT);
-				gpiop->flags &= ~PINMUX_FLAG_DBIT;
-				gpiop->flags |= (n << PINMUX_FLAG_DBIT_SHIFT);
-				return;
-			}
-		}
-		k++;
-	}
-
-	BUG();
-}
-
-static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
-{
-	struct pinmux_data_reg *drp;
-	int k;
-
-	for (k = 0; k < pfc->info->nr_pins; k++) {
-		if (pfc->info->pins[k].enum_id == 0)
-			continue;
-
-		sh_pfc_setup_data_reg(pfc, k);
-	}
-
-	k = 0;
-	while (1) {
-		drp = pfc->info->data_regs + k;
-
-		if (!drp->reg_width)
-			break;
-
-		drp->reg_shadow = sh_pfc_read_raw_reg(drp->mapped_reg,
-						      drp->reg_width);
-		k++;
-	}
-}
-
-void sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
-			 struct pinmux_data_reg **drp, int *bitp)
-{
-	struct sh_pfc_pin *gpiop = sh_pfc_get_pin(pfc, gpio);
-	int k, n;
-
-	k = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;
-	n = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
-	*drp = pfc->info->data_regs + k;
-	*bitp = n;
-}
-
 static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 				 struct pinmux_cfg_reg **crp, int *fieldp,
 				 int *valuep, unsigned long **cntp)
@@ -518,7 +419,6 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	spin_lock_init(&pfc->lock);
 
 	pinctrl_provide_dummies();
-	sh_pfc_setup_data_regs(pfc);
 
 	/*
 	 * Initialize pinctrl bindings first

commit 63d573835f835aab4c44d0e0342cf5976fb14b35
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Feb 15 01:33:38 2013 +0100

    sh-pfc: Add support for sparse pin numbers
    
    The PFC driver assumes that the value of the GPIO_PORTxxx enumeration
    names are equal to the port number. This isn't true when the port number
    space is sparse, as with the SH73A0.
    
    Fix the issue by adding support for pin numbers ranges specified through
    SoC data. When no range is specified the driver considers that the PFC
    implements a single contiguous range for all pins.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 667db99fb510..798248261f30 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -80,7 +80,24 @@ static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
 
 struct sh_pfc_pin *sh_pfc_get_pin(struct sh_pfc *pfc, unsigned int pin)
 {
-	return &pfc->info->pins[pin];
+	unsigned int offset;
+	unsigned int i;
+
+	if (pfc->info->ranges == NULL)
+		return &pfc->info->pins[pin];
+
+	for (i = 0, offset = 0; i < pfc->info->nr_ranges; ++i) {
+		const struct pinmux_range *range = &pfc->info->ranges[i];
+
+		if (pin <= range->end)
+			return pin >= range->begin
+			     ? &pfc->info->pins[offset + pin - range->begin]
+			     : NULL;
+
+		offset += range->end - range->begin + 1;
+	}
+
+	return NULL;
 }
 
 static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)

commit 934cb02bab9003bf65afe73e9146a1ea63b26c40
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Feb 14 22:35:09 2013 +0100

    sh-pfc: Add function to retrieve a pin instance from its pin number
    
    This prepares support for sparse pin numbering. The function currently
    just performs and indexed lookup in the pins array.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 9b5c0319eb77..667db99fb510 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -78,6 +78,11 @@ static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
 	return (void __iomem *)address;
 }
 
+struct sh_pfc_pin *sh_pfc_get_pin(struct sh_pfc *pfc, unsigned int pin)
+{
+	return &pfc->info->pins[pin];
+}
+
 static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
 {
 	if (enum_id < r->begin)
@@ -278,7 +283,7 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 void sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
 			 struct pinmux_data_reg **drp, int *bitp)
 {
-	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
+	struct sh_pfc_pin *gpiop = sh_pfc_get_pin(pfc, gpio);
 	int k, n;
 
 	k = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;

commit 0b73ee5d534cc6dcb96efb9eac4cf96b40910911
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Feb 14 22:12:11 2013 +0100

    sh-pfc: Simplify the sh_pfc_gpio_is_pin() logic
    
    The function is guaranteed to be called with a gpio number smaller than
    nr_pins. The condition can the be simplified, and the function inlined.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 3387f824920b..9b5c0319eb77 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -89,12 +89,6 @@ static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
 	return 1;
 }
 
-static bool sh_pfc_gpio_is_pin(struct sh_pfc *pfc, unsigned int gpio)
-{
-	return (gpio < pfc->info->nr_pins) &&
-	       (pfc->info->pins[gpio].enum_id != 0);
-}
-
 static unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
 					 unsigned long reg_width)
 {
@@ -226,15 +220,12 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 	sh_pfc_write_raw_reg(mapped_reg, crp->reg_width, data);
 }
 
-static int sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
+static void sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
 {
 	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
 	struct pinmux_data_reg *data_reg;
 	int k, n;
 
-	if (!sh_pfc_gpio_is_pin(pfc, gpio))
-		return -1;
-
 	k = 0;
 	while (1) {
 		data_reg = pfc->info->data_regs + k;
@@ -250,15 +241,13 @@ static int sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
 				gpiop->flags |= (k << PINMUX_FLAG_DREG_SHIFT);
 				gpiop->flags &= ~PINMUX_FLAG_DBIT;
 				gpiop->flags |= (n << PINMUX_FLAG_DBIT_SHIFT);
-				return 0;
+				return;
 			}
 		}
 		k++;
 	}
 
 	BUG();
-
-	return -1;
 }
 
 static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
@@ -266,8 +255,12 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 	struct pinmux_data_reg *drp;
 	int k;
 
-	for (k = 0; k < pfc->info->nr_pins; k++)
+	for (k = 0; k < pfc->info->nr_pins; k++) {
+		if (pfc->info->pins[k].enum_id == 0)
+			continue;
+
 		sh_pfc_setup_data_reg(pfc, k);
+	}
 
 	k = 0;
 	while (1) {
@@ -282,20 +275,16 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 	}
 }
 
-int sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
-			struct pinmux_data_reg **drp, int *bitp)
+void sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
+			 struct pinmux_data_reg **drp, int *bitp)
 {
 	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
 	int k, n;
 
-	if (!sh_pfc_gpio_is_pin(pfc, gpio))
-		return -1;
-
 	k = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;
 	n = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
 	*drp = pfc->info->data_regs + k;
 	*bitp = n;
-	return 0;
 }
 
 static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,

commit a68fdca9b0447a0e7a85ee378510509be8b70d90
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Feb 14 17:36:56 2013 +0100

    sh-pfc: Use pinmux identifiers in the pin muxing API
    
    The PFC core exposes a sh_pfc_config_gpio() function that configures
    pinmuxing for a given GPIO (either a real GPIO or a function GPIO).
    Handling of real and function GPIOs belong to the GPIO layer, move the
    GPIO number to mark translation to the caller and rename the function to
    sh_pfc_config_mux().
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 22f299993a36..3387f824920b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -95,13 +95,6 @@ static bool sh_pfc_gpio_is_pin(struct sh_pfc *pfc, unsigned int gpio)
 	       (pfc->info->pins[gpio].enum_id != 0);
 }
 
-static bool sh_pfc_gpio_is_function(struct sh_pfc *pfc, unsigned int gpio)
-{
-	return (gpio >= pfc->info->nr_pins) &&
-	       (gpio < pfc->info->nr_pins + pfc->info->nr_func_gpios) &&
-	       (pfc->info->func_gpios[gpio - pfc->info->nr_pins].enum_id != 0);
-}
-
 static unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
 					 unsigned long reg_width)
 {
@@ -350,41 +343,30 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 	return -1;
 }
 
-static int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
-			       pinmux_enum_t *enum_idp)
+static int sh_pfc_mark_to_enum(struct sh_pfc *pfc, pinmux_enum_t mark, int pos,
+			      pinmux_enum_t *enum_idp)
 {
 	pinmux_enum_t *data = pfc->info->gpio_data;
-	pinmux_enum_t enum_id;
 	int k;
 
-	if (sh_pfc_gpio_is_pin(pfc, gpio)) {
-		enum_id = pfc->info->pins[gpio].enum_id;
-	} else if (sh_pfc_gpio_is_function(pfc, gpio)) {
-		unsigned int offset = gpio - pfc->info->nr_pins;
-		enum_id = pfc->info->func_gpios[offset].enum_id;
-	} else {
-		pr_err("non data/mark enum_id for gpio %d\n", gpio);
-		return -1;
-	}
-
 	if (pos) {
 		*enum_idp = data[pos + 1];
 		return pos + 1;
 	}
 
 	for (k = 0; k < pfc->info->gpio_data_size; k++) {
-		if (data[k] == enum_id) {
+		if (data[k] == mark) {
 			*enum_idp = data[k + 1];
 			return k + 1;
 		}
 	}
 
-	pr_err("cannot locate data/mark enum_id for gpio %d\n", gpio);
+	pr_err("cannot locate data/mark enum_id for mark %d\n", mark);
 	return -1;
 }
 
-int sh_pfc_config_gpio(struct sh_pfc *pfc, unsigned gpio, int pinmux_type,
-		       int cfg_mode)
+int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type,
+		      int cfg_mode)
 {
 	struct pinmux_cfg_reg *cr = NULL;
 	pinmux_enum_t enum_id;
@@ -423,7 +405,7 @@ int sh_pfc_config_gpio(struct sh_pfc *pfc, unsigned gpio, int pinmux_type,
 	field = 0;
 	value = 0;
 	while (1) {
-		pos = sh_pfc_gpio_to_enum(pfc, gpio, pos, &enum_id);
+		pos = sh_pfc_mark_to_enum(pfc, mark, pos, &enum_id);
 		if (pos <= 0)
 			goto out_err;
 

commit c07f54f604b3b458f10452b60fe21c549218bf02
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Jan 3 14:12:14 2013 +0100

    sh-pfc: Look up IRQ table entries by GPIO number
    
    Instead of converting the GPIO number to an enum_id and looking up IRQ
    table entries by enum_id, replace the pinmux_irq enum_ids field with a
    gpios field and lookup entries using the GPIO number.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index f94d80c67ef3..22f299993a36 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -350,8 +350,8 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 	return -1;
 }
 
-int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
-			pinmux_enum_t *enum_idp)
+static int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
+			       pinmux_enum_t *enum_idp)
 {
 	pinmux_enum_t *data = pfc->info->gpio_data;
 	pinmux_enum_t enum_id;

commit a3db40a68a5b2f3ed2190f586bdaf3904f4933b2
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Jan 2 14:53:37 2013 +0100

    sh-pfc: Rename struct pinmux_pin to struct sh_pfc_pin
    
    And drop the pinmux_flag_t typedef.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 6cf39439694f..f94d80c67ef3 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -235,7 +235,7 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 static int sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
 {
-	struct pinmux_pin *gpiop = &pfc->info->pins[gpio];
+	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
 	struct pinmux_data_reg *data_reg;
 	int k, n;
 
@@ -292,7 +292,7 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 int sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
 			struct pinmux_data_reg **drp, int *bitp)
 {
-	struct pinmux_pin *gpiop = &pfc->info->pins[gpio];
+	struct sh_pfc_pin *gpiop = &pfc->info->pins[gpio];
 	int k, n;
 
 	if (!sh_pfc_gpio_is_pin(pfc, gpio))

commit 16883814eca229506cd2a4e447b2b5a2338fa35e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Dec 6 14:49:25 2012 +0100

    sh-pfc: Split pins and functions into separate gpio_chip instances
    
    Register two GPIO chips, one for the real GPIOs and one for the function
    GPIOs.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 9dee3b911283..6cf39439694f 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -95,7 +95,7 @@ static bool sh_pfc_gpio_is_pin(struct sh_pfc *pfc, unsigned int gpio)
 	       (pfc->info->pins[gpio].enum_id != 0);
 }
 
-bool sh_pfc_gpio_is_function(struct sh_pfc *pfc, unsigned int gpio)
+static bool sh_pfc_gpio_is_function(struct sh_pfc *pfc, unsigned int gpio)
 {
 	return (gpio >= pfc->info->nr_pins) &&
 	       (gpio < pfc->info->nr_pins + pfc->info->nr_func_gpios) &&

commit a373ed0aa229f06e7d699797669b664ef39d97c1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Nov 29 13:24:07 2012 +0100

    sh-pfc: Split pins and functions definition tables
    
    Split the GPIOs table into a pins table for real GPIOs and a functions
    table for function GPIOs.
    
    Only register pins with the pinctrl core. The function GPIOs remain
    accessible as GPIOs.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index bed2d23e2464..9dee3b911283 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -92,13 +92,14 @@ static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
 static bool sh_pfc_gpio_is_pin(struct sh_pfc *pfc, unsigned int gpio)
 {
 	return (gpio < pfc->info->nr_pins) &&
-	       (pfc->info->gpios[gpio].enum_id != 0);
+	       (pfc->info->pins[gpio].enum_id != 0);
 }
 
 bool sh_pfc_gpio_is_function(struct sh_pfc *pfc, unsigned int gpio)
 {
-	return (gpio >= pfc->info->nr_pins) && (gpio < pfc->info->nr_gpios) &&
-	       (pfc->info->gpios[gpio].enum_id != 0);
+	return (gpio >= pfc->info->nr_pins) &&
+	       (gpio < pfc->info->nr_pins + pfc->info->nr_func_gpios) &&
+	       (pfc->info->func_gpios[gpio - pfc->info->nr_pins].enum_id != 0);
 }
 
 static unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
@@ -234,7 +235,7 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 static int sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
 {
-	struct pinmux_gpio *gpiop = &pfc->info->gpios[gpio];
+	struct pinmux_pin *gpiop = &pfc->info->pins[gpio];
 	struct pinmux_data_reg *data_reg;
 	int k, n;
 
@@ -291,7 +292,7 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 int sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
 			struct pinmux_data_reg **drp, int *bitp)
 {
-	struct pinmux_gpio *gpiop = &pfc->info->gpios[gpio];
+	struct pinmux_pin *gpiop = &pfc->info->pins[gpio];
 	int k, n;
 
 	if (!sh_pfc_gpio_is_pin(pfc, gpio))
@@ -352,12 +353,16 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
 			pinmux_enum_t *enum_idp)
 {
-	pinmux_enum_t enum_id = pfc->info->gpios[gpio].enum_id;
 	pinmux_enum_t *data = pfc->info->gpio_data;
+	pinmux_enum_t enum_id;
 	int k;
 
-	if (!sh_pfc_gpio_is_pin(pfc, gpio) &&
-	    !sh_pfc_gpio_is_function(pfc, gpio)) {
+	if (sh_pfc_gpio_is_pin(pfc, gpio)) {
+		enum_id = pfc->info->pins[gpio].enum_id;
+	} else if (sh_pfc_gpio_is_function(pfc, gpio)) {
+		unsigned int offset = gpio - pfc->info->nr_pins;
+		enum_id = pfc->info->func_gpios[offset].enum_id;
+	} else {
 		pr_err("non data/mark enum_id for gpio %d\n", gpio);
 		return -1;
 	}

commit 2119f7c9afaf4c5fe88e9ffec1f34c5bc6b02f78
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Nov 29 13:03:53 2012 +0100

    sh-pfc: Shrink the pinctrl GPIO range to include real GPIOs only
    
    As a step towards GPIO function removal, shorten the GPIO range
    registered with the pinctrl core. Function GPIOs are now handled in the
    GPIO handlers directly instead of going through the pinctrl API.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index e7ad0d93fed4..bed2d23e2464 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -95,7 +95,7 @@ static bool sh_pfc_gpio_is_pin(struct sh_pfc *pfc, unsigned int gpio)
 	       (pfc->info->gpios[gpio].enum_id != 0);
 }
 
-static bool sh_pfc_gpio_is_function(struct sh_pfc *pfc, unsigned int gpio)
+bool sh_pfc_gpio_is_function(struct sh_pfc *pfc, unsigned int gpio)
 {
 	return (gpio >= pfc->info->nr_pins) && (gpio < pfc->info->nr_gpios) &&
 	       (pfc->info->gpios[gpio].enum_id != 0);

commit caa5bac3b4749ae3dca1db33d648280197f91a56
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Nov 29 12:24:51 2012 +0100

    sh-pfc: Replace SoC info data and mark ranges with a number of pins
    
    The data and mark ranges are only used to check whether a GPIO
    corresponds to a real pin or a function. As pins come first in the list
    of GPIOs and in the platform-specific GPIO enumerations, we can replace
    the data and mark ranges by a number of pins.
    
    Add an nr_pins field to struct sh_pfc_soc_info to store the number of
    pins implemented by the SoC, remove the data and mark range fields and
    introduce sh_pfc_gpio_is_pin() and sh_pfc_gpio_is_function() functions
    to replace range-based checks.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 1b86a906a97b..e7ad0d93fed4 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -89,6 +89,18 @@ static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
 	return 1;
 }
 
+static bool sh_pfc_gpio_is_pin(struct sh_pfc *pfc, unsigned int gpio)
+{
+	return (gpio < pfc->info->nr_pins) &&
+	       (pfc->info->gpios[gpio].enum_id != 0);
+}
+
+static bool sh_pfc_gpio_is_function(struct sh_pfc *pfc, unsigned int gpio)
+{
+	return (gpio >= pfc->info->nr_pins) && (gpio < pfc->info->nr_gpios) &&
+	       (pfc->info->gpios[gpio].enum_id != 0);
+}
+
 static unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
 					 unsigned long reg_width)
 {
@@ -226,7 +238,7 @@ static int sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
 	struct pinmux_data_reg *data_reg;
 	int k, n;
 
-	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->info->data))
+	if (!sh_pfc_gpio_is_pin(pfc, gpio))
 		return -1;
 
 	k = 0;
@@ -260,7 +272,7 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 	struct pinmux_data_reg *drp;
 	int k;
 
-	for (k = 0; k < pfc->info->nr_gpios; k++)
+	for (k = 0; k < pfc->info->nr_pins; k++)
 		sh_pfc_setup_data_reg(pfc, k);
 
 	k = 0;
@@ -282,7 +294,7 @@ int sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
 	struct pinmux_gpio *gpiop = &pfc->info->gpios[gpio];
 	int k, n;
 
-	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->info->data))
+	if (!sh_pfc_gpio_is_pin(pfc, gpio))
 		return -1;
 
 	k = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;
@@ -344,11 +356,10 @@ int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
 	pinmux_enum_t *data = pfc->info->gpio_data;
 	int k;
 
-	if (!sh_pfc_enum_in_range(enum_id, &pfc->info->data)) {
-		if (!sh_pfc_enum_in_range(enum_id, &pfc->info->mark)) {
-			pr_err("non data/mark enum_id for gpio %d\n", gpio);
-			return -1;
-		}
+	if (!sh_pfc_gpio_is_pin(pfc, gpio) &&
+	    !sh_pfc_gpio_is_function(pfc, gpio)) {
+		pr_err("non data/mark enum_id for gpio %d\n", gpio);
+		return -1;
 	}
 
 	if (pos) {

commit d7a7ca5781fa2ac40319acc7125c487db5b26d91
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Nov 28 17:51:00 2012 +0100

    sh-pfc: Replace first_gpio and last_gpio with nr_gpios
    
    The SoC information first_gpio field is always equal to 0, and the
    last_gpio field is the index of the last entry in the pinmux_gpios
    array. Replace the first_gpio and last_gpio fields by a nr_gpios field,
    and initialize it to ARRAY_SIZE(pinmux_gpios).
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 970ddff2b0b6..1b86a906a97b 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -260,7 +260,7 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 	struct pinmux_data_reg *drp;
 	int k;
 
-	for (k = pfc->info->first_gpio; k <= pfc->info->last_gpio; k++)
+	for (k = 0; k < pfc->info->nr_gpios; k++)
 		sh_pfc_setup_data_reg(pfc, k);
 
 	k = 0;

commit 8c43fcc7804fc4609ccd9fa021e21f5423db9d96
Author: Magnus Damm <damm@opensource.se>
Date:   Thu Feb 14 21:23:47 2013 +0900

    sh-pfc: sh_pfc_probe() sizeof() fix
    
    Fix sizeof() usage in sh-pfc/core.c to allocate space
    for the full data structure instead of a pointer.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index d323c24fffaf..970ddff2b0b6 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -495,7 +495,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	if (info == NULL)
 		return -ENODEV;
 
-	pfc = devm_kzalloc(&pdev->dev, sizeof(pfc), GFP_KERNEL);
+	pfc = devm_kzalloc(&pdev->dev, sizeof(*pfc), GFP_KERNEL);
 	if (pfc == NULL)
 		return -ENOMEM;
 

commit c3323806a67c0c656e27956b7340e37ba6c6968b
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:55 2012 +0100

    sh-pfc: Move sh_pfc.h from include/linux/ to driver directory
    
    The header file isn't used by arch code anymore. Make it private to the
    driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 33181f4b0731..d323c24fffaf 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -21,7 +21,6 @@
 #include <linux/module.h>
 #include <linux/pinctrl/machine.h>
 #include <linux/platform_device.h>
-#include <linux/sh_pfc.h>
 #include <linux/slab.h>
 
 #include "core.h"

commit d5d9a818b857346a321f52f3be050fdb7aeb6200
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:40 2012 +0100

    sh-pfc: Add shx3 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index bdb431235452..33181f4b0731 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -600,6 +600,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7786
 	{ "pfc-sh7786", (kernel_ulong_t)&sh7786_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SHX3
+	{ "pfc-shx3", (kernel_ulong_t)&shx3_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit d2a31bddbdae8c3ac43c48a865f935fcb7c65190
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:39 2012 +0100

    sh-pfc: Add sh7786 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index cb62216e113a..bdb431235452 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -597,6 +597,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7785
 	{ "pfc-sh7785", (kernel_ulong_t)&sh7785_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7786
+	{ "pfc-sh7786", (kernel_ulong_t)&sh7786_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit a56398e9691ab7630bdde76f0ca21267246ce99e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:38 2012 +0100

    sh-pfc: Add sh7785 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index eb2f47ca18e6..cb62216e113a 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -594,6 +594,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7757
 	{ "pfc-sh7757", (kernel_ulong_t)&sh7757_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7785
+	{ "pfc-sh7785", (kernel_ulong_t)&sh7785_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit 0bb92677ab45e09f99bca06ec6635852ee6ec893
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:37 2012 +0100

    sh-pfc: Add sh7757 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a8af4a3df362..eb2f47ca18e6 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -591,6 +591,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7734
 	{ "pfc-sh7734", (kernel_ulong_t)&sh7734_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7757
+	{ "pfc-sh7757", (kernel_ulong_t)&sh7757_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit ac1ebc2190f575fce6685941f5eeecac808ba467
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:36 2012 +0100

    sh-pfc: Add sh7734 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index c1b2bf5460f1..a8af4a3df362 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -588,6 +588,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7724
 	{ "pfc-sh7724", (kernel_ulong_t)&sh7724_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7734
+	{ "pfc-sh7734", (kernel_ulong_t)&sh7734_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit 0ff25baba0386ce9de32b90b5116f1a14a4224b8
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:35 2012 +0100

    sh-pfc: Add sh7724 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 3a288e4508df..c1b2bf5460f1 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -585,6 +585,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7723
 	{ "pfc-sh7723", (kernel_ulong_t)&sh7723_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7724
+	{ "pfc-sh7724", (kernel_ulong_t)&sh7724_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit d05afa0afc183b2037dbd5f3cf12fe5229dce539
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:34 2012 +0100

    sh-pfc: Add sh7723 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a6f32c799a3a..3a288e4508df 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -582,6 +582,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7722
 	{ "pfc-sh7722", (kernel_ulong_t)&sh7722_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7723
+	{ "pfc-sh7723", (kernel_ulong_t)&sh7723_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit f5e25ae52feff2dc99da168aa524ff4e799530b1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:33 2012 +0100

    sh-pfc: Add sh7722 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index cab17526d584..a6f32c799a3a 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -579,6 +579,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7720
 	{ "pfc-sh7720", (kernel_ulong_t)&sh7720_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7722
+	{ "pfc-sh7722", (kernel_ulong_t)&sh7722_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit 74cad60549e3a176d47214b9dd973ae00a411935
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:32 2012 +0100

    sh-pfc: Add sh7720 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index a68831ba0d9d..cab17526d584 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -576,6 +576,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH73A0
 	{ "pfc-sh73a0", (kernel_ulong_t)&sh73a0_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7720
+	{ "pfc-sh7720", (kernel_ulong_t)&sh7720_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit f5e811f2a43117b2c6291c556fb19acef92e28dc
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:31 2012 +0100

    sh-pfc: Add sh7269 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 807ca01cc05d..a68831ba0d9d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -568,6 +568,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_SH7264
 	{ "pfc-sh7264", (kernel_ulong_t)&sh7264_pinmux_info },
 #endif
+#ifdef CONFIG_PINCTRL_PFC_SH7269
+	{ "pfc-sh7269", (kernel_ulong_t)&sh7269_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7372
 	{ "pfc-sh7372", (kernel_ulong_t)&sh7372_pinmux_info },
 #endif

commit a8d42fc4217b1ea18f34a6676a60ddcc34248f44
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:30 2012 +0100

    sh-pfc: Add sh7264 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 5b1426ad4844..807ca01cc05d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -565,6 +565,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_SH7203
 	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
 #endif
+#ifdef CONFIG_PINCTRL_PFC_SH7264
+	{ "pfc-sh7264", (kernel_ulong_t)&sh7264_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7372
 	{ "pfc-sh7372", (kernel_ulong_t)&sh7372_pinmux_info },
 #endif

commit ccda552eb168590fb35ef840b295014e11721ad5
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:29 2012 +0100

    sh-pfc: Add sh7203 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 015c81620af7..5b1426ad4844 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -562,6 +562,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7779
 	{ "pfc-r8a7779", (kernel_ulong_t)&r8a7779_pinmux_info },
 #endif
+#ifdef CONFIG_PINCTRL_PFC_SH7203
+	{ "pfc-sh7203", (kernel_ulong_t)&sh7203_pinmux_info },
+#endif
 #ifdef CONFIG_PINCTRL_PFC_SH7372
 	{ "pfc-sh7372", (kernel_ulong_t)&sh7372_pinmux_info },
 #endif

commit 5d5166dc39bcbe2c21d4fca034540133c415dce6
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:24 2012 +0100

    sh-pfc: Add sh73a0 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index cd48b64d4c0d..015c81620af7 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -564,6 +564,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_SH7372
 	{ "pfc-sh7372", (kernel_ulong_t)&sh7372_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH73A0
+	{ "pfc-sh73a0", (kernel_ulong_t)&sh73a0_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit 6e5469a6b149568355e81d791099d0cbf2a4a37a
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:23 2012 +0100

    sh-pfc: Add sh7372 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index bffc93ecd5e5..cd48b64d4c0d 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -561,6 +561,9 @@ static const struct platform_device_id sh_pfc_id_table[] = {
 #endif
 #ifdef CONFIG_PINCTRL_PFC_R8A7779
 	{ "pfc-r8a7779", (kernel_ulong_t)&r8a7779_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_SH7372
+	{ "pfc-sh7372", (kernel_ulong_t)&sh7372_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit 881023d28b465eb457067dc8bbca0f24d8b34279
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:22 2012 +0100

    sh-pfc: Add r8a7779 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 2676f691c719..bffc93ecd5e5 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -558,6 +558,9 @@ static int sh_pfc_remove(struct platform_device *pdev)
 static const struct platform_device_id sh_pfc_id_table[] = {
 #ifdef CONFIG_PINCTRL_PFC_R8A7740
 	{ "pfc-r8a7740", (kernel_ulong_t)&r8a7740_pinmux_info },
+#endif
+#ifdef CONFIG_PINCTRL_PFC_R8A7779
+	{ "pfc-r8a7779", (kernel_ulong_t)&r8a7779_pinmux_info },
 #endif
 	{ "sh-pfc", 0 },
 	{ },

commit d5b1521a94659167e77616368fe6e7c9b3aa1733
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:21 2012 +0100

    sh-pfc: Add r8a7740 pinmux support
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 95cd10f83e18..2676f691c719 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -556,6 +556,9 @@ static int sh_pfc_remove(struct platform_device *pdev)
 }
 
 static const struct platform_device_id sh_pfc_id_table[] = {
+#ifdef CONFIG_PINCTRL_PFC_R8A7740
+	{ "pfc-r8a7740", (kernel_ulong_t)&r8a7740_pinmux_info },
+#endif
 	{ "sh-pfc", 0 },
 	{ },
 };

commit 19bb7fe36950ff74ce322cc29f6f4e025999f1f0
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:20 2012 +0100

    sh-pfc: Support pinmux info in driver data instead of platform data
    
    Pinmux information should be provided by the pinmux driver, not arch
    code. Make it possible to do so by supporting pinmux information passed
    through the driver_data field in the platform ID table. Platform data
    will remain supported until all arch code has been converted.
    
    Rename the sh_pfc_platform_data structure to sh_pfc_soc_info to reflect
    this.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
index 8e7818bccb29..95cd10f83e18 100644
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -213,9 +213,9 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 	data &= mask;
 	data |= value;
 
-	if (pfc->pdata->unlock_reg)
+	if (pfc->info->unlock_reg)
 		sh_pfc_write_raw_reg(
-			sh_pfc_phys_to_virt(pfc, pfc->pdata->unlock_reg), 32,
+			sh_pfc_phys_to_virt(pfc, pfc->info->unlock_reg), 32,
 			~data);
 
 	sh_pfc_write_raw_reg(mapped_reg, crp->reg_width, data);
@@ -223,16 +223,16 @@ static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
 
 static int sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
 {
-	struct pinmux_gpio *gpiop = &pfc->pdata->gpios[gpio];
+	struct pinmux_gpio *gpiop = &pfc->info->gpios[gpio];
 	struct pinmux_data_reg *data_reg;
 	int k, n;
 
-	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->pdata->data))
+	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->info->data))
 		return -1;
 
 	k = 0;
 	while (1) {
-		data_reg = pfc->pdata->data_regs + k;
+		data_reg = pfc->info->data_regs + k;
 
 		if (!data_reg->reg_width)
 			break;
@@ -261,12 +261,12 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 	struct pinmux_data_reg *drp;
 	int k;
 
-	for (k = pfc->pdata->first_gpio; k <= pfc->pdata->last_gpio; k++)
+	for (k = pfc->info->first_gpio; k <= pfc->info->last_gpio; k++)
 		sh_pfc_setup_data_reg(pfc, k);
 
 	k = 0;
 	while (1) {
-		drp = pfc->pdata->data_regs + k;
+		drp = pfc->info->data_regs + k;
 
 		if (!drp->reg_width)
 			break;
@@ -280,15 +280,15 @@ static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
 int sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
 			struct pinmux_data_reg **drp, int *bitp)
 {
-	struct pinmux_gpio *gpiop = &pfc->pdata->gpios[gpio];
+	struct pinmux_gpio *gpiop = &pfc->info->gpios[gpio];
 	int k, n;
 
-	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->pdata->data))
+	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->info->data))
 		return -1;
 
 	k = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;
 	n = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
-	*drp = pfc->pdata->data_regs + k;
+	*drp = pfc->info->data_regs + k;
 	*bitp = n;
 	return 0;
 }
@@ -303,7 +303,7 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 
 	k = 0;
 	while (1) {
-		config_reg = pfc->pdata->cfg_regs + k;
+		config_reg = pfc->info->cfg_regs + k;
 
 		r_width = config_reg->reg_width;
 		f_width = config_reg->field_width;
@@ -341,12 +341,12 @@ static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
 int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
 			pinmux_enum_t *enum_idp)
 {
-	pinmux_enum_t enum_id = pfc->pdata->gpios[gpio].enum_id;
-	pinmux_enum_t *data = pfc->pdata->gpio_data;
+	pinmux_enum_t enum_id = pfc->info->gpios[gpio].enum_id;
+	pinmux_enum_t *data = pfc->info->gpio_data;
 	int k;
 
-	if (!sh_pfc_enum_in_range(enum_id, &pfc->pdata->data)) {
-		if (!sh_pfc_enum_in_range(enum_id, &pfc->pdata->mark)) {
+	if (!sh_pfc_enum_in_range(enum_id, &pfc->info->data)) {
+		if (!sh_pfc_enum_in_range(enum_id, &pfc->info->mark)) {
 			pr_err("non data/mark enum_id for gpio %d\n", gpio);
 			return -1;
 		}
@@ -357,7 +357,7 @@ int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
 		return pos + 1;
 	}
 
-	for (k = 0; k < pfc->pdata->gpio_data_size; k++) {
+	for (k = 0; k < pfc->info->gpio_data_size; k++) {
 		if (data[k] == enum_id) {
 			*enum_idp = data[k + 1];
 			return k + 1;
@@ -384,19 +384,19 @@ int sh_pfc_config_gpio(struct sh_pfc *pfc, unsigned gpio, int pinmux_type,
 		break;
 
 	case PINMUX_TYPE_OUTPUT:
-		range = &pfc->pdata->output;
+		range = &pfc->info->output;
 		break;
 
 	case PINMUX_TYPE_INPUT:
-		range = &pfc->pdata->input;
+		range = &pfc->info->input;
 		break;
 
 	case PINMUX_TYPE_INPUT_PULLUP:
-		range = &pfc->pdata->input_pu;
+		range = &pfc->info->input_pu;
 		break;
 
 	case PINMUX_TYPE_INPUT_PULLDOWN:
-		range = &pfc->pdata->input_pd;
+		range = &pfc->info->input_pd;
 		break;
 
 	default:
@@ -416,7 +416,7 @@ int sh_pfc_config_gpio(struct sh_pfc *pfc, unsigned gpio, int pinmux_type,
 			break;
 
 		/* first check if this is a function enum */
-		in_range = sh_pfc_enum_in_range(enum_id, &pfc->pdata->function);
+		in_range = sh_pfc_enum_in_range(enum_id, &pfc->info->function);
 		if (!in_range) {
 			/* not a function enum */
 			if (range) {
@@ -482,7 +482,7 @@ int sh_pfc_config_gpio(struct sh_pfc *pfc, unsigned gpio, int pinmux_type,
 
 static int sh_pfc_probe(struct platform_device *pdev)
 {
-	struct sh_pfc_platform_data *pdata = pdev->dev.platform_data;
+	struct sh_pfc_soc_info *info;
 	struct sh_pfc *pfc;
 	int ret;
 
@@ -491,14 +491,16 @@ static int sh_pfc_probe(struct platform_device *pdev)
 	 */
 	BUILD_BUG_ON(PINMUX_FLAG_TYPE > ((1 << PINMUX_FLAG_DBIT_SHIFT) - 1));
 
-	if (pdata == NULL)
+	info = pdev->id_entry->driver_data
+	      ? (void *)pdev->id_entry->driver_data : pdev->dev.platform_data;
+	if (info == NULL)
 		return -ENODEV;
 
 	pfc = devm_kzalloc(&pdev->dev, sizeof(pfc), GFP_KERNEL);
 	if (pfc == NULL)
 		return -ENOMEM;
 
-	pfc->pdata = pdata;
+	pfc->info = info;
 	pfc->dev = &pdev->dev;
 
 	ret = sh_pfc_ioremap(pfc, pdev);
@@ -534,7 +536,7 @@ static int sh_pfc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, pfc);
 
-	pr_info("%s support registered\n", pdata->name);
+	pr_info("%s support registered\n", info->name);
 
 	return 0;
 }

commit 6e54d8d252ed09ae148af6565971974af9a96e10
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Dec 15 23:51:19 2012 +0100

    sh-pfc: Move driver from drivers/sh/ to drivers/pinctrl/
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c
new file mode 100644
index 000000000000..8e7818bccb29
--- /dev/null
+++ b/drivers/pinctrl/sh-pfc/core.c
@@ -0,0 +1,586 @@
+/*
+ * SuperH Pin Function Controller support.
+ *
+ * Copyright (C) 2008 Magnus Damm
+ * Copyright (C) 2009 - 2012 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#define DRV_NAME "sh-pfc"
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/platform_device.h>
+#include <linux/sh_pfc.h>
+#include <linux/slab.h>
+
+#include "core.h"
+
+static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
+{
+	struct resource *res;
+	int k;
+
+	if (pdev->num_resources == 0) {
+		pfc->num_windows = 0;
+		return 0;
+	}
+
+	pfc->window = devm_kzalloc(pfc->dev, pdev->num_resources *
+				   sizeof(*pfc->window), GFP_NOWAIT);
+	if (!pfc->window)
+		return -ENOMEM;
+
+	pfc->num_windows = pdev->num_resources;
+
+	for (k = 0, res = pdev->resource; k < pdev->num_resources; k++, res++) {
+		WARN_ON(resource_type(res) != IORESOURCE_MEM);
+		pfc->window[k].phys = res->start;
+		pfc->window[k].size = resource_size(res);
+		pfc->window[k].virt = devm_ioremap_nocache(pfc->dev, res->start,
+							   resource_size(res));
+		if (!pfc->window[k].virt)
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc,
+					 unsigned long address)
+{
+	struct sh_pfc_window *window;
+	int k;
+
+	/* scan through physical windows and convert address */
+	for (k = 0; k < pfc->num_windows; k++) {
+		window = pfc->window + k;
+
+		if (address < window->phys)
+			continue;
+
+		if (address >= (window->phys + window->size))
+			continue;
+
+		return window->virt + (address - window->phys);
+	}
+
+	/* no windows defined, register must be 1:1 mapped virt:phys */
+	return (void __iomem *)address;
+}
+
+static int sh_pfc_enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)
+{
+	if (enum_id < r->begin)
+		return 0;
+
+	if (enum_id > r->end)
+		return 0;
+
+	return 1;
+}
+
+static unsigned long sh_pfc_read_raw_reg(void __iomem *mapped_reg,
+					 unsigned long reg_width)
+{
+	switch (reg_width) {
+	case 8:
+		return ioread8(mapped_reg);
+	case 16:
+		return ioread16(mapped_reg);
+	case 32:
+		return ioread32(mapped_reg);
+	}
+
+	BUG();
+	return 0;
+}
+
+static void sh_pfc_write_raw_reg(void __iomem *mapped_reg,
+				 unsigned long reg_width, unsigned long data)
+{
+	switch (reg_width) {
+	case 8:
+		iowrite8(data, mapped_reg);
+		return;
+	case 16:
+		iowrite16(data, mapped_reg);
+		return;
+	case 32:
+		iowrite32(data, mapped_reg);
+		return;
+	}
+
+	BUG();
+}
+
+int sh_pfc_read_bit(struct pinmux_data_reg *dr, unsigned long in_pos)
+{
+	unsigned long pos;
+
+	pos = dr->reg_width - (in_pos + 1);
+
+	pr_debug("read_bit: addr = %lx, pos = %ld, "
+		 "r_width = %ld\n", dr->reg, pos, dr->reg_width);
+
+	return (sh_pfc_read_raw_reg(dr->mapped_reg, dr->reg_width) >> pos) & 1;
+}
+
+void sh_pfc_write_bit(struct pinmux_data_reg *dr, unsigned long in_pos,
+		      unsigned long value)
+{
+	unsigned long pos;
+
+	pos = dr->reg_width - (in_pos + 1);
+
+	pr_debug("write_bit addr = %lx, value = %d, pos = %ld, "
+		 "r_width = %ld\n",
+		 dr->reg, !!value, pos, dr->reg_width);
+
+	if (value)
+		set_bit(pos, &dr->reg_shadow);
+	else
+		clear_bit(pos, &dr->reg_shadow);
+
+	sh_pfc_write_raw_reg(dr->mapped_reg, dr->reg_width, dr->reg_shadow);
+}
+
+static void sh_pfc_config_reg_helper(struct sh_pfc *pfc,
+				     struct pinmux_cfg_reg *crp,
+				     unsigned long in_pos,
+				     void __iomem **mapped_regp,
+				     unsigned long *maskp,
+				     unsigned long *posp)
+{
+	int k;
+
+	*mapped_regp = sh_pfc_phys_to_virt(pfc, crp->reg);
+
+	if (crp->field_width) {
+		*maskp = (1 << crp->field_width) - 1;
+		*posp = crp->reg_width - ((in_pos + 1) * crp->field_width);
+	} else {
+		*maskp = (1 << crp->var_field_width[in_pos]) - 1;
+		*posp = crp->reg_width;
+		for (k = 0; k <= in_pos; k++)
+			*posp -= crp->var_field_width[k];
+	}
+}
+
+static int sh_pfc_read_config_reg(struct sh_pfc *pfc,
+				  struct pinmux_cfg_reg *crp,
+				  unsigned long field)
+{
+	void __iomem *mapped_reg;
+	unsigned long mask, pos;
+
+	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
+
+	pr_debug("read_reg: addr = %lx, field = %ld, "
+		 "r_width = %ld, f_width = %ld\n",
+		 crp->reg, field, crp->reg_width, crp->field_width);
+
+	return (sh_pfc_read_raw_reg(mapped_reg, crp->reg_width) >> pos) & mask;
+}
+
+static void sh_pfc_write_config_reg(struct sh_pfc *pfc,
+				    struct pinmux_cfg_reg *crp,
+				    unsigned long field, unsigned long value)
+{
+	void __iomem *mapped_reg;
+	unsigned long mask, pos, data;
+
+	sh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);
+
+	pr_debug("write_reg addr = %lx, value = %ld, field = %ld, "
+		 "r_width = %ld, f_width = %ld\n",
+		 crp->reg, value, field, crp->reg_width, crp->field_width);
+
+	mask = ~(mask << pos);
+	value = value << pos;
+
+	data = sh_pfc_read_raw_reg(mapped_reg, crp->reg_width);
+	data &= mask;
+	data |= value;
+
+	if (pfc->pdata->unlock_reg)
+		sh_pfc_write_raw_reg(
+			sh_pfc_phys_to_virt(pfc, pfc->pdata->unlock_reg), 32,
+			~data);
+
+	sh_pfc_write_raw_reg(mapped_reg, crp->reg_width, data);
+}
+
+static int sh_pfc_setup_data_reg(struct sh_pfc *pfc, unsigned gpio)
+{
+	struct pinmux_gpio *gpiop = &pfc->pdata->gpios[gpio];
+	struct pinmux_data_reg *data_reg;
+	int k, n;
+
+	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->pdata->data))
+		return -1;
+
+	k = 0;
+	while (1) {
+		data_reg = pfc->pdata->data_regs + k;
+
+		if (!data_reg->reg_width)
+			break;
+
+		data_reg->mapped_reg = sh_pfc_phys_to_virt(pfc, data_reg->reg);
+
+		for (n = 0; n < data_reg->reg_width; n++) {
+			if (data_reg->enum_ids[n] == gpiop->enum_id) {
+				gpiop->flags &= ~PINMUX_FLAG_DREG;
+				gpiop->flags |= (k << PINMUX_FLAG_DREG_SHIFT);
+				gpiop->flags &= ~PINMUX_FLAG_DBIT;
+				gpiop->flags |= (n << PINMUX_FLAG_DBIT_SHIFT);
+				return 0;
+			}
+		}
+		k++;
+	}
+
+	BUG();
+
+	return -1;
+}
+
+static void sh_pfc_setup_data_regs(struct sh_pfc *pfc)
+{
+	struct pinmux_data_reg *drp;
+	int k;
+
+	for (k = pfc->pdata->first_gpio; k <= pfc->pdata->last_gpio; k++)
+		sh_pfc_setup_data_reg(pfc, k);
+
+	k = 0;
+	while (1) {
+		drp = pfc->pdata->data_regs + k;
+
+		if (!drp->reg_width)
+			break;
+
+		drp->reg_shadow = sh_pfc_read_raw_reg(drp->mapped_reg,
+						      drp->reg_width);
+		k++;
+	}
+}
+
+int sh_pfc_get_data_reg(struct sh_pfc *pfc, unsigned gpio,
+			struct pinmux_data_reg **drp, int *bitp)
+{
+	struct pinmux_gpio *gpiop = &pfc->pdata->gpios[gpio];
+	int k, n;
+
+	if (!sh_pfc_enum_in_range(gpiop->enum_id, &pfc->pdata->data))
+		return -1;
+
+	k = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;
+	n = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;
+	*drp = pfc->pdata->data_regs + k;
+	*bitp = n;
+	return 0;
+}
+
+static int sh_pfc_get_config_reg(struct sh_pfc *pfc, pinmux_enum_t enum_id,
+				 struct pinmux_cfg_reg **crp, int *fieldp,
+				 int *valuep, unsigned long **cntp)
+{
+	struct pinmux_cfg_reg *config_reg;
+	unsigned long r_width, f_width, curr_width, ncomb;
+	int k, m, n, pos, bit_pos;
+
+	k = 0;
+	while (1) {
+		config_reg = pfc->pdata->cfg_regs + k;
+
+		r_width = config_reg->reg_width;
+		f_width = config_reg->field_width;
+
+		if (!r_width)
+			break;
+
+		pos = 0;
+		m = 0;
+		for (bit_pos = 0; bit_pos < r_width; bit_pos += curr_width) {
+			if (f_width)
+				curr_width = f_width;
+			else
+				curr_width = config_reg->var_field_width[m];
+
+			ncomb = 1 << curr_width;
+			for (n = 0; n < ncomb; n++) {
+				if (config_reg->enum_ids[pos + n] == enum_id) {
+					*crp = config_reg;
+					*fieldp = m;
+					*valuep = n;
+					*cntp = &config_reg->cnt[m];
+					return 0;
+				}
+			}
+			pos += ncomb;
+			m++;
+		}
+		k++;
+	}
+
+	return -1;
+}
+
+int sh_pfc_gpio_to_enum(struct sh_pfc *pfc, unsigned gpio, int pos,
+			pinmux_enum_t *enum_idp)
+{
+	pinmux_enum_t enum_id = pfc->pdata->gpios[gpio].enum_id;
+	pinmux_enum_t *data = pfc->pdata->gpio_data;
+	int k;
+
+	if (!sh_pfc_enum_in_range(enum_id, &pfc->pdata->data)) {
+		if (!sh_pfc_enum_in_range(enum_id, &pfc->pdata->mark)) {
+			pr_err("non data/mark enum_id for gpio %d\n", gpio);
+			return -1;
+		}
+	}
+
+	if (pos) {
+		*enum_idp = data[pos + 1];
+		return pos + 1;
+	}
+
+	for (k = 0; k < pfc->pdata->gpio_data_size; k++) {
+		if (data[k] == enum_id) {
+			*enum_idp = data[k + 1];
+			return k + 1;
+		}
+	}
+
+	pr_err("cannot locate data/mark enum_id for gpio %d\n", gpio);
+	return -1;
+}
+
+int sh_pfc_config_gpio(struct sh_pfc *pfc, unsigned gpio, int pinmux_type,
+		       int cfg_mode)
+{
+	struct pinmux_cfg_reg *cr = NULL;
+	pinmux_enum_t enum_id;
+	struct pinmux_range *range;
+	int in_range, pos, field, value;
+	unsigned long *cntp;
+
+	switch (pinmux_type) {
+
+	case PINMUX_TYPE_FUNCTION:
+		range = NULL;
+		break;
+
+	case PINMUX_TYPE_OUTPUT:
+		range = &pfc->pdata->output;
+		break;
+
+	case PINMUX_TYPE_INPUT:
+		range = &pfc->pdata->input;
+		break;
+
+	case PINMUX_TYPE_INPUT_PULLUP:
+		range = &pfc->pdata->input_pu;
+		break;
+
+	case PINMUX_TYPE_INPUT_PULLDOWN:
+		range = &pfc->pdata->input_pd;
+		break;
+
+	default:
+		goto out_err;
+	}
+
+	pos = 0;
+	enum_id = 0;
+	field = 0;
+	value = 0;
+	while (1) {
+		pos = sh_pfc_gpio_to_enum(pfc, gpio, pos, &enum_id);
+		if (pos <= 0)
+			goto out_err;
+
+		if (!enum_id)
+			break;
+
+		/* first check if this is a function enum */
+		in_range = sh_pfc_enum_in_range(enum_id, &pfc->pdata->function);
+		if (!in_range) {
+			/* not a function enum */
+			if (range) {
+				/*
+				 * other range exists, so this pin is
+				 * a regular GPIO pin that now is being
+				 * bound to a specific direction.
+				 *
+				 * for this case we only allow function enums
+				 * and the enums that match the other range.
+				 */
+				in_range = sh_pfc_enum_in_range(enum_id, range);
+
+				/*
+				 * special case pass through for fixed
+				 * input-only or output-only pins without
+				 * function enum register association.
+				 */
+				if (in_range && enum_id == range->force)
+					continue;
+			} else {
+				/*
+				 * no other range exists, so this pin
+				 * must then be of the function type.
+				 *
+				 * allow function type pins to select
+				 * any combination of function/in/out
+				 * in their MARK lists.
+				 */
+				in_range = 1;
+			}
+		}
+
+		if (!in_range)
+			continue;
+
+		if (sh_pfc_get_config_reg(pfc, enum_id, &cr,
+					  &field, &value, &cntp) != 0)
+			goto out_err;
+
+		switch (cfg_mode) {
+		case GPIO_CFG_DRYRUN:
+			if (!*cntp ||
+			    (sh_pfc_read_config_reg(pfc, cr, field) != value))
+				continue;
+			break;
+
+		case GPIO_CFG_REQ:
+			sh_pfc_write_config_reg(pfc, cr, field, value);
+			*cntp = *cntp + 1;
+			break;
+
+		case GPIO_CFG_FREE:
+			*cntp = *cntp - 1;
+			break;
+		}
+	}
+
+	return 0;
+ out_err:
+	return -1;
+}
+
+static int sh_pfc_probe(struct platform_device *pdev)
+{
+	struct sh_pfc_platform_data *pdata = pdev->dev.platform_data;
+	struct sh_pfc *pfc;
+	int ret;
+
+	/*
+	 * Ensure that the type encoding fits
+	 */
+	BUILD_BUG_ON(PINMUX_FLAG_TYPE > ((1 << PINMUX_FLAG_DBIT_SHIFT) - 1));
+
+	if (pdata == NULL)
+		return -ENODEV;
+
+	pfc = devm_kzalloc(&pdev->dev, sizeof(pfc), GFP_KERNEL);
+	if (pfc == NULL)
+		return -ENOMEM;
+
+	pfc->pdata = pdata;
+	pfc->dev = &pdev->dev;
+
+	ret = sh_pfc_ioremap(pfc, pdev);
+	if (unlikely(ret < 0))
+		return ret;
+
+	spin_lock_init(&pfc->lock);
+
+	pinctrl_provide_dummies();
+	sh_pfc_setup_data_regs(pfc);
+
+	/*
+	 * Initialize pinctrl bindings first
+	 */
+	ret = sh_pfc_register_pinctrl(pfc);
+	if (unlikely(ret != 0))
+		return ret;
+
+#ifdef CONFIG_GPIO_SH_PFC
+	/*
+	 * Then the GPIO chip
+	 */
+	ret = sh_pfc_register_gpiochip(pfc);
+	if (unlikely(ret != 0)) {
+		/*
+		 * If the GPIO chip fails to come up we still leave the
+		 * PFC state as it is, given that there are already
+		 * extant users of it that have succeeded by this point.
+		 */
+		pr_notice("failed to init GPIO chip, ignoring...\n");
+	}
+#endif
+
+	platform_set_drvdata(pdev, pfc);
+
+	pr_info("%s support registered\n", pdata->name);
+
+	return 0;
+}
+
+static int sh_pfc_remove(struct platform_device *pdev)
+{
+	struct sh_pfc *pfc = platform_get_drvdata(pdev);
+
+#ifdef CONFIG_GPIO_SH_PFC
+	sh_pfc_unregister_gpiochip(pfc);
+#endif
+	sh_pfc_unregister_pinctrl(pfc);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct platform_device_id sh_pfc_id_table[] = {
+	{ "sh-pfc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(platform, sh_pfc_id_table);
+
+static struct platform_driver sh_pfc_driver = {
+	.probe		= sh_pfc_probe,
+	.remove		= sh_pfc_remove,
+	.id_table	= sh_pfc_id_table,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init sh_pfc_init(void)
+{
+	return platform_driver_register(&sh_pfc_driver);
+}
+postcore_initcall(sh_pfc_init);
+
+static void __exit sh_pfc_exit(void)
+{
+	platform_driver_unregister(&sh_pfc_driver);
+}
+module_exit(sh_pfc_exit);
+
+MODULE_AUTHOR("Magnus Damm, Paul Mundt, Laurent Pinchart");
+MODULE_DESCRIPTION("Pin Control and GPIO driver for SuperH pin function controller");
+MODULE_LICENSE("GPL v2");
