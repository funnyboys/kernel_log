commit d71ffeb9f250a89fe477d9b3645f49680dc6c685
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Tue Apr 21 22:24:02 2020 +0800

    pinctrl: fix several typos
    
    use codespell to fix lots of typos over frontends.
    
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    CC: Andy Shevchenko <andy.shevchenko@gmail.com>
    Link: https://lore.kernel.org/r/20200421142402.9524-1-zhengdejin5@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index 786bf89487d6..80d00ab8c110 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -94,7 +94,7 @@ static int zx_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,
 	if (data->aon_pin) {
 		/*
 		 * It's an AON pin, whose mux register offset and bit position
-		 * can be caluculated from pin number.  Each register covers 16
+		 * can be calculated from pin number.  Each register covers 16
 		 * pins, and each pin occupies 2 bits.
 		 */
 		u16 aoffset = pindesc->number / 16 * 4;

commit 4b024225c4a8245e6ecc66ce1df1eaf2ebeb4acb
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon Nov 4 22:26:54 2019 +0800

    pinctrl: use devm_platform_ioremap_resource() to simplify code
    
    devm_platform_ioremap_resource() internally have platform_get_resource()
    and devm_ioremap_resource() in it. So instead of calling them separately
    use devm_platform_ioremap_resource() directly.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Link: https://lore.kernel.org/r/20191104142654.39256-1-yuehaibing@huawei.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index 9512045420ec..786bf89487d6 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -387,7 +387,6 @@ int zx_pinctrl_init(struct platform_device *pdev,
 	struct pinctrl_desc *pctldesc;
 	struct zx_pinctrl *zpctl;
 	struct device_node *np;
-	struct resource *res;
 	int ret;
 
 	zpctl = devm_kzalloc(&pdev->dev, sizeof(*zpctl), GFP_KERNEL);
@@ -396,8 +395,7 @@ int zx_pinctrl_init(struct platform_device *pdev,
 
 	spin_lock_init(&zpctl->lock);
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	zpctl->base = devm_ioremap_resource(&pdev->dev, res);
+	zpctl->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(zpctl->base))
 		return PTR_ERR(zpctl->base);
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index 3cb69309912b..9512045420ec 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2017 Sanechips Technology Co., Ltd.
  * Copyright 2017 Linaro Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/io.h>

commit 02d15f0d80720545f1f4922a1550ea4aaad4e152
Author: Wen Yang <wen.yang99@zte.com.cn>
Date:   Fri Apr 12 14:02:23 2019 +0800

    pinctrl: zte: fix leaked of_node references
    
    The call to of_parse_phandle returns a node pointer with refcount
    incremented thus it must be explicitly decremented after the last
    usage.
    
    Detected by coccinelle with the following warnings:
    ./drivers/pinctrl/zte/pinctrl-zx.c:415:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 407, but without a corresponding object release within this function.
    ./drivers/pinctrl/zte/pinctrl-zx.c:422:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 407, but without a corresponding object release within this function.
    ./drivers/pinctrl/zte/pinctrl-zx.c:436:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 407, but without a corresponding object release within this function.
    ./drivers/pinctrl/zte/pinctrl-zx.c:444:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 407, but without a corresponding object release within this function.
    ./drivers/pinctrl/zte/pinctrl-zx.c:448:1-7: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 407, but without a corresponding object release within this function.
    
    Signed-off-by: Wen Yang <wen.yang99@zte.com.cn>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jun Nie <jun.nie@linaro.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-gpio@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index caa44dd2880a..3cb69309912b 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -411,6 +411,7 @@ int zx_pinctrl_init(struct platform_device *pdev,
 	}
 
 	zpctl->aux_base = of_iomap(np, 0);
+	of_node_put(np);
 	if (!zpctl->aux_base)
 		return -ENOMEM;
 

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index ded366bb6564..caa44dd2880a 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -277,7 +277,7 @@ static int zx_pinctrl_build_state(struct platform_device *pdev)
 
 	/* Every single pin composes a group */
 	ngroups = info->npins;
-	groups = devm_kzalloc(&pdev->dev, ngroups * sizeof(*groups),
+	groups = devm_kcalloc(&pdev->dev, ngroups, sizeof(*groups),
 			      GFP_KERNEL);
 	if (!groups)
 		return -ENOMEM;
@@ -362,8 +362,8 @@ static int zx_pinctrl_build_state(struct platform_device *pdev)
 
 			func = functions + j;
 			if (!func->group_names) {
-				func->group_names = devm_kzalloc(&pdev->dev,
-						func->num_group_names *
+				func->group_names = devm_kcalloc(&pdev->dev,
+						func->num_group_names,
 						sizeof(*func->group_names),
 						GFP_KERNEL);
 				if (!func->group_names) {

commit bba2e8712602e2d8192f748f588910d1534e4baf
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sun Jul 16 21:33:28 2017 +0800

    pinctrl: zte: fix 'functions' allocation in zx_pinctrl_build_state()
    
    It fixes the following Smatch static check warning:
    
     drivers/pinctrl/zte/pinctrl-zx.c:338 zx_pinctrl_build_state()
     warn: passing devm_ allocated variable to kfree.
    
    As we will be calling krealloc() on pointer 'functions', which means
    kfree() will be called in there, devm_kzalloc() shouldn't be used with
    the allocation in the first place.  Fix the warning by calling kcalloc()
    and managing the free procedure in error path on our own.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Fixes: cbff0c4d27f4 ("pinctrl: add ZTE ZX pinctrl driver support")
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index f828ee340a98..ded366bb6564 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -295,8 +295,7 @@ static int zx_pinctrl_build_state(struct platform_device *pdev)
 	pctldev->num_groups = ngroups;
 
 	/* Build function list from pin mux functions */
-	functions = devm_kzalloc(&pdev->dev, info->npins * sizeof(*functions),
-				 GFP_KERNEL);
+	functions = kcalloc(info->npins, sizeof(*functions), GFP_KERNEL);
 	if (!functions)
 		return -ENOMEM;
 
@@ -367,8 +366,10 @@ static int zx_pinctrl_build_state(struct platform_device *pdev)
 						func->num_group_names *
 						sizeof(*func->group_names),
 						GFP_KERNEL);
-				if (!func->group_names)
+				if (!func->group_names) {
+					kfree(functions);
 					return -ENOMEM;
+				}
 			}
 
 			group = func->group_names;

commit b962e2cd357f2a529fe14387092401e6552f43d6
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jul 1 11:45:36 2017 +0800

    pinctrl: zte: fix dereference of 'data' in zx_set_mux()
    
    It fixes the following Smatch complaint:
    
    drivers/pinctrl/zte/pinctrl-zx.c:76 zx_set_mux()
    warn: variable dereferenced before check 'data' (see line 67)
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Fixes: cbff0c4d27f4 ("pinctrl: add ZTE ZX pinctrl driver support")
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index 787e3967bd5c..f828ee340a98 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -64,10 +64,8 @@ static int zx_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,
 	struct zx_pinctrl_soc_info *info = zpctl->info;
 	const struct pinctrl_pin_desc *pindesc = info->pins + group_selector;
 	struct zx_pin_data *data = pindesc->drv_data;
-	struct zx_mux_desc *mux = data->muxes;
-	u32 mask = (1 << data->width) - 1;
-	u32 offset = data->offset;
-	u32 bitpos = data->bitpos;
+	struct zx_mux_desc *mux;
+	u32 mask, offset, bitpos;
 	struct function_desc *func;
 	unsigned long flags;
 	u32 val, mval;
@@ -76,6 +74,11 @@ static int zx_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,
 	if (!data)
 		return -EINVAL;
 
+	mux = data->muxes;
+	mask = (1 << data->width) - 1;
+	offset = data->offset;
+	bitpos = data->bitpos;
+
 	func = pinmux_generic_get_function(pctldev, func_selector);
 	if (!func)
 		return -EINVAL;

commit 80fbc2d9b3e9796133470069fa1a10fe2a755a7a
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon May 22 21:59:35 2017 +0800

    pinctrl: zte: fix group_desc initialization
    
    There are a couple of issues with group_desc initialization in function
    zx_pinctrl_build_state().
    
     - num_pins is not initialized and remains zero.
     - pins shouldn't be initialized with a pointer to variable in the
       stack.
    
    With them fixed, pin_request() in pinmux_enable_setting() can be invoked
    correctly.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
index 2aca4e4b3f1c..787e3967bd5c 100644
--- a/drivers/pinctrl/zte/pinctrl-zx.c
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -282,10 +282,10 @@ static int zx_pinctrl_build_state(struct platform_device *pdev)
 	for (i = 0; i < ngroups; i++) {
 		const struct pinctrl_pin_desc *pindesc = info->pins + i;
 		struct group_desc *group = groups + i;
-		int id = pindesc->number;
 
 		group->name = pindesc->name;
-		group->pins = &id;
+		group->pins = (int *) &pindesc->number;
+		group->num_pins = 1;
 		radix_tree_insert(&pctldev->pin_group_tree, i, group);
 	}
 

commit cbff0c4d27f4f4b7dc11d137d51ac7b139a94d50
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon Apr 24 21:01:13 2017 +0800

    pinctrl: add ZTE ZX pinctrl driver support
    
    The pin controller on ZTE ZX platforms is kinda of hybrid.  It consists
    of a main controller and an auxiliary one.  For example, on ZX296718 SoC,
    the main controller is TOP_PMM and the auxiliary one is AON_IOCFG.  Both
    controllers work together to control pin multiplexing and configuration.
    
    For most of pins, the pinmux function is controlled by main controller
    only, and this type of pins are meant by term 'TOP pins'.  For other
    pins, the pinmux is controlled by both main and auxiliary controllers,
    as the available multiplexing functions for the pin spread in both
    controllers.  This type of pins are called 'AON pins'.  Though pinmux
    implementation is quite different, pinconf is same for both types of
    pins.  Both are controlled by auxiliary controller, i.e. AON_IOCFG on
    ZX296718.
    
    The patch adds the ZTE ZX core pinctrl driver to support this hybrid
    pin controller as well as ZX296718 SoC specific pin data.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/zte/pinctrl-zx.c b/drivers/pinctrl/zte/pinctrl-zx.c
new file mode 100644
index 000000000000..2aca4e4b3f1c
--- /dev/null
+++ b/drivers/pinctrl/zte/pinctrl-zx.c
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2017 Sanechips Technology Co., Ltd.
+ * Copyright 2017 Linaro Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include "../core.h"
+#include "../pinctrl-utils.h"
+#include "../pinmux.h"
+#include "pinctrl-zx.h"
+
+#define ZX_PULL_DOWN		BIT(0)
+#define ZX_PULL_UP		BIT(1)
+#define ZX_INPUT_ENABLE		BIT(3)
+#define ZX_DS_SHIFT		4
+#define ZX_DS_MASK		(0x7 << ZX_DS_SHIFT)
+#define ZX_DS_VALUE(x)		(((x) << ZX_DS_SHIFT) & ZX_DS_MASK)
+#define ZX_SLEW			BIT(8)
+
+struct zx_pinctrl {
+	struct pinctrl_dev *pctldev;
+	struct device *dev;
+	void __iomem *base;
+	void __iomem *aux_base;
+	spinlock_t lock;
+	struct zx_pinctrl_soc_info *info;
+};
+
+static int zx_dt_node_to_map(struct pinctrl_dev *pctldev,
+			     struct device_node *np_config,
+			     struct pinctrl_map **map, u32 *num_maps)
+{
+	return pinconf_generic_dt_node_to_map(pctldev, np_config, map,
+					      num_maps, PIN_MAP_TYPE_INVALID);
+}
+
+static const struct pinctrl_ops zx_pinctrl_ops = {
+	.dt_node_to_map = zx_dt_node_to_map,
+	.dt_free_map = pinctrl_utils_free_map,
+	.get_groups_count = pinctrl_generic_get_group_count,
+	.get_group_name = pinctrl_generic_get_group_name,
+	.get_group_pins = pinctrl_generic_get_group_pins,
+};
+
+#define NONAON_MVAL 2
+
+static int zx_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,
+		      unsigned int group_selector)
+{
+	struct zx_pinctrl *zpctl = pinctrl_dev_get_drvdata(pctldev);
+	struct zx_pinctrl_soc_info *info = zpctl->info;
+	const struct pinctrl_pin_desc *pindesc = info->pins + group_selector;
+	struct zx_pin_data *data = pindesc->drv_data;
+	struct zx_mux_desc *mux = data->muxes;
+	u32 mask = (1 << data->width) - 1;
+	u32 offset = data->offset;
+	u32 bitpos = data->bitpos;
+	struct function_desc *func;
+	unsigned long flags;
+	u32 val, mval;
+
+	/* Skip reserved pin */
+	if (!data)
+		return -EINVAL;
+
+	func = pinmux_generic_get_function(pctldev, func_selector);
+	if (!func)
+		return -EINVAL;
+
+	while (mux->name) {
+		if (strcmp(mux->name, func->name) == 0)
+			break;
+		mux++;
+	}
+
+	/* Found mux value to be written */
+	mval = mux->muxval;
+
+	spin_lock_irqsave(&zpctl->lock, flags);
+
+	if (data->aon_pin) {
+		/*
+		 * It's an AON pin, whose mux register offset and bit position
+		 * can be caluculated from pin number.  Each register covers 16
+		 * pins, and each pin occupies 2 bits.
+		 */
+		u16 aoffset = pindesc->number / 16 * 4;
+		u16 abitpos = (pindesc->number % 16) * 2;
+
+		if (mval & AON_MUX_FLAG) {
+			/*
+			 * This is a mux value that needs to be written into
+			 * AON pinmux register.  Write it and then we're done.
+			 */
+			val = readl(zpctl->aux_base + aoffset);
+			val &= ~(0x3 << abitpos);
+			val |= (mval & 0x3) << abitpos;
+			writel(val, zpctl->aux_base + aoffset);
+		} else {
+			/*
+			 * It's a mux value that needs to be written into TOP
+			 * pinmux register.
+			 */
+			val = readl(zpctl->base + offset);
+			val &= ~(mask << bitpos);
+			val |= (mval & mask) << bitpos;
+			writel(val, zpctl->base + offset);
+
+			/*
+			 * In this case, the AON pinmux register needs to be
+			 * set up to select non-AON function.
+			 */
+			val = readl(zpctl->aux_base + aoffset);
+			val &= ~(0x3 << abitpos);
+			val |= NONAON_MVAL << abitpos;
+			writel(val, zpctl->aux_base + aoffset);
+		}
+
+	} else {
+		/*
+		 * This is a TOP pin, and we only need to set up TOP pinmux
+		 * register and then we're done with it.
+		 */
+		val = readl(zpctl->base + offset);
+		val &= ~(mask << bitpos);
+		val |= (mval & mask) << bitpos;
+		writel(val, zpctl->base + offset);
+	}
+
+	spin_unlock_irqrestore(&zpctl->lock, flags);
+
+	return 0;
+}
+
+static const struct pinmux_ops zx_pinmux_ops = {
+	.get_functions_count = pinmux_generic_get_function_count,
+	.get_function_name = pinmux_generic_get_function_name,
+	.get_function_groups = pinmux_generic_get_function_groups,
+	.set_mux = zx_set_mux,
+};
+
+static int zx_pin_config_get(struct pinctrl_dev *pctldev, unsigned int pin,
+			     unsigned long *config)
+{
+	struct zx_pinctrl *zpctl = pinctrl_dev_get_drvdata(pctldev);
+	struct zx_pinctrl_soc_info *info = zpctl->info;
+	const struct pinctrl_pin_desc *pindesc = info->pins + pin;
+	struct zx_pin_data *data = pindesc->drv_data;
+	enum pin_config_param param = pinconf_to_config_param(*config);
+	u32 val;
+
+	/* Skip reserved pin */
+	if (!data)
+		return -EINVAL;
+
+	val = readl(zpctl->aux_base + data->coffset);
+	val = val >> data->cbitpos;
+
+	switch (param) {
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		val &= ZX_PULL_DOWN;
+		val = !!val;
+		if (val == 0)
+			return -EINVAL;
+		break;
+	case PIN_CONFIG_BIAS_PULL_UP:
+		val &= ZX_PULL_UP;
+		val = !!val;
+		if (val == 0)
+			return -EINVAL;
+		break;
+	case PIN_CONFIG_INPUT_ENABLE:
+		val &= ZX_INPUT_ENABLE;
+		val = !!val;
+		if (val == 0)
+			return -EINVAL;
+		break;
+	case PIN_CONFIG_DRIVE_STRENGTH:
+		val &= ZX_DS_MASK;
+		val = val >> ZX_DS_SHIFT;
+		break;
+	case PIN_CONFIG_SLEW_RATE:
+		val &= ZX_SLEW;
+		val = !!val;
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, val);
+
+	return 0;
+}
+
+static int zx_pin_config_set(struct pinctrl_dev *pctldev, unsigned int pin,
+			     unsigned long *configs, unsigned int num_configs)
+{
+	struct zx_pinctrl *zpctl = pinctrl_dev_get_drvdata(pctldev);
+	struct zx_pinctrl_soc_info *info = zpctl->info;
+	const struct pinctrl_pin_desc *pindesc = info->pins + pin;
+	struct zx_pin_data *data = pindesc->drv_data;
+	enum pin_config_param param;
+	u32 val, arg;
+	int i;
+
+	/* Skip reserved pin */
+	if (!data)
+		return -EINVAL;
+
+	val = readl(zpctl->aux_base + data->coffset);
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			val |= ZX_PULL_DOWN << data->cbitpos;
+			break;
+		case PIN_CONFIG_BIAS_PULL_UP:
+			val |= ZX_PULL_UP << data->cbitpos;
+			break;
+		case PIN_CONFIG_INPUT_ENABLE:
+			val |= ZX_INPUT_ENABLE << data->cbitpos;
+			break;
+		case PIN_CONFIG_DRIVE_STRENGTH:
+			val &= ~(ZX_DS_MASK << data->cbitpos);
+			val |= ZX_DS_VALUE(arg) << data->cbitpos;
+			break;
+		case PIN_CONFIG_SLEW_RATE:
+			if (arg)
+				val |= ZX_SLEW << data->cbitpos;
+			else
+				val &= ~ZX_SLEW << data->cbitpos;
+			break;
+		default:
+			return -ENOTSUPP;
+		}
+	}
+
+	writel(val, zpctl->aux_base + data->coffset);
+	return 0;
+}
+
+static const struct pinconf_ops zx_pinconf_ops = {
+	.pin_config_set = zx_pin_config_set,
+	.pin_config_get = zx_pin_config_get,
+	.is_generic = true,
+};
+
+static int zx_pinctrl_build_state(struct platform_device *pdev)
+{
+	struct zx_pinctrl *zpctl = platform_get_drvdata(pdev);
+	struct zx_pinctrl_soc_info *info = zpctl->info;
+	struct pinctrl_dev *pctldev = zpctl->pctldev;
+	struct function_desc *functions;
+	int nfunctions;
+	struct group_desc *groups;
+	int ngroups;
+	int i;
+
+	/* Every single pin composes a group */
+	ngroups = info->npins;
+	groups = devm_kzalloc(&pdev->dev, ngroups * sizeof(*groups),
+			      GFP_KERNEL);
+	if (!groups)
+		return -ENOMEM;
+
+	for (i = 0; i < ngroups; i++) {
+		const struct pinctrl_pin_desc *pindesc = info->pins + i;
+		struct group_desc *group = groups + i;
+		int id = pindesc->number;
+
+		group->name = pindesc->name;
+		group->pins = &id;
+		radix_tree_insert(&pctldev->pin_group_tree, i, group);
+	}
+
+	pctldev->num_groups = ngroups;
+
+	/* Build function list from pin mux functions */
+	functions = devm_kzalloc(&pdev->dev, info->npins * sizeof(*functions),
+				 GFP_KERNEL);
+	if (!functions)
+		return -ENOMEM;
+
+	nfunctions = 0;
+	for (i = 0; i < info->npins; i++) {
+		const struct pinctrl_pin_desc *pindesc = info->pins + i;
+		struct zx_pin_data *data = pindesc->drv_data;
+		struct zx_mux_desc *mux;
+
+		/* Reserved pins do not have a drv_data at all */
+		if (!data)
+			continue;
+
+		/* Loop over all muxes for the pin */
+		mux = data->muxes;
+		while (mux->name) {
+			struct function_desc *func = functions;
+
+			/* Search function list for given mux */
+			while (func->name) {
+				if (strcmp(mux->name, func->name) == 0) {
+					/* Function exists */
+					func->num_group_names++;
+					break;
+				}
+				func++;
+			}
+
+			if (!func->name) {
+				/* New function */
+				func->name = mux->name;
+				func->num_group_names = 1;
+				radix_tree_insert(&pctldev->pin_function_tree,
+						  nfunctions++, func);
+			}
+
+			mux++;
+		}
+	}
+
+	pctldev->num_functions = nfunctions;
+	functions = krealloc(functions, nfunctions * sizeof(*functions),
+			     GFP_KERNEL);
+
+	/* Find pin groups for every single function */
+	for (i = 0; i < info->npins; i++) {
+		const struct pinctrl_pin_desc *pindesc = info->pins + i;
+		struct zx_pin_data *data = pindesc->drv_data;
+		struct zx_mux_desc *mux;
+
+		if (!data)
+			continue;
+
+		mux = data->muxes;
+		while (mux->name) {
+			struct function_desc *func;
+			const char **group;
+			int j;
+
+			/* Find function for given mux */
+			for (j = 0; j < nfunctions; j++)
+				if (strcmp(functions[j].name, mux->name) == 0)
+					break;
+
+			func = functions + j;
+			if (!func->group_names) {
+				func->group_names = devm_kzalloc(&pdev->dev,
+						func->num_group_names *
+						sizeof(*func->group_names),
+						GFP_KERNEL);
+				if (!func->group_names)
+					return -ENOMEM;
+			}
+
+			group = func->group_names;
+			while (*group)
+				group++;
+			*group = pindesc->name;
+
+			mux++;
+		}
+	}
+
+	return 0;
+}
+
+int zx_pinctrl_init(struct platform_device *pdev,
+		    struct zx_pinctrl_soc_info *info)
+{
+	struct pinctrl_desc *pctldesc;
+	struct zx_pinctrl *zpctl;
+	struct device_node *np;
+	struct resource *res;
+	int ret;
+
+	zpctl = devm_kzalloc(&pdev->dev, sizeof(*zpctl), GFP_KERNEL);
+	if (!zpctl)
+		return -ENOMEM;
+
+	spin_lock_init(&zpctl->lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	zpctl->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(zpctl->base))
+		return PTR_ERR(zpctl->base);
+
+	np = of_parse_phandle(pdev->dev.of_node, "zte,auxiliary-controller", 0);
+	if (!np) {
+		dev_err(&pdev->dev, "failed to find auxiliary controller\n");
+		return -ENODEV;
+	}
+
+	zpctl->aux_base = of_iomap(np, 0);
+	if (!zpctl->aux_base)
+		return -ENOMEM;
+
+	zpctl->dev = &pdev->dev;
+	zpctl->info = info;
+
+	pctldesc = devm_kzalloc(&pdev->dev, sizeof(*pctldesc), GFP_KERNEL);
+	if (!pctldesc)
+		return -ENOMEM;
+
+	pctldesc->name = dev_name(&pdev->dev);
+	pctldesc->owner = THIS_MODULE;
+	pctldesc->pins = info->pins;
+	pctldesc->npins = info->npins;
+	pctldesc->pctlops = &zx_pinctrl_ops;
+	pctldesc->pmxops = &zx_pinmux_ops;
+	pctldesc->confops = &zx_pinconf_ops;
+
+	zpctl->pctldev = devm_pinctrl_register(&pdev->dev, pctldesc, zpctl);
+	if (IS_ERR(zpctl->pctldev)) {
+		ret = PTR_ERR(zpctl->pctldev);
+		dev_err(&pdev->dev, "failed to register pinctrl: %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, zpctl);
+
+	ret = zx_pinctrl_build_state(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to build state: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "initialized pinctrl driver\n");
+	return 0;
+}
