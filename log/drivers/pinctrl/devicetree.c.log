commit 828907ef25e0133f50c346ef5a3c79a707a9b100
Merge: 6f43bae38269 4ed7d7dd4890
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 4 10:27:00 2020 -0700

    Merge tag 'gpio-v5.7-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO development for the v5.7 kernel cycle.
    
      Core and userspace API:
    
       - The userspace API KFIFOs have been imoproved with locks that do not
         block interrupts. This makes us better at getting events to
         userspace without blocking or disturbing new events arriving in the
         same time. This was reviewed by the KFIFO maintainer Stefani. This
         is a generic improvement which paves the road for similar
         improvements in other subsystems.
    
       - We provide a new ioctl() for monitoring changes in the line
         information, such as when multiple clients are taking lines and
         giving them back, possibly reconfiguring them in the process: we
         can now monitor that and not get stuck with stale static
         information.
    
       - An example tool 'gpio-watch' is provided to showcase this
         functionality.
    
       - Timestamps for events are switched to ktime_get_ns() which is
         monotonic. We previously had a 'realtime' stamp which could move
         forward and *backward* in time, which probably would just cause
         silent bugs and weird behaviour. In the long run we see two
         relevant timestamps: ktime_get_ns() or the timestamp sometimes
         provided by the GPIO hardware itself, if that exists.
    
       - Device Tree overlay support for GPIO hogs. On systems that load
         overlays, these overlays can now contain hogs, and will then be
         respected.
    
       - Handle pin control interaction with nonexisting pin ranges in the
         GPIO library core instead of in the individual drivers.
    
      New drivers:
    
       - New driver for the Mellanox BlueField 2 GPIO controller.
    
      Driver improvements:
    
       - Introduce the BGPIOF_NO_SET_ON_INPUT flag to the generic MMIO GPIO
         library and use this flag in the MT7621 driver.
    
       - Texas Instruments OMAP CPU power management improvements, such as
         blocking of idle on pending GPIO interrupts"
    
    * tag 'gpio-v5.7-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (59 commits)
      Revert "gpio: eic-sprd: Use devm_platform_ioremap_resource()"
      pinctrl: Unconditionally assign .request()/.free()
      gpio: Unconditionally assign .request()/.free()
      gpio: export of_pinctrl_get to modules
      pinctrl: Define of_pinctrl_get() dummy for !PINCTRL
      gpio: Rename variable in core APIs
      gpio: Avoid using pin ranges with !PINCTRL
      gpiolib: Remove unused gpio_chip parameter from gpio_set_bias()
      gpiolib: Pass gpio_desc to gpio_set_config()
      gpiolib: Introduce gpiod_set_config()
      tools: gpio: Fix out-of-tree build regression
      gpio: gpiolib: fix a doc warning
      gpio: tegra186: Add Tegra194 pin ranges for GG.0 and GG.1
      gpio: tegra186: Add support for pin ranges
      gpio: Support GPIO controllers without pin-ranges
      ARM: integrator: impd1: Use GPIO_LOOKUP() helper macro
      gpio: brcmstb: support gpio-line-names property
      tools: gpio: Fix typo in gpio-utils
      tools: gpio-hammer: Apply scripts/Lindent and retain good changes
      gpiolib: gpio_name_to_desc: factor out !name check
      ...

commit 33dd888263199676946f1c789e821d39a9a79d98
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Apr 1 15:19:04 2020 +1100

    gpio: export of_pinctrl_get to modules
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Link: https://lore.kernel.org/r/20200401151904.6948af20@canb.auug.org.au
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 9357f7c46cf3..01f71258f727 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -103,6 +103,7 @@ struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 {
 	return get_pinctrl_dev_from_of_node(np);
 }
+EXPORT_SYMBOL_GPL(of_pinctrl_get);
 
 static int dt_to_map_one_config(struct pinctrl *p,
 				struct pinctrl_dev *hog_pctldev,

commit bec6c0ecb24373077b4e2f3661a32eb6f022e9a6
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 25 05:08:25 2020 +0000

    pinctrl: Remove use of driver_deferred_probe_check_state_continue()
    
    With the earlier sanity fixes to
    driver_deferred_probe_check_state() it should be usable for the
    pinctrl logic here.
    
    So tweak the logic to use driver_deferred_probe_check_state()
    instead of driver_deferred_probe_check_state_continue()
    
    Cc: linux-pm@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200225050828.56458-4-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 9357f7c46cf3..1ed20ac2243f 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -127,11 +127,12 @@ static int dt_to_map_one_config(struct pinctrl *p,
 		np_pctldev = of_get_next_parent(np_pctldev);
 		if (!np_pctldev || of_node_is_root(np_pctldev)) {
 			of_node_put(np_pctldev);
+			ret = driver_deferred_probe_check_state(p->dev);
 			/* keep deferring if modules are enabled unless we've timed out */
-			if (IS_ENABLED(CONFIG_MODULES) && !allow_default)
-				return driver_deferred_probe_check_state_continue(p->dev);
-
-			return driver_deferred_probe_check_state(p->dev);
+			if (IS_ENABLED(CONFIG_MODULES) && !allow_default &&
+			    (ret == -ENODEV))
+				ret = -EPROBE_DEFER;
+			return ret;
 		}
 		/* If we're creating a hog we can use the passed pctldev */
 		if (hog_pctldev && (np_pctldev == p->dev->of_node)) {

commit c72bed23b9e45accdeab626cf2cb2bd08d846f3e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Dec 16 21:51:18 2019 +0100

    pinctrl: Allow modules to use pinctrl_[un]register_mappings
    
    Currently only the drivers/pinctrl/devicetree.c code allows registering
    pinctrl-mappings which may later be unregistered, all other mappings
    are assumed to be permanent.
    
    Non-dt platforms may also want to register pinctrl mappings from code which
    is build as a module, which requires being able to unregister the mapping
    when the module is unloaded to avoid dangling pointers.
    
    To allow unregistering the mappings the devicetree code uses 2 internal
    functions: pinctrl_register_map and pinctrl_unregister_map.
    
    pinctrl_register_map allows the devicetree code to tell the core to
    not memdup the mappings as it retains ownership of them and
    pinctrl_unregister_map does the unregistering, note this only works
    when the mappings where not memdupped.
    
    The only code relying on the memdup/shallow-copy done by
    pinctrl_register_mappings is arch/arm/mach-u300/core.c this commit
    replaces the __initdata with const, so that the shallow-copy is no
    longer necessary.
    
    After that we can get rid of the internal pinctrl_unregister_map function
    and just use pinctrl_register_mappings directly everywhere.
    
    This commit also renames pinctrl_unregister_map to
    pinctrl_unregister_mappings so that its naming matches its
    pinctrl_register_mappings counter-part and exports it.
    
    Together these 2 changes will allow non-dt platform code to
    register pinctrl-mappings from modules without breaking things on
    module unload (as they can now unregister the mapping on unload).
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20191216205122.1850923-2-hdegoede@redhat.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 674920daac26..9357f7c46cf3 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -51,7 +51,7 @@ void pinctrl_dt_free_maps(struct pinctrl *p)
 	struct pinctrl_dt_map *dt_map, *n1;
 
 	list_for_each_entry_safe(dt_map, n1, &p->dt_maps, node) {
-		pinctrl_unregister_map(dt_map->map);
+		pinctrl_unregister_mappings(dt_map->map);
 		list_del(&dt_map->node);
 		dt_free_map(dt_map->pctldev, dt_map->map,
 			    dt_map->num_maps);
@@ -92,7 +92,7 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 	dt_map->num_maps = num_maps;
 	list_add_tail(&dt_map->node, &p->dt_maps);
 
-	return pinctrl_register_map(map, num_maps, false);
+	return pinctrl_register_mappings(map, num_maps);
 
 err_free_map:
 	dt_free_map(pctldev, map, num_maps);

commit 6e4f3db8dfcf6c4126232086251a31db364503e1
Author: lijiazi <jqqlijiazi@gmail.com>
Date:   Fri Nov 1 19:43:52 2019 +0800

    pinctrl: just return if no valid maps
    
    If there is a problem with a pinctrl node of a device,
    for example, config child node do not have prop specified in
    dt_params, num_maps maybe 0. On this condition, no need remember
    this map.
    
    Signed-off-by: lijiazi <lijiazi@xiaomi.com>
    Link: https://lore.kernel.org/r/29421e7720443a2454830963186f00583c76ce1e.1572588550.git.lijiazi@xiaomi.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 1a300374a16d..674920daac26 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -162,6 +162,16 @@ static int dt_to_map_one_config(struct pinctrl *p,
 	ret = ops->dt_node_to_map(pctldev, np_config, &map, &num_maps);
 	if (ret < 0)
 		return ret;
+	else if (num_maps == 0) {
+		/*
+		 * If we have no valid maps (maybe caused by empty pinctrl node
+		 * or typing error) ther is no need remember this, so just
+		 * return.
+		 */
+		dev_info(p->dev,
+			 "there is not valid maps for state %s\n", statename);
+		return 0;
+	}
 
 	/* Stash the mapping table chunk away for later use */
 	return dt_remember_or_free_map(p, statename, pctldev, map, num_maps);

commit 037699139ecb223c2eb7206f21cfb06f2812fd8c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Mon Sep 23 16:20:05 2019 +0200

    pinctrl: devicetree.c: remove orphan pinctrl_dt_has_hogs()
    
    The helper pinctrl_dt_has_hogs() was introduced in
    99e4f67508e1 (pinctrl: core: Use delayed work for hogs), but the sole
    use then got removed shortly after in 950b0d91dc10 (pinctrl: core: Fix
    regression caused by delayed work for hogs).
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Link: https://lore.kernel.org/r/20190923142005.5632-1-linux@rasmusvillemoes.dk
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index dbaacde1b36a..1a300374a16d 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -181,21 +181,6 @@ static int dt_remember_dummy_state(struct pinctrl *p, const char *statename)
 	return dt_remember_or_free_map(p, statename, NULL, map, 1);
 }
 
-bool pinctrl_dt_has_hogs(struct pinctrl_dev *pctldev)
-{
-	struct device_node *np;
-	struct property *prop;
-	int size;
-
-	np = pctldev->dev->of_node;
-	if (!np)
-		return false;
-
-	prop = of_find_property(np, "pinctrl-0", &size);
-
-	return prop ? true : false;
-}
-
 int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)
 {
 	struct device_node *np = p->dev->of_node;

commit be4c60b563edee3712d392aaeb0943a768df7023
Author: Will Deacon <will@kernel.org>
Date:   Wed Oct 2 13:42:06 2019 +0100

    pinctrl: devicetree: Avoid taking direct reference to device name string
    
    When populating the pinctrl mapping table entries for a device, the
    'dev_name' field for each entry is initialised to point directly at the
    string returned by 'dev_name()' for the device and subsequently used by
    'create_pinctrl()' when looking up the mappings for the device being
    probed.
    
    This is unreliable in the presence of calls to 'dev_set_name()', which may
    reallocate the device name string leaving the pinctrl mappings with a
    dangling reference. This then leads to a use-after-free every time the
    name is dereferenced by a device probe:
    
      | BUG: KASAN: invalid-access in strcmp+0x20/0x64
      | Read of size 1 at addr 13ffffc153494b00 by task modprobe/590
      | Pointer tag: [13], memory tag: [fe]
      |
      | Call trace:
      |  __kasan_report+0x16c/0x1dc
      |  kasan_report+0x10/0x18
      |  check_memory_region
      |  __hwasan_load1_noabort+0x4c/0x54
      |  strcmp+0x20/0x64
      |  create_pinctrl+0x18c/0x7f4
      |  pinctrl_get+0x90/0x114
      |  devm_pinctrl_get+0x44/0x98
      |  pinctrl_bind_pins+0x5c/0x450
      |  really_probe+0x1c8/0x9a4
      |  driver_probe_device+0x120/0x1d8
    
    Follow the example of sysfs, and duplicate the device name string before
    stashing it away in the pinctrl mapping entries.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Reported-by: Elena Petrova <lenaptr@google.com>
    Tested-by: Elena Petrova <lenaptr@google.com>
    Signed-off-by: Will Deacon <will@kernel.org>
    Link: https://lore.kernel.org/r/20191002124206.22928-1-will@kernel.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 5d6d8b1e9062..dbaacde1b36a 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -29,6 +29,13 @@ struct pinctrl_dt_map {
 static void dt_free_map(struct pinctrl_dev *pctldev,
 		     struct pinctrl_map *map, unsigned num_maps)
 {
+	int i;
+
+	for (i = 0; i < num_maps; ++i) {
+		kfree_const(map[i].dev_name);
+		map[i].dev_name = NULL;
+	}
+
 	if (pctldev) {
 		const struct pinctrl_ops *ops = pctldev->desc->pctlops;
 		if (ops->dt_free_map)
@@ -63,7 +70,13 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 
 	/* Initialize common mapping table entry fields */
 	for (i = 0; i < num_maps; i++) {
-		map[i].dev_name = dev_name(p->dev);
+		const char *devname;
+
+		devname = kstrdup_const(dev_name(p->dev), GFP_KERNEL);
+		if (!devname)
+			goto err_free_map;
+
+		map[i].dev_name = devname;
 		map[i].name = statename;
 		if (pctldev)
 			map[i].ctrl_dev_name = dev_name(pctldev->dev);
@@ -71,10 +84,8 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 
 	/* Remember the converted mapping table entries */
 	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
-	if (!dt_map) {
-		dt_free_map(pctldev, map, num_maps);
-		return -ENOMEM;
-	}
+	if (!dt_map)
+		goto err_free_map;
 
 	dt_map->pctldev = pctldev;
 	dt_map->map = map;
@@ -82,6 +93,10 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 	list_add_tail(&dt_map->node, &p->dt_maps);
 
 	return pinctrl_register_map(map, num_maps, false);
+
+err_free_map:
+	dt_free_map(pctldev, map, num_maps);
+	return -ENOMEM;
 }
 
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)

commit f0b0e923e07aa3efd3d5db0bd6ff421bd9a9a0d4
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jul 31 15:29:15 2019 +0200

    pinctrl: devicetree: Use strlen() instead of hardcoded number
    
    Improve readability by replacing a hardcoded number requiring a comment
    by strlen().
    
    Gcc is smart enough to evaluate the length of a constant string at
    compile-time.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20190731132917.17607-2-geert+renesas@glider.be
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 88ddbb2e30de..5d6d8b1e9062 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -228,10 +228,8 @@ int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)
 		 * than dynamically allocate it and have to free it later,
 		 * just point part way into the property name for the string.
 		 */
-		if (ret < 0) {
-			/* strlen("pinctrl-") == 8 */
-			statename = prop->name + 8;
-		}
+		if (ret < 0)
+			statename = prop->name + strlen("pinctrl-");
 
 		/* For every referenced pin configuration node in it */
 		for (config = 0; config < size; config++) {

commit 62a6bc3a1e4f4ee9ae0076fa295f9af1c3725ce3
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jun 21 17:17:25 2019 +0200

    driver: core: Allow subsystems to continue deferring probe
    
    Some subsystems, such as pinctrl, allow continuing to defer probe
    indefinitely. This is useful for devices that depend on resources
    provided by devices that are only probed after the init stage.
    
    One example of this can be seen on Tegra, where the DPAUX hardware
    contains pinmuxing controls for pins that it shares with an I2C
    controller. The I2C controller is typically used for communication
    with a monitor over HDMI (DDC). However, other instances of the I2C
    controller are used to access system critical components, such as a
    PMIC. The I2C controller driver will therefore usually be a builtin
    driver, whereas the DPAUX driver is part of the display driver that
    is loaded from a module to avoid bloating the kernel image with all
    of the DRM/KMS subsystem.
    
    In this particular case the pins used by this I2C/DDC controller
    become accessible very late in the boot process. However, since the
    controller is only used in conjunction with display, that's not an
    issue.
    
    Unfortunately the driver core currently outputs a warning message
    when a device fails to get the pinctrl before the end of the init
    stage. That can be confusing for the user because it may sound like
    an unwanted error occurred, whereas it's really an expected and
    harmless situation.
    
    In order to eliminate this warning, this patch allows callers of the
    driver_deferred_probe_check_state() helper to specify that they want
    to continue deferring probe, regardless of whether we're past the
    init stage or not. All of the callers of that function are updated
    for the new signature, but only the pinctrl subsystem passes a true
    value in the new persist parameter if appropriate.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190621151725.20414-1-thierry.reding@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index f7e354f85518..88ddbb2e30de 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -112,12 +112,11 @@ static int dt_to_map_one_config(struct pinctrl *p,
 		np_pctldev = of_get_next_parent(np_pctldev);
 		if (!np_pctldev || of_node_is_root(np_pctldev)) {
 			of_node_put(np_pctldev);
-			ret = driver_deferred_probe_check_state(p->dev);
 			/* keep deferring if modules are enabled unless we've timed out */
-			if (IS_ENABLED(CONFIG_MODULES) && !allow_default && ret == -ENODEV)
-				ret = -EPROBE_DEFER;
+			if (IS_ENABLED(CONFIG_MODULES) && !allow_default)
+				return driver_deferred_probe_check_state_continue(p->dev);
 
-			return ret;
+			return driver_deferred_probe_check_state(p->dev);
 		}
 		/* If we're creating a hog we can use the passed pctldev */
 		if (hog_pctldev && (np_pctldev == p->dev->of_node)) {

commit 9952f6918daa4ab5fc81307a9f90e31a4df3b200
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:04 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 201
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 228 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.107155473@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 2969ff3162c3..f7e354f85518 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Device tree integration for the pin control subsystem
  *
  * Copyright (C) 2012 NVIDIA CORPORATION. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/device.h>

commit d19c5e79d46efdf89306be99f3c8824cf58e35f6
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 9 09:41:50 2018 -0600

    pinctrl: Support stopping deferred probe after initcalls
    
    Pinctrl drivers are a common dependency which can prevent a system
    booting even if the default or bootloader configured settings can work.
    If a pinctrl node in DT indicates that the default pin setup can be used
    with the 'pinctrl-use-default' property, then only defer probe until
    initcalls are done. If the deferred probe timeout is enabled or loadable
    modules are disabled, then we'll stop deferring probe regardless of the
    DT property. This gives platforms the option to work without their
    pinctrl driver being enabled.
    
    Dropped the pinctrl specific deferring probe message as the driver core
    can print deferred probe related messages if needed.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index c4aa411f5935..2969ff3162c3 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -111,17 +111,24 @@ static int dt_to_map_one_config(struct pinctrl *p,
 	int ret;
 	struct pinctrl_map *map;
 	unsigned num_maps;
+	bool allow_default = false;
 
 	/* Find the pin controller containing np_config */
 	np_pctldev = of_node_get(np_config);
 	for (;;) {
+		if (!allow_default)
+			allow_default = of_property_read_bool(np_pctldev,
+							      "pinctrl-use-default");
+
 		np_pctldev = of_get_next_parent(np_pctldev);
 		if (!np_pctldev || of_node_is_root(np_pctldev)) {
-			dev_info(p->dev, "could not find pctldev for node %pOF, deferring probe\n",
-				np_config);
 			of_node_put(np_pctldev);
-			/* OK let's just assume this will appear later then */
-			return -EPROBE_DEFER;
+			ret = driver_deferred_probe_check_state(p->dev);
+			/* keep deferring if modules are enabled unless we've timed out */
+			if (IS_ENABLED(CONFIG_MODULES) && !allow_default && ret == -ENODEV)
+				ret = -EPROBE_DEFER;
+
+			return ret;
 		}
 		/* If we're creating a hog we can use the passed pctldev */
 		if (hog_pctldev && (np_pctldev == p->dev->of_node)) {

commit bc3322bc166a2905bc91f774d7b22773dc7c063a
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Thu Jun 7 13:51:33 2018 -0300

    pinctrl: devicetree: Fix pctldev pointer overwrite
    
    Commit b89405b6102f ("pinctrl: devicetree: Fix dt_to_map_one_config
    handling of hogs") causes the pinctrl hog pins to not get initialized
    on i.MX platforms leaving them with the IOMUX settings untouched.
    
    This causes several regressions on i.MX such as:
    
    - OV5640 camera driver can not be probed anymore on imx6qdl-sabresd
    because the camera clock pin is in a pinctrl_hog group and since
    its pinctrl initialization is skipped, the camera clock is kept
    in GPIO functionality instead of CLK_CKO function.
    
    - Audio stopped working on imx6qdl-wandboard and imx53-qsb for
    the same reason.
    
    Richard Fitzgerald explains the problem:
    
    "I see the bug. If the hog node isn't a 1st level child of the pinctrl
    parent node it will go around the for(;;) loop again but on the first
    pass I overwrite pctldev with the result of
    get_pinctrl_dev_from_of_node() so it doesn't point to the pinctrl driver
    any more."
    
    Fix the issue by stashing the original pctldev so it doesn't
    get overwritten.
    
    Fixes:  b89405b6102f ("pinctrl: devicetree: Fix dt_to_map_one_config handling of hogs")
    Cc: <stable@vger.kernel.org>
    Reported-by: Mika Penttilä <mika.penttila@nextfour.com>
    Reported-by: Steve Longerbeam <slongerbeam@gmail.com>
    Suggested-by: Richard Fitzgerald <rf@opensource.cirrus.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Richard Fitzgerald <rf@opensource.cirrus.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index b601039d6c69..c4aa411f5935 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -101,10 +101,11 @@ struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 }
 
 static int dt_to_map_one_config(struct pinctrl *p,
-				struct pinctrl_dev *pctldev,
+				struct pinctrl_dev *hog_pctldev,
 				const char *statename,
 				struct device_node *np_config)
 {
+	struct pinctrl_dev *pctldev = NULL;
 	struct device_node *np_pctldev;
 	const struct pinctrl_ops *ops;
 	int ret;
@@ -123,8 +124,10 @@ static int dt_to_map_one_config(struct pinctrl *p,
 			return -EPROBE_DEFER;
 		}
 		/* If we're creating a hog we can use the passed pctldev */
-		if (pctldev && (np_pctldev == p->dev->of_node))
+		if (hog_pctldev && (np_pctldev == p->dev->of_node)) {
+			pctldev = hog_pctldev;
 			break;
+		}
 		pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
 		if (pctldev)
 			break;

commit b89405b6102fcc3746f43697b826028caa94c823
Author: Richard Fitzgerald <rf@opensource.cirrus.com>
Date:   Wed Feb 28 15:53:06 2018 +0000

    pinctrl: devicetree: Fix dt_to_map_one_config handling of hogs
    
    When dt_to_map_one_config() is called with a pinctrl_dev passed
    in, it should only be using this if the node being looked up
    is a hog. The code was always using the passed pinctrl_dev
    without checking whether the dt node referred to it.
    
    A pin controller can have pinctrl-n dependencies on other pin
    controllers in these cases:
    
    - the pin controller hardware is external, for example I2C, so
      needs other pin controller(s) to be setup to communicate with
      the hardware device.
    
    - it is a child of a composite MFD so its of_node is shared with
      the parent MFD and other children of that MFD. Any part of that
      MFD could have dependencies on other pin controllers.
    
    Because of this, dt_to_map_one_config() can't assume that if it
    has a pinctrl_dev passed in then the node it looks up must be
    a hog. It could be a reference to some other pin controller.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.cirrus.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 1ff6c3573493..b601039d6c69 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -122,8 +122,10 @@ static int dt_to_map_one_config(struct pinctrl *p,
 			/* OK let's just assume this will appear later then */
 			return -EPROBE_DEFER;
 		}
-		if (!pctldev)
-			pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
+		/* If we're creating a hog we can use the passed pctldev */
+		if (pctldev && (np_pctldev == p->dev->of_node))
+			break;
+		pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
 		if (pctldev)
 			break;
 		/* Do not defer probing of hogs (circular loop) */

commit 9b21e72e8ce7f70f53f3cc3d2d47568e7f6029d2
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 26 20:30:04 2017 +0200

    pinctrl: Delete an error message
    
    Omit an extra message for a memory allocation failure in these functions.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 0a20afc2210c..1ff6c3573493 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -83,7 +83,6 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 	/* Remember the converted mapping table entries */
 	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
 	if (!dt_map) {
-		dev_err(p->dev, "failed to alloc struct pinctrl_dt_map\n");
 		dt_free_map(pctldev, map, num_maps);
 		return -ENOMEM;
 	}
@@ -158,10 +157,8 @@ static int dt_remember_dummy_state(struct pinctrl *p, const char *statename)
 	struct pinctrl_map *map;
 
 	map = kzalloc(sizeof(*map), GFP_KERNEL);
-	if (!map) {
-		dev_err(p->dev, "failed to alloc struct pinctrl_map\n");
+	if (!map)
 		return -ENOMEM;
-	}
 
 	/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */
 	map->type = PIN_MAP_TYPE_DUMMY_STATE;

commit f5292d06c4f1d0c220d7c9e9c0553cabe5b37d4c
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:23 2017 -0500

    pinctrl: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Lee Jones <lee@kernel.org>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Barry Song <baohua@kernel.org>
    Cc: linux-gpio@vger.kernel.org
    Cc: linux-rpi-kernel@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: kernel@stlinux.com
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-renesas-soc@vger.kernel.org
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Ludovic Desroches <ludovic.desroches@microchip.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 0e5c9f14a706..0a20afc2210c 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -117,8 +117,8 @@ static int dt_to_map_one_config(struct pinctrl *p,
 	for (;;) {
 		np_pctldev = of_get_next_parent(np_pctldev);
 		if (!np_pctldev || of_node_is_root(np_pctldev)) {
-			dev_info(p->dev, "could not find pctldev for node %s, deferring probe\n",
-				np_config->full_name);
+			dev_info(p->dev, "could not find pctldev for node %pOF, deferring probe\n",
+				np_config);
 			of_node_put(np_pctldev);
 			/* OK let's just assume this will appear later then */
 			return -EPROBE_DEFER;

commit 92c2b671848e7816455ba5374e98913d920f3257
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Dec 30 10:37:31 2016 -0800

    pinctrl: core: Make dt_free_map optional
    
    If the pin controller driver is using devm_kzalloc, there may not be
    anything to do for dt_free_map. Let's make it optional to avoid
    unncessary boilerplate code.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index e082bddad83a..0e5c9f14a706 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -42,7 +42,8 @@ static void dt_free_map(struct pinctrl_dev *pctldev,
 {
 	if (pctldev) {
 		const struct pinctrl_ops *ops = pctldev->desc->pctlops;
-		ops->dt_free_map(pctldev, map, num_maps);
+		if (ops->dt_free_map)
+			ops->dt_free_map(pctldev, map, num_maps);
 	} else {
 		/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */
 		kfree(map);

commit 99e4f67508e1dd51e21ebae2150c6e4f4eae068b
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 27 09:19:59 2016 -0800

    pinctrl: core: Use delayed work for hogs
    
    Having the pin control framework call pin controller functions
    before it's probe has finished is not nice as the pin controller
    device driver does not yet have struct pinctrl_dev handle.
    
    Let's fix this issue by adding deferred work for late init. This is
    needed to be able to add pinctrl generic helper functions that expect
    to know struct pinctrl_dev handle. Note that we now need to call
    create_pinctrl() directly as we don't want to add the pin controller
    to the list of controllers until the hogs are claimed. We also need
    to pass the pinctrl_dev to the device tree parser functions as they
    otherwise won't find the right controller at this point.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 260908480075..e082bddad83a 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -100,11 +100,12 @@ struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 	return get_pinctrl_dev_from_of_node(np);
 }
 
-static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
+static int dt_to_map_one_config(struct pinctrl *p,
+				struct pinctrl_dev *pctldev,
+				const char *statename,
 				struct device_node *np_config)
 {
 	struct device_node *np_pctldev;
-	struct pinctrl_dev *pctldev;
 	const struct pinctrl_ops *ops;
 	int ret;
 	struct pinctrl_map *map;
@@ -121,7 +122,8 @@ static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 			/* OK let's just assume this will appear later then */
 			return -EPROBE_DEFER;
 		}
-		pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
+		if (!pctldev)
+			pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
 		if (pctldev)
 			break;
 		/* Do not defer probing of hogs (circular loop) */
@@ -166,7 +168,22 @@ static int dt_remember_dummy_state(struct pinctrl *p, const char *statename)
 	return dt_remember_or_free_map(p, statename, NULL, map, 1);
 }
 
-int pinctrl_dt_to_map(struct pinctrl *p)
+bool pinctrl_dt_has_hogs(struct pinctrl_dev *pctldev)
+{
+	struct device_node *np;
+	struct property *prop;
+	int size;
+
+	np = pctldev->dev->of_node;
+	if (!np)
+		return false;
+
+	prop = of_find_property(np, "pinctrl-0", &size);
+
+	return prop ? true : false;
+}
+
+int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)
 {
 	struct device_node *np = p->dev->of_node;
 	int state, ret;
@@ -233,7 +250,8 @@ int pinctrl_dt_to_map(struct pinctrl *p)
 			}
 
 			/* Parse the node */
-			ret = dt_to_map_one_config(p, statename, np_config);
+			ret = dt_to_map_one_config(p, pctldev, statename,
+						   np_config);
 			of_node_put(np_config);
 			if (ret < 0)
 				goto err;

commit 42124bc598f64f84b3335d5a058304207695b84f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 3 09:35:47 2016 -0700

    pinctrl: Introduce generic #pinctrl-cells and pinctrl_parse_index_with_args
    
    Introduce #pinctrl-cells helper binding and generic helper functions
    pinctrl_count_index_with_args() and pinctrl_parse_index_with_args().
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    [Forward-declare of_phandle_args]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 54dad89fc9bf..260908480075 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -253,3 +253,147 @@ int pinctrl_dt_to_map(struct pinctrl *p)
 	pinctrl_dt_free_maps(p);
 	return ret;
 }
+
+/*
+ * For pinctrl binding, typically #pinctrl-cells is for the pin controller
+ * device, so either parent or grandparent. See pinctrl-bindings.txt.
+ */
+static int pinctrl_find_cells_size(const struct device_node *np)
+{
+	const char *cells_name = "#pinctrl-cells";
+	int cells_size, error;
+
+	error = of_property_read_u32(np->parent, cells_name, &cells_size);
+	if (error) {
+		error = of_property_read_u32(np->parent->parent,
+					     cells_name, &cells_size);
+		if (error)
+			return -ENOENT;
+	}
+
+	return cells_size;
+}
+
+/**
+ * pinctrl_get_list_and_count - Gets the list and it's cell size and number
+ * @np: pointer to device node with the property
+ * @list_name: property that contains the list
+ * @list: pointer for the list found
+ * @cells_size: pointer for the cell size found
+ * @nr_elements: pointer for the number of elements found
+ *
+ * Typically np is a single pinctrl entry containing the list.
+ */
+static int pinctrl_get_list_and_count(const struct device_node *np,
+				      const char *list_name,
+				      const __be32 **list,
+				      int *cells_size,
+				      int *nr_elements)
+{
+	int size;
+
+	*cells_size = 0;
+	*nr_elements = 0;
+
+	*list = of_get_property(np, list_name, &size);
+	if (!*list)
+		return -ENOENT;
+
+	*cells_size = pinctrl_find_cells_size(np);
+	if (*cells_size < 0)
+		return -ENOENT;
+
+	/* First element is always the index within the pinctrl device */
+	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
+
+	return 0;
+}
+
+/**
+ * pinctrl_count_index_with_args - Count number of elements in a pinctrl entry
+ * @np: pointer to device node with the property
+ * @list_name: property that contains the list
+ *
+ * Counts the number of elements in a pinctrl array consisting of an index
+ * within the controller and a number of u32 entries specified for each
+ * entry. Note that device_node is always for the parent pin controller device.
+ */
+int pinctrl_count_index_with_args(const struct device_node *np,
+				  const char *list_name)
+{
+	const __be32 *list;
+	int size, nr_cells, error;
+
+	error = pinctrl_get_list_and_count(np, list_name, &list,
+					   &nr_cells, &size);
+	if (error)
+		return error;
+
+	return size;
+}
+EXPORT_SYMBOL_GPL(pinctrl_count_index_with_args);
+
+/**
+ * pinctrl_copy_args - Populates of_phandle_args based on index
+ * @np: pointer to device node with the property
+ * @list: pointer to a list with the elements
+ * @index: entry within the list of elements
+ * @nr_cells: number of cells in the list
+ * @nr_elem: number of elements for each entry in the list
+ * @out_args: returned values
+ *
+ * Populates the of_phandle_args based on the index in the list.
+ */
+static int pinctrl_copy_args(const struct device_node *np,
+			     const __be32 *list,
+			     int index, int nr_cells, int nr_elem,
+			     struct of_phandle_args *out_args)
+{
+	int i;
+
+	memset(out_args, 0, sizeof(*out_args));
+	out_args->np = (struct device_node *)np;
+	out_args->args_count = nr_cells + 1;
+
+	if (index >= nr_elem)
+		return -EINVAL;
+
+	list += index * (nr_cells + 1);
+
+	for (i = 0; i < nr_cells + 1; i++)
+		out_args->args[i] = be32_to_cpup(list++);
+
+	return 0;
+}
+
+/**
+ * pinctrl_parse_index_with_args - Find a node pointed by index in a list
+ * @np: pointer to device node with the property
+ * @list_name: property that contains the list
+ * @index: index within the list
+ * @out_arts: entries in the list pointed by index
+ *
+ * Finds the selected element in a pinctrl array consisting of an index
+ * within the controller and a number of u32 entries specified for each
+ * entry. Note that device_node is always for the parent pin controller device.
+ */
+int pinctrl_parse_index_with_args(const struct device_node *np,
+				  const char *list_name, int index,
+				  struct of_phandle_args *out_args)
+{
+	const __be32 *list;
+	int nr_elem, nr_cells, error;
+
+	error = pinctrl_get_list_and_count(np, list_name, &list,
+					   &nr_cells, &nr_elem);
+	if (error || !nr_cells)
+		return error;
+
+	error = pinctrl_copy_args(np, list, index, nr_cells, nr_elem,
+				  out_args);
+	if (error)
+		return error;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pinctrl_parse_index_with_args);

commit 98849fa0163e755ef2c4565c814bf08ffb5a2c4a
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Thu Jun 16 16:27:41 2016 +0100

    pinctrl: OF: Don't create a pinctrl handle if no pinctrl entries exist
    
    When pinctrl_get() is called for a device, it will return a valid handle
    even if the device itself has no pinctrl state entries defined in
    device-tree. This is caused by the function pinctrl_dt_to_map() which
    will return success even if the first pinctrl state, 'pinctrl-0', is not
    found in the device-tree node for a device.
    
    According to the pinctrl device-tree binding documentation, pinctrl
    states must be numbered starting from 0 and so 'pinctrl-0' should always
    be present if a device uses pinctrl and therefore, if 'pinctrl-0' is not
    present it seems valid that we should not return a valid pinctrl handle.
    
    Fix this by returning an error code if the property 'pinctrl-0' is not
    present for a device.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index fe04e748dfe4..54dad89fc9bf 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -195,8 +195,13 @@ int pinctrl_dt_to_map(struct pinctrl *p)
 		propname = kasprintf(GFP_KERNEL, "pinctrl-%d", state);
 		prop = of_find_property(np, propname, &size);
 		kfree(propname);
-		if (!prop)
+		if (!prop) {
+			if (state == 0) {
+				of_node_put(np);
+				return -ENODEV;
+			}
 			break;
+		}
 		list = prop->value;
 		size /= sizeof(*list);
 

commit fb00de771b0c35fc42212272596ddb07bf120b21
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jun 18 14:42:45 2015 +0900

    pinctrl: simplify of_pinctrl_get()
    
    This commit does not change the logic at all.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 0bbf7d71b281..fe04e748dfe4 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -97,13 +97,7 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 {
-	struct pinctrl_dev *pctldev;
-
-	pctldev = get_pinctrl_dev_from_of_node(np);
-	if (!pctldev)
-		return NULL;
-
-	return pctldev;
+	return get_pinctrl_dev_from_of_node(np);
 }
 
 static int dt_to_map_one_config(struct pinctrl *p, const char *statename,

commit c5272a28566b00cce79127ad382406e0a8650690
Author: Doug Anderson <dianders@chromium.org>
Date:   Fri May 1 09:01:27 2015 -0700

    pinctrl: Don't just pretend to protect pinctrl_maps, do it for real
    
    Way back, when the world was a simpler place and there was no war, no
    evil, and no kernel bugs, there was just a single pinctrl lock.  That
    was how the world was when (57291ce pinctrl: core device tree mapping
    table parsing support) was written.  In that case, there were
    instances where the pinctrl mutex was already held when
    pinctrl_register_map() was called, hence a "locked" parameter was
    passed to the function to indicate that the mutex was already locked
    (so we shouldn't lock it again).
    
    A few years ago in (42fed7b pinctrl: move subsystem mutex to
    pinctrl_dev struct), we switched to a separate pinctrl_maps_mutex.
    ...but (oops) we forgot to re-think about the whole "locked" parameter
    for pinctrl_register_map().  Basically the "locked" parameter appears
    to still refer to whether the bigger pinctrl_dev mutex is locked, but
    we're using it to skip locks of our (now separate) pinctrl_maps_mutex.
    
    That's kind of a bad thing(TM).  Probably nobody noticed because most
    of the calls to pinctrl_register_map happen at boot time and we've got
    synchronous device probing.  ...and even cases where we're
    asynchronous don't end up actually hitting the race too often.  ...but
    after banging my head against the wall for a bug that reproduced 1 out
    of 1000 reboots and lots of looking through kgdb, I finally noticed
    this.
    
    Anyway, we can now safely remove the "locked" parameter and go back to
    a war-free, evil-free, and kernel-bug-free world.
    
    Fixes: 42fed7ba44e4 ("pinctrl: move subsystem mutex to pinctrl_dev struct")
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index eda13de2e7c0..0bbf7d71b281 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -92,7 +92,7 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 	dt_map->num_maps = num_maps;
 	list_add_tail(&dt_map->node, &p->dt_maps);
 
-	return pinctrl_register_map(map, num_maps, false, true);
+	return pinctrl_register_map(map, num_maps, false);
 }
 
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)

commit 5d88dceac736a779fdf6208bbd0a06e81fe25300
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 30 18:57:20 2014 +0000

    pinctrl: Quiet logging about missing DT nodes when not using DT
    
    On systems which were not booted using DT it is entirely unsurprising that
    device nodes don't have any DT information and this is going to happen for
    every single device in the system. Make pinctrl be less chatty about this
    situation by only logging in the case where we have DT.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 340fb4e6c600..eda13de2e7c0 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -186,7 +186,9 @@ int pinctrl_dt_to_map(struct pinctrl *p)
 
 	/* CONFIG_OF enabled, p->dev not instantiated from DT */
 	if (!np) {
-		dev_dbg(p->dev, "no of_node; not parsing pinctrl DT\n");
+		if (of_have_populated_dt())
+			dev_dbg(p->dev,
+				"no of_node; not parsing pinctrl DT\n");
 		return 0;
 	}
 

commit 42fed7ba44e4e8c1fb27b28ad14490cb1daff3c7
Author: Patrice Chotard <patrice.chotard@st.com>
Date:   Thu Apr 11 11:01:27 2013 +0200

    pinctrl: move subsystem mutex to pinctrl_dev struct
    
    This mutex avoids deadlock in case of use of multiple pin
    controllers. Before this modification, by using a global
    mutex, deadlock appeared when, for example, a call to
    pinctrl_pins_show() locked the pinctrl_mutex, called the
    ops->pin_dbg_show of a particular pin controller. If this
    pin controller needs I2C access to retrieve configuration
    information and I2C driver is using pinctrl to drive its
    pins, a call to pinctrl_select_state() try to lock again
    pinctrl_mutex which leads to a deadlock.
    
    Notice that the mutex grab from the two direction functions
    was moved into pinctrl_gpio_direction().
    
    For several cases, we can't replace pinctrl_mutex by
    pctldev->mutex, because at this stage, pctldev is
    not accessible :
            - pinctrl_get()/pinctrl_put()
            - pinctrl_register_maps()
    
    So add respectively pinctrl_list_mutex and
    pinctrl_maps_mutex in order to protect
    pinctrl_list and pinctrl_maps list instead.
    
    Reintroduce pinctrldev_list_mutex in
    find_pinctrl_by_of_node(),
    pinctrl_find_and_add_gpio_range()
    pinctrl_request_gpio(), pinctrl_free_gpio(),
    pinctrl_gpio_direction(), pinctrl_devices_show(),
    pinctrl_register() and pinctrl_unregister() to
    protect pinctrldev_list.
    
    Changes v2->v3:
    - Fix a missing EXPORT_SYMBOL_GPL() for pinctrl_select_state().
    
    Changes v1->v2:
    - pinctrl_select_state_locked() is removed, all lock mechanism
      is located inside pinctrl_select_state(). When parsing
      the state->setting list, take the per-pin-controller driver
      lock. (Patrice).
    - Introduce pinctrldev_list_mutex to protect pinctrldev_list
      in all functions which parse or modify pictrldev_list.
      (Patrice).
    - move find_pinctrl_by_of_node() from pinctrl/devicetree.c to
      pinctrl/core.c in order to protect pinctrldev_list.
      (Patrice).
    - Sink mutex:es into some functions and remove some _locked
      variants down to where the lists are actually accessed to
      make things simpler. (Linus)
    - Drop *all* mutexes completely from pinctrl_lookup_state()
      and pinctrl_select_state() - no relevant mutex was taken
      and it was unclear what this was protecting against. (Linus)
    
    Reported by : Seraphin Bonnaffe <seraphin.bonnaffe@stericsson.com>
    Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index c7b7cb477129..340fb4e6c600 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -95,22 +95,11 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 	return pinctrl_register_map(map, num_maps, false, true);
 }
 
-static struct pinctrl_dev *find_pinctrl_by_of_node(struct device_node *np)
-{
-	struct pinctrl_dev *pctldev;
-
-	list_for_each_entry(pctldev, &pinctrldev_list, node)
-		if (pctldev->dev->of_node == np)
-			return pctldev;
-
-	return NULL;
-}
-
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 {
 	struct pinctrl_dev *pctldev;
 
-	pctldev = find_pinctrl_by_of_node(np);
+	pctldev = get_pinctrl_dev_from_of_node(np);
 	if (!pctldev)
 		return NULL;
 
@@ -138,7 +127,7 @@ static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 			/* OK let's just assume this will appear later then */
 			return -EPROBE_DEFER;
 		}
-		pctldev = find_pinctrl_by_of_node(np_pctldev);
+		pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
 		if (pctldev)
 			break;
 		/* Do not defer probing of hogs (circular loop) */

commit 022ab148d28e8466e45d28552224e3029f1cccd8
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 10:25:07 2013 +0100

    pinctrl: Declare operation structures as const
    
    The pinconf, pinctrl and pinmux operation structures hold function
    pointers that are never modified. Declare them as const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index fd40a11ad645..c7b7cb477129 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -41,7 +41,7 @@ static void dt_free_map(struct pinctrl_dev *pctldev,
 		     struct pinctrl_map *map, unsigned num_maps)
 {
 	if (pctldev) {
-		struct pinctrl_ops *ops = pctldev->desc->pctlops;
+		const struct pinctrl_ops *ops = pctldev->desc->pctlops;
 		ops->dt_free_map(pctldev, map, num_maps);
 	} else {
 		/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */
@@ -122,7 +122,7 @@ static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 {
 	struct device_node *np_pctldev;
 	struct pinctrl_dev *pctldev;
-	struct pinctrl_ops *ops;
+	const struct pinctrl_ops *ops;
 	int ret;
 	struct pinctrl_map *map;
 	unsigned num_maps;

commit b2083062a3b4035e85349120b426ecef2b6d155f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jan 11 21:22:36 2013 +0100

    pinctrl: do not defer device tree hogs
    
    commit af1024e0f7cde9023ddd0f3116db03911d5914c0
    "pinctrl: skip deferral of hogs"
    
    Attempts to avoid probe deferral on hogged pins, but we
    forgot the device tree case. This patch fixes this.
    
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reported-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index fe2d1af7cfa0..fd40a11ad645 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -141,6 +141,11 @@ static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 		pctldev = find_pinctrl_by_of_node(np_pctldev);
 		if (pctldev)
 			break;
+		/* Do not defer probing of hogs (circular loop) */
+		if (np_pctldev == p->dev->of_node) {
+			of_node_put(np_pctldev);
+			return -ENODEV;
+		}
 	}
 	of_node_put(np_pctldev);
 

commit 1e63d7b9363f0c57d00991f9f2e0af374dfc591a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 6 16:03:35 2012 +0100

    gpiolib: separation of pin concerns
    
    The fact that of_gpiochip_add_pin_range() and
    gpiochip_add_pin_range() share too much code is fragile and
    will invariably mean that bugs need to be fixed in two places
    instead of one.
    
    So separate the concerns of gpiolib.c and gpiolib-of.c and
    have the latter call the former as back-end. This is necessary
    also when going forward with other device descriptions such
    as ACPI.
    
    This is done by:
    
    - Adding a return code to gpiochip_add_pin_range() so we can
      reliably check whether this succeeds.
    
    - Get rid of the custom of_pinctrl_add_gpio_range() from
      pinctrl. Instead create of_pinctrl_get() to just retrive the
      pin controller per se from an OF node. This composite
      function was just begging to be deleted, it was way to
      purpose-specific.
    
    - Use pinctrl_dev_get_name() to get the name of the retrieved
      pin controller and use that to call back into the generic
      gpiochip_add_pin_range().
    
    Now the pin range is only allocated and tied to a pin
    controller from the core implementation in gpiolib.c.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 6728ec71cb65..fe2d1af7cfa0 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -106,8 +106,7 @@ static struct pinctrl_dev *find_pinctrl_by_of_node(struct device_node *np)
 	return NULL;
 }
 
-struct pinctrl_dev *of_pinctrl_add_gpio_range(struct device_node *np,
-		struct pinctrl_gpio_range *range)
+struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 {
 	struct pinctrl_dev *pctldev;
 
@@ -115,7 +114,6 @@ struct pinctrl_dev *of_pinctrl_add_gpio_range(struct device_node *np,
 	if (!pctldev)
 		return NULL;
 
-	pinctrl_add_gpio_range(pctldev, range);
 	return pctldev;
 }
 

commit f23f1516b6757c326cc638bed8c402c77e2a596e
Author: Shiraz Hashim <shiraz.hashim@st.com>
Date:   Sat Oct 27 15:21:36 2012 +0530

    gpiolib: provide provision to register pin ranges
    
    pinctrl subsystem needs gpio chip base to prepare set of gpio
    pin ranges, which a given pinctrl driver can handle. This is
    important to handle pinctrl gpio request calls in order to
    program a given pin properly for gpio operation.
    
    As gpio base is allocated dynamically during gpiochip
    registration, presently there exists no clean way to pass this
    information to the pinctrl subsystem.
    
    After few discussions from [1], it was concluded that may be
    gpio controller reporting the pin range it supports, is a
    better way than pinctrl subsystem directly registering it.
    
    [1] http://comments.gmane.org/gmane.linux.ports.arm.kernel/184816
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Shiraz Hashim <shiraz.hashim@st.com>
    [Edited documentation a bit]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index fcb1de45473c..6728ec71cb65 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -106,6 +106,19 @@ static struct pinctrl_dev *find_pinctrl_by_of_node(struct device_node *np)
 	return NULL;
 }
 
+struct pinctrl_dev *of_pinctrl_add_gpio_range(struct device_node *np,
+		struct pinctrl_gpio_range *range)
+{
+	struct pinctrl_dev *pctldev;
+
+	pctldev = find_pinctrl_by_of_node(np);
+	if (!pctldev)
+		return NULL;
+
+	pinctrl_add_gpio_range(pctldev, range);
+	return pctldev;
+}
+
 static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 				struct device_node *np_config)
 {

commit c05127c4e2c6e7d9949347a76fd05c337bcd5e84
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 10 10:00:38 2012 +0200

    pinctrl: implement pinctrl deferred probing
    
    If drivers try to obtain pinctrl handles for a pin controller that
    has not yet registered to the subsystem, we need to be able to
    back out and retry with deferred probing. So let's return
    -EPROBE_DEFER whenever this location fails. Also downgrade the
    errors to info, maybe we will even set them to debug once the
    deferred probing is commonplace.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 5ef2feb44395..fcb1de45473c 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -121,11 +121,11 @@ static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 	for (;;) {
 		np_pctldev = of_get_next_parent(np_pctldev);
 		if (!np_pctldev || of_node_is_root(np_pctldev)) {
-			dev_err(p->dev, "could not find pctldev for node %s\n",
+			dev_info(p->dev, "could not find pctldev for node %s, deferring probe\n",
 				np_config->full_name);
 			of_node_put(np_pctldev);
-			/* FIXME: This should trigger deferrered probe */
-			return -ENODEV;
+			/* OK let's just assume this will appear later then */
+			return -EPROBE_DEFER;
 		}
 		pctldev = find_pinctrl_by_of_node(np_pctldev);
 		if (pctldev)

commit 57291ce295c0aca738dd284c4a9c591c09ebee71
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Fri Mar 23 10:29:46 2012 -0600

    pinctrl: core device tree mapping table parsing support
    
    During pinctrl_get(), if the client device has a device tree node, look
    for the common pinctrl properties there. If found, parse the referenced
    device tree nodes, with the help of the pinctrl drivers, and generate
    mapping table entries from them.
    
    During pinctrl_put(), free any results of device tree parsing.
    
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
new file mode 100644
index 000000000000..5ef2feb44395
--- /dev/null
+++ b/drivers/pinctrl/devicetree.c
@@ -0,0 +1,249 @@
+/*
+ * Device tree integration for the pin control subsystem
+ *
+ * Copyright (C) 2012 NVIDIA CORPORATION. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/slab.h>
+
+#include "core.h"
+#include "devicetree.h"
+
+/**
+ * struct pinctrl_dt_map - mapping table chunk parsed from device tree
+ * @node: list node for struct pinctrl's @dt_maps field
+ * @pctldev: the pin controller that allocated this struct, and will free it
+ * @maps: the mapping table entries
+ */
+struct pinctrl_dt_map {
+	struct list_head node;
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_map *map;
+	unsigned num_maps;
+};
+
+static void dt_free_map(struct pinctrl_dev *pctldev,
+		     struct pinctrl_map *map, unsigned num_maps)
+{
+	if (pctldev) {
+		struct pinctrl_ops *ops = pctldev->desc->pctlops;
+		ops->dt_free_map(pctldev, map, num_maps);
+	} else {
+		/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */
+		kfree(map);
+	}
+}
+
+void pinctrl_dt_free_maps(struct pinctrl *p)
+{
+	struct pinctrl_dt_map *dt_map, *n1;
+
+	list_for_each_entry_safe(dt_map, n1, &p->dt_maps, node) {
+		pinctrl_unregister_map(dt_map->map);
+		list_del(&dt_map->node);
+		dt_free_map(dt_map->pctldev, dt_map->map,
+			    dt_map->num_maps);
+		kfree(dt_map);
+	}
+
+	of_node_put(p->dev->of_node);
+}
+
+static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
+				   struct pinctrl_dev *pctldev,
+				   struct pinctrl_map *map, unsigned num_maps)
+{
+	int i;
+	struct pinctrl_dt_map *dt_map;
+
+	/* Initialize common mapping table entry fields */
+	for (i = 0; i < num_maps; i++) {
+		map[i].dev_name = dev_name(p->dev);
+		map[i].name = statename;
+		if (pctldev)
+			map[i].ctrl_dev_name = dev_name(pctldev->dev);
+	}
+
+	/* Remember the converted mapping table entries */
+	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
+	if (!dt_map) {
+		dev_err(p->dev, "failed to alloc struct pinctrl_dt_map\n");
+		dt_free_map(pctldev, map, num_maps);
+		return -ENOMEM;
+	}
+
+	dt_map->pctldev = pctldev;
+	dt_map->map = map;
+	dt_map->num_maps = num_maps;
+	list_add_tail(&dt_map->node, &p->dt_maps);
+
+	return pinctrl_register_map(map, num_maps, false, true);
+}
+
+static struct pinctrl_dev *find_pinctrl_by_of_node(struct device_node *np)
+{
+	struct pinctrl_dev *pctldev;
+
+	list_for_each_entry(pctldev, &pinctrldev_list, node)
+		if (pctldev->dev->of_node == np)
+			return pctldev;
+
+	return NULL;
+}
+
+static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
+				struct device_node *np_config)
+{
+	struct device_node *np_pctldev;
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_ops *ops;
+	int ret;
+	struct pinctrl_map *map;
+	unsigned num_maps;
+
+	/* Find the pin controller containing np_config */
+	np_pctldev = of_node_get(np_config);
+	for (;;) {
+		np_pctldev = of_get_next_parent(np_pctldev);
+		if (!np_pctldev || of_node_is_root(np_pctldev)) {
+			dev_err(p->dev, "could not find pctldev for node %s\n",
+				np_config->full_name);
+			of_node_put(np_pctldev);
+			/* FIXME: This should trigger deferrered probe */
+			return -ENODEV;
+		}
+		pctldev = find_pinctrl_by_of_node(np_pctldev);
+		if (pctldev)
+			break;
+	}
+	of_node_put(np_pctldev);
+
+	/*
+	 * Call pinctrl driver to parse device tree node, and
+	 * generate mapping table entries
+	 */
+	ops = pctldev->desc->pctlops;
+	if (!ops->dt_node_to_map) {
+		dev_err(p->dev, "pctldev %s doesn't support DT\n",
+			dev_name(pctldev->dev));
+		return -ENODEV;
+	}
+	ret = ops->dt_node_to_map(pctldev, np_config, &map, &num_maps);
+	if (ret < 0)
+		return ret;
+
+	/* Stash the mapping table chunk away for later use */
+	return dt_remember_or_free_map(p, statename, pctldev, map, num_maps);
+}
+
+static int dt_remember_dummy_state(struct pinctrl *p, const char *statename)
+{
+	struct pinctrl_map *map;
+
+	map = kzalloc(sizeof(*map), GFP_KERNEL);
+	if (!map) {
+		dev_err(p->dev, "failed to alloc struct pinctrl_map\n");
+		return -ENOMEM;
+	}
+
+	/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */
+	map->type = PIN_MAP_TYPE_DUMMY_STATE;
+
+	return dt_remember_or_free_map(p, statename, NULL, map, 1);
+}
+
+int pinctrl_dt_to_map(struct pinctrl *p)
+{
+	struct device_node *np = p->dev->of_node;
+	int state, ret;
+	char *propname;
+	struct property *prop;
+	const char *statename;
+	const __be32 *list;
+	int size, config;
+	phandle phandle;
+	struct device_node *np_config;
+
+	/* CONFIG_OF enabled, p->dev not instantiated from DT */
+	if (!np) {
+		dev_dbg(p->dev, "no of_node; not parsing pinctrl DT\n");
+		return 0;
+	}
+
+	/* We may store pointers to property names within the node */
+	of_node_get(np);
+
+	/* For each defined state ID */
+	for (state = 0; ; state++) {
+		/* Retrieve the pinctrl-* property */
+		propname = kasprintf(GFP_KERNEL, "pinctrl-%d", state);
+		prop = of_find_property(np, propname, &size);
+		kfree(propname);
+		if (!prop)
+			break;
+		list = prop->value;
+		size /= sizeof(*list);
+
+		/* Determine whether pinctrl-names property names the state */
+		ret = of_property_read_string_index(np, "pinctrl-names",
+						    state, &statename);
+		/*
+		 * If not, statename is just the integer state ID. But rather
+		 * than dynamically allocate it and have to free it later,
+		 * just point part way into the property name for the string.
+		 */
+		if (ret < 0) {
+			/* strlen("pinctrl-") == 8 */
+			statename = prop->name + 8;
+		}
+
+		/* For every referenced pin configuration node in it */
+		for (config = 0; config < size; config++) {
+			phandle = be32_to_cpup(list++);
+
+			/* Look up the pin configuration node */
+			np_config = of_find_node_by_phandle(phandle);
+			if (!np_config) {
+				dev_err(p->dev,
+					"prop %s index %i invalid phandle\n",
+					prop->name, config);
+				ret = -EINVAL;
+				goto err;
+			}
+
+			/* Parse the node */
+			ret = dt_to_map_one_config(p, statename, np_config);
+			of_node_put(np_config);
+			if (ret < 0)
+				goto err;
+		}
+
+		/* No entries in DT? Generate a dummy state table entry */
+		if (!size) {
+			ret = dt_remember_dummy_state(p, statename);
+			if (ret < 0)
+				goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	pinctrl_dt_free_maps(p);
+	return ret;
+}
