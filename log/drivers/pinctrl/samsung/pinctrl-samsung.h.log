commit 1c5fb66afa2a1d1860cff46ef426117b11e029aa
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 13 13:58:21 2018 +0200

    pinctrl: Include <linux/gpio/driver.h> nothing else
    
    These drivers are GPIO drivers, and the do not need to use the
    legacy header in <linux/gpio.h>, go directly for
    <linux/gpio/driver.h> instead.
    
    Replace any use of GPIOF_* with 0/1, these flags are for
    consumers, not drivers.
    
    Get rid of a few gpio_to_irq() users that was littering
    around the place, use local callbacks or avoid using it at
    all.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index e571bbd7139b..379f34a9a482 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -19,7 +19,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/pinctrl/machine.h>
 
-#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 
 /**
  * enum pincfg_type - possible pin configuration types supported.

commit a8be2af0218cf037704dc2e733bf56d6560fa324
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Jul 23 19:52:58 2018 +0200

    pinctrl: samsung: Write external wakeup interrupt mask
    
    The pinctrl driver defines an IRQ chip which handles external wakeup
    interrupts, therefore from logical point of view, it is the owner of
    external interrupt mask.  The register controlling the mask belongs to
    Power Management Unit address space so it has to be accessed with PMU
    syscon regmap handle.
    
    This mask should be written to hardware during system suspend.  Till now
    ARMv7 machine code was responsible for this which created a dependency
    between pin controller driver and arch/arm/mach code.
    
    Try to rework this dependency so the pinctrl driver will write external
    wakeup interrupt mask during late suspend.
    
    Impact on ARMv7 designs (S5Pv210 and Exynos)
    ============================================
    This duplicates setting mask with existing machine code
    arch/arm/mach-exynos/suspend.c and arch/arm/mach-s5pv210/pm.c but it is
    not a problem - the wakeup mask register will be written twice.  The
    machine code will be cleaned up later.
    
    The difference between implementation here and ARMv7 machine code
    (arch/arm/mach-*) is the time of writing the mask:
    1. The machine code is writing the mask quite late during system suspend
       path, after offlining secondary CPUs and just before doing actual
       suspend.
    2. The implementation in pinctrl driver uses late suspend ops, therefore it
       will write the mask much earlier.  Hopefully late enough, after all
       drivers will enable or disable their interrupt wakeups
       (enable_irq_wake() etc).
    
    Impact on ARMv8 designs (Exynos5433 and Exynos7)
    ================================================
    The Suspend to RAM was not supported and external wakeup interrupt mask
    was not written to HW.  This change brings us one step closer to
    supporting Suspend to RAM.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Sylwester Nawrocki <snawrocki@kernel.org>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index aac16cc8362a..e571bbd7139b 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -227,6 +227,9 @@ struct samsung_retention_data {
  *	device suspend, see samsung_pinctrl_suspend()
  * @resume: platform specific resume callback, executed during pin controller
  *	device suspend, see samsung_pinctrl_resume()
+ *
+ * External wakeup interrupts must define at least eint_wkup_init,
+ * retention_data and suspend in order for proper suspend/resume to work.
  */
 struct samsung_pin_ctrl {
 	const struct samsung_pin_bank_data *pin_banks;

commit 00d6fff37066e96814796d05e1c6e8131f38576a
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Jul 23 19:52:54 2018 +0200

    pinctrl: samsung: Document suspend and resume members
    
    Add missing documentation for suspend and resume members of struct
    samsung_pin_ctrl and samsung_pinctrl_drv_data.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Sylwester Nawrocki <snawrocki@kernel.org>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index f0cda9424dfe..aac16cc8362a 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -223,6 +223,10 @@ struct samsung_retention_data {
  *	interrupts for the controller.
  * @eint_wkup_init: platform specific callback to setup the external wakeup
  *	interrupts for the controller.
+ * @suspend: platform specific suspend callback, executed during pin controller
+ *	device suspend, see samsung_pinctrl_suspend()
+ * @resume: platform specific resume callback, executed during pin controller
+ *	device suspend, see samsung_pinctrl_resume()
  */
 struct samsung_pin_ctrl {
 	const struct samsung_pin_bank_data *pin_banks;
@@ -255,6 +259,10 @@ struct samsung_pin_ctrl {
  * @pin_base: starting system wide pin number.
  * @nr_pins: number of pins supported by the controller.
  * @retention_ctrl: retention control runtime data.
+ * @suspend: platform specific suspend callback, executed during pin controller
+ *	device suspend, see samsung_pinctrl_suspend()
+ * @resume: platform specific resume callback, executed during pin controller
+ *	device suspend, see samsung_pinctrl_resume()
  */
 struct samsung_pinctrl_drv_data {
 	struct list_head		node;

commit 93b0beae721b3344923b4b8317e9d83b542f4ca6
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Feb 20 19:17:51 2018 +0100

    pinctrl: samsung: Validate alias coming from DT
    
    Driver uses alias from Device Tree as an index of pin controller data
    array.  In case of a wrong DTB or an out-of-tree DTB, the alias could be
    outside of this data array leading to out-of-bounds access.
    
    Depending on binary and memory layout, this could be handled properly
    (showing error like "samsung-pinctrl 3860000.pinctrl: driver data not
    available") or could lead to exceptions.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: <stable@vger.kernel.org>
    Fixes: 30574f0db1b1 ("pinctrl: add samsung pinctrl and gpiolib driver")
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index e204f609823b..f0cda9424dfe 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -281,6 +281,16 @@ struct samsung_pinctrl_drv_data {
 	void (*resume)(struct samsung_pinctrl_drv_data *);
 };
 
+/**
+ * struct samsung_pinctrl_of_match_data: OF match device specific configuration data.
+ * @ctrl: array of pin controller data.
+ * @num_ctrl: size of array @ctrl.
+ */
+struct samsung_pinctrl_of_match_data {
+	const struct samsung_pin_ctrl	*ctrl;
+	unsigned int			num_ctrl;
+};
+
 /**
  * struct samsung_pin_group: represent group of pins of a pinmux function.
  * @name: name of the pin group, used to lookup the group.
@@ -309,20 +319,20 @@ struct samsung_pmx_func {
 };
 
 /* list of all exported SoC specific data */
-extern const struct samsung_pin_ctrl exynos3250_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos4210_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos5250_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos5260_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos5410_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos5420_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos5433_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos7_pin_ctrl[];
-extern const struct samsung_pin_ctrl s3c64xx_pin_ctrl[];
-extern const struct samsung_pin_ctrl s3c2412_pin_ctrl[];
-extern const struct samsung_pin_ctrl s3c2416_pin_ctrl[];
-extern const struct samsung_pin_ctrl s3c2440_pin_ctrl[];
-extern const struct samsung_pin_ctrl s3c2450_pin_ctrl[];
-extern const struct samsung_pin_ctrl s5pv210_pin_ctrl[];
+extern const struct samsung_pinctrl_of_match_data exynos3250_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos4210_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos4x12_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos5250_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos5260_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos5410_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos5420_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos5433_of_data;
+extern const struct samsung_pinctrl_of_match_data exynos7_of_data;
+extern const struct samsung_pinctrl_of_match_data s3c64xx_of_data;
+extern const struct samsung_pinctrl_of_match_data s3c2412_of_data;
+extern const struct samsung_pinctrl_of_match_data s3c2416_of_data;
+extern const struct samsung_pinctrl_of_match_data s3c2440_of_data;
+extern const struct samsung_pinctrl_of_match_data s3c2450_of_data;
+extern const struct samsung_pinctrl_of_match_data s5pv210_of_data;
 
 #endif /* __PINCTRL_SAMSUNG_H */

commit 221173a3fc2063247a07d7f523704634d17112fb
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Dec 26 19:09:42 2017 +0100

    pinctrl: samsung: Add SPDX license identifiers
    
    Replace GPL license statements with SPDX GPL-2.0+ license identifiers.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 9af07af6cad6..e204f609823b 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * pin-controller/pin-mux/pin-config/gpio-driver for Samsung's SoC's.
  *
@@ -7,11 +8,6 @@
  *		http://www.linaro.org
  *
  * Author: Thomas Abraham <thomas.ab@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #ifndef __PINCTRL_SAMSUNG_H

commit 12cdd5790fe342bf223cbfc13f9929201fbe22db
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Thu Jun 15 18:33:16 2017 +0200

    pinctrl: samsung: Consistently use unsigned instead of u32 for nr_banks
    
    Unlike for other countable members, the driver used u32 for number of
    banks (nr_banks).  There is no specific need for using fixed-width
    integer in this particular place.  Make it consistent.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 49a05f4fc37d..9af07af6cad6 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -230,7 +230,7 @@ struct samsung_retention_data {
  */
 struct samsung_pin_ctrl {
 	const struct samsung_pin_bank_data *pin_banks;
-	u32		nr_banks;
+	unsigned int	nr_banks;
 	unsigned int	nr_ext_resources;
 	const struct samsung_retention_data *retention_data;
 
@@ -275,7 +275,7 @@ struct samsung_pinctrl_drv_data {
 	unsigned int			nr_functions;
 
 	struct samsung_pin_bank		*pin_banks;
-	u32				nr_banks;
+	unsigned int			nr_banks;
 	unsigned int			pin_base;
 	unsigned int			nr_pins;
 

commit 52d0ed009cfba83b3cc869380497361f699a4545
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Thu Jun 15 18:33:15 2017 +0200

    pinctrl: samsung: Use unsigned int for number of controller IO mem resources
    
    Number of IO memory resources cannot be negative obviously and the
    driver depends silently on this (by iterating from 0 to
    nr_ext_resources+1).  Make this requirement explicit.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 15b26c786b1e..49a05f4fc37d 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -231,7 +231,7 @@ struct samsung_retention_data {
 struct samsung_pin_ctrl {
 	const struct samsung_pin_bank_data *pin_banks;
 	u32		nr_banks;
-	int		nr_ext_resources;
+	unsigned int	nr_ext_resources;
 	const struct samsung_retention_data *retention_data;
 
 	int		(*eint_gpio_init)(struct samsung_pinctrl_drv_data *);

commit 4460dc21cbaf056cf34b82d72d9b6270ec0b02fe
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Thu Jun 15 17:06:28 2017 +0200

    pinctrl: samsung: Use define from dt-bindings for pin mux function
    
    We already have macros for values used by driver and Device Tree
    sources for pin mux configuration.  Use them instead of duplicating
    defines.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 61c4cab0ad24..15b26c786b1e 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -25,10 +25,6 @@
 
 #include <linux/gpio.h>
 
-/* pinmux function number for pin as gpio output line */
-#define FUNC_INPUT	0x0
-#define FUNC_OUTPUT	0x1
-
 /**
  * enum pincfg_type - possible pin configuration types supported.
  * @PINCFG_TYPE_FUNC: Function configuration.

commit cee7413d84044a0c1919a7c70a2d761ae24390de
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Thu Jun 15 17:46:37 2017 +0200

    pinctrl: samsung: Fix NULL pointer exception on external interrupts on S3C24xx
    
    After commit 8b1bd11c1f8f ("pinctrl: samsung: Add the support the
    multiple IORESOURCE_MEM for one pin-bank"), the S3C24xx (and probably
    S3C64xx as well) fails:
    
            Unable to handle kernel NULL pointer dereference at virtual address 000000a8
            ...
            (s3c24xx_demux_eint4_7) from [<c004469c>] (__handle_domain_irq+0x6c/0xcc)
            (__handle_domain_irq) from [<c0009444>] (s3c24xx_handle_irq+0x6c/0x12c)
            (s3c24xx_handle_irq) from [<c000e5fc>] (__irq_svc+0x5c/0x78)
    
    Mentioned commit moved the pointer to controller's base IO memory address
    from each controller's driver data (samsung_pinctrl_drv_data) to per-bank
    structure (samsung_pin_bank).  The external interrupt demux
    handlers (s3c24xx_demux_eint()) tried to get this base address from opaque
    pointer stored under irq_chip data:
    
            struct irq_data *irqd = irq_desc_get_irq_data(desc);
            struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);
            ...
            pend = readl(bank->eint_base + EINTPEND_REG);
    
    which is wrong because this is hardware irq and it bank was never set
    for this irq_chip.
    
    For S3C24xx and S3C64xx, this partially reverts mentioned commit by
    bringing back the virt_base stored under each controller's driver data
    (samsung_pinctrl_drv_data).  This virt_base address will be now
    duplicated:
     - samsung_pinctrl_drv_data->virt_base: used on S3C24xx and S3C64xx,
     - samsung_pin_bank->pctl_base: used on Exynos.
    
    Fixes: 8b1bd11c1f8f ("pinctrl: samsung: Add the support the multiple IORESOURCE_MEM for one pin-bank")
    Cc: <stable@vger.kernel.org>
    Cc: Sergio Prado <sergio.prado@e-labworks.com>
    Reported-by: Sergio Prado <sergio.prado@e-labworks.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Tested-by: Lihua Yao <ylhuajnu@163.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 515a61035e54..61c4cab0ad24 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -247,6 +247,10 @@ struct samsung_pin_ctrl {
 /**
  * struct samsung_pinctrl_drv_data: wrapper for holding driver data together.
  * @node: global list node
+ * @virt_base: register base address of the controller; this will be equal
+ *             to each bank samsung_pin_bank->pctl_base and used on legacy
+ *             platforms (like S3C24XX or S3C64XX) which has to access the base
+ *             through samsung_pinctrl_drv_data, not samsung_pin_bank).
  * @dev: device instance representing the controller.
  * @irq: interrpt number used by the controller to notify gpio interrupts.
  * @ctrl: pin controller instance managed by the driver.
@@ -262,6 +266,7 @@ struct samsung_pin_ctrl {
  */
 struct samsung_pinctrl_drv_data {
 	struct list_head		node;
+	void __iomem			*virt_base;
 	struct device			*dev;
 	int				irq;
 

commit 1fc8ad86f73689b4e47f8d3c89aab946120468f3
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Jan 26 10:29:24 2017 +0100

    pinctrl: samsung: Add infrastructure for pin-bank retention control
    
    Pad retention control after suspend/resume cycle should be done from pin
    controller driver instead of PMU (power management unit) driver to avoid
    possible ordering and logical dependencies. Till now it worked fine only
    because PMU driver registered its sys_ops after pin controller.
    
    This patch adds infrastructure to handle pad retention during pin control
    driver resume.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 6f7ce7539a00..515a61035e54 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -184,11 +184,49 @@ struct samsung_pin_bank {
 	u32 pm_save[PINCFG_TYPE_NUM + 1]; /* +1 to handle double CON registers*/
 };
 
+/**
+ * struct samsung_retention_data: runtime pin-bank retention control data.
+ * @regs: array of PMU registers to control pad retention.
+ * @nr_regs: number of registers in @regs array.
+ * @value: value to store to registers to turn off retention.
+ * @refcnt: atomic counter if retention control affects more than one bank.
+ * @priv: retention control code private data
+ * @enable: platform specific callback to enter retention mode.
+ * @disable: platform specific callback to exit retention mode.
+ **/
+struct samsung_retention_ctrl {
+	const u32	*regs;
+	int		nr_regs;
+	u32		value;
+	atomic_t	*refcnt;
+	void		*priv;
+	void		(*enable)(struct samsung_pinctrl_drv_data *);
+	void		(*disable)(struct samsung_pinctrl_drv_data *);
+};
+
+/**
+ * struct samsung_retention_data: represent a pin-bank retention control data.
+ * @regs: array of PMU registers to control pad retention.
+ * @nr_regs: number of registers in @regs array.
+ * @value: value to store to registers to turn off retention.
+ * @refcnt: atomic counter if retention control affects more than one bank.
+ * @init: platform specific callback to initialize retention control.
+ **/
+struct samsung_retention_data {
+	const u32	*regs;
+	int		nr_regs;
+	u32		value;
+	atomic_t	*refcnt;
+	struct samsung_retention_ctrl *(*init)(struct samsung_pinctrl_drv_data *,
+					const struct samsung_retention_data *);
+};
+
 /**
  * struct samsung_pin_ctrl: represent a pin controller.
  * @pin_banks: list of pin banks included in this controller.
  * @nr_banks: number of pin banks.
  * @nr_ext_resources: number of the extra base address for pin banks.
+ * @retention_data: configuration data for retention control.
  * @eint_gpio_init: platform specific callback to setup the external gpio
  *	interrupts for the controller.
  * @eint_wkup_init: platform specific callback to setup the external wakeup
@@ -198,6 +236,7 @@ struct samsung_pin_ctrl {
 	const struct samsung_pin_bank_data *pin_banks;
 	u32		nr_banks;
 	int		nr_ext_resources;
+	const struct samsung_retention_data *retention_data;
 
 	int		(*eint_gpio_init)(struct samsung_pinctrl_drv_data *);
 	int		(*eint_wkup_init)(struct samsung_pinctrl_drv_data *);
@@ -219,6 +258,7 @@ struct samsung_pin_ctrl {
  * @nr_function: number of such pin functions.
  * @pin_base: starting system wide pin number.
  * @nr_pins: number of pins supported by the controller.
+ * @retention_ctrl: retention control runtime data.
  */
 struct samsung_pinctrl_drv_data {
 	struct list_head		node;
@@ -238,6 +278,8 @@ struct samsung_pinctrl_drv_data {
 	unsigned int			pin_base;
 	unsigned int			nr_pins;
 
+	struct samsung_retention_ctrl	*retention_ctrl;
+
 	void (*suspend)(struct samsung_pinctrl_drv_data *);
 	void (*resume)(struct samsung_pinctrl_drv_data *);
 };

commit 9635af833eaf96d0baf2f301b4d804777b786e5d
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Sat Jan 14 14:36:41 2017 +0200

    pinctrl: samsung: Remove support for Exynos4415 (SoC not supported anymore)
    
    Support for Exynos4415 is going away because there are no internal nor
    external users.
    
    Since commit 46dcf0ff0de3 ("ARM: dts: exynos: Remove exynos4415.dtsi"),
    the platform cannot be instantiated so remove also the drivers.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 043cb6c11180..6f7ce7539a00 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -273,7 +273,6 @@ struct samsung_pmx_func {
 extern const struct samsung_pin_ctrl exynos3250_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos4210_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
-extern const struct samsung_pin_ctrl exynos4415_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5250_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5260_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5410_pin_ctrl[];

commit 8b1bd11c1f8f529057369c5b3702d13fd24e2765
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Wed Nov 9 17:40:10 2016 +0900

    pinctrl: samsung: Add the support the multiple IORESOURCE_MEM for one pin-bank
    
    This patch supports the multiple IORESOURCE_MEM resources for one pin-bank.
    In the pre-existing Exynos series, the registers of the gpio bank are included
    in the one memory map. But, some gpio bank need to support the one more memory
    map (IORESOURCE_MEM) because the registers of gpio bank are separated into
    the different memory map.
    
    For example,
    The both ALIVE and IMEM domain have the different memory base address.
    The GFP[1-5] of exynos5433 are composed as following:
    - ALIVE domain : WEINT_* registers
    - IMEM domain  : CON/DAT/PUD/DRV/CONPDN/PUDPDN register
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: linux-gpio@vger.kernel.org
    Suggested-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index cd31bfaf62cb..043cb6c11180 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -116,6 +116,7 @@ struct samsung_pin_bank_type {
  * struct samsung_pin_bank_data: represent a controller pin-bank (init data).
  * @type: type of the bank (register offsets and bitfield widths)
  * @pctl_offset: starting offset of the pin-bank registers.
+ * @pctl_res_idx: index of base address for pin-bank registers.
  * @nr_pins: number of pins included in this bank.
  * @eint_func: function to set in CON register to configure pin as EINT.
  * @eint_type: type of the external interrupt supported by the bank.
@@ -126,6 +127,7 @@ struct samsung_pin_bank_type {
 struct samsung_pin_bank_data {
 	const struct samsung_pin_bank_type *type;
 	u32		pctl_offset;
+	u8		pctl_res_idx;
 	u8		nr_pins;
 	u8		eint_func;
 	enum eint_type	eint_type;
@@ -137,8 +139,10 @@ struct samsung_pin_bank_data {
 /**
  * struct samsung_pin_bank: represent a controller pin-bank.
  * @type: type of the bank (register offsets and bitfield widths)
+ * @pctl_base: base address of the pin-bank registers
  * @pctl_offset: starting offset of the pin-bank registers.
  * @nr_pins: number of pins included in this bank.
+ * @eint_base: base address of the pin-bank EINT registers.
  * @eint_func: function to set in CON register to configure pin as EINT.
  * @eint_type: type of the external interrupt supported by the bank.
  * @eint_mask: bit mask of pins which support EINT function.
@@ -157,8 +161,10 @@ struct samsung_pin_bank_data {
  */
 struct samsung_pin_bank {
 	const struct samsung_pin_bank_type *type;
+	void __iomem	*pctl_base;
 	u32		pctl_offset;
 	u8		nr_pins;
+	void __iomem	*eint_base;
 	u8		eint_func;
 	enum eint_type	eint_type;
 	u32		eint_mask;
@@ -182,6 +188,7 @@ struct samsung_pin_bank {
  * struct samsung_pin_ctrl: represent a pin controller.
  * @pin_banks: list of pin banks included in this controller.
  * @nr_banks: number of pin banks.
+ * @nr_ext_resources: number of the extra base address for pin banks.
  * @eint_gpio_init: platform specific callback to setup the external gpio
  *	interrupts for the controller.
  * @eint_wkup_init: platform specific callback to setup the external wakeup
@@ -190,6 +197,7 @@ struct samsung_pin_bank {
 struct samsung_pin_ctrl {
 	const struct samsung_pin_bank_data *pin_banks;
 	u32		nr_banks;
+	int		nr_ext_resources;
 
 	int		(*eint_gpio_init)(struct samsung_pinctrl_drv_data *);
 	int		(*eint_wkup_init)(struct samsung_pinctrl_drv_data *);
@@ -200,7 +208,6 @@ struct samsung_pin_ctrl {
 /**
  * struct samsung_pinctrl_drv_data: wrapper for holding driver data together.
  * @node: global list node
- * @virt_base: register base address of the controller.
  * @dev: device instance representing the controller.
  * @irq: interrpt number used by the controller to notify gpio interrupts.
  * @ctrl: pin controller instance managed by the driver.
@@ -215,7 +222,6 @@ struct samsung_pin_ctrl {
  */
 struct samsung_pinctrl_drv_data {
 	struct list_head		node;
-	void __iomem			*virt_base;
 	struct device			*dev;
 	int				irq;
 

commit 023e06dfa6882f500b9c86fd61f0b1913aa07f36
Author: Hakjoo Kim <ruppi.kim@hardkernel.com>
Date:   Sun Mar 15 23:00:32 2015 +0100

    pinctrl: exynos: add exynos5410 SoC specific data
    
    Add Samsung EXYNOS5410 SoC specific data to enable pinctrl
    support for all platforms based on EXYNOS5410.
    
    Signed-off-by: Hakjoo Kim <ruppi.kim@hardkernel.com>
    [AF: Rebased onto Exynos5260, irq_chip consolidation, const'ification]
    Signed-off-by: Andreas FÃ¤rber <afaerber@suse.de>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Tested-by: Pavel Fedin <p.fedin@samsung.com>
    [k.kozlowski: Rebased on current v4.3]
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index c1239ff6157d..cd31bfaf62cb 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -270,6 +270,7 @@ extern const struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos4415_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5250_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5260_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos5410_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5420_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5433_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos7_pin_ctrl[];

commit 3c5ecc9ed3537846fd95e8f288d6d6968075879f
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Wed Jan 21 15:43:11 2015 +0900

    pinctrl: exynos: Add support for Exynos5433
    
    This patch adds driver data for Exynos5433 SoC. Exynos5433 includes 228 multi-
    functional input/output port pins and 135 memory port pins. There are 41 general
    port groups and 2 memory port groups.
    
    Cc: Thomas Abraham <thomas.abraham@linaro.org>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 1b8c0139d604..c1239ff6157d 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -271,6 +271,7 @@ extern const struct samsung_pin_ctrl exynos4415_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5250_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5260_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5420_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos5433_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos7_pin_ctrl[];
 extern const struct samsung_pin_ctrl s3c64xx_pin_ctrl[];
 extern const struct samsung_pin_ctrl s3c2412_pin_ctrl[];

commit 2891ba2906b6d2fd453042f410a11e6fc3edc37d
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Mon Oct 27 10:21:18 2014 +0900

    pinctrl: exynos: Add support for Exynos4415
    
    The pin controllers of Exynos4415 are similar to Exynos4412, but certain
    differences cause the need to create separate driver data for it. This
    patch adds pin controller and bank descriptor arrays to the driver to
    support the new SoC.
    
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Thomas Abraham <thomas.abraham@linaro.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>
    [cw00.choi: Rebase it on mainline kernel]
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    [tomasz.figa@gmail.com: Resolved merge with earlier clean-up series.]
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 29004be52eaa..1b8c0139d604 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -267,6 +267,7 @@ struct samsung_pmx_func {
 extern const struct samsung_pin_ctrl exynos3250_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos4210_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos4415_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5250_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5260_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5420_pin_ctrl[];

commit 50cea0cff7131b364c0ff80dedf8e91212b18a26
Author: Naveen Krishna Ch <naveenkrishna.ch@gmail.com>
Date:   Thu Oct 9 19:24:32 2014 +0530

    pinctrl: exynos: Add initial driver data for Exynos7
    
    This patch adds initial driver data for Exynos7 pinctrl support.
    
    Signed-off-by: Naveen Krishna Ch <naveenkrishna.ch@gmail.com>
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Reviewed-by: Thomas Abraham <thomas.ab@samsung.com>
    Tested-by: Thomas Abraham <thomas.ab@samsung.com>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 3076b8b591c7..29004be52eaa 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -270,6 +270,7 @@ extern const struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5250_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5260_pin_ctrl[];
 extern const struct samsung_pin_ctrl exynos5420_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos7_pin_ctrl[];
 extern const struct samsung_pin_ctrl s3c64xx_pin_ctrl[];
 extern const struct samsung_pin_ctrl s3c2412_pin_ctrl[];
 extern const struct samsung_pin_ctrl s3c2416_pin_ctrl[];

commit 0d3d30db93635936652417efd0f4a3e9049d0938
Author: Abhilash Kesavan <a.kesavan@samsung.com>
Date:   Thu Oct 9 19:24:29 2014 +0530

    pinctrl: exynos: Generalize the eint16_31 demux code
    
    The function exynos_irq_demux_eint16_31 uses pre-defined offsets for external
    interrupt pending status and mask registers. So this function is not extensible
    for Exynos7 SoC which has these registers at different offsets. Generalize
    the exynos_irq_demux_eint16_31 function by using the pending/mask register
    offset values from the exynos_irq_chip structure. This is done by adding a
    irq_chip field to the samsung_pin_bank struct.
    
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Reviewed-by: Thomas Abraham <thomas.ab@samsung.com>
    Tested-by: Thomas Abraham <thomas.ab@samsung.com>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index ec43b7d49fb9..3076b8b591c7 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -151,6 +151,7 @@ struct samsung_pin_bank_data {
  * @irq_domain: IRQ domain of the bank.
  * @gpio_chip: GPIO chip of the bank.
  * @grange: linux gpio pin range supported by this bank.
+ * @irq_chip: link to irq chip for external gpio and wakeup interrupts.
  * @slock: spinlock protecting bank registers
  * @pm_save: saved register values during suspend
  */
@@ -171,6 +172,7 @@ struct samsung_pin_bank {
 	struct irq_domain *irq_domain;
 	struct gpio_chip gpio_chip;
 	struct pinctrl_gpio_range grange;
+	struct exynos_irq_chip *irq_chip;
 	spinlock_t slock;
 
 	u32 pm_save[PINCFG_TYPE_NUM + 1]; /* +1 to handle double CON registers*/

commit 8100cf47698fedbde6dc3fa540b1fefcee69fd40
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Tue Sep 23 21:05:41 2014 +0200

    pinctrl: samsung: Separate per-bank init and runtime data
    
    Currently the driver mixes constant init data with runtime data, which
    is far from being elegant and can invite potential hard to track issues.
    This patch intends to solve this by introducing a new
    samsung_pin_bank_data structure to hold only constant data known at
    compile time, which can be copied to main samsung_pin_bank struct used
    at runtime.
    
    In addition, thanks to this change, all per-bank initdata can be marked
    with const and __initconst keywords and dropped after init completes.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index cf2d61d0f001..ec43b7d49fb9 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -112,16 +112,40 @@ struct samsung_pin_bank_type {
 	u8 reg_offset[PINCFG_TYPE_NUM];
 };
 
+/**
+ * struct samsung_pin_bank_data: represent a controller pin-bank (init data).
+ * @type: type of the bank (register offsets and bitfield widths)
+ * @pctl_offset: starting offset of the pin-bank registers.
+ * @nr_pins: number of pins included in this bank.
+ * @eint_func: function to set in CON register to configure pin as EINT.
+ * @eint_type: type of the external interrupt supported by the bank.
+ * @eint_mask: bit mask of pins which support EINT function.
+ * @eint_offset: SoC-specific EINT register or interrupt offset of bank.
+ * @name: name to be prefixed for each pin in this pin bank.
+ */
+struct samsung_pin_bank_data {
+	const struct samsung_pin_bank_type *type;
+	u32		pctl_offset;
+	u8		nr_pins;
+	u8		eint_func;
+	enum eint_type	eint_type;
+	u32		eint_mask;
+	u32		eint_offset;
+	const char	*name;
+};
+
 /**
  * struct samsung_pin_bank: represent a controller pin-bank.
  * @type: type of the bank (register offsets and bitfield widths)
  * @pctl_offset: starting offset of the pin-bank registers.
- * @pin_base: starting pin number of the bank.
  * @nr_pins: number of pins included in this bank.
  * @eint_func: function to set in CON register to configure pin as EINT.
  * @eint_type: type of the external interrupt supported by the bank.
  * @eint_mask: bit mask of pins which support EINT function.
+ * @eint_offset: SoC-specific EINT register or interrupt offset of bank.
  * @name: name to be prefixed for each pin in this pin bank.
+ * @pin_base: starting pin number of the bank.
+ * @soc_priv: per-bank private data for SoC-specific code.
  * @of_node: OF node of the bank.
  * @drvdata: link to controller driver data
  * @irq_domain: IRQ domain of the bank.
@@ -133,13 +157,14 @@ struct samsung_pin_bank_type {
 struct samsung_pin_bank {
 	const struct samsung_pin_bank_type *type;
 	u32		pctl_offset;
-	u32		pin_base;
 	u8		nr_pins;
 	u8		eint_func;
 	enum eint_type	eint_type;
 	u32		eint_mask;
 	u32		eint_offset;
-	char		*name;
+	const char	*name;
+
+	u32		pin_base;
 	void		*soc_priv;
 	struct device_node *of_node;
 	struct samsung_pinctrl_drv_data *drvdata;
@@ -161,7 +186,7 @@ struct samsung_pin_bank {
  *	interrupts for the controller.
  */
 struct samsung_pin_ctrl {
-	struct samsung_pin_bank	*pin_banks;
+	const struct samsung_pin_bank_data *pin_banks;
 	u32		nr_banks;
 
 	int		(*eint_gpio_init)(struct samsung_pinctrl_drv_data *);

commit 1bf00d7a6dbff0a29eff4f8c022653b2bc9f5b97
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Tue Sep 23 21:05:40 2014 +0200

    pinctrl: samsung: Constify samsung_pin_ctrl struct
    
    In order to separate initialization constants from runtime data, this
    patch modifies the driver to store only constant data in
    samsung_pin_ctrl struct and copy data required at runtime to
    samsung_pinctrl_drv_data struct. This makes it possible to mark all
    existing instances of samsung_pin_ctrl struct as const and __initconst.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index c67738597d2a..cf2d61d0f001 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -155,8 +155,6 @@ struct samsung_pin_bank {
  * struct samsung_pin_ctrl: represent a pin controller.
  * @pin_banks: list of pin banks included in this controller.
  * @nr_banks: number of pin banks.
- * @base: starting system wide pin number.
- * @nr_pins: number of pins supported by the controller.
  * @eint_gpio_init: platform specific callback to setup the external gpio
  *	interrupts for the controller.
  * @eint_wkup_init: platform specific callback to setup the external wakeup
@@ -166,9 +164,6 @@ struct samsung_pin_ctrl {
 	struct samsung_pin_bank	*pin_banks;
 	u32		nr_banks;
 
-	u32		base;
-	u32		nr_pins;
-
 	int		(*eint_gpio_init)(struct samsung_pinctrl_drv_data *);
 	int		(*eint_wkup_init)(struct samsung_pinctrl_drv_data *);
 	void		(*suspend)(struct samsung_pinctrl_drv_data *);
@@ -188,6 +183,8 @@ struct samsung_pin_ctrl {
  * @nr_groups: number of such pin groups.
  * @pmx_functions: list of pin functions available to the driver.
  * @nr_function: number of such pin functions.
+ * @pin_base: starting system wide pin number.
+ * @nr_pins: number of pins supported by the controller.
  */
 struct samsung_pinctrl_drv_data {
 	struct list_head		node;
@@ -195,7 +192,6 @@ struct samsung_pinctrl_drv_data {
 	struct device			*dev;
 	int				irq;
 
-	struct samsung_pin_ctrl		*ctrl;
 	struct pinctrl_desc		pctl;
 	struct pinctrl_dev		*pctl_dev;
 
@@ -203,6 +199,14 @@ struct samsung_pinctrl_drv_data {
 	unsigned int			nr_groups;
 	const struct samsung_pmx_func	*pmx_functions;
 	unsigned int			nr_functions;
+
+	struct samsung_pin_bank		*pin_banks;
+	u32				nr_banks;
+	unsigned int			pin_base;
+	unsigned int			nr_pins;
+
+	void (*suspend)(struct samsung_pinctrl_drv_data *);
+	void (*resume)(struct samsung_pinctrl_drv_data *);
 };
 
 /**
@@ -233,17 +237,17 @@ struct samsung_pmx_func {
 };
 
 /* list of all exported SoC specific data */
-extern struct samsung_pin_ctrl exynos3250_pin_ctrl[];
-extern struct samsung_pin_ctrl exynos4210_pin_ctrl[];
-extern struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
-extern struct samsung_pin_ctrl exynos5250_pin_ctrl[];
-extern struct samsung_pin_ctrl exynos5260_pin_ctrl[];
-extern struct samsung_pin_ctrl exynos5420_pin_ctrl[];
-extern struct samsung_pin_ctrl s3c64xx_pin_ctrl[];
-extern struct samsung_pin_ctrl s3c2412_pin_ctrl[];
-extern struct samsung_pin_ctrl s3c2416_pin_ctrl[];
-extern struct samsung_pin_ctrl s3c2440_pin_ctrl[];
-extern struct samsung_pin_ctrl s3c2450_pin_ctrl[];
-extern struct samsung_pin_ctrl s5pv210_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos3250_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos4210_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos5250_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos5260_pin_ctrl[];
+extern const struct samsung_pin_ctrl exynos5420_pin_ctrl[];
+extern const struct samsung_pin_ctrl s3c64xx_pin_ctrl[];
+extern const struct samsung_pin_ctrl s3c2412_pin_ctrl[];
+extern const struct samsung_pin_ctrl s3c2416_pin_ctrl[];
+extern const struct samsung_pin_ctrl s3c2440_pin_ctrl[];
+extern const struct samsung_pin_ctrl s3c2450_pin_ctrl[];
+extern const struct samsung_pin_ctrl s5pv210_pin_ctrl[];
 
 #endif /* __PINCTRL_SAMSUNG_H */

commit 94ce944bed8a849a9b83b4e66f0e6e4abc16c457
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Tue Sep 23 21:05:39 2014 +0200

    pinctrl: samsung: Constify samsung_pin_bank_type struct
    
    This structure is not intended to be modified at runtime and functions
    as constant data shared between multiple pin banks. This patch makes all
    instances of it constant across the driver.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index da527b390513..c67738597d2a 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -131,7 +131,7 @@ struct samsung_pin_bank_type {
  * @pm_save: saved register values during suspend
  */
 struct samsung_pin_bank {
-	struct samsung_pin_bank_type *type;
+	const struct samsung_pin_bank_type *type;
 	u32		pctl_offset;
 	u32		pin_base;
 	u8		nr_pins;

commit e06deff967d29beffceeaffc4cdc90aacbd34898
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Tue Sep 23 21:05:38 2014 +0200

    pinctrl: samsung: Drop unused label field in samsung_pin_ctrl struct
    
    There is no code using it and in fact there are pin controller variants
    that do not even have this field initialized in their init data. This
    patch removes it completely.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 5cedc9d26390..da527b390513 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -161,7 +161,6 @@ struct samsung_pin_bank {
  *	interrupts for the controller.
  * @eint_wkup_init: platform specific callback to setup the external wakeup
  *	interrupts for the controller.
- * @label: for debug information.
  */
 struct samsung_pin_ctrl {
 	struct samsung_pin_bank	*pin_banks;
@@ -174,8 +173,6 @@ struct samsung_pin_ctrl {
 	int		(*eint_wkup_init)(struct samsung_pinctrl_drv_data *);
 	void		(*suspend)(struct samsung_pinctrl_drv_data *);
 	void		(*resume)(struct samsung_pinctrl_drv_data *);
-
-	char		*label;
 };
 
 /**

commit f6a8249f9e55d45a47777d2a3cc69defa23c87bb
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Sat Aug 9 01:48:05 2014 +0200

    pinctrl: exynos: Lock GPIOs as interrupts when used as EINTs
    
    Currently after configuring a GPIO pin as an interrupt related pinmux
    registers are changed, but there is no protection from calling
    gpio_direction_*() in a badly written driver, which would cause the same
    pinmux register to be reconfigured for regular input/output and this
    disabling interrupt capability of the pin.
    
    This patch addresses this issue by moving pinmux reconfiguration to
    .irq_{request,release}_resources() callback of irq_chip and calling
    gpio_lock_as_irq() helper to prevent reconfiguration of pin direction.
    
    Setting up a GPIO interrupt on Samsung SoCs is a two-step operation -
    in addition to trigger configuration in a dedicated register, the pinmux
    must be also reconfigured to GPIO interrupt, which is a different function
    than normal GPIO input, although I/O-wise they both behave in the same way
    and gpio_get_value() can be used on a pin configured as IRQ as well.
    
    Such design implies subtleties such as gpio_direction_input() not having
    to fail if a pin is already configured as an interrupt nor change the
    configuration to normal input. But the FLAG_USED_AS_IRQ set in gpiolib by
    gpio_lock_as_irq() is only used to check that gpio_direction_output() is
    not called, it's not used to prevent gpio_direction_input() to be called.
    So this is not a complete solution for Samsung SoCs but it's definitely a
    move in the right direction.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    [javier: use request resources instead of startup and expand commit message]
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
index 2b882320e8e9..5cedc9d26390 100644
--- a/drivers/pinctrl/samsung/pinctrl-samsung.h
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -26,6 +26,7 @@
 #include <linux/gpio.h>
 
 /* pinmux function number for pin as gpio output line */
+#define FUNC_INPUT	0x0
 #define FUNC_OUTPUT	0x1
 
 /**

commit ebe629a39e04db3fe876d34833a2d8a6a6d4c134
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Thu Jul 10 17:33:27 2014 +0530

    pinctrl: samsung: Group all drivers in a sub-dir
    
    Group all pin control drivers of Samsung platform together in
    a sub-directory for easy maintenance.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h
new file mode 100644
index 000000000000..2b882320e8e9
--- /dev/null
+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h
@@ -0,0 +1,251 @@
+/*
+ * pin-controller/pin-mux/pin-config/gpio-driver for Samsung's SoC's.
+ *
+ * Copyright (c) 2012 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ * Copyright (c) 2012 Linaro Ltd
+ *		http://www.linaro.org
+ *
+ * Author: Thomas Abraham <thomas.ab@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __PINCTRL_SAMSUNG_H
+#define __PINCTRL_SAMSUNG_H
+
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+
+#include <linux/gpio.h>
+
+/* pinmux function number for pin as gpio output line */
+#define FUNC_OUTPUT	0x1
+
+/**
+ * enum pincfg_type - possible pin configuration types supported.
+ * @PINCFG_TYPE_FUNC: Function configuration.
+ * @PINCFG_TYPE_DAT: Pin value configuration.
+ * @PINCFG_TYPE_PUD: Pull up/down configuration.
+ * @PINCFG_TYPE_DRV: Drive strength configuration.
+ * @PINCFG_TYPE_CON_PDN: Pin function in power down mode.
+ * @PINCFG_TYPE_PUD_PDN: Pull up/down configuration in power down mode.
+ */
+enum pincfg_type {
+	PINCFG_TYPE_FUNC,
+	PINCFG_TYPE_DAT,
+	PINCFG_TYPE_PUD,
+	PINCFG_TYPE_DRV,
+	PINCFG_TYPE_CON_PDN,
+	PINCFG_TYPE_PUD_PDN,
+
+	PINCFG_TYPE_NUM
+};
+
+/*
+ * pin configuration (pull up/down and drive strength) type and its value are
+ * packed together into a 16-bits. The upper 8-bits represent the configuration
+ * type and the lower 8-bits hold the value of the configuration type.
+ */
+#define PINCFG_TYPE_MASK		0xFF
+#define PINCFG_VALUE_SHIFT		8
+#define PINCFG_VALUE_MASK		(0xFF << PINCFG_VALUE_SHIFT)
+#define PINCFG_PACK(type, value)	(((value) << PINCFG_VALUE_SHIFT) | type)
+#define PINCFG_UNPACK_TYPE(cfg)		((cfg) & PINCFG_TYPE_MASK)
+#define PINCFG_UNPACK_VALUE(cfg)	(((cfg) & PINCFG_VALUE_MASK) >> \
+						PINCFG_VALUE_SHIFT)
+/**
+ * enum eint_type - possible external interrupt types.
+ * @EINT_TYPE_NONE: bank does not support external interrupts
+ * @EINT_TYPE_GPIO: bank supportes external gpio interrupts
+ * @EINT_TYPE_WKUP: bank supportes external wakeup interrupts
+ * @EINT_TYPE_WKUP_MUX: bank supports multiplexed external wakeup interrupts
+ *
+ * Samsung GPIO controller groups all the available pins into banks. The pins
+ * in a pin bank can support external gpio interrupts or external wakeup
+ * interrupts or no interrupts at all. From a software perspective, the only
+ * difference between external gpio and external wakeup interrupts is that
+ * the wakeup interrupts can additionally wakeup the system if it is in
+ * suspended state.
+ */
+enum eint_type {
+	EINT_TYPE_NONE,
+	EINT_TYPE_GPIO,
+	EINT_TYPE_WKUP,
+	EINT_TYPE_WKUP_MUX,
+};
+
+/* maximum length of a pin in pin descriptor (example: "gpa0-0") */
+#define PIN_NAME_LENGTH	10
+
+#define PIN_GROUP(n, p, f)				\
+	{						\
+		.name		= n,			\
+		.pins		= p,			\
+		.num_pins	= ARRAY_SIZE(p),	\
+		.func		= f			\
+	}
+
+#define PMX_FUNC(n, g)					\
+	{						\
+		.name		= n,			\
+		.groups		= g,			\
+		.num_groups	= ARRAY_SIZE(g),	\
+	}
+
+struct samsung_pinctrl_drv_data;
+
+/**
+ * struct samsung_pin_bank_type: pin bank type description
+ * @fld_width: widths of configuration bitfields (0 if unavailable)
+ * @reg_offset: offsets of configuration registers (don't care of width is 0)
+ */
+struct samsung_pin_bank_type {
+	u8 fld_width[PINCFG_TYPE_NUM];
+	u8 reg_offset[PINCFG_TYPE_NUM];
+};
+
+/**
+ * struct samsung_pin_bank: represent a controller pin-bank.
+ * @type: type of the bank (register offsets and bitfield widths)
+ * @pctl_offset: starting offset of the pin-bank registers.
+ * @pin_base: starting pin number of the bank.
+ * @nr_pins: number of pins included in this bank.
+ * @eint_func: function to set in CON register to configure pin as EINT.
+ * @eint_type: type of the external interrupt supported by the bank.
+ * @eint_mask: bit mask of pins which support EINT function.
+ * @name: name to be prefixed for each pin in this pin bank.
+ * @of_node: OF node of the bank.
+ * @drvdata: link to controller driver data
+ * @irq_domain: IRQ domain of the bank.
+ * @gpio_chip: GPIO chip of the bank.
+ * @grange: linux gpio pin range supported by this bank.
+ * @slock: spinlock protecting bank registers
+ * @pm_save: saved register values during suspend
+ */
+struct samsung_pin_bank {
+	struct samsung_pin_bank_type *type;
+	u32		pctl_offset;
+	u32		pin_base;
+	u8		nr_pins;
+	u8		eint_func;
+	enum eint_type	eint_type;
+	u32		eint_mask;
+	u32		eint_offset;
+	char		*name;
+	void		*soc_priv;
+	struct device_node *of_node;
+	struct samsung_pinctrl_drv_data *drvdata;
+	struct irq_domain *irq_domain;
+	struct gpio_chip gpio_chip;
+	struct pinctrl_gpio_range grange;
+	spinlock_t slock;
+
+	u32 pm_save[PINCFG_TYPE_NUM + 1]; /* +1 to handle double CON registers*/
+};
+
+/**
+ * struct samsung_pin_ctrl: represent a pin controller.
+ * @pin_banks: list of pin banks included in this controller.
+ * @nr_banks: number of pin banks.
+ * @base: starting system wide pin number.
+ * @nr_pins: number of pins supported by the controller.
+ * @eint_gpio_init: platform specific callback to setup the external gpio
+ *	interrupts for the controller.
+ * @eint_wkup_init: platform specific callback to setup the external wakeup
+ *	interrupts for the controller.
+ * @label: for debug information.
+ */
+struct samsung_pin_ctrl {
+	struct samsung_pin_bank	*pin_banks;
+	u32		nr_banks;
+
+	u32		base;
+	u32		nr_pins;
+
+	int		(*eint_gpio_init)(struct samsung_pinctrl_drv_data *);
+	int		(*eint_wkup_init)(struct samsung_pinctrl_drv_data *);
+	void		(*suspend)(struct samsung_pinctrl_drv_data *);
+	void		(*resume)(struct samsung_pinctrl_drv_data *);
+
+	char		*label;
+};
+
+/**
+ * struct samsung_pinctrl_drv_data: wrapper for holding driver data together.
+ * @node: global list node
+ * @virt_base: register base address of the controller.
+ * @dev: device instance representing the controller.
+ * @irq: interrpt number used by the controller to notify gpio interrupts.
+ * @ctrl: pin controller instance managed by the driver.
+ * @pctl: pin controller descriptor registered with the pinctrl subsystem.
+ * @pctl_dev: cookie representing pinctrl device instance.
+ * @pin_groups: list of pin groups available to the driver.
+ * @nr_groups: number of such pin groups.
+ * @pmx_functions: list of pin functions available to the driver.
+ * @nr_function: number of such pin functions.
+ */
+struct samsung_pinctrl_drv_data {
+	struct list_head		node;
+	void __iomem			*virt_base;
+	struct device			*dev;
+	int				irq;
+
+	struct samsung_pin_ctrl		*ctrl;
+	struct pinctrl_desc		pctl;
+	struct pinctrl_dev		*pctl_dev;
+
+	const struct samsung_pin_group	*pin_groups;
+	unsigned int			nr_groups;
+	const struct samsung_pmx_func	*pmx_functions;
+	unsigned int			nr_functions;
+};
+
+/**
+ * struct samsung_pin_group: represent group of pins of a pinmux function.
+ * @name: name of the pin group, used to lookup the group.
+ * @pins: the pins included in this group.
+ * @num_pins: number of pins included in this group.
+ * @func: the function number to be programmed when selected.
+ */
+struct samsung_pin_group {
+	const char		*name;
+	const unsigned int	*pins;
+	u8			num_pins;
+	u8			func;
+};
+
+/**
+ * struct samsung_pmx_func: represent a pin function.
+ * @name: name of the pin function, used to lookup the function.
+ * @groups: one or more names of pin groups that provide this function.
+ * @num_groups: number of groups included in @groups.
+ */
+struct samsung_pmx_func {
+	const char		*name;
+	const char		**groups;
+	u8			num_groups;
+	u32			val;
+};
+
+/* list of all exported SoC specific data */
+extern struct samsung_pin_ctrl exynos3250_pin_ctrl[];
+extern struct samsung_pin_ctrl exynos4210_pin_ctrl[];
+extern struct samsung_pin_ctrl exynos4x12_pin_ctrl[];
+extern struct samsung_pin_ctrl exynos5250_pin_ctrl[];
+extern struct samsung_pin_ctrl exynos5260_pin_ctrl[];
+extern struct samsung_pin_ctrl exynos5420_pin_ctrl[];
+extern struct samsung_pin_ctrl s3c64xx_pin_ctrl[];
+extern struct samsung_pin_ctrl s3c2412_pin_ctrl[];
+extern struct samsung_pin_ctrl s3c2416_pin_ctrl[];
+extern struct samsung_pin_ctrl s3c2440_pin_ctrl[];
+extern struct samsung_pin_ctrl s3c2450_pin_ctrl[];
+extern struct samsung_pin_ctrl s5pv210_pin_ctrl[];
+
+#endif /* __PINCTRL_SAMSUNG_H */
