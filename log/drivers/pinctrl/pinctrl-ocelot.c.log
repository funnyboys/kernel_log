commit 0b47afc65453a70bc521e251138418056f65793f
Author: Lars Povlsen <lars.povlsen@microchip.com>
Date:   Wed May 13 14:55:21 2020 +0200

    pinctrl: ocelot: Fix GPIO interrupt decoding on Jaguar2
    
    This fixes a problem with using the GPIO as an interrupt on Jaguar2
    (and similar), as the register layout of the platforms with 64 GPIO's
    are pairwise, such that the original offset must be multiplied with
    the platform stride.
    
    Fixes: da801ab56ad8 pinctrl: ocelot: add MSCC Jaguar2 support.
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Lars Povlsen <lars.povlsen@microchip.com>
    Link: https://lore.kernel.org/r/20200513125532.24585-4-lars.povlsen@microchip.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index 375f3ea3b80c..95c225bc7572 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -680,11 +680,12 @@ static void ocelot_irq_handler(struct irq_desc *desc)
 	struct irq_chip *parent_chip = irq_desc_get_chip(desc);
 	struct gpio_chip *chip = irq_desc_get_handler_data(desc);
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int id_reg = OCELOT_GPIO_INTR_IDENT * info->stride;
 	unsigned int reg = 0, irq, i;
 	unsigned long irqs;
 
 	for (i = 0; i < info->stride; i++) {
-		regmap_read(info->map, OCELOT_GPIO_INTR_IDENT + 4 * i, &reg);
+		regmap_read(info->map, id_reg + 4 * i, &reg);
 		if (!reg)
 			continue;
 

commit edc7254664abdcd087e49849f0ba6489c1f19b49
Author: Lars Povlsen <lars.povlsen@microchip.com>
Date:   Wed May 13 14:55:20 2020 +0200

    pinctrl: ocelot: Remove instance number from pin functions
    
    This patch removes the instance number from the "miim", "reco_clk" and
    "sfp" pin function.
    
    The change needed is to prepare the driver for adding new platforms
    with more of these instances. The instance number is also redundant,
    as this is implicit for each pin.
    
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Lars Povlsen <lars.povlsen@microchip.com>
    Link: https://lore.kernel.org/r/20200513125532.24585-3-lars.povlsen@microchip.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index d4ac65b1efc0..375f3ea3b80c 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -46,32 +46,15 @@ enum {
 	FUNC_IRQ0_OUT,
 	FUNC_IRQ1_IN,
 	FUNC_IRQ1_OUT,
-	FUNC_MIIM1,
-	FUNC_MIIM2,
+	FUNC_MIIM,
 	FUNC_PCI_WAKE,
 	FUNC_PTP0,
 	FUNC_PTP1,
 	FUNC_PTP2,
 	FUNC_PTP3,
 	FUNC_PWM,
-	FUNC_RECO_CLK0,
-	FUNC_RECO_CLK1,
-	FUNC_SFP0,
-	FUNC_SFP1,
-	FUNC_SFP2,
-	FUNC_SFP3,
-	FUNC_SFP4,
-	FUNC_SFP5,
-	FUNC_SFP6,
-	FUNC_SFP7,
-	FUNC_SFP8,
-	FUNC_SFP9,
-	FUNC_SFP10,
-	FUNC_SFP11,
-	FUNC_SFP12,
-	FUNC_SFP13,
-	FUNC_SFP14,
-	FUNC_SFP15,
+	FUNC_RECO_CLK,
+	FUNC_SFP,
 	FUNC_SG0,
 	FUNC_SG1,
 	FUNC_SG2,
@@ -92,32 +75,15 @@ static const char *const ocelot_function_names[] = {
 	[FUNC_IRQ0_OUT]		= "irq0_out",
 	[FUNC_IRQ1_IN]		= "irq1_in",
 	[FUNC_IRQ1_OUT]		= "irq1_out",
-	[FUNC_MIIM1]		= "miim1",
-	[FUNC_MIIM2]		= "miim2",
+	[FUNC_MIIM]		= "miim",
 	[FUNC_PCI_WAKE]		= "pci_wake",
 	[FUNC_PTP0]		= "ptp0",
 	[FUNC_PTP1]		= "ptp1",
 	[FUNC_PTP2]		= "ptp2",
 	[FUNC_PTP3]		= "ptp3",
 	[FUNC_PWM]		= "pwm",
-	[FUNC_RECO_CLK0]	= "reco_clk0",
-	[FUNC_RECO_CLK1]	= "reco_clk1",
-	[FUNC_SFP0]		= "sfp0",
-	[FUNC_SFP1]		= "sfp1",
-	[FUNC_SFP2]		= "sfp2",
-	[FUNC_SFP3]		= "sfp3",
-	[FUNC_SFP4]		= "sfp4",
-	[FUNC_SFP5]		= "sfp5",
-	[FUNC_SFP6]		= "sfp6",
-	[FUNC_SFP7]		= "sfp7",
-	[FUNC_SFP8]		= "sfp8",
-	[FUNC_SFP9]		= "sfp9",
-	[FUNC_SFP10]		= "sfp10",
-	[FUNC_SFP11]		= "sfp11",
-	[FUNC_SFP12]		= "sfp12",
-	[FUNC_SFP13]		= "sfp13",
-	[FUNC_SFP14]		= "sfp14",
-	[FUNC_SFP15]		= "sfp15",
+	[FUNC_RECO_CLK]		= "reco_clk",
+	[FUNC_SFP]		= "sfp",
 	[FUNC_SG0]		= "sg0",
 	[FUNC_SG1]		= "sg1",
 	[FUNC_SG2]		= "sg2",
@@ -168,18 +134,18 @@ OCELOT_P(6,  UART,      TWI_SCL_M, NONE);
 OCELOT_P(7,  UART,      TWI_SCL_M, NONE);
 OCELOT_P(8,  SI,        TWI_SCL_M, IRQ0_OUT);
 OCELOT_P(9,  SI,        TWI_SCL_M, IRQ1_OUT);
-OCELOT_P(10, PTP2,      TWI_SCL_M, SFP0);
-OCELOT_P(11, PTP3,      TWI_SCL_M, SFP1);
-OCELOT_P(12, UART2,     TWI_SCL_M, SFP2);
-OCELOT_P(13, UART2,     TWI_SCL_M, SFP3);
-OCELOT_P(14, MIIM1,     TWI_SCL_M, SFP4);
-OCELOT_P(15, MIIM1,     TWI_SCL_M, SFP5);
+OCELOT_P(10, PTP2,      TWI_SCL_M, SFP);
+OCELOT_P(11, PTP3,      TWI_SCL_M, SFP);
+OCELOT_P(12, UART2,     TWI_SCL_M, SFP);
+OCELOT_P(13, UART2,     TWI_SCL_M, SFP);
+OCELOT_P(14, MIIM,      TWI_SCL_M, SFP);
+OCELOT_P(15, MIIM,      TWI_SCL_M, SFP);
 OCELOT_P(16, TWI,       NONE,      SI);
 OCELOT_P(17, TWI,       TWI_SCL_M, SI);
 OCELOT_P(18, PTP0,      TWI_SCL_M, NONE);
 OCELOT_P(19, PTP1,      TWI_SCL_M, NONE);
-OCELOT_P(20, RECO_CLK0, TACHO,     NONE);
-OCELOT_P(21, RECO_CLK1, PWM,       NONE);
+OCELOT_P(20, RECO_CLK,  TACHO,     TWI_SCL_M);
+OCELOT_P(21, RECO_CLK,  PWM,       TWI_SCL_M);
 
 #define OCELOT_PIN(n) {						\
 	.number = n,						\
@@ -264,22 +230,22 @@ JAGUAR2_P(40, NONE,      TWI_SCL_M);
 JAGUAR2_P(41, NONE,      TWI_SCL_M);
 JAGUAR2_P(42, NONE,      TWI_SCL_M);
 JAGUAR2_P(43, NONE,      TWI_SCL_M);
-JAGUAR2_P(44, NONE,      SFP8);
-JAGUAR2_P(45, NONE,      SFP9);
-JAGUAR2_P(46, NONE,      SFP10);
-JAGUAR2_P(47, NONE,      SFP11);
-JAGUAR2_P(48, SFP0,      NONE);
-JAGUAR2_P(49, SFP1,      SI);
-JAGUAR2_P(50, SFP2,      SI);
-JAGUAR2_P(51, SFP3,      SI);
-JAGUAR2_P(52, SFP4,      NONE);
-JAGUAR2_P(53, SFP5,      NONE);
-JAGUAR2_P(54, SFP6,      NONE);
-JAGUAR2_P(55, SFP7,      NONE);
-JAGUAR2_P(56, MIIM1,     SFP12);
-JAGUAR2_P(57, MIIM1,     SFP13);
-JAGUAR2_P(58, MIIM2,     SFP14);
-JAGUAR2_P(59, MIIM2,     SFP15);
+JAGUAR2_P(44, NONE,      SFP);
+JAGUAR2_P(45, NONE,      SFP);
+JAGUAR2_P(46, NONE,      SFP);
+JAGUAR2_P(47, NONE,      SFP);
+JAGUAR2_P(48, SFP,       NONE);
+JAGUAR2_P(49, SFP,       SI);
+JAGUAR2_P(50, SFP,       SI);
+JAGUAR2_P(51, SFP,       SI);
+JAGUAR2_P(52, SFP,       NONE);
+JAGUAR2_P(53, SFP,       NONE);
+JAGUAR2_P(54, SFP,       NONE);
+JAGUAR2_P(55, SFP,       NONE);
+JAGUAR2_P(56, MIIM,      SFP);
+JAGUAR2_P(57, MIIM,      SFP);
+JAGUAR2_P(58, MIIM,      SFP);
+JAGUAR2_P(59, MIIM,      SFP);
 JAGUAR2_P(60, NONE,      NONE);
 JAGUAR2_P(61, NONE,      NONE);
 JAGUAR2_P(62, NONE,      NONE);

commit 550713e33f4338c8596776828a936fd1e3bf35de
Author: Lars Povlsen <lars.povlsen@microchip.com>
Date:   Wed May 13 14:55:19 2020 +0200

    pinctrl: ocelot: Always register GPIO driver
    
    This fixes the situation where the GPIO controller is not
    used as an interrupt controller as well.
    
    Previously, the driver would silently fail to register even the
    GPIO's. With this change, the driver will only register as an
    interrupt controller if a parent interrupt is provided.
    
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Lars Povlsen <lars.povlsen@microchip.com>
    Link: https://lore.kernel.org/r/20200513125532.24585-2-lars.povlsen@microchip.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index ed8eac6c1494..d4ac65b1efc0 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -751,21 +751,21 @@ static int ocelot_gpiochip_register(struct platform_device *pdev,
 	gc->of_node = info->dev->of_node;
 	gc->label = "ocelot-gpio";
 
-	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
-	if (irq <= 0)
-		return irq;
-
-	girq = &gc->irq;
-	girq->chip = &ocelot_irqchip;
-	girq->parent_handler = ocelot_irq_handler;
-	girq->num_parents = 1;
-	girq->parents = devm_kcalloc(&pdev->dev, 1, sizeof(*girq->parents),
-				     GFP_KERNEL);
-	if (!girq->parents)
-		return -ENOMEM;
-	girq->parents[0] = irq;
-	girq->default_type = IRQ_TYPE_NONE;
-	girq->handler = handle_edge_irq;
+	irq = irq_of_parse_and_map(gc->of_node, 0);
+	if (irq) {
+		girq = &gc->irq;
+		girq->chip = &ocelot_irqchip;
+		girq->parent_handler = ocelot_irq_handler;
+		girq->num_parents = 1;
+		girq->parents = devm_kcalloc(&pdev->dev, 1,
+					     sizeof(*girq->parents),
+					     GFP_KERNEL);
+		if (!girq->parents)
+			return -ENOMEM;
+		girq->parents[0] = irq;
+		girq->default_type = IRQ_TYPE_NONE;
+		girq->handler = handle_edge_irq;
+	}
 
 	ret = devm_gpiochip_add_data(&pdev->dev, gc, info);
 	if (ret)

commit 3c827873590c3f49c76d540c1e646135a11e0b4e
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Fri Feb 14 15:57:12 2020 +0200

    pinctrl: Use new GPIO_LINE_DIRECTION
    
    Use newly added GPIO defines GPIO_LINE_DIRECTION_IN and
    GPIO_LINE_DIRECTION_OUT instead of using hard-coded 1 and 0.
    
    Main benefit is to make it easier to see which values mean IN and which
    OUT. As a side effect this helps GPIO framework to change the direction
    defines to something else if ever needed.
    
    Please note that return value from get_direction call on
    pinctrl-axp209 driver was changed. Previously pinctrl-axp209 might have
    returned value 2 for direction INPUT.
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Reported-by: kbuild test robot <lkp@intel.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Jacopo Mondi <jacopo+renesas@jmondi.org>
    Link: https://lore.kernel.org/r/20200214135712.GA14557@localhost.localdomain
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index eb3dd0d46d6c..ed8eac6c1494 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -604,7 +604,10 @@ static int ocelot_gpio_get_direction(struct gpio_chip *chip,
 
 	regmap_read(info->map, REG(OCELOT_GPIO_OE, info, offset), &val);
 
-	return !(val & BIT(offset % 32));
+	if (val & BIT(offset % 32))
+		return GPIO_LINE_DIRECTION_OUT;
+
+	return GPIO_LINE_DIRECTION_IN;
 }
 
 static int ocelot_gpio_direction_input(struct gpio_chip *chip,

commit d874beca9f4e8c93cfe9b18570f65ee3c50275f3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 2 13:44:54 2019 +0200

    pinctrl: ocelot: Pass irqchip when adding gpiochip
    
    We need to convert all old gpio irqchips to pass the irqchip
    setup along when adding the gpio_chip. For more info see
    drivers/gpio/TODO.
    
    For chained irqchips this is a pretty straight-forward
    conversion.
    
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20191002114454.9684-1-linus.walleij@linaro.org

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index fb76fb2e9ea5..eb3dd0d46d6c 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -736,6 +736,7 @@ static int ocelot_gpiochip_register(struct platform_device *pdev,
 				    struct ocelot_pinctrl *info)
 {
 	struct gpio_chip *gc;
+	struct gpio_irq_chip *girq;
 	int ret, irq;
 
 	info->gpio_chip = ocelot_gpiolib_chip;
@@ -747,22 +748,26 @@ static int ocelot_gpiochip_register(struct platform_device *pdev,
 	gc->of_node = info->dev->of_node;
 	gc->label = "ocelot-gpio";
 
-	ret = devm_gpiochip_add_data(&pdev->dev, gc, info);
-	if (ret)
-		return ret;
-
 	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
 	if (irq <= 0)
 		return irq;
 
-	ret = gpiochip_irqchip_add(gc, &ocelot_irqchip, 0, handle_edge_irq,
-				   IRQ_TYPE_NONE);
+	girq = &gc->irq;
+	girq->chip = &ocelot_irqchip;
+	girq->parent_handler = ocelot_irq_handler;
+	girq->num_parents = 1;
+	girq->parents = devm_kcalloc(&pdev->dev, 1, sizeof(*girq->parents),
+				     GFP_KERNEL);
+	if (!girq->parents)
+		return -ENOMEM;
+	girq->parents[0] = irq;
+	girq->default_type = IRQ_TYPE_NONE;
+	girq->handler = handle_edge_irq;
+
+	ret = devm_gpiochip_add_data(&pdev->dev, gc, info);
 	if (ret)
 		return ret;
 
-	gpiochip_set_chained_irqchip(gc, &ocelot_irqchip, irq,
-				     ocelot_irq_handler);
-
 	return 0;
 }
 

commit 4b36082e2e09c2769710756390d54cfca563ed96
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Jun 20 20:30:37 2019 +0200

    pinctrl: ocelot: fix pinmuxing for pins after 31
    
    The actual layout for OCELOT_GPIO_ALT[01] when there are more than 32 pins
    is interleaved, i.e. OCELOT_GPIO_ALT0[0], OCELOT_GPIO_ALT1[0],
    OCELOT_GPIO_ALT0[1], OCELOT_GPIO_ALT1[1]. Introduce a new REG_ALT macro to
    facilitate the register offset calculation and use it where necessary.
    
    Fixes: da801ab56ad8 pinctrl: ocelot: add MSCC Jaguar2 support
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index d2478db975bd..fb76fb2e9ea5 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -396,7 +396,7 @@ static int ocelot_pin_function_idx(struct ocelot_pinctrl *info,
 	return -1;
 }
 
-#define REG(r, info, p) ((r) * (info)->stride + (4 * ((p) / 32)))
+#define REG_ALT(msb, info, p) (OCELOT_GPIO_ALT0 * (info)->stride + 4 * ((msb) + ((info)->stride * ((p) / 32))))
 
 static int ocelot_pinmux_set_mux(struct pinctrl_dev *pctldev,
 				 unsigned int selector, unsigned int group)
@@ -412,19 +412,21 @@ static int ocelot_pinmux_set_mux(struct pinctrl_dev *pctldev,
 
 	/*
 	 * f is encoded on two bits.
-	 * bit 0 of f goes in BIT(pin) of ALT0, bit 1 of f goes in BIT(pin) of
-	 * ALT1
+	 * bit 0 of f goes in BIT(pin) of ALT[0], bit 1 of f goes in BIT(pin) of
+	 * ALT[1]
 	 * This is racy because both registers can't be updated at the same time
 	 * but it doesn't matter much for now.
 	 */
-	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT0, info, pin->pin),
+	regmap_update_bits(info->map, REG_ALT(0, info, pin->pin),
 			   BIT(p), f << p);
-	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT1, info, pin->pin),
+	regmap_update_bits(info->map, REG_ALT(1, info, pin->pin),
 			   BIT(p), f << (p - 1));
 
 	return 0;
 }
 
+#define REG(r, info, p) ((r) * (info)->stride + (4 * ((p) / 32)))
+
 static int ocelot_gpio_set_direction(struct pinctrl_dev *pctldev,
 				     struct pinctrl_gpio_range *range,
 				     unsigned int pin, bool input)
@@ -445,9 +447,9 @@ static int ocelot_gpio_request_enable(struct pinctrl_dev *pctldev,
 	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
 	unsigned int p = offset % 32;
 
-	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT0, info, offset),
+	regmap_update_bits(info->map, REG_ALT(0, info, offset),
 			   BIT(p), 0);
-	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT1, info, offset),
+	regmap_update_bits(info->map, REG_ALT(1, info, offset),
 			   BIT(p), 0);
 
 	return 0;

commit f2818ba3a0125670cb9999bb5a65ebb631a8da2f
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Jun 20 20:30:36 2019 +0200

    pinctrl: ocelot: fix gpio direction for pins after 31
    
    The third argument passed to REG is not the correct one and
    ocelot_gpio_set_direction is not working for pins after 31. Fix that by
    passing the pin number instead of the modulo 32 value.
    
    Fixes: da801ab56ad8 pinctrl: ocelot: add MSCC Jaguar2 support
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index 3b4ca52d2456..d2478db975bd 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -432,7 +432,7 @@ static int ocelot_gpio_set_direction(struct pinctrl_dev *pctldev,
 	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
 	unsigned int p = pin % 32;
 
-	regmap_update_bits(info->map, REG(OCELOT_GPIO_OE, info, p), BIT(p),
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_OE, info, pin), BIT(p),
 			   input ? 0 : BIT(p));
 
 	return 0;

commit da801ab56ad874897b0b255216767c983e665a4c
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Dec 20 15:44:31 2018 +0100

    pinctrl: ocelot: add MSCC Jaguar2 support
    
    Jaguar2 has the same register layout as Ocelot but it has 64 pins, meaning
    that there are 2 registers instead of one.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index f9fc2b3a8731..3b4ca52d2456 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -37,7 +37,6 @@
 #define OCELOT_GPIO_ALT1	0x24
 #define OCELOT_GPIO_SD_MAP	0x28
 
-#define OCELOT_PINS		22
 #define OCELOT_FUNC_PER_PIN	4
 
 enum {
@@ -48,6 +47,7 @@ enum {
 	FUNC_IRQ1_IN,
 	FUNC_IRQ1_OUT,
 	FUNC_MIIM1,
+	FUNC_MIIM2,
 	FUNC_PCI_WAKE,
 	FUNC_PTP0,
 	FUNC_PTP1,
@@ -62,10 +62,23 @@ enum {
 	FUNC_SFP3,
 	FUNC_SFP4,
 	FUNC_SFP5,
+	FUNC_SFP6,
+	FUNC_SFP7,
+	FUNC_SFP8,
+	FUNC_SFP9,
+	FUNC_SFP10,
+	FUNC_SFP11,
+	FUNC_SFP12,
+	FUNC_SFP13,
+	FUNC_SFP14,
+	FUNC_SFP15,
 	FUNC_SG0,
+	FUNC_SG1,
+	FUNC_SG2,
 	FUNC_SI,
 	FUNC_TACHO,
 	FUNC_TWI,
+	FUNC_TWI2,
 	FUNC_TWI_SCL_M,
 	FUNC_UART,
 	FUNC_UART2,
@@ -80,6 +93,7 @@ static const char *const ocelot_function_names[] = {
 	[FUNC_IRQ1_IN]		= "irq1_in",
 	[FUNC_IRQ1_OUT]		= "irq1_out",
 	[FUNC_MIIM1]		= "miim1",
+	[FUNC_MIIM2]		= "miim2",
 	[FUNC_PCI_WAKE]		= "pci_wake",
 	[FUNC_PTP0]		= "ptp0",
 	[FUNC_PTP1]		= "ptp1",
@@ -94,10 +108,23 @@ static const char *const ocelot_function_names[] = {
 	[FUNC_SFP3]		= "sfp3",
 	[FUNC_SFP4]		= "sfp4",
 	[FUNC_SFP5]		= "sfp5",
+	[FUNC_SFP6]		= "sfp6",
+	[FUNC_SFP7]		= "sfp7",
+	[FUNC_SFP8]		= "sfp8",
+	[FUNC_SFP9]		= "sfp9",
+	[FUNC_SFP10]		= "sfp10",
+	[FUNC_SFP11]		= "sfp11",
+	[FUNC_SFP12]		= "sfp12",
+	[FUNC_SFP13]		= "sfp13",
+	[FUNC_SFP14]		= "sfp14",
+	[FUNC_SFP15]		= "sfp15",
 	[FUNC_SG0]		= "sg0",
+	[FUNC_SG1]		= "sg1",
+	[FUNC_SG2]		= "sg2",
 	[FUNC_SI]		= "si",
 	[FUNC_TACHO]		= "tacho",
 	[FUNC_TWI]		= "twi",
+	[FUNC_TWI2]		= "twi2",
 	[FUNC_TWI_SCL_M]	= "twi_scl_m",
 	[FUNC_UART]		= "uart",
 	[FUNC_UART2]		= "uart2",
@@ -118,7 +145,9 @@ struct ocelot_pinctrl {
 	struct pinctrl_dev *pctl;
 	struct gpio_chip gpio_chip;
 	struct regmap *map;
+	struct pinctrl_desc *desc;
 	struct ocelot_pmx_func func[FUNC_MAX];
+	u8 stride;
 };
 
 #define OCELOT_P(p, f0, f1, f2)						\
@@ -183,6 +212,152 @@ static const struct pinctrl_pin_desc ocelot_pins[] = {
 	OCELOT_PIN(21),
 };
 
+#define JAGUAR2_P(p, f0, f1)						\
+static struct ocelot_pin_caps jaguar2_pin_##p = {			\
+	.pin = p,							\
+	.functions = {							\
+			FUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_NONE	\
+	},								\
+}
+
+JAGUAR2_P(0,  SG0,       NONE);
+JAGUAR2_P(1,  SG0,       NONE);
+JAGUAR2_P(2,  SG0,       NONE);
+JAGUAR2_P(3,  SG0,       NONE);
+JAGUAR2_P(4,  SG1,       NONE);
+JAGUAR2_P(5,  SG1,       NONE);
+JAGUAR2_P(6,  IRQ0_IN,   IRQ0_OUT);
+JAGUAR2_P(7,  IRQ1_IN,   IRQ1_OUT);
+JAGUAR2_P(8,  PTP0,      NONE);
+JAGUAR2_P(9,  PTP1,      NONE);
+JAGUAR2_P(10, UART,      NONE);
+JAGUAR2_P(11, UART,      NONE);
+JAGUAR2_P(12, SG1,       NONE);
+JAGUAR2_P(13, SG1,       NONE);
+JAGUAR2_P(14, TWI,       TWI_SCL_M);
+JAGUAR2_P(15, TWI,       NONE);
+JAGUAR2_P(16, SI,        TWI_SCL_M);
+JAGUAR2_P(17, SI,        TWI_SCL_M);
+JAGUAR2_P(18, SI,        TWI_SCL_M);
+JAGUAR2_P(19, PCI_WAKE,  NONE);
+JAGUAR2_P(20, IRQ0_OUT,  TWI_SCL_M);
+JAGUAR2_P(21, IRQ1_OUT,  TWI_SCL_M);
+JAGUAR2_P(22, TACHO,     NONE);
+JAGUAR2_P(23, PWM,       NONE);
+JAGUAR2_P(24, UART2,     NONE);
+JAGUAR2_P(25, UART2,     SI);
+JAGUAR2_P(26, PTP2,      SI);
+JAGUAR2_P(27, PTP3,      SI);
+JAGUAR2_P(28, TWI2,      SI);
+JAGUAR2_P(29, TWI2,      SI);
+JAGUAR2_P(30, SG2,       SI);
+JAGUAR2_P(31, SG2,       SI);
+JAGUAR2_P(32, SG2,       SI);
+JAGUAR2_P(33, SG2,       SI);
+JAGUAR2_P(34, NONE,      TWI_SCL_M);
+JAGUAR2_P(35, NONE,      TWI_SCL_M);
+JAGUAR2_P(36, NONE,      TWI_SCL_M);
+JAGUAR2_P(37, NONE,      TWI_SCL_M);
+JAGUAR2_P(38, NONE,      TWI_SCL_M);
+JAGUAR2_P(39, NONE,      TWI_SCL_M);
+JAGUAR2_P(40, NONE,      TWI_SCL_M);
+JAGUAR2_P(41, NONE,      TWI_SCL_M);
+JAGUAR2_P(42, NONE,      TWI_SCL_M);
+JAGUAR2_P(43, NONE,      TWI_SCL_M);
+JAGUAR2_P(44, NONE,      SFP8);
+JAGUAR2_P(45, NONE,      SFP9);
+JAGUAR2_P(46, NONE,      SFP10);
+JAGUAR2_P(47, NONE,      SFP11);
+JAGUAR2_P(48, SFP0,      NONE);
+JAGUAR2_P(49, SFP1,      SI);
+JAGUAR2_P(50, SFP2,      SI);
+JAGUAR2_P(51, SFP3,      SI);
+JAGUAR2_P(52, SFP4,      NONE);
+JAGUAR2_P(53, SFP5,      NONE);
+JAGUAR2_P(54, SFP6,      NONE);
+JAGUAR2_P(55, SFP7,      NONE);
+JAGUAR2_P(56, MIIM1,     SFP12);
+JAGUAR2_P(57, MIIM1,     SFP13);
+JAGUAR2_P(58, MIIM2,     SFP14);
+JAGUAR2_P(59, MIIM2,     SFP15);
+JAGUAR2_P(60, NONE,      NONE);
+JAGUAR2_P(61, NONE,      NONE);
+JAGUAR2_P(62, NONE,      NONE);
+JAGUAR2_P(63, NONE,      NONE);
+
+#define JAGUAR2_PIN(n) {					\
+	.number = n,						\
+	.name = "GPIO_"#n,					\
+	.drv_data = &jaguar2_pin_##n				\
+}
+
+static const struct pinctrl_pin_desc jaguar2_pins[] = {
+	JAGUAR2_PIN(0),
+	JAGUAR2_PIN(1),
+	JAGUAR2_PIN(2),
+	JAGUAR2_PIN(3),
+	JAGUAR2_PIN(4),
+	JAGUAR2_PIN(5),
+	JAGUAR2_PIN(6),
+	JAGUAR2_PIN(7),
+	JAGUAR2_PIN(8),
+	JAGUAR2_PIN(9),
+	JAGUAR2_PIN(10),
+	JAGUAR2_PIN(11),
+	JAGUAR2_PIN(12),
+	JAGUAR2_PIN(13),
+	JAGUAR2_PIN(14),
+	JAGUAR2_PIN(15),
+	JAGUAR2_PIN(16),
+	JAGUAR2_PIN(17),
+	JAGUAR2_PIN(18),
+	JAGUAR2_PIN(19),
+	JAGUAR2_PIN(20),
+	JAGUAR2_PIN(21),
+	JAGUAR2_PIN(22),
+	JAGUAR2_PIN(23),
+	JAGUAR2_PIN(24),
+	JAGUAR2_PIN(25),
+	JAGUAR2_PIN(26),
+	JAGUAR2_PIN(27),
+	JAGUAR2_PIN(28),
+	JAGUAR2_PIN(29),
+	JAGUAR2_PIN(30),
+	JAGUAR2_PIN(31),
+	JAGUAR2_PIN(32),
+	JAGUAR2_PIN(33),
+	JAGUAR2_PIN(34),
+	JAGUAR2_PIN(35),
+	JAGUAR2_PIN(36),
+	JAGUAR2_PIN(37),
+	JAGUAR2_PIN(38),
+	JAGUAR2_PIN(39),
+	JAGUAR2_PIN(40),
+	JAGUAR2_PIN(41),
+	JAGUAR2_PIN(42),
+	JAGUAR2_PIN(43),
+	JAGUAR2_PIN(44),
+	JAGUAR2_PIN(45),
+	JAGUAR2_PIN(46),
+	JAGUAR2_PIN(47),
+	JAGUAR2_PIN(48),
+	JAGUAR2_PIN(49),
+	JAGUAR2_PIN(50),
+	JAGUAR2_PIN(51),
+	JAGUAR2_PIN(52),
+	JAGUAR2_PIN(53),
+	JAGUAR2_PIN(54),
+	JAGUAR2_PIN(55),
+	JAGUAR2_PIN(56),
+	JAGUAR2_PIN(57),
+	JAGUAR2_PIN(58),
+	JAGUAR2_PIN(59),
+	JAGUAR2_PIN(60),
+	JAGUAR2_PIN(61),
+	JAGUAR2_PIN(62),
+	JAGUAR2_PIN(63),
+};
+
 static int ocelot_get_functions_count(struct pinctrl_dev *pctldev)
 {
 	return ARRAY_SIZE(ocelot_function_names);
@@ -207,9 +382,10 @@ static int ocelot_get_function_groups(struct pinctrl_dev *pctldev,
 	return 0;
 }
 
-static int ocelot_pin_function_idx(unsigned int pin, unsigned int function)
+static int ocelot_pin_function_idx(struct ocelot_pinctrl *info,
+				   unsigned int pin, unsigned int function)
 {
-	struct ocelot_pin_caps *p = ocelot_pins[pin].drv_data;
+	struct ocelot_pin_caps *p = info->desc->pins[pin].drv_data;
 	int i;
 
 	for (i = 0; i < OCELOT_FUNC_PER_PIN; i++) {
@@ -220,14 +396,17 @@ static int ocelot_pin_function_idx(unsigned int pin, unsigned int function)
 	return -1;
 }
 
+#define REG(r, info, p) ((r) * (info)->stride + (4 * ((p) / 32)))
+
 static int ocelot_pinmux_set_mux(struct pinctrl_dev *pctldev,
 				 unsigned int selector, unsigned int group)
 {
 	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
-	struct ocelot_pin_caps *pin = ocelot_pins[group].drv_data;
+	struct ocelot_pin_caps *pin = info->desc->pins[group].drv_data;
+	unsigned int p = pin->pin % 32;
 	int f;
 
-	f = ocelot_pin_function_idx(group, selector);
+	f = ocelot_pin_function_idx(info, group, selector);
 	if (f < 0)
 		return -EINVAL;
 
@@ -238,10 +417,10 @@ static int ocelot_pinmux_set_mux(struct pinctrl_dev *pctldev,
 	 * This is racy because both registers can't be updated at the same time
 	 * but it doesn't matter much for now.
 	 */
-	regmap_update_bits(info->map, OCELOT_GPIO_ALT0, BIT(pin->pin),
-			   f << pin->pin);
-	regmap_update_bits(info->map, OCELOT_GPIO_ALT1, BIT(pin->pin),
-			   f << (pin->pin - 1));
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT0, info, pin->pin),
+			   BIT(p), f << p);
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT1, info, pin->pin),
+			   BIT(p), f << (p - 1));
 
 	return 0;
 }
@@ -251,9 +430,10 @@ static int ocelot_gpio_set_direction(struct pinctrl_dev *pctldev,
 				     unsigned int pin, bool input)
 {
 	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	unsigned int p = pin % 32;
 
-	regmap_update_bits(info->map, OCELOT_GPIO_OE, BIT(pin),
-			   input ? 0 : BIT(pin));
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_OE, info, p), BIT(p),
+			   input ? 0 : BIT(p));
 
 	return 0;
 }
@@ -263,9 +443,12 @@ static int ocelot_gpio_request_enable(struct pinctrl_dev *pctldev,
 				      unsigned int offset)
 {
 	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	unsigned int p = offset % 32;
 
-	regmap_update_bits(info->map, OCELOT_GPIO_ALT0, BIT(offset), 0);
-	regmap_update_bits(info->map, OCELOT_GPIO_ALT1, BIT(offset), 0);
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT0, info, offset),
+			   BIT(p), 0);
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_ALT1, info, offset),
+			   BIT(p), 0);
 
 	return 0;
 }
@@ -281,13 +464,17 @@ static const struct pinmux_ops ocelot_pmx_ops = {
 
 static int ocelot_pctl_get_groups_count(struct pinctrl_dev *pctldev)
 {
-	return ARRAY_SIZE(ocelot_pins);
+	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->desc->npins;
 }
 
 static const char *ocelot_pctl_get_group_name(struct pinctrl_dev *pctldev,
 					      unsigned int group)
 {
-	return ocelot_pins[group].name;
+	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->desc->pins[group].name;
 }
 
 static int ocelot_pctl_get_group_pins(struct pinctrl_dev *pctldev,
@@ -295,7 +482,9 @@ static int ocelot_pctl_get_group_pins(struct pinctrl_dev *pctldev,
 				      const unsigned int **pins,
 				      unsigned int *num_pins)
 {
-	*pins = &ocelot_pins[group].number;
+	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	*pins = &info->desc->pins[group].number;
 	*num_pins = 1;
 
 	return 0;
@@ -318,30 +507,47 @@ static struct pinctrl_desc ocelot_desc = {
 	.owner = THIS_MODULE,
 };
 
+static struct pinctrl_desc jaguar2_desc = {
+	.name = "jaguar2-pinctrl",
+	.pins = jaguar2_pins,
+	.npins = ARRAY_SIZE(jaguar2_pins),
+	.pctlops = &ocelot_pctl_ops,
+	.pmxops = &ocelot_pmx_ops,
+	.owner = THIS_MODULE,
+};
+
 static int ocelot_create_group_func_map(struct device *dev,
 					struct ocelot_pinctrl *info)
 {
-	u16 pins[ARRAY_SIZE(ocelot_pins)];
 	int f, npins, i;
+	u8 *pins = kcalloc(info->desc->npins, sizeof(u8), GFP_KERNEL);
+
+	if (!pins)
+		return -ENOMEM;
 
 	for (f = 0; f < FUNC_MAX; f++) {
-		for (npins = 0, i = 0; i < ARRAY_SIZE(ocelot_pins); i++) {
-			if (ocelot_pin_function_idx(i, f) >= 0)
+		for (npins = 0, i = 0; i < info->desc->npins; i++) {
+			if (ocelot_pin_function_idx(info, i, f) >= 0)
 				pins[npins++] = i;
 		}
 
+		if (!npins)
+			continue;
+
 		info->func[f].ngroups = npins;
-		info->func[f].groups = devm_kcalloc(dev,
-							 npins,
-							 sizeof(char *),
-							 GFP_KERNEL);
-		if (!info->func[f].groups)
+		info->func[f].groups = devm_kcalloc(dev, npins, sizeof(char *),
+						    GFP_KERNEL);
+		if (!info->func[f].groups) {
+			kfree(pins);
 			return -ENOMEM;
+		}
 
 		for (i = 0; i < npins; i++)
-			info->func[f].groups[i] = ocelot_pins[pins[i]].name;
+			info->func[f].groups[i] = info->desc->pins[pins[i]].name;
 	}
 
+	kfree(pins);
+
 	return 0;
 }
 
@@ -356,7 +562,7 @@ static int ocelot_pinctrl_register(struct platform_device *pdev,
 		return ret;
 	}
 
-	info->pctl = devm_pinctrl_register(&pdev->dev, &ocelot_desc, info);
+	info->pctl = devm_pinctrl_register(&pdev->dev, info->desc, info);
 	if (IS_ERR(info->pctl)) {
 		dev_err(&pdev->dev, "Failed to register pinctrl\n");
 		return PTR_ERR(info->pctl);
@@ -370,9 +576,9 @@ static int ocelot_gpio_get(struct gpio_chip *chip, unsigned int offset)
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
 	unsigned int val;
 
-	regmap_read(info->map, OCELOT_GPIO_IN, &val);
+	regmap_read(info->map, REG(OCELOT_GPIO_IN, info, offset), &val);
 
-	return !!(val & BIT(offset));
+	return !!(val & BIT(offset % 32));
 }
 
 static void ocelot_gpio_set(struct gpio_chip *chip, unsigned int offset,
@@ -381,9 +587,11 @@ static void ocelot_gpio_set(struct gpio_chip *chip, unsigned int offset,
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
 
 	if (value)
-		regmap_write(info->map, OCELOT_GPIO_OUT_SET, BIT(offset));
+		regmap_write(info->map, REG(OCELOT_GPIO_OUT_SET, info, offset),
+			     BIT(offset % 32));
 	else
-		regmap_write(info->map, OCELOT_GPIO_OUT_CLR, BIT(offset));
+		regmap_write(info->map, REG(OCELOT_GPIO_OUT_CLR, info, offset),
+			     BIT(offset % 32));
 }
 
 static int ocelot_gpio_get_direction(struct gpio_chip *chip,
@@ -392,9 +600,9 @@ static int ocelot_gpio_get_direction(struct gpio_chip *chip,
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
 	unsigned int val;
 
-	regmap_read(info->map, OCELOT_GPIO_OE, &val);
+	regmap_read(info->map, REG(OCELOT_GPIO_OE, info, offset), &val);
 
-	return !(val & BIT(offset));
+	return !(val & BIT(offset % 32));
 }
 
 static int ocelot_gpio_direction_input(struct gpio_chip *chip,
@@ -407,12 +615,14 @@ static int ocelot_gpio_direction_output(struct gpio_chip *chip,
 					unsigned int offset, int value)
 {
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
-	unsigned int pin = BIT(offset);
+	unsigned int pin = BIT(offset % 32);
 
 	if (value)
-		regmap_write(info->map, OCELOT_GPIO_OUT_SET, pin);
+		regmap_write(info->map, REG(OCELOT_GPIO_OUT_SET, info, offset),
+			     pin);
 	else
-		regmap_write(info->map, OCELOT_GPIO_OUT_CLR, pin);
+		regmap_write(info->map, REG(OCELOT_GPIO_OUT_CLR, info, offset),
+			     pin);
 
 	return pinctrl_gpio_direction_output(chip->base + offset);
 }
@@ -434,7 +644,8 @@ static void ocelot_irq_mask(struct irq_data *data)
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
 	unsigned int gpio = irqd_to_hwirq(data);
 
-	regmap_update_bits(info->map, OCELOT_GPIO_INTR_ENA, BIT(gpio), 0);
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_INTR_ENA, info, gpio),
+			   BIT(gpio % 32), 0);
 }
 
 static void ocelot_irq_unmask(struct irq_data *data)
@@ -443,8 +654,8 @@ static void ocelot_irq_unmask(struct irq_data *data)
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
 	unsigned int gpio = irqd_to_hwirq(data);
 
-	regmap_update_bits(info->map, OCELOT_GPIO_INTR_ENA, BIT(gpio),
-			   BIT(gpio));
+	regmap_update_bits(info->map, REG(OCELOT_GPIO_INTR_ENA, info, gpio),
+			   BIT(gpio % 32), BIT(gpio % 32));
 }
 
 static void ocelot_irq_ack(struct irq_data *data)
@@ -453,7 +664,8 @@ static void ocelot_irq_ack(struct irq_data *data)
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
 	unsigned int gpio = irqd_to_hwirq(data);
 
-	regmap_write_bits(info->map, OCELOT_GPIO_INTR, BIT(gpio), BIT(gpio));
+	regmap_write_bits(info->map, REG(OCELOT_GPIO_INTR, info, gpio),
+			  BIT(gpio % 32), BIT(gpio % 32));
 }
 
 static int ocelot_irq_set_type(struct irq_data *data, unsigned int type);
@@ -497,22 +709,25 @@ static void ocelot_irq_handler(struct irq_desc *desc)
 	struct irq_chip *parent_chip = irq_desc_get_chip(desc);
 	struct gpio_chip *chip = irq_desc_get_handler_data(desc);
 	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
-	unsigned int reg = 0, irq;
+	unsigned int reg = 0, irq, i;
 	unsigned long irqs;
 
-	regmap_read(info->map, OCELOT_GPIO_INTR_IDENT, &reg);
-	if (!reg)
-		return;
+	for (i = 0; i < info->stride; i++) {
+		regmap_read(info->map, OCELOT_GPIO_INTR_IDENT + 4 * i, &reg);
+		if (!reg)
+			continue;
 
-	chained_irq_enter(parent_chip, desc);
+		chained_irq_enter(parent_chip, desc);
 
-	irqs = reg;
+		irqs = reg;
 
-	for_each_set_bit(irq, &irqs, OCELOT_PINS) {
-		generic_handle_irq(irq_linear_revmap(chip->irq.domain, irq));
-	}
+		for_each_set_bit(irq, &irqs,
+				 min(32U, info->desc->npins - 32 * i))
+			generic_handle_irq(irq_linear_revmap(chip->irq.domain,
+							     irq + 32 * i));
 
-	chained_irq_exit(parent_chip, desc);
+		chained_irq_exit(parent_chip, desc);
+	}
 }
 
 static int ocelot_gpiochip_register(struct platform_device *pdev,
@@ -524,7 +739,7 @@ static int ocelot_gpiochip_register(struct platform_device *pdev,
 	info->gpio_chip = ocelot_gpiolib_chip;
 
 	gc = &info->gpio_chip;
-	gc->ngpio = OCELOT_PINS;
+	gc->ngpio = info->desc->npins;
 	gc->parent = &pdev->dev;
 	gc->base = 0;
 	gc->of_node = info->dev->of_node;
@@ -549,15 +764,9 @@ static int ocelot_gpiochip_register(struct platform_device *pdev,
 	return 0;
 }
 
-static const struct regmap_config ocelot_pinctrl_regmap_config = {
-	.reg_bits = 32,
-	.val_bits = 32,
-	.reg_stride = 4,
-	.max_register = 0x64,
-};
-
 static const struct of_device_id ocelot_pinctrl_of_match[] = {
-	{ .compatible = "mscc,ocelot-pinctrl" },
+	{ .compatible = "mscc,ocelot-pinctrl", .data = &ocelot_desc },
+	{ .compatible = "mscc,jaguar2-pinctrl", .data = &jaguar2_desc },
 	{},
 };
 
@@ -567,11 +776,18 @@ static int ocelot_pinctrl_probe(struct platform_device *pdev)
 	struct ocelot_pinctrl *info;
 	void __iomem *base;
 	int ret;
+	struct regmap_config regmap_config = {
+		.reg_bits = 32,
+		.val_bits = 32,
+		.reg_stride = 4,
+	};
 
 	info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;
 
+	info->desc = (struct pinctrl_desc *)device_get_match_data(dev);
+
 	base = devm_ioremap_resource(dev,
 			platform_get_resource(pdev, IORESOURCE_MEM, 0));
 	if (IS_ERR(base)) {
@@ -579,8 +795,10 @@ static int ocelot_pinctrl_probe(struct platform_device *pdev)
 		return PTR_ERR(base);
 	}
 
-	info->map = devm_regmap_init_mmio(dev, base,
-					  &ocelot_pinctrl_regmap_config);
+	info->stride = 1 + (info->desc->npins - 1) / 32;
+	regmap_config.max_register = OCELOT_GPIO_SD_MAP * info->stride + 15 * 4;
+
+	info->map = devm_regmap_init_mmio(dev, base, &regmap_config);
 	if (IS_ERR(info->map)) {
 		dev_err(dev, "Failed to create regmap\n");
 		return PTR_ERR(info->map);

commit be36abb71d878f3320412a84e6bbec8dd796010c
Author: Quentin Schulz <quentin.schulz@bootlin.com>
Date:   Wed Jul 25 14:26:21 2018 +0200

    pinctrl: ocelot: add support for interrupt controller
    
    This GPIO controller can serve as an interrupt controller as well on the
    GPIOs it handles.
    
    An interrupt is generated whenever a GPIO line changes and the
    interrupt for this GPIO line is enabled. This means that both the
    changes from low to high and high to low generate an interrupt.
    
    For some use cases, it makes sense to ignore the high to low change and
    not generate an interrupt. Such a use case is a line that is hold in a
    level high/low manner until the event holding the line gets acked.
    This can be achieved by making sure the interrupt on the GPIO controller
    side gets acked and masked only after the line gets hold in its default
    state, this is what's done with the fasteoi functions.
    
    Only IRQ_TYPE_EDGE_BOTH and IRQ_TYPE_LEVEL_HIGH are supported for now.
    
    Signed-off-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index e93669f4d1c8..f9fc2b3a8731 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -11,6 +11,7 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/pinctrl/pinmux.h>
@@ -427,11 +428,98 @@ static const struct gpio_chip ocelot_gpiolib_chip = {
 	.owner = THIS_MODULE,
 };
 
+static void ocelot_irq_mask(struct irq_data *data)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int gpio = irqd_to_hwirq(data);
+
+	regmap_update_bits(info->map, OCELOT_GPIO_INTR_ENA, BIT(gpio), 0);
+}
+
+static void ocelot_irq_unmask(struct irq_data *data)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int gpio = irqd_to_hwirq(data);
+
+	regmap_update_bits(info->map, OCELOT_GPIO_INTR_ENA, BIT(gpio),
+			   BIT(gpio));
+}
+
+static void ocelot_irq_ack(struct irq_data *data)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int gpio = irqd_to_hwirq(data);
+
+	regmap_write_bits(info->map, OCELOT_GPIO_INTR, BIT(gpio), BIT(gpio));
+}
+
+static int ocelot_irq_set_type(struct irq_data *data, unsigned int type);
+
+static struct irq_chip ocelot_eoi_irqchip = {
+	.name		= "gpio",
+	.irq_mask	= ocelot_irq_mask,
+	.irq_eoi	= ocelot_irq_ack,
+	.irq_unmask	= ocelot_irq_unmask,
+	.flags          = IRQCHIP_EOI_THREADED | IRQCHIP_EOI_IF_HANDLED,
+	.irq_set_type	= ocelot_irq_set_type,
+};
+
+static struct irq_chip ocelot_irqchip = {
+	.name		= "gpio",
+	.irq_mask	= ocelot_irq_mask,
+	.irq_ack	= ocelot_irq_ack,
+	.irq_unmask	= ocelot_irq_unmask,
+	.irq_set_type	= ocelot_irq_set_type,
+};
+
+static int ocelot_irq_set_type(struct irq_data *data, unsigned int type)
+{
+	type &= IRQ_TYPE_SENSE_MASK;
+
+	if (!(type & (IRQ_TYPE_EDGE_BOTH | IRQ_TYPE_LEVEL_HIGH)))
+		return -EINVAL;
+
+	if (type & IRQ_TYPE_LEVEL_HIGH)
+		irq_set_chip_handler_name_locked(data, &ocelot_eoi_irqchip,
+						 handle_fasteoi_irq, NULL);
+	if (type & IRQ_TYPE_EDGE_BOTH)
+		irq_set_chip_handler_name_locked(data, &ocelot_irqchip,
+						 handle_edge_irq, NULL);
+
+	return 0;
+}
+
+static void ocelot_irq_handler(struct irq_desc *desc)
+{
+	struct irq_chip *parent_chip = irq_desc_get_chip(desc);
+	struct gpio_chip *chip = irq_desc_get_handler_data(desc);
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int reg = 0, irq;
+	unsigned long irqs;
+
+	regmap_read(info->map, OCELOT_GPIO_INTR_IDENT, &reg);
+	if (!reg)
+		return;
+
+	chained_irq_enter(parent_chip, desc);
+
+	irqs = reg;
+
+	for_each_set_bit(irq, &irqs, OCELOT_PINS) {
+		generic_handle_irq(irq_linear_revmap(chip->irq.domain, irq));
+	}
+
+	chained_irq_exit(parent_chip, desc);
+}
+
 static int ocelot_gpiochip_register(struct platform_device *pdev,
 				    struct ocelot_pinctrl *info)
 {
 	struct gpio_chip *gc;
-	int ret;
+	int ret, irq;
 
 	info->gpio_chip = ocelot_gpiolib_chip;
 
@@ -446,7 +534,17 @@ static int ocelot_gpiochip_register(struct platform_device *pdev,
 	if (ret)
 		return ret;
 
-	/* TODO: this can be used as an irqchip but no board is using that */
+	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (irq <= 0)
+		return irq;
+
+	ret = gpiochip_irqchip_add(gc, &ocelot_irqchip, 0, handle_edge_irq,
+				   IRQ_TYPE_NONE);
+	if (ret)
+		return ret;
+
+	gpiochip_set_chained_irqchip(gc, &ocelot_irqchip, irq,
+				     ocelot_irq_handler);
 
 	return 0;
 }

commit 17f790843cd77d69927ccd2f01a3bbd55067069e
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Wed Jul 11 15:01:26 2018 +0200

    pinctrl: ocelot: fix gpio4 twi function
    
    the TWI function on GPIO4 is actually a multiplexed SCL, not an original
    TWI SDA or SCL. Fix it.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index 15bb1cb8729b..e93669f4d1c8 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -132,7 +132,7 @@ OCELOT_P(0,  SG0,       NONE,      NONE);
 OCELOT_P(1,  SG0,       NONE,      NONE);
 OCELOT_P(2,  SG0,       NONE,      NONE);
 OCELOT_P(3,  SG0,       NONE,      NONE);
-OCELOT_P(4,  IRQ0_IN,   IRQ0_OUT,  TWI);
+OCELOT_P(4,  IRQ0_IN,   IRQ0_OUT,  TWI_SCL_M);
 OCELOT_P(5,  IRQ1_IN,   IRQ1_OUT,  PCI_WAKE);
 OCELOT_P(6,  UART,      TWI_SCL_M, NONE);
 OCELOT_P(7,  UART,      TWI_SCL_M, NONE);

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index b5b3547fdcb2..15bb1cb8729b 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -330,7 +330,8 @@ static int ocelot_create_group_func_map(struct device *dev,
 		}
 
 		info->func[f].ngroups = npins;
-		info->func[f].groups = devm_kzalloc(dev, npins *
+		info->func[f].groups = devm_kcalloc(dev,
+							 npins,
 							 sizeof(char *),
 							 GFP_KERNEL);
 		if (!info->func[f].groups)

commit 44edff1bbc48595a041f65a725203763e3590a73
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Mar 22 13:35:00 2018 +0100

    pinctrl: ocelot: fix gpio direction
    
    Bits have to be cleared in DEVCPU_GCB:GPIO:GPIO_OE for input and set for
    output. ocelot_gpio_set_direction() got it wrong and this went unnoticed
    when the driver was reworked.
    
    Reported-by: Gregory Clement <gregory.clement@bootlin.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index a9423238471e..b5b3547fdcb2 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -252,7 +252,7 @@ static int ocelot_gpio_set_direction(struct pinctrl_dev *pctldev,
 	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
 
 	regmap_update_bits(info->map, OCELOT_GPIO_OE, BIT(pin),
-			   input ? BIT(pin) : 0);
+			   input ? 0 : BIT(pin));
 
 	return 0;
 }

commit ce3e7f0ee9a3d0c0ad5a88e21b7f8cdad3f2c156
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Feb 8 14:24:37 2018 +0000

    pinctrl: ocelot: make function ocelot_pinctrl_probe static
    
    The function ocelot_pinctrl_probe is local to the source and does not
    need to be in global scope, so make it static.
    
    Cleans up sparse warning:
    drivers/pinctrl/pinctrl-ocelot.c:465:5: warning: symbol
    'ocelot_pinctrl_probe' was not declared. Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
index 01a50d969111..a9423238471e 100644
--- a/drivers/pinctrl/pinctrl-ocelot.c
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -462,7 +462,7 @@ static const struct of_device_id ocelot_pinctrl_of_match[] = {
 	{},
 };
 
-int ocelot_pinctrl_probe(struct platform_device *pdev)
+static int ocelot_pinctrl_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ocelot_pinctrl *info;

commit ce8dc0943357a5d10b05dcf0556b537c1d7b8b1f
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Sat Jan 6 01:09:26 2018 +0100

    pinctrl: Add Microsemi Ocelot SoC driver
    
    The Microsemi Ocelot SoC has a few pins that can be used as GPIOs or take
    multiple other functions. Add a driver for the pinmuxing and the GPIOs.
    
    There is currently no support for interrupts.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-ocelot.c b/drivers/pinctrl/pinctrl-ocelot.c
new file mode 100644
index 000000000000..01a50d969111
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-ocelot.c
@@ -0,0 +1,511 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Microsemi SoCs pinctrl driver
+ *
+ * Author: <alexandre.belloni@free-electrons.com>
+ * License: Dual MIT/GPL
+ * Copyright (c) 2017 Microsemi Corporation
+ */
+
+#include <linux/gpio/driver.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include "core.h"
+#include "pinconf.h"
+#include "pinmux.h"
+
+#define OCELOT_GPIO_OUT_SET	0x0
+#define OCELOT_GPIO_OUT_CLR	0x4
+#define OCELOT_GPIO_OUT		0x8
+#define OCELOT_GPIO_IN		0xc
+#define OCELOT_GPIO_OE		0x10
+#define OCELOT_GPIO_INTR	0x14
+#define OCELOT_GPIO_INTR_ENA	0x18
+#define OCELOT_GPIO_INTR_IDENT	0x1c
+#define OCELOT_GPIO_ALT0	0x20
+#define OCELOT_GPIO_ALT1	0x24
+#define OCELOT_GPIO_SD_MAP	0x28
+
+#define OCELOT_PINS		22
+#define OCELOT_FUNC_PER_PIN	4
+
+enum {
+	FUNC_NONE,
+	FUNC_GPIO,
+	FUNC_IRQ0_IN,
+	FUNC_IRQ0_OUT,
+	FUNC_IRQ1_IN,
+	FUNC_IRQ1_OUT,
+	FUNC_MIIM1,
+	FUNC_PCI_WAKE,
+	FUNC_PTP0,
+	FUNC_PTP1,
+	FUNC_PTP2,
+	FUNC_PTP3,
+	FUNC_PWM,
+	FUNC_RECO_CLK0,
+	FUNC_RECO_CLK1,
+	FUNC_SFP0,
+	FUNC_SFP1,
+	FUNC_SFP2,
+	FUNC_SFP3,
+	FUNC_SFP4,
+	FUNC_SFP5,
+	FUNC_SG0,
+	FUNC_SI,
+	FUNC_TACHO,
+	FUNC_TWI,
+	FUNC_TWI_SCL_M,
+	FUNC_UART,
+	FUNC_UART2,
+	FUNC_MAX
+};
+
+static const char *const ocelot_function_names[] = {
+	[FUNC_NONE]		= "none",
+	[FUNC_GPIO]		= "gpio",
+	[FUNC_IRQ0_IN]		= "irq0_in",
+	[FUNC_IRQ0_OUT]		= "irq0_out",
+	[FUNC_IRQ1_IN]		= "irq1_in",
+	[FUNC_IRQ1_OUT]		= "irq1_out",
+	[FUNC_MIIM1]		= "miim1",
+	[FUNC_PCI_WAKE]		= "pci_wake",
+	[FUNC_PTP0]		= "ptp0",
+	[FUNC_PTP1]		= "ptp1",
+	[FUNC_PTP2]		= "ptp2",
+	[FUNC_PTP3]		= "ptp3",
+	[FUNC_PWM]		= "pwm",
+	[FUNC_RECO_CLK0]	= "reco_clk0",
+	[FUNC_RECO_CLK1]	= "reco_clk1",
+	[FUNC_SFP0]		= "sfp0",
+	[FUNC_SFP1]		= "sfp1",
+	[FUNC_SFP2]		= "sfp2",
+	[FUNC_SFP3]		= "sfp3",
+	[FUNC_SFP4]		= "sfp4",
+	[FUNC_SFP5]		= "sfp5",
+	[FUNC_SG0]		= "sg0",
+	[FUNC_SI]		= "si",
+	[FUNC_TACHO]		= "tacho",
+	[FUNC_TWI]		= "twi",
+	[FUNC_TWI_SCL_M]	= "twi_scl_m",
+	[FUNC_UART]		= "uart",
+	[FUNC_UART2]		= "uart2",
+};
+
+struct ocelot_pmx_func {
+	const char **groups;
+	unsigned int ngroups;
+};
+
+struct ocelot_pin_caps {
+	unsigned int pin;
+	unsigned char functions[OCELOT_FUNC_PER_PIN];
+};
+
+struct ocelot_pinctrl {
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	struct gpio_chip gpio_chip;
+	struct regmap *map;
+	struct ocelot_pmx_func func[FUNC_MAX];
+};
+
+#define OCELOT_P(p, f0, f1, f2)						\
+static struct ocelot_pin_caps ocelot_pin_##p = {			\
+	.pin = p,							\
+	.functions = {							\
+			FUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_##f2,	\
+	},								\
+}
+
+OCELOT_P(0,  SG0,       NONE,      NONE);
+OCELOT_P(1,  SG0,       NONE,      NONE);
+OCELOT_P(2,  SG0,       NONE,      NONE);
+OCELOT_P(3,  SG0,       NONE,      NONE);
+OCELOT_P(4,  IRQ0_IN,   IRQ0_OUT,  TWI);
+OCELOT_P(5,  IRQ1_IN,   IRQ1_OUT,  PCI_WAKE);
+OCELOT_P(6,  UART,      TWI_SCL_M, NONE);
+OCELOT_P(7,  UART,      TWI_SCL_M, NONE);
+OCELOT_P(8,  SI,        TWI_SCL_M, IRQ0_OUT);
+OCELOT_P(9,  SI,        TWI_SCL_M, IRQ1_OUT);
+OCELOT_P(10, PTP2,      TWI_SCL_M, SFP0);
+OCELOT_P(11, PTP3,      TWI_SCL_M, SFP1);
+OCELOT_P(12, UART2,     TWI_SCL_M, SFP2);
+OCELOT_P(13, UART2,     TWI_SCL_M, SFP3);
+OCELOT_P(14, MIIM1,     TWI_SCL_M, SFP4);
+OCELOT_P(15, MIIM1,     TWI_SCL_M, SFP5);
+OCELOT_P(16, TWI,       NONE,      SI);
+OCELOT_P(17, TWI,       TWI_SCL_M, SI);
+OCELOT_P(18, PTP0,      TWI_SCL_M, NONE);
+OCELOT_P(19, PTP1,      TWI_SCL_M, NONE);
+OCELOT_P(20, RECO_CLK0, TACHO,     NONE);
+OCELOT_P(21, RECO_CLK1, PWM,       NONE);
+
+#define OCELOT_PIN(n) {						\
+	.number = n,						\
+	.name = "GPIO_"#n,					\
+	.drv_data = &ocelot_pin_##n				\
+}
+
+static const struct pinctrl_pin_desc ocelot_pins[] = {
+	OCELOT_PIN(0),
+	OCELOT_PIN(1),
+	OCELOT_PIN(2),
+	OCELOT_PIN(3),
+	OCELOT_PIN(4),
+	OCELOT_PIN(5),
+	OCELOT_PIN(6),
+	OCELOT_PIN(7),
+	OCELOT_PIN(8),
+	OCELOT_PIN(9),
+	OCELOT_PIN(10),
+	OCELOT_PIN(11),
+	OCELOT_PIN(12),
+	OCELOT_PIN(13),
+	OCELOT_PIN(14),
+	OCELOT_PIN(15),
+	OCELOT_PIN(16),
+	OCELOT_PIN(17),
+	OCELOT_PIN(18),
+	OCELOT_PIN(19),
+	OCELOT_PIN(20),
+	OCELOT_PIN(21),
+};
+
+static int ocelot_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(ocelot_function_names);
+}
+
+static const char *ocelot_get_function_name(struct pinctrl_dev *pctldev,
+					    unsigned int function)
+{
+	return ocelot_function_names[function];
+}
+
+static int ocelot_get_function_groups(struct pinctrl_dev *pctldev,
+				      unsigned int function,
+				      const char *const **groups,
+				      unsigned *const num_groups)
+{
+	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups  = info->func[function].groups;
+	*num_groups = info->func[function].ngroups;
+
+	return 0;
+}
+
+static int ocelot_pin_function_idx(unsigned int pin, unsigned int function)
+{
+	struct ocelot_pin_caps *p = ocelot_pins[pin].drv_data;
+	int i;
+
+	for (i = 0; i < OCELOT_FUNC_PER_PIN; i++) {
+		if (function == p->functions[i])
+			return i;
+	}
+
+	return -1;
+}
+
+static int ocelot_pinmux_set_mux(struct pinctrl_dev *pctldev,
+				 unsigned int selector, unsigned int group)
+{
+	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	struct ocelot_pin_caps *pin = ocelot_pins[group].drv_data;
+	int f;
+
+	f = ocelot_pin_function_idx(group, selector);
+	if (f < 0)
+		return -EINVAL;
+
+	/*
+	 * f is encoded on two bits.
+	 * bit 0 of f goes in BIT(pin) of ALT0, bit 1 of f goes in BIT(pin) of
+	 * ALT1
+	 * This is racy because both registers can't be updated at the same time
+	 * but it doesn't matter much for now.
+	 */
+	regmap_update_bits(info->map, OCELOT_GPIO_ALT0, BIT(pin->pin),
+			   f << pin->pin);
+	regmap_update_bits(info->map, OCELOT_GPIO_ALT1, BIT(pin->pin),
+			   f << (pin->pin - 1));
+
+	return 0;
+}
+
+static int ocelot_gpio_set_direction(struct pinctrl_dev *pctldev,
+				     struct pinctrl_gpio_range *range,
+				     unsigned int pin, bool input)
+{
+	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	regmap_update_bits(info->map, OCELOT_GPIO_OE, BIT(pin),
+			   input ? BIT(pin) : 0);
+
+	return 0;
+}
+
+static int ocelot_gpio_request_enable(struct pinctrl_dev *pctldev,
+				      struct pinctrl_gpio_range *range,
+				      unsigned int offset)
+{
+	struct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	regmap_update_bits(info->map, OCELOT_GPIO_ALT0, BIT(offset), 0);
+	regmap_update_bits(info->map, OCELOT_GPIO_ALT1, BIT(offset), 0);
+
+	return 0;
+}
+
+static const struct pinmux_ops ocelot_pmx_ops = {
+	.get_functions_count = ocelot_get_functions_count,
+	.get_function_name = ocelot_get_function_name,
+	.get_function_groups = ocelot_get_function_groups,
+	.set_mux = ocelot_pinmux_set_mux,
+	.gpio_set_direction = ocelot_gpio_set_direction,
+	.gpio_request_enable = ocelot_gpio_request_enable,
+};
+
+static int ocelot_pctl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(ocelot_pins);
+}
+
+static const char *ocelot_pctl_get_group_name(struct pinctrl_dev *pctldev,
+					      unsigned int group)
+{
+	return ocelot_pins[group].name;
+}
+
+static int ocelot_pctl_get_group_pins(struct pinctrl_dev *pctldev,
+				      unsigned int group,
+				      const unsigned int **pins,
+				      unsigned int *num_pins)
+{
+	*pins = &ocelot_pins[group].number;
+	*num_pins = 1;
+
+	return 0;
+}
+
+static const struct pinctrl_ops ocelot_pctl_ops = {
+	.get_groups_count = ocelot_pctl_get_groups_count,
+	.get_group_name = ocelot_pctl_get_group_name,
+	.get_group_pins = ocelot_pctl_get_group_pins,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+	.dt_free_map = pinconf_generic_dt_free_map,
+};
+
+static struct pinctrl_desc ocelot_desc = {
+	.name = "ocelot-pinctrl",
+	.pins = ocelot_pins,
+	.npins = ARRAY_SIZE(ocelot_pins),
+	.pctlops = &ocelot_pctl_ops,
+	.pmxops = &ocelot_pmx_ops,
+	.owner = THIS_MODULE,
+};
+
+static int ocelot_create_group_func_map(struct device *dev,
+					struct ocelot_pinctrl *info)
+{
+	u16 pins[ARRAY_SIZE(ocelot_pins)];
+	int f, npins, i;
+
+	for (f = 0; f < FUNC_MAX; f++) {
+		for (npins = 0, i = 0; i < ARRAY_SIZE(ocelot_pins); i++) {
+			if (ocelot_pin_function_idx(i, f) >= 0)
+				pins[npins++] = i;
+		}
+
+		info->func[f].ngroups = npins;
+		info->func[f].groups = devm_kzalloc(dev, npins *
+							 sizeof(char *),
+							 GFP_KERNEL);
+		if (!info->func[f].groups)
+			return -ENOMEM;
+
+		for (i = 0; i < npins; i++)
+			info->func[f].groups[i] = ocelot_pins[pins[i]].name;
+	}
+
+	return 0;
+}
+
+static int ocelot_pinctrl_register(struct platform_device *pdev,
+				   struct ocelot_pinctrl *info)
+{
+	int ret;
+
+	ret = ocelot_create_group_func_map(&pdev->dev, info);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to create group func map.\n");
+		return ret;
+	}
+
+	info->pctl = devm_pinctrl_register(&pdev->dev, &ocelot_desc, info);
+	if (IS_ERR(info->pctl)) {
+		dev_err(&pdev->dev, "Failed to register pinctrl\n");
+		return PTR_ERR(info->pctl);
+	}
+
+	return 0;
+}
+
+static int ocelot_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int val;
+
+	regmap_read(info->map, OCELOT_GPIO_IN, &val);
+
+	return !!(val & BIT(offset));
+}
+
+static void ocelot_gpio_set(struct gpio_chip *chip, unsigned int offset,
+			    int value)
+{
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+
+	if (value)
+		regmap_write(info->map, OCELOT_GPIO_OUT_SET, BIT(offset));
+	else
+		regmap_write(info->map, OCELOT_GPIO_OUT_CLR, BIT(offset));
+}
+
+static int ocelot_gpio_get_direction(struct gpio_chip *chip,
+				     unsigned int offset)
+{
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int val;
+
+	regmap_read(info->map, OCELOT_GPIO_OE, &val);
+
+	return !(val & BIT(offset));
+}
+
+static int ocelot_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned int offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int ocelot_gpio_direction_output(struct gpio_chip *chip,
+					unsigned int offset, int value)
+{
+	struct ocelot_pinctrl *info = gpiochip_get_data(chip);
+	unsigned int pin = BIT(offset);
+
+	if (value)
+		regmap_write(info->map, OCELOT_GPIO_OUT_SET, pin);
+	else
+		regmap_write(info->map, OCELOT_GPIO_OUT_CLR, pin);
+
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static const struct gpio_chip ocelot_gpiolib_chip = {
+	.request = gpiochip_generic_request,
+	.free = gpiochip_generic_free,
+	.set = ocelot_gpio_set,
+	.get = ocelot_gpio_get,
+	.get_direction = ocelot_gpio_get_direction,
+	.direction_input = ocelot_gpio_direction_input,
+	.direction_output = ocelot_gpio_direction_output,
+	.owner = THIS_MODULE,
+};
+
+static int ocelot_gpiochip_register(struct platform_device *pdev,
+				    struct ocelot_pinctrl *info)
+{
+	struct gpio_chip *gc;
+	int ret;
+
+	info->gpio_chip = ocelot_gpiolib_chip;
+
+	gc = &info->gpio_chip;
+	gc->ngpio = OCELOT_PINS;
+	gc->parent = &pdev->dev;
+	gc->base = 0;
+	gc->of_node = info->dev->of_node;
+	gc->label = "ocelot-gpio";
+
+	ret = devm_gpiochip_add_data(&pdev->dev, gc, info);
+	if (ret)
+		return ret;
+
+	/* TODO: this can be used as an irqchip but no board is using that */
+
+	return 0;
+}
+
+static const struct regmap_config ocelot_pinctrl_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x64,
+};
+
+static const struct of_device_id ocelot_pinctrl_of_match[] = {
+	{ .compatible = "mscc,ocelot-pinctrl" },
+	{},
+};
+
+int ocelot_pinctrl_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ocelot_pinctrl *info;
+	void __iomem *base;
+	int ret;
+
+	info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	base = devm_ioremap_resource(dev,
+			platform_get_resource(pdev, IORESOURCE_MEM, 0));
+	if (IS_ERR(base)) {
+		dev_err(dev, "Failed to ioremap registers\n");
+		return PTR_ERR(base);
+	}
+
+	info->map = devm_regmap_init_mmio(dev, base,
+					  &ocelot_pinctrl_regmap_config);
+	if (IS_ERR(info->map)) {
+		dev_err(dev, "Failed to create regmap\n");
+		return PTR_ERR(info->map);
+	}
+	dev_set_drvdata(dev, info->map);
+	info->dev = dev;
+
+	ret = ocelot_pinctrl_register(pdev, info);
+	if (ret)
+		return ret;
+
+	ret = ocelot_gpiochip_register(pdev, info);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static struct platform_driver ocelot_pinctrl_driver = {
+	.driver = {
+		.name = "pinctrl-ocelot",
+		.of_match_table = of_match_ptr(ocelot_pinctrl_of_match),
+		.suppress_bind_attrs = true,
+	},
+	.probe = ocelot_pinctrl_probe,
+};
+builtin_platform_driver(ocelot_pinctrl_driver);
