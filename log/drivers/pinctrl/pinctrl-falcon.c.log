commit d62e7fbea4951c124a24176da0c7bf3003ec53d4
Author: Mathias Kresin <dev@kresin.me>
Date:   Thu Mar 5 19:22:45 2020 +0100

    pinctrl: falcon: fix syntax error
    
    Add the missing semicolon after of_node_put to get the file compiled.
    
    Fixes: f17d2f54d36d ("pinctrl: falcon: Add of_node_put() before return")
    Cc: stable@vger.kernel.org # v5.4+
    Signed-off-by: Mathias Kresin <dev@kresin.me>
    Link: https://lore.kernel.org/r/20200305182245.9636-1-dev@kresin.me
    Acked-by: Thomas Langer <thomas.langer@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index a454f57c264e..62c02b969327 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -451,7 +451,7 @@ static int pinctrl_falcon_probe(struct platform_device *pdev)
 		falcon_info.clk[*bank] = clk_get(&ppdev->dev, NULL);
 		if (IS_ERR(falcon_info.clk[*bank])) {
 			dev_err(&ppdev->dev, "failed to get clock\n");
-			of_node_put(np)
+			of_node_put(np);
 			return PTR_ERR(falcon_info.clk[*bank]);
 		}
 		falcon_info.membase[*bank] = devm_ioremap_resource(&pdev->dev,

commit f17d2f54d36dd316bcff4e619a1a349f04214a83
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Sun Aug 4 20:57:45 2019 +0530

    pinctrl: falcon: Add of_node_put() before return
    
    Each iteration of for_each_compatible_node puts the previous node, but in
    the case of a return from the middle of the loop, there is no put, thus
    causing a memory leak. Hence add an of_node_put before the return in two
    places.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190804152745.2231-1-nishkadg.linux@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 4a3b8d2677fd..a454f57c264e 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -451,12 +451,15 @@ static int pinctrl_falcon_probe(struct platform_device *pdev)
 		falcon_info.clk[*bank] = clk_get(&ppdev->dev, NULL);
 		if (IS_ERR(falcon_info.clk[*bank])) {
 			dev_err(&ppdev->dev, "failed to get clock\n");
+			of_node_put(np)
 			return PTR_ERR(falcon_info.clk[*bank]);
 		}
 		falcon_info.membase[*bank] = devm_ioremap_resource(&pdev->dev,
 								   &res);
-		if (IS_ERR(falcon_info.membase[*bank]))
+		if (IS_ERR(falcon_info.membase[*bank])) {
+			of_node_put(np);
 			return PTR_ERR(falcon_info.membase[*bank]);
+		}
 
 		avail = pad_r32(falcon_info.membase[*bank],
 					LTQ_PADC_AVAIL);

commit 811604d01e1a98a5cfdebde211f20368d151fcd4
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jul 31 15:29:16 2019 +0200

    pinctrl: lantiq: Use kasprintf() instead of fixed buffer formatting
    
    Improve readability and maintainability by replacing a hardcoded string
    allocation and formatting by the use of the kasprintf() helper.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20190731132917.17607-3-geert+renesas@glider.be
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index ef133a82e612..4a3b8d2677fd 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -96,12 +96,8 @@ static void lantiq_load_pin_desc(struct pinctrl_pin_desc *d, int bank, int len)
 	int i;
 
 	for (i = 0; i < len; i++) {
-		/* strlen("ioXYZ") + 1 = 6 */
-		char *name = kzalloc(6, GFP_KERNEL);
-
-		snprintf(name, 6, "io%d", base + i);
 		d[i].number = base + i;
-		d[i].name = name;
+		d[i].name = kasprintf(GFP_KERNEL, "io%d", base + i);
 	}
 	pad_count[bank] = len;
 }

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 4d032e637f5c..ef133a82e612 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/drivers/pinctrl/pinmux-falcon.c
  *  based on linux/drivers/pinctrl/pinmux-pxa910.c
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- *
  *  Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
  *  Copyright (C) 2012 John Crispin <john@phrozen.org>
  */

commit 1c5fb66afa2a1d1860cff46ef426117b11e029aa
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 13 13:58:21 2018 +0200

    pinctrl: Include <linux/gpio/driver.h> nothing else
    
    These drivers are GPIO drivers, and the do not need to use the
    legacy header in <linux/gpio.h>, go directly for
    <linux/gpio/driver.h> instead.
    
    Replace any use of GPIOF_* with 0/1, these flags are for
    consumers, not drivers.
    
    Get rid of a few gpio_to_irq() users that was littering
    around the place, use local callbacks or avoid using it at
    all.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index fb73dcbb5ef3..4d032e637f5c 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -10,7 +10,7 @@
  *  Copyright (C) 2012 John Crispin <john@phrozen.org>
  */
 
-#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/export.h>

commit 55e409502e02aeca224efa4cae69d2480879744b
Author: John Crispin <john@phrozen.org>
Date:   Tue Dec 20 19:55:41 2016 +0100

    pinctrl: update my email address
    
    This patch updates my email address as I no longer have access to the old
    one.
    
    Signed-off-by: John Crispin <john@phrozen.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 0b0fc2eb48e0..fb73dcbb5ef3 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -7,7 +7,7 @@
  *  by the Free Software Foundation.
  *
  *  Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
- *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2012 John Crispin <john@phrozen.org>
  */
 
 #include <linux/gpio.h>

commit 40b9e4fa752cae81e2ca448d8ef252264732a00f
Author: Anjana Sasindran <anjanasasindran123@gmail.com>
Date:   Thu Jan 15 21:45:22 2015 +0530

    staging: drivers: pinctrl: Fixed checkpatch.pl warnings
    
    This patch fixes two checkpatch.pl warnings
    
    WARNING: Error trailing white space
    WARNING: MIssing blank line after declaration
    
    Signed-off-by: Anjana Sasindran <anjanasasindran123@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 1d21dc226920..0b0fc2eb48e0 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -101,6 +101,7 @@ static void lantiq_load_pin_desc(struct pinctrl_pin_desc *d, int bank, int len)
 	for (i = 0; i < len; i++) {
 		/* strlen("ioXYZ") + 1 = 6 */
 		char *name = kzalloc(6, GFP_KERNEL);
+
 		snprintf(name, 6, "io%d", base + i);
 		d[i].number = base + i;
 		d[i].name = name;
@@ -463,7 +464,7 @@ static int pinctrl_falcon_probe(struct platform_device *pdev)
 								   &res);
 		if (IS_ERR(falcon_info.membase[*bank]))
 			return PTR_ERR(falcon_info.membase[*bank]);
-		
+
 		avail = pad_r32(falcon_info.membase[*bank],
 					LTQ_PADC_AVAIL);
 		pins = fls(avail);

commit 5c759d73b0228901d0e05e5f02402fb35f5d2263
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:21 2014 +0200

    pinctrl: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 2e62689b5e9f..1d21dc226920 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -500,7 +500,6 @@ static struct platform_driver pinctrl_falcon_driver = {
 	.probe = pinctrl_falcon_probe,
 	.driver = {
 		.name = "pinctrl-falcon",
-		.owner = THIS_MODULE,
 		.of_match_table = falcon_match,
 	},
 };

commit 03b054e9696c3cbd3d5905ec96da15acd0a2fe8d
Author: Sherman Yin <syin@broadcom.com>
Date:   Tue Aug 27 11:32:12 2013 -0700

    pinctrl: Pass all configs to driver on pin_config_set()
    
    When setting pin configuration in the pinctrl framework, pin_config_set() or
    pin_config_group_set() is called in a loop to set one configuration at a time
    for the specified pin or group.
    
    This patch 1) removes the loop and 2) changes the API to pass the whole pin
    config array to the driver.  It is now up to the driver to loop through the
    configs.  This allows the driver to potentially combine configs and reduce the
    number of writes to pin config registers.
    
    All c files changed have been build-tested to verify the change compiles and
    that the corresponding .o is successfully generated.
    
    Signed-off-by: Sherman Yin <syin@broadcom.com>
    Reviewed-by: Christian Daudt <csd@broadcom.com>
    Reviewed-by: Matt Porter <matt.porter@linaro.org>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 4e731f24df85..2e62689b5e9f 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -238,7 +238,8 @@ static int falcon_pinconf_group_get(struct pinctrl_dev *pctrldev,
 }
 
 static int falcon_pinconf_group_set(struct pinctrl_dev *pctrldev,
-				unsigned group, unsigned long config)
+				unsigned group, unsigned long *configs,
+				unsigned num_configs)
 {
 	return -ENOTSUPP;
 }
@@ -279,39 +280,47 @@ static int falcon_pinconf_get(struct pinctrl_dev *pctrldev,
 }
 
 static int falcon_pinconf_set(struct pinctrl_dev *pctrldev,
-			unsigned pin, unsigned long config)
+			unsigned pin, unsigned long *configs,
+			unsigned num_configs)
 {
-	enum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(config);
-	int arg = LTQ_PINCONF_UNPACK_ARG(config);
+	enum ltq_pinconf_param param;
+	int arg;
 	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
 	void __iomem *mem = info->membase[PORT(pin)];
 	u32 reg;
+	int i;
 
-	switch (param) {
-	case LTQ_PINCONF_PARAM_DRIVE_CURRENT:
-		reg = LTQ_PADC_DCC;
-		break;
-
-	case LTQ_PINCONF_PARAM_SLEW_RATE:
-		reg = LTQ_PADC_SRC;
-		break;
-
-	case LTQ_PINCONF_PARAM_PULL:
-		if (arg == 1)
-			reg = LTQ_PADC_PDEN;
-		else
-			reg = LTQ_PADC_PUEN;
-		break;
+	for (i = 0; i < num_configs; i++) {
+		param = LTQ_PINCONF_UNPACK_PARAM(configs[i]);
+		arg = LTQ_PINCONF_UNPACK_ARG(configs[i]);
+
+		switch (param) {
+		case LTQ_PINCONF_PARAM_DRIVE_CURRENT:
+			reg = LTQ_PADC_DCC;
+			break;
+
+		case LTQ_PINCONF_PARAM_SLEW_RATE:
+			reg = LTQ_PADC_SRC;
+			break;
+
+		case LTQ_PINCONF_PARAM_PULL:
+			if (arg == 1)
+				reg = LTQ_PADC_PDEN;
+			else
+				reg = LTQ_PADC_PUEN;
+			break;
+
+		default:
+			pr_err("%s: Invalid config param %04x\n",
+			pinctrl_dev_get_name(pctrldev), param);
+			return -ENOTSUPP;
+		}
 
-	default:
-		pr_err("%s: Invalid config param %04x\n",
-		pinctrl_dev_get_name(pctrldev), param);
-		return -ENOTSUPP;
-	}
+		pad_w32(mem, BIT(PORT_PIN(pin)), reg);
+		if (!(pad_r32(mem, reg) & BIT(PORT_PIN(pin))))
+			return -ENOTSUPP;
+	} /* for each config */
 
-	pad_w32(mem, BIT(PORT_PIN(pin)), reg);
-	if (!(pad_r32(mem, reg) & BIT(PORT_PIN(pin))))
-		return -ENOTSUPP;
 	return 0;
 }
 

commit 89ebefe3890e44516a99fb3d21d015ec3b75e50c
Author: Thomas Langer <thomas.langer@lantiq.com>
Date:   Fri Aug 9 20:38:14 2013 +0200

    pinctrl/lantiq: add missing pin definition to falcon pinctrl driver
    
    The pps pin definition is missing in the current code.
    
    Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
    Acked-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index f9b2a1d4854f..4e731f24df85 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -75,6 +75,7 @@ enum falcon_mux {
 	FALCON_MUX_GPIO = 0,
 	FALCON_MUX_RST,
 	FALCON_MUX_NTR,
+	FALCON_MUX_PPS,
 	FALCON_MUX_MDIO,
 	FALCON_MUX_LED,
 	FALCON_MUX_SPI,
@@ -114,7 +115,7 @@ static struct ltq_mfp_pin falcon_mfp[] = {
 	MFP_FALCON(GPIO2,	GPIO,	GPIO,   NONE,   NONE),
 	MFP_FALCON(GPIO3,	GPIO,	GPIO,   NONE,   NONE),
 	MFP_FALCON(GPIO4,	NTR,	GPIO,   NONE,   NONE),
-	MFP_FALCON(GPIO5,	NTR,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO5,	NTR,	GPIO,   PPS,    NONE),
 	MFP_FALCON(GPIO6,	RST,	GPIO,   NONE,   NONE),
 	MFP_FALCON(GPIO7,	MDIO,	GPIO,   NONE,   NONE),
 	MFP_FALCON(GPIO8,	MDIO,	GPIO,   NONE,   NONE),
@@ -168,6 +169,7 @@ static struct ltq_mfp_pin falcon_mfp[] = {
 static const unsigned pins_por[] = {GPIO0};
 static const unsigned pins_ntr[] = {GPIO4};
 static const unsigned pins_ntr8k[] = {GPIO5};
+static const unsigned pins_pps[] = {GPIO5};
 static const unsigned pins_hrst[] = {GPIO6};
 static const unsigned pins_mdio[] = {GPIO7, GPIO8};
 static const unsigned pins_bled[] = {GPIO9, GPIO10, GPIO11,
@@ -186,6 +188,7 @@ static struct ltq_pin_group falcon_grps[] = {
 	GRP_MUX("por", RST, pins_por),
 	GRP_MUX("ntr", NTR, pins_ntr),
 	GRP_MUX("ntr8k", NTR, pins_ntr8k),
+	GRP_MUX("pps", PPS, pins_pps),
 	GRP_MUX("hrst", RST, pins_hrst),
 	GRP_MUX("mdio", MDIO, pins_mdio),
 	GRP_MUX("bootled", LED, pins_bled),
@@ -201,7 +204,7 @@ static struct ltq_pin_group falcon_grps[] = {
 };
 
 static const char * const ltq_rst_grps[] = {"por", "hrst"};
-static const char * const ltq_ntr_grps[] = {"ntr", "ntr8k"};
+static const char * const ltq_ntr_grps[] = {"ntr", "ntr8k", "pps"};
 static const char * const ltq_mdio_grps[] = {"mdio"};
 static const char * const ltq_bled_grps[] = {"bootled"};
 static const char * const ltq_asc_grps[] = {"asc0", "asc1"};

commit 022ab148d28e8466e45d28552224e3029f1cccd8
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 10:25:07 2013 +0100

    pinctrl: Declare operation structures as const
    
    The pinconf, pinctrl and pinmux operation structures hold function
    pointers that are never modified. Declare them as const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index af97a1f90007..f9b2a1d4854f 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -353,7 +353,7 @@ static void falcon_pinconf_group_dbg_show(struct pinctrl_dev *pctrldev,
 {
 }
 
-static struct pinconf_ops falcon_pinconf_ops = {
+static const struct pinconf_ops falcon_pinconf_ops = {
 	.pin_config_get			= falcon_pinconf_get,
 	.pin_config_set			= falcon_pinconf_set,
 	.pin_config_group_get		= falcon_pinconf_group_get,

commit 06991c28f37ad68e5c03777f5c3b679b56e3dac1
Merge: 460dc1eecf37 74fef7a8fd1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 12:05:51 2013 -0800

    Merge tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core patches from Greg Kroah-Hartman:
     "Here is the big driver core merge for 3.9-rc1
    
      There are two major series here, both of which touch lots of drivers
      all over the kernel, and will cause you some merge conflicts:
    
       - add a new function called devm_ioremap_resource() to properly be
         able to check return values.
    
       - remove CONFIG_EXPERIMENTAL
    
      Other than those patches, there's not much here, some minor fixes and
      updates"
    
    Fix up trivial conflicts
    
    * tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (221 commits)
      base: memory: fix soft/hard_offline_page permissions
      drivercore: Fix ordering between deferred_probe and exiting initcalls
      backlight: fix class_find_device() arguments
      TTY: mark tty_get_device call with the proper const values
      driver-core: constify data for class_find_device()
      firmware: Ignore abort check when no user-helper is used
      firmware: Reduce ifdef CONFIG_FW_LOADER_USER_HELPER
      firmware: Make user-mode helper optional
      firmware: Refactoring for splitting user-mode helper code
      Driver core: treat unregistered bus_types as having no devices
      watchdog: Convert to devm_ioremap_resource()
      thermal: Convert to devm_ioremap_resource()
      spi: Convert to devm_ioremap_resource()
      power: Convert to devm_ioremap_resource()
      mtd: Convert to devm_ioremap_resource()
      mmc: Convert to devm_ioremap_resource()
      mfd: Convert to devm_ioremap_resource()
      media: Convert to devm_ioremap_resource()
      iommu: Convert to devm_ioremap_resource()
      drm: Convert to devm_ioremap_resource()
      ...

commit c58bdc36bc111cf3d8f1a27b68899ea3caf2e12b
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:05:03 2013 +0100

    pinctrl/lantiq: add functionality to falcon_pinconf_dbg_show
    
    The current code only has a stub for falcon_pinconf_dbg_show.
    This patch adds proper functionality.
    
    Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index c5a986855e17..4a0d54a08890 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -315,6 +315,37 @@ static int falcon_pinconf_set(struct pinctrl_dev *pctrldev,
 static void falcon_pinconf_dbg_show(struct pinctrl_dev *pctrldev,
 			struct seq_file *s, unsigned offset)
 {
+	unsigned long config;
+	struct pin_desc *desc;
+
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
+	int port = PORT(offset);
+
+	seq_printf(s, " (port %d) mux %d -- ", port,
+		pad_r32(info->membase[port], LTQ_PADC_MUX(PORT_PIN(offset))));
+
+	config = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_PULL, 0);
+	if (!falcon_pinconf_get(pctrldev, offset, &config))
+		seq_printf(s, "pull %d ",
+			(int)LTQ_PINCONF_UNPACK_ARG(config));
+
+	config = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_DRIVE_CURRENT, 0);
+	if (!falcon_pinconf_get(pctrldev, offset, &config))
+		seq_printf(s, "drive-current %d ",
+			(int)LTQ_PINCONF_UNPACK_ARG(config));
+
+	config = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_SLEW_RATE, 0);
+	if (!falcon_pinconf_get(pctrldev, offset, &config))
+		seq_printf(s, "slew-rate %d ",
+			(int)LTQ_PINCONF_UNPACK_ARG(config));
+
+	desc = pin_desc_get(pctrldev, offset);
+	if (desc) {
+		if (desc->gpio_owner)
+			seq_printf(s, " owner: %s", desc->gpio_owner);
+	} else {
+		seq_printf(s, " not registered");
+	}
 }
 
 static void falcon_pinconf_group_dbg_show(struct pinctrl_dev *pctrldev,

commit 77ef406272095691e84c85bebef0b225b5096e8d
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:05:02 2013 +0100

    pinctrl/lantiq: fix pinconfig parameters
    
    The Falcon driver only defined the pinconf parameters but
    did not pass them properly to the underlying api.
    
    Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 249a405fb80b..c5a986855e17 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -360,6 +360,8 @@ static const struct ltq_cfg_param falcon_cfg_params[] = {
 static struct ltq_pinmux_info falcon_info = {
 	.desc		= &falcon_pctrl_desc,
 	.apply_mux	= falcon_mux_apply,
+	.params		= falcon_cfg_params,
+	.num_params	= ARRAY_SIZE(falcon_cfg_params),
 };
 
 

commit 41228b7b336e4445f7a908bc2834cd4ef31d195f
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:05:01 2013 +0100

    pinctrl/lantiq: one of the boot leds was defined incorrectly
    
    On the Falcon SoC the bootleds are located on pins 9->14.
    
    Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 6331c5c25dbb..249a405fb80b 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -170,7 +170,7 @@ static const unsigned pins_ntr[] = {GPIO4};
 static const unsigned pins_ntr8k[] = {GPIO5};
 static const unsigned pins_hrst[] = {GPIO6};
 static const unsigned pins_mdio[] = {GPIO7, GPIO8};
-static const unsigned pins_bled[] = {GPIO7, GPIO10, GPIO11,
+static const unsigned pins_bled[] = {GPIO9, GPIO10, GPIO11,
 					GPIO12, GPIO13, GPIO14};
 static const unsigned pins_asc0[] = {GPIO32, GPIO33};
 static const unsigned pins_spi[] = {GPIO34, GPIO35, GPIO36};

commit a8ae367f40867fde80c90484c90b96c3968c224b
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:05:00 2013 +0100

    pinctrl/lantiq: only probe available pad controllers
    
    The template falcon.dtsi lists all 6 pad controllers that
    can be loaded. Only probe those that have status = "okay";
    inside the dts file.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 8ed20e84cb02..6331c5c25dbb 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -398,6 +398,9 @@ static int pinctrl_falcon_probe(struct platform_device *pdev)
 		u32 avail;
 		int pins;
 
+		if (!of_device_is_available(np))
+			continue;
+
 		if (!ppdev) {
 			dev_err(&pdev->dev, "failed to find pad pdev\n");
 			continue;

commit 9e0c1fb29a7c257a31c321c2437617b6b4d66168
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:14 2013 +0100

    pinctrl: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index 8ed20e84cb02..a5d9d562d966 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -411,14 +411,11 @@ static int pinctrl_falcon_probe(struct platform_device *pdev)
 			dev_err(&ppdev->dev, "failed to get clock\n");
 			return PTR_ERR(falcon_info.clk[*bank]);
 		}
-		falcon_info.membase[*bank] =
-				devm_request_and_ioremap(&pdev->dev, &res);
-		if (!falcon_info.membase[*bank]) {
-			dev_err(&pdev->dev,
-				"Failed to remap memory for bank %d\n",
-				*bank);
-			return -ENOMEM;
-		}
+		falcon_info.membase[*bank] = devm_ioremap_resource(&pdev->dev,
+								   &res);
+		if (IS_ERR(falcon_info.membase[*bank]))
+			return PTR_ERR(falcon_info.membase[*bank]);
+		
 		avail = pad_r32(falcon_info.membase[*bank],
 					LTQ_PADC_AVAIL);
 		pins = fls(avail);

commit 6bb0700bfe124f3ee245da24b5bb35152d2e6bfc
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Nov 7 13:37:08 2012 +0800

    pinctrl: Staticize pinconf_ops
    
    They are not referenced outside respective driver.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Cc: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
index ee7305903470..8ed20e84cb02 100644
--- a/drivers/pinctrl/pinctrl-falcon.c
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -322,7 +322,7 @@ static void falcon_pinconf_group_dbg_show(struct pinctrl_dev *pctrldev,
 {
 }
 
-struct pinconf_ops falcon_pinconf_ops = {
+static struct pinconf_ops falcon_pinconf_ops = {
 	.pin_config_get			= falcon_pinconf_get,
 	.pin_config_set			= falcon_pinconf_set,
 	.pin_config_group_get		= falcon_pinconf_group_get,

commit e316cb2b16bbfbe48387b56e7e6b5d32ec686f82
Author: John Crispin <blogic@openwrt.org>
Date:   Sun May 20 00:33:56 2012 +0200

    OF: pinctrl: MIPS: lantiq: adds support for FALCON SoC
    
    Implement support for pinctrl on lantiq/falcon socs. The FALCON has 5 banks
    of up to 32 pins.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/drivers/pinctrl/pinctrl-falcon.c b/drivers/pinctrl/pinctrl-falcon.c
new file mode 100644
index 000000000000..ee7305903470
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-falcon.c
@@ -0,0 +1,468 @@
+/*
+ *  linux/drivers/pinctrl/pinmux-falcon.c
+ *  based on linux/drivers/pinctrl/pinmux-pxa910.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
+ *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+
+#include "pinctrl-lantiq.h"
+
+#include <lantiq_soc.h>
+
+/* Multiplexer Control Register */
+#define LTQ_PADC_MUX(x)         (x * 0x4)
+/* Pull Up Enable Register */
+#define LTQ_PADC_PUEN		0x80
+/* Pull Down Enable Register */
+#define LTQ_PADC_PDEN		0x84
+/* Slew Rate Control Register */
+#define LTQ_PADC_SRC		0x88
+/* Drive Current Control Register */
+#define LTQ_PADC_DCC		0x8C
+/* Pad Control Availability Register */
+#define LTQ_PADC_AVAIL          0xF0
+
+#define pad_r32(p, reg)		ltq_r32(p + reg)
+#define pad_w32(p, val, reg)	ltq_w32(val, p + reg)
+#define pad_w32_mask(c, clear, set, reg) \
+		pad_w32(c, (pad_r32(c, reg) & ~(clear)) | (set), reg)
+
+#define pad_getbit(m, r, p)	(!!(ltq_r32(m + r) & (1 << p)))
+
+#define PORTS			5
+#define PINS			32
+#define PORT(x)                 (x / PINS)
+#define PORT_PIN(x)             (x % PINS)
+
+#define MFP_FALCON(a, f0, f1, f2, f3)		\
+{						\
+	.name = #a,				\
+	.pin = a,				\
+	.func = {				\
+		FALCON_MUX_##f0,		\
+		FALCON_MUX_##f1,		\
+		FALCON_MUX_##f2,		\
+		FALCON_MUX_##f3,		\
+	},					\
+}
+
+#define GRP_MUX(a, m, p)	\
+{				\
+	.name = a,		\
+	.mux = FALCON_MUX_##m,	\
+	.pins = p,		\
+	.npins = ARRAY_SIZE(p),	\
+}
+
+enum falcon_mux {
+	FALCON_MUX_GPIO = 0,
+	FALCON_MUX_RST,
+	FALCON_MUX_NTR,
+	FALCON_MUX_MDIO,
+	FALCON_MUX_LED,
+	FALCON_MUX_SPI,
+	FALCON_MUX_ASC,
+	FALCON_MUX_I2C,
+	FALCON_MUX_HOSTIF,
+	FALCON_MUX_SLIC,
+	FALCON_MUX_JTAG,
+	FALCON_MUX_PCM,
+	FALCON_MUX_MII,
+	FALCON_MUX_PHY,
+	FALCON_MUX_NONE = 0xffff,
+};
+
+static struct pinctrl_pin_desc falcon_pads[PORTS * PINS];
+static int pad_count[PORTS];
+
+static void lantiq_load_pin_desc(struct pinctrl_pin_desc *d, int bank, int len)
+{
+	int base = bank * PINS;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		/* strlen("ioXYZ") + 1 = 6 */
+		char *name = kzalloc(6, GFP_KERNEL);
+		snprintf(name, 6, "io%d", base + i);
+		d[i].number = base + i;
+		d[i].name = name;
+	}
+	pad_count[bank] = len;
+}
+
+static struct ltq_mfp_pin falcon_mfp[] = {
+	/*	pin		f0	f1	f2	f3 */
+	MFP_FALCON(GPIO0,	RST,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO1,	GPIO,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO2,	GPIO,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO3,	GPIO,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO4,	NTR,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO5,	NTR,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO6,	RST,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO7,	MDIO,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO8,	MDIO,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO9,	LED,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO10,	LED,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO11,	LED,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO12,	LED,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO13,	LED,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO14,	LED,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO32,	ASC,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO33,	ASC,	GPIO,   NONE,   NONE),
+	MFP_FALCON(GPIO34,	SPI,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO35,	SPI,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO36,	SPI,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO37,	SPI,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO38,	SPI,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO39,	I2C,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO40,	I2C,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO41,	HOSTIF,	GPIO,	HOSTIF,	JTAG),
+	MFP_FALCON(GPIO42,	HOSTIF,	GPIO,	HOSTIF,	NONE),
+	MFP_FALCON(GPIO43,	SLIC,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO44,	SLIC,	GPIO,	PCM,	ASC),
+	MFP_FALCON(GPIO45,	SLIC,	GPIO,	PCM,	ASC),
+	MFP_FALCON(GPIO64,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO65,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO66,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO67,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO68,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO69,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO70,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO71,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO72,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO73,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO74,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO75,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO76,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO77,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO78,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO79,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO80,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO81,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO82,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO83,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO84,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO85,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO86,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO87,	MII,	GPIO,	NONE,	NONE),
+	MFP_FALCON(GPIO88,	PHY,	GPIO,	NONE,	NONE),
+};
+
+static const unsigned pins_por[] = {GPIO0};
+static const unsigned pins_ntr[] = {GPIO4};
+static const unsigned pins_ntr8k[] = {GPIO5};
+static const unsigned pins_hrst[] = {GPIO6};
+static const unsigned pins_mdio[] = {GPIO7, GPIO8};
+static const unsigned pins_bled[] = {GPIO7, GPIO10, GPIO11,
+					GPIO12, GPIO13, GPIO14};
+static const unsigned pins_asc0[] = {GPIO32, GPIO33};
+static const unsigned pins_spi[] = {GPIO34, GPIO35, GPIO36};
+static const unsigned pins_spi_cs0[] = {GPIO37};
+static const unsigned pins_spi_cs1[] = {GPIO38};
+static const unsigned pins_i2c[] = {GPIO39, GPIO40};
+static const unsigned pins_jtag[] = {GPIO41};
+static const unsigned pins_slic[] = {GPIO43, GPIO44, GPIO45};
+static const unsigned pins_pcm[] = {GPIO44, GPIO45};
+static const unsigned pins_asc1[] = {GPIO44, GPIO45};
+
+static struct ltq_pin_group falcon_grps[] = {
+	GRP_MUX("por", RST, pins_por),
+	GRP_MUX("ntr", NTR, pins_ntr),
+	GRP_MUX("ntr8k", NTR, pins_ntr8k),
+	GRP_MUX("hrst", RST, pins_hrst),
+	GRP_MUX("mdio", MDIO, pins_mdio),
+	GRP_MUX("bootled", LED, pins_bled),
+	GRP_MUX("asc0", ASC, pins_asc0),
+	GRP_MUX("spi", SPI, pins_spi),
+	GRP_MUX("spi cs0", SPI, pins_spi_cs0),
+	GRP_MUX("spi cs1", SPI, pins_spi_cs1),
+	GRP_MUX("i2c", I2C, pins_i2c),
+	GRP_MUX("jtag", JTAG, pins_jtag),
+	GRP_MUX("slic", SLIC, pins_slic),
+	GRP_MUX("pcm", PCM, pins_pcm),
+	GRP_MUX("asc1", ASC, pins_asc1),
+};
+
+static const char * const ltq_rst_grps[] = {"por", "hrst"};
+static const char * const ltq_ntr_grps[] = {"ntr", "ntr8k"};
+static const char * const ltq_mdio_grps[] = {"mdio"};
+static const char * const ltq_bled_grps[] = {"bootled"};
+static const char * const ltq_asc_grps[] = {"asc0", "asc1"};
+static const char * const ltq_spi_grps[] = {"spi", "spi cs0", "spi cs1"};
+static const char * const ltq_i2c_grps[] = {"i2c"};
+static const char * const ltq_jtag_grps[] = {"jtag"};
+static const char * const ltq_slic_grps[] = {"slic"};
+static const char * const ltq_pcm_grps[] = {"pcm"};
+
+static struct ltq_pmx_func falcon_funcs[] = {
+	{"rst",		ARRAY_AND_SIZE(ltq_rst_grps)},
+	{"ntr",		ARRAY_AND_SIZE(ltq_ntr_grps)},
+	{"mdio",	ARRAY_AND_SIZE(ltq_mdio_grps)},
+	{"led",		ARRAY_AND_SIZE(ltq_bled_grps)},
+	{"asc",		ARRAY_AND_SIZE(ltq_asc_grps)},
+	{"spi",		ARRAY_AND_SIZE(ltq_spi_grps)},
+	{"i2c",		ARRAY_AND_SIZE(ltq_i2c_grps)},
+	{"jtag",	ARRAY_AND_SIZE(ltq_jtag_grps)},
+	{"slic",	ARRAY_AND_SIZE(ltq_slic_grps)},
+	{"pcm",		ARRAY_AND_SIZE(ltq_pcm_grps)},
+};
+
+
+
+
+/* ---------  pinconf related code --------- */
+static int falcon_pinconf_group_get(struct pinctrl_dev *pctrldev,
+				unsigned group, unsigned long *config)
+{
+	return -ENOTSUPP;
+}
+
+static int falcon_pinconf_group_set(struct pinctrl_dev *pctrldev,
+				unsigned group, unsigned long config)
+{
+	return -ENOTSUPP;
+}
+
+static int falcon_pinconf_get(struct pinctrl_dev *pctrldev,
+				unsigned pin, unsigned long *config)
+{
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
+	enum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(*config);
+	void __iomem *mem = info->membase[PORT(pin)];
+
+	switch (param) {
+	case LTQ_PINCONF_PARAM_DRIVE_CURRENT:
+		*config = LTQ_PINCONF_PACK(param,
+			!!pad_getbit(mem, LTQ_PADC_DCC, PORT_PIN(pin)));
+		break;
+
+	case LTQ_PINCONF_PARAM_SLEW_RATE:
+		*config = LTQ_PINCONF_PACK(param,
+			!!pad_getbit(mem, LTQ_PADC_SRC, PORT_PIN(pin)));
+		break;
+
+	case LTQ_PINCONF_PARAM_PULL:
+		if (pad_getbit(mem, LTQ_PADC_PDEN, PORT_PIN(pin)))
+			*config = LTQ_PINCONF_PACK(param, 1);
+		else if (pad_getbit(mem, LTQ_PADC_PUEN, PORT_PIN(pin)))
+			*config = LTQ_PINCONF_PACK(param, 2);
+		else
+			*config = LTQ_PINCONF_PACK(param, 0);
+
+		break;
+
+	default:
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static int falcon_pinconf_set(struct pinctrl_dev *pctrldev,
+			unsigned pin, unsigned long config)
+{
+	enum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(config);
+	int arg = LTQ_PINCONF_UNPACK_ARG(config);
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
+	void __iomem *mem = info->membase[PORT(pin)];
+	u32 reg;
+
+	switch (param) {
+	case LTQ_PINCONF_PARAM_DRIVE_CURRENT:
+		reg = LTQ_PADC_DCC;
+		break;
+
+	case LTQ_PINCONF_PARAM_SLEW_RATE:
+		reg = LTQ_PADC_SRC;
+		break;
+
+	case LTQ_PINCONF_PARAM_PULL:
+		if (arg == 1)
+			reg = LTQ_PADC_PDEN;
+		else
+			reg = LTQ_PADC_PUEN;
+		break;
+
+	default:
+		pr_err("%s: Invalid config param %04x\n",
+		pinctrl_dev_get_name(pctrldev), param);
+		return -ENOTSUPP;
+	}
+
+	pad_w32(mem, BIT(PORT_PIN(pin)), reg);
+	if (!(pad_r32(mem, reg) & BIT(PORT_PIN(pin))))
+		return -ENOTSUPP;
+	return 0;
+}
+
+static void falcon_pinconf_dbg_show(struct pinctrl_dev *pctrldev,
+			struct seq_file *s, unsigned offset)
+{
+}
+
+static void falcon_pinconf_group_dbg_show(struct pinctrl_dev *pctrldev,
+			struct seq_file *s, unsigned selector)
+{
+}
+
+struct pinconf_ops falcon_pinconf_ops = {
+	.pin_config_get			= falcon_pinconf_get,
+	.pin_config_set			= falcon_pinconf_set,
+	.pin_config_group_get		= falcon_pinconf_group_get,
+	.pin_config_group_set		= falcon_pinconf_group_set,
+	.pin_config_dbg_show		= falcon_pinconf_dbg_show,
+	.pin_config_group_dbg_show	= falcon_pinconf_group_dbg_show,
+};
+
+static struct pinctrl_desc falcon_pctrl_desc = {
+	.owner		= THIS_MODULE,
+	.pins		= falcon_pads,
+	.confops	= &falcon_pinconf_ops,
+};
+
+static inline int falcon_mux_apply(struct pinctrl_dev *pctrldev,
+			int mfp, int mux)
+{
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
+	int port = PORT(info->mfp[mfp].pin);
+
+	if ((port >= PORTS) || (!info->membase[port]))
+		return -ENODEV;
+
+	pad_w32(info->membase[port], mux,
+		LTQ_PADC_MUX(PORT_PIN(info->mfp[mfp].pin)));
+	return 0;
+}
+
+static const struct ltq_cfg_param falcon_cfg_params[] = {
+	{"lantiq,pull",			LTQ_PINCONF_PARAM_PULL},
+	{"lantiq,drive-current",	LTQ_PINCONF_PARAM_DRIVE_CURRENT},
+	{"lantiq,slew-rate",		LTQ_PINCONF_PARAM_SLEW_RATE},
+};
+
+static struct ltq_pinmux_info falcon_info = {
+	.desc		= &falcon_pctrl_desc,
+	.apply_mux	= falcon_mux_apply,
+};
+
+
+
+
+/* --------- register the pinctrl layer --------- */
+
+int pinctrl_falcon_get_range_size(int id)
+{
+	u32 avail;
+
+	if ((id >= PORTS) || (!falcon_info.membase[id]))
+		return -EINVAL;
+
+	avail = pad_r32(falcon_info.membase[id], LTQ_PADC_AVAIL);
+
+	return fls(avail);
+}
+
+void pinctrl_falcon_add_gpio_range(struct pinctrl_gpio_range *range)
+{
+	pinctrl_add_gpio_range(falcon_info.pctrl, range);
+}
+
+static int pinctrl_falcon_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	int pad_count = 0;
+	int ret = 0;
+
+	/* load and remap the pad resources of the different banks */
+	for_each_compatible_node(np, NULL, "lantiq,pad-falcon") {
+		struct platform_device *ppdev = of_find_device_by_node(np);
+		const __be32 *bank = of_get_property(np, "lantiq,bank", NULL);
+		struct resource res;
+		u32 avail;
+		int pins;
+
+		if (!ppdev) {
+			dev_err(&pdev->dev, "failed to find pad pdev\n");
+			continue;
+		}
+		if (!bank || *bank >= PORTS)
+			continue;
+		if (of_address_to_resource(np, 0, &res))
+			continue;
+		falcon_info.clk[*bank] = clk_get(&ppdev->dev, NULL);
+		if (IS_ERR(falcon_info.clk[*bank])) {
+			dev_err(&ppdev->dev, "failed to get clock\n");
+			return PTR_ERR(falcon_info.clk[*bank]);
+		}
+		falcon_info.membase[*bank] =
+				devm_request_and_ioremap(&pdev->dev, &res);
+		if (!falcon_info.membase[*bank]) {
+			dev_err(&pdev->dev,
+				"Failed to remap memory for bank %d\n",
+				*bank);
+			return -ENOMEM;
+		}
+		avail = pad_r32(falcon_info.membase[*bank],
+					LTQ_PADC_AVAIL);
+		pins = fls(avail);
+		lantiq_load_pin_desc(&falcon_pads[pad_count], *bank, pins);
+		pad_count += pins;
+		clk_enable(falcon_info.clk[*bank]);
+		dev_dbg(&pdev->dev, "found %s with %d pads\n",
+				res.name, pins);
+	}
+	dev_dbg(&pdev->dev, "found a total of %d pads\n", pad_count);
+	falcon_pctrl_desc.name	= dev_name(&pdev->dev);
+	falcon_pctrl_desc.npins	= pad_count;
+
+	falcon_info.mfp		= falcon_mfp;
+	falcon_info.num_mfp	= ARRAY_SIZE(falcon_mfp);
+	falcon_info.grps	= falcon_grps;
+	falcon_info.num_grps	= ARRAY_SIZE(falcon_grps);
+	falcon_info.funcs	= falcon_funcs;
+	falcon_info.num_funcs	= ARRAY_SIZE(falcon_funcs);
+
+	ret = ltq_pinctrl_register(pdev, &falcon_info);
+	if (!ret)
+		dev_info(&pdev->dev, "Init done\n");
+	return ret;
+}
+
+static const struct of_device_id falcon_match[] = {
+	{ .compatible = "lantiq,pinctrl-falcon" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, falcon_match);
+
+static struct platform_driver pinctrl_falcon_driver = {
+	.probe = pinctrl_falcon_probe,
+	.driver = {
+		.name = "pinctrl-falcon",
+		.owner = THIS_MODULE,
+		.of_match_table = falcon_match,
+	},
+};
+
+int __init pinctrl_falcon_init(void)
+{
+	return platform_driver_register(&pinctrl_falcon_driver);
+}
+
+core_initcall_sync(pinctrl_falcon_init);
