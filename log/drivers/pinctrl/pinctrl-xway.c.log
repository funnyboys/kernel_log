commit 4b024225c4a8245e6ecc66ce1df1eaf2ebeb4acb
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon Nov 4 22:26:54 2019 +0800

    pinctrl: use devm_platform_ioremap_resource() to simplify code
    
    devm_platform_ioremap_resource() internally have platform_get_resource()
    and devm_ioremap_resource() in it. So instead of calling them separately
    use devm_platform_ioremap_resource() directly.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Link: https://lore.kernel.org/r/20191104142654.39256-1-yuehaibing@huawei.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 913d38f29b73..5e3f31b55eb7 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1705,12 +1705,10 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
 	const struct pinctrl_xway_soc *xway_soc;
-	struct resource *res;
 	int ret, i;
 
 	/* get and remap our register range */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	xway_info.membase[0] = devm_ioremap_resource(&pdev->dev, res);
+	xway_info.membase[0] = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(xway_info.membase[0]))
 		return PTR_ERR(xway_info.membase[0]);
 

commit d55b7fdd58ac12e76ef65979af4a13b9c15fc00d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jul 31 15:29:17 2019 +0200

    pinctrl: xway: Use devm_kasprintf() instead of fixed buffer formatting
    
    Improve readability and maintainability by replacing a hardcoded string
    allocation and formatting by the use of the devm_kasprintf() helper.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20190731132917.17607-4-geert+renesas@glider.be
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 376222d0e5c5..913d38f29b73 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1731,13 +1731,11 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	for (i = 0; i < xway_chip.ngpio; i++) {
-		/* strlen("ioXY") + 1 = 5 */
-		char *name = devm_kzalloc(&pdev->dev, 5, GFP_KERNEL);
+		char *name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "io%d", i);
 
 		if (!name)
 			return -ENOMEM;
 
-		snprintf(name, 5, "io%d", i);
 		xway_info.pads[i].number = GPIO0 + i;
 		xway_info.pads[i].name = name;
 	}

commit 1d0ea0692ae3f909b22e99af3121bcf3142a5c5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:46 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 332
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      publishhed by the free software foundation
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 48 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.292339952@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index ae74b260b014..376222d0e5c5 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/drivers/pinctrl/pinmux-xway.c
  *  based on linux/drivers/pinctrl/pinmux-pxa910.c
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  publishhed by the Free Software Foundation.
- *
  *  Copyright (C) 2012 John Crispin <john@phrozen.org>
  *  Copyright (C) 2015 Martin Schiller <mschiller@tdt.de>
  */

commit 9b4924da4711674e62d97d4f5360446cc78337af
Author: Martin Schiller <ms@dev.tdt.de>
Date:   Fri Dec 14 08:48:25 2018 +0100

    pinctrl: xway: fix gpio-hog related boot issues
    
    This patch is based on commit a86caa9ba5d7 ("pinctrl: msm: fix gpio-hog
    related boot issues").
    
    It fixes the issue that the gpio ranges needs to be defined before
    gpiochip_add().
    
    Therefore, we also have to swap the order of registering the pinctrl
    driver and registering the gpio chip.
    
    You also have to add the "gpio-ranges" property to the pinctrl device
    node to get it finally working.
    
    Signed-off-by: Martin Schiller <ms@dev.tdt.de>
    Acked-by: John Crispin <john@phrozen.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 93f8bd04e7fe..ae74b260b014 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1746,14 +1746,6 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	}
 	xway_pctrl_desc.pins = xway_info.pads;
 
-	/* register the gpio chip */
-	xway_chip.parent = &pdev->dev;
-	ret = devm_gpiochip_add_data(&pdev->dev, &xway_chip, NULL);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to register gpio chip\n");
-		return ret;
-	}
-
 	/* setup the data needed by pinctrl */
 	xway_pctrl_desc.name	= dev_name(&pdev->dev);
 	xway_pctrl_desc.npins	= xway_chip.ngpio;
@@ -1775,10 +1767,33 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/* finish with registering the gpio range in pinctrl */
-	xway_gpio_range.npins = xway_chip.ngpio;
-	xway_gpio_range.base = xway_chip.base;
-	pinctrl_add_gpio_range(xway_info.pctrl, &xway_gpio_range);
+	/* register the gpio chip */
+	xway_chip.parent = &pdev->dev;
+	xway_chip.owner = THIS_MODULE;
+	xway_chip.of_node = pdev->dev.of_node;
+	ret = devm_gpiochip_add_data(&pdev->dev, &xway_chip, NULL);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register gpio chip\n");
+		return ret;
+	}
+
+	/*
+	 * For DeviceTree-supported systems, the gpio core checks the
+	 * pinctrl's device node for the "gpio-ranges" property.
+	 * If it is present, it takes care of adding the pin ranges
+	 * for the driver. In this case the driver can skip ahead.
+	 *
+	 * In order to remain compatible with older, existing DeviceTree
+	 * files which don't set the "gpio-ranges" property or systems that
+	 * utilize ACPI the driver has to call gpiochip_add_pin_range().
+	 */
+	if (!of_property_read_bool(pdev->dev.of_node, "gpio-ranges")) {
+		/* finish with registering the gpio range in pinctrl */
+		xway_gpio_range.npins = xway_chip.ngpio;
+		xway_gpio_range.base = xway_chip.base;
+		pinctrl_add_gpio_range(xway_info.pctrl, &xway_gpio_range);
+	}
+
 	dev_info(&pdev->dev, "Init done\n");
 	return 0;
 }

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index cd0f402c1164..93f8bd04e7fe 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1727,8 +1727,8 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	xway_chip.ngpio = xway_soc->pin_count;
 
 	/* load our pad descriptors */
-	xway_info.pads = devm_kzalloc(&pdev->dev,
-			sizeof(struct pinctrl_pin_desc) * xway_chip.ngpio,
+	xway_info.pads = devm_kcalloc(&pdev->dev,
+			xway_chip.ngpio, sizeof(struct pinctrl_pin_desc),
 			GFP_KERNEL);
 	if (!xway_info.pads)
 		return -ENOMEM;

commit e423f0ceef436b3246fd8b0d5ed51cf89fd8b45e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Dec 25 21:51:26 2017 +0100

    pinctrl: xway: Delete two error messages for a failed memory allocation in pinmux_xway_probe()
    
    Omit extra messages for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index f9e98a7d4f0c..cd0f402c1164 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1730,18 +1730,16 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	xway_info.pads = devm_kzalloc(&pdev->dev,
 			sizeof(struct pinctrl_pin_desc) * xway_chip.ngpio,
 			GFP_KERNEL);
-	if (!xway_info.pads) {
-		dev_err(&pdev->dev, "Failed to allocate pads\n");
+	if (!xway_info.pads)
 		return -ENOMEM;
-	}
+
 	for (i = 0; i < xway_chip.ngpio; i++) {
 		/* strlen("ioXY") + 1 = 5 */
 		char *name = devm_kzalloc(&pdev->dev, 5, GFP_KERNEL);
 
-		if (!name) {
-			dev_err(&pdev->dev, "Failed to allocate pad name\n");
+		if (!name)
 			return -ENOMEM;
-		}
+
 		snprintf(name, 5, "io%d", i);
 		xway_info.pads[i].number = GPIO0 + i;
 		xway_info.pads[i].name = name;

commit 4196be5ba0b0f394ecee1cd1fde945034f943556
Author: Martin Schiller <ms@dev.tdt.de>
Date:   Mon May 29 06:08:38 2017 +0200

    pinctrl: xway: fix copy/paste error in xrx200_grps
    
    Signed-off-by: Martin Schiller <ms@dev.tdt.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index d4167e2c173a..f9e98a7d4f0c 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1028,7 +1028,7 @@ static const struct ltq_pin_group xrx200_grps[] = {
 	GRP_MUX("spi_cs5", SPI, xrx200_pins_spi_cs5),
 	GRP_MUX("spi_cs6", SPI, xrx200_pins_spi_cs6),
 	GRP_MUX("usif uart_rx", USIF, xrx200_pins_usif_uart_rx),
-	GRP_MUX("usif uart_rx", USIF, xrx200_pins_usif_uart_tx),
+	GRP_MUX("usif uart_tx", USIF, xrx200_pins_usif_uart_tx),
 	GRP_MUX("usif uart_rts", USIF, xrx200_pins_usif_uart_rts),
 	GRP_MUX("usif uart_cts", USIF, xrx200_pins_usif_uart_cts),
 	GRP_MUX("usif uart_dtr", USIF, xrx200_pins_usif_uart_dtr),

commit 55e409502e02aeca224efa4cae69d2480879744b
Author: John Crispin <john@phrozen.org>
Date:   Tue Dec 20 19:55:41 2016 +0100

    pinctrl: update my email address
    
    This patch updates my email address as I no longer have access to the old
    one.
    
    Signed-off-by: John Crispin <john@phrozen.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index dd85ad1807f5..d4167e2c173a 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -6,7 +6,7 @@
  *  it under the terms of the GNU General Public License version 2 as
  *  publishhed by the Free Software Foundation.
  *
- *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2012 John Crispin <john@phrozen.org>
  *  Copyright (C) 2015 Martin Schiller <mschiller@tdt.de>
  */
 

commit d94ba9e7d8d5c821d0442f13b30b0140c1109c38
Merge: 1c88e19b0f6a 9573e7923007
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 28 17:06:51 2016 -0700

    Merge tag 'pinctrl-v4.8-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This is the bulk of pin control changes for the v4.8 kernel cycle.
    
      Nothing stands out as especially exiting: new drivers, new subdrivers,
      lots of cleanups and incremental features.
    
      Business as usual.
    
      New drivers:
    
       - New driver for Oxnas pin control and GPIO.  This ARM-based chipset
         is used in a few storage (NAS) type devices.
    
       - New driver for the MAX77620/MAX20024 pin controller portions.
    
       - New driver for the Intel Merrifield pin controller.
    
      New subdrivers:
    
       - New subdriver for the Qualcomm MDM9615
    
       - New subdriver for the STM32F746 MCU
    
       - New subdriver for the Broadcom NSP SoC.
    
      Cleanups:
    
       - Demodularization of bool compiled-in drivers.
    
      Apart from this there is just regular incremental improvements to a
      lot of drivers, especially Uniphier and PFC"
    
    * tag 'pinctrl-v4.8-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (131 commits)
      pinctrl: fix pincontrol definition for marvell
      pinctrl: xway: fix typo
      Revert "pinctrl: amd: make it explicitly non-modular"
      pinctrl: iproc: Add NSP and Stingray GPIO support
      pinctrl: Update iProc GPIO DT bindings
      pinctrl: bcm: add OF dependencies
      pinctrl: ns2: remove redundant dev_err call in ns2_pinmux_probe()
      pinctrl: Add STM32F746 MCU support
      pinctrl: intel: Protect set wake flow by spin lock
      pinctrl: nsp: remove redundant dev_err call in nsp_pinmux_probe()
      pinctrl: uniphier: add Ethernet pin-mux settings
      sh-pfc: Use PTR_ERR_OR_ZERO() to simplify the code
      pinctrl: ns2: fix return value check in ns2_pinmux_probe()
      pinctrl: qcom: update DT bindings with ebi2 groups
      pinctrl: qcom: establish proper EBI2 pin groups
      pinctrl: imx21: Remove the MODULE_DEVICE_TABLE() macro
      Documentation: dt: Add new compatible to STM32 pinctrl driver bindings
      includes: dt-bindings: Add STM32F746 pinctrl DT bindings
      pinctrl: sunxi: fix nand0 function name for sun8i
      pinctrl: uniphier: remove pointless pin-mux settings for PH1-LD11
      ...

commit 728cf7448c6672c1fe8f6afcd6b48366952bead6
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jul 22 17:42:39 2016 +0200

    pinctrl: xway: fix typo
    
    A typo in the previous commit to this file needs fixing.
    
    Cc: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Fixes: 6b4316aecec0 ("pinctrl: xway: Change structure initialisation to c99 style")
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index dac88a2a1693..f3775f823e8b 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1647,7 +1647,7 @@ static struct pinctrl_xway_soc danube_pinctrl = {
 	.funcs = danube_funcs,
 	.num_funcs = ARRAY_SIZE(danube_funcs),
 	.exin = danube_exin_pin_map,
-	.num-exin = 3
+	.num_exin = 3
 };
 
 /* XWAY xRX100 Family */

commit 6b4316aecec07db6ac27820720cc2f2d18ea52e9
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sat Jun 11 09:32:52 2016 +0530

    pinctrl: xway: Change structure initialisation to c99 style
    
    Replace the in order struct initialisation style with explicit field
    style.
    
    The Coccinelle semantic patch used to make this change is as follows:
    
    @decl@
    identifier i1,fld;
    type T;
    field list[n] fs;
    @@
    
    struct i1 {
     fs
     T fld;
     ...};
    
    @@
    identifier decl.i1,i2,decl.fld;
    expression e;
    position bad.p, bad.fix;
    @@
    
    struct i1 i2@p = { ...,
    + .fld = e
    - e@fix
     ,...};
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index a13f2b6f6fc0..dac88a2a1693 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1616,50 +1616,74 @@ struct pinctrl_xway_soc {
 
 /* xway xr9 series (DEPRECATED: Use XWAY xRX100/xRX200 Family) */
 static struct pinctrl_xway_soc xr9_pinctrl = {
-	XR9_MAX_PIN, xway_mfp,
-	xway_grps, ARRAY_SIZE(xway_grps),
-	xrx_funcs, ARRAY_SIZE(xrx_funcs),
-	xway_exin_pin_map, 6
+	.pin_count = XR9_MAX_PIN,
+	.mfp = xway_mfp,
+	.grps = xway_grps,
+	.num_grps = ARRAY_SIZE(xway_grps),
+	.funcs = xrx_funcs,
+	.num_funcs = ARRAY_SIZE(xrx_funcs),
+	.exin = xway_exin_pin_map,
+	.num_exin = 6
 };
 
 /* XWAY AMAZON Family */
 static struct pinctrl_xway_soc ase_pinctrl = {
-	ASE_MAX_PIN, ase_mfp,
-	ase_grps, ARRAY_SIZE(ase_grps),
-	ase_funcs, ARRAY_SIZE(ase_funcs),
-	ase_exin_pin_map, 3
+	.pin_count = ASE_MAX_PIN,
+	.mfp = ase_mfp,
+	.grps = ase_grps,
+	.num_grps = ARRAY_SIZE(ase_grps),
+	.funcs = ase_funcs,
+	.num_funcs = ARRAY_SIZE(ase_funcs),
+	.exin = ase_exin_pin_map,
+	.num_exin = 3
 };
 
 /* XWAY DANUBE Family */
 static struct pinctrl_xway_soc danube_pinctrl = {
-	DANUBE_MAX_PIN, danube_mfp,
-	danube_grps, ARRAY_SIZE(danube_grps),
-	danube_funcs, ARRAY_SIZE(danube_funcs),
-	danube_exin_pin_map, 3
+	.pin_count = DANUBE_MAX_PIN,
+	.mfp = danube_mfp,
+	.grps = danube_grps,
+	.num_grps = ARRAY_SIZE(danube_grps),
+	.funcs = danube_funcs,
+	.num_funcs = ARRAY_SIZE(danube_funcs),
+	.exin = danube_exin_pin_map,
+	.num-exin = 3
 };
 
 /* XWAY xRX100 Family */
 static struct pinctrl_xway_soc xrx100_pinctrl = {
-	XRX100_MAX_PIN, xrx100_mfp,
-	xrx100_grps, ARRAY_SIZE(xrx100_grps),
-	xrx100_funcs, ARRAY_SIZE(xrx100_funcs),
-	xrx100_exin_pin_map, 6
+	.pin_count = XRX100_MAX_PIN,
+	.mfp = xrx100_mfp,
+	.grps = xrx100_grps,
+	.num_grps = ARRAY_SIZE(xrx100_grps),
+	.funcs = xrx100_funcs,
+	.num_funcs = ARRAY_SIZE(xrx100_funcs),
+	.exin = xrx100_exin_pin_map,
+	.num_exin = 6
 };
 
 /* XWAY xRX200 Family */
 static struct pinctrl_xway_soc xrx200_pinctrl = {
-	XRX200_MAX_PIN, xrx200_mfp,
-	xrx200_grps, ARRAY_SIZE(xrx200_grps),
-	xrx200_funcs, ARRAY_SIZE(xrx200_funcs),
-	xrx200_exin_pin_map, 6
+	.pin_count = XRX200_MAX_PIN,
+	.mfp = xrx200_mfp,
+	.grps = xrx200_grps,
+	.num_grps = ARRAY_SIZE(xrx200_grps),
+	.funcs = xrx200_funcs,
+	.num_funcs = ARRAY_SIZE(xrx200_funcs),
+	.exin = xrx200_exin_pin_map,
+	.num_exin = 6
 };
 
 /* XWAY xRX300 Family */
 static struct pinctrl_xway_soc xrx300_pinctrl = {
-	XRX300_MAX_PIN, xrx300_mfp,
-	xrx300_grps, ARRAY_SIZE(xrx300_grps),
-	xrx300_funcs, ARRAY_SIZE(xrx300_funcs),
-	xrx300_exin_pin_map, 5
+	.pin_count = XRX300_MAX_PIN,
+	.mfp = xrx300_mfp,
+	.grps = xrx300_grps,
+	.num_grps = ARRAY_SIZE(xrx300_grps),
+	.funcs = xrx300_funcs,
+	.num_funcs = ARRAY_SIZE(xrx300_funcs),
+	.exin = xrx300_exin_pin_map,
+	.num_exin = 5
 };
 
 static struct pinctrl_gpio_range xway_gpio_range = {

commit 86ede3d41b56f98fb5923a127d08857309b35524
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon May 23 11:00:37 2016 +0200

    pinctrl: xway: use devm_gpiochip_add_data()
    
    Avoid a gpiochip_free() and use standard functions.
    
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Pramod Gurav <pramod.gurav@smartplayin.com>
    Cc: Martin Schiller <mschiller@tdt.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index a13f2b6f6fc0..b9375544dff0 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1724,9 +1724,9 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	}
 	xway_pctrl_desc.pins = xway_info.pads;
 
-	/* load the gpio chip */
+	/* register the gpio chip */
 	xway_chip.parent = &pdev->dev;
-	ret = gpiochip_add(&xway_chip);
+	ret = devm_gpiochip_add_data(&pdev->dev, &xway_chip, NULL);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to register gpio chip\n");
 		return ret;
@@ -1749,7 +1749,6 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	/* register with the generic lantiq layer */
 	ret = ltq_pinctrl_register(pdev, &xway_info);
 	if (ret) {
-		gpiochip_remove(&xway_chip);
 		dev_err(&pdev->dev, "Failed to register pinctrl driver\n");
 		return ret;
 	}

commit e1641c9d174ee21b4a75a64ab6df9063cf60ac4a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Apr 1 15:21:27 2016 +0200

    Revert "Revert "pinctrl: lantiq: Implement gpio_chip.to_irq""
    
    This reverts commit 446f59acb70b70a425ea4105277a71eb615327cd.

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 412c6b78140a..a13f2b6f6fc0 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1573,6 +1573,22 @@ static int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)
 	return 0;
 }
 
+/*
+ * gpiolib gpiod_to_irq callback function.
+ * Returns the mapped IRQ (external interrupt) number for a given GPIO pin.
+ */
+static int xway_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
+	int i;
+
+	for (i = 0; i < info->num_exin; i++)
+		if (info->exin[i] == offset)
+			return ltq_eiu_get_irq(i);
+
+	return -1;
+}
+
 static struct gpio_chip xway_chip = {
 	.label = "gpio-xway",
 	.direction_input = xway_gpio_dir_in,
@@ -1581,6 +1597,7 @@ static struct gpio_chip xway_chip = {
 	.set = xway_gpio_set,
 	.request = gpiochip_generic_request,
 	.free = gpiochip_generic_free,
+	.to_irq = xway_gpio_to_irq,
 	.base = -1,
 };
 

commit 58cf279acac3080ce03eeea5ca268210b3165fe1
Merge: 6606b342febf c474e348778b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 17 12:32:01 2016 -0800

    Merge tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "Here is the bulk of GPIO changes for v4.5.
    
      Notably there are big refactorings mostly by myself, aimed at getting
      the gpio_chip into a shape that makes me believe I can proceed to
      preserve state for a proper userspace ABI (character device) that has
      already been proposed once, but resulted in the feedback that I need
      to go back and restructure stuff.  So I've been restructuring stuff.
      On the way I ran into brokenness (return code from the get_value()
      callback) and had to fix it.  Also, refactored generic GPIO to be
      simpler.
    
      Some of that is still waiting to trickle down from the subsystems all
      over the kernel that provide random gpio_chips, I've touched every
      single GPIO driver in the kernel now, oh man I didn't know I was
      responsible for so much...
    
      Apart from that we're churning along as usual.
    
      I took some effort to test and retest so it should merge nicely and we
      shook out a couple of bugs in -next.
    
      Infrastructural changes:
    
       - In struct gpio_chip, rename the .dev node to .parent to better
         reflect the fact that this is not the GPIO struct device
         abstraction.  We will add that soon so this would be totallt
         confusing.
    
       - It was noted that the driver .get_value() callbacks was sometimes
         reporting negative -ERR values to the gpiolib core, expecting them
         to be propagated to consumer gpiod_get_value() and gpio_get_value()
         calls.  This was not happening, so as there was a mess of drivers
         returning negative errors and some returning "anything else than
         zero" to indicate that a line was active.  As some would have bit
         31 set to indicate "line active" it clashed with negative error
         codes.  This is fixed by the largeish series clamping values in all
         drivers with !!value to [0,1] and then augmenting the code to
         propagate error codes to consumers.  (Includes some ACKed patches
         in other subsystems.)
    
       - Add a void *data pointer to struct gpio_chip.  The container_of()
         design pattern is indeed very nice, but we want to reform the
         struct gpio_chip to be a non-volative, stateless business, and keep
         states internal to the gpiolib to be able to hold on to the state
         when adding a proper userspace ABI (character device) further down
         the road.  To achieve this, drivers need a handle at the internal
         state that is not dependent on their struct gpio_chip() so we add
         gpiochip_add_data() and gpiochip_get_data() following the pattern
         of many other subsystems.  All the "use gpiochip data pointer"
         patches transforms drivers to this scheme.
    
       - The Generic GPIO chip header has been merged into the general
         <linux/gpio/driver.h> header, and the custom header for that
         removed.  Instead of having a separate mm_gpio_chip struct for
         these generic drivers, merge that into struct gpio_chip,
         simplifying the code and removing the need for separate and
         confusing includes.
    
      Misc improvements:
    
       - Stabilize the way GPIOs are looked up from the ACPI legacy
         specification.
    
       - Incremental driver features for PXA, PCA953X, Lantiq (patches from
         the OpenWRT community), RCAR, Zynq, PL061, 104-idi-48
    
      New drivers:
    
       - Add a GPIO chip to the ALSA SoC AC97 driver.
    
       - Add a new Broadcom NSP SoC driver (this lands in the pinctrl dir,
         but the branch is merged here too to account for infrastructural
         changes).
    
       - The sx150x driver now supports the sx1502"
    
    * tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (220 commits)
      gpio: generic: make bgpio_pdata always visible
      gpiolib: fix chip order in gpio list
      gpio: mpc8xxx: Do not use gpiochip_get_data() in mpc8xxx_gpio_save_regs()
      gpio: mm-lantiq: Do not use gpiochip_get_data() in ltq_mm_save_regs()
      gpio: brcmstb: Allow building driver for BMIPS_GENERIC
      gpio: brcmstb: Set endian flags for big-endian MIPS
      gpio: moxart: fix build regression
      gpio: xilinx: Do not use gpiochip_get_data() in xgpio_save_regs()
      leds: pca9532: use gpiochip data pointer
      leds: tca6507: use gpiochip data pointer
      hid: cp2112: use gpiochip data pointer
      bcma: gpio: use gpiochip data pointer
      avr32: gpio: use gpiochip data pointer
      video: fbdev: via: use gpiochip data pointer
      gpio: pch: Optimize pch_gpio_get()
      Revert "pinctrl: lantiq: Implement gpio_chip.to_irq"
      pinctrl: nsp-gpio: use gpiochip data pointer
      pinctrl: vt8500-wmt: use gpiochip data pointer
      pinctrl: exynos5440: use gpiochip data pointer
      pinctrl: at91-pio4: use gpiochip data pointer
      ...

commit 446f59acb70b70a425ea4105277a71eb615327cd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 5 14:10:17 2016 +0100

    Revert "pinctrl: lantiq: Implement gpio_chip.to_irq"
    
    This reverts commit 3e640743fee6e6a82ead1f163737755b2a965712.
    
    This commit needs to go into the pinctrl tree to avoid
    clashes.

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index ebd867f50700..af69af869f5b 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -682,22 +682,6 @@ static int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)
 	return 0;
 }
 
-/*
- * gpiolib gpiod_to_irq callback function.
- * Returns the mapped IRQ (external interrupt) number for a given GPIO pin.
- */
-static int xway_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
-{
-	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
-	int i;
-
-	for (i = 0; i < info->num_exin; i++)
-		if (info->exin[i] == offset)
-			return ltq_eiu_get_irq(i);
-
-	return -1;
-}
-
 static struct gpio_chip xway_chip = {
 	.label = "gpio-xway",
 	.direction_input = xway_gpio_dir_in,
@@ -706,7 +690,6 @@ static struct gpio_chip xway_chip = {
 	.set = xway_gpio_set,
 	.request = gpiochip_generic_request,
 	.free = gpiochip_generic_free,
-	.to_irq = xway_gpio_to_irq,
 	.base = -1,
 };
 

commit c9f294ff6584782d20b4a766901a9cff7398bb20
Author: John Crispin <blogic@openwrt.org>
Date:   Mon Jan 4 22:27:57 2016 +0100

    pinctrl: lantiq: 2 pins have the wrong mux list
    
    The latest vendor SDK contained this patch.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index b78baaa5ee4b..7db74699fda4 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -160,10 +160,10 @@ static const struct ltq_mfp_pin xway_mfp[] = {
 	MFP_XWAY(GPIO41, GPIO,	NONE,	NONE,	NONE),
 	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
 	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
-	MFP_XWAY(GPIO44, GPIO,	NONE,	SIN,	GPHY),
+	MFP_XWAY(GPIO44, GPIO,	MII,	SIN,	GPHY),
 	MFP_XWAY(GPIO45, GPIO,	NONE,	GPHY,	SIN),
 	MFP_XWAY(GPIO46, GPIO,	NONE,	NONE,	EXIN),
-	MFP_XWAY(GPIO47, GPIO,	NONE,	GPHY,	SIN),
+	MFP_XWAY(GPIO47, GPIO,	MII,	GPHY,	SIN),
 	MFP_XWAY(GPIO48, GPIO,	EBU,	NONE,	NONE),
 	MFP_XWAY(GPIO49, GPIO,	EBU,	NONE,	NONE),
 	MFP_XWAY(GPIO50, GPIO,	NONE,	NONE,	NONE),

commit e15736975955639daa8a913a5f2076ba1cef58a4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Dec 21 16:28:11 2015 +0100

    pinctrl: xway: Be sure to clamp return value
    
    As we want gpio_chip .get() calls to be able to return negative
    error codes and propagate to drivers, we need to go over all
    drivers and make sure their return values are clamped to [0,1].
    We do this by using the ret = !!(val) design pattern.
    
    Cc: Pramod Gurav <pramod.gurav@smartplayin.com>
    Cc: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index e56222eac96c..ebd867f50700 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -660,7 +660,7 @@ static int xway_gpio_get(struct gpio_chip *chip, unsigned int pin)
 {
 	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
 
-	return gpio_getbit(info->membase[0], GPIO_IN(pin), PORT_PIN(pin));
+	return !!gpio_getbit(info->membase[0], GPIO_IN(pin), PORT_PIN(pin));
 }
 
 static int xway_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)

commit 3e640743fee6e6a82ead1f163737755b2a965712
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Dec 4 11:05:44 2015 +0100

    pinctrl: lantiq: Implement gpio_chip.to_irq
    
    Some drivers require a way to translate GPIO pins to their IRQ numbers.
    
    This patch adds the .to_irq() gpiolib callback to the pinctrl-xway
    driver, which returns an IRQ mapping for a given GPIO pin.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Martin Schiller <mschiller@tdt.de>
    [Switched ->dev to ->parent]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index b4380fb72001..e56222eac96c 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -682,6 +682,22 @@ static int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)
 	return 0;
 }
 
+/*
+ * gpiolib gpiod_to_irq callback function.
+ * Returns the mapped IRQ (external interrupt) number for a given GPIO pin.
+ */
+static int xway_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
+	int i;
+
+	for (i = 0; i < info->num_exin; i++)
+		if (info->exin[i] == offset)
+			return ltq_eiu_get_irq(i);
+
+	return -1;
+}
+
 static struct gpio_chip xway_chip = {
 	.label = "gpio-xway",
 	.direction_input = xway_gpio_dir_in,
@@ -690,6 +706,7 @@ static struct gpio_chip xway_chip = {
 	.set = xway_gpio_set,
 	.request = gpiochip_generic_request,
 	.free = gpiochip_generic_free,
+	.to_irq = xway_gpio_to_irq,
 	.base = -1,
 };
 

commit 57b588c950b7e04e0f22393ad439299ba4fda9c3
Author: John Crispin <blogic@openwrt.org>
Date:   Thu Nov 26 11:00:09 2015 +0100

    pinctrl/lantiq: Fix GPIO Setup of GPIO Port3
    
    Some special handling of GPIO Port 3 is needed because of
    some hardware thingofabob.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Martin Schiller <mschiller@tdt.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index a064962ece8b..b78baaa5ee4b 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -1563,6 +1563,10 @@ static int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)
 {
 	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
 
+	if (PORT(pin) == PORT3)
+		gpio_setbit(info->membase[0], GPIO3_OD, PORT_PIN(pin));
+	else
+		gpio_setbit(info->membase[0], GPIO_OD(pin), PORT_PIN(pin));
 	gpio_setbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));
 	xway_gpio_set(chip, pin, val);
 

commit be14811c03cf20c793fd176a347625335110b0e6
Author: Martin Schiller <mschiller@tdt.de>
Date:   Thu Nov 26 11:00:07 2015 +0100

    pinctrl/lantiq: introduce new dedicated devicetree bindings
    
    This patch introduces new dedicated "lantiq,<chip>-pinctrl" devicetree
    bindings, where <chip> is one of "ase", "danube", "xrx100", "xrx200" or
    "xrx300" and marks the "lantiq,pinctrl-xway", "lantiq,pinctrl-ase" and
    "lantiq,pinctrl-xr9" bindings as DEPRECATED.
    
    Based on the newest Lantiq Hardware Description it turend out, that there are
    some differences in the GPIO alternative functions of the Danube, xRX100 and
    xRX200 families, which makes it impossible to use only one xway_mfp table.
    
    This patch also adds support for the xRX300 family.
    
    Signed-off-by: Martin Schiller <mschiller@tdt.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index ae724bdab3d3..a064962ece8b 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -7,6 +7,7 @@
  *  publishhed by the Free Software Foundation.
  *
  *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2015 Martin Schiller <mschiller@tdt.de>
  */
 
 #include <linux/err.h>
@@ -24,7 +25,7 @@
 
 #include <lantiq_soc.h>
 
-/* we have 3 1/2 banks of 16 bit each */
+/* we have up to 4 banks of 16 bit each */
 #define PINS			16
 #define PORT3			3
 #define PORT(x)			(x / PINS)
@@ -35,7 +36,7 @@
 #define MUX_ALT1	0x2
 
 /*
- * each bank has this offset apart from the 1/2 bank that is mixed into the
+ * each bank has this offset apart from the 4th bank that is mixed into the
  * other 3 ranges
  */
 #define REG_OFF			0x30
@@ -51,7 +52,7 @@
 #define GPIO_PUDSEL(p)		(GPIO_BASE(p) + 0x1c)
 #define GPIO_PUDEN(p)		(GPIO_BASE(p) + 0x20)
 
-/* the 1/2 port needs special offsets for some registers */
+/* the 4th port needs special offsets for some registers */
 #define GPIO3_OD		(GPIO_BASE(0) + 0x24)
 #define GPIO3_PUDSEL		(GPIO_BASE(0) + 0x28)
 #define GPIO3_PUDEN		(GPIO_BASE(0) + 0x2C)
@@ -80,17 +81,18 @@
 #define FUNC_MUX(f, m)		\
 	{ .func = f, .mux = XWAY_MUX_##m, }
 
-#define XWAY_MAX_PIN		32
-#define XR9_MAX_PIN		56
-
 enum xway_mux {
 	XWAY_MUX_GPIO = 0,
 	XWAY_MUX_SPI,
 	XWAY_MUX_ASC,
+	XWAY_MUX_USIF,
 	XWAY_MUX_PCI,
+	XWAY_MUX_CBUS,
 	XWAY_MUX_CGU,
 	XWAY_MUX_EBU,
+	XWAY_MUX_EBU2,
 	XWAY_MUX_JTAG,
+	XWAY_MUX_MCD,
 	XWAY_MUX_EXIN,
 	XWAY_MUX_TDM,
 	XWAY_MUX_STP,
@@ -103,9 +105,15 @@ enum xway_mux {
 	XWAY_MUX_DFE,
 	XWAY_MUX_SDIO,
 	XWAY_MUX_GPHY,
+	XWAY_MUX_SSI,
+	XWAY_MUX_WIFI,
 	XWAY_MUX_NONE = 0xffff,
 };
 
+/* ---------  DEPRECATED: xr9 related code --------- */
+/* ----------  use xrx100/xrx200 instead  ---------- */
+#define XR9_MAX_PIN		56
+
 static const struct ltq_mfp_pin xway_mfp[] = {
 	/*       pin    f0	f1	f2	f3   */
 	MFP_XWAY(GPIO0, GPIO,	EXIN,	NONE,	TDM),
@@ -113,7 +121,7 @@ static const struct ltq_mfp_pin xway_mfp[] = {
 	MFP_XWAY(GPIO2, GPIO,	CGU,	EXIN,	GPHY),
 	MFP_XWAY(GPIO3, GPIO,	CGU,	NONE,	PCI),
 	MFP_XWAY(GPIO4, GPIO,	STP,	NONE,	ASC),
-	MFP_XWAY(GPIO5, GPIO,	STP,	NONE,	GPHY),
+	MFP_XWAY(GPIO5, GPIO,	STP,	GPHY,	NONE),
 	MFP_XWAY(GPIO6, GPIO,	STP,	GPT,	ASC),
 	MFP_XWAY(GPIO7, GPIO,	CGU,	PCI,	GPHY),
 	MFP_XWAY(GPIO8, GPIO,	CGU,	NMI,	NONE),
@@ -152,7 +160,7 @@ static const struct ltq_mfp_pin xway_mfp[] = {
 	MFP_XWAY(GPIO41, GPIO,	NONE,	NONE,	NONE),
 	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
 	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
-	MFP_XWAY(GPIO44, GPIO,	NONE,	GPHY,	SIN),
+	MFP_XWAY(GPIO44, GPIO,	NONE,	SIN,	GPHY),
 	MFP_XWAY(GPIO45, GPIO,	NONE,	GPHY,	SIN),
 	MFP_XWAY(GPIO46, GPIO,	NONE,	NONE,	EXIN),
 	MFP_XWAY(GPIO47, GPIO,	NONE,	GPHY,	SIN),
@@ -166,42 +174,6 @@ static const struct ltq_mfp_pin xway_mfp[] = {
 	MFP_XWAY(GPIO55, GPIO,	NONE,	NONE,	NONE),
 };
 
-static const struct ltq_mfp_pin ase_mfp[] = {
-	/*       pin    f0	f1	f2	f3   */
-	MFP_XWAY(GPIO0, GPIO,	EXIN,	MII,	TDM),
-	MFP_XWAY(GPIO1, GPIO,	STP,	DFE,	EBU),
-	MFP_XWAY(GPIO2, GPIO,	STP,	DFE,	EPHY),
-	MFP_XWAY(GPIO3, GPIO,	STP,	EPHY,	EBU),
-	MFP_XWAY(GPIO4, GPIO,	GPT,	EPHY,	MII),
-	MFP_XWAY(GPIO5, GPIO,	MII,	ASC,	GPT),
-	MFP_XWAY(GPIO6, GPIO,	MII,	ASC,	EXIN),
-	MFP_XWAY(GPIO7, GPIO,	SPI,	MII,	JTAG),
-	MFP_XWAY(GPIO8, GPIO,	SPI,	MII,	JTAG),
-	MFP_XWAY(GPIO9, GPIO,	SPI,	MII,	JTAG),
-	MFP_XWAY(GPIO10, GPIO,	SPI,	MII,	JTAG),
-	MFP_XWAY(GPIO11, GPIO,	EBU,	CGU,	JTAG),
-	MFP_XWAY(GPIO12, GPIO,	EBU,	MII,	SDIO),
-	MFP_XWAY(GPIO13, GPIO,	EBU,	MII,	CGU),
-	MFP_XWAY(GPIO14, GPIO,	EBU,	SPI,	CGU),
-	MFP_XWAY(GPIO15, GPIO,	EBU,	SPI,	SDIO),
-	MFP_XWAY(GPIO16, GPIO,	NONE,	NONE,	NONE),
-	MFP_XWAY(GPIO17, GPIO,	NONE,	NONE,	NONE),
-	MFP_XWAY(GPIO18, GPIO,	NONE,	NONE,	NONE),
-	MFP_XWAY(GPIO19, GPIO,	EBU,	MII,	SDIO),
-	MFP_XWAY(GPIO20, GPIO,	EBU,	MII,	SDIO),
-	MFP_XWAY(GPIO21, GPIO,	EBU,	MII,	SDIO),
-	MFP_XWAY(GPIO22, GPIO,	EBU,	MII,	CGU),
-	MFP_XWAY(GPIO23, GPIO,	EBU,	MII,	CGU),
-	MFP_XWAY(GPIO24, GPIO,	EBU,	NONE,	MII),
-	MFP_XWAY(GPIO25, GPIO,	EBU,	MII,	GPT),
-	MFP_XWAY(GPIO26, GPIO,	EBU,	MII,	SDIO),
-	MFP_XWAY(GPIO27, GPIO,	EBU,	NONE,	MII),
-	MFP_XWAY(GPIO28, GPIO,	MII,	EBU,	SDIO),
-	MFP_XWAY(GPIO29, GPIO,	EBU,	MII,	EXIN),
-	MFP_XWAY(GPIO30, GPIO,	NONE,	NONE,	NONE),
-	MFP_XWAY(GPIO31, GPIO,	NONE,	NONE,	NONE),
-};
-
 static const unsigned pins_jtag[] = {GPIO15, GPIO16, GPIO17, GPIO19, GPIO35};
 static const unsigned pins_asc0[] = {GPIO11, GPIO12};
 static const unsigned pins_asc0_cts_rts[] = {GPIO9, GPIO10};
@@ -231,6 +203,8 @@ static const unsigned pins_nand_cle[] = {GPIO24};
 static const unsigned pins_nand_rdy[] = {GPIO48};
 static const unsigned pins_nand_rd[] = {GPIO49};
 
+static const unsigned xway_exin_pin_map[] = {GPIO0, GPIO1, GPIO2, GPIO39, GPIO46, GPIO9};
+
 static const unsigned pins_exin0[] = {GPIO0};
 static const unsigned pins_exin1[] = {GPIO1};
 static const unsigned pins_exin2[] = {GPIO2};
@@ -240,7 +214,7 @@ static const unsigned pins_exin5[] = {GPIO9};
 
 static const unsigned pins_spi[] = {GPIO16, GPIO17, GPIO18};
 static const unsigned pins_spi_cs1[] = {GPIO15};
-static const unsigned pins_spi_cs2[] = {GPIO21};
+static const unsigned pins_spi_cs2[] = {GPIO22};
 static const unsigned pins_spi_cs3[] = {GPIO13};
 static const unsigned pins_spi_cs4[] = {GPIO10};
 static const unsigned pins_spi_cs5[] = {GPIO9};
@@ -264,25 +238,6 @@ static const unsigned pins_pci_req2[] = {GPIO31};
 static const unsigned pins_pci_req3[] = {GPIO3};
 static const unsigned pins_pci_req4[] = {GPIO37};
 
-static const unsigned ase_pins_jtag[] = {GPIO7, GPIO8, GPIO9, GPIO10, GPIO11};
-static const unsigned ase_pins_asc[] = {GPIO5, GPIO6};
-static const unsigned ase_pins_stp[] = {GPIO1, GPIO2, GPIO3};
-static const unsigned ase_pins_ephy[] = {GPIO2, GPIO3, GPIO4};
-static const unsigned ase_pins_dfe[] = {GPIO1, GPIO2};
-
-static const unsigned ase_pins_spi[] = {GPIO8, GPIO9, GPIO10};
-static const unsigned ase_pins_spi_cs1[] = {GPIO7};
-static const unsigned ase_pins_spi_cs2[] = {GPIO15};
-static const unsigned ase_pins_spi_cs3[] = {GPIO14};
-
-static const unsigned ase_pins_exin0[] = {GPIO6};
-static const unsigned ase_pins_exin1[] = {GPIO29};
-static const unsigned ase_pins_exin2[] = {GPIO0};
-
-static const unsigned ase_pins_gpt1[] = {GPIO5};
-static const unsigned ase_pins_gpt2[] = {GPIO4};
-static const unsigned ase_pins_gpt3[] = {GPIO25};
-
 static const struct ltq_pin_group xway_grps[] = {
 	GRP_MUX("exin0", EXIN, pins_exin0),
 	GRP_MUX("exin1", EXIN, pins_exin1),
@@ -338,24 +293,6 @@ static const struct ltq_pin_group xway_grps[] = {
 	GRP_MUX("gphy1 led2", GPHY, pins_gphy1_led2),
 };
 
-static const struct ltq_pin_group ase_grps[] = {
-	GRP_MUX("exin0", EXIN, ase_pins_exin0),
-	GRP_MUX("exin1", EXIN, ase_pins_exin1),
-	GRP_MUX("exin2", EXIN, ase_pins_exin2),
-	GRP_MUX("jtag", JTAG, ase_pins_jtag),
-	GRP_MUX("stp", STP, ase_pins_stp),
-	GRP_MUX("asc", ASC, ase_pins_asc),
-	GRP_MUX("gpt1", GPT, ase_pins_gpt1),
-	GRP_MUX("gpt2", GPT, ase_pins_gpt2),
-	GRP_MUX("gpt3", GPT, ase_pins_gpt3),
-	GRP_MUX("ephy", EPHY, ase_pins_ephy),
-	GRP_MUX("dfe", DFE, ase_pins_dfe),
-	GRP_MUX("spi", SPI, ase_pins_spi),
-	GRP_MUX("spi_cs1", SPI, ase_pins_spi_cs1),
-	GRP_MUX("spi_cs2", SPI, ase_pins_spi_cs2),
-	GRP_MUX("spi_cs3", SPI, ase_pins_spi_cs3),
-};
-
 static const char * const xway_pci_grps[] = {"gnt1", "gnt2",
 						"gnt3", "req1",
 						"req2", "req3"};
@@ -395,30 +332,6 @@ static const char * const xrx_pci_grps[] = {"gnt1", "gnt2",
 						"req1", "req2",
 						"req3", "req4"};
 
-/* ase */
-static const char * const ase_exin_grps[] = {"exin0", "exin1", "exin2"};
-static const char * const ase_gpt_grps[] = {"gpt1", "gpt2", "gpt3"};
-static const char * const ase_dfe_grps[] = {"dfe"};
-static const char * const ase_ephy_grps[] = {"ephy"};
-static const char * const ase_asc_grps[] = {"asc"};
-static const char * const ase_jtag_grps[] = {"jtag"};
-static const char * const ase_stp_grps[] = {"stp"};
-static const char * const ase_spi_grps[] = {"spi", "spi_cs1",
-						"spi_cs2", "spi_cs3"};
-
-static const struct ltq_pmx_func danube_funcs[] = {
-	{"spi",		ARRAY_AND_SIZE(xway_spi_grps)},
-	{"asc",		ARRAY_AND_SIZE(xway_asc_grps)},
-	{"cgu",		ARRAY_AND_SIZE(xway_cgu_grps)},
-	{"jtag",	ARRAY_AND_SIZE(xway_jtag_grps)},
-	{"exin",	ARRAY_AND_SIZE(xway_exin_grps)},
-	{"stp",		ARRAY_AND_SIZE(xway_stp_grps)},
-	{"gpt",		ARRAY_AND_SIZE(xway_gpt_grps)},
-	{"nmi",		ARRAY_AND_SIZE(xway_nmi_grps)},
-	{"pci",		ARRAY_AND_SIZE(xway_pci_grps)},
-	{"ebu",		ARRAY_AND_SIZE(xway_ebu_grps)},
-};
-
 static const struct ltq_pmx_func xrx_funcs[] = {
 	{"spi",		ARRAY_AND_SIZE(xway_spi_grps)},
 	{"asc",		ARRAY_AND_SIZE(xway_asc_grps)},
@@ -434,17 +347,991 @@ static const struct ltq_pmx_func xrx_funcs[] = {
 	{"gphy",	ARRAY_AND_SIZE(xrx_gphy_grps)},
 };
 
+/* ---------  ase related code --------- */
+#define ASE_MAX_PIN		32
+
+static const struct ltq_mfp_pin ase_mfp[] = {
+	/*       pin    f0	f1	f2	f3   */
+	MFP_XWAY(GPIO0, GPIO,	EXIN,	MII,	TDM),
+	MFP_XWAY(GPIO1, GPIO,	STP,	DFE,	EBU),
+	MFP_XWAY(GPIO2, GPIO,	STP,	DFE,	EPHY),
+	MFP_XWAY(GPIO3, GPIO,	STP,	EPHY,	EBU),
+	MFP_XWAY(GPIO4, GPIO,	GPT,	EPHY,	MII),
+	MFP_XWAY(GPIO5, GPIO,	MII,	ASC,	GPT),
+	MFP_XWAY(GPIO6, GPIO,	MII,	ASC,	EXIN),
+	MFP_XWAY(GPIO7, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO8, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO9, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO10, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO11, GPIO,	EBU,	CGU,	JTAG),
+	MFP_XWAY(GPIO12, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO13, GPIO,	EBU,	MII,	CGU),
+	MFP_XWAY(GPIO14, GPIO,	EBU,	SPI,	CGU),
+	MFP_XWAY(GPIO15, GPIO,	EBU,	SPI,	SDIO),
+	MFP_XWAY(GPIO16, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO17, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO18, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO19, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO20, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO21, GPIO,	EBU,	MII,	EBU2),
+	MFP_XWAY(GPIO22, GPIO,	EBU,	MII,	CGU),
+	MFP_XWAY(GPIO23, GPIO,	EBU,	MII,	CGU),
+	MFP_XWAY(GPIO24, GPIO,	EBU,	EBU2,	MDIO),
+	MFP_XWAY(GPIO25, GPIO,	EBU,	MII,	GPT),
+	MFP_XWAY(GPIO26, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO27, GPIO,	EBU,	NONE,	MDIO),
+	MFP_XWAY(GPIO28, GPIO,	MII,	EBU,	SDIO),
+	MFP_XWAY(GPIO29, GPIO,	EBU,	MII,	EXIN),
+	MFP_XWAY(GPIO30, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO31, GPIO,	NONE,	NONE,	NONE),
+};
+
+static const unsigned ase_exin_pin_map[] = {GPIO6, GPIO29, GPIO0};
+
+static const unsigned ase_pins_exin0[] = {GPIO6};
+static const unsigned ase_pins_exin1[] = {GPIO29};
+static const unsigned ase_pins_exin2[] = {GPIO0};
+
+static const unsigned ase_pins_jtag[] = {GPIO7, GPIO8, GPIO9, GPIO10, GPIO11};
+static const unsigned ase_pins_asc[] = {GPIO5, GPIO6};
+static const unsigned ase_pins_stp[] = {GPIO1, GPIO2, GPIO3};
+static const unsigned ase_pins_mdio[] = {GPIO24, GPIO27};
+static const unsigned ase_pins_ephy_led0[] = {GPIO2};
+static const unsigned ase_pins_ephy_led1[] = {GPIO3};
+static const unsigned ase_pins_ephy_led2[] = {GPIO4};
+static const unsigned ase_pins_dfe_led0[] = {GPIO1};
+static const unsigned ase_pins_dfe_led1[] = {GPIO2};
+
+static const unsigned ase_pins_spi[] = {GPIO8, GPIO9, GPIO10}; /* DEPRECATED */
+static const unsigned ase_pins_spi_di[] = {GPIO8};
+static const unsigned ase_pins_spi_do[] = {GPIO9};
+static const unsigned ase_pins_spi_clk[] = {GPIO10};
+static const unsigned ase_pins_spi_cs1[] = {GPIO7};
+static const unsigned ase_pins_spi_cs2[] = {GPIO15};
+static const unsigned ase_pins_spi_cs3[] = {GPIO14};
+
+static const unsigned ase_pins_gpt1[] = {GPIO5};
+static const unsigned ase_pins_gpt2[] = {GPIO4};
+static const unsigned ase_pins_gpt3[] = {GPIO25};
+
+static const unsigned ase_pins_clkout0[] = {GPIO23};
+static const unsigned ase_pins_clkout1[] = {GPIO22};
+static const unsigned ase_pins_clkout2[] = {GPIO14};
+
+static const struct ltq_pin_group ase_grps[] = {
+	GRP_MUX("exin0", EXIN, ase_pins_exin0),
+	GRP_MUX("exin1", EXIN, ase_pins_exin1),
+	GRP_MUX("exin2", EXIN, ase_pins_exin2),
+	GRP_MUX("jtag", JTAG, ase_pins_jtag),
+	GRP_MUX("spi", SPI, ase_pins_spi), /* DEPRECATED */
+	GRP_MUX("spi_di", SPI, ase_pins_spi_di),
+	GRP_MUX("spi_do", SPI, ase_pins_spi_do),
+	GRP_MUX("spi_clk", SPI, ase_pins_spi_clk),
+	GRP_MUX("spi_cs1", SPI, ase_pins_spi_cs1),
+	GRP_MUX("spi_cs2", SPI, ase_pins_spi_cs2),
+	GRP_MUX("spi_cs3", SPI, ase_pins_spi_cs3),
+	GRP_MUX("asc", ASC, ase_pins_asc),
+	GRP_MUX("stp", STP, ase_pins_stp),
+	GRP_MUX("gpt1", GPT, ase_pins_gpt1),
+	GRP_MUX("gpt2", GPT, ase_pins_gpt2),
+	GRP_MUX("gpt3", GPT, ase_pins_gpt3),
+	GRP_MUX("clkout0", CGU, ase_pins_clkout0),
+	GRP_MUX("clkout1", CGU, ase_pins_clkout1),
+	GRP_MUX("clkout2", CGU, ase_pins_clkout2),
+	GRP_MUX("mdio", MDIO, ase_pins_mdio),
+	GRP_MUX("dfe led0", DFE, ase_pins_dfe_led0),
+	GRP_MUX("dfe led1", DFE, ase_pins_dfe_led1),
+	GRP_MUX("ephy led0", EPHY, ase_pins_ephy_led0),
+	GRP_MUX("ephy led1", EPHY, ase_pins_ephy_led1),
+	GRP_MUX("ephy led2", EPHY, ase_pins_ephy_led2),
+};
+
+static const char * const ase_exin_grps[] = {"exin0", "exin1", "exin2"};
+static const char * const ase_gpt_grps[] = {"gpt1", "gpt2", "gpt3"};
+static const char * const ase_cgu_grps[] = {"clkout0", "clkout1",
+						"clkout2"};
+static const char * const ase_mdio_grps[] = {"mdio"};
+static const char * const ase_dfe_grps[] = {"dfe led0", "dfe led1"};
+static const char * const ase_ephy_grps[] = {"ephy led0", "ephy led1",
+						"ephy led2"};
+static const char * const ase_asc_grps[] = {"asc"};
+static const char * const ase_jtag_grps[] = {"jtag"};
+static const char * const ase_stp_grps[] = {"stp"};
+static const char * const ase_spi_grps[] = {"spi",  /* DEPRECATED */
+						"spi_di", "spi_do",
+						"spi_clk", "spi_cs1",
+						"spi_cs2", "spi_cs3"};
+
 static const struct ltq_pmx_func ase_funcs[] = {
 	{"spi",		ARRAY_AND_SIZE(ase_spi_grps)},
 	{"asc",		ARRAY_AND_SIZE(ase_asc_grps)},
+	{"cgu",		ARRAY_AND_SIZE(ase_cgu_grps)},
 	{"jtag",	ARRAY_AND_SIZE(ase_jtag_grps)},
 	{"exin",	ARRAY_AND_SIZE(ase_exin_grps)},
 	{"stp",		ARRAY_AND_SIZE(ase_stp_grps)},
 	{"gpt",		ARRAY_AND_SIZE(ase_gpt_grps)},
+	{"mdio",	ARRAY_AND_SIZE(ase_mdio_grps)},
 	{"ephy",	ARRAY_AND_SIZE(ase_ephy_grps)},
 	{"dfe",		ARRAY_AND_SIZE(ase_dfe_grps)},
 };
 
+/* ---------  danube related code --------- */
+#define DANUBE_MAX_PIN		32
+
+static const struct ltq_mfp_pin danube_mfp[] = {
+	/*       pin    f0	f1	f2	f3   */
+	MFP_XWAY(GPIO0, GPIO,	EXIN,	SDIO,	TDM),
+	MFP_XWAY(GPIO1, GPIO,	EXIN,	CBUS,	MII),
+	MFP_XWAY(GPIO2, GPIO,	CGU,	EXIN,	MII),
+	MFP_XWAY(GPIO3, GPIO,	CGU,	SDIO,	PCI),
+	MFP_XWAY(GPIO4, GPIO,	STP,	DFE,	ASC),
+	MFP_XWAY(GPIO5, GPIO,	STP,	MII,	DFE),
+	MFP_XWAY(GPIO6, GPIO,	STP,	GPT,	ASC),
+	MFP_XWAY(GPIO7, GPIO,	CGU,	CBUS,	MII),
+	MFP_XWAY(GPIO8, GPIO,	CGU,	NMI,	MII),
+	MFP_XWAY(GPIO9, GPIO,	ASC,	SPI,	MII),
+	MFP_XWAY(GPIO10, GPIO,	ASC,	SPI,	MII),
+	MFP_XWAY(GPIO11, GPIO,	ASC,	CBUS,	SPI),
+	MFP_XWAY(GPIO12, GPIO,	ASC,	CBUS,	MCD),
+	MFP_XWAY(GPIO13, GPIO,	EBU,	SPI,	MII),
+	MFP_XWAY(GPIO14, GPIO,	CGU,	CBUS,	MII),
+	MFP_XWAY(GPIO15, GPIO,	SPI,	SDIO,	JTAG),
+	MFP_XWAY(GPIO16, GPIO,	SPI,	SDIO,	JTAG),
+	MFP_XWAY(GPIO17, GPIO,	SPI,	SDIO,	JTAG),
+	MFP_XWAY(GPIO18, GPIO,	SPI,	SDIO,	JTAG),
+	MFP_XWAY(GPIO19, GPIO,	PCI,	SDIO,	MII),
+	MFP_XWAY(GPIO20, GPIO,	JTAG,	SDIO,	MII),
+	MFP_XWAY(GPIO21, GPIO,	PCI,	EBU,	GPT),
+	MFP_XWAY(GPIO22, GPIO,	SPI,	MCD,	MII),
+	MFP_XWAY(GPIO23, GPIO,	EBU,	PCI,	STP),
+	MFP_XWAY(GPIO24, GPIO,	EBU,	TDM,	PCI),
+	MFP_XWAY(GPIO25, GPIO,	TDM,	SDIO,	ASC),
+	MFP_XWAY(GPIO26, GPIO,	EBU,	TDM,	SDIO),
+	MFP_XWAY(GPIO27, GPIO,	TDM,	SDIO,	ASC),
+	MFP_XWAY(GPIO28, GPIO,	GPT,	MII,	SDIO),
+	MFP_XWAY(GPIO29, GPIO,	PCI,	CBUS,	MII),
+	MFP_XWAY(GPIO30, GPIO,	PCI,	CBUS,	MII),
+	MFP_XWAY(GPIO31, GPIO,	EBU,	PCI,	MII),
+};
+
+static const unsigned danube_exin_pin_map[] = {GPIO0, GPIO1, GPIO2};
+
+static const unsigned danube_pins_exin0[] = {GPIO0};
+static const unsigned danube_pins_exin1[] = {GPIO1};
+static const unsigned danube_pins_exin2[] = {GPIO2};
+
+static const unsigned danube_pins_jtag[] = {GPIO15, GPIO16, GPIO17, GPIO18, GPIO20};
+static const unsigned danube_pins_asc0[] = {GPIO11, GPIO12};
+static const unsigned danube_pins_asc0_cts_rts[] = {GPIO9, GPIO10};
+static const unsigned danube_pins_stp[] = {GPIO4, GPIO5, GPIO6};
+static const unsigned danube_pins_nmi[] = {GPIO8};
+
+static const unsigned danube_pins_dfe_led0[] = {GPIO4};
+static const unsigned danube_pins_dfe_led1[] = {GPIO5};
+
+static const unsigned danube_pins_ebu_a24[] = {GPIO13};
+static const unsigned danube_pins_ebu_clk[] = {GPIO21};
+static const unsigned danube_pins_ebu_cs1[] = {GPIO23};
+static const unsigned danube_pins_ebu_a23[] = {GPIO24};
+static const unsigned danube_pins_ebu_wait[] = {GPIO26};
+static const unsigned danube_pins_ebu_a25[] = {GPIO31};
+
+static const unsigned danube_pins_nand_ale[] = {GPIO13};
+static const unsigned danube_pins_nand_cs1[] = {GPIO23};
+static const unsigned danube_pins_nand_cle[] = {GPIO24};
+
+static const unsigned danube_pins_spi[] = {GPIO16, GPIO17, GPIO18}; /* DEPRECATED */
+static const unsigned danube_pins_spi_di[] = {GPIO16};
+static const unsigned danube_pins_spi_do[] = {GPIO17};
+static const unsigned danube_pins_spi_clk[] = {GPIO18};
+static const unsigned danube_pins_spi_cs1[] = {GPIO15};
+static const unsigned danube_pins_spi_cs2[] = {GPIO21};
+static const unsigned danube_pins_spi_cs3[] = {GPIO13};
+static const unsigned danube_pins_spi_cs4[] = {GPIO10};
+static const unsigned danube_pins_spi_cs5[] = {GPIO9};
+static const unsigned danube_pins_spi_cs6[] = {GPIO11};
+
+static const unsigned danube_pins_gpt1[] = {GPIO28};
+static const unsigned danube_pins_gpt2[] = {GPIO21};
+static const unsigned danube_pins_gpt3[] = {GPIO6};
+
+static const unsigned danube_pins_clkout0[] = {GPIO8};
+static const unsigned danube_pins_clkout1[] = {GPIO7};
+static const unsigned danube_pins_clkout2[] = {GPIO3};
+static const unsigned danube_pins_clkout3[] = {GPIO2};
+
+static const unsigned danube_pins_pci_gnt1[] = {GPIO30};
+static const unsigned danube_pins_pci_gnt2[] = {GPIO23};
+static const unsigned danube_pins_pci_gnt3[] = {GPIO19};
+static const unsigned danube_pins_pci_req1[] = {GPIO29};
+static const unsigned danube_pins_pci_req2[] = {GPIO31};
+static const unsigned danube_pins_pci_req3[] = {GPIO3};
+
+static const struct ltq_pin_group danube_grps[] = {
+	GRP_MUX("exin0", EXIN, danube_pins_exin0),
+	GRP_MUX("exin1", EXIN, danube_pins_exin1),
+	GRP_MUX("exin2", EXIN, danube_pins_exin2),
+	GRP_MUX("jtag", JTAG, danube_pins_jtag),
+	GRP_MUX("ebu a23", EBU, danube_pins_ebu_a23),
+	GRP_MUX("ebu a24", EBU, danube_pins_ebu_a24),
+	GRP_MUX("ebu a25", EBU, danube_pins_ebu_a25),
+	GRP_MUX("ebu clk", EBU, danube_pins_ebu_clk),
+	GRP_MUX("ebu cs1", EBU, danube_pins_ebu_cs1),
+	GRP_MUX("ebu wait", EBU, danube_pins_ebu_wait),
+	GRP_MUX("nand ale", EBU, danube_pins_nand_ale),
+	GRP_MUX("nand cs1", EBU, danube_pins_nand_cs1),
+	GRP_MUX("nand cle", EBU, danube_pins_nand_cle),
+	GRP_MUX("spi", SPI, danube_pins_spi), /* DEPRECATED */
+	GRP_MUX("spi_di", SPI, danube_pins_spi_di),
+	GRP_MUX("spi_do", SPI, danube_pins_spi_do),
+	GRP_MUX("spi_clk", SPI, danube_pins_spi_clk),
+	GRP_MUX("spi_cs1", SPI, danube_pins_spi_cs1),
+	GRP_MUX("spi_cs2", SPI, danube_pins_spi_cs2),
+	GRP_MUX("spi_cs3", SPI, danube_pins_spi_cs3),
+	GRP_MUX("spi_cs4", SPI, danube_pins_spi_cs4),
+	GRP_MUX("spi_cs5", SPI, danube_pins_spi_cs5),
+	GRP_MUX("spi_cs6", SPI, danube_pins_spi_cs6),
+	GRP_MUX("asc0", ASC, danube_pins_asc0),
+	GRP_MUX("asc0 cts rts", ASC, danube_pins_asc0_cts_rts),
+	GRP_MUX("stp", STP, danube_pins_stp),
+	GRP_MUX("nmi", NMI, danube_pins_nmi),
+	GRP_MUX("gpt1", GPT, danube_pins_gpt1),
+	GRP_MUX("gpt2", GPT, danube_pins_gpt2),
+	GRP_MUX("gpt3", GPT, danube_pins_gpt3),
+	GRP_MUX("clkout0", CGU, danube_pins_clkout0),
+	GRP_MUX("clkout1", CGU, danube_pins_clkout1),
+	GRP_MUX("clkout2", CGU, danube_pins_clkout2),
+	GRP_MUX("clkout3", CGU, danube_pins_clkout3),
+	GRP_MUX("gnt1", PCI, danube_pins_pci_gnt1),
+	GRP_MUX("gnt2", PCI, danube_pins_pci_gnt2),
+	GRP_MUX("gnt3", PCI, danube_pins_pci_gnt3),
+	GRP_MUX("req1", PCI, danube_pins_pci_req1),
+	GRP_MUX("req2", PCI, danube_pins_pci_req2),
+	GRP_MUX("req3", PCI, danube_pins_pci_req3),
+	GRP_MUX("dfe led0", DFE, danube_pins_dfe_led0),
+	GRP_MUX("dfe led1", DFE, danube_pins_dfe_led1),
+};
+
+static const char * const danube_pci_grps[] = {"gnt1", "gnt2",
+						"gnt3", "req1",
+						"req2", "req3"};
+static const char * const danube_spi_grps[] = {"spi", /* DEPRECATED */
+						"spi_di", "spi_do",
+						"spi_clk", "spi_cs1",
+						"spi_cs2", "spi_cs3",
+						"spi_cs4", "spi_cs5",
+						"spi_cs6"};
+static const char * const danube_cgu_grps[] = {"clkout0", "clkout1",
+						"clkout2", "clkout3"};
+static const char * const danube_ebu_grps[] = {"ebu a23", "ebu a24",
+						"ebu a25", "ebu cs1",
+						"ebu wait", "ebu clk",
+						"nand ale", "nand cs1",
+						"nand cle"};
+static const char * const danube_dfe_grps[] = {"dfe led0", "dfe led1"};
+static const char * const danube_exin_grps[] = {"exin0", "exin1", "exin2"};
+static const char * const danube_gpt_grps[] = {"gpt1", "gpt2", "gpt3"};
+static const char * const danube_asc_grps[] = {"asc0", "asc0 cts rts"};
+static const char * const danube_jtag_grps[] = {"jtag"};
+static const char * const danube_stp_grps[] = {"stp"};
+static const char * const danube_nmi_grps[] = {"nmi"};
+
+static const struct ltq_pmx_func danube_funcs[] = {
+	{"spi",		ARRAY_AND_SIZE(danube_spi_grps)},
+	{"asc",		ARRAY_AND_SIZE(danube_asc_grps)},
+	{"cgu",		ARRAY_AND_SIZE(danube_cgu_grps)},
+	{"jtag",	ARRAY_AND_SIZE(danube_jtag_grps)},
+	{"exin",	ARRAY_AND_SIZE(danube_exin_grps)},
+	{"stp",		ARRAY_AND_SIZE(danube_stp_grps)},
+	{"gpt",		ARRAY_AND_SIZE(danube_gpt_grps)},
+	{"nmi",		ARRAY_AND_SIZE(danube_nmi_grps)},
+	{"pci",		ARRAY_AND_SIZE(danube_pci_grps)},
+	{"ebu",		ARRAY_AND_SIZE(danube_ebu_grps)},
+	{"dfe",		ARRAY_AND_SIZE(danube_dfe_grps)},
+};
+
+/* ---------  xrx100 related code --------- */
+#define XRX100_MAX_PIN		56
+
+static const struct ltq_mfp_pin xrx100_mfp[] = {
+	/*       pin    f0	f1	f2	f3   */
+	MFP_XWAY(GPIO0, GPIO,	EXIN,	SDIO,	TDM),
+	MFP_XWAY(GPIO1, GPIO,	EXIN,	CBUS,	SIN),
+	MFP_XWAY(GPIO2, GPIO,	CGU,	EXIN,	NONE),
+	MFP_XWAY(GPIO3, GPIO,	CGU,	SDIO,	PCI),
+	MFP_XWAY(GPIO4, GPIO,	STP,	DFE,	ASC),
+	MFP_XWAY(GPIO5, GPIO,	STP,	NONE,	DFE),
+	MFP_XWAY(GPIO6, GPIO,	STP,	GPT,	ASC),
+	MFP_XWAY(GPIO7, GPIO,	CGU,	CBUS,	NONE),
+	MFP_XWAY(GPIO8, GPIO,	CGU,	NMI,	NONE),
+	MFP_XWAY(GPIO9, GPIO,	ASC,	SPI,	EXIN),
+	MFP_XWAY(GPIO10, GPIO,	ASC,	SPI,	EXIN),
+	MFP_XWAY(GPIO11, GPIO,	ASC,	CBUS,	SPI),
+	MFP_XWAY(GPIO12, GPIO,	ASC,	CBUS,	MCD),
+	MFP_XWAY(GPIO13, GPIO,	EBU,	SPI,	NONE),
+	MFP_XWAY(GPIO14, GPIO,	CGU,	NONE,	NONE),
+	MFP_XWAY(GPIO15, GPIO,	SPI,	SDIO,	MCD),
+	MFP_XWAY(GPIO16, GPIO,	SPI,	SDIO,	NONE),
+	MFP_XWAY(GPIO17, GPIO,	SPI,	SDIO,	NONE),
+	MFP_XWAY(GPIO18, GPIO,	SPI,	SDIO,	NONE),
+	MFP_XWAY(GPIO19, GPIO,	PCI,	SDIO,	CGU),
+	MFP_XWAY(GPIO20, GPIO,	NONE,	SDIO,	EBU),
+	MFP_XWAY(GPIO21, GPIO,	PCI,	EBU,	GPT),
+	MFP_XWAY(GPIO22, GPIO,	SPI,	NONE,	EBU),
+	MFP_XWAY(GPIO23, GPIO,	EBU,	PCI,	STP),
+	MFP_XWAY(GPIO24, GPIO,	EBU,	TDM,	PCI),
+	MFP_XWAY(GPIO25, GPIO,	TDM,	SDIO,	ASC),
+	MFP_XWAY(GPIO26, GPIO,	EBU,	TDM,	SDIO),
+	MFP_XWAY(GPIO27, GPIO,	TDM,	SDIO,	ASC),
+	MFP_XWAY(GPIO28, GPIO,	GPT,	NONE,	SDIO),
+	MFP_XWAY(GPIO29, GPIO,	PCI,	CBUS,	NONE),
+	MFP_XWAY(GPIO30, GPIO,	PCI,	CBUS,	NONE),
+	MFP_XWAY(GPIO31, GPIO,	EBU,	PCI,	NONE),
+	MFP_XWAY(GPIO32, GPIO,	MII,	NONE,	EBU),
+	MFP_XWAY(GPIO33, GPIO,	MII,	NONE,	EBU),
+	MFP_XWAY(GPIO34, GPIO,	SIN,	SSI,	NONE),
+	MFP_XWAY(GPIO35, GPIO,	SIN,	SSI,	NONE),
+	MFP_XWAY(GPIO36, GPIO,	SIN,	SSI,	NONE),
+	MFP_XWAY(GPIO37, GPIO,	PCI,	NONE,	NONE),
+	MFP_XWAY(GPIO38, GPIO,	PCI,	NONE,	NONE),
+	MFP_XWAY(GPIO39, GPIO,	NONE,	EXIN,	NONE),
+	MFP_XWAY(GPIO40, GPIO,	MII,	TDM,	NONE),
+	MFP_XWAY(GPIO41, GPIO,	MII,	TDM,	NONE),
+	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO44, GPIO,	MII,	SIN,	NONE),
+	MFP_XWAY(GPIO45, GPIO,	MII,	NONE,	SIN),
+	MFP_XWAY(GPIO46, GPIO,	MII,	NONE,	EXIN),
+	MFP_XWAY(GPIO47, GPIO,	MII,	NONE,	SIN),
+	MFP_XWAY(GPIO48, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO49, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO50, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO51, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO52, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO53, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO54, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO55, GPIO,	NONE,	NONE,	NONE),
+};
+
+static const unsigned xrx100_exin_pin_map[] = {GPIO0, GPIO1, GPIO2, GPIO39, GPIO10, GPIO9};
+
+static const unsigned xrx100_pins_exin0[] = {GPIO0};
+static const unsigned xrx100_pins_exin1[] = {GPIO1};
+static const unsigned xrx100_pins_exin2[] = {GPIO2};
+static const unsigned xrx100_pins_exin3[] = {GPIO39};
+static const unsigned xrx100_pins_exin4[] = {GPIO10};
+static const unsigned xrx100_pins_exin5[] = {GPIO9};
+
+static const unsigned xrx100_pins_asc0[] = {GPIO11, GPIO12};
+static const unsigned xrx100_pins_asc0_cts_rts[] = {GPIO9, GPIO10};
+static const unsigned xrx100_pins_stp[] = {GPIO4, GPIO5, GPIO6};
+static const unsigned xrx100_pins_nmi[] = {GPIO8};
+static const unsigned xrx100_pins_mdio[] = {GPIO42, GPIO43};
+
+static const unsigned xrx100_pins_dfe_led0[] = {GPIO4};
+static const unsigned xrx100_pins_dfe_led1[] = {GPIO5};
+
+static const unsigned xrx100_pins_ebu_a24[] = {GPIO13};
+static const unsigned xrx100_pins_ebu_clk[] = {GPIO21};
+static const unsigned xrx100_pins_ebu_cs1[] = {GPIO23};
+static const unsigned xrx100_pins_ebu_a23[] = {GPIO24};
+static const unsigned xrx100_pins_ebu_wait[] = {GPIO26};
+static const unsigned xrx100_pins_ebu_a25[] = {GPIO31};
+
+static const unsigned xrx100_pins_nand_ale[] = {GPIO13};
+static const unsigned xrx100_pins_nand_cs1[] = {GPIO23};
+static const unsigned xrx100_pins_nand_cle[] = {GPIO24};
+static const unsigned xrx100_pins_nand_rdy[] = {GPIO48};
+static const unsigned xrx100_pins_nand_rd[] = {GPIO49};
+
+static const unsigned xrx100_pins_spi_di[] = {GPIO16};
+static const unsigned xrx100_pins_spi_do[] = {GPIO17};
+static const unsigned xrx100_pins_spi_clk[] = {GPIO18};
+static const unsigned xrx100_pins_spi_cs1[] = {GPIO15};
+static const unsigned xrx100_pins_spi_cs2[] = {GPIO22};
+static const unsigned xrx100_pins_spi_cs3[] = {GPIO13};
+static const unsigned xrx100_pins_spi_cs4[] = {GPIO10};
+static const unsigned xrx100_pins_spi_cs5[] = {GPIO9};
+static const unsigned xrx100_pins_spi_cs6[] = {GPIO11};
+
+static const unsigned xrx100_pins_gpt1[] = {GPIO28};
+static const unsigned xrx100_pins_gpt2[] = {GPIO21};
+static const unsigned xrx100_pins_gpt3[] = {GPIO6};
+
+static const unsigned xrx100_pins_clkout0[] = {GPIO8};
+static const unsigned xrx100_pins_clkout1[] = {GPIO7};
+static const unsigned xrx100_pins_clkout2[] = {GPIO3};
+static const unsigned xrx100_pins_clkout3[] = {GPIO2};
+
+static const unsigned xrx100_pins_pci_gnt1[] = {GPIO30};
+static const unsigned xrx100_pins_pci_gnt2[] = {GPIO23};
+static const unsigned xrx100_pins_pci_gnt3[] = {GPIO19};
+static const unsigned xrx100_pins_pci_gnt4[] = {GPIO38};
+static const unsigned xrx100_pins_pci_req1[] = {GPIO29};
+static const unsigned xrx100_pins_pci_req2[] = {GPIO31};
+static const unsigned xrx100_pins_pci_req3[] = {GPIO3};
+static const unsigned xrx100_pins_pci_req4[] = {GPIO37};
+
+static const struct ltq_pin_group xrx100_grps[] = {
+	GRP_MUX("exin0", EXIN, xrx100_pins_exin0),
+	GRP_MUX("exin1", EXIN, xrx100_pins_exin1),
+	GRP_MUX("exin2", EXIN, xrx100_pins_exin2),
+	GRP_MUX("exin3", EXIN, xrx100_pins_exin3),
+	GRP_MUX("exin4", EXIN, xrx100_pins_exin4),
+	GRP_MUX("exin5", EXIN, xrx100_pins_exin5),
+	GRP_MUX("ebu a23", EBU, xrx100_pins_ebu_a23),
+	GRP_MUX("ebu a24", EBU, xrx100_pins_ebu_a24),
+	GRP_MUX("ebu a25", EBU, xrx100_pins_ebu_a25),
+	GRP_MUX("ebu clk", EBU, xrx100_pins_ebu_clk),
+	GRP_MUX("ebu cs1", EBU, xrx100_pins_ebu_cs1),
+	GRP_MUX("ebu wait", EBU, xrx100_pins_ebu_wait),
+	GRP_MUX("nand ale", EBU, xrx100_pins_nand_ale),
+	GRP_MUX("nand cs1", EBU, xrx100_pins_nand_cs1),
+	GRP_MUX("nand cle", EBU, xrx100_pins_nand_cle),
+	GRP_MUX("nand rdy", EBU, xrx100_pins_nand_rdy),
+	GRP_MUX("nand rd", EBU, xrx100_pins_nand_rd),
+	GRP_MUX("spi_di", SPI, xrx100_pins_spi_di),
+	GRP_MUX("spi_do", SPI, xrx100_pins_spi_do),
+	GRP_MUX("spi_clk", SPI, xrx100_pins_spi_clk),
+	GRP_MUX("spi_cs1", SPI, xrx100_pins_spi_cs1),
+	GRP_MUX("spi_cs2", SPI, xrx100_pins_spi_cs2),
+	GRP_MUX("spi_cs3", SPI, xrx100_pins_spi_cs3),
+	GRP_MUX("spi_cs4", SPI, xrx100_pins_spi_cs4),
+	GRP_MUX("spi_cs5", SPI, xrx100_pins_spi_cs5),
+	GRP_MUX("spi_cs6", SPI, xrx100_pins_spi_cs6),
+	GRP_MUX("asc0", ASC, xrx100_pins_asc0),
+	GRP_MUX("asc0 cts rts", ASC, xrx100_pins_asc0_cts_rts),
+	GRP_MUX("stp", STP, xrx100_pins_stp),
+	GRP_MUX("nmi", NMI, xrx100_pins_nmi),
+	GRP_MUX("gpt1", GPT, xrx100_pins_gpt1),
+	GRP_MUX("gpt2", GPT, xrx100_pins_gpt2),
+	GRP_MUX("gpt3", GPT, xrx100_pins_gpt3),
+	GRP_MUX("clkout0", CGU, xrx100_pins_clkout0),
+	GRP_MUX("clkout1", CGU, xrx100_pins_clkout1),
+	GRP_MUX("clkout2", CGU, xrx100_pins_clkout2),
+	GRP_MUX("clkout3", CGU, xrx100_pins_clkout3),
+	GRP_MUX("gnt1", PCI, xrx100_pins_pci_gnt1),
+	GRP_MUX("gnt2", PCI, xrx100_pins_pci_gnt2),
+	GRP_MUX("gnt3", PCI, xrx100_pins_pci_gnt3),
+	GRP_MUX("gnt4", PCI, xrx100_pins_pci_gnt4),
+	GRP_MUX("req1", PCI, xrx100_pins_pci_req1),
+	GRP_MUX("req2", PCI, xrx100_pins_pci_req2),
+	GRP_MUX("req3", PCI, xrx100_pins_pci_req3),
+	GRP_MUX("req4", PCI, xrx100_pins_pci_req4),
+	GRP_MUX("mdio", MDIO, xrx100_pins_mdio),
+	GRP_MUX("dfe led0", DFE, xrx100_pins_dfe_led0),
+	GRP_MUX("dfe led1", DFE, xrx100_pins_dfe_led1),
+};
+
+static const char * const xrx100_pci_grps[] = {"gnt1", "gnt2",
+						"gnt3", "gnt4",
+						"req1", "req2",
+						"req3", "req4"};
+static const char * const xrx100_spi_grps[] = {"spi_di", "spi_do",
+						"spi_clk", "spi_cs1",
+						"spi_cs2", "spi_cs3",
+						"spi_cs4", "spi_cs5",
+						"spi_cs6"};
+static const char * const xrx100_cgu_grps[] = {"clkout0", "clkout1",
+						"clkout2", "clkout3"};
+static const char * const xrx100_ebu_grps[] = {"ebu a23", "ebu a24",
+						"ebu a25", "ebu cs1",
+						"ebu wait", "ebu clk",
+						"nand ale", "nand cs1",
+						"nand cle", "nand rdy",
+						"nand rd"};
+static const char * const xrx100_exin_grps[] = {"exin0", "exin1", "exin2",
+						"exin3", "exin4", "exin5"};
+static const char * const xrx100_gpt_grps[] = {"gpt1", "gpt2", "gpt3"};
+static const char * const xrx100_asc_grps[] = {"asc0", "asc0 cts rts"};
+static const char * const xrx100_stp_grps[] = {"stp"};
+static const char * const xrx100_nmi_grps[] = {"nmi"};
+static const char * const xrx100_mdio_grps[] = {"mdio"};
+static const char * const xrx100_dfe_grps[] = {"dfe led0", "dfe led1"};
+
+static const struct ltq_pmx_func xrx100_funcs[] = {
+	{"spi",		ARRAY_AND_SIZE(xrx100_spi_grps)},
+	{"asc",		ARRAY_AND_SIZE(xrx100_asc_grps)},
+	{"cgu",		ARRAY_AND_SIZE(xrx100_cgu_grps)},
+	{"exin",	ARRAY_AND_SIZE(xrx100_exin_grps)},
+	{"stp",		ARRAY_AND_SIZE(xrx100_stp_grps)},
+	{"gpt",		ARRAY_AND_SIZE(xrx100_gpt_grps)},
+	{"nmi",		ARRAY_AND_SIZE(xrx100_nmi_grps)},
+	{"pci",		ARRAY_AND_SIZE(xrx100_pci_grps)},
+	{"ebu",		ARRAY_AND_SIZE(xrx100_ebu_grps)},
+	{"mdio",	ARRAY_AND_SIZE(xrx100_mdio_grps)},
+	{"dfe",		ARRAY_AND_SIZE(xrx100_dfe_grps)},
+};
+
+/* ---------  xrx200 related code --------- */
+#define XRX200_MAX_PIN		50
+
+static const struct ltq_mfp_pin xrx200_mfp[] = {
+	/*       pin    f0	f1	f2	f3   */
+	MFP_XWAY(GPIO0, GPIO,	EXIN,	SDIO,	TDM),
+	MFP_XWAY(GPIO1, GPIO,	EXIN,	CBUS,	SIN),
+	MFP_XWAY(GPIO2, GPIO,	CGU,	EXIN,	GPHY),
+	MFP_XWAY(GPIO3, GPIO,	CGU,	SDIO,	PCI),
+	MFP_XWAY(GPIO4, GPIO,	STP,	DFE,	USIF),
+	MFP_XWAY(GPIO5, GPIO,	STP,	GPHY,	DFE),
+	MFP_XWAY(GPIO6, GPIO,	STP,	GPT,	USIF),
+	MFP_XWAY(GPIO7, GPIO,	CGU,	CBUS,	GPHY),
+	MFP_XWAY(GPIO8, GPIO,	CGU,	NMI,	NONE),
+	MFP_XWAY(GPIO9, GPIO,	USIF,	SPI,	EXIN),
+	MFP_XWAY(GPIO10, GPIO,	USIF,	SPI,	EXIN),
+	MFP_XWAY(GPIO11, GPIO,	USIF,	CBUS,	SPI),
+	MFP_XWAY(GPIO12, GPIO,	USIF,	CBUS,	MCD),
+	MFP_XWAY(GPIO13, GPIO,	EBU,	SPI,	NONE),
+	MFP_XWAY(GPIO14, GPIO,	CGU,	CBUS,	USIF),
+	MFP_XWAY(GPIO15, GPIO,	SPI,	SDIO,	MCD),
+	MFP_XWAY(GPIO16, GPIO,	SPI,	SDIO,	NONE),
+	MFP_XWAY(GPIO17, GPIO,	SPI,	SDIO,	NONE),
+	MFP_XWAY(GPIO18, GPIO,	SPI,	SDIO,	NONE),
+	MFP_XWAY(GPIO19, GPIO,	PCI,	SDIO,	CGU),
+	MFP_XWAY(GPIO20, GPIO,	NONE,	SDIO,	EBU),
+	MFP_XWAY(GPIO21, GPIO,	PCI,	EBU,	GPT),
+	MFP_XWAY(GPIO22, GPIO,	SPI,	CGU,	EBU),
+	MFP_XWAY(GPIO23, GPIO,	EBU,	PCI,	STP),
+	MFP_XWAY(GPIO24, GPIO,	EBU,	TDM,	PCI),
+	MFP_XWAY(GPIO25, GPIO,	TDM,	SDIO,	USIF),
+	MFP_XWAY(GPIO26, GPIO,	EBU,	TDM,	SDIO),
+	MFP_XWAY(GPIO27, GPIO,	TDM,	SDIO,	USIF),
+	MFP_XWAY(GPIO28, GPIO,	GPT,	PCI,	SDIO),
+	MFP_XWAY(GPIO29, GPIO,	PCI,	CBUS,	EXIN),
+	MFP_XWAY(GPIO30, GPIO,	PCI,	CBUS,	NONE),
+	MFP_XWAY(GPIO31, GPIO,	EBU,	PCI,	NONE),
+	MFP_XWAY(GPIO32, GPIO,	MII,	NONE,	EBU),
+	MFP_XWAY(GPIO33, GPIO,	MII,	NONE,	EBU),
+	MFP_XWAY(GPIO34, GPIO,	SIN,	SSI,	NONE),
+	MFP_XWAY(GPIO35, GPIO,	SIN,	SSI,	NONE),
+	MFP_XWAY(GPIO36, GPIO,	SIN,	SSI,	EXIN),
+	MFP_XWAY(GPIO37, GPIO,	USIF,	NONE,	PCI),
+	MFP_XWAY(GPIO38, GPIO,	PCI,	USIF,	NONE),
+	MFP_XWAY(GPIO39, GPIO,	USIF,	EXIN,	NONE),
+	MFP_XWAY(GPIO40, GPIO,	MII,	TDM,	NONE),
+	MFP_XWAY(GPIO41, GPIO,	MII,	TDM,	NONE),
+	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO44, GPIO,	MII,	SIN,	GPHY),
+	MFP_XWAY(GPIO45, GPIO,	MII,	GPHY,	SIN),
+	MFP_XWAY(GPIO46, GPIO,	MII,	NONE,	EXIN),
+	MFP_XWAY(GPIO47, GPIO,	MII,	GPHY,	SIN),
+	MFP_XWAY(GPIO48, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO49, GPIO,	EBU,	NONE,	NONE),
+};
+
+static const unsigned xrx200_exin_pin_map[] = {GPIO0, GPIO1, GPIO2, GPIO39, GPIO10, GPIO9};
+
+static const unsigned xrx200_pins_exin0[] = {GPIO0};
+static const unsigned xrx200_pins_exin1[] = {GPIO1};
+static const unsigned xrx200_pins_exin2[] = {GPIO2};
+static const unsigned xrx200_pins_exin3[] = {GPIO39};
+static const unsigned xrx200_pins_exin4[] = {GPIO10};
+static const unsigned xrx200_pins_exin5[] = {GPIO9};
+
+static const unsigned xrx200_pins_usif_uart_rx[] = {GPIO11};
+static const unsigned xrx200_pins_usif_uart_tx[] = {GPIO12};
+static const unsigned xrx200_pins_usif_uart_rts[] = {GPIO9};
+static const unsigned xrx200_pins_usif_uart_cts[] = {GPIO10};
+static const unsigned xrx200_pins_usif_uart_dtr[] = {GPIO4};
+static const unsigned xrx200_pins_usif_uart_dsr[] = {GPIO6};
+static const unsigned xrx200_pins_usif_uart_dcd[] = {GPIO25};
+static const unsigned xrx200_pins_usif_uart_ri[] = {GPIO27};
+
+static const unsigned xrx200_pins_usif_spi_di[] = {GPIO11};
+static const unsigned xrx200_pins_usif_spi_do[] = {GPIO12};
+static const unsigned xrx200_pins_usif_spi_clk[] = {GPIO38};
+static const unsigned xrx200_pins_usif_spi_cs0[] = {GPIO37};
+static const unsigned xrx200_pins_usif_spi_cs1[] = {GPIO39};
+static const unsigned xrx200_pins_usif_spi_cs2[] = {GPIO14};
+
+static const unsigned xrx200_pins_stp[] = {GPIO4, GPIO5, GPIO6};
+static const unsigned xrx200_pins_nmi[] = {GPIO8};
+static const unsigned xrx200_pins_mdio[] = {GPIO42, GPIO43};
+
+static const unsigned xrx200_pins_dfe_led0[] = {GPIO4};
+static const unsigned xrx200_pins_dfe_led1[] = {GPIO5};
+
+static const unsigned xrx200_pins_gphy0_led0[] = {GPIO5};
+static const unsigned xrx200_pins_gphy0_led1[] = {GPIO7};
+static const unsigned xrx200_pins_gphy0_led2[] = {GPIO2};
+static const unsigned xrx200_pins_gphy1_led0[] = {GPIO44};
+static const unsigned xrx200_pins_gphy1_led1[] = {GPIO45};
+static const unsigned xrx200_pins_gphy1_led2[] = {GPIO47};
+
+static const unsigned xrx200_pins_ebu_a24[] = {GPIO13};
+static const unsigned xrx200_pins_ebu_clk[] = {GPIO21};
+static const unsigned xrx200_pins_ebu_cs1[] = {GPIO23};
+static const unsigned xrx200_pins_ebu_a23[] = {GPIO24};
+static const unsigned xrx200_pins_ebu_wait[] = {GPIO26};
+static const unsigned xrx200_pins_ebu_a25[] = {GPIO31};
+
+static const unsigned xrx200_pins_nand_ale[] = {GPIO13};
+static const unsigned xrx200_pins_nand_cs1[] = {GPIO23};
+static const unsigned xrx200_pins_nand_cle[] = {GPIO24};
+static const unsigned xrx200_pins_nand_rdy[] = {GPIO48};
+static const unsigned xrx200_pins_nand_rd[] = {GPIO49};
+
+static const unsigned xrx200_pins_spi_di[] = {GPIO16};
+static const unsigned xrx200_pins_spi_do[] = {GPIO17};
+static const unsigned xrx200_pins_spi_clk[] = {GPIO18};
+static const unsigned xrx200_pins_spi_cs1[] = {GPIO15};
+static const unsigned xrx200_pins_spi_cs2[] = {GPIO22};
+static const unsigned xrx200_pins_spi_cs3[] = {GPIO13};
+static const unsigned xrx200_pins_spi_cs4[] = {GPIO10};
+static const unsigned xrx200_pins_spi_cs5[] = {GPIO9};
+static const unsigned xrx200_pins_spi_cs6[] = {GPIO11};
+
+static const unsigned xrx200_pins_gpt1[] = {GPIO28};
+static const unsigned xrx200_pins_gpt2[] = {GPIO21};
+static const unsigned xrx200_pins_gpt3[] = {GPIO6};
+
+static const unsigned xrx200_pins_clkout0[] = {GPIO8};
+static const unsigned xrx200_pins_clkout1[] = {GPIO7};
+static const unsigned xrx200_pins_clkout2[] = {GPIO3};
+static const unsigned xrx200_pins_clkout3[] = {GPIO2};
+
+static const unsigned xrx200_pins_pci_gnt1[] = {GPIO28};
+static const unsigned xrx200_pins_pci_gnt2[] = {GPIO23};
+static const unsigned xrx200_pins_pci_gnt3[] = {GPIO19};
+static const unsigned xrx200_pins_pci_gnt4[] = {GPIO38};
+static const unsigned xrx200_pins_pci_req1[] = {GPIO29};
+static const unsigned xrx200_pins_pci_req2[] = {GPIO31};
+static const unsigned xrx200_pins_pci_req3[] = {GPIO3};
+static const unsigned xrx200_pins_pci_req4[] = {GPIO37};
+
+static const struct ltq_pin_group xrx200_grps[] = {
+	GRP_MUX("exin0", EXIN, xrx200_pins_exin0),
+	GRP_MUX("exin1", EXIN, xrx200_pins_exin1),
+	GRP_MUX("exin2", EXIN, xrx200_pins_exin2),
+	GRP_MUX("exin3", EXIN, xrx200_pins_exin3),
+	GRP_MUX("exin4", EXIN, xrx200_pins_exin4),
+	GRP_MUX("exin5", EXIN, xrx200_pins_exin5),
+	GRP_MUX("ebu a23", EBU, xrx200_pins_ebu_a23),
+	GRP_MUX("ebu a24", EBU, xrx200_pins_ebu_a24),
+	GRP_MUX("ebu a25", EBU, xrx200_pins_ebu_a25),
+	GRP_MUX("ebu clk", EBU, xrx200_pins_ebu_clk),
+	GRP_MUX("ebu cs1", EBU, xrx200_pins_ebu_cs1),
+	GRP_MUX("ebu wait", EBU, xrx200_pins_ebu_wait),
+	GRP_MUX("nand ale", EBU, xrx200_pins_nand_ale),
+	GRP_MUX("nand cs1", EBU, xrx200_pins_nand_cs1),
+	GRP_MUX("nand cle", EBU, xrx200_pins_nand_cle),
+	GRP_MUX("nand rdy", EBU, xrx200_pins_nand_rdy),
+	GRP_MUX("nand rd", EBU, xrx200_pins_nand_rd),
+	GRP_MUX("spi_di", SPI, xrx200_pins_spi_di),
+	GRP_MUX("spi_do", SPI, xrx200_pins_spi_do),
+	GRP_MUX("spi_clk", SPI, xrx200_pins_spi_clk),
+	GRP_MUX("spi_cs1", SPI, xrx200_pins_spi_cs1),
+	GRP_MUX("spi_cs2", SPI, xrx200_pins_spi_cs2),
+	GRP_MUX("spi_cs3", SPI, xrx200_pins_spi_cs3),
+	GRP_MUX("spi_cs4", SPI, xrx200_pins_spi_cs4),
+	GRP_MUX("spi_cs5", SPI, xrx200_pins_spi_cs5),
+	GRP_MUX("spi_cs6", SPI, xrx200_pins_spi_cs6),
+	GRP_MUX("usif uart_rx", USIF, xrx200_pins_usif_uart_rx),
+	GRP_MUX("usif uart_rx", USIF, xrx200_pins_usif_uart_tx),
+	GRP_MUX("usif uart_rts", USIF, xrx200_pins_usif_uart_rts),
+	GRP_MUX("usif uart_cts", USIF, xrx200_pins_usif_uart_cts),
+	GRP_MUX("usif uart_dtr", USIF, xrx200_pins_usif_uart_dtr),
+	GRP_MUX("usif uart_dsr", USIF, xrx200_pins_usif_uart_dsr),
+	GRP_MUX("usif uart_dcd", USIF, xrx200_pins_usif_uart_dcd),
+	GRP_MUX("usif uart_ri", USIF, xrx200_pins_usif_uart_ri),
+	GRP_MUX("usif spi_di", USIF, xrx200_pins_usif_spi_di),
+	GRP_MUX("usif spi_do", USIF, xrx200_pins_usif_spi_do),
+	GRP_MUX("usif spi_clk", USIF, xrx200_pins_usif_spi_clk),
+	GRP_MUX("usif spi_cs0", USIF, xrx200_pins_usif_spi_cs0),
+	GRP_MUX("usif spi_cs1", USIF, xrx200_pins_usif_spi_cs1),
+	GRP_MUX("usif spi_cs2", USIF, xrx200_pins_usif_spi_cs2),
+	GRP_MUX("stp", STP, xrx200_pins_stp),
+	GRP_MUX("nmi", NMI, xrx200_pins_nmi),
+	GRP_MUX("gpt1", GPT, xrx200_pins_gpt1),
+	GRP_MUX("gpt2", GPT, xrx200_pins_gpt2),
+	GRP_MUX("gpt3", GPT, xrx200_pins_gpt3),
+	GRP_MUX("clkout0", CGU, xrx200_pins_clkout0),
+	GRP_MUX("clkout1", CGU, xrx200_pins_clkout1),
+	GRP_MUX("clkout2", CGU, xrx200_pins_clkout2),
+	GRP_MUX("clkout3", CGU, xrx200_pins_clkout3),
+	GRP_MUX("gnt1", PCI, xrx200_pins_pci_gnt1),
+	GRP_MUX("gnt2", PCI, xrx200_pins_pci_gnt2),
+	GRP_MUX("gnt3", PCI, xrx200_pins_pci_gnt3),
+	GRP_MUX("gnt4", PCI, xrx200_pins_pci_gnt4),
+	GRP_MUX("req1", PCI, xrx200_pins_pci_req1),
+	GRP_MUX("req2", PCI, xrx200_pins_pci_req2),
+	GRP_MUX("req3", PCI, xrx200_pins_pci_req3),
+	GRP_MUX("req4", PCI, xrx200_pins_pci_req4),
+	GRP_MUX("mdio", MDIO, xrx200_pins_mdio),
+	GRP_MUX("dfe led0", DFE, xrx200_pins_dfe_led0),
+	GRP_MUX("dfe led1", DFE, xrx200_pins_dfe_led1),
+	GRP_MUX("gphy0 led0", GPHY, xrx200_pins_gphy0_led0),
+	GRP_MUX("gphy0 led1", GPHY, xrx200_pins_gphy0_led1),
+	GRP_MUX("gphy0 led2", GPHY, xrx200_pins_gphy0_led2),
+	GRP_MUX("gphy1 led0", GPHY, xrx200_pins_gphy1_led0),
+	GRP_MUX("gphy1 led1", GPHY, xrx200_pins_gphy1_led1),
+	GRP_MUX("gphy1 led2", GPHY, xrx200_pins_gphy1_led2),
+};
+
+static const char * const xrx200_pci_grps[] = {"gnt1", "gnt2",
+						"gnt3", "gnt4",
+						"req1", "req2",
+						"req3", "req4"};
+static const char * const xrx200_spi_grps[] = {"spi_di", "spi_do",
+						"spi_clk", "spi_cs1",
+						"spi_cs2", "spi_cs3",
+						"spi_cs4", "spi_cs5",
+						"spi_cs6"};
+static const char * const xrx200_cgu_grps[] = {"clkout0", "clkout1",
+						"clkout2", "clkout3"};
+static const char * const xrx200_ebu_grps[] = {"ebu a23", "ebu a24",
+						"ebu a25", "ebu cs1",
+						"ebu wait", "ebu clk",
+						"nand ale", "nand cs1",
+						"nand cle", "nand rdy",
+						"nand rd"};
+static const char * const xrx200_exin_grps[] = {"exin0", "exin1", "exin2",
+						"exin3", "exin4", "exin5"};
+static const char * const xrx200_gpt_grps[] = {"gpt1", "gpt2", "gpt3"};
+static const char * const xrx200_usif_grps[] = {"usif uart_rx", "usif uart_tx",
+						"usif uart_rts", "usif uart_cts",
+						"usif uart_dtr", "usif uart_dsr",
+						"usif uart_dcd", "usif uart_ri",
+						"usif spi_di", "usif spi_do",
+						"usif spi_clk", "usif spi_cs0",
+						"usif spi_cs1", "usif spi_cs2"};
+static const char * const xrx200_stp_grps[] = {"stp"};
+static const char * const xrx200_nmi_grps[] = {"nmi"};
+static const char * const xrx200_mdio_grps[] = {"mdio"};
+static const char * const xrx200_dfe_grps[] = {"dfe led0", "dfe led1"};
+static const char * const xrx200_gphy_grps[] = {"gphy0 led0", "gphy0 led1",
+						"gphy0 led2", "gphy1 led0",
+						"gphy1 led1", "gphy1 led2"};
+
+static const struct ltq_pmx_func xrx200_funcs[] = {
+	{"spi",		ARRAY_AND_SIZE(xrx200_spi_grps)},
+	{"usif",	ARRAY_AND_SIZE(xrx200_usif_grps)},
+	{"cgu",		ARRAY_AND_SIZE(xrx200_cgu_grps)},
+	{"exin",	ARRAY_AND_SIZE(xrx200_exin_grps)},
+	{"stp",		ARRAY_AND_SIZE(xrx200_stp_grps)},
+	{"gpt",		ARRAY_AND_SIZE(xrx200_gpt_grps)},
+	{"nmi",		ARRAY_AND_SIZE(xrx200_nmi_grps)},
+	{"pci",		ARRAY_AND_SIZE(xrx200_pci_grps)},
+	{"ebu",		ARRAY_AND_SIZE(xrx200_ebu_grps)},
+	{"mdio",	ARRAY_AND_SIZE(xrx200_mdio_grps)},
+	{"dfe",		ARRAY_AND_SIZE(xrx200_dfe_grps)},
+	{"gphy",	ARRAY_AND_SIZE(xrx200_gphy_grps)},
+};
+
+/* ---------  xrx300 related code --------- */
+#define XRX300_MAX_PIN		64
+
+static const struct ltq_mfp_pin xrx300_mfp[] = {
+	/*       pin    f0	f1	f2	f3   */
+	MFP_XWAY(GPIO0, GPIO,	EXIN,	EPHY,	NONE),
+	MFP_XWAY(GPIO1, GPIO,	NONE,	EXIN,	NONE),
+	MFP_XWAY(GPIO2, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO3, GPIO,	CGU,	NONE,	NONE),
+	MFP_XWAY(GPIO4, GPIO,	STP,	DFE,	NONE),
+	MFP_XWAY(GPIO5, GPIO,	STP,	EPHY,	DFE),
+	MFP_XWAY(GPIO6, GPIO,	STP,	NONE,	NONE),
+	MFP_XWAY(GPIO7, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO8, GPIO,	CGU,	GPHY,	EPHY),
+	MFP_XWAY(GPIO9, GPIO,	WIFI,	NONE,	EXIN),
+	MFP_XWAY(GPIO10, GPIO,	USIF,	SPI,	EXIN),
+	MFP_XWAY(GPIO11, GPIO,	USIF,	WIFI,	SPI),
+	MFP_XWAY(GPIO12, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO13, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO14, GPIO,	CGU,	USIF,	EPHY),
+	MFP_XWAY(GPIO15, GPIO,	SPI,	NONE,	MCD),
+	MFP_XWAY(GPIO16, GPIO,	SPI,	EXIN,	NONE),
+	MFP_XWAY(GPIO17, GPIO,	SPI,	NONE,	NONE),
+	MFP_XWAY(GPIO18, GPIO,	SPI,	NONE,	NONE),
+	MFP_XWAY(GPIO19, GPIO,	USIF,	NONE,	EPHY),
+	MFP_XWAY(GPIO20, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO21, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO22, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO23, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO24, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO25, GPIO,	TDM,	NONE,	NONE),
+	MFP_XWAY(GPIO26, GPIO,	TDM,	NONE,	NONE),
+	MFP_XWAY(GPIO27, GPIO,	TDM,	NONE,	NONE),
+	MFP_XWAY(GPIO28, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO29, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO30, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO31, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO32, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO33, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO34, GPIO,	NONE,	SSI,	NONE),
+	MFP_XWAY(GPIO35, GPIO,	NONE,	SSI,	NONE),
+	MFP_XWAY(GPIO36, GPIO,	NONE,	SSI,	NONE),
+	MFP_XWAY(GPIO37, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO38, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO39, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO40, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO41, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO44, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO45, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO46, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO47, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO48, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO49, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO50, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO51, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO52, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO53, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO54, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO55, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO56, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO57, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO58, GPIO,	EBU,	TDM,	NONE),
+	MFP_XWAY(GPIO59, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO60, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO61, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO62, NONE,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO63, NONE,	NONE,	NONE,	NONE),
+};
+
+static const unsigned xrx300_exin_pin_map[] = {GPIO0, GPIO1, GPIO16, GPIO10, GPIO9};
+
+static const unsigned xrx300_pins_exin0[] = {GPIO0};
+static const unsigned xrx300_pins_exin1[] = {GPIO1};
+static const unsigned xrx300_pins_exin2[] = {GPIO16};
+/* EXIN3 is not available on xrX300 */
+static const unsigned xrx300_pins_exin4[] = {GPIO10};
+static const unsigned xrx300_pins_exin5[] = {GPIO9};
+
+static const unsigned xrx300_pins_usif_uart_rx[] = {GPIO11};
+static const unsigned xrx300_pins_usif_uart_tx[] = {GPIO10};
+
+static const unsigned xrx300_pins_usif_spi_di[] = {GPIO11};
+static const unsigned xrx300_pins_usif_spi_do[] = {GPIO10};
+static const unsigned xrx300_pins_usif_spi_clk[] = {GPIO19};
+static const unsigned xrx300_pins_usif_spi_cs0[] = {GPIO14};
+
+static const unsigned xrx300_pins_stp[] = {GPIO4, GPIO5, GPIO6};
+static const unsigned xrx300_pins_mdio[] = {GPIO42, GPIO43};
+
+static const unsigned xrx300_pins_dfe_led0[] = {GPIO4};
+static const unsigned xrx300_pins_dfe_led1[] = {GPIO5};
+
+static const unsigned xrx300_pins_ephy0_led0[] = {GPIO5};
+static const unsigned xrx300_pins_ephy0_led1[] = {GPIO8};
+static const unsigned xrx300_pins_ephy1_led0[] = {GPIO14};
+static const unsigned xrx300_pins_ephy1_led1[] = {GPIO19};
+
+static const unsigned xrx300_pins_nand_ale[] = {GPIO13};
+static const unsigned xrx300_pins_nand_cs1[] = {GPIO23};
+static const unsigned xrx300_pins_nand_cle[] = {GPIO24};
+static const unsigned xrx300_pins_nand_rdy[] = {GPIO48};
+static const unsigned xrx300_pins_nand_rd[] = {GPIO49};
+static const unsigned xrx300_pins_nand_d1[] = {GPIO50};
+static const unsigned xrx300_pins_nand_d0[] = {GPIO51};
+static const unsigned xrx300_pins_nand_d2[] = {GPIO52};
+static const unsigned xrx300_pins_nand_d7[] = {GPIO53};
+static const unsigned xrx300_pins_nand_d6[] = {GPIO54};
+static const unsigned xrx300_pins_nand_d5[] = {GPIO55};
+static const unsigned xrx300_pins_nand_d4[] = {GPIO56};
+static const unsigned xrx300_pins_nand_d3[] = {GPIO57};
+static const unsigned xrx300_pins_nand_cs0[] = {GPIO58};
+static const unsigned xrx300_pins_nand_wr[] = {GPIO59};
+static const unsigned xrx300_pins_nand_wp[] = {GPIO60};
+static const unsigned xrx300_pins_nand_se[] = {GPIO61};
+
+static const unsigned xrx300_pins_spi_di[] = {GPIO16};
+static const unsigned xrx300_pins_spi_do[] = {GPIO17};
+static const unsigned xrx300_pins_spi_clk[] = {GPIO18};
+static const unsigned xrx300_pins_spi_cs1[] = {GPIO15};
+/* SPI_CS2 is not available on xrX300 */
+/* SPI_CS3 is not available on xrX300 */
+static const unsigned xrx300_pins_spi_cs4[] = {GPIO10};
+/* SPI_CS5 is not available on xrX300 */
+static const unsigned xrx300_pins_spi_cs6[] = {GPIO11};
+
+/* CLKOUT0 is not available on xrX300 */
+/* CLKOUT1 is not available on xrX300 */
+static const unsigned xrx300_pins_clkout2[] = {GPIO3};
+
+static const struct ltq_pin_group xrx300_grps[] = {
+	GRP_MUX("exin0", EXIN, xrx300_pins_exin0),
+	GRP_MUX("exin1", EXIN, xrx300_pins_exin1),
+	GRP_MUX("exin2", EXIN, xrx300_pins_exin2),
+	GRP_MUX("exin4", EXIN, xrx300_pins_exin4),
+	GRP_MUX("exin5", EXIN, xrx300_pins_exin5),
+	GRP_MUX("nand ale", EBU, xrx300_pins_nand_ale),
+	GRP_MUX("nand cs1", EBU, xrx300_pins_nand_cs1),
+	GRP_MUX("nand cle", EBU, xrx300_pins_nand_cle),
+	GRP_MUX("nand rdy", EBU, xrx300_pins_nand_rdy),
+	GRP_MUX("nand rd", EBU, xrx300_pins_nand_rd),
+	GRP_MUX("nand d1", EBU, xrx300_pins_nand_d1),
+	GRP_MUX("nand d0", EBU, xrx300_pins_nand_d0),
+	GRP_MUX("nand d2", EBU, xrx300_pins_nand_d2),
+	GRP_MUX("nand d7", EBU, xrx300_pins_nand_d7),
+	GRP_MUX("nand d6", EBU, xrx300_pins_nand_d6),
+	GRP_MUX("nand d5", EBU, xrx300_pins_nand_d5),
+	GRP_MUX("nand d4", EBU, xrx300_pins_nand_d4),
+	GRP_MUX("nand d3", EBU, xrx300_pins_nand_d3),
+	GRP_MUX("nand cs0", EBU, xrx300_pins_nand_cs0),
+	GRP_MUX("nand wr", EBU, xrx300_pins_nand_wr),
+	GRP_MUX("nand wp", EBU, xrx300_pins_nand_wp),
+	GRP_MUX("nand se", EBU, xrx300_pins_nand_se),
+	GRP_MUX("spi_di", SPI, xrx300_pins_spi_di),
+	GRP_MUX("spi_do", SPI, xrx300_pins_spi_do),
+	GRP_MUX("spi_clk", SPI, xrx300_pins_spi_clk),
+	GRP_MUX("spi_cs1", SPI, xrx300_pins_spi_cs1),
+	GRP_MUX("spi_cs4", SPI, xrx300_pins_spi_cs4),
+	GRP_MUX("spi_cs6", SPI, xrx300_pins_spi_cs6),
+	GRP_MUX("usif uart_rx", USIF, xrx300_pins_usif_uart_rx),
+	GRP_MUX("usif uart_tx", USIF, xrx300_pins_usif_uart_tx),
+	GRP_MUX("usif spi_di", USIF, xrx300_pins_usif_spi_di),
+	GRP_MUX("usif spi_do", USIF, xrx300_pins_usif_spi_do),
+	GRP_MUX("usif spi_clk", USIF, xrx300_pins_usif_spi_clk),
+	GRP_MUX("usif spi_cs0", USIF, xrx300_pins_usif_spi_cs0),
+	GRP_MUX("stp", STP, xrx300_pins_stp),
+	GRP_MUX("clkout2", CGU, xrx300_pins_clkout2),
+	GRP_MUX("mdio", MDIO, xrx300_pins_mdio),
+	GRP_MUX("dfe led0", DFE, xrx300_pins_dfe_led0),
+	GRP_MUX("dfe led1", DFE, xrx300_pins_dfe_led1),
+	GRP_MUX("ephy0 led0", GPHY, xrx300_pins_ephy0_led0),
+	GRP_MUX("ephy0 led1", GPHY, xrx300_pins_ephy0_led1),
+	GRP_MUX("ephy1 led0", GPHY, xrx300_pins_ephy1_led0),
+	GRP_MUX("ephy1 led1", GPHY, xrx300_pins_ephy1_led1),
+};
+
+static const char * const xrx300_spi_grps[] = {"spi_di", "spi_do",
+						"spi_clk", "spi_cs1",
+						"spi_cs4", "spi_cs6"};
+static const char * const xrx300_cgu_grps[] = {"clkout2"};
+static const char * const xrx300_ebu_grps[] = {"nand ale", "nand cs1",
+						"nand cle", "nand rdy",
+						"nand rd", "nand d1",
+						"nand d0", "nand d2",
+						"nand d7", "nand d6",
+						"nand d5", "nand d4",
+						"nand d3", "nand cs0",
+						"nand wr", "nand wp",
+						"nand se"};
+static const char * const xrx300_exin_grps[] = {"exin0", "exin1", "exin2",
+						"exin4", "exin5"};
+static const char * const xrx300_usif_grps[] = {"usif uart_rx", "usif uart_tx",
+						"usif spi_di", "usif spi_do",
+						"usif spi_clk", "usif spi_cs0"};
+static const char * const xrx300_stp_grps[] = {"stp"};
+static const char * const xrx300_mdio_grps[] = {"mdio"};
+static const char * const xrx300_dfe_grps[] = {"dfe led0", "dfe led1"};
+static const char * const xrx300_gphy_grps[] = {"ephy0 led0", "ephy0 led1",
+						"ephy1 led0", "ephy1 led1"};
+
+static const struct ltq_pmx_func xrx300_funcs[] = {
+	{"spi",		ARRAY_AND_SIZE(xrx300_spi_grps)},
+	{"usif",	ARRAY_AND_SIZE(xrx300_usif_grps)},
+	{"cgu",		ARRAY_AND_SIZE(xrx300_cgu_grps)},
+	{"exin",	ARRAY_AND_SIZE(xrx300_exin_grps)},
+	{"stp",		ARRAY_AND_SIZE(xrx300_stp_grps)},
+	{"ebu",		ARRAY_AND_SIZE(xrx300_ebu_grps)},
+	{"mdio",	ARRAY_AND_SIZE(xrx300_mdio_grps)},
+	{"dfe",		ARRAY_AND_SIZE(xrx300_dfe_grps)},
+	{"ephy",	ARRAY_AND_SIZE(xrx300_gphy_grps)},
+};
+
 /* ---------  pinconf related code --------- */
 static int xway_pinconf_get(struct pinctrl_dev *pctldev,
 				unsigned pin,
@@ -695,10 +1582,7 @@ static struct gpio_chip xway_chip = {
 
 
 /* --------- register the pinctrl layer --------- */
-static const unsigned xway_exin_pin_map[] = {GPIO0, GPIO1, GPIO2, GPIO39, GPIO46, GPIO9};
-static const unsigned ase_exin_pins_map[] = {GPIO6, GPIO29, GPIO0};
-
-static struct pinctrl_xway_soc {
+struct pinctrl_xway_soc {
 	int pin_count;
 	const struct ltq_mfp_pin *mfp;
 	const struct ltq_pin_group *grps;
@@ -707,22 +1591,54 @@ static struct pinctrl_xway_soc {
 	unsigned int num_funcs;
 	const unsigned *exin;
 	unsigned int num_exin;
-} soc_cfg[] = {
-	/* legacy xway */
-	{XWAY_MAX_PIN, xway_mfp,
-		xway_grps, ARRAY_SIZE(xway_grps),
-		danube_funcs, ARRAY_SIZE(danube_funcs),
-		xway_exin_pin_map, 3},
-	/* xway xr9 series */
-	{XR9_MAX_PIN, xway_mfp,
-		xway_grps, ARRAY_SIZE(xway_grps),
-		xrx_funcs, ARRAY_SIZE(xrx_funcs),
-		xway_exin_pin_map, 6},
-	/* xway ase series */
-	{XWAY_MAX_PIN, ase_mfp,
-		ase_grps, ARRAY_SIZE(ase_grps),
-		ase_funcs, ARRAY_SIZE(ase_funcs),
-		ase_exin_pins_map, 3},
+};
+
+/* xway xr9 series (DEPRECATED: Use XWAY xRX100/xRX200 Family) */
+static struct pinctrl_xway_soc xr9_pinctrl = {
+	XR9_MAX_PIN, xway_mfp,
+	xway_grps, ARRAY_SIZE(xway_grps),
+	xrx_funcs, ARRAY_SIZE(xrx_funcs),
+	xway_exin_pin_map, 6
+};
+
+/* XWAY AMAZON Family */
+static struct pinctrl_xway_soc ase_pinctrl = {
+	ASE_MAX_PIN, ase_mfp,
+	ase_grps, ARRAY_SIZE(ase_grps),
+	ase_funcs, ARRAY_SIZE(ase_funcs),
+	ase_exin_pin_map, 3
+};
+
+/* XWAY DANUBE Family */
+static struct pinctrl_xway_soc danube_pinctrl = {
+	DANUBE_MAX_PIN, danube_mfp,
+	danube_grps, ARRAY_SIZE(danube_grps),
+	danube_funcs, ARRAY_SIZE(danube_funcs),
+	danube_exin_pin_map, 3
+};
+
+/* XWAY xRX100 Family */
+static struct pinctrl_xway_soc xrx100_pinctrl = {
+	XRX100_MAX_PIN, xrx100_mfp,
+	xrx100_grps, ARRAY_SIZE(xrx100_grps),
+	xrx100_funcs, ARRAY_SIZE(xrx100_funcs),
+	xrx100_exin_pin_map, 6
+};
+
+/* XWAY xRX200 Family */
+static struct pinctrl_xway_soc xrx200_pinctrl = {
+	XRX200_MAX_PIN, xrx200_mfp,
+	xrx200_grps, ARRAY_SIZE(xrx200_grps),
+	xrx200_funcs, ARRAY_SIZE(xrx200_funcs),
+	xrx200_exin_pin_map, 6
+};
+
+/* XWAY xRX300 Family */
+static struct pinctrl_xway_soc xrx300_pinctrl = {
+	XRX300_MAX_PIN, xrx300_mfp,
+	xrx300_grps, ARRAY_SIZE(xrx300_grps),
+	xrx300_funcs, ARRAY_SIZE(xrx300_funcs),
+	xrx300_exin_pin_map, 5
 };
 
 static struct pinctrl_gpio_range xway_gpio_range = {
@@ -731,9 +1647,14 @@ static struct pinctrl_gpio_range xway_gpio_range = {
 };
 
 static const struct of_device_id xway_match[] = {
-	{ .compatible = "lantiq,pinctrl-xway", .data = &soc_cfg[0]},
-	{ .compatible = "lantiq,pinctrl-xr9", .data = &soc_cfg[1]},
-	{ .compatible = "lantiq,pinctrl-ase", .data = &soc_cfg[2]},
+	{ .compatible = "lantiq,pinctrl-xway", .data = &danube_pinctrl}, /*DEPRECATED*/
+	{ .compatible = "lantiq,pinctrl-xr9", .data = &xr9_pinctrl}, /*DEPRECATED*/
+	{ .compatible = "lantiq,pinctrl-ase", .data = &ase_pinctrl}, /*DEPRECATED*/
+	{ .compatible = "lantiq,ase-pinctrl", .data = &ase_pinctrl},
+	{ .compatible = "lantiq,danube-pinctrl", .data = &danube_pinctrl},
+	{ .compatible = "lantiq,xrx100-pinctrl", .data = &xrx100_pinctrl},
+	{ .compatible = "lantiq,xrx200-pinctrl", .data = &xrx200_pinctrl},
+	{ .compatible = "lantiq,xrx300-pinctrl", .data = &xrx300_pinctrl},
 	{},
 };
 MODULE_DEVICE_TABLE(of, xway_match);
@@ -755,7 +1676,7 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	if (match)
 		xway_soc = (const struct pinctrl_xway_soc *) match->data;
 	else
-		xway_soc = &soc_cfg[0];
+		xway_soc = &danube_pinctrl;
 
 	/* find out how many pads we have */
 	xway_chip.ngpio = xway_soc->pin_count;

commit 58383c78425e4ee1c077253cf297b641c861c02e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 4 09:56:26 2015 +0100

    gpio: change member .dev to .parent
    
    The name .dev in a struct is normally reserved for a struct device
    that is let us say a superclass to the thing described by the struct.
    struct gpio_chip stands out by confusingly using a struct device *dev
    to point to the parent device (such as a platform_device) that
    represents the hardware. As we want to give gpio_chip:s real devices,
    this is not working. We need to rename this member to parent.
    
    This was done by two coccinelle scripts, I guess it is possible to
    combine them into one, but I don't know such stuff. They look like
    this:
    
    @@
    struct gpio_chip *var;
    @@
    -var->dev
    +var->parent
    
    and:
    
    @@
    struct gpio_chip var;
    @@
    -var.dev
    +var.parent
    
    and:
    
    @@
    struct bgpio_chip *var;
    @@
    -var->gc.dev
    +var->gc.parent
    
    Plus a few instances of bgpio that I couldn't figure out how
    to teach Coccinelle to rewrite.
    
    This patch hits all over the place, but I *strongly* prefer this
    solution to any piecemal approaches that just exercise patch
    mechanics all over the place. It mainly hits drivers/gpio and
    drivers/pinctrl which is my own backyard anyway.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Rafa Miecki <zajec5@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Alek Du <alek.du@intel.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index ae724bdab3d3..b4380fb72001 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -648,7 +648,7 @@ static struct ltq_pinmux_info xway_info = {
 /* ---------  gpio_chip related code --------- */
 static void xway_gpio_set(struct gpio_chip *chip, unsigned int pin, int val)
 {
-	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
 
 	if (val)
 		gpio_setbit(info->membase[0], GPIO_OUT(pin), PORT_PIN(pin));
@@ -658,14 +658,14 @@ static void xway_gpio_set(struct gpio_chip *chip, unsigned int pin, int val)
 
 static int xway_gpio_get(struct gpio_chip *chip, unsigned int pin)
 {
-	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
 
 	return gpio_getbit(info->membase[0], GPIO_IN(pin), PORT_PIN(pin));
 }
 
 static int xway_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)
 {
-	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
 
 	gpio_clearbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));
 
@@ -674,7 +674,7 @@ static int xway_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)
 
 static int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)
 {
-	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
 
 	gpio_setbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));
 	xway_gpio_set(chip, pin, val);
@@ -783,7 +783,7 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	xway_pctrl_desc.pins = xway_info.pads;
 
 	/* load the gpio chip */
-	xway_chip.dev = &pdev->dev;
+	xway_chip.parent = &pdev->dev;
 	ret = gpiochip_add(&xway_chip);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to register gpio chip\n");

commit 98c85d583a5dee70d75faed3eb79851dd0a2e2fe
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Sun Oct 11 17:34:19 2015 +0200

    pinctrl: replace trivial implementations of gpio_chip request/free
    
    Replace all trivial request/free callbacks that do nothing but call into
    pinctrl code with the generic versions.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Acked-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Eric Anholt <eric@anholt.net>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Andrew Bresticker <abrestic@chromium.org>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Lee Jones <lee@kernel.org>
    Acked-by: Laxman Dewangan <ldewangan@nvidia.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 779950c62e53..ae724bdab3d3 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -682,28 +682,14 @@ static int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)
 	return 0;
 }
 
-static int xway_gpio_req(struct gpio_chip *chip, unsigned offset)
-{
-	int gpio = chip->base + offset;
-
-	return pinctrl_request_gpio(gpio);
-}
-
-static void xway_gpio_free(struct gpio_chip *chip, unsigned offset)
-{
-	int gpio = chip->base + offset;
-
-	pinctrl_free_gpio(gpio);
-}
-
 static struct gpio_chip xway_chip = {
 	.label = "gpio-xway",
 	.direction_input = xway_gpio_dir_in,
 	.direction_output = xway_gpio_dir_out,
 	.get = xway_gpio_get,
 	.set = xway_gpio_set,
-	.request = xway_gpio_req,
-	.free = xway_gpio_free,
+	.request = gpiochip_generic_request,
+	.free = gpiochip_generic_free,
 	.base = -1,
 };
 

commit 41f632fe177bc4822c2e8236fe7c291e6e9eb6f8
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Jan 12 17:20:51 2015 +0100

    pinctrl: lantiq: remove bogus of_gpio_chip_add
    
    Remove bogus call to of_gpiochip_add (and of_gpio_chip remove in error
    path) which is also called when adding the gpio chip.
    
    This prevents adding the same pinctrl range twice.
    
    Fixes: 3f8c50c9b110 ("OF: pinctrl: MIPS: lantiq: implement lantiq/xway
    pinctrl support")
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index c5cef59f5965..779950c62e53 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -798,10 +798,8 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 
 	/* load the gpio chip */
 	xway_chip.dev = &pdev->dev;
-	of_gpiochip_add(&xway_chip);
 	ret = gpiochip_add(&xway_chip);
 	if (ret) {
-		of_gpiochip_remove(&xway_chip);
 		dev_err(&pdev->dev, "Failed to register gpio chip\n");
 		return ret;
 	}

commit 5c759d73b0228901d0e05e5f02402fb35f5d2263
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:21 2014 +0200

    pinctrl: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 37040ab42890..c5cef59f5965 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -840,7 +840,6 @@ static struct platform_driver pinmux_xway_driver = {
 	.probe	= pinmux_xway_probe,
 	.driver = {
 		.name	= "pinctrl-xway",
-		.owner	= THIS_MODULE,
 		.of_match_table = xway_match,
 	},
 };

commit 849a8c25c80a2cde824072813bf4aabbc79b8789
Author: Pramod Gurav <pramod.gurav@smartplayin.com>
Date:   Tue Sep 9 13:35:52 2014 +0530

    pinctrl: lantiq: Release gpiochip resources in fail case
    
    This patch releases gpiochip resources with of_gpiochip_remove
    and gpiochip_remove in failure cases.
    
    CC: John Crispin <blogic@openwrt.org>
    CC: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Pramod Gurav <pramod.gurav@smartplayin.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index e66f4cae7633..37040ab42890 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -801,6 +801,7 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	of_gpiochip_add(&xway_chip);
 	ret = gpiochip_add(&xway_chip);
 	if (ret) {
+		of_gpiochip_remove(&xway_chip);
 		dev_err(&pdev->dev, "Failed to register gpio chip\n");
 		return ret;
 	}
@@ -822,6 +823,7 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	/* register with the generic lantiq layer */
 	ret = ltq_pinctrl_register(pdev, &xway_info);
 	if (ret) {
+		gpiochip_remove(&xway_chip);
 		dev_err(&pdev->dev, "Failed to register pinctrl driver\n");
 		return ret;
 	}

commit a1edd49e42f1b79015dab2d5d7057ef39730a789
Author: Antonios Vamporakis <ant@area128.com>
Date:   Sun Dec 29 22:48:02 2013 +0100

    pinctrl/lantiq: fix typo
    
    Signed-off-by: Antonios Vamporakis <ant@area128.com>
    CC: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index ed2d1ba69cef..e66f4cae7633 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -332,10 +332,10 @@ static const struct ltq_pin_group xway_grps[] = {
 	GRP_MUX("mdio", MDIO, pins_mdio),
 	GRP_MUX("gphy0 led0", GPHY, pins_gphy0_led0),
 	GRP_MUX("gphy0 led1", GPHY, pins_gphy0_led1),
-	GRP_MUX("gphy0 lde2", GPHY, pins_gphy0_led2),
+	GRP_MUX("gphy0 led2", GPHY, pins_gphy0_led2),
 	GRP_MUX("gphy1 led0", GPHY, pins_gphy1_led0),
 	GRP_MUX("gphy1 led1", GPHY, pins_gphy1_led1),
-	GRP_MUX("gphy1 lde2", GPHY, pins_gphy1_led2),
+	GRP_MUX("gphy1 led2", GPHY, pins_gphy1_led2),
 };
 
 static const struct ltq_pin_group ase_grps[] = {

commit 03b054e9696c3cbd3d5905ec96da15acd0a2fe8d
Author: Sherman Yin <syin@broadcom.com>
Date:   Tue Aug 27 11:32:12 2013 -0700

    pinctrl: Pass all configs to driver on pin_config_set()
    
    When setting pin configuration in the pinctrl framework, pin_config_set() or
    pin_config_group_set() is called in a loop to set one configuration at a time
    for the specified pin or group.
    
    This patch 1) removes the loop and 2) changes the API to pass the whole pin
    config array to the driver.  It is now up to the driver to loop through the
    configs.  This allows the driver to potentially combine configs and reduce the
    number of writes to pin config registers.
    
    All c files changed have been build-tested to verify the change compiles and
    that the corresponding .o is successfully generated.
    
    Signed-off-by: Sherman Yin <syin@broadcom.com>
    Reviewed-by: Christian Daudt <csd@broadcom.com>
    Reviewed-by: Matt Porter <matt.porter@linaro.org>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 86c8cf82105b..ed2d1ba69cef 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -499,74 +499,101 @@ static int xway_pinconf_get(struct pinctrl_dev *pctldev,
 
 static int xway_pinconf_set(struct pinctrl_dev *pctldev,
 				unsigned pin,
-				unsigned long config)
+				unsigned long *configs,
+				unsigned num_configs)
 {
 	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);
-	enum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(config);
-	int arg = LTQ_PINCONF_UNPACK_ARG(config);
+	enum ltq_pinconf_param param;
+	int arg;
 	int port = PORT(pin);
 	u32 reg;
+	int i;
+
+	for (i = 0; i < num_configs; i++) {
+		param = LTQ_PINCONF_UNPACK_PARAM(configs[i]);
+		arg = LTQ_PINCONF_UNPACK_ARG(configs[i]);
+
+		switch (param) {
+		case LTQ_PINCONF_PARAM_OPEN_DRAIN:
+			if (port == PORT3)
+				reg = GPIO3_OD;
+			else
+				reg = GPIO_OD(pin);
+			if (arg == 0)
+				gpio_setbit(info->membase[0],
+					reg,
+					PORT_PIN(pin));
+			else
+				gpio_clearbit(info->membase[0],
+					reg,
+					PORT_PIN(pin));
+			break;
 
-	switch (param) {
-	case LTQ_PINCONF_PARAM_OPEN_DRAIN:
-		if (port == PORT3)
-			reg = GPIO3_OD;
-		else
-			reg = GPIO_OD(pin);
-		if (arg == 0)
+		case LTQ_PINCONF_PARAM_PULL:
+			if (port == PORT3)
+				reg = GPIO3_PUDEN;
+			else
+				reg = GPIO_PUDEN(pin);
+			if (arg == 0) {
+				gpio_clearbit(info->membase[0],
+					reg,
+					PORT_PIN(pin));
+				break;
+			}
 			gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
-		else
-			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
-		break;
 
-	case LTQ_PINCONF_PARAM_PULL:
-		if (port == PORT3)
-			reg = GPIO3_PUDEN;
-		else
-			reg = GPIO_PUDEN(pin);
-		if (arg == 0) {
-			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
+			if (port == PORT3)
+				reg = GPIO3_PUDSEL;
+			else
+				reg = GPIO_PUDSEL(pin);
+			if (arg == 1)
+				gpio_clearbit(info->membase[0],
+					reg,
+					PORT_PIN(pin));
+			else if (arg == 2)
+				gpio_setbit(info->membase[0],
+					reg,
+					PORT_PIN(pin));
+			else
+				dev_err(pctldev->dev,
+					"Invalid pull value %d\n", arg);
 			break;
-		}
-		gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
 
-		if (port == PORT3)
-			reg = GPIO3_PUDSEL;
-		else
-			reg = GPIO_PUDSEL(pin);
-		if (arg == 1)
-			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
-		else if (arg == 2)
-			gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
-		else
-			dev_err(pctldev->dev, "Invalid pull value %d\n", arg);
-		break;
+		case LTQ_PINCONF_PARAM_OUTPUT:
+			reg = GPIO_DIR(pin);
+			if (arg == 0)
+				gpio_clearbit(info->membase[0],
+					reg,
+					PORT_PIN(pin));
+			else
+				gpio_setbit(info->membase[0],
+					reg,
+					PORT_PIN(pin));
+			break;
 
-	case LTQ_PINCONF_PARAM_OUTPUT:
-		reg = GPIO_DIR(pin);
-		if (arg == 0)
-			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
-		else
-			gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
-		break;
+		default:
+			dev_err(pctldev->dev,
+				"Invalid config param %04x\n", param);
+			return -ENOTSUPP;
+		}
+	} /* for each config */
 
-	default:
-		dev_err(pctldev->dev, "Invalid config param %04x\n", param);
-		return -ENOTSUPP;
-	}
 	return 0;
 }
 
 int xway_pinconf_group_set(struct pinctrl_dev *pctldev,
 			unsigned selector,
-			unsigned long config)
+			unsigned long *configs,
+			unsigned num_configs)
 {
 	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);
 	int i, ret = 0;
 
 	for (i = 0; i < info->grps[selector].npins && !ret; i++)
 		ret = xway_pinconf_set(pctldev,
-				info->grps[selector].pins[i], config);
+				info->grps[selector].pins[i],
+				configs,
+				num_configs);
 
 	return ret;
 }

commit 0fabc8354318f84efd942fe3017fff2326392094
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Aug 9 20:38:15 2013 +0200

    pinctrl/lantiq: add missing gphy led setup
    
    We found out how to set the gphy led pinmuxing.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index e92132c76a6b..86c8cf82105b 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -102,6 +102,7 @@ enum xway_mux {
 	XWAY_MUX_EPHY,
 	XWAY_MUX_DFE,
 	XWAY_MUX_SDIO,
+	XWAY_MUX_GPHY,
 	XWAY_MUX_NONE = 0xffff,
 };
 
@@ -109,12 +110,12 @@ static const struct ltq_mfp_pin xway_mfp[] = {
 	/*       pin    f0	f1	f2	f3   */
 	MFP_XWAY(GPIO0, GPIO,	EXIN,	NONE,	TDM),
 	MFP_XWAY(GPIO1, GPIO,	EXIN,	NONE,	NONE),
-	MFP_XWAY(GPIO2, GPIO,	CGU,	EXIN,	NONE),
+	MFP_XWAY(GPIO2, GPIO,	CGU,	EXIN,	GPHY),
 	MFP_XWAY(GPIO3, GPIO,	CGU,	NONE,	PCI),
 	MFP_XWAY(GPIO4, GPIO,	STP,	NONE,	ASC),
-	MFP_XWAY(GPIO5, GPIO,	STP,	NONE,	NONE),
+	MFP_XWAY(GPIO5, GPIO,	STP,	NONE,	GPHY),
 	MFP_XWAY(GPIO6, GPIO,	STP,	GPT,	ASC),
-	MFP_XWAY(GPIO7, GPIO,	CGU,	PCI,	NONE),
+	MFP_XWAY(GPIO7, GPIO,	CGU,	PCI,	GPHY),
 	MFP_XWAY(GPIO8, GPIO,	CGU,	NMI,	NONE),
 	MFP_XWAY(GPIO9, GPIO,	ASC,	SPI,	EXIN),
 	MFP_XWAY(GPIO10, GPIO,	ASC,	SPI,	NONE),
@@ -151,10 +152,10 @@ static const struct ltq_mfp_pin xway_mfp[] = {
 	MFP_XWAY(GPIO41, GPIO,	NONE,	NONE,	NONE),
 	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
 	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
-	MFP_XWAY(GPIO44, GPIO,	NONE,	NONE,	SIN),
-	MFP_XWAY(GPIO45, GPIO,	NONE,	NONE,	SIN),
+	MFP_XWAY(GPIO44, GPIO,	NONE,	GPHY,	SIN),
+	MFP_XWAY(GPIO45, GPIO,	NONE,	GPHY,	SIN),
 	MFP_XWAY(GPIO46, GPIO,	NONE,	NONE,	EXIN),
-	MFP_XWAY(GPIO47, GPIO,	NONE,	NONE,	SIN),
+	MFP_XWAY(GPIO47, GPIO,	NONE,	GPHY,	SIN),
 	MFP_XWAY(GPIO48, GPIO,	EBU,	NONE,	NONE),
 	MFP_XWAY(GPIO49, GPIO,	EBU,	NONE,	NONE),
 	MFP_XWAY(GPIO50, GPIO,	NONE,	NONE,	NONE),
@@ -208,6 +209,13 @@ static const unsigned pins_stp[] = {GPIO4, GPIO5, GPIO6};
 static const unsigned pins_nmi[] = {GPIO8};
 static const unsigned pins_mdio[] = {GPIO42, GPIO43};
 
+static const unsigned pins_gphy0_led0[] = {GPIO5};
+static const unsigned pins_gphy0_led1[] = {GPIO7};
+static const unsigned pins_gphy0_led2[] = {GPIO2};
+static const unsigned pins_gphy1_led0[] = {GPIO44};
+static const unsigned pins_gphy1_led1[] = {GPIO45};
+static const unsigned pins_gphy1_led2[] = {GPIO47};
+
 static const unsigned pins_ebu_a24[] = {GPIO13};
 static const unsigned pins_ebu_clk[] = {GPIO21};
 static const unsigned pins_ebu_cs1[] = {GPIO23};
@@ -322,6 +330,12 @@ static const struct ltq_pin_group xway_grps[] = {
 	GRP_MUX("gnt4", PCI, pins_pci_gnt4),
 	GRP_MUX("req4", PCI, pins_pci_gnt4),
 	GRP_MUX("mdio", MDIO, pins_mdio),
+	GRP_MUX("gphy0 led0", GPHY, pins_gphy0_led0),
+	GRP_MUX("gphy0 led1", GPHY, pins_gphy0_led1),
+	GRP_MUX("gphy0 lde2", GPHY, pins_gphy0_led2),
+	GRP_MUX("gphy1 led0", GPHY, pins_gphy1_led0),
+	GRP_MUX("gphy1 led1", GPHY, pins_gphy1_led1),
+	GRP_MUX("gphy1 lde2", GPHY, pins_gphy1_led2),
 };
 
 static const struct ltq_pin_group ase_grps[] = {
@@ -365,6 +379,9 @@ static const char * const xway_nmi_grps[] = {"nmi"};
 
 /* ar9/vr9/gr9 */
 static const char * const xrx_mdio_grps[] = {"mdio"};
+static const char * const xrx_gphy_grps[] = {"gphy0 led0", "gphy0 led1",
+						"gphy0 led2", "gphy1 led0",
+						"gphy1 led1", "gphy1 led2"};
 static const char * const xrx_ebu_grps[] = {"ebu a23", "ebu a24",
 						"ebu a25", "ebu cs1",
 						"ebu wait", "ebu clk",
@@ -414,6 +431,7 @@ static const struct ltq_pmx_func xrx_funcs[] = {
 	{"pci",		ARRAY_AND_SIZE(xrx_pci_grps)},
 	{"ebu",		ARRAY_AND_SIZE(xrx_ebu_grps)},
 	{"mdio",	ARRAY_AND_SIZE(xrx_mdio_grps)},
+	{"gphy",	ARRAY_AND_SIZE(xrx_gphy_grps)},
 };
 
 static const struct ltq_pmx_func ase_funcs[] = {

commit 0497a59450a70fcecffc288f9d864d6c778746ee
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Sun May 12 15:19:50 2013 +0200

    drivers/pinctrl: don't check resource with devm_ioremap_resource
    
    devm_ioremap_resource does sanity checks on the given resource. No need to
    duplicate this in the driver.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index f2977cff8366..e92132c76a6b 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -716,10 +716,6 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 
 	/* get and remap our register range */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Failed to get resource\n");
-		return -ENOENT;
-	}
 	xway_info.membase[0] = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(xway_info.membase[0]))
 		return PTR_ERR(xway_info.membase[0]);

commit 022ab148d28e8466e45d28552224e3029f1cccd8
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 10:25:07 2013 +0100

    pinctrl: Declare operation structures as const
    
    The pinconf, pinctrl and pinmux operation structures hold function
    pointers that are never modified. Declare them as const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 068224efa6fa..f2977cff8366 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -553,7 +553,7 @@ int xway_pinconf_group_set(struct pinctrl_dev *pctldev,
 	return ret;
 }
 
-static struct pinconf_ops xway_pinconf_ops = {
+static const struct pinconf_ops xway_pinconf_ops = {
 	.pin_config_get	= xway_pinconf_get,
 	.pin_config_set	= xway_pinconf_set,
 	.pin_config_group_set = xway_pinconf_group_set,

commit 06991c28f37ad68e5c03777f5c3b679b56e3dac1
Merge: 460dc1eecf37 74fef7a8fd1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 12:05:51 2013 -0800

    Merge tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core patches from Greg Kroah-Hartman:
     "Here is the big driver core merge for 3.9-rc1
    
      There are two major series here, both of which touch lots of drivers
      all over the kernel, and will cause you some merge conflicts:
    
       - add a new function called devm_ioremap_resource() to properly be
         able to check return values.
    
       - remove CONFIG_EXPERIMENTAL
    
      Other than those patches, there's not much here, some minor fixes and
      updates"
    
    Fix up trivial conflicts
    
    * tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (221 commits)
      base: memory: fix soft/hard_offline_page permissions
      drivercore: Fix ordering between deferred_probe and exiting initcalls
      backlight: fix class_find_device() arguments
      TTY: mark tty_get_device call with the proper const values
      driver-core: constify data for class_find_device()
      firmware: Ignore abort check when no user-helper is used
      firmware: Reduce ifdef CONFIG_FW_LOADER_USER_HELPER
      firmware: Make user-mode helper optional
      firmware: Refactoring for splitting user-mode helper code
      Driver core: treat unregistered bus_types as having no devices
      watchdog: Convert to devm_ioremap_resource()
      thermal: Convert to devm_ioremap_resource()
      spi: Convert to devm_ioremap_resource()
      power: Convert to devm_ioremap_resource()
      mtd: Convert to devm_ioremap_resource()
      mmc: Convert to devm_ioremap_resource()
      mfd: Convert to devm_ioremap_resource()
      media: Convert to devm_ioremap_resource()
      iommu: Convert to devm_ioremap_resource()
      drm: Convert to devm_ioremap_resource()
      ...

commit 933862873740923a059cbcda0c66487c6179ba3c
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:04:59 2013 +0100

    pinctrl/lantiq: the pinconf OD parameter argument was ignored
    
    When setting the OpenDrain bit we should really honour the
    argument passed inside the devicetree.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index b23b8954ae31..53cb6a3a56ed 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -494,7 +494,10 @@ static int xway_pinconf_set(struct pinctrl_dev *pctldev,
 			reg = GPIO3_OD;
 		else
 			reg = GPIO_OD(pin);
-		gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
+		if (arg == 0)
+			gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
+		else
+			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
 		break;
 
 	case LTQ_PINCONF_PARAM_PULL:

commit 6360350cbc0567f51afacb2d1e6a8e611b3b9b2b
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:04:58 2013 +0100

    pinctrl/lantiq: add output pinconf parameter
    
    While converting the boards inside OpenWrt to OF I noticed
    that the we are missing a pinconf parameter to set a pin
    to output.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index aa4c8b815c20..b23b8954ae31 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -466,6 +466,11 @@ static int xway_pinconf_get(struct pinctrl_dev *pctldev,
 			*config = LTQ_PINCONF_PACK(param, 1);
 		break;
 
+	case LTQ_PINCONF_PARAM_OUTPUT:
+		reg = GPIO_DIR(pin);
+		*config = LTQ_PINCONF_PACK(param,
+			gpio_getbit(info->membase[0], reg, PORT_PIN(pin)));
+		break;
 	default:
 		dev_err(pctldev->dev, "Invalid config param %04x\n", param);
 		return -ENOTSUPP;
@@ -515,6 +520,14 @@ static int xway_pinconf_set(struct pinctrl_dev *pctldev,
 			dev_err(pctldev->dev, "Invalid pull value %d\n", arg);
 		break;
 
+	case LTQ_PINCONF_PARAM_OUTPUT:
+		reg = GPIO_DIR(pin);
+		if (arg == 0)
+			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
+		else
+			gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
+		break;
+
 	default:
 		dev_err(pctldev->dev, "Invalid config param %04x\n", param);
 		return -ENOTSUPP;
@@ -573,6 +586,7 @@ static inline int xway_mux_apply(struct pinctrl_dev *pctrldev,
 static const struct ltq_cfg_param xway_cfg_params[] = {
 	{"lantiq,pull",		LTQ_PINCONF_PARAM_PULL},
 	{"lantiq,open-drain",	LTQ_PINCONF_PARAM_OPEN_DRAIN},
+	{"lantiq,output",	LTQ_PINCONF_PARAM_OUTPUT},
 };
 
 static struct ltq_pinmux_info xway_info = {

commit 3a6b04ca33a225dd64fcd5f4469b7b1088f16c37
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:04:57 2013 +0100

    pinctrl/lantiq: add pin_config_group_set support
    
    While converting all the boards supported by OpenWrt to OF
    I noticed that this feature is missing. Adding it makes the
    devicetrees more readable.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index c49c9dbe3917..aa4c8b815c20 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -522,9 +522,24 @@ static int xway_pinconf_set(struct pinctrl_dev *pctldev,
 	return 0;
 }
 
+int xway_pinconf_group_set(struct pinctrl_dev *pctldev,
+			unsigned selector,
+			unsigned long config)
+{
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);
+	int i, ret = 0;
+
+	for (i = 0; i < info->grps[selector].npins && !ret; i++)
+		ret = xway_pinconf_set(pctldev,
+				info->grps[selector].pins[i], config);
+
+	return ret;
+}
+
 static struct pinconf_ops xway_pinconf_ops = {
 	.pin_config_get	= xway_pinconf_get,
 	.pin_config_set	= xway_pinconf_set,
+	.pin_config_group_set = xway_pinconf_group_set,
 };
 
 static struct pinctrl_desc xway_pctrl_desc = {

commit 7541083fc4d9b24f63ea2e8e7726aeb5b2786176
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:04:56 2013 +0100

    pinctrl/lantiq: faulty bit inversion
    
    The logic of the OD bit was inverted when calling the
    pinconf get method.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 69dec9b191d9..c49c9dbe3917 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -443,7 +443,7 @@ static int xway_pinconf_get(struct pinctrl_dev *pctldev,
 		else
 			reg = GPIO_OD(pin);
 		*config = LTQ_PINCONF_PACK(param,
-			!!gpio_getbit(info->membase[0], reg, PORT_PIN(pin)));
+			!gpio_getbit(info->membase[0], reg, PORT_PIN(pin)));
 		break;
 
 	case LTQ_PINCONF_PARAM_PULL:

commit 362ba3cfb45a68d12b6b7d2584eda6df28c77bcb
Author: John Crispin <blogic@openwrt.org>
Date:   Fri Feb 1 13:04:55 2013 +0100

    pinctrl/lantiq: pinconf uses port instead of pin
    
    The XWAY pinctrl driver invalidly uses the port and not the pin
    number to work out the registers and bits to be set for the
    opendrain and pullup/down resistors.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 5f0eb04c2336..69dec9b191d9 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -441,17 +441,17 @@ static int xway_pinconf_get(struct pinctrl_dev *pctldev,
 		if (port == PORT3)
 			reg = GPIO3_OD;
 		else
-			reg = GPIO_OD(port);
+			reg = GPIO_OD(pin);
 		*config = LTQ_PINCONF_PACK(param,
-			!!gpio_getbit(info->membase[0], reg, PORT_PIN(port)));
+			!!gpio_getbit(info->membase[0], reg, PORT_PIN(pin)));
 		break;
 
 	case LTQ_PINCONF_PARAM_PULL:
 		if (port == PORT3)
 			reg = GPIO3_PUDEN;
 		else
-			reg = GPIO_PUDEN(port);
-		if (!gpio_getbit(info->membase[0], reg, PORT_PIN(port))) {
+			reg = GPIO_PUDEN(pin);
+		if (!gpio_getbit(info->membase[0], reg, PORT_PIN(pin))) {
 			*config = LTQ_PINCONF_PACK(param, 0);
 			break;
 		}
@@ -459,8 +459,8 @@ static int xway_pinconf_get(struct pinctrl_dev *pctldev,
 		if (port == PORT3)
 			reg = GPIO3_PUDSEL;
 		else
-			reg = GPIO_PUDSEL(port);
-		if (!gpio_getbit(info->membase[0], reg, PORT_PIN(port)))
+			reg = GPIO_PUDSEL(pin);
+		if (!gpio_getbit(info->membase[0], reg, PORT_PIN(pin)))
 			*config = LTQ_PINCONF_PACK(param, 2);
 		else
 			*config = LTQ_PINCONF_PACK(param, 1);
@@ -488,29 +488,29 @@ static int xway_pinconf_set(struct pinctrl_dev *pctldev,
 		if (port == PORT3)
 			reg = GPIO3_OD;
 		else
-			reg = GPIO_OD(port);
-		gpio_setbit(info->membase[0], reg, PORT_PIN(port));
+			reg = GPIO_OD(pin);
+		gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
 		break;
 
 	case LTQ_PINCONF_PARAM_PULL:
 		if (port == PORT3)
 			reg = GPIO3_PUDEN;
 		else
-			reg = GPIO_PUDEN(port);
+			reg = GPIO_PUDEN(pin);
 		if (arg == 0) {
-			gpio_clearbit(info->membase[0], reg, PORT_PIN(port));
+			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
 			break;
 		}
-		gpio_setbit(info->membase[0], reg, PORT_PIN(port));
+		gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
 
 		if (port == PORT3)
 			reg = GPIO3_PUDSEL;
 		else
-			reg = GPIO_PUDSEL(port);
+			reg = GPIO_PUDSEL(pin);
 		if (arg == 1)
-			gpio_clearbit(info->membase[0], reg, PORT_PIN(port));
+			gpio_clearbit(info->membase[0], reg, PORT_PIN(pin));
 		else if (arg == 2)
-			gpio_setbit(info->membase[0], reg, PORT_PIN(port));
+			gpio_setbit(info->membase[0], reg, PORT_PIN(pin));
 		else
 			dev_err(pctldev->dev, "Invalid pull value %d\n", arg);
 		break;

commit 9e0c1fb29a7c257a31c321c2437617b6b4d66168
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:14 2013 +0100

    pinctrl: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index 5f0eb04c2336..ae8f3a02ed97 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -9,6 +9,7 @@
  *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
  */
 
+#include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
@@ -687,11 +688,9 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Failed to get resource\n");
 		return -ENOENT;
 	}
-	xway_info.membase[0] = devm_request_and_ioremap(&pdev->dev, res);
-	if (!xway_info.membase[0]) {
-		dev_err(&pdev->dev, "Failed to remap resource\n");
-		return -ENOMEM;
-	}
+	xway_info.membase[0] = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(xway_info.membase[0]))
+		return PTR_ERR(xway_info.membase[0]);
 
 	match = of_match_device(xway_match, &pdev->dev);
 	if (match)

commit 150632b09aadf1996f5cb6c0c2620d63a01fe2de
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:10:23 2012 -0800

    Drivers: pinctrl: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Barry Song <baohua.song@csr.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index ad90984ec500..5f0eb04c2336 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -674,7 +674,7 @@ static const struct of_device_id xway_match[] = {
 };
 MODULE_DEVICE_TABLE(of, xway_match);
 
-static int __devinit pinmux_xway_probe(struct platform_device *pdev)
+static int pinmux_xway_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
 	const struct pinctrl_xway_soc *xway_soc;

commit 6bb0700bfe124f3ee245da24b5bb35152d2e6bfc
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Nov 7 13:37:08 2012 +0800

    pinctrl: Staticize pinconf_ops
    
    They are not referenced outside respective driver.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Cc: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index b9bcaec66223..ad90984ec500 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -522,7 +522,7 @@ static int xway_pinconf_set(struct pinctrl_dev *pctldev,
 	return 0;
 }
 
-struct pinconf_ops xway_pinconf_ops = {
+static struct pinconf_ops xway_pinconf_ops = {
 	.pin_config_get	= xway_pinconf_get,
 	.pin_config_set	= xway_pinconf_set,
 };

commit b51b16a36fd8fd27b2e392a86f2637deaaf4267f
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Wed Oct 10 20:59:32 2012 +0800

    pinctrl: remove duplicated include from pinctrl-xway.c
    
    Remove duplicated include.
    
    dpatch engine is used to auto generate this patch.
    (https://github.com/weiyj/dpatch)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index f8d917d40c92..b9bcaec66223 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -17,8 +17,6 @@
 #include <linux/ioport.h>
 #include <linux/io.h>
 #include <linux/device.h>
-#include <linux/module.h>
-#include <linux/io.h>
 #include <linux/platform_device.h>
 
 #include "pinctrl-lantiq.h"

commit 3f8c50c9b110dad4136ea7226cd87b0c4cdb70c8
Author: John Crispin <blogic@openwrt.org>
Date:   Tue Aug 28 12:44:59 2012 +0200

    OF: pinctrl: MIPS: lantiq: implement lantiq/xway pinctrl support
    
    Implement support for pinctrl on lantiq/xway socs. The IO core found on these
    socs has the registers for pinctrl, pinconf and gpio mixed up in the same
    register range. As the gpio_chip handling is only a few lines, the driver also
    implements the gpio functionality. This obseletes the old gpio driver that was
    located in the arch/ folder.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
new file mode 100644
index 000000000000..f8d917d40c92
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -0,0 +1,781 @@
+/*
+ *  linux/drivers/pinctrl/pinmux-xway.c
+ *  based on linux/drivers/pinctrl/pinmux-pxa910.c
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ *
+ *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include "pinctrl-lantiq.h"
+
+#include <lantiq_soc.h>
+
+/* we have 3 1/2 banks of 16 bit each */
+#define PINS			16
+#define PORT3			3
+#define PORT(x)			(x / PINS)
+#define PORT_PIN(x)		(x % PINS)
+
+/* we have 2 mux bits that can be set for each pin */
+#define MUX_ALT0	0x1
+#define MUX_ALT1	0x2
+
+/*
+ * each bank has this offset apart from the 1/2 bank that is mixed into the
+ * other 3 ranges
+ */
+#define REG_OFF			0x30
+
+/* these are the offsets to our registers */
+#define GPIO_BASE(p)		(REG_OFF * PORT(p))
+#define GPIO_OUT(p)		GPIO_BASE(p)
+#define GPIO_IN(p)		(GPIO_BASE(p) + 0x04)
+#define GPIO_DIR(p)		(GPIO_BASE(p) + 0x08)
+#define GPIO_ALT0(p)		(GPIO_BASE(p) + 0x0C)
+#define GPIO_ALT1(p)		(GPIO_BASE(p) + 0x10)
+#define GPIO_OD(p)		(GPIO_BASE(p) + 0x14)
+#define GPIO_PUDSEL(p)		(GPIO_BASE(p) + 0x1c)
+#define GPIO_PUDEN(p)		(GPIO_BASE(p) + 0x20)
+
+/* the 1/2 port needs special offsets for some registers */
+#define GPIO3_OD		(GPIO_BASE(0) + 0x24)
+#define GPIO3_PUDSEL		(GPIO_BASE(0) + 0x28)
+#define GPIO3_PUDEN		(GPIO_BASE(0) + 0x2C)
+#define GPIO3_ALT1		(GPIO_BASE(PINS) + 0x24)
+
+/* macros to help us access the registers */
+#define gpio_getbit(m, r, p)	(!!(ltq_r32(m + r) & BIT(p)))
+#define gpio_setbit(m, r, p)	ltq_w32_mask(0, BIT(p), m + r)
+#define gpio_clearbit(m, r, p)	ltq_w32_mask(BIT(p), 0, m + r)
+
+#define MFP_XWAY(a, f0, f1, f2, f3)	\
+	{				\
+		.name = #a,		\
+		.pin = a,		\
+		.func = {		\
+			XWAY_MUX_##f0,	\
+			XWAY_MUX_##f1,	\
+			XWAY_MUX_##f2,	\
+			XWAY_MUX_##f3,	\
+		},			\
+	}
+
+#define GRP_MUX(a, m, p)		\
+	{ .name = a, .mux = XWAY_MUX_##m, .pins = p, .npins = ARRAY_SIZE(p), }
+
+#define FUNC_MUX(f, m)		\
+	{ .func = f, .mux = XWAY_MUX_##m, }
+
+#define XWAY_MAX_PIN		32
+#define XR9_MAX_PIN		56
+
+enum xway_mux {
+	XWAY_MUX_GPIO = 0,
+	XWAY_MUX_SPI,
+	XWAY_MUX_ASC,
+	XWAY_MUX_PCI,
+	XWAY_MUX_CGU,
+	XWAY_MUX_EBU,
+	XWAY_MUX_JTAG,
+	XWAY_MUX_EXIN,
+	XWAY_MUX_TDM,
+	XWAY_MUX_STP,
+	XWAY_MUX_SIN,
+	XWAY_MUX_GPT,
+	XWAY_MUX_NMI,
+	XWAY_MUX_MDIO,
+	XWAY_MUX_MII,
+	XWAY_MUX_EPHY,
+	XWAY_MUX_DFE,
+	XWAY_MUX_SDIO,
+	XWAY_MUX_NONE = 0xffff,
+};
+
+static const struct ltq_mfp_pin xway_mfp[] = {
+	/*       pin    f0	f1	f2	f3   */
+	MFP_XWAY(GPIO0, GPIO,	EXIN,	NONE,	TDM),
+	MFP_XWAY(GPIO1, GPIO,	EXIN,	NONE,	NONE),
+	MFP_XWAY(GPIO2, GPIO,	CGU,	EXIN,	NONE),
+	MFP_XWAY(GPIO3, GPIO,	CGU,	NONE,	PCI),
+	MFP_XWAY(GPIO4, GPIO,	STP,	NONE,	ASC),
+	MFP_XWAY(GPIO5, GPIO,	STP,	NONE,	NONE),
+	MFP_XWAY(GPIO6, GPIO,	STP,	GPT,	ASC),
+	MFP_XWAY(GPIO7, GPIO,	CGU,	PCI,	NONE),
+	MFP_XWAY(GPIO8, GPIO,	CGU,	NMI,	NONE),
+	MFP_XWAY(GPIO9, GPIO,	ASC,	SPI,	EXIN),
+	MFP_XWAY(GPIO10, GPIO,	ASC,	SPI,	NONE),
+	MFP_XWAY(GPIO11, GPIO,	ASC,	PCI,	SPI),
+	MFP_XWAY(GPIO12, GPIO,	ASC,	NONE,	NONE),
+	MFP_XWAY(GPIO13, GPIO,	EBU,	SPI,	NONE),
+	MFP_XWAY(GPIO14, GPIO,	CGU,	PCI,	NONE),
+	MFP_XWAY(GPIO15, GPIO,	SPI,	JTAG,	NONE),
+	MFP_XWAY(GPIO16, GPIO,	SPI,	NONE,	JTAG),
+	MFP_XWAY(GPIO17, GPIO,	SPI,	NONE,	JTAG),
+	MFP_XWAY(GPIO18, GPIO,	SPI,	NONE,	JTAG),
+	MFP_XWAY(GPIO19, GPIO,	PCI,	NONE,	NONE),
+	MFP_XWAY(GPIO20, GPIO,	JTAG,	NONE,	NONE),
+	MFP_XWAY(GPIO21, GPIO,	PCI,	EBU,	GPT),
+	MFP_XWAY(GPIO22, GPIO,	SPI,	NONE,	NONE),
+	MFP_XWAY(GPIO23, GPIO,	EBU,	PCI,	STP),
+	MFP_XWAY(GPIO24, GPIO,	EBU,	TDM,	PCI),
+	MFP_XWAY(GPIO25, GPIO,	TDM,	NONE,	ASC),
+	MFP_XWAY(GPIO26, GPIO,	EBU,	NONE,	TDM),
+	MFP_XWAY(GPIO27, GPIO,	TDM,	NONE,	ASC),
+	MFP_XWAY(GPIO28, GPIO,	GPT,	NONE,	NONE),
+	MFP_XWAY(GPIO29, GPIO,	PCI,	NONE,	NONE),
+	MFP_XWAY(GPIO30, GPIO,	PCI,	NONE,	NONE),
+	MFP_XWAY(GPIO31, GPIO,	EBU,	PCI,	NONE),
+	MFP_XWAY(GPIO32, GPIO,	NONE,	NONE,	EBU),
+	MFP_XWAY(GPIO33, GPIO,	NONE,	NONE,	EBU),
+	MFP_XWAY(GPIO34, GPIO,	NONE,	NONE,	EBU),
+	MFP_XWAY(GPIO35, GPIO,	NONE,	NONE,	EBU),
+	MFP_XWAY(GPIO36, GPIO,	SIN,	NONE,	EBU),
+	MFP_XWAY(GPIO37, GPIO,	PCI,	NONE,	NONE),
+	MFP_XWAY(GPIO38, GPIO,	PCI,	NONE,	NONE),
+	MFP_XWAY(GPIO39, GPIO,	EXIN,	NONE,	NONE),
+	MFP_XWAY(GPIO40, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO41, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
+	MFP_XWAY(GPIO44, GPIO,	NONE,	NONE,	SIN),
+	MFP_XWAY(GPIO45, GPIO,	NONE,	NONE,	SIN),
+	MFP_XWAY(GPIO46, GPIO,	NONE,	NONE,	EXIN),
+	MFP_XWAY(GPIO47, GPIO,	NONE,	NONE,	SIN),
+	MFP_XWAY(GPIO48, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO49, GPIO,	EBU,	NONE,	NONE),
+	MFP_XWAY(GPIO50, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO51, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO52, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO53, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO54, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO55, GPIO,	NONE,	NONE,	NONE),
+};
+
+static const struct ltq_mfp_pin ase_mfp[] = {
+	/*       pin    f0	f1	f2	f3   */
+	MFP_XWAY(GPIO0, GPIO,	EXIN,	MII,	TDM),
+	MFP_XWAY(GPIO1, GPIO,	STP,	DFE,	EBU),
+	MFP_XWAY(GPIO2, GPIO,	STP,	DFE,	EPHY),
+	MFP_XWAY(GPIO3, GPIO,	STP,	EPHY,	EBU),
+	MFP_XWAY(GPIO4, GPIO,	GPT,	EPHY,	MII),
+	MFP_XWAY(GPIO5, GPIO,	MII,	ASC,	GPT),
+	MFP_XWAY(GPIO6, GPIO,	MII,	ASC,	EXIN),
+	MFP_XWAY(GPIO7, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO8, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO9, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO10, GPIO,	SPI,	MII,	JTAG),
+	MFP_XWAY(GPIO11, GPIO,	EBU,	CGU,	JTAG),
+	MFP_XWAY(GPIO12, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO13, GPIO,	EBU,	MII,	CGU),
+	MFP_XWAY(GPIO14, GPIO,	EBU,	SPI,	CGU),
+	MFP_XWAY(GPIO15, GPIO,	EBU,	SPI,	SDIO),
+	MFP_XWAY(GPIO16, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO17, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO18, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO19, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO20, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO21, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO22, GPIO,	EBU,	MII,	CGU),
+	MFP_XWAY(GPIO23, GPIO,	EBU,	MII,	CGU),
+	MFP_XWAY(GPIO24, GPIO,	EBU,	NONE,	MII),
+	MFP_XWAY(GPIO25, GPIO,	EBU,	MII,	GPT),
+	MFP_XWAY(GPIO26, GPIO,	EBU,	MII,	SDIO),
+	MFP_XWAY(GPIO27, GPIO,	EBU,	NONE,	MII),
+	MFP_XWAY(GPIO28, GPIO,	MII,	EBU,	SDIO),
+	MFP_XWAY(GPIO29, GPIO,	EBU,	MII,	EXIN),
+	MFP_XWAY(GPIO30, GPIO,	NONE,	NONE,	NONE),
+	MFP_XWAY(GPIO31, GPIO,	NONE,	NONE,	NONE),
+};
+
+static const unsigned pins_jtag[] = {GPIO15, GPIO16, GPIO17, GPIO19, GPIO35};
+static const unsigned pins_asc0[] = {GPIO11, GPIO12};
+static const unsigned pins_asc0_cts_rts[] = {GPIO9, GPIO10};
+static const unsigned pins_stp[] = {GPIO4, GPIO5, GPIO6};
+static const unsigned pins_nmi[] = {GPIO8};
+static const unsigned pins_mdio[] = {GPIO42, GPIO43};
+
+static const unsigned pins_ebu_a24[] = {GPIO13};
+static const unsigned pins_ebu_clk[] = {GPIO21};
+static const unsigned pins_ebu_cs1[] = {GPIO23};
+static const unsigned pins_ebu_a23[] = {GPIO24};
+static const unsigned pins_ebu_wait[] = {GPIO26};
+static const unsigned pins_ebu_a25[] = {GPIO31};
+static const unsigned pins_ebu_rdy[] = {GPIO48};
+static const unsigned pins_ebu_rd[] = {GPIO49};
+
+static const unsigned pins_nand_ale[] = {GPIO13};
+static const unsigned pins_nand_cs1[] = {GPIO23};
+static const unsigned pins_nand_cle[] = {GPIO24};
+static const unsigned pins_nand_rdy[] = {GPIO48};
+static const unsigned pins_nand_rd[] = {GPIO49};
+
+static const unsigned pins_exin0[] = {GPIO0};
+static const unsigned pins_exin1[] = {GPIO1};
+static const unsigned pins_exin2[] = {GPIO2};
+static const unsigned pins_exin3[] = {GPIO39};
+static const unsigned pins_exin4[] = {GPIO46};
+static const unsigned pins_exin5[] = {GPIO9};
+
+static const unsigned pins_spi[] = {GPIO16, GPIO17, GPIO18};
+static const unsigned pins_spi_cs1[] = {GPIO15};
+static const unsigned pins_spi_cs2[] = {GPIO21};
+static const unsigned pins_spi_cs3[] = {GPIO13};
+static const unsigned pins_spi_cs4[] = {GPIO10};
+static const unsigned pins_spi_cs5[] = {GPIO9};
+static const unsigned pins_spi_cs6[] = {GPIO11};
+
+static const unsigned pins_gpt1[] = {GPIO28};
+static const unsigned pins_gpt2[] = {GPIO21};
+static const unsigned pins_gpt3[] = {GPIO6};
+
+static const unsigned pins_clkout0[] = {GPIO8};
+static const unsigned pins_clkout1[] = {GPIO7};
+static const unsigned pins_clkout2[] = {GPIO3};
+static const unsigned pins_clkout3[] = {GPIO2};
+
+static const unsigned pins_pci_gnt1[] = {GPIO30};
+static const unsigned pins_pci_gnt2[] = {GPIO23};
+static const unsigned pins_pci_gnt3[] = {GPIO19};
+static const unsigned pins_pci_gnt4[] = {GPIO38};
+static const unsigned pins_pci_req1[] = {GPIO29};
+static const unsigned pins_pci_req2[] = {GPIO31};
+static const unsigned pins_pci_req3[] = {GPIO3};
+static const unsigned pins_pci_req4[] = {GPIO37};
+
+static const unsigned ase_pins_jtag[] = {GPIO7, GPIO8, GPIO9, GPIO10, GPIO11};
+static const unsigned ase_pins_asc[] = {GPIO5, GPIO6};
+static const unsigned ase_pins_stp[] = {GPIO1, GPIO2, GPIO3};
+static const unsigned ase_pins_ephy[] = {GPIO2, GPIO3, GPIO4};
+static const unsigned ase_pins_dfe[] = {GPIO1, GPIO2};
+
+static const unsigned ase_pins_spi[] = {GPIO8, GPIO9, GPIO10};
+static const unsigned ase_pins_spi_cs1[] = {GPIO7};
+static const unsigned ase_pins_spi_cs2[] = {GPIO15};
+static const unsigned ase_pins_spi_cs3[] = {GPIO14};
+
+static const unsigned ase_pins_exin0[] = {GPIO6};
+static const unsigned ase_pins_exin1[] = {GPIO29};
+static const unsigned ase_pins_exin2[] = {GPIO0};
+
+static const unsigned ase_pins_gpt1[] = {GPIO5};
+static const unsigned ase_pins_gpt2[] = {GPIO4};
+static const unsigned ase_pins_gpt3[] = {GPIO25};
+
+static const struct ltq_pin_group xway_grps[] = {
+	GRP_MUX("exin0", EXIN, pins_exin0),
+	GRP_MUX("exin1", EXIN, pins_exin1),
+	GRP_MUX("exin2", EXIN, pins_exin2),
+	GRP_MUX("jtag", JTAG, pins_jtag),
+	GRP_MUX("ebu a23", EBU, pins_ebu_a23),
+	GRP_MUX("ebu a24", EBU, pins_ebu_a24),
+	GRP_MUX("ebu a25", EBU, pins_ebu_a25),
+	GRP_MUX("ebu clk", EBU, pins_ebu_clk),
+	GRP_MUX("ebu cs1", EBU, pins_ebu_cs1),
+	GRP_MUX("ebu wait", EBU, pins_ebu_wait),
+	GRP_MUX("nand ale", EBU, pins_nand_ale),
+	GRP_MUX("nand cs1", EBU, pins_nand_cs1),
+	GRP_MUX("nand cle", EBU, pins_nand_cle),
+	GRP_MUX("spi", SPI, pins_spi),
+	GRP_MUX("spi_cs1", SPI, pins_spi_cs1),
+	GRP_MUX("spi_cs2", SPI, pins_spi_cs2),
+	GRP_MUX("spi_cs3", SPI, pins_spi_cs3),
+	GRP_MUX("spi_cs4", SPI, pins_spi_cs4),
+	GRP_MUX("spi_cs5", SPI, pins_spi_cs5),
+	GRP_MUX("spi_cs6", SPI, pins_spi_cs6),
+	GRP_MUX("asc0", ASC, pins_asc0),
+	GRP_MUX("asc0 cts rts", ASC, pins_asc0_cts_rts),
+	GRP_MUX("stp", STP, pins_stp),
+	GRP_MUX("nmi", NMI, pins_nmi),
+	GRP_MUX("gpt1", GPT, pins_gpt1),
+	GRP_MUX("gpt2", GPT, pins_gpt2),
+	GRP_MUX("gpt3", GPT, pins_gpt3),
+	GRP_MUX("clkout0", CGU, pins_clkout0),
+	GRP_MUX("clkout1", CGU, pins_clkout1),
+	GRP_MUX("clkout2", CGU, pins_clkout2),
+	GRP_MUX("clkout3", CGU, pins_clkout3),
+	GRP_MUX("gnt1", PCI, pins_pci_gnt1),
+	GRP_MUX("gnt2", PCI, pins_pci_gnt2),
+	GRP_MUX("gnt3", PCI, pins_pci_gnt3),
+	GRP_MUX("req1", PCI, pins_pci_req1),
+	GRP_MUX("req2", PCI, pins_pci_req2),
+	GRP_MUX("req3", PCI, pins_pci_req3),
+/* xrx only */
+	GRP_MUX("nand rdy", EBU, pins_nand_rdy),
+	GRP_MUX("nand rd", EBU, pins_nand_rd),
+	GRP_MUX("exin3", EXIN, pins_exin3),
+	GRP_MUX("exin4", EXIN, pins_exin4),
+	GRP_MUX("exin5", EXIN, pins_exin5),
+	GRP_MUX("gnt4", PCI, pins_pci_gnt4),
+	GRP_MUX("req4", PCI, pins_pci_gnt4),
+	GRP_MUX("mdio", MDIO, pins_mdio),
+};
+
+static const struct ltq_pin_group ase_grps[] = {
+	GRP_MUX("exin0", EXIN, ase_pins_exin0),
+	GRP_MUX("exin1", EXIN, ase_pins_exin1),
+	GRP_MUX("exin2", EXIN, ase_pins_exin2),
+	GRP_MUX("jtag", JTAG, ase_pins_jtag),
+	GRP_MUX("stp", STP, ase_pins_stp),
+	GRP_MUX("asc", ASC, ase_pins_asc),
+	GRP_MUX("gpt1", GPT, ase_pins_gpt1),
+	GRP_MUX("gpt2", GPT, ase_pins_gpt2),
+	GRP_MUX("gpt3", GPT, ase_pins_gpt3),
+	GRP_MUX("ephy", EPHY, ase_pins_ephy),
+	GRP_MUX("dfe", DFE, ase_pins_dfe),
+	GRP_MUX("spi", SPI, ase_pins_spi),
+	GRP_MUX("spi_cs1", SPI, ase_pins_spi_cs1),
+	GRP_MUX("spi_cs2", SPI, ase_pins_spi_cs2),
+	GRP_MUX("spi_cs3", SPI, ase_pins_spi_cs3),
+};
+
+static const char * const xway_pci_grps[] = {"gnt1", "gnt2",
+						"gnt3", "req1",
+						"req2", "req3"};
+static const char * const xway_spi_grps[] = {"spi", "spi_cs1",
+						"spi_cs2", "spi_cs3",
+						"spi_cs4", "spi_cs5",
+						"spi_cs6"};
+static const char * const xway_cgu_grps[] = {"clkout0", "clkout1",
+						"clkout2", "clkout3"};
+static const char * const xway_ebu_grps[] = {"ebu a23", "ebu a24",
+						"ebu a25", "ebu cs1",
+						"ebu wait", "ebu clk",
+						"nand ale", "nand cs1",
+						"nand cle"};
+static const char * const xway_exin_grps[] = {"exin0", "exin1", "exin2"};
+static const char * const xway_gpt_grps[] = {"gpt1", "gpt2", "gpt3"};
+static const char * const xway_asc_grps[] = {"asc0", "asc0 cts rts"};
+static const char * const xway_jtag_grps[] = {"jtag"};
+static const char * const xway_stp_grps[] = {"stp"};
+static const char * const xway_nmi_grps[] = {"nmi"};
+
+/* ar9/vr9/gr9 */
+static const char * const xrx_mdio_grps[] = {"mdio"};
+static const char * const xrx_ebu_grps[] = {"ebu a23", "ebu a24",
+						"ebu a25", "ebu cs1",
+						"ebu wait", "ebu clk",
+						"nand ale", "nand cs1",
+						"nand cle", "nand rdy",
+						"nand rd"};
+static const char * const xrx_exin_grps[] = {"exin0", "exin1", "exin2",
+						"exin3", "exin4", "exin5"};
+static const char * const xrx_pci_grps[] = {"gnt1", "gnt2",
+						"gnt3", "gnt4",
+						"req1", "req2",
+						"req3", "req4"};
+
+/* ase */
+static const char * const ase_exin_grps[] = {"exin0", "exin1", "exin2"};
+static const char * const ase_gpt_grps[] = {"gpt1", "gpt2", "gpt3"};
+static const char * const ase_dfe_grps[] = {"dfe"};
+static const char * const ase_ephy_grps[] = {"ephy"};
+static const char * const ase_asc_grps[] = {"asc"};
+static const char * const ase_jtag_grps[] = {"jtag"};
+static const char * const ase_stp_grps[] = {"stp"};
+static const char * const ase_spi_grps[] = {"spi", "spi_cs1",
+						"spi_cs2", "spi_cs3"};
+
+static const struct ltq_pmx_func danube_funcs[] = {
+	{"spi",		ARRAY_AND_SIZE(xway_spi_grps)},
+	{"asc",		ARRAY_AND_SIZE(xway_asc_grps)},
+	{"cgu",		ARRAY_AND_SIZE(xway_cgu_grps)},
+	{"jtag",	ARRAY_AND_SIZE(xway_jtag_grps)},
+	{"exin",	ARRAY_AND_SIZE(xway_exin_grps)},
+	{"stp",		ARRAY_AND_SIZE(xway_stp_grps)},
+	{"gpt",		ARRAY_AND_SIZE(xway_gpt_grps)},
+	{"nmi",		ARRAY_AND_SIZE(xway_nmi_grps)},
+	{"pci",		ARRAY_AND_SIZE(xway_pci_grps)},
+	{"ebu",		ARRAY_AND_SIZE(xway_ebu_grps)},
+};
+
+static const struct ltq_pmx_func xrx_funcs[] = {
+	{"spi",		ARRAY_AND_SIZE(xway_spi_grps)},
+	{"asc",		ARRAY_AND_SIZE(xway_asc_grps)},
+	{"cgu",		ARRAY_AND_SIZE(xway_cgu_grps)},
+	{"jtag",	ARRAY_AND_SIZE(xway_jtag_grps)},
+	{"exin",	ARRAY_AND_SIZE(xrx_exin_grps)},
+	{"stp",		ARRAY_AND_SIZE(xway_stp_grps)},
+	{"gpt",		ARRAY_AND_SIZE(xway_gpt_grps)},
+	{"nmi",		ARRAY_AND_SIZE(xway_nmi_grps)},
+	{"pci",		ARRAY_AND_SIZE(xrx_pci_grps)},
+	{"ebu",		ARRAY_AND_SIZE(xrx_ebu_grps)},
+	{"mdio",	ARRAY_AND_SIZE(xrx_mdio_grps)},
+};
+
+static const struct ltq_pmx_func ase_funcs[] = {
+	{"spi",		ARRAY_AND_SIZE(ase_spi_grps)},
+	{"asc",		ARRAY_AND_SIZE(ase_asc_grps)},
+	{"jtag",	ARRAY_AND_SIZE(ase_jtag_grps)},
+	{"exin",	ARRAY_AND_SIZE(ase_exin_grps)},
+	{"stp",		ARRAY_AND_SIZE(ase_stp_grps)},
+	{"gpt",		ARRAY_AND_SIZE(ase_gpt_grps)},
+	{"ephy",	ARRAY_AND_SIZE(ase_ephy_grps)},
+	{"dfe",		ARRAY_AND_SIZE(ase_dfe_grps)},
+};
+
+/* ---------  pinconf related code --------- */
+static int xway_pinconf_get(struct pinctrl_dev *pctldev,
+				unsigned pin,
+				unsigned long *config)
+{
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);
+	enum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(*config);
+	int port = PORT(pin);
+	u32 reg;
+
+	switch (param) {
+	case LTQ_PINCONF_PARAM_OPEN_DRAIN:
+		if (port == PORT3)
+			reg = GPIO3_OD;
+		else
+			reg = GPIO_OD(port);
+		*config = LTQ_PINCONF_PACK(param,
+			!!gpio_getbit(info->membase[0], reg, PORT_PIN(port)));
+		break;
+
+	case LTQ_PINCONF_PARAM_PULL:
+		if (port == PORT3)
+			reg = GPIO3_PUDEN;
+		else
+			reg = GPIO_PUDEN(port);
+		if (!gpio_getbit(info->membase[0], reg, PORT_PIN(port))) {
+			*config = LTQ_PINCONF_PACK(param, 0);
+			break;
+		}
+
+		if (port == PORT3)
+			reg = GPIO3_PUDSEL;
+		else
+			reg = GPIO_PUDSEL(port);
+		if (!gpio_getbit(info->membase[0], reg, PORT_PIN(port)))
+			*config = LTQ_PINCONF_PACK(param, 2);
+		else
+			*config = LTQ_PINCONF_PACK(param, 1);
+		break;
+
+	default:
+		dev_err(pctldev->dev, "Invalid config param %04x\n", param);
+		return -ENOTSUPP;
+	}
+	return 0;
+}
+
+static int xway_pinconf_set(struct pinctrl_dev *pctldev,
+				unsigned pin,
+				unsigned long config)
+{
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);
+	enum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(config);
+	int arg = LTQ_PINCONF_UNPACK_ARG(config);
+	int port = PORT(pin);
+	u32 reg;
+
+	switch (param) {
+	case LTQ_PINCONF_PARAM_OPEN_DRAIN:
+		if (port == PORT3)
+			reg = GPIO3_OD;
+		else
+			reg = GPIO_OD(port);
+		gpio_setbit(info->membase[0], reg, PORT_PIN(port));
+		break;
+
+	case LTQ_PINCONF_PARAM_PULL:
+		if (port == PORT3)
+			reg = GPIO3_PUDEN;
+		else
+			reg = GPIO_PUDEN(port);
+		if (arg == 0) {
+			gpio_clearbit(info->membase[0], reg, PORT_PIN(port));
+			break;
+		}
+		gpio_setbit(info->membase[0], reg, PORT_PIN(port));
+
+		if (port == PORT3)
+			reg = GPIO3_PUDSEL;
+		else
+			reg = GPIO_PUDSEL(port);
+		if (arg == 1)
+			gpio_clearbit(info->membase[0], reg, PORT_PIN(port));
+		else if (arg == 2)
+			gpio_setbit(info->membase[0], reg, PORT_PIN(port));
+		else
+			dev_err(pctldev->dev, "Invalid pull value %d\n", arg);
+		break;
+
+	default:
+		dev_err(pctldev->dev, "Invalid config param %04x\n", param);
+		return -ENOTSUPP;
+	}
+	return 0;
+}
+
+struct pinconf_ops xway_pinconf_ops = {
+	.pin_config_get	= xway_pinconf_get,
+	.pin_config_set	= xway_pinconf_set,
+};
+
+static struct pinctrl_desc xway_pctrl_desc = {
+	.owner		= THIS_MODULE,
+	.confops	= &xway_pinconf_ops,
+};
+
+static inline int xway_mux_apply(struct pinctrl_dev *pctrldev,
+				int pin, int mux)
+{
+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
+	int port = PORT(pin);
+	u32 alt1_reg = GPIO_ALT1(pin);
+
+	if (port == PORT3)
+		alt1_reg = GPIO3_ALT1;
+
+	if (mux & MUX_ALT0)
+		gpio_setbit(info->membase[0], GPIO_ALT0(pin), PORT_PIN(pin));
+	else
+		gpio_clearbit(info->membase[0], GPIO_ALT0(pin), PORT_PIN(pin));
+
+	if (mux & MUX_ALT1)
+		gpio_setbit(info->membase[0], alt1_reg, PORT_PIN(pin));
+	else
+		gpio_clearbit(info->membase[0], alt1_reg, PORT_PIN(pin));
+
+	return 0;
+}
+
+static const struct ltq_cfg_param xway_cfg_params[] = {
+	{"lantiq,pull",		LTQ_PINCONF_PARAM_PULL},
+	{"lantiq,open-drain",	LTQ_PINCONF_PARAM_OPEN_DRAIN},
+};
+
+static struct ltq_pinmux_info xway_info = {
+	.desc		= &xway_pctrl_desc,
+	.apply_mux	= xway_mux_apply,
+	.params		= xway_cfg_params,
+	.num_params	= ARRAY_SIZE(xway_cfg_params),
+};
+
+/* ---------  gpio_chip related code --------- */
+static void xway_gpio_set(struct gpio_chip *chip, unsigned int pin, int val)
+{
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+
+	if (val)
+		gpio_setbit(info->membase[0], GPIO_OUT(pin), PORT_PIN(pin));
+	else
+		gpio_clearbit(info->membase[0], GPIO_OUT(pin), PORT_PIN(pin));
+}
+
+static int xway_gpio_get(struct gpio_chip *chip, unsigned int pin)
+{
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+
+	return gpio_getbit(info->membase[0], GPIO_IN(pin), PORT_PIN(pin));
+}
+
+static int xway_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)
+{
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+
+	gpio_clearbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));
+
+	return 0;
+}
+
+static int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)
+{
+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
+
+	gpio_setbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));
+	xway_gpio_set(chip, pin, val);
+
+	return 0;
+}
+
+static int xway_gpio_req(struct gpio_chip *chip, unsigned offset)
+{
+	int gpio = chip->base + offset;
+
+	return pinctrl_request_gpio(gpio);
+}
+
+static void xway_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	int gpio = chip->base + offset;
+
+	pinctrl_free_gpio(gpio);
+}
+
+static struct gpio_chip xway_chip = {
+	.label = "gpio-xway",
+	.direction_input = xway_gpio_dir_in,
+	.direction_output = xway_gpio_dir_out,
+	.get = xway_gpio_get,
+	.set = xway_gpio_set,
+	.request = xway_gpio_req,
+	.free = xway_gpio_free,
+	.base = -1,
+};
+
+
+/* --------- register the pinctrl layer --------- */
+static const unsigned xway_exin_pin_map[] = {GPIO0, GPIO1, GPIO2, GPIO39, GPIO46, GPIO9};
+static const unsigned ase_exin_pins_map[] = {GPIO6, GPIO29, GPIO0};
+
+static struct pinctrl_xway_soc {
+	int pin_count;
+	const struct ltq_mfp_pin *mfp;
+	const struct ltq_pin_group *grps;
+	unsigned int num_grps;
+	const struct ltq_pmx_func *funcs;
+	unsigned int num_funcs;
+	const unsigned *exin;
+	unsigned int num_exin;
+} soc_cfg[] = {
+	/* legacy xway */
+	{XWAY_MAX_PIN, xway_mfp,
+		xway_grps, ARRAY_SIZE(xway_grps),
+		danube_funcs, ARRAY_SIZE(danube_funcs),
+		xway_exin_pin_map, 3},
+	/* xway xr9 series */
+	{XR9_MAX_PIN, xway_mfp,
+		xway_grps, ARRAY_SIZE(xway_grps),
+		xrx_funcs, ARRAY_SIZE(xrx_funcs),
+		xway_exin_pin_map, 6},
+	/* xway ase series */
+	{XWAY_MAX_PIN, ase_mfp,
+		ase_grps, ARRAY_SIZE(ase_grps),
+		ase_funcs, ARRAY_SIZE(ase_funcs),
+		ase_exin_pins_map, 3},
+};
+
+static struct pinctrl_gpio_range xway_gpio_range = {
+	.name	= "XWAY GPIO",
+	.gc	= &xway_chip,
+};
+
+static const struct of_device_id xway_match[] = {
+	{ .compatible = "lantiq,pinctrl-xway", .data = &soc_cfg[0]},
+	{ .compatible = "lantiq,pinctrl-xr9", .data = &soc_cfg[1]},
+	{ .compatible = "lantiq,pinctrl-ase", .data = &soc_cfg[2]},
+	{},
+};
+MODULE_DEVICE_TABLE(of, xway_match);
+
+static int __devinit pinmux_xway_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	const struct pinctrl_xway_soc *xway_soc;
+	struct resource *res;
+	int ret, i;
+
+	/* get and remap our register range */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Failed to get resource\n");
+		return -ENOENT;
+	}
+	xway_info.membase[0] = devm_request_and_ioremap(&pdev->dev, res);
+	if (!xway_info.membase[0]) {
+		dev_err(&pdev->dev, "Failed to remap resource\n");
+		return -ENOMEM;
+	}
+
+	match = of_match_device(xway_match, &pdev->dev);
+	if (match)
+		xway_soc = (const struct pinctrl_xway_soc *) match->data;
+	else
+		xway_soc = &soc_cfg[0];
+
+	/* find out how many pads we have */
+	xway_chip.ngpio = xway_soc->pin_count;
+
+	/* load our pad descriptors */
+	xway_info.pads = devm_kzalloc(&pdev->dev,
+			sizeof(struct pinctrl_pin_desc) * xway_chip.ngpio,
+			GFP_KERNEL);
+	if (!xway_info.pads) {
+		dev_err(&pdev->dev, "Failed to allocate pads\n");
+		return -ENOMEM;
+	}
+	for (i = 0; i < xway_chip.ngpio; i++) {
+		/* strlen("ioXY") + 1 = 5 */
+		char *name = devm_kzalloc(&pdev->dev, 5, GFP_KERNEL);
+
+		if (!name) {
+			dev_err(&pdev->dev, "Failed to allocate pad name\n");
+			return -ENOMEM;
+		}
+		snprintf(name, 5, "io%d", i);
+		xway_info.pads[i].number = GPIO0 + i;
+		xway_info.pads[i].name = name;
+	}
+	xway_pctrl_desc.pins = xway_info.pads;
+
+	/* load the gpio chip */
+	xway_chip.dev = &pdev->dev;
+	of_gpiochip_add(&xway_chip);
+	ret = gpiochip_add(&xway_chip);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register gpio chip\n");
+		return ret;
+	}
+
+	/* setup the data needed by pinctrl */
+	xway_pctrl_desc.name	= dev_name(&pdev->dev);
+	xway_pctrl_desc.npins	= xway_chip.ngpio;
+
+	xway_info.num_pads	= xway_chip.ngpio;
+	xway_info.num_mfp	= xway_chip.ngpio;
+	xway_info.mfp		= xway_soc->mfp;
+	xway_info.grps		= xway_soc->grps;
+	xway_info.num_grps	= xway_soc->num_grps;
+	xway_info.funcs		= xway_soc->funcs;
+	xway_info.num_funcs	= xway_soc->num_funcs;
+	xway_info.exin		= xway_soc->exin;
+	xway_info.num_exin	= xway_soc->num_exin;
+
+	/* register with the generic lantiq layer */
+	ret = ltq_pinctrl_register(pdev, &xway_info);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register pinctrl driver\n");
+		return ret;
+	}
+
+	/* finish with registering the gpio range in pinctrl */
+	xway_gpio_range.npins = xway_chip.ngpio;
+	xway_gpio_range.base = xway_chip.base;
+	pinctrl_add_gpio_range(xway_info.pctrl, &xway_gpio_range);
+	dev_info(&pdev->dev, "Init done\n");
+	return 0;
+}
+
+static struct platform_driver pinmux_xway_driver = {
+	.probe	= pinmux_xway_probe,
+	.driver = {
+		.name	= "pinctrl-xway",
+		.owner	= THIS_MODULE,
+		.of_match_table = xway_match,
+	},
+};
+
+static int __init pinmux_xway_init(void)
+{
+	return platform_driver_register(&pinmux_xway_driver);
+}
+
+core_initcall_sync(pinmux_xway_init);
