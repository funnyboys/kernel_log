commit c72bed23b9e45accdeab626cf2cb2bd08d846f3e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Dec 16 21:51:18 2019 +0100

    pinctrl: Allow modules to use pinctrl_[un]register_mappings
    
    Currently only the drivers/pinctrl/devicetree.c code allows registering
    pinctrl-mappings which may later be unregistered, all other mappings
    are assumed to be permanent.
    
    Non-dt platforms may also want to register pinctrl mappings from code which
    is build as a module, which requires being able to unregister the mapping
    when the module is unloaded to avoid dangling pointers.
    
    To allow unregistering the mappings the devicetree code uses 2 internal
    functions: pinctrl_register_map and pinctrl_unregister_map.
    
    pinctrl_register_map allows the devicetree code to tell the core to
    not memdup the mappings as it retains ownership of them and
    pinctrl_unregister_map does the unregistering, note this only works
    when the mappings where not memdupped.
    
    The only code relying on the memdup/shallow-copy done by
    pinctrl_register_mappings is arch/arm/mach-u300/core.c this commit
    replaces the __initdata with const, so that the shallow-copy is no
    longer necessary.
    
    After that we can get rid of the internal pinctrl_unregister_map function
    and just use pinctrl_register_mappings directly everywhere.
    
    This commit also renames pinctrl_unregister_map to
    pinctrl_unregister_mappings so that its naming matches its
    pinctrl_register_mappings counter-part and exports it.
    
    Together these 2 changes will allow non-dt platform code to
    register pinctrl-mappings from modules without breaking things on
    module unload (as they can now unregister the mapping on unload).
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20191216205122.1850923-2-hdegoede@redhat.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 7f34167a0405..840103c40c14 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -236,10 +236,6 @@ extern struct pinctrl_gpio_range *
 pinctrl_find_gpio_range_from_pin_nolock(struct pinctrl_dev *pctldev,
 					unsigned int pin);
 
-int pinctrl_register_map(const struct pinctrl_map *maps, unsigned num_maps,
-			 bool dup);
-void pinctrl_unregister_map(const struct pinctrl_map *map);
-
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
 extern int pinctrl_force_default(struct pinctrl_dev *pctldev);
 

commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 4a0526e567df..7f34167a0405 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Core private header for the pin control subsystem
  *
@@ -5,8 +6,6 @@
  * Written on behalf of Linaro for ST-Ericsson
  *
  * Author: Linus Walleij <linus.walleij@linaro.org>
- *
- * License terms: GNU General Public License (GPL) version 2
  */
 
 #include <linux/kref.h>

commit 93639058b2af462a9871159be1afe60eab59431e
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 5 02:10:18 2018 -0700

    pinctrl: core: Remove broken remove_last group and pinmux functions
    
    With no users left for these functions let's remove them.
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Cc: Christ van Willegen <cvwillegen@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@linaro.org>
    Cc: Jacopo Mondi <jacopo+renesas@jmondi.org>
    Cc: Paul Cercueil <paul@crapouillou.net>
    Cc: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-By: H. Nikolaus Schaller <hns@goldelico.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 8cf2eba17c8c..4a0526e567df 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -218,12 +218,6 @@ int pinctrl_generic_add_group(struct pinctrl_dev *pctldev, const char *name,
 int pinctrl_generic_remove_group(struct pinctrl_dev *pctldev,
 				 unsigned int group_selector);
 
-static inline int
-pinctrl_generic_remove_last_group(struct pinctrl_dev *pctldev)
-{
-	return pinctrl_generic_remove_group(pctldev, pctldev->num_groups - 1);
-}
-
 #endif	/* CONFIG_GENERIC_PINCTRL_GROUPS */
 
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);

commit a9a1d2a7827c9cf780966d0879c73ef5a91380e9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Sep 22 11:02:10 2017 +0200

    pinctrl/gpio: Unify namespace for cross-calls
    
    The pinctrl_request_gpio() and pinctrl_free_gpio() break the nice
    namespacing in the other cross-calls like pinctrl_gpio_foo().
    Just rename them and all references so we have one namespace
    with all cross-calls under pinctrl_gpio_*().
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 7880c3adc450..8cf2eba17c8c 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -154,7 +154,7 @@ struct pinctrl_setting {
  *	or pin, and each of these will increment the @usecount.
  * @mux_owner: The name of device that called pinctrl_get().
  * @mux_setting: The most recent selected mux setting for this pin, if any.
- * @gpio_owner: If pinctrl_request_gpio() was called for this pin, this is
+ * @gpio_owner: If pinctrl_gpio_request() was called for this pin, this is
  *	the name of the GPIO that "owns" this pin.
  */
 struct pin_desc {

commit 3f713b7c223ebe5094973ce6e0272bd97363b552
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Aug 4 11:22:31 2017 +0900

    pinctrl: move const qualifier before struct
    
    Update subsystem wide for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 1c35de59a658..7880c3adc450 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -179,7 +179,7 @@ struct pin_desc {
  */
 struct pinctrl_maps {
 	struct list_head node;
-	struct pinctrl_map const *maps;
+	const struct pinctrl_map *maps;
 	unsigned num_maps;
 };
 
@@ -243,9 +243,9 @@ extern struct pinctrl_gpio_range *
 pinctrl_find_gpio_range_from_pin_nolock(struct pinctrl_dev *pctldev,
 					unsigned int pin);
 
-int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
+int pinctrl_register_map(const struct pinctrl_map *maps, unsigned num_maps,
 			 bool dup);
-void pinctrl_unregister_map(struct pinctrl_map const *map);
+void pinctrl_unregister_map(const struct pinctrl_map *map);
 
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
 extern int pinctrl_force_default(struct pinctrl_dev *pctldev);

commit 950b0d91dc108f54bccca5a2f75bb46f2df63d29
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 11 14:13:34 2017 -0800

    pinctrl: core: Fix regression caused by delayed work for hogs
    
    Commit df61b366af26 ("pinctrl: core: Use delayed work for hogs") caused a
    regression at least with sh-pfc that is also a GPIO controller as
    noted by Geert Uytterhoeven <geert@linux-m68k.org>.
    
    As the original pinctrl_register() has issues calling pin controller
    driver functions early before the controller has finished registering,
    we can't just revert commit df61b366af26. That would break the drivers
    using GENERIC_PINCTRL_GROUPS or GENERIC_PINMUX_FUNCTIONS.
    
    So let's fix the issue with the following steps as a single patch:
    
    1. Revert the late_init parts of commit df61b366af26.
    
       The late_init clearly won't work and we have to just give up
       on fixing pinctrl_register() for GENERIC_PINCTRL_GROUPS and
       GENERIC_PINMUX_FUNCTIONS.
    
    2. Split pinctrl_register() into two parts
    
       By splitting pinctrl_register() into pinctrl_init_controller()
       and pinctrl_create_and_start() we have better control over when
       it's safe to call pinctrl_create().
    
    3. Introduce a new pinctrl_register_and_init() function
    
       As suggested by Linus Walleij <linus.walleij@linaro.org>, we
       can just introduce a new function for the controllers that need
       pinctrl_create() called later.
    
    4. Convert the four known problem cases to use new function
    
       Let's convert pinctrl-imx, pinctrl-single, sh-pfc and ti-iodelay
       to use the new function to fix the issues. The rest of the drivers
       can be converted later. Let's also update Documentation/pinctrl.txt
       accordingly because of the known issues with pinctrl_register().
    
    Fixes: df61b366af26 ("pinctrl: core: Use delayed work for hogs")
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Gary Bisson <gary.bisson@boundarydevices.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index ad812a2d7248..1c35de59a658 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -37,7 +37,6 @@ struct pinctrl_gpio_range;
  * @p: result of pinctrl_get() for this device
  * @hog_default: default state for pins hogged by this device
  * @hog_sleep: sleep state for pins hogged by this device
- * @late_init: delayed work for pin controller to finish registration
  * @mutex: mutex taken on each pin controller specific action
  * @device_root: debugfs root for this device
  */
@@ -60,7 +59,6 @@ struct pinctrl_dev {
 	struct pinctrl *p;
 	struct pinctrl_state *hog_default;
 	struct pinctrl_state *hog_sleep;
-	struct delayed_work late_init;
 	struct mutex mutex;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;

commit a76edc89b100e4fefb2a5c00cd8cd557437659e7
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 27 09:20:01 2016 -0800

    pinctrl: core: Add generic pinctrl functions for managing groups
    
    We can add generic helpers for function handling for cases where the pin
    controller driver does not need to use static arrays.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    [Renamed the Kconfig item and moved things around]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index b04c59bf9701..ad812a2d7248 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -26,6 +26,8 @@ struct pinctrl_gpio_range;
  *	this radix tree
  * @pin_group_tree: optionally each pin group can be stored in this radix tree
  * @num_groups: optionally number of groups can be kept here
+ * @pin_function_tree: optionally each function can be stored in this radix tree
+ * @num_functions: optionally number of functions can be kept here
  * @gpio_ranges: a list of GPIO ranges that is handled by this pin controller,
  *	ranges are added to this list at runtime
  * @dev: the device entry for this pin controller
@@ -46,6 +48,10 @@ struct pinctrl_dev {
 #ifdef CONFIG_GENERIC_PINCTRL_GROUPS
 	struct radix_tree_root pin_group_tree;
 	unsigned int num_groups;
+#endif
+#ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS
+	struct radix_tree_root pin_function_tree;
+	unsigned int num_functions;
 #endif
 	struct list_head gpio_ranges;
 	struct device *dev;

commit c033a718f615b6b3ddc83ce3e0a217c30bd09cb5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Dec 30 15:04:43 2016 +0100

    pinctrl: stricten up generic group code
    
    Rename the symbol PINCTRL_GENERIC to PINCTRL_GENERIC_GROUPS since
    it all pertains to groups. Replace everywhere.
    
    ifdef out the radix tree and the struct when not using the
    generic groups.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index af98b6313902..b04c59bf9701 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -43,8 +43,10 @@ struct pinctrl_dev {
 	struct list_head node;
 	struct pinctrl_desc *desc;
 	struct radix_tree_root pin_desc_tree;
+#ifdef CONFIG_GENERIC_PINCTRL_GROUPS
 	struct radix_tree_root pin_group_tree;
 	unsigned int num_groups;
+#endif
 	struct list_head gpio_ranges;
 	struct device *dev;
 	struct module *owner;
@@ -165,6 +167,20 @@ struct pin_desc {
 #endif
 };
 
+/**
+ * struct pinctrl_maps - a list item containing part of the mapping table
+ * @node: mapping table list node
+ * @maps: array of mapping table entries
+ * @num_maps: the number of entries in @maps
+ */
+struct pinctrl_maps {
+	struct list_head node;
+	struct pinctrl_map const *maps;
+	unsigned num_maps;
+};
+
+#ifdef CONFIG_GENERIC_PINCTRL_GROUPS
+
 /**
  * struct group_desc - generic pin group descriptor
  * @name: name of the pin group
@@ -179,20 +195,6 @@ struct group_desc {
 	void *data;
 };
 
-/**
- * struct pinctrl_maps - a list item containing part of the mapping table
- * @node: mapping table list node
- * @maps: array of mapping table entries
- * @num_maps: the number of entries in @maps
- */
-struct pinctrl_maps {
-	struct list_head node;
-	struct pinctrl_map const *maps;
-	unsigned num_maps;
-};
-
-#ifdef CONFIG_GENERIC_PINCTRL
-
 int pinctrl_generic_get_group_count(struct pinctrl_dev *pctldev);
 
 const char *pinctrl_generic_get_group_name(struct pinctrl_dev *pctldev,
@@ -218,7 +220,7 @@ pinctrl_generic_remove_last_group(struct pinctrl_dev *pctldev)
 	return pinctrl_generic_remove_group(pctldev, pctldev->num_groups - 1);
 }
 
-#endif	/* CONFIG_GENERIC_PINCTRL */
+#endif	/* CONFIG_GENERIC_PINCTRL_GROUPS */
 
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
 struct pinctrl_dev *get_pinctrl_dev_from_of_node(struct device_node *np);

commit c7059c5ac70aea194b07b2d811df433eb0ca81b5
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 27 09:20:00 2016 -0800

    pinctrl: core: Add generic pinctrl functions for managing groups
    
    We can add generic helpers for pin group handling for cases where the pin
    controller driver does not need to use static arrays.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 722b2579166d..af98b6313902 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -24,6 +24,8 @@ struct pinctrl_gpio_range;
  *	controller
  * @pin_desc_tree: each pin descriptor for this pin controller is stored in
  *	this radix tree
+ * @pin_group_tree: optionally each pin group can be stored in this radix tree
+ * @num_groups: optionally number of groups can be kept here
  * @gpio_ranges: a list of GPIO ranges that is handled by this pin controller,
  *	ranges are added to this list at runtime
  * @dev: the device entry for this pin controller
@@ -41,6 +43,8 @@ struct pinctrl_dev {
 	struct list_head node;
 	struct pinctrl_desc *desc;
 	struct radix_tree_root pin_desc_tree;
+	struct radix_tree_root pin_group_tree;
+	unsigned int num_groups;
 	struct list_head gpio_ranges;
 	struct device *dev;
 	struct module *owner;
@@ -161,6 +165,20 @@ struct pin_desc {
 #endif
 };
 
+/**
+ * struct group_desc - generic pin group descriptor
+ * @name: name of the pin group
+ * @pins: array of pins that belong to the group
+ * @num_pins: number of pins in the group
+ * @data: pin controller driver specific data
+ */
+struct group_desc {
+	const char *name;
+	int *pins;
+	int num_pins;
+	void *data;
+};
+
 /**
  * struct pinctrl_maps - a list item containing part of the mapping table
  * @node: mapping table list node
@@ -173,6 +191,35 @@ struct pinctrl_maps {
 	unsigned num_maps;
 };
 
+#ifdef CONFIG_GENERIC_PINCTRL
+
+int pinctrl_generic_get_group_count(struct pinctrl_dev *pctldev);
+
+const char *pinctrl_generic_get_group_name(struct pinctrl_dev *pctldev,
+					   unsigned int group_selector);
+
+int pinctrl_generic_get_group_pins(struct pinctrl_dev *pctldev,
+				   unsigned int group_selector,
+				   const unsigned int **pins,
+				   unsigned int *npins);
+
+struct group_desc *pinctrl_generic_get_group(struct pinctrl_dev *pctldev,
+					     unsigned int group_selector);
+
+int pinctrl_generic_add_group(struct pinctrl_dev *pctldev, const char *name,
+			      int *gpins, int ngpins, void *data);
+
+int pinctrl_generic_remove_group(struct pinctrl_dev *pctldev,
+				 unsigned int group_selector);
+
+static inline int
+pinctrl_generic_remove_last_group(struct pinctrl_dev *pctldev)
+{
+	return pinctrl_generic_remove_group(pctldev, pctldev->num_groups - 1);
+}
+
+#endif	/* CONFIG_GENERIC_PINCTRL */
+
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
 struct pinctrl_dev *get_pinctrl_dev_from_of_node(struct device_node *np);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);

commit 99e4f67508e1dd51e21ebae2150c6e4f4eae068b
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 27 09:19:59 2016 -0800

    pinctrl: core: Use delayed work for hogs
    
    Having the pin control framework call pin controller functions
    before it's probe has finished is not nice as the pin controller
    device driver does not yet have struct pinctrl_dev handle.
    
    Let's fix this issue by adding deferred work for late init. This is
    needed to be able to add pinctrl generic helper functions that expect
    to know struct pinctrl_dev handle. Note that we now need to call
    create_pinctrl() directly as we don't want to add the pin controller
    to the list of controllers until the hogs are claimed. We also need
    to pass the pinctrl_dev to the device tree parser functions as they
    otherwise won't find the right controller at this point.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 747c423c11f3..722b2579166d 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -33,6 +33,7 @@ struct pinctrl_gpio_range;
  * @p: result of pinctrl_get() for this device
  * @hog_default: default state for pins hogged by this device
  * @hog_sleep: sleep state for pins hogged by this device
+ * @late_init: delayed work for pin controller to finish registration
  * @mutex: mutex taken on each pin controller specific action
  * @device_root: debugfs root for this device
  */
@@ -47,6 +48,7 @@ struct pinctrl_dev {
 	struct pinctrl *p;
 	struct pinctrl_state *hog_default;
 	struct pinctrl_state *hog_sleep;
+	struct delayed_work late_init;
 	struct mutex mutex;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;

commit cd8f61f1e52b33766639e28a042d717d1e069d4f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 25 14:09:31 2016 +0900

    pinctrl: copy per-pin driver private data to struct pin_desc
    
    Currently, struct pinctrl_pin_desc can have per-pin driver private
    data, but it is not copied to struct pin_desc.
    
    For a driver with sparse pin space, for-loop search like below would
    be necessary in order to get the driver-specific data for a desired
    pin number.
    
      for (i = 0; i < pctldev->desc->npins; i++)
              if (pin_number == pctldev->desc->pins[i].number)
                      return pctldev->desc->pins[i].drv_data;
    
    This is not efficient for a driver with a large number of pins.
    So, copy the data to struct pin_desc when each pin is registered
    for the faster radix tree lookup.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index ca08723b9ee1..747c423c11f3 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -134,6 +134,7 @@ struct pinctrl_setting {
  * @name: a name for the pin, e.g. the name of the pin/pad/finger on a
  *	datasheet or such
  * @dynamic_name: if the name of this pin was dynamically allocated
+ * @drv_data: driver-defined per-pin data. pinctrl core does not touch this
  * @mux_usecount: If zero, the pin is not claimed, and @owner should be NULL.
  *	If non-zero, this pin is claimed by @owner. This field is an integer
  *	rather than a boolean, since pinctrl_get() might process multiple
@@ -148,6 +149,7 @@ struct pin_desc {
 	struct pinctrl_dev *pctldev;
 	const char *name;
 	bool dynamic_name;
+	void *drv_data;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX
 	unsigned mux_usecount;

commit b18537cd8ec2e5280ba19d24ea8812b80e5b3208
Author: Joachim Eastwood <manabian@gmail.com>
Date:   Thu Feb 25 22:44:37 2016 +0100

    pinctrl: core: create nolock version of pinctrl_find_gpio_range_from_pin
    
    pinctrl_find_gpio_range_from_pin takes the pctldev->mutex but so
    does pinconf_pins_show and this will cause a deadlock if
    pinctrl_find_gpio_range_from_pin is used in .pin_config_get
    callback.
    
    Create a nolock version of pinctrl_find_gpio_range_from_pin to
    allow pin to gpio lookup to be used from pinconf_pins_show.
    
    Signed-off-by: Joachim Eastwood <manabian@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index b24ea846c867..ca08723b9ee1 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -182,6 +182,10 @@ static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
 	return radix_tree_lookup(&pctldev->pin_desc_tree, pin);
 }
 
+extern struct pinctrl_gpio_range *
+pinctrl_find_gpio_range_from_pin_nolock(struct pinctrl_dev *pctldev,
+					unsigned int pin);
+
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
 			 bool dup);
 void pinctrl_unregister_map(struct pinctrl_map const *map);

commit c5272a28566b00cce79127ad382406e0a8650690
Author: Doug Anderson <dianders@chromium.org>
Date:   Fri May 1 09:01:27 2015 -0700

    pinctrl: Don't just pretend to protect pinctrl_maps, do it for real
    
    Way back, when the world was a simpler place and there was no war, no
    evil, and no kernel bugs, there was just a single pinctrl lock.  That
    was how the world was when (57291ce pinctrl: core device tree mapping
    table parsing support) was written.  In that case, there were
    instances where the pinctrl mutex was already held when
    pinctrl_register_map() was called, hence a "locked" parameter was
    passed to the function to indicate that the mutex was already locked
    (so we shouldn't lock it again).
    
    A few years ago in (42fed7b pinctrl: move subsystem mutex to
    pinctrl_dev struct), we switched to a separate pinctrl_maps_mutex.
    ...but (oops) we forgot to re-think about the whole "locked" parameter
    for pinctrl_register_map().  Basically the "locked" parameter appears
    to still refer to whether the bigger pinctrl_dev mutex is locked, but
    we're using it to skip locks of our (now separate) pinctrl_maps_mutex.
    
    That's kind of a bad thing(TM).  Probably nobody noticed because most
    of the calls to pinctrl_register_map happen at boot time and we've got
    synchronous device probing.  ...and even cases where we're
    asynchronous don't end up actually hitting the race too often.  ...but
    after banging my head against the wall for a bug that reproduced 1 out
    of 1000 reboots and lots of looking through kgdb, I finally noticed
    this.
    
    Anyway, we can now safely remove the "locked" parameter and go back to
    a war-free, evil-free, and kernel-bug-free world.
    
    Fixes: 42fed7ba44e4 ("pinctrl: move subsystem mutex to pinctrl_dev struct")
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 75476b3d87da..b24ea846c867 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -183,7 +183,7 @@ static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
 }
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
-			 bool dup, bool locked);
+			 bool dup);
 void pinctrl_unregister_map(struct pinctrl_map const *map);
 
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);

commit 42fed7ba44e4e8c1fb27b28ad14490cb1daff3c7
Author: Patrice Chotard <patrice.chotard@st.com>
Date:   Thu Apr 11 11:01:27 2013 +0200

    pinctrl: move subsystem mutex to pinctrl_dev struct
    
    This mutex avoids deadlock in case of use of multiple pin
    controllers. Before this modification, by using a global
    mutex, deadlock appeared when, for example, a call to
    pinctrl_pins_show() locked the pinctrl_mutex, called the
    ops->pin_dbg_show of a particular pin controller. If this
    pin controller needs I2C access to retrieve configuration
    information and I2C driver is using pinctrl to drive its
    pins, a call to pinctrl_select_state() try to lock again
    pinctrl_mutex which leads to a deadlock.
    
    Notice that the mutex grab from the two direction functions
    was moved into pinctrl_gpio_direction().
    
    For several cases, we can't replace pinctrl_mutex by
    pctldev->mutex, because at this stage, pctldev is
    not accessible :
            - pinctrl_get()/pinctrl_put()
            - pinctrl_register_maps()
    
    So add respectively pinctrl_list_mutex and
    pinctrl_maps_mutex in order to protect
    pinctrl_list and pinctrl_maps list instead.
    
    Reintroduce pinctrldev_list_mutex in
    find_pinctrl_by_of_node(),
    pinctrl_find_and_add_gpio_range()
    pinctrl_request_gpio(), pinctrl_free_gpio(),
    pinctrl_gpio_direction(), pinctrl_devices_show(),
    pinctrl_register() and pinctrl_unregister() to
    protect pinctrldev_list.
    
    Changes v2->v3:
    - Fix a missing EXPORT_SYMBOL_GPL() for pinctrl_select_state().
    
    Changes v1->v2:
    - pinctrl_select_state_locked() is removed, all lock mechanism
      is located inside pinctrl_select_state(). When parsing
      the state->setting list, take the per-pin-controller driver
      lock. (Patrice).
    - Introduce pinctrldev_list_mutex to protect pinctrldev_list
      in all functions which parse or modify pictrldev_list.
      (Patrice).
    - move find_pinctrl_by_of_node() from pinctrl/devicetree.c to
      pinctrl/core.c in order to protect pinctrldev_list.
      (Patrice).
    - Sink mutex:es into some functions and remove some _locked
      variants down to where the lists are actually accessed to
      make things simpler. (Linus)
    - Drop *all* mutexes completely from pinctrl_lookup_state()
      and pinctrl_select_state() - no relevant mutex was taken
      and it was unclear what this was protecting against. (Linus)
    
    Reported by : Seraphin Bonnaffe <seraphin.bonnaffe@stericsson.com>
    Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 6d3d40036d1b..75476b3d87da 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -33,6 +33,7 @@ struct pinctrl_gpio_range;
  * @p: result of pinctrl_get() for this device
  * @hog_default: default state for pins hogged by this device
  * @hog_sleep: sleep state for pins hogged by this device
+ * @mutex: mutex taken on each pin controller specific action
  * @device_root: debugfs root for this device
  */
 struct pinctrl_dev {
@@ -46,6 +47,7 @@ struct pinctrl_dev {
 	struct pinctrl *p;
 	struct pinctrl_state *hog_default;
 	struct pinctrl_state *hog_sleep;
+	struct mutex mutex;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;
 #endif
@@ -168,6 +170,7 @@ struct pinctrl_maps {
 };
 
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
+struct pinctrl_dev *get_pinctrl_dev_from_of_node(struct device_node *np);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
 const char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin);
 int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
@@ -186,8 +189,7 @@ void pinctrl_unregister_map(struct pinctrl_map const *map);
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
 extern int pinctrl_force_default(struct pinctrl_dev *pctldev);
 
-extern struct mutex pinctrl_mutex;
-extern struct list_head pinctrldev_list;
+extern struct mutex pinctrl_maps_mutex;
 extern struct list_head pinctrl_maps;
 
 #define for_each_maps(_maps_node_, _i_, _map_) \

commit 2c9abf808a81e2b2b61f6e05ec1554669aab3b19
Author: Richard Genoud <richard.genoud@gmail.com>
Date:   Mon Mar 25 15:47:20 2013 +0100

    pinctrl: fix typo in header
    
    Clearly, "node" was meant instead of "not"
    
    Signed-off-by: Richard Genoud <richard.genoud@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index ee72f1f6d862..6d3d40036d1b 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -72,7 +72,7 @@ struct pinctrl {
 
 /**
  * struct pinctrl_state - a pinctrl state for a device
- * @node: list not for struct pinctrl's @states field
+ * @node: list node for struct pinctrl's @states field
  * @name: the name of this state
  * @settings: a list of settings for this state
  */

commit 6f9e41f4e673bf9ae6a5c0831b1524a91ea1c440
Author: Laurent Meunier <laurent.meunier@st.com>
Date:   Wed Feb 6 09:09:44 2013 +0100

    pinctrl/pinconfig: add debug interface
    
    This update adds a debugfs interface to modify a pin configuration
    for a given state in the pinctrl map. This allows to modify the
    configuration for a non-active state, typically sleep state.
    This configuration is not applied right away, but only when the state
    will be entered.
    
    This solution is mandated for us by HW validation: in order
    to test and verify several pin configurations during sleep without
    recompiling the software.
    
    Signed-off-by: Laurent Meunier <laurent.meunier@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index fdd350d639f6..ee72f1f6d862 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -155,6 +155,18 @@ struct pin_desc {
 #endif
 };
 
+/**
+ * struct pinctrl_maps - a list item containing part of the mapping table
+ * @node: mapping table list node
+ * @maps: array of mapping table entries
+ * @num_maps: the number of entries in @maps
+ */
+struct pinctrl_maps {
+	struct list_head node;
+	struct pinctrl_map const *maps;
+	unsigned num_maps;
+};
+
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
 const char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin);
@@ -176,3 +188,10 @@ extern int pinctrl_force_default(struct pinctrl_dev *pctldev);
 
 extern struct mutex pinctrl_mutex;
 extern struct list_head pinctrldev_list;
+extern struct list_head pinctrl_maps;
+
+#define for_each_maps(_maps_node_, _i_, _map_) \
+	list_for_each_entry(_maps_node_, &pinctrl_maps, node) \
+		for (_i_ = 0, _map_ = &_maps_node_->maps[_i_]; \
+			_i_ < _maps_node_->num_maps; \
+			_i_++, _map_ = &_maps_node_->maps[_i_])

commit ab78029ecc347debbd737f06688d788bd9d60c1d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 22 10:56:14 2013 -0700

    drivers/pinctrl: grab default handles from device core
    
    This makes the device core auto-grab the pinctrl handle and set
    the "default" (PINCTRL_STATE_DEFAULT) state for every device
    that is present in the device model right before probe. This will
    account for the lion's share of embedded silicon devcies.
    
    A modification of the semantics for pinctrl_get() is also done:
    previously if the pinctrl handle for a certain device was already
    taken, the pinctrl core would return an error. Now, since the
    core may have already default-grabbed the handle and set its
    state to "default", if the handle was already taken, this will
    be disregarded and the located, previously instanitated handle
    will be returned to the caller.
    
    This way all code in drivers explicitly requesting their pinctrl
    handlers will still be functional, and drivers that want to
    explicitly retrieve and switch their handles can still do that.
    But if the desired functionality is just boilerplate of this
    type in the probe() function:
    
    struct pinctrl  *p;
    
    p = devm_pinctrl_get_select_default(&dev);
    if (IS_ERR(p)) {
       if (PTR_ERR(p) == -EPROBE_DEFER)
            return -EPROBE_DEFER;
            dev_warn(&dev, "no pinctrl handle\n");
    }
    
    The discussion began with the addition of such boilerplate
    to the omap4 keypad driver:
    http://marc.info/?l=linux-input&m=135091157719300&w=2
    
    A previous approach using notifiers was discussed:
    http://marc.info/?l=linux-kernel&m=135263661110528&w=2
    This failed because it could not handle deferred probes.
    
    This patch alone does not solve the entire dilemma faced:
    whether code should be distributed into the drivers or
    if it should be centralized to e.g. a PM domain. But it
    solves the immediate issue of the addition of boilerplate
    to a lot of drivers that just want to grab the default
    state. As mentioned, they can later explicitly retrieve
    the handle and set different states, and this could as
    well be done by e.g. PM domains as it is only related
    to a certain struct device * pointer.
    
    ChangeLog v4->v5 (Stephen):
    - Simplified the devicecore grab code.
    - Deleted a piece of documentation recommending that pins
      be mapped to a device rather than hogged.
    ChangeLog v3->v4 (Linus):
    - Drop overzealous NULL checks.
    - Move kref initialization to pinctrl_create().
    - Seeking Tested-by from Stephen Warren so we do not disturb
      the Tegra platform.
    - Seeking ACK on this from Greg (and others who like it) so I
      can merge it through the pinctrl subsystem.
    ChangeLog v2->v3 (Linus):
    - Abstain from using IS_ERR_OR_NULL() in the driver core,
      Russell recently sent a patch to remove it. Handle the
      NULL case explicitly even though it's a bogus case.
    - Make sure we handle probe deferral correctly in the device
      core file. devm_kfree() the container on error so we don't
      waste memory for devices without pinctrl handles.
    - Introduce reference counting into the pinctrl core using
      <linux/kref.h> so that we don't release pinctrl handles
      that have been obtained for two or more places.
    ChangeLog v1->v2 (Linus):
    - Only store a pointer in the device struct, and only allocate
      this if it's really used by the device.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Mitch Bradley <wmb@firmworks.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Rickard Andersson <rickard.andersson@stericsson.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [swarren: fixed and simplified error-handling in pinctrl_bind_pins(), to
    correctly handle deferred probe. Removed admonition from docs not to use
    pinctrl hogs for devices]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 232a9f6db4aa..fdd350d639f6 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -9,6 +9,7 @@
  * License terms: GNU General Public License (GPL) version 2
  */
 
+#include <linux/kref.h>
 #include <linux/mutex.h>
 #include <linux/radix-tree.h>
 #include <linux/pinctrl/pinconf.h>
@@ -58,6 +59,7 @@ struct pinctrl_dev {
  * @state: the current state
  * @dt_maps: the mapping table chunks dynamically parsed from device tree for
  *	this device, if any
+ * @users: reference count
  */
 struct pinctrl {
 	struct list_head node;
@@ -65,6 +67,7 @@ struct pinctrl {
 	struct list_head states;
 	struct pinctrl_state *state;
 	struct list_head dt_maps;
+	struct kref users;
 };
 
 /**

commit 840a47ba43a2aefbd9834924228549879ee3cb49
Author: Julien Delacou <julien.delacou@stericsson.com>
Date:   Mon Dec 10 14:47:33 2012 +0100

    pinctrl: add sleep mode management for hogs
    
    This fix allows handling sleep mode for hogged
    pins in pinctrl. It provides functions to set pins
    to sleep/default configurations according to their
    current state.
    
    Signed-off-by: Julien Delacou <julien.delacou@stericsson.com>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 12f5694f3d5d..232a9f6db4aa 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -30,6 +30,8 @@ struct pinctrl_gpio_range;
  * @driver_data: driver data for drivers registering to the pin controller
  *	subsystem
  * @p: result of pinctrl_get() for this device
+ * @hog_default: default state for pins hogged by this device
+ * @hog_sleep: sleep state for pins hogged by this device
  * @device_root: debugfs root for this device
  */
 struct pinctrl_dev {
@@ -41,6 +43,8 @@ struct pinctrl_dev {
 	struct module *owner;
 	void *driver_data;
 	struct pinctrl *p;
+	struct pinctrl_state *hog_default;
+	struct pinctrl_state *hog_sleep;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;
 #endif
@@ -164,5 +168,8 @@ int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
 			 bool dup, bool locked);
 void pinctrl_unregister_map(struct pinctrl_map const *map);
 
+extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
+extern int pinctrl_force_default(struct pinctrl_dev *pctldev);
+
 extern struct mutex pinctrl_mutex;
 extern struct list_head pinctrldev_list;

commit 1a78958dc212f3698fdc543857af80155cb30f7f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 17 20:51:54 2012 +0200

    pinctrl: reserve pins when states are activated
    
    This switches the way that pins are reserved for multiplexing:
    
    We used to do this when the map was parsed, at the creation of
    the settings inside the pinctrl handle, in pinmux_map_to_setting().
    
    However this does not work for us, because we want to use the
    same set of pins with different devices at different times: the
    current code assumes that the pin groups in a pinmux state will
    only be used with one single device, albeit different groups can
    be active at different times. For example if a single I2C driver
    block is used to drive two different busses located on two
    pin groups A and B, then the pins for all possible states of a
    function are reserved when fetching the pinctrl handle: the
    I2C bus can choose either set A or set B by a mux state at
    runtime, but all pins in both group A and B (the superset) are
    effectively reserved for that I2C function and mapped to the
    device. Another device can never get in and use the pins in
    group A, even if the device/function is using group B at the
    moment.
    
    Instead: let use reserve the pins when the state is activated
    and drop them when the state is disabled, i.e. when we move to
    another state. This way different devices/functions can use the
    same pins at different times.
    
    We know that this is an odd way of doing things, but we really
    need to switch e.g. an SD-card slot to become a tracing output
    sink at runtime: we plug in a special "tracing card" then mux
    the pins that used to be an SD slot around to the tracing
    unit and push out tracing data there instead of SD-card
    traffic.
    
    As a side effect pinmux_free_setting() is unused but the stubs
    are kept for future additions of code.
    
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Loic Pallardy <loic.pallardy@st.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Jean Nicolas Graux <jean-nicolas.graux@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 1f40ff68a8c4..12f5694f3d5d 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -105,12 +105,14 @@ struct pinctrl_setting_configs {
  * @type: the type of setting
  * @pctldev: pin control device handling to be programmed. Not used for
  *   PIN_MAP_TYPE_DUMMY_STATE.
+ * @dev_name: the name of the device using this state
  * @data: Data specific to the setting type
  */
 struct pinctrl_setting {
 	struct list_head node;
 	enum pinctrl_map_type type;
 	struct pinctrl_dev *pctldev;
+	const char *dev_name;
 	union {
 		struct pinctrl_setting_mux mux;
 		struct pinctrl_setting_configs configs;

commit dcb5dbc305b975cccf40942feba40964069541d3
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Tue Apr 17 15:00:46 2012 +0800

    pinctrl: show pin name for pingroups in sysfs
    
    Pin name is more useful to users.
    
    After change, when cat pingroups in sysfs, it becomes:
    root@freescale /sys/kernel/debug/pinctrl/20e0000.iomuxc$ cat pingroups
    registered pin groups:
    group: uart4grp-1
    pin 219 (MX6Q_PAD_KEY_ROW0)
    pin 218 (MX6Q_PAD_KEY_COL0)
    
    group: usdhc4grp-1
    pin 305 (MX6Q_PAD_SD4_CMD)
    pin 306 (MX6Q_PAD_SD4_CLK)
    pin 315 (MX6Q_PAD_SD4_DAT0)
    pin 316 (MX6Q_PAD_SD4_DAT1)
    pin 317 (MX6Q_PAD_SD4_DAT2)
    pin 318 (MX6Q_PAD_SD4_DAT3)
    pin 319 (MX6Q_PAD_SD4_DAT4)
    pin 320 (MX6Q_PAD_SD4_DAT5)
    pin 321 (MX6Q_PAD_SD4_DAT6)
    pin 322 (MX6Q_PAD_SD4_DAT7)
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 98ae8085e735..1f40ff68a8c4 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -148,6 +148,7 @@ struct pin_desc {
 
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
+const char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin);
 int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
 			       const char *pin_group);
 

commit 57291ce295c0aca738dd284c4a9c591c09ebee71
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Fri Mar 23 10:29:46 2012 -0600

    pinctrl: core device tree mapping table parsing support
    
    During pinctrl_get(), if the client device has a device tree node, look
    for the common pinctrl properties there. If found, parse the referenced
    device tree nodes, with the help of the pinctrl drivers, and generate
    mapping table entries from them.
    
    During pinctrl_put(), free any results of device tree parsing.
    
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 17ecf651b123..98ae8085e735 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -52,12 +52,15 @@ struct pinctrl_dev {
  * @dev: the device using this pin control handle
  * @states: a list of states for this device
  * @state: the current state
+ * @dt_maps: the mapping table chunks dynamically parsed from device tree for
+ *	this device, if any
  */
 struct pinctrl {
 	struct list_head node;
 	struct device *dev;
 	struct list_head states;
 	struct pinctrl_state *state;
+	struct list_head dt_maps;
 };
 
 /**
@@ -100,7 +103,8 @@ struct pinctrl_setting_configs {
  * struct pinctrl_setting - an individual mux or config setting
  * @node: list node for struct pinctrl_settings's @settings field
  * @type: the type of setting
- * @pctldev: pin control device handling to be programmed
+ * @pctldev: pin control device handling to be programmed. Not used for
+ *   PIN_MAP_TYPE_DUMMY_STATE.
  * @data: Data specific to the setting type
  */
 struct pinctrl_setting {
@@ -153,4 +157,9 @@ static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
 	return radix_tree_lookup(&pctldev->pin_desc_tree, pin);
 }
 
+int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
+			 bool dup, bool locked);
+void pinctrl_unregister_map(struct pinctrl_map const *map);
+
 extern struct mutex pinctrl_mutex;
+extern struct list_head pinctrldev_list;

commit 652162d469a73450a66b6c8049b16c2b7828fa24
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Mar 5 17:22:15 2012 -0700

    pinctrl: allow concurrent gpio and mux function ownership of pins
    
    Per recent updates to Documentation/gpio.txt, gpiolib drivers should
    inform pinctrl when a GPIO is requested. pinctrl then marks that pin as
    in-use for that GPIO function.
    
    When an SoC muxes pins in a group, it's quite possible for the group to
    contain e.g. 6 pins, but only 4 of them actually be needed by the HW
    module that's mux'd to them. In this case, the other 2 pins could be
    used as GPIOs. However, pinctrl marks all the pins within the group as
    in-use by the selected mux function. To allow the expected gpiolib
    interaction, separate the concepts of pin ownership into two parts: One
    for the mux function and one for GPIO usage. Finally, allow those two
    ownerships to exist in parallel.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index efbfb62ab147..17ecf651b123 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -119,15 +119,15 @@ struct pinctrl_setting {
  * @name: a name for the pin, e.g. the name of the pin/pad/finger on a
  *	datasheet or such
  * @dynamic_name: if the name of this pin was dynamically allocated
- * @usecount: If zero, the pin is not claimed, and @owner should be NULL.
+ * @mux_usecount: If zero, the pin is not claimed, and @owner should be NULL.
  *	If non-zero, this pin is claimed by @owner. This field is an integer
  *	rather than a boolean, since pinctrl_get() might process multiple
  *	mapping table entries that refer to, and hence claim, the same group
  *	or pin, and each of these will increment the @usecount.
- * @owner: The name of the entity owning the pin. Typically, this is the name
- *	of the device that called pinctrl_get(). Alternatively, it may be the
- *	name of the GPIO passed to pinctrl_request_gpio().
+ * @mux_owner: The name of device that called pinctrl_get().
  * @mux_setting: The most recent selected mux setting for this pin, if any.
+ * @gpio_owner: If pinctrl_request_gpio() was called for this pin, this is
+ *	the name of the GPIO that "owns" this pin.
  */
 struct pin_desc {
 	struct pinctrl_dev *pctldev;
@@ -135,9 +135,10 @@ struct pin_desc {
 	bool dynamic_name;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX
-	unsigned usecount;
-	const char *owner;
+	unsigned mux_usecount;
+	const char *mux_owner;
 	const struct pinctrl_setting_mux *mux_setting;
+	const char *gpio_owner;
 #endif
 };
 

commit 872acc322c74bb06b7ceb61fe93314e2da32362c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 6 13:52:22 2012 +0100

    pinctrl: include machine header to core.h
    
    struct pinctrl_setting contains an enum pinctrl_map_type
    field, so we need to include machine.h. Also fix kerneldoc
    to indicate that the pinctrl_setting is about both muxing
    and other config.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 5b3ff134d6db..efbfb62ab147 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -12,6 +12,7 @@
 #include <linux/mutex.h>
 #include <linux/radix-tree.h>
 #include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/machine.h>
 
 struct pinctrl_gpio_range;
 
@@ -96,7 +97,7 @@ struct pinctrl_setting_configs {
 };
 
 /**
- * struct pinctrl_setting - an individual mux setting
+ * struct pinctrl_setting - an individual mux or config setting
  * @node: list node for struct pinctrl_settings's @settings field
  * @type: the type of setting
  * @pctldev: pin control device handling to be programmed

commit ba110d90c08d9676370db9a62792f57ade5b3bbf
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:49 2012 -0700

    pinctrl: Show selected function and group in pinmux-pins debugfs
    
    Until recently, the pinctrl pinmux-pins debugfs file displayed the
    selected function for each owned pin. This feature was removed during
    restructing in support of recent API rework. This change restoreds this
    feature, and also displays the group that the function was selected on,
    in case a pin is a member of multiple groups.
    
    Based on work by: Linus Walleij <linus.walleij@linaro.org>
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 1cae3723bbed..5b3ff134d6db 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -126,6 +126,7 @@ struct pinctrl_setting {
  * @owner: The name of the entity owning the pin. Typically, this is the name
  *	of the device that called pinctrl_get(). Alternatively, it may be the
  *	name of the GPIO passed to pinctrl_request_gpio().
+ * @mux_setting: The most recent selected mux setting for this pin, if any.
  */
 struct pin_desc {
 	struct pinctrl_dev *pctldev;
@@ -135,6 +136,7 @@ struct pin_desc {
 #ifdef CONFIG_PINMUX
 	unsigned usecount;
 	const char *owner;
+	const struct pinctrl_setting_mux *mux_setting;
 #endif
 };
 

commit 1e2082b520721734c358f776d34a069867214c8e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:48 2012 -0700

    pinctrl: enhance mapping table to support pin config operations
    
    The pinctrl mapping table can now contain entries to:
    * Set the mux function of a pin group
    * Apply a set of pin config options to a pin or a group
    
    This allows pinctrl_select_state() to apply pin configs settings as well
    as mux settings.
    
    v3: Fix find_pinctrl() to iterate over the correct list.
       s/_MUX_CONFIGS_/_CONFIGS_/ in mapping table macros.
       Fix documentation to use correct mapping table macro.
    v2: Added numerous extra PIN_MAP_*() special-case macros.
       Fixed kerneldoc typo. Delete pinctrl_get_pin_id() and
       replace it with pin_get_from_name(). Various minor fixes.
       Updates due to rebase.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 5691d312e15a..1cae3723bbed 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -71,18 +71,45 @@ struct pinctrl_state {
 	struct list_head settings;
 };
 
+/**
+ * struct pinctrl_setting_mux - setting data for MAP_TYPE_MUX_GROUP
+ * @group: the group selector to program
+ * @func: the function selector to program
+ */
+struct pinctrl_setting_mux {
+	unsigned group;
+	unsigned func;
+};
+
+/**
+ * struct pinctrl_setting_configs - setting data for MAP_TYPE_CONFIGS_*
+ * @group_or_pin: the group selector or pin ID to program
+ * @configs: a pointer to an array of config parameters/values to program into
+ *	hardware. Each individual pin controller defines the format and meaning
+ *	of config parameters.
+ * @num_configs: the number of entries in array @configs
+ */
+struct pinctrl_setting_configs {
+	unsigned group_or_pin;
+	unsigned long *configs;
+	unsigned num_configs;
+};
+
 /**
  * struct pinctrl_setting - an individual mux setting
  * @node: list node for struct pinctrl_settings's @settings field
+ * @type: the type of setting
  * @pctldev: pin control device handling to be programmed
- * @group_selector: the group selector to program
- * @func_selector: the function selector to program
+ * @data: Data specific to the setting type
  */
 struct pinctrl_setting {
 	struct list_head node;
+	enum pinctrl_map_type type;
 	struct pinctrl_dev *pctldev;
-	unsigned group_selector;
-	unsigned func_selector;
+	union {
+		struct pinctrl_setting_mux mux;
+		struct pinctrl_setting_configs configs;
+	} data;
 };
 
 /**

commit 6e5e959dde0d92d177f035652aeaa77f9330c9c6
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:47 2012 -0700

    pinctrl: API changes to support multiple states per device
    
    The API model is changed from:
    
    p = pinctrl_get(dev, "state1");
    pinctrl_enable(p);
    ...
    pinctrl_disable(p);
    pinctrl_put(p);
    p = pinctrl_get(dev, "state2");
    pinctrl_enable(p);
    ...
    pinctrl_disable(p);
    pinctrl_put(p);
    
    to this:
    
    p = pinctrl_get(dev);
    s1 = pinctrl_lookup_state(p, "state1");
    s2 = pinctrl_lookup_state(p, "state2");
    pinctrl_select_state(p, s1);
    ...
    pinctrl_select_state(p, s2);
    ...
    pinctrl_put(p);
    
    This allows devices to directly transition between states without
    disabling the pin controller programming and put()/get()ing the
    configuration data each time. This model will also better suit pinconf
    programming, which doesn't have a concept of "disable".
    
    The special-case hogging feature of pin controllers is re-written to use
    the regular APIs instead of special-case code. Hence, the pinmux-hogs
    debugfs file is removed; see the top-level pinctrl-handles files for
    equivalent data.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 0bc52ecaf710..5691d312e15a 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -49,22 +49,31 @@ struct pinctrl_dev {
  * struct pinctrl - per-device pin control state holder
  * @node: global list node
  * @dev: the device using this pin control handle
- * @state: the state name passed to pinctrl_get()
- * @usecount: the number of active users of this pin controller setting, used
- *	to keep track of nested use cases
- * @settings: a list of settings for this device/state
+ * @states: a list of states for this device
+ * @state: the current state
  */
 struct pinctrl {
 	struct list_head node;
 	struct device *dev;
-	const char *state;
-	unsigned usecount;
+	struct list_head states;
+	struct pinctrl_state *state;
+};
+
+/**
+ * struct pinctrl_state - a pinctrl state for a device
+ * @node: list not for struct pinctrl's @states field
+ * @name: the name of this state
+ * @settings: a list of settings for this state
+ */
+struct pinctrl_state {
+	struct list_head node;
+	const char *name;
 	struct list_head settings;
 };
 
 /**
  * struct pinctrl_setting - an individual mux setting
- * @node: list node for struct pinctrl's @settings field
+ * @node: list node for struct pinctrl_settings's @settings field
  * @pctldev: pin control device handling to be programmed
  * @group_selector: the group selector to program
  * @func_selector: the function selector to program

commit 0e3db173e2b9fd3b82246516e72c17763eb5f98d
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:46 2012 -0700

    pinctrl: add usecount to pins for muxing
    
    Multiple mapping table entries could reference the same pin, and hence
    "own" it. This would be unusual now that pinctrl_get() represents a single
    state for a client device, but in the future when it represents all known
    states for a device, this is quite likely. Implement reference counting
    for pin ownership to handle this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 5f258b793400..0bc52ecaf710 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -82,7 +82,14 @@ struct pinctrl_setting {
  * @name: a name for the pin, e.g. the name of the pin/pad/finger on a
  *	datasheet or such
  * @dynamic_name: if the name of this pin was dynamically allocated
- * @owner: the device holding this pin or NULL of no device has claimed it
+ * @usecount: If zero, the pin is not claimed, and @owner should be NULL.
+ *	If non-zero, this pin is claimed by @owner. This field is an integer
+ *	rather than a boolean, since pinctrl_get() might process multiple
+ *	mapping table entries that refer to, and hence claim, the same group
+ *	or pin, and each of these will increment the @usecount.
+ * @owner: The name of the entity owning the pin. Typically, this is the name
+ *	of the device that called pinctrl_get(). Alternatively, it may be the
+ *	name of the GPIO passed to pinctrl_request_gpio().
  */
 struct pin_desc {
 	struct pinctrl_dev *pctldev;
@@ -90,6 +97,7 @@ struct pin_desc {
 	bool dynamic_name;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX
+	unsigned usecount;
 	const char *owner;
 #endif
 };

commit 7ecdb16fe63e5b356335ebdc236adfb48cef31e1
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:45 2012 -0700

    pinctrl: refactor struct pinctrl handling in core.c vs pinmux.c
    
    This change separates two aspects of struct pinctrl:
    
    a) The data representation of the parsed mapping table, into:
    
       1) The top-level struct pinctrl object, a single entity returned
          by pinctrl_get().
    
       2) The parsed version of each mapping table entry, struct
          pinctrl_setting, of which there is one per mapping table entry.
    
    b) The code that handles this; the code for (1) above is in core.c, and
       the code to parse/execute each entry in (2) above is in pinmux.c, while
       the iteration over multiple settings is lifted to core.c.
    
    This will allow the following future changes:
    
    1) pinctrl_get() API rework, so that struct pinctrl represents all states
       for the device, and the device can select between them without calling
       put()/get() again.
    
    2) To support that, a struct pinctrl_state object will be inserted into
       the data model between the struct pinctrl and struct pinctrl_setting.
    
    3) The mapping table will be extended to allow specification of pin config
       settings too. To support this, struct pinctrl_setting will be enhanced
       to store either mux settings or config settings, and functions will be
       added to pinconf.c to parse/execute pin configuration settings.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 8808f25a07d4..5f258b793400 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -49,22 +49,31 @@ struct pinctrl_dev {
  * struct pinctrl - per-device pin control state holder
  * @node: global list node
  * @dev: the device using this pin control handle
+ * @state: the state name passed to pinctrl_get()
  * @usecount: the number of active users of this pin controller setting, used
  *	to keep track of nested use cases
- * @pctldev: pin control device handling this pin control handle
- * @groups: the group selectors for the pinmux device and
- *	selector combination handling this pinmux, this is a list that
- *	will be traversed on all pinmux operations such as
- *	get/put/enable/disable
+ * @settings: a list of settings for this device/state
  */
 struct pinctrl {
 	struct list_head node;
 	struct device *dev;
+	const char *state;
 	unsigned usecount;
+	struct list_head settings;
+};
+
+/**
+ * struct pinctrl_setting - an individual mux setting
+ * @node: list node for struct pinctrl's @settings field
+ * @pctldev: pin control device handling to be programmed
+ * @group_selector: the group selector to program
+ * @func_selector: the function selector to program
+ */
+struct pinctrl_setting {
+	struct list_head node;
 	struct pinctrl_dev *pctldev;
-#ifdef CONFIG_PINMUX
-	struct list_head groups;
-#endif
+	unsigned group_selector;
+	unsigned func_selector;
 };
 
 /**

commit 57b676f9c1b7cd84397fe5a86c9bd2788ac4bd32
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:44 2012 -0700

    pinctrl: fix and simplify locking
    
    There are many problems with the current pinctrl locking:
    
    struct pinctrl_dev's gpio_ranges_lock isn't effective;
    pinctrl_match_gpio_range() only holds this lock while searching for a gpio
    range, but the found range is return and manipulated after releading the
    lock. This could allow pinctrl_remove_gpio_range() for that range while it
    is in use, and the caller may very well delete the range after removing it,
    causing pinctrl code to touch the now-free range object.
    
    Solving this requires the introduction of a higher-level lock, at least
    a lock per pin controller, which both gpio range registration and
    pinctrl_get()/put() will acquire.
    
    There is missing locking on HW programming; pin controllers may pack the
    configuration for different pins/groups/config options/... into one
    register, and hence have to read-modify-write the register. This needs to
    be protected, but currently isn't. Related, a future change will add a
    "complete" op to the pin controller drivers, the idea being that each
    state's programming will be programmed into the pinctrl driver followed
    by the "complete" call, which may e.g. flush a register cache to HW. For
    this to work, it must not be possible to interleave the pinctrl driver
    calls for different devices.
    
    As above, solving this requires the introduction of a higher-level lock,
    at least a lock per pin controller, which will be held for the duration
    of any pinctrl_enable()/disable() call.
    
    However, each pinctrl mapping table entry may affect a different pin
    controller if necessary. Hence, with a per-pin-controller lock, almost
    any pinctrl API may need to acquire multiple locks, one per controller.
    To avoid deadlock, these would need to be acquired in the same order in
    all cases. This is extremely difficult to implement in the case of
    pinctrl_get(), which doesn't know which pin controllers to lock until it
    has parsed the entire mapping table, since it contains somewhat arbitrary
    data.
    
    The simplest solution here is to introduce a single lock that covers all
    pin controllers at once. This will be acquired by all pinctrl APIs.
    
    This then makes struct pinctrl's mutex irrelevant, since that single lock
    will always be held whenever this mutex is currently held.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index e1dfdb3c144f..8808f25a07d4 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -9,6 +9,8 @@
  * License terms: GNU General Public License (GPL) version 2
  */
 
+#include <linux/mutex.h>
+#include <linux/radix-tree.h>
 #include <linux/pinctrl/pinconf.h>
 
 struct pinctrl_gpio_range;
@@ -22,7 +24,6 @@ struct pinctrl_gpio_range;
  *	this radix tree
  * @gpio_ranges: a list of GPIO ranges that is handled by this pin controller,
  *	ranges are added to this list at runtime
- * @gpio_ranges_lock: lock for the GPIO ranges list
  * @dev: the device entry for this pin controller
  * @owner: module providing the pin controller, used for refcounting
  * @driver_data: driver data for drivers registering to the pin controller
@@ -35,7 +36,6 @@ struct pinctrl_dev {
 	struct pinctrl_desc *desc;
 	struct radix_tree_root pin_desc_tree;
 	struct list_head gpio_ranges;
-	struct mutex gpio_ranges_lock;
 	struct device *dev;
 	struct module *owner;
 	void *driver_data;
@@ -52,7 +52,6 @@ struct pinctrl_dev {
  * @usecount: the number of active users of this pin controller setting, used
  *	to keep track of nested use cases
  * @pctldev: pin control device handling this pin control handle
- * @mutex: a lock for the pin control state holder
  * @groups: the group selectors for the pinmux device and
  *	selector combination handling this pinmux, this is a list that
  *	will be traversed on all pinmux operations such as
@@ -63,7 +62,6 @@ struct pinctrl {
 	struct device *dev;
 	unsigned usecount;
 	struct pinctrl_dev *pctldev;
-	struct mutex mutex;
 #ifdef CONFIG_PINMUX
 	struct list_head groups;
 #endif
@@ -75,14 +73,12 @@ struct pinctrl {
  * @name: a name for the pin, e.g. the name of the pin/pad/finger on a
  *	datasheet or such
  * @dynamic_name: if the name of this pin was dynamically allocated
- * @lock: a lock to protect the descriptor structure
  * @owner: the device holding this pin or NULL of no device has claimed it
  */
 struct pin_desc {
 	struct pinctrl_dev *pctldev;
 	const char *name;
 	bool dynamic_name;
-	spinlock_t lock;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX
 	const char *owner;
@@ -99,3 +95,5 @@ static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
 {
 	return radix_tree_lookup(&pctldev->pin_desc_tree, pin);
 }
+
+extern struct mutex pinctrl_mutex;

commit 962bcbc57aa244eeb1176fa2e9f65ac865cca68a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Mar 2 16:52:46 2012 +0100

    pinctrl: fix the pin descriptor kerneldoc
    
    The introduction of the owner field on the pin descriptor was not
    properly documented so fix this up.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 97f8124b4381..e1dfdb3c144f 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -76,9 +76,7 @@ struct pinctrl {
  *	datasheet or such
  * @dynamic_name: if the name of this pin was dynamically allocated
  * @lock: a lock to protect the descriptor structure
- * @mux_requested: whether the pin is already requested by pinmux or not
- * @mux_function: a named muxing function for the pin that will be passed to
- *	subdrivers and shown in debugfs etc
+ * @owner: the device holding this pin or NULL of no device has claimed it
  */
 struct pin_desc {
 	struct pinctrl_dev *pctldev;

commit 46919ae63d4820e76724beb655274ce143f0da0b
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Mar 1 18:48:32 2012 -0700

    pinctrl: introduce PINCTRL_STATE_DEFAULT, define hogs as that state
    
    This provides a single centralized name for the default state.
    
    Update PIN_MAP_* macros to use this state name, instead of requiring the
    user to pass a state name in.
    
    With this change, hog entries in the mapping table are defined as those
    with state name PINCTRL_STATE_DEFAULT, i.e. all entries have the same
    name. This interacts badly with the nested iteration over mapping table
    entries in pinctrl_hog_maps() and pinctrl_hog_map() which would now
    attempt to claim each hog mapping table entry multiple times. Replacing
    the custom hog code with a simple pinctrl_get()/pinctrl_enable().
    
    Update documentation and mapping tables to use this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 8164e7b4182b..97f8124b4381 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -27,7 +27,7 @@ struct pinctrl_gpio_range;
  * @owner: module providing the pin controller, used for refcounting
  * @driver_data: driver data for drivers registering to the pin controller
  *	subsystem
- * @pinctrl_hogs: list of pin control maps hogged by this device
+ * @p: result of pinctrl_get() for this device
  * @device_root: debugfs root for this device
  */
 struct pinctrl_dev {
@@ -39,7 +39,7 @@ struct pinctrl_dev {
 	struct device *dev;
 	struct module *owner;
 	void *driver_data;
-	struct list_head pinctrl_hogs;
+	struct pinctrl *p;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;
 #endif

commit d4e3198736d9d64e4ba4d2b46ab75cbcf5d0a4e0
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Mar 1 18:48:31 2012 -0700

    pinctrl: enhance pinctrl_get() to handle multiple functions
    
    At present, pinctrl_get() assumes that all matching mapping table entries
    have the same "function" value, albeit potentially applied to different
    pins/groups.
    
    This change removes this restriction; pinctrl_get() can now handle a set
    of mapping tables where different functions are applied to the various
    pins/groups.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 7551611666f8..8164e7b4182b 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -53,8 +53,6 @@ struct pinctrl_dev {
  *	to keep track of nested use cases
  * @pctldev: pin control device handling this pin control handle
  * @mutex: a lock for the pin control state holder
- * @func_selector: the function selector for the pinmux device handling
- *	this pinmux
  * @groups: the group selectors for the pinmux device and
  *	selector combination handling this pinmux, this is a list that
  *	will be traversed on all pinmux operations such as
@@ -67,7 +65,6 @@ struct pinctrl {
 	struct pinctrl_dev *pctldev;
 	struct mutex mutex;
 #ifdef CONFIG_PINMUX
-	unsigned func_selector;
 	struct list_head groups;
 #endif
 };

commit 2304b4737f492b6ee9b714d8129e153af0bef989
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Feb 22 14:26:01 2012 -0700

    pinctrl: remove pin and hogs locks from struct pinctrl_dev
    
    struct pinctrl_dev's pin_desc_tree_lock and pinctrl_hogs_lock aren't
    useful; the data they protect is read-only except when registering or
    unregistering a pinctrl_dev, and at those times, it doesn't make sense to
    protect one part of the structure independently from the rest.
    
    Move pinctrl_init_device_debugfs() to the end of pinctrl_register() so
    that debugfs can't access the struct pinctrl_dev until it's fully
    initialized, i.e. after the hogs are set up.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 061c57d0e8f9..7551611666f8 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -20,7 +20,6 @@ struct pinctrl_gpio_range;
  *	controller
  * @pin_desc_tree: each pin descriptor for this pin controller is stored in
  *	this radix tree
- * @pin_desc_tree_lock: lock for the descriptor tree
  * @gpio_ranges: a list of GPIO ranges that is handled by this pin controller,
  *	ranges are added to this list at runtime
  * @gpio_ranges_lock: lock for the GPIO ranges list
@@ -28,7 +27,6 @@ struct pinctrl_gpio_range;
  * @owner: module providing the pin controller, used for refcounting
  * @driver_data: driver data for drivers registering to the pin controller
  *	subsystem
- * @pinctrl_hogs_lock: lock for the pin control hog list
  * @pinctrl_hogs: list of pin control maps hogged by this device
  * @device_root: debugfs root for this device
  */
@@ -36,13 +34,11 @@ struct pinctrl_dev {
 	struct list_head node;
 	struct pinctrl_desc *desc;
 	struct radix_tree_root pin_desc_tree;
-	spinlock_t pin_desc_tree_lock;
 	struct list_head gpio_ranges;
 	struct mutex gpio_ranges_lock;
 	struct device *dev;
 	struct module *owner;
 	void *driver_data;
-	struct mutex pinctrl_hogs_lock;
 	struct list_head pinctrl_hogs;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;
@@ -99,7 +95,12 @@ struct pin_desc {
 };
 
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
-struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, unsigned int pin);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
 int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
 			       const char *pin_group);
+
+static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
+					    unsigned int pin)
+{
+	return radix_tree_lookup(&pctldev->pin_desc_tree, pin);
+}

commit 3cc70ed32cd6c5cb57de17bde615148ed7eda88f
Author: Stephen Warren <swarren@nvidia.com>
Date:   Sun Feb 19 23:45:44 2012 -0700

    pinctrl: record a pin owner, not mux function, when requesting pins
    
    When pins are requested/acquired/got, some device becomes the owner of
    their mux setting. At this point, it isn't certain which mux function
    will be selected for the pin, since this may vary between each of the
    device's states in the pinctrl mapping table. As such, we should record
    the owning device, not what we think the initial mux setting will be,
    when requesting pins.
    
    This doesn't make a lot of difference right now since pinctrl_get gets
    only one single device/state combination, but this will make a difference
    when pinctrl_get gets all states, and pinctrl_select_state can switch
    between states.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 7c305672919e..061c57d0e8f9 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -94,7 +94,7 @@ struct pin_desc {
 	spinlock_t lock;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX
-	const char *mux_function;
+	const char *owner;
 #endif
 };
 

commit 4ecce45dd663f6945bed7e2e06c05b5d90f3a2a1
Author: Stephen Warren <swarren@nvidia.com>
Date:   Sun Feb 19 23:45:47 2012 -0700

    pinctrl: core.c/h cleanups
    
    * Make all functions internal to core.c static. Remove any of these from
      core.h.
    * Add any missing EXPORT_SYMBOL_GPL().
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index a50cdb053c84..7c305672919e 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -101,8 +101,5 @@ struct pin_desc {
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
 struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, unsigned int pin);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
-int pinctrl_get_device_gpio_range(unsigned gpio,
-				  struct pinctrl_dev **outdev,
-				  struct pinctrl_gpio_range **outrange);
 int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
 			       const char *pin_group);

commit befe5bdfbb698b3bc57c58d0bd7ca3391c9275ed
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 19:47:48 2012 +0100

    pinctrl: factor pin control handles over to the core
    
    This moves the per-devices struct pinctrl handles and device map
    over from the pinmux part of the subsystem to the core pinctrl part.
    This makes the device handles core infrastructure with the goal of
    using these handles also for pin configuration, so that device
    drivers (or boards etc) will need one and only one handle to the
    pin control core.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 7a89888fce94..a50cdb053c84 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -30,6 +30,7 @@ struct pinctrl_gpio_range;
  *	subsystem
  * @pinctrl_hogs_lock: lock for the pin control hog list
  * @pinctrl_hogs: list of pin control maps hogged by this device
+ * @device_root: debugfs root for this device
  */
 struct pinctrl_dev {
 	struct list_head node;
@@ -41,12 +42,37 @@ struct pinctrl_dev {
 	struct device *dev;
 	struct module *owner;
 	void *driver_data;
+	struct mutex pinctrl_hogs_lock;
+	struct list_head pinctrl_hogs;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;
 #endif
+};
+
+/**
+ * struct pinctrl - per-device pin control state holder
+ * @node: global list node
+ * @dev: the device using this pin control handle
+ * @usecount: the number of active users of this pin controller setting, used
+ *	to keep track of nested use cases
+ * @pctldev: pin control device handling this pin control handle
+ * @mutex: a lock for the pin control state holder
+ * @func_selector: the function selector for the pinmux device handling
+ *	this pinmux
+ * @groups: the group selectors for the pinmux device and
+ *	selector combination handling this pinmux, this is a list that
+ *	will be traversed on all pinmux operations such as
+ *	get/put/enable/disable
+ */
+struct pinctrl {
+	struct list_head node;
+	struct device *dev;
+	unsigned usecount;
+	struct pinctrl_dev *pctldev;
+	struct mutex mutex;
 #ifdef CONFIG_PINMUX
-	struct mutex pinctrl_hogs_lock;
-	struct list_head pinctrl_hogs;
+	unsigned func_selector;
+	struct list_head groups;
 #endif
 };
 

commit e93bcee00c43e2bd4037291262111016f4c05793
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 07:23:28 2012 +0100

    pinctrl: move generic functions to the pinctrl_ namespace
    
    Since we want to use the former pinmux handles and mapping tables for
    generic control involving both muxing and configuration we begin
    refactoring by renaming them from pinmux_* to pinctrl_*.
    
    ChangeLog v1->v2:
    - Also rename the PINMUX_* macros in machine.h to PIN_ as indicated
      in the documentation so as to reflect the generic nature of these
      mapping entries from now on.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 8a8b02e9c18e..7a89888fce94 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -28,8 +28,8 @@ struct pinctrl_gpio_range;
  * @owner: module providing the pin controller, used for refcounting
  * @driver_data: driver data for drivers registering to the pin controller
  *	subsystem
- * @pinmux_hogs_lock: lock for the pinmux hog list
- * @pinmux_hogs: list of pinmux maps hogged by this device
+ * @pinctrl_hogs_lock: lock for the pin control hog list
+ * @pinctrl_hogs: list of pin control maps hogged by this device
  */
 struct pinctrl_dev {
 	struct list_head node;
@@ -45,8 +45,8 @@ struct pinctrl_dev {
 	struct dentry *device_root;
 #endif
 #ifdef CONFIG_PINMUX
-	struct mutex pinmux_hogs_lock;
-	struct list_head pinmux_hogs;
+	struct mutex pinctrl_hogs_lock;
+	struct list_head pinctrl_hogs;
 #endif
 };
 

commit 9dfac4fd7f8cdcdf734dff2ccc7ca467f53f1cfd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 1 18:02:47 2012 +0100

    pinctrl: delete raw device pointers in pinmux maps
    
    After discussion with Mark Brown in an unrelated thread about
    ADC lookups, it came to my knowledge that the ability to pass
    a struct device * in the regulator consumers is just a
    historical artifact, and not really recommended. Since there
    are no in-kernel users of these pointers, we just kill them
    right now, before someone starts to use them.
    
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index cfa86da6b4b1..8a8b02e9c18e 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -72,8 +72,7 @@ struct pin_desc {
 #endif
 };
 
-struct pinctrl_dev *get_pinctrl_dev_from_dev(struct device *dev,
-					     const char *dev_name);
+struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
 struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, unsigned int pin);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
 int pinctrl_get_device_gpio_range(unsigned gpio,

commit 0215716083cac67ff7ea3e3efdc9943bdb462274
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 20 08:17:22 2012 -0800

    pinctrl: free debugfs entries when unloading a pinmux driver
    
    We were not cleaning up properly after unloading a pinmux
    driver compiled as module.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 177a3310547f..cfa86da6b4b1 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -41,6 +41,9 @@ struct pinctrl_dev {
 	struct device *dev;
 	struct module *owner;
 	void *driver_data;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *device_root;
+#endif
 #ifdef CONFIG_PINMUX
 	struct mutex pinmux_hogs_lock;
 	struct list_head pinmux_hogs;

commit ca53c5f1ca5c936777caca46b7c716a40682ce83
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Dec 14 20:33:37 2011 +0100

    pinctrl: conjure names for unnamed pins
    
    If pins with blank names are registered, we assign them names on-the-fly
    on the form "PINn" where n is the pin number for that pin on the specific
    controller.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 5375582566a5..177a3310547f 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -52,6 +52,7 @@ struct pinctrl_dev {
  * @pctldev: corresponding pin control device
  * @name: a name for the pin, e.g. the name of the pin/pad/finger on a
  *	datasheet or such
+ * @dynamic_name: if the name of this pin was dynamically allocated
  * @lock: a lock to protect the descriptor structure
  * @mux_requested: whether the pin is already requested by pinmux or not
  * @mux_function: a named muxing function for the pin that will be passed to
@@ -60,6 +61,7 @@ struct pinctrl_dev {
 struct pin_desc {
 	struct pinctrl_dev *pctldev;
 	const char *name;
+	bool dynamic_name;
 	spinlock_t lock;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX

commit 51cd24ee625c348654114032499914d0311e5832
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Dec 9 16:59:05 2011 -0700

    pinctrl: don't create a device for each pin controller
    
    Pin controllers should already be instantiated as a device, so there's
    no need for the pinctrl core to create a new struct device for each
    controller.
    
    This allows the controller's real name to be used in the mux mapping
    table, rather than e.g. "pinctrl.0", "pinctrl.1", etc.
    
    This necessitates removal of the PINMUX_MAP_PRIMARY*() macros, since
    their sole purpose was to hard-code the .ctrl_dev_name field to be
    "pinctrl.0".
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 3f5b911acf18..5375582566a5 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -38,7 +38,7 @@ struct pinctrl_dev {
 	spinlock_t pin_desc_tree_lock;
 	struct list_head gpio_ranges;
 	struct mutex gpio_ranges_lock;
-	struct device dev;
+	struct device *dev;
 	struct module *owner;
 	void *driver_data;
 #ifdef CONFIG_PINMUX

commit ae6b4d8588f4fc95520b0e62c4b1f474c82191a9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 19 18:14:33 2011 +0200

    pinctrl: add a pin config interface
    
    This add per-pin and per-group pin config interfaces for biasing,
    driving and other such electronic properties. The details of passed
    configurations are passed in an opaque unsigned long which may be
    dereferences to integer types, structs or lists on either side
    of the configuration interface.
    
    ChangeLog v1->v2:
    - Clear split of terminology: we now have pin controllers, and
      those may support two interfaces using vtables: pin
      multiplexing and pin configuration.
    - Break out pin configuration to its own C file, controllers may
      implement only config without mux, and vice versa, so keep each
      sub-functionality of pin controllers separate. Introduce
      CONFIG_PINCONF in Kconfig.
    - Implement some core logic around pin configuration in the
      pinconf.c file.
    - Remove UNKNOWN config states, these were just surplus baggage.
    - Remove FLOAT config state - HIGH_IMPEDANCE should be enough for
      everyone.
    - PIN_CONFIG_POWER_SOURCE added to handle switching the power
      supply for the pin logic between different sources
    - Explicit DISABLE config enums to turn schmitt-trigger,
      wakeup etc OFF.
    - Update documentation to reflect all the recent reasoning.
    ChangeLog v2->v3:
    - Twist API around to pass around arrays of config tuples instead
      of (param, value) pairs everywhere.
    - Explicit drive strength semantics for push/pull and similar
      drive modes, this shall be the number of drive stages vs
      nominal load impedance, which should match the actual
      electronics used in push/pull CMOS or TTY totempoles.
    - Drop load capacitance configuration - I probably don't know
      what I'm doing here so leave it out.
    - Drop PIN_CONFIG_INPUT_SCHMITT_OFF, instead the argument zero to
      PIN_CONFIG_INPUT_SCHMITT turns schmitt trigger off.
    - Drop PIN_CONFIG_NORMAL_POWER_MODE and have a well defined
      argument to PIN_CONFIG_LOW_POWER_MODE to get out of it instead.
    - Drop PIN_CONFIG_WAKEUP_ENABLE/DISABLE and just use
      PIN_CONFIG_WAKEUP with defined value zero to turn wakeup off.
    - Add PIN_CONFIG_INPUT_DEBOUNCE for configuring debounce time
      on input lines.
    - Fix a bug when we tried to configure pins for pin controllers
      without pinconf support.
    - Initialized debugfs properly so it works.
    - Initialize the mutex properly and lock around config tampering
      sections.
    - Check the return value from get_initial_config() properly.
    ChangeLog v3->v4:
    - Export the pin_config_get(), pin_config_set() and
      pin_config_group() functions.
    - Drop the entire concept of just getting initial config and
      keeping track of pin states internally, instead ask the pins
      what state they are in. Previous idea was plain wrong, if the
      device cannot keep track of its state, the driver should do
      it.
    - Drop the generic configuration layout, it seems this impose
      too much restriction on some pin controllers, so let them do
      things the way they want and split off support for generic
      config as an optional add-on.
    ChangeLog v4->v5:
    - Introduce two symmetric driver calls for group configuration,
      .pin_config_group_[get|set] and corresponding external calls.
    - Remove generic semantic meanings of return values from config
      calls, these belong in the generic config patch. Just pass the
      return value through instead.
    - Add a debugfs entry "pinconf-groups" to read status from group
      configuration only, also slam in a per-group debug callback in
      the pinconf_ops so custom drivers can display something
      meaningful for their pins.
    - Fix some dangling newline.
    - Drop dangling #else clause.
    - Update documentation to match the above.
    ChangeLog v5->v6:
    - Change to using a pin name as parameter for the
      [get|set]_config() functions, as suggested by Stephen Warren.
      This is more natural as names will be what a developer has
      access to in written documentation etc.
    ChangeLog v6->v7:
    - Refactor out by-pin and by-name get/set functions, only expose
      the by-name functions externally, expose the by-pin functions
      internally.
    - Show supported pin control functionality in the debugfs
      pinctrl-devices file.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 74dee439dcf0..3f5b911acf18 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -9,6 +9,10 @@
  * License terms: GNU General Public License (GPL) version 2
  */
 
+#include <linux/pinctrl/pinconf.h>
+
+struct pinctrl_gpio_range;
+
 /**
  * struct pinctrl_dev - pin control class device
  * @node: node to include this pin controller in the global pin controller list
@@ -66,6 +70,7 @@ struct pin_desc {
 struct pinctrl_dev *get_pinctrl_dev_from_dev(struct device *dev,
 					     const char *dev_name);
 struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, unsigned int pin);
+int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
 int pinctrl_get_device_gpio_range(unsigned gpio,
 				  struct pinctrl_dev **outdev,
 				  struct pinctrl_gpio_range **outrange);

commit 33d58949adee5086478e140751e4a7263bd7e207
Author: Marek Belisko <marek.belisko@open-nandra.com>
Date:   Mon Oct 31 21:27:52 2011 +0100

    pinctrl: unify pin type from signed to unsigned
    
    We want singned pins to mean "invalid" only on the outside
    of the subsystem.
    
    Signed-off-by: Marek Belisko <marek.belisko@open-nandra.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index dcc6d687b653..74dee439dcf0 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -65,7 +65,7 @@ struct pin_desc {
 
 struct pinctrl_dev *get_pinctrl_dev_from_dev(struct device *dev,
 					     const char *dev_name);
-struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, int pin);
+struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, unsigned int pin);
 int pinctrl_get_device_gpio_range(unsigned gpio,
 				  struct pinctrl_dev **outdev,
 				  struct pinctrl_gpio_range **outrange);

commit 7afde8baa83b9ac409a6db86f27a41878aa6b33f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 19 17:07:16 2011 +0200

    pinctrl: move group lookup to core
    
    Now also the core needs to look up pin groups so move the lookup
    function there and expose it in the internal header.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 472fa1341cc0..dcc6d687b653 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -69,3 +69,5 @@ struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, int pin);
 int pinctrl_get_device_gpio_range(unsigned gpio,
 				  struct pinctrl_dev **outdev,
 				  struct pinctrl_gpio_range **outrange);
+int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
+			       const char *pin_group);

commit 5d2eaf8090874f8e65388e82f7e91f9cef74885e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Oct 19 16:19:28 2011 -0600

    pinctrl: Don't copy function name when requesting a pin
    
    Instead, store a pointer to the currently assigned function.
    
    This allows us to delete the mux_requested variable from pin_desc; a pin
    is requested if its currently assigned function is non-NULL.
    
    When a pin is requested as a GPIO rather than a regular function, the
    assigned function name is dynamically constructed. In this case, we have
    to kstrdup() the dynamically constructed name, so that mux_function doesn't
    pointed at stack data. This requires pin_free to be told whether to free
    the mux_function pointer or not.
    
    This removes the hard-coded maximum function name length.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index e431aa537287..472fa1341cc0 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -59,8 +59,7 @@ struct pin_desc {
 	spinlock_t lock;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX
-	bool	mux_requested;
-	char	mux_function[16];
+	const char *mux_function;
 #endif
 };
 

commit 9af1e44fb4a4c62a90bff9b095eb001764d91b65
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Oct 19 16:19:27 2011 -0600

    pinctrl: Don't copy pin names when registering them
    
    A pin controller's names array is no longer marked __refdata. Hence, we
    can avoid copying a pin's name into the descriptor when registering it.
    Instead, just point at the string supplied in the pin array.
    
    This both simplifies and speeds up pin controller initialization, but
    also removes the hard-coded maximum pin name length.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 17e07772160c..e431aa537287 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -55,7 +55,7 @@ struct pinctrl_dev {
  */
 struct pin_desc {
 	struct pinctrl_dev *pctldev;
-	char	name[16];
+	const char *name;
 	spinlock_t lock;
 	/* These fields only added when supporting pinmux drivers */
 #ifdef CONFIG_PINMUX

commit 2744e8afb3b76343e7eb8197e8b3e085036010a5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon May 2 20:50:54 2011 +0200

    drivers: create a pin control subsystem
    
    This creates a subsystem for handling of pin control devices.
    These are devices that control different aspects of package
    pins.
    
    Currently it handles pinmuxing, i.e. assigning electronic
    functions to groups of pins on primarily PGA and BGA type of
    chip packages which are common in embedded systems.
    
    The plan is to also handle other I/O pin control aspects
    such as biasing, driving, input properties such as
    schmitt-triggering, load capacitance etc within this
    subsystem, to remove a lot of ARM arch code as well as
    feature-creepy GPIO drivers which are implementing the same
    thing over and over again.
    
    This is being done to depopulate the arch/arm/* directory
    of such custom drivers and try to abstract the infrastructure
    they all need. See the Documentation/pinctrl.txt file that is
    part of this patch for more details.
    
    ChangeLog v1->v2:
    
    - Various minor fixes from Joe's and Stephens review comments
    - Added a pinmux_config() that can invoke custom configuration
      with arbitrary data passed in or out to/from the pinmux driver
    
    ChangeLog v2->v3:
    
    - Renamed subsystem folder to "pinctrl" since we will likely
      want to keep other pin control such as biasing in this
      subsystem too, so let us keep to something generic even though
      we're mainly doing pinmux now.
    - As a consequence, register pins as an abstract entity separate
      from the pinmux. The muxing functions will claim pins out of the
      pin pool and make sure they do not collide. Pins can now be
      named by the pinctrl core.
    - Converted the pin lookup from a static array into a radix tree,
      I agreed with Grant Likely to try to avoid any static allocation
      (which is crap for device tree stuff) so I just rewrote this
      to be dynamic, just like irq number descriptors. The
      platform-wide definition of number of pins goes away - this is
      now just the sum total of the pins registered to the subsystem.
    - Make sure mappings with only a function name and no device
      works properly.
    
    ChangeLog v3->v4:
    
    - Define a number space per controller instead of globally,
      Stephen and Grant requested the same thing so now maps need to
      define target controller, and the radix tree of pin descriptors
      is a property on each pin controller device.
    - Add a compulsory pinctrl device entry to the pinctrl mapping
      table. This must match the pinctrl device, like "pinctrl.0"
    - Split the file core.c in two: core.c and pinmux.c where the
      latter carry all pinmux stuff, the core is for generic pin
      control, and use local headers to access functionality between
      files. It is now possible to implement a "blank" pin controller
      without pinmux capabilities. This split will make new additions
      like pindrive.c, pinbias.c etc possible for combined drivers
      and chunks of functionality which is a GoodThing(TM).
    - Rewrite the interaction with the GPIO subsystem - the pin
      controller descriptor now handles this by defining an offset
      into the GPIO numberspace for its handled pin range. This is
      used to look up the apropriate pin controller for a GPIO pin.
      Then that specific GPIO range is matched 1-1 for the target
      controller instance.
    - Fixed a number of review comments from Joe Perches.
    - Broke out a header file pinctrl.h for the core pin handling
      stuff that will be reused by other stuff than pinmux.
    - Fixed some erroneous EXPORT() stuff.
    - Remove mispatched U300 Kconfig and Makefile entries
    - Fixed a number of review comments from Stephen Warren, not all
      of them - still WIP. But I think the new mapping that will
      specify which function goes to which pin mux controller address
      50% of your concerns (else beat me up).
    
    ChangeLog v4->v5:
    
    - Defined a "position" for each function, so the pin controller now
      tracks a function in a certain position, and the pinmux maps define
      what position you want the function in. (Feedback from Stephen
      Warren and Sascha Hauer).
    - Since we now need to request a combined function+position from
      the machine mapping table that connect mux settings to drivers,
      it was extended with a position field and a name field. The
      name field is now used if you e.g. need to switch between two
      mux map settings at runtime.
    - Switched from a class device to using struct bus_type for this
      subsystem. Verified sysfs functionality: seems to work fine.
      (Feedback from Arnd Bergmann and Greg Kroah-Hartman)
    - Define a per pincontroller list of GPIO ranges from the GPIO
      pin space that can be handled by the pin controller. These can
      be added one by one at runtime. (Feedback from Barry Song)
    - Expanded documentation of regulator_[get|enable|disable|put]
      semantics.
    - Fixed a number of review comments from Barry Song. (Thanks!)
    
    ChangeLog v5->v6:
    
    - Create an abstract pin group concept that can sort pins into
      named and enumerated groups no matter what the use of these
      groups may be, one possible usecase is a group of pins being
      muxed in or so. The intention is however to also use these
      groups for other pin control activities.
    - Make it compulsory for pinmux functions to associate with
      at least one group, so the abstract pin group concept is used
      to define the groups of pins affected by a pinmux function.
      The pinmux driver interface has been altered so as to enforce
      a function to list applicable groups per function.
    - Provide an optional .group entry in the pinmux machine map
      so the map can select beteween different available groups
      to be used with a certain function.
    - Consequent changes all over the place so that e.g. debugfs
      present reasonable information about the world.
    - Drop the per-pin mux (*config) function in the pinmux_ops
      struct - I was afraid that this would start to be used for
      things totally unrelated to muxing, we can introduce that to
      the generic struct pinctrl_ops if needed. I want to keep
      muxing orthogonal to other pin control subjects and not mix
      these things up.
    
    ChangeLog v6->v7:
    
    - Make it possible to have several map entries matching the
      same device, pin controller and function, but using
      a different group, and alter the semantics so that
      pinmux_get() will pick all matching map entries, and
      store the associated groups in a list. The list will
      then be iterated over at pinmux_enable()/pinmux_disable()
      and corresponding driver functions called for each
      defined group. Notice that you're only allowed to map
      multiple *groups* to the same
      { device, pin controller, function } triplet, attempts
      to map the same device to multiple pin controllers will
      for example fail. This is hopefully the crucial feature
      requested by Stephen Warren.
    - Add a pinmux hogging field to the pinmux mapping entries,
      and enable the pinmux core to hog pinmux map entries.
      This currently only works for pinmuxes without assigned
      devices as it looks now, but with device trees we can
      look up the corresponding struct device * entries when
      we register the pinmux driver, and have it hog each
      pinmux map in turn, for a simple approach to
      non-dynamic pin muxing. This addresses an issue from
      Grant Likely that the machine should take care of as
      much of the pinmux setup as possible, not the devices.
      By supplying a list of hogs, it can now instruct the
      core to take care of any static mappings.
    - Switch pinmux group retrieveal function to grab an
      array of strings representing the groups rather than an
      array of unsigned and rewrite accordingly.
    - Alter debugfs to show the grouplist handled by each
      pinmux. Also add a list of hogs.
    - Dynamically allocate a struct pinmux at pinmux_get() and
      free it at pinmux_put(), then add these to the global
      list of pinmuxes active as we go along.
    - Go over the list of pinmux maps at pinmux_get() time
      and repeatedly apply matches.
    - Retrieve applicable groups per function from the driver
      as a string array rather than a unsigned array, then
      lookup the enumerators.
    - Make the device to pinmux map a singleton - only allow the
      mapping table to be registered once and even tag the
      registration function with __init so it surely won't be
      abused.
    - Create a separate debugfs file to view the pinmux map at
      runtime.
    - Introduce a spin lock to the pin descriptor struct, lock it
      when modifying pin status entries. Reported by Stijn Devriendt.
    - Fix up the documentation after review from Stephen Warren.
    - Let the GPIO ranges give names as const char * instead of some
      fixed-length string.
    - add a function to unregister GPIO ranges to mirror the
      registration function.
    - Privatized the struct pinctrl_device and removed it from the
      <linux/pinctrl/pinctrl.h> API, the drivers do not need to know
      the members of this struct. It is now in the local header
      "core.h".
    - Rename the concept of "anonymous" mux maps to "system" muxes
      and add convenience macros and documentation.
    
    ChangeLog v7->v8:
    
    - Delete the leftover pinmux_config() function from the
     <linux/pinctrl/pinmux.h> header.
    - Fix a race condition found by Stijn Devriendt in pin_request()
    
    ChangeLog v8->v9:
    
    - Drop the bus_type and the sysfs attributes and all, we're not on
      the clear about how this should be used for e.g. userspace
      interfaces so let us save this for the future.
    - Use the right name in MAINTAINERS, PIN CONTROL rather than
      PINMUX
    - Don't kfree() the device state holder, let the .remove() callback
      handle this.
    - Fix up numerous kerneldoc headers to have one line for the function
      description and more verbose documentation below the parameters
    
    ChangeLog v9->v10:
    - pinctrl: EXPORT_SYMBOL needs export.h, folded in a patch
      from Steven Rothwell
    - fix pinctrl_register error handling, folded in a patch from
      Axel Lin
    - Various fixes to documentation text so that it's consistent.
    - Removed pointless comment from drivers/Kconfig
    - Removed dependency on SYSFS since we removed the bus in
      v9.
    - Renamed hopelessly abbreviated pctldev_* functions to the
      more verbose pinctrl_dev_*
    - Drop mutex properly when looking up GPIO ranges
    - Return NULL instead of ERR_PTR() errors on registration of
      pin controllers, using cast pointers is fragile. We can
      live without the detailed error codes for sure.
    
    Cc: Stijn Devriendt <highguy@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Barry Song <21cnbao@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
new file mode 100644
index 000000000000..17e07772160c
--- /dev/null
+++ b/drivers/pinctrl/core.h
@@ -0,0 +1,72 @@
+/*
+ * Core private header for the pin control subsystem
+ *
+ * Copyright (C) 2011 ST-Ericsson SA
+ * Written on behalf of Linaro for ST-Ericsson
+ *
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+
+/**
+ * struct pinctrl_dev - pin control class device
+ * @node: node to include this pin controller in the global pin controller list
+ * @desc: the pin controller descriptor supplied when initializing this pin
+ *	controller
+ * @pin_desc_tree: each pin descriptor for this pin controller is stored in
+ *	this radix tree
+ * @pin_desc_tree_lock: lock for the descriptor tree
+ * @gpio_ranges: a list of GPIO ranges that is handled by this pin controller,
+ *	ranges are added to this list at runtime
+ * @gpio_ranges_lock: lock for the GPIO ranges list
+ * @dev: the device entry for this pin controller
+ * @owner: module providing the pin controller, used for refcounting
+ * @driver_data: driver data for drivers registering to the pin controller
+ *	subsystem
+ * @pinmux_hogs_lock: lock for the pinmux hog list
+ * @pinmux_hogs: list of pinmux maps hogged by this device
+ */
+struct pinctrl_dev {
+	struct list_head node;
+	struct pinctrl_desc *desc;
+	struct radix_tree_root pin_desc_tree;
+	spinlock_t pin_desc_tree_lock;
+	struct list_head gpio_ranges;
+	struct mutex gpio_ranges_lock;
+	struct device dev;
+	struct module *owner;
+	void *driver_data;
+#ifdef CONFIG_PINMUX
+	struct mutex pinmux_hogs_lock;
+	struct list_head pinmux_hogs;
+#endif
+};
+
+/**
+ * struct pin_desc - pin descriptor for each physical pin in the arch
+ * @pctldev: corresponding pin control device
+ * @name: a name for the pin, e.g. the name of the pin/pad/finger on a
+ *	datasheet or such
+ * @lock: a lock to protect the descriptor structure
+ * @mux_requested: whether the pin is already requested by pinmux or not
+ * @mux_function: a named muxing function for the pin that will be passed to
+ *	subdrivers and shown in debugfs etc
+ */
+struct pin_desc {
+	struct pinctrl_dev *pctldev;
+	char	name[16];
+	spinlock_t lock;
+	/* These fields only added when supporting pinmux drivers */
+#ifdef CONFIG_PINMUX
+	bool	mux_requested;
+	char	mux_function[16];
+#endif
+};
+
+struct pinctrl_dev *get_pinctrl_dev_from_dev(struct device *dev,
+					     const char *dev_name);
+struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, int pin);
+int pinctrl_get_device_gpio_range(unsigned gpio,
+				  struct pinctrl_dev **outdev,
+				  struct pinctrl_gpio_range **outrange);
