commit 94873f6b46f8c103759c28adc121a58022972d01
Author: Baolin Wang <baolin.wang7@gmail.com>
Date:   Thu May 7 11:47:25 2020 +0800

    pinctrl: sprd: Fix the incorrect pull-up definition
    
    The bits of pull up resistor selection were defined mistakenly,
    thus fix them.
    
    Fixes: 41d32cfce1ae ("pinctrl: sprd: Add Spreadtrum pin control driver")
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/e973f8f194ce4cb2639121572e8621b5efa5bfbe.1588823152.git.baolin.wang7@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 48cbf2a2837f..08dc1931b358 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -68,8 +68,8 @@
 #define SLEEP_PULL_UP_MASK		0x1
 #define SLEEP_PULL_UP_SHIFT		3
 
-#define PULL_UP_20K			(BIT(12) | BIT(7))
-#define PULL_UP_4_7K			BIT(12)
+#define PULL_UP_4_7K			(BIT(12) | BIT(7))
+#define PULL_UP_20K			BIT(7)
 #define PULL_UP_MASK			0x21
 #define PULL_UP_SHIFT			7
 

commit 1592c4b9935fa8a3b7c297955bb872a357e5a3b6
Author: Linhua Xu <linhua.xu@unisoc.com>
Date:   Wed Mar 25 16:25:28 2020 +0800

    pinctrl: sprd: Add pin high impedance mode support
    
    For Spreadtrum pin controller, it will be the high impedance
    mode if disable input and output mode for a pin. Thus add
    PIN_CONFIG_BIAS_HIGH_IMPEDANCE configuration to support it.
    
    Signed-off-by: Linhua Xu <linhua.xu@unisoc.com>
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/3bdac4c2673b54c940e511f3fa569ee33b87b8d5.1585124562.git.baolin.wang7@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 8e396104ad1a..48cbf2a2837f 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -467,6 +467,12 @@ static int sprd_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin_id,
 		case PIN_CONFIG_OUTPUT_ENABLE:
 			arg = reg & SLEEP_OUTPUT_MASK;
 			break;
+		case PIN_CONFIG_BIAS_HIGH_IMPEDANCE:
+			if ((reg & SLEEP_OUTPUT) || (reg & SLEEP_INPUT))
+				return -EINVAL;
+
+			arg = 1;
+			break;
 		case PIN_CONFIG_DRIVE_STRENGTH:
 			arg = (reg >> DRIVE_STRENGTH_SHIFT) &
 				DRIVE_STRENGTH_MASK;
@@ -646,6 +652,12 @@ static int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,
 					shift = SLEEP_OUTPUT_SHIFT;
 				}
 				break;
+			case PIN_CONFIG_BIAS_HIGH_IMPEDANCE:
+				if (is_sleep_config == true) {
+					val = shift = 0;
+					mask = SLEEP_OUTPUT | SLEEP_INPUT;
+				}
+				break;
 			case PIN_CONFIG_DRIVE_STRENGTH:
 				if (arg < 2 || arg > 60)
 					return -EINVAL;

commit bb0f472f96fa2bda2c3e412cd84f16b15d992a56
Author: Linhua Xu <linhua.xu@unisoc.com>
Date:   Wed Mar 25 16:25:27 2020 +0800

    pinctrl: sprd: Use the correct pin output configuration
    
    The Spreadtrum pin controller did not supply registers to set high level
    or low level for output mode, instead we should let the pin controller
    current configuration drive values on the line. So we should use the
    PIN_CONFIG_OUTPUT_ENABLE configuration to enable or disable the output
    mode.
    
    [Baolin Wang changes the commit message]
    Fixes: 41d32cfce1ae ("pinctrl: sprd: Add Spreadtrum pin control driver")
    Signed-off-by: Linhua Xu <linhua.xu@unisoc.com>
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/8a6f91b49c17beb218e46b23084f59a7c7260f86.1585124562.git.baolin.wang7@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index ea04bac3b453..8e396104ad1a 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -464,7 +464,7 @@ static int sprd_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin_id,
 		case PIN_CONFIG_INPUT_ENABLE:
 			arg = (reg >> SLEEP_INPUT_SHIFT) & SLEEP_INPUT_MASK;
 			break;
-		case PIN_CONFIG_OUTPUT:
+		case PIN_CONFIG_OUTPUT_ENABLE:
 			arg = reg & SLEEP_OUTPUT_MASK;
 			break;
 		case PIN_CONFIG_DRIVE_STRENGTH:
@@ -635,9 +635,13 @@ static int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,
 					shift = SLEEP_INPUT_SHIFT;
 				}
 				break;
-			case PIN_CONFIG_OUTPUT:
+			case PIN_CONFIG_OUTPUT_ENABLE:
 				if (is_sleep_config == true) {
-					val |= SLEEP_OUTPUT;
+					if (arg > 0)
+						val |= SLEEP_OUTPUT;
+					else
+						val &= ~SLEEP_OUTPUT;
+
 					mask = SLEEP_OUTPUT_MASK;
 					shift = SLEEP_OUTPUT_SHIFT;
 				}

commit 1df49cc80da167f3fa91e3a47c3c1aabd4a3953c
Author: Baolin Wang <baolin.wang7@gmail.com>
Date:   Thu Feb 27 12:13:47 2020 +0800

    pinctrl: sprd: Allow the SPRD pinctrl driver building into a module
    
    Change the config to 'tristate' and export some symbols needed by modules
    to allow the Spreadtrum pinctrl driver building into a module.
    
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/d7239f3c7379e402f665fc8927f635ac56691380.1582776447.git.baolin.wang7@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 157712ab05a8..ea04bac3b453 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -1090,6 +1090,7 @@ int sprd_pinctrl_core_probe(struct platform_device *pdev,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(sprd_pinctrl_core_probe);
 
 int sprd_pinctrl_remove(struct platform_device *pdev)
 {
@@ -1098,6 +1099,7 @@ int sprd_pinctrl_remove(struct platform_device *pdev)
 	pinctrl_unregister(sprd_pctl->pctl);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(sprd_pinctrl_remove);
 
 void sprd_pinctrl_shutdown(struct platform_device *pdev)
 {
@@ -1112,6 +1114,7 @@ void sprd_pinctrl_shutdown(struct platform_device *pdev)
 		return;
 	pinctrl_select_state(pinctl, state);
 }
+EXPORT_SYMBOL_GPL(sprd_pinctrl_shutdown);
 
 MODULE_DESCRIPTION("SPREADTRUM Pin Controller Driver");
 MODULE_AUTHOR("Baolin Wang <baolin.wang@spreadtrum.com>");

commit e543b3f5bb1d7dc39c2628e2932c625670913436
Author: Bruce Chen <bruce.chen@unisoc.com>
Date:   Wed Oct 16 20:23:39 2019 +0800

    pinctrl: sprd: Add CM4 sleep mode support
    
    For the new Spreadtrum pin controller, it expands 6bits to describe the
    pin sleep mode with adding one CM4_SLEEP mode, which means the pin sleep
    related configuration will be loaded automatically by hardware when the
    CM4 system goes into deep sleep mode.
    
    Signed-off-by: Bruce Chen <bruce.chen@unisoc.com>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Link: https://lore.kernel.org/r/8ae52263b0625c416461821c457e6789b67170b6.1571228451.git.baolin.wang@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 8869843d34e3..157712ab05a8 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -41,7 +41,8 @@
 #define PUBCP_SLEEP_MODE		BIT(14)
 #define TGLDSP_SLEEP_MODE		BIT(15)
 #define AGDSP_SLEEP_MODE		BIT(16)
-#define SLEEP_MODE_MASK			GENMASK(3, 0)
+#define CM4_SLEEP_MODE			BIT(17)
+#define SLEEP_MODE_MASK			GENMASK(5, 0)
 #define SLEEP_MODE_SHIFT		13
 
 #define SLEEP_INPUT			BIT(1)
@@ -81,6 +82,7 @@ enum pin_sleep_mode {
 	PUBCP_SLEEP = BIT(1),
 	TGLDSP_SLEEP = BIT(2),
 	AGDSP_SLEEP = BIT(3),
+	CM4_SLEEP = BIT(4),
 };
 
 enum pin_func_sel {
@@ -616,6 +618,8 @@ static int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,
 					val |= TGLDSP_SLEEP_MODE;
 				if (arg & AGDSP_SLEEP)
 					val |= AGDSP_SLEEP_MODE;
+				if (arg & CM4_SLEEP)
+					val |= CM4_SLEEP_MODE;
 
 				mask = SLEEP_MODE_MASK;
 				shift = SLEEP_MODE_SHIFT;

commit f8b05fe41b72adc8bc3ce164d6a2c7ac55f44724
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Oct 9 12:52:45 2019 +0800

    pinctrl: sprd: Add PIN_CONFIG_BIAS_DISABLE configuration support
    
    Add PIN_CONFIG_BIAS_DISABLE configuration support for Spreadtrum pin
    controller.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Link: https://lore.kernel.org/r/66d373ddee61e8be2fcef49aac5e80bd58f14915.1570596606.git.baolin.wang@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 7b95bf5a82a9..8869843d34e3 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -484,6 +484,13 @@ static int sprd_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin_id,
 			       SLEEP_PULL_UP_MASK) << 16;
 			arg |= (reg >> PULL_UP_SHIFT) & PULL_UP_MASK;
 			break;
+		case PIN_CONFIG_BIAS_DISABLE:
+			if ((reg & (SLEEP_PULL_DOWN | SLEEP_PULL_UP)) ||
+			    (reg & (PULL_DOWN | PULL_UP_4_7K | PULL_UP_20K)))
+				return -EINVAL;
+
+			arg = 1;
+			break;
 		case PIN_CONFIG_SLEEP_HARDWARE_STATE:
 			arg = 0;
 			break;
@@ -674,6 +681,16 @@ static int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,
 					shift = PULL_UP_SHIFT;
 				}
 				break;
+			case PIN_CONFIG_BIAS_DISABLE:
+				if (is_sleep_config == true) {
+					val = shift = 0;
+					mask = SLEEP_PULL_DOWN | SLEEP_PULL_UP;
+				} else {
+					val = shift = 0;
+					mask = PULL_DOWN | PULL_UP_20K |
+						PULL_UP_4_7K;
+				}
+				break;
 			case PIN_CONFIG_SLEEP_HARDWARE_STATE:
 				continue;
 			default:

commit 5a6bc29032700bcc1fb752dd58f73179a78d115b
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Thu Aug 8 13:13:29 2019 +0530

    pinctrl: sprd: Add of_node_put() before return to prevent memory leak
    
    Each iteration of for_each_child_of_node puts the previous node, but in
    the case of a return from the middle of the loop, there is no put, thus
    causing a memory leak. Hence add an of_node_put before the return in
    two places.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190808074329.15579-1-nishkadg.linux@gmail.com
    Reviewed-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 5d40bab42881..7b95bf5a82a9 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -925,8 +925,10 @@ static int sprd_pinctrl_parse_dt(struct sprd_pinctrl *sprd_pctl)
 
 	for_each_child_of_node(np, child) {
 		ret = sprd_pinctrl_parse_groups(child, sprd_pctl, grp);
-		if (ret)
+		if (ret) {
+			of_node_put(child);
 			return ret;
+		}
 
 		*temp++ = grp->name;
 		grp++;
@@ -935,8 +937,11 @@ static int sprd_pinctrl_parse_dt(struct sprd_pinctrl *sprd_pctl)
 			for_each_child_of_node(child, sub_child) {
 				ret = sprd_pinctrl_parse_groups(sub_child,
 								sprd_pctl, grp);
-				if (ret)
+				if (ret) {
+					of_node_put(sub_child);
+					of_node_put(child);
 					return ret;
+				}
 
 				*temp++ = grp->name;
 				grp++;

commit 2f22e2028c03d95c47b077887297dfa068da2c8a
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Thu Jul 25 17:56:31 2019 +0800

    pinctrl: sprd: Combine the condition of MISC_PIN and COMMON_PIN
    
    Since the follow-up pin design on Spreadtrum platform has some changes,
    some configuration of MISC_PIN moved to COMMON_PIN. To support current
    pin design and keep backward compatibility, we should combine the
    condition of MISC_PIN and COMMON_PIN to configure an individual pin.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Link: https://lore.kernel.org/r/17af5e761e0515d288a7ea4078ac9aa4a82a7a4e.1564048446.git.baolin.wang@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index a32e8098d887..5d40bab42881 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -454,7 +454,7 @@ static int sprd_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin_id,
 	if (pin->type == GLOBAL_CTRL_PIN &&
 	    param == SPRD_PIN_CONFIG_CONTROL) {
 		arg = reg;
-	} else if (pin->type == COMMON_PIN) {
+	} else if (pin->type == COMMON_PIN || pin->type == MISC_PIN) {
 		switch (param) {
 		case SPRD_PIN_CONFIG_SLEEP_MODE:
 			arg = (reg >> SLEEP_MODE_SHIFT) & SLEEP_MODE_MASK;
@@ -465,14 +465,6 @@ static int sprd_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin_id,
 		case PIN_CONFIG_OUTPUT:
 			arg = reg & SLEEP_OUTPUT_MASK;
 			break;
-		case PIN_CONFIG_SLEEP_HARDWARE_STATE:
-			arg = 0;
-			break;
-		default:
-			return -ENOTSUPP;
-		}
-	} else if (pin->type == MISC_PIN) {
-		switch (param) {
 		case PIN_CONFIG_DRIVE_STRENGTH:
 			arg = (reg >> DRIVE_STRENGTH_SHIFT) &
 				DRIVE_STRENGTH_MASK;
@@ -606,7 +598,7 @@ static int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,
 		if (pin->type == GLOBAL_CTRL_PIN &&
 		    param == SPRD_PIN_CONFIG_CONTROL) {
 			val = arg;
-		} else if (pin->type == COMMON_PIN) {
+		} else if (pin->type == COMMON_PIN || pin->type == MISC_PIN) {
 			switch (param) {
 			case SPRD_PIN_CONFIG_SLEEP_MODE:
 				if (arg & AP_SLEEP)
@@ -639,13 +631,6 @@ static int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,
 					shift = SLEEP_OUTPUT_SHIFT;
 				}
 				break;
-			case PIN_CONFIG_SLEEP_HARDWARE_STATE:
-				continue;
-			default:
-				return -ENOTSUPP;
-			}
-		} else if (pin->type == MISC_PIN) {
-			switch (param) {
 			case PIN_CONFIG_DRIVE_STRENGTH:
 				if (arg < 2 || arg > 60)
 					return -EINVAL;

commit e89febc75df909fadd43b76754778109a05383c0
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Thu Jul 25 17:56:30 2019 +0800

    pinctrl: sprd: Change to use devm_platform_ioremap_resource()
    
    The devm_platform_ioremap_resource() function wraps platform_get_resource()
    and devm_ioremap_resource() in a single helper, thus use it to simplify
    the code.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Link: https://lore.kernel.org/r/ff410d312ed0047b5a36e5113daf7df78bcf1aa8.1564048446.git.baolin.wang@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index c31b58168772..a32e8098d887 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -1020,7 +1020,6 @@ int sprd_pinctrl_core_probe(struct platform_device *pdev,
 	struct sprd_pinctrl *sprd_pctl;
 	struct sprd_pinctrl_soc_info *pinctrl_info;
 	struct pinctrl_pin_desc *pin_desc;
-	struct resource *res;
 	int ret, i;
 
 	sprd_pctl = devm_kzalloc(&pdev->dev, sizeof(struct sprd_pinctrl),
@@ -1028,8 +1027,7 @@ int sprd_pinctrl_core_probe(struct platform_device *pdev,
 	if (!sprd_pctl)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	sprd_pctl->base = devm_ioremap_resource(&pdev->dev, res);
+	sprd_pctl->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(sprd_pctl->base))
 		return PTR_ERR(sprd_pctl->base);
 

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 7d9a44bd0047..c31b58168772 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Spreadtrum pin controller driver
  * Copyright (C) 2017 Spreadtrum  - http://www.spreadtrum.com
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
  */
 
 #include <linux/debugfs.h>

commit 957063c924736d4341e5d588757b9f31e8f6fa24
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Wed Oct 31 17:44:10 2018 -0700

    pinctrl: sprd: Use define directive for sprd_pinconf_params values
    
    Clang warns when one enumerated type is implicitly converted to another:
    
    drivers/pinctrl/sprd/pinctrl-sprd.c:845:19: warning: implicit conversion
    from enumeration type 'enum sprd_pinconf_params' to different
    enumeration type 'enum pin_config_param' [-Wenum-conversion]
            {"sprd,control", SPRD_PIN_CONFIG_CONTROL, 0},
            ~                ^~~~~~~~~~~~~~~~~~~~~~~
    drivers/pinctrl/sprd/pinctrl-sprd.c:846:22: warning: implicit conversion
    from enumeration type 'enum sprd_pinconf_params' to different
    enumeration type 'enum pin_config_param' [-Wenum-conversion]
            {"sprd,sleep-mode", SPRD_PIN_CONFIG_SLEEP_MODE, 0},
            ~                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
    
    It is expected that pinctrl drivers can extend pin_config_param because
    of the gap between PIN_CONFIG_END and PIN_CONFIG_MAX so this conversion
    isn't an issue. Most drivers that take advantage of this define the
    PIN_CONFIG variables as constants, rather than enumerated values. Do the
    same thing here so that Clang no longer warns.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/138
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 4537b5453996..7d9a44bd0047 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -159,10 +159,8 @@ struct sprd_pinctrl {
 	struct sprd_pinctrl_soc_info *info;
 };
 
-enum sprd_pinconf_params {
-	SPRD_PIN_CONFIG_CONTROL = PIN_CONFIG_END + 1,
-	SPRD_PIN_CONFIG_SLEEP_MODE = PIN_CONFIG_END + 2,
-};
+#define SPRD_PIN_CONFIG_CONTROL		(PIN_CONFIG_END + 1)
+#define SPRD_PIN_CONFIG_SLEEP_MODE	(PIN_CONFIG_END + 2)
 
 static int sprd_pinctrl_get_id_by_name(struct sprd_pinctrl *sprd_pctl,
 				       const char *name)

commit 63e037bc51b32d414cd07dd700e71359ce27a11f
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Thu Sep 27 17:15:08 2018 +0800

    pinctrl: sprd: Move DT parsing before registering pinctrl device
    
    It will be failed to select default or sleep state for pins hogged
    by the pin controller device, since we hadn't parsed pins configuration
    in device tree before registering the pin controller device. Thus
    we should move the device tree parsing function before registering
    the pin controller device.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 78c2f548b25f..4537b5453996 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -1059,6 +1059,12 @@ int sprd_pinctrl_core_probe(struct platform_device *pdev,
 		return ret;
 	}
 
+	ret = sprd_pinctrl_parse_dt(sprd_pctl);
+	if (ret) {
+		dev_err(&pdev->dev, "fail to parse dt properties\n");
+		return ret;
+	}
+
 	pin_desc = devm_kcalloc(&pdev->dev,
 				pinctrl_info->npins,
 				sizeof(struct pinctrl_pin_desc),
@@ -1083,13 +1089,6 @@ int sprd_pinctrl_core_probe(struct platform_device *pdev,
 		return PTR_ERR(sprd_pctl->pctl);
 	}
 
-	ret = sprd_pinctrl_parse_dt(sprd_pctl);
-	if (ret) {
-		dev_err(&pdev->dev, "fail to parse dt properties\n");
-		pinctrl_unregister(sprd_pctl->pctl);
-		return ret;
-	}
-
 	return 0;
 }
 

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index ba1c2ca406e4..78c2f548b25f 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -879,8 +879,9 @@ static int sprd_pinctrl_parse_groups(struct device_node *np,
 
 	grp->name = np->name;
 	grp->npins = ret;
-	grp->pins = devm_kzalloc(sprd_pctl->dev, grp->npins *
-				 sizeof(unsigned int), GFP_KERNEL);
+	grp->pins = devm_kcalloc(sprd_pctl->dev,
+				 grp->npins, sizeof(unsigned int),
+				 GFP_KERNEL);
 	if (!grp->pins)
 		return -ENOMEM;
 
@@ -931,14 +932,15 @@ static int sprd_pinctrl_parse_dt(struct sprd_pinctrl *sprd_pctl)
 	if (!info->ngroups)
 		return 0;
 
-	info->groups = devm_kzalloc(sprd_pctl->dev, info->ngroups *
+	info->groups = devm_kcalloc(sprd_pctl->dev,
+				    info->ngroups,
 				    sizeof(struct sprd_pin_group),
 				    GFP_KERNEL);
 	if (!info->groups)
 		return -ENOMEM;
 
-	info->grp_names = devm_kzalloc(sprd_pctl->dev,
-				       info->ngroups * sizeof(char *),
+	info->grp_names = devm_kcalloc(sprd_pctl->dev,
+				       info->ngroups, sizeof(char *),
 				       GFP_KERNEL);
 	if (!info->grp_names)
 		return -ENOMEM;
@@ -980,8 +982,8 @@ static int sprd_pinctrl_add_pins(struct sprd_pinctrl *sprd_pctl,
 	int i;
 
 	info->npins = pins_cnt;
-	info->pins = devm_kzalloc(sprd_pctl->dev,
-				  info->npins * sizeof(struct sprd_pin),
+	info->pins = devm_kcalloc(sprd_pctl->dev,
+				  info->npins, sizeof(struct sprd_pin),
 				  GFP_KERNEL);
 	if (!info->pins)
 		return -ENOMEM;
@@ -1057,7 +1059,8 @@ int sprd_pinctrl_core_probe(struct platform_device *pdev,
 		return ret;
 	}
 
-	pin_desc = devm_kzalloc(&pdev->dev, pinctrl_info->npins *
+	pin_desc = devm_kcalloc(&pdev->dev,
+				pinctrl_info->npins,
 				sizeof(struct pinctrl_pin_desc),
 				GFP_KERNEL);
 	if (!pin_desc)

commit 9d2fc7c37099f741c860733272ec12cd9829c230
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 13 12:42:14 2018 +0100

    pinctrl: sprd: Use seq_putc() in sprd_pinconf_group_dbg_show()
    
    A single character (line break) should be put into a sequence.
    Thus use the corresponding function "seq_putc".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 63529911445c..ba1c2ca406e4 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -818,7 +818,7 @@ static void sprd_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
 
 	grp = &info->groups[selector];
 
-	seq_printf(s, "\n");
+	seq_putc(s, '\n');
 	for (i = 0; i < grp->npins; i++, config++) {
 		unsigned int pin_id = grp->pins[i];
 

commit 4ce504c4eb5628073f35d38efe490554a12aee04
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 7 14:12:05 2017 +0300

    pinctrl: sprd: fix off by one bugs
    
    info->groups[] has info->ngroups elements so these comparisons should be
    >= instead of >.
    
    Fixes: 41d32cfce1ae ("pinctrl: sprd: Add Spreadtrum pin control driver")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Baolin Wang <baolin.wang@spreadtrum.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index e52a01e1f662..63529911445c 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -400,7 +400,7 @@ static int sprd_pmx_set_mux(struct pinctrl_dev *pctldev,
 	unsigned long reg;
 	unsigned int val = 0;
 
-	if (group_selector > info->ngroups)
+	if (group_selector >= info->ngroups)
 		return -EINVAL;
 
 	switch (func_selector) {
@@ -734,7 +734,7 @@ static int sprd_pinconf_group_get(struct pinctrl_dev *pctldev,
 	struct sprd_pin_group *grp;
 	unsigned int pin_id;
 
-	if (selector > info->ngroups)
+	if (selector >= info->ngroups)
 		return -EINVAL;
 
 	grp = &info->groups[selector];
@@ -753,7 +753,7 @@ static int sprd_pinconf_group_set(struct pinctrl_dev *pctldev,
 	struct sprd_pin_group *grp;
 	int ret, i;
 
-	if (selector > info->ngroups)
+	if (selector >= info->ngroups)
 		return -EINVAL;
 
 	grp = &info->groups[selector];
@@ -813,7 +813,7 @@ static void sprd_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
 	const char *name;
 	int i, ret;
 
-	if (selector > info->ngroups)
+	if (selector >= info->ngroups)
 		return;
 
 	grp = &info->groups[selector];

commit 41470c379b4f8d9a1513d930338fadfbccc287b6
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 7 10:29:26 2017 +0300

    pinctrl: sprd: check for allocation failure
    
    devm_pinctrl_get() could fail with ERR_PTR(-ENOMEM) so I have added a
    check for that.  I also reversed the other IS_ERR() test because it was
    a little confusing to test one way and then the opposite a couple lines
    later.
    
    Fixes: 41d32cfce1ae ("pinctrl: sprd: Add Spreadtrum pin control driver")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index c178b4a6d7f5..e52a01e1f662 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -1100,12 +1100,16 @@ int sprd_pinctrl_remove(struct platform_device *pdev)
 
 void sprd_pinctrl_shutdown(struct platform_device *pdev)
 {
-	struct pinctrl *pinctl = devm_pinctrl_get(&pdev->dev);
+	struct pinctrl *pinctl;
 	struct pinctrl_state *state;
 
+	pinctl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(pinctl))
+		return;
 	state = pinctrl_lookup_state(pinctl, "shutdown");
-	if (!IS_ERR(state))
-		pinctrl_select_state(pinctl, state);
+	if (IS_ERR(state))
+		return;
+	pinctrl_select_state(pinctl, state);
 }
 
 MODULE_DESCRIPTION("SPREADTRUM Pin Controller Driver");

commit 045b5792dc48848742d3746efab436f4c66be115
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Sep 4 11:53:22 2017 +0100

    pinctrl: sprd: make three local functions static
    
    The functions sprd_pmx_get_function_count, sprd_pmx_get_function_name
    and sprd_pmx_get_function_groups are local to the source and do not
    need to be in global scope, so make them static.
    
    Cleans up sparse warnings:
    "symbol 'sprd_pmx_get_function_count' was not declared. Should it be
    static?"
    "symbol 'sprd_pmx_get_function_name' was not declared. Should it be
    static?"
    "symbol 'sprd_pmx_get_function_groups' was not declared. Should it be
    static?"
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
index 7e7b9ac7e836..c178b4a6d7f5 100644
--- a/drivers/pinctrl/sprd/pinctrl-sprd.c
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -353,13 +353,13 @@ static const struct pinctrl_ops sprd_pctrl_ops = {
 	.dt_free_map = pinctrl_utils_free_map,
 };
 
-int sprd_pmx_get_function_count(struct pinctrl_dev *pctldev)
+static int sprd_pmx_get_function_count(struct pinctrl_dev *pctldev)
 {
 	return PIN_FUNC_MAX;
 }
 
-const char *sprd_pmx_get_function_name(struct pinctrl_dev *pctldev,
-				       unsigned int selector)
+static const char *sprd_pmx_get_function_name(struct pinctrl_dev *pctldev,
+					      unsigned int selector)
 {
 	switch (selector) {
 	case PIN_FUNC_1:
@@ -375,10 +375,10 @@ const char *sprd_pmx_get_function_name(struct pinctrl_dev *pctldev,
 	}
 }
 
-int sprd_pmx_get_function_groups(struct pinctrl_dev *pctldev,
-				 unsigned int selector,
-				 const char * const **groups,
-				 unsigned int * const num_groups)
+static int sprd_pmx_get_function_groups(struct pinctrl_dev *pctldev,
+					unsigned int selector,
+					const char * const **groups,
+					unsigned int * const num_groups)
 {
 	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
 	struct sprd_pinctrl_soc_info *info = pctl->info;

commit 41d32cfce1ae616413761d07986e1fb4b907e808
Author: Baolin Wang <baolin.wang@spreadtrum.com>
Date:   Thu Aug 17 14:50:38 2017 +0800

    pinctrl: sprd: Add Spreadtrum pin control driver
    
    This patch adds the pin control driver for Spreadtrum SC9860 platform.
    
    Signed-off-by: Baolin Wang <baolin.wang@spreadtrum.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/sprd/pinctrl-sprd.c b/drivers/pinctrl/sprd/pinctrl-sprd.c
new file mode 100644
index 000000000000..7e7b9ac7e836
--- /dev/null
+++ b/drivers/pinctrl/sprd/pinctrl-sprd.c
@@ -0,0 +1,1113 @@
+/*
+ * Spreadtrum pin controller driver
+ * Copyright (C) 2017 Spreadtrum  - http://www.spreadtrum.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/slab.h>
+
+#include "../core.h"
+#include "../pinmux.h"
+#include "../pinconf.h"
+#include "../pinctrl-utils.h"
+#include "pinctrl-sprd.h"
+
+#define PINCTRL_BIT_MASK(width)		(~(~0UL << (width)))
+#define PINCTRL_REG_OFFSET		0x20
+#define PINCTRL_REG_MISC_OFFSET		0x4020
+#define PINCTRL_REG_LEN			0x4
+
+#define PIN_FUNC_MASK			(BIT(4) | BIT(5))
+#define PIN_FUNC_SEL_1			~PIN_FUNC_MASK
+#define PIN_FUNC_SEL_2			BIT(4)
+#define PIN_FUNC_SEL_3			BIT(5)
+#define PIN_FUNC_SEL_4			PIN_FUNC_MASK
+
+#define AP_SLEEP_MODE			BIT(13)
+#define PUBCP_SLEEP_MODE		BIT(14)
+#define TGLDSP_SLEEP_MODE		BIT(15)
+#define AGDSP_SLEEP_MODE		BIT(16)
+#define SLEEP_MODE_MASK			GENMASK(3, 0)
+#define SLEEP_MODE_SHIFT		13
+
+#define SLEEP_INPUT			BIT(1)
+#define SLEEP_INPUT_MASK		0x1
+#define SLEEP_INPUT_SHIFT		1
+
+#define SLEEP_OUTPUT			BIT(0)
+#define SLEEP_OUTPUT_MASK		0x1
+#define SLEEP_OUTPUT_SHIFT		0
+
+#define DRIVE_STRENGTH_MASK		GENMASK(3, 0)
+#define DRIVE_STRENGTH_SHIFT		19
+
+#define SLEEP_PULL_DOWN			BIT(2)
+#define SLEEP_PULL_DOWN_MASK		0x1
+#define SLEEP_PULL_DOWN_SHIFT		2
+
+#define PULL_DOWN			BIT(6)
+#define PULL_DOWN_MASK			0x1
+#define PULL_DOWN_SHIFT			6
+
+#define SLEEP_PULL_UP			BIT(3)
+#define SLEEP_PULL_UP_MASK		0x1
+#define SLEEP_PULL_UP_SHIFT		3
+
+#define PULL_UP_20K			(BIT(12) | BIT(7))
+#define PULL_UP_4_7K			BIT(12)
+#define PULL_UP_MASK			0x21
+#define PULL_UP_SHIFT			7
+
+#define INPUT_SCHMITT			BIT(11)
+#define INPUT_SCHMITT_MASK		0x1
+#define INPUT_SCHMITT_SHIFT		11
+
+enum pin_sleep_mode {
+	AP_SLEEP = BIT(0),
+	PUBCP_SLEEP = BIT(1),
+	TGLDSP_SLEEP = BIT(2),
+	AGDSP_SLEEP = BIT(3),
+};
+
+enum pin_func_sel {
+	PIN_FUNC_1,
+	PIN_FUNC_2,
+	PIN_FUNC_3,
+	PIN_FUNC_4,
+	PIN_FUNC_MAX,
+};
+
+/**
+ * struct sprd_pin: represent one pin's description
+ * @name: pin name
+ * @number: pin number
+ * @type: pin type, can be GLOBAL_CTRL_PIN/COMMON_PIN/MISC_PIN
+ * @reg: pin register address
+ * @bit_offset: bit offset in pin register
+ * @bit_width: bit width in pin register
+ */
+struct sprd_pin {
+	const char *name;
+	unsigned int number;
+	enum pin_type type;
+	unsigned long reg;
+	unsigned long bit_offset;
+	unsigned long bit_width;
+};
+
+/**
+ * struct sprd_pin_group: represent one group's description
+ * @name: group name
+ * @npins: pin numbers of this group
+ * @pins: pointer to pins array
+ */
+struct sprd_pin_group {
+	const char *name;
+	unsigned int npins;
+	unsigned int *pins;
+};
+
+/**
+ * struct sprd_pinctrl_soc_info: represent the SoC's pins description
+ * @groups: pointer to groups of pins
+ * @ngroups: group numbers of the whole SoC
+ * @pins: pointer to pins description
+ * @npins: pin numbers of the whole SoC
+ * @grp_names: pointer to group names array
+ */
+struct sprd_pinctrl_soc_info {
+	struct sprd_pin_group *groups;
+	unsigned int ngroups;
+	struct sprd_pin *pins;
+	unsigned int npins;
+	const char **grp_names;
+};
+
+/**
+ * struct sprd_pinctrl: represent the pin controller device
+ * @dev: pointer to the device structure
+ * @pctl: pointer to the pinctrl handle
+ * @base: base address of the controller
+ * @info: pointer to SoC's pins description information
+ */
+struct sprd_pinctrl {
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	void __iomem *base;
+	struct sprd_pinctrl_soc_info *info;
+};
+
+enum sprd_pinconf_params {
+	SPRD_PIN_CONFIG_CONTROL = PIN_CONFIG_END + 1,
+	SPRD_PIN_CONFIG_SLEEP_MODE = PIN_CONFIG_END + 2,
+};
+
+static int sprd_pinctrl_get_id_by_name(struct sprd_pinctrl *sprd_pctl,
+				       const char *name)
+{
+	struct sprd_pinctrl_soc_info *info = sprd_pctl->info;
+	int i;
+
+	for (i = 0; i < info->npins; i++) {
+		if (!strcmp(info->pins[i].name, name))
+			return info->pins[i].number;
+	}
+
+	return -ENODEV;
+}
+
+static struct sprd_pin *
+sprd_pinctrl_get_pin_by_id(struct sprd_pinctrl *sprd_pctl, unsigned int id)
+{
+	struct sprd_pinctrl_soc_info *info = sprd_pctl->info;
+	struct sprd_pin *pin = NULL;
+	int i;
+
+	for (i = 0; i < info->npins; i++) {
+		if (info->pins[i].number == id) {
+			pin = &info->pins[i];
+			break;
+		}
+	}
+
+	return pin;
+}
+
+static const struct sprd_pin_group *
+sprd_pinctrl_find_group_by_name(struct sprd_pinctrl *sprd_pctl,
+				const char *name)
+{
+	struct sprd_pinctrl_soc_info *info = sprd_pctl->info;
+	const struct sprd_pin_group *grp = NULL;
+	int i;
+
+	for (i = 0; i < info->ngroups; i++) {
+		if (!strcmp(info->groups[i].name, name)) {
+			grp = &info->groups[i];
+			break;
+		}
+	}
+
+	return grp;
+}
+
+static int sprd_pctrl_group_count(struct pinctrl_dev *pctldev)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+
+	return info->ngroups;
+}
+
+static const char *sprd_pctrl_group_name(struct pinctrl_dev *pctldev,
+					 unsigned int selector)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+
+	return info->groups[selector].name;
+}
+
+static int sprd_pctrl_group_pins(struct pinctrl_dev *pctldev,
+				 unsigned int selector,
+				 const unsigned int **pins,
+				 unsigned int *npins)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+
+	if (selector >= info->ngroups)
+		return -EINVAL;
+
+	*pins = info->groups[selector].pins;
+	*npins = info->groups[selector].npins;
+
+	return 0;
+}
+
+static int sprd_dt_node_to_map(struct pinctrl_dev *pctldev,
+			       struct device_node *np,
+			       struct pinctrl_map **map,
+			       unsigned int *num_maps)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct sprd_pin_group *grp;
+	unsigned long *configs = NULL;
+	unsigned int num_configs = 0;
+	unsigned int reserved_maps = 0;
+	unsigned int reserve = 0;
+	const char *function;
+	enum pinctrl_map_type type;
+	int ret;
+
+	grp = sprd_pinctrl_find_group_by_name(pctl, np->name);
+	if (!grp) {
+		dev_err(pctl->dev, "unable to find group for node %s\n",
+			of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	ret = of_property_count_strings(np, "pins");
+	if (ret < 0)
+		return ret;
+
+	if (ret == 1)
+		type = PIN_MAP_TYPE_CONFIGS_PIN;
+	else
+		type = PIN_MAP_TYPE_CONFIGS_GROUP;
+
+	ret = of_property_read_string(np, "function", &function);
+	if (ret < 0) {
+		if (ret != -EINVAL)
+			dev_err(pctl->dev,
+				"%s: could not parse property function\n",
+				of_node_full_name(np));
+		function = NULL;
+	}
+
+	ret = pinconf_generic_parse_dt_config(np, pctldev, &configs,
+					      &num_configs);
+	if (ret < 0) {
+		dev_err(pctl->dev, "%s: could not parse node property\n",
+			of_node_full_name(np));
+		return ret;
+	}
+
+	*map = NULL;
+	*num_maps = 0;
+
+	if (function != NULL)
+		reserve++;
+	if (num_configs)
+		reserve++;
+
+	ret = pinctrl_utils_reserve_map(pctldev, map, &reserved_maps,
+					num_maps, reserve);
+	if (ret < 0)
+		goto out;
+
+	if (function) {
+		ret = pinctrl_utils_add_map_mux(pctldev, map,
+						&reserved_maps, num_maps,
+						grp->name, function);
+		if (ret < 0)
+			goto out;
+	}
+
+	if (num_configs) {
+		const char *group_or_pin;
+		unsigned int pin_id;
+
+		if (type == PIN_MAP_TYPE_CONFIGS_PIN) {
+			pin_id = grp->pins[0];
+			group_or_pin = pin_get_name(pctldev, pin_id);
+		} else {
+			group_or_pin = grp->name;
+		}
+
+		ret = pinctrl_utils_add_map_configs(pctldev, map,
+						    &reserved_maps, num_maps,
+						    group_or_pin, configs,
+						    num_configs, type);
+	}
+
+out:
+	kfree(configs);
+	return ret;
+}
+
+static void sprd_pctrl_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,
+				unsigned int offset)
+{
+	seq_printf(s, "%s", dev_name(pctldev->dev));
+}
+
+static const struct pinctrl_ops sprd_pctrl_ops = {
+	.get_groups_count = sprd_pctrl_group_count,
+	.get_group_name = sprd_pctrl_group_name,
+	.get_group_pins = sprd_pctrl_group_pins,
+	.pin_dbg_show = sprd_pctrl_dbg_show,
+	.dt_node_to_map = sprd_dt_node_to_map,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+int sprd_pmx_get_function_count(struct pinctrl_dev *pctldev)
+{
+	return PIN_FUNC_MAX;
+}
+
+const char *sprd_pmx_get_function_name(struct pinctrl_dev *pctldev,
+				       unsigned int selector)
+{
+	switch (selector) {
+	case PIN_FUNC_1:
+		return "func1";
+	case PIN_FUNC_2:
+		return "func2";
+	case PIN_FUNC_3:
+		return "func3";
+	case PIN_FUNC_4:
+		return "func4";
+	default:
+		return "null";
+	}
+}
+
+int sprd_pmx_get_function_groups(struct pinctrl_dev *pctldev,
+				 unsigned int selector,
+				 const char * const **groups,
+				 unsigned int * const num_groups)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+
+	*groups = info->grp_names;
+	*num_groups = info->ngroups;
+
+	return 0;
+}
+
+static int sprd_pmx_set_mux(struct pinctrl_dev *pctldev,
+			    unsigned int func_selector,
+			    unsigned int group_selector)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+	struct sprd_pin_group *grp = &info->groups[group_selector];
+	unsigned int i, grp_pins = grp->npins;
+	unsigned long reg;
+	unsigned int val = 0;
+
+	if (group_selector > info->ngroups)
+		return -EINVAL;
+
+	switch (func_selector) {
+	case PIN_FUNC_1:
+		val &= PIN_FUNC_SEL_1;
+		break;
+	case PIN_FUNC_2:
+		val |= PIN_FUNC_SEL_2;
+		break;
+	case PIN_FUNC_3:
+		val |= PIN_FUNC_SEL_3;
+		break;
+	case PIN_FUNC_4:
+		val |= PIN_FUNC_SEL_4;
+		break;
+	default:
+		break;
+	}
+
+	for (i = 0; i < grp_pins; i++) {
+		unsigned int pin_id = grp->pins[i];
+		struct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);
+
+		if (!pin || pin->type != COMMON_PIN)
+			continue;
+
+		reg = readl((void __iomem *)pin->reg);
+		reg &= ~PIN_FUNC_MASK;
+		reg |= val;
+		writel(reg, (void __iomem *)pin->reg);
+	}
+
+	return 0;
+}
+
+static const struct pinmux_ops sprd_pmx_ops = {
+	.get_functions_count = sprd_pmx_get_function_count,
+	.get_function_name = sprd_pmx_get_function_name,
+	.get_function_groups = sprd_pmx_get_function_groups,
+	.set_mux = sprd_pmx_set_mux,
+};
+
+static int sprd_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin_id,
+			    unsigned long *config)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);
+	unsigned int param = pinconf_to_config_param(*config);
+	unsigned int reg, arg;
+
+	if (!pin)
+		return -EINVAL;
+
+	if (pin->type == GLOBAL_CTRL_PIN) {
+		reg = (readl((void __iomem *)pin->reg) >>
+			   pin->bit_offset) & PINCTRL_BIT_MASK(pin->bit_width);
+	} else {
+		reg = readl((void __iomem *)pin->reg);
+	}
+
+	if (pin->type == GLOBAL_CTRL_PIN &&
+	    param == SPRD_PIN_CONFIG_CONTROL) {
+		arg = reg;
+	} else if (pin->type == COMMON_PIN) {
+		switch (param) {
+		case SPRD_PIN_CONFIG_SLEEP_MODE:
+			arg = (reg >> SLEEP_MODE_SHIFT) & SLEEP_MODE_MASK;
+			break;
+		case PIN_CONFIG_INPUT_ENABLE:
+			arg = (reg >> SLEEP_INPUT_SHIFT) & SLEEP_INPUT_MASK;
+			break;
+		case PIN_CONFIG_OUTPUT:
+			arg = reg & SLEEP_OUTPUT_MASK;
+			break;
+		case PIN_CONFIG_SLEEP_HARDWARE_STATE:
+			arg = 0;
+			break;
+		default:
+			return -ENOTSUPP;
+		}
+	} else if (pin->type == MISC_PIN) {
+		switch (param) {
+		case PIN_CONFIG_DRIVE_STRENGTH:
+			arg = (reg >> DRIVE_STRENGTH_SHIFT) &
+				DRIVE_STRENGTH_MASK;
+			break;
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			/* combine sleep pull down and pull down config */
+			arg = ((reg >> SLEEP_PULL_DOWN_SHIFT) &
+			       SLEEP_PULL_DOWN_MASK) << 16;
+			arg |= (reg >> PULL_DOWN_SHIFT) & PULL_DOWN_MASK;
+			break;
+		case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
+			arg = (reg >> INPUT_SCHMITT_SHIFT) & INPUT_SCHMITT_MASK;
+			break;
+		case PIN_CONFIG_BIAS_PULL_UP:
+			/* combine sleep pull up and pull up config */
+			arg = ((reg >> SLEEP_PULL_UP_SHIFT) &
+			       SLEEP_PULL_UP_MASK) << 16;
+			arg |= (reg >> PULL_UP_SHIFT) & PULL_UP_MASK;
+			break;
+		case PIN_CONFIG_SLEEP_HARDWARE_STATE:
+			arg = 0;
+			break;
+		default:
+			return -ENOTSUPP;
+		}
+	} else {
+		return -ENOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, arg);
+	return 0;
+}
+
+static unsigned int sprd_pinconf_drive(unsigned int mA)
+{
+	unsigned int val = 0;
+
+	switch (mA) {
+	case 2:
+		break;
+	case 4:
+		val |= BIT(19);
+		break;
+	case 6:
+		val |= BIT(20);
+		break;
+	case 8:
+		val |= BIT(19) | BIT(20);
+		break;
+	case 10:
+		val |= BIT(21);
+		break;
+	case 12:
+		val |= BIT(21) | BIT(19);
+		break;
+	case 14:
+		val |= BIT(21) | BIT(20);
+		break;
+	case 16:
+		val |= BIT(19) | BIT(20) | BIT(21);
+		break;
+	case 20:
+		val |= BIT(22);
+		break;
+	case 21:
+		val |= BIT(22) | BIT(19);
+		break;
+	case 24:
+		val |= BIT(22) | BIT(20);
+		break;
+	case 25:
+		val |= BIT(22) | BIT(20) | BIT(19);
+		break;
+	case 27:
+		val |= BIT(22) | BIT(21);
+		break;
+	case 29:
+		val |= BIT(22) | BIT(21) | BIT(19);
+		break;
+	case 31:
+		val |= BIT(22) | BIT(21) | BIT(20);
+		break;
+	case 33:
+		val |= BIT(22) | BIT(21) | BIT(20) | BIT(19);
+		break;
+	default:
+		break;
+	}
+
+	return val;
+}
+
+static bool sprd_pinctrl_check_sleep_config(unsigned long *configs,
+					    unsigned int num_configs)
+{
+	unsigned int param;
+	int i;
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		if (param == PIN_CONFIG_SLEEP_HARDWARE_STATE)
+			return true;
+	}
+
+	return false;
+}
+
+static int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,
+			    unsigned long *configs, unsigned int num_configs)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);
+	bool is_sleep_config;
+	unsigned long reg;
+	int i;
+
+	if (!pin)
+		return -EINVAL;
+
+	is_sleep_config = sprd_pinctrl_check_sleep_config(configs, num_configs);
+
+	for (i = 0; i < num_configs; i++) {
+		unsigned int param, arg, shift, mask, val;
+
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		val = 0;
+		shift = 0;
+		mask = 0;
+		if (pin->type == GLOBAL_CTRL_PIN &&
+		    param == SPRD_PIN_CONFIG_CONTROL) {
+			val = arg;
+		} else if (pin->type == COMMON_PIN) {
+			switch (param) {
+			case SPRD_PIN_CONFIG_SLEEP_MODE:
+				if (arg & AP_SLEEP)
+					val |= AP_SLEEP_MODE;
+				if (arg & PUBCP_SLEEP)
+					val |= PUBCP_SLEEP_MODE;
+				if (arg & TGLDSP_SLEEP)
+					val |= TGLDSP_SLEEP_MODE;
+				if (arg & AGDSP_SLEEP)
+					val |= AGDSP_SLEEP_MODE;
+
+				mask = SLEEP_MODE_MASK;
+				shift = SLEEP_MODE_SHIFT;
+				break;
+			case PIN_CONFIG_INPUT_ENABLE:
+				if (is_sleep_config == true) {
+					if (arg > 0)
+						val |= SLEEP_INPUT;
+					else
+						val &= ~SLEEP_INPUT;
+
+					mask = SLEEP_INPUT_MASK;
+					shift = SLEEP_INPUT_SHIFT;
+				}
+				break;
+			case PIN_CONFIG_OUTPUT:
+				if (is_sleep_config == true) {
+					val |= SLEEP_OUTPUT;
+					mask = SLEEP_OUTPUT_MASK;
+					shift = SLEEP_OUTPUT_SHIFT;
+				}
+				break;
+			case PIN_CONFIG_SLEEP_HARDWARE_STATE:
+				continue;
+			default:
+				return -ENOTSUPP;
+			}
+		} else if (pin->type == MISC_PIN) {
+			switch (param) {
+			case PIN_CONFIG_DRIVE_STRENGTH:
+				if (arg < 2 || arg > 60)
+					return -EINVAL;
+
+				val = sprd_pinconf_drive(arg);
+				mask = DRIVE_STRENGTH_MASK;
+				shift = DRIVE_STRENGTH_SHIFT;
+				break;
+			case PIN_CONFIG_BIAS_PULL_DOWN:
+				if (is_sleep_config == true) {
+					val |= SLEEP_PULL_DOWN;
+					mask = SLEEP_PULL_DOWN_MASK;
+					shift = SLEEP_PULL_DOWN_SHIFT;
+				} else {
+					val |= PULL_DOWN;
+					mask = PULL_DOWN_MASK;
+					shift = PULL_DOWN_SHIFT;
+				}
+				break;
+			case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
+				if (arg > 0)
+					val |= INPUT_SCHMITT;
+				else
+					val &= ~INPUT_SCHMITT;
+
+				mask = INPUT_SCHMITT_MASK;
+				shift = INPUT_SCHMITT_SHIFT;
+				break;
+			case PIN_CONFIG_BIAS_PULL_UP:
+				if (is_sleep_config == true) {
+					val |= SLEEP_PULL_UP;
+					mask = SLEEP_PULL_UP_MASK;
+					shift = SLEEP_PULL_UP_SHIFT;
+				} else {
+					if (arg == 20000)
+						val |= PULL_UP_20K;
+					else if (arg == 4700)
+						val |= PULL_UP_4_7K;
+
+					mask = PULL_UP_MASK;
+					shift = PULL_UP_SHIFT;
+				}
+				break;
+			case PIN_CONFIG_SLEEP_HARDWARE_STATE:
+				continue;
+			default:
+				return -ENOTSUPP;
+			}
+		} else {
+			return -ENOTSUPP;
+		}
+
+		if (pin->type == GLOBAL_CTRL_PIN) {
+			reg = readl((void __iomem *)pin->reg);
+			reg &= ~(PINCTRL_BIT_MASK(pin->bit_width)
+				<< pin->bit_offset);
+			reg |= (val & PINCTRL_BIT_MASK(pin->bit_width))
+				<< pin->bit_offset;
+			writel(reg, (void __iomem *)pin->reg);
+		} else {
+			reg = readl((void __iomem *)pin->reg);
+			reg &= ~(mask << shift);
+			reg |= val;
+			writel(reg, (void __iomem *)pin->reg);
+		}
+	}
+
+	return 0;
+}
+
+static int sprd_pinconf_group_get(struct pinctrl_dev *pctldev,
+				  unsigned int selector, unsigned long *config)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+	struct sprd_pin_group *grp;
+	unsigned int pin_id;
+
+	if (selector > info->ngroups)
+		return -EINVAL;
+
+	grp = &info->groups[selector];
+	pin_id = grp->pins[0];
+
+	return sprd_pinconf_get(pctldev, pin_id, config);
+}
+
+static int sprd_pinconf_group_set(struct pinctrl_dev *pctldev,
+				  unsigned int selector,
+				  unsigned long *configs,
+				  unsigned int num_configs)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+	struct sprd_pin_group *grp;
+	int ret, i;
+
+	if (selector > info->ngroups)
+		return -EINVAL;
+
+	grp = &info->groups[selector];
+
+	for (i = 0; i < grp->npins; i++) {
+		unsigned int pin_id = grp->pins[i];
+
+		ret = sprd_pinconf_set(pctldev, pin_id, configs, num_configs);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int sprd_pinconf_get_config(struct pinctrl_dev *pctldev,
+				   unsigned int pin_id,
+				   unsigned long *config)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);
+
+	if (!pin)
+		return -EINVAL;
+
+	if (pin->type == GLOBAL_CTRL_PIN) {
+		*config = (readl((void __iomem *)pin->reg) >>
+			   pin->bit_offset) & PINCTRL_BIT_MASK(pin->bit_width);
+	} else {
+		*config = readl((void __iomem *)pin->reg);
+	}
+
+	return 0;
+}
+
+static void sprd_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+				  struct seq_file *s, unsigned int pin_id)
+{
+	unsigned long config;
+	int ret;
+
+	ret = sprd_pinconf_get_config(pctldev, pin_id, &config);
+	if (ret)
+		return;
+
+	seq_printf(s, "0x%lx", config);
+}
+
+static void sprd_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
+					struct seq_file *s,
+					unsigned int selector)
+{
+	struct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sprd_pinctrl_soc_info *info = pctl->info;
+	struct sprd_pin_group *grp;
+	unsigned long config;
+	const char *name;
+	int i, ret;
+
+	if (selector > info->ngroups)
+		return;
+
+	grp = &info->groups[selector];
+
+	seq_printf(s, "\n");
+	for (i = 0; i < grp->npins; i++, config++) {
+		unsigned int pin_id = grp->pins[i];
+
+		name = pin_get_name(pctldev, pin_id);
+		ret = sprd_pinconf_get_config(pctldev, pin_id, &config);
+		if (ret)
+			return;
+
+		seq_printf(s, "%s: 0x%lx ", name, config);
+	}
+}
+
+static const struct pinconf_ops sprd_pinconf_ops = {
+	.is_generic = true,
+	.pin_config_get = sprd_pinconf_get,
+	.pin_config_set = sprd_pinconf_set,
+	.pin_config_group_get = sprd_pinconf_group_get,
+	.pin_config_group_set = sprd_pinconf_group_set,
+	.pin_config_dbg_show = sprd_pinconf_dbg_show,
+	.pin_config_group_dbg_show = sprd_pinconf_group_dbg_show,
+};
+
+static const struct pinconf_generic_params sprd_dt_params[] = {
+	{"sprd,control", SPRD_PIN_CONFIG_CONTROL, 0},
+	{"sprd,sleep-mode", SPRD_PIN_CONFIG_SLEEP_MODE, 0},
+};
+
+#ifdef CONFIG_DEBUG_FS
+static const struct pin_config_item sprd_conf_items[] = {
+	PCONFDUMP(SPRD_PIN_CONFIG_CONTROL, "global control", NULL, true),
+	PCONFDUMP(SPRD_PIN_CONFIG_SLEEP_MODE, "sleep mode", NULL, true),
+};
+#endif
+
+static struct pinctrl_desc sprd_pinctrl_desc = {
+	.pctlops = &sprd_pctrl_ops,
+	.pmxops = &sprd_pmx_ops,
+	.confops = &sprd_pinconf_ops,
+	.num_custom_params = ARRAY_SIZE(sprd_dt_params),
+	.custom_params = sprd_dt_params,
+#ifdef CONFIG_DEBUG_FS
+	.custom_conf_items = sprd_conf_items,
+#endif
+	.owner = THIS_MODULE,
+};
+
+static int sprd_pinctrl_parse_groups(struct device_node *np,
+				     struct sprd_pinctrl *sprd_pctl,
+				     struct sprd_pin_group *grp)
+{
+	struct property *prop;
+	const char *pin_name;
+	int ret, i = 0;
+
+	ret = of_property_count_strings(np, "pins");
+	if (ret < 0)
+		return ret;
+
+	grp->name = np->name;
+	grp->npins = ret;
+	grp->pins = devm_kzalloc(sprd_pctl->dev, grp->npins *
+				 sizeof(unsigned int), GFP_KERNEL);
+	if (!grp->pins)
+		return -ENOMEM;
+
+	of_property_for_each_string(np, "pins", prop, pin_name) {
+		ret = sprd_pinctrl_get_id_by_name(sprd_pctl, pin_name);
+		if (ret >= 0)
+			grp->pins[i++] = ret;
+	}
+
+	for (i = 0; i < grp->npins; i++) {
+		dev_dbg(sprd_pctl->dev,
+			"Group[%s] contains [%d] pins: id = %d\n",
+			grp->name, grp->npins, grp->pins[i]);
+	}
+
+	return 0;
+}
+
+static unsigned int sprd_pinctrl_get_groups(struct device_node *np)
+{
+	struct device_node *child;
+	unsigned int group_cnt, cnt;
+
+	group_cnt = of_get_child_count(np);
+
+	for_each_child_of_node(np, child) {
+		cnt = of_get_child_count(child);
+		if (cnt > 0)
+			group_cnt += cnt;
+	}
+
+	return group_cnt;
+}
+
+static int sprd_pinctrl_parse_dt(struct sprd_pinctrl *sprd_pctl)
+{
+	struct sprd_pinctrl_soc_info *info = sprd_pctl->info;
+	struct device_node *np = sprd_pctl->dev->of_node;
+	struct device_node *child, *sub_child;
+	struct sprd_pin_group *grp;
+	const char **temp;
+	int ret;
+
+	if (!np)
+		return -ENODEV;
+
+	info->ngroups = sprd_pinctrl_get_groups(np);
+	if (!info->ngroups)
+		return 0;
+
+	info->groups = devm_kzalloc(sprd_pctl->dev, info->ngroups *
+				    sizeof(struct sprd_pin_group),
+				    GFP_KERNEL);
+	if (!info->groups)
+		return -ENOMEM;
+
+	info->grp_names = devm_kzalloc(sprd_pctl->dev,
+				       info->ngroups * sizeof(char *),
+				       GFP_KERNEL);
+	if (!info->grp_names)
+		return -ENOMEM;
+
+	temp = info->grp_names;
+	grp = info->groups;
+
+	for_each_child_of_node(np, child) {
+		ret = sprd_pinctrl_parse_groups(child, sprd_pctl, grp);
+		if (ret)
+			return ret;
+
+		*temp++ = grp->name;
+		grp++;
+
+		if (of_get_child_count(child) > 0) {
+			for_each_child_of_node(child, sub_child) {
+				ret = sprd_pinctrl_parse_groups(sub_child,
+								sprd_pctl, grp);
+				if (ret)
+					return ret;
+
+				*temp++ = grp->name;
+				grp++;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int sprd_pinctrl_add_pins(struct sprd_pinctrl *sprd_pctl,
+				 struct sprd_pins_info *sprd_soc_pin_info,
+				 int pins_cnt)
+{
+	struct sprd_pinctrl_soc_info *info = sprd_pctl->info;
+	unsigned int ctrl_pin = 0, com_pin = 0;
+	struct sprd_pin *pin;
+	int i;
+
+	info->npins = pins_cnt;
+	info->pins = devm_kzalloc(sprd_pctl->dev,
+				  info->npins * sizeof(struct sprd_pin),
+				  GFP_KERNEL);
+	if (!info->pins)
+		return -ENOMEM;
+
+	for (i = 0, pin = info->pins; i < info->npins; i++, pin++) {
+		unsigned int reg;
+
+		pin->name = sprd_soc_pin_info[i].name;
+		pin->type = sprd_soc_pin_info[i].type;
+		pin->number = sprd_soc_pin_info[i].num;
+		reg = sprd_soc_pin_info[i].reg;
+		if (pin->type == GLOBAL_CTRL_PIN) {
+			pin->reg = (unsigned long)sprd_pctl->base +
+				PINCTRL_REG_LEN * reg;
+			pin->bit_offset = sprd_soc_pin_info[i].bit_offset;
+			pin->bit_width = sprd_soc_pin_info[i].bit_width;
+			ctrl_pin++;
+		} else if (pin->type == COMMON_PIN) {
+			pin->reg = (unsigned long)sprd_pctl->base +
+				PINCTRL_REG_OFFSET + PINCTRL_REG_LEN *
+				(i - ctrl_pin);
+			com_pin++;
+		} else if (pin->type == MISC_PIN) {
+			pin->reg = (unsigned long)sprd_pctl->base +
+				PINCTRL_REG_MISC_OFFSET + PINCTRL_REG_LEN *
+				(i - ctrl_pin - com_pin);
+		}
+	}
+
+	for (i = 0, pin = info->pins; i < info->npins; pin++, i++) {
+		dev_dbg(sprd_pctl->dev, "pin name[%s-%d], type = %d, "
+			"bit offset = %ld, bit width = %ld, reg = 0x%lx\n",
+			pin->name, pin->number, pin->type,
+			pin->bit_offset, pin->bit_width, pin->reg);
+	}
+
+	return 0;
+}
+
+int sprd_pinctrl_core_probe(struct platform_device *pdev,
+			    struct sprd_pins_info *sprd_soc_pin_info,
+			    int pins_cnt)
+{
+	struct sprd_pinctrl *sprd_pctl;
+	struct sprd_pinctrl_soc_info *pinctrl_info;
+	struct pinctrl_pin_desc *pin_desc;
+	struct resource *res;
+	int ret, i;
+
+	sprd_pctl = devm_kzalloc(&pdev->dev, sizeof(struct sprd_pinctrl),
+				 GFP_KERNEL);
+	if (!sprd_pctl)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sprd_pctl->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(sprd_pctl->base))
+		return PTR_ERR(sprd_pctl->base);
+
+	pinctrl_info = devm_kzalloc(&pdev->dev,
+				    sizeof(struct sprd_pinctrl_soc_info),
+				    GFP_KERNEL);
+	if (!pinctrl_info)
+		return -ENOMEM;
+
+	sprd_pctl->info = pinctrl_info;
+	sprd_pctl->dev = &pdev->dev;
+	platform_set_drvdata(pdev, sprd_pctl);
+
+	ret = sprd_pinctrl_add_pins(sprd_pctl, sprd_soc_pin_info, pins_cnt);
+	if (ret) {
+		dev_err(&pdev->dev, "fail to add pins information\n");
+		return ret;
+	}
+
+	pin_desc = devm_kzalloc(&pdev->dev, pinctrl_info->npins *
+				sizeof(struct pinctrl_pin_desc),
+				GFP_KERNEL);
+	if (!pin_desc)
+		return -ENOMEM;
+
+	for (i = 0; i < pinctrl_info->npins; i++) {
+		pin_desc[i].number = pinctrl_info->pins[i].number;
+		pin_desc[i].name = pinctrl_info->pins[i].name;
+		pin_desc[i].drv_data = pinctrl_info;
+	}
+
+	sprd_pinctrl_desc.pins = pin_desc;
+	sprd_pinctrl_desc.name = dev_name(&pdev->dev);
+	sprd_pinctrl_desc.npins = pinctrl_info->npins;
+
+	sprd_pctl->pctl = pinctrl_register(&sprd_pinctrl_desc,
+					   &pdev->dev, (void *)sprd_pctl);
+	if (IS_ERR(sprd_pctl->pctl)) {
+		dev_err(&pdev->dev, "could not register pinctrl driver\n");
+		return PTR_ERR(sprd_pctl->pctl);
+	}
+
+	ret = sprd_pinctrl_parse_dt(sprd_pctl);
+	if (ret) {
+		dev_err(&pdev->dev, "fail to parse dt properties\n");
+		pinctrl_unregister(sprd_pctl->pctl);
+		return ret;
+	}
+
+	return 0;
+}
+
+int sprd_pinctrl_remove(struct platform_device *pdev)
+{
+	struct sprd_pinctrl *sprd_pctl = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(sprd_pctl->pctl);
+	return 0;
+}
+
+void sprd_pinctrl_shutdown(struct platform_device *pdev)
+{
+	struct pinctrl *pinctl = devm_pinctrl_get(&pdev->dev);
+	struct pinctrl_state *state;
+
+	state = pinctrl_lookup_state(pinctl, "shutdown");
+	if (!IS_ERR(state))
+		pinctrl_select_state(pinctl, state);
+}
+
+MODULE_DESCRIPTION("SPREADTRUM Pin Controller Driver");
+MODULE_AUTHOR("Baolin Wang <baolin.wang@spreadtrum.com>");
+MODULE_LICENSE("GPL v2");
