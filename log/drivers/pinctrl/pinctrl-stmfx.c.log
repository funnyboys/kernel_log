commit 36126f5309b5054c2a57f7c603a6f8da1f4800d4
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Wed Apr 22 09:25:13 2020 +0200

    pinctrl: stmfx: stmfx_pinconf_set doesn't require to get direction anymore
    
    Pin direction is not used to set pin configuration.
    
    Fixes: a502b343ebd0 ("pinctrl: stmfx: update pinconf settings")
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Link: https://lore.kernel.org/r/20200422072513.8352-1-amelie.delaunay@st.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 60100b45f5e5..1aae803c12cd 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -288,7 +288,7 @@ static int stmfx_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 	struct pinctrl_gpio_range *range;
 	enum pin_config_param param;
 	u32 arg;
-	int dir, i, ret;
+	int i, ret;
 
 	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);
 	if (!range) {
@@ -296,10 +296,6 @@ static int stmfx_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 		return -EINVAL;
 	}
 
-	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, pin);
-	if (dir < 0)
-		return dir;
-
 	for (i = 0; i < num_configs; i++) {
 		param = pinconf_to_config_param(configs[i]);
 		arg = pinconf_to_config_argument(configs[i]);

commit 3c827873590c3f49c76d540c1e646135a11e0b4e
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Fri Feb 14 15:57:12 2020 +0200

    pinctrl: Use new GPIO_LINE_DIRECTION
    
    Use newly added GPIO defines GPIO_LINE_DIRECTION_IN and
    GPIO_LINE_DIRECTION_OUT instead of using hard-coded 1 and 0.
    
    Main benefit is to make it easier to see which values mean IN and which
    OUT. As a side effect this helps GPIO framework to change the direction
    defines to something else if ever needed.
    
    Please note that return value from get_direction call on
    pinctrl-axp209 driver was changed. Previously pinctrl-axp209 might have
    returned value 2 for direction INPUT.
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Reported-by: kbuild test robot <lkp@intel.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Jacopo Mondi <jacopo+renesas@jmondi.org>
    Link: https://lore.kernel.org/r/20200214135712.GA14557@localhost.localdomain
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 16723797fa7c..60100b45f5e5 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -134,10 +134,14 @@ static int stmfx_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
 	ret = regmap_read(pctl->stmfx->map, reg, &val);
 	/*
 	 * On stmfx, gpio pins direction is (0)input, (1)output.
-	 * .get_direction returns 0=out, 1=in
 	 */
+	if (ret)
+		return ret;
 
-	return ret ? ret : !(val & mask);
+	if (val & mask)
+		return GPIO_LINE_DIRECTION_OUT;
+
+	return GPIO_LINE_DIRECTION_IN;
 }
 
 static int stmfx_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)
@@ -223,6 +227,13 @@ static int stmfx_pinconf_get(struct pinctrl_dev *pctldev,
 	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, pin);
 	if (dir < 0)
 		return dir;
+
+	/*
+	 * Currently the gpiolib IN is 1 and OUT is 0 but let's not count
+	 * on it just to be on the safe side also in the future :)
+	 */
+	dir = (dir == GPIO_LINE_DIRECTION_IN) ? 1 : 0;
+
 	type = stmfx_pinconf_get_type(pctl, pin);
 	if (type < 0)
 		return type;
@@ -360,7 +371,7 @@ static void stmfx_pinconf_dbg_show(struct pinctrl_dev *pctldev,
 	if (val < 0)
 		return;
 
-	if (!dir) {
+	if (dir == GPIO_LINE_DIRECTION_OUT) {
 		seq_printf(s, "output %s ", val ? "high" : "low");
 		if (type)
 			seq_printf(s, "open drain %s internal pull-up ",

commit dc5fa4656864d3391cdf13512ffa0733ef72fcdc
Merge: 3d9e3501a064 ae75b53e08b9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 27 10:00:33 2019 -0800

    Merge tag 'pinctrl-v5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This is the bulk of pin control changes for v5.5.
    
      It is pretty much business as usual, the most interesting thing I
      think is the pin controller for a new Intel chip called Lightning
      Mountain, which is according to news reports some kind of embedded
      network processor and what is surprising about it is that Intel have
      decided to use device tree to describe the system rather than ACPI
      that they have traditionally favored.
    
      Core changes:
    
       - Avoid taking direct references to device tree-supplied device
         names: these may changed at runtime under certain circumstances to
         kstrdup them.
    
      GPIO related:
    
       - Work is ongoing to move to passing the irqchip along as a templated
         struct gpio_irq_chip when adding a standard gpiolib-based irqchip
         to a GPIO controller, a few patches in this cycle switches a few
         pin control drivers over to using this method.
    
      New hardware support:
    
       - Intel Lightning Mountain SoC pin controller and GPIO support, a
         first Intel platform to use device tree rather than ACPI to
         configure the system. News reports says that this SoC is a network
         processor.
    
       - Qualcomm MSM8976 and MSM8956
    
       - Qualcomm PMIC GPIO now also supports PM6150 and PM6150L
    
       - Qualcomm SPMI MPP and SPMI GPIO for PM8950 and PMI8950
    
       - Rockchip RK3308
    
       - Renesas R8A77961
    
       - Allwinner Meson-A1
    
      Driver improvements:
    
       - get_multiple and set_multiple support for the AT91-PIO4 driver.
    
       - Convert Qualcomm SSBI GPIO to use the hierarchical IRQ helpers in
         the GPIOlib irqchip"
    
    * tag 'pinctrl-v5.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (93 commits)
      pinctrl: ingenic: Add OTG VBUS pin for the JZ4770
      pinctrl: ingenic: Handle PIN_CONFIG_OUTPUT config
      pinctrl: Fix Kconfig indentation
      pinctrl: lewisburg: Update pin list according to v1.1v6
      MAINTAINERS: Replace my email by one @kernel.org
      pinctrl: armada-37xx: Fix irq mask access in armada_37xx_irq_set_type()
      dt-bindings: pinctrl: intel: Add for new SoC
      pinctrl: Add pinmux & GPIO controller driver for a new SoC
      pinctrl: rza1: remove unnecessary static inline function
      pinctrl: meson: add pinctrl driver support for Meson-A1 SoC
      pinctrl: meson: add a new callback for SoCs fixup
      pinctrl: nomadik: db8500: Add mc0_a_2 pin group without direction control
      dt-bindings: pinctrl: Convert generic pin mux and config properties to schema
      pinctrl: cherryview: Missed type change to unsigned int
      pinctrl: intel: Missed type change to unsigned int
      pinctrl: use devm_platform_ioremap_resource() to simplify code
      pinctrl: just return if no valid maps
      dt-bindings: pinctrl: qcom-pmic-mpp: Add support for PM/PMI8950
      pinctrl: qcom: spmi-mpp: Add PM/PMI8950 compatible strings
      dt-bindings: pinctrl: qcom-pmic-gpio: Add support for PM/PMI8950
      ...

commit 1566a6a30bf4d85849bab7e389392d6d3de1530e
Merge: 3af50e548019 d6d5df1db6e9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 13 23:10:52 2019 +0100

    Merge tag 'v5.4-rc5' into devel
    
    Linux 5.4-rc5

commit 63e006c107ff4235d2a8fd52704f283d23642537
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Mon Nov 4 11:09:08 2019 +0100

    pinctrl: stmfx: fix valid_mask init sequence
    
    With stmfx_pinctrl_gpio_init_valid_mask callback, gpio_valid_mask was used
    to initialize gpiochip valid_mask for gpiolib. But gpio_valid_mask was not
    yet initialized. gpio_valid_mask required gpio-ranges to be registered,
    this is the case after gpiochip_add_data call. But init_valid_mask
    callback is also called under gpiochip_add_data. gpio_valid_mask
    initialization cannot be moved before gpiochip_add_data because
    gpio-ranges are not registered.
    So, it is not possible to use init_valid_mask callback.
    To avoid this issue, get rid of valid_mask and rely on ranges.
    
    Fixes: da9b142ab2c5 ("pinctrl: stmfx: Use the callback to populate valid_mask")
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Link: https://lore.kernel.org/r/20191104100908.10880-1-amelie.delaunay@st.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 564660028fcc..ccdf0bb21414 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -585,19 +585,6 @@ static int stmfx_pinctrl_gpio_function_enable(struct stmfx_pinctrl *pctl)
 	return stmfx_function_enable(pctl->stmfx, func);
 }
 
-static int stmfx_pinctrl_gpio_init_valid_mask(struct gpio_chip *gc,
-					      unsigned long *valid_mask,
-					      unsigned int ngpios)
-{
-	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
-	u32 n;
-
-	for_each_clear_bit(n, &pctl->gpio_valid_mask, ngpios)
-		clear_bit(n, valid_mask);
-
-	return 0;
-}
-
 static int stmfx_pinctrl_probe(struct platform_device *pdev)
 {
 	struct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);
@@ -660,7 +647,6 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->gpio_chip.ngpio = pctl->pctl_desc.npins;
 	pctl->gpio_chip.can_sleep = true;
 	pctl->gpio_chip.of_node = np;
-	pctl->gpio_chip.init_valid_mask = stmfx_pinctrl_gpio_init_valid_mask;
 
 	ret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);
 	if (ret) {

commit f086d1fe06cf3c5be928a6c2f8d1c54003f91d46
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Wed Oct 9 11:16:06 2019 +0200

    pinctrl: stmfx: add irq_request/release_resources callbacks
    
    When an STMFX IO is used as interrupt through the interrupt-controller
    binding, the STMFX driver should configure this IO as input. Default
    value of STMFX IO direction is input, but if the IO is used as output
    before the interrupt use, it will not work without these callbacks.
    
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Link: https://lore.kernel.org/r/20191009091606.17283-1-amelie.delaunay@st.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 974973777395..e6f76d2f18ab 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -505,6 +505,25 @@ static void stmfx_pinctrl_irq_bus_sync_unlock(struct irq_data *data)
 	mutex_unlock(&pctl->lock);
 }
 
+static int stmfx_gpio_irq_request_resources(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	int ret;
+
+	ret = stmfx_gpio_direction_input(gpio_chip, data->hwirq);
+	if (ret)
+		return ret;
+
+	return gpiochip_reqres_irq(gpio_chip, data->hwirq);
+}
+
+static void stmfx_gpio_irq_release_resources(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+
+	return gpiochip_relres_irq(gpio_chip, data->hwirq);
+}
+
 static void stmfx_pinctrl_irq_toggle_trigger(struct stmfx_pinctrl *pctl,
 					     unsigned int offset)
 {
@@ -678,6 +697,8 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->irq_chip.irq_set_type = stmfx_pinctrl_irq_set_type;
 	pctl->irq_chip.irq_bus_lock = stmfx_pinctrl_irq_bus_lock;
 	pctl->irq_chip.irq_bus_sync_unlock = stmfx_pinctrl_irq_bus_sync_unlock;
+	pctl->irq_chip.irq_request_resources = stmfx_gpio_irq_request_resources;
+	pctl->irq_chip.irq_release_resources = stmfx_gpio_irq_release_resources;
 
 	ret = gpiochip_irqchip_add_nested(&pctl->gpio_chip, &pctl->irq_chip,
 					  0, handle_bad_irq, IRQ_TYPE_NONE);

commit 2fd215b8fdbe4d3a609adbe3a323696393cb1e53
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Fri Oct 4 14:23:42 2019 +0200

    pinctrl: stmfx: fix null pointer on remove
    
    dev_get_platdata(&pdev->dev) returns a pointer on struct stmfx_pinctrl,
    not on struct stmfx (platform_set_drvdata(pdev, pctl); in probe).
    Pointer on struct stmfx is stored in driver data of pdev parent (in probe:
    struct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);).
    
    Fixes: 1490d9f841b1 ("pinctrl: Add STMFX GPIO expander Pinctrl/GPIO driver")
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Link: https://lore.kernel.org/r/20191004122342.22018-1-amelie.delaunay@st.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 974973777395..564660028fcc 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -705,7 +705,7 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 
 static int stmfx_pinctrl_remove(struct platform_device *pdev)
 {
-	struct stmfx *stmfx = dev_get_platdata(&pdev->dev);
+	struct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);
 
 	return stmfx_function_disable(stmfx,
 				      STMFX_FUNC_GPIO |

commit 3c2edc36a77420d8be05d656019dbc8c31535992
Merge: 32b90daf5caf cb0438e44360
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 14:19:33 2019 -0700

    Merge tag 'pinctrl-v5.4-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This is the bulk of pin control changes for the v5.4 kernel cycle:
    
      Core changes:
    
       - Fix errors in example code in the documentation.
    
      New drivers:
    
       - Add support for JZ4760, JZ4760B, X1000, X1000E and X1500 to the
         Ingenic driver.
    
       - Support Cirrus Logic Madera CS47L92 and CS47L15.
    
       - Support Allwinner Sunxi V3S.
    
       - Support Aspeed 2600 BMC.
    
       - Support Qualcomm SC7180.
    
       - Support Marvell MVEBU CS115.
    
      Driver improvements:
    
       - Clean up a few drivers to use the devm_platform_ioremap_resource()
         helper.
    
       - Pass the irqchip when registering the gpio_chip in some pin
         controllers that are also GPIO controllers.
    
       - Support suspend/resume in the Tegra driver.
    
       - Support pull-up on the Broadcom BCM2711.
    
       - The Intel driver can now request locked pads.
    
       - Fix the UFS reset pin in the Qualcomm SDM845 driver"
    
    * tag 'pinctrl-v5.4-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (112 commits)
      pinctrl: meson-gxbb: Fix wrong pinning definition for uart_c
      pinctrl: sh-pfc: Unlock on error in sh_pfc_func_set_mux()
      pinctrl: bcm: remove redundant assignment to pointer log
      pinctrl: iproc: Add 'get_direction' support
      pinctrl: iproc-gpio: Handle interrupts for multiple instances
      pinctrl: iproc-gpio: Fix incorrect pinconf configurations
      pinctrl: intel: mark intel_pin_to_gpio __maybe_unused
      pinctrl: qcom: sdm845: Fix UFS_RESET pin
      pinctrl: mvebu: add additional variant for standalone CP115
      pinctrl: mvebu: Add CP110 missing pin functionality
      dt-bindings: cp110: document the new CP115 pinctrl compatible
      pinctrl: bcm2835: Pass irqchip when adding gpiochip
      pinctrl: meson: meson: Add of_node_put() before return
      pinctrl/gpio: Take MUX usage into account
      dt-bindings: pinctrl: qcom-pmic-gpio: Add pm8150l support
      dt-bindings: pinctrl: qcom-pmic-gpio: Add pm8150b support
      dt-bindings: pinctrl: qcom-pmic-gpio: Add pm8150 support
      pinctrl: amd: disable spurious-firing GPIO IRQs
      pinctrl: rza2: Include the appropriate headers
      pinctrl: rza2: Drop driver use of consumer flags
      ...

commit eb1e8bd6e3900e3a3b9776cd1b09ecfc05573619
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Aug 19 11:30:58 2019 +0200

    gpio: Use callback presence to determine need of valid_mask
    
    After we switched the two drivers that have .need_valid_mask
    set to use the callback for setting up the .valid_mask,
    we can just use the presence of the .init_valid_mask()
    callback (or the OF reserved ranges, nota bene) to determine
    whether to allocate the mask or not and we can drop the
    .need_valid_mask field altogether.
    
    Cc: Benjamin Gaignard <benjamin.gaignard@st.com>
    Cc: Amelie Delaunay <amelie.delaunay@st.com>
    Cc: Stephen Boyd <swboyd@chromium.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190819093058.10863-1-linus.walleij@linaro.org

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 13b6d6f72bcc..dd5aa9a2dfe5 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -662,7 +662,6 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->gpio_chip.ngpio = pctl->pctl_desc.npins;
 	pctl->gpio_chip.can_sleep = true;
 	pctl->gpio_chip.of_node = np;
-	pctl->gpio_chip.need_valid_mask = true;
 	pctl->gpio_chip.init_valid_mask = stmfx_pinctrl_gpio_init_valid_mask;
 
 	ret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);

commit da9b142ab2c55ae8c46242a7624fdf62c4089e7f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Aug 19 11:11:40 2019 +0200

    pinctrl: stmfx: Use the callback to populate valid_mask
    
    This makes use of the existing callback to populate the
    valid mask instead of iteratively setting it up during
    probe.
    
    Cc: Benjamin Gaignard <benjamin.gaignard@st.com>
    Cc: Amelie Delaunay <amelie.delaunay@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190819091140.622-1-linus.walleij@linaro.org

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index d3332da35637..13b6d6f72bcc 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -585,12 +585,24 @@ static int stmfx_pinctrl_gpio_function_enable(struct stmfx_pinctrl *pctl)
 	return stmfx_function_enable(pctl->stmfx, func);
 }
 
+static int stmfx_pinctrl_gpio_init_valid_mask(struct gpio_chip *gc,
+					      unsigned long *valid_mask,
+					      unsigned int ngpios)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 n;
+
+	for_each_clear_bit(n, &pctl->gpio_valid_mask, ngpios)
+		clear_bit(n, valid_mask);
+
+	return 0;
+}
+
 static int stmfx_pinctrl_probe(struct platform_device *pdev)
 {
 	struct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);
 	struct device_node *np = pdev->dev.of_node;
 	struct stmfx_pinctrl *pctl;
-	u32 n;
 	int irq, ret;
 
 	pctl = devm_kzalloc(stmfx->dev, sizeof(*pctl), GFP_KERNEL);
@@ -651,6 +663,7 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->gpio_chip.can_sleep = true;
 	pctl->gpio_chip.of_node = np;
 	pctl->gpio_chip.need_valid_mask = true;
+	pctl->gpio_chip.init_valid_mask = stmfx_pinctrl_gpio_init_valid_mask;
 
 	ret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);
 	if (ret) {
@@ -668,8 +681,6 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->irq_chip.irq_set_type = stmfx_pinctrl_irq_set_type;
 	pctl->irq_chip.irq_bus_lock = stmfx_pinctrl_irq_bus_lock;
 	pctl->irq_chip.irq_bus_sync_unlock = stmfx_pinctrl_irq_bus_sync_unlock;
-	for_each_clear_bit(n, &pctl->gpio_valid_mask, pctl->gpio_chip.ngpio)
-		clear_bit(n, pctl->gpio_chip.valid_mask);
 
 	ret = gpiochip_irqchip_add_nested(&pctl->gpio_chip, &pctl->irq_chip,
 					  0, handle_bad_irq, IRQ_TYPE_NONE);

commit 64c4dcbfcc4ea3ae8f898e6dac836e57acb16b6b
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:33 2019 -0700

    pinctrl: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-gpio@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190730181557.90391-34-swboyd@chromium.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 31b6e511670f..d7e37b51984f 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -608,10 +608,8 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq <= 0) {
-		dev_err(pctl->dev, "failed to get irq\n");
+	if (irq <= 0)
 		return -ENXIO;
-	}
 
 	mutex_init(&pctl->lock);
 

commit a502b343ebd0eab38f3cb33fbb84011847cf5aac
Author: Alexandre Torgue <alexandre.torgue@st.com>
Date:   Thu Jul 25 13:16:56 2019 +0200

    pinctrl: stmfx: update pinconf settings
    
    According to the following tab (coming from STMFX datasheet), updates
    have to done in stmfx_pinconf_set function:
    
    -"type" has to be set when "bias" is configured as "pull-up or pull-down"
    -PIN_CONFIG_DRIVE_PUSH_PULL should only be used when gpio is configured as
     output. There is so no need to check direction.
    
    DIR | TYPE | PUPD | MFX GPIO configuration
    ----|------|------|---------------------------------------------------
    1   | 1    | 1    | OUTPUT open drain with internal pull-up resistor
    ----|------|------|---------------------------------------------------
    1   | 1    | 0    | OUTPUT open drain with internal pull-down resistor
    ----|------|------|---------------------------------------------------
    1   | 0    | 0/1  | OUTPUT push pull no pull
    ----|------|------|---------------------------------------------------
    0   | 1    | 1    | INPUT with internal pull-up resistor
    ----|------|------|---------------------------------------------------
    0   | 1    | 0    | INPUT with internal pull-down resistor
    ----|------|------|---------------------------------------------------
    0   | 0    | 1    | INPUT floating
    ----|------|------|---------------------------------------------------
    0   | 0    | 0    | analog (GPIO not used, default setting)
    
    Signed-off-by: Alexandre Torgue <alexandre.torgue@st.com>
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Link: https://lore.kernel.org/r/1564053416-32192-1-git-send-email-amelie.delaunay@st.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index d3332da35637..31b6e511670f 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -296,29 +296,29 @@ static int stmfx_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 		switch (param) {
 		case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
 		case PIN_CONFIG_BIAS_DISABLE:
+		case PIN_CONFIG_DRIVE_PUSH_PULL:
+			ret = stmfx_pinconf_set_type(pctl, pin, 0);
+			if (ret)
+				return ret;
+			break;
 		case PIN_CONFIG_BIAS_PULL_DOWN:
+			ret = stmfx_pinconf_set_type(pctl, pin, 1);
+			if (ret)
+				return ret;
 			ret = stmfx_pinconf_set_pupd(pctl, pin, 0);
 			if (ret)
 				return ret;
 			break;
 		case PIN_CONFIG_BIAS_PULL_UP:
-			ret = stmfx_pinconf_set_pupd(pctl, pin, 1);
+			ret = stmfx_pinconf_set_type(pctl, pin, 1);
 			if (ret)
 				return ret;
-			break;
-		case PIN_CONFIG_DRIVE_OPEN_DRAIN:
-			if (!dir)
-				ret = stmfx_pinconf_set_type(pctl, pin, 1);
-			else
-				ret = stmfx_pinconf_set_type(pctl, pin, 0);
+			ret = stmfx_pinconf_set_pupd(pctl, pin, 1);
 			if (ret)
 				return ret;
 			break;
-		case PIN_CONFIG_DRIVE_PUSH_PULL:
-			if (!dir)
-				ret = stmfx_pinconf_set_type(pctl, pin, 0);
-			else
-				ret = stmfx_pinconf_set_type(pctl, pin, 1);
+		case PIN_CONFIG_DRIVE_OPEN_DRAIN:
+			ret = stmfx_pinconf_set_type(pctl, pin, 1);
 			if (ret)
 				return ret;
 			break;

commit c6045b4e3cadc2d8d65be8601deb76811e08a6ce
Author: Benjamin Gaignard <benjamin.gaignard@st.com>
Date:   Wed May 22 17:29:25 2019 +0200

    pinctrl: stmfx: enable links creations
    
    Set create_link to inform pinctrl core that stmfx wants to create
    link with its consumers.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index eba872ce4a7c..d3332da35637 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -622,6 +622,7 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->pctl_desc.pins = stmfx_pins;
 	pctl->pctl_desc.npins = ARRAY_SIZE(stmfx_pins);
 	pctl->pctl_desc.owner = THIS_MODULE;
+	pctl->pctl_desc.link_consumers = true;
 
 	ret = devm_pinctrl_register_and_init(pctl->dev, &pctl->pctl_desc,
 					     pctl, &pctl->pctl_dev);

commit d17ed797b8fd5c8765cd959ac44aaa2f090f5a89
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon May 13 07:38:04 2019 +0100

    pinctrl: stmfx: Fix 'warn: bitwise AND condition is false here'
    
    drivers/pinctrl/pinctrl-stmfx.c:441 stmfx_pinctrl_irq_set_type() warn: bitwise AND condition is false here
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 074c8fa3e75c..eba872ce4a7c 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -437,7 +437,7 @@ static int stmfx_pinctrl_irq_set_type(struct irq_data *data, unsigned int type)
 	u32 reg = get_reg(data->hwirq);
 	u32 mask = get_mask(data->hwirq);
 
-	if (type & IRQ_TYPE_NONE)
+	if (type == IRQ_TYPE_NONE)
 		return -EINVAL;
 
 	if (type & IRQ_TYPE_EDGE_BOTH) {

commit 28a853860f719a89774a28596e1d1fdf1cd4a611
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon May 13 07:36:16 2019 +0100

    pinctrl: stmfx: Fix 'warn: unsigned <VAR> is never less than zero'
    
    smatch warnings:
    drivers/pinctrl/pinctrl-stmfx.c:225 stmfx_pinconf_get() warn: unsigned 'dir' is never less than zero.
    drivers/pinctrl/pinctrl-stmfx.c:228 stmfx_pinconf_get() warn: unsigned 'type' is never less than zero.
    drivers/pinctrl/pinctrl-stmfx.c:231 stmfx_pinconf_get() warn: unsigned 'pupd' is never less than zero.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index bcd81269445e..074c8fa3e75c 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -213,9 +213,8 @@ static int stmfx_pinconf_get(struct pinctrl_dev *pctldev,
 	struct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
 	u32 param = pinconf_to_config_param(*config);
 	struct pinctrl_gpio_range *range;
-	u32 dir, type, pupd;
 	u32 arg = 0;
-	int ret;
+	int ret, dir, type, pupd;
 
 	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);
 	if (!range)

commit 1490d9f841b186664f9d3ca213dcfa4464a60680
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Thu May 9 10:58:51 2019 +0200

    pinctrl: Add STMFX GPIO expander Pinctrl/GPIO driver
    
    This patch adds pinctrl/GPIO driver for STMicroelectronics
    Multi-Function eXpander (STMFX) GPIO expander.
    STMFX is an I2C slave controller, offering up to 24 GPIOs.
    The driver relies on generic pin config interface to configure the GPIOs.
    
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
new file mode 100644
index 000000000000..bcd81269445e
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -0,0 +1,820 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STMicroelectronics Multi-Function eXpander (STMFX) GPIO expander
+ *
+ * Copyright (C) 2019 STMicroelectronics
+ * Author(s): Amelie Delaunay <amelie.delaunay@st.com>.
+ */
+#include <linux/gpio/driver.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/stmfx.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinmux.h>
+
+#include "core.h"
+#include "pinctrl-utils.h"
+
+/* GPIOs expander */
+/* GPIO_STATE1 0x10, GPIO_STATE2 0x11, GPIO_STATE3 0x12 */
+#define STMFX_REG_GPIO_STATE		STMFX_REG_GPIO_STATE1 /* R */
+/* GPIO_DIR1 0x60, GPIO_DIR2 0x61, GPIO_DIR3 0x63 */
+#define STMFX_REG_GPIO_DIR		STMFX_REG_GPIO_DIR1 /* RW */
+/* GPIO_TYPE1 0x64, GPIO_TYPE2 0x65, GPIO_TYPE3 0x66 */
+#define STMFX_REG_GPIO_TYPE		STMFX_REG_GPIO_TYPE1 /* RW */
+/* GPIO_PUPD1 0x68, GPIO_PUPD2 0x69, GPIO_PUPD3 0x6A */
+#define STMFX_REG_GPIO_PUPD		STMFX_REG_GPIO_PUPD1 /* RW */
+/* GPO_SET1 0x6C, GPO_SET2 0x6D, GPO_SET3 0x6E */
+#define STMFX_REG_GPO_SET		STMFX_REG_GPO_SET1 /* RW */
+/* GPO_CLR1 0x70, GPO_CLR2 0x71, GPO_CLR3 0x72 */
+#define STMFX_REG_GPO_CLR		STMFX_REG_GPO_CLR1 /* RW */
+/* IRQ_GPI_SRC1 0x48, IRQ_GPI_SRC2 0x49, IRQ_GPI_SRC3 0x4A */
+#define STMFX_REG_IRQ_GPI_SRC		STMFX_REG_IRQ_GPI_SRC1 /* RW */
+/* IRQ_GPI_EVT1 0x4C, IRQ_GPI_EVT2 0x4D, IRQ_GPI_EVT3 0x4E */
+#define STMFX_REG_IRQ_GPI_EVT		STMFX_REG_IRQ_GPI_EVT1 /* RW */
+/* IRQ_GPI_TYPE1 0x50, IRQ_GPI_TYPE2 0x51, IRQ_GPI_TYPE3 0x52 */
+#define STMFX_REG_IRQ_GPI_TYPE		STMFX_REG_IRQ_GPI_TYPE1 /* RW */
+/* IRQ_GPI_PENDING1 0x0C, IRQ_GPI_PENDING2 0x0D, IRQ_GPI_PENDING3 0x0E*/
+#define STMFX_REG_IRQ_GPI_PENDING	STMFX_REG_IRQ_GPI_PENDING1 /* R */
+/* IRQ_GPI_ACK1 0x54, IRQ_GPI_ACK2 0x55, IRQ_GPI_ACK3 0x56 */
+#define STMFX_REG_IRQ_GPI_ACK		STMFX_REG_IRQ_GPI_ACK1 /* RW */
+
+#define NR_GPIO_REGS			3
+#define NR_GPIOS_PER_REG		8
+#define get_reg(offset)			((offset) / NR_GPIOS_PER_REG)
+#define get_shift(offset)		((offset) % NR_GPIOS_PER_REG)
+#define get_mask(offset)		(BIT(get_shift(offset)))
+
+/*
+ * STMFX pinctrl can have up to 24 pins if STMFX other functions are not used.
+ * Pins availability is managed thanks to gpio-ranges property.
+ */
+static const struct pinctrl_pin_desc stmfx_pins[] = {
+	PINCTRL_PIN(0, "gpio0"),
+	PINCTRL_PIN(1, "gpio1"),
+	PINCTRL_PIN(2, "gpio2"),
+	PINCTRL_PIN(3, "gpio3"),
+	PINCTRL_PIN(4, "gpio4"),
+	PINCTRL_PIN(5, "gpio5"),
+	PINCTRL_PIN(6, "gpio6"),
+	PINCTRL_PIN(7, "gpio7"),
+	PINCTRL_PIN(8, "gpio8"),
+	PINCTRL_PIN(9, "gpio9"),
+	PINCTRL_PIN(10, "gpio10"),
+	PINCTRL_PIN(11, "gpio11"),
+	PINCTRL_PIN(12, "gpio12"),
+	PINCTRL_PIN(13, "gpio13"),
+	PINCTRL_PIN(14, "gpio14"),
+	PINCTRL_PIN(15, "gpio15"),
+	PINCTRL_PIN(16, "agpio0"),
+	PINCTRL_PIN(17, "agpio1"),
+	PINCTRL_PIN(18, "agpio2"),
+	PINCTRL_PIN(19, "agpio3"),
+	PINCTRL_PIN(20, "agpio4"),
+	PINCTRL_PIN(21, "agpio5"),
+	PINCTRL_PIN(22, "agpio6"),
+	PINCTRL_PIN(23, "agpio7"),
+};
+
+struct stmfx_pinctrl {
+	struct device *dev;
+	struct stmfx *stmfx;
+	struct pinctrl_dev *pctl_dev;
+	struct pinctrl_desc pctl_desc;
+	struct gpio_chip gpio_chip;
+	struct irq_chip irq_chip;
+	struct mutex lock; /* IRQ bus lock */
+	unsigned long gpio_valid_mask;
+	/* Cache of IRQ_GPI_* registers for bus_lock */
+	u8 irq_gpi_src[NR_GPIO_REGS];
+	u8 irq_gpi_type[NR_GPIO_REGS];
+	u8 irq_gpi_evt[NR_GPIO_REGS];
+	u8 irq_toggle_edge[NR_GPIO_REGS];
+#ifdef CONFIG_PM
+	/* Backup of GPIO_* registers for suspend/resume */
+	u8 bkp_gpio_state[NR_GPIO_REGS];
+	u8 bkp_gpio_dir[NR_GPIO_REGS];
+	u8 bkp_gpio_type[NR_GPIO_REGS];
+	u8 bkp_gpio_pupd[NR_GPIO_REGS];
+#endif
+};
+
+static int stmfx_gpio_get(struct gpio_chip *gc, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_STATE + get_reg(offset);
+	u32 mask = get_mask(offset);
+	u32 value;
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &value);
+
+	return ret ? ret : !!(value & mask);
+}
+
+static void stmfx_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = value ? STMFX_REG_GPO_SET : STMFX_REG_GPO_CLR;
+	u32 mask = get_mask(offset);
+
+	regmap_write_bits(pctl->stmfx->map, reg + get_reg(offset),
+			  mask, mask);
+}
+
+static int stmfx_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);
+	u32 mask = get_mask(offset);
+	u32 val;
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &val);
+	/*
+	 * On stmfx, gpio pins direction is (0)input, (1)output.
+	 * .get_direction returns 0=out, 1=in
+	 */
+
+	return ret ? ret : !(val & mask);
+}
+
+static int stmfx_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, 0);
+}
+
+static int stmfx_gpio_direction_output(struct gpio_chip *gc,
+				       unsigned int offset, int value)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	stmfx_gpio_set(gc, offset, value);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, mask);
+}
+
+static int stmfx_pinconf_get_pupd(struct stmfx_pinctrl *pctl,
+				  unsigned int offset)
+{
+	u32 reg = STMFX_REG_GPIO_PUPD + get_reg(offset);
+	u32 pupd, mask = get_mask(offset);
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &pupd);
+	if (ret)
+		return ret;
+
+	return !!(pupd & mask);
+}
+
+static int stmfx_pinconf_set_pupd(struct stmfx_pinctrl *pctl,
+				  unsigned int offset, u32 pupd)
+{
+	u32 reg = STMFX_REG_GPIO_PUPD + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, pupd ? mask : 0);
+}
+
+static int stmfx_pinconf_get_type(struct stmfx_pinctrl *pctl,
+				  unsigned int offset)
+{
+	u32 reg = STMFX_REG_GPIO_TYPE + get_reg(offset);
+	u32 type, mask = get_mask(offset);
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &type);
+	if (ret)
+		return ret;
+
+	return !!(type & mask);
+}
+
+static int stmfx_pinconf_set_type(struct stmfx_pinctrl *pctl,
+				  unsigned int offset, u32 type)
+{
+	u32 reg = STMFX_REG_GPIO_TYPE + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, type ? mask : 0);
+}
+
+static int stmfx_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned int pin, unsigned long *config)
+{
+	struct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	u32 param = pinconf_to_config_param(*config);
+	struct pinctrl_gpio_range *range;
+	u32 dir, type, pupd;
+	u32 arg = 0;
+	int ret;
+
+	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);
+	if (!range)
+		return -EINVAL;
+
+	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, pin);
+	if (dir < 0)
+		return dir;
+	type = stmfx_pinconf_get_type(pctl, pin);
+	if (type < 0)
+		return type;
+	pupd = stmfx_pinconf_get_pupd(pctl, pin);
+	if (pupd < 0)
+		return pupd;
+
+	switch (param) {
+	case PIN_CONFIG_BIAS_DISABLE:
+		if ((!dir && (!type || !pupd)) || (dir && !type))
+			arg = 1;
+		break;
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		if (dir && type && !pupd)
+			arg = 1;
+		break;
+	case PIN_CONFIG_BIAS_PULL_UP:
+		if (type && pupd)
+			arg = 1;
+		break;
+	case PIN_CONFIG_DRIVE_OPEN_DRAIN:
+		if ((!dir && type) || (dir && !type))
+			arg = 1;
+		break;
+	case PIN_CONFIG_DRIVE_PUSH_PULL:
+		if ((!dir && !type) || (dir && type))
+			arg = 1;
+		break;
+	case PIN_CONFIG_OUTPUT:
+		if (dir)
+			return -EINVAL;
+
+		ret = stmfx_gpio_get(&pctl->gpio_chip, pin);
+		if (ret < 0)
+			return ret;
+
+		arg = ret;
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, arg);
+
+	return 0;
+}
+
+static int stmfx_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
+			     unsigned long *configs, unsigned int num_configs)
+{
+	struct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct pinctrl_gpio_range *range;
+	enum pin_config_param param;
+	u32 arg;
+	int dir, i, ret;
+
+	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);
+	if (!range) {
+		dev_err(pctldev->dev, "pin %d is not available\n", pin);
+		return -EINVAL;
+	}
+
+	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, pin);
+	if (dir < 0)
+		return dir;
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+		case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
+		case PIN_CONFIG_BIAS_DISABLE:
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			ret = stmfx_pinconf_set_pupd(pctl, pin, 0);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_BIAS_PULL_UP:
+			ret = stmfx_pinconf_set_pupd(pctl, pin, 1);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_DRIVE_OPEN_DRAIN:
+			if (!dir)
+				ret = stmfx_pinconf_set_type(pctl, pin, 1);
+			else
+				ret = stmfx_pinconf_set_type(pctl, pin, 0);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_DRIVE_PUSH_PULL:
+			if (!dir)
+				ret = stmfx_pinconf_set_type(pctl, pin, 0);
+			else
+				ret = stmfx_pinconf_set_type(pctl, pin, 1);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_OUTPUT:
+			ret = stmfx_gpio_direction_output(&pctl->gpio_chip,
+							  pin, arg);
+			if (ret)
+				return ret;
+			break;
+		default:
+			return -ENOTSUPP;
+		}
+	}
+
+	return 0;
+}
+
+static void stmfx_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+				   struct seq_file *s, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct pinctrl_gpio_range *range;
+	int dir, type, pupd, val;
+
+	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, offset);
+	if (!range)
+		return;
+
+	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, offset);
+	if (dir < 0)
+		return;
+	type = stmfx_pinconf_get_type(pctl, offset);
+	if (type < 0)
+		return;
+	pupd = stmfx_pinconf_get_pupd(pctl, offset);
+	if (pupd < 0)
+		return;
+	val = stmfx_gpio_get(&pctl->gpio_chip, offset);
+	if (val < 0)
+		return;
+
+	if (!dir) {
+		seq_printf(s, "output %s ", val ? "high" : "low");
+		if (type)
+			seq_printf(s, "open drain %s internal pull-up ",
+				   pupd ? "with" : "without");
+		else
+			seq_puts(s, "push pull no pull ");
+	} else {
+		seq_printf(s, "input %s ", val ? "high" : "low");
+		if (type)
+			seq_printf(s, "with internal pull-%s ",
+				   pupd ? "up" : "down");
+		else
+			seq_printf(s, "%s ", pupd ? "floating" : "analog");
+	}
+}
+
+static const struct pinconf_ops stmfx_pinconf_ops = {
+	.pin_config_get		= stmfx_pinconf_get,
+	.pin_config_set		= stmfx_pinconf_set,
+	.pin_config_dbg_show	= stmfx_pinconf_dbg_show,
+};
+
+static int stmfx_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return 0;
+}
+
+static const char *stmfx_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+						unsigned int selector)
+{
+	return NULL;
+}
+
+static int stmfx_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+					unsigned int selector,
+					const unsigned int **pins,
+					unsigned int *num_pins)
+{
+	return -ENOTSUPP;
+}
+
+static const struct pinctrl_ops stmfx_pinctrl_ops = {
+	.get_groups_count = stmfx_pinctrl_get_groups_count,
+	.get_group_name = stmfx_pinctrl_get_group_name,
+	.get_group_pins = stmfx_pinctrl_get_group_pins,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+static void stmfx_pinctrl_irq_mask(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	pctl->irq_gpi_src[reg] &= ~mask;
+}
+
+static void stmfx_pinctrl_irq_unmask(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	pctl->irq_gpi_src[reg] |= mask;
+}
+
+static int stmfx_pinctrl_irq_set_type(struct irq_data *data, unsigned int type)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	if (type & IRQ_TYPE_NONE)
+		return -EINVAL;
+
+	if (type & IRQ_TYPE_EDGE_BOTH) {
+		pctl->irq_gpi_evt[reg] |= mask;
+		irq_set_handler_locked(data, handle_edge_irq);
+	} else {
+		pctl->irq_gpi_evt[reg] &= ~mask;
+		irq_set_handler_locked(data, handle_level_irq);
+	}
+
+	if ((type & IRQ_TYPE_EDGE_RISING) || (type & IRQ_TYPE_LEVEL_HIGH))
+		pctl->irq_gpi_type[reg] |= mask;
+	else
+		pctl->irq_gpi_type[reg] &= ~mask;
+
+	/*
+	 * In case of (type & IRQ_TYPE_EDGE_BOTH), we need to know current
+	 * GPIO value to set the right edge trigger. But in atomic context
+	 * here we can't access registers over I2C. That's why (type &
+	 * IRQ_TYPE_EDGE_BOTH) will be managed in .irq_sync_unlock.
+	 */
+
+	if ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)
+		pctl->irq_toggle_edge[reg] |= mask;
+	else
+		pctl->irq_toggle_edge[reg] &= mask;
+
+	return 0;
+}
+
+static void stmfx_pinctrl_irq_bus_lock(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+
+	mutex_lock(&pctl->lock);
+}
+
+static void stmfx_pinctrl_irq_bus_sync_unlock(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	/*
+	 * In case of IRQ_TYPE_EDGE_BOTH), read the current GPIO value
+	 * (this couldn't be done in .irq_set_type because of atomic context)
+	 * to set the right irq trigger type.
+	 */
+	if (pctl->irq_toggle_edge[reg] & mask) {
+		if (stmfx_gpio_get(gpio_chip, data->hwirq))
+			pctl->irq_gpi_type[reg] &= ~mask;
+		else
+			pctl->irq_gpi_type[reg] |= mask;
+	}
+
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_EVT,
+			  pctl->irq_gpi_evt, NR_GPIO_REGS);
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_TYPE,
+			  pctl->irq_gpi_type, NR_GPIO_REGS);
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,
+			  pctl->irq_gpi_src, NR_GPIO_REGS);
+
+	mutex_unlock(&pctl->lock);
+}
+
+static void stmfx_pinctrl_irq_toggle_trigger(struct stmfx_pinctrl *pctl,
+					     unsigned int offset)
+{
+	u32 reg = get_reg(offset);
+	u32 mask = get_mask(offset);
+	int val;
+
+	if (!(pctl->irq_toggle_edge[reg] & mask))
+		return;
+
+	val = stmfx_gpio_get(&pctl->gpio_chip, offset);
+	if (val < 0)
+		return;
+
+	if (val) {
+		pctl->irq_gpi_type[reg] &= mask;
+		regmap_write_bits(pctl->stmfx->map,
+				  STMFX_REG_IRQ_GPI_TYPE + reg,
+				  mask, 0);
+
+	} else {
+		pctl->irq_gpi_type[reg] |= mask;
+		regmap_write_bits(pctl->stmfx->map,
+				  STMFX_REG_IRQ_GPI_TYPE + reg,
+				  mask, mask);
+	}
+}
+
+static irqreturn_t stmfx_pinctrl_irq_thread_fn(int irq, void *dev_id)
+{
+	struct stmfx_pinctrl *pctl = (struct stmfx_pinctrl *)dev_id;
+	struct gpio_chip *gc = &pctl->gpio_chip;
+	u8 pending[NR_GPIO_REGS];
+	u8 src[NR_GPIO_REGS] = {0, 0, 0};
+	unsigned long n, status;
+	int ret;
+
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_IRQ_GPI_PENDING,
+			       &pending, NR_GPIO_REGS);
+	if (ret)
+		return IRQ_NONE;
+
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,
+			  src, NR_GPIO_REGS);
+
+	status = *(unsigned long *)pending;
+	for_each_set_bit(n, &status, gc->ngpio) {
+		handle_nested_irq(irq_find_mapping(gc->irq.domain, n));
+		stmfx_pinctrl_irq_toggle_trigger(pctl, n);
+	}
+
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,
+			  pctl->irq_gpi_src, NR_GPIO_REGS);
+
+	return IRQ_HANDLED;
+}
+
+static int stmfx_pinctrl_gpio_function_enable(struct stmfx_pinctrl *pctl)
+{
+	struct pinctrl_gpio_range *gpio_range;
+	struct pinctrl_dev *pctl_dev = pctl->pctl_dev;
+	u32 func = STMFX_FUNC_GPIO;
+
+	pctl->gpio_valid_mask = GENMASK(15, 0);
+
+	gpio_range = pinctrl_find_gpio_range_from_pin(pctl_dev, 16);
+	if (gpio_range) {
+		func |= STMFX_FUNC_ALTGPIO_LOW;
+		pctl->gpio_valid_mask |= GENMASK(19, 16);
+	}
+
+	gpio_range = pinctrl_find_gpio_range_from_pin(pctl_dev, 20);
+	if (gpio_range) {
+		func |= STMFX_FUNC_ALTGPIO_HIGH;
+		pctl->gpio_valid_mask |= GENMASK(23, 20);
+	}
+
+	return stmfx_function_enable(pctl->stmfx, func);
+}
+
+static int stmfx_pinctrl_probe(struct platform_device *pdev)
+{
+	struct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);
+	struct device_node *np = pdev->dev.of_node;
+	struct stmfx_pinctrl *pctl;
+	u32 n;
+	int irq, ret;
+
+	pctl = devm_kzalloc(stmfx->dev, sizeof(*pctl), GFP_KERNEL);
+	if (!pctl)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pctl);
+
+	pctl->dev = &pdev->dev;
+	pctl->stmfx = stmfx;
+
+	if (!of_find_property(np, "gpio-ranges", NULL)) {
+		dev_err(pctl->dev, "missing required gpio-ranges property\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(pctl->dev, "failed to get irq\n");
+		return -ENXIO;
+	}
+
+	mutex_init(&pctl->lock);
+
+	/* Register pin controller */
+	pctl->pctl_desc.name = "stmfx-pinctrl";
+	pctl->pctl_desc.pctlops = &stmfx_pinctrl_ops;
+	pctl->pctl_desc.confops = &stmfx_pinconf_ops;
+	pctl->pctl_desc.pins = stmfx_pins;
+	pctl->pctl_desc.npins = ARRAY_SIZE(stmfx_pins);
+	pctl->pctl_desc.owner = THIS_MODULE;
+
+	ret = devm_pinctrl_register_and_init(pctl->dev, &pctl->pctl_desc,
+					     pctl, &pctl->pctl_dev);
+	if (ret) {
+		dev_err(pctl->dev, "pinctrl registration failed\n");
+		return ret;
+	}
+
+	ret = pinctrl_enable(pctl->pctl_dev);
+	if (ret) {
+		dev_err(pctl->dev, "pinctrl enable failed\n");
+		return ret;
+	}
+
+	/* Register gpio controller */
+	pctl->gpio_chip.label = "stmfx-gpio";
+	pctl->gpio_chip.parent = pctl->dev;
+	pctl->gpio_chip.get_direction = stmfx_gpio_get_direction;
+	pctl->gpio_chip.direction_input = stmfx_gpio_direction_input;
+	pctl->gpio_chip.direction_output = stmfx_gpio_direction_output;
+	pctl->gpio_chip.get = stmfx_gpio_get;
+	pctl->gpio_chip.set = stmfx_gpio_set;
+	pctl->gpio_chip.set_config = gpiochip_generic_config;
+	pctl->gpio_chip.base = -1;
+	pctl->gpio_chip.ngpio = pctl->pctl_desc.npins;
+	pctl->gpio_chip.can_sleep = true;
+	pctl->gpio_chip.of_node = np;
+	pctl->gpio_chip.need_valid_mask = true;
+
+	ret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);
+	if (ret) {
+		dev_err(pctl->dev, "gpio_chip registration failed\n");
+		return ret;
+	}
+
+	ret = stmfx_pinctrl_gpio_function_enable(pctl);
+	if (ret)
+		return ret;
+
+	pctl->irq_chip.name = dev_name(pctl->dev);
+	pctl->irq_chip.irq_mask = stmfx_pinctrl_irq_mask;
+	pctl->irq_chip.irq_unmask = stmfx_pinctrl_irq_unmask;
+	pctl->irq_chip.irq_set_type = stmfx_pinctrl_irq_set_type;
+	pctl->irq_chip.irq_bus_lock = stmfx_pinctrl_irq_bus_lock;
+	pctl->irq_chip.irq_bus_sync_unlock = stmfx_pinctrl_irq_bus_sync_unlock;
+	for_each_clear_bit(n, &pctl->gpio_valid_mask, pctl->gpio_chip.ngpio)
+		clear_bit(n, pctl->gpio_chip.valid_mask);
+
+	ret = gpiochip_irqchip_add_nested(&pctl->gpio_chip, &pctl->irq_chip,
+					  0, handle_bad_irq, IRQ_TYPE_NONE);
+	if (ret) {
+		dev_err(pctl->dev, "cannot add irqchip to gpiochip\n");
+		return ret;
+	}
+
+	ret = devm_request_threaded_irq(pctl->dev, irq, NULL,
+					stmfx_pinctrl_irq_thread_fn,
+					IRQF_ONESHOT,
+					pctl->irq_chip.name, pctl);
+	if (ret) {
+		dev_err(pctl->dev, "cannot request irq%d\n", irq);
+		return ret;
+	}
+
+	gpiochip_set_nested_irqchip(&pctl->gpio_chip, &pctl->irq_chip, irq);
+
+	dev_info(pctl->dev,
+		 "%ld GPIOs available\n", hweight_long(pctl->gpio_valid_mask));
+
+	return 0;
+}
+
+static int stmfx_pinctrl_remove(struct platform_device *pdev)
+{
+	struct stmfx *stmfx = dev_get_platdata(&pdev->dev);
+
+	return stmfx_function_disable(stmfx,
+				      STMFX_FUNC_GPIO |
+				      STMFX_FUNC_ALTGPIO_LOW |
+				      STMFX_FUNC_ALTGPIO_HIGH);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int stmfx_pinctrl_backup_regs(struct stmfx_pinctrl *pctl)
+{
+	int ret;
+
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_STATE,
+			       &pctl->bkp_gpio_state, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_DIR,
+			       &pctl->bkp_gpio_dir, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_TYPE,
+			       &pctl->bkp_gpio_type, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_PUPD,
+			       &pctl->bkp_gpio_pupd, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stmfx_pinctrl_restore_regs(struct stmfx_pinctrl *pctl)
+{
+	int ret;
+
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_DIR,
+				pctl->bkp_gpio_dir, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_TYPE,
+				pctl->bkp_gpio_type, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_PUPD,
+				pctl->bkp_gpio_pupd, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPO_SET,
+				pctl->bkp_gpio_state, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_EVT,
+				pctl->irq_gpi_evt, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_TYPE,
+				pctl->irq_gpi_type, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,
+				pctl->irq_gpi_src, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stmfx_pinctrl_suspend(struct device *dev)
+{
+	struct stmfx_pinctrl *pctl = dev_get_drvdata(dev);
+	int ret;
+
+	ret = stmfx_pinctrl_backup_regs(pctl);
+	if (ret) {
+		dev_err(pctl->dev, "registers backup failure\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stmfx_pinctrl_resume(struct device *dev)
+{
+	struct stmfx_pinctrl *pctl = dev_get_drvdata(dev);
+	int ret;
+
+	ret = stmfx_pinctrl_restore_regs(pctl);
+	if (ret) {
+		dev_err(pctl->dev, "registers restoration failure\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(stmfx_pinctrl_dev_pm_ops,
+			 stmfx_pinctrl_suspend, stmfx_pinctrl_resume);
+
+static const struct of_device_id stmfx_pinctrl_of_match[] = {
+	{ .compatible = "st,stmfx-0300-pinctrl", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stmfx_pinctrl_of_match);
+
+static struct platform_driver stmfx_pinctrl_driver = {
+	.driver = {
+		.name = "stmfx-pinctrl",
+		.of_match_table = stmfx_pinctrl_of_match,
+		.pm = &stmfx_pinctrl_dev_pm_ops,
+	},
+	.probe = stmfx_pinctrl_probe,
+	.remove = stmfx_pinctrl_remove,
+};
+module_platform_driver(stmfx_pinctrl_driver);
+
+MODULE_DESCRIPTION("STMFX pinctrl/GPIO driver");
+MODULE_AUTHOR("Amelie Delaunay <amelie.delaunay@st.com>");
+MODULE_LICENSE("GPL v2");
