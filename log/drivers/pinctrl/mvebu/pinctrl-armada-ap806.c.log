commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
index 66e442260a4e..89bab536717d 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Marvell Armada ap806 pinctrl driver based on mvebu pinctrl core
  *
@@ -5,11 +6,6 @@
  *
  * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  * Hanna Hawa <hannah@marvell.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/err.h>

commit 86fbd09440f39d7eacf30684985ebe9370f5f813
Author: Hanna Hawa <hannah@marvell.com>
Date:   Mon Jun 12 17:34:56 2017 +0200

    pinctrl: mvebu: add driver for Armada AP806 pinctrl
    
    This commit adds a pinctrl driver for the pin-muxing controller found in
    the AP806 part of the Marvell Armada 7K and 8K SoCs. Its register
    interface is compatible with the one used by previous mvebu pin
    controllers, so the common logic in drivers/pinctrl/mvebu/pinctrl-mvebu.c
    is used.
    
    Signed-off-by: Hanna Hawa <hannah@marvell.com>
    Reviewed-by: Shadi Ammouri <shadi@marvell.com>
    [updated for mvebu pinctrl changes
     - converted to simple_mmio
     - removed unimplemented .remove function
     - removed DTS description
      - converted  to use syscon/regmap
     --rmk]
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
new file mode 100644
index 000000000000..66e442260a4e
--- /dev/null
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
@@ -0,0 +1,140 @@
+/*
+ * Marvell Armada ap806 pinctrl driver based on mvebu pinctrl core
+ *
+ * Copyright (C) 2017 Marvell
+ *
+ * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+ * Hanna Hawa <hannah@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+
+#include "pinctrl-mvebu.h"
+
+static struct mvebu_mpp_mode armada_ap806_mpp_modes[] = {
+	MPP_MODE(0,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "clk"),
+		 MPP_FUNCTION(3, "spi0",    "clk")),
+	MPP_MODE(1,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "cmd"),
+		 MPP_FUNCTION(3, "spi0",    "miso")),
+	MPP_MODE(2,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d0"),
+		 MPP_FUNCTION(3, "spi0",    "mosi")),
+	MPP_MODE(3,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d1"),
+		 MPP_FUNCTION(3, "spi0",    "cs0n")),
+	MPP_MODE(4,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d2"),
+		 MPP_FUNCTION(3, "i2c0",    "sda")),
+	MPP_MODE(5,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d3"),
+		 MPP_FUNCTION(3, "i2c0",    "sdk")),
+	MPP_MODE(6,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "ds")),
+	MPP_MODE(7,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d4"),
+		 MPP_FUNCTION(3, "uart1",   "rxd")),
+	MPP_MODE(8,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d5"),
+		 MPP_FUNCTION(3, "uart1",   "txd")),
+	MPP_MODE(9,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d6"),
+		 MPP_FUNCTION(3, "spi0",    "cs1n")),
+	MPP_MODE(10,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d7")),
+	MPP_MODE(11,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(3, "uart0",   "txd")),
+	MPP_MODE(12,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "pw_off"),
+		 MPP_FUNCTION(2, "sdio",    "hw_rst")),
+	MPP_MODE(13,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(14,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(15,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(16,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(17,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(18,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(19,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(3, "uart0",   "rxd"),
+		 MPP_FUNCTION(4, "sdio",    "pw_off")),
+};
+
+static struct mvebu_pinctrl_soc_info armada_ap806_pinctrl_info;
+
+static const struct of_device_id armada_ap806_pinctrl_of_match[] = {
+	{
+		.compatible = "marvell,ap806-pinctrl",
+	},
+	{ },
+};
+
+static const struct mvebu_mpp_ctrl armada_ap806_mpp_controls[] = {
+	MPP_FUNC_CTRL(0, 19, NULL, mvebu_regmap_mpp_ctrl),
+};
+
+static struct pinctrl_gpio_range armada_ap806_mpp_gpio_ranges[] = {
+	MPP_GPIO_RANGE(0,   0,  0, 20),
+};
+
+static int armada_ap806_pinctrl_probe(struct platform_device *pdev)
+{
+	struct mvebu_pinctrl_soc_info *soc = &armada_ap806_pinctrl_info;
+	const struct of_device_id *match =
+		of_match_device(armada_ap806_pinctrl_of_match, &pdev->dev);
+
+	if (!match || !pdev->dev.parent)
+		return -ENODEV;
+
+	soc->variant = 0; /* no variants for Armada AP806 */
+	soc->controls = armada_ap806_mpp_controls;
+	soc->ncontrols = ARRAY_SIZE(armada_ap806_mpp_controls);
+	soc->gpioranges = armada_ap806_mpp_gpio_ranges;
+	soc->ngpioranges = ARRAY_SIZE(armada_ap806_mpp_gpio_ranges);
+	soc->modes = armada_ap806_mpp_modes;
+	soc->nmodes = armada_ap806_mpp_controls[0].npins;
+
+	pdev->dev.platform_data = soc;
+
+	return mvebu_pinctrl_simple_regmap_probe(pdev, pdev->dev.parent, 0);
+}
+
+static struct platform_driver armada_ap806_pinctrl_driver = {
+	.driver = {
+		.name = "armada-ap806-pinctrl",
+		.of_match_table = of_match_ptr(armada_ap806_pinctrl_of_match),
+	},
+	.probe = armada_ap806_pinctrl_probe,
+};
+
+builtin_platform_driver(armada_ap806_pinctrl_driver);
