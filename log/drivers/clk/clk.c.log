commit 6f630784cc0d92fb58ea326e2bc01aa056279ecb
Merge: 3a2a87517421 9ac1eafa885a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 11:42:19 2020 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "This time around we have four lines of diff in the core framework,
      removing a function that isn't used anymore. Otherwise the main new
      thing for the common clk framework is that it is selectable in the
      Kconfig language now. Hopefully this will let clk drivers and clk
      consumers be testable on more than the architectures that support the
      clk framework. The goal is to introduce some Kunit tests for the
      framework.
    
      Outside of the core framework we have the usual set of various driver
      updates and non-critical fixes. The dirstat shows that the new
      Baikal-T1 driver is the largest addition this time around in terms of
      lines of code. After that the x86 (Intel), Qualcomm, and Mediatek
      drivers introduce many lines to support new or upcoming SoCs. After
      that the dirstat shows the usual suspects working on their SoC support
      by fixing minor bugs, correcting data and converting some of their DT
      bindings to YAML.
    
      Core:
       - Allow the COMMON_CLK config to be selectable
    
      New Drivers:
       - Clk driver for Baikal-T1 SoCs
       - Mediatek MT6765 clock support
       - Support for Intel Agilex clks
       - Add support for X1830 and X1000 Ingenic SoC clk controllers
       - Add support for the new Renesas RZ/G1H (R8A7742) SoC
       - Add support for Qualcomm's MSM8939 Generic Clock Controller
    
      Updates:
       - Support IDT VersaClock 5P49V5925
       - Bunch of updates for HSDK clock generation unit (CGU) driver
       - Start making audio and GPU clks work on Marvell MMP2/MMP3 SoCs
       - Add some GPU, NPU, and UFS clks to Qualcomm SM8150 driver
       - Enable supply regulators for GPU gdscs on Qualcomm SoCs
       - Add support for Si5342, Si5344 and Si5345 chips
       - Support custom flags in Xilinx zynq firmware
       - Various small fixes to the Xilinx clk driver
       - A single minor rounding fix for the legacy Allwinner clock support
       - A few patches from Abel Vesa as preparation of adding audiomix
         clock support on i.MX
       - A couple of cleanups from Anson Huang for i.MX clk-sscg-pll and
         clk-pllv3 drivers
       - Drop dependency on ARM64 for i.MX8M clock driver, to support
         aarch32 mode on aarch64 hardware
       - A series from Peng Fan to improve i.MX8M clock drivers, using
         composite clock for core and bus clk slice
       - Set a better parent clock for flexcan on i.MX6UL to support CiA102
         defined bit rates
       - A couple changes for EMC frequency scaling on Tegra210
       - Support for CPU frequency scaling on Tegra20/Tegra30
       - New clk gate for CSI test pattern generator on Tegra210
       - Regression fixes for Samsung exynos542x and exynos5433 SoCs
       - Use of fallthrough; attribute for Samsung s3c24xx
       - Updates and fixup HDMI and video clocks on Meson8b
       - Fixup reset polarity on Meson8b
       - Fix GPU glitch free mux switch on Meson gx and g12
       - A minor fix for the currently unused suspend/resume handling on
         Renesas RZ/A1 and RZ/A2
       - Two more conversions of Renesas DT bindings to json-schema
       - Add support for the USB 2.0 clock selector on Renesas R-Car M3-W+"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (155 commits)
      clk: mediatek: Remove ifr{0,1}_cfg_regs structures
      clk: baikal-t1: remove redundant assignment to variable 'divider'
      clk: baikal-t1: fix spelling mistake "Uncompatible" -> "Incompatible"
      dt-bindings: clock: Add a missing include to MMP Audio Clock binding
      dt: Add bindings for IDT VersaClock 5P49V5925
      clk: vc5: Add support for IDT VersaClock 5P49V6965
      clk: Add Baikal-T1 CCU Dividers driver
      clk: Add Baikal-T1 CCU PLLs driver
      dt-bindings: clk: Add Baikal-T1 CCU Dividers binding
      dt-bindings: clk: Add Baikal-T1 CCU PLLs binding
      clk: mediatek: assign the initial value to clk_init_data of mtk_mux
      clk: mediatek: Add MT6765 clock support
      clk: mediatek: add mt6765 clock IDs
      dt-bindings: clock: mediatek: document clk bindings vcodecsys for Mediatek MT6765 SoC
      dt-bindings: clock: mediatek: document clk bindings mipi0a for Mediatek MT6765 SoC
      dt-bindings: clock: mediatek: document clk bindings for Mediatek MT6765 SoC
      CLK: HSDK: CGU: add support for 148.5MHz clock
      CLK: HSDK: CGU: support PLL bypassing
      CLK: HSDK: CGU: check if PLL is bypassed first
      clk: clk-si5341: Add support for the Si5345 series
      ...

commit 64c7d7ea22d86cacb65d0c097cc447bc0e6d8abd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 21 19:08:09 2020 +0200

    PM: runtime: clk: Fix clk_pm_runtime_get() error path
    
    clk_pm_runtime_get() assumes that the PM-runtime usage counter will
    be dropped by pm_runtime_get_sync() on errors, which is not the case,
    so PM-runtime references to devices acquired by the former are leaked
    on errors returned by the latter.
    
    Fix this by modifying clk_pm_runtime_get() to drop the reference if
    pm_runtime_get_sync() returns an error.
    
    Fixes: 9a34b45397e5 clk: Add support for runtime PM
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2dfb30b963c4..407f6919604c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -114,7 +114,11 @@ static int clk_pm_runtime_get(struct clk_core *core)
 		return 0;
 
 	ret = pm_runtime_get_sync(core->dev);
-	return ret < 0 ? ret : 0;
+	if (ret < 0) {
+		pm_runtime_put_noidle(core->dev);
+		return ret;
+	}
+	return 0;
 }
 
 static void clk_pm_runtime_put(struct clk_core *core)

commit 782fe98b9350fd64b4d1a651a1da1d303e03b32c
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue May 5 16:30:01 2020 +0800

    clk: Remove unused inline function clk_debug_reparent
    
    There's no callers in-tree anymore.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lkml.kernel.org/r/20200505083001.52564-1-yuehaibing@huawei.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 39c59f063aa0..5501041c91fc 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3295,10 +3295,6 @@ static int __init clk_debug_init(void)
 late_initcall(clk_debug_init);
 #else
 static inline void clk_debug_register(struct clk_core *core) { }
-static inline void clk_debug_reparent(struct clk_core *core,
-				      struct clk_core *new_parent)
-{
-}
 static inline void clk_debug_unregister(struct clk_core *core)
 {
 }

commit 018d4671b9bbd4a5c55cf6eab3e1dbc70a50b66e
Author: Marc Zyngier <maz@kernel.org>
Date:   Tue May 5 15:09:53 2020 +0100

    clk: Unlink clock if failed to prepare or enable
    
    On failing to prepare or enable a clock, remove the core structure
    from the list it has been inserted as it is about to be freed.
    
    This otherwise leads to random crashes when subsequent clocks get
    registered, during which parsing of the clock tree becomes adventurous.
    
    Observed with QEMU's RPi-3 emulation.
    
    Fixes: 12ead77432f2 ("clk: Don't try to enable critical clocks if prepare failed")
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Link: https://lkml.kernel.org/r/20200505140953.409430-1-maz@kernel.org
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 39c59f063aa0..2dfb30b963c4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3519,6 +3519,9 @@ static int __clk_core_init(struct clk_core *core)
 out:
 	clk_pm_runtime_put(core);
 unlock:
+	if (ret)
+		hlist_del_init(&core->child_node);
+
 	clk_prepare_unlock();
 
 	if (!ret)

commit 347619565197ae0e62a755efc4a80904d66fc0a1
Merge: aa1a8ce53332 28ecaf1c30fe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 10:43:32 2020 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "There's not much to see in the core framework this time around.
      Instead the majority of the diff is the normal collection of driver
      additions for new SoCs and non-critical clk data fixes and updates.
      The framework must be middle aged.
    
      The two biggest directories in the diffstat show that the Qualcomm and
      Unisoc support added a handful of big drivers for new SoCs but that's
      not really the whole story because those new drivers tend to add large
      numbers of lines of clk data. There's a handful of AT91 clk drivers
      added this time around too and a bunch of improvements to drivers like
      the i.MX driver. All around lots of updates and fixes in various clk
      drivers which is good to see.
    
      The core framework has only one real major change which has been
      baking in next for the past couple months. It fixes the framework so
      that it stops caching a clk's phase when the phase clk_op returns an
      error. Before this change we would consider some negative errno as a
      phase and that just doesn't make sense.
    
      Core:
       - Don't show clk phase when it is invalid
    
      New Drivers:
       - Add support for Unisoc SC9863A clks
       - Qualcomm SM8250 RPMh and MSM8976 RPM clks
       - Qualcomm SM8250 Global Clock Controller (GCC) support
       - Qualcomm SC7180 Modem Clock Controller (MSS CC) support
       - EHRPWM's TimeBase clock(TBCLK) for TI AM654 SoCs
       - Support PMC clks on at91sam9n12, at91rm9200, sama5d3, and
         at91sam9g45 SoCs
    
      Updates:
       - GPU GX GDSC support on Qualcomm sc7180
       - Fixes and improvements for the Marvell MMP2/MMP3 SoC clk drivers
       - A series from Anson to convert i.MX8 clock bindings to json-schema
       - Update i.MX pll14xx driver to include new frequency entries for
         pll1443x table, and return error for invalid PLL type
       - Add missing of_node_put() call for a number of i.MX clock drivers
       - Drop flag CLK_IS_CRITICAL from 'A53_CORE' mux clock, as we already
         have the flag on its child cpu clock
       - Fix a53 cpu clock for i.MX8 drivers to get it source from ARM PLL
         via CORE_SEL slice, and source from A53 CCM clk root when we need
         to change ARM PLL frequency. Thus, we can support core running
         above 1GHz safely
       - Update i.MX pfdv2 driver to check zero rate and use determine_rate
         for getting the best rate
       - Add CLKO2 for imx8mm, SNVS clock for imx8mn, and PXP clock for
         imx7d
       - Remove PMC clks from Tegra clk driver
       - Improved clock/reset handling for the Renesas R-Car USB2 Clock
         Selector
       - Conversion to json-schema of the Renesas CPG/MSSR DT bindings
       - Add Crypto clocks on Renesas R-Car M3-W/W+, M3-N, E3, and D3
       - Add RPC (QSPI/HyperFLASH) clocks on Renesas R-Car H3, M3-W/W+, and
         M3-N
       - Update Amlogic audio clock gate hierarchy for meson8 and gxbb
       - Update Amlogic g12a spicc clock sources
       - Support for Ingenic X1000 TCU clks"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (146 commits)
      clk: sprd: fix to get a correct ibias of pll
      dt-bindings: imx8mm-clock: Fix the file path
      dt-bindings: imx8mq-clock: Fix the file path
      clk: qcom: rpmh: Drop unnecessary semicolons
      clk: qcom: rpmh: Simplify clk_rpmh_bcm_send_cmd()
      clk: tegra: Use NULL for pointer initialization
      clk: sprd: add clocks support for SC9863A
      clk: sprd: support to get regmap from parent node
      clk: sprd: Add macros for referencing parents without strings
      clk: sprd: Add dt-bindings include file for SC9863A
      dt-bindings: clk: sprd: add bindings for sc9863a clock controller
      dt-bindings: clk: sprd: rename the common file name sprd.txt to SoC specific
      clk: sprd: add gate for pll clocks
      MAINTAINERS: dt: update reference for arm-integrator.txt
      clk: mmp2: Fix bit masks for LCDC I/O and pixel clocks
      clk: mmp2: Add clock for fifth SD HCI on MMP3
      dt-bindings: marvell,mmp2: Add clock id for the fifth SD HCI on MMP3
      clk: mmp2: Add clocks for the thermal sensors
      dt-bindings: marvell,mmp2: Add clock ids for the thermal sensors
      clk: mmp2: add the GPU clocks
      ...

commit 53a2cc5cc36fd97728e1b418dbfa8f70bf23391a
Merge: 2d11e9a1fd2a 1aa0817e43c5 edcc42945dee a37a5a9d715f 02ff48e4d7f7 de17be999cb0 7928f4f6a20c
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 3 15:09:55 2020 -0700

    Merge branches 'clk-ti', 'clk-ingenic', 'clk-typo', 'clk-at91', 'clk-mmp2' and 'clk-arm-icst' into clk-next
    
     - EHRPWM's TimeBase clock(TBCLK) for TI AM654 SoCs
     - Support PMC clks on at91sam9n12, at91rm9200, sama5d3, and at91sam9g45 SoCs
     - Fixes and improvements for the Marvell MMP2/MMP3 SoC clk drivers
    
    * clk-ti:
      clk: keystone: Add new driver to handle syscon based clocks
      dt-bindings: clock: Add binding documentation for TI EHRPWM TBCLK
    
    * clk-ingenic:
      clk: ingenic/TCU: Fix round_rate returning error
      clk: ingenic/jz4770: Exit with error if CGU init failed
      clk: JZ4780: Add function for enable the second core.
      clk: Ingenic: Add support for TCU of X1000.
    
    * clk-typo:
      clk: Fix trivia typo in comment exlusive => exclusive
    
    * clk-at91:
      clk: at91: add at91rm9200 pmc driver
      clk: at91: add at91sam9n12 pmc driver
      clk: at91: add sama5d3 pmc driver
      clk: at91: add at91sam9g45 pmc driver
      clk: at91: usb: introduce num_parents in driver's structure
      clk: at91: usb: use proper usbs_mask
      clk: at91: sam9x60: fix usb clock parents
      clk: at91: usb: continue if clk_hw_round_rate() return zero
      clk: at91: sam9x60: Don't use audio PLL
    
    * clk-mmp2:
      clk: mmp2: Fix bit masks for LCDC I/O and pixel clocks
      clk: mmp2: Add clock for fifth SD HCI on MMP3
      dt-bindings: marvell,mmp2: Add clock id for the fifth SD HCI on MMP3
      clk: mmp2: Add clocks for the thermal sensors
      dt-bindings: marvell,mmp2: Add clock ids for the thermal sensors
      clk: mmp2: add the GPU clocks
      dt-bindings: marvell,mmp2: Add clock ids for the GPU clocks
      clk: mmp2: Add PLLs that are available on MMP3
      dt-bindings: marvell,mmp2: Add clock ids for MMP3 PLLs
      clk: mmp2: Check for MMP3
      dt-bindings: clock: Add MMP3 compatible string
      clk: mmp2: Stop pretending PLL outputs are constant
      clk: mmp2: Add support for PLL clock sources
      dt-bindings: clock: Convert marvell,mmp2-clock to json-schema
      clk: mmp2: Constify some strings
      clk: mmp2: Remove a unused prototype
    
    * clk-arm-icst:
      MAINTAINERS: dt: update reference for arm-integrator.txt
      clk: versatile: Add device tree probing for IM-PD1 clocks
      clk: versatile: Export icst_clk_setup()
      dt-bindings: clock: Create YAML schema for ICST clocks

commit 2d11e9a1fd2abe784b334442b36f7d83ff914287
Merge: ea0a1fb716c1 d89499250247 dfbfee870234 f58272b6f6ed 8ca1f3c06f1a
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 3 15:09:32 2020 -0700

    Merge branches 'clk-phase-errors', 'clk-amlogic', 'clk-renesas' and 'clk-allwinner' into clk-next
    
     - Don't show clk phase when it is invalid
    
    * clk-phase-errors:
      clk: rockchip: fix mmc get phase
      clk: Fix phase init check
      clk: Bail out when calculating phase fails during clk registration
      clk: Move rate and accuracy recalc to mostly consumer APIs
      clk: Use 'parent' to shorten lines in __clk_core_init()
      clk: Don't cache errors from clk_ops::get_phase()
    
    * clk-amlogic:
      clk: meson: meson8b: set audio output clock hierarchy
      clk: meson: g12a: add support for the SPICC SCLK Source clocks
      dt-bindings: clk: g12a-clkc: add SPICC SCLK Source clock IDs
      clk: meson: gxbb: set audio output clock hierarchy
      clk: meson: gxbb: add the gxl internal dac gate
      dt-bindings: clk: meson: add the gxl internal dac gate
    
    * clk-renesas:
      dt-bindings: clock: renesas: cpg-mssr: Convert to json-schema
      clk: renesas: rcar-usb2-clock-sel: Add reset_control
      clk: renesas: rcar-usb2-clock-sel: Add multiple clocks management
      dt-bindings: clock: renesas: rcar-usb2-clock-sel: Add power-domains and resets properties
      dt-bindings: clock: renesas: rcar-usb2-clock-sel: Fix clock[-name]s properties
      clk: renesas: Remove use of ARCH_R8A7795
      clk: renesas: r8a77965: Add RPC clocks
      clk: renesas: r8a7796: Add RPC clocks
      clk: renesas: r8a7795: Add RPC clocks
      clk: renesas: rcar-gen3: Add CCREE clocks
    
    * clk-allwinner:
      clk: sunxi-ng: sun8i-de2: Sort structures
      clk: sunxi-ng: sun8i-de2: Add R40 specific quirks
      clk: sunxi-ng: sun8i-de2: Add rotation core clocks and reset for A83T
      clk: sunxi-ng: sun8i-de2: Don't reuse A83T resets
      clk: sunxi-ng: sun8i-de2: H6 doesn't have rotate core
      clk: sunxi-ng: sun8i-de2: Add rotation core clocks and reset for A64
      clk: sunxi-ng: sun8i-de2: Split out H5 definitions
      clk: sunxi-ng: a64: Export MBUS clock

commit a37a5a9d715f0dc30761bf469f85bc5e02240cf5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 10 15:55:07 2020 +0200

    clk: Fix trivia typo in comment exlusive => exclusive
    
    Fix trivia typo in comment exlusive => exclusive.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lkml.kernel.org/r/20200310135507.87959-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f0f2b599fd7e..1aa21178068f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -774,7 +774,7 @@ static void clk_core_rate_restore_protect(struct clk_core *core, int count)
  * clk_rate_exclusive_get - get exclusivity over the clk rate control
  * @clk: the clk over which the exclusity of rate control is requested
  *
- * clk_rate_exlusive_get() begins a critical section during which a clock
+ * clk_rate_exclusive_get() begins a critical section during which a clock
  * consumer cannot tolerate any other consumer making any operation on the
  * clock which could result in a rate change or rate glitch. Exclusive clocks
  * cannot have their rate changed, either directly or indirectly due to changes

commit c3944ec8c6df256ab480b56cb776f36df44b2ba5
Author: Maxime Ripard <maxime@cerno.tech>
Date:   Tue Feb 25 14:42:48 2020 +0100

    clk: Fix phase init check
    
    Commit 2760878662a2 ("clk: Bail out when calculating phase fails during
    clk registration") introduced a check on error values at the time the
    clock is registered to bail out when such an error occurs. However, it
    doesn't check whether the returned value is positive which will happen
    if the driver returns a non-zero phase. Since a phase is usually a
    non-zero positive number this ends up returning something that isn't 0
    to the caller of __clk_core_init(), making most clks fail to register
    if they implement a phase clk op and return anything besides 0 for the
    phase.
    
    Fix this by returning the error if phase is less than zero or just
    return zero if the phase is a positive number.
    
    Fixes: 2760878662a2 ("clk: Bail out when calculating phase fails during clk registration")
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>
    Link: https://lkml.kernel.org/r/20200225134248.919889-1-maxime@cerno.tech
    Reported-by: "kernelci.org bot" <bot@kernelci.org>
    [sboyd@kernel.org: Reword commit text to provide clarity]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ed1797857bae..4d6fd7de05ae 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3344,6 +3344,7 @@ static int __clk_core_init(struct clk_core *core)
 	int ret;
 	struct clk_core *parent;
 	unsigned long rate;
+	int phase;
 
 	if (!core)
 		return -EINVAL;
@@ -3457,8 +3458,9 @@ static int __clk_core_init(struct clk_core *core)
 	 * Since a phase is by definition relative to its parent, just
 	 * query the current clock phase, or just assume it's in phase.
 	 */
-	ret = clk_core_get_phase(core);
-	if (ret < 0) {
+	phase = clk_core_get_phase(core);
+	if (phase < 0) {
+		ret = phase;
 		pr_warn("%s: Failed to get phase for clk '%s'\n", __func__,
 			core->name);
 		goto out;

commit be545c79b28917caa0cee231f376be2a2e5c9d0e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Dec 6 14:34:14 2019 +0100

    clk: Fix continuation of of_clk_detect_critical()
    
    The second line of the of_clk_detect_critical() function signature is
    not indented according to coding style.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lkml.kernel.org/r/20191206133414.23925-1-geert+renesas@glider.be
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f0f2b599fd7e..e42145cd996a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -4865,8 +4865,8 @@ static int parent_ready(struct device_node *np)
  *
  * Return: error code or zero on success
  */
-int of_clk_detect_critical(struct device_node *np,
-					  int index, unsigned long *flags)
+int of_clk_detect_critical(struct device_node *np, int index,
+			   unsigned long *flags)
 {
 	struct property *prop;
 	const __be32 *cur;

commit 2760878662a290ac57cff8a5a8d8bda8f4dddc37
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Feb 5 15:28:02 2020 -0800

    clk: Bail out when calculating phase fails during clk registration
    
    Bail out of clk registration if we fail to get the phase for a clk that
    has a clk_ops::get_phase() callback. Print a warning too so that driver
    authors can easily figure out that some clk is unable to read back phase
    information at boot.
    
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Suggested-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20200205232802.29184-5-sboyd@kernel.org
    Acked-by: Jerome Brunet <jbrunet@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index dc8bdfbd6a0c..ed1797857bae 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3457,7 +3457,12 @@ static int __clk_core_init(struct clk_core *core)
 	 * Since a phase is by definition relative to its parent, just
 	 * query the current clock phase, or just assume it's in phase.
 	 */
-	clk_core_get_phase(core);
+	ret = clk_core_get_phase(core);
+	if (ret < 0) {
+		pr_warn("%s: Failed to get phase for clk '%s'\n", __func__,
+			core->name);
+		goto out;
+	}
 
 	/*
 	 * Set clk's duty cycle.

commit 0daa376d832f4ce585f153efee4233b52fa3fe58
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Feb 5 15:28:01 2020 -0800

    clk: Move rate and accuracy recalc to mostly consumer APIs
    
    There's some confusion about when recalc is done for the rate and
    accuracy clk consumer APIs in relation to the prepare lock being taken.
    Oddly enough, we take the lock again in debugfs APIs so that we can call
    the internal "clk_core" APIs to get these fields with any necessary
    recalculations. Instead of having this confusion, let's introduce a
    recalc variant of these two consumer APIs as internal helpers and call
    them from the consumer APIs and the debugfs code so that we don't take
    the lock more than once.
    
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20200205232802.29184-4-sboyd@kernel.org
    Acked-by: Jerome Brunet <jbrunet@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3ddca6084e8e..dc8bdfbd6a0c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -488,7 +488,7 @@ unsigned long clk_hw_get_rate(const struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(clk_hw_get_rate);
 
-static unsigned long __clk_get_accuracy(struct clk_core *core)
+static unsigned long clk_core_get_accuracy_no_lock(struct clk_core *core)
 {
 	if (!core)
 		return 0;
@@ -1517,18 +1517,12 @@ static void __clk_recalc_accuracies(struct clk_core *core)
 		__clk_recalc_accuracies(child);
 }
 
-static long clk_core_get_accuracy(struct clk_core *core)
+static long clk_core_get_accuracy_recalc(struct clk_core *core)
 {
-	unsigned long accuracy;
-
-	clk_prepare_lock();
 	if (core && (core->flags & CLK_GET_ACCURACY_NOCACHE))
 		__clk_recalc_accuracies(core);
 
-	accuracy = __clk_get_accuracy(core);
-	clk_prepare_unlock();
-
-	return accuracy;
+	return clk_core_get_accuracy_no_lock(core);
 }
 
 /**
@@ -1542,10 +1536,16 @@ static long clk_core_get_accuracy(struct clk_core *core)
  */
 long clk_get_accuracy(struct clk *clk)
 {
+	long accuracy;
+
 	if (!clk)
 		return 0;
 
-	return clk_core_get_accuracy(clk->core);
+	clk_prepare_lock();
+	accuracy = clk_core_get_accuracy_recalc(clk->core);
+	clk_prepare_unlock();
+
+	return accuracy;
 }
 EXPORT_SYMBOL_GPL(clk_get_accuracy);
 
@@ -1599,19 +1599,12 @@ static void __clk_recalc_rates(struct clk_core *core, unsigned long msg)
 		__clk_recalc_rates(child, msg);
 }
 
-static unsigned long clk_core_get_rate(struct clk_core *core)
+static unsigned long clk_core_get_rate_recalc(struct clk_core *core)
 {
-	unsigned long rate;
-
-	clk_prepare_lock();
-
 	if (core && (core->flags & CLK_GET_RATE_NOCACHE))
 		__clk_recalc_rates(core, 0);
 
-	rate = clk_core_get_rate_nolock(core);
-	clk_prepare_unlock();
-
-	return rate;
+	return clk_core_get_rate_nolock(core);
 }
 
 /**
@@ -1624,10 +1617,16 @@ static unsigned long clk_core_get_rate(struct clk_core *core)
  */
 unsigned long clk_get_rate(struct clk *clk)
 {
+	unsigned long rate;
+
 	if (!clk)
 		return 0;
 
-	return clk_core_get_rate(clk->core);
+	clk_prepare_lock();
+	rate = clk_core_get_rate_recalc(clk->core);
+	clk_prepare_unlock();
+
+	return rate;
 }
 EXPORT_SYMBOL_GPL(clk_get_rate);
 
@@ -2910,7 +2909,8 @@ static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
 		   c->enable_count, c->prepare_count, c->protect_count,
-		   clk_core_get_rate(c), clk_core_get_accuracy(c));
+		   clk_core_get_rate_recalc(c),
+		   clk_core_get_accuracy_recalc(c));
 
 	phase = clk_core_get_phase(c);
 	if (phase >= 0)
@@ -2965,10 +2965,10 @@ static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
 	seq_printf(s, "\"protect_count\": %d,", c->protect_count);
-	seq_printf(s, "\"rate\": %lu,", clk_core_get_rate(c));
+	seq_printf(s, "\"rate\": %lu,", clk_core_get_rate_recalc(c));
 	seq_printf(s, "\"min_rate\": %lu,", min_rate);
 	seq_printf(s, "\"max_rate\": %lu,", max_rate);
-	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy(c));
+	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy_recalc(c));
 	phase = clk_core_get_phase(c);
 	if (phase >= 0)
 		seq_printf(s, "\"phase\": %d,", phase);
@@ -3446,7 +3446,7 @@ static int __clk_core_init(struct clk_core *core)
 	 */
 	if (core->ops->recalc_accuracy)
 		core->accuracy = core->ops->recalc_accuracy(core->hw,
-					__clk_get_accuracy(parent));
+					clk_core_get_accuracy_no_lock(parent));
 	else if (parent)
 		core->accuracy = parent->accuracy;
 	else

commit 768a5d4f63c29d3bed5abb3c187312fcf623fa05
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Feb 5 15:28:00 2020 -0800

    clk: Use 'parent' to shorten lines in __clk_core_init()
    
    Some lines are getting long in this function. Let's move 'parent' up to
    the top of the function and use it in many places whenever there is a
    parent for a clk. This shortens some lines by avoiding core->parent->
    indirections.
    
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20200205232802.29184-3-sboyd@kernel.org
    Acked-by: Jerome Brunet <jbrunet@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 82d96d4071b1..3ddca6084e8e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3342,6 +3342,7 @@ static void clk_core_reparent_orphans_nolock(void)
 static int __clk_core_init(struct clk_core *core)
 {
 	int ret;
+	struct clk_core *parent;
 	unsigned long rate;
 
 	if (!core)
@@ -3413,7 +3414,7 @@ static int __clk_core_init(struct clk_core *core)
 			goto out;
 	}
 
-	core->parent = __clk_init_parent(core);
+	parent = core->parent = __clk_init_parent(core);
 
 	/*
 	 * Populate core->parent if parent has already been clk_core_init'd. If
@@ -3425,10 +3426,9 @@ static int __clk_core_init(struct clk_core *core)
 	 * clocks and re-parent any that are children of the clock currently
 	 * being clk_init'd.
 	 */
-	if (core->parent) {
-		hlist_add_head(&core->child_node,
-				&core->parent->children);
-		core->orphan = core->parent->orphan;
+	if (parent) {
+		hlist_add_head(&core->child_node, &parent->children);
+		core->orphan = parent->orphan;
 	} else if (!core->num_parents) {
 		hlist_add_head(&core->child_node, &clk_root_list);
 		core->orphan = false;
@@ -3446,9 +3446,9 @@ static int __clk_core_init(struct clk_core *core)
 	 */
 	if (core->ops->recalc_accuracy)
 		core->accuracy = core->ops->recalc_accuracy(core->hw,
-					__clk_get_accuracy(core->parent));
-	else if (core->parent)
-		core->accuracy = core->parent->accuracy;
+					__clk_get_accuracy(parent));
+	else if (parent)
+		core->accuracy = parent->accuracy;
 	else
 		core->accuracy = 0;
 
@@ -3472,9 +3472,9 @@ static int __clk_core_init(struct clk_core *core)
 	 */
 	if (core->ops->recalc_rate)
 		rate = core->ops->recalc_rate(core->hw,
-				clk_core_get_rate_nolock(core->parent));
-	else if (core->parent)
-		rate = core->parent->rate;
+				clk_core_get_rate_nolock(parent));
+	else if (parent)
+		rate = parent->rate;
 	else
 		rate = 0;
 	core->rate = core->req_rate = rate;

commit f21cf9c77ee82ef8adfeb2143adfacf21ec1d5cc
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Feb 5 15:27:59 2020 -0800

    clk: Don't cache errors from clk_ops::get_phase()
    
    We don't check for errors from clk_ops::get_phase() before storing away
    the result into the clk_core::phase member. This can lead to some fairly
    confusing debugfs information if these ops do return an error. Let's
    skip the store when this op fails to fix this. While we're here, move
    the locking outside of clk_core_get_phase() to simplify callers from
    the debugfs side.
    
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20200205232802.29184-2-sboyd@kernel.org
    Acked-by: Jerome Brunet <jbrunet@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f0f2b599fd7e..82d96d4071b1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2660,12 +2660,14 @@ static int clk_core_get_phase(struct clk_core *core)
 {
 	int ret;
 
-	clk_prepare_lock();
+	lockdep_assert_held(&prepare_lock);
+	if (!core->ops->get_phase)
+		return 0;
+
 	/* Always try to update cached phase if possible */
-	if (core->ops->get_phase)
-		core->phase = core->ops->get_phase(core->hw);
-	ret = core->phase;
-	clk_prepare_unlock();
+	ret = core->ops->get_phase(core->hw);
+	if (ret >= 0)
+		core->phase = ret;
 
 	return ret;
 }
@@ -2679,10 +2681,16 @@ static int clk_core_get_phase(struct clk_core *core)
  */
 int clk_get_phase(struct clk *clk)
 {
+	int ret;
+
 	if (!clk)
 		return 0;
 
-	return clk_core_get_phase(clk->core);
+	clk_prepare_lock();
+	ret = clk_core_get_phase(clk->core);
+	clk_prepare_unlock();
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_get_phase);
 
@@ -2896,13 +2904,21 @@ static struct hlist_head *orphan_list[] = {
 static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
 				 int level)
 {
-	seq_printf(s, "%*s%-*s %7d %8d %8d %11lu %10lu %5d %6d\n",
+	int phase;
+
+	seq_printf(s, "%*s%-*s %7d %8d %8d %11lu %10lu ",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
 		   c->enable_count, c->prepare_count, c->protect_count,
-		   clk_core_get_rate(c), clk_core_get_accuracy(c),
-		   clk_core_get_phase(c),
-		   clk_core_get_scaled_duty_cycle(c, 100000));
+		   clk_core_get_rate(c), clk_core_get_accuracy(c));
+
+	phase = clk_core_get_phase(c);
+	if (phase >= 0)
+		seq_printf(s, "%5d", phase);
+	else
+		seq_puts(s, "-----");
+
+	seq_printf(s, " %6d\n", clk_core_get_scaled_duty_cycle(c, 100000));
 }
 
 static void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,
@@ -2939,6 +2955,7 @@ DEFINE_SHOW_ATTRIBUTE(clk_summary);
 
 static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 {
+	int phase;
 	unsigned long min_rate, max_rate;
 
 	clk_core_get_boundaries(c, &min_rate, &max_rate);
@@ -2952,7 +2969,9 @@ static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 	seq_printf(s, "\"min_rate\": %lu,", min_rate);
 	seq_printf(s, "\"max_rate\": %lu,", max_rate);
 	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy(c));
-	seq_printf(s, "\"phase\": %d,", clk_core_get_phase(c));
+	phase = clk_core_get_phase(c);
+	if (phase >= 0)
+		seq_printf(s, "\"phase\": %d,", phase);
 	seq_printf(s, "\"duty_cycle\": %u",
 		   clk_core_get_scaled_duty_cycle(c, 100000));
 }
@@ -3434,14 +3453,11 @@ static int __clk_core_init(struct clk_core *core)
 		core->accuracy = 0;
 
 	/*
-	 * Set clk's phase.
+	 * Set clk's phase by clk_core_get_phase() caching the phase.
 	 * Since a phase is by definition relative to its parent, just
 	 * query the current clock phase, or just assume it's in phase.
 	 */
-	if (core->ops->get_phase)
-		core->phase = core->ops->get_phase(core->hw);
-	else
-		core->phase = 0;
+	clk_core_get_phase(core);
 
 	/*
 	 * Set clk's duty cycle.

commit 4a4472fdc098fb78f52a0848788faf46674a8423
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Feb 12 10:43:17 2020 +0100

    of: clk: Make of_clk_get_parent_{count,name}() parameter const
    
    of_clk_get_parent_count() and of_clk_get_parent_name() never modify the
    device nodes passed, so they can be const.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lkml.kernel.org/r/20200212094317.1150-1-geert+renesas@glider.be
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f0f2b599fd7e..95adf6c6db3d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -4713,7 +4713,7 @@ EXPORT_SYMBOL(of_clk_get_by_name);
  *
  * Returns: The number of clocks that are possible parents of this node
  */
-unsigned int of_clk_get_parent_count(struct device_node *np)
+unsigned int of_clk_get_parent_count(const struct device_node *np)
 {
 	int count;
 
@@ -4725,7 +4725,7 @@ unsigned int of_clk_get_parent_count(struct device_node *np)
 }
 EXPORT_SYMBOL_GPL(of_clk_get_parent_count);
 
-const char *of_clk_get_parent_name(struct device_node *np, int index)
+const char *of_clk_get_parent_name(const struct device_node *np, int index)
 {
 	struct of_phandle_args clkspec;
 	struct property *prop;

commit cc12071ff39060fc2e47c58b43e249fe0d0061ee
Merge: 9717c1cea16e f3cc4e1d44a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 4 07:24:48 2020 +0000

    Merge branch 'akpm' (patches from Andrew)
    
    Merge more updates from Andrew Morton:
     "The rest of MM and the rest of everything else: hotfixes, ipc, misc,
      procfs, lib, cleanups, arm"
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (67 commits)
      ARM: dma-api: fix max_pfn off-by-one error in __dma_supported()
      treewide: remove redundant IS_ERR() before error code check
      include/linux/cpumask.h: don't calculate length of the input string
      lib: new testcases for bitmap_parse{_user}
      lib: rework bitmap_parse()
      lib: make bitmap_parse_user a wrapper on bitmap_parse
      lib: add test for bitmap_parse()
      bitops: more BITS_TO_* macros
      lib/string: add strnchrnul()
      proc: convert everything to "struct proc_ops"
      proc: decouple proc from VFS with "struct proc_ops"
      asm-generic/tlb: provide MMU_GATHER_TABLE_FREE
      asm-generic/tlb: rename HAVE_MMU_GATHER_NO_GATHER
      asm-generic/tlb: rename HAVE_MMU_GATHER_PAGE_SIZE
      asm-generic/tlb: rename HAVE_RCU_TABLE_FREE
      asm-generic/tlb: add missing CONFIG symbol
      asm-gemeric/tlb: remove stray function declarations
      asm-generic/tlb: avoid potential double flush
      mm/mmu_gather: invalidate TLB correctly on batch allocation failure and flush
      powerpc/mmu_gather: enable RCU_TABLE_FREE even for !SMP case
      ...

commit 45586c7078d42b932c5399953d21746800083691
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Feb 3 17:37:45 2020 -0800

    treewide: remove redundant IS_ERR() before error code check
    
    'PTR_ERR(p) == -E*' is a stronger condition than IS_ERR(p).
    Hence, IS_ERR(p) is unneeded.
    
    The semantic patch that generates this commit is as follows:
    
    // <smpl>
    @@
    expression ptr;
    constant error_code;
    @@
    -IS_ERR(ptr) && (PTR_ERR(ptr) == - error_code)
    +PTR_ERR(ptr) == - error_code
    // </smpl>
    
    Link: http://lkml.kernel.org/r/20200106045833.1725-1-masahiroy@kernel.org
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Acked-by: Stephen Boyd <sboyd@kernel.org> [drivers/clk/clk.c]
    Acked-by: Bartosz Golaszewski <bgolaszewski@baylibre.com> [GPIO]
    Acked-by: Wolfram Sang <wsa@the-dreams.de> [drivers/i2c]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> [acpi/scan.c]
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Eric Biggers <ebiggers@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 772258de2d1f..39eda7fd3830 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -429,7 +429,7 @@ static void clk_core_fill_parent_index(struct clk_core *core, u8 index)
 			parent = ERR_PTR(-EPROBE_DEFER);
 	} else {
 		parent = clk_core_get(core, index);
-		if (IS_ERR(parent) && PTR_ERR(parent) == -ENOENT && entry->name)
+		if (PTR_ERR(parent) == -ENOENT && entry->name)
 			parent = clk_core_lookup(entry->name);
 	}
 

commit 6e7a9f0c4ea83b570175c08e7af3ce4711b554f3
Merge: 36bf7a5bdd34 37215da5553e ff258817137a c1c95a46ed15 31ef091770da fa9ae3057d7a
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jan 31 13:12:14 2020 -0800

    Merge branches 'clk-debugfs-danger', 'clk-basic-hw', 'clk-renesas', 'clk-amlogic' and 'clk-allwinner' into clk-next
    
     - Support dangerous debugfs actions on clks with dead code
     - Convert gpio, fixed-factor, mux, gate, divider basic clks to hw based APIs
    
    * clk-debugfs-danger:
      clk: Add support for setting clk_rate via debugfs
    
    * clk-basic-hw:
      clk: divider: Add support for specifying parents via DT/pointers
      clk: gate: Add support for specifying parents via DT/pointers
      clk: mux: Add support for specifying parents via DT/pointers
      clk: asm9260: Use parent accuracy in fixed rate clk
      clk: fixed-rate: Document that accuracy isn't a rate
      clk: fixed-rate: Add clk flags for parent accuracy
      clk: fixed-rate: Add support for specifying parents via DT/pointers
      clk: fixed-rate: Document accuracy member
      clk: fixed-rate: Move to_clk_fixed_rate() to C file
      clk: fixed-rate: Remove clk_register_fixed_rate_with_accuracy()
      clk: fixed-rate: Convert to clk_hw based APIs
      clk: gpio: Use DT way of specifying parents
    
    * clk-renesas:
      clk: renesas: Prepare for split of R-Car H3 config symbol
      dt-bindings: clock: renesas: cpg-mssr: Fix r8a774b1 typo
      clk: renesas: r7s9210: Add SPIBSC clock
      clk: renesas: rcar-gen3: Allow changing the RPC[D2] clocks
      clk: renesas: Remove use of ARCH_R8A7796
      clk: renesas: rcar-gen2: Change multipliers and dividers to u8
    
    * clk-amlogic:
      clk: clarify that clk_set_rate() does updates from top to bottom
      clk: meson: meson8b: make the CCF use the glitch-free mali mux
      clk: meson: pll: Fix by 0 division in __pll_params_to_rate()
      clk: meson: g12a: fix missing uart2 in regmap table
      clk: meson: meson8b: use of_clk_hw_register to register the clocks
      clk: meson: meson8b: don't register the XTAL clock when provided via OF
      clk: meson: meson8b: change references to the XTAL clock to use [fw_]name
      clk: meson: meson8b: use clk_hw_set_parent in the CPU clock notifier
      clk: meson: add a driver for the Meson8/8b/8m2 DDR clock controller
      dt-bindings: clock: meson8b: add the clock inputs
      dt-bindings: clock: add the Amlogic Meson8 DDR clock controller binding
    
    * clk-allwinner:
      clk: sunxi: a23/a33: Export the MIPI PLL
      clk: sunxi: a31: Export the MIPI PLL
      clk: sunxi-ng: a64: export CLK_CPUX clock for DVFS
      clk: sunxi-ng: add mux and pll notifiers for A64 CPU clock
      clk: sunxi-ng: r40: Export MBUS clock
      clk: sunxi: use of_device_get_match_data

commit 36bf7a5bdd349dd150b9c6bc8d5601bd1069ce9f
Merge: 28db9a8c82a8 1ec09a2ec67a 2d2699926143 248fdcc77a35 333d2d19df09 66d9f5214c9b
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jan 31 13:12:00 2020 -0800

    Merge branches 'clk-uniphier', 'clk-warn-critical', 'clk-ux500', 'clk-kconfig' and 'clk-at91' into clk-next
    
     - Warn about critical clks that fail to enable or prepare
     - Detect more PRMCU variants in ux500 driver
    
    * clk-uniphier:
      clk: uniphier: Add SCSSI clock gate for each channel
    
    * clk-warn-critical:
      clk: Warn about critical clks that fail to enable
      clk: Don't try to enable critical clocks if prepare failed
      clk: tegra: Fix double-free in tegra_clk_init()
      clk: samsung: exynos5420: Keep top G3D clocks enabled
      clk: qcom: Avoid SMMU/cx gdsc corner cases
      clk: qcom: gcc-sc7180: Fix setting flag for votable GDSCs
      clk: Move clk_core_reparent_orphans() under CONFIG_OF
      clk: at91: fix possible deadlock
      clk: walk orphan list on clock provider registration
      clk: imx: pll14xx: fix clk_pll14xx_wait_lock
      clk: imx: clk-imx7ulp: Add missing sentinel of ulp_div_table
      clk: imx: clk-composite-8m: add lock to gate/mux
    
    * clk-ux500:
      clk: ux500: Fix up the SGA clock for some variants
    
    * clk-kconfig:
      clk: Fix Kconfig indentation
    
    * clk-at91:
      clk: at91: sam9x60: fix programmable clock prescaler
      clk: at91: sam9x60-pll: adapt PMC_PLL_ACR default value

commit 28db9a8c82a81efb8c2548104a5416bb8d101176
Merge: f873744c2903 59ef4da4e408 9011f92622e5
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jan 31 13:11:52 2020 -0800

    Merge branches 'clk-init-allocation', 'clk-unused' and 'clk-register-dt-node-better' into clk-next
    
     - Let clk_ops::init() return an error code
     - Add a clk_ops::terminate() callback to undo clk_ops::init()
    
    * clk-init-allocation:
      clk: add terminate callback to clk_ops
      clk: let init callback return an error code
      clk: actually call the clock init before any other callback of the clock
    
    * clk-unused:
      clk: bm1800: Remove set but not used variable 'fref'
    
    * clk-register-dt-node-better:
      clk: Use parent node pointer during registration if necessary

commit 37215da5553eb00616291a82decb958bb2d98fc1
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Aug 28 15:23:06 2019 +0200

    clk: Add support for setting clk_rate via debugfs
    
    For testing, it is useful to be able to specify a clock rate manually.
    As this is a dangerous feature, it is not enabled by default.
    Users need to modify the source directly and #define
    CLOCK_ALLOW_WRITE_DEBUGFS.
    
    This follows the spirit of commit 09c6ecd394105c48 ("regmap: Add support
    for writing to regmap registers via debugfs").
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lkml.kernel.org/r/20190828132306.19012-1-geert+renesas@glider.be
    Suggested-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b68e200829f2..9c5b9419e585 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2996,6 +2996,41 @@ static int clk_dump_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(clk_dump);
 
+#undef CLOCK_ALLOW_WRITE_DEBUGFS
+#ifdef CLOCK_ALLOW_WRITE_DEBUGFS
+/*
+ * This can be dangerous, therefore don't provide any real compile time
+ * configuration option for this feature.
+ * People who want to use this will need to modify the source code directly.
+ */
+static int clk_rate_set(void *data, u64 val)
+{
+	struct clk_core *core = data;
+	int ret;
+
+	clk_prepare_lock();
+	ret = clk_core_set_rate_nolock(core, val);
+	clk_prepare_unlock();
+
+	return ret;
+}
+
+#define clk_rate_mode	0644
+#else
+#define clk_rate_set	NULL
+#define clk_rate_mode	0444
+#endif
+
+static int clk_rate_get(void *data, u64 *val)
+{
+	struct clk_core *core = data;
+
+	*val = core->rate;
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(clk_rate_fops, clk_rate_get, clk_rate_set, "%llu\n");
+
 static const struct {
 	unsigned long flag;
 	const char *name;
@@ -3145,7 +3180,8 @@ static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	root = debugfs_create_dir(core->name, pdentry);
 	core->dentry = root;
 
-	debugfs_create_ulong("clk_rate", 0444, root, &core->rate);
+	debugfs_create_file("clk_rate", clk_rate_mode, root, core,
+			    &clk_rate_fops);
 	debugfs_create_file("clk_min_rate", 0444, root, core, &clk_min_rate_fops);
 	debugfs_create_file("clk_max_rate", 0444, root, core, &clk_max_rate_fops);
 	debugfs_create_ulong("clk_accuracy", 0444, root, &core->accuracy);

commit 2d2699926143624ef0fce3bbb5a0f089d674d12c
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Dec 26 14:09:27 2019 -0800

    clk: Warn about critical clks that fail to enable
    
    If we don't warn here users of the CLK_IS_CRITICAL flag may not know
    that their clk isn't actually enabled because it silently fails to
    enable. Let's print a warning in that case so developers find these
    problems faster.
    
    Suggested-by: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20200102005503.71923-1-sboyd@kernel.org
    Reviewed-by: Jerome Brunet <jbrunet@baylibre.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 772258de2d1f..b03c2be4014b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3427,13 +3427,18 @@ static int __clk_core_init(struct clk_core *core)
 		unsigned long flags;
 
 		ret = clk_core_prepare(core);
-		if (ret)
+		if (ret) {
+			pr_warn("%s: critical clk '%s' failed to prepare\n",
+			       __func__, core->name);
 			goto out;
+		}
 
 		flags = clk_enable_lock();
 		ret = clk_core_enable(core);
 		clk_enable_unlock(flags);
 		if (ret) {
+			pr_warn("%s: critical clk '%s' failed to enable\n",
+			       __func__, core->name);
 			clk_core_unprepare(core);
 			goto out;
 		}

commit 9011f92622e5ef2d075f45e5fa818776d4feb8c0
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Dec 30 10:29:35 2019 -0800

    clk: Use parent node pointer during registration if necessary
    
    Sometimes clk drivers are attached to devices which are children of a
    parent device that is connected to a node in DT. This happens when
    devices are MFD-ish and the parent device driver mostly registers child
    devices to match against drivers placed in their respective subsystem
    directories like drivers/clk, drivers/regulator, etc. When the clk
    driver calls clk_register() with a device pointer, that struct device
    pointer won't have a device_node associated with it because it was
    created purely in software as a way to partition logic to a subsystem.
    
    This causes problems for the way we find parent clks for the clks
    registered by these child devices because we look at the registering
    device's device_node pointer to lookup 'clocks' and 'clock-names'
    properties. Let's use the parent device's device_node pointer if the
    registering device doesn't have a device_node but the parent does. This
    simplifies clk registration code by avoiding the need to assign some
    device_node to the device registering the clk.
    
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reported-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20191230190455.141339-1-sboyd@kernel.org
    [sboyd@kernel.org: Fixup kernel-doc notation]
    Reviewed-by: Niklas Cassel <nks@flawful.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b68e200829f2..897874acb893 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3719,6 +3719,28 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 	return ERR_PTR(ret);
 }
 
+/**
+ * dev_or_parent_of_node() - Get device node of @dev or @dev's parent
+ * @dev: Device to get device node of
+ *
+ * Return: device node pointer of @dev, or the device node pointer of
+ * @dev->parent if dev doesn't have a device node, or NULL if neither
+ * @dev or @dev->parent have a device node.
+ */
+static struct device_node *dev_or_parent_of_node(struct device *dev)
+{
+	struct device_node *np;
+
+	if (!dev)
+		return NULL;
+
+	np = dev_of_node(dev);
+	if (!np)
+		np = dev_of_node(dev->parent);
+
+	return np;
+}
+
 /**
  * clk_register - allocate a new clock, register it and return an opaque cookie
  * @dev: device that is registering this clock
@@ -3734,7 +3756,7 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
  */
 struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 {
-	return __clk_register(dev, dev_of_node(dev), hw);
+	return __clk_register(dev, dev_or_parent_of_node(dev), hw);
 }
 EXPORT_SYMBOL_GPL(clk_register);
 
@@ -3750,7 +3772,8 @@ EXPORT_SYMBOL_GPL(clk_register);
  */
 int clk_hw_register(struct device *dev, struct clk_hw *hw)
 {
-	return PTR_ERR_OR_ZERO(__clk_register(dev, dev_of_node(dev), hw));
+	return PTR_ERR_OR_ZERO(__clk_register(dev, dev_or_parent_of_node(dev),
+			       hw));
 }
 EXPORT_SYMBOL_GPL(clk_hw_register);
 

commit 12ead77432f2ce32dea797742316d15c5800cb32
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Dec 25 08:34:29 2019 -0800

    clk: Don't try to enable critical clocks if prepare failed
    
    The following traceback is seen if a critical clock fails to prepare.
    
    bcm2835-clk 3f101000.cprman: plld: couldn't lock PLL
    ------------[ cut here ]------------
    Enabling unprepared plld_per
    WARNING: CPU: 1 PID: 1 at drivers/clk/clk.c:1014 clk_core_enable+0xcc/0x2c0
    ...
    Call trace:
     clk_core_enable+0xcc/0x2c0
     __clk_register+0x5c4/0x788
     devm_clk_hw_register+0x4c/0xb0
     bcm2835_register_pll_divider+0xc0/0x150
     bcm2835_clk_probe+0x134/0x1e8
     platform_drv_probe+0x50/0xa0
     really_probe+0xd4/0x308
     driver_probe_device+0x54/0xe8
     device_driver_attach+0x6c/0x78
     __driver_attach+0x54/0xd8
    ...
    
    Check return values from clk_core_prepare() and clk_core_enable() and
    bail out if any of those functions returns an error.
    
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Fixes: 99652a469df1 ("clk: migrate the count of orphaned clocks at init")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lkml.kernel.org/r/20191225163429.29694-1-linux@roeck-us.net
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 6a11239ccde3..772258de2d1f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3426,11 +3426,17 @@ static int __clk_core_init(struct clk_core *core)
 	if (core->flags & CLK_IS_CRITICAL) {
 		unsigned long flags;
 
-		clk_core_prepare(core);
+		ret = clk_core_prepare(core);
+		if (ret)
+			goto out;
 
 		flags = clk_enable_lock();
-		clk_core_enable(core);
+		ret = clk_core_enable(core);
 		clk_enable_unlock(flags);
+		if (ret) {
+			clk_core_unprepare(core);
+			goto out;
+		}
 	}
 
 	clk_core_reparent_orphans_nolock();

commit f873744c29036cc734ec8ecbedd1a451ce61cef2
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Sep 24 14:39:54 2019 +0200

    clk: add terminate callback to clk_ops
    
    Add a terminate callback to the clk_ops to release the resources
    claimed in .init()
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lkml.kernel.org/r/20190924123954.31561-4-jbrunet@baylibre.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b8dc848a04f7..ef4416721777 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3862,6 +3862,7 @@ static void clk_core_evict_parent_cache(struct clk_core *core)
 void clk_unregister(struct clk *clk)
 {
 	unsigned long flags;
+	const struct clk_ops *ops;
 
 	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
 		return;
@@ -3870,7 +3871,8 @@ void clk_unregister(struct clk *clk)
 
 	clk_prepare_lock();
 
-	if (clk->core->ops == &clk_nodrv_ops) {
+	ops = clk->core->ops;
+	if (ops == &clk_nodrv_ops) {
 		pr_err("%s: unregistered clock: %s\n", __func__,
 		       clk->core->name);
 		goto unlock;
@@ -3883,6 +3885,9 @@ void clk_unregister(struct clk *clk)
 	clk->core->ops = &clk_nodrv_ops;
 	clk_enable_unlock(flags);
 
+	if (ops->terminate)
+		ops->terminate(clk->core->hw);
+
 	if (!hlist_empty(&clk->core->children)) {
 		struct clk_core *child;
 		struct hlist_node *t;

commit 89d079dc17e8a32397de827cc85c1f4911b90424
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Sep 24 14:39:53 2019 +0200

    clk: let init callback return an error code
    
    If the init callback is allowed to request resources, it needs a return
    value to report the outcome of such a request.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lkml.kernel.org/r/20190924123954.31561-3-jbrunet@baylibre.com
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 676e40deefcf..b8dc848a04f7 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3316,16 +3316,21 @@ static int __clk_core_init(struct clk_core *core)
 	 * optional platform-specific magic
 	 *
 	 * The .init callback is not used by any of the basic clock types, but
-	 * exists for weird hardware that must perform initialization magic.
-	 * Please consider other ways of solving initialization problems before
-	 * using this callback, as its use is discouraged.
+	 * exists for weird hardware that must perform initialization magic for
+	 * CCF to get an accurate view of clock for any other callbacks. It may
+	 * also be used needs to perform dynamic allocations. Such allocation
+	 * must be freed in the terminate() callback.
+	 * This callback shall not be used to initialize the parameters state,
+	 * such as rate, parent, etc ...
 	 *
 	 * If it exist, this callback should called before any other callback of
 	 * the clock
 	 */
-	if (core->ops->init)
-		core->ops->init(core->hw);
-
+	if (core->ops->init) {
+		ret = core->ops->init(core->hw);
+		if (ret)
+			goto out;
+	}
 
 	core->parent = __clk_init_parent(core);
 

commit f6fa75ca912be6021335de63a32aa4d295f3c524
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Sep 24 14:39:52 2019 +0200

    clk: actually call the clock init before any other callback of the clock
    
     __clk_init_parent() will call the .get_parent() callback of the clock
     so .init() must run before.
    
    Fixes: 541debae0adf ("clk: call the clock init() callback before any other ops callback")
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lkml.kernel.org/r/20190924123954.31561-2-jbrunet@baylibre.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b68e200829f2..676e40deefcf 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3312,6 +3312,21 @@ static int __clk_core_init(struct clk_core *core)
 		goto out;
 	}
 
+	/*
+	 * optional platform-specific magic
+	 *
+	 * The .init callback is not used by any of the basic clock types, but
+	 * exists for weird hardware that must perform initialization magic.
+	 * Please consider other ways of solving initialization problems before
+	 * using this callback, as its use is discouraged.
+	 *
+	 * If it exist, this callback should called before any other callback of
+	 * the clock
+	 */
+	if (core->ops->init)
+		core->ops->init(core->hw);
+
+
 	core->parent = __clk_init_parent(core);
 
 	/*
@@ -3336,17 +3351,6 @@ static int __clk_core_init(struct clk_core *core)
 		core->orphan = true;
 	}
 
-	/*
-	 * optional platform-specific magic
-	 *
-	 * The .init callback is not used by any of the basic clock types, but
-	 * exists for weird hardware that must perform initialization magic.
-	 * Please consider other ways of solving initialization problems before
-	 * using this callback, as its use is discouraged.
-	 */
-	if (core->ops->init)
-		core->ops->init(core->hw);
-
 	/*
 	 * Set clk's accuracy.  The preferred method is to use
 	 * .recalc_accuracy. For simple clocks and lazy developers the default

commit c771256ee7a03d3fb3c0443319ae6249c455849d
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Dec 18 09:56:21 2019 -0800

    clk: Move clk_core_reparent_orphans() under CONFIG_OF
    
    A recent addition exposed a helper that is only used for CONFIG_OF. Move
    it into the CONFIG_OF zone in this file to make the compiler stop
    warning about an unused function.
    
    Fixes: 66d9506440bb ("clk: walk orphan list on clock provider registration")
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Link: https://lkml.kernel.org/r/20191217082501.424892072D@mail.kernel.org
    [sboyd@kernel.org: "Simply" move the function instead]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ae2795b30e06..6a11239ccde3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3277,13 +3277,6 @@ static void clk_core_reparent_orphans_nolock(void)
 	}
 }
 
-static void clk_core_reparent_orphans(void)
-{
-	clk_prepare_lock();
-	clk_core_reparent_orphans_nolock();
-	clk_prepare_unlock();
-}
-
 /**
  * __clk_core_init - initialize the data structures in a struct clk_core
  * @core:	clk_core being initialized
@@ -4193,6 +4186,13 @@ int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)
 EXPORT_SYMBOL_GPL(clk_notifier_unregister);
 
 #ifdef CONFIG_OF
+static void clk_core_reparent_orphans(void)
+{
+	clk_prepare_lock();
+	clk_core_reparent_orphans_nolock();
+	clk_prepare_unlock();
+}
+
 /**
  * struct of_clk_provider - Clock provider registration structure
  * @link: Entry in global list of clock providers

commit 66d9506440bb05289eb4867059e7b8c6ed209717
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Dec 3 09:08:05 2019 +0100

    clk: walk orphan list on clock provider registration
    
    So far, we walked the orphan list every time a new clock was registered
    in CCF. This was fine since the clocks were only referenced by name.
    
    Now that the clock can be referenced through DT, it is not enough:
    * Controller A register first a reference clocks from controller B
      through DT.
    * Controller B register all its clocks then register the provider.
    
    Each time controller B registers a new clock, the orphan list is walked
    but it can't match since the provider is registered yet. When the
    provider is finally registered, the orphan list is not walked unless
    another clock is registered afterward.
    
    This can lead to situation where some clocks remain orphaned even if
    the parent is available.
    
    Walking the orphan list on provider registration solves the problem.
    
    Reported-by: Jian Hu <jian.hu@amlogic.com>
    Fixes: fc0c209c147f ("clk: Allow parents to be specified without string names")
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lkml.kernel.org/r/20191203080805.104628-1-jbrunet@baylibre.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b68e200829f2..ae2795b30e06 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3249,6 +3249,41 @@ static inline void clk_debug_unregister(struct clk_core *core)
 }
 #endif
 
+static void clk_core_reparent_orphans_nolock(void)
+{
+	struct clk_core *orphan;
+	struct hlist_node *tmp2;
+
+	/*
+	 * walk the list of orphan clocks and reparent any that newly finds a
+	 * parent.
+	 */
+	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
+		struct clk_core *parent = __clk_init_parent(orphan);
+
+		/*
+		 * We need to use __clk_set_parent_before() and _after() to
+		 * to properly migrate any prepare/enable count of the orphan
+		 * clock. This is important for CLK_IS_CRITICAL clocks, which
+		 * are enabled during init but might not have a parent yet.
+		 */
+		if (parent) {
+			/* update the clk tree topology */
+			__clk_set_parent_before(orphan, parent);
+			__clk_set_parent_after(orphan, parent, NULL);
+			__clk_recalc_accuracies(orphan);
+			__clk_recalc_rates(orphan, 0);
+		}
+	}
+}
+
+static void clk_core_reparent_orphans(void)
+{
+	clk_prepare_lock();
+	clk_core_reparent_orphans_nolock();
+	clk_prepare_unlock();
+}
+
 /**
  * __clk_core_init - initialize the data structures in a struct clk_core
  * @core:	clk_core being initialized
@@ -3259,8 +3294,6 @@ static inline void clk_debug_unregister(struct clk_core *core)
 static int __clk_core_init(struct clk_core *core)
 {
 	int ret;
-	struct clk_core *orphan;
-	struct hlist_node *tmp2;
 	unsigned long rate;
 
 	if (!core)
@@ -3407,27 +3440,8 @@ static int __clk_core_init(struct clk_core *core)
 		clk_enable_unlock(flags);
 	}
 
-	/*
-	 * walk the list of orphan clocks and reparent any that newly finds a
-	 * parent.
-	 */
-	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
-		struct clk_core *parent = __clk_init_parent(orphan);
+	clk_core_reparent_orphans_nolock();
 
-		/*
-		 * We need to use __clk_set_parent_before() and _after() to
-		 * to properly migrate any prepare/enable count of the orphan
-		 * clock. This is important for CLK_IS_CRITICAL clocks, which
-		 * are enabled during init but might not have a parent yet.
-		 */
-		if (parent) {
-			/* update the clk tree topology */
-			__clk_set_parent_before(orphan, parent);
-			__clk_set_parent_after(orphan, parent, NULL);
-			__clk_recalc_accuracies(orphan);
-			__clk_recalc_rates(orphan, 0);
-		}
-	}
 
 	kref_init(&core->ref);
 out:
@@ -4274,6 +4288,8 @@ int of_clk_add_provider(struct device_node *np,
 	mutex_unlock(&of_clk_mutex);
 	pr_debug("Added clock from %pOF\n", np);
 
+	clk_core_reparent_orphans();
+
 	ret = of_clk_set_defaults(np, true);
 	if (ret < 0)
 		of_clk_del_provider(np);
@@ -4309,6 +4325,8 @@ int of_clk_add_hw_provider(struct device_node *np,
 	mutex_unlock(&of_clk_mutex);
 	pr_debug("Added clk_hw provider from %pOF\n", np);
 
+	clk_core_reparent_orphans();
+
 	ret = of_clk_set_defaults(np, true);
 	if (ret < 0)
 		of_clk_del_provider(np);

commit ec16ffe36d80b18a1f98d126a865d5557ab27c30
Merge: dabedfede324 cd94eade0b2a 564f86d38475 8f39f22f73b3 1e4fb2c0cb34
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Nov 27 08:15:13 2019 -0800

    Merge branches 'clk-ingenic', 'clk-init-leak', 'clk-ux500' and 'clk-bitmain' into clk-next
    
     - Support CGU in Ingenix X1000
     - Support Bitmain BM1880 clks
    
    * clk-ingenic:
      clk: ingenic: Allow drivers to be built with COMPILE_TEST
      clk: Ingenic: Add CGU driver for X1000.
      dt-bindings: clock: Add X1000 bindings.
    
    * clk-init-leak:
      clk: mark clk_disable_unused() as __init
      clk: Fix memory leak in clk_unregister()
    
    * clk-ux500:
      MAINTAINERS: Update section for Ux500 clock drivers
    
    * clk-bitmain:
      MAINTAINERS: Add entry for BM1880 SoC clock driver
      clk: Add common clock driver for BM1880 SoC
      dt-bindings: clock: Add devicetree binding for BM1880 SoC
      clk: Add clk_hw_unregister_composite helper function definition
      clk: Zero init clk_init_data in helpers

commit 564f86d384755e3fbb5c00703d3695df89c1e049
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Oct 4 11:48:25 2019 +0200

    clk: mark clk_disable_unused() as __init
    
    clk_disable_unused is only called once, as a late_initcall, so reclaim
    a bit of memory by marking it (and the functions and data it is the
    sole user of) as __init/__initdata. This moves ~1900 bytes from .text
    to .init.text for a imx_v6_v7_defconfig.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Link: https://lkml.kernel.org/r/20191004094826.8320-1-linux@rasmusvillemoes.dk
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2f2eea26c375..8fafdad9403e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1187,7 +1187,7 @@ static void clk_core_disable_unprepare(struct clk_core *core)
 	clk_core_unprepare_lock(core);
 }
 
-static void clk_unprepare_unused_subtree(struct clk_core *core)
+static void __init clk_unprepare_unused_subtree(struct clk_core *core)
 {
 	struct clk_core *child;
 
@@ -1217,7 +1217,7 @@ static void clk_unprepare_unused_subtree(struct clk_core *core)
 	clk_pm_runtime_put(core);
 }
 
-static void clk_disable_unused_subtree(struct clk_core *core)
+static void __init clk_disable_unused_subtree(struct clk_core *core)
 {
 	struct clk_core *child;
 	unsigned long flags;
@@ -1263,7 +1263,7 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 		clk_core_disable_unprepare(core->parent);
 }
 
-static bool clk_ignore_unused;
+static bool clk_ignore_unused __initdata;
 static int __init clk_ignore_unused_setup(char *__unused)
 {
 	clk_ignore_unused = true;
@@ -1271,7 +1271,7 @@ static int __init clk_ignore_unused_setup(char *__unused)
 }
 __setup("clk_ignore_unused", clk_ignore_unused_setup);
 
-static int clk_disable_unused(void)
+static int __init clk_disable_unused(void)
 {
 	struct clk_core *core;
 

commit 8247470772beb38822f226c99a2ed8c195f6b438
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Tue Oct 22 12:41:53 2019 +0530

    clk: Fix memory leak in clk_unregister()
    
    Memory allocated in alloc_clk() for 'struct clk' and
    'const char *con_id' while invoking clk_register() is never freed
    in clk_unregister(), resulting in kmemleak showing the following
    backtrace.
    
      backtrace:
        [<00000000546f5dd0>] kmem_cache_alloc+0x18c/0x270
        [<0000000073a32862>] alloc_clk+0x30/0x70
        [<0000000082942480>] __clk_register+0xc8/0x760
        [<000000005c859fca>] devm_clk_register+0x54/0xb0
        [<00000000868834a8>] 0xffff800008c60950
        [<00000000d5a80534>] platform_drv_probe+0x50/0xa0
        [<000000001b3889fc>] really_probe+0x108/0x348
        [<00000000953fa60a>] driver_probe_device+0x58/0x100
        [<0000000008acc17c>] device_driver_attach+0x6c/0x90
        [<0000000022813df3>] __driver_attach+0x84/0xc8
        [<00000000448d5443>] bus_for_each_dev+0x74/0xc8
        [<00000000294aa93f>] driver_attach+0x20/0x28
        [<00000000e5e52626>] bus_add_driver+0x148/0x1f0
        [<000000001de21efc>] driver_register+0x60/0x110
        [<00000000af07c068>] __platform_driver_register+0x40/0x48
        [<0000000060fa80ee>] 0xffff800008c66020
    
    Fix it here.
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Link: https://lkml.kernel.org/r/20191022071153.21118-1-kishon@ti.com
    Fixes: 1df4046a93e0 ("clk: Combine __clk_get() and __clk_create_clk()")
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 1c677d7f7f53..2f2eea26c375 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3879,6 +3879,7 @@ void clk_unregister(struct clk *clk)
 					__func__, clk->core->name);
 
 	kref_put(&clk->core->ref, __clk_release);
+	free_clk(clk);
 unlock:
 	clk_prepare_unlock();
 }

commit d9b86cc48283112f06738d45031b88bd3f9ecb92
Author: Sowjanya Komatineni <skomatineni@nvidia.com>
Date:   Fri Aug 16 12:41:52 2019 -0700

    clk: Add API to get index of the clock parent
    
    This patch adds a new clk_hw_get_parent_index() function that can be
    used to retrieve the index of a given clock's parent. This can be useful
    for restoring a clock on system resume.
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 1c677d7f7f53..f8ed6e613436 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1674,6 +1674,24 @@ static int clk_fetch_parent_index(struct clk_core *core,
 	return i;
 }
 
+/**
+ * clk_hw_get_parent_index - return the index of the parent clock
+ * @hw: clk_hw associated with the clk being consumed
+ *
+ * Fetches and returns the index of parent clock. Returns -EINVAL if the given
+ * clock does not have a current parent.
+ */
+int clk_hw_get_parent_index(struct clk_hw *hw)
+{
+	struct clk_hw *parent = clk_hw_get_parent(hw);
+
+	if (WARN_ON(parent == NULL))
+		return -EINVAL;
+
+	return clk_fetch_parent_index(hw->core, parent->core);
+}
+EXPORT_SYMBOL_GPL(clk_hw_get_parent_index);
+
 /*
  * Update the orphan status of @core and all its children.
  */

commit a703d279c57e1bfe2b6536c3a17c1c498b416d24
Merge: 1ddd00276fd5 ebd47c843406
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 20 15:45:07 2019 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "We have a small collection of core framework updates this time, mostly
      around clk registration by clk providers and debugfs "nice to haves"
      for rate constraints. I'll highlight that we're now setting the
      clk_init_data pointer inside struct clk_hw to NULL during
      clk_register(), which may break some drivers that thought they could
      use that pointer during normal operations. That change has been
      sitting in next for a while now but maybe something is still broken.
      We'l see. Other than that the core framework changes aren't invasive
      and they're fixing bugs, simplifying, and making things better.
    
      On the clk driver side we got the usual addition of new SoC support,
      new features for existing drivers, and bug fixes scattered throughout.
      The biggest diffstat is the Amlogic driver that gained CPU clk support
      in addition to migrating to the new way of specifying clk parents.
      After that the Qualcomm, i.MX, Mediatek, and Rockchip clk drivers got
      support for various new SoCs and clock controllers from those vendors.
    
      Core:
       - Drop NULL checks in clk debugfs
       - Add min/max rates to clk debugfs
       - Set clk_init_data pointer inside clk_hw to NULL after registration
       - Make clk_bulk_get_all() return an 'id' corresponding to clock-names
       - Evict parents from parent cache when they're unregistered
    
      New Drivers:
       - Add clock driver for i.MX8MN SoCs
       - Support aspeed AST2600 SoCs
       - Support for Mediatek MT6779 SoCs
       - Support qcom SM8150 GCC and RPMh clks
       - Support qcom QCS404 WCSS clks
       - Add CPU clock support for Armada 7K/8K (specifically AP806 and AP807)
       - Addition of clock driver for Rockchip rk3308 SoCs
    
      Updates:
       - Add regulator support to the cdce925 clk driver
       - Add support for Raspberry Pi 4 bcm2711 SoCs
       - Add SDIO gate support to aspeed driver
       - Add missing of_node_put() calls in various clk drivers
       - Migrate Amlogic driver to new clock parent description method
       - Add DVFS support to Amlogic Meson g12
       - Add Amlogic Meson g12a reset support to the axg audio clock controller
       - Add sm1 support to the Amlogic Meson g12a clock controller
       - Switch i.MX8MM clock driver to platform driver
       - Add Hifi4 DSP related clocks for i.MX8QXP SoC
       - Fix Audio PLL setting and parent clock for USB
       - Misc i.MX8 clock driver improvements and corrections
       - Set floor ops for Qualcomm SD clks so that rounding works
       - Fix "always-on" Clock Domains on Renesas R-Car M1A, RZ/A1, RZ/A2, and RZ/N1
       - Enable the Allwinner V3 SoC and fix the i2s clock for H6"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (137 commits)
      clk: Drop !clk checks in debugfs dumping
      clk: imx: imx8mn: fix pll mux bit
      clk: imx: imx8mm: fix pll mux bit
      clk: imx: clk-pll14xx: unbypass PLL by default
      clk: imx: pll14xx: avoid glitch when set rate
      clk: mvebu: ap80x: add AP807 clock support
      clk: mvebu: ap806: Prepare the introduction of AP807 clock support
      clk: mvebu: ap806: add AP-DCLK (hclk) to system controller driver
      clk: mvebu: ap806: be more explicit on what SaR is
      clk: mvebu: ap80x-cpu: add AP807 CPU clock support
      clk: mvebu: ap806-cpu: prepare mapping of AP807 CPU clock
      dt-bindings: ap806: Document AP807 clock compatible
      dt-bindings: ap80x: Document AP807 CPU clock compatible
      clk: sprd: add missing kfree
      clk: at91: allow 24 Mhz clock as input for PLL
      clk: Make clk_bulk_get_all() return a valid "id"
      clk: actions: Fix factor clk struct member access
      clk: qcom: rcg: Return failure for RCG update
      clk: remove extra ---help--- tags in Kconfig
      clk: add include guard to clk-conf.h
      ...

commit b6c444de05acb10c6497549d1d0c6fb7e5883742
Merge: 91bcbc11d65f d69d0b4384ba 5c5ba218c6dc bdcf1dc25324 ed309bfb4812
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Sep 19 15:31:46 2019 -0700

    Merge branches 'clk-cdce-regulator', 'clk-bcm', 'clk-evict-parent-cache' and 'clk-actions' into clk-next
    
     - Add regulator support to the cdce925 clk driver
     - Add support for Raspberry Pi 4 bcm2711 SoCs
     - Evict parents from parent cache when they're unregistered
    
    * clk-cdce-regulator:
      clk: clk-cdce925: Add regulator support
      dt-bindings: clock: cdce925: Add regulator documentation
    
    * clk-bcm:
      clk: bcm2835: Mark PLLD_PER as CRITICAL
      clk: bcm2835: Add BCM2711_CLOCK_EMMC2 support
      clk: bcm2835: Introduce SoC specific clock registration
      dt-bindings: bcm2835-cprman: Add bcm2711 support
    
    * clk-evict-parent-cache:
      clk: Evict unregistered clks from parent caches
    
    * clk-actions:
      clk: actions: Fix factor clk struct member access

commit a1ff1ce30036eca05bce1239159311bc3ef8f363
Merge: f5c7305db30b 0214f33c4e0e 863e53e6ed7a 60a8a148b2fb 924a8c6edaed
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Sep 19 15:31:27 2019 -0700

    Merge branches 'clk-init-destroy', 'clk-doc', 'clk-imx' and 'clk-allwinner' into clk-next
    
     - Set clk_init_data pointer inside clk_hw to NULL after registration
    
    * clk-init-destroy:
      clk: Overwrite clk_hw::init with NULL during clk_register()
      clk: sunxi: Don't call clk_hw_get_name() on a hw that isn't registered
      clk: ti: Don't reference clk_init_data after registration
      clk: qcom: Remove error prints from DFS registration
      rtc: sun6i: Don't reference clk_init_data after registration
      clk: zx296718: Don't reference clk_init_data after registration
      clk: milbeaut: Don't reference clk_init_data after registration
      clk: socfpga: deindent code to proper indentation
      phy: ti: am654-serdes: Don't reference clk_init_data after registration
      clk: sprd: Don't reference clk_init_data after registration
      clk: socfpga: Don't reference clk_init_data after registration
      clk: sirf: Don't reference clk_init_data after registration
      clk: qcom: Don't reference clk_init_data after registration
      clk: meson: axg-audio: Don't reference clk_init_data after registration
      clk: lochnagar: Don't reference clk_init_data after registration
      clk: actions: Don't reference clk_init_data after registration
    
    * clk-doc:
      clk: remove extra ---help--- tags in Kconfig
      clk: add include guard to clk-conf.h
      clk: Document of_parse_clkspec() some more
      clk: Remove extraneous 'for' word in comments
    
    * clk-imx: (32 commits)
      clk: imx: imx8mn: fix pll mux bit
      clk: imx: imx8mm: fix pll mux bit
      clk: imx: clk-pll14xx: unbypass PLL by default
      clk: imx: pll14xx: avoid glitch when set rate
      clk: imx: imx8mn: fix audio pll setting
      clk: imx8mn: Add necessary frequency support for ARM PLL table
      clk: imx8mn: Add missing rate_count assignment for each PLL structure
      clk: imx8mn: fix int pll clk gate
      clk: imx8mn: Add GIC clock
      clk: imx8mn: Fix incorrect parents
      clk: imx8mm: Fix incorrect parents
      clk: imx8mq: Fix sys3 pll references
      clk: imx8mq: Unregister clks when of_clk_add_provider failed
      clk: imx8mm: Unregister clks when of_clk_add_provider failed
      clk: imx8mq: Mark AHB clock as critical
      clk: imx8mn: Keep uart clocks on for early console
      clk: imx: Remove unused function statement
      clk: imx7ulp: Make sure earlycon's clock is enabled
      clk: imx8mm: Switch to platform driver
      clk: imx: imx8mm: fix audio pll setting
      ...
    
    * clk-allwinner:
      clk: sunxi-ng: h6: Allow I2S to change parent rate
      clk: sunxi-ng: v3s: add Allwinner V3 support
      clk: sunxi-ng: v3s: add missing clock slices for MMC2 module clocks
      dt-bindings: clk: sunxi-ccu: add compatible string for V3 CCU
      clk: sunxi-ng: v3s: add the missing PLL_DDR1

commit f5c7305db30b5a15d341d3a7009a55c4357d459c
Merge: cee99529ee0a 21ea4b62e1f3 327aa7415638 c0448dce56a4 03d570e1a4dc 5a85a642575c
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Sep 19 15:30:59 2019 -0700

    Merge branches 'clk-qcom', 'clk-mtk', 'clk-armada', 'clk-ingenic' and 'clk-meson' into clk-next
    
     - Support qcom SM8150 RPMh clks
     - Set floor ops for qcom sd clks
     - Support qcom QCS404 WCSS clks
     - Support for Mediatek MT6779 SoCs
     - Add CPU clock support for Armada 7K/8K (specifically AP806 and AP807)
    
    * clk-qcom:
      clk: qcom: rcg: Return failure for RCG update
      clk: qcom: fix QCS404 TuringCC regmap
      clk: qcom: clk-rpmh: Add support for SM8150
      dt-bindings: clock: Document SM8150 rpmh-clock compatible
      clk: qcom: clk-rpmh: Convert to parent data scheme
      dt-bindings: clock: Document the parent clocks
      clk: qcom: gcc: Use floor ops for SDCC clocks
      clk: qcom: gcc-qcs404: Use floor ops for sdcc clks
      clk: qcom: gcc-sdm845: Use floor ops for sdcc clks
      clk: qcom: define probe by index API as common API
      clk: qcom: Add WCSS gcc clock control for QCS404
      clk: qcom: msm8916: Don't build by default
      clk: qcom: gcc: Add global clock controller driver for SM8150
      dt-bindings: clock: Document gcc bindings for SM8150
      clk: qcom: clk-alpha-pll: Add support for Trion PLLs
      clk: qcom: clk-alpha-pll: Remove post_div_table checks
      clk: qcom: clk-alpha-pll: Remove unnecessary cast
    
    * clk-mtk:
      clk: mediatek: Runtime PM support for MT8183 mcucfg clock provider
      clk: mediatek: Register clock gate with device
      clk: mediatek: add pericfg clocks for MT8183
      dt-bindings: clock: mediatek: add pericfg for MT8183
      clk: mediatek: Add MT6779 clock support
      clk: mediatek: Add dt-bindings for MT6779 clocks
      dt-bindings: mediatek: bindings for MT6779 clk
      clk: reset: Modify reset-controller driver
    
    * clk-armada:
      clk: mvebu: ap80x: add AP807 clock support
      clk: mvebu: ap806: Prepare the introduction of AP807 clock support
      clk: mvebu: ap806: add AP-DCLK (hclk) to system controller driver
      clk: mvebu: ap806: be more explicit on what SaR is
      clk: mvebu: ap80x-cpu: add AP807 CPU clock support
      clk: mvebu: ap806-cpu: prepare mapping of AP807 CPU clock
      dt-bindings: ap806: Document AP807 clock compatible
      dt-bindings: ap80x: Document AP807 CPU clock compatible
      clk: mvebu: ap806: Fix clock name for the cluster
      clk: mvebu: add CPU clock driver for Armada 7K/8K
      clk: mvebu: add helper file for Armada AP and CP clocks
      dt-bindings: ap806: add the cluster clock node in the syscon file
    
    * clk-ingenic:
      clk: ingenic: Use CLK_OF_DECLARE_DRIVER macro
      clk: ingenic/jz4740: Fix "pll half" divider not read/written properly
    
    * clk-meson: (23 commits)
      clk: meson: g12a: add support for SM1 CPU 1, 2 & 3 clocks
      clk: meson: g12a: add support for SM1 DynamIQ Shared Unit clock
      clk: meson: g12a: add support for SM1 GP1 PLL
      dt-bindings: clk: meson: add sm1 periph clock controller bindings
      clk: meson: axg-audio: add g12a reset support
      dt-bindings: clock: meson: add resets to the audio clock controller
      clk: meson: g12a: expose CPUB clock ID for G12B
      clk: meson: g12a: add notifiers to handle cpu clock change
      clk: meson: add g12a cpu dynamic divider driver
      clk: core: introduce clk_hw_set_parent()
      clk: meson: remove clk input helper
      clk: meson: remove ee input bypass clocks
      clk: meson: clk-regmap: migrate to new parent description method
      clk: meson: meson8b: migrate to the new parent description method
      clk: meson: axg: migrate to the new parent description method
      clk: meson: gxbb: migrate to the new parent description method
      clk: meson: g12a: migrate to the new parent description method
      clk: meson: remove ao input bypass clocks
      clk: meson: axg-aoclk: migrate to the new parent description method
      clk: meson: gxbb-aoclk: migrate to the new parent description method
      ...

commit 7f4804665b58ced5d09848785d835af0f7a51b3e
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Aug 26 16:47:29 2019 -0700

    clk: Drop !clk checks in debugfs dumping
    
    These recursive functions have checks for !clk being passed in, but the
    callers are always looping through lists and therefore the pointers
    can't be NULL. Drop the checks to simplify the code.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190826234729.145593-1-sboyd@kernel.org

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b6f50db759a4..7783c25fb407 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2849,9 +2849,6 @@ static struct hlist_head *orphan_list[] = {
 static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
 				 int level)
 {
-	if (!c)
-		return;
-
 	seq_printf(s, "%*s%-*s %7d %8d %8d %11lu %10lu %5d %6d\n",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
@@ -2866,9 +2863,6 @@ static void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,
 {
 	struct clk_core *child;
 
-	if (!c)
-		return;
-
 	clk_summary_show_one(s, c, level);
 
 	hlist_for_each_entry(child, &c->children, child_node)
@@ -2900,9 +2894,6 @@ static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 {
 	unsigned long min_rate, max_rate;
 
-	if (!c)
-		return;
-
 	clk_core_get_boundaries(c, &min_rate, &max_rate);
 
 	/* This should be JSON format, i.e. elements separated with a comma */
@@ -2923,9 +2914,6 @@ static void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)
 {
 	struct clk_core *child;
 
-	if (!c)
-		return;
-
 	clk_dump_one(s, c, level);
 
 	hlist_for_each_entry(child, &c->children, child_node) {

commit bdcf1dc253248542537a742ae1e7ccafdd03f2d3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Aug 28 11:19:59 2019 -0700

    clk: Evict unregistered clks from parent caches
    
    We leave a dangling pointer in each clk_core::parents array that has an
    unregistered clk as a potential parent when that clk_core pointer is
    freed by clk{_hw}_unregister(). It is impossible for the true parent of
    a clk to be set with clk_set_parent() once the dangling pointer is left
    in the cache because we compare parent pointers in
    clk_fetch_parent_index() instead of checking for a matching clk name or
    clk_hw pointer.
    
    Before commit ede77858473a ("clk: Remove global clk traversal on fetch
    parent index"), we would check clk_hw pointers, which has a higher
    chance of being the same between registration and unregistration, but it
    can still be allocated and freed by the clk provider. In fact, this has
    been a long standing problem since commit da0f0b2c3ad2 ("clk: Correct
    lookup logic in clk_fetch_parent_index()") where we stopped trying to
    compare clk names and skipped over entries in the cache that weren't
    NULL.
    
    There are good (performance) reasons to not do the global tree lookup in
    cases where the cache holds dangling pointers to parents that have been
    unregistered. Let's take the performance hit on the uncommon
    registration path instead. Loop through all the clk_core::parents arrays
    when a clk is unregistered and set the entry to NULL when the parent
    cache entry and clk being unregistered are the same pointer. This will
    fix this problem and avoid the overhead for the "normal" case.
    
    Based on a patch by Bjorn Andersson.
    
    Fixes: da0f0b2c3ad2 ("clk: Correct lookup logic in clk_fetch_parent_index()")
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190828181959.204401-1-sboyd@kernel.org

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c0990703ce54..f9076c74bf0d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -37,6 +37,12 @@ static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
 
+static struct hlist_head *all_lists[] = {
+	&clk_root_list,
+	&clk_orphan_list,
+	NULL,
+};
+
 /***    private data structures    ***/
 
 struct clk_parent_map {
@@ -2833,12 +2839,6 @@ static int inited = 0;
 static DEFINE_MUTEX(clk_debug_lock);
 static HLIST_HEAD(clk_debug_list);
 
-static struct hlist_head *all_lists[] = {
-	&clk_root_list,
-	&clk_orphan_list,
-	NULL,
-};
-
 static struct hlist_head *orphan_list[] = {
 	&clk_orphan_list,
 	NULL,
@@ -3737,6 +3737,34 @@ static const struct clk_ops clk_nodrv_ops = {
 	.set_parent	= clk_nodrv_set_parent,
 };
 
+static void clk_core_evict_parent_cache_subtree(struct clk_core *root,
+						struct clk_core *target)
+{
+	int i;
+	struct clk_core *child;
+
+	for (i = 0; i < root->num_parents; i++)
+		if (root->parents[i].core == target)
+			root->parents[i].core = NULL;
+
+	hlist_for_each_entry(child, &root->children, child_node)
+		clk_core_evict_parent_cache_subtree(child, target);
+}
+
+/* Remove this clk from all parent caches */
+static void clk_core_evict_parent_cache(struct clk_core *core)
+{
+	struct hlist_head **lists;
+	struct clk_core *root;
+
+	lockdep_assert_held(&prepare_lock);
+
+	for (lists = all_lists; *lists; lists++)
+		hlist_for_each_entry(root, *lists, child_node)
+			clk_core_evict_parent_cache_subtree(root, core);
+
+}
+
 /**
  * clk_unregister - unregister a currently registered clock
  * @clk: clock to unregister
@@ -3775,6 +3803,8 @@ void clk_unregister(struct clk *clk)
 			clk_core_set_parent_nolock(child, NULL);
 	}
 
+	clk_core_evict_parent_cache(clk->core);
+
 	hlist_del_init(&clk->core->child_node);
 
 	if (clk->core->prepare_count)

commit cef7298262e9af841fb70d8673af45caf55300a1
Merge: d47ebd684229 44acee207844
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 16 15:56:22 2019 -0700

    Merge tag 'armsoc-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM DT updates from Arnd Bergmann:
     "This is another huge branch with close to 450 changessets related to
      devicetree files, roughly half of this for 32-bit and 64-bit
      respectively. There are lots of cleanups and additional hardware
      support for platforms we already support based on SoCs from Renesas,
      ST-Microelectronics, Intel/Altera, Rockchips, Allwinner, Broadcom and
      other manufacturers.
    
      A total of 6 new SoCs and 37 new boards gets added this time, one more
      SoC will come in a follow-up branch. Most of the new boards are for
      64-bit ARM SoCs, the others are typically for the 32-bit Cortex-A7.
    
      Going more into details for SoC platforms with new hardware support:
    
       - The Snapdragon 855 (SM8150) is Qualcomm's current high-end phone
         platform, usually paired with an external 5G modem. So far we only
         support the Qualcomm SM8150 MTP reference platform, but no actual
         products.
    
       - For the slightly older Qualcomm platforms, support for several
         interesting products is getting added: Three laptops based on
         Snapdragon 835/MSM8998 (Asus NovaGo, HP Envy X2 and Lenovo Miix
         630), one laptop based on Snapdragon 850/sdm850 (Lenovo Yoga C630)
         and several phones based on the older Snapdragon 410/MSM8916
         (Samsung A3 and A5, Longcheer L8150 aka Android One 2nd gen "seed"
         aka Wileyfox Swift).
    
       - Mediatek MT7629 is a new wireless network router chip, similar to
         the older MT7623. It gets added together with the reference board
         implementation.
    
       - Allwinner V3 is a repackaged version of the existing low-end V3s
         chip, and is used in the tiny Lichee Pi Zero plus, also added here.
         There is also a new TV set-top box based on Allwinner H6, the Tanix
         TX6, and the eMMC variant of the Olimex A64-Olinuxino development
         board.
    
       - NXP i.MX8M Nano is a new member of the ever-expanding i.MX SoC
         family, similar to the i.MX8M Mini. As usual, there is a large
         number of new boards for i.MX SoCs: Einfochips i.MX8QXP AI_ML,
         SolidRun Hummingboard Pulse baseboard and System-on-Module,
         Boundary Devices i.MX8MQ Nitrogen8M, and TechNexion
         PICO-PI-IMX8M-DEV for the 64-bit i.MX8 line. For 32-bit, we get the
         Kontron i.MX6UL N6310 SoM with two baseboards, the PHYTEC
         phyBOARD-Segin SoM with three baseboards, and the Zodiac Inflight
         Innovations i.MX7 RMU2 board.
    
       - In a different NXP product line, the Layerscape LS1046A "Freeway"
         reference board gets added.
    
       - Amlogic SM1 (S905X3) and G12B (S922X, A311D) are updated chips from
         their set-top-box line and smart speaker with newer CPU and GPU
         cores compared to their predecessors. Both are now also supported
         by the Khadas VIM3 development board series, and the dts files for
         that get reorganized a bit to better deal with all variants.
         Another board based on SM1 that gets added is the SEI Robotics
         SEI610.
    
       - There are a handful of new x86 and Power9 server boards using
         Aspeed BMC chips that are gaining support for running Linux on the
         BMC through the OpenBMC project: Facebook
         Minipack/Wedge100/Wedge40, Lenovo Hr855xg2, and Mihawk. Notably
         these are still new machines using SoCs based on the ARM9 and ARM11
         CPU cores, as support for the new Cortex-A7 based AST2600 is still
         ramping up.
    
       - There are three new end-user products using 32-bit Rockchips SoCs:
         Mecer Xtreme Mini S6 is an Android "mini PC" box based on the
         low-end RK3229 chip, while the two AOpen products Chromebox Mini
         (Fievel) and Chromebase Mini (Tiger) run ChromeOS and are meant for
         commercial settings(digital signage, PoS, ...).
    
       - One more single-board computer based on the popular 64-bit RK3399
         is added: the Leez RK3399 P710"
    
    * tag 'armsoc-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (467 commits)
      arm64: dts: qcom: Add Lenovo Yoga C630
      ARM: dts: aspeed-g5: Fixe gpio-ranges upper limit
      ARM; dts: aspeed: mihawk: File should not be executable
      ARM: dts: aspeed: swift: Change power supplies to version 2
      ARM: dts: aspeed: vesnin: Add secondary SPI flash chip
      ARM: dts: aspeed: vesnin: Add wdt2 with alt-boot option
      ARM: dts: aspeed-g4: Add all flash chips
      ARM: dts: exynos: Enable GPU/Mali T604 on Arndale board
      ARM: dts: exynos: Enable GPU/Mali T604 on Chromebook Snow
      ARM: dts: exynos: Add GPU/Mali T604 node to Exynos5250
      ARM: dts: exynos: Fix min/max buck4 for GPU on Arndale board
      ARM: dts: exynos: Mark LDO10 as always-on on Peach Pit/Pi Chromebooks
      ARM: dts: exynos: Remove not accurate secondary ADC compatible
      arm64: dts: rockchip: limit clock rate of MMC controllers for RK3328
      arm64: dts: meson-sm1-sei610: add stdout-path property back
      arm64: dts: meson-sm1-sei610: enable DVFS
      arm64: dts: khadas-vim3: add support for the SM1 based VIM3L
      dt-bindings: arm: amlogic: add Amlogic SM1 based Khadas VIM3L bindings
      arm64: dts: khadas-vim3: move common nodes into meson-khadas-vim3.dtsi
      arm64: dts: meson: g12a: add reset to tdm formatters
      ...

commit 226fd70209451428c563977f5ce022a41d077110
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Aug 26 14:20:42 2019 -0700

    clk: Document of_parse_clkspec() some more
    
    The return value of of_parse_clkspec() is peculiar. If the function is
    called with a NULL argument for 'name' it will return -ENOENT, but if
    it's called with a non-NULL argument for 'name' it will return -EINVAL.
    This peculiarity is documented by commit 5c56dfe63b6e ("clk: Add comment
    about __of_clk_get_by_name() error values").
    
    Let's further document this function so that it's clear what the return
    value is and how to use the arguments to parse clk specifiers.
    
    Cc: Phil Edworthy <phil.edworthy@renesas.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190826212042.48642-1-sboyd@kernel.org
    Reviewed-by: Phil Edworthy <phil.edworthy@renesas.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index bea50eee9e8c..4649e036eed2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -4316,12 +4316,43 @@ void devm_of_clk_del_provider(struct device *dev)
 }
 EXPORT_SYMBOL(devm_of_clk_del_provider);
 
-/*
- * Beware the return values when np is valid, but no clock provider is found.
- * If name == NULL, the function returns -ENOENT.
- * If name != NULL, the function returns -EINVAL. This is because
- * of_parse_phandle_with_args() is called even if of_property_match_string()
- * returns an error.
+/**
+ * of_parse_clkspec() - Parse a DT clock specifier for a given device node
+ * @np: device node to parse clock specifier from
+ * @index: index of phandle to parse clock out of. If index < 0, @name is used
+ * @name: clock name to find and parse. If name is NULL, the index is used
+ * @out_args: Result of parsing the clock specifier
+ *
+ * Parses a device node's "clocks" and "clock-names" properties to find the
+ * phandle and cells for the index or name that is desired. The resulting clock
+ * specifier is placed into @out_args, or an errno is returned when there's a
+ * parsing error. The @index argument is ignored if @name is non-NULL.
+ *
+ * Example:
+ *
+ * phandle1: clock-controller@1 {
+ *	#clock-cells = <2>;
+ * }
+ *
+ * phandle2: clock-controller@2 {
+ *	#clock-cells = <1>;
+ * }
+ *
+ * clock-consumer@3 {
+ *	clocks = <&phandle1 1 2 &phandle2 3>;
+ *	clock-names = "name1", "name2";
+ * }
+ *
+ * To get a device_node for `clock-controller@2' node you may call this
+ * function a few different ways:
+ *
+ *   of_parse_clkspec(clock-consumer@3, -1, "name2", &args);
+ *   of_parse_clkspec(clock-consumer@3, 1, NULL, &args);
+ *   of_parse_clkspec(clock-consumer@3, 1, "name2", &args);
+ *
+ * Return: 0 upon successfully parsing the clock specifier. Otherwise, -ENOENT
+ * if @name is NULL or -EINVAL if @name is non-NULL and it can't be found in
+ * the "clock-names" property of @np.
  */
 static int of_parse_clkspec(const struct device_node *np, int index,
 			    const char *name, struct of_phandle_args *out_args)

commit ef13e55c27e128b6d84aa939dcc565b1d2ee7724
Author: Rishi Gupta <gupt21@gmail.com>
Date:   Sat Aug 17 12:05:59 2019 +0530

    clk: Remove extraneous 'for' word in comments
    
    An extra 'for' word is grammatically incorrect in the comment
    'verifying ops for multi-parent clks'. This commit removes
    this extra for word.
    
    Signed-off-by: Rishi Gupta <gupt21@gmail.com>
    Link: https://lkml.kernel.org/r/1566023759-7880-1-git-send-email-gupt21@gmail.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c0990703ce54..bea50eee9e8c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2437,7 +2437,7 @@ static int clk_core_set_parent_nolock(struct clk_core *core,
 	if (core->parent == parent)
 		return 0;
 
-	/* verify ops for for multi-parent clks */
+	/* verify ops for multi-parent clks */
 	if (core->num_parents > 1 && !core->ops->set_parent)
 		return -EPERM;
 

commit 24876f09a7dfe36a82f53d304d8c1bceb3257a0f
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Fri Aug 16 00:31:55 2019 +0200

    clk: Fix potential NULL dereference in clk_fetch_parent_index()
    
    Don't compare the parent clock name with a NULL name in the
    clk_parent_map. This prevents a kernel crash when passing NULL
    core->parents[i].name to strcmp().
    
    An example which triggered this is a mux clock with four parents when
    each of them is referenced in the clock driver using
    clk_parent_data.fw_name and then calling clk_set_parent(clk, 3rd_parent)
    on this mux.
    In this case the first parent is also the HW default so
    core->parents[i].hw is populated when the clock is registered. Calling
    clk_set_parent(clk, 3rd_parent) will then go through all parents and
    skip the first parent because it's hw pointer doesn't match. For the
    second parent no hw pointer is cached yet and clk_core_get(core, 1)
    returns a non-matching pointer (which is correct because we are comparing
    the second with the third parent). Comparing the result of
    clk_core_get(core, 2) with the requested parent gives a match. However
    we don't reach this point because right after the clk_core_get(core, 1)
    mismatch the old code tried to !strcmp(parent->name, NULL) (where the
    second argument is actually core->parents[i].name, but that was never
    populated by the clock driver).
    
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Link: https://lkml.kernel.org/r/20190815223155.21384-1-martin.blumenstingl@googlemail.com
    Fixes: fc0c209c147f ("clk: Allow parents to be specified without string names")
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8bce6bb4a965..1c46babeb093 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1654,7 +1654,8 @@ static int clk_fetch_parent_index(struct clk_core *core,
 			break;
 
 		/* Fallback to comparing globally unique names */
-		if (!strcmp(parent->name, core->parents[i].name))
+		if (core->parents[i].name &&
+		    !strcmp(parent->name, core->parents[i].name))
 			break;
 	}
 

commit 4f8c6aba37da199155a121c6cdc38505a9eb0259
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Aug 13 14:41:47 2019 -0700

    clk: Fix falling back to legacy parent string matching
    
    Calls to clk_core_get() will return ERR_PTR(-EINVAL) if we've started
    migrating a clk driver to use the DT based style of specifying parents
    but we haven't made any DT updates yet. This happens when we pass a
    non-NULL value as the 'name' argument of of_parse_clkspec(). That
    function returns -EINVAL in such a situation, instead of -ENOENT like we
    expected. The return value comes back up to clk_core_fill_parent_index()
    which proceeds to skip calling clk_core_lookup() because the error
    pointer isn't equal to -ENOENT, it's -EINVAL.
    
    Furthermore, we blindly overwrite the error pointer returned by
    clk_core_get() with NULL when there isn't a legacy .name member
    specified in the parent map. This isn't too bad right now because we
    don't really care to differentiate NULL from an error, but in the future
    we should only try to do a legacy lookup if we know we might find
    something. This way DT lookups that fail don't try to lookup based on
    strings when there isn't any string to match, hiding the error from DT
    parsing.
    
    Fix both these problems so that clk provider drivers can use the new
    style of parent mapping without having to also update their DT at the
    same time. This patch is based on an earlier patch from Taniya Das which
    checked for -EINVAL in addition to -ENOENT return values from
    clk_core_get().
    
    Fixes: 601b6e93304a ("clk: Allow parents to be specified via clkspec index")
    Cc: Taniya Das <tdas@codeaurora.org>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Reported-by: Taniya Das <tdas@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190813214147.34394-1-sboyd@kernel.org
    Tested-by: Taniya Das <tdas@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c0990703ce54..8bce6bb4a965 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -324,6 +324,25 @@ static struct clk_core *clk_core_lookup(const char *name)
 	return NULL;
 }
 
+#ifdef CONFIG_OF
+static int of_parse_clkspec(const struct device_node *np, int index,
+			    const char *name, struct of_phandle_args *out_args);
+static struct clk_hw *
+of_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec);
+#else
+static inline int of_parse_clkspec(const struct device_node *np, int index,
+				   const char *name,
+				   struct of_phandle_args *out_args)
+{
+	return -ENOENT;
+}
+static inline struct clk_hw *
+of_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec)
+{
+	return ERR_PTR(-ENOENT);
+}
+#endif
+
 /**
  * clk_core_get - Find the clk_core parent of a clk
  * @core: clk to find parent of
@@ -355,8 +374,9 @@ static struct clk_core *clk_core_lookup(const char *name)
  *      };
  *
  * Returns: -ENOENT when the provider can't be found or the clk doesn't
- * exist in the provider. -EINVAL when the name can't be found. NULL when the
- * provider knows about the clk but it isn't provided on this system.
+ * exist in the provider or the name can't be found in the DT node or
+ * in a clkdev lookup. NULL when the provider knows about the clk but it
+ * isn't provided on this system.
  * A valid clk_core pointer when the clk can be found in the provider.
  */
 static struct clk_core *clk_core_get(struct clk_core *core, u8 p_index)
@@ -367,17 +387,19 @@ static struct clk_core *clk_core_get(struct clk_core *core, u8 p_index)
 	struct device *dev = core->dev;
 	const char *dev_id = dev ? dev_name(dev) : NULL;
 	struct device_node *np = core->of_node;
+	struct of_phandle_args clkspec;
 
-	if (np && (name || index >= 0))
-		hw = of_clk_get_hw(np, index, name);
-
-	/*
-	 * If the DT search above couldn't find the provider or the provider
-	 * didn't know about this clk, fallback to looking up via clkdev based
-	 * clk_lookups
-	 */
-	if (PTR_ERR(hw) == -ENOENT && name)
+	if (np && (name || index >= 0) &&
+	    !of_parse_clkspec(np, index, name, &clkspec)) {
+		hw = of_clk_get_hw_from_clkspec(&clkspec);
+		of_node_put(clkspec.np);
+	} else if (name) {
+		/*
+		 * If the DT search above couldn't find the provider fallback to
+		 * looking up via clkdev based clk_lookups.
+		 */
 		hw = clk_find_hw(dev_id, name);
+	}
 
 	if (IS_ERR(hw))
 		return ERR_CAST(hw);
@@ -401,7 +423,7 @@ static void clk_core_fill_parent_index(struct clk_core *core, u8 index)
 			parent = ERR_PTR(-EPROBE_DEFER);
 	} else {
 		parent = clk_core_get(core, index);
-		if (IS_ERR(parent) && PTR_ERR(parent) == -ENOENT)
+		if (IS_ERR(parent) && PTR_ERR(parent) == -ENOENT && entry->name)
 			parent = clk_core_lookup(entry->name);
 	}
 

commit 0214f33c4e0e1f5a9a9c3f4881310c61713294e6
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Jul 31 12:35:17 2019 -0700

    clk: Overwrite clk_hw::init with NULL during clk_register()
    
    We don't want clk provider drivers to use the init structure after clk
    registration time, but we leave a dangling reference to it by means of
    clk_hw::init. Let's overwrite the member with NULL during clk_register()
    so that this can't be used anymore after registration time.
    
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190731193517.237136-10-sboyd@kernel.org
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c0990703ce54..efac620264a2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3484,9 +3484,9 @@ static int clk_cpy_name(const char **dst_p, const char *src, bool must_exist)
 	return 0;
 }
 
-static int clk_core_populate_parent_map(struct clk_core *core)
+static int clk_core_populate_parent_map(struct clk_core *core,
+					const struct clk_init_data *init)
 {
-	const struct clk_init_data *init = core->hw->init;
 	u8 num_parents = init->num_parents;
 	const char * const *parent_names = init->parent_names;
 	const struct clk_hw **parent_hws = init->parent_hws;
@@ -3566,6 +3566,14 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 {
 	int ret;
 	struct clk_core *core;
+	const struct clk_init_data *init = hw->init;
+
+	/*
+	 * The init data is not supposed to be used outside of registration path.
+	 * Set it to NULL so that provider drivers can't use it either and so that
+	 * we catch use of hw->init early on in the core.
+	 */
+	hw->init = NULL;
 
 	core = kzalloc(sizeof(*core), GFP_KERNEL);
 	if (!core) {
@@ -3573,17 +3581,17 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 		goto fail_out;
 	}
 
-	core->name = kstrdup_const(hw->init->name, GFP_KERNEL);
+	core->name = kstrdup_const(init->name, GFP_KERNEL);
 	if (!core->name) {
 		ret = -ENOMEM;
 		goto fail_name;
 	}
 
-	if (WARN_ON(!hw->init->ops)) {
+	if (WARN_ON(!init->ops)) {
 		ret = -EINVAL;
 		goto fail_ops;
 	}
-	core->ops = hw->init->ops;
+	core->ops = init->ops;
 
 	if (dev && pm_runtime_enabled(dev))
 		core->rpm_enabled = true;
@@ -3592,13 +3600,13 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 	if (dev && dev->driver)
 		core->owner = dev->driver->owner;
 	core->hw = hw;
-	core->flags = hw->init->flags;
-	core->num_parents = hw->init->num_parents;
+	core->flags = init->flags;
+	core->num_parents = init->num_parents;
 	core->min_rate = 0;
 	core->max_rate = ULONG_MAX;
 	hw->core = core;
 
-	ret = clk_core_populate_parent_map(core);
+	ret = clk_core_populate_parent_map(core, init);
 	if (ret)
 		goto fail_parents;
 

commit 3567894b6914813299300019e028874927210880
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Wed Jul 31 10:40:16 2019 +0200

    clk: core: introduce clk_hw_set_parent()
    
    Introduce the clk_hw_set_parent() provider call to change parent of
    a clock by using the clk_hw pointers.
    
    This eases the clock reparenting from clock rate notifiers and
    implementing DVFS with simpler code avoiding the boilerplates
    functions as __clk_lookup(clk_hw_get_name()) then clk_set_parent().
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c0990703ce54..c11b1781d24a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2487,6 +2487,12 @@ static int clk_core_set_parent_nolock(struct clk_core *core,
 	return ret;
 }
 
+int clk_hw_set_parent(struct clk_hw *hw, struct clk_hw *parent)
+{
+	return clk_core_set_parent_nolock(hw->core, parent->core);
+}
+EXPORT_SYMBOL_GPL(clk_hw_set_parent);
+
 /**
  * clk_set_parent - switch the parent of a mux clk
  * @clk: the mux clk whose input we are switching

commit 1ccc0ddf046a0197f2f9acca02a64da10aa6112d
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Jul 1 22:20:40 2019 +0200

    clk: Use seq_puts() in possible_parent_show()
    
    A string which did not contain a data format specification should be put
    into a sequence. Thus use the corresponding function seq_puts.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 991fb3a62bda..b6f50db759a4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3021,15 +3021,15 @@ static void possible_parent_show(struct seq_file *s, struct clk_core *core,
 	 */
 	parent = clk_core_get_parent_by_index(core, i);
 	if (parent)
-		seq_printf(s, "%s", parent->name);
+		seq_puts(s, parent->name);
 	else if (core->parents[i].name)
-		seq_printf(s, "%s", core->parents[i].name);
+		seq_puts(s, core->parents[i].name);
 	else if (core->parents[i].fw_name)
 		seq_printf(s, "<%s>(fw)", core->parents[i].fw_name);
 	else if (core->parents[i].index >= 0)
-		seq_printf(s, "%s",
-			   of_clk_get_parent_name(core->of_node,
-						  core->parents[i].index));
+		seq_puts(s,
+			 of_clk_get_parent_name(core->of_node,
+						core->parents[i].index));
 	else
 		seq_puts(s, "(missing)");
 

commit 9f7767226083d51c0674f1b71ac52daea6778b84
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Tue Jul 2 16:27:10 2019 +0300

    clk: Assert prepare_lock in clk_core_get_boundaries
    
    This function iterates the clk consumer list on clk_core so it must be
    called under prepare_lock. This is already done by all callers but add a
    lockdep assert to check anyway.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Link: https://lkml.kernel.org/r/29453ee8e820457d87a8faf9d496390e59c6826f.1562073871.git.leonard.crestez@nxp.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a7cee0fac071..991fb3a62bda 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -593,6 +593,8 @@ static void clk_core_get_boundaries(struct clk_core *core,
 {
 	struct clk *clk_user;
 
+	lockdep_assert_held(&prepare_lock);
+
 	*min_rate = core->min_rate;
 	*max_rate = core->max_rate;
 

commit 1bd37a46770017e89943769112c5f09e5a7b24c1
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Tue Jul 2 16:27:09 2019 +0300

    clk: Add clk_min/max_rate entries in debugfs
    
    Add two files to expose min/max clk rates as determined by
    clk_core_get_boundaries, taking all consumer requests into account.
    
    This information does not appear to be otherwise exposed to userspace.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Link: https://lkml.kernel.org/r/68e96af2df96512300604d797ade2088d7e6e496.1562073871.git.leonard.crestez@nxp.com
    [sboyd@kernel.org: Drop if statements for JSON printing]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c0990703ce54..a7cee0fac071 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2896,15 +2896,21 @@ DEFINE_SHOW_ATTRIBUTE(clk_summary);
 
 static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 {
+	unsigned long min_rate, max_rate;
+
 	if (!c)
 		return;
 
+	clk_core_get_boundaries(c, &min_rate, &max_rate);
+
 	/* This should be JSON format, i.e. elements separated with a comma */
 	seq_printf(s, "\"%s\": { ", c->name);
 	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
 	seq_printf(s, "\"protect_count\": %d,", c->protect_count);
 	seq_printf(s, "\"rate\": %lu,", clk_core_get_rate(c));
+	seq_printf(s, "\"min_rate\": %lu,", min_rate);
+	seq_printf(s, "\"max_rate\": %lu,", max_rate);
 	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy(c));
 	seq_printf(s, "\"phase\": %d,", clk_core_get_phase(c));
 	seq_printf(s, "\"duty_cycle\": %u",
@@ -3064,6 +3070,34 @@ static int clk_duty_cycle_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(clk_duty_cycle);
 
+static int clk_min_rate_show(struct seq_file *s, void *data)
+{
+	struct clk_core *core = s->private;
+	unsigned long min_rate, max_rate;
+
+	clk_prepare_lock();
+	clk_core_get_boundaries(core, &min_rate, &max_rate);
+	clk_prepare_unlock();
+	seq_printf(s, "%lu\n", min_rate);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(clk_min_rate);
+
+static int clk_max_rate_show(struct seq_file *s, void *data)
+{
+	struct clk_core *core = s->private;
+	unsigned long min_rate, max_rate;
+
+	clk_prepare_lock();
+	clk_core_get_boundaries(core, &min_rate, &max_rate);
+	clk_prepare_unlock();
+	seq_printf(s, "%lu\n", max_rate);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(clk_max_rate);
+
 static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
 	struct dentry *root;
@@ -3075,6 +3109,8 @@ static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	core->dentry = root;
 
 	debugfs_create_ulong("clk_rate", 0444, root, &core->rate);
+	debugfs_create_file("clk_min_rate", 0444, root, core, &clk_min_rate_fops);
+	debugfs_create_file("clk_max_rate", 0444, root, core, &clk_max_rate_fops);
 	debugfs_create_ulong("clk_accuracy", 0444, root, &core->accuracy);
 	debugfs_create_u32("clk_phase", 0444, root, &core->phase);
 	debugfs_create_file("clk_flags", 0444, root, core, &clk_flags_fops);

commit 916f562fb28a49457d3d99d156ca415b50d6750e
Merge: edafb6fe42cf b1511f7a48c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 17 10:07:48 2019 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "This round of clk driver and framework updates is heavy on the driver
      update side. The two main highlights in the core framework are the
      addition of an bulk clk_get API that handles optional clks and an
      extra debugfs file that tells the developer about the current parent
      of a clk.
    
      The driver updates are dominated by i.MX in the diffstat, but that is
      mostly because that SoC has started converting to the clk_hw style of
      clk registration. The next big update is in the Amlogic meson clk
      driver that gained some support for audio, cpu, and temperature clks
      while fixing some PLL issues. Finally, the biggest thing that stands
      out is the conversion of a large part of the Allwinner sunxi-ng driver
      to the new clk parent scheme that uses less strings and more pointer
      comparisons to match clk parents and children up.
    
      In general, it looks like we have a lot of little fixes and tweaks
      here and there to clk data along with the normal addition of a handful
      of new drivers and a couple new core framework features.
    
      Core:
       - Add a 'clk_parent' file in clk debugfs
       - Add a clk_bulk_get_optional() API (with devm too)
    
      New Drivers:
       - Support gated clk controller on MIPS based BCM63XX SoCs
       - Support SiLabs Si5341 and Si5340 chips
       - Support for CPU clks on Raspberry Pi devices
       - Audsys clock driver for MediaTek MT8516 SoCs
    
      Updates:
       - Convert a large portion of the Allwinner sunxi-ng driver to new clk parent scheme
       - Small frequency support for SiLabs Si544 chips
       - Slow clk support for AT91 SAM9X60 SoCs
       - Remove dead code in various clk drivers (-Wunused)
       - Support for Marvell 98DX1135 SoCs
       - Get duty cycle of generic pwm clks
       - Improvement in mmc phase calculation and cleanup of some rate defintions
       - Switch i.MX6 and i.MX7 clock drivers to clk_hw based APIs
       - Add GPIO, SNVS and GIC clocks for i.MX8 drivers
       - Mark imx6sx/ul/ull/sll MMDC_P1_IPG and imx8mm DRAM_APB as critical clock
       - Correct imx7ulp nic1_bus_clk and imx8mm audio_pll2_clk clock setting
       - Add clks for new Exynos5422 Dynamic Memory Controller driver
       - Clock definition for Exynos4412 Mali
       - Add CMM (Color Management Module) clocks on Renesas R-Car H3, M3-N, E3, and D3
       - Add TPU (Timer Pulse Unit / PWM) clocks on Renesas RZ/G2M
       - Support for 32 bit clock IDs in TI's sci-clks for J721e SoCs
       - TI clock probing done from DT by default instead of firmware
       - Fix Amlogic Meson mpll fractional part and spread sprectrum issues
       - Add Amlogic meson8 audio clocks
       - Add Amlogic g12a temperature sensors clocks
       - Add Amlogic g12a and g12b cpu clocks
       - Add TPU (Timer Pulse Unit / PWM) clocks on Renesas R-Car H3, M3-W, and M3-N
       - Add CMM (Color Management Module) clocks on Renesas R-Car M3-W
       - Add Clock Domain support on Renesas RZ/N1"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (190 commits)
      clk: consoldiate the __clk_get_hw() declarations
      clk: sprd: Add check for return value of sprd_clk_regmap_init()
      clk: lochnagar: Update DT binding doc to include the primary SPDIF MCLK
      clk: Add Si5341/Si5340 driver
      dt-bindings: clock: Add silabs,si5341
      clk: clk-si544: Implement small frequency change support
      clk: add BCM63XX gated clock controller driver
      devicetree: document the BCM63XX gated clock bindings
      clk: at91: sckc: use dedicated functions to unregister clock
      clk: at91: sckc: improve error path for sama5d4 sck registration
      clk: at91: sckc: remove unnecessary line
      clk: at91: sckc: improve error path for sam9x5 sck register
      clk: at91: sckc: add support to free slow clock osclillator
      clk: at91: sckc: add support to free slow rc oscillator
      clk: at91: sckc: add support to free slow oscillator
      clk: rockchip: export HDMIPHY clock on rk3228
      clk: rockchip: add watchdog pclk on rk3328
      clk: rockchip: add clock id for hdmi_phy special clock on rk3228
      clk: rockchip: add clock id for watchdog pclk on rk3328
      clk: at91: sckc: add support for SAM9X60
      ...

commit 47c9e0cef01494aa512e924b100160206295f45e
Merge: a993be3724d0 e2bb18347c8e e3527dca15c8 1df379924304 c974c48deeb9 ecbcc2aa6557
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jul 12 11:11:30 2019 -0700

    Merge branches 'clk-rpi-cpufreq', 'clk-tegra', 'clk-simplify-provider.h', 'clk-sprd' and 'clk-at91' into clk-next
    
     - Support for CPU clks on Raspberry Pi devices
     - Slow clk support for AT91 SAM9X60 SoCs
    
    * clk-rpi-cpufreq:
      clk: raspberrypi: register platform device for raspberrypi-cpufreq
      firmware: raspberrypi: register clk device
      clk: bcm283x: add driver interfacing with Raspberry Pi's firmware
      clk: bcm2835: remove pllb
    
    * clk-tegra:
      clk: tegra: Do not enable PLL_RE_VCO on Tegra210
      clk: tegra: Warn if an enabled PLL is in IDDQ
      clk: tegra: Do not warn unnecessarily
      clk: tegra210: fix PLLU and PLLU_OUT1
    
    * clk-simplify-provider.h:
      clk: consoldiate the __clk_get_hw() declarations
      clk: Unexport __clk_of_table
      clk: Remove ifdef for COMMON_CLK in clk-provider.h
    
    * clk-sprd:
      clk: sprd: Add check for return value of sprd_clk_regmap_init()
      clk: sprd: Check error only for devm_regmap_init_mmio()
      clk: sprd: Switch from of_iomap() to devm_ioremap_resource()
    
    * clk-at91:
      clk: at91: sckc: use dedicated functions to unregister clock
      clk: at91: sckc: improve error path for sama5d4 sck registration
      clk: at91: sckc: remove unnecessary line
      clk: at91: sckc: improve error path for sam9x5 sck register
      clk: at91: sckc: add support to free slow clock osclillator
      clk: at91: sckc: add support to free slow rc oscillator
      clk: at91: sckc: add support to free slow oscillator
      clk: at91: sckc: add support for SAM9X60
      dt-bindings: clk: at91: add bindings for SAM9X60's slow clock controller
      clk: at91: sckc: add support to specify registers bit offsets
      clk: at91: sckc: sama5d4 has no bypass support

commit a993be3724d0eb25a905db2eefc77fab4c355f53
Merge: dfe1d3a2830d e5e89247a74b da642427bd77 df095f996b8f 78a5ba8f9126
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jul 12 11:11:16 2019 -0700

    Merge branches 'clk-debugfs', 'clk-unused', 'clk-refactor' and 'clk-qoriq' into clk-next
    
     - Add a 'clk_parent' file in clk debugfs
     - Remove dead code in various clk drivers
    
    * clk-debugfs:
      clk: Add clk_parent entry in debugfs
    
    * clk-unused:
      clk: qcom: Fix -Wunused-const-variable
      clk: mmp: frac: Remove set but not used variable 'prev_rate'
      clk: ti: Remove unused functions
      clk: mediatek: mt8516: Remove unused variable
    
    * clk-refactor:
      clk: clk-cdce706: simplify getting the adapter of a client
      clk: Simplify clk_core_can_round()
    
    * clk-qoriq:
      clk: qoriq: add support for lx2160a

commit dfe1d3a2830d607bbd66bae8bb86ae7ffde04f38
Merge: e02cb1f59340 179175d389c7 88aa7af9c180 16e3c572cdc9 65e2218d1006
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jul 12 11:11:06 2019 -0700

    Merge branches 'clk-bulk-optional', 'clk-kirkwood', 'clk-socfpga' and 'clk-docs' into clk-next
    
     - Add a clk_bulk_get_optional() API (with devm too)
     - Support for Marvell 98DX1135 SoCs
    
    * clk-bulk-optional:
      clk: Document some devm_clk_bulk*() APIs
      clk: Add devm_clk_bulk_get_optional() function
      clk: Add clk_bulk_get_optional() function
    
    * clk-kirkwood:
      clk: kirkwood: Add support for MV98DX1135
      dt-bindings: clock: mvebu: Add compatible string for 98dx1135 core clock
    
    * clk-socfpga:
      clk: socfpga: stratix10: fix divider entry for the emac clocks
      clk: socfpga: stratix10: add additional clocks needed for the NAND IP
    
    * clk-docs:
      clk: Grammar missing "and", Spelling s/statisfied/satisfied/

commit e5e89247a74bf35f0bbfd180a46f5bf75c086885
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Mon Jun 10 14:06:38 2019 +0300

    clk: Add clk_parent entry in debugfs
    
    This allows to easily determine the parent in shell scripts without
    parsing more complex files.
    
    Add the clk_parent file for all clks which can have a parent, not just
    muxes. This way it can be used to determine the clk tree structure
    without parsing more complex files.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index aa51756fd4d6..d21a219deef8 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3011,6 +3011,17 @@ static int possible_parents_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(possible_parents);
 
+static int current_parent_show(struct seq_file *s, void *data)
+{
+	struct clk_core *core = s->private;
+
+	if (core->parent)
+		seq_printf(s, "%s\n", core->parent->name);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(current_parent);
+
 static int clk_duty_cycle_show(struct seq_file *s, void *data)
 {
 	struct clk_core *core = s->private;
@@ -3043,6 +3054,10 @@ static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	debugfs_create_file("clk_duty_cycle", 0444, root, core,
 			    &clk_duty_cycle_fops);
 
+	if (core->num_parents > 0)
+		debugfs_create_file("clk_parent", 0444, root, core,
+				    &current_parent_fops);
+
 	if (core->num_parents > 1)
 		debugfs_create_file("clk_possible_parents", 0444, root, core,
 				    &possible_parents_fops);

commit 65e2218d10064d1143572584251f8599dd09290a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Jun 17 15:56:02 2019 +0200

    clk: Grammar missing "and", Spelling s/statisfied/satisfied/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index aa51756fd4d6..b41023717779 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2194,7 +2194,7 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 EXPORT_SYMBOL_GPL(clk_set_rate);
 
 /**
- * clk_set_rate_exclusive - specify a new rate get exclusive control
+ * clk_set_rate_exclusive - specify a new rate and get exclusive control
  * @clk: the clk whose rate is being changed
  * @rate: the new rate for clk
  *
@@ -2202,7 +2202,7 @@ EXPORT_SYMBOL_GPL(clk_set_rate);
  * within a critical section
  *
  * This can be used initially to ensure that at least 1 consumer is
- * statisfied when several consumers are competing for exclusivity over the
+ * satisfied when several consumers are competing for exclusivity over the
  * same clock provider.
  *
  * The exclusivity is not applied if setting the rate failed.

commit eef1f1b6cff90ab7b24f9aaee11bbfeb1c7dc66b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Jun 17 14:02:48 2019 +0200

    clk: Simplify clk_core_can_round()
    
    A boolean expression already evaluates to true or false, so there is no
    need to check the result and return true or false explicitly.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index aa51756fd4d6..c68bc5f69591 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1324,10 +1324,7 @@ static void clk_core_init_rate_req(struct clk_core * const core,
 
 static bool clk_core_can_round(struct clk_core * const core)
 {
-	if (core->ops->determine_rate || core->ops->round_rate)
-		return true;
-
-	return false;
+	return core->ops->determine_rate || core->ops->round_rate;
 }
 
 static int clk_core_round_rate_nolock(struct clk_core *core,

commit 11f6c2307caee89370d7752eb6f404f1ed73faaf
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Jun 24 20:01:55 2019 -0700

    clk: Simplify debugfs printing and add a newline
    
    The possible parent printing function duplicates a bunch of if
    conditions. Pull that into another function so we can print an extra
    character at the end, either a space or a newline. This way we can add
    the required newline that got lost here and also shorten the code.
    
    Fixes: 2d156b78ce8f ("clk: Fix debugfs clk_possible_parents for clks without parent string names")
    Cc: Chen-Yu Tsai <wens@csie.org>
    Tested-by: Chen-Yu Tsai <wens@csie.org>
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 093161ca4dcc..09d8e84a1968 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2997,11 +2997,10 @@ static int clk_flags_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(clk_flags);
 
-static int possible_parents_show(struct seq_file *s, void *data)
+static void possible_parent_show(struct seq_file *s, struct clk_core *core,
+				 unsigned int i, char terminator)
 {
-	struct clk_core *core = s->private;
 	struct clk_core *parent;
-	int i;
 
 	/*
 	 * Go through the following options to fetch a parent's name.
@@ -3015,22 +3014,6 @@ static int possible_parents_show(struct seq_file *s, void *data)
 	 * specified directly via a struct clk_hw pointer, but it isn't
 	 * registered (yet).
 	 */
-	for (i = 0; i < core->num_parents - 1; i++) {
-		parent = clk_core_get_parent_by_index(core, i);
-		if (parent)
-			seq_printf(s, "%s ", parent->name);
-		else if (core->parents[i].name)
-			seq_printf(s, "%s ", core->parents[i].name);
-		else if (core->parents[i].fw_name)
-			seq_printf(s, "<%s>(fw) ", core->parents[i].fw_name);
-		else if (core->parents[i].index >= 0)
-			seq_printf(s, "%s ",
-				   of_clk_get_parent_name(core->of_node,
-							  core->parents[i].index));
-		else
-			seq_puts(s, "(missing) ");
-	}
-
 	parent = clk_core_get_parent_by_index(core, i);
 	if (parent)
 		seq_printf(s, "%s", parent->name);
@@ -3045,6 +3028,19 @@ static int possible_parents_show(struct seq_file *s, void *data)
 	else
 		seq_puts(s, "(missing)");
 
+	seq_putc(s, terminator);
+}
+
+static int possible_parents_show(struct seq_file *s, void *data)
+{
+	struct clk_core *core = s->private;
+	int i;
+
+	for (i = 0; i < core->num_parents - 1; i++)
+		possible_parent_show(s, core, i, ' ');
+
+	possible_parent_show(s, core, i, '\n');
+
 	return 0;
 }
 DEFINE_SHOW_ATTRIBUTE(possible_parents);

commit 2d156b78ce8febf15cd58a025d7d9d7b7577126a
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Fri May 3 11:15:09 2019 +0800

    clk: Fix debugfs clk_possible_parents for clks without parent string names
    
    Following the commit fc0c209c147f ("clk: Allow parents to be specified
    without string names"), the parent name string is not always populated.
    
    Instead, fetch the parents clk_core struct using the appropriate helper,
    and read its name directly. If that fails, go through the possible
    sources of parent names. The order in which they are used is different
    from how parents are looked up, with the global name having precedence
    over local fw_name and indices. This makes more sense as a) the
    parent_maps structure does not differentiate between legacy global names
    and fallback global names, and b) global names likely provide more
    information than local fw_names.
    
    Fixes: fc0c209c147f ("clk: Allow parents to be specified without string names")
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index aa51756fd4d6..093161ca4dcc 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3000,12 +3000,50 @@ DEFINE_SHOW_ATTRIBUTE(clk_flags);
 static int possible_parents_show(struct seq_file *s, void *data)
 {
 	struct clk_core *core = s->private;
+	struct clk_core *parent;
 	int i;
 
-	for (i = 0; i < core->num_parents - 1; i++)
-		seq_printf(s, "%s ", core->parents[i].name);
+	/*
+	 * Go through the following options to fetch a parent's name.
+	 *
+	 * 1. Fetch the registered parent clock and use its name
+	 * 2. Use the global (fallback) name if specified
+	 * 3. Use the local fw_name if provided
+	 * 4. Fetch parent clock's clock-output-name if DT index was set
+	 *
+	 * This may still fail in some cases, such as when the parent is
+	 * specified directly via a struct clk_hw pointer, but it isn't
+	 * registered (yet).
+	 */
+	for (i = 0; i < core->num_parents - 1; i++) {
+		parent = clk_core_get_parent_by_index(core, i);
+		if (parent)
+			seq_printf(s, "%s ", parent->name);
+		else if (core->parents[i].name)
+			seq_printf(s, "%s ", core->parents[i].name);
+		else if (core->parents[i].fw_name)
+			seq_printf(s, "<%s>(fw) ", core->parents[i].fw_name);
+		else if (core->parents[i].index >= 0)
+			seq_printf(s, "%s ",
+				   of_clk_get_parent_name(core->of_node,
+							  core->parents[i].index));
+		else
+			seq_puts(s, "(missing) ");
+	}
 
-	seq_printf(s, "%s\n", core->parents[i].name);
+	parent = clk_core_get_parent_by_index(core, i);
+	if (parent)
+		seq_printf(s, "%s", parent->name);
+	else if (core->parents[i].name)
+		seq_printf(s, "%s", core->parents[i].name);
+	else if (core->parents[i].fw_name)
+		seq_printf(s, "<%s>(fw)", core->parents[i].fw_name);
+	else if (core->parents[i].index >= 0)
+		seq_printf(s, "%s",
+			   of_clk_get_parent_name(core->of_node,
+						  core->parents[i].index));
+	else
+		seq_puts(s, "(missing)");
 
 	return 0;
 }

commit c8edb316b9bb6149193436dfbd240994733e27be
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jun 14 10:46:06 2019 -0700

    clk: Do a DT parent lookup even when index < 0
    
    We want to allow the parent lookup to happen even if the index is some
    value less than 0. This may be the case if a clk provider only specifies
    the .name member to match a string in the "clock-names" DT property. We
    shouldn't require that the index be >= 0 to make this use case work.
    
    Fixes: 601b6e93304a ("clk: Allow parents to be specified via clkspec index")
    Reported-by: Alexandre Mergnat <amergnat@baylibre.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index aa51756fd4d6..87b410d6e51d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -368,7 +368,7 @@ static struct clk_core *clk_core_get(struct clk_core *core, u8 p_index)
 	const char *dev_id = dev ? dev_name(dev) : NULL;
 	struct device_node *np = core->of_node;
 
-	if (np && index >= 0)
+	if (np && (name || index >= 0))
 		hw = of_clk_get_hw(np, index, name);
 
 	/*

commit 30d5a945743cd05ec5c847f2e38c2fbda5e00944
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu May 23 17:11:57 2019 -0700

    clk: Unexport __clk_of_table
    
    This symbol doesn't need to be exported to clk providers anymore.
    Originally, it was hidden inside clk.c, but then OMAP needed to get
    access to it in commit 819b4861c18d ("CLK: ti: add init support for
    clock IP blocks"), but eventually that code also changed in commit
    c08ee14cc663 ("clk: ti: change clock init to use generic of_clk_init")
    and we were left with this exported. Move this back into clk.c so that
    it isn't exposed anymore.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index aa51756fd4d6..b34e84bb8167 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -4038,6 +4038,7 @@ struct of_clk_provider {
 	void *data;
 };
 
+extern struct of_device_id __clk_of_table;
 static const struct of_device_id __clk_of_table_sentinel
 	__used __section(__clk_of_table_end);
 

commit c1157f60d72e8b20efc670cef28883832f42406c
Merge: 0caf00081735 1a079560b145
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue May 7 11:46:13 2019 -0700

    Merge branch 'clk-parent-rewrite-1' into clk-next
    
     - Rewrite how clk parents can be specified to be DT/clkdev based instead
       of just string based
    
    * clk-parent-rewrite-1:
      clk: Cache core in clk_fetch_parent_index() without names
      clk: fixed-factor: Initialize clk_init_data on stack
      clk: fixed-factor: Let clk framework find parent
      clk: Allow parents to be specified via clkspec index
      clk: Look for parents with clkdev based clk_lookups
      clk: Allow parents to be specified without string names
      clk: Add of_clk_hw_register() API for early clk drivers
      driver core: Let dev_of_node() accept a NULL dev
      clk: Prepare for clk registration API that uses DT nodes
      clkdev: Move clk creation outside of 'clocks_mutex'

commit 0caf000817353cfc5db22363ecdac63b83d3a3f9
Merge: ff060019f4e5 90b6c5c73c69
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue May 7 11:46:02 2019 -0700

    Merge branch 'clk-ti' into clk-next
    
    * clk-ti:
      clk: Remove CLK_IS_BASIC clk flag
      clk: ti: dra7: disable the RNG and TIMER12 clkctrl clocks on HS devices
      clk: ti: dra7x: prevent non-existing clkctrl clocks from registering
      ARM: omap2+: hwmod: drop CLK_IS_BASIC flag usage
      clk: ti: export the omap2_clk_is_hw_omap call

commit f6111b9d7970df07f783d3891735003fef2bc37e
Merge: 2ed3b9103a2b f14382d7e40c 043f44aba9a8 6e4fcc34e6a3 5834fd75e623
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue May 7 11:44:42 2019 -0700

    Merge branches 'clk-doc', 'clk-more-critical', 'clk-meson' and 'clk-basic-be' into clk-next
    
     - Remove clk_readl() and introduce BE versions of basic clk types
    
    * clk-doc:
      clk: Drop duplicate clk_register() documentation
      clk: Document and simplify clk_core_get_rate_nolock()
      clk: Remove 'flags' member of struct clk_fixed_rate
      clk: nxp: Drop 'flags' on fixed_rate clk macro
      clk: Document __clk_mux_determine_rate()
      clk: Document CLK_MUX_READ_ONLY mux flag
      clk: Document deprecated things
      clk: Collapse gpio clk kerneldoc
    
    * clk-more-critical:
      clk: highbank: Convert to CLK_IS_CRITICAL
    
    * clk-meson: (21 commits)
      clk: meson: axg-audio: add g12a support
      clk: meson: axg-audio: don't register inputs in the onecell data
      clk: meson: axg_audio: replace prefix axg by aud
      dt-bindings: clk: axg-audio: add g12a support
      clk: meson: meson8b: add the video decoder clock trees
      clk: meson: meson8b: add the VPU clock trees
      clk: meson: meson8b: add support for the GP_PLL clock on Meson8m2
      clk: meson: meson8b: use a separate clock table for Meson8m2
      dt-bindings: clock: meson8b: export the video decoder clocks
      clk: meson-g12a: add video decoder clocks
      dt-bindings: clock: meson8b: export the VPU clock
      clk: meson-g12a: add PCIE PLL clocks
      dt-bindings: clock: g12a-aoclk: expose CLKID_AO_CTS_OSCIN
      clk: meson-pll: add reduced specific clk_ops for G12A PCIe PLL
      dt-bindings: clock: meson8b: drop the "ABP" clock definition
      clk: meson: g12a: add cpu clocks
      dt-bindings: clk: g12a-clkc: add VDEC clock IDs
      dt-bindings: clock: axg-audio: unexpose controller inputs
      dt-bindings: clk: g12a-clkc: add PCIE PLL clock ID
      clk: g12a-aoclk: re-export CLKID_AO_SAR_ADC_SEL clock id
      ...
    
    * clk-basic-be:
      clk: core: replace clk_{readl,writel} with {readl,writel}
      clk: core: remove powerpc special handling
      powerpc/512x: mark clocks as big endian
      clk: mux: add explicit big endian support
      clk: multiplier: add explicit big endian support
      clk: gate: add explicit big endian support
      clk: fractional-divider: add explicit big endian support
      clk: divider: add explicit big endian support

commit 1a079560b1450b72ff4e944bb9185e77633d74c4
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Apr 30 10:22:30 2019 -0700

    clk: Cache core in clk_fetch_parent_index() without names
    
    If a clk has specified parents via clk_hw pointers it won't specify the
    globally unique names for the parents. Without the unique names, we
    can't fallback to comparing them against the name of the 'parent'
    pointer here. Therefore, do a pointer comparison against the clk_hw
    pointers too and cache the clk_core structure if they match. This fixes
    parent lookup code for clks that only specify clk_hw pointers and
    nothing else, like muxes that are purely inside a clk controller.
    
    Similarly, if the parent pointer isn't cached after trying to match
    clk_core or clk_hw pointers, lookup the pointer from DT or via clkdev
    lookups instead of relying purely on the globally unique clk name match.
    This should allow us to move away from having to specify global names
    for clk parents entirely.
    
    While we're in the area, add some comments so it's clearer what's going
    on. The if statements don't lend themselves to much clarity in their raw
    form.
    
    Fixes: fc0c209c147f ("clk: Allow parents to be specified without string names")
    Reported-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index dc05cb339761..dcb7e1cddd2d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -327,8 +327,7 @@ static struct clk_core *clk_core_lookup(const char *name)
 /**
  * clk_core_get - Find the clk_core parent of a clk
  * @core: clk to find parent of
- * @name: name to search for (if string based)
- * @index: index to use for search (if DT index based)
+ * @p_index: parent index to search for
  *
  * This is the preferred method for clk providers to find the parent of a
  * clk when that parent is external to the clk controller. The parent_names
@@ -360,9 +359,10 @@ static struct clk_core *clk_core_lookup(const char *name)
  * provider knows about the clk but it isn't provided on this system.
  * A valid clk_core pointer when the clk can be found in the provider.
  */
-static struct clk_core *clk_core_get(struct clk_core *core, const char *name,
-				     int index)
+static struct clk_core *clk_core_get(struct clk_core *core, u8 p_index)
 {
+	const char *name = core->parents[p_index].fw_name;
+	int index = core->parents[p_index].index;
 	struct clk_hw *hw = ERR_PTR(-ENOENT);
 	struct device *dev = core->dev;
 	const char *dev_id = dev ? dev_name(dev) : NULL;
@@ -400,7 +400,7 @@ static void clk_core_fill_parent_index(struct clk_core *core, u8 index)
 		if (!parent)
 			parent = ERR_PTR(-EPROBE_DEFER);
 	} else {
-		parent = clk_core_get(core, entry->fw_name, entry->index);
+		parent = clk_core_get(core, index);
 		if (IS_ERR(parent) && PTR_ERR(parent) == -ENOENT)
 			parent = clk_core_lookup(entry->name);
 	}
@@ -1612,20 +1612,37 @@ static int clk_fetch_parent_index(struct clk_core *core,
 		return -EINVAL;
 
 	for (i = 0; i < core->num_parents; i++) {
+		/* Found it first try! */
 		if (core->parents[i].core == parent)
 			return i;
 
+		/* Something else is here, so keep looking */
 		if (core->parents[i].core)
 			continue;
 
-		/* Fallback to comparing globally unique names */
-		if (!strcmp(parent->name, core->parents[i].name)) {
-			core->parents[i].core = parent;
-			return i;
+		/* Maybe core hasn't been cached but the hw is all we know? */
+		if (core->parents[i].hw) {
+			if (core->parents[i].hw == parent->hw)
+				break;
+
+			/* Didn't match, but we're expecting a clk_hw */
+			continue;
 		}
+
+		/* Maybe it hasn't been cached (clk_set_parent() path) */
+		if (parent == clk_core_get(core, i))
+			break;
+
+		/* Fallback to comparing globally unique names */
+		if (!strcmp(parent->name, core->parents[i].name))
+			break;
 	}
 
-	return -EINVAL;
+	if (i == core->num_parents)
+		return -EINVAL;
+
+	core->parents[i].core = parent;
+	return i;
 }
 
 /*

commit 90b6c5c73c6904ac200161fc38974d867f0535b0
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 25 10:57:37 2019 -0700

    clk: Remove CLK_IS_BASIC clk flag
    
    This flag was historically used to indicate that a clk is a "basic" type
    of clk like a mux, divider, gate, etc. This never turned out to be very
    useful though because it was hard to cleanly split "basic" clks from
    other clks in a system. This one flag was a way for type introspection
    and it just didn't scale. If anything, it was used by the TI clk driver
    to indicate that a clk_hw wasn't contained in the SoC specific clk
    structure. We can get rid of this define now that TI is finding those
    clks a different way.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: <linux-mips@vger.kernel.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: <linux-pwm@vger.kernel.org>
    Cc: <linux-amlogic@lists.infradead.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 96053a96fe2f..7279573eefd5 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2850,7 +2850,6 @@ static const struct {
 	ENTRY(CLK_SET_PARENT_GATE),
 	ENTRY(CLK_SET_RATE_PARENT),
 	ENTRY(CLK_IGNORE_UNUSED),
-	ENTRY(CLK_IS_BASIC),
 	ENTRY(CLK_GET_RATE_NOCACHE),
 	ENTRY(CLK_SET_RATE_NO_REPARENT),
 	ENTRY(CLK_GET_ACCURACY_NOCACHE),

commit 601b6e93304a65f8f7c37168763ab9ba5b195ce5
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:49 2019 -0700

    clk: Allow parents to be specified via clkspec index
    
    Some clk providers are simple DT nodes that only have a 'clocks'
    property without having an associated 'clock-names' property. In these
    cases, we want to let these clk providers point to their parent clks
    without having to dereference the 'clocks' property at probe time to
    figure out the parent's globally unique clk name. Let's add an 'index'
    property to the parent_data structure so that clk providers can indicate
    that their parent is a particular index in the 'clocks' DT property.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 50f5c73de688..dc05cb339761 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -44,6 +44,7 @@ struct clk_parent_map {
 	struct clk_core		*core;
 	const char		*fw_name;
 	const char		*name;
+	int			index;
 };
 
 struct clk_core {
@@ -326,7 +327,8 @@ static struct clk_core *clk_core_lookup(const char *name)
 /**
  * clk_core_get - Find the clk_core parent of a clk
  * @core: clk to find parent of
- * @name: name to search for
+ * @name: name to search for (if string based)
+ * @index: index to use for search (if DT index based)
  *
  * This is the preferred method for clk providers to find the parent of a
  * clk when that parent is external to the clk controller. The parent_names
@@ -358,22 +360,23 @@ static struct clk_core *clk_core_lookup(const char *name)
  * provider knows about the clk but it isn't provided on this system.
  * A valid clk_core pointer when the clk can be found in the provider.
  */
-static struct clk_core *clk_core_get(struct clk_core *core, const char *name)
+static struct clk_core *clk_core_get(struct clk_core *core, const char *name,
+				     int index)
 {
 	struct clk_hw *hw = ERR_PTR(-ENOENT);
 	struct device *dev = core->dev;
 	const char *dev_id = dev ? dev_name(dev) : NULL;
 	struct device_node *np = core->of_node;
 
-	if (np)
-		hw = of_clk_get_hw(np, -1, name);
+	if (np && index >= 0)
+		hw = of_clk_get_hw(np, index, name);
 
 	/*
 	 * If the DT search above couldn't find the provider or the provider
 	 * didn't know about this clk, fallback to looking up via clkdev based
 	 * clk_lookups
 	 */
-	if (PTR_ERR(hw) == -ENOENT)
+	if (PTR_ERR(hw) == -ENOENT && name)
 		hw = clk_find_hw(dev_id, name);
 
 	if (IS_ERR(hw))
@@ -397,8 +400,7 @@ static void clk_core_fill_parent_index(struct clk_core *core, u8 index)
 		if (!parent)
 			parent = ERR_PTR(-EPROBE_DEFER);
 	} else {
-		if (entry->fw_name)
-			parent = clk_core_get(core, entry->fw_name);
+		parent = clk_core_get(core, entry->fw_name, entry->index);
 		if (IS_ERR(parent) && PTR_ERR(parent) == -ENOENT)
 			parent = clk_core_lookup(entry->name);
 	}
@@ -3443,6 +3445,7 @@ static int clk_core_populate_parent_map(struct clk_core *core)
 
 	/* Copy everything over because it might be __initdata */
 	for (i = 0, parent = parents; i < num_parents; i++, parent++) {
+		parent->index = -1;
 		if (parent_names) {
 			/* throw a WARN if any entries are NULL */
 			WARN(!parent_names[i],
@@ -3452,6 +3455,7 @@ static int clk_core_populate_parent_map(struct clk_core *core)
 					   true);
 		} else if (parent_data) {
 			parent->hw = parent_data[i].hw;
+			parent->index = parent_data[i].index;
 			ret = clk_cpy_name(&parent->fw_name,
 					   parent_data[i].fw_name, false);
 			if (!ret)

commit dde4eff47c82c52a72af333d9e55370eee6d95d6
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:48 2019 -0700

    clk: Look for parents with clkdev based clk_lookups
    
    In addition to looking for DT based parents, support clkdev based
    clk_lookups. This should allow non-DT based clk drivers to participate
    in the parent lookup process.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ffd33b63c37e..50f5c73de688 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -324,14 +324,15 @@ static struct clk_core *clk_core_lookup(const char *name)
 }
 
 /**
- * clk_core_get - Find the parent of a clk using a clock specifier in DT
+ * clk_core_get - Find the clk_core parent of a clk
  * @core: clk to find parent of
- * @name: name to search for in 'clock-names' of device providing clk
+ * @name: name to search for
  *
  * This is the preferred method for clk providers to find the parent of a
  * clk when that parent is external to the clk controller. The parent_names
  * array is indexed and treated as a local name matching a string in the device
- * node's 'clock-names' property. This allows clk providers to use their own
+ * node's 'clock-names' property or as the 'con_id' matching the device's
+ * dev_name() in a clk_lookup. This allows clk providers to use their own
  * namespace instead of looking for a globally unique parent string.
  *
  * For example the following DT snippet would allow a clock registered by the
@@ -359,15 +360,23 @@ static struct clk_core *clk_core_lookup(const char *name)
  */
 static struct clk_core *clk_core_get(struct clk_core *core, const char *name)
 {
-	struct clk_hw *hw;
+	struct clk_hw *hw = ERR_PTR(-ENOENT);
+	struct device *dev = core->dev;
+	const char *dev_id = dev ? dev_name(dev) : NULL;
 	struct device_node *np = core->of_node;
 
-	if (!np)
-		return ERR_PTR(-ENOENT);
+	if (np)
+		hw = of_clk_get_hw(np, -1, name);
 
-	/* TODO: Support clkdev clk_lookups */
-	hw = of_clk_get_hw(np, -1, name);
-	if (IS_ERR_OR_NULL(hw))
+	/*
+	 * If the DT search above couldn't find the provider or the provider
+	 * didn't know about this clk, fallback to looking up via clkdev based
+	 * clk_lookups
+	 */
+	if (PTR_ERR(hw) == -ENOENT)
+		hw = clk_find_hw(dev_id, name);
+
+	if (IS_ERR(hw))
 		return ERR_CAST(hw);
 
 	return hw->core;

commit fc0c209c147f35ed2648adda09db39fcad89e334
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:47 2019 -0700

    clk: Allow parents to be specified without string names
    
    The common clk framework is lacking in ability to describe the clk
    topology without specifying strings for every possible parent-child
    link. There are a few drawbacks to the current approach:
    
     1) String comparisons are used for everything, including describing
     topologies that are 'local' to a single clock controller.
    
     2) clk providers (e.g. i2c clk drivers) need to create globally unique
     clk names to avoid collisions in the clk namespace, leading to awkward
     name generation code in various clk drivers.
    
     3) DT bindings may not fully describe the clk topology and linkages
     between clk controllers because drivers can easily rely on globally unique
     strings to describe connections between clks.
    
    This leads to confusing DT bindings, complicated clk name generation
    code, and inefficient string comparisons during clk registration just so
    that the clk framework can detect the topology of the clk tree.
    Furthermore, some drivers call clk_get() and then __clk_get_name() to
    extract the globally unique clk name just so they can specify the parent
    of the clk they're registering. We have of_clk_parent_fill() but that
    mostly only works for single clks registered from a DT node, which isn't
    the norm. Let's simplify this all by introducing two new ways of
    specifying clk parents.
    
    The first method is an array of pointers to clk_hw structures
    corresponding to the parents at that index. This works for clks that are
    registered when we have access to all the clk_hw pointers for the
    parents.
    
    The second method is a mix of clk_hw pointers and strings of local and
    global parent clk names. If the .fw_name member of the map is set we'll
    look for that clk by performing a DT based lookup of the device the clk
    is registered with and the .name specified in the map. If that fails,
    we'll fallback to the .name member and perform a global clk name lookup
    like we've always done before.
    
    Using either one of these new methods is entirely optional. Existing
    drivers will continue to work, and they can migrate to this new approach
    as they see fit. Eventually, we'll want to get rid of the 'parent_names'
    array in struct clk_init_data and use one of these new methods instead.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Rob Herring <robh@kernel.org>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ffa63ddcd408..ffd33b63c37e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -39,6 +39,13 @@ static LIST_HEAD(clk_notifier_list);
 
 /***    private data structures    ***/
 
+struct clk_parent_map {
+	const struct clk_hw	*hw;
+	struct clk_core		*core;
+	const char		*fw_name;
+	const char		*name;
+};
+
 struct clk_core {
 	const char		*name;
 	const struct clk_ops	*ops;
@@ -47,8 +54,7 @@ struct clk_core {
 	struct device		*dev;
 	struct device_node	*of_node;
 	struct clk_core		*parent;
-	const char		**parent_names;
-	struct clk_core		**parents;
+	struct clk_parent_map	*parents;
 	u8			num_parents;
 	u8			new_parent_index;
 	unsigned long		rate;
@@ -317,17 +323,92 @@ static struct clk_core *clk_core_lookup(const char *name)
 	return NULL;
 }
 
+/**
+ * clk_core_get - Find the parent of a clk using a clock specifier in DT
+ * @core: clk to find parent of
+ * @name: name to search for in 'clock-names' of device providing clk
+ *
+ * This is the preferred method for clk providers to find the parent of a
+ * clk when that parent is external to the clk controller. The parent_names
+ * array is indexed and treated as a local name matching a string in the device
+ * node's 'clock-names' property. This allows clk providers to use their own
+ * namespace instead of looking for a globally unique parent string.
+ *
+ * For example the following DT snippet would allow a clock registered by the
+ * clock-controller@c001 that has a clk_init_data::parent_data array
+ * with 'xtal' in the 'name' member to find the clock provided by the
+ * clock-controller@f00abcd without needing to get the globally unique name of
+ * the xtal clk.
+ *
+ *      parent: clock-controller@f00abcd {
+ *              reg = <0xf00abcd 0xabcd>;
+ *              #clock-cells = <0>;
+ *      };
+ *
+ *      clock-controller@c001 {
+ *              reg = <0xc001 0xf00d>;
+ *              clocks = <&parent>;
+ *              clock-names = "xtal";
+ *              #clock-cells = <1>;
+ *      };
+ *
+ * Returns: -ENOENT when the provider can't be found or the clk doesn't
+ * exist in the provider. -EINVAL when the name can't be found. NULL when the
+ * provider knows about the clk but it isn't provided on this system.
+ * A valid clk_core pointer when the clk can be found in the provider.
+ */
+static struct clk_core *clk_core_get(struct clk_core *core, const char *name)
+{
+	struct clk_hw *hw;
+	struct device_node *np = core->of_node;
+
+	if (!np)
+		return ERR_PTR(-ENOENT);
+
+	/* TODO: Support clkdev clk_lookups */
+	hw = of_clk_get_hw(np, -1, name);
+	if (IS_ERR_OR_NULL(hw))
+		return ERR_CAST(hw);
+
+	return hw->core;
+}
+
+static void clk_core_fill_parent_index(struct clk_core *core, u8 index)
+{
+	struct clk_parent_map *entry = &core->parents[index];
+	struct clk_core *parent = ERR_PTR(-ENOENT);
+
+	if (entry->hw) {
+		parent = entry->hw->core;
+		/*
+		 * We have a direct reference but it isn't registered yet?
+		 * Orphan it and let clk_reparent() update the orphan status
+		 * when the parent is registered.
+		 */
+		if (!parent)
+			parent = ERR_PTR(-EPROBE_DEFER);
+	} else {
+		if (entry->fw_name)
+			parent = clk_core_get(core, entry->fw_name);
+		if (IS_ERR(parent) && PTR_ERR(parent) == -ENOENT)
+			parent = clk_core_lookup(entry->name);
+	}
+
+	/* Only cache it if it's not an error */
+	if (!IS_ERR(parent))
+		entry->core = parent;
+}
+
 static struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,
 							 u8 index)
 {
-	if (!core || index >= core->num_parents)
+	if (!core || index >= core->num_parents || !core->parents)
 		return NULL;
 
-	if (!core->parents[index])
-		core->parents[index] =
-				clk_core_lookup(core->parent_names[index]);
+	if (!core->parents[index].core)
+		clk_core_fill_parent_index(core, index);
 
-	return core->parents[index];
+	return core->parents[index].core;
 }
 
 struct clk_hw *
@@ -1520,15 +1601,15 @@ static int clk_fetch_parent_index(struct clk_core *core,
 		return -EINVAL;
 
 	for (i = 0; i < core->num_parents; i++) {
-		if (core->parents[i] == parent)
+		if (core->parents[i].core == parent)
 			return i;
 
-		if (core->parents[i])
+		if (core->parents[i].core)
 			continue;
 
 		/* Fallback to comparing globally unique names */
-		if (!strcmp(parent->name, core->parent_names[i])) {
-			core->parents[i] = parent;
+		if (!strcmp(parent->name, core->parents[i].name)) {
+			core->parents[i].core = parent;
 			return i;
 		}
 	}
@@ -2294,6 +2375,7 @@ void clk_hw_reparent(struct clk_hw *hw, struct clk_hw *new_parent)
 bool clk_has_parent(struct clk *clk, struct clk *parent)
 {
 	struct clk_core *core, *parent_core;
+	int i;
 
 	/* NULL clocks should be nops, so return success if either is NULL. */
 	if (!clk || !parent)
@@ -2306,8 +2388,11 @@ bool clk_has_parent(struct clk *clk, struct clk *parent)
 	if (core->parent == parent_core)
 		return true;
 
-	return match_string(core->parent_names, core->num_parents,
-			    parent_core->name) >= 0;
+	for (i = 0; i < core->num_parents; i++)
+		if (!strcmp(core->parents[i].name, parent_core->name))
+			return true;
+
+	return false;
 }
 EXPORT_SYMBOL_GPL(clk_has_parent);
 
@@ -2890,9 +2975,9 @@ static int possible_parents_show(struct seq_file *s, void *data)
 	int i;
 
 	for (i = 0; i < core->num_parents - 1; i++)
-		seq_printf(s, "%s ", core->parent_names[i]);
+		seq_printf(s, "%s ", core->parents[i].name);
 
-	seq_printf(s, "%s\n", core->parent_names[i]);
+	seq_printf(s, "%s\n", core->parents[i].name);
 
 	return 0;
 }
@@ -3026,7 +3111,7 @@ static inline void clk_debug_unregister(struct clk_core *core)
  */
 static int __clk_core_init(struct clk_core *core)
 {
-	int i, ret;
+	int ret;
 	struct clk_core *orphan;
 	struct hlist_node *tmp2;
 	unsigned long rate;
@@ -3080,12 +3165,6 @@ static int __clk_core_init(struct clk_core *core)
 		goto out;
 	}
 
-	/* throw a WARN if any entries in parent_names are NULL */
-	for (i = 0; i < core->num_parents; i++)
-		WARN(!core->parent_names[i],
-				"%s: invalid NULL in %s's .parent_names\n",
-				__func__, core->name);
-
 	core->parent = __clk_init_parent(core);
 
 	/*
@@ -3314,10 +3393,102 @@ struct clk *clk_hw_create_clk(struct device *dev, struct clk_hw *hw,
 	return clk;
 }
 
+static int clk_cpy_name(const char **dst_p, const char *src, bool must_exist)
+{
+	const char *dst;
+
+	if (!src) {
+		if (must_exist)
+			return -EINVAL;
+		return 0;
+	}
+
+	*dst_p = dst = kstrdup_const(src, GFP_KERNEL);
+	if (!dst)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int clk_core_populate_parent_map(struct clk_core *core)
+{
+	const struct clk_init_data *init = core->hw->init;
+	u8 num_parents = init->num_parents;
+	const char * const *parent_names = init->parent_names;
+	const struct clk_hw **parent_hws = init->parent_hws;
+	const struct clk_parent_data *parent_data = init->parent_data;
+	int i, ret = 0;
+	struct clk_parent_map *parents, *parent;
+
+	if (!num_parents)
+		return 0;
+
+	/*
+	 * Avoid unnecessary string look-ups of clk_core's possible parents by
+	 * having a cache of names/clk_hw pointers to clk_core pointers.
+	 */
+	parents = kcalloc(num_parents, sizeof(*parents), GFP_KERNEL);
+	core->parents = parents;
+	if (!parents)
+		return -ENOMEM;
+
+	/* Copy everything over because it might be __initdata */
+	for (i = 0, parent = parents; i < num_parents; i++, parent++) {
+		if (parent_names) {
+			/* throw a WARN if any entries are NULL */
+			WARN(!parent_names[i],
+				"%s: invalid NULL in %s's .parent_names\n",
+				__func__, core->name);
+			ret = clk_cpy_name(&parent->name, parent_names[i],
+					   true);
+		} else if (parent_data) {
+			parent->hw = parent_data[i].hw;
+			ret = clk_cpy_name(&parent->fw_name,
+					   parent_data[i].fw_name, false);
+			if (!ret)
+				ret = clk_cpy_name(&parent->name,
+						   parent_data[i].name,
+						   false);
+		} else if (parent_hws) {
+			parent->hw = parent_hws[i];
+		} else {
+			ret = -EINVAL;
+			WARN(1, "Must specify parents if num_parents > 0\n");
+		}
+
+		if (ret) {
+			do {
+				kfree_const(parents[i].name);
+				kfree_const(parents[i].fw_name);
+			} while (--i >= 0);
+			kfree(parents);
+
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void clk_core_free_parent_map(struct clk_core *core)
+{
+	int i = core->num_parents;
+
+	if (!core->num_parents)
+		return;
+
+	while (--i >= 0) {
+		kfree_const(core->parents[i].name);
+		kfree_const(core->parents[i].fw_name);
+	}
+
+	kfree(core->parents);
+}
+
 static struct clk *
 __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 {
-	int i, ret;
+	int ret;
 	struct clk_core *core;
 
 	core = kzalloc(sizeof(*core), GFP_KERNEL);
@@ -3351,33 +3522,9 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 	core->max_rate = ULONG_MAX;
 	hw->core = core;
 
-	/* allocate local copy in case parent_names is __initdata */
-	core->parent_names = kcalloc(core->num_parents, sizeof(char *),
-					GFP_KERNEL);
-
-	if (!core->parent_names) {
-		ret = -ENOMEM;
-		goto fail_parent_names;
-	}
-
-
-	/* copy each string name in case parent_names is __initdata */
-	for (i = 0; i < core->num_parents; i++) {
-		core->parent_names[i] = kstrdup_const(hw->init->parent_names[i],
-						GFP_KERNEL);
-		if (!core->parent_names[i]) {
-			ret = -ENOMEM;
-			goto fail_parent_names_copy;
-		}
-	}
-
-	/* avoid unnecessary string look-ups of clk_core's possible parents. */
-	core->parents = kcalloc(core->num_parents, sizeof(*core->parents),
-				GFP_KERNEL);
-	if (!core->parents) {
-		ret = -ENOMEM;
+	ret = clk_core_populate_parent_map(core);
+	if (ret)
 		goto fail_parents;
-	};
 
 	INIT_HLIST_HEAD(&core->clks);
 
@@ -3388,7 +3535,7 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 	hw->clk = alloc_clk(core, NULL, NULL);
 	if (IS_ERR(hw->clk)) {
 		ret = PTR_ERR(hw->clk);
-		goto fail_parents;
+		goto fail_create_clk;
 	}
 
 	clk_core_link_consumer(hw->core, hw->clk);
@@ -3404,13 +3551,9 @@ __clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 	free_clk(hw->clk);
 	hw->clk = NULL;
 
+fail_create_clk:
+	clk_core_free_parent_map(core);
 fail_parents:
-	kfree(core->parents);
-fail_parent_names_copy:
-	while (--i >= 0)
-		kfree_const(core->parent_names[i]);
-	kfree(core->parent_names);
-fail_parent_names:
 fail_ops:
 	kfree_const(core->name);
 fail_name:
@@ -3473,15 +3616,10 @@ EXPORT_SYMBOL_GPL(of_clk_hw_register);
 static void __clk_release(struct kref *ref)
 {
 	struct clk_core *core = container_of(ref, struct clk_core, ref);
-	int i = core->num_parents;
 
 	lockdep_assert_held(&prepare_lock);
 
-	kfree(core->parents);
-	while (--i >= 0)
-		kfree_const(core->parent_names[i]);
-
-	kfree(core->parent_names);
+	clk_core_free_parent_map(core);
 	kfree_const(core->name);
 	kfree(core);
 }

commit 89a5ddcc799d5d7dbcf6197b79dafc1dc9f997f5
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:46 2019 -0700

    clk: Add of_clk_hw_register() API for early clk drivers
    
    In some circumstances drivers register clks early and don't have access
    to a struct device because the device model isn't initialized yet. Add
    an API to let drivers register clks associated with a struct device_node
    so that these drivers can participate in getting parent clks through DT.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Rob Herring <robh@kernel.org>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d27775a73e67..ffa63ddcd408 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -45,6 +45,7 @@ struct clk_core {
 	struct clk_hw		*hw;
 	struct module		*owner;
 	struct device		*dev;
+	struct device_node	*of_node;
 	struct clk_core		*parent;
 	const char		**parent_names;
 	struct clk_core		**parents;
@@ -3313,7 +3314,8 @@ struct clk *clk_hw_create_clk(struct device *dev, struct clk_hw *hw,
 	return clk;
 }
 
-static struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
+static struct clk *
+__clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)
 {
 	int i, ret;
 	struct clk_core *core;
@@ -3339,6 +3341,7 @@ static struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
 	if (dev && pm_runtime_enabled(dev))
 		core->rpm_enabled = true;
 	core->dev = dev;
+	core->of_node = np;
 	if (dev && dev->driver)
 		core->owner = dev->driver->owner;
 	core->hw = hw;
@@ -3429,7 +3432,7 @@ static struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
  */
 struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 {
-	return __clk_register(dev, hw);
+	return __clk_register(dev, dev_of_node(dev), hw);
 }
 EXPORT_SYMBOL_GPL(clk_register);
 
@@ -3445,10 +3448,27 @@ EXPORT_SYMBOL_GPL(clk_register);
  */
 int clk_hw_register(struct device *dev, struct clk_hw *hw)
 {
-	return PTR_ERR_OR_ZERO(__clk_register(dev, hw));
+	return PTR_ERR_OR_ZERO(__clk_register(dev, dev_of_node(dev), hw));
 }
 EXPORT_SYMBOL_GPL(clk_hw_register);
 
+/*
+ * of_clk_hw_register - register a clk_hw and return an error code
+ * @node: device_node of device that is registering this clock
+ * @hw: link to hardware-specific clock data
+ *
+ * of_clk_hw_register() is the primary interface for populating the clock tree
+ * with new clock nodes when a struct device is not available, but a struct
+ * device_node is. It returns an integer equal to zero indicating success or
+ * less than zero indicating failure. Drivers must test for an error code after
+ * calling of_clk_hw_register().
+ */
+int of_clk_hw_register(struct device_node *node, struct clk_hw *hw)
+{
+	return PTR_ERR_OR_ZERO(__clk_register(NULL, node, hw));
+}
+EXPORT_SYMBOL_GPL(of_clk_hw_register);
+
 /* Free memory allocated for a clock. */
 static void __clk_release(struct kref *ref)
 {

commit fceaa7d8004339820a0026d163b20becc796d1af
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:44 2019 -0700

    clk: Prepare for clk registration API that uses DT nodes
    
    Split out the body of the clk_register() function so it can be shared
    between the different types of registration APIs (DT, device).
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Rob Herring <robh@kernel.org>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 96053a96fe2f..d27775a73e67 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3313,18 +3313,7 @@ struct clk *clk_hw_create_clk(struct device *dev, struct clk_hw *hw,
 	return clk;
 }
 
-/**
- * clk_register - allocate a new clock, register it and return an opaque cookie
- * @dev: device that is registering this clock
- * @hw: link to hardware-specific clock data
- *
- * clk_register is the primary interface for populating the clock tree with new
- * clock nodes.  It returns a pointer to the newly allocated struct clk which
- * cannot be dereferenced by driver code but may be used in conjunction with the
- * rest of the clock API.  In the event of an error clk_register will return an
- * error code; drivers must test for an error code after calling clk_register.
- */
-struct clk *clk_register(struct device *dev, struct clk_hw *hw)
+static struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
 {
 	int i, ret;
 	struct clk_core *core;
@@ -3426,6 +3415,22 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 fail_out:
 	return ERR_PTR(ret);
 }
+
+/**
+ * clk_register - allocate a new clock, register it and return an opaque cookie
+ * @dev: device that is registering this clock
+ * @hw: link to hardware-specific clock data
+ *
+ * clk_register is the primary interface for populating the clock tree with new
+ * clock nodes.  It returns a pointer to the newly allocated struct clk which
+ * cannot be dereferenced by driver code but may be used in conjunction with the
+ * rest of the clock API.  In the event of an error clk_register will return an
+ * error code; drivers must test for an error code after calling clk_register.
+ */
+struct clk *clk_register(struct device *dev, struct clk_hw *hw)
+{
+	return __clk_register(dev, hw);
+}
 EXPORT_SYMBOL_GPL(clk_register);
 
 /**
@@ -3440,7 +3445,7 @@ EXPORT_SYMBOL_GPL(clk_register);
  */
 int clk_hw_register(struct device *dev, struct clk_hw *hw)
 {
-	return PTR_ERR_OR_ZERO(clk_register(dev, hw));
+	return PTR_ERR_OR_ZERO(__clk_register(dev, hw));
 }
 EXPORT_SYMBOL_GPL(clk_hw_register);
 

commit 65cf20ad4f54d7feb87cda0369d6560e9789f0d5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Mar 6 16:18:28 2019 +0900

    clk: fixup default index for of_clk_get_by_name()
    
    of_clk_get_by_name() is using -1 for __of_clk_get() index.  It will go
    to of_parse_clkspec(), and be used for of_parse_phandle_with_args().
    Here, if user doesn't specify clock name (= of_clk_get_by_name(np,
    NULL)), this index is still -1, and of_parse_phandle_with_args() will
    return -EINVAL (This index will be updated if if it had clock name).
    clk_get_by_name(np, NULL) should work, then, default index should be 0
    instead of -1. This patch fixes it.
    
    Fixes: 4472287a3b2f ("clk: Introduce of_clk_get_hw_from_clkspec()")
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 14cbf239d9b2..96053a96fe2f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -4213,7 +4213,7 @@ struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
 	if (!np)
 		return ERR_PTR(-ENOENT);
 
-	return __of_clk_get(np, -1, np->full_name, name);
+	return __of_clk_get(np, 0, np->full_name, name);
 }
 EXPORT_SYMBOL(of_clk_get_by_name);
 

commit 5dc7e84268f53f08251abe1d388a019f55ddb077
Merge: fea0b0850aad cf13f2896807
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Mar 8 10:35:01 2019 -0800

    Merge branch 'clk-parent-rewrite' (early part) into clk-next
    
    * 'clk-parent-rewrite' (early part):
      clk: Move of_clk_*() APIs into clk.c from clkdev.c
      clk: Inform the core about consumer devices
      clk: Introduce of_clk_get_hw_from_clkspec()
      clk: core: clarify the check for runtime PM
      clk: Combine __clk_get() and __clk_create_clk()

commit 3f8e7e7247e0627b4f1d758d793041fe3032b6e3
Merge: 7e2570031a1a 60b8f0ddf1a9 d3236214e7de da392a5ab411 a9ca321716c8 df446f7e6ec0
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Mar 8 10:27:21 2019 -0800

    Merge branches 'clk-optional', 'clk-devm-clkdev-register', 'clk-allwinner', 'clk-meson' and 'clk-renesas' into clk-next
    
     - Add a {devm_}clk_get_optional() API
     - Add devm_clk_hw_register_clkdev() API to manage clkdev lookups
    
    * clk-optional:
      clk: Add (devm_)clk_get_optional() functions
      clk: Add comment about __of_clk_get_by_name() error values
    
    * clk-devm-clkdev-register:
      clk: clk-st: avoid clkdev lookup leak at remove
      clk: clk-max77686: Clean clkdev lookup leak and use devm
      clkdev: add managed clkdev lookup registration
    
    * clk-allwinner:
      clk: sunxi-ng: sun8i-a23: Enable PLL-MIPI LDOs when ungating it
    
    * clk-meson: (22 commits)
      clk: meson: meson8b: fix the naming of the APB clocks
      dt-bindings: clock: meson8b: add APB clock definition
      clk: meson: Add G12A AO Clock + Reset Controller
      dt-bindings: clk: add G12A AO Clock and Reset Bindings
      clk: meson: factorise meson64 peripheral clock controller drivers
      clk: meson: g12a: add peripheral clock controller
      dt-bindings: clk: meson: add g12a periph clock controller bindings
      clk: meson: pll: update driver for the g12a
      clk: meson: rework and clean drivers dependencies
      clk: meson: axg-audio does not require syscon
      clk: meson: use CONFIG_ARCH_MESON to enter meson clk directory
      clk: export some clk_hw function symbols for module drivers
      clk: meson: ao-clkc: claim clock controller input clocks from DT
      clk: meson: axg: claim clock controller input clock from DT
      clk: meson: gxbb: claim clock controller input clock from DT
      clk: meson: meson8b: add the GPU clock tree
      clk: meson: meson8b: use a separate clock table for Meson8
      clk: meson: axg-ao: add 32k generation subtree
      clk: meson: gxbb-ao: replace cec-32k with the dual divider
      clk: meson: add dual divider clock driver
      ...
    
    * clk-renesas:
      clk: renesas: r8a774a1: Fix LAST_DT_CORE_CLK
      clk: renesas: r8a774c0: Fix LAST_DT_CORE_CLK
      clk: renesas: r8a774c0: Add TMU clock
      clk: renesas: r8a77980: Add RPC clocks
      clk: renesas: rcar-gen3: Add RPC clocks
      clk: renesas: rcar-gen3: Add spinlock
      clk: renesas: rcar-gen3: Factor out cpg_reg_modify()
      clk: renesas: r8a774c0: Correct parent clock of DU
      clk: renesas: r8a774a1: Add missing CANFD clock
      clk: renesas: r8a774c0: Add missing CANFD clock

commit cf13f2896807d516df79d118d1e82f9d2db3c336
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Dec 19 15:09:14 2018 -0800

    clk: Move of_clk_*() APIs into clk.c from clkdev.c
    
    The API between clk.c and clkdev.c is purely getting the clk_hw
    structure (or the struct clk if it's not CCF) and then turning that
    struct clk_hw pointer into a struct clk pointer via clk_hw_create_clk().
    There's no need to complicate clkdev.c with these DT parsing details
    that are only relevant to the common clk framework. Move the DT parsing
    logic into the core framework and just expose the APIs to get a clk_hw
    pointer and convert it.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8244ef2ba977..937b8d092d17 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -4068,8 +4068,8 @@ void devm_of_clk_del_provider(struct device *dev)
 }
 EXPORT_SYMBOL(devm_of_clk_del_provider);
 
-int of_parse_clkspec(const struct device_node *np, int index, const char *name,
-		     struct of_phandle_args *out_args)
+static int of_parse_clkspec(const struct device_node *np, int index,
+			    const char *name, struct of_phandle_args *out_args)
 {
 	int ret = -ENOENT;
 
@@ -4119,7 +4119,8 @@ __of_clk_get_hw_from_provider(struct of_clk_provider *provider,
 	return __clk_get_hw(clk);
 }
 
-struct clk_hw *of_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec)
+static struct clk_hw *
+of_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec)
 {
 	struct of_clk_provider *provider;
 	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
@@ -4156,6 +4157,56 @@ struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 }
 EXPORT_SYMBOL_GPL(of_clk_get_from_provider);
 
+struct clk_hw *of_clk_get_hw(struct device_node *np, int index,
+			     const char *con_id)
+{
+	int ret;
+	struct clk_hw *hw;
+	struct of_phandle_args clkspec;
+
+	ret = of_parse_clkspec(np, index, con_id, &clkspec);
+	if (ret)
+		return ERR_PTR(ret);
+
+	hw = of_clk_get_hw_from_clkspec(&clkspec);
+	of_node_put(clkspec.np);
+
+	return hw;
+}
+
+static struct clk *__of_clk_get(struct device_node *np,
+				int index, const char *dev_id,
+				const char *con_id)
+{
+	struct clk_hw *hw = of_clk_get_hw(np, index, con_id);
+
+	return clk_hw_create_clk(NULL, hw, dev_id, con_id);
+}
+
+struct clk *of_clk_get(struct device_node *np, int index)
+{
+	return __of_clk_get(np, index, np->full_name, NULL);
+}
+EXPORT_SYMBOL(of_clk_get);
+
+/**
+ * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node
+ * @np: pointer to clock consumer node
+ * @name: name of consumer's clock input, or NULL for the first clock reference
+ *
+ * This function parses the clocks and clock-names properties,
+ * and uses them to look up the struct clk from the registered list of clock
+ * providers.
+ */
+struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
+{
+	if (!np)
+		return ERR_PTR(-ENOENT);
+
+	return __of_clk_get(np, -1, np->full_name, name);
+}
+EXPORT_SYMBOL(of_clk_get_by_name);
+
 /**
  * of_clk_get_parent_count() - Count the number of clocks a device node has
  * @np: device node to count

commit efa850487a6b6742699e3352d8562f5aba531ae7
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 08:34:16 2018 -0800

    clk: Inform the core about consumer devices
    
    We'd like to have a pointer to the device that's consuming a particular
    clk in the clk framework so we can link the consumer to the clk provider
    with a PM device link. Add a device argument to clk_hw_create_clk() for
    this so it can be used in subsequent patches to add and remove the link.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 04288063847b..8244ef2ba977 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -82,6 +82,7 @@ struct clk_core {
 
 struct clk {
 	struct clk_core	*core;
+	struct device *dev;
 	const char *dev_id;
 	const char *con_id;
 	unsigned long min_rate;
@@ -3273,6 +3274,7 @@ static void free_clk(struct clk *clk)
 /**
  * clk_hw_create_clk: Allocate and link a clk consumer to a clk_core given
  * a clk_hw
+ * @dev: clk consumer device
  * @hw: clk_hw associated with the clk being consumed
  * @dev_id: string describing device name
  * @con_id: connection ID string on device
@@ -3281,7 +3283,7 @@ static void free_clk(struct clk *clk)
  * consumers. It connects a consumer to the clk_core and clk_hw structures
  * used by the framework and clk provider respectively.
  */
-struct clk *clk_hw_create_clk(struct clk_hw *hw,
+struct clk *clk_hw_create_clk(struct device *dev, struct clk_hw *hw,
 			      const char *dev_id, const char *con_id)
 {
 	struct clk *clk;
@@ -3295,6 +3297,7 @@ struct clk *clk_hw_create_clk(struct clk_hw *hw,
 	clk = alloc_clk(core, dev_id, con_id);
 	if (IS_ERR(clk))
 		return clk;
+	clk->dev = dev;
 
 	if (!try_module_get(core->owner)) {
 		free_clk(clk);
@@ -4149,7 +4152,7 @@ struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 {
 	struct clk_hw *hw = of_clk_get_hw_from_clkspec(clkspec);
 
-	return clk_hw_create_clk(hw, NULL, __func__);
+	return clk_hw_create_clk(NULL, hw, NULL, __func__);
 }
 EXPORT_SYMBOL_GPL(of_clk_get_from_provider);
 

commit 4472287a3b2f52f4aa53f294ccb74392dde4e07d
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Dec 19 10:59:55 2018 -0800

    clk: Introduce of_clk_get_hw_from_clkspec()
    
    We want to get struct clk_hw pointers from a DT clk specifier (i.e. a
    clocks property) so that we can find parent clks without searching for
    globally unique clk names. This should save time by avoiding the global
    string search for clks that are external to the clock controller
    providing the clk and let us move away from string comparisons in
    general.
    
    Introduce of_clk_get_hw_from_clkspec() which is largely the DT parsing
    part of finding clks implemented in clkdev.c and have that return a
    clk_hw pointer instead of converting that into a clk pointer. This lets
    us push up the clk pointer creation to the caller in clk_get() and
    avoids the need to push the dev_id and con_id throughout the DT parsing
    code.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d46e8b9b9c9f..04288063847b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -4065,6 +4065,42 @@ void devm_of_clk_del_provider(struct device *dev)
 }
 EXPORT_SYMBOL(devm_of_clk_del_provider);
 
+int of_parse_clkspec(const struct device_node *np, int index, const char *name,
+		     struct of_phandle_args *out_args)
+{
+	int ret = -ENOENT;
+
+	/* Walk up the tree of devices looking for a clock property that matches */
+	while (np) {
+		/*
+		 * For named clocks, first look up the name in the
+		 * "clock-names" property.  If it cannot be found, then index
+		 * will be an error code and of_parse_phandle_with_args() will
+		 * return -EINVAL.
+		 */
+		if (name)
+			index = of_property_match_string(np, "clock-names", name);
+		ret = of_parse_phandle_with_args(np, "clocks", "#clock-cells",
+						 index, out_args);
+		if (!ret)
+			break;
+		if (name && index >= 0)
+			break;
+
+		/*
+		 * No matching clock found on this node.  If the parent node
+		 * has a "clock-ranges" property, then we can try one of its
+		 * clocks.
+		 */
+		np = np->parent;
+		if (np && !of_get_property(np, "clock-ranges", NULL))
+			break;
+		index = 0;
+	}
+
+	return ret;
+}
+
 static struct clk_hw *
 __of_clk_get_hw_from_provider(struct of_clk_provider *provider,
 			      struct of_phandle_args *clkspec)
@@ -4080,8 +4116,7 @@ __of_clk_get_hw_from_provider(struct of_clk_provider *provider,
 	return __clk_get_hw(clk);
 }
 
-struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
-				       const char *dev_id, const char *con_id)
+struct clk_hw *of_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec)
 {
 	struct of_clk_provider *provider;
 	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
@@ -4089,7 +4124,6 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 	if (!clkspec)
 		return ERR_PTR(-EINVAL);
 
-	/* Check if we have such a provider in our array */
 	mutex_lock(&of_clk_mutex);
 	list_for_each_entry(provider, &of_clk_providers, link) {
 		if (provider->node == clkspec->np) {
@@ -4100,7 +4134,7 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 	}
 	mutex_unlock(&of_clk_mutex);
 
-	return clk_hw_create_clk(hw, dev_id, con_id);
+	return hw;
 }
 
 /**
@@ -4113,7 +4147,9 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
  */
 struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 {
-	return __of_clk_get_from_provider(clkspec, NULL, __func__);
+	struct clk_hw *hw = of_clk_get_hw_from_clkspec(clkspec);
+
+	return clk_hw_create_clk(hw, NULL, __func__);
 }
 EXPORT_SYMBOL_GPL(of_clk_get_from_provider);
 

commit 2447883934a03c80a85d92cd313ea1d10e330158
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Tue Dec 4 20:24:37 2018 +0100

    clk: core: clarify the check for runtime PM
    
    Currently, the core->dev entry is populated only if runtime PM is
    enabled. Doing so prevents accessing the device structure in any
    case.
    
    Keep the same logic but instead of using the presence of core->dev as
    the only condition, also check the status of
    pm_runtime_enabled(). Then, we can set the core->dev pointer at any
    time as long as a device structure is available.
    
    This change will help supporting device links in the clock subsystem.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    [sboyd@kernel.org: Change to a boolean flag]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fef937ea44f4..d46e8b9b9c9f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -57,6 +57,7 @@ struct clk_core {
 	struct clk_core		*new_child;
 	unsigned long		flags;
 	bool			orphan;
+	bool			rpm_enabled;
 	unsigned int		enable_count;
 	unsigned int		prepare_count;
 	unsigned int		protect_count;
@@ -92,9 +93,9 @@ struct clk {
 /***           runtime pm          ***/
 static int clk_pm_runtime_get(struct clk_core *core)
 {
-	int ret = 0;
+	int ret;
 
-	if (!core->dev)
+	if (!core->rpm_enabled)
 		return 0;
 
 	ret = pm_runtime_get_sync(core->dev);
@@ -103,7 +104,7 @@ static int clk_pm_runtime_get(struct clk_core *core)
 
 static void clk_pm_runtime_put(struct clk_core *core)
 {
-	if (!core->dev)
+	if (!core->rpm_enabled)
 		return;
 
 	pm_runtime_put_sync(core->dev);
@@ -223,7 +224,7 @@ static bool clk_core_is_enabled(struct clk_core *core)
 	 * taking enable spinlock, but the below check is needed if one tries
 	 * to call it from other places.
 	 */
-	if (core->dev) {
+	if (core->rpm_enabled) {
 		pm_runtime_get_noresume(core->dev);
 		if (!pm_runtime_active(core->dev)) {
 			ret = false;
@@ -233,7 +234,7 @@ static bool clk_core_is_enabled(struct clk_core *core)
 
 	ret = core->ops->is_enabled(core->hw);
 done:
-	if (core->dev)
+	if (core->rpm_enabled)
 		pm_runtime_put(core->dev);
 
 	return ret;
@@ -3341,7 +3342,8 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	core->ops = hw->init->ops;
 
 	if (dev && pm_runtime_enabled(dev))
-		core->dev = dev;
+		core->rpm_enabled = true;
+	core->dev = dev;
 	if (dev && dev->driver)
 		core->owner = dev->driver->owner;
 	core->hw = hw;

commit 1df4046a93e086f77d244ea47c21591b4acad3e2
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 08:32:04 2018 -0800

    clk: Combine __clk_get() and __clk_create_clk()
    
    The __clk_get() function is practically a private clk implementation
    detail now. No architecture defines it, and given that new code should
    be using the common clk framework there isn't a need for it to keep
    existing just to serve clkdev purposes. Let's fold it into the
    __clk_create_clk() function and make that a little more generic by
    renaming it to clk_hw_create_clk(). This will allow the framework to
    create a struct clk handle to a particular clk_hw pointer and link it up
    as a consumer wherever that's needed.
    
    Doing this also lets us get rid of the __clk_free_clk() API that had to
    be kept in sync with __clk_put(). Splitting that API up into the "link
    and unlink from consumer list" phase and "free the clk pointer" phase
    allows us to reuse that logic in a couple places, simplifying the code.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d2477a5058ac..fef937ea44f4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3209,42 +3209,103 @@ static int __clk_core_init(struct clk_core *core)
 	return ret;
 }
 
-struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
+/**
+ * clk_core_link_consumer - Add a clk consumer to the list of consumers in a clk_core
+ * @core: clk to add consumer to
+ * @clk: consumer to link to a clk
+ */
+static void clk_core_link_consumer(struct clk_core *core, struct clk *clk)
+{
+	clk_prepare_lock();
+	hlist_add_head(&clk->clks_node, &core->clks);
+	clk_prepare_unlock();
+}
+
+/**
+ * clk_core_unlink_consumer - Remove a clk consumer from the list of consumers in a clk_core
+ * @clk: consumer to unlink
+ */
+static void clk_core_unlink_consumer(struct clk *clk)
+{
+	lockdep_assert_held(&prepare_lock);
+	hlist_del(&clk->clks_node);
+}
+
+/**
+ * alloc_clk - Allocate a clk consumer, but leave it unlinked to the clk_core
+ * @core: clk to allocate a consumer for
+ * @dev_id: string describing device name
+ * @con_id: connection ID string on device
+ *
+ * Returns: clk consumer left unlinked from the consumer list
+ */
+static struct clk *alloc_clk(struct clk_core *core, const char *dev_id,
 			     const char *con_id)
 {
 	struct clk *clk;
 
-	/* This is to allow this function to be chained to others */
-	if (IS_ERR_OR_NULL(hw))
-		return ERR_CAST(hw);
-
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 	if (!clk)
 		return ERR_PTR(-ENOMEM);
 
-	clk->core = hw->core;
+	clk->core = core;
 	clk->dev_id = dev_id;
 	clk->con_id = kstrdup_const(con_id, GFP_KERNEL);
 	clk->max_rate = ULONG_MAX;
 
-	clk_prepare_lock();
-	hlist_add_head(&clk->clks_node, &hw->core->clks);
-	clk_prepare_unlock();
-
 	return clk;
 }
 
-/* keep in sync with __clk_put */
-void __clk_free_clk(struct clk *clk)
+/**
+ * free_clk - Free a clk consumer
+ * @clk: clk consumer to free
+ *
+ * Note, this assumes the clk has been unlinked from the clk_core consumer
+ * list.
+ */
+static void free_clk(struct clk *clk)
 {
-	clk_prepare_lock();
-	hlist_del(&clk->clks_node);
-	clk_prepare_unlock();
-
 	kfree_const(clk->con_id);
 	kfree(clk);
 }
 
+/**
+ * clk_hw_create_clk: Allocate and link a clk consumer to a clk_core given
+ * a clk_hw
+ * @hw: clk_hw associated with the clk being consumed
+ * @dev_id: string describing device name
+ * @con_id: connection ID string on device
+ *
+ * This is the main function used to create a clk pointer for use by clk
+ * consumers. It connects a consumer to the clk_core and clk_hw structures
+ * used by the framework and clk provider respectively.
+ */
+struct clk *clk_hw_create_clk(struct clk_hw *hw,
+			      const char *dev_id, const char *con_id)
+{
+	struct clk *clk;
+	struct clk_core *core;
+
+	/* This is to allow this function to be chained to others */
+	if (IS_ERR_OR_NULL(hw))
+		return ERR_CAST(hw);
+
+	core = hw->core;
+	clk = alloc_clk(core, dev_id, con_id);
+	if (IS_ERR(clk))
+		return clk;
+
+	if (!try_module_get(core->owner)) {
+		free_clk(clk);
+		return ERR_PTR(-ENOENT);
+	}
+
+	kref_get(&core->ref);
+	clk_core_link_consumer(core, clk);
+
+	return clk;
+}
+
 /**
  * clk_register - allocate a new clock, register it and return an opaque cookie
  * @dev: device that is registering this clock
@@ -3320,17 +3381,27 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 	INIT_HLIST_HEAD(&core->clks);
 
-	hw->clk = __clk_create_clk(hw, NULL, NULL);
+	/*
+	 * Don't call clk_hw_create_clk() here because that would pin the
+	 * provider module to itself and prevent it from ever being removed.
+	 */
+	hw->clk = alloc_clk(core, NULL, NULL);
 	if (IS_ERR(hw->clk)) {
 		ret = PTR_ERR(hw->clk);
 		goto fail_parents;
 	}
 
+	clk_core_link_consumer(hw->core, hw->clk);
+
 	ret = __clk_core_init(core);
 	if (!ret)
 		return hw->clk;
 
-	__clk_free_clk(hw->clk);
+	clk_prepare_lock();
+	clk_core_unlink_consumer(hw->clk);
+	clk_prepare_unlock();
+
+	free_clk(hw->clk);
 	hw->clk = NULL;
 
 fail_parents:
@@ -3601,20 +3672,7 @@ EXPORT_SYMBOL_GPL(devm_clk_hw_unregister);
 /*
  * clkdev helpers
  */
-int __clk_get(struct clk *clk)
-{
-	struct clk_core *core = !clk ? NULL : clk->core;
-
-	if (core) {
-		if (!try_module_get(core->owner))
-			return 0;
-
-		kref_get(&core->ref);
-	}
-	return 1;
-}
 
-/* keep in sync with __clk_free_clk */
 void __clk_put(struct clk *clk)
 {
 	struct module *owner;
@@ -3648,8 +3706,7 @@ void __clk_put(struct clk *clk)
 
 	module_put(owner);
 
-	kfree_const(clk->con_id);
-	kfree(clk);
+	free_clk(clk);
 }
 
 /***        clk rate change notifiers        ***/
@@ -4025,8 +4082,7 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 				       const char *dev_id, const char *con_id)
 {
 	struct of_clk_provider *provider;
-	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
-	struct clk_hw *hw;
+	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
 
 	if (!clkspec)
 		return ERR_PTR(-EINVAL);
@@ -4036,21 +4092,13 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 	list_for_each_entry(provider, &of_clk_providers, link) {
 		if (provider->node == clkspec->np) {
 			hw = __of_clk_get_hw_from_provider(provider, clkspec);
-			clk = __clk_create_clk(hw, dev_id, con_id);
-		}
-
-		if (!IS_ERR(clk)) {
-			if (!__clk_get(clk)) {
-				__clk_free_clk(clk);
-				clk = ERR_PTR(-ENOENT);
-			}
-
-			break;
+			if (!IS_ERR(hw))
+				break;
 		}
 	}
 	mutex_unlock(&of_clk_mutex);
 
-	return clk;
+	return clk_hw_create_clk(hw, dev_id, con_id);
 }
 
 /**

commit 12aa377bf80cb3a38053dba70eaa7e39975849b2
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Feb 1 13:58:38 2019 +0100

    clk: export some clk_hw function symbols for module drivers
    
    clk-provider.h provides clk_hw_is_prepared(), clk_hw_is_enabled() and
    clk_hw_is_prepared() but these symbols are not exported for the
    modules which prevents a clock driver using them to be compiled as
    a module. Export them to fix the problem.
    
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://lkml.kernel.org/r/20190201125841.26785-2-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 75d13c0eff12..5558af12f9db 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -394,16 +394,19 @@ bool clk_hw_is_prepared(const struct clk_hw *hw)
 {
 	return clk_core_is_prepared(hw->core);
 }
+EXPORT_SYMBOL_GPL(clk_hw_is_prepared);
 
 bool clk_hw_rate_is_protected(const struct clk_hw *hw)
 {
 	return clk_core_rate_is_protected(hw->core);
 }
+EXPORT_SYMBOL_GPL(clk_hw_rate_is_protected);
 
 bool clk_hw_is_enabled(const struct clk_hw *hw)
 {
 	return clk_core_is_enabled(hw->core);
 }
+EXPORT_SYMBOL_GPL(clk_hw_is_enabled);
 
 bool __clk_is_enabled(struct clk *clk)
 {

commit 73d4f945f6eacc8f4fadd61020faea3c6dc602dc
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Feb 1 15:39:50 2019 -0800

    clk: Document and simplify clk_core_get_rate_nolock()
    
    This function uses a few gotos and doesn't explain why parents and
    numbers of parents are being checked before returning different values
    for the clk's rate. Document and simplify this function somewhat to make
    this better.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c9860074899b..79d0466cd180 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -345,23 +345,18 @@ unsigned int __clk_get_enable_count(struct clk *clk)
 
 static unsigned long clk_core_get_rate_nolock(struct clk_core *core)
 {
-	unsigned long ret;
-
-	if (!core) {
-		ret = 0;
-		goto out;
-	}
-
-	ret = core->rate;
-
-	if (!core->num_parents)
-		goto out;
+	if (!core)
+		return 0;
 
-	if (!core->parent)
-		ret = 0;
+	if (!core->num_parents || core->parent)
+		return core->rate;
 
-out:
-	return ret;
+	/*
+	 * Clk must have a parent because num_parents > 0 but the parent isn't
+	 * known yet. Best to return 0 as the rate of this clk until we can
+	 * properly recalc the rate based on the parent's rate.
+	 */
+	return 0;
 }
 
 unsigned long clk_hw_get_rate(const struct clk_hw *hw)

commit 777c1a40a34f183640b33ff142c5ab3ef1748974
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 13:24:50 2018 -0800

    clk: Document __clk_mux_determine_rate()
    
    It had some documentation, but not kerneldoc style so it wasn't getting
    picked up. Add some docs so scripts can pick this function out.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 592e315f7cfd..c9860074899b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -519,9 +519,15 @@ void clk_hw_set_rate_range(struct clk_hw *hw, unsigned long min_rate,
 EXPORT_SYMBOL_GPL(clk_hw_set_rate_range);
 
 /*
+ * __clk_mux_determine_rate - clk_ops::determine_rate implementation for a mux type clk
+ * @hw: mux type clk to determine rate on
+ * @req: rate request, also used to return preferred parent and frequencies
+ *
  * Helper for finding best parent to provide a given frequency. This can be used
  * directly as a determine_rate callback (e.g. for a mux), or from a more
  * complex clock that may combine a mux with other operations.
+ *
+ * Returns: 0 on success, -EERROR value on error
  */
 int __clk_mux_determine_rate(struct clk_hw *hw,
 			     struct clk_rate_request *req)

commit 9fe9b7ab4d050eaf646728752b320043c59dc214
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 10:49:40 2018 -0800

    clk: Document deprecated things
    
    We don't want driver authors to use the struct clk based registration
    and provider APIs. Instead, they should use the clk_hw based APIs. Add
    some notes in the kerneldoc to this effect.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 75d13c0eff12..592e315f7cfd 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3240,8 +3240,10 @@ void __clk_free_clk(struct clk *clk)
  * @dev: device that is registering this clock
  * @hw: link to hardware-specific clock data
  *
- * clk_register is the primary interface for populating the clock tree with new
- * clock nodes.  It returns a pointer to the newly allocated struct clk which
+ * clk_register is the *deprecated* interface for populating the clock tree with
+ * new clock nodes. Use clk_hw_register() instead.
+ *
+ * Returns: a pointer to the newly allocated struct clk which
  * cannot be dereferenced by driver code but may be used in conjunction with the
  * rest of the clock API.  In the event of an error clk_register will return an
  * error code; drivers must test for an error code after calling clk_register.
@@ -3486,9 +3488,10 @@ static void devm_clk_hw_release(struct device *dev, void *res)
  * @dev: device that is registering this clock
  * @hw: link to hardware-specific clock data
  *
- * Managed clk_register(). Clocks returned from this function are
- * automatically clk_unregister()ed on driver detach. See clk_register() for
- * more information.
+ * Managed clk_register(). This function is *deprecated*, use devm_clk_hw_register() instead.
+ *
+ * Clocks returned from this function are automatically clk_unregister()ed on
+ * driver detach. See clk_register() for more information.
  */
 struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw)
 {
@@ -3820,6 +3823,8 @@ EXPORT_SYMBOL_GPL(of_clk_hw_onecell_get);
  * @np: Device node pointer associated with clock provider
  * @clk_src_get: callback for decoding clock
  * @data: context pointer for @clk_src_get callback.
+ *
+ * This function is *deprecated*. Use of_clk_add_hw_provider() instead.
  */
 int of_clk_add_provider(struct device_node *np,
 			struct clk *(*clk_src_get)(struct of_phandle_args *clkspec,

commit ede77858473ae4cab6f8f147efcaa76989761535
Author: Derek Basehore <dbasehore@chromium.org>
Date:   Thu Dec 20 16:31:00 2018 -0800

    clk: Remove global clk traversal on fetch parent index
    
    It's not required to traverse the entire clk tree when the parents array
    contains a NULL value. We already have the parent clk_core pointer, so
    we can just compare the parent->name and parent_names[i] pointers.
    
    This can be a substantial power improvement in cases where the parent
    clk isn't known and that clk is never registered, because a mux having
    an unregistered parent name may traverse the clk tree on every
    clk_set_rate() call in clk_mux_determine_rate_flags(). This can happen
    hundreds of times a second for CPU clks.
    
    This patch is the combination of reverting commit 470b5e2f97cf ("clk:
    simplify clk_fetch_parent_index() function") and optimizing the
    resulting code to never call __clk_lookup() because we already have the
    clk_core pointer we're looking for. That optimization went unnoticed
    even after commit da0f0b2c3ad2 ("clk: Correct lookup logic in
    clk_fetch_parent_index()") tried to optimize this path.
    
    Signed-off-by: Derek Basehore <dbasehore@chromium.org>
    [sboyd@kernel.org: More description in commit text]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 6ccdbedb02f3..d2477a5058ac 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1513,9 +1513,19 @@ static int clk_fetch_parent_index(struct clk_core *core,
 	if (!parent)
 		return -EINVAL;
 
-	for (i = 0; i < core->num_parents; i++)
-		if (clk_core_get_parent_by_index(core, i) == parent)
+	for (i = 0; i < core->num_parents; i++) {
+		if (core->parents[i] == parent)
+			return i;
+
+		if (core->parents[i])
+			continue;
+
+		/* Fallback to comparing globally unique names */
+		if (!strcmp(parent->name, core->parent_names[i])) {
+			core->parents[i] = parent;
 			return i;
+		}
+	}
 
 	return -EINVAL;
 }

commit c6e909972ef87aa2a479269f46b84126f99ec6db
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Fri Jan 4 23:05:49 2019 +0100

    clk: sysfs: fix invalid JSON in clk_dump
    
    Add a missing comma so that the output is valid JSON format again.
    
    Fixes: 9fba738a53dd ("clk: add duty cycle support")
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 75d13c0eff12..6ccdbedb02f3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2779,7 +2779,7 @@ static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 	seq_printf(s, "\"protect_count\": %d,", c->protect_count);
 	seq_printf(s, "\"rate\": %lu,", clk_core_get_rate(c));
 	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy(c));
-	seq_printf(s, "\"phase\": %d", clk_core_get_phase(c));
+	seq_printf(s, "\"phase\": %d,", clk_core_get_phase(c));
 	seq_printf(s, "\"duty_cycle\": %u",
 		   clk_core_get_scaled_duty_cycle(c, 100000));
 }

commit 1a501c8defe950571316d5ddd917bf44f5ed7bd4
Merge: 3315fe5faff4 2e62246b08a6 e1bd55e5a567 0f51659a438e 56950ff82325
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Dec 14 13:33:44 2018 -0800

    Merge branches 'clk-managed-registration', 'clk-spdx', 'clk-remove-basic' and 'clk-ops-const' into clk-next
    
     - Make devm_of_clk_add_hw_provider() use parent dt node if necessary
     - Various SPDX taggings
     - Mark clk_ops const when possible
    
    * clk-managed-registration:
      clk: bd718x7: Initial support for ROHM bd71837/bd71847 PMIC clock
      clk: apcs-msm8916: simplify probe cleanup by using devm
      clk: clk-twl6040: Free of_provider at remove
      clk: rk808: use managed version of of_provider registration
      clk: clk-hi655x: Free of_provider at remove
      clk: of-provider: look at parent if registered device has no provider info
      clk: Add kerneldoc to managed of-provider interfaces
    
    * clk-spdx:
      clk: Tag basic clk types with SPDX
      clk: Tag clk core files with SPDX
      clk: bcm2835: Switch to SPDX identifier
    
    * clk-remove-basic:
      clk: Loongson1: Remove usage of CLK_IS_BASIC
      clk: samsung: s3c2410: Remove usage of CLK_IS_BASIC
      clk: versatile: sp810: Remove usage of CLK_IS_BASIC
      clk: hisilicon: Remove usage of CLK_IS_BASIC
      clk: h8300: Remove usage of CLK_IS_BASIC
      clk: axm5516: Remove usage of CLK_IS_BASIC
      clk: st: Remove usage of CLK_IS_BASIC
      clk: renesas: Remove usage of CLK_IS_BASIC
    
    * clk-ops-const:
      clk: s2mps11: constify clk_ops structure
      clk: pxa: constify clk_ops structures
      clk: pistachio: constify clk_ops structures
      clk: palmas: constify clk_ops structure
      clk: max77686: constify clk_ops structure

commit ebafb63dc7759c4cc54065b5aa675080b5f453ce
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 09:43:03 2018 -0800

    clk: Tag clk core files with SPDX
    
    These are all GPL-2.0 files per the existing license text. Replace the
    boiler plate with the tag.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index af011974d4ec..27260971bb39 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
  * Copyright (C) 2011-2012 Linaro Ltd <mturquette@linaro.org>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Standard functionality for the common clock API.  See Documentation/driver-api/clk.rst
  */
 

commit 05502bf9eb7a7297f5fa6f1d17b169b3d5b53570
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Tue Dec 4 13:34:53 2018 +0200

    clk: of-provider: look at parent if registered device has no provider info
    
    It seems to be usual for MFD devices that the created 'clock sub-device'
    do not have own DT node. The clock provider information is usually in the
    main device node which is owned by the MFD device. Change the devm variant
    of clk of-provider registration to check the parent device node if given
    device has no own node or if the node does not contain the #clock-cells
    property. In such case use the parent node if it contains the #clock-cells.
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    [sboyd@kernel.org: Add some comment in the code and pull out logic into
    a single function to return the provider device_node pointer]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2e1f204fe7e3..6ff852bda892 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3893,14 +3893,36 @@ static void devm_of_clk_release_provider(struct device *dev, void *res)
 	of_clk_del_provider(*(struct device_node **)res);
 }
 
+/*
+ * We allow a child device to use its parent device as the clock provider node
+ * for cases like MFD sub-devices where the child device driver wants to use
+ * devm_*() APIs but not list the device in DT as a sub-node.
+ */
+static struct device_node *get_clk_provider_node(struct device *dev)
+{
+	struct device_node *np, *parent_np;
+
+	np = dev->of_node;
+	parent_np = dev->parent ? dev->parent->of_node : NULL;
+
+	if (!of_find_property(np, "#clock-cells", NULL))
+		if (of_find_property(parent_np, "#clock-cells", NULL))
+			np = parent_np;
+
+	return np;
+}
+
 /**
  * devm_of_clk_add_hw_provider() - Managed clk provider node registration
  * @dev: Device acting as the clock provider (used for DT node and lifetime)
  * @get: callback for decoding clk_hw
  * @data: context pointer for @get callback
  *
- * Registers clock provider for given device's node. Provider is automatically
- * released at device exit.
+ * Registers clock provider for given device's node. If the device has no DT
+ * node or if the device node lacks of clock provider information (#clock-cells)
+ * then the parent device's node is scanned for this information. If parent node
+ * has the #clock-cells then it is used in registration. Provider is
+ * automatically released at device exit.
  *
  * Return: 0 on success or an errno on failure.
  */
@@ -3917,7 +3939,7 @@ int devm_of_clk_add_hw_provider(struct device *dev,
 	if (!ptr)
 		return -ENOMEM;
 
-	np = dev->of_node;
+	np = get_clk_provider_node(dev);
 	ret = of_clk_add_hw_provider(np, get, data);
 	if (!ret) {
 		*ptr = np;
@@ -3968,9 +3990,10 @@ static int devm_clk_provider_match(struct device *dev, void *res, void *data)
 void devm_of_clk_del_provider(struct device *dev)
 {
 	int ret;
+	struct device_node *np = get_clk_provider_node(dev);
 
 	ret = devres_release(dev, devm_of_clk_release_provider,
-			     devm_clk_provider_match, dev->of_node);
+			     devm_clk_provider_match, np);
 
 	WARN_ON(ret);
 }

commit e45838b52cb3bb0de0c217c903ce81ba2e48cd5d
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Tue Dec 4 13:33:48 2018 +0200

    clk: Add kerneldoc to managed of-provider interfaces
    
    Document the devm_of_clk_del_provider and the
    devm_of_clk_add_hw_provider functions.
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    [sboyd@kernel.org: Comply with kernel-doc formatting]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index af011974d4ec..2e1f204fe7e3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3893,6 +3893,17 @@ static void devm_of_clk_release_provider(struct device *dev, void *res)
 	of_clk_del_provider(*(struct device_node **)res);
 }
 
+/**
+ * devm_of_clk_add_hw_provider() - Managed clk provider node registration
+ * @dev: Device acting as the clock provider (used for DT node and lifetime)
+ * @get: callback for decoding clk_hw
+ * @data: context pointer for @get callback
+ *
+ * Registers clock provider for given device's node. Provider is automatically
+ * released at device exit.
+ *
+ * Return: 0 on success or an errno on failure.
+ */
 int devm_of_clk_add_hw_provider(struct device *dev,
 			struct clk_hw *(*get)(struct of_phandle_args *clkspec,
 					      void *data),
@@ -3950,6 +3961,10 @@ static int devm_clk_provider_match(struct device *dev, void *res, void *data)
 	return *np == data;
 }
 
+/**
+ * devm_of_clk_del_provider() - Remove clock provider registered using devm
+ * @dev: Device to whose lifetime the clock provider was bound
+ */
 void devm_of_clk_del_provider(struct device *dev)
 {
 	int ret;

commit 9be766274db4c446e54bc0c2f0c1fbcbb4a2bd1e
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Oct 11 09:28:13 2018 -0700

    clk: Clean up suspend/resume coding style
    
    The normal style is to use 'core' for struct clk_core pointers and to
    directly access the core pointer from the clk_hw pointer when we're
    within the common clk framework. Update the patches to make it a bit
    easier to handle.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index dd775771a7cc..af011974d4ec 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -935,39 +935,41 @@ static int clk_core_enable_lock(struct clk_core *core)
  */
 void clk_gate_restore_context(struct clk_hw *hw)
 {
-	if (hw->clk->core->enable_count)
-		hw->clk->core->ops->enable(hw);
+	struct clk_core *core = hw->core;
+
+	if (core->enable_count)
+		core->ops->enable(hw);
 	else
-		hw->clk->core->ops->disable(hw);
+		core->ops->disable(hw);
 }
 EXPORT_SYMBOL_GPL(clk_gate_restore_context);
 
-static int _clk_save_context(struct clk_core *clk)
+static int clk_core_save_context(struct clk_core *core)
 {
 	struct clk_core *child;
 	int ret = 0;
 
-	hlist_for_each_entry(child, &clk->children, child_node) {
-		ret = _clk_save_context(child);
+	hlist_for_each_entry(child, &core->children, child_node) {
+		ret = clk_core_save_context(child);
 		if (ret < 0)
 			return ret;
 	}
 
-	if (clk->ops && clk->ops->save_context)
-		ret = clk->ops->save_context(clk->hw);
+	if (core->ops && core->ops->save_context)
+		ret = core->ops->save_context(core->hw);
 
 	return ret;
 }
 
-static void _clk_restore_context(struct clk_core *clk)
+static void clk_core_restore_context(struct clk_core *core)
 {
 	struct clk_core *child;
 
-	if (clk->ops && clk->ops->restore_context)
-		clk->ops->restore_context(clk->hw);
+	if (core->ops && core->ops->restore_context)
+		core->ops->restore_context(core->hw);
 
-	hlist_for_each_entry(child, &clk->children, child_node)
-		_clk_restore_context(child);
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_core_restore_context(child);
 }
 
 /**
@@ -983,13 +985,13 @@ int clk_save_context(void)
 	int ret;
 
 	hlist_for_each_entry(clk, &clk_root_list, child_node) {
-		ret = _clk_save_context(clk);
+		ret = clk_core_save_context(clk);
 		if (ret < 0)
 			return ret;
 	}
 
 	hlist_for_each_entry(clk, &clk_orphan_list, child_node) {
-		ret = _clk_save_context(clk);
+		ret = clk_core_save_context(clk);
 		if (ret < 0)
 			return ret;
 	}
@@ -1006,13 +1008,13 @@ EXPORT_SYMBOL_GPL(clk_save_context);
  */
 void clk_restore_context(void)
 {
-	struct clk_core *clk;
+	struct clk_core *core;
 
-	hlist_for_each_entry(clk, &clk_root_list, child_node)
-		_clk_restore_context(clk);
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_core_restore_context(core);
 
-	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
-		_clk_restore_context(clk);
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_core_restore_context(core);
 }
 EXPORT_SYMBOL_GPL(clk_restore_context);
 

commit 435365485f40cf12747d1daa2253a4f4b46b8148
Author: Keerthy <j-keerthy@ti.com>
Date:   Tue Sep 4 12:19:36 2018 +0530

    clk: clk: Add clk_gate_restore_context function
    
    The clock gate restore context function enables or disables
    the gate clocks based on the enable_count. This is done in cases
    where the clock context is lost and based on the enable_count
    the clock either needs to be enabled/disabled.
    
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8a0254a1c303..dd775771a7cc 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -923,6 +923,25 @@ static int clk_core_enable_lock(struct clk_core *core)
 	return ret;
 }
 
+/**
+ * clk_gate_restore_context - restore context for poweroff
+ * @hw: the clk_hw pointer of clock whose state is to be restored
+ *
+ * The clock gate restore context function enables or disables
+ * the gate clocks based on the enable_count. This is done in cases
+ * where the clock context is lost and based on the enable_count
+ * the clock either needs to be enabled/disabled. This
+ * helps restore the state of gate clocks.
+ */
+void clk_gate_restore_context(struct clk_hw *hw)
+{
+	if (hw->clk->core->enable_count)
+		hw->clk->core->ops->enable(hw);
+	else
+		hw->clk->core->ops->disable(hw);
+}
+EXPORT_SYMBOL_GPL(clk_gate_restore_context);
+
 static int _clk_save_context(struct clk_core *clk)
 {
 	struct clk_core *child;

commit 8b95d1ce3300c411728954473316bd04d0ba9883
Author: Russ Dill <Russ.Dill@ti.com>
Date:   Tue Sep 4 12:19:35 2018 +0530

    clk: Add functions to save/restore clock context en-masse
    
    Deep enough power saving mode can result into losing context of the clock
    registers also, and they need to be restored once coming back from the power
    saving mode. Hence add functions to save/restore clock context.
    
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d31055ae6ec6..8a0254a1c303 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -923,6 +923,80 @@ static int clk_core_enable_lock(struct clk_core *core)
 	return ret;
 }
 
+static int _clk_save_context(struct clk_core *clk)
+{
+	struct clk_core *child;
+	int ret = 0;
+
+	hlist_for_each_entry(child, &clk->children, child_node) {
+		ret = _clk_save_context(child);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (clk->ops && clk->ops->save_context)
+		ret = clk->ops->save_context(clk->hw);
+
+	return ret;
+}
+
+static void _clk_restore_context(struct clk_core *clk)
+{
+	struct clk_core *child;
+
+	if (clk->ops && clk->ops->restore_context)
+		clk->ops->restore_context(clk->hw);
+
+	hlist_for_each_entry(child, &clk->children, child_node)
+		_clk_restore_context(child);
+}
+
+/**
+ * clk_save_context - save clock context for poweroff
+ *
+ * Saves the context of the clock register for powerstates in which the
+ * contents of the registers will be lost. Occurs deep within the suspend
+ * code.  Returns 0 on success.
+ */
+int clk_save_context(void)
+{
+	struct clk_core *clk;
+	int ret;
+
+	hlist_for_each_entry(clk, &clk_root_list, child_node) {
+		ret = _clk_save_context(clk);
+		if (ret < 0)
+			return ret;
+	}
+
+	hlist_for_each_entry(clk, &clk_orphan_list, child_node) {
+		ret = _clk_save_context(clk);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(clk_save_context);
+
+/**
+ * clk_restore_context - restore clock context after poweroff
+ *
+ * Restore the saved clock context upon resume.
+ *
+ */
+void clk_restore_context(void)
+{
+	struct clk_core *clk;
+
+	hlist_for_each_entry(clk, &clk_root_list, child_node)
+		_clk_restore_context(clk);
+
+	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
+		_clk_restore_context(clk);
+}
+EXPORT_SYMBOL_GPL(clk_restore_context);
+
 /**
  * clk_enable - ungate a clock
  * @clk: the clk being ungated

commit db06f826ec12bf0701ea7fc0a3c0aa00b84417c8
Merge: 6de4c691eab8 ac7da1b787d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 15 21:41:21 2018 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "The new and exciting feature this time around is in the clk core.
      We've added duty cycle support to the clk API so that clk signal duty
      cycle ratios can be adjusted while taking into account things like clk
      dividers and clk tree hierarchy. So far only one SoC has implemented
      support for this, but I expect there will be more to come in the
      future.
    
      Outside of the core, we have the usual pile of clk driver updates and
      additions. The Amlogic meson driver got the most lines in the diffstat
      this time around because it added support for a whole bunch of
      hardware and duty cycle configuration. After that the Rockchip PX30,
      Qualcomm SDM845, and Renesas SoC drivers fill in a majority of the
      diff. We're left with the collection of non-critical fixes after that.
      Overall it looks pretty quiet this time.
    
      Core:
       - Clk duty cycle support
       - Proper CLK_SET_RATE_GATE support throughout the tree
    
      New Drivers:
       - Actions Semi Owl series S700 SoC clk driver
       - Qualcomm SDM845 display clock controller
       - i.MX6SX ocram_s clk support
       - Uniphier NAND, USB3 PHY, and SPI clk support
       - Qualcomm RPMh clk driver
       - i.MX7D mailbox clk support
       - Maxim 9485 Programmable Clock Generator
       - expose 32 kHz PLL on PXA SoCs
       - imx6sll GPIO clk gate support
       - Atmel at91 I2S audio clk support
       - SI544/SI514 clk on/off support
       - i.MX6UL GPIO clock gates in CCM CCGR
       - Renesas Crypto Engine clocks on R-Car H3
       - Renesas clk support for the new RZ/N1D SoC
       - Allwinner A64 display engine clock support
       - support for Rockchip's PX30 SoC
       - Amlogic Meson axg PCIe and audio clocks
       - Amlogic Meson GEN CLK on gxbb, gxl and axg
    
      Updates:
       - remove an unused variable from Exynos4412 ISP driver
       - fix a thinko bug in SCMI clk division logic
       - add missing of_node_put()s in some i.MX clk drivers
       - Tegra SDMMC clk jitter improvements with high speed signaling modes
       - SPDX tagging for qcom and cs2000-cp drivers
       - stop leaking con ids in __clk_put()
       - fix a corner case in fixed factor clk probing where node is in DT
         but parent clk is registered much later
       - Marvell Armada 3700 clk_pm_cpu_get_parent() had an invalid return
         value
       - i.MX clk init arrays removed in place of CLK_IS_CRITICAL
       - convert to CLK_IS_CRITICAL for i.MX51/53 driver
       - fix Tegra BPMP driver oops when xlating a NULL clk
       - proper default configuration for vic03 and vde clks on Tegra124
       - mark Tegra memory controller clks as critical
       - fix array bounds clamp in Tegra's emc determine_rate() op
       - Ingenic i2s bit update and allow UDC clk to gate
       - fix name of aspeed SDC clk define to have only one 'CLK'
       - fix i.MX6QDL video clk parent
       - critical clk markings for qcom SDM845
       - fix Stratix10 mpu_free_clk and sdmmc_free_clk parents
       - mark Rockchip's pclk_rkpwm_pmu as critical clock, due to it
         supplying the pwm used to drive the logic supply of the rk3399
         core"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (85 commits)
      clk: rockchip: Add pclk_rkpwm_pmu to PMU critical clocks in rk3399
      clk: cs2000-cp: convert to SPDX identifiers
      clk: scmi: Fix the rounding of clock rate
      clk: qcom: Add display clock controller driver for SDM845
      clk: mvebu: armada-37xx-periph: Remove unused var num_parents
      clk: samsung: Remove unused mout_user_aclk400_mcuisp_p4x12 variable
      clk: actions: Add S700 SoC clock support
      dt-bindings: clock: Add S700 support for Actions Semi Soc's
      clk: actions: Add missing REGMAP_MMIO dependency
      clk: uniphier: add clock frequency support for SPI
      clk: uniphier: add more USB3 PHY clocks
      clk: uniphier: add NAND 200MHz clock
      clk: tegra: make sdmmc2 and sdmmc4 as sdmmc clocks
      clk: tegra: Add sdmmc mux divider clock
      clk: tegra: Refactor fractional divider calculation
      clk: tegra: Fix includes required by fence_udelay()
      clk: imx6sll: fix missing of_node_put()
      clk: imx6ul: fix missing of_node_put()
      clk: imx: add ocram_s clock for i.mx6sx
      clk: mvebu: armada-37xx-periph: Fix wrong return value in get_parent
      ...

commit 4a18ef5babd1bac0c746e87d1b94a7696fcd36be
Merge: d16adaf0b92f 9c7e47025a6b f9419783a6b4 365f7a89c881 f6dab4233d6b 8927c27b3270
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Aug 14 22:58:49 2018 -0700

    Merge branches 'clk-qcom-rpmh', 'clk-qcom-spdx', 'clk-con-id-leak', 'clk-fixed-factor-populated' and 'clk-mvebu-periph-parent' into clk-next
    
    * clk-qcom-rpmh:
      :  - Qualcomm RPMh clk driver
      clk: qcom: clk-rpmh: Add QCOM RPMh clock driver
    
    * clk-qcom-spdx:
      :  - SPDX tagging for qcom
      clk: qcom: Update SPDX headers for common files
    
    * clk-con-id-leak:
      :  - Stop leaking con ids in __clk_put()
      clk: core: Potentially free connection id
    
    * clk-fixed-factor-populated:
      :  - Fix a corner case in fixed factor clk probing where node is in DT but
      :    parent clk is registered much later
      clk: clk-fixed-factor: Clear OF_POPULATED flag in case of failure
    
    * clk-mvebu-periph-parent:
      :  - Marvell Armada 3700 clk_pm_cpu_get_parent() had an invalid return value
      clk: mvebu: armada-37xx-periph: Remove unused var num_parents
      clk: mvebu: armada-37xx-periph: Fix wrong return value in get_parent

commit 5ef7748ba37e0b1667ae973c1162fa60c0248f49
Merge: 04cdd5af51c6 9461f7b33d11 9fba738a53dd e8f127caf63a 4a2eaa8e2567
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Aug 14 22:58:30 2018 -0700

    Merge branches 'clk-qcom-set-rate-gate', 'clk-core-set-rate-gate', 'clk-core-duty-cycle', 'clk-si-prepare' and 'clk-imx-gpio-gates' into clk-next
    
    * clk-qcom-set-rate-gate:
      clk: qcom: drop CLK_SET_RATE_GATE from sdc clocks
    
    * clk-core-set-rate-gate:
      clk: fix CLK_SET_RATE_GATE with clock rate protection
    
    * clk-core-duty-cycle:
      clk: add duty cycle support
    
    * clk-si-prepare:
      :  - SI544/SI514 clk on/off support
      clk-si514, clk-si544: Implement prepare/unprepare/is_prepared operations
    
    * clk-imx-gpio-gates:
      :  - i.MX6UL GPIO clock gates in CCM CCGR
      clk: imx6ul: remove clks_init_on array
      clk: imx6ul: add GPIO clock gates
      dt-bindings: clock: imx6ul: Do not change the clock definition order

commit 4aa5db22d35588e1a5d2ee88472348ea73d9fb23
Merge: 6c0848398776 f2cf0ef7c0ce
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Aug 9 14:47:05 2018 +0100

    Merge branch 'asoc-4.19' into asoc-next

commit 365f7a89c881e84f1ebc925f65f899d5d7ce547e
Author: Mikko Perttunen <mperttunen@nvidia.com>
Date:   Wed Jul 11 11:21:04 2018 +0300

    clk: core: Potentially free connection id
    
    Patch "clk: core: Copy connection id" made it so that the connector id
    'con_id' is kstrdup_const()ed to cater to drivers that pass non-constant
    connection ids. The patch added the corresponding kfree_const to
    __clk_free_clk(), but struct clk's can be freed also via __clk_put().
    Add the kfree_const call to __clk_put() and add comments to both
    functions to remind that the logic in them should be kept in sync.
    
    Fixes: 253160a8ad06 ("clk: core: Copy connection id")
    Signed-off-by: Mikko Perttunen <mperttunen@nvidia.com>
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9760b526ca31..eeec6885c302 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2934,6 +2934,7 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 	return clk;
 }
 
+/* keep in sync with __clk_put */
 void __clk_free_clk(struct clk *clk)
 {
 	clk_prepare_lock();
@@ -3313,6 +3314,7 @@ int __clk_get(struct clk *clk)
 	return 1;
 }
 
+/* keep in sync with __clk_free_clk */
 void __clk_put(struct clk *clk)
 {
 	struct module *owner;
@@ -3346,6 +3348,7 @@ void __clk_put(struct clk *clk)
 
 	module_put(owner);
 
+	kfree_const(clk->con_id);
 	kfree(clk);
 }
 

commit 40dd71c75e395d9b0343f1e646de7ab5312540cc
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jul 6 17:16:54 2018 +0200

    clk: Really show symbolic clock flags in debugfs
    
    The last-minute fold-in of the ENTRY() macro did change behavior:
    instead of printing the symbolic name (e.g. "CLK_IS_BASIC"), it prints
    the expansion of it (e.g. "(1UL << (5))").
    
    Use "#" instead of  __stringify() to fix this.
    
    Fixes: a6059ab98130fb56 ("clk: Show symbolic clock flags in debugfs")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9760b526ca31..e2ed078abd90 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -24,7 +24,6 @@
 #include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/clkdev.h>
-#include <linux/stringify.h>
 
 #include "clk.h"
 
@@ -2559,7 +2558,7 @@ static const struct {
 	unsigned long flag;
 	const char *name;
 } clk_flags[] = {
-#define ENTRY(f) { f, __stringify(f) }
+#define ENTRY(f) { f, #f }
 	ENTRY(CLK_SET_RATE_GATE),
 	ENTRY(CLK_SET_PARENT_GATE),
 	ENTRY(CLK_SET_RATE_PARENT),

commit 9fba738a53dda20e748d6ee240b6c017c8146b4b
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Jun 19 16:41:41 2018 +0200

    clk: add duty cycle support
    
    Add the possibility to apply and query the clock signal duty cycle ratio.
    
    This is useful when the duty cycle of the clock signal depends on some
    other parameters controlled by the clock framework.
    
    For example, the duty cycle of a divider may depends on the raw divider
    setting (ratio = N / div) , which is controlled by the CCF. In such case,
    going through the pwm framework to control the duty cycle ratio of this
    clock would be a burden.
    
    A clock provider is not required to implement the operation to set and get
    the duty cycle. If it does not implement .get_duty_cycle(), the ratio is
    assumed to be 50%.
    
    This change also adds a new flag, CLK_DUTY_CYCLE_PARENT. This flag should
    be used to indicate that a clock, such as gates and muxes, may inherit
    the duty cycle ratio of its parent clock. If a clock does not provide a
    get_duty_cycle() callback and has CLK_DUTY_CYCLE_PARENT, then the call
    will be directly forwarded to its parent clock, if any. For
    set_duty_cycle(), the clock should also have CLK_SET_RATE_PARENT for the
    call to be forwarded
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20180619144141.8506-1-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9760b526ca31..b0a2719d86f3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -68,6 +68,7 @@ struct clk_core {
 	unsigned long		max_rate;
 	unsigned long		accuracy;
 	int			phase;
+	struct clk_duty		duty;
 	struct hlist_head	children;
 	struct hlist_node	child_node;
 	struct hlist_head	clks;
@@ -2402,6 +2403,172 @@ int clk_get_phase(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_phase);
 
+static void clk_core_reset_duty_cycle_nolock(struct clk_core *core)
+{
+	/* Assume a default value of 50% */
+	core->duty.num = 1;
+	core->duty.den = 2;
+}
+
+static int clk_core_update_duty_cycle_parent_nolock(struct clk_core *core);
+
+static int clk_core_update_duty_cycle_nolock(struct clk_core *core)
+{
+	struct clk_duty *duty = &core->duty;
+	int ret = 0;
+
+	if (!core->ops->get_duty_cycle)
+		return clk_core_update_duty_cycle_parent_nolock(core);
+
+	ret = core->ops->get_duty_cycle(core->hw, duty);
+	if (ret)
+		goto reset;
+
+	/* Don't trust the clock provider too much */
+	if (duty->den == 0 || duty->num > duty->den) {
+		ret = -EINVAL;
+		goto reset;
+	}
+
+	return 0;
+
+reset:
+	clk_core_reset_duty_cycle_nolock(core);
+	return ret;
+}
+
+static int clk_core_update_duty_cycle_parent_nolock(struct clk_core *core)
+{
+	int ret = 0;
+
+	if (core->parent &&
+	    core->flags & CLK_DUTY_CYCLE_PARENT) {
+		ret = clk_core_update_duty_cycle_nolock(core->parent);
+		memcpy(&core->duty, &core->parent->duty, sizeof(core->duty));
+	} else {
+		clk_core_reset_duty_cycle_nolock(core);
+	}
+
+	return ret;
+}
+
+static int clk_core_set_duty_cycle_parent_nolock(struct clk_core *core,
+						 struct clk_duty *duty);
+
+static int clk_core_set_duty_cycle_nolock(struct clk_core *core,
+					  struct clk_duty *duty)
+{
+	int ret;
+
+	lockdep_assert_held(&prepare_lock);
+
+	if (clk_core_rate_is_protected(core))
+		return -EBUSY;
+
+	trace_clk_set_duty_cycle(core, duty);
+
+	if (!core->ops->set_duty_cycle)
+		return clk_core_set_duty_cycle_parent_nolock(core, duty);
+
+	ret = core->ops->set_duty_cycle(core->hw, duty);
+	if (!ret)
+		memcpy(&core->duty, duty, sizeof(*duty));
+
+	trace_clk_set_duty_cycle_complete(core, duty);
+
+	return ret;
+}
+
+static int clk_core_set_duty_cycle_parent_nolock(struct clk_core *core,
+						 struct clk_duty *duty)
+{
+	int ret = 0;
+
+	if (core->parent &&
+	    core->flags & (CLK_DUTY_CYCLE_PARENT | CLK_SET_RATE_PARENT)) {
+		ret = clk_core_set_duty_cycle_nolock(core->parent, duty);
+		memcpy(&core->duty, &core->parent->duty, sizeof(core->duty));
+	}
+
+	return ret;
+}
+
+/**
+ * clk_set_duty_cycle - adjust the duty cycle ratio of a clock signal
+ * @clk: clock signal source
+ * @num: numerator of the duty cycle ratio to be applied
+ * @den: denominator of the duty cycle ratio to be applied
+ *
+ * Apply the duty cycle ratio if the ratio is valid and the clock can
+ * perform this operation
+ *
+ * Returns (0) on success, a negative errno otherwise.
+ */
+int clk_set_duty_cycle(struct clk *clk, unsigned int num, unsigned int den)
+{
+	int ret;
+	struct clk_duty duty;
+
+	if (!clk)
+		return 0;
+
+	/* sanity check the ratio */
+	if (den == 0 || num > den)
+		return -EINVAL;
+
+	duty.num = num;
+	duty.den = den;
+
+	clk_prepare_lock();
+
+	if (clk->exclusive_count)
+		clk_core_rate_unprotect(clk->core);
+
+	ret = clk_core_set_duty_cycle_nolock(clk->core, &duty);
+
+	if (clk->exclusive_count)
+		clk_core_rate_protect(clk->core);
+
+	clk_prepare_unlock();
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_duty_cycle);
+
+static int clk_core_get_scaled_duty_cycle(struct clk_core *core,
+					  unsigned int scale)
+{
+	struct clk_duty *duty = &core->duty;
+	int ret;
+
+	clk_prepare_lock();
+
+	ret = clk_core_update_duty_cycle_nolock(core);
+	if (!ret)
+		ret = mult_frac(scale, duty->num, duty->den);
+
+	clk_prepare_unlock();
+
+	return ret;
+}
+
+/**
+ * clk_get_scaled_duty_cycle - return the duty cycle ratio of a clock signal
+ * @clk: clock signal source
+ * @scale: scaling factor to be applied to represent the ratio as an integer
+ *
+ * Returns the duty cycle ratio of a clock node multiplied by the provided
+ * scaling factor, or negative errno on error.
+ */
+int clk_get_scaled_duty_cycle(struct clk *clk, unsigned int scale)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_get_scaled_duty_cycle(clk->core, scale);
+}
+EXPORT_SYMBOL_GPL(clk_get_scaled_duty_cycle);
+
 /**
  * clk_is_match - check if two clk's point to the same hardware clock
  * @p: clk compared against q
@@ -2455,12 +2622,13 @@ static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
 	if (!c)
 		return;
 
-	seq_printf(s, "%*s%-*s %7d %8d %8d %11lu %10lu %-3d\n",
+	seq_printf(s, "%*s%-*s %7d %8d %8d %11lu %10lu %5d %6d\n",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
 		   c->enable_count, c->prepare_count, c->protect_count,
 		   clk_core_get_rate(c), clk_core_get_accuracy(c),
-		   clk_core_get_phase(c));
+		   clk_core_get_phase(c),
+		   clk_core_get_scaled_duty_cycle(c, 100000));
 }
 
 static void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,
@@ -2482,9 +2650,9 @@ static int clk_summary_show(struct seq_file *s, void *data)
 	struct clk_core *c;
 	struct hlist_head **lists = (struct hlist_head **)s->private;
 
-	seq_puts(s, "                                 enable  prepare  protect                               \n");
-	seq_puts(s, "   clock                          count    count    count        rate   accuracy   phase\n");
-	seq_puts(s, "----------------------------------------------------------------------------------------\n");
+	seq_puts(s, "                                 enable  prepare  protect                                duty\n");
+	seq_puts(s, "   clock                          count    count    count        rate   accuracy phase  cycle\n");
+	seq_puts(s, "---------------------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 
@@ -2511,6 +2679,8 @@ static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 	seq_printf(s, "\"rate\": %lu,", clk_core_get_rate(c));
 	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy(c));
 	seq_printf(s, "\"phase\": %d", clk_core_get_phase(c));
+	seq_printf(s, "\"duty_cycle\": %u",
+		   clk_core_get_scaled_duty_cycle(c, 100000));
 }
 
 static void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)
@@ -2572,6 +2742,7 @@ static const struct {
 	ENTRY(CLK_SET_RATE_UNGATE),
 	ENTRY(CLK_IS_CRITICAL),
 	ENTRY(CLK_OPS_PARENT_ENABLE),
+	ENTRY(CLK_DUTY_CYCLE_PARENT),
 #undef ENTRY
 };
 
@@ -2610,6 +2781,17 @@ static int possible_parents_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(possible_parents);
 
+static int clk_duty_cycle_show(struct seq_file *s, void *data)
+{
+	struct clk_core *core = s->private;
+	struct clk_duty *duty = &core->duty;
+
+	seq_printf(s, "%u/%u\n", duty->num, duty->den);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(clk_duty_cycle);
+
 static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
 	struct dentry *root;
@@ -2628,6 +2810,8 @@ static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	debugfs_create_u32("clk_enable_count", 0444, root, &core->enable_count);
 	debugfs_create_u32("clk_protect_count", 0444, root, &core->protect_count);
 	debugfs_create_u32("clk_notifier_count", 0444, root, &core->notifier_count);
+	debugfs_create_file("clk_duty_cycle", 0444, root, core,
+			    &clk_duty_cycle_fops);
 
 	if (core->num_parents > 1)
 		debugfs_create_file("clk_possible_parents", 0444, root, core,
@@ -2845,6 +3029,11 @@ static int __clk_core_init(struct clk_core *core)
 	else
 		core->phase = 0;
 
+	/*
+	 * Set clk's duty cycle.
+	 */
+	clk_core_update_duty_cycle_nolock(core);
+
 	/*
 	 * Set clk's rate.  The preferred method is to use .recalc_rate.  For
 	 * simple clocks and lazy developers the default fallback is to use the

commit 9461f7b33d11cbbf5ce79c3c03d0da9d42dfce92
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Jun 19 15:40:51 2018 +0200

    clk: fix CLK_SET_RATE_GATE with clock rate protection
    
    CLK_SET_RATE_GATE should prevent any operation which may result in a rate
    change or glitch while the clock is prepared/enabled.
    
    IOW, the following sequence is not allowed anymore with CLK_SET_RATE_GATE:
    * clk_get()
    * clk_prepare_enable()
    * clk_get_rate()
    * clk_set_rate()
    
    At the moment this is enforced on the leaf clock of the operation, not
    along the tree. This problematic because, if a PLL has the CLK_RATE_GATE,
    it won't be enforced if the clk_set_rate() is called on its child clocks.
    
    Using clock rate protection, we can now enforce CLK_SET_RATE_GATE along the
    clock tree
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20180619134051.16726-3-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9760b526ca31..97c09243fb21 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -691,6 +691,9 @@ static void clk_core_unprepare(struct clk_core *core)
 	    "Unpreparing critical %s\n", core->name))
 		return;
 
+	if (core->flags & CLK_SET_RATE_GATE)
+		clk_core_rate_unprotect(core);
+
 	if (--core->prepare_count > 0)
 		return;
 
@@ -765,6 +768,16 @@ static int clk_core_prepare(struct clk_core *core)
 
 	core->prepare_count++;
 
+	/*
+	 * CLK_SET_RATE_GATE is a special case of clock protection
+	 * Instead of a consumer claiming exclusive rate control, it is
+	 * actually the provider which prevents any consumer from making any
+	 * operation which could result in a rate change or rate glitch while
+	 * the clock is prepared.
+	 */
+	if (core->flags & CLK_SET_RATE_GATE)
+		clk_core_rate_protect(core);
+
 	return 0;
 unprepare:
 	clk_core_unprepare(core->parent);
@@ -1888,9 +1901,6 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 	if (clk_core_rate_is_protected(core))
 		return -EBUSY;
 
-	if ((core->flags & CLK_SET_RATE_GATE) && core->prepare_count)
-		return -EBUSY;
-
 	/* calculate new rates and get the topmost changed clock */
 	top = clk_calc_new_rates(core, req_rate);
 	if (!top)

commit 5fb94e9ca333f0fe1d96de06704a79942b3832c3
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue May 8 15:14:57 2018 -0300

    docs: Fix some broken references
    
    As we move stuff around, some doc references are broken. Fix some of
    them via this script:
            ./scripts/documentation-file-ref-check --fix
    
    Manually checked if the produced result is valid, removing a few
    false-positives.
    
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Masami Hiramatsu <mhiramat@kernel.org>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Coly Li <colyli@suse.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a24a6afb50b6..9760b526ca31 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -6,7 +6,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * Standard functionality for the common clock API.  See Documentation/clk.txt
+ * Standard functionality for the common clock API.  See Documentation/driver-api/clk.rst
  */
 
 #include <linux/clk.h>
@@ -2747,7 +2747,7 @@ static int __clk_core_init(struct clk_core *core)
 		goto out;
 	}
 
-	/* check that clk_ops are sane.  See Documentation/clk.txt */
+	/* check that clk_ops are sane.  See Documentation/driver-api/clk.rst */
 	if (core->ops->set_rate &&
 	    !((core->ops->round_rate || core->ops->determine_rate) &&
 	      core->ops->recalc_rate)) {

commit 6419945e3313fd894af79caefca6823d4511133f
Merge: d60dafdca4b4 55913c2d3330
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 9 12:06:24 2018 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "This time we have a good set of changes to the core framework that do
      some general cleanups, but nothing too major. The majority of the diff
      goes to two SoCs, Actions Semi and Qualcomm. A brand new driver is
      introduced for Actions Semi so it takes up some lines to add all the
      different types, and the Qualcomm diff is there because we add support
      for two SoCs and it's quite a bit of data.
    
      Otherwise the big driver updates are on TI Davinci and Amlogic
      platforms. And then the long tail of driver updates for various fixes
      and stuff follows after that.
    
      Core:
       - debugfs cleanups removing error checking and an unused provider API
       - Removal of a clk init typedef that isn't used
       - Usage of match_string() to simplify parent string name matching
       - OF clk helpers moved to their own file (linux/of_clk.h)
       - Make clk warnings more readable across kernel versions
    
      New Drivers:
       - Qualcomm SDM845 GCC and Video clk controllers
       - Qualcomm MSM8998 GCC
       - Actions Semi S900 SoC support
       - Nuvoton npcm750 microcontroller clks
       - Amlogic axg AO clock controller
    
      Removed Drivers:
       - Deprecated Rockchip clk-gate driver
    
      Updates:
       - debugfs functions stopped checking return values
       - Support for the MSIOF module clocks on Rensas R-Car M3-N
       - Support for the new Rensas RZ/G1C and R-Car E3 SoCs
       - Qualcomm GDSC, RCG, and PLL updates for clk changes in new SoCs
       - Berlin and Amlogic SPDX tagging
       - Usage of of_clk_get_parent_count() in more places
       - Proper implementation of the CDEV1/2 clocks on Tegra20
       - Allwinner H6 PRCM clock support and R40 EMAC support
       - Add critical flag to meson8b's fdiv2 as temporary fixup for ethernet
       - Round closest support for meson's mpll driver
       - Support for meson8b nand clocks and gxbb video decoder clocks
       - Mediatek mali clks
       - STM32MP1 fixes
       - Uniphier LD11/LD20 stream demux system clock"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (134 commits)
      clk: qcom: Export clk_fabia_pll_configure()
      clk: bcm: Update and add Stingray clock entries
      dt-bindings: clk: Update Stingray binding doc
      clk-si544: Properly round requested frequency to nearest match
      clk: ingenic: jz4770: Add 150us delay after enabling VPU clock
      clk: ingenic: jz4770: Enable power of AHB1 bus after ungating VPU clock
      clk: ingenic: jz4770: Modify C1CLK clock to disable CPU clock stop on idle
      clk: ingenic: jz4770: Change OTG from custom to standard gated clock
      clk: ingenic: Support specifying "wait for clock stable" delay
      clk: ingenic: Add support for clocks whose gate bit is inverted
      clk: use match_string() helper
      clk: bcm2835: use match_string() helper
      clk: Return void from debug_init op
      clk: remove clk_debugfs_add_file()
      clk: tegra: no need to check return value of debugfs_create functions
      clk: davinci: no need to check return value of debugfs_create functions
      clk: bcm2835: no need to check return value of debugfs_create functions
      clk: no need to check return value of debugfs_create functions
      clk: imx6: add EPIT clock support
      clk: mvebu: use correct bit for 98DX3236 NAND
      ...

commit 36851edd7ea96ac74266de27b2ff7870e14563c8
Merge: ef1ae47094b5 d6347445c496 6ee3d385c263 4d3f36c5e9ca 5afa881c6635
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Jun 4 12:32:33 2018 -0700

    Merge branches 'clk-match-string', 'clk-ingenic', 'clk-si544-round-fix' and 'clk-bcm-stingray' into clk-next
    
    * clk-match-string:
      clk: use match_string() helper
      clk: bcm2835: use match_string() helper
    
    * clk-ingenic:
      clk: ingenic: jz4770: Add 150us delay after enabling VPU clock
      clk: ingenic: jz4770: Enable power of AHB1 bus after ungating VPU clock
      clk: ingenic: jz4770: Modify C1CLK clock to disable CPU clock stop on idle
      clk: ingenic: jz4770: Change OTG from custom to standard gated clock
      clk: ingenic: Support specifying "wait for clock stable" delay
      clk: ingenic: Add support for clocks whose gate bit is inverted
    
    * clk-si544-round-fix:
      clk-si544: Properly round requested frequency to nearest match
    
    * clk-bcm-stingray:
      clk: bcm: Update and add Stingray clock entries
      dt-bindings: clk: Update Stingray binding doc

commit ef1ae47094b506b0194b251888166809e9258cf8
Merge: fff2e3371760 b4f5e1ffcc47 7b873e4b5a93 00c5a926af12 b1569380a60f d75d50c016a4
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Jun 4 12:32:28 2018 -0700

    Merge branches 'clk-imx7d', 'clk-hisi-stub', 'clk-mvebu', 'clk-imx6-epit' and 'clk-debugfs-simple' into clk-next
    
    * clk-imx7d:
      clk: imx7d: reset parent for mipi csi root
      clk: imx7d: fix mipi dphy div parent
    
    * clk-hisi-stub:
      clk/driver/hisi: Consolidate the Kconfig for the CLOCK_STUB
    
    * clk-mvebu:
      clk: mvebu: use correct bit for 98DX3236 NAND
    
    * clk-imx6-epit:
      clk: imx6: add EPIT clock support
    
    * clk-debugfs-simple:
      clk: Return void from debug_init op
      clk: remove clk_debugfs_add_file()
      clk: tegra: no need to check return value of debugfs_create functions
      clk: davinci: no need to check return value of debugfs_create functions
      clk: bcm2835: no need to check return value of debugfs_create functions
      clk: no need to check return value of debugfs_create functions

commit 101cfc9f787d8ca22866a178f2c1684fb10f8c7a
Merge: ab525dcccfd6 a597043304a1 1af897dff60a b5f5f525c547
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Jun 4 12:26:39 2018 -0700

    Merge branches 'clk-warn', 'clk-core', 'clk-spear' and 'clk-qcom-msm8998' into clk-next
    
    * clk-warn:
      clk: Print the clock name and warning cause
    
    * clk-core:
      clk: Remove clk_init_cb typedef
    
    * clk-spear:
      clk: spear: fix WDT clock definition on SPEAr600
    
    * clk-qcom-msm8998:
      clk: qcom: Add MSM8998 Global Clock Control (GCC) driver

commit d6347445c49637237c5316fd76833be1d0ffa695
Author: Yisheng Xie <xieyisheng1@huawei.com>
Date:   Thu May 31 19:11:14 2018 +0800

    clk: use match_string() helper
    
    match_string() returns the index of an array for a matching string,
    which can be used instead of open coded variant.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: linux-clk@vger.kernel.org
    Signed-off-by: Yisheng Xie <xieyisheng1@huawei.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ea67ac81c6f9..b7d1a5634164 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2170,7 +2170,6 @@ void clk_hw_reparent(struct clk_hw *hw, struct clk_hw *new_parent)
 bool clk_has_parent(struct clk *clk, struct clk *parent)
 {
 	struct clk_core *core, *parent_core;
-	unsigned int i;
 
 	/* NULL clocks should be nops, so return success if either is NULL. */
 	if (!clk || !parent)
@@ -2183,11 +2182,8 @@ bool clk_has_parent(struct clk *clk, struct clk *parent)
 	if (core->parent == parent_core)
 		return true;
 
-	for (i = 0; i < core->num_parents; i++)
-		if (strcmp(core->parent_names[i], parent_core->name) == 0)
-			return true;
-
-	return false;
+	return match_string(core->parent_names, core->num_parents,
+			    parent_core->name) >= 0;
 }
 EXPORT_SYMBOL_GPL(clk_has_parent);
 

commit c1c2873df06372a108976599583eba7e47483379
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 29 18:08:04 2018 +0200

    clk: remove clk_debugfs_add_file()
    
    No one was using this api call, so remove it.  If it is ever needed in
    the future, a "raw" debugfs call can be used.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ef701ce44439..59207cd6138a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2669,19 +2669,6 @@ static void clk_debug_unregister(struct clk_core *core)
 	mutex_unlock(&clk_debug_lock);
 }
 
-struct dentry *clk_debugfs_add_file(struct clk_hw *hw, char *name, umode_t mode,
-				void *data, const struct file_operations *fops)
-{
-	struct dentry *d = NULL;
-
-	if (hw->core->dentry)
-		d = debugfs_create_file(name, mode, hw->core->dentry, data,
-					fops);
-
-	return d;
-}
-EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
-
 /**
  * clk_debug_init - lazily populate the debugfs clk directory
  *

commit 8a26bbbb932021fd6ce8821ca8b2e6771b8ff7d2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 29 18:08:00 2018 +0200

    clk: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    This cleans up the init code a lot, and there's no need to return an
    error value based on the debugfs calls, especially as it turns out no
    one was even looking at that return value.  So it obviously wasn't that
    important :)
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ea67ac81c6f9..ef701ce44439 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2608,81 +2608,31 @@ static int possible_parents_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(possible_parents);
 
-static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
+static void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
-	struct dentry *d;
-	int ret = -ENOMEM;
-
-	if (!core || !pdentry) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	d = debugfs_create_dir(core->name, pdentry);
-	if (!d)
-		goto out;
-
-	core->dentry = d;
-
-	d = debugfs_create_ulong("clk_rate", 0444, core->dentry, &core->rate);
-	if (!d)
-		goto err_out;
-
-	d = debugfs_create_ulong("clk_accuracy", 0444, core->dentry,
-				 &core->accuracy);
-	if (!d)
-		goto err_out;
+	struct dentry *root;
 
-	d = debugfs_create_u32("clk_phase", 0444, core->dentry, &core->phase);
-	if (!d)
-		goto err_out;
-
-	d = debugfs_create_file("clk_flags", 0444, core->dentry, core,
-				&clk_flags_fops);
-	if (!d)
-		goto err_out;
-
-	d = debugfs_create_u32("clk_prepare_count", 0444, core->dentry,
-			       &core->prepare_count);
-	if (!d)
-		goto err_out;
-
-	d = debugfs_create_u32("clk_enable_count", 0444, core->dentry,
-			       &core->enable_count);
-	if (!d)
-		goto err_out;
-
-	d = debugfs_create_u32("clk_protect_count", 0444, core->dentry,
-			       &core->protect_count);
-	if (!d)
-		goto err_out;
-
-	d = debugfs_create_u32("clk_notifier_count", 0444, core->dentry,
-			       &core->notifier_count);
-	if (!d)
-		goto err_out;
+	if (!core || !pdentry)
+		return;
 
-	if (core->num_parents > 1) {
-		d = debugfs_create_file("clk_possible_parents", 0444,
-				core->dentry, core, &possible_parents_fops);
-		if (!d)
-			goto err_out;
-	}
+	root = debugfs_create_dir(core->name, pdentry);
+	core->dentry = root;
 
-	if (core->ops->debug_init) {
-		ret = core->ops->debug_init(core->hw, core->dentry);
-		if (ret)
-			goto err_out;
-	}
+	debugfs_create_ulong("clk_rate", 0444, root, &core->rate);
+	debugfs_create_ulong("clk_accuracy", 0444, root, &core->accuracy);
+	debugfs_create_u32("clk_phase", 0444, root, &core->phase);
+	debugfs_create_file("clk_flags", 0444, root, core, &clk_flags_fops);
+	debugfs_create_u32("clk_prepare_count", 0444, root, &core->prepare_count);
+	debugfs_create_u32("clk_enable_count", 0444, root, &core->enable_count);
+	debugfs_create_u32("clk_protect_count", 0444, root, &core->protect_count);
+	debugfs_create_u32("clk_notifier_count", 0444, root, &core->notifier_count);
 
-	ret = 0;
-	goto out;
+	if (core->num_parents > 1)
+		debugfs_create_file("clk_possible_parents", 0444, root, core,
+				    &possible_parents_fops);
 
-err_out:
-	debugfs_remove_recursive(core->dentry);
-	core->dentry = NULL;
-out:
-	return ret;
+	if (core->ops->debug_init)
+		core->ops->debug_init(core->hw, core->dentry);
 }
 
 /**
@@ -2693,17 +2643,13 @@ static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
  * initialized.  Otherwise it bails out early since the debugfs clk directory
  * will be created lazily by clk_debug_init as part of a late_initcall.
  */
-static int clk_debug_register(struct clk_core *core)
+static void clk_debug_register(struct clk_core *core)
 {
-	int ret = 0;
-
 	mutex_lock(&clk_debug_lock);
 	hlist_add_head(&core->debug_node, &clk_debug_list);
 	if (inited)
-		ret = clk_debug_create_one(core, rootdir);
+		clk_debug_create_one(core, rootdir);
 	mutex_unlock(&clk_debug_lock);
-
-	return ret;
 }
 
  /**
@@ -2748,32 +2694,17 @@ EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
 static int __init clk_debug_init(void)
 {
 	struct clk_core *core;
-	struct dentry *d;
 
 	rootdir = debugfs_create_dir("clk", NULL);
 
-	if (!rootdir)
-		return -ENOMEM;
-
-	d = debugfs_create_file("clk_summary", 0444, rootdir, &all_lists,
-				&clk_summary_fops);
-	if (!d)
-		return -ENOMEM;
-
-	d = debugfs_create_file("clk_dump", 0444, rootdir, &all_lists,
-				&clk_dump_fops);
-	if (!d)
-		return -ENOMEM;
-
-	d = debugfs_create_file("clk_orphan_summary", 0444, rootdir,
-				&orphan_list, &clk_summary_fops);
-	if (!d)
-		return -ENOMEM;
-
-	d = debugfs_create_file("clk_orphan_dump", 0444, rootdir,
-				&orphan_list, &clk_dump_fops);
-	if (!d)
-		return -ENOMEM;
+	debugfs_create_file("clk_summary", 0444, rootdir, &all_lists,
+			    &clk_summary_fops);
+	debugfs_create_file("clk_dump", 0444, rootdir, &all_lists,
+			    &clk_dump_fops);
+	debugfs_create_file("clk_orphan_summary", 0444, rootdir, &orphan_list,
+			    &clk_summary_fops);
+	debugfs_create_file("clk_orphan_dump", 0444, rootdir, &orphan_list,
+			    &clk_dump_fops);
 
 	mutex_lock(&clk_debug_lock);
 	hlist_for_each_entry(core, &clk_debug_list, debug_node)
@@ -2786,7 +2717,7 @@ static int __init clk_debug_init(void)
 }
 late_initcall(clk_debug_init);
 #else
-static inline int clk_debug_register(struct clk_core *core) { return 0; }
+static inline void clk_debug_register(struct clk_core *core) { }
 static inline void clk_debug_reparent(struct clk_core *core,
 				      struct clk_core *new_parent)
 {

commit a597043304a13defc646bb1f16514e4903b36c3c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 10 15:06:05 2018 +0200

    clk: Remove clk_init_cb typedef
    
    Since commit c08ee14cc6634457 ("clk: ti: change clock init to use
    generic of_clk_init"), there is only a single (private) user left of the
    (public) clk_init_cb typedef.
    
    Hence expand its single user in the core clock code, and remove the
    typedef.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/1523365565-17124-1-git-send-email-geert+renesas@glider.be

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ea67ac81c6f9..972f1ea4b63f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3906,7 +3906,7 @@ int of_clk_parent_fill(struct device_node *np, const char **parents,
 EXPORT_SYMBOL_GPL(of_clk_parent_fill);
 
 struct clock_provider {
-	of_clk_init_cb_t clk_init_cb;
+	void (*clk_init_cb)(struct device_node *);
 	struct device_node *np;
 	struct list_head node;
 };

commit 4ad69b80e886a845f56ce0a3d10211208693d92b
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Mon Apr 9 15:59:20 2018 +0200

    clk: honor CLK_MUX_ROUND_CLOSEST in generic clk mux
    
    CLK_MUX_ROUND_CLOSEST is part of the clk_mux documentation but clk_mux
    directly calls __clk_mux_determine_rate(), which overrides the flag.
    As result, if clk_mux is instantiated with CLK_MUX_ROUND_CLOSEST, the
    flag will be ignored and the clock rounded down.
    
    To solve this, this patch expose clk_mux_determine_rate_flags() in the
    clk-provider API and uses it in the determine_rate() callback of clk_mux.
    
    Fixes: 15a02c1f6dd7 ("clk: Add __clk_mux_determine_rate_closest")
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ea67ac81c6f9..7af555f0e60c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -426,9 +426,9 @@ static bool mux_is_better_rate(unsigned long rate, unsigned long now,
 	return now <= rate && now > best;
 }
 
-static int
-clk_mux_determine_rate_flags(struct clk_hw *hw, struct clk_rate_request *req,
-			     unsigned long flags)
+int clk_mux_determine_rate_flags(struct clk_hw *hw,
+				 struct clk_rate_request *req,
+				 unsigned long flags)
 {
 	struct clk_core *core = hw->core, *parent, *best_parent = NULL;
 	int i, num_parents, ret;
@@ -488,6 +488,7 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, struct clk_rate_request *req,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(clk_mux_determine_rate_flags);
 
 struct clk *__clk_lookup(const char *name)
 {

commit fbc20b8c3cc4b95c0e31f89c596eaa350f9cd6c3
Merge: e8121d98672b 6a4a45958045 1f9c63e8de3d cef7b18c3e8b f72595cf441b 8bcde6582c90
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 6 13:21:52 2018 -0700

    Merge branches 'clk-mvebu', 'clk-phase', 'clk-nxp', 'clk-mtk2712' and 'clk-qcom-rpmcc' into clk-next
    
    * clk-mvebu:
      clk: mvebu: armada-38x: add support for missing clocks
      clk: mvebu: cp110: Fix clock tree representation
    
    * clk-phase:
      clk: Don't show the incorrect clock phase
      clk: update cached phase to respect the fact when setting phase
    
    * clk-nxp:
      clk: lpc32xx: Set name of regmap_config
    
    * clk-mtk2712:
      clk: mediatek: update clock driver of MT2712
      dt-bindings: clock: add clocks for MT2712
    
    * clk-qcom-rpmcc:
      clk: qcom: rpmcc: Add support to XO buffered clocks

commit caa9f3b7d73f7675145d61e95f58394a1f537a3a
Merge: 15afa044cba4 a1d803d78b9e 5bc5673c098b 6e0d4ff4580c 91927ff6446c fec0ef3f5273
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 6 13:21:39 2018 -0700

    Merge branches 'clk-versatile', 'clk-doc', 'clk-must-check', 'clk-qcom' and 'clk-debugfs' into clk-next
    
    * clk-versatile:
      clk: versatile: Remove WARNs in ->round_rate()
      clk: versatile: add min/max rate boundaries for vexpress osc clock
    
    * clk-doc:
      Documentation: clk: enable lock is not held for clk_is_enabled API
    
    * clk-must-check:
      clk: add more __must_check for bulk APIs
    
    * clk-qcom:
      clk: qcom: smd-rpm: Migrate to devm_of_clk_add_hw_provider()
      clk: qcom: gcc-msm8996: Mark aggre0 noc clks as critical
    
    * clk-debugfs:
      clk: Re-use DEFINE_SHOW_ATTRIBUTE() macro

commit 1f9c63e8de3d7b377c9d74e4a17524cfb60e6384
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Mar 14 08:28:31 2018 +0800

    clk: Don't show the incorrect clock phase
    
    It's found that the clock phase output from clk_summary is
    wrong compared to the actual phase reading from the register.
    
    cat /sys/kernel/debug/clk/clk_summary | grep sdio_sample
    sdio_sample     0        1        0 50000000          0 -22
    
    It exposes an issue that clk core, clk_core_get_phase, always
    returns the cached core->phase which should be either updated
    by calling clk_set_phase or directly from the first place the
    clk was registered.
    
    When registering the clk, the core->phase geting from ->get_phase()
    may return negative value indicating error. This is quite common
    since the clk's phase may be highly related to its parent chain,
    but it was temporarily orphan when registered, since its parent
    chains hadn't be ready at that time, so the clk drivers decide to
    return error in this case. However, if no clk_set_phase is called or
    maybe the ->set_phase() isn't even implemented, the core->phase would
    never be updated. This is wrong, and we should try to update it when
    all its parent chains are settled down, like the way of updating clock
    rate for that. But it's not deserved to complicate the code now and
    just update it anyway when calling clk_core_get_phase, which would be
    much simple and enough.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Acked-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 617e56268b18..d5c477c7bcf1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2373,6 +2373,9 @@ static int clk_core_get_phase(struct clk_core *core)
 	int ret;
 
 	clk_prepare_lock();
+	/* Always try to update cached phase if possible */
+	if (core->ops->get_phase)
+		core->phase = core->ops->get_phase(core->hw);
 	ret = core->phase;
 	clk_prepare_unlock();
 

commit fec0ef3f52735e1e9ac60f8644d4015ae21c0928
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Feb 14 17:48:00 2018 +0200

    clk: Re-use DEFINE_SHOW_ATTRIBUTE() macro
    
    ...instead of open coding file operations followed by custom ->open()
    callbacks per each attribute.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0f686a9dac3e..cc97b18ac31f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2486,19 +2486,7 @@ static int clk_summary_show(struct seq_file *s, void *data)
 
 	return 0;
 }
-
-
-static int clk_summary_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, clk_summary_show, inode->i_private);
-}
-
-static const struct file_operations clk_summary_fops = {
-	.open		= clk_summary_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(clk_summary);
 
 static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 {
@@ -2532,7 +2520,7 @@ static void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)
 	seq_putc(s, '}');
 }
 
-static int clk_dump(struct seq_file *s, void *data)
+static int clk_dump_show(struct seq_file *s, void *data)
 {
 	struct clk_core *c;
 	bool first_node = true;
@@ -2555,19 +2543,7 @@ static int clk_dump(struct seq_file *s, void *data)
 	seq_puts(s, "}\n");
 	return 0;
 }
-
-
-static int clk_dump_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, clk_dump, inode->i_private);
-}
-
-static const struct file_operations clk_dump_fops = {
-	.open		= clk_dump_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(clk_dump);
 
 static const struct {
 	unsigned long flag;
@@ -2589,7 +2565,7 @@ static const struct {
 #undef ENTRY
 };
 
-static int clk_flags_dump(struct seq_file *s, void *data)
+static int clk_flags_show(struct seq_file *s, void *data)
 {
 	struct clk_core *core = s->private;
 	unsigned long flags = core->flags;
@@ -2608,20 +2584,9 @@ static int clk_flags_dump(struct seq_file *s, void *data)
 
 	return 0;
 }
+DEFINE_SHOW_ATTRIBUTE(clk_flags);
 
-static int clk_flags_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, clk_flags_dump, inode->i_private);
-}
-
-static const struct file_operations clk_flags_fops = {
-	.open		= clk_flags_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int possible_parents_dump(struct seq_file *s, void *data)
+static int possible_parents_show(struct seq_file *s, void *data)
 {
 	struct clk_core *core = s->private;
 	int i;
@@ -2633,18 +2598,7 @@ static int possible_parents_dump(struct seq_file *s, void *data)
 
 	return 0;
 }
-
-static int possible_parents_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, possible_parents_dump, inode->i_private);
-}
-
-static const struct file_operations possible_parents_fops = {
-	.open		= possible_parents_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(possible_parents);
 
 static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {

commit ab525dcccfd6ad11a0313fd58222b72cee4ca7ad
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Tue Jan 16 10:50:34 2018 -0200

    clk: Print the clock name and warning cause
    
    When getting the clock related warnings, it is useful to know what
    is the clock name that is causing the problem and the cause of the
    problem.
    
    Add the clock name and the the warning cause to the log, so that the
    output becomes clearer like this:
    
    [    2.383969] ------------[ cut here ]------------
    [    2.388720] WARNING: CPU: 0 PID: 1 at drivers/clk/clk.c:814 clk_core_disable+0xd4/0xf8
    [    2.396658] uart4_ipg_gate already disabled
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0f686a9dac3e..c95dc09a1ca7 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -548,7 +548,8 @@ static void clk_core_rate_unprotect(struct clk_core *core)
 	if (!core)
 		return;
 
-	if (WARN_ON(core->protect_count == 0))
+	if (WARN(core->protect_count == 0,
+	    "%s already unprotected\n", core->name))
 		return;
 
 	if (--core->protect_count > 0)
@@ -681,16 +682,18 @@ static void clk_core_unprepare(struct clk_core *core)
 	if (!core)
 		return;
 
-	if (WARN_ON(core->prepare_count == 0))
+	if (WARN(core->prepare_count == 0,
+	    "%s already unprepared\n", core->name))
 		return;
 
-	if (WARN_ON(core->prepare_count == 1 && core->flags & CLK_IS_CRITICAL))
+	if (WARN(core->prepare_count == 1 && core->flags & CLK_IS_CRITICAL,
+	    "Unpreparing critical %s\n", core->name))
 		return;
 
 	if (--core->prepare_count > 0)
 		return;
 
-	WARN_ON(core->enable_count > 0);
+	WARN(core->enable_count > 0, "Unpreparing enabled %s\n", core->name);
 
 	trace_clk_unprepare(core);
 
@@ -808,10 +811,11 @@ static void clk_core_disable(struct clk_core *core)
 	if (!core)
 		return;
 
-	if (WARN_ON(core->enable_count == 0))
+	if (WARN(core->enable_count == 0, "%s already disabled\n", core->name))
 		return;
 
-	if (WARN_ON(core->enable_count == 1 && core->flags & CLK_IS_CRITICAL))
+	if (WARN(core->enable_count == 1 && core->flags & CLK_IS_CRITICAL,
+	    "Disabling critical %s\n", core->name))
 		return;
 
 	if (--core->enable_count > 0)
@@ -866,7 +870,8 @@ static int clk_core_enable(struct clk_core *core)
 	if (!core)
 		return 0;
 
-	if (WARN_ON(core->prepare_count == 0))
+	if (WARN(core->prepare_count == 0,
+	    "Enabling unprepared %s\n", core->name))
 		return -ESHUTDOWN;
 
 	if (core->enable_count == 0) {

commit 541debae0adf0bee96137724fa1ce81d3102d14c
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Wed Feb 14 14:43:37 2018 +0100

    clk: call the clock init() callback before any other ops callback
    
    Some clocks may need to initialize things, whatever it is, before
    being able to properly operate. Move the .init() call before any
    other callback, such recalc_rate() or get_phase(), so the clock
    is properly setup before being used.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index cca05ea2c058..9d56be6ead39 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2929,6 +2929,17 @@ static int __clk_core_init(struct clk_core *core)
 		core->orphan = true;
 	}
 
+	/*
+	 * optional platform-specific magic
+	 *
+	 * The .init callback is not used by any of the basic clock types, but
+	 * exists for weird hardware that must perform initialization magic.
+	 * Please consider other ways of solving initialization problems before
+	 * using this callback, as its use is discouraged.
+	 */
+	if (core->ops->init)
+		core->ops->init(core->hw);
+
 	/*
 	 * Set clk's accuracy.  The preferred method is to use
 	 * .recalc_accuracy. For simple clocks and lazy developers the default
@@ -3006,17 +3017,6 @@ static int __clk_core_init(struct clk_core *core)
 		}
 	}
 
-	/*
-	 * optional platform-specific magic
-	 *
-	 * The .init callback is not used by any of the basic clock types, but
-	 * exists for weird hardware that must perform initialization magic.
-	 * Please consider other ways of solving initialization problems before
-	 * using this callback, as its use is discouraged.
-	 */
-	if (core->ops->init)
-		core->ops->init(core->hw);
-
 	kref_init(&core->ref);
 out:
 	clk_pm_runtime_put(core);

commit 04bf9ab3359ff89059509ee5c35446c45b9cdaaa
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Wed Feb 14 14:43:35 2018 +0100

    clk: fix determine rate error with pass-through clock
    
    If we try to determine the rate of a pass-through clock (a clock which
    does not implement .round_rate() nor .determine_rate()),
    clk_core_round_rate_nolock() will directly forward the call to the
    parent clock. In the particular case where the pass-through actually
    does not have a parent, clk_core_round_rate_nolock() will directly
    return 0 with the requested rate still set to the initial request
    structure. This is interpreted as if the rate could be exactly achieved
    while it actually cannot be adjusted.
    
    This become a real problem when this particular pass-through clock is
    the parent of a mux with the flag CLK_SET_RATE_PARENT set. The
    pass-through clock will always report an exact match, get picked and
    finally error when the rate is actually getting set.
    
    This is fixed by setting the rate inside the req to 0 when core is NULL
    in clk_core_round_rate_nolock() (same as in __clk_determine_rate() when
    hw is NULL)
    
    Fixes: 0f6cc2b8e94d ("clk: rework calls to round and determine rate callbacks")
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 6d54e933c901..cca05ea2c058 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1125,8 +1125,10 @@ static int clk_core_round_rate_nolock(struct clk_core *core,
 {
 	lockdep_assert_held(&prepare_lock);
 
-	if (!core)
+	if (!core) {
+		req->rate = 0;
 		return 0;
+	}
 
 	clk_core_init_rate_req(core, req);
 

commit 99652a469df19086d594e8e89757d4081a812789
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Wed Feb 14 14:43:36 2018 +0100

    clk: migrate the count of orphaned clocks at init
    
    The orphan clocks reparents should migrate any existing count from the
    orphan clock to its new acestor clocks, otherwise we may have
    inconsistent counts in the tree and end-up with gated critical clocks
    
    Assuming we have two clocks, A and B.
    * Clock A has CLK_IS_CRITICAL flag set.
    * Clock B is an ancestor of A which can gate. Clock B gate is left
      enabled by the bootloader.
    
    Step 1: Clock A is registered. Since it is a critical clock, it is
    enabled. The clock being still an orphan, no parent are enabled.
    
    Step 2: Clock B is registered and reparented to clock A (potentially
    through several other clocks). We are now in situation where the enable
    count of clock A is 1 while the enable count of its ancestors is 0, which
    is not good.
    
    Step 3: in lateinit, clk_disable_unused() is called, the enable_count of
    clock B being 0, clock B is gated and and critical clock A actually gets
    disabled.
    
    This situation was found while adding fdiv_clk gates to the meson8b
    platform.  These clocks parent clk81 critical clock, which is the mother
    of all peripheral clocks in this system. Because of the issue described
    here, the system is crashing when clk_disable_unused() is called.
    
    The situation is solved by reverting
    commit f8f8f1d04494 ("clk: Don't touch hardware when reparenting during registration").
    To avoid breaking again the situation described in this commit
    description, enabling critical clock should be done before walking the
    orphan list. This way, a parent critical clock may not be accidentally
    disabled due to the CLK_OPS_PARENT_ENABLE mechanism.
    
    Fixes: f8f8f1d04494 ("clk: Don't touch hardware when reparenting during registration")
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0f686a9dac3e..6d54e933c901 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2967,23 +2967,38 @@ static int __clk_core_init(struct clk_core *core)
 		rate = 0;
 	core->rate = core->req_rate = rate;
 
+	/*
+	 * Enable CLK_IS_CRITICAL clocks so newly added critical clocks
+	 * don't get accidentally disabled when walking the orphan tree and
+	 * reparenting clocks
+	 */
+	if (core->flags & CLK_IS_CRITICAL) {
+		unsigned long flags;
+
+		clk_core_prepare(core);
+
+		flags = clk_enable_lock();
+		clk_core_enable(core);
+		clk_enable_unlock(flags);
+	}
+
 	/*
 	 * walk the list of orphan clocks and reparent any that newly finds a
 	 * parent.
 	 */
 	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
 		struct clk_core *parent = __clk_init_parent(orphan);
-		unsigned long flags;
 
 		/*
-		 * we could call __clk_set_parent, but that would result in a
-		 * redundant call to the .set_rate op, if it exists
+		 * We need to use __clk_set_parent_before() and _after() to
+		 * to properly migrate any prepare/enable count of the orphan
+		 * clock. This is important for CLK_IS_CRITICAL clocks, which
+		 * are enabled during init but might not have a parent yet.
 		 */
 		if (parent) {
 			/* update the clk tree topology */
-			flags = clk_enable_lock();
-			clk_reparent(orphan, parent);
-			clk_enable_unlock(flags);
+			__clk_set_parent_before(orphan, parent);
+			__clk_set_parent_after(orphan, parent, NULL);
 			__clk_recalc_accuracies(orphan);
 			__clk_recalc_rates(orphan, 0);
 		}
@@ -3000,16 +3015,6 @@ static int __clk_core_init(struct clk_core *core)
 	if (core->ops->init)
 		core->ops->init(core->hw);
 
-	if (core->flags & CLK_IS_CRITICAL) {
-		unsigned long flags;
-
-		clk_core_prepare(core);
-
-		flags = clk_enable_lock();
-		clk_core_enable(core);
-		clk_enable_unlock(flags);
-	}
-
 	kref_init(&core->ref);
 out:
 	clk_pm_runtime_put(core);

commit 7f95beea36089918335eb1810ddd7ba8cf9d09cc
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Thu Mar 8 14:49:41 2018 +0800

    clk: update cached phase to respect the fact when setting phase
    
    It's found that the final phase set by driver doesn't match that of
    the output from clk_summary:
    
    dwmmc_rockchip fe310000.dwmmc: Successfully tuned phase to 346
    mmc0: new ultra high speed SDR104 SDIO card at address 0001
    
    cat /sys/kernel/debug/clk/clk_summary | grep sdio_sample
    sdio_sample     0        1        0    50000000 0 0
    
    It seems the cached core->phase isn't updated after the clk was
    registered. So fix this issue by updating the core->phase if setting
    phase successfully.
    
    Fixes: 9e4d04adeb1a ("clk: add clk_core_set_phase_nolock function")
    Cc: Stable <stable@vger.kernel.org>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Reviewed-by: Jerome Brunet <jbrunet@baylibre.com>
    Tested-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0f686a9dac3e..617e56268b18 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2309,8 +2309,11 @@ static int clk_core_set_phase_nolock(struct clk_core *core, int degrees)
 
 	trace_clk_set_phase(core, degrees);
 
-	if (core->ops->set_phase)
+	if (core->ops->set_phase) {
 		ret = core->ops->set_phase(core->hw, degrees);
+		if (!ret)
+			core->phase = degrees;
+	}
 
 	trace_clk_set_phase_complete(core, degrees);
 

commit 3879ae653a3e98380fe2daf653338830b7ca0097
Merge: fe53d1443a14 c43a52cfd27b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 16:56:07 2018 -0800

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "The core framework has a handful of patches this time around, mostly
      due to the clk rate protection support added by Jerome Brunet.
    
      This feature will allow consumers to lock in a certain rate on the
      output of a clk so that things like audio playback don't hear pops
      when the clk frequency changes due to shared parent clks changing
      rates. Currently the clk API doesn't guarantee the rate of a clk stays
      at the rate you request after clk_set_rate() is called, so this new
      API will allow drivers to express that requirement.
    
      Beyond this, the core got some debugfs pretty printing patches and a
      couple minor non-critical fixes.
    
      Looking outside of the core framework diff we have some new driver
      additions and the removal of a legacy TI clk driver. Both of these hit
      high in the dirstat. Also, the removal of the asm-generic/clkdev.h
      file causes small one-liners in all the architecture Kbuild files.
    
      Overall, the driver diff seems to be the normal stuff that comes all
      the time to fix little problems here and there and to support new
      hardware.
    
      Summary:
    
      Core:
       - Clk rate protection
       - Symbolic clk flags in debugfs output
       - Clk registration enabled clks while doing bookkeeping updates
    
      New Drivers:
       - Spreadtrum SC9860
       - HiSilicon hi3660 stub
       - Qualcomm A53 PLL, SPMI clkdiv, and MSM8916 APCS
       - Amlogic Meson-AXG
       - ASPEED BMC
    
      Removed Drivers:
       - TI OMAP 3xxx legacy clk (non-DT) support
       - asm*/clkdev.h got removed (not really a driver)
    
      Updates:
       - Renesas FDP1-0 module clock on R-Car M3-W
       - Renesas LVDS module clock on R-Car V3M
       - Misc fixes to pr_err() prints
       - Qualcomm MSM8916 audio fixes
       - Qualcomm IPQ8074 rounded out support for more peripherals
       - Qualcomm Alpha PLL variants
       - Divider code was using container_of() on bad pointers
       - Allwinner DE2 clks on H3
       - Amlogic minor data fixes and dropping of CLK_IGNORE_UNUSED
       - Mediatek clk driver compile test support
       - AT91 PMC clk suspend/resume restoration support
       - PLL issues fixed on si5351
       - Broadcom IProc PLL calculation updates
       - DVFS support for Armada mvebu CPU clks
       - Allwinner fixed post-divider support
       - TI clkctrl fixes and support for newer SoCs"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (125 commits)
      clk: aspeed: Handle inverse polarity of USB port 1 clock gate
      clk: aspeed: Fix return value check in aspeed_cc_init()
      clk: aspeed: Add reset controller
      clk: aspeed: Register gated clocks
      clk: aspeed: Add platform driver and register PLLs
      clk: aspeed: Register core clocks
      clk: Add clock driver for ASPEED BMC SoCs
      clk: mediatek: adjust dependency of reset.c to avoid unexpectedly being built
      clk: fix reentrancy of clk_enable() on UP systems
      clk: meson-axg: fix potential NULL dereference in axg_clkc_probe()
      clk: Simplify debugfs registration
      clk: Fix debugfs_create_*() usage
      clk: Show symbolic clock flags in debugfs
      clk: renesas: r8a7796: Add FDP clock
      clk: Move __clk_{get,put}() into private clk.h API
      clk: sunxi: Use CLK_IS_CRITICAL flag for critical clks
      clk: Improve flags doc for of_clk_detect_critical()
      arch: Remove clkdev.h asm-generic from Kbuild
      clk: sunxi-ng: a83t: Add M divider to TCON1 clock
      clk: Prepare to remove asm-generic/clkdev.h
      ...

commit c43a52cfd27b20292d19d924eddfa5ff8dce87e5
Merge: 4d1d13a5ae8d 6671507f0fbd a12aa8a68dfe bc27360b3c7a ef0e5f382f50
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jan 26 16:43:39 2018 -0800

    Merge branches 'clk-aspeed', 'clk-lock-UP', 'clk-mediatek' and 'clk-allwinner' into clk-next
    
    * clk-aspeed:
      clk: aspeed: Handle inverse polarity of USB port 1 clock gate
      clk: aspeed: Fix return value check in aspeed_cc_init()
      clk: aspeed: Add reset controller
      clk: aspeed: Register gated clocks
      clk: aspeed: Add platform driver and register PLLs
      clk: aspeed: Register core clocks
      clk: Add clock driver for ASPEED BMC SoCs
      dt-bindings: clock: Add ASPEED constants
    
    * clk-lock-UP:
      clk: fix reentrancy of clk_enable() on UP systems
    
    * clk-mediatek:
      clk: mediatek: adjust dependency of reset.c to avoid unexpectedly being built
      clk: mediatek: Fix all warnings for missing struct clk_onecell_data
      clk: mediatek: fixup test-building of MediaTek clock drivers
      clk: mediatek: group drivers under indpendent menu
    
    * clk-allwinner:
      clk: sunxi-ng: a83t: Add M divider to TCON1 clock
      clk: sunxi-ng: fix the A64/H5 clock description of DE2 CCU
      clk: sunxi-ng: add support for Allwinner H3 DE2 CCU
      dt-bindings: fix the binding of Allwinner DE2 CCU of A83T and H3
      clk: sunxi-ng: sun8i: a83t: Use sigma-delta modulation for audio PLL
      clk: sunxi-ng: sun8i: a83t: Add /2 fixed post divider to audio PLL
      clk: sunxi-ng: Support fixed post-dividers on NM style clocks
      clk: sunxi-ng: sun50i: a64: Add 2x fixed post-divider to MMC module clocks
      clk: sunxi-ng: Support fixed post-dividers on MP style clocks
      clk: sunxi: Use PTR_ERR_OR_ZERO()

commit 4d1d13a5ae8d468923106d5b05de407bc25cefa2
Merge: 716d9b1d4a88 bfc0cbfcad12 db3188fadfe6 ade98cbc2bf0 9d548d803847
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jan 26 16:43:32 2018 -0800

    Merge branches 'clk-remove-asm-clkdev', 'clk-debugfs-fixes', 'clk-renesas' and 'clk-meson' into clk-next
    
    * clk-remove-asm-clkdev:
      clk: Move __clk_{get,put}() into private clk.h API
      clk: sunxi: Use CLK_IS_CRITICAL flag for critical clks
      arch: Remove clkdev.h asm-generic from Kbuild
      clk: Prepare to remove asm-generic/clkdev.h
      blackfin: Use generic clkdev.h header
    
    * clk-debugfs-fixes:
      clk: Simplify debugfs registration
      clk: Fix debugfs_create_*() usage
      clk: Show symbolic clock flags in debugfs
      clk: Improve flags doc for of_clk_detect_critical()
    
    * clk-renesas:
      clk: renesas: r8a7796: Add FDP clock
      clk: renesas: cpg-mssr: Keep wakeup sources active during system suspend
      clk: renesas: mstp: Keep wakeup sources active during system suspend
      clk: renesas: r8a77970: Add LVDS clock
    
    * clk-meson:
      clk: meson-axg: fix potential NULL dereference in axg_clkc_probe()
      clk: meson-axg: make local symbol axg_gp0_params_table static
      clk: meson-axg: fix return value check in axg_clkc_probe()
      clk: meson: mpll: use 64-bit maths in params_from_rate
      clk: meson-axg: add clock controller drivers
      clk: meson-axg: add clocks dt-bindings required header
      dt-bindings: clock: add compatible variant for the Meson-AXG
      clk: meson: make the spinlock naming more specific
      clk: meson: gxbb: remove IGNORE_UNUSED from mmc clocks
      clk: meson: gxbb: fix wrong clock for SARADC/SANA

commit a2c09c12d4e1935807d02d58d2a338fa74554305
Merge: 21170e3bda0e 13967bea0bdb f8f8f1d04494 448c3c057a1d 0136f852be24 869de5cf96cf
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jan 26 16:41:52 2018 -0800

    Merge branches 'clk-at91', 'clk-imx7ulp', 'clk-axigen', 'clk-si5351' and 'clk-pxa' into clk-next
    
    * clk-at91:
      clk: at91: pmc: Support backup for programmable clocks
      clk: at91: pmc: Save SCSR during suspend
      clk: at91: pmc: Wait for clocks when resuming
    
    * clk-imx7ulp:
      clk: Don't touch hardware when reparenting during registration
    
    * clk-axigen:
      clk: axi-clkgen: Round closest in round_rate() and recalc_rate()
      clk: axi-clkgen: Correctly handle nocount bit in recalc_rate()
    
    * clk-si5351:
      clk: si5351: _si5351_clkout_reset_pll() can be static
      clk: si5351: Do not enable parent clocks on probe
      clk: si5351: Rename internal plls to avoid name collisions
      clk: si5351: Apply PLL soft reset before enabling the outputs
      clk: si5351: Add DT property to enable PLL reset
      clk: si5351: implement remove handler
    
    * clk-pxa:
      clk: pxa: unbreak lookup of CLK_POUT

commit 74b48999b1c80f42ad0477341aac7249d2641b04
Merge: 90552a6f9312 23c68cc9683e 29fd2a34ef8d 6562fbcf3ad5 7956a0319ead
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jan 26 16:41:39 2018 -0800

    Merge branches 'clk-qcom-alpha-pll', 'clk-check-ops-ptr', 'clk-protect-rate' and 'clk-omap' into clk-next
    
    * clk-qcom-alpha-pll:
      clk: qcom: add read-only alpha pll post divider operations
      clk: qcom: support for 2 bit PLL post divider
      clk: qcom: support Brammo type Alpha PLL
      clk: qcom: support Huayra type Alpha PLL
      clk: qcom: support for dynamic updating the PLL
      clk: qcom: support for alpha mode configuration
      clk: qcom: flag for 64 bit CONFIG_CTL
      clk: qcom: fix 16 bit alpha support calculation
      clk: qcom: support for alpha pll properties
    
    * clk-check-ops-ptr:
      clk: check ops pointer on clock register
    
    * clk-protect-rate:
      clk: fix set_rate_range when current rate is out of range
      clk: add clk_rate_exclusive api
      clk: cosmetic changes to clk_summary debugfs entry
      clk: add clock protection mechanism to clk core
      clk: use round rate to bail out early in set_rate
      clk: rework calls to round and determine rate callbacks
      clk: add clk_core_set_phase_nolock function
      clk: take the prepare lock out of clk_core_set_parent
      clk: fix incorrect usage of ENOSYS
    
    * clk-omap:
      clk: ti: Drop legacy clk-3xxx-legacy code

commit a12aa8a68dfef5de181f2e555aa950a0ab05411f
Author: David Lechner <david@lechnology.com>
Date:   Thu Jan 4 19:46:08 2018 -0600

    clk: fix reentrancy of clk_enable() on UP systems
    
    Reentrant calls to clk_enable() are not working on UP systems. This is
    caused by the fact spin_trylock_irqsave() always returns true when
    CONFIG_SMP=n (and CONFIG_DEBUG_SPINLOCK=n) which causes the reference
    counting to not work correctly when clk_enable_lock() is called twice
    before clk_enable_unlock() is called (this happens when clk_enable()
    is called from within another clk_enable()).
    
    This fixes the problem by skipping the call to spin_trylock_irqsave() on UP
    systems and relying solely on reference counting. We also make sure to set
    flags in this case so that we are not returning an uninitialized value.
    
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 647d056df88c..b221d80cc7ba 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -141,10 +141,18 @@ static unsigned long clk_enable_lock(void)
 {
 	unsigned long flags;
 
-	if (!spin_trylock_irqsave(&enable_lock, flags)) {
+	/*
+	 * On UP systems, spin_trylock_irqsave() always returns true, even if
+	 * we already hold the lock. So, in that case, we rely only on
+	 * reference counting.
+	 */
+	if (!IS_ENABLED(CONFIG_SMP) ||
+	    !spin_trylock_irqsave(&enable_lock, flags)) {
 		if (enable_owner == current) {
 			enable_refcnt++;
 			__acquire(enable_lock);
+			if (!IS_ENABLED(CONFIG_SMP))
+				local_save_flags(flags);
 			return flags;
 		}
 		spin_lock_irqsave(&enable_lock, flags);

commit db3188fadfe6af73d2485131a6975c032306e1ea
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jan 3 16:44:37 2018 -0800

    clk: Simplify debugfs registration
    
    We don't need a goto here. Drop it.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c8ea2dd32251..0a52357ded5c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2723,12 +2723,8 @@ static int clk_debug_register(struct clk_core *core)
 
 	mutex_lock(&clk_debug_lock);
 	hlist_add_head(&core->debug_node, &clk_debug_list);
-
-	if (!inited)
-		goto unlock;
-
-	ret = clk_debug_create_one(core, rootdir);
-unlock:
+	if (inited)
+		ret = clk_debug_create_one(core, rootdir);
 	mutex_unlock(&clk_debug_lock);
 
 	return ret;

commit 4c8326d5ebb0de3191e98980c80ab644026728d0
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jan 3 12:06:15 2018 +0100

    clk: Fix debugfs_create_*() usage
    
    When exposing data access through debugfs, the correct
    debugfs_create_*() functions must be used, matching the data
    types.
    
    Remove all casts from data pointers passed to debugfs_create_*()
    functions, as such casts prevent the compiler from flagging bugs.
    
    clk_core.rate and .accuracy are "unsigned long", hence casting
    their addresses to "u32 *" exposed the wrong halves on big-endian
    64-bit systems. Fix this by using debugfs_create_ulong() instead.
    
    Octal permissions are preferred, as they are easier to read than
    symbolic permissions. Hence replace "S_IRUGO" by "0444"
    throughout.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    [sboyd@codeaurora.org: Squash the octal change in too]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 479a3ee9cfe2..c8ea2dd32251 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2648,18 +2648,16 @@ static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 
 	core->dentry = d;
 
-	d = debugfs_create_u32("clk_rate", S_IRUGO, core->dentry,
-			(u32 *)&core->rate);
+	d = debugfs_create_ulong("clk_rate", 0444, core->dentry, &core->rate);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_accuracy", S_IRUGO, core->dentry,
-			(u32 *)&core->accuracy);
+	d = debugfs_create_ulong("clk_accuracy", 0444, core->dentry,
+				 &core->accuracy);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_phase", S_IRUGO, core->dentry,
-			(u32 *)&core->phase);
+	d = debugfs_create_u32("clk_phase", 0444, core->dentry, &core->phase);
 	if (!d)
 		goto err_out;
 
@@ -2668,28 +2666,28 @@ static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_prepare_count", S_IRUGO, core->dentry,
-			(u32 *)&core->prepare_count);
+	d = debugfs_create_u32("clk_prepare_count", 0444, core->dentry,
+			       &core->prepare_count);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_enable_count", S_IRUGO, core->dentry,
-			(u32 *)&core->enable_count);
+	d = debugfs_create_u32("clk_enable_count", 0444, core->dentry,
+			       &core->enable_count);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_protect_count", S_IRUGO, core->dentry,
-			(u32 *)&core->protect_count);
+	d = debugfs_create_u32("clk_protect_count", 0444, core->dentry,
+			       &core->protect_count);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_notifier_count", S_IRUGO, core->dentry,
-			(u32 *)&core->notifier_count);
+	d = debugfs_create_u32("clk_notifier_count", 0444, core->dentry,
+			       &core->notifier_count);
 	if (!d)
 		goto err_out;
 
 	if (core->num_parents > 1) {
-		d = debugfs_create_file("clk_possible_parents", S_IRUGO,
+		d = debugfs_create_file("clk_possible_parents", 0444,
 				core->dentry, core, &possible_parents_fops);
 		if (!d)
 			goto err_out;
@@ -2785,22 +2783,22 @@ static int __init clk_debug_init(void)
 	if (!rootdir)
 		return -ENOMEM;
 
-	d = debugfs_create_file("clk_summary", S_IRUGO, rootdir, &all_lists,
+	d = debugfs_create_file("clk_summary", 0444, rootdir, &all_lists,
 				&clk_summary_fops);
 	if (!d)
 		return -ENOMEM;
 
-	d = debugfs_create_file("clk_dump", S_IRUGO, rootdir, &all_lists,
+	d = debugfs_create_file("clk_dump", 0444, rootdir, &all_lists,
 				&clk_dump_fops);
 	if (!d)
 		return -ENOMEM;
 
-	d = debugfs_create_file("clk_orphan_summary", S_IRUGO, rootdir,
+	d = debugfs_create_file("clk_orphan_summary", 0444, rootdir,
 				&orphan_list, &clk_summary_fops);
 	if (!d)
 		return -ENOMEM;
 
-	d = debugfs_create_file("clk_orphan_dump", S_IRUGO, rootdir,
+	d = debugfs_create_file("clk_orphan_dump", 0444, rootdir,
 				&orphan_list, &clk_dump_fops);
 	if (!d)
 		return -ENOMEM;

commit a6059ab98130fb561157682d320c51c5ccd4b647
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jan 3 12:06:16 2018 +0100

    clk: Show symbolic clock flags in debugfs
    
    Currently the virtual "clk_flags" file in debugfs shows the numeric
    value of the top-level framework flags for the specified clock.
    Hence the user must manually interpret these values.
    
    Moreover, on big-endian 64-bit systems, the wrong half of the value is
    shown, due to the cast from "unsigned long *" to "u32 *".
    
    Fix both issues by showing the symbolic flag names instead.
    Any non-standard flags are shown as a hex number.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fe2d43e34216..479a3ee9cfe2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -24,6 +24,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/clkdev.h>
+#include <linux/stringify.h>
 
 #include "clk.h"
 
@@ -2554,6 +2555,58 @@ static const struct file_operations clk_dump_fops = {
 	.release	= single_release,
 };
 
+static const struct {
+	unsigned long flag;
+	const char *name;
+} clk_flags[] = {
+#define ENTRY(f) { f, __stringify(f) }
+	ENTRY(CLK_SET_RATE_GATE),
+	ENTRY(CLK_SET_PARENT_GATE),
+	ENTRY(CLK_SET_RATE_PARENT),
+	ENTRY(CLK_IGNORE_UNUSED),
+	ENTRY(CLK_IS_BASIC),
+	ENTRY(CLK_GET_RATE_NOCACHE),
+	ENTRY(CLK_SET_RATE_NO_REPARENT),
+	ENTRY(CLK_GET_ACCURACY_NOCACHE),
+	ENTRY(CLK_RECALC_NEW_RATES),
+	ENTRY(CLK_SET_RATE_UNGATE),
+	ENTRY(CLK_IS_CRITICAL),
+	ENTRY(CLK_OPS_PARENT_ENABLE),
+#undef ENTRY
+};
+
+static int clk_flags_dump(struct seq_file *s, void *data)
+{
+	struct clk_core *core = s->private;
+	unsigned long flags = core->flags;
+	unsigned int i;
+
+	for (i = 0; flags && i < ARRAY_SIZE(clk_flags); i++) {
+		if (flags & clk_flags[i].flag) {
+			seq_printf(s, "%s\n", clk_flags[i].name);
+			flags &= ~clk_flags[i].flag;
+		}
+	}
+	if (flags) {
+		/* Unknown flags */
+		seq_printf(s, "0x%lx\n", flags);
+	}
+
+	return 0;
+}
+
+static int clk_flags_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clk_flags_dump, inode->i_private);
+}
+
+static const struct file_operations clk_flags_fops = {
+	.open		= clk_flags_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static int possible_parents_dump(struct seq_file *s, void *data)
 {
 	struct clk_core *core = s->private;
@@ -2610,8 +2663,8 @@ static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_x32("clk_flags", S_IRUGO, core->dentry,
-			(u32 *)&core->flags);
+	d = debugfs_create_file("clk_flags", 0444, core->dentry, core,
+				&clk_flags_fops);
 	if (!d)
 		goto err_out;
 

commit f7ae75036762618ecc2cc7ae6fb4f6a74af92afb
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jan 3 12:06:14 2018 +0100

    clk: Improve flags doc for of_clk_detect_critical()
    
    The "flags" parameter passed to of_clk_detect_critical() cannot be a
    pointer to a real clk_core.flags field, as clk_core is private to the
    clock framework internals.
    
    Change the comment to refer to top-level framework flags instead.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index efbc802da3b3..fe2d43e34216 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3912,7 +3912,7 @@ static int parent_ready(struct device_node *np)
  * of_clk_detect_critical() - set CLK_IS_CRITICAL flag from Device Tree
  * @np: Device node pointer associated with clock provider
  * @index: clock index
- * @flags: pointer to clk_core->flags
+ * @flags: pointer to top-level framework flags
  *
  * Detects if the clock-critical property exists and, if so, sets the
  * corresponding CLK_IS_CRITICAL flag.

commit 756efe131088b6e6e7f0124ff9c4e1f0165d3140
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Fri Dec 22 17:46:04 2017 +0800

    clk: use atomic runtime pm api in clk_core_is_enabled
    
    Current clk_pm_runtime_put is using pm_runtime_put_sync which
    is not safe to be called in clk_core_is_enabled as it should
    be able to run in atomic context.
    
    Thus use pm_runtime_put instead which is atomic safe.
    
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Fixes: 9a34b45397e5 ("clk: Add support for runtime PM")
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8a1860a36c77..b56c11f51baf 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -220,7 +220,8 @@ static bool clk_core_is_enabled(struct clk_core *core)
 
 	ret = core->ops->is_enabled(core->hw);
 done:
-	clk_pm_runtime_put(core);
+	if (core->dev)
+		pm_runtime_put(core->dev);
 
 	return ret;
 }

commit f8f8f1d04494d3a6546bee3f0618c4dba31d7b72
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Nov 2 00:36:09 2017 -0700

    clk: Don't touch hardware when reparenting during registration
    
    The orphan clocks reparent operation shouldn't touch the hardware
    if clocks are enabled, otherwise it may get a chance to disable a
    newly registered critical clock which triggers the warning below.
    
    Assuming we have two clocks: A and B, B is the parent of A.
    Clock A has flag: CLK_OPS_PARENT_ENABLE
    Clock B has flag: CLK_IS_CRITICAL
    
    Step 1:
    Clock A is registered, then it becomes orphan.
    
    Step 2:
    Clock B is registered. Before clock B reach the critical clock enable
    operation, orphan A will find the newly registered parent B and do
    reparent operation, then parent B will be finally disabled in
    __clk_set_parent_after() due to CLK_OPS_PARENT_ENABLE flag as there's
    still no users of B which will then trigger the following warning.
    
    WARNING: CPU: 0 PID: 0 at drivers/clk/clk.c:597 clk_core_disable+0xb4/0xe0
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.11.0-rc1-00056-gdff1f66-dirty #1373
    Hardware name: Generic DT based system
    Backtrace:
    [<c010c4bc>] (dump_backtrace) from [<c010c764>] (show_stack+0x18/0x1c)
     r6:600000d3 r5:00000000 r4:c0e26358 r3:00000000
    [<c010c74c>] (show_stack) from [<c040599c>] (dump_stack+0xb4/0xe8)
    [<c04058e8>] (dump_stack) from [<c0125c94>] (__warn+0xd8/0x104)
     r10:c0c21cd0 r9:c048aa78 r8:00000255 r7:00000009 r6:c0c1cd90 r5:00000000
     r4:00000000 r3:c0e01d34
    [<c0125bbc>] (__warn) from [<c0125d74>] (warn_slowpath_null+0x28/0x30)
     r9:00000000 r8:ef00bf80 r7:c165ac4c r6:ef00bf80 r5:ef00bf80 r4:ef00bf80
    [<c0125d4c>] (warn_slowpath_null) from [<c048aa78>] (clk_core_disable+0xb4/0xe0)
    [<c048a9c4>] (clk_core_disable) from [<c048be88>] (clk_core_disable_lock+0x20/0x2c)
     r4:000000d3 r3:c0e0af00
    [<c048be68>] (clk_core_disable_lock) from [<c048c224>] (clk_core_disable_unprepare+0x14/0x28)
     r5:00000000 r4:ef00bf80
    [<c048c210>] (clk_core_disable_unprepare) from [<c048c270>] (__clk_set_parent_after+0x38/0x54)
     r4:ef00bd80 r3:000010a0
    [<c048c238>] (__clk_set_parent_after) from [<c048daa8>] (clk_register+0x4d0/0x648)
     r6:ef00d500 r5:ef00bf80 r4:ef00bd80 r3:ef00bfd4
    [<c048d5d8>] (clk_register) from [<c048dc30>] (clk_hw_register+0x10/0x1c)
     r9:00000000 r8:00000003 r7:00000000 r6:00000824 r5:00000001 r4:ef00d500
    [<c048dc20>] (clk_hw_register) from [<c048e698>] (_register_divider+0xcc/0x120)
    [<c048e5cc>] (_register_divider) from [<c048e730>] (clk_register_divider+0x44/0x54)
     r10:00000004 r9:00000003 r8:00000001 r7:00000000 r6:00000003 r5:00000001
     r4:f0810030
    [<c048e6ec>] (clk_register_divider) from [<c0d3ff58>] (imx7ulp_clocks_init+0x558/0xe98)
     r7:c0e296f8 r6:c165c808 r5:00000000 r4:c165c808
    [<c0d3fa00>] (imx7ulp_clocks_init) from [<c0d24db0>] (of_clk_init+0x118/0x1e0)
     r10:00000001 r9:c0e01f68 r8:00000000 r7:c0e01f60 r6:ef7f8974 r5:ef0035c0
     r4:00000006
    [<c0d24c98>] (of_clk_init) from [<c0d04a50>] (time_init+0x2c/0x38)
     r10:efffed40 r9:c0d61a48 r8:c0e78000 r7:c0e07900 r6:ffffffff r5:c0e78000
     r4:00000000
    [<c0d04a24>] (time_init) from [<c0d00b8c>] (start_kernel+0x218/0x394)
    [<c0d00974>] (start_kernel) from [<6000807c>] (0x6000807c)
     r10:00000000 r9:410fc075 r8:6000406a r7:c0e0c930 r6:c0d61a44 r5:c0e07918
     r4:c0e78294
    
    We know that the clk isn't enabled with any sort of prepare_count
    here so we don't need to enable anything to prevent a race. And
    we're holding the prepare mutex so set_rate/set_parent can't race
    here either. Based on an earlier patch by Dong Aisheng.
    
    Fixes: fc8726a2c021 ("clk: core: support clocks which requires parents enable (part 2)")
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Reported-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 647d056df88c..999777a66505 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2570,14 +2570,17 @@ static int __clk_core_init(struct clk_core *core)
 	 */
 	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
 		struct clk_core *parent = __clk_init_parent(orphan);
+		unsigned long flags;
 
 		/*
 		 * we could call __clk_set_parent, but that would result in a
 		 * redundant call to the .set_rate op, if it exists
 		 */
 		if (parent) {
-			__clk_set_parent_before(orphan, parent);
-			__clk_set_parent_after(orphan, parent, NULL);
+			/* update the clk tree topology */
+			flags = clk_enable_lock();
+			clk_reparent(orphan, parent);
+			clk_enable_unlock(flags);
 			__clk_recalc_accuracies(orphan);
 			__clk_recalc_rates(orphan, 0);
 		}

commit 6562fbcf3ad5ffa56f1fc79bb1afae909cf3627b
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:52:00 2017 +0100

    clk: fix set_rate_range when current rate is out of range
    
    Calling clk_core_set_rate() with core->req_rate is basically a no-op
    because of the early bail-out mechanism.
    
    This may leave the clock in inconsistent state if the rate is out the
    requested range. Calling clk_core_set_rate() with the closest rate
    limit could solve the problem but:
    - The underlying determine_rate() callback needs to account for this
      corner case (rounding within the range, if possible)
    - if only round_rate() is available, we rely on luck unfortunately.
    
    Fixes: 1c8e600440c7 ("clk: Add rate constraints to clocks")
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-11-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8e728f395b54..efbc802da3b3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2000,6 +2000,7 @@ EXPORT_SYMBOL_GPL(clk_set_rate_exclusive);
 int clk_set_rate_range(struct clk *clk, unsigned long min, unsigned long max)
 {
 	int ret = 0;
+	unsigned long old_min, old_max, rate;
 
 	if (!clk)
 		return 0;
@@ -2016,10 +2017,38 @@ int clk_set_rate_range(struct clk *clk, unsigned long min, unsigned long max)
 	if (clk->exclusive_count)
 		clk_core_rate_unprotect(clk->core);
 
-	if (min != clk->min_rate || max != clk->max_rate) {
-		clk->min_rate = min;
-		clk->max_rate = max;
-		ret = clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
+	/* Save the current values in case we need to rollback the change */
+	old_min = clk->min_rate;
+	old_max = clk->max_rate;
+	clk->min_rate = min;
+	clk->max_rate = max;
+
+	rate = clk_core_get_rate_nolock(clk->core);
+	if (rate < min || rate > max) {
+		/*
+		 * FIXME:
+		 * We are in bit of trouble here, current rate is outside the
+		 * the requested range. We are going try to request appropriate
+		 * range boundary but there is a catch. It may fail for the
+		 * usual reason (clock broken, clock protected, etc) but also
+		 * because:
+		 * - round_rate() was not favorable and fell on the wrong
+		 *   side of the boundary
+		 * - the determine_rate() callback does not really check for
+		 *   this corner case when determining the rate
+		 */
+
+		if (rate < min)
+			rate = min;
+		else
+			rate = max;
+
+		ret = clk_core_set_rate_nolock(clk->core, rate);
+		if (ret) {
+			/* rollback the changes */
+			clk->min_rate = old_min;
+			clk->max_rate = old_max;
+		}
 	}
 
 	if (clk->exclusive_count)

commit 55e9b8b7b806ec3f9a8817e13596682a5981c19c
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:59 2017 +0100

    clk: add clk_rate_exclusive api
    
    Using clock rate protection, we can now provide a way for clock consumer
    to claim exclusive control over the rate of a producer
    
    So far, rate change operations have been a "last write wins" affair. This
    changes allows drivers to explicitly protect against this behavior, if
    required.
    
    Of course, if exclusivity over a producer is claimed more than once, the
    rate is effectively locked as exclusivity cannot be preempted
    
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-10-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f6fe5e5595ca..8e728f395b54 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -87,6 +87,7 @@ struct clk {
 	const char *con_id;
 	unsigned long min_rate;
 	unsigned long max_rate;
+	unsigned int exclusive_count;
 	struct hlist_node clks_node;
 };
 
@@ -565,6 +566,45 @@ static int clk_core_rate_nuke_protect(struct clk_core *core)
 	return ret;
 }
 
+/**
+ * clk_rate_exclusive_put - release exclusivity over clock rate control
+ * @clk: the clk over which the exclusivity is released
+ *
+ * clk_rate_exclusive_put() completes a critical section during which a clock
+ * consumer cannot tolerate any other consumer making any operation on the
+ * clock which could result in a rate change or rate glitch. Exclusive clocks
+ * cannot have their rate changed, either directly or indirectly due to changes
+ * further up the parent chain of clocks. As a result, clocks up parent chain
+ * also get under exclusive control of the calling consumer.
+ *
+ * If exlusivity is claimed more than once on clock, even by the same consumer,
+ * the rate effectively gets locked as exclusivity can't be preempted.
+ *
+ * Calls to clk_rate_exclusive_put() must be balanced with calls to
+ * clk_rate_exclusive_get(). Calls to this function may sleep, and do not return
+ * error status.
+ */
+void clk_rate_exclusive_put(struct clk *clk)
+{
+	if (!clk)
+		return;
+
+	clk_prepare_lock();
+
+	/*
+	 * if there is something wrong with this consumer protect count, stop
+	 * here before messing with the provider
+	 */
+	if (WARN_ON(clk->exclusive_count <= 0))
+		goto out;
+
+	clk_core_rate_unprotect(clk->core);
+	clk->exclusive_count--;
+out:
+	clk_prepare_unlock();
+}
+EXPORT_SYMBOL_GPL(clk_rate_exclusive_put);
+
 static void clk_core_rate_protect(struct clk_core *core)
 {
 	lockdep_assert_held(&prepare_lock);
@@ -592,6 +632,38 @@ static void clk_core_rate_restore_protect(struct clk_core *core, int count)
 	core->protect_count = count;
 }
 
+/**
+ * clk_rate_exclusive_get - get exclusivity over the clk rate control
+ * @clk: the clk over which the exclusity of rate control is requested
+ *
+ * clk_rate_exlusive_get() begins a critical section during which a clock
+ * consumer cannot tolerate any other consumer making any operation on the
+ * clock which could result in a rate change or rate glitch. Exclusive clocks
+ * cannot have their rate changed, either directly or indirectly due to changes
+ * further up the parent chain of clocks. As a result, clocks up parent chain
+ * also get under exclusive control of the calling consumer.
+ *
+ * If exlusivity is claimed more than once on clock, even by the same consumer,
+ * the rate effectively gets locked as exclusivity can't be preempted.
+ *
+ * Calls to clk_rate_exclusive_get() should be balanced with calls to
+ * clk_rate_exclusive_put(). Calls to this function may sleep.
+ * Returns 0 on success, -EERROR otherwise
+ */
+int clk_rate_exclusive_get(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	clk_prepare_lock();
+	clk_core_rate_protect(clk->core);
+	clk->exclusive_count++;
+	clk_prepare_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(clk_rate_exclusive_get);
+
 static void clk_core_unprepare(struct clk_core *core)
 {
 	lockdep_assert_held(&prepare_lock);
@@ -988,6 +1060,12 @@ static int clk_core_determine_round_nolock(struct clk_core *core,
 	if (!core)
 		return 0;
 
+	/*
+	 * At this point, core protection will be disabled if
+	 * - if the provider is not protected at all
+	 * - if the calling consumer is the only one which has exclusivity
+	 *   over the provider
+	 */
 	if (clk_core_rate_is_protected(core)) {
 		req->rate = core->rate;
 	} else if (core->ops->determine_rate) {
@@ -1104,10 +1182,17 @@ long clk_round_rate(struct clk *clk, unsigned long rate)
 
 	clk_prepare_lock();
 
+	if (clk->exclusive_count)
+		clk_core_rate_unprotect(clk->core);
+
 	clk_core_get_boundaries(clk->core, &req.min_rate, &req.max_rate);
 	req.rate = rate;
 
 	ret = clk_core_round_rate_nolock(clk->core, &req);
+
+	if (clk->exclusive_count)
+		clk_core_rate_protect(clk->core);
+
 	clk_prepare_unlock();
 
 	if (ret)
@@ -1843,14 +1928,67 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	/* prevent racing with updates to the clock topology */
 	clk_prepare_lock();
 
+	if (clk->exclusive_count)
+		clk_core_rate_unprotect(clk->core);
+
 	ret = clk_core_set_rate_nolock(clk->core, rate);
 
+	if (clk->exclusive_count)
+		clk_core_rate_protect(clk->core);
+
 	clk_prepare_unlock();
 
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_set_rate);
 
+/**
+ * clk_set_rate_exclusive - specify a new rate get exclusive control
+ * @clk: the clk whose rate is being changed
+ * @rate: the new rate for clk
+ *
+ * This is a combination of clk_set_rate() and clk_rate_exclusive_get()
+ * within a critical section
+ *
+ * This can be used initially to ensure that at least 1 consumer is
+ * statisfied when several consumers are competing for exclusivity over the
+ * same clock provider.
+ *
+ * The exclusivity is not applied if setting the rate failed.
+ *
+ * Calls to clk_rate_exclusive_get() should be balanced with calls to
+ * clk_rate_exclusive_put().
+ *
+ * Returns 0 on success, -EERROR otherwise.
+ */
+int clk_set_rate_exclusive(struct clk *clk, unsigned long rate)
+{
+	int ret;
+
+	if (!clk)
+		return 0;
+
+	/* prevent racing with updates to the clock topology */
+	clk_prepare_lock();
+
+	/*
+	 * The temporary protection removal is not here, on purpose
+	 * This function is meant to be used instead of clk_rate_protect,
+	 * so before the consumer code path protect the clock provider
+	 */
+
+	ret = clk_core_set_rate_nolock(clk->core, rate);
+	if (!ret) {
+		clk_core_rate_protect(clk->core);
+		clk->exclusive_count++;
+	}
+
+	clk_prepare_unlock();
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_rate_exclusive);
+
 /**
  * clk_set_rate_range - set a rate range for a clock source
  * @clk: clock source
@@ -1875,12 +2013,18 @@ int clk_set_rate_range(struct clk *clk, unsigned long min, unsigned long max)
 
 	clk_prepare_lock();
 
+	if (clk->exclusive_count)
+		clk_core_rate_unprotect(clk->core);
+
 	if (min != clk->min_rate || max != clk->max_rate) {
 		clk->min_rate = min;
 		clk->max_rate = max;
 		ret = clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
 	}
 
+	if (clk->exclusive_count)
+		clk_core_rate_protect(clk->core);
+
 	clk_prepare_unlock();
 
 	return ret;
@@ -2091,8 +2235,16 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 		return 0;
 
 	clk_prepare_lock();
+
+	if (clk->exclusive_count)
+		clk_core_rate_unprotect(clk->core);
+
 	ret = clk_core_set_parent_nolock(clk->core,
 					 parent ? parent->core : NULL);
+
+	if (clk->exclusive_count)
+		clk_core_rate_protect(clk->core);
+
 	clk_prepare_unlock();
 
 	return ret;
@@ -2154,7 +2306,15 @@ int clk_set_phase(struct clk *clk, int degrees)
 		degrees += 360;
 
 	clk_prepare_lock();
+
+	if (clk->exclusive_count)
+		clk_core_rate_unprotect(clk->core);
+
 	ret = clk_core_set_phase_nolock(clk->core, degrees);
+
+	if (clk->exclusive_count)
+		clk_core_rate_protect(clk->core);
+
 	clk_prepare_unlock();
 
 	return ret;
@@ -3175,6 +3335,18 @@ void __clk_put(struct clk *clk)
 
 	clk_prepare_lock();
 
+	/*
+	 * Before calling clk_put, all calls to clk_rate_exclusive_get() from a
+	 * given user should be balanced with calls to clk_rate_exclusive_put()
+	 * and by that same consumer
+	 */
+	if (WARN_ON(clk->exclusive_count)) {
+		/* We voiced our concern, let's sanitize the situation */
+		clk->core->protect_count -= (clk->exclusive_count - 1);
+		clk_core_rate_unprotect(clk->core);
+		clk->exclusive_count = 0;
+	}
+
 	hlist_del(&clk->clks_node);
 	if (clk->min_rate > clk->core->req_rate ||
 	    clk->max_rate < clk->core->req_rate)

commit c5ce26edb4fec178232b9cb37f334ec574931514
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:57 2017 +0100

    clk: cosmetic changes to clk_summary debugfs entry
    
    clk_summary debugfs entry was already well over the traditional 80
    characters per line limit but it grew even larger with the addition of
    clock protection.
    
       clock                         enable_cnt  prepare_cnt  protect_cnt        rate   accuracy   phase
    ----------------------------------------------------------------------------------------------------
     wifi32k                                  1            1            0       32768          0 0
     vcpu                                     0            0            0  2016000000          0 0
     xtal                                     5            5            0    24000000          0 0
    
    This patch reduce the width a bit:
                                     enable  prepare  protect
       clock                          count    count    count        rate   accuracy   phase
    ----------------------------------------------------------------------------------------
     wifi32k                              1        1        0       32768          0 0
     vcpu                                 0        0        0  2016000000          0 0
     xtal                                 5        5        0    24000000          0 0
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-8-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f69a2176cde1..f6fe5e5595ca 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2241,7 +2241,7 @@ static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
 	if (!c)
 		return;
 
-	seq_printf(s, "%*s%-*s %11d %12d %12d %11lu %10lu %-3d\n",
+	seq_printf(s, "%*s%-*s %7d %8d %8d %11lu %10lu %-3d\n",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
 		   c->enable_count, c->prepare_count, c->protect_count,
@@ -2268,8 +2268,9 @@ static int clk_summary_show(struct seq_file *s, void *data)
 	struct clk_core *c;
 	struct hlist_head **lists = (struct hlist_head **)s->private;
 
-	seq_puts(s, "   clock                         enable_cnt  prepare_cnt  protect_cnt        rate   accuracy   phase\n");
-	seq_puts(s, "----------------------------------------------------------------------------------------------------\n");
+	seq_puts(s, "                                 enable  prepare  protect                               \n");
+	seq_puts(s, "   clock                          count    count    count        rate   accuracy   phase\n");
+	seq_puts(s, "----------------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 

commit e55a839a7a1c561b7d2fbd9cc50b7d40dd2b3361
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:56 2017 +0100

    clk: add clock protection mechanism to clk core
    
    The patch adds clk_core_protect and clk_core_unprotect to the internal
    CCF API. These functions allow to set a new constraint along the clock
    tree to prevent any change, even indirect, which may result in rate
    change or glitch.
    
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-7-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index bbe90babdae4..f69a2176cde1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -62,6 +62,7 @@ struct clk_core {
 	bool			orphan;
 	unsigned int		enable_count;
 	unsigned int		prepare_count;
+	unsigned int		protect_count;
 	unsigned long		min_rate;
 	unsigned long		max_rate;
 	unsigned long		accuracy;
@@ -170,6 +171,11 @@ static void clk_enable_unlock(unsigned long flags)
 	spin_unlock_irqrestore(&enable_lock, flags);
 }
 
+static bool clk_core_rate_is_protected(struct clk_core *core)
+{
+	return core->protect_count;
+}
+
 static bool clk_core_is_prepared(struct clk_core *core)
 {
 	bool ret = false;
@@ -381,6 +387,11 @@ bool clk_hw_is_prepared(const struct clk_hw *hw)
 	return clk_core_is_prepared(hw->core);
 }
 
+bool clk_hw_rate_is_protected(const struct clk_hw *hw)
+{
+	return clk_core_rate_is_protected(hw->core);
+}
+
 bool clk_hw_is_enabled(const struct clk_hw *hw)
 {
 	return clk_core_is_enabled(hw->core);
@@ -519,6 +530,68 @@ EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
 
 /***        clk api        ***/
 
+static void clk_core_rate_unprotect(struct clk_core *core)
+{
+	lockdep_assert_held(&prepare_lock);
+
+	if (!core)
+		return;
+
+	if (WARN_ON(core->protect_count == 0))
+		return;
+
+	if (--core->protect_count > 0)
+		return;
+
+	clk_core_rate_unprotect(core->parent);
+}
+
+static int clk_core_rate_nuke_protect(struct clk_core *core)
+{
+	int ret;
+
+	lockdep_assert_held(&prepare_lock);
+
+	if (!core)
+		return -EINVAL;
+
+	if (core->protect_count == 0)
+		return 0;
+
+	ret = core->protect_count;
+	core->protect_count = 1;
+	clk_core_rate_unprotect(core);
+
+	return ret;
+}
+
+static void clk_core_rate_protect(struct clk_core *core)
+{
+	lockdep_assert_held(&prepare_lock);
+
+	if (!core)
+		return;
+
+	if (core->protect_count == 0)
+		clk_core_rate_protect(core->parent);
+
+	core->protect_count++;
+}
+
+static void clk_core_rate_restore_protect(struct clk_core *core, int count)
+{
+	lockdep_assert_held(&prepare_lock);
+
+	if (!core)
+		return;
+
+	if (count == 0)
+		return;
+
+	clk_core_rate_protect(core);
+	core->protect_count = count;
+}
+
 static void clk_core_unprepare(struct clk_core *core)
 {
 	lockdep_assert_held(&prepare_lock);
@@ -915,7 +988,9 @@ static int clk_core_determine_round_nolock(struct clk_core *core,
 	if (!core)
 		return 0;
 
-	if (core->ops->determine_rate) {
+	if (clk_core_rate_is_protected(core)) {
+		req->rate = core->rate;
+	} else if (core->ops->determine_rate) {
 		return core->ops->determine_rate(core->hw, req);
 	} else if (core->ops->round_rate) {
 		rate = core->ops->round_rate(core->hw, req->rate,
@@ -1661,7 +1736,7 @@ static void clk_change_rate(struct clk_core *core)
 static unsigned long clk_core_req_round_rate_nolock(struct clk_core *core,
 						     unsigned long req_rate)
 {
-	int ret;
+	int ret, cnt;
 	struct clk_rate_request req;
 
 	lockdep_assert_held(&prepare_lock);
@@ -1669,11 +1744,19 @@ static unsigned long clk_core_req_round_rate_nolock(struct clk_core *core,
 	if (!core)
 		return 0;
 
+	/* simulate what the rate would be if it could be freely set */
+	cnt = clk_core_rate_nuke_protect(core);
+	if (cnt < 0)
+		return cnt;
+
 	clk_core_get_boundaries(core, &req.min_rate, &req.max_rate);
 	req.rate = req_rate;
 
 	ret = clk_core_round_rate_nolock(core, &req);
 
+	/* restore the protection */
+	clk_core_rate_restore_protect(core, cnt);
+
 	return ret ? 0 : req.rate;
 }
 
@@ -1693,6 +1776,10 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 	if (rate == clk_core_get_rate_nolock(core))
 		return 0;
 
+	/* fail on a direct rate set of a protected provider */
+	if (clk_core_rate_is_protected(core))
+		return -EBUSY;
+
 	if ((core->flags & CLK_SET_RATE_GATE) && core->prepare_count)
 		return -EBUSY;
 
@@ -1937,6 +2024,9 @@ static int clk_core_set_parent_nolock(struct clk_core *core,
 	if ((core->flags & CLK_SET_PARENT_GATE) && core->prepare_count)
 		return -EBUSY;
 
+	if (clk_core_rate_is_protected(core))
+		return -EBUSY;
+
 	/* try finding the new parent index */
 	if (parent) {
 		p_index = clk_fetch_parent_index(core, parent);
@@ -2018,6 +2108,9 @@ static int clk_core_set_phase_nolock(struct clk_core *core, int degrees)
 	if (!core)
 		return 0;
 
+	if (clk_core_rate_is_protected(core))
+		return -EBUSY;
+
 	trace_clk_set_phase(core, degrees);
 
 	if (core->ops->set_phase)
@@ -2148,11 +2241,12 @@ static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
 	if (!c)
 		return;
 
-	seq_printf(s, "%*s%-*s %11d %12d %11lu %10lu %-3d\n",
+	seq_printf(s, "%*s%-*s %11d %12d %12d %11lu %10lu %-3d\n",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
-		   c->enable_count, c->prepare_count, clk_core_get_rate(c),
-		   clk_core_get_accuracy(c), clk_core_get_phase(c));
+		   c->enable_count, c->prepare_count, c->protect_count,
+		   clk_core_get_rate(c), clk_core_get_accuracy(c),
+		   clk_core_get_phase(c));
 }
 
 static void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,
@@ -2174,8 +2268,8 @@ static int clk_summary_show(struct seq_file *s, void *data)
 	struct clk_core *c;
 	struct hlist_head **lists = (struct hlist_head **)s->private;
 
-	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy   phase\n");
-	seq_puts(s, "----------------------------------------------------------------------------------------\n");
+	seq_puts(s, "   clock                         enable_cnt  prepare_cnt  protect_cnt        rate   accuracy   phase\n");
+	seq_puts(s, "----------------------------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 
@@ -2210,6 +2304,7 @@ static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 	seq_printf(s, "\"%s\": { ", c->name);
 	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
+	seq_printf(s, "\"protect_count\": %d,", c->protect_count);
 	seq_printf(s, "\"rate\": %lu,", clk_core_get_rate(c));
 	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy(c));
 	seq_printf(s, "\"phase\": %d", clk_core_get_phase(c));
@@ -2340,6 +2435,11 @@ static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
+	d = debugfs_create_u32("clk_protect_count", S_IRUGO, core->dentry,
+			(u32 *)&core->protect_count);
+	if (!d)
+		goto err_out;
+
 	d = debugfs_create_u32("clk_notifier_count", S_IRUGO, core->dentry,
 			(u32 *)&core->notifier_count);
 	if (!d)
@@ -2911,6 +3011,11 @@ void clk_unregister(struct clk *clk)
 	if (clk->core->prepare_count)
 		pr_warn("%s: unregistering prepared clock: %s\n",
 					__func__, clk->core->name);
+
+	if (clk->core->protect_count)
+		pr_warn("%s: unregistering protected clock: %s\n",
+					__func__, clk->core->name);
+
 	kref_put(&clk->core->ref, __clk_release);
 unlock:
 	clk_prepare_unlock();

commit ca5e089a32c5ffba6c5101fdabdd6dea18041c34
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:55 2017 +0100

    clk: use round rate to bail out early in set_rate
    
    The current implementation of clk_core_set_rate_nolock() bails out early
    if the requested rate is exactly the same as the one set. It should bail
    out if the request would not result in a rate a change. This is important
    when the rate is not exactly what is requested, which is fairly common
    with PLLs.
    
    Ex: provider able to give any rate with steps of 100Hz
     - 1st consumer request 48000Hz and gets it.
     - 2nd consumer request 48010Hz as well. If we were to perform the usual
       mechanism, we would get 48000Hz as well. The clock would not change so
       there is no point performing any checks to make sure the clock can
       change, we know it won't.
    
    This is important to prepare the addition of the clock protection
    mechanism
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-6-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 322d9ba7e5cd..bbe90babdae4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1658,16 +1658,37 @@ static void clk_change_rate(struct clk_core *core)
 		clk_change_rate(core->new_child);
 }
 
+static unsigned long clk_core_req_round_rate_nolock(struct clk_core *core,
+						     unsigned long req_rate)
+{
+	int ret;
+	struct clk_rate_request req;
+
+	lockdep_assert_held(&prepare_lock);
+
+	if (!core)
+		return 0;
+
+	clk_core_get_boundaries(core, &req.min_rate, &req.max_rate);
+	req.rate = req_rate;
+
+	ret = clk_core_round_rate_nolock(core, &req);
+
+	return ret ? 0 : req.rate;
+}
+
 static int clk_core_set_rate_nolock(struct clk_core *core,
 				    unsigned long req_rate)
 {
 	struct clk_core *top, *fail_clk;
-	unsigned long rate = req_rate;
+	unsigned long rate;
 	int ret = 0;
 
 	if (!core)
 		return 0;
 
+	rate = clk_core_req_round_rate_nolock(core, req_rate);
+
 	/* bail early if nothing to do */
 	if (rate == clk_core_get_rate_nolock(core))
 		return 0;
@@ -1676,7 +1697,7 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 		return -EBUSY;
 
 	/* calculate new rates and get the topmost changed clock */
-	top = clk_calc_new_rates(core, rate);
+	top = clk_calc_new_rates(core, req_rate);
 	if (!top)
 		return -EINVAL;
 

commit 0f6cc2b8e94da5400528c0ba7fd910392ec598a2
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:54 2017 +0100

    clk: rework calls to round and determine rate callbacks
    
    Rework the way the callbacks round_rate() and determine_rate() are called.
    The goal is to do this at a single point and make it easier to add
    conditions before calling them.
    
    Because of this factorization, rate returned by determine_rate() is also
    checked against the min and max rate values
    
    This rework is done to ease the integration of "protected" clock
    functionality.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-5-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7946a069ba2e..322d9ba7e5cd 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -905,10 +905,9 @@ static int clk_disable_unused(void)
 }
 late_initcall_sync(clk_disable_unused);
 
-static int clk_core_round_rate_nolock(struct clk_core *core,
-				      struct clk_rate_request *req)
+static int clk_core_determine_round_nolock(struct clk_core *core,
+					   struct clk_rate_request *req)
 {
-	struct clk_core *parent;
 	long rate;
 
 	lockdep_assert_held(&prepare_lock);
@@ -916,15 +915,6 @@ static int clk_core_round_rate_nolock(struct clk_core *core,
 	if (!core)
 		return 0;
 
-	parent = core->parent;
-	if (parent) {
-		req->best_parent_hw = parent->hw;
-		req->best_parent_rate = parent->rate;
-	} else {
-		req->best_parent_hw = NULL;
-		req->best_parent_rate = 0;
-	}
-
 	if (core->ops->determine_rate) {
 		return core->ops->determine_rate(core->hw, req);
 	} else if (core->ops->round_rate) {
@@ -934,15 +924,58 @@ static int clk_core_round_rate_nolock(struct clk_core *core,
 			return rate;
 
 		req->rate = rate;
-	} else if (core->flags & CLK_SET_RATE_PARENT) {
-		return clk_core_round_rate_nolock(parent, req);
 	} else {
-		req->rate = core->rate;
+		return -EINVAL;
 	}
 
 	return 0;
 }
 
+static void clk_core_init_rate_req(struct clk_core * const core,
+				   struct clk_rate_request *req)
+{
+	struct clk_core *parent;
+
+	if (WARN_ON(!core || !req))
+		return;
+
+	parent = core->parent;
+	if (parent) {
+		req->best_parent_hw = parent->hw;
+		req->best_parent_rate = parent->rate;
+	} else {
+		req->best_parent_hw = NULL;
+		req->best_parent_rate = 0;
+	}
+}
+
+static bool clk_core_can_round(struct clk_core * const core)
+{
+	if (core->ops->determine_rate || core->ops->round_rate)
+		return true;
+
+	return false;
+}
+
+static int clk_core_round_rate_nolock(struct clk_core *core,
+				      struct clk_rate_request *req)
+{
+	lockdep_assert_held(&prepare_lock);
+
+	if (!core)
+		return 0;
+
+	clk_core_init_rate_req(core, req);
+
+	if (clk_core_can_round(core))
+		return clk_core_determine_round_nolock(core, req);
+	else if (core->flags & CLK_SET_RATE_PARENT)
+		return clk_core_round_rate_nolock(core->parent, req);
+
+	req->rate = core->rate;
+	return 0;
+}
+
 /**
  * __clk_determine_rate - get the closest rate actually supported by a clock
  * @hw: determine the rate of this clock
@@ -1432,34 +1465,23 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *core,
 	clk_core_get_boundaries(core, &min_rate, &max_rate);
 
 	/* find the closest rate and parent clk/rate */
-	if (core->ops->determine_rate) {
+	if (clk_core_can_round(core)) {
 		struct clk_rate_request req;
 
 		req.rate = rate;
 		req.min_rate = min_rate;
 		req.max_rate = max_rate;
-		if (parent) {
-			req.best_parent_hw = parent->hw;
-			req.best_parent_rate = parent->rate;
-		} else {
-			req.best_parent_hw = NULL;
-			req.best_parent_rate = 0;
-		}
 
-		ret = core->ops->determine_rate(core->hw, &req);
+		clk_core_init_rate_req(core, &req);
+
+		ret = clk_core_determine_round_nolock(core, &req);
 		if (ret < 0)
 			return NULL;
 
 		best_parent_rate = req.best_parent_rate;
 		new_rate = req.rate;
 		parent = req.best_parent_hw ? req.best_parent_hw->core : NULL;
-	} else if (core->ops->round_rate) {
-		ret = core->ops->round_rate(core->hw, rate,
-					    &best_parent_rate);
-		if (ret < 0)
-			return NULL;
 
-		new_rate = ret;
 		if (new_rate < min_rate || new_rate > max_rate)
 			return NULL;
 	} else if (!parent || !(core->flags & CLK_SET_RATE_PARENT)) {

commit 9e4d04adeb1a957be212aace20ac5cee6f14013c
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:53 2017 +0100

    clk: add clk_core_set_phase_nolock function
    
    Create a core function for set_phase, as it is done for set_rate and
    set_parent.
    
    This rework is done to ease the integration of "protected" clock
    functionality.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-4-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index e60b2a26b10b..7946a069ba2e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1966,6 +1966,25 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 }
 EXPORT_SYMBOL_GPL(clk_set_parent);
 
+static int clk_core_set_phase_nolock(struct clk_core *core, int degrees)
+{
+	int ret = -EINVAL;
+
+	lockdep_assert_held(&prepare_lock);
+
+	if (!core)
+		return 0;
+
+	trace_clk_set_phase(core, degrees);
+
+	if (core->ops->set_phase)
+		ret = core->ops->set_phase(core->hw, degrees);
+
+	trace_clk_set_phase_complete(core, degrees);
+
+	return ret;
+}
+
 /**
  * clk_set_phase - adjust the phase shift of a clock signal
  * @clk: clock signal source
@@ -1988,7 +2007,7 @@ EXPORT_SYMBOL_GPL(clk_set_parent);
  */
 int clk_set_phase(struct clk *clk, int degrees)
 {
-	int ret = -EINVAL;
+	int ret;
 
 	if (!clk)
 		return 0;
@@ -1999,17 +2018,7 @@ int clk_set_phase(struct clk *clk, int degrees)
 		degrees += 360;
 
 	clk_prepare_lock();
-
-	trace_clk_set_phase(clk->core, degrees);
-
-	if (clk->core->ops->set_phase)
-		ret = clk->core->ops->set_phase(clk->core->hw, degrees);
-
-	trace_clk_set_phase_complete(clk->core, degrees);
-
-	if (!ret)
-		clk->core->phase = degrees;
-
+	ret = clk_core_set_phase_nolock(clk->core, degrees);
 	clk_prepare_unlock();
 
 	return ret;

commit 91baa9ffe6d4e8191ef55b4ece3e556294141515
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:52 2017 +0100

    clk: take the prepare lock out of clk_core_set_parent
    
    Rework set_parent core function so it can be called when the prepare lock
    is already held by the caller.
    
    This rework is done to ease the integration of the "protected" clock
    functionality.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-3-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5fe9e63b15c6..e60b2a26b10b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1871,32 +1871,28 @@ bool clk_has_parent(struct clk *clk, struct clk *parent)
 }
 EXPORT_SYMBOL_GPL(clk_has_parent);
 
-static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
+static int clk_core_set_parent_nolock(struct clk_core *core,
+				      struct clk_core *parent)
 {
 	int ret = 0;
 	int p_index = 0;
 	unsigned long p_rate = 0;
 
+	lockdep_assert_held(&prepare_lock);
+
 	if (!core)
 		return 0;
 
-	/* prevent racing with updates to the clock topology */
-	clk_prepare_lock();
-
 	if (core->parent == parent)
-		goto out;
+		return 0;
 
 	/* verify ops for for multi-parent clks */
-	if ((core->num_parents > 1) && (!core->ops->set_parent)) {
-		ret = -EPERM;
-		goto out;
-	}
+	if (core->num_parents > 1 && !core->ops->set_parent)
+		return -EPERM;
 
 	/* check that we are allowed to re-parent if the clock is in use */
-	if ((core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {
-		ret = -EBUSY;
-		goto out;
-	}
+	if ((core->flags & CLK_SET_PARENT_GATE) && core->prepare_count)
+		return -EBUSY;
 
 	/* try finding the new parent index */
 	if (parent) {
@@ -1904,15 +1900,14 @@ static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
 		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",
 					__func__, parent->name, core->name);
-			ret = p_index;
-			goto out;
+			return p_index;
 		}
 		p_rate = parent->rate;
 	}
 
 	ret = clk_pm_runtime_get(core);
 	if (ret)
-		goto out;
+		return ret;
 
 	/* propagate PRE_RATE_CHANGE notifications */
 	ret = __clk_speculate_rates(core, p_rate);
@@ -1934,8 +1929,6 @@ static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
 
 runtime_put:
 	clk_pm_runtime_put(core);
-out:
-	clk_prepare_unlock();
 
 	return ret;
 }
@@ -1959,10 +1952,17 @@ static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
  */
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {
+	int ret;
+
 	if (!clk)
 		return 0;
 
-	return clk_core_set_parent(clk->core, parent ? parent->core : NULL);
+	clk_prepare_lock();
+	ret = clk_core_set_parent_nolock(clk->core,
+					 parent ? parent->core : NULL);
+	clk_prepare_unlock();
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_set_parent);
 
@@ -2851,7 +2851,7 @@ void clk_unregister(struct clk *clk)
 		/* Reparent all children to the orphan list. */
 		hlist_for_each_entry_safe(child, t, &clk->core->children,
 					  child_node)
-			clk_core_set_parent(child, NULL);
+			clk_core_set_parent_nolock(child, NULL);
 	}
 
 	hlist_del_init(&clk->core->child_node);

commit 56e7ceddbeb812a6f79f37523eb4e6e4620f4416
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Dec 1 22:51:51 2017 +0100

    clk: fix incorrect usage of ENOSYS
    
    ENOSYS is special and should only be used for incorrect syscall number.
    It does not seem to be the case here.
    
    Reported by checkpatch.pl while working on clock protection.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Tested-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171201215200.23523-2-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 647d056df88c..5fe9e63b15c6 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1888,7 +1888,7 @@ static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
 
 	/* verify ops for for multi-parent clks */
 	if ((core->num_parents > 1) && (!core->ops->set_parent)) {
-		ret = -ENOSYS;
+		ret = -EPERM;
 		goto out;
 	}
 

commit 29fd2a34ef8d863e48183bd473ba57c8d7839e25
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Dec 19 09:33:29 2017 +0100

    clk: check ops pointer on clock register
    
    Nothing really prevents a provider from (trying to) register a clock
    without providing the clock ops structure.
    
    We do check the individual fields before using them, but not the
    structure pointer itself. This may have the usual nasty consequences when
    the pointer is dereferenced, most likely when checking one the field
    during the initialization.
    
    This is fixed by returning an error on clock register if the ops pointer
    is NULL.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20171219083329.24746-1-jbrunet@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 647d056df88c..e3e98acab2c0 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2678,7 +2678,13 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		ret = -ENOMEM;
 		goto fail_name;
 	}
+
+	if (WARN_ON(!hw->init->ops)) {
+		ret = -EINVAL;
+		goto fail_ops;
+	}
 	core->ops = hw->init->ops;
+
 	if (dev && pm_runtime_enabled(dev))
 		core->dev = dev;
 	if (dev && dev->driver)
@@ -2740,6 +2746,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		kfree_const(core->parent_names[i]);
 	kfree(core->parent_names);
 fail_parent_names:
+fail_ops:
 	kfree_const(core->name);
 fail_name:
 	kfree(core);

commit 588fb54b0cc5be5fd2e12bb04810534ffc3d49cc
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Nov 30 13:14:51 2017 +0100

    clk: Manage proper runtime PM state in clk_change_rate()
    
    clk_change_rate() propagates rate change down to all its children. Such
    operation requires managing proper runtime PM state of each child, what
    was missing. Add needed calls to clk_pm_runtime*() to ensure that
    set_rate() clock callback is called on runtime active clock.
    
    This fixes following issue found on Exynos5433 TM2 board with devfreq
    enabled:
    
    Synchronous External Abort: synchronous external abort (0x96000210) at 0xffffff80093f5600
    Internal error: : 96000210 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/u16:0 Not tainted 4.15.0-rc1-next-20171129+ #4
    Hardware name: Samsung TM2 board (DT)
    Workqueue: devfreq_wq devfreq_monitor
    task: ffffffc0ca96b600 task.stack: ffffff80093a8000
    pstate: a0000085 (NzCv daIf -PAN -UAO)
    pc : clk_divider_set_rate+0x54/0x118
    lr : clk_divider_set_rate+0x44/0x118
    ...
    Process kworker/u16:0 (pid: 5, stack limit = 0xffffff80093a8000)
    Call trace:
     clk_divider_set_rate+0x54/0x118
     clk_change_rate+0xfc/0x4e0
     clk_change_rate+0x1f0/0x4e0
     clk_change_rate+0x1f0/0x4e0
     clk_change_rate+0x1f0/0x4e0
     clk_core_set_rate_nolock+0x138/0x148
     clk_set_rate+0x28/0x50
     exynos_bus_passive_target+0x6c/0x11c
     update_devfreq_passive+0x58/0xb4
     devfreq_passive_notifier_call+0x50/0x5c
     notifier_call_chain+0x4c/0x88
     __srcu_notifier_call_chain+0x54/0x80
     srcu_notifier_call_chain+0x14/0x1c
     update_devfreq+0x100/0x1b4
     devfreq_monitor+0x2c/0x88
     process_one_work+0x148/0x3d8
     worker_thread+0x13c/0x3f8
     kthread+0x100/0x12c
     ret_from_fork+0x10/0x18
    
    Reported-by: Chanwoo Choi <cw00.choi@samsung.com>
    Fixes: 9a34b45397e5 ("clk: Add support for runtime PM")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 647d056df88c..8a1860a36c77 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1564,6 +1564,9 @@ static void clk_change_rate(struct clk_core *core)
 		best_parent_rate = core->parent->rate;
 	}
 
+	if (clk_pm_runtime_get(core))
+		return;
+
 	if (core->flags & CLK_SET_RATE_UNGATE) {
 		unsigned long flags;
 
@@ -1634,6 +1637,8 @@ static void clk_change_rate(struct clk_core *core)
 	/* handle the new child who might not be in core->children yet */
 	if (core->new_child)
 		clk_change_rate(core->new_child);
+
+	clk_pm_runtime_put(core);
 }
 
 static int clk_core_set_rate_nolock(struct clk_core *core,

commit 2dd850ef6e1e525a06b4ba111968199a32844177
Merge: ed9c62f75aef b87206f8addc
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Nov 14 10:07:39 2017 -0800

    Merge branch 'clk-devm-provider' into clk-next
    
    * clk-devm-provider:
      clk: qcom: common: Migrate to devm_* APIs for resets and clk providers
      clk: Add devm_of_clk_add_hw_provider()/del_provider() APIs

commit aa795c41d9cd41dc9c915dd1956ddd0e4ae44485
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Sep 1 16:16:40 2017 -0700

    clk: Add devm_of_clk_add_hw_provider()/del_provider() APIs
    
    Sometimes we only have one of_clk_del_provider() call in driver
    error and remove paths, because we're missing a
    devm_of_clk_add_hw_provider() API. Introduce the API so we can
    convert drivers to use this and potentially reduce the amount of
    code needed to remove providers in drivers.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c8d83acda006..856d4858ae27 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3177,6 +3177,37 @@ int of_clk_add_hw_provider(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(of_clk_add_hw_provider);
 
+static void devm_of_clk_release_provider(struct device *dev, void *res)
+{
+	of_clk_del_provider(*(struct device_node **)res);
+}
+
+int devm_of_clk_add_hw_provider(struct device *dev,
+			struct clk_hw *(*get)(struct of_phandle_args *clkspec,
+					      void *data),
+			void *data)
+{
+	struct device_node **ptr, *np;
+	int ret;
+
+	ptr = devres_alloc(devm_of_clk_release_provider, sizeof(*ptr),
+			   GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	np = dev->of_node;
+	ret = of_clk_add_hw_provider(np, get, data);
+	if (!ret) {
+		*ptr = np;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(devm_of_clk_add_hw_provider);
+
 /**
  * of_clk_del_provider() - Remove a previously registered clock provider
  * @np: Device node pointer associated with clock provider
@@ -3198,6 +3229,27 @@ void of_clk_del_provider(struct device_node *np)
 }
 EXPORT_SYMBOL_GPL(of_clk_del_provider);
 
+static int devm_clk_provider_match(struct device *dev, void *res, void *data)
+{
+	struct device_node **np = res;
+
+	if (WARN_ON(!np || !*np))
+		return 0;
+
+	return *np == data;
+}
+
+void devm_of_clk_del_provider(struct device *dev)
+{
+	int ret;
+
+	ret = devres_release(dev, devm_of_clk_release_provider,
+			     devm_clk_provider_match, dev->of_node);
+
+	WARN_ON(ret);
+}
+EXPORT_SYMBOL(devm_of_clk_del_provider);
+
 static struct clk_hw *
 __of_clk_get_hw_from_provider(struct of_clk_provider *provider,
 			      struct of_phandle_args *clkspec)

commit e7cc33358a88e0a0949370ada47144c11c2aa290
Merge: 79765e9a3d99 ae432a9b314e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Sep 29 16:07:28 2017 -0700

    Merge branch 'clk-pm-runtime' into clk-next
    
    * clk-pm-runtime:
      clk: samsung: exynos-audss: Add support for runtime PM
      clk: samsung: exynos-audss: Use local variable for controller's device
      clk: samsung: exynos5433: Add support for runtime PM
      clk: samsung: Add support for runtime PM
      clk: Add support for runtime PM

commit 9a34b45397e5a389e25a0c5d39983300d040e5e2
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Aug 21 10:04:59 2017 +0200

    clk: Add support for runtime PM
    
    Registers for some clocks might be located in the SOC area, which are under the
    power domain. To enable access to those registers respective domain has to be
    turned on. Additionally, registers for such clocks will usually loose its
    contents when power domain is turned off, so additional saving and restoring of
    them might be needed in the clock controller driver.
    
    This patch adds basic infrastructure in the clocks core to allow implementing
    driver for such clocks under power domains. Clock provider can supply a
    struct device pointer, which is the used by clock core for tracking and managing
    clock's controller runtime pm state. Each clk_prepare() operation
    will first call pm_runtime_get_sync() on the supplied device, while
    clk_unprepare() will do pm_runtime_put_sync() at the end.
    
    Additional calls to pm_runtime_get/put functions are required to ensure that any
    register access (like calculating/changing clock rates and unpreparing/disabling
    unused clocks on boot) will be done with clock controller in runtime resumend
    state.
    
    When one wants to register clock controller, which make use of this feature, he
    has to:
    1. Provide a struct device to the core when registering the provider.
    2. Ensure to enable runtime PM for that device before registering clocks.
    3. Make sure that the runtime PM status of the controller device reflects
       the HW state.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/1503302703-13801-2-git-send-email-m.szyprowski@samsung.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fc58c52a26b4..5bb6308fbf0d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -21,6 +21,7 @@
 #include <linux/of.h>
 #include <linux/device.h>
 #include <linux/init.h>
+#include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/clkdev.h>
 
@@ -46,6 +47,7 @@ struct clk_core {
 	const struct clk_ops	*ops;
 	struct clk_hw		*hw;
 	struct module		*owner;
+	struct device		*dev;
 	struct clk_core		*parent;
 	const char		**parent_names;
 	struct clk_core		**parents;
@@ -87,6 +89,26 @@ struct clk {
 	struct hlist_node clks_node;
 };
 
+/***           runtime pm          ***/
+static int clk_pm_runtime_get(struct clk_core *core)
+{
+	int ret = 0;
+
+	if (!core->dev)
+		return 0;
+
+	ret = pm_runtime_get_sync(core->dev);
+	return ret < 0 ? ret : 0;
+}
+
+static void clk_pm_runtime_put(struct clk_core *core)
+{
+	if (!core->dev)
+		return;
+
+	pm_runtime_put_sync(core->dev);
+}
+
 /***           locking             ***/
 static void clk_prepare_lock(void)
 {
@@ -150,6 +172,8 @@ static void clk_enable_unlock(unsigned long flags)
 
 static bool clk_core_is_prepared(struct clk_core *core)
 {
+	bool ret = false;
+
 	/*
 	 * .is_prepared is optional for clocks that can prepare
 	 * fall back to software usage counter if it is missing
@@ -157,11 +181,18 @@ static bool clk_core_is_prepared(struct clk_core *core)
 	if (!core->ops->is_prepared)
 		return core->prepare_count;
 
-	return core->ops->is_prepared(core->hw);
+	if (!clk_pm_runtime_get(core)) {
+		ret = core->ops->is_prepared(core->hw);
+		clk_pm_runtime_put(core);
+	}
+
+	return ret;
 }
 
 static bool clk_core_is_enabled(struct clk_core *core)
 {
+	bool ret = false;
+
 	/*
 	 * .is_enabled is only mandatory for clocks that gate
 	 * fall back to software usage counter if .is_enabled is missing
@@ -169,7 +200,29 @@ static bool clk_core_is_enabled(struct clk_core *core)
 	if (!core->ops->is_enabled)
 		return core->enable_count;
 
-	return core->ops->is_enabled(core->hw);
+	/*
+	 * Check if clock controller's device is runtime active before
+	 * calling .is_enabled callback. If not, assume that clock is
+	 * disabled, because we might be called from atomic context, from
+	 * which pm_runtime_get() is not allowed.
+	 * This function is called mainly from clk_disable_unused_subtree,
+	 * which ensures proper runtime pm activation of controller before
+	 * taking enable spinlock, but the below check is needed if one tries
+	 * to call it from other places.
+	 */
+	if (core->dev) {
+		pm_runtime_get_noresume(core->dev);
+		if (!pm_runtime_active(core->dev)) {
+			ret = false;
+			goto done;
+		}
+	}
+
+	ret = core->ops->is_enabled(core->hw);
+done:
+	clk_pm_runtime_put(core);
+
+	return ret;
 }
 
 /***    helper functions   ***/
@@ -489,6 +542,8 @@ static void clk_core_unprepare(struct clk_core *core)
 	if (core->ops->unprepare)
 		core->ops->unprepare(core->hw);
 
+	clk_pm_runtime_put(core);
+
 	trace_clk_unprepare_complete(core);
 	clk_core_unprepare(core->parent);
 }
@@ -530,10 +585,14 @@ static int clk_core_prepare(struct clk_core *core)
 		return 0;
 
 	if (core->prepare_count == 0) {
-		ret = clk_core_prepare(core->parent);
+		ret = clk_pm_runtime_get(core);
 		if (ret)
 			return ret;
 
+		ret = clk_core_prepare(core->parent);
+		if (ret)
+			goto runtime_put;
+
 		trace_clk_prepare(core);
 
 		if (core->ops->prepare)
@@ -541,15 +600,18 @@ static int clk_core_prepare(struct clk_core *core)
 
 		trace_clk_prepare_complete(core);
 
-		if (ret) {
-			clk_core_unprepare(core->parent);
-			return ret;
-		}
+		if (ret)
+			goto unprepare;
 	}
 
 	core->prepare_count++;
 
 	return 0;
+unprepare:
+	clk_core_unprepare(core->parent);
+runtime_put:
+	clk_pm_runtime_put(core);
+	return ret;
 }
 
 static int clk_core_prepare_lock(struct clk_core *core)
@@ -745,6 +807,9 @@ static void clk_unprepare_unused_subtree(struct clk_core *core)
 	if (core->flags & CLK_IGNORE_UNUSED)
 		return;
 
+	if (clk_pm_runtime_get(core))
+		return;
+
 	if (clk_core_is_prepared(core)) {
 		trace_clk_unprepare(core);
 		if (core->ops->unprepare_unused)
@@ -753,6 +818,8 @@ static void clk_unprepare_unused_subtree(struct clk_core *core)
 			core->ops->unprepare(core->hw);
 		trace_clk_unprepare_complete(core);
 	}
+
+	clk_pm_runtime_put(core);
 }
 
 static void clk_disable_unused_subtree(struct clk_core *core)
@@ -768,6 +835,9 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 	if (core->flags & CLK_OPS_PARENT_ENABLE)
 		clk_core_prepare_enable(core->parent);
 
+	if (clk_pm_runtime_get(core))
+		goto unprepare_out;
+
 	flags = clk_enable_lock();
 
 	if (core->enable_count)
@@ -792,6 +862,8 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 
 unlock_out:
 	clk_enable_unlock(flags);
+	clk_pm_runtime_put(core);
+unprepare_out:
 	if (core->flags & CLK_OPS_PARENT_ENABLE)
 		clk_core_disable_unprepare(core->parent);
 }
@@ -1038,9 +1110,13 @@ EXPORT_SYMBOL_GPL(clk_get_accuracy);
 static unsigned long clk_recalc(struct clk_core *core,
 				unsigned long parent_rate)
 {
-	if (core->ops->recalc_rate)
-		return core->ops->recalc_rate(core->hw, parent_rate);
-	return parent_rate;
+	unsigned long rate = parent_rate;
+
+	if (core->ops->recalc_rate && !clk_pm_runtime_get(core)) {
+		rate = core->ops->recalc_rate(core->hw, parent_rate);
+		clk_pm_runtime_put(core);
+	}
+	return rate;
 }
 
 /**
@@ -1565,6 +1641,7 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 {
 	struct clk_core *top, *fail_clk;
 	unsigned long rate = req_rate;
+	int ret = 0;
 
 	if (!core)
 		return 0;
@@ -1581,21 +1658,28 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 	if (!top)
 		return -EINVAL;
 
+	ret = clk_pm_runtime_get(core);
+	if (ret)
+		return ret;
+
 	/* notify that we are about to change rates */
 	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
 	if (fail_clk) {
 		pr_debug("%s: failed to set %s rate\n", __func__,
 				fail_clk->name);
 		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto err;
 	}
 
 	/* change the rates */
 	clk_change_rate(top);
 
 	core->req_rate = req_rate;
+err:
+	clk_pm_runtime_put(core);
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -1826,12 +1910,16 @@ static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
 		p_rate = parent->rate;
 	}
 
+	ret = clk_pm_runtime_get(core);
+	if (ret)
+		goto out;
+
 	/* propagate PRE_RATE_CHANGE notifications */
 	ret = __clk_speculate_rates(core, p_rate);
 
 	/* abort if a driver objects */
 	if (ret & NOTIFY_STOP_MASK)
-		goto out;
+		goto runtime_put;
 
 	/* do the re-parent */
 	ret = __clk_set_parent(core, parent, p_index);
@@ -1844,6 +1932,8 @@ static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
 		__clk_recalc_accuracies(core);
 	}
 
+runtime_put:
+	clk_pm_runtime_put(core);
 out:
 	clk_prepare_unlock();
 
@@ -2350,7 +2440,7 @@ static inline void clk_debug_unregister(struct clk_core *core)
  */
 static int __clk_core_init(struct clk_core *core)
 {
-	int i, ret = 0;
+	int i, ret;
 	struct clk_core *orphan;
 	struct hlist_node *tmp2;
 	unsigned long rate;
@@ -2360,6 +2450,10 @@ static int __clk_core_init(struct clk_core *core)
 
 	clk_prepare_lock();
 
+	ret = clk_pm_runtime_get(core);
+	if (ret)
+		goto unlock;
+
 	/* check to see if a clock with this name is already registered */
 	if (clk_core_lookup(core->name)) {
 		pr_debug("%s: clk %s already initialized\n",
@@ -2512,6 +2606,8 @@ static int __clk_core_init(struct clk_core *core)
 
 	kref_init(&core->ref);
 out:
+	clk_pm_runtime_put(core);
+unlock:
 	clk_prepare_unlock();
 
 	if (!ret)
@@ -2583,6 +2679,8 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		goto fail_name;
 	}
 	core->ops = hw->init->ops;
+	if (dev && pm_runtime_enabled(dev))
+		core->dev = dev;
 	if (dev && dev->driver)
 		core->owner = dev->driver->owner;
 	core->hw = hw;

commit 1667393126d7c51fad8b3cb9d3798e8e0367e2ec
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:42:52 2017 -0500

    clk: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: "Emilio Lpez" <emilio@elopez.com.ar>
    Cc: Peter De Schrijver <pdeschrijver@nvidia.com>
    Cc: Prashant Gaikwad <pgaikwad@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: James Liao <jamesjj.liao@mediatek.com>
    Acked-by: Alexandre TORGUE <alexandre.torgue@st.com>
    Reviewed-by: Matthias Brugger <matthias.bgg@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fc58c52a26b4..c8d83acda006 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3132,7 +3132,7 @@ int of_clk_add_provider(struct device_node *np,
 	mutex_lock(&of_clk_mutex);
 	list_add(&cp->link, &of_clk_providers);
 	mutex_unlock(&of_clk_mutex);
-	pr_debug("Added clock from %s\n", np->full_name);
+	pr_debug("Added clock from %pOF\n", np);
 
 	ret = of_clk_set_defaults(np, true);
 	if (ret < 0)
@@ -3167,7 +3167,7 @@ int of_clk_add_hw_provider(struct device_node *np,
 	mutex_lock(&of_clk_mutex);
 	list_add(&cp->link, &of_clk_providers);
 	mutex_unlock(&of_clk_mutex);
-	pr_debug("Added clk_hw provider from %s\n", np->full_name);
+	pr_debug("Added clk_hw provider from %pOF\n", np);
 
 	ret = of_clk_set_defaults(np, true);
 	if (ret < 0)

commit 1808a3201965c430b70cb9236ff80d2cad403452
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Apr 20 09:30:52 2017 +0200

    clk: Improve a size determination in two functions
    
    Replace the specification of two data structures by pointer dereferences
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3e5562a161a4..fc58c52a26b4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2973,7 +2973,7 @@ int clk_notifier_register(struct clk *clk, struct notifier_block *nb)
 
 	/* if clk wasn't in the notifier list, allocate new clk_notifier */
 	if (cn->clk != clk) {
-		cn = kzalloc(sizeof(struct clk_notifier), GFP_KERNEL);
+		cn = kzalloc(sizeof(*cn), GFP_KERNEL);
 		if (!cn)
 			goto out;
 
@@ -3121,7 +3121,7 @@ int of_clk_add_provider(struct device_node *np,
 	struct of_clk_provider *cp;
 	int ret;
 
-	cp = kzalloc(sizeof(struct of_clk_provider), GFP_KERNEL);
+	cp = kzalloc(sizeof(*cp), GFP_KERNEL);
 	if (!cp)
 		return -ENOMEM;
 

commit 4d32758671527761e6ee94568b8e32925c4bc682
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Apr 20 08:45:43 2017 +0200

    clk: Replace four seq_printf() calls by seq_putc()
    
    Four single characters should be put into a sequence.
    Thus use the corresponding function "seq_putc".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index cddddbe46d9d..3e5562a161a4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2083,11 +2083,11 @@ static void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)
 	clk_dump_one(s, c, level);
 
 	hlist_for_each_entry(child, &c->children, child_node) {
-		seq_printf(s, ",");
+		seq_putc(s, ',');
 		clk_dump_subtree(s, child, level + 1);
 	}
 
-	seq_printf(s, "}");
+	seq_putc(s, '}');
 }
 
 static int clk_dump(struct seq_file *s, void *data)
@@ -2096,14 +2096,13 @@ static int clk_dump(struct seq_file *s, void *data)
 	bool first_node = true;
 	struct hlist_head **lists = (struct hlist_head **)s->private;
 
-	seq_printf(s, "{");
-
+	seq_putc(s, '{');
 	clk_prepare_lock();
 
 	for (; *lists; lists++) {
 		hlist_for_each_entry(c, *lists, child_node) {
 			if (!first_node)
-				seq_puts(s, ",");
+				seq_putc(s, ',');
 			first_node = false;
 			clk_dump_subtree(s, c, 0);
 		}

commit 17c34c566795ca7529cf888fb33fdb7997d6b202
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Tue Mar 21 12:16:26 2017 +0200

    clk: aggregate return codes of notify chains
    
    In case there are multiple notify chains for the same clocks (because they
    were registered by different users), we need to propagate potential failure
    of any single one of them to the caller. Otherwise we eg risk violating the
    V/f curve when a notifier is used for DVFS.
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0d8eb5aa477a..cddddbe46d9d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -966,6 +966,8 @@ static int __clk_notify(struct clk_core *core, unsigned long msg,
 			cnd.clk = cn->clk;
 			ret = srcu_notifier_call_chain(&cn->notifier_head, msg,
 					&cnd);
+			if (ret & NOTIFY_STOP_MASK)
+				return ret;
 		}
 	}
 

commit 92031575c3e60c2f641aacf752bd7494d65e70f7
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Tue Mar 21 15:20:31 2017 +0200

    clk: add clk_possible_parents debugfs file
    
    For validation purposes, it's often useful to be able to retrieve the list
    of possible parents in userspace. Add a debugfs file for every clock which
    has more than 1 possible parent.
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Reviewed-by: Jon Mayo <jmayo@nvidia.com>
    [sboyd@codeaurora.org: Remove useless cast from void and extra
    newline]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 67201f67a14a..0d8eb5aa477a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2126,6 +2126,31 @@ static const struct file_operations clk_dump_fops = {
 	.release	= single_release,
 };
 
+static int possible_parents_dump(struct seq_file *s, void *data)
+{
+	struct clk_core *core = s->private;
+	int i;
+
+	for (i = 0; i < core->num_parents - 1; i++)
+		seq_printf(s, "%s ", core->parent_names[i]);
+
+	seq_printf(s, "%s\n", core->parent_names[i]);
+
+	return 0;
+}
+
+static int possible_parents_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, possible_parents_dump, inode->i_private);
+}
+
+static const struct file_operations possible_parents_fops = {
+	.open		= possible_parents_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
 	struct dentry *d;
@@ -2177,6 +2202,13 @@ static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
+	if (core->num_parents > 1) {
+		d = debugfs_create_file("clk_possible_parents", S_IRUGO,
+				core->dentry, core, &possible_parents_fops);
+		if (!d)
+			goto err_out;
+	}
+
 	if (core->ops->debug_init) {
 		ret = core->ops->debug_init(core->hw, core->dentry);
 		if (ret)

commit 253160a8ad06bcc1c1db16a58b1f06d5128f6c5e
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Mon Feb 20 15:20:56 2017 +0200

    clk: core: Copy connection id
    
    Some drivers use sprintf to build clk connection id names but the clk
    core will save those strings and occasionally print them back. Duplicate
    the con_id strings instead of fixing all the users.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0fb39fe217d1..67201f67a14a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2502,7 +2502,7 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 
 	clk->core = hw->core;
 	clk->dev_id = dev_id;
-	clk->con_id = con_id;
+	clk->con_id = kstrdup_const(con_id, GFP_KERNEL);
 	clk->max_rate = ULONG_MAX;
 
 	clk_prepare_lock();
@@ -2518,6 +2518,7 @@ void __clk_free_clk(struct clk *clk)
 	hlist_del(&clk->clks_node);
 	clk_prepare_unlock();
 
+	kfree_const(clk->con_id);
 	kfree(clk);
 }
 

commit 3174b0c9a62bb3738b4a2a506b8a075d4430e353
Author: Jean-Francois Moine <moinejf@free.fr>
Date:   Wed Aug 24 08:32:51 2016 +0200

    clk: core: Force setting the phase delay when no change
    
    This patch reverts commit 023bd7166be0 ("clk: skip unnecessary
    set_phase if nothing to do"), fixing two problems:
    
    * in some SoCs, the hardware phase delay depends on the rate ratio of
      the clock and its parent. So, changing this ratio may imply to set
      new hardware values, even if the logical delay is the same.
    
    * when the delay was the same as previously, an error was returned.
    
    Signed-off-by: Jean-Francois Moine <moinejf@free.fr>
    Fixes: 023bd7166be0 ("clk: skip unnecessary set_phase if nothing to do")
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d3d26148cdfb..0fb39fe217d1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1908,10 +1908,6 @@ int clk_set_phase(struct clk *clk, int degrees)
 
 	clk_prepare_lock();
 
-	/* bail early if nothing to do */
-	if (degrees == clk->core->phase)
-		goto out;
-
 	trace_clk_set_phase(clk->core, degrees);
 
 	if (clk->core->ops->set_phase)
@@ -1922,7 +1918,6 @@ int clk_set_phase(struct clk *clk, int degrees)
 	if (!ret)
 		clk->core->phase = degrees;
 
-out:
 	clk_prepare_unlock();
 
 	return ret;

commit 74002fcde01d8acb4ce68878e9998fad51fe7925
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Aug 25 13:35:36 2016 -0700

    clk: Simplify __of_clk_get_hw_from_provider()
    
    __of_clk_get_hw_from_provider() is confusing because it will
    return EPROBE_DEFER if there isn't a ->get() or ->get_hw()
    function pointer in a provider. That's just a bug though, and we
    used to NULL pointer exception when ->get() was missing anyway,
    so let's make this more obvious that they're not optional. The
    assumption is that most providers will implement ->get_hw() so we
    only fallback to the ->get() function if necessary. This
    clarifies the intent and removes any possibility of probe defer
    happening if clk providers are buggy.
    
    Reported-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 71cc56712666..d3d26148cdfb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3174,19 +3174,14 @@ __of_clk_get_hw_from_provider(struct of_clk_provider *provider,
 			      struct of_phandle_args *clkspec)
 {
 	struct clk *clk;
-	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
 
-	if (provider->get_hw) {
-		hw = provider->get_hw(clkspec, provider->data);
-	} else if (provider->get) {
-		clk = provider->get(clkspec, provider->data);
-		if (!IS_ERR(clk))
-			hw = __clk_get_hw(clk);
-		else
-			hw = ERR_CAST(clk);
-	}
+	if (provider->get_hw)
+		return provider->get_hw(clkspec, provider->data);
 
-	return hw;
+	clk = provider->get(clkspec, provider->data);
+	if (IS_ERR(clk))
+		return ERR_CAST(clk);
+	return __clk_get_hw(clk);
 }
 
 struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,

commit f155d15b64e36b45ca89e3521fe0c1ccad5e5ff0
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Aug 15 14:32:23 2016 -0700

    clk: Return errors from clk providers in __of_clk_get_from_provider()
    
    Before commit 0861e5b8cf80 (clk: Add clk_hw OF clk providers,
    2016-02-05) __of_clk_get_from_provider() would return an error
    pointer of the provider's choosing if there was a provider
    registered and EPROBE_DEFER otherwise. After that commit, it
    would return EPROBE_DEFER regardless of whether or not the
    provider returned an error. This is odd and can lead to behavior
    where clk consumers keep probe deferring when they should be
    seeing some other error.
    
    Let's restore the previous behavior where we only return
    EPROBE_DEFER when there isn't a provider in our of_clk_providers
    list. Otherwise, return the error from the last provider we find
    that matches the node.
    
    Reported-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Fixes: 0861e5b8cf80 ("clk: Add clk_hw OF clk providers")
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 6298715d0e44..71cc56712666 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3194,7 +3194,7 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 {
 	struct of_clk_provider *provider;
 	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
-	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
+	struct clk_hw *hw;
 
 	if (!clkspec)
 		return ERR_PTR(-EINVAL);
@@ -3202,12 +3202,13 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 	/* Check if we have such a provider in our array */
 	mutex_lock(&of_clk_mutex);
 	list_for_each_entry(provider, &of_clk_providers, link) {
-		if (provider->node == clkspec->np)
+		if (provider->node == clkspec->np) {
 			hw = __of_clk_get_hw_from_provider(provider, clkspec);
-		if (!IS_ERR(hw)) {
 			clk = __clk_create_clk(hw, dev_id, con_id);
+		}
 
-			if (!IS_ERR(clk) && !__clk_get(clk)) {
+		if (!IS_ERR(clk)) {
+			if (!__clk_get(clk)) {
 				__clk_free_clk(clk);
 				clk = ERR_PTR(-ENOENT);
 			}

commit 8a23133c7a2afc49d97b5b27caefe6847d32599e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jul 19 16:28:47 2016 +0900

    clk: use ERR_CAST() for __clk_create_clk()
    
    This code is clear enough, but the intention will be even clearer
    with this.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0c6009a19957..6298715d0e44 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2499,7 +2499,7 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 
 	/* This is to allow this function to be chained to others */
 	if (IS_ERR_OR_NULL(hw))
-		return (struct clk *) hw;
+		return ERR_CAST(hw);
 
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 	if (!clk)

commit 989eafd0b6091c15a0929ea5f520ff926ccaaa25
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue Jul 5 18:23:32 2016 +0200

    clk: core: Avoid double initialization of clocks
    
    Some clock providers can be initialized via of_clk_init() and also via
    platform device probe.
    
    Avoid double initialization of them by setting the OF_POPULATED flag.
    
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 238b989bf778..0c6009a19957 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3459,6 +3459,10 @@ void __init of_clk_init(const struct of_device_id *matches)
 					&clk_provider_list, node) {
 			if (force || parent_ready(clk_provider->np)) {
 
+				/* Don't populate platform devices */
+				of_node_set_flag(clk_provider->np,
+						 OF_POPULATED);
+
 				clk_provider->clk_init_cb(clk_provider->np);
 				of_clk_set_defaults(clk_provider->np, true);
 

commit 904e6ead02dcb409cb6eb5ec1c31dc2c7c28b5df
Author: Michael Turquette <mturquette@baylibre.com>
Date:   Fri Jul 8 16:32:10 2016 -0700

    clk: migrate ref counts when orphans are reunited
    
    It's always nice to see families reunited, and this is equally true when
    talking about parent clocks and their children. However, if the orphan
    clk had a positive prepare_count or enable_count, then we would not
    migrate those counts up the parent chain correctly.
    
    This has manifested with the recent critical clocks feature, which often
    enables clocks very early, before their parents have been registered.
    
    Fixed by replacing the call to clk_core_reparent with calls to
    __clk_set_parent_{before,after}.
    
    Cc: James Liao <jamesjj.liao@mediatek.com>
    Cc: Erin Lo <erin.lo@mediatek.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    [sboyd@codeaurora.org: Recalc accuracies and rates too]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 820a939fb6bb..238b989bf778 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2449,8 +2449,16 @@ static int __clk_core_init(struct clk_core *core)
 	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
 		struct clk_core *parent = __clk_init_parent(orphan);
 
-		if (parent)
-			clk_core_reparent(orphan, parent);
+		/*
+		 * we could call __clk_set_parent, but that would result in a
+		 * redundant call to the .set_rate op, if it exists
+		 */
+		if (parent) {
+			__clk_set_parent_before(orphan, parent);
+			__clk_set_parent_after(orphan, parent, NULL);
+			__clk_recalc_accuracies(orphan);
+			__clk_recalc_rates(orphan, 0);
+		}
 	}
 
 	/*

commit fc8726a2c021b5525151ff6482f8f9a863c56d8d
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Jun 30 17:31:14 2016 +0800

    clk: core: support clocks which requires parents enable (part 2)
    
    On Freescale i.MX7D platform, all clocks operations, including
    enable/disable, rate change and re-parent, requires its parent clock on.
    Current clock core can not support it well.
    This patch adding flag CLK_OPS_PARENT_ENABLE to handle this special case in
    clock core that enable its parent clock firstly for each operation and
    disable it later after operation complete.
    
    The patch part 2 fixes set clock rate and set parent while its parent
    is off. The most special case is for set_parent() operation which requires
    all parents including both old and new one to be enabled at the same time
    during the operation.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    [sboyd@codeaurora.org: Move set_rate tracepoint after prepare_enable]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index e3bd28c9ef28..820a939fb6bb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1172,7 +1172,9 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 	struct clk_core *old_parent = core->parent;
 
 	/*
-	 * Migrate prepare state between parents and prevent race with
+	 * 1. enable parents for CLK_OPS_PARENT_ENABLE clock
+	 *
+	 * 2. Migrate prepare state between parents and prevent race with
 	 * clk_enable().
 	 *
 	 * If the clock is not prepared, then a race with
@@ -1188,12 +1190,17 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 	 *
 	 * See also: Comment for clk_set_parent() below.
 	 */
+
+	/* enable old_parent & parent if CLK_OPS_PARENT_ENABLE is set */
+	if (core->flags & CLK_OPS_PARENT_ENABLE) {
+		clk_core_prepare_enable(old_parent);
+		clk_core_prepare_enable(parent);
+	}
+
+	/* migrate prepare count if > 0 */
 	if (core->prepare_count) {
-		clk_core_prepare(parent);
-		flags = clk_enable_lock();
-		clk_core_enable(parent);
-		clk_core_enable(core);
-		clk_enable_unlock(flags);
+		clk_core_prepare_enable(parent);
+		clk_core_enable_lock(core);
 	}
 
 	/* update the clk tree topology */
@@ -1208,18 +1215,19 @@ static void __clk_set_parent_after(struct clk_core *core,
 				   struct clk_core *parent,
 				   struct clk_core *old_parent)
 {
-	unsigned long flags;
-
 	/*
 	 * Finish the migration of prepare state and undo the changes done
 	 * for preventing a race with clk_enable().
 	 */
 	if (core->prepare_count) {
-		flags = clk_enable_lock();
-		clk_core_disable(core);
-		clk_core_disable(old_parent);
-		clk_enable_unlock(flags);
-		clk_core_unprepare(old_parent);
+		clk_core_disable_lock(core);
+		clk_core_disable_unprepare(old_parent);
+	}
+
+	/* re-balance ref counting if CLK_OPS_PARENT_ENABLE is set */
+	if (core->flags & CLK_OPS_PARENT_ENABLE) {
+		clk_core_disable_unprepare(parent);
+		clk_core_disable_unprepare(old_parent);
 	}
 }
 
@@ -1466,13 +1474,17 @@ static void clk_change_rate(struct clk_core *core)
 	unsigned long best_parent_rate = 0;
 	bool skip_set_rate = false;
 	struct clk_core *old_parent;
+	struct clk_core *parent = NULL;
 
 	old_rate = core->rate;
 
-	if (core->new_parent)
+	if (core->new_parent) {
+		parent = core->new_parent;
 		best_parent_rate = core->new_parent->rate;
-	else if (core->parent)
+	} else if (core->parent) {
+		parent = core->parent;
 		best_parent_rate = core->parent->rate;
+	}
 
 	if (core->flags & CLK_SET_RATE_UNGATE) {
 		unsigned long flags;
@@ -1500,6 +1512,9 @@ static void clk_change_rate(struct clk_core *core)
 		__clk_set_parent_after(core, core->new_parent, old_parent);
 	}
 
+	if (core->flags & CLK_OPS_PARENT_ENABLE)
+		clk_core_prepare_enable(parent);
+
 	trace_clk_set_rate(core, core->new_rate);
 
 	if (!skip_set_rate && core->ops->set_rate)
@@ -1518,6 +1533,9 @@ static void clk_change_rate(struct clk_core *core)
 		clk_core_unprepare(core);
 	}
 
+	if (core->flags & CLK_OPS_PARENT_ENABLE)
+		clk_core_disable_unprepare(parent);
+
 	if (core->notifier_count && old_rate != core->rate)
 		__clk_notify(core, POST_RATE_CHANGE, old_rate, core->rate);
 

commit a4b3518d146f150d633f7dc815bb8ee2fbc162e9
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Jun 30 17:31:13 2016 +0800

    clk: core: support clocks which requires parents enable (part 1)
    
    On Freescale i.MX7D platform, all clocks operations, including
    enable/disable, rate change and re-parent, requires its parent
    clock enable. Current clock core can not support it well.
    This patch introduce a new flag CLK_OPS_PARENT_ENABLE to handle this
    special case in clock core that enable its parent clock firstly for
    each operation and disable it later after operation complete.
    
    The patch part 1 fixes the possible disabling clocks while its parent
    is off during kernel booting phase in clk_disable_unused_subtree().
    
    Before the completion of kernel booting, clock tree is still not built
    completely, there may be a case that the child clock is on but its
    parent is off which could be caused by either HW initial reset state
    or bootloader initialization.
    
    Taking bootloader as an example, we may enable all clocks in HW by default.
    And during kernel booting time, the parent clock could be disabled in its
    driver probe due to calling clk_prepare_enable and clk_disable_unprepare.
    Because it's child clock is only enabled in HW while its SW usecount
    in clock tree is still 0, so clk_disable of parent clock will gate
    the parent clock in both HW and SW usecount ultimately. Then there will
    be a child clock is still on in HW but its parent is already off.
    
    Later in clk_disable_unused(), this clock disable accessing while its
    parent off will cause system hang due to the limitation of HW which
    must require its parent on.
    
    This patch simply enables the parent clock first before disabling
    if flag CLK_OPS_PARENT_ENABLE is set in clk_disable_unused_subtree().
    This is a simple solution and only affects booting time.
    
    After kernel booting up the clock tree is already created, there will
    be no case that child is off but its parent is off.
    So no need do this checking for normal clk_disable() later.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index e2e8f0c9f20a..e3bd28c9ef28 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -765,6 +765,9 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 	hlist_for_each_entry(child, &core->children, child_node)
 		clk_disable_unused_subtree(child);
 
+	if (core->flags & CLK_OPS_PARENT_ENABLE)
+		clk_core_prepare_enable(core->parent);
+
 	flags = clk_enable_lock();
 
 	if (core->enable_count)
@@ -789,6 +792,8 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 
 unlock_out:
 	clk_enable_unlock(flags);
+	if (core->flags & CLK_OPS_PARENT_ENABLE)
+		clk_core_disable_unprepare(core->parent);
 }
 
 static bool clk_ignore_unused;

commit 7ec986efed0208ca5fdfc26f9fc19c1604d3d502
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Jun 30 17:31:12 2016 +0800

    clk: move clk_disable_unused after clk_core_disable_unprepare function
    
    No function level change, just moving code place.
    clk_disable_unused function will need to call clk_core_prepare_enable/
    clk_core_disable_unprepare when adding CLK_OPS_PARENT_ENABLE features.
    So move it after clk_core_disable_unprepare to avoid adding forward
    declared functions later.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 55e62bac0fb4..e2e8f0c9f20a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -172,104 +172,6 @@ static bool clk_core_is_enabled(struct clk_core *core)
 	return core->ops->is_enabled(core->hw);
 }
 
-static void clk_unprepare_unused_subtree(struct clk_core *core)
-{
-	struct clk_core *child;
-
-	lockdep_assert_held(&prepare_lock);
-
-	hlist_for_each_entry(child, &core->children, child_node)
-		clk_unprepare_unused_subtree(child);
-
-	if (core->prepare_count)
-		return;
-
-	if (core->flags & CLK_IGNORE_UNUSED)
-		return;
-
-	if (clk_core_is_prepared(core)) {
-		trace_clk_unprepare(core);
-		if (core->ops->unprepare_unused)
-			core->ops->unprepare_unused(core->hw);
-		else if (core->ops->unprepare)
-			core->ops->unprepare(core->hw);
-		trace_clk_unprepare_complete(core);
-	}
-}
-
-static void clk_disable_unused_subtree(struct clk_core *core)
-{
-	struct clk_core *child;
-	unsigned long flags;
-
-	lockdep_assert_held(&prepare_lock);
-
-	hlist_for_each_entry(child, &core->children, child_node)
-		clk_disable_unused_subtree(child);
-
-	flags = clk_enable_lock();
-
-	if (core->enable_count)
-		goto unlock_out;
-
-	if (core->flags & CLK_IGNORE_UNUSED)
-		goto unlock_out;
-
-	/*
-	 * some gate clocks have special needs during the disable-unused
-	 * sequence.  call .disable_unused if available, otherwise fall
-	 * back to .disable
-	 */
-	if (clk_core_is_enabled(core)) {
-		trace_clk_disable(core);
-		if (core->ops->disable_unused)
-			core->ops->disable_unused(core->hw);
-		else if (core->ops->disable)
-			core->ops->disable(core->hw);
-		trace_clk_disable_complete(core);
-	}
-
-unlock_out:
-	clk_enable_unlock(flags);
-}
-
-static bool clk_ignore_unused;
-static int __init clk_ignore_unused_setup(char *__unused)
-{
-	clk_ignore_unused = true;
-	return 1;
-}
-__setup("clk_ignore_unused", clk_ignore_unused_setup);
-
-static int clk_disable_unused(void)
-{
-	struct clk_core *core;
-
-	if (clk_ignore_unused) {
-		pr_warn("clk: Not disabling unused clocks\n");
-		return 0;
-	}
-
-	clk_prepare_lock();
-
-	hlist_for_each_entry(core, &clk_root_list, child_node)
-		clk_disable_unused_subtree(core);
-
-	hlist_for_each_entry(core, &clk_orphan_list, child_node)
-		clk_disable_unused_subtree(core);
-
-	hlist_for_each_entry(core, &clk_root_list, child_node)
-		clk_unprepare_unused_subtree(core);
-
-	hlist_for_each_entry(core, &clk_orphan_list, child_node)
-		clk_unprepare_unused_subtree(core);
-
-	clk_prepare_unlock();
-
-	return 0;
-}
-late_initcall_sync(clk_disable_unused);
-
 /***    helper functions   ***/
 
 const char *__clk_get_name(const struct clk *clk)
@@ -828,6 +730,104 @@ static void clk_core_disable_unprepare(struct clk_core *core)
 	clk_core_unprepare_lock(core);
 }
 
+static void clk_unprepare_unused_subtree(struct clk_core *core)
+{
+	struct clk_core *child;
+
+	lockdep_assert_held(&prepare_lock);
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_unprepare_unused_subtree(child);
+
+	if (core->prepare_count)
+		return;
+
+	if (core->flags & CLK_IGNORE_UNUSED)
+		return;
+
+	if (clk_core_is_prepared(core)) {
+		trace_clk_unprepare(core);
+		if (core->ops->unprepare_unused)
+			core->ops->unprepare_unused(core->hw);
+		else if (core->ops->unprepare)
+			core->ops->unprepare(core->hw);
+		trace_clk_unprepare_complete(core);
+	}
+}
+
+static void clk_disable_unused_subtree(struct clk_core *core)
+{
+	struct clk_core *child;
+	unsigned long flags;
+
+	lockdep_assert_held(&prepare_lock);
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_disable_unused_subtree(child);
+
+	flags = clk_enable_lock();
+
+	if (core->enable_count)
+		goto unlock_out;
+
+	if (core->flags & CLK_IGNORE_UNUSED)
+		goto unlock_out;
+
+	/*
+	 * some gate clocks have special needs during the disable-unused
+	 * sequence.  call .disable_unused if available, otherwise fall
+	 * back to .disable
+	 */
+	if (clk_core_is_enabled(core)) {
+		trace_clk_disable(core);
+		if (core->ops->disable_unused)
+			core->ops->disable_unused(core->hw);
+		else if (core->ops->disable)
+			core->ops->disable(core->hw);
+		trace_clk_disable_complete(core);
+	}
+
+unlock_out:
+	clk_enable_unlock(flags);
+}
+
+static bool clk_ignore_unused;
+static int __init clk_ignore_unused_setup(char *__unused)
+{
+	clk_ignore_unused = true;
+	return 1;
+}
+__setup("clk_ignore_unused", clk_ignore_unused_setup);
+
+static int clk_disable_unused(void)
+{
+	struct clk_core *core;
+
+	if (clk_ignore_unused) {
+		pr_warn("clk: Not disabling unused clocks\n");
+		return 0;
+	}
+
+	clk_prepare_lock();
+
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_disable_unused_subtree(core);
+
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_disable_unused_subtree(core);
+
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_unprepare_unused_subtree(core);
+
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_unprepare_unused_subtree(core);
+
+	clk_prepare_unlock();
+
+	return 0;
+}
+late_initcall_sync(clk_disable_unused);
+
 static int clk_core_round_rate_nolock(struct clk_core *core,
 				      struct clk_rate_request *req)
 {

commit a6adc30ba7bef8da62a32c884609eb9cace04fbc
Author: Dong Aisheng <aisheng.dong@nxp.com>
Date:   Thu Jun 30 17:31:11 2016 +0800

    clk: introduce clk_core_enable_lock and clk_core_disable_lock functions
    
    This can be useful when clock core wants to enable/disable clocks.
    Then we don't have to convert the struct clk_core to struct clk to call
    clk_enable/clk_disable which is a bit un-align with exist using.
    
    And after introduce clk_core_{enable|disable}_lock, we can refine
    clk_enable and clk_disable a bit.
    
    As well as clk_core_{enable|disable}_lock, we also added
    clk_core_{prepare|unprepare}_lock and clk_core_prepare_enable/
    clk_core_unprepare_disable for clock core to easily use.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 95b80aeb8c9d..55e62bac0fb4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -591,6 +591,13 @@ static void clk_core_unprepare(struct clk_core *core)
 	clk_core_unprepare(core->parent);
 }
 
+static void clk_core_unprepare_lock(struct clk_core *core)
+{
+	clk_prepare_lock();
+	clk_core_unprepare(core);
+	clk_prepare_unlock();
+}
+
 /**
  * clk_unprepare - undo preparation of a clock source
  * @clk: the clk being unprepared
@@ -607,9 +614,7 @@ void clk_unprepare(struct clk *clk)
 	if (IS_ERR_OR_NULL(clk))
 		return;
 
-	clk_prepare_lock();
-	clk_core_unprepare(clk->core);
-	clk_prepare_unlock();
+	clk_core_unprepare_lock(clk->core);
 }
 EXPORT_SYMBOL_GPL(clk_unprepare);
 
@@ -645,6 +650,17 @@ static int clk_core_prepare(struct clk_core *core)
 	return 0;
 }
 
+static int clk_core_prepare_lock(struct clk_core *core)
+{
+	int ret;
+
+	clk_prepare_lock();
+	ret = clk_core_prepare(core);
+	clk_prepare_unlock();
+
+	return ret;
+}
+
 /**
  * clk_prepare - prepare a clock source
  * @clk: the clk being prepared
@@ -659,16 +675,10 @@ static int clk_core_prepare(struct clk_core *core)
  */
 int clk_prepare(struct clk *clk)
 {
-	int ret;
-
 	if (!clk)
 		return 0;
 
-	clk_prepare_lock();
-	ret = clk_core_prepare(clk->core);
-	clk_prepare_unlock();
-
-	return ret;
+	return clk_core_prepare_lock(clk->core);
 }
 EXPORT_SYMBOL_GPL(clk_prepare);
 
@@ -698,6 +708,15 @@ static void clk_core_disable(struct clk_core *core)
 	clk_core_disable(core->parent);
 }
 
+static void clk_core_disable_lock(struct clk_core *core)
+{
+	unsigned long flags;
+
+	flags = clk_enable_lock();
+	clk_core_disable(core);
+	clk_enable_unlock(flags);
+}
+
 /**
  * clk_disable - gate a clock
  * @clk: the clk being gated
@@ -712,14 +731,10 @@ static void clk_core_disable(struct clk_core *core)
  */
 void clk_disable(struct clk *clk)
 {
-	unsigned long flags;
-
 	if (IS_ERR_OR_NULL(clk))
 		return;
 
-	flags = clk_enable_lock();
-	clk_core_disable(clk->core);
-	clk_enable_unlock(flags);
+	clk_core_disable_lock(clk->core);
 }
 EXPORT_SYMBOL_GPL(clk_disable);
 
@@ -758,6 +773,18 @@ static int clk_core_enable(struct clk_core *core)
 	return 0;
 }
 
+static int clk_core_enable_lock(struct clk_core *core)
+{
+	unsigned long flags;
+	int ret;
+
+	flags = clk_enable_lock();
+	ret = clk_core_enable(core);
+	clk_enable_unlock(flags);
+
+	return ret;
+}
+
 /**
  * clk_enable - ungate a clock
  * @clk: the clk being ungated
@@ -773,19 +800,33 @@ static int clk_core_enable(struct clk_core *core)
  */
 int clk_enable(struct clk *clk)
 {
-	unsigned long flags;
-	int ret;
-
 	if (!clk)
 		return 0;
 
-	flags = clk_enable_lock();
-	ret = clk_core_enable(clk->core);
-	clk_enable_unlock(flags);
+	return clk_core_enable_lock(clk->core);
+}
+EXPORT_SYMBOL_GPL(clk_enable);
+
+static int clk_core_prepare_enable(struct clk_core *core)
+{
+	int ret;
+
+	ret = clk_core_prepare_lock(core);
+	if (ret)
+		return ret;
+
+	ret = clk_core_enable_lock(core);
+	if (ret)
+		clk_core_unprepare_lock(core);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(clk_enable);
+
+static void clk_core_disable_unprepare(struct clk_core *core)
+{
+	clk_core_disable_lock(core);
+	clk_core_unprepare_lock(core);
+}
 
 static int clk_core_round_rate_nolock(struct clk_core *core,
 				      struct clk_rate_request *req)

commit 2d5b520cfec56fa7fa09bd08c98d7f49a05aedd9
Author: Peng Fan <van.freenix@gmail.com>
Date:   Mon Jun 13 19:34:21 2016 +0800

    clk: correct comments for __clk_determine_rate
    
    Correct comments for __clk_determine_rate.
    
    Signed-off-by: Peng Fan <van.freenix@gmail.com>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index df844a60fdf9..95b80aeb8c9d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -828,9 +828,7 @@ static int clk_core_round_rate_nolock(struct clk_core *core,
 /**
  * __clk_determine_rate - get the closest rate actually supported by a clock
  * @hw: determine the rate of this clock
- * @rate: target rate
- * @min_rate: returned rate must be greater than this rate
- * @max_rate: returned rate must be less than this rate
+ * @req: target rate request
  *
  * Useful for clk_ops such as .set_rate and .determine_rate.
  */

commit 06b37e4a6ef2d392f3f35c94a9fe5d43f09f36c7
Author: Lee Jones <lee.jones@linaro.org>
Date:   Tue Jun 7 13:25:02 2016 +0100

    clk: Remove unused variable
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 874c7dd8ef66..df844a60fdf9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1501,7 +1501,6 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 {
 	struct clk_core *top, *fail_clk;
 	unsigned long rate = req_rate;
-	int ret = 0;
 
 	if (!core)
 		return 0;
@@ -1532,7 +1531,7 @@ static int clk_core_set_rate_nolock(struct clk_core *core,
 
 	core->req_rate = req_rate;
 
-	return ret;
+	return 0;
 }
 
 /**

commit 071a0cb66cc6d355f70e5c3aa701033f22ac7476
Merge: 72ad679aa718 f17a0dd1c2e0
Author: Michael Turquette <mturquette@baylibre.com>
Date:   Thu Jun 16 22:07:08 2016 -0700

    Merge commit 'f17a0dd1c2e0' into clk-next

commit f17a0dd1c2e0d05c38589c9a13a36db455b74818
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Apr 26 14:02:23 2016 -0700

    clk: Use _rcuidle suffix to allow clk_core_enable() to used from idle
    
    This commit fixes the RCU use-from-idle bug corresponding the following
    splat:
    
    > [ INFO: suspicious RCU usage. ]
    > 4.6.0-rc5-next-20160426+ #1127 Not tainted
    > -------------------------------
    > include/trace/events/clk.h:45 suspicious rcu_dereference_check() usage!
    >
    > other info that might help us debug this:
    >
    >
    > RCU used illegally from idle CPU!
    > rcu_scheduler_active = 1, debug_locks = 0
    > RCU used illegally from extended quiescent state!
    > 2 locks held by swapper/0/0:
    >  #0:  (&oh->hwmod_key#30){......}, at: [<c0121afc>] omap_hwmod_enable+0x18/0x44
    >  #1:  (enable_lock){......}, at: [<c0630684>] clk_enable_lock+0x18/0x124
    >
    > stack backtrace:
    > CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.6.0-rc5-next-20160426+ #1127
    > Hardware name: Generic OMAP36xx (Flattened Device Tree)
    > [<c0110290>] (unwind_backtrace) from [<c010c3a8>] (show_stack+0x10/0x14)
    > [<c010c3a8>] (show_stack) from [<c047fd68>] (dump_stack+0xb0/0xe4)
    > [<c047fd68>] (dump_stack) from [<c06315c0>] (clk_core_enable+0x1e0/0x36c)
    > [<c06315c0>] (clk_core_enable) from [<c0632298>] (clk_enable+0x1c/0x38)
    > [<c0632298>] (clk_enable) from [<c01204e0>] (_enable_clocks+0x18/0x7c)
    > [<c01204e0>] (_enable_clocks) from [<c012137c>] (_enable+0x114/0x2ec)
    > [<c012137c>] (_enable) from [<c0121b08>] (omap_hwmod_enable+0x24/0x44)
    > [<c0121b08>] (omap_hwmod_enable) from [<c0122ad0>] (omap_device_enable+0x3c/0x90)
    > [<c0122ad0>] (omap_device_enable) from [<c0122b34>] (_od_runtime_resume+0x10/0x38)
    > [<c0122b34>] (_od_runtime_resume) from [<c052cc00>] (__rpm_callback+0x2c/0x60)
    > [<c052cc00>] (__rpm_callback) from [<c052cc54>] (rpm_callback+0x20/0x80)
    > [<c052cc54>] (rpm_callback) from [<c052df7c>] (rpm_resume+0x3d0/0x6f0)
    > [<c052df7c>] (rpm_resume) from [<c052e2e8>] (__pm_runtime_resume+0x4c/0x64)
    > [<c052e2e8>] (__pm_runtime_resume) from [<c04bf2c4>] (omap2_gpio_resume_after_idle+0x54/0x68)
    > [<c04bf2c4>] (omap2_gpio_resume_after_idle) from [<c01269dc>] (omap3_enter_idle_bm+0xfc/0x1ec)
    > [<c01269dc>] (omap3_enter_idle_bm) from [<c0601888>] (cpuidle_enter_state+0x80/0x3d4)
    > [<c0601888>] (cpuidle_enter_state) from [<c0183b08>] (cpu_startup_entry+0x198/0x3a0)
    > [<c0183b08>] (cpu_startup_entry) from [<c0b00c0c>] (start_kernel+0x354/0x3c8)
    > [<c0b00c0c>] (start_kernel) from [<8000807c>] (0x8000807c)
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: <linux-omap@vger.kernel.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <linux-clk@vger.kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4fa43c02d682..ec83f404c1d2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -735,12 +735,12 @@ static int clk_core_enable(struct clk_core *core)
 		if (ret)
 			return ret;
 
-		trace_clk_enable(core);
+		trace_clk_enable_rcuidle(core);
 
 		if (core->ops->enable)
 			ret = core->ops->enable(core->hw);
 
-		trace_clk_enable_complete(core);
+		trace_clk_enable_complete_rcuidle(core);
 
 		if (ret) {
 			clk_core_disable(core->parent);

commit 2f87a6ea1b0c4dfb71acf40d24f12b27e7680794
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Apr 26 12:43:57 2016 -0700

    clk: Add _rcuidle tracepoints to allow clk_core_disable() use from idle
    
    This commit adds an _rcuidle suffix to a pair of trace events to
    prevent the following splat:
    
    > ===============================
    > [ INFO: suspicious RCU usage. ]
    > 4.6.0-rc5-next-20160426+ #1114 Not tainted
    > -------------------------------
    > include/trace/events/clk.h:59 suspicious rcu_dereference_check() usage!
    >
    > other info that might help us debug this:
    >
    >
    > RCU used illegally from idle CPU!
    > rcu_scheduler_active = 1, debug_locks = 0
    > RCU used illegally from extended quiescent state!
    > 2 locks held by swapper/0/0:
    >  #0:  (&oh->hwmod_key#30){......}, at: [<c0121b40>] omap_hwmod_idle+0x18/0x44
    >  #1:  (enable_lock){......}, at: [<c0630998>] clk_enable_lock+0x18/0x124
    >
    > stack backtrace:
    > CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.6.0-rc5-next-20160426+ #1114
    > Hardware name: Generic OMAP36xx (Flattened Device Tree)
    > [<c0110290>] (unwind_backtrace) from [<c010c3a8>] (show_stack+0x10/0x14)
    > [<c010c3a8>] (show_stack) from [<c047fd68>] (dump_stack+0xb0/0xe4)
    > [<c047fd68>] (dump_stack) from [<c0631618>] (clk_core_disable+0x17c/0x348)
    > [<c0631618>] (clk_core_disable) from [<c0632774>] (clk_disable+0x24/0x30)
    > [<c0632774>] (clk_disable) from [<c0120590>] (_disable_clocks+0x18/0x7c)
    > [<c0120590>] (_disable_clocks) from [<c0121680>] (_idle+0x12c/0x230)
    > [<c0121680>] (_idle) from [<c0121b4c>] (omap_hwmod_idle+0x24/0x44)
    > [<c0121b4c>] (omap_hwmod_idle) from [<c0122c24>] (omap_device_idle+0x3c/0x90)
    > [<c0122c24>] (omap_device_idle) from [<c052cc00>] (__rpm_callback+0x2c/0x60)
    > [<c052cc00>] (__rpm_callback) from [<c052cc54>] (rpm_callback+0x20/0x80)
    > [<c052cc54>] (rpm_callback) from [<c052d150>] (rpm_suspend+0x100/0x768)
    > [<c052d150>] (rpm_suspend) from [<c052ec58>] (__pm_runtime_suspend+0x64/0x84)
    > [<c052ec58>] (__pm_runtime_suspend) from [<c04bf25c>] (omap2_gpio_prepare_for_idle+0x5c/0x70)
    > [<c04bf25c>] (omap2_gpio_prepare_for_idle) from [<c0125568>] (omap_sram_idle+0x140/0x244)
    > [<c0125568>] (omap_sram_idle) from [<c01269dc>] (omap3_enter_idle_bm+0xfc/0x1ec)
    > [<c01269dc>] (omap3_enter_idle_bm) from [<c0601bdc>] (cpuidle_enter_state+0x80/0x3d4)
    > [<c0601bdc>] (cpuidle_enter_state) from [<c0183b08>] (cpu_startup_entry+0x198/0x3a0)
    > [<c0183b08>] (cpu_startup_entry) from [<c0b00c0c>] (start_kernel+0x354/0x3c8)
    > [<c0b00c0c>] (start_kernel) from [<8000807c>] (0x8000807c)
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: <linux-omap@vger.kernel.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <linux-clk@vger.kernel.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fb74dc1f7520..4fa43c02d682 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -682,12 +682,12 @@ static void clk_core_disable(struct clk_core *core)
 	if (--core->enable_count > 0)
 		return;
 
-	trace_clk_disable(core);
+	trace_clk_disable_rcuidle(core);
 
 	if (core->ops->disable)
 		core->ops->disable(core->hw);
 
-	trace_clk_disable_complete(core);
+	trace_clk_disable_complete_rcuidle(core);
 
 	clk_core_disable(core->parent);
 }

commit ef56b79b66faeeb0dc14213d3cc9e0534a960dee
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Fri May 13 10:00:31 2016 +0200

    clk: fix critical clock locking
    
    The critical clock handling in __clk_core_init isn't taking the enable lock
    before calling clk_core_enable, which in turns triggers the warning in the
    lockdep_assert_held call in that function when lockep is enabled.
    
    Add the calls to clk_enable_lock/unlock to make sure it doesn't happen.
    
    Fixes: 32b9b1096186 ("clk: Allow clocks to be marked as CRITICAL")
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ce39add5a258..d584004f7af7 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2404,8 +2404,13 @@ static int __clk_core_init(struct clk_core *core)
 		core->ops->init(core->hw);
 
 	if (core->flags & CLK_IS_CRITICAL) {
+		unsigned long flags;
+
 		clk_core_prepare(core);
+
+		flags = clk_enable_lock();
 		clk_core_enable(core);
+		clk_enable_unlock(flags);
 	}
 
 	kref_init(&core->ref);

commit c47265ad64fa793657ce7ecf1a8f636c794e9f40
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun May 1 19:56:08 2016 +0900

    clk: fix comment of devm_clk_hw_register()
    
    Unlike devm_clk_register(), devm_clk_hw_register() returns integer.
    So, the statement "Clocks returned from this function ..." sounds
    odd.  Adjust the comment for this new API.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ba1c3647fbf8..ce39add5a258 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2719,7 +2719,7 @@ EXPORT_SYMBOL_GPL(devm_clk_register);
  * @dev: device that is registering this clock
  * @hw: link to hardware-specific clock data
  *
- * Managed clk_hw_register(). Clocks returned from this function are
+ * Managed clk_hw_register(). Clocks registered by this function are
  * automatically clk_hw_unregister()ed on driver detach. See clk_hw_register()
  * for more information.
  */

commit 58657d189a2f626a568308f70a6b34255650c87e
Merge: e9471c4ecf8a 26ef56be9e09
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 21 14:47:18 2016 -0700

    Merge branch 'clk-hw-register' (early part) into clk-next
    
    * 'clk-hw-register' (early part):
      clk: fixed-rate: Add hw based registration APIs
      clk: gpio: Add hw based registration APIs
      clk: composite: Add hw based registration APIs
      clk: fractional-divider: Add hw based registration APIs
      clk: fixed-factor: Add hw based registration APIs
      clk: mux: Add hw based registration APIs
      clk: gate: Add hw based registration APIs
      clk: divider: Add hw based registration APIs
      clkdev: Add clk_hw based registration APIs
      clk: Add clk_hw OF clk providers
      clk: Add {devm_}clk_hw_{register,unregister}() APIs
      clkdev: Remove clk_register_clkdevs()

commit 0861e5b8cf80038e91942f1005c8dfce79d18c38
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 5 17:38:26 2016 -0800

    clk: Add clk_hw OF clk providers
    
    Now that we have a clk registration API that doesn't return
    struct clks, we need to have some way to hand out struct clks via
    the clk_get() APIs that doesn't involve associating struct clk
    pointers with an OF node. Currently we ask the OF provider to
    give us a struct clk pointer for some clkspec, turn that struct
    clk into a struct clk_hw and then allocate a new struct clk to
    return to the caller.
    
    Let's add a clk_hw based OF provider hook that returns a struct
    clk_hw directly, so that we skip the intermediate step of
    converting from struct clk to struct clk_hw. Eventually when
    we've converted all OF clk providers to struct clk_hw based APIs
    we can remove the struct clk based ones.
    
    It should also be noted that we change the onecell provider to
    have a flex array instead of a pointer for the array of clk_hw
    pointers. This allows providers to allocate one structure of the
    correct length in one step instead of two.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0ef919666827..e813b2aabc87 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2941,6 +2941,7 @@ struct of_clk_provider {
 
 	struct device_node *node;
 	struct clk *(*get)(struct of_phandle_args *clkspec, void *data);
+	struct clk_hw *(*get_hw)(struct of_phandle_args *clkspec, void *data);
 	void *data;
 };
 
@@ -2957,6 +2958,12 @@ struct clk *of_clk_src_simple_get(struct of_phandle_args *clkspec,
 }
 EXPORT_SYMBOL_GPL(of_clk_src_simple_get);
 
+struct clk_hw *of_clk_hw_simple_get(struct of_phandle_args *clkspec, void *data)
+{
+	return data;
+}
+EXPORT_SYMBOL_GPL(of_clk_hw_simple_get);
+
 struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data)
 {
 	struct clk_onecell_data *clk_data = data;
@@ -2971,6 +2978,21 @@ struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data)
 }
 EXPORT_SYMBOL_GPL(of_clk_src_onecell_get);
 
+struct clk_hw *
+of_clk_hw_onecell_get(struct of_phandle_args *clkspec, void *data)
+{
+	struct clk_hw_onecell_data *hw_data = data;
+	unsigned int idx = clkspec->args[0];
+
+	if (idx >= hw_data->num) {
+		pr_err("%s: invalid index %u\n", __func__, idx);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return hw_data->hws[idx];
+}
+EXPORT_SYMBOL_GPL(of_clk_hw_onecell_get);
+
 /**
  * of_clk_add_provider() - Register a clock provider for a node
  * @np: Device node pointer associated with clock provider
@@ -3006,6 +3028,41 @@ int of_clk_add_provider(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(of_clk_add_provider);
 
+/**
+ * of_clk_add_hw_provider() - Register a clock provider for a node
+ * @np: Device node pointer associated with clock provider
+ * @get: callback for decoding clk_hw
+ * @data: context pointer for @get callback.
+ */
+int of_clk_add_hw_provider(struct device_node *np,
+			   struct clk_hw *(*get)(struct of_phandle_args *clkspec,
+						 void *data),
+			   void *data)
+{
+	struct of_clk_provider *cp;
+	int ret;
+
+	cp = kzalloc(sizeof(*cp), GFP_KERNEL);
+	if (!cp)
+		return -ENOMEM;
+
+	cp->node = of_node_get(np);
+	cp->data = data;
+	cp->get_hw = get;
+
+	mutex_lock(&of_clk_mutex);
+	list_add(&cp->link, &of_clk_providers);
+	mutex_unlock(&of_clk_mutex);
+	pr_debug("Added clk_hw provider from %s\n", np->full_name);
+
+	ret = of_clk_set_defaults(np, true);
+	if (ret < 0)
+		of_clk_del_provider(np);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(of_clk_add_hw_provider);
+
 /**
  * of_clk_del_provider() - Remove a previously registered clock provider
  * @np: Device node pointer associated with clock provider
@@ -3027,11 +3084,32 @@ void of_clk_del_provider(struct device_node *np)
 }
 EXPORT_SYMBOL_GPL(of_clk_del_provider);
 
+static struct clk_hw *
+__of_clk_get_hw_from_provider(struct of_clk_provider *provider,
+			      struct of_phandle_args *clkspec)
+{
+	struct clk *clk;
+	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
+
+	if (provider->get_hw) {
+		hw = provider->get_hw(clkspec, provider->data);
+	} else if (provider->get) {
+		clk = provider->get(clkspec, provider->data);
+		if (!IS_ERR(clk))
+			hw = __clk_get_hw(clk);
+		else
+			hw = ERR_CAST(clk);
+	}
+
+	return hw;
+}
+
 struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 				       const char *dev_id, const char *con_id)
 {
 	struct of_clk_provider *provider;
 	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
+	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
 
 	if (!clkspec)
 		return ERR_PTR(-EINVAL);
@@ -3040,10 +3118,9 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 	mutex_lock(&of_clk_mutex);
 	list_for_each_entry(provider, &of_clk_providers, link) {
 		if (provider->node == clkspec->np)
-			clk = provider->get(clkspec, provider->data);
-		if (!IS_ERR(clk)) {
-			clk = __clk_create_clk(__clk_get_hw(clk), dev_id,
-					       con_id);
+			hw = __of_clk_get_hw_from_provider(provider, clkspec);
+		if (!IS_ERR(hw)) {
+			clk = __clk_create_clk(hw, dev_id, con_id);
 
 			if (!IS_ERR(clk) && !__clk_get(clk)) {
 				__clk_free_clk(clk);

commit 4143804c4fdef40358c654d1fb2271a1a0f1fedf
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 5 17:02:52 2016 -0800

    clk: Add {devm_}clk_hw_{register,unregister}() APIs
    
    We've largely split the clk consumer and provider APIs along
    struct clk and struct clk_hw, but clk_register() still returns a
    struct clk pointer for each struct clk_hw that's registered.
    Eventually we'd like to only allocate struct clks when there's a
    user, because struct clk is per-user now, so clk_register() needs
    to change.
    
    Let's add new APIs to register struct clk_hws, but this time
    we'll hide the struct clk from the caller by returning an int
    error code. Also add an unregistration API that takes the clk_hw
    structure that was passed to the registration API. This way
    provider drivers never have to deal with a struct clk pointer
    unless they're using the clk consumer APIs.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fb74dc1f7520..0ef919666827 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2536,6 +2536,22 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(clk_register);
 
+/**
+ * clk_hw_register - register a clk_hw and return an error code
+ * @dev: device that is registering this clock
+ * @hw: link to hardware-specific clock data
+ *
+ * clk_hw_register is the primary interface for populating the clock tree with
+ * new clock nodes. It returns an integer equal to zero indicating success or
+ * less than zero indicating failure. Drivers must test for an error code after
+ * calling clk_hw_register().
+ */
+int clk_hw_register(struct device *dev, struct clk_hw *hw)
+{
+	return PTR_ERR_OR_ZERO(clk_register(dev, hw));
+}
+EXPORT_SYMBOL_GPL(clk_hw_register);
+
 /* Free memory allocated for a clock. */
 static void __clk_release(struct kref *ref)
 {
@@ -2637,11 +2653,26 @@ void clk_unregister(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_unregister);
 
+/**
+ * clk_hw_unregister - unregister a currently registered clk_hw
+ * @hw: hardware-specific clock data to unregister
+ */
+void clk_hw_unregister(struct clk_hw *hw)
+{
+	clk_unregister(hw->clk);
+}
+EXPORT_SYMBOL_GPL(clk_hw_unregister);
+
 static void devm_clk_release(struct device *dev, void *res)
 {
 	clk_unregister(*(struct clk **)res);
 }
 
+static void devm_clk_hw_release(struct device *dev, void *res)
+{
+	clk_hw_unregister(*(struct clk_hw **)res);
+}
+
 /**
  * devm_clk_register - resource managed clk_register()
  * @dev: device that is registering this clock
@@ -2672,6 +2703,36 @@ struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(devm_clk_register);
 
+/**
+ * devm_clk_hw_register - resource managed clk_hw_register()
+ * @dev: device that is registering this clock
+ * @hw: link to hardware-specific clock data
+ *
+ * Managed clk_hw_register(). Clocks returned from this function are
+ * automatically clk_hw_unregister()ed on driver detach. See clk_hw_register()
+ * for more information.
+ */
+int devm_clk_hw_register(struct device *dev, struct clk_hw *hw)
+{
+	struct clk_hw **hwp;
+	int ret;
+
+	hwp = devres_alloc(devm_clk_hw_release, sizeof(*hwp), GFP_KERNEL);
+	if (!hwp)
+		return -ENOMEM;
+
+	ret = clk_hw_register(dev, hw);
+	if (!ret) {
+		*hwp = hw;
+		devres_add(dev, hwp);
+	} else {
+		devres_free(hwp);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(devm_clk_hw_register);
+
 static int devm_clk_match(struct device *dev, void *res, void *data)
 {
 	struct clk *c = res;
@@ -2680,6 +2741,15 @@ static int devm_clk_match(struct device *dev, void *res, void *data)
 	return c == data;
 }
 
+static int devm_clk_hw_match(struct device *dev, void *res, void *data)
+{
+	struct clk_hw *hw = res;
+
+	if (WARN_ON(!hw))
+		return 0;
+	return hw == data;
+}
+
 /**
  * devm_clk_unregister - resource managed clk_unregister()
  * @clk: clock to unregister
@@ -2694,6 +2764,22 @@ void devm_clk_unregister(struct device *dev, struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(devm_clk_unregister);
 
+/**
+ * devm_clk_hw_unregister - resource managed clk_hw_unregister()
+ * @dev: device that is unregistering the hardware-specific clock data
+ * @hw: link to hardware-specific clock data
+ *
+ * Unregister a clk_hw registered with devm_clk_hw_register(). Normally
+ * this function will not need to be called and the resource management
+ * code will ensure that the resource is freed.
+ */
+void devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw)
+{
+	WARN_ON(devres_release(dev, devm_clk_hw_release, devm_clk_hw_match,
+				hw));
+}
+EXPORT_SYMBOL_GPL(devm_clk_hw_unregister);
+
 /*
  * clkdev helpers
  */

commit d56f8994b6fb928f59481fabc25bcd1c2f9bd06d
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Feb 11 13:19:11 2016 -0800

    clk: Provide OF helper to mark clocks as CRITICAL
    
    This call matches clocks which have been marked as critical in DT
    and sets the appropriate flag.  These flags can then be used to
    mark the clock core flags appropriately prior to registration.
    
    Legacy bindings requiring this feature must add the clock-critical
    property to their binding descriptions, as it is not a part of
    common-clock binding.
    
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/1455225554-13267-4-git-send-email-mturquette@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index dede0ce679e4..9f77cc67cdc3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3137,6 +3137,41 @@ static int parent_ready(struct device_node *np)
 	}
 }
 
+/**
+ * of_clk_detect_critical() - set CLK_IS_CRITICAL flag from Device Tree
+ * @np: Device node pointer associated with clock provider
+ * @index: clock index
+ * @flags: pointer to clk_core->flags
+ *
+ * Detects if the clock-critical property exists and, if so, sets the
+ * corresponding CLK_IS_CRITICAL flag.
+ *
+ * Do not use this function. It exists only for legacy Device Tree
+ * bindings, such as the one-clock-per-node style that are outdated.
+ * Those bindings typically put all clock data into .dts and the Linux
+ * driver has no clock data, thus making it impossible to set this flag
+ * correctly from the driver. Only those drivers may call
+ * of_clk_detect_critical from their setup functions.
+ *
+ * Return: error code or zero on success
+ */
+int of_clk_detect_critical(struct device_node *np,
+					  int index, unsigned long *flags)
+{
+	struct property *prop;
+	const __be32 *cur;
+	uint32_t idx;
+
+	if (!np || !flags)
+		return -EINVAL;
+
+	of_property_for_each_u32(np, "clock-critical", prop, cur, idx)
+		if (index == idx)
+			*flags |= CLK_IS_CRITICAL;
+
+	return 0;
+}
+
 /**
  * of_clk_init() - Scan and init clock providers from the DT
  * @matches: array of compatible values and init functions for providers.

commit 2e20fbf592621b2c2aeddd82e0fa3dad053cce03
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Feb 11 13:19:10 2016 -0800

    clk: WARN_ON about to disable a critical clock
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/1455225554-13267-3-git-send-email-mturquette@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 275201fd7b01..dede0ce679e4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -574,6 +574,9 @@ static void clk_core_unprepare(struct clk_core *core)
 	if (WARN_ON(core->prepare_count == 0))
 		return;
 
+	if (WARN_ON(core->prepare_count == 1 && core->flags & CLK_IS_CRITICAL))
+		return;
+
 	if (--core->prepare_count > 0)
 		return;
 
@@ -679,6 +682,9 @@ static void clk_core_disable(struct clk_core *core)
 	if (WARN_ON(core->enable_count == 0))
 		return;
 
+	if (WARN_ON(core->enable_count == 1 && core->flags & CLK_IS_CRITICAL))
+		return;
+
 	if (--core->enable_count > 0)
 		return;
 

commit 32b9b10961860860268961d9aad0c56a73018c37
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Feb 11 13:19:09 2016 -0800

    clk: Allow clocks to be marked as CRITICAL
    
    Critical clocks are those which must not be gated, else undefined
    or catastrophic failure would occur.  Here we have chosen to
    ensure the prepare/enable counts are correctly incremented, so as
    not to confuse users with enabled clocks with no visible users.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/1455225554-13267-2-git-send-email-mturquette@baylibre.com

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fb74dc1f7520..275201fd7b01 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2397,6 +2397,11 @@ static int __clk_core_init(struct clk_core *core)
 	if (core->ops->init)
 		core->ops->init(core->hw);
 
+	if (core->flags & CLK_IS_CRITICAL) {
+		clk_core_prepare(core);
+		clk_core_enable(core);
+	}
+
 	kref_init(&core->ref);
 out:
 	clk_prepare_unlock();

commit 929e7f3bc7b82fb3e72392dec6a1df334cff6313
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 19 15:52:32 2016 -0800

    clk: Make of_clk_get_parent_count() return unsigned ints
    
    Russell King recently pointed out a bug in the clk-gpio code
    where it fails to register the clk if of_clk_get_parent_count()
    returns an error because the "clocks" property isn't present in
    the DT node. If we're trying to count parents from DT we'd like
    to know the count, not if there is a "clocks" property or not.
    Furthermore, some drivers are assigning the return value to their
    clk_init_data::num_parents member which is unsigned, leading to
    potentially large numbers of parents when the property isn't
    present.
    
    Let's change the API to return an unsigned int instead of an int.
    All the callers just want to know the count anyway, and this
    avoids the bug that was in the clk-gpio driver.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b775c88ac36d..fb74dc1f7520 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2986,9 +2986,21 @@ struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 }
 EXPORT_SYMBOL_GPL(of_clk_get_from_provider);
 
-int of_clk_get_parent_count(struct device_node *np)
+/**
+ * of_clk_get_parent_count() - Count the number of clocks a device node has
+ * @np: device node to count
+ *
+ * Returns: The number of clocks that are possible parents of this node
+ */
+unsigned int of_clk_get_parent_count(struct device_node *np)
 {
-	return of_count_phandle_with_args(np, "clocks", "#clock-cells");
+	int count;
+
+	count = of_count_phandle_with_args(np, "clocks", "#clock-cells");
+	if (count < 0)
+		return 0;
+
+	return count;
 }
 EXPORT_SYMBOL_GPL(of_clk_get_parent_count);
 

commit 3e5dd6f6e690048d0fd1c913397506648724474e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Feb 26 16:54:31 2016 +0100

    clk: Ignore disabled DT clock providers
    
    of_clk_init() uses for_each_matching_node_and_match() to find clock
    providers, which returns all matching device nodes, whether they are
    enabled or not. Hence clock providers that are disabled explicitly in DT
    using e.g.
    
            "status = "disabled";
    
    are still activated.
    
    Add a check to ignore device nodes that are not enabled, like
    of_irq_init() does.
    
    Reported-by: Ramesh Shanmugasundaram <ramesh.shanmugasundaram@bp.renesas.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 437eebf89fcf..b775c88ac36d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3138,6 +3138,9 @@ void __init of_clk_init(const struct of_device_id *matches)
 	for_each_matching_node_and_match(np, matches, &match) {
 		struct clock_provider *parent;
 
+		if (!of_device_is_available(np))
+			continue;
+
 		parent = kzalloc(sizeof(*parent), GFP_KERNEL);
 		if (!parent) {
 			list_for_each_entry_safe(clk_provider, next,

commit 023bd7166be0595d18220dfd5c9765b3970f6ef3
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Fri Feb 26 09:25:52 2016 +0800

    clk: skip unnecessary set_phase if nothing to do
    
    Let's compare the degrees from clk_set_rate with
    clk->core->phase. If the requested degrees is already
    there, skip the following steps.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    [sboyd@codeaurora.org: s/drgrees/degrees/ in commit text]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d95d6f924cac..437eebf89fcf 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1841,6 +1841,10 @@ int clk_set_phase(struct clk *clk, int degrees)
 
 	clk_prepare_lock();
 
+	/* bail early if nothing to do */
+	if (degrees == clk->core->phase)
+		goto out;
+
 	trace_clk_set_phase(clk->core, degrees);
 
 	if (clk->core->ops->set_phase)
@@ -1851,6 +1855,7 @@ int clk_set_phase(struct clk *clk, int degrees)
 	if (!ret)
 		clk->core->phase = degrees;
 
+out:
 	clk_prepare_unlock();
 
 	return ret;

commit 706d5c73e3367e2b866a211d1bff2cedab772146
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Feb 22 15:43:41 2016 -0800

    clk: Update some outdated comments
    
    __clk_init() was renamed to __clk_core_init() but these comments
    weren't updated.
    
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 51d673370d42..d95d6f924cac 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2157,7 +2157,7 @@ static int clk_debug_register(struct clk_core *core)
  *
  * Dynamically removes a clk and all its child nodes from the
  * debugfs clk directory if clk->dentry points to debugfs created by
- * clk_debug_register in __clk_init.
+ * clk_debug_register in __clk_core_init.
  */
 static void clk_debug_unregister(struct clk_core *core)
 {
@@ -2309,8 +2309,8 @@ static int __clk_core_init(struct clk_core *core)
 	core->parent = __clk_init_parent(core);
 
 	/*
-	 * Populate core->parent if parent has already been __clk_init'd.  If
-	 * parent has not yet been __clk_init'd then place clk in the orphan
+	 * Populate core->parent if parent has already been clk_core_init'd. If
+	 * parent has not yet been clk_core_init'd then place clk in the orphan
 	 * list.  If clk doesn't have any parents then place it in the root
 	 * clk list.
 	 *

commit fa459711a0b8fb190a12fe86b03d910c252a7f5c
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Feb 22 15:01:39 2016 -0800

    Revert "clk: avoid circular clock topology"
    
    This reverts commit 858d5881564026cbc4e6f5e25ae878a27df5d4c9.
    
    Joachim reports that this commit breaks lpc18xx boot. This is
    because the hardware has circular clk topology where PLLs can
    feed into dividers and the same dividers can feed into the PLLs.
    The hardware is designed this way so that you can choose to put
    the divider before the PLL or after the PLL depending on what you
    configure to be the parent of the divider and what you configure
    to be the parent of the PLL.
    
    So let's drop this patch for now because we have hardware that
    actually has loops. A future patch could check for circular
    parents when we change parents and fail the switch, but that's
    probably best left to some debugging Kconfig option so that we
    don't suffer the sanity checking cost all the time.
    
    Reported-by: Joachim Eastwood <manabian@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 58ef3dab894a..51d673370d42 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2241,38 +2241,6 @@ static inline void clk_debug_unregister(struct clk_core *core)
 }
 #endif
 
-/**
- * __clk_is_ancestor - check if a clk_core is a possible ancestor of another
- * @core: clock core
- * @ancestor: ancestor clock core
- *
- * Returns true if there is a possibility that @ancestor can be an ancestor
- * of @core, false otherwise.
- *
- * This function can be used against @core or @ancestor that has not been
- * registered yet.
- */
-static bool __clk_is_ancestor(struct clk_core *core, struct clk_core *ancestor)
-{
-	struct clk_core *parent;
-	int i;
-
-	for (i = 0; i < core->num_parents; i++) {
-		parent = clk_core_get_parent_by_index(core, i);
-		/*
-		 * If ancestor has not been added to clk_{root,orphan}_list
-		 * yet, clk_core_lookup() cannot find it.  If parent is NULL,
-		 * compare the name strings, too.
-		 */
-		if ((parent && (parent == ancestor ||
-				__clk_is_ancestor(parent, ancestor))) ||
-		    (!parent && !strcmp(core->parent_names[i], ancestor->name)))
-			return true;
-	}
-
-	return false;
-}
-
 /**
  * __clk_core_init - initialize the data structures in a struct clk_core
  * @core:	clk_core being initialized
@@ -2338,14 +2306,6 @@ static int __clk_core_init(struct clk_core *core)
 				"%s: invalid NULL in %s's .parent_names\n",
 				__func__, core->name);
 
-	/* If core is an ancestor of itself, it would make a loop. */
-	if (__clk_is_ancestor(core, core)) {
-		pr_err("%s: %s would create circular parent\n", __func__,
-		       core->name);
-		ret = -EINVAL;
-		goto out;
-	}
-
 	core->parent = __clk_init_parent(core);
 
 	/*

commit fb4dd22203e03087c71e5c8757ed14fc122bc9ea
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Feb 12 12:50:16 2016 -0600

    clk: Make of_clk_get_from_provider() available to modules
    
    Export symbol of_clk_get_from_provider so it can be used in
    loadable kernel modules
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 67cd2f116c3b..58ef3dab894a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3019,6 +3019,7 @@ struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 {
 	return __of_clk_get_from_provider(clkspec, NULL, __func__);
 }
+EXPORT_SYMBOL_GPL(of_clk_get_from_provider);
 
 int of_clk_get_parent_count(struct device_node *np)
 {

commit 2430a94d1e719b7b4af2a65b781a4c036eb22e64
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Feb 9 20:19:14 2016 +0900

    clk: fix __clk_init_parent() for single parent clocks
    
    Before commit b3d192d5121f ("clk: simplify __clk_init_parent()"),
    __clk_init_parent() called .get_parent() only for multi-parent
    clocks.  That commit changed the behavior to call .get_parent()
    if available even for single-parent clocks and root clocks.
    
    It turned out a problem because there are some single-parent clocks
    that implement .get_parent() callback and return non-zero index.
    The SOCFPGA clock is the case; the commit broke the SOCFPGA boards.
    
    To keep the original behavior, invoke .get_parent() only when
    num_parents is greater than 1.
    
    Fixes: b3d192d5121f ("clk: simplify __clk_init_parent()")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reported-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index cd8382c83f48..67cd2f116c3b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1662,7 +1662,7 @@ static struct clk_core *__clk_init_parent(struct clk_core *core)
 {
 	u8 index = 0;
 
-	if (core->ops->get_parent)
+	if (core->num_parents > 1 && core->ops->get_parent)
 		index = core->ops->get_parent(core->hw);
 
 	return clk_core_get_parent_by_index(core, index);

commit 47b0eeb3dc8a01848ad62908000b1051d1833eaf
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Feb 2 17:24:56 2016 -0800

    clk: Deprecate CLK_IS_ROOT
    
    We don't use CLK_IS_ROOT but in a few places in the common clk
    framework core. Let's replace those checks with a check for the
    number of parents a clk has instead of the flag, freeing up one
    flag for something else. We don't remove the flag yet so that
    things keep building, but we'll remove it once all drivers have
    removed their flag usage.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index bb01ed6cc63e..cd8382c83f48 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -385,7 +385,7 @@ static unsigned long clk_core_get_rate_nolock(struct clk_core *core)
 
 	ret = core->rate;
 
-	if (core->flags & CLK_IS_ROOT)
+	if (!core->num_parents)
 		goto out;
 
 	if (!core->parent)
@@ -2351,7 +2351,7 @@ static int __clk_core_init(struct clk_core *core)
 	/*
 	 * Populate core->parent if parent has already been __clk_init'd.  If
 	 * parent has not yet been __clk_init'd then place clk in the orphan
-	 * list.  If clk has set the CLK_IS_ROOT flag then place it in the root
+	 * list.  If clk doesn't have any parents then place it in the root
 	 * clk list.
 	 *
 	 * Every time a new clk is clk_init'd then we walk the list of orphan
@@ -2362,7 +2362,7 @@ static int __clk_core_init(struct clk_core *core)
 		hlist_add_head(&core->child_node,
 				&core->parent->children);
 		core->orphan = core->parent->orphan;
-	} else if (core->flags & CLK_IS_ROOT) {
+	} else if (!core->num_parents) {
 		hlist_add_head(&core->child_node, &clk_root_list);
 		core->orphan = false;
 	} else {

commit 4106a3d9ebb9839a8e93b0116c0f94dc4f10e4b2
Author: Insu Yun <wuninsu@gmail.com>
Date:   Sat Jan 30 10:12:04 2016 -0500

    clk: unlock for handling unregistered clock
    
    If clock is already unregistered, it returns with holding lock.
    It needs to be unlocked.
    
    Signed-off-by: Insu Yun <wuninsu@gmail.com>
    [sboyd@codeaurora.org: Use goto instead]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d31ed95d27a4..bb01ed6cc63e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2641,7 +2641,7 @@ void clk_unregister(struct clk *clk)
 	if (clk->core->ops == &clk_nodrv_ops) {
 		pr_err("%s: unregistered clock: %s\n", __func__,
 		       clk->core->name);
-		return;
+		goto unlock;
 	}
 	/*
 	 * Assign empty clock ops for consumers that might still hold
@@ -2667,7 +2667,7 @@ void clk_unregister(struct clk *clk)
 		pr_warn("%s: unregistering prepared clock: %s\n",
 					__func__, clk->core->name);
 	kref_put(&clk->core->ref, __clk_release);
-
+unlock:
 	clk_prepare_unlock();
 }
 EXPORT_SYMBOL_GPL(clk_unregister);

commit e8f0e68ec0802dc840e29e0fabdcfdc39aa2a8fb
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:10 2015 +0900

    clk: slightly optimize clk_core_set_parent()
    
    If clk_fetch_parent_index() fails, p_rate is unused.  Move the
    assignment after the error checking.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 82b79a6ec0ec..d31ed95d27a4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1748,13 +1748,13 @@ static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
 	/* try finding the new parent index */
 	if (parent) {
 		p_index = clk_fetch_parent_index(core, parent);
-		p_rate = parent->rate;
 		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",
 					__func__, parent->name, core->name);
 			ret = p_index;
 			goto out;
 		}
+		p_rate = parent->rate;
 	}
 
 	/* propagate PRE_RATE_CHANGE notifications */

commit 470b5e2f97cf8fb6a8375cc59e86314c9dd354c2
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:09 2015 +0900

    clk: simplify clk_fetch_parent_index() function
    
    The clk_core_get_parent_by_index can be used as a helper function
    to simplify the implementation of clk_fetch_parent_index().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index da7c9a523f02..82b79a6ec0ec 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1069,23 +1069,9 @@ static int clk_fetch_parent_index(struct clk_core *core,
 	if (!parent)
 		return -EINVAL;
 
-	/*
-	 * find index of new parent clock using cached parent ptrs,
-	 * or if not yet cached, use string name comparison and cache
-	 * them now to avoid future calls to clk_core_lookup.
-	 */
-	for (i = 0; i < core->num_parents; i++) {
-		if (core->parents[i] == parent)
-			return i;
-
-		if (core->parents[i])
-			continue;
-
-		if (!strcmp(core->parent_names[i], parent->name)) {
-			core->parents[i] = clk_core_lookup(parent->name);
+	for (i = 0; i < core->num_parents; i++)
+		if (clk_core_get_parent_by_index(core, i) == parent)
 			return i;
-		}
-	}
 
 	return -EINVAL;
 }

commit 508f884a66abb61f22fcc2b36ab1e68492f1d295
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:08 2015 +0900

    clk: make sure parent is not NULL in clk_fetch_parent_index()
    
    If parent is given with NULL, clk_fetch_parent_index() could return
    a positive index value.
    
    Currently, parent is checked by the callers of this function, but
    it would be safer to do it in this function.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 03820467fbba..da7c9a523f02 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1066,6 +1066,9 @@ static int clk_fetch_parent_index(struct clk_core *core,
 {
 	int i;
 
+	if (!parent)
+		return -EINVAL;
+
 	/*
 	 * find index of new parent clock using cached parent ptrs,
 	 * or if not yet cached, use string name comparison and cache

commit 0e8f6e499ebfd3617c81a89778f55fa6c54623e8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:07 2015 +0900

    clk: walk the orphan clock list more simply
    
    This loop can be much simpler. If a new parent is available for
    orphan clocks, __clk_init_parent(orphan) can detect it.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5a1507498e05..03820467fbba 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2422,24 +2422,15 @@ static int __clk_core_init(struct clk_core *core)
 	core->rate = core->req_rate = rate;
 
 	/*
-	 * walk the list of orphan clocks and reparent any that are children of
-	 * this clock
+	 * walk the list of orphan clocks and reparent any that newly finds a
+	 * parent.
 	 */
 	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
-		if (orphan->num_parents && orphan->ops->get_parent) {
-			i = orphan->ops->get_parent(orphan->hw);
-			if (i >= 0 && i < orphan->num_parents &&
-			    !strcmp(core->name, orphan->parent_names[i]))
-				clk_core_reparent(orphan, core);
-			continue;
-		}
+		struct clk_core *parent = __clk_init_parent(orphan);
 
-		for (i = 0; i < orphan->num_parents; i++)
-			if (!strcmp(core->name, orphan->parent_names[i])) {
-				clk_core_reparent(orphan, core);
-				break;
-			}
-	 }
+		if (parent)
+			clk_core_reparent(orphan, parent);
+	}
 
 	/*
 	 * optional platform-specific magic

commit 858d5881564026cbc4e6f5e25ae878a27df5d4c9
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:06 2015 +0900

    clk: avoid circular clock topology
    
    Currently, clk_register() never checks a circular parent looping,
    but clock providers could register such an insane clock topology.
    For example, "clk_a" could have "clk_b" as a parent, and vice versa.
    In this case, clk_core_reparent() creates a circular parent list
    and __clk_recalc_accuracies() calls itself recursively forever.
    
    The core infrastructure should be kind enough to bail out, showing
    an appropriate error message in such a case.  This helps to easily
    find a bug in clock providers.  (uh, I made such a silly mistake
    when I was implementing my clock providers first.  I was upset
    because the kernel did not respond, without any error message.)
    
    This commit adds a new helper function, __clk_is_ancestor().  It
    returns true if the second argument is a possible ancestor of the
    first one.  If a clock core is a possible ancestor of itself, it
    would make a loop when it were registered.  That should be detected
    as an error.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index dee9c528ea83..5a1507498e05 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2252,6 +2252,38 @@ static inline void clk_debug_unregister(struct clk_core *core)
 }
 #endif
 
+/**
+ * __clk_is_ancestor - check if a clk_core is a possible ancestor of another
+ * @core: clock core
+ * @ancestor: ancestor clock core
+ *
+ * Returns true if there is a possibility that @ancestor can be an ancestor
+ * of @core, false otherwise.
+ *
+ * This function can be used against @core or @ancestor that has not been
+ * registered yet.
+ */
+static bool __clk_is_ancestor(struct clk_core *core, struct clk_core *ancestor)
+{
+	struct clk_core *parent;
+	int i;
+
+	for (i = 0; i < core->num_parents; i++) {
+		parent = clk_core_get_parent_by_index(core, i);
+		/*
+		 * If ancestor has not been added to clk_{root,orphan}_list
+		 * yet, clk_core_lookup() cannot find it.  If parent is NULL,
+		 * compare the name strings, too.
+		 */
+		if ((parent && (parent == ancestor ||
+				__clk_is_ancestor(parent, ancestor))) ||
+		    (!parent && !strcmp(core->parent_names[i], ancestor->name)))
+			return true;
+	}
+
+	return false;
+}
+
 /**
  * __clk_core_init - initialize the data structures in a struct clk_core
  * @core:	clk_core being initialized
@@ -2317,6 +2349,14 @@ static int __clk_core_init(struct clk_core *core)
 				"%s: invalid NULL in %s's .parent_names\n",
 				__func__, core->name);
 
+	/* If core is an ancestor of itself, it would make a loop. */
+	if (__clk_is_ancestor(core, core)) {
+		pr_err("%s: %s would create circular parent\n", __func__,
+		       core->name);
+		ret = -EINVAL;
+		goto out;
+	}
+
 	core->parent = __clk_init_parent(core);
 
 	/*

commit 5146e0b05963f75347c9f4e18996da245f859e32
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:04 2015 +0900

    clk: simplify __clk_init_parent()
    
    The translation from the index into clk_core is done by
    clk_core_get_parent_by_index().  The if-block for num_parents == 1
    case is duplicating the code in the clk_core_get_parent_by_index().
    
    Drop the "if (num_parents == 1)" from the special case.  Instead,
    set the index to zero if .get_parent() is missing.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7fe94a5c6b4a..dee9c528ea83 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1669,44 +1669,14 @@ struct clk *clk_get_parent(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_parent);
 
-/*
- * .get_parent is mandatory for clocks with multiple possible parents.  It is
- * optional for single-parent clocks.  Always call .get_parent if it is
- * available and WARN if it is missing for multi-parent clocks.
- *
- * For single-parent clocks without .get_parent, first check to see if the
- * .parents array exists, and if so use it to avoid an expensive tree
- * traversal.  If .parents does not exist then walk the tree.
- */
 static struct clk_core *__clk_init_parent(struct clk_core *core)
 {
-	struct clk_core *ret = NULL;
-	u8 index;
-
-	/* handle the trivial cases */
+	u8 index = 0;
 
-	if (!core->num_parents)
-		goto out;
-
-	if (core->num_parents == 1) {
-		if (IS_ERR_OR_NULL(core->parent))
-			core->parent = clk_core_lookup(core->parent_names[0]);
-		ret = core->parent;
-		goto out;
-	}
+	if (core->ops->get_parent)
+		index = core->ops->get_parent(core->hw);
 
-	/*
-	 * Do our best to cache parent clocks in core->parents.  This prevents
-	 * unnecessary and expensive lookups.  We don't set core->parent here;
-	 * that is done by the calling function.
-	 */
-
-	index = core->ops->get_parent(core->hw);
-
-	ret = clk_core_get_parent_by_index(core, index);
-
-out:
-	return ret;
+	return clk_core_get_parent_by_index(core, index);
 }
 
 static void clk_core_reparent(struct clk_core *core,

commit 3c8e77dd20ab733f855e66bb6197ce84eb33e480
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:04 2015 +0900

    clk: move checking .get_parent to __clk_core_init()
    
    The .get_parent is mandatory for multi-parent clocks.  Move the check
    to __clk_core_init(), like other callback checkings.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    [sboyd@codeaurora.org: Squashed in error path handling, fix typos
    in commit message]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 09d84453ea3a..7fe94a5c6b4a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1695,13 +1695,6 @@ static struct clk_core *__clk_init_parent(struct clk_core *core)
 		goto out;
 	}
 
-	if (!core->ops->get_parent) {
-		WARN(!core->ops->get_parent,
-			"%s: multi-parent clocks must implement .get_parent\n",
-			__func__);
-		goto out;
-	}
-
 	/*
 	 * Do our best to cache parent clocks in core->parents.  This prevents
 	 * unnecessary and expensive lookups.  We don't set core->parent here;
@@ -2333,6 +2326,13 @@ static int __clk_core_init(struct clk_core *core)
 		goto out;
 	}
 
+	if (core->num_parents > 1 && !core->ops->get_parent) {
+		pr_err("%s: %s must implement .get_parent as it has multi parents\n",
+		       __func__, core->name);
+		ret = -EINVAL;
+		goto out;
+	}
+
 	if (core->ops->set_rate_and_parent &&
 			!(core->ops->set_parent && core->ops->set_rate)) {
 		pr_err("%s: %s must implement .set_parent & .set_rate\n",

commit c44fccb5f7b071d36cac3962799ba5a571429c28
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:03 2015 +0900

    clk: replace pr_warn() with pr_err() for fatal cases
    
    These three cases let clk_register() fail.  They should be considered
    as error messages.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 98c68e99d5f6..09d84453ea3a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2320,22 +2320,22 @@ static int __clk_core_init(struct clk_core *core)
 	if (core->ops->set_rate &&
 	    !((core->ops->round_rate || core->ops->determine_rate) &&
 	      core->ops->recalc_rate)) {
-		pr_warning("%s: %s must implement .round_rate or .determine_rate in addition to .recalc_rate\n",
-				__func__, core->name);
+		pr_err("%s: %s must implement .round_rate or .determine_rate in addition to .recalc_rate\n",
+		       __func__, core->name);
 		ret = -EINVAL;
 		goto out;
 	}
 
 	if (core->ops->set_parent && !core->ops->get_parent) {
-		pr_warning("%s: %s must implement .get_parent & .set_parent\n",
-				__func__, core->name);
+		pr_err("%s: %s must implement .get_parent & .set_parent\n",
+		       __func__, core->name);
 		ret = -EINVAL;
 		goto out;
 	}
 
 	if (core->ops->set_rate_and_parent &&
 			!(core->ops->set_parent && core->ops->set_rate)) {
-		pr_warn("%s: %s must implement .set_parent & .set_rate\n",
+		pr_err("%s: %s must implement .set_parent & .set_rate\n",
 				__func__, core->name);
 		ret = -EINVAL;
 		goto out;

commit 3c436bf95a1df22fa501be7134bccd29f8387dfe
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:02 2015 +0900

    clk: drop the initial core->parents look-ups from __clk_core_init()
    
    The core->parents is a cache to save expensive clock parent look-ups.
    It will be filled as needed later.  We do not have to do it here.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c2e993db0cfd..98c68e99d5f6 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2347,17 +2347,6 @@ static int __clk_core_init(struct clk_core *core)
 				"%s: invalid NULL in %s's .parent_names\n",
 				__func__, core->name);
 
-	/*
-	 * clk_core_lookup returns NULL for parents that have not been
-	 * clk_init'd; thus any access to clk->parents[] must check
-	 * for a NULL pointer.  We can always perform lazy lookups for
-	 * missing parents later on.
-	 */
-	if (core->parents)
-		for (i = 0; i < core->num_parents; i++)
-			core->parents[i] =
-				clk_core_lookup(core->parent_names[i]);
-
 	core->parent = __clk_init_parent(core);
 
 	/*

commit 88cfbef2acd38443c3eed780263b5f5e95a8dc1f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:01 2015 +0900

    clk: simplify clk_core_get_parent_by_index()
    
    Drop the "if (!core->parents)" case and refactor the function a bit
    because core->parents is always allocated.  (Strictly speaking, it is
    ZERO_SIZE_PTR if core->num_parents == 0, but such a case is omitted
    by the if-conditional above.)
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a92feedda592..c2e993db0cfd 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -350,13 +350,12 @@ static struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,
 {
 	if (!core || index >= core->num_parents)
 		return NULL;
-	else if (!core->parents)
-		return clk_core_lookup(core->parent_names[index]);
-	else if (!core->parents[index])
-		return core->parents[index] =
-			clk_core_lookup(core->parent_names[index]);
-	else
-		return core->parents[index];
+
+	if (!core->parents[index])
+		core->parents[index] =
+				clk_core_lookup(core->parent_names[index]);
+
+	return core->parents[index];
 }
 
 struct clk_hw *

commit 176d11690ba2c8ad59f99734d692f19f451c408b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:23:00 2015 +0900

    clk: move core->parents allocation to clk_register()
    
    Currently, __clk_core_init() allows failure of the kcalloc() for the
    core->parents.  So, clk_fetch_parent_index() and __clk_init_parent()
    also try to allocate core->parents in case it has not been allocated
    yet.  Scattering memory allocation here and there makes things
    complicated.
    
    Like other clk_core members, allocate core->parents in clk_register()
    and let it fail in case of memory shortage.  If we cannot allocate
    such a small piece of memory, the system is already insane.  There is
    no point to postpone the memory allocation.
    
    Also, allocate core->parents regardless of core->num_parents.  We want
    it even if core->num_parents == 1 because clk_fetch_parent_index()
    might be called against the clk_core with a single parent.
    
    If core->num_parents == 0, core->parents is set to ZERO_SIZE_PTR. It
    is harmless because no access happens to core->parents in such a case.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f9cab0919bb4..a92feedda592 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1067,13 +1067,6 @@ static int clk_fetch_parent_index(struct clk_core *core,
 {
 	int i;
 
-	if (!core->parents) {
-		core->parents = kcalloc(core->num_parents,
-					sizeof(*core->parents), GFP_KERNEL);
-		if (!core->parents)
-			return -ENOMEM;
-	}
-
 	/*
 	 * find index of new parent clock using cached parent ptrs,
 	 * or if not yet cached, use string name comparison and cache
@@ -1718,11 +1711,6 @@ static struct clk_core *__clk_init_parent(struct clk_core *core)
 
 	index = core->ops->get_parent(core->hw);
 
-	if (!core->parents)
-		core->parents =
-			kcalloc(core->num_parents, sizeof(*core->parents),
-					GFP_KERNEL);
-
 	ret = clk_core_get_parent_by_index(core, index);
 
 out:
@@ -2361,26 +2349,15 @@ static int __clk_core_init(struct clk_core *core)
 				__func__, core->name);
 
 	/*
-	 * Allocate an array of struct clk *'s to avoid unnecessary string
-	 * look-ups of clk's possible parents.  This can fail for clocks passed
-	 * in to clk_init during early boot; thus any access to core->parents[]
-	 * must always check for a NULL pointer and try to populate it if
-	 * necessary.
+	 * clk_core_lookup returns NULL for parents that have not been
+	 * clk_init'd; thus any access to clk->parents[] must check
+	 * for a NULL pointer.  We can always perform lazy lookups for
+	 * missing parents later on.
 	 */
-	if (core->num_parents > 1) {
-		core->parents = kcalloc(core->num_parents,
-					sizeof(*core->parents), GFP_KERNEL);
-		/*
-		 * clk_core_lookup returns NULL for parents that have not been
-		 * clk_init'd; thus any access to clk->parents[] must check
-		 * for a NULL pointer.  We can always perform lazy lookups for
-		 * missing parents later on.
-		 */
-		if (core->parents)
-			for (i = 0; i < core->num_parents; i++)
-				core->parents[i] =
-					clk_core_lookup(core->parent_names[i]);
-	}
+	if (core->parents)
+		for (i = 0; i < core->num_parents; i++)
+			core->parents[i] =
+				clk_core_lookup(core->parent_names[i]);
 
 	core->parent = __clk_init_parent(core);
 
@@ -2578,12 +2555,20 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		}
 	}
 
+	/* avoid unnecessary string look-ups of clk_core's possible parents. */
+	core->parents = kcalloc(core->num_parents, sizeof(*core->parents),
+				GFP_KERNEL);
+	if (!core->parents) {
+		ret = -ENOMEM;
+		goto fail_parents;
+	};
+
 	INIT_HLIST_HEAD(&core->clks);
 
 	hw->clk = __clk_create_clk(hw, NULL, NULL);
 	if (IS_ERR(hw->clk)) {
 		ret = PTR_ERR(hw->clk);
-		goto fail_parent_names_copy;
+		goto fail_parents;
 	}
 
 	ret = __clk_core_init(core);
@@ -2593,6 +2578,8 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	__clk_free_clk(hw->clk);
 	hw->clk = NULL;
 
+fail_parents:
+	kfree(core->parents);
 fail_parent_names_copy:
 	while (--i >= 0)
 		kfree_const(core->parent_names[i]);

commit 3a6e84545129913613dc1a97bbe8e4f2378696ee
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:22:59 2015 +0900

    clk: change sizeof(struct clk *) to sizeof(*core->parents)
    
    Now, the clock parent is not "struct clk *", but "struct clk_core *".
    Of course, the size of a pointer is always same, but strictly speaking,
    sizeof(struct clk *) should be sizeof(struct clk_core *) here.
    
    This mismatch happened when we split the structure into struct clk
    and struct clk_core.  For the potential possibility of future renaming,
    sizeof(*core->parents) would be better.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 735828d55c00..f9cab0919bb4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1069,7 +1069,7 @@ static int clk_fetch_parent_index(struct clk_core *core,
 
 	if (!core->parents) {
 		core->parents = kcalloc(core->num_parents,
-					sizeof(struct clk *), GFP_KERNEL);
+					sizeof(*core->parents), GFP_KERNEL);
 		if (!core->parents)
 			return -ENOMEM;
 	}
@@ -1720,7 +1720,7 @@ static struct clk_core *__clk_init_parent(struct clk_core *core)
 
 	if (!core->parents)
 		core->parents =
-			kcalloc(core->num_parents, sizeof(struct clk *),
+			kcalloc(core->num_parents, sizeof(*core->parents),
 					GFP_KERNEL);
 
 	ret = clk_core_get_parent_by_index(core, index);
@@ -2368,8 +2368,8 @@ static int __clk_core_init(struct clk_core *core)
 	 * necessary.
 	 */
 	if (core->num_parents > 1) {
-		core->parents = kcalloc(core->num_parents, sizeof(struct clk *),
-					GFP_KERNEL);
+		core->parents = kcalloc(core->num_parents,
+					sizeof(*core->parents), GFP_KERNEL);
 		/*
 		 * clk_core_lookup returns NULL for parents that have not been
 		 * clk_init'd; thus any access to clk->parents[] must check

commit 027f942ce44131bc3a11aaae6dbb227f461845b6
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:22:58 2015 +0900

    clk: remove unnecessary !core->parents conditional
    
    This if-block has been here since the introduction of the common
    clock framework.  Now no clock drivers are statically initialized.
    core->parent is always NULL at this point.  Drop the redundant
    check and the confusing comment.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index e7701d6029b3..735828d55c00 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2366,11 +2366,8 @@ static int __clk_core_init(struct clk_core *core)
 	 * in to clk_init during early boot; thus any access to core->parents[]
 	 * must always check for a NULL pointer and try to populate it if
 	 * necessary.
-	 *
-	 * If core->parents is not NULL we skip this entire block.  This allows
-	 * for clock drivers to statically initialize core->parents.
 	 */
-	if (core->num_parents > 1 && !core->parents) {
+	if (core->num_parents > 1) {
 		core->parents = kcalloc(core->num_parents, sizeof(struct clk *),
 					GFP_KERNEL);
 		/*

commit be45ebf25fc8866675f4822c74c9d0eb3dd96103
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:22:57 2015 +0900

    clk: rename __clk_init() into __clk_core_init()
    
    Now this function takes clk_core as its argument.  __clk_core_init()
    would be more suitable for the name of this function.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b8cd6bbdbbc0..e7701d6029b3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2303,13 +2303,13 @@ static inline void clk_debug_unregister(struct clk_core *core)
 #endif
 
 /**
- * __clk_init - initialize the data structures in a struct clk_core
+ * __clk_core_init - initialize the data structures in a struct clk_core
  * @core:	clk_core being initialized
  *
  * Initializes the lists in struct clk_core, queries the hardware for the
  * parent and rate and sets them both.
  */
-static int __clk_init(struct clk_core *core)
+static int __clk_core_init(struct clk_core *core)
 {
 	int i, ret = 0;
 	struct clk_core *orphan;
@@ -2589,7 +2589,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		goto fail_parent_names_copy;
 	}
 
-	ret = __clk_init(core);
+	ret = __clk_core_init(core);
 	if (!ret)
 		return hw->clk;
 

commit d35c80c248c7a97458b075225b1bf3e41c8a6d50
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:22:56 2015 +0900

    clk: change the argument of __clk_init() into pointer to clk_core
    
    The argument clk_user is used only for the clk_user->core.  The rest
    of this function only takes care of clk_core.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4bb7d09dfcf2..b8cd6bbdbbc0 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2303,25 +2303,22 @@ static inline void clk_debug_unregister(struct clk_core *core)
 #endif
 
 /**
- * __clk_init - initialize the data structures in a struct clk
- * @clk:	clk being initialized
+ * __clk_init - initialize the data structures in a struct clk_core
+ * @core:	clk_core being initialized
  *
  * Initializes the lists in struct clk_core, queries the hardware for the
  * parent and rate and sets them both.
  */
-static int __clk_init(struct clk *clk_user)
+static int __clk_init(struct clk_core *core)
 {
 	int i, ret = 0;
 	struct clk_core *orphan;
 	struct hlist_node *tmp2;
-	struct clk_core *core;
 	unsigned long rate;
 
-	if (!clk_user)
+	if (!core)
 		return -EINVAL;
 
-	core = clk_user->core;
-
 	clk_prepare_lock();
 
 	/* check to see if a clock with this name is already registered */
@@ -2592,7 +2589,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		goto fail_parent_names_copy;
 	}
 
-	ret = __clk_init(hw->clk);
+	ret = __clk_init(core);
 	if (!ret)
 		return hw->clk;
 

commit d9e743408ecd468974cd233623ed19253fa2a7b0
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Dec 28 19:22:55 2015 +0900

    clk: remove unused first argument of __clk_init()
    
    The "struct device *dev" is not used at all in this function.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b4db67a446c8..4bb7d09dfcf2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2304,13 +2304,12 @@ static inline void clk_debug_unregister(struct clk_core *core)
 
 /**
  * __clk_init - initialize the data structures in a struct clk
- * @dev:	device initializing this clk, placeholder for now
  * @clk:	clk being initialized
  *
  * Initializes the lists in struct clk_core, queries the hardware for the
  * parent and rate and sets them both.
  */
-static int __clk_init(struct device *dev, struct clk *clk_user)
+static int __clk_init(struct clk *clk_user)
 {
 	int i, ret = 0;
 	struct clk_core *orphan;
@@ -2593,7 +2592,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		goto fail_parent_names_copy;
 	}
 
-	ret = __clk_init(dev, hw->clk);
+	ret = __clk_init(hw->clk);
 	if (!ret)
 		return hw->clk;
 

commit a915e30dd26ea5f3cc2e2c044aba38ee5973d3fa
Merge: ce6dd266d535 b0158bb27c7b
Author: Michael Turquette <mturquette@baylibre.com>
Date:   Wed Dec 23 13:08:56 2015 -0800

    Merge branch 'clk-rockchip' into clk-next

commit 2eb8c7104c648ad4bfae1f5333f98c09522149b5
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Tue Dec 22 22:27:58 2015 +0100

    clk: add flag for clocks that need to be enabled on rate changes
    
    Some clocks need to be enabled to accept rate changes. This patch adds a
    new flag CLK_SET_RATE_UNGATE that lets clk_change_rate enable the clock
    before trying to change the rate and disable it again afterwards.
    This of course doesn't effect clocks that are already running at that
    point, as their refcount will only temporarily increase.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Reviewed-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f13c3f4228d4..bd64a9414de2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1443,6 +1443,15 @@ static void clk_change_rate(struct clk_core *core)
 	else if (core->parent)
 		best_parent_rate = core->parent->rate;
 
+	if (core->flags & CLK_SET_RATE_UNGATE) {
+		unsigned long flags;
+
+		clk_core_prepare(core);
+		flags = clk_enable_lock();
+		clk_core_enable(core);
+		clk_enable_unlock(flags);
+	}
+
 	if (core->new_parent && core->new_parent != core->parent) {
 		old_parent = __clk_set_parent_before(core, core->new_parent);
 		trace_clk_set_parent(core, core->new_parent);
@@ -1469,6 +1478,15 @@ static void clk_change_rate(struct clk_core *core)
 
 	core->rate = clk_recalc(core, best_parent_rate);
 
+	if (core->flags & CLK_SET_RATE_UNGATE) {
+		unsigned long flags;
+
+		flags = clk_enable_lock();
+		clk_core_disable(core);
+		clk_enable_unlock(flags);
+		clk_core_unprepare(core);
+	}
+
 	if (core->notifier_count && old_rate != core->rate)
 		__clk_notify(core, POST_RATE_CHANGE, old_rate, core->rate);
 

commit 8da411cc1964c5d6a0a0f94c7bbf8693c9673a87
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Dec 3 11:20:35 2015 +0900

    clk: let of_clk_get_parent_name() fail for invalid clock-indices
    
    Currently, of_clk_get_parent_name() returns a wrong parent clock name
    when "clock-indices" property exists and the target index is not
    found in the property.  In this case, NULL should be returned.
    
    For example,
    
            oscillator {
                    compatible = "myclocktype";
                    #clock-cells = <1>;
                    clock-indices = <1>, <3>;
                    clock-output-names = "clka", "clkb";
            };
    
            consumer {
                    compatible = "myclockconsumer";
                    clocks = <&oscillator 0>, <&oscillator 1>;
            };
    
    Currently, of_clk_get_parent_name(consumer_np, 0) returns "clka"
    (and of_clk_get_parent_name(consumer_np, 1) also returns "clka",
    this is correct).   Because the "clock-indices" in the clock parent
    does not contain <0>, of_clk_get_parent_name(consumer_np, 0) should
    return NULL.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a66efc9d8bfc..9352a13395c8 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3079,6 +3079,9 @@ const char *of_clk_get_parent_name(struct device_node *np, int index)
 		}
 		count++;
 	}
+	/* We went off the end of 'clock-indices' without finding it */
+	if (prop && !vp)
+		return NULL;
 
 	if (of_property_read_string_index(clkspec.np, "clock-output-names",
 					  index,

commit 198bb59493f810ece01e56e9694bfdb39b5aa056
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Nov 30 16:40:51 2015 +0900

    clk: fix a typo in comment block of clk_notifier_register()
    
    The word "cases" is doubled.  Keep decent forms for the following
    lines.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 27e99c7c57b9..a66efc9d8bfc 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2806,10 +2806,9 @@ void __clk_put(struct clk *clk)
  * re-enter into the clk framework by calling any top-level clk APIs;
  * this will cause a nested prepare_lock mutex.
  *
- * In all notification cases cases (pre, post and abort rate change) the
- * original clock rate is passed to the callback via struct
- * clk_notifier_data.old_rate and the new frequency is passed via struct
- * clk_notifier_data.new_rate.
+ * In all notification cases (pre, post and abort rate change) the original
+ * clock rate is passed to the callback via struct clk_notifier_data.old_rate
+ * and the new frequency is passed via struct clk_notifier_data.new_rate.
  *
  * clk_notifier_register() must be called from non-atomic context.
  * Returns -EINVAL if called with null arguments, -ENOMEM upon

commit 3fe003f944755f6d959387f9568d271512dcb12d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Oct 29 20:55:00 2015 +0100

    clk: Spelling s/derefing/dereferencing/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 20d8e07026a1..27e99c7c57b9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1944,7 +1944,7 @@ bool clk_is_match(const struct clk *p, const struct clk *q)
 	if (p == q)
 		return true;
 
-	/* true if clk->core pointers match. Avoid derefing garbage */
+	/* true if clk->core pointers match. Avoid dereferencing garbage */
 	if (!IS_ERR_OR_NULL(p) && !IS_ERR_OR_NULL(q))
 		if (p->core == q->core)
 			return true;

commit c1de13574d7880c7321abe789ef02fa540631eaf
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 20 14:38:49 2015 +0900

    clk: use IS_ERR_OR_NULL(hw) instead of !hw || IS_ERR(hw)
    
    This minor refactoring does not change the function behavior.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7429edebbe68..20d8e07026a1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2482,7 +2482,7 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 	struct clk *clk;
 
 	/* This is to allow this function to be chained to others */
-	if (!hw || IS_ERR(hw))
+	if (IS_ERR_OR_NULL(hw))
 		return (struct clk *) hw;
 
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);

commit c736c4e11e9def555482f3f626254594d3f11f9c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 20 16:36:19 2015 +0900

    clk: remove redundant negative index check in of_clk_get_parent_name()
    
    This if-block can be dropped because the of_parse_phandle_with_args()
    in the following line returns -EINVAL for negative index.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f13c3f4228d4..7429edebbe68 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3062,9 +3062,6 @@ const char *of_clk_get_parent_name(struct device_node *np, int index)
 	int count;
 	struct clk *clk;
 
-	if (index < 0)
-		return NULL;
-
 	rc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", index,
 					&clkspec);
 	if (rc)

commit be68bf883170b3e4123fc4ff3745e38fb45a573e
Author: Joachim Eastwood <manabian@gmail.com>
Date:   Sat Oct 24 18:55:22 2015 +0200

    clk: Add clk_hw_is_enabled() for use by clk providers
    
    Add clk_hw_is_enabled() to the provider APIs so clk providers can
    use a struct clk_hw instead of a struct clk to check if a clk is
    enabled or not.
    
    Signed-off-by: Joachim Eastwood <manabian@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2eae76f21d6f..f13c3f4228d4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -427,6 +427,11 @@ bool clk_hw_is_prepared(const struct clk_hw *hw)
 	return clk_core_is_prepared(hw->core);
 }
 
+bool clk_hw_is_enabled(const struct clk_hw *hw)
+{
+	return clk_core_is_enabled(hw->core);
+}
+
 bool __clk_is_enabled(struct clk *clk)
 {
 	if (!clk)

commit 6bc9d9d62cbc885414c7d4bb1926c43950498479
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Oct 21 22:41:36 2015 +0200

    clk: add missing of_node_put
    
    for_each_matching_node_and_match performs an of_node_get on each iteration,
    so a break out of the loop requires an of_node_put.
    
    A simplified version of the semantic patch that fixes this problem is as
    follows (http://coccinelle.lip6.fr):
    
    // <smpl>
    @@
    expression e1,e2,e;
    local idexpression np;
    @@
    
     for_each_matching_node_and_match(np, e1, e2) {
       ... when != of_node_put(np)
           when != e = np
    (
       return np;
    |
    +  of_node_put(np);
    ?  return ...;
    )
       ...
     }
    // </smpl>
    
    Besides the problem identified by the semantic patch, this patch adds an
    of_node_get in front of saving np in a field of parent, to account for the
    fact that this value will be put on going on to the next element in the
    iteration, and then adds of_node_puts in the two loops where the parent
    pointer can be freed.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ecb1e5232554..2eae76f21d6f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3197,13 +3197,15 @@ void __init of_clk_init(const struct of_device_id *matches)
 			list_for_each_entry_safe(clk_provider, next,
 						 &clk_provider_list, node) {
 				list_del(&clk_provider->node);
+				of_node_put(clk_provider->np);
 				kfree(clk_provider);
 			}
+			of_node_put(np);
 			return;
 		}
 
 		parent->clk_init_cb = match->data;
-		parent->np = np;
+		parent->np = of_node_get(np);
 		list_add_tail(&parent->node, &clk_provider_list);
 	}
 
@@ -3217,6 +3219,7 @@ void __init of_clk_init(const struct of_device_id *matches)
 				of_clk_set_defaults(clk_provider->np, true);
 
 				list_del(&clk_provider->node);
+				of_node_put(clk_provider->np);
 				kfree(clk_provider);
 				is_init_done = true;
 			}

commit b76281cb97761002277730432812b1687de96062
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Oct 16 14:35:21 2015 +0200

    clk: Make clk input parameter of __clk_get_name() const
    
    When calling __clk_get_name() on a const clock:
    
        warning: passing argument 1 of '__clk_get_name' discards 'const' qualifier from pointer target type
        include/linux/clk-provider.h:613:13: note: expected 'struct clk *' but argument is of type 'const struct clk *'
    
    __clk_get_name() does not modify the passed clock, hence make it const.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 63d0bfb29e83..ecb1e5232554 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -272,7 +272,7 @@ late_initcall_sync(clk_disable_unused);
 
 /***    helper functions   ***/
 
-const char *__clk_get_name(struct clk *clk)
+const char *__clk_get_name(const struct clk *clk)
 {
 	return !clk ? NULL : clk->core->name;
 }

commit 7e96353c3faaedea91f67972d011db41ed21b367
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Oct 16 17:12:32 2015 +0200

    clk: Use %u to format unsigned int in of_clk_src_onecell_get()
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a0fe9ca1f0af..63d0bfb29e83 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2932,7 +2932,7 @@ struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data)
 	unsigned int idx = clkspec->args[0];
 
 	if (idx >= clk_data->clk_num) {
-		pr_err("%s: invalid clock index %d\n", __func__, idx);
+		pr_err("%s: invalid clock index %u\n", __func__, idx);
 		return ERR_PTR(-EINVAL);
 	}
 

commit 0a4807c2f9a4a1afc2163089176abdc7ee4a361a
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Oct 14 14:03:07 2015 -0700

    clk: Make of_clk_get_parent_name() robust with #clock-cells = 1
    
    If a clock provider has #clock-cells = 1 and we call
    of_clk_get_parent_name() on it we may end up returning the name
    of the provider node if the provider doesn't have a
    clock-output-names property. This doesn't make sense, especially
    when you consider that calling of_clk_get_parent_name() on such a
    node with different indices will return the same name each time.
    
    Let's try getting the clock from the framework via of_clk_get()
    instead, and only fallback to the node name if we have a provider
    with #clock-cells = 0. This way, we can't hand out the same name
    for different clocks when we don't actually know their names.
    
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b005f666e3a1..a0fe9ca1f0af 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3055,6 +3055,7 @@ const char *of_clk_get_parent_name(struct device_node *np, int index)
 	u32 pv;
 	int rc;
 	int count;
+	struct clk *clk;
 
 	if (index < 0)
 		return NULL;
@@ -3080,8 +3081,25 @@ const char *of_clk_get_parent_name(struct device_node *np, int index)
 
 	if (of_property_read_string_index(clkspec.np, "clock-output-names",
 					  index,
-					  &clk_name) < 0)
-		clk_name = clkspec.np->name;
+					  &clk_name) < 0) {
+		/*
+		 * Best effort to get the name if the clock has been
+		 * registered with the framework. If the clock isn't
+		 * registered, we return the node name as the name of
+		 * the clock as long as #clock-cells = 0.
+		 */
+		clk = of_clk_get_from_provider(&clkspec);
+		if (IS_ERR(clk)) {
+			if (clkspec.args_count == 0)
+				clk_name = clkspec.np->name;
+			else
+				clk_name = NULL;
+		} else {
+			clk_name = __clk_get_name(clk);
+			clk_put(clk);
+		}
+	}
+
 
 	of_node_put(clkspec.np);
 	return clk_name;

commit ab5c342992cac7d1ddaf8a75a4dcab0d13718022
Merge: 90c53547fcae d34e210ed3a2
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Sep 17 12:28:41 2015 -0700

    Merge branch 'clk-fixes' into clk-next
    
    * clk-fixes:
      drivers: clk: st: Rename st_pll3200c32_407_c0_x into st_pll3200c32_cx_x
      clk: check for invalid parent index of orphans in __clk_init()

commit 90c53547fcae9daf46265fd9e74adc4f936cd919
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Sep 17 15:49:29 2015 +0200

    clk: Remove unneeded semicolons
    
    There are cleary typo errors so can be removed.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Leo Yan <leo.yan@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 43e2c3ad6c31..a66a6d433b1f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1685,7 +1685,7 @@ static struct clk_core *__clk_init_parent(struct clk_core *core)
 			"%s: multi-parent clocks must implement .get_parent\n",
 			__func__);
 		goto out;
-	};
+	}
 
 	/*
 	 * Do our best to cache parent clocks in core->parents.  This prevents

commit 9054a31d603ea82c6ed4914170a8708812a16324
Author: Mans Rullgard <mans@mansr.com>
Date:   Sun Feb 15 12:33:49 2015 +0000

    clk: check for invalid parent index of orphans in __clk_init()
    
    If a mux clock is initialised (by hardware or firmware) with an
    invalid parent, its ->get_parent() can return an out of range
    index.  For example, the generic mux clock attempts to return
    -EINVAL, which due to the u8 return type ends up a rather large
    number.  Using this index with the parent_names[] array results
    in an invalid pointer and (usually) a crash in the following
    strcmp().
    
    This patch adds a check for the parent index being in range,
    ignoring clocks reporting invalid values.
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    Tested-by: Rhyland Klein <rklein@nvidia.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 43e2c3ad6c31..0ebcf449778a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2437,7 +2437,8 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
 		if (orphan->num_parents && orphan->ops->get_parent) {
 			i = orphan->ops->get_parent(orphan->hw);
-			if (!strcmp(core->name, orphan->parent_names[i]))
+			if (i >= 0 && i < orphan->num_parents &&
+			    !strcmp(core->name, orphan->parent_names[i]))
 				clk_core_reparent(orphan, core);
 			continue;
 		}

commit c660b2ebb25be5668a4ed333539f34b05841e17a
Author: Dong Aisheng <aisheng.dong@freescale.com>
Date:   Tue Jul 28 21:19:41 2015 +0800

    clk: remove duplicated code with __clk_set_parent_after
    
    __clk_set_parent_after() actually used the second argument then we
    could put this duplicate logic in there and call it with a different
    order of arguments in the success vs. error paths in this function.
    
    Cc: Mike Turquette <mturquette@linaro.org>
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Dong Aisheng <aisheng.dong@freescale.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8e6688d1ecbd..43e2c3ad6c31 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1208,14 +1208,8 @@ static int __clk_set_parent(struct clk_core *core, struct clk_core *parent,
 		flags = clk_enable_lock();
 		clk_reparent(core, old_parent);
 		clk_enable_unlock(flags);
+		__clk_set_parent_after(core, old_parent, parent);
 
-		if (core->prepare_count) {
-			flags = clk_enable_lock();
-			clk_core_disable(core);
-			clk_core_disable(parent);
-			clk_enable_unlock(flags);
-			clk_core_unprepare(parent);
-		}
 		return ret;
 	}
 

commit e7df6f6e21883d7e8b3ad4641c911da8314ef283
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Aug 12 13:04:56 2015 -0700

    clk: Constify clk_hw argument to provider APIs
    
    We don't modify the clk_hw argument in these functions, so it's
    safe to mark it as const.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 128ad748b682..8e6688d1ecbd 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -278,7 +278,7 @@ const char *__clk_get_name(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_name);
 
-const char *clk_hw_get_name(struct clk_hw *hw)
+const char *clk_hw_get_name(const struct clk_hw *hw)
 {
 	return hw->core->name;
 }
@@ -290,13 +290,13 @@ struct clk_hw *__clk_get_hw(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_hw);
 
-unsigned int clk_hw_get_num_parents(struct clk_hw *hw)
+unsigned int clk_hw_get_num_parents(const struct clk_hw *hw)
 {
 	return hw->core->num_parents;
 }
 EXPORT_SYMBOL_GPL(clk_hw_get_num_parents);
 
-struct clk_hw *clk_hw_get_parent(struct clk_hw *hw)
+struct clk_hw *clk_hw_get_parent(const struct clk_hw *hw)
 {
 	return hw->core->parent ? hw->core->parent->hw : NULL;
 }
@@ -359,7 +359,8 @@ static struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,
 		return core->parents[index];
 }
 
-struct clk_hw *clk_hw_get_parent_by_index(struct clk_hw *hw, unsigned int index)
+struct clk_hw *
+clk_hw_get_parent_by_index(const struct clk_hw *hw, unsigned int index)
 {
 	struct clk_core *parent;
 
@@ -395,7 +396,7 @@ static unsigned long clk_core_get_rate_nolock(struct clk_core *core)
 	return ret;
 }
 
-unsigned long clk_hw_get_rate(struct clk_hw *hw)
+unsigned long clk_hw_get_rate(const struct clk_hw *hw)
 {
 	return clk_core_get_rate_nolock(hw->core);
 }
@@ -415,13 +416,13 @@ unsigned long __clk_get_flags(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_flags);
 
-unsigned long clk_hw_get_flags(struct clk_hw *hw)
+unsigned long clk_hw_get_flags(const struct clk_hw *hw)
 {
 	return hw->core->flags;
 }
 EXPORT_SYMBOL_GPL(clk_hw_get_flags);
 
-bool clk_hw_is_prepared(struct clk_hw *hw)
+bool clk_hw_is_prepared(const struct clk_hw *hw)
 {
 	return clk_core_is_prepared(hw->core);
 }

commit fc4a05d4b0eb1a0110ef11201bf563cd4b53fbce
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 25 17:24:15 2015 -0700

    clk: Remove unused provider APIs
    
    Remove these APIs now that we've converted all users to the
    replacement struct clk_hw based versions.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a30fd30f4948..128ad748b682 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -290,28 +290,12 @@ struct clk_hw *__clk_get_hw(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_hw);
 
-u8 __clk_get_num_parents(struct clk *clk)
-{
-	return !clk ? 0 : clk->core->num_parents;
-}
-EXPORT_SYMBOL_GPL(__clk_get_num_parents);
-
 unsigned int clk_hw_get_num_parents(struct clk_hw *hw)
 {
 	return hw->core->num_parents;
 }
 EXPORT_SYMBOL_GPL(clk_hw_get_num_parents);
 
-struct clk *__clk_get_parent(struct clk *clk)
-{
-	if (!clk)
-		return NULL;
-
-	/* TODO: Create a per-user clk and change callers to call clk_put */
-	return !clk->core->parent ? NULL : clk->core->parent->hw->clk;
-}
-EXPORT_SYMBOL_GPL(__clk_get_parent);
-
 struct clk_hw *clk_hw_get_parent(struct clk_hw *hw)
 {
 	return hw->core->parent ? hw->core->parent->hw : NULL;
@@ -375,19 +359,6 @@ static struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,
 		return core->parents[index];
 }
 
-struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
-{
-	struct clk_core *parent;
-
-	if (!clk)
-		return NULL;
-
-	parent = clk_core_get_parent_by_index(clk->core, index);
-
-	return !parent ? NULL : parent->hw->clk;
-}
-EXPORT_SYMBOL_GPL(clk_get_parent_by_index);
-
 struct clk_hw *clk_hw_get_parent_by_index(struct clk_hw *hw, unsigned int index)
 {
 	struct clk_core *parent;
@@ -424,15 +395,6 @@ static unsigned long clk_core_get_rate_nolock(struct clk_core *core)
 	return ret;
 }
 
-unsigned long __clk_get_rate(struct clk *clk)
-{
-	if (!clk)
-		return 0;
-
-	return clk_core_get_rate_nolock(clk->core);
-}
-EXPORT_SYMBOL_GPL(__clk_get_rate);
-
 unsigned long clk_hw_get_rate(struct clk_hw *hw)
 {
 	return clk_core_get_rate_nolock(hw->core);
@@ -459,14 +421,6 @@ unsigned long clk_hw_get_flags(struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(clk_hw_get_flags);
 
-bool __clk_is_prepared(struct clk *clk)
-{
-	if (!clk)
-		return false;
-
-	return clk_core_is_prepared(clk->core);
-}
-
 bool clk_hw_is_prepared(struct clk_hw *hw)
 {
 	return clk_core_is_prepared(hw->core);
@@ -880,32 +834,6 @@ int __clk_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)
 }
 EXPORT_SYMBOL_GPL(__clk_determine_rate);
 
-/**
- * __clk_round_rate - round the given rate for a clk
- * @clk: round the rate of this clock
- * @rate: the rate which is to be rounded
- *
- * Useful for clk_ops such as .set_rate
- */
-unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
-{
-	struct clk_rate_request req;
-	int ret;
-
-	if (!clk)
-		return 0;
-
-	clk_core_get_boundaries(clk->core, &req.min_rate, &req.max_rate);
-	req.rate = rate;
-
-	ret = clk_core_round_rate_nolock(clk->core, &req);
-	if (ret)
-		return 0;
-
-	return req.rate;
-}
-EXPORT_SYMBOL_GPL(__clk_round_rate);
-
 unsigned long clk_hw_round_rate(struct clk_hw *hw, unsigned long rate)
 {
 	int ret;
@@ -933,16 +861,24 @@ EXPORT_SYMBOL_GPL(clk_hw_round_rate);
  */
 long clk_round_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long ret;
+	struct clk_rate_request req;
+	int ret;
 
 	if (!clk)
 		return 0;
 
 	clk_prepare_lock();
-	ret = __clk_round_rate(clk, rate);
+
+	clk_core_get_boundaries(clk->core, &req.min_rate, &req.max_rate);
+	req.rate = rate;
+
+	ret = clk_core_round_rate_nolock(clk->core, &req);
 	clk_prepare_unlock();
 
-	return ret;
+	if (ret)
+		return ret;
+
+	return req.rate;
 }
 EXPORT_SYMBOL_GPL(clk_round_rate);
 
@@ -1711,8 +1647,12 @@ struct clk *clk_get_parent(struct clk *clk)
 {
 	struct clk *parent;
 
+	if (!clk)
+		return NULL;
+
 	clk_prepare_lock();
-	parent = __clk_get_parent(clk);
+	/* TODO: Create a per-user clk and change callers to call clk_put */
+	parent = !clk->core->parent ? NULL : clk->core->parent->hw->clk;
 	clk_prepare_unlock();
 
 	return parent;

commit 1a9c069cb2d28bb72fefee509e0d26f92d7f7166
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 25 15:55:14 2015 -0700

    clk: Add clk_hw_*() APIs for use by clk providers
    
    clk providers shouldn't need to use the consumer APIs (clk.h).
    Add provider APIs to replace the __clk_*() APIs that take a
    struct clk_hw as their first argument instead of a struct clk.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4912c2e55e2c..a30fd30f4948 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -278,6 +278,12 @@ const char *__clk_get_name(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_name);
 
+const char *clk_hw_get_name(struct clk_hw *hw)
+{
+	return hw->core->name;
+}
+EXPORT_SYMBOL_GPL(clk_hw_get_name);
+
 struct clk_hw *__clk_get_hw(struct clk *clk)
 {
 	return !clk ? NULL : clk->core->hw;
@@ -290,6 +296,12 @@ u8 __clk_get_num_parents(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_num_parents);
 
+unsigned int clk_hw_get_num_parents(struct clk_hw *hw)
+{
+	return hw->core->num_parents;
+}
+EXPORT_SYMBOL_GPL(clk_hw_get_num_parents);
+
 struct clk *__clk_get_parent(struct clk *clk)
 {
 	if (!clk)
@@ -300,6 +312,12 @@ struct clk *__clk_get_parent(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_parent);
 
+struct clk_hw *clk_hw_get_parent(struct clk_hw *hw)
+{
+	return hw->core->parent ? hw->core->parent->hw : NULL;
+}
+EXPORT_SYMBOL_GPL(clk_hw_get_parent);
+
 static struct clk_core *__clk_lookup_subtree(const char *name,
 					     struct clk_core *core)
 {
@@ -370,6 +388,16 @@ struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
 }
 EXPORT_SYMBOL_GPL(clk_get_parent_by_index);
 
+struct clk_hw *clk_hw_get_parent_by_index(struct clk_hw *hw, unsigned int index)
+{
+	struct clk_core *parent;
+
+	parent = clk_core_get_parent_by_index(hw->core, index);
+
+	return !parent ? NULL : parent->hw;
+}
+EXPORT_SYMBOL_GPL(clk_hw_get_parent_by_index);
+
 unsigned int __clk_get_enable_count(struct clk *clk)
 {
 	return !clk ? 0 : clk->core->enable_count;
@@ -405,6 +433,12 @@ unsigned long __clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_rate);
 
+unsigned long clk_hw_get_rate(struct clk_hw *hw)
+{
+	return clk_core_get_rate_nolock(hw->core);
+}
+EXPORT_SYMBOL_GPL(clk_hw_get_rate);
+
 static unsigned long __clk_get_accuracy(struct clk_core *core)
 {
 	if (!core)
@@ -419,6 +453,12 @@ unsigned long __clk_get_flags(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_flags);
 
+unsigned long clk_hw_get_flags(struct clk_hw *hw)
+{
+	return hw->core->flags;
+}
+EXPORT_SYMBOL_GPL(clk_hw_get_flags);
+
 bool __clk_is_prepared(struct clk *clk)
 {
 	if (!clk)
@@ -427,6 +467,11 @@ bool __clk_is_prepared(struct clk *clk)
 	return clk_core_is_prepared(clk->core);
 }
 
+bool clk_hw_is_prepared(struct clk_hw *hw)
+{
+	return clk_core_is_prepared(hw->core);
+}
+
 bool __clk_is_enabled(struct clk *clk)
 {
 	if (!clk)
@@ -861,6 +906,22 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 }
 EXPORT_SYMBOL_GPL(__clk_round_rate);
 
+unsigned long clk_hw_round_rate(struct clk_hw *hw, unsigned long rate)
+{
+	int ret;
+	struct clk_rate_request req;
+
+	clk_core_get_boundaries(hw->core, &req.min_rate, &req.max_rate);
+	req.rate = rate;
+
+	ret = clk_core_round_rate_nolock(hw->core, &req);
+	if (ret)
+		return 0;
+
+	return req.rate;
+}
+EXPORT_SYMBOL_GPL(clk_hw_round_rate);
+
 /**
  * clk_round_rate - round the given rate for a clk
  * @clk: the clk for which we are rounding a rate

commit e6500344edbbc405cde8d20a9c0d165a4efa9142
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Wed Apr 22 22:53:05 2015 +0200

    clk: track the orphan status of clocks and their children
    
    While children of orphan clocks are not carried in the orphan-list itself,
    they're nevertheless orphans in their own right as they also don't have an
    input-rate available. To ease tracking if a clock is an orphan or has an
    orphan in its parent path introduce an orphan field into struct clk and
    update it and the fields in child-clocks when a clock gets added or removed
    from the orphan-list.
    
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Alex Elder <elder@linaro.org>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: kernel@pengutronix.de
    Cc: Zhangfei Gao <zhangfei.gao@linaro.org>
    Cc: Santosh Shilimkar <ssantosh@kernel.org>
    Cc: Chao Xie <chao.xie@marvell.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Georgi Djakov <georgi.djakov@linaro.org>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Barry Song <baohua@kernel.org>
    Cc: Dinh Nguyen <dinguyen@opensource.altera.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Gabriel FERNANDEZ <gabriel.fernandez@st.com>
    Cc: emilio@elopez.com.ar
    Cc: Peter De Schrijver <pdeschrijver@nvidia.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Michal Simek <michal.simek@xilinx.com>
    [sboyd@codeaurora.org: s/clk/core/ in new function]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 898052ee0efa..4912c2e55e2c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -57,6 +57,7 @@ struct clk_core {
 	struct clk_core		*new_parent;
 	struct clk_core		*new_child;
 	unsigned long		flags;
+	bool			orphan;
 	unsigned int		enable_count;
 	unsigned int		prepare_count;
 	unsigned long		min_rate;
@@ -1091,18 +1092,40 @@ static int clk_fetch_parent_index(struct clk_core *core,
 	return -EINVAL;
 }
 
+/*
+ * Update the orphan status of @core and all its children.
+ */
+static void clk_core_update_orphan_status(struct clk_core *core, bool is_orphan)
+{
+	struct clk_core *child;
+
+	core->orphan = is_orphan;
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_core_update_orphan_status(child, is_orphan);
+}
+
 static void clk_reparent(struct clk_core *core, struct clk_core *new_parent)
 {
+	bool was_orphan = core->orphan;
+
 	hlist_del(&core->child_node);
 
 	if (new_parent) {
+		bool becomes_orphan = new_parent->orphan;
+
 		/* avoid duplicate POST_RATE_CHANGE notifications */
 		if (new_parent->new_child == core)
 			new_parent->new_child = NULL;
 
 		hlist_add_head(&core->child_node, &new_parent->children);
+
+		if (was_orphan != becomes_orphan)
+			clk_core_update_orphan_status(core, becomes_orphan);
 	} else {
 		hlist_add_head(&core->child_node, &clk_orphan_list);
+		if (!was_orphan)
+			clk_core_update_orphan_status(core, true);
 	}
 
 	core->parent = new_parent;
@@ -2359,13 +2382,17 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	 * clocks and re-parent any that are children of the clock currently
 	 * being clk_init'd.
 	 */
-	if (core->parent)
+	if (core->parent) {
 		hlist_add_head(&core->child_node,
 				&core->parent->children);
-	else if (core->flags & CLK_IS_ROOT)
+		core->orphan = core->parent->orphan;
+	} else if (core->flags & CLK_IS_ROOT) {
 		hlist_add_head(&core->child_node, &clk_root_list);
-	else
+		core->orphan = false;
+	} else {
 		hlist_add_head(&core->child_node, &clk_orphan_list);
+		core->orphan = true;
+	}
 
 	/*
 	 * Set clk's accuracy.  The preferred method is to use

commit a57aa18539f8b232065f574f438edb646c6b9d9b
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jul 24 12:24:48 2015 -0700

    clk: Silence warnings about lock imbalances
    
    The recursive spinlock implementation trips up sparse and it
    complains that these functions have lock imbalances. That isn't
    really true though, so add some __acquires() and __releases()
    information so that sparse is quiet.
    
    drivers/clk/clk.c:116:22: warning: context imbalance in 'clk_enable_lock' - wrong count at exit
    drivers/clk/clk.c:141:9: warning: context imbalance in 'clk_enable_unlock' - unexpected unlock
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 819ffa6db83d..898052ee0efa 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -114,12 +114,14 @@ static void clk_prepare_unlock(void)
 }
 
 static unsigned long clk_enable_lock(void)
+	__acquires(enable_lock)
 {
 	unsigned long flags;
 
 	if (!spin_trylock_irqsave(&enable_lock, flags)) {
 		if (enable_owner == current) {
 			enable_refcnt++;
+			__acquire(enable_lock);
 			return flags;
 		}
 		spin_lock_irqsave(&enable_lock, flags);
@@ -132,12 +134,15 @@ static unsigned long clk_enable_lock(void)
 }
 
 static void clk_enable_unlock(unsigned long flags)
+	__releases(enable_lock)
 {
 	WARN_ON_ONCE(enable_owner != current);
 	WARN_ON_ONCE(enable_refcnt == 0);
 
-	if (--enable_refcnt)
+	if (--enable_refcnt) {
+		__release(enable_lock);
 		return;
+	}
 	enable_owner = NULL;
 	spin_unlock_irqrestore(&enable_lock, flags);
 }

commit 9cfad9bc472a4bdd5ee7d9e713113a9f5a676704
Merge: 9da9e7612737 61ae76563ec3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 21 11:22:42 2015 -0700

    Merge branch 'cleanup-clk-h-includes' into clk-next
    
    * cleanup-clk-h-includes: (62 commits)
      clk: Remove clk.h from clk-provider.h
      clk: h8300: Remove clk.h and clkdev.h includes
      clk: at91: Include clk.h and slab.h
      clk: ti: Switch clk-provider.h include to clk.h
      clk: pistachio: Include clk.h
      clk: ingenic: Include clk.h
      clk: si570: Include clk.h
      clk: moxart: Include clk.h
      clk: cdce925: Include clk.h
      clk: Include clk.h in clk.c
      clk: zynq: Include clk.h
      clk: ti: Include clk.h
      clk: sunxi: Include clk.h and remove unused clkdev.h includes
      clk: st: Include clk.h
      clk: qcom: Include clk.h
      clk: highbank: Include clk.h
      clk: bcm: Include clk.h
      clk: versatile: Remove clk.h and clkdev.h includes
      clk: ux500: Remove clk.h and clkdev.h includes
      clk: tegra: Properly include clk.h
      ...

commit 9783c0d98501aa146ff467916ab4b8830a655d7c
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 16 12:50:27 2015 -0700

    clk: Allow providers to configure min/max rates
    
    clk providers are using the consumer APIs to set min/max rates on
    the clock they're providing. To encourage clk providers to move
    away from the consumer APIs, add a provider API to set the
    min/max rate of a clock. The assumption is that this is done
    before the clock can be requested via clk_get() and that the
    clock rate is already within the boundaries of the min/max that's
    configured.
    
    Tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index bd6dfbe04cf0..1ac237fe2fdb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -58,6 +58,8 @@ struct clk_core {
 	unsigned long		flags;
 	unsigned int		enable_count;
 	unsigned int		prepare_count;
+	unsigned long		min_rate;
+	unsigned long		max_rate;
 	unsigned long		accuracy;
 	int			phase;
 	struct hlist_head	children;
@@ -512,8 +514,8 @@ static void clk_core_get_boundaries(struct clk_core *core,
 {
 	struct clk *clk_user;
 
-	*min_rate = 0;
-	*max_rate = ULONG_MAX;
+	*min_rate = core->min_rate;
+	*max_rate = core->max_rate;
 
 	hlist_for_each_entry(clk_user, &core->clks, clks_node)
 		*min_rate = max(*min_rate, clk_user->min_rate);
@@ -522,6 +524,14 @@ static void clk_core_get_boundaries(struct clk_core *core,
 		*max_rate = min(*max_rate, clk_user->max_rate);
 }
 
+void clk_hw_set_rate_range(struct clk_hw *hw, unsigned long min_rate,
+			   unsigned long max_rate)
+{
+	hw->core->min_rate = min_rate;
+	hw->core->max_rate = max_rate;
+}
+EXPORT_SYMBOL_GPL(clk_hw_set_rate_range);
+
 /*
  * Helper for finding best parent to provide a given frequency. This can be used
  * directly as a determine_rate callback (e.g. for a mux), or from a more
@@ -2498,6 +2508,8 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	core->hw = hw;
 	core->flags = hw->init->flags;
 	core->num_parents = hw->init->num_parents;
+	core->min_rate = 0;
+	core->max_rate = ULONG_MAX;
 	hw->core = core;
 
 	/* allocate local copy in case parent_names is __initdata */

commit 19aab273083fa10c2262b8c8e3315bacb054d75d
Merge: 86665d289720 57d866e606dd
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 28 11:51:30 2015 -0700

    Merge branch 'clk-determine-rate-struct' into clk-next
    
    * clk-determine-rate-struct:
      clk: fix some determine_rate implementations
      clk: change clk_ops' ->determine_rate() prototype

commit 57d866e606ddf2a0cd51f7140cfd8df1fdaa48f6
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Jul 9 22:39:38 2015 +0200

    clk: fix some determine_rate implementations
    
    Some determine_rate implementations are not returning an error
    when they failed to adapt the rate according to the rate request.
    Fix them so that they return an error instead of silently
    returning 0.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    CC: Jonathan Corbet <corbet@lwn.net>
    CC: Tony Lindgren <tony@atomide.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: "Emilio Lpez" <emilio@elopez.com.ar>
    CC: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    CC: Peter De Schrijver <pdeschrijver@nvidia.com>
    CC: Prashant Gaikwad <pgaikwad@nvidia.com>
    CC: Stephen Warren <swarren@wwwdotorg.org>
    CC: Thierry Reding <thierry.reding@gmail.com>
    CC: Alexandre Courbot <gnurou@gmail.com>
    CC: linux-doc@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-omap@vger.kernel.org
    CC: linux-mips@linux-mips.org
    CC: linux-tegra@vger.kernel.org
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4e9ff928ef88..c907289ff03c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -487,6 +487,9 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, struct clk_rate_request *req,
 		}
 	}
 
+	if (!best_parent)
+		return -EINVAL;
+
 out:
 	if (best_parent)
 		req->best_parent_hw = best_parent->hw;

commit 0817b62cc037a56c5e4238c7eb7522299ea27aef
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jul 7 20:48:08 2015 +0200

    clk: change clk_ops' ->determine_rate() prototype
    
    Clock rates are stored in an unsigned long field, but ->determine_rate()
    (which returns a rounded rate from a requested one) returns a long
    value (errors are reported using negative error codes), which can lead
    to long overflow if the clock rate exceed 2Ghz.
    
    Change ->determine_rate() prototype to return 0 or an error code, and pass
    a pointer to a clk_rate_request structure containing the expected target
    rate and the rate constraints imposed by clk users.
    
    The clk_rate_request structure might be extended in the future to contain
    other kind of constraints like the rounding policy, the maximum clock
    inaccuracy or other things that are not yet supported by the CCF
    (power consumption constraints ?).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    CC: Jonathan Corbet <corbet@lwn.net>
    CC: Tony Lindgren <tony@atomide.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: "Emilio Lpez" <emilio@elopez.com.ar>
    CC: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    CC: Peter De Schrijver <pdeschrijver@nvidia.com>
    CC: Prashant Gaikwad <pgaikwad@nvidia.com>
    CC: Stephen Warren <swarren@wwwdotorg.org>
    CC: Thierry Reding <thierry.reding@gmail.com>
    CC: Alexandre Courbot <gnurou@gmail.com>
    CC: linux-doc@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-omap@vger.kernel.org
    CC: linux-mips@linux-mips.org
    CC: linux-tegra@vger.kernel.org
    [sboyd@codeaurora.org: Fix parent dereference problem in
    __clk_determine_rate()]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: Romain Perier <romain.perier@gmail.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    [sboyd@codeaurora.org: Folded in fix from Heiko for fixed-rate
    clocks without parents or a rate determining op]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ddb4b541016f..4e9ff928ef88 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -436,28 +436,31 @@ static bool mux_is_better_rate(unsigned long rate, unsigned long now,
 	return now <= rate && now > best;
 }
 
-static long
-clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
-			     unsigned long min_rate,
-			     unsigned long max_rate,
-			     unsigned long *best_parent_rate,
-			     struct clk_hw **best_parent_p,
+static int
+clk_mux_determine_rate_flags(struct clk_hw *hw, struct clk_rate_request *req,
 			     unsigned long flags)
 {
 	struct clk_core *core = hw->core, *parent, *best_parent = NULL;
-	int i, num_parents;
-	unsigned long parent_rate, best = 0;
+	int i, num_parents, ret;
+	unsigned long best = 0;
+	struct clk_rate_request parent_req = *req;
 
 	/* if NO_REPARENT flag set, pass through to current parent */
 	if (core->flags & CLK_SET_RATE_NO_REPARENT) {
 		parent = core->parent;
-		if (core->flags & CLK_SET_RATE_PARENT)
-			best = __clk_determine_rate(parent ? parent->hw : NULL,
-						    rate, min_rate, max_rate);
-		else if (parent)
+		if (core->flags & CLK_SET_RATE_PARENT) {
+			ret = __clk_determine_rate(parent ? parent->hw : NULL,
+						   &parent_req);
+			if (ret)
+				return ret;
+
+			best = parent_req.rate;
+		} else if (parent) {
 			best = clk_core_get_rate_nolock(parent);
-		else
+		} else {
 			best = clk_core_get_rate_nolock(core);
+		}
+
 		goto out;
 	}
 
@@ -467,24 +470,30 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
 		parent = clk_core_get_parent_by_index(core, i);
 		if (!parent)
 			continue;
-		if (core->flags & CLK_SET_RATE_PARENT)
-			parent_rate = __clk_determine_rate(parent->hw, rate,
-							   min_rate,
-							   max_rate);
-		else
-			parent_rate = clk_core_get_rate_nolock(parent);
-		if (mux_is_better_rate(rate, parent_rate, best, flags)) {
+
+		if (core->flags & CLK_SET_RATE_PARENT) {
+			parent_req = *req;
+			ret = __clk_determine_rate(parent->hw, &parent_req);
+			if (ret)
+				continue;
+		} else {
+			parent_req.rate = clk_core_get_rate_nolock(parent);
+		}
+
+		if (mux_is_better_rate(req->rate, parent_req.rate,
+				       best, flags)) {
 			best_parent = parent;
-			best = parent_rate;
+			best = parent_req.rate;
 		}
 	}
 
 out:
 	if (best_parent)
-		*best_parent_p = best_parent->hw;
-	*best_parent_rate = best;
+		req->best_parent_hw = best_parent->hw;
+	req->best_parent_rate = best;
+	req->rate = best;
 
-	return best;
+	return 0;
 }
 
 struct clk *__clk_lookup(const char *name)
@@ -515,28 +524,17 @@ static void clk_core_get_boundaries(struct clk_core *core,
  * directly as a determine_rate callback (e.g. for a mux), or from a more
  * complex clock that may combine a mux with other operations.
  */
-long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
-			      unsigned long min_rate,
-			      unsigned long max_rate,
-			      unsigned long *best_parent_rate,
-			      struct clk_hw **best_parent_p)
+int __clk_mux_determine_rate(struct clk_hw *hw,
+			     struct clk_rate_request *req)
 {
-	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
-					    best_parent_rate,
-					    best_parent_p, 0);
+	return clk_mux_determine_rate_flags(hw, req, 0);
 }
 EXPORT_SYMBOL_GPL(__clk_mux_determine_rate);
 
-long __clk_mux_determine_rate_closest(struct clk_hw *hw, unsigned long rate,
-			      unsigned long min_rate,
-			      unsigned long max_rate,
-			      unsigned long *best_parent_rate,
-			      struct clk_hw **best_parent_p)
+int __clk_mux_determine_rate_closest(struct clk_hw *hw,
+				     struct clk_rate_request *req)
 {
-	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
-					    best_parent_rate,
-					    best_parent_p,
-					    CLK_MUX_ROUND_CLOSEST);
+	return clk_mux_determine_rate_flags(hw, req, CLK_MUX_ROUND_CLOSEST);
 }
 EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
 
@@ -759,14 +757,11 @@ int clk_enable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_enable);
 
-static unsigned long clk_core_round_rate_nolock(struct clk_core *core,
-						unsigned long rate,
-						unsigned long min_rate,
-						unsigned long max_rate)
+static int clk_core_round_rate_nolock(struct clk_core *core,
+				      struct clk_rate_request *req)
 {
-	unsigned long parent_rate = 0;
 	struct clk_core *parent;
-	struct clk_hw *parent_hw;
+	long rate;
 
 	lockdep_assert_held(&prepare_lock);
 
@@ -774,21 +769,30 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *core,
 		return 0;
 
 	parent = core->parent;
-	if (parent)
-		parent_rate = parent->rate;
+	if (parent) {
+		req->best_parent_hw = parent->hw;
+		req->best_parent_rate = parent->rate;
+	} else {
+		req->best_parent_hw = NULL;
+		req->best_parent_rate = 0;
+	}
 
 	if (core->ops->determine_rate) {
-		parent_hw = parent ? parent->hw : NULL;
-		return core->ops->determine_rate(core->hw, rate,
-						min_rate, max_rate,
-						&parent_rate, &parent_hw);
-	} else if (core->ops->round_rate)
-		return core->ops->round_rate(core->hw, rate, &parent_rate);
-	else if (core->flags & CLK_SET_RATE_PARENT)
-		return clk_core_round_rate_nolock(core->parent, rate, min_rate,
-						  max_rate);
-	else
-		return core->rate;
+		return core->ops->determine_rate(core->hw, req);
+	} else if (core->ops->round_rate) {
+		rate = core->ops->round_rate(core->hw, req->rate,
+					     &req->best_parent_rate);
+		if (rate < 0)
+			return rate;
+
+		req->rate = rate;
+	} else if (core->flags & CLK_SET_RATE_PARENT) {
+		return clk_core_round_rate_nolock(parent, req);
+	} else {
+		req->rate = core->rate;
+	}
+
+	return 0;
 }
 
 /**
@@ -800,15 +804,14 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *core,
  *
  * Useful for clk_ops such as .set_rate and .determine_rate.
  */
-unsigned long __clk_determine_rate(struct clk_hw *hw,
-				   unsigned long rate,
-				   unsigned long min_rate,
-				   unsigned long max_rate)
+int __clk_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)
 {
-	if (!hw)
+	if (!hw) {
+		req->rate = 0;
 		return 0;
+	}
 
-	return clk_core_round_rate_nolock(hw->core, rate, min_rate, max_rate);
+	return clk_core_round_rate_nolock(hw->core, req);
 }
 EXPORT_SYMBOL_GPL(__clk_determine_rate);
 
@@ -821,15 +824,20 @@ EXPORT_SYMBOL_GPL(__clk_determine_rate);
  */
 unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long min_rate;
-	unsigned long max_rate;
+	struct clk_rate_request req;
+	int ret;
 
 	if (!clk)
 		return 0;
 
-	clk_core_get_boundaries(clk->core, &min_rate, &max_rate);
+	clk_core_get_boundaries(clk->core, &req.min_rate, &req.max_rate);
+	req.rate = rate;
+
+	ret = clk_core_round_rate_nolock(clk->core, &req);
+	if (ret)
+		return 0;
 
-	return clk_core_round_rate_nolock(clk->core, rate, min_rate, max_rate);
+	return req.rate;
 }
 EXPORT_SYMBOL_GPL(__clk_round_rate);
 
@@ -1249,7 +1257,6 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *core,
 {
 	struct clk_core *top = core;
 	struct clk_core *old_parent, *parent;
-	struct clk_hw *parent_hw;
 	unsigned long best_parent_rate = 0;
 	unsigned long new_rate;
 	unsigned long min_rate;
@@ -1270,20 +1277,29 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *core,
 
 	/* find the closest rate and parent clk/rate */
 	if (core->ops->determine_rate) {
-		parent_hw = parent ? parent->hw : NULL;
-		ret = core->ops->determine_rate(core->hw, rate,
-					       min_rate,
-					       max_rate,
-					       &best_parent_rate,
-					       &parent_hw);
+		struct clk_rate_request req;
+
+		req.rate = rate;
+		req.min_rate = min_rate;
+		req.max_rate = max_rate;
+		if (parent) {
+			req.best_parent_hw = parent->hw;
+			req.best_parent_rate = parent->rate;
+		} else {
+			req.best_parent_hw = NULL;
+			req.best_parent_rate = 0;
+		}
+
+		ret = core->ops->determine_rate(core->hw, &req);
 		if (ret < 0)
 			return NULL;
 
-		new_rate = ret;
-		parent = parent_hw ? parent_hw->core : NULL;
+		best_parent_rate = req.best_parent_rate;
+		new_rate = req.rate;
+		parent = req.best_parent_hw ? req.best_parent_hw->core : NULL;
 	} else if (core->ops->round_rate) {
 		ret = core->ops->round_rate(core->hw, rate,
-					   &best_parent_rate);
+					    &best_parent_rate);
 		if (ret < 0)
 			return NULL;
 

commit 3c37311730efec287b323e0928c9cf3737ab93e2
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: Include clk.h in clk.c
    
    This file implements the clk API and so it should include clk.h
    directly instead of indirectly including it through
    clk-provider.h.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ddb4b541016f..89e531a3f384 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -9,6 +9,7 @@
  * Standard functionality for the common clock API.  See Documentation/clk.txt
  */
 
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/clk/clk-conf.h>
 #include <linux/module.h>

commit 2573a02aa5c882fdcab82bba953241f2fa3181a3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jul 6 16:50:00 2015 -0700

    clk: Move clk_provider_list to scope of function using it
    
    The list isn't used after of_clk_init() is called, so we don't
    need to keep an empty list around after init. Put the list on the
    stack.
    
    Cc: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 705156828a7a..7873151a7ff8 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3054,8 +3054,6 @@ struct clock_provider {
 	struct list_head node;
 };
 
-static LIST_HEAD(clk_provider_list);
-
 /*
  * This function looks for a parent clock. If there is one, then it
  * checks that the provider for this parent clock was initialized, in
@@ -3106,6 +3104,7 @@ void __init of_clk_init(const struct of_device_id *matches)
 	struct clock_provider *clk_provider, *next;
 	bool is_init_done;
 	bool force = false;
+	LIST_HEAD(clk_provider_list);
 
 	if (!matches)
 		matches = &__clk_of_table;

commit 2e3b19f137f31290979999ff7ac67ce52e02be0e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jul 6 16:48:19 2015 -0700

    clk: Check for allocation errors in of_clk_init()
    
    Dan Carpenter reports that we don't check the allocation here for
    failure. Add a failure check and free any previously allocated
    providers from the clk_provider_list.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ddb4b541016f..705156828a7a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3112,8 +3112,17 @@ void __init of_clk_init(const struct of_device_id *matches)
 
 	/* First prepare the list of the clocks providers */
 	for_each_matching_node_and_match(np, matches, &match) {
-		struct clock_provider *parent =
-			kzalloc(sizeof(struct clock_provider),	GFP_KERNEL);
+		struct clock_provider *parent;
+
+		parent = kzalloc(sizeof(*parent), GFP_KERNEL);
+		if (!parent) {
+			list_for_each_entry_safe(clk_provider, next,
+						 &clk_provider_list, node) {
+				list_del(&clk_provider->node);
+				kfree(clk_provider);
+			}
+			return;
+		}
 
 		parent->clk_init_cb = match->data;
 		parent->np = np;

commit 2cd7b0432888ef2e1f8b54c1c6f8751e1e0e9b5e
Merge: 85e88fab134d 36b7be6d3ea8
Author: Michael Turquette <mturquette@baylibre.com>
Date:   Sat Jun 20 13:29:48 2015 -0700

    Merge tag 'tegra-for-4.2-clk' of git://git.kernel.org/pub/scm/linux/kernel/git/tegra/linux into clk-next
    
    clk: tegra: Changes for v4.2-rc1
    
    This contains the EMC clock driver that's been exhaustively reviewed and
    tested. It also includes a change to the clock core that allows a clock
    provider to perform low-level reparenting of clocks. This is required by
    the EMC clock driver because the reparenting needs to be done at a very
    specific point in time during the EMC frequency switch.

commit 85e88fab134d8896cf4d8be0aac10cc54018ee63
Merge: ddfb157444e3 8eb92ab68f96
Author: Michael Turquette <mturquette@baylibre.com>
Date:   Sat Jun 20 12:18:03 2015 -0700

    Merge branch 'clk-exynos-cpu-clk' into clk-next
    
    Folded into this merge commit is a build error fix: s/clk/core in
    clk_change_rate due to the new struct clk_core

commit d8d919879e9a645061a560a0a26abb9f3bca97df
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Apr 3 18:43:44 2015 +0200

    clk: add CLK_RECALC_NEW_RATES clock flag for Exynos cpu clock support
    
    This flag is needed to fix the issue with wrong dividers being setup
    by Common Clock Framework when using the new Exynos cpu clock support.
    
    The issue happens because clk_core_set_rate_nolock()  calls
    clk_calc_new_rates(clk, rate) before both pre/post clock notifiers have
    a chance to run.  In case of Exynos cpu clock support pre/post clock
    notifiers are registered for mout_apll clock which is a parent of armclk
    cpu clock and dividers are modified in both pre and post clock notifier.
    This results in wrong dividers values being later programmed by
    clk_change_rate(top).  To workaround the problem CLK_RECALC_NEW_RATES
    flag is added and it is set for mout_apll clock later so the correct
    divider values are re-calculated after both pre and post clock notifiers
    had run.
    
    For example when using "performance" governor on Exynos4210 Origen board
    the cpufreq-dt driver requests to change the frequency from 1000MHz to
    1200MHz and after the change state of the relevant clocks is following:
    
    Without use of CLK_GET_RATE_NOCACHE flag:
    
     fout_apll rate: 1200000000
             fout_apll_div_2 rate: 600000000
                     mout_clkout_cpu rate: 600000000
                             div_clkout_cpu rate: 600000000
                                     clkout_cpu rate: 600000000
             mout_apll rate: 1200000000
                     armclk rate: 1200000000
                     mout_hpm rate: 1200000000
                             div_copy rate: 300000000
                                     div_hpm rate: 300000000
                     mout_core rate: 1200000000
                             div_core rate: 1200000000
                                     div_core2 rate: 1200000000
                                             arm_clk_div_2 rate: 600000000
                                             div_corem0 rate: 300000000
                                             div_corem1 rate: 150000000
                                             div_periph rate: 300000000
                             div_atb rate: 300000000
                                     div_pclk_dbg rate: 150000000
                     sclk_apll rate: 1200000000
                             sclk_apll_div_2 rate: 600000000
    
    With use of CLK_GET_RATE_NOCACHE flag:
    
     fout_apll rate: 1200000000
             fout_apll_div_2 rate: 600000000
                     mout_clkout_cpu rate: 600000000
                             div_clkout_cpu rate: 600000000
                                     clkout_cpu rate: 600000000
             mout_apll rate: 1200000000
                     armclk rate: 1200000000
                     mout_hpm rate: 1200000000
                             div_copy rate: 200000000
                                     div_hpm rate: 200000000
                     mout_core rate: 1200000000
                             div_core rate: 1200000000
                                     div_core2 rate: 1200000000
                                             arm_clk_div_2 rate: 600000000
                                             div_corem0 rate: 300000000
                                             div_corem1 rate: 150000000
                                             div_periph rate: 300000000
                             div_atb rate: 240000000
                                     div_pclk_dbg rate: 120000000
                     sclk_apll rate: 150000000
                             sclk_apll_div_2 rate: 75000000
    
    Without this change cpufreq-dt driver showed ~10 mA larger energy
    consumption when compared to cpufreq-exynos one when "performance"
    cpufreq governor was used on Exynos4210 SoC based Origen board.
    
    This issue was probably meant to be workarounded by use of
    CLK_GET_RATE_NOCACHE and CLK_DIVIDER_READ_ONLY clock flags in
    the original Exynos cpu clock patchset (in "[PATCH v12 6/6] clk:
    samsung: remove unused clock aliases and update clock flags" patch)
    but usage of these flags is not sufficient to fix the issue observed.
    
    Cc: Thomas Abraham <thomas.ab@samsung.com>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5b0f41868b42..0c0124c4eeeb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1788,6 +1788,9 @@ static void clk_change_rate(struct clk_core *clk)
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
 
+	if (clk->flags & CLK_RECALC_NEW_RATES)
+		(void)clk_calc_new_rates(clk, clk->new_rate);
+
 	/*
 	 * Use safe iteration, as change_rate can actually swap parents
 	 * for certain clock types.

commit 8c9a8a8f71f43e56d35524fa17646ce45c2f7fe6
Author: Maxime Coquelin <maxime.coquelin@st.com>
Date:   Wed Jun 10 13:28:27 2015 +0200

    clk: Move debug_node field under DEBUG_FS flag in struct clk_core
    
    The debug_node field is only used when DEBUG_FS config is selected,
    so declare it only if DEBUG_FS is selected.
    
    Signed-off-by: Maxime Coquelin <maxime.coquelin@st.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ee222e28bd97..1cf479b9f3b4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -62,11 +62,11 @@ struct clk_core {
 	int			phase;
 	struct hlist_head	children;
 	struct hlist_node	child_node;
-	struct hlist_node	debug_node;
 	struct hlist_head	clks;
 	unsigned int		notifier_count;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*dentry;
+	struct hlist_node	debug_node;
 #endif
 	struct kref		ref;
 };

commit 2e61dfb3602b904966491f260f62c01b9895936a
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Fri Jun 5 11:26:13 2015 -0500

    clk: of: helper for filling parent clock array and return num of parents
    
    Sprinkled all through the platform clock drivers are code like this to
    fill the clock parent array:
    
    for (i = 0; i < num_parents; ++i)
            parent_names[i] = of_clk_get_parent_name(np, i);
    
    The of_clk_parent_fill() will do the same as the code above, and while
    at it, return the number of parents as well since the logic of the
    function is to the walk the clock node to look for the parent.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    [sboyd@codeaurora.org: Fixed kernel-doc]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a522dbbc01b9..ee222e28bd97 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3016,6 +3016,27 @@ const char *of_clk_get_parent_name(struct device_node *np, int index)
 }
 EXPORT_SYMBOL_GPL(of_clk_get_parent_name);
 
+/**
+ * of_clk_parent_fill() - Fill @parents with names of @np's parents and return
+ * number of parents
+ * @np: Device node pointer associated with clock provider
+ * @parents: pointer to char array that hold the parents' names
+ * @size: size of the @parents array
+ *
+ * Return: number of parents for the clock node.
+ */
+int of_clk_parent_fill(struct device_node *np, const char **parents,
+		       unsigned int size)
+{
+	unsigned int i = 0;
+
+	while (i < size && (parents[i] = of_clk_get_parent_name(np, i)) != NULL)
+		i++;
+
+	return i;
+}
+EXPORT_SYMBOL_GPL(of_clk_parent_fill);
+
 struct clock_provider {
 	of_clk_init_cb_t clk_init_cb;
 	struct device_node *np;

commit a59a516398750dc3477a81df34e655b596e352b3
Author: Shailendra Verma <shailendra.capricorn@gmail.com>
Date:   Thu May 21 00:06:48 2015 +0530

    clk: Fix typo in clk_register() comment
    
    Signed-off-by: Shailendra Verma <shailendra.capricorn@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c44623fe9c48..a522dbbc01b9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2442,7 +2442,7 @@ void __clk_free_clk(struct clk *clk)
  *
  * clk_register is the primary interface for populating the clock tree with new
  * clock nodes.  It returns a pointer to the newly allocated struct clk which
- * cannot be dereferenced by driver code but may be used in conjuction with the
+ * cannot be dereferenced by driver code but may be used in conjunction with the
  * rest of the clock API.  In the event of an error clk_register will return an
  * error code; drivers must test for an error code after calling clk_register.
  */

commit 562ef0b098552970fd25e9c960691e6c2bcb1181
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri May 1 12:16:14 2015 -0700

    clk: Silence sparse warnings about __clk_{get,put}()
    
    drivers/clk/clk.c:2700:5: warning: symbol '__clk_get' was not declared. Should it be static?
    drivers/clk/clk.c:2713:6: warning: symbol '__clk_put' was not declared. Should it be static?
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 659f2b036cf5..c44623fe9c48 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -21,6 +21,7 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/clkdev.h>
 
 #include "clk.h"
 

commit 42c86547f4e5c2e81616c76ce9a2badce515c41f
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Wed Mar 11 11:34:25 2015 +0100

    clk: Expose clk_hw_reparent() to providers
    
    To be used by clock implementations for switching to a new parent during
    rate change.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 459ce9da13e0..5315a273eae9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2020,6 +2020,14 @@ static void clk_core_reparent(struct clk_core *clk,
 	__clk_recalc_rates(clk, POST_RATE_CHANGE);
 }
 
+void clk_hw_reparent(struct clk_hw *hw, struct clk_hw *new_parent)
+{
+	if (!hw)
+		return;
+
+	clk_core_reparent(hw->core, !new_parent ? NULL : new_parent->core);
+}
+
 /**
  * clk_has_parent - check if a clock is a possible parent for another
  * @clk: clock source

commit a63347251907d7f9fc2fc02e3b9898efda573c05
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed May 6 17:00:54 2015 -0700

    clk: Add some more lockdep assertions
    
    We don't check to make sure the enable_lock is held across
    enable/disable and we don't check if the prepare_lock is held
    across prepare/unprepare. Add some asserts to catch any future
    locking problems.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9e9d18cadeee..659f2b036cf5 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -543,6 +543,8 @@ EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
 
 static void clk_core_unprepare(struct clk_core *core)
 {
+	lockdep_assert_held(&prepare_lock);
+
 	if (!core)
 		return;
 
@@ -589,6 +591,8 @@ static int clk_core_prepare(struct clk_core *core)
 {
 	int ret = 0;
 
+	lockdep_assert_held(&prepare_lock);
+
 	if (!core)
 		return 0;
 
@@ -644,6 +648,8 @@ EXPORT_SYMBOL_GPL(clk_prepare);
 
 static void clk_core_disable(struct clk_core *core)
 {
+	lockdep_assert_held(&enable_lock);
+
 	if (!core)
 		return;
 
@@ -692,6 +698,8 @@ static int clk_core_enable(struct clk_core *core)
 {
 	int ret = 0;
 
+	lockdep_assert_held(&enable_lock);
+
 	if (!core)
 		return 0;
 

commit 18e70efe3e2a27b53a63fb4454cc6c9e1dc0db49
Merge: c542a54fcb55 d2a5d46b167a
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu May 7 11:32:49 2015 -0700

    Merge branch 'clk-fixes' into clk-next

commit 70e9f4dde00182600989ca57f08d51be12f1523f
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri May 1 09:48:37 2015 -0500

    clk: add newline character after dumping all clocks
    
    clk_dump() will dump data about all clocks in JSON
    format, but it misses a newline character at the
    end of the JSON string. This patch adds that missing
    newline character.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    [sboyd@codeaurora.org: Squelch checkpatch with seq_puts()]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ea7e8695a32b..4a2e9478edbd 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1998,7 +1998,7 @@ static int clk_dump(struct seq_file *s, void *data)
 
 	clk_prepare_unlock();
 
-	seq_printf(s, "}");
+	seq_puts(s, "}\n");
 	return 0;
 }
 

commit d2a5d46b167a9a8231264daf80165b739aecf1d7
Author: Dong Aisheng <aisheng.dong@freescale.com>
Date:   Wed Apr 15 22:26:36 2015 +0800

    clk: add missing lock when call clk_core_enable in clk_set_parent
    
    Before commit 035a61c314eb ("clk: Make clk API return per-user
    struct clk instances") we acquired the enable_lock in
    __clk_set_parent_{before,after}() by means of calling
    clk_enable(). After commit 035a61c314eb we use clk_core_enable()
    in place of the clk_enable(), and clk_core_enable() doesn't
    acquire the enable_lock. This opens up a race condition between
    clk_set_parent() and clk_enable(). Fix it.
    
    Fixes: 035a61c314eb ("clk: Make clk API return per-user struct clk instances")
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Dong Aisheng <aisheng.dong@freescale.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 459ce9da13e0..5b0f41868b42 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1475,8 +1475,10 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *clk,
 	 */
 	if (clk->prepare_count) {
 		clk_core_prepare(parent);
+		flags = clk_enable_lock();
 		clk_core_enable(parent);
 		clk_core_enable(clk);
+		clk_enable_unlock(flags);
 	}
 
 	/* update the clk tree topology */
@@ -1491,13 +1493,17 @@ static void __clk_set_parent_after(struct clk_core *core,
 				   struct clk_core *parent,
 				   struct clk_core *old_parent)
 {
+	unsigned long flags;
+
 	/*
 	 * Finish the migration of prepare state and undo the changes done
 	 * for preventing a race with clk_enable().
 	 */
 	if (core->prepare_count) {
+		flags = clk_enable_lock();
 		clk_core_disable(core);
 		clk_core_disable(old_parent);
+		clk_enable_unlock(flags);
 		clk_core_unprepare(old_parent);
 	}
 }
@@ -1525,8 +1531,10 @@ static int __clk_set_parent(struct clk_core *clk, struct clk_core *parent,
 		clk_enable_unlock(flags);
 
 		if (clk->prepare_count) {
+			flags = clk_enable_lock();
 			clk_core_disable(clk);
 			clk_core_disable(parent);
+			clk_enable_unlock(flags);
 			clk_core_unprepare(parent);
 		}
 		return ret;

commit 7cb81136d2efe0f5ed9d965857f4756a15e6c338
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Wed Apr 29 16:36:43 2015 +0000

    clk: Fix JSON output in debugfs
    
    key/value pairs in a JSON object must be separated by a comma.
    After adding the properties "accuracy" and "phase" the JSON output
    of /sys/kernel/debug/clk/clk_dump is invalid.
    
    So add the missing commas to fix it.
    
    Fixes: 5279fc402ae5 ("clk: add clk accuracy retrieval support")
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    [sboyd@codeaurora.org: Added comment in function]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 43b7e7227056..ea7e8695a32b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1951,11 +1951,12 @@ static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 	if (!c)
 		return;
 
+	/* This should be JSON format, i.e. elements separated with a comma */
 	seq_printf(s, "\"%s\": { ", c->name);
 	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
-	seq_printf(s, "\"rate\": %lu", clk_core_get_rate(c));
-	seq_printf(s, "\"accuracy\": %lu", clk_core_get_accuracy(c));
+	seq_printf(s, "\"rate\": %lu,", clk_core_get_rate(c));
+	seq_printf(s, "\"accuracy\": %lu,", clk_core_get_accuracy(c));
 	seq_printf(s, "\"phase\": %d", clk_core_get_phase(c));
 }
 

commit 6e5ab41b1064eee6e3477f573370b2dda7d82bb7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 30 15:11:31 2015 -0700

    clk: Update some comments to reflect reality
    
    The debugfs clk directory no longer expresses a clk tree. Update
    the comments around that apporiately. Also drop comments about
    prepare locks needing to be held as we have the proper
    annotations with lockdep_assert_held().
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0001b91f2b6e..43b7e7227056 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -162,7 +162,6 @@ static bool clk_core_is_enabled(struct clk_core *core)
 	return core->ops->is_enabled(core->hw);
 }
 
-/* caller must hold prepare_lock */
 static void clk_unprepare_unused_subtree(struct clk_core *core)
 {
 	struct clk_core *child;
@@ -188,7 +187,6 @@ static void clk_unprepare_unused_subtree(struct clk_core *core)
 	}
 }
 
-/* caller must hold prepare_lock */
 static void clk_disable_unused_subtree(struct clk_core *core)
 {
 	struct clk_core *child;
@@ -791,8 +789,7 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *core,
  * @min_rate: returned rate must be greater than this rate
  * @max_rate: returned rate must be less than this rate
  *
- * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate and
- * .determine_rate.
+ * Useful for clk_ops such as .set_rate and .determine_rate.
  */
 unsigned long __clk_determine_rate(struct clk_hw *hw,
 				   unsigned long rate,
@@ -811,7 +808,7 @@ EXPORT_SYMBOL_GPL(__clk_determine_rate);
  * @clk: round the rate of this clock
  * @rate: the rate which is to be rounded
  *
- * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate
+ * Useful for clk_ops such as .set_rate
  */
 unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 {
@@ -892,10 +889,8 @@ static int __clk_notify(struct clk_core *core, unsigned long msg,
  *
  * Walks the subtree of clks starting with clk and recalculates accuracies as
  * it goes.  Note that if a clk does not implement the .recalc_accuracy
- * callback then it is assumed that the clock will take on the accuracy of it's
+ * callback then it is assumed that the clock will take on the accuracy of its
  * parent.
- *
- * Caller must hold prepare_lock.
  */
 static void __clk_recalc_accuracies(struct clk_core *core)
 {
@@ -968,8 +963,6 @@ static unsigned long clk_recalc(struct clk_core *core,
  *
  * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,
  * if necessary.
- *
- * Caller must hold prepare_lock.
  */
 static void __clk_recalc_rates(struct clk_core *core, unsigned long msg)
 {
@@ -1179,8 +1172,6 @@ static int __clk_set_parent(struct clk_core *core, struct clk_core *parent,
  * subtree have subscribed to the notifications.  Note that if a clk does not
  * implement the .recalc_rate callback then it is assumed that the clock will
  * take on the rate of its parent.
- *
- * Caller must hold prepare_lock.
  */
 static int __clk_speculate_rates(struct clk_core *core,
 				 unsigned long parent_rate)
@@ -2091,11 +2082,11 @@ static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 }
 
 /**
- * clk_debug_register - add a clk node to the debugfs clk tree
- * @core: the clk being added to the debugfs clk tree
+ * clk_debug_register - add a clk node to the debugfs clk directory
+ * @core: the clk being added to the debugfs clk directory
  *
- * Dynamically adds a clk to the debugfs clk tree if debugfs has been
- * initialized.  Otherwise it bails out early since the debugfs clk tree
+ * Dynamically adds a clk to the debugfs clk directory if debugfs has been
+ * initialized.  Otherwise it bails out early since the debugfs clk directory
  * will be created lazily by clk_debug_init as part of a late_initcall.
  */
 static int clk_debug_register(struct clk_core *core)
@@ -2116,11 +2107,11 @@ static int clk_debug_register(struct clk_core *core)
 }
 
  /**
- * clk_debug_unregister - remove a clk node from the debugfs clk tree
- * @core: the clk being removed from the debugfs clk tree
+ * clk_debug_unregister - remove a clk node from the debugfs clk directory
+ * @core: the clk being removed from the debugfs clk directory
  *
- * Dynamically removes a clk and all it's children clk nodes from the
- * debugfs clk tree if clk->dentry points to debugfs created by
+ * Dynamically removes a clk and all its child nodes from the
+ * debugfs clk directory if clk->dentry points to debugfs created by
  * clk_debug_register in __clk_init.
  */
 static void clk_debug_unregister(struct clk_core *core)
@@ -2146,16 +2137,13 @@ struct dentry *clk_debugfs_add_file(struct clk_hw *hw, char *name, umode_t mode,
 EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
 
 /**
- * clk_debug_init - lazily create the debugfs clk tree visualization
+ * clk_debug_init - lazily populate the debugfs clk directory
  *
- * clks are often initialized very early during boot before memory can
- * be dynamically allocated and well before debugfs is setup.
- * clk_debug_init walks the clk tree hierarchy while holding
- * prepare_lock and creates the topology as part of a late_initcall,
- * thus insuring that clks initialized very early will still be
- * represented in the debugfs clk tree.  This function should only be
- * called once at boot-time, and all other clks added dynamically will
- * be done so with clk_debug_register.
+ * clks are often initialized very early during boot before memory can be
+ * dynamically allocated and well before debugfs is setup. This function
+ * populates the debugfs clk directory once at boot-time when we know that
+ * debugfs is setup. It should only be called once at boot-time, all other clks
+ * added dynamically will be done so with clk_debug_register.
  */
 static int __init clk_debug_init(void)
 {
@@ -2512,10 +2500,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(clk_register);
 
-/*
- * Free memory allocated for a clock.
- * Caller must hold prepare_lock.
- */
+/* Free memory allocated for a clock. */
 static void __clk_release(struct kref *ref)
 {
 	struct clk_core *core = container_of(ref, struct clk_core, ref);

commit 4dff95dc9477a34de77d24c59dcf1dc593687fcf
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 30 14:43:22 2015 -0700

    clk: Remove forward declared function prototypes
    
    Move the code around so that we don't need to declare function
    prototypes at the start of the file. Simplify
    clk_core_is_prepared() and clk_core_is_enabled() too to make the
    diff easier to read.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3e58b7453076..0001b91f2b6e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -37,13 +37,6 @@ static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
 
-static long clk_core_get_accuracy(struct clk_core *core);
-static unsigned long clk_core_get_rate(struct clk_core *core);
-static int clk_core_get_phase(struct clk_core *core);
-static bool clk_core_is_prepared(struct clk_core *core);
-static bool clk_core_is_enabled(struct clk_core *core);
-static struct clk_core *clk_core_lookup(const char *name);
-
 /***    private data structures    ***/
 
 struct clk_core {
@@ -145,2093 +138,2075 @@ static void clk_enable_unlock(unsigned long flags)
 	spin_unlock_irqrestore(&enable_lock, flags);
 }
 
-/***        debugfs support        ***/
-
-#ifdef CONFIG_DEBUG_FS
-#include <linux/debugfs.h>
+static bool clk_core_is_prepared(struct clk_core *core)
+{
+	/*
+	 * .is_prepared is optional for clocks that can prepare
+	 * fall back to software usage counter if it is missing
+	 */
+	if (!core->ops->is_prepared)
+		return core->prepare_count;
 
-static struct dentry *rootdir;
-static int inited = 0;
-static DEFINE_MUTEX(clk_debug_lock);
-static HLIST_HEAD(clk_debug_list);
+	return core->ops->is_prepared(core->hw);
+}
 
-static struct hlist_head *all_lists[] = {
-	&clk_root_list,
-	&clk_orphan_list,
-	NULL,
-};
+static bool clk_core_is_enabled(struct clk_core *core)
+{
+	/*
+	 * .is_enabled is only mandatory for clocks that gate
+	 * fall back to software usage counter if .is_enabled is missing
+	 */
+	if (!core->ops->is_enabled)
+		return core->enable_count;
 
-static struct hlist_head *orphan_list[] = {
-	&clk_orphan_list,
-	NULL,
-};
+	return core->ops->is_enabled(core->hw);
+}
 
-static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
-				 int level)
+/* caller must hold prepare_lock */
+static void clk_unprepare_unused_subtree(struct clk_core *core)
 {
-	if (!c)
+	struct clk_core *child;
+
+	lockdep_assert_held(&prepare_lock);
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_unprepare_unused_subtree(child);
+
+	if (core->prepare_count)
 		return;
 
-	seq_printf(s, "%*s%-*s %11d %12d %11lu %10lu %-3d\n",
-		   level * 3 + 1, "",
-		   30 - level * 3, c->name,
-		   c->enable_count, c->prepare_count, clk_core_get_rate(c),
-		   clk_core_get_accuracy(c), clk_core_get_phase(c));
+	if (core->flags & CLK_IGNORE_UNUSED)
+		return;
+
+	if (clk_core_is_prepared(core)) {
+		trace_clk_unprepare(core);
+		if (core->ops->unprepare_unused)
+			core->ops->unprepare_unused(core->hw);
+		else if (core->ops->unprepare)
+			core->ops->unprepare(core->hw);
+		trace_clk_unprepare_complete(core);
+	}
 }
 
-static void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,
-				     int level)
+/* caller must hold prepare_lock */
+static void clk_disable_unused_subtree(struct clk_core *core)
 {
 	struct clk_core *child;
+	unsigned long flags;
 
-	if (!c)
-		return;
+	lockdep_assert_held(&prepare_lock);
 
-	clk_summary_show_one(s, c, level);
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_disable_unused_subtree(child);
 
-	hlist_for_each_entry(child, &c->children, child_node)
-		clk_summary_show_subtree(s, child, level + 1);
+	flags = clk_enable_lock();
+
+	if (core->enable_count)
+		goto unlock_out;
+
+	if (core->flags & CLK_IGNORE_UNUSED)
+		goto unlock_out;
+
+	/*
+	 * some gate clocks have special needs during the disable-unused
+	 * sequence.  call .disable_unused if available, otherwise fall
+	 * back to .disable
+	 */
+	if (clk_core_is_enabled(core)) {
+		trace_clk_disable(core);
+		if (core->ops->disable_unused)
+			core->ops->disable_unused(core->hw);
+		else if (core->ops->disable)
+			core->ops->disable(core->hw);
+		trace_clk_disable_complete(core);
+	}
+
+unlock_out:
+	clk_enable_unlock(flags);
 }
 
-static int clk_summary_show(struct seq_file *s, void *data)
+static bool clk_ignore_unused;
+static int __init clk_ignore_unused_setup(char *__unused)
 {
-	struct clk_core *c;
-	struct hlist_head **lists = (struct hlist_head **)s->private;
+	clk_ignore_unused = true;
+	return 1;
+}
+__setup("clk_ignore_unused", clk_ignore_unused_setup);
 
-	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy   phase\n");
-	seq_puts(s, "----------------------------------------------------------------------------------------\n");
+static int clk_disable_unused(void)
+{
+	struct clk_core *core;
+
+	if (clk_ignore_unused) {
+		pr_warn("clk: Not disabling unused clocks\n");
+		return 0;
+	}
 
 	clk_prepare_lock();
 
-	for (; *lists; lists++)
-		hlist_for_each_entry(c, *lists, child_node)
-			clk_summary_show_subtree(s, c, 0);
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_disable_unused_subtree(core);
+
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_disable_unused_subtree(core);
+
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_unprepare_unused_subtree(core);
+
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_unprepare_unused_subtree(core);
 
 	clk_prepare_unlock();
 
 	return 0;
 }
+late_initcall_sync(clk_disable_unused);
 
+/***    helper functions   ***/
 
-static int clk_summary_open(struct inode *inode, struct file *file)
+const char *__clk_get_name(struct clk *clk)
 {
-	return single_open(file, clk_summary_show, inode->i_private);
+	return !clk ? NULL : clk->core->name;
 }
+EXPORT_SYMBOL_GPL(__clk_get_name);
 
-static const struct file_operations clk_summary_fops = {
-	.open		= clk_summary_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+struct clk_hw *__clk_get_hw(struct clk *clk)
+{
+	return !clk ? NULL : clk->core->hw;
+}
+EXPORT_SYMBOL_GPL(__clk_get_hw);
 
-static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
+u8 __clk_get_num_parents(struct clk *clk)
 {
-	if (!c)
-		return;
+	return !clk ? 0 : clk->core->num_parents;
+}
+EXPORT_SYMBOL_GPL(__clk_get_num_parents);
 
-	seq_printf(s, "\"%s\": { ", c->name);
-	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
-	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
-	seq_printf(s, "\"rate\": %lu", clk_core_get_rate(c));
-	seq_printf(s, "\"accuracy\": %lu", clk_core_get_accuracy(c));
-	seq_printf(s, "\"phase\": %d", clk_core_get_phase(c));
+struct clk *__clk_get_parent(struct clk *clk)
+{
+	if (!clk)
+		return NULL;
+
+	/* TODO: Create a per-user clk and change callers to call clk_put */
+	return !clk->core->parent ? NULL : clk->core->parent->hw->clk;
 }
+EXPORT_SYMBOL_GPL(__clk_get_parent);
 
-static void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)
+static struct clk_core *__clk_lookup_subtree(const char *name,
+					     struct clk_core *core)
 {
 	struct clk_core *child;
+	struct clk_core *ret;
 
-	if (!c)
-		return;
-
-	clk_dump_one(s, c, level);
+	if (!strcmp(core->name, name))
+		return core;
 
-	hlist_for_each_entry(child, &c->children, child_node) {
-		seq_printf(s, ",");
-		clk_dump_subtree(s, child, level + 1);
+	hlist_for_each_entry(child, &core->children, child_node) {
+		ret = __clk_lookup_subtree(name, child);
+		if (ret)
+			return ret;
 	}
 
-	seq_printf(s, "}");
+	return NULL;
 }
 
-static int clk_dump(struct seq_file *s, void *data)
+static struct clk_core *clk_core_lookup(const char *name)
 {
-	struct clk_core *c;
-	bool first_node = true;
-	struct hlist_head **lists = (struct hlist_head **)s->private;
-
-	seq_printf(s, "{");
+	struct clk_core *root_clk;
+	struct clk_core *ret;
 
-	clk_prepare_lock();
+	if (!name)
+		return NULL;
 
-	for (; *lists; lists++) {
-		hlist_for_each_entry(c, *lists, child_node) {
-			if (!first_node)
-				seq_puts(s, ",");
-			first_node = false;
-			clk_dump_subtree(s, c, 0);
-		}
+	/* search the 'proper' clk tree first */
+	hlist_for_each_entry(root_clk, &clk_root_list, child_node) {
+		ret = __clk_lookup_subtree(name, root_clk);
+		if (ret)
+			return ret;
 	}
 
-	clk_prepare_unlock();
+	/* if not found, then search the orphan tree */
+	hlist_for_each_entry(root_clk, &clk_orphan_list, child_node) {
+		ret = __clk_lookup_subtree(name, root_clk);
+		if (ret)
+			return ret;
+	}
 
-	seq_printf(s, "}");
-	return 0;
+	return NULL;
 }
 
-
-static int clk_dump_open(struct inode *inode, struct file *file)
+static struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,
+							 u8 index)
 {
-	return single_open(file, clk_dump, inode->i_private);
+	if (!core || index >= core->num_parents)
+		return NULL;
+	else if (!core->parents)
+		return clk_core_lookup(core->parent_names[index]);
+	else if (!core->parents[index])
+		return core->parents[index] =
+			clk_core_lookup(core->parent_names[index]);
+	else
+		return core->parents[index];
 }
 
-static const struct file_operations clk_dump_fops = {
-	.open		= clk_dump_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
+struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
 {
-	struct dentry *d;
-	int ret = -ENOMEM;
+	struct clk_core *parent;
 
-	if (!core || !pdentry) {
-		ret = -EINVAL;
-		goto out;
-	}
+	if (!clk)
+		return NULL;
 
-	d = debugfs_create_dir(core->name, pdentry);
-	if (!d)
-		goto out;
-
-	core->dentry = d;
-
-	d = debugfs_create_u32("clk_rate", S_IRUGO, core->dentry,
-			(u32 *)&core->rate);
-	if (!d)
-		goto err_out;
-
-	d = debugfs_create_u32("clk_accuracy", S_IRUGO, core->dentry,
-			(u32 *)&core->accuracy);
-	if (!d)
-		goto err_out;
+	parent = clk_core_get_parent_by_index(clk->core, index);
 
-	d = debugfs_create_u32("clk_phase", S_IRUGO, core->dentry,
-			(u32 *)&core->phase);
-	if (!d)
-		goto err_out;
+	return !parent ? NULL : parent->hw->clk;
+}
+EXPORT_SYMBOL_GPL(clk_get_parent_by_index);
 
-	d = debugfs_create_x32("clk_flags", S_IRUGO, core->dentry,
-			(u32 *)&core->flags);
-	if (!d)
-		goto err_out;
+unsigned int __clk_get_enable_count(struct clk *clk)
+{
+	return !clk ? 0 : clk->core->enable_count;
+}
 
-	d = debugfs_create_u32("clk_prepare_count", S_IRUGO, core->dentry,
-			(u32 *)&core->prepare_count);
-	if (!d)
-		goto err_out;
+static unsigned long clk_core_get_rate_nolock(struct clk_core *core)
+{
+	unsigned long ret;
 
-	d = debugfs_create_u32("clk_enable_count", S_IRUGO, core->dentry,
-			(u32 *)&core->enable_count);
-	if (!d)
-		goto err_out;
+	if (!core) {
+		ret = 0;
+		goto out;
+	}
 
-	d = debugfs_create_u32("clk_notifier_count", S_IRUGO, core->dentry,
-			(u32 *)&core->notifier_count);
-	if (!d)
-		goto err_out;
+	ret = core->rate;
 
-	if (core->ops->debug_init) {
-		ret = core->ops->debug_init(core->hw, core->dentry);
-		if (ret)
-			goto err_out;
-	}
+	if (core->flags & CLK_IS_ROOT)
+		goto out;
 
-	ret = 0;
-	goto out;
+	if (!core->parent)
+		ret = 0;
 
-err_out:
-	debugfs_remove_recursive(core->dentry);
-	core->dentry = NULL;
 out:
 	return ret;
 }
 
-/**
- * clk_debug_register - add a clk node to the debugfs clk tree
- * @core: the clk being added to the debugfs clk tree
- *
- * Dynamically adds a clk to the debugfs clk tree if debugfs has been
- * initialized.  Otherwise it bails out early since the debugfs clk tree
- * will be created lazily by clk_debug_init as part of a late_initcall.
- */
-static int clk_debug_register(struct clk_core *core)
+unsigned long __clk_get_rate(struct clk *clk)
 {
-	int ret = 0;
-
-	mutex_lock(&clk_debug_lock);
-	hlist_add_head(&core->debug_node, &clk_debug_list);
+	if (!clk)
+		return 0;
 
-	if (!inited)
-		goto unlock;
+	return clk_core_get_rate_nolock(clk->core);
+}
+EXPORT_SYMBOL_GPL(__clk_get_rate);
 
-	ret = clk_debug_create_one(core, rootdir);
-unlock:
-	mutex_unlock(&clk_debug_lock);
+static unsigned long __clk_get_accuracy(struct clk_core *core)
+{
+	if (!core)
+		return 0;
 
-	return ret;
+	return core->accuracy;
 }
 
- /**
- * clk_debug_unregister - remove a clk node from the debugfs clk tree
- * @core: the clk being removed from the debugfs clk tree
- *
- * Dynamically removes a clk and all it's children clk nodes from the
- * debugfs clk tree if clk->dentry points to debugfs created by
- * clk_debug_register in __clk_init.
- */
-static void clk_debug_unregister(struct clk_core *core)
+unsigned long __clk_get_flags(struct clk *clk)
 {
-	mutex_lock(&clk_debug_lock);
-	hlist_del_init(&core->debug_node);
-	debugfs_remove_recursive(core->dentry);
-	core->dentry = NULL;
-	mutex_unlock(&clk_debug_lock);
+	return !clk ? 0 : clk->core->flags;
 }
+EXPORT_SYMBOL_GPL(__clk_get_flags);
 
-struct dentry *clk_debugfs_add_file(struct clk_hw *hw, char *name, umode_t mode,
-				void *data, const struct file_operations *fops)
+bool __clk_is_prepared(struct clk *clk)
 {
-	struct dentry *d = NULL;
-
-	if (hw->core->dentry)
-		d = debugfs_create_file(name, mode, hw->core->dentry, data,
-					fops);
+	if (!clk)
+		return false;
 
-	return d;
+	return clk_core_is_prepared(clk->core);
 }
-EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
 
-/**
- * clk_debug_init - lazily create the debugfs clk tree visualization
- *
- * clks are often initialized very early during boot before memory can
- * be dynamically allocated and well before debugfs is setup.
- * clk_debug_init walks the clk tree hierarchy while holding
- * prepare_lock and creates the topology as part of a late_initcall,
- * thus insuring that clks initialized very early will still be
- * represented in the debugfs clk tree.  This function should only be
- * called once at boot-time, and all other clks added dynamically will
- * be done so with clk_debug_register.
- */
-static int __init clk_debug_init(void)
+bool __clk_is_enabled(struct clk *clk)
 {
-	struct clk_core *core;
-	struct dentry *d;
-
-	rootdir = debugfs_create_dir("clk", NULL);
+	if (!clk)
+		return false;
 
-	if (!rootdir)
-		return -ENOMEM;
+	return clk_core_is_enabled(clk->core);
+}
+EXPORT_SYMBOL_GPL(__clk_is_enabled);
 
-	d = debugfs_create_file("clk_summary", S_IRUGO, rootdir, &all_lists,
-				&clk_summary_fops);
-	if (!d)
-		return -ENOMEM;
+static bool mux_is_better_rate(unsigned long rate, unsigned long now,
+			   unsigned long best, unsigned long flags)
+{
+	if (flags & CLK_MUX_ROUND_CLOSEST)
+		return abs(now - rate) < abs(best - rate);
 
-	d = debugfs_create_file("clk_dump", S_IRUGO, rootdir, &all_lists,
-				&clk_dump_fops);
-	if (!d)
-		return -ENOMEM;
+	return now <= rate && now > best;
+}
 
-	d = debugfs_create_file("clk_orphan_summary", S_IRUGO, rootdir,
-				&orphan_list, &clk_summary_fops);
-	if (!d)
-		return -ENOMEM;
+static long
+clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
+			     unsigned long min_rate,
+			     unsigned long max_rate,
+			     unsigned long *best_parent_rate,
+			     struct clk_hw **best_parent_p,
+			     unsigned long flags)
+{
+	struct clk_core *core = hw->core, *parent, *best_parent = NULL;
+	int i, num_parents;
+	unsigned long parent_rate, best = 0;
 
-	d = debugfs_create_file("clk_orphan_dump", S_IRUGO, rootdir,
-				&orphan_list, &clk_dump_fops);
-	if (!d)
-		return -ENOMEM;
+	/* if NO_REPARENT flag set, pass through to current parent */
+	if (core->flags & CLK_SET_RATE_NO_REPARENT) {
+		parent = core->parent;
+		if (core->flags & CLK_SET_RATE_PARENT)
+			best = __clk_determine_rate(parent ? parent->hw : NULL,
+						    rate, min_rate, max_rate);
+		else if (parent)
+			best = clk_core_get_rate_nolock(parent);
+		else
+			best = clk_core_get_rate_nolock(core);
+		goto out;
+	}
 
-	mutex_lock(&clk_debug_lock);
-	hlist_for_each_entry(core, &clk_debug_list, debug_node)
-		clk_debug_create_one(core, rootdir);
+	/* find the parent that can provide the fastest rate <= rate */
+	num_parents = core->num_parents;
+	for (i = 0; i < num_parents; i++) {
+		parent = clk_core_get_parent_by_index(core, i);
+		if (!parent)
+			continue;
+		if (core->flags & CLK_SET_RATE_PARENT)
+			parent_rate = __clk_determine_rate(parent->hw, rate,
+							   min_rate,
+							   max_rate);
+		else
+			parent_rate = clk_core_get_rate_nolock(parent);
+		if (mux_is_better_rate(rate, parent_rate, best, flags)) {
+			best_parent = parent;
+			best = parent_rate;
+		}
+	}
 
-	inited = 1;
-	mutex_unlock(&clk_debug_lock);
+out:
+	if (best_parent)
+		*best_parent_p = best_parent->hw;
+	*best_parent_rate = best;
 
-	return 0;
-}
-late_initcall(clk_debug_init);
-#else
-static inline int clk_debug_register(struct clk_core *core) { return 0; }
-static inline void clk_debug_reparent(struct clk_core *core,
-				      struct clk_core *new_parent)
-{
+	return best;
 }
-static inline void clk_debug_unregister(struct clk_core *core)
+
+struct clk *__clk_lookup(const char *name)
 {
+	struct clk_core *core = clk_core_lookup(name);
+
+	return !core ? NULL : core->hw->clk;
 }
-#endif
 
-/* caller must hold prepare_lock */
-static void clk_unprepare_unused_subtree(struct clk_core *core)
+static void clk_core_get_boundaries(struct clk_core *core,
+				    unsigned long *min_rate,
+				    unsigned long *max_rate)
 {
-	struct clk_core *child;
+	struct clk *clk_user;
 
-	lockdep_assert_held(&prepare_lock);
+	*min_rate = 0;
+	*max_rate = ULONG_MAX;
 
-	hlist_for_each_entry(child, &core->children, child_node)
-		clk_unprepare_unused_subtree(child);
+	hlist_for_each_entry(clk_user, &core->clks, clks_node)
+		*min_rate = max(*min_rate, clk_user->min_rate);
 
-	if (core->prepare_count)
-		return;
+	hlist_for_each_entry(clk_user, &core->clks, clks_node)
+		*max_rate = min(*max_rate, clk_user->max_rate);
+}
 
-	if (core->flags & CLK_IGNORE_UNUSED)
-		return;
-
-	if (clk_core_is_prepared(core)) {
-		trace_clk_unprepare(core);
-		if (core->ops->unprepare_unused)
-			core->ops->unprepare_unused(core->hw);
-		else if (core->ops->unprepare)
-			core->ops->unprepare(core->hw);
-		trace_clk_unprepare_complete(core);
-	}
+/*
+ * Helper for finding best parent to provide a given frequency. This can be used
+ * directly as a determine_rate callback (e.g. for a mux), or from a more
+ * complex clock that may combine a mux with other operations.
+ */
+long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long min_rate,
+			      unsigned long max_rate,
+			      unsigned long *best_parent_rate,
+			      struct clk_hw **best_parent_p)
+{
+	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
+					    best_parent_rate,
+					    best_parent_p, 0);
 }
+EXPORT_SYMBOL_GPL(__clk_mux_determine_rate);
 
-/* caller must hold prepare_lock */
-static void clk_disable_unused_subtree(struct clk_core *core)
+long __clk_mux_determine_rate_closest(struct clk_hw *hw, unsigned long rate,
+			      unsigned long min_rate,
+			      unsigned long max_rate,
+			      unsigned long *best_parent_rate,
+			      struct clk_hw **best_parent_p)
 {
-	struct clk_core *child;
-	unsigned long flags;
+	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
+					    best_parent_rate,
+					    best_parent_p,
+					    CLK_MUX_ROUND_CLOSEST);
+}
+EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
 
-	lockdep_assert_held(&prepare_lock);
+/***        clk api        ***/
 
-	hlist_for_each_entry(child, &core->children, child_node)
-		clk_disable_unused_subtree(child);
+static void clk_core_unprepare(struct clk_core *core)
+{
+	if (!core)
+		return;
 
-	flags = clk_enable_lock();
+	if (WARN_ON(core->prepare_count == 0))
+		return;
 
-	if (core->enable_count)
-		goto unlock_out;
+	if (--core->prepare_count > 0)
+		return;
 
-	if (core->flags & CLK_IGNORE_UNUSED)
-		goto unlock_out;
+	WARN_ON(core->enable_count > 0);
 
-	/*
-	 * some gate clocks have special needs during the disable-unused
-	 * sequence.  call .disable_unused if available, otherwise fall
-	 * back to .disable
-	 */
-	if (clk_core_is_enabled(core)) {
-		trace_clk_disable(core);
-		if (core->ops->disable_unused)
-			core->ops->disable_unused(core->hw);
-		else if (core->ops->disable)
-			core->ops->disable(core->hw);
-		trace_clk_disable_complete(core);
-	}
+	trace_clk_unprepare(core);
 
-unlock_out:
-	clk_enable_unlock(flags);
+	if (core->ops->unprepare)
+		core->ops->unprepare(core->hw);
+
+	trace_clk_unprepare_complete(core);
+	clk_core_unprepare(core->parent);
 }
 
-static bool clk_ignore_unused;
-static int __init clk_ignore_unused_setup(char *__unused)
+/**
+ * clk_unprepare - undo preparation of a clock source
+ * @clk: the clk being unprepared
+ *
+ * clk_unprepare may sleep, which differentiates it from clk_disable.  In a
+ * simple case, clk_unprepare can be used instead of clk_disable to gate a clk
+ * if the operation may sleep.  One example is a clk which is accessed over
+ * I2c.  In the complex case a clk gate operation may require a fast and a slow
+ * part.  It is this reason that clk_unprepare and clk_disable are not mutually
+ * exclusive.  In fact clk_disable must be called before clk_unprepare.
+ */
+void clk_unprepare(struct clk *clk)
 {
-	clk_ignore_unused = true;
-	return 1;
+	if (IS_ERR_OR_NULL(clk))
+		return;
+
+	clk_prepare_lock();
+	clk_core_unprepare(clk->core);
+	clk_prepare_unlock();
 }
-__setup("clk_ignore_unused", clk_ignore_unused_setup);
+EXPORT_SYMBOL_GPL(clk_unprepare);
 
-static int clk_disable_unused(void)
+static int clk_core_prepare(struct clk_core *core)
 {
-	struct clk_core *core;
+	int ret = 0;
 
-	if (clk_ignore_unused) {
-		pr_warn("clk: Not disabling unused clocks\n");
+	if (!core)
 		return 0;
-	}
 
-	clk_prepare_lock();
+	if (core->prepare_count == 0) {
+		ret = clk_core_prepare(core->parent);
+		if (ret)
+			return ret;
 
-	hlist_for_each_entry(core, &clk_root_list, child_node)
-		clk_disable_unused_subtree(core);
+		trace_clk_prepare(core);
 
-	hlist_for_each_entry(core, &clk_orphan_list, child_node)
-		clk_disable_unused_subtree(core);
+		if (core->ops->prepare)
+			ret = core->ops->prepare(core->hw);
 
-	hlist_for_each_entry(core, &clk_root_list, child_node)
-		clk_unprepare_unused_subtree(core);
+		trace_clk_prepare_complete(core);
 
-	hlist_for_each_entry(core, &clk_orphan_list, child_node)
-		clk_unprepare_unused_subtree(core);
+		if (ret) {
+			clk_core_unprepare(core->parent);
+			return ret;
+		}
+	}
 
-	clk_prepare_unlock();
+	core->prepare_count++;
 
 	return 0;
 }
-late_initcall_sync(clk_disable_unused);
-
-/***    helper functions   ***/
 
-const char *__clk_get_name(struct clk *clk)
+/**
+ * clk_prepare - prepare a clock source
+ * @clk: the clk being prepared
+ *
+ * clk_prepare may sleep, which differentiates it from clk_enable.  In a simple
+ * case, clk_prepare can be used instead of clk_enable to ungate a clk if the
+ * operation may sleep.  One example is a clk which is accessed over I2c.  In
+ * the complex case a clk ungate operation may require a fast and a slow part.
+ * It is this reason that clk_prepare and clk_enable are not mutually
+ * exclusive.  In fact clk_prepare must be called before clk_enable.
+ * Returns 0 on success, -EERROR otherwise.
+ */
+int clk_prepare(struct clk *clk)
 {
-	return !clk ? NULL : clk->core->name;
-}
-EXPORT_SYMBOL_GPL(__clk_get_name);
+	int ret;
 
-struct clk_hw *__clk_get_hw(struct clk *clk)
-{
-	return !clk ? NULL : clk->core->hw;
-}
-EXPORT_SYMBOL_GPL(__clk_get_hw);
+	if (!clk)
+		return 0;
 
-u8 __clk_get_num_parents(struct clk *clk)
-{
-	return !clk ? 0 : clk->core->num_parents;
+	clk_prepare_lock();
+	ret = clk_core_prepare(clk->core);
+	clk_prepare_unlock();
+
+	return ret;
 }
-EXPORT_SYMBOL_GPL(__clk_get_num_parents);
+EXPORT_SYMBOL_GPL(clk_prepare);
 
-struct clk *__clk_get_parent(struct clk *clk)
+static void clk_core_disable(struct clk_core *core)
 {
-	if (!clk)
-		return NULL;
+	if (!core)
+		return;
 
-	/* TODO: Create a per-user clk and change callers to call clk_put */
-	return !clk->core->parent ? NULL : clk->core->parent->hw->clk;
-}
-EXPORT_SYMBOL_GPL(__clk_get_parent);
+	if (WARN_ON(core->enable_count == 0))
+		return;
 
-static struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,
-							 u8 index)
-{
-	if (!core || index >= core->num_parents)
-		return NULL;
-	else if (!core->parents)
-		return clk_core_lookup(core->parent_names[index]);
-	else if (!core->parents[index])
-		return core->parents[index] =
-			clk_core_lookup(core->parent_names[index]);
-	else
-		return core->parents[index];
-}
+	if (--core->enable_count > 0)
+		return;
 
-struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
-{
-	struct clk_core *parent;
+	trace_clk_disable(core);
 
-	if (!clk)
-		return NULL;
+	if (core->ops->disable)
+		core->ops->disable(core->hw);
 
-	parent = clk_core_get_parent_by_index(clk->core, index);
+	trace_clk_disable_complete(core);
 
-	return !parent ? NULL : parent->hw->clk;
+	clk_core_disable(core->parent);
 }
-EXPORT_SYMBOL_GPL(clk_get_parent_by_index);
 
-unsigned int __clk_get_enable_count(struct clk *clk)
+/**
+ * clk_disable - gate a clock
+ * @clk: the clk being gated
+ *
+ * clk_disable must not sleep, which differentiates it from clk_unprepare.  In
+ * a simple case, clk_disable can be used instead of clk_unprepare to gate a
+ * clk if the operation is fast and will never sleep.  One example is a
+ * SoC-internal clk which is controlled via simple register writes.  In the
+ * complex case a clk gate operation may require a fast and a slow part.  It is
+ * this reason that clk_unprepare and clk_disable are not mutually exclusive.
+ * In fact clk_disable must be called before clk_unprepare.
+ */
+void clk_disable(struct clk *clk)
 {
-	return !clk ? 0 : clk->core->enable_count;
+	unsigned long flags;
+
+	if (IS_ERR_OR_NULL(clk))
+		return;
+
+	flags = clk_enable_lock();
+	clk_core_disable(clk->core);
+	clk_enable_unlock(flags);
 }
+EXPORT_SYMBOL_GPL(clk_disable);
 
-static unsigned long clk_core_get_rate_nolock(struct clk_core *core)
+static int clk_core_enable(struct clk_core *core)
 {
-	unsigned long ret;
+	int ret = 0;
 
-	if (!core) {
-		ret = 0;
-		goto out;
-	}
+	if (!core)
+		return 0;
 
-	ret = core->rate;
+	if (WARN_ON(core->prepare_count == 0))
+		return -ESHUTDOWN;
 
-	if (core->flags & CLK_IS_ROOT)
-		goto out;
+	if (core->enable_count == 0) {
+		ret = clk_core_enable(core->parent);
 
-	if (!core->parent)
-		ret = 0;
+		if (ret)
+			return ret;
 
-out:
-	return ret;
-}
+		trace_clk_enable(core);
 
-unsigned long __clk_get_rate(struct clk *clk)
-{
-	if (!clk)
-		return 0;
+		if (core->ops->enable)
+			ret = core->ops->enable(core->hw);
 
-	return clk_core_get_rate_nolock(clk->core);
+		trace_clk_enable_complete(core);
+
+		if (ret) {
+			clk_core_disable(core->parent);
+			return ret;
+		}
+	}
+
+	core->enable_count++;
+	return 0;
 }
-EXPORT_SYMBOL_GPL(__clk_get_rate);
 
-static unsigned long __clk_get_accuracy(struct clk_core *core)
+/**
+ * clk_enable - ungate a clock
+ * @clk: the clk being ungated
+ *
+ * clk_enable must not sleep, which differentiates it from clk_prepare.  In a
+ * simple case, clk_enable can be used instead of clk_prepare to ungate a clk
+ * if the operation will never sleep.  One example is a SoC-internal clk which
+ * is controlled via simple register writes.  In the complex case a clk ungate
+ * operation may require a fast and a slow part.  It is this reason that
+ * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare
+ * must be called before clk_enable.  Returns 0 on success, -EERROR
+ * otherwise.
+ */
+int clk_enable(struct clk *clk)
 {
-	if (!core)
+	unsigned long flags;
+	int ret;
+
+	if (!clk)
 		return 0;
 
-	return core->accuracy;
-}
+	flags = clk_enable_lock();
+	ret = clk_core_enable(clk->core);
+	clk_enable_unlock(flags);
 
-unsigned long __clk_get_flags(struct clk *clk)
-{
-	return !clk ? 0 : clk->core->flags;
+	return ret;
 }
-EXPORT_SYMBOL_GPL(__clk_get_flags);
+EXPORT_SYMBOL_GPL(clk_enable);
 
-static bool clk_core_is_prepared(struct clk_core *core)
+static unsigned long clk_core_round_rate_nolock(struct clk_core *core,
+						unsigned long rate,
+						unsigned long min_rate,
+						unsigned long max_rate)
 {
-	int ret;
+	unsigned long parent_rate = 0;
+	struct clk_core *parent;
+	struct clk_hw *parent_hw;
+
+	lockdep_assert_held(&prepare_lock);
 
 	if (!core)
-		return false;
+		return 0;
 
-	/*
-	 * .is_prepared is optional for clocks that can prepare
-	 * fall back to software usage counter if it is missing
-	 */
-	if (!core->ops->is_prepared) {
-		ret = core->prepare_count ? 1 : 0;
-		goto out;
-	}
+	parent = core->parent;
+	if (parent)
+		parent_rate = parent->rate;
 
-	ret = core->ops->is_prepared(core->hw);
-out:
-	return !!ret;
+	if (core->ops->determine_rate) {
+		parent_hw = parent ? parent->hw : NULL;
+		return core->ops->determine_rate(core->hw, rate,
+						min_rate, max_rate,
+						&parent_rate, &parent_hw);
+	} else if (core->ops->round_rate)
+		return core->ops->round_rate(core->hw, rate, &parent_rate);
+	else if (core->flags & CLK_SET_RATE_PARENT)
+		return clk_core_round_rate_nolock(core->parent, rate, min_rate,
+						  max_rate);
+	else
+		return core->rate;
 }
 
-bool __clk_is_prepared(struct clk *clk)
+/**
+ * __clk_determine_rate - get the closest rate actually supported by a clock
+ * @hw: determine the rate of this clock
+ * @rate: target rate
+ * @min_rate: returned rate must be greater than this rate
+ * @max_rate: returned rate must be less than this rate
+ *
+ * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate and
+ * .determine_rate.
+ */
+unsigned long __clk_determine_rate(struct clk_hw *hw,
+				   unsigned long rate,
+				   unsigned long min_rate,
+				   unsigned long max_rate)
 {
-	if (!clk)
-		return false;
+	if (!hw)
+		return 0;
 
-	return clk_core_is_prepared(clk->core);
+	return clk_core_round_rate_nolock(hw->core, rate, min_rate, max_rate);
 }
+EXPORT_SYMBOL_GPL(__clk_determine_rate);
 
-static bool clk_core_is_enabled(struct clk_core *core)
+/**
+ * __clk_round_rate - round the given rate for a clk
+ * @clk: round the rate of this clock
+ * @rate: the rate which is to be rounded
+ *
+ * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate
+ */
+unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 {
-	int ret;
+	unsigned long min_rate;
+	unsigned long max_rate;
 
-	if (!core)
-		return false;
+	if (!clk)
+		return 0;
 
-	/*
-	 * .is_enabled is only mandatory for clocks that gate
-	 * fall back to software usage counter if .is_enabled is missing
-	 */
-	if (!core->ops->is_enabled) {
-		ret = core->enable_count ? 1 : 0;
-		goto out;
-	}
+	clk_core_get_boundaries(clk->core, &min_rate, &max_rate);
 
-	ret = core->ops->is_enabled(core->hw);
-out:
-	return !!ret;
+	return clk_core_round_rate_nolock(clk->core, rate, min_rate, max_rate);
 }
+EXPORT_SYMBOL_GPL(__clk_round_rate);
 
-bool __clk_is_enabled(struct clk *clk)
+/**
+ * clk_round_rate - round the given rate for a clk
+ * @clk: the clk for which we are rounding a rate
+ * @rate: the rate which is to be rounded
+ *
+ * Takes in a rate as input and rounds it to a rate that the clk can actually
+ * use which is then returned.  If clk doesn't support round_rate operation
+ * then the parent rate is returned.
+ */
+long clk_round_rate(struct clk *clk, unsigned long rate)
 {
+	unsigned long ret;
+
 	if (!clk)
-		return false;
+		return 0;
 
-	return clk_core_is_enabled(clk->core);
+	clk_prepare_lock();
+	ret = __clk_round_rate(clk, rate);
+	clk_prepare_unlock();
+
+	return ret;
 }
-EXPORT_SYMBOL_GPL(__clk_is_enabled);
+EXPORT_SYMBOL_GPL(clk_round_rate);
 
-static struct clk_core *__clk_lookup_subtree(const char *name,
-					     struct clk_core *core)
+/**
+ * __clk_notify - call clk notifier chain
+ * @core: clk that is changing rate
+ * @msg: clk notifier type (see include/linux/clk.h)
+ * @old_rate: old clk rate
+ * @new_rate: new clk rate
+ *
+ * Triggers a notifier call chain on the clk rate-change notification
+ * for 'clk'.  Passes a pointer to the struct clk and the previous
+ * and current rates to the notifier callback.  Intended to be called by
+ * internal clock code only.  Returns NOTIFY_DONE from the last driver
+ * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if
+ * a driver returns that.
+ */
+static int __clk_notify(struct clk_core *core, unsigned long msg,
+		unsigned long old_rate, unsigned long new_rate)
 {
-	struct clk_core *child;
-	struct clk_core *ret;
+	struct clk_notifier *cn;
+	struct clk_notifier_data cnd;
+	int ret = NOTIFY_DONE;
 
-	if (!strcmp(core->name, name))
-		return core;
+	cnd.old_rate = old_rate;
+	cnd.new_rate = new_rate;
 
-	hlist_for_each_entry(child, &core->children, child_node) {
-		ret = __clk_lookup_subtree(name, child);
-		if (ret)
-			return ret;
+	list_for_each_entry(cn, &clk_notifier_list, node) {
+		if (cn->clk->core == core) {
+			cnd.clk = cn->clk;
+			ret = srcu_notifier_call_chain(&cn->notifier_head, msg,
+					&cnd);
+		}
 	}
 
-	return NULL;
+	return ret;
 }
 
-static struct clk_core *clk_core_lookup(const char *name)
+/**
+ * __clk_recalc_accuracies
+ * @core: first clk in the subtree
+ *
+ * Walks the subtree of clks starting with clk and recalculates accuracies as
+ * it goes.  Note that if a clk does not implement the .recalc_accuracy
+ * callback then it is assumed that the clock will take on the accuracy of it's
+ * parent.
+ *
+ * Caller must hold prepare_lock.
+ */
+static void __clk_recalc_accuracies(struct clk_core *core)
 {
-	struct clk_core *root_clk;
-	struct clk_core *ret;
+	unsigned long parent_accuracy = 0;
+	struct clk_core *child;
 
-	if (!name)
-		return NULL;
+	lockdep_assert_held(&prepare_lock);
 
-	/* search the 'proper' clk tree first */
-	hlist_for_each_entry(root_clk, &clk_root_list, child_node) {
-		ret = __clk_lookup_subtree(name, root_clk);
-		if (ret)
-			return ret;
-	}
+	if (core->parent)
+		parent_accuracy = core->parent->accuracy;
 
-	/* if not found, then search the orphan tree */
-	hlist_for_each_entry(root_clk, &clk_orphan_list, child_node) {
-		ret = __clk_lookup_subtree(name, root_clk);
-		if (ret)
-			return ret;
-	}
+	if (core->ops->recalc_accuracy)
+		core->accuracy = core->ops->recalc_accuracy(core->hw,
+							  parent_accuracy);
+	else
+		core->accuracy = parent_accuracy;
 
-	return NULL;
+	hlist_for_each_entry(child, &core->children, child_node)
+		__clk_recalc_accuracies(child);
 }
 
-static bool mux_is_better_rate(unsigned long rate, unsigned long now,
-			   unsigned long best, unsigned long flags)
+static long clk_core_get_accuracy(struct clk_core *core)
 {
-	if (flags & CLK_MUX_ROUND_CLOSEST)
-		return abs(now - rate) < abs(best - rate);
+	unsigned long accuracy;
 
-	return now <= rate && now > best;
-}
+	clk_prepare_lock();
+	if (core && (core->flags & CLK_GET_ACCURACY_NOCACHE))
+		__clk_recalc_accuracies(core);
 
-static long
-clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
-			     unsigned long min_rate,
-			     unsigned long max_rate,
-			     unsigned long *best_parent_rate,
-			     struct clk_hw **best_parent_p,
-			     unsigned long flags)
-{
-	struct clk_core *core = hw->core, *parent, *best_parent = NULL;
-	int i, num_parents;
-	unsigned long parent_rate, best = 0;
-
-	/* if NO_REPARENT flag set, pass through to current parent */
-	if (core->flags & CLK_SET_RATE_NO_REPARENT) {
-		parent = core->parent;
-		if (core->flags & CLK_SET_RATE_PARENT)
-			best = __clk_determine_rate(parent ? parent->hw : NULL,
-						    rate, min_rate, max_rate);
-		else if (parent)
-			best = clk_core_get_rate_nolock(parent);
-		else
-			best = clk_core_get_rate_nolock(core);
-		goto out;
-	}
-
-	/* find the parent that can provide the fastest rate <= rate */
-	num_parents = core->num_parents;
-	for (i = 0; i < num_parents; i++) {
-		parent = clk_core_get_parent_by_index(core, i);
-		if (!parent)
-			continue;
-		if (core->flags & CLK_SET_RATE_PARENT)
-			parent_rate = __clk_determine_rate(parent->hw, rate,
-							   min_rate,
-							   max_rate);
-		else
-			parent_rate = clk_core_get_rate_nolock(parent);
-		if (mux_is_better_rate(rate, parent_rate, best, flags)) {
-			best_parent = parent;
-			best = parent_rate;
-		}
-	}
-
-out:
-	if (best_parent)
-		*best_parent_p = best_parent->hw;
-	*best_parent_rate = best;
+	accuracy = __clk_get_accuracy(core);
+	clk_prepare_unlock();
 
-	return best;
+	return accuracy;
 }
 
-struct clk *__clk_lookup(const char *name)
+/**
+ * clk_get_accuracy - return the accuracy of clk
+ * @clk: the clk whose accuracy is being returned
+ *
+ * Simply returns the cached accuracy of the clk, unless
+ * CLK_GET_ACCURACY_NOCACHE flag is set, which means a recalc_rate will be
+ * issued.
+ * If clk is NULL then returns 0.
+ */
+long clk_get_accuracy(struct clk *clk)
 {
-	struct clk_core *core = clk_core_lookup(name);
+	if (!clk)
+		return 0;
 
-	return !core ? NULL : core->hw->clk;
+	return clk_core_get_accuracy(clk->core);
 }
+EXPORT_SYMBOL_GPL(clk_get_accuracy);
 
-static void clk_core_get_boundaries(struct clk_core *core,
-				    unsigned long *min_rate,
-				    unsigned long *max_rate)
+static unsigned long clk_recalc(struct clk_core *core,
+				unsigned long parent_rate)
 {
-	struct clk *clk_user;
-
-	*min_rate = 0;
-	*max_rate = ULONG_MAX;
-
-	hlist_for_each_entry(clk_user, &core->clks, clks_node)
-		*min_rate = max(*min_rate, clk_user->min_rate);
-
-	hlist_for_each_entry(clk_user, &core->clks, clks_node)
-		*max_rate = min(*max_rate, clk_user->max_rate);
+	if (core->ops->recalc_rate)
+		return core->ops->recalc_rate(core->hw, parent_rate);
+	return parent_rate;
 }
 
-/*
- * Helper for finding best parent to provide a given frequency. This can be used
- * directly as a determine_rate callback (e.g. for a mux), or from a more
- * complex clock that may combine a mux with other operations.
+/**
+ * __clk_recalc_rates
+ * @core: first clk in the subtree
+ * @msg: notification type (see include/linux/clk.h)
+ *
+ * Walks the subtree of clks starting with clk and recalculates rates as it
+ * goes.  Note that if a clk does not implement the .recalc_rate callback then
+ * it is assumed that the clock will take on the rate of its parent.
+ *
+ * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,
+ * if necessary.
+ *
+ * Caller must hold prepare_lock.
  */
-long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
-			      unsigned long min_rate,
-			      unsigned long max_rate,
-			      unsigned long *best_parent_rate,
-			      struct clk_hw **best_parent_p)
+static void __clk_recalc_rates(struct clk_core *core, unsigned long msg)
 {
-	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
-					    best_parent_rate,
-					    best_parent_p, 0);
-}
-EXPORT_SYMBOL_GPL(__clk_mux_determine_rate);
+	unsigned long old_rate;
+	unsigned long parent_rate = 0;
+	struct clk_core *child;
 
-long __clk_mux_determine_rate_closest(struct clk_hw *hw, unsigned long rate,
-			      unsigned long min_rate,
-			      unsigned long max_rate,
-			      unsigned long *best_parent_rate,
-			      struct clk_hw **best_parent_p)
-{
-	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
-					    best_parent_rate,
-					    best_parent_p,
-					    CLK_MUX_ROUND_CLOSEST);
-}
-EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
+	lockdep_assert_held(&prepare_lock);
 
-/***        clk api        ***/
+	old_rate = core->rate;
 
-static void clk_core_unprepare(struct clk_core *core)
-{
-	if (!core)
-		return;
+	if (core->parent)
+		parent_rate = core->parent->rate;
 
-	if (WARN_ON(core->prepare_count == 0))
-		return;
+	core->rate = clk_recalc(core, parent_rate);
 
-	if (--core->prepare_count > 0)
-		return;
+	/*
+	 * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE
+	 * & ABORT_RATE_CHANGE notifiers
+	 */
+	if (core->notifier_count && msg)
+		__clk_notify(core, msg, old_rate, core->rate);
 
-	WARN_ON(core->enable_count > 0);
+	hlist_for_each_entry(child, &core->children, child_node)
+		__clk_recalc_rates(child, msg);
+}
 
-	trace_clk_unprepare(core);
+static unsigned long clk_core_get_rate(struct clk_core *core)
+{
+	unsigned long rate;
 
-	if (core->ops->unprepare)
-		core->ops->unprepare(core->hw);
+	clk_prepare_lock();
 
-	trace_clk_unprepare_complete(core);
-	clk_core_unprepare(core->parent);
+	if (core && (core->flags & CLK_GET_RATE_NOCACHE))
+		__clk_recalc_rates(core, 0);
+
+	rate = clk_core_get_rate_nolock(core);
+	clk_prepare_unlock();
+
+	return rate;
 }
 
 /**
- * clk_unprepare - undo preparation of a clock source
- * @clk: the clk being unprepared
+ * clk_get_rate - return the rate of clk
+ * @clk: the clk whose rate is being returned
  *
- * clk_unprepare may sleep, which differentiates it from clk_disable.  In a
- * simple case, clk_unprepare can be used instead of clk_disable to gate a clk
- * if the operation may sleep.  One example is a clk which is accessed over
- * I2c.  In the complex case a clk gate operation may require a fast and a slow
- * part.  It is this reason that clk_unprepare and clk_disable are not mutually
- * exclusive.  In fact clk_disable must be called before clk_unprepare.
+ * Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag
+ * is set, which means a recalc_rate will be issued.
+ * If clk is NULL then returns 0.
  */
-void clk_unprepare(struct clk *clk)
+unsigned long clk_get_rate(struct clk *clk)
 {
-	if (IS_ERR_OR_NULL(clk))
-		return;
+	if (!clk)
+		return 0;
 
-	clk_prepare_lock();
-	clk_core_unprepare(clk->core);
-	clk_prepare_unlock();
+	return clk_core_get_rate(clk->core);
 }
-EXPORT_SYMBOL_GPL(clk_unprepare);
+EXPORT_SYMBOL_GPL(clk_get_rate);
 
-static int clk_core_prepare(struct clk_core *core)
+static int clk_fetch_parent_index(struct clk_core *core,
+				  struct clk_core *parent)
 {
-	int ret = 0;
-
-	if (!core)
-		return 0;
-
-	if (core->prepare_count == 0) {
-		ret = clk_core_prepare(core->parent);
-		if (ret)
-			return ret;
+	int i;
 
-		trace_clk_prepare(core);
+	if (!core->parents) {
+		core->parents = kcalloc(core->num_parents,
+					sizeof(struct clk *), GFP_KERNEL);
+		if (!core->parents)
+			return -ENOMEM;
+	}
 
-		if (core->ops->prepare)
-			ret = core->ops->prepare(core->hw);
+	/*
+	 * find index of new parent clock using cached parent ptrs,
+	 * or if not yet cached, use string name comparison and cache
+	 * them now to avoid future calls to clk_core_lookup.
+	 */
+	for (i = 0; i < core->num_parents; i++) {
+		if (core->parents[i] == parent)
+			return i;
 
-		trace_clk_prepare_complete(core);
+		if (core->parents[i])
+			continue;
 
-		if (ret) {
-			clk_core_unprepare(core->parent);
-			return ret;
+		if (!strcmp(core->parent_names[i], parent->name)) {
+			core->parents[i] = clk_core_lookup(parent->name);
+			return i;
 		}
 	}
 
-	core->prepare_count++;
-
-	return 0;
+	return -EINVAL;
 }
 
-/**
- * clk_prepare - prepare a clock source
- * @clk: the clk being prepared
- *
- * clk_prepare may sleep, which differentiates it from clk_enable.  In a simple
- * case, clk_prepare can be used instead of clk_enable to ungate a clk if the
- * operation may sleep.  One example is a clk which is accessed over I2c.  In
- * the complex case a clk ungate operation may require a fast and a slow part.
- * It is this reason that clk_prepare and clk_enable are not mutually
- * exclusive.  In fact clk_prepare must be called before clk_enable.
- * Returns 0 on success, -EERROR otherwise.
- */
-int clk_prepare(struct clk *clk)
+static void clk_reparent(struct clk_core *core, struct clk_core *new_parent)
 {
-	int ret;
-
-	if (!clk)
-		return 0;
+	hlist_del(&core->child_node);
 
-	clk_prepare_lock();
-	ret = clk_core_prepare(clk->core);
-	clk_prepare_unlock();
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(clk_prepare);
-
-static void clk_core_disable(struct clk_core *core)
-{
-	if (!core)
-		return;
-
-	if (WARN_ON(core->enable_count == 0))
-		return;
-
-	if (--core->enable_count > 0)
-		return;
-
-	trace_clk_disable(core);
-
-	if (core->ops->disable)
-		core->ops->disable(core->hw);
+	if (new_parent) {
+		/* avoid duplicate POST_RATE_CHANGE notifications */
+		if (new_parent->new_child == core)
+			new_parent->new_child = NULL;
 
-	trace_clk_disable_complete(core);
+		hlist_add_head(&core->child_node, &new_parent->children);
+	} else {
+		hlist_add_head(&core->child_node, &clk_orphan_list);
+	}
 
-	clk_core_disable(core->parent);
+	core->parent = new_parent;
 }
 
-/**
- * clk_disable - gate a clock
- * @clk: the clk being gated
- *
- * clk_disable must not sleep, which differentiates it from clk_unprepare.  In
- * a simple case, clk_disable can be used instead of clk_unprepare to gate a
- * clk if the operation is fast and will never sleep.  One example is a
- * SoC-internal clk which is controlled via simple register writes.  In the
- * complex case a clk gate operation may require a fast and a slow part.  It is
- * this reason that clk_unprepare and clk_disable are not mutually exclusive.
- * In fact clk_disable must be called before clk_unprepare.
- */
-void clk_disable(struct clk *clk)
+static struct clk_core *__clk_set_parent_before(struct clk_core *core,
+					   struct clk_core *parent)
 {
 	unsigned long flags;
+	struct clk_core *old_parent = core->parent;
 
-	if (IS_ERR_OR_NULL(clk))
-		return;
+	/*
+	 * Migrate prepare state between parents and prevent race with
+	 * clk_enable().
+	 *
+	 * If the clock is not prepared, then a race with
+	 * clk_enable/disable() is impossible since we already have the
+	 * prepare lock (future calls to clk_enable() need to be preceded by
+	 * a clk_prepare()).
+	 *
+	 * If the clock is prepared, migrate the prepared state to the new
+	 * parent and also protect against a race with clk_enable() by
+	 * forcing the clock and the new parent on.  This ensures that all
+	 * future calls to clk_enable() are practically NOPs with respect to
+	 * hardware and software states.
+	 *
+	 * See also: Comment for clk_set_parent() below.
+	 */
+	if (core->prepare_count) {
+		clk_core_prepare(parent);
+		clk_core_enable(parent);
+		clk_core_enable(core);
+	}
 
+	/* update the clk tree topology */
 	flags = clk_enable_lock();
-	clk_core_disable(clk->core);
+	clk_reparent(core, parent);
 	clk_enable_unlock(flags);
+
+	return old_parent;
 }
-EXPORT_SYMBOL_GPL(clk_disable);
 
-static int clk_core_enable(struct clk_core *core)
+static void __clk_set_parent_after(struct clk_core *core,
+				   struct clk_core *parent,
+				   struct clk_core *old_parent)
 {
-	int ret = 0;
-
-	if (!core)
-		return 0;
+	/*
+	 * Finish the migration of prepare state and undo the changes done
+	 * for preventing a race with clk_enable().
+	 */
+	if (core->prepare_count) {
+		clk_core_disable(core);
+		clk_core_disable(old_parent);
+		clk_core_unprepare(old_parent);
+	}
+}
 
-	if (WARN_ON(core->prepare_count == 0))
-		return -ESHUTDOWN;
+static int __clk_set_parent(struct clk_core *core, struct clk_core *parent,
+			    u8 p_index)
+{
+	unsigned long flags;
+	int ret = 0;
+	struct clk_core *old_parent;
 
-	if (core->enable_count == 0) {
-		ret = clk_core_enable(core->parent);
+	old_parent = __clk_set_parent_before(core, parent);
 
-		if (ret)
-			return ret;
+	trace_clk_set_parent(core, parent);
 
-		trace_clk_enable(core);
+	/* change clock input source */
+	if (parent && core->ops->set_parent)
+		ret = core->ops->set_parent(core->hw, p_index);
 
-		if (core->ops->enable)
-			ret = core->ops->enable(core->hw);
+	trace_clk_set_parent_complete(core, parent);
 
-		trace_clk_enable_complete(core);
+	if (ret) {
+		flags = clk_enable_lock();
+		clk_reparent(core, old_parent);
+		clk_enable_unlock(flags);
 
-		if (ret) {
-			clk_core_disable(core->parent);
-			return ret;
+		if (core->prepare_count) {
+			clk_core_disable(core);
+			clk_core_disable(parent);
+			clk_core_unprepare(parent);
 		}
+		return ret;
 	}
 
-	core->enable_count++;
+	__clk_set_parent_after(core, parent, old_parent);
+
 	return 0;
 }
 
 /**
- * clk_enable - ungate a clock
- * @clk: the clk being ungated
+ * __clk_speculate_rates
+ * @core: first clk in the subtree
+ * @parent_rate: the "future" rate of clk's parent
  *
- * clk_enable must not sleep, which differentiates it from clk_prepare.  In a
- * simple case, clk_enable can be used instead of clk_prepare to ungate a clk
- * if the operation will never sleep.  One example is a SoC-internal clk which
- * is controlled via simple register writes.  In the complex case a clk ungate
- * operation may require a fast and a slow part.  It is this reason that
- * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare
- * must be called before clk_enable.  Returns 0 on success, -EERROR
- * otherwise.
+ * Walks the subtree of clks starting with clk, speculating rates as it
+ * goes and firing off PRE_RATE_CHANGE notifications as necessary.
+ *
+ * Unlike clk_recalc_rates, clk_speculate_rates exists only for sending
+ * pre-rate change notifications and returns early if no clks in the
+ * subtree have subscribed to the notifications.  Note that if a clk does not
+ * implement the .recalc_rate callback then it is assumed that the clock will
+ * take on the rate of its parent.
+ *
+ * Caller must hold prepare_lock.
  */
-int clk_enable(struct clk *clk)
+static int __clk_speculate_rates(struct clk_core *core,
+				 unsigned long parent_rate)
 {
-	unsigned long flags;
-	int ret;
+	struct clk_core *child;
+	unsigned long new_rate;
+	int ret = NOTIFY_DONE;
 
-	if (!clk)
-		return 0;
+	lockdep_assert_held(&prepare_lock);
 
-	flags = clk_enable_lock();
-	ret = clk_core_enable(clk->core);
-	clk_enable_unlock(flags);
+	new_rate = clk_recalc(core, parent_rate);
+
+	/* abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */
+	if (core->notifier_count)
+		ret = __clk_notify(core, PRE_RATE_CHANGE, core->rate, new_rate);
+
+	if (ret & NOTIFY_STOP_MASK) {
+		pr_debug("%s: clk notifier callback for clock %s aborted with error %d\n",
+				__func__, core->name, ret);
+		goto out;
+	}
+
+	hlist_for_each_entry(child, &core->children, child_node) {
+		ret = __clk_speculate_rates(child, new_rate);
+		if (ret & NOTIFY_STOP_MASK)
+			break;
+	}
 
+out:
 	return ret;
 }
-EXPORT_SYMBOL_GPL(clk_enable);
 
-static unsigned long clk_core_round_rate_nolock(struct clk_core *core,
-						unsigned long rate,
-						unsigned long min_rate,
-						unsigned long max_rate)
+static void clk_calc_subtree(struct clk_core *core, unsigned long new_rate,
+			     struct clk_core *new_parent, u8 p_index)
 {
-	unsigned long parent_rate = 0;
-	struct clk_core *parent;
-	struct clk_hw *parent_hw;
+	struct clk_core *child;
 
-	lockdep_assert_held(&prepare_lock);
+	core->new_rate = new_rate;
+	core->new_parent = new_parent;
+	core->new_parent_index = p_index;
+	/* include clk in new parent's PRE_RATE_CHANGE notifications */
+	core->new_child = NULL;
+	if (new_parent && new_parent != core->parent)
+		new_parent->new_child = core;
 
-	if (!core)
-		return 0;
+	hlist_for_each_entry(child, &core->children, child_node) {
+		child->new_rate = clk_recalc(child, new_rate);
+		clk_calc_subtree(child, child->new_rate, NULL, 0);
+	}
+}
 
-	parent = core->parent;
+/*
+ * calculate the new rates returning the topmost clock that has to be
+ * changed.
+ */
+static struct clk_core *clk_calc_new_rates(struct clk_core *core,
+					   unsigned long rate)
+{
+	struct clk_core *top = core;
+	struct clk_core *old_parent, *parent;
+	struct clk_hw *parent_hw;
+	unsigned long best_parent_rate = 0;
+	unsigned long new_rate;
+	unsigned long min_rate;
+	unsigned long max_rate;
+	int p_index = 0;
+	long ret;
+
+	/* sanity */
+	if (IS_ERR_OR_NULL(core))
+		return NULL;
+
+	/* save parent rate, if it exists */
+	parent = old_parent = core->parent;
 	if (parent)
-		parent_rate = parent->rate;
+		best_parent_rate = parent->rate;
 
+	clk_core_get_boundaries(core, &min_rate, &max_rate);
+
+	/* find the closest rate and parent clk/rate */
 	if (core->ops->determine_rate) {
 		parent_hw = parent ? parent->hw : NULL;
-		return core->ops->determine_rate(core->hw, rate,
-						min_rate, max_rate,
-						&parent_rate, &parent_hw);
-	} else if (core->ops->round_rate)
-		return core->ops->round_rate(core->hw, rate, &parent_rate);
-	else if (core->flags & CLK_SET_RATE_PARENT)
-		return clk_core_round_rate_nolock(core->parent, rate, min_rate,
-						  max_rate);
-	else
-		return core->rate;
-}
-
-/**
- * __clk_determine_rate - get the closest rate actually supported by a clock
- * @hw: determine the rate of this clock
- * @rate: target rate
- * @min_rate: returned rate must be greater than this rate
- * @max_rate: returned rate must be less than this rate
- *
- * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate and
- * .determine_rate.
- */
-unsigned long __clk_determine_rate(struct clk_hw *hw,
-				   unsigned long rate,
-				   unsigned long min_rate,
-				   unsigned long max_rate)
-{
-	if (!hw)
-		return 0;
-
-	return clk_core_round_rate_nolock(hw->core, rate, min_rate, max_rate);
-}
-EXPORT_SYMBOL_GPL(__clk_determine_rate);
-
-/**
- * __clk_round_rate - round the given rate for a clk
- * @clk: round the rate of this clock
- * @rate: the rate which is to be rounded
- *
- * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate
- */
-unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
-{
-	unsigned long min_rate;
-	unsigned long max_rate;
+		ret = core->ops->determine_rate(core->hw, rate,
+					       min_rate,
+					       max_rate,
+					       &best_parent_rate,
+					       &parent_hw);
+		if (ret < 0)
+			return NULL;
 
-	if (!clk)
-		return 0;
+		new_rate = ret;
+		parent = parent_hw ? parent_hw->core : NULL;
+	} else if (core->ops->round_rate) {
+		ret = core->ops->round_rate(core->hw, rate,
+					   &best_parent_rate);
+		if (ret < 0)
+			return NULL;
 
-	clk_core_get_boundaries(clk->core, &min_rate, &max_rate);
+		new_rate = ret;
+		if (new_rate < min_rate || new_rate > max_rate)
+			return NULL;
+	} else if (!parent || !(core->flags & CLK_SET_RATE_PARENT)) {
+		/* pass-through clock without adjustable parent */
+		core->new_rate = core->rate;
+		return NULL;
+	} else {
+		/* pass-through clock with adjustable parent */
+		top = clk_calc_new_rates(parent, rate);
+		new_rate = parent->new_rate;
+		goto out;
+	}
 
-	return clk_core_round_rate_nolock(clk->core, rate, min_rate, max_rate);
-}
-EXPORT_SYMBOL_GPL(__clk_round_rate);
+	/* some clocks must be gated to change parent */
+	if (parent != old_parent &&
+	    (core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {
+		pr_debug("%s: %s not gated but wants to reparent\n",
+			 __func__, core->name);
+		return NULL;
+	}
 
-/**
- * clk_round_rate - round the given rate for a clk
- * @clk: the clk for which we are rounding a rate
- * @rate: the rate which is to be rounded
- *
- * Takes in a rate as input and rounds it to a rate that the clk can actually
- * use which is then returned.  If clk doesn't support round_rate operation
- * then the parent rate is returned.
- */
-long clk_round_rate(struct clk *clk, unsigned long rate)
-{
-	unsigned long ret;
+	/* try finding the new parent index */
+	if (parent && core->num_parents > 1) {
+		p_index = clk_fetch_parent_index(core, parent);
+		if (p_index < 0) {
+			pr_debug("%s: clk %s can not be parent of clk %s\n",
+				 __func__, parent->name, core->name);
+			return NULL;
+		}
+	}
 
-	if (!clk)
-		return 0;
+	if ((core->flags & CLK_SET_RATE_PARENT) && parent &&
+	    best_parent_rate != parent->rate)
+		top = clk_calc_new_rates(parent, best_parent_rate);
 
-	clk_prepare_lock();
-	ret = __clk_round_rate(clk, rate);
-	clk_prepare_unlock();
+out:
+	clk_calc_subtree(core, new_rate, parent, p_index);
 
-	return ret;
+	return top;
 }
-EXPORT_SYMBOL_GPL(clk_round_rate);
 
-/**
- * __clk_notify - call clk notifier chain
- * @core: clk that is changing rate
- * @msg: clk notifier type (see include/linux/clk.h)
- * @old_rate: old clk rate
- * @new_rate: new clk rate
- *
- * Triggers a notifier call chain on the clk rate-change notification
- * for 'clk'.  Passes a pointer to the struct clk and the previous
- * and current rates to the notifier callback.  Intended to be called by
- * internal clock code only.  Returns NOTIFY_DONE from the last driver
- * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if
- * a driver returns that.
+/*
+ * Notify about rate changes in a subtree. Always walk down the whole tree
+ * so that in case of an error we can walk down the whole tree again and
+ * abort the change.
  */
-static int __clk_notify(struct clk_core *core, unsigned long msg,
-		unsigned long old_rate, unsigned long new_rate)
+static struct clk_core *clk_propagate_rate_change(struct clk_core *core,
+						  unsigned long event)
 {
-	struct clk_notifier *cn;
-	struct clk_notifier_data cnd;
+	struct clk_core *child, *tmp_clk, *fail_clk = NULL;
 	int ret = NOTIFY_DONE;
 
-	cnd.old_rate = old_rate;
-	cnd.new_rate = new_rate;
+	if (core->rate == core->new_rate)
+		return NULL;
 
-	list_for_each_entry(cn, &clk_notifier_list, node) {
-		if (cn->clk->core == core) {
-			cnd.clk = cn->clk;
-			ret = srcu_notifier_call_chain(&cn->notifier_head, msg,
-					&cnd);
-		}
+	if (core->notifier_count) {
+		ret = __clk_notify(core, event, core->rate, core->new_rate);
+		if (ret & NOTIFY_STOP_MASK)
+			fail_clk = core;
 	}
 
-	return ret;
-}
-
-/**
- * __clk_recalc_accuracies
- * @core: first clk in the subtree
- *
- * Walks the subtree of clks starting with clk and recalculates accuracies as
- * it goes.  Note that if a clk does not implement the .recalc_accuracy
- * callback then it is assumed that the clock will take on the accuracy of it's
- * parent.
- *
- * Caller must hold prepare_lock.
- */
-static void __clk_recalc_accuracies(struct clk_core *core)
-{
-	unsigned long parent_accuracy = 0;
-	struct clk_core *child;
-
-	lockdep_assert_held(&prepare_lock);
-
-	if (core->parent)
-		parent_accuracy = core->parent->accuracy;
+	hlist_for_each_entry(child, &core->children, child_node) {
+		/* Skip children who will be reparented to another clock */
+		if (child->new_parent && child->new_parent != core)
+			continue;
+		tmp_clk = clk_propagate_rate_change(child, event);
+		if (tmp_clk)
+			fail_clk = tmp_clk;
+	}
 
-	if (core->ops->recalc_accuracy)
-		core->accuracy = core->ops->recalc_accuracy(core->hw,
-							  parent_accuracy);
-	else
-		core->accuracy = parent_accuracy;
+	/* handle the new child who might not be in core->children yet */
+	if (core->new_child) {
+		tmp_clk = clk_propagate_rate_change(core->new_child, event);
+		if (tmp_clk)
+			fail_clk = tmp_clk;
+	}
 
-	hlist_for_each_entry(child, &core->children, child_node)
-		__clk_recalc_accuracies(child);
+	return fail_clk;
 }
 
-static long clk_core_get_accuracy(struct clk_core *core)
+/*
+ * walk down a subtree and set the new rates notifying the rate
+ * change on the way
+ */
+static void clk_change_rate(struct clk_core *core)
 {
-	unsigned long accuracy;
-
-	clk_prepare_lock();
-	if (core && (core->flags & CLK_GET_ACCURACY_NOCACHE))
-		__clk_recalc_accuracies(core);
+	struct clk_core *child;
+	struct hlist_node *tmp;
+	unsigned long old_rate;
+	unsigned long best_parent_rate = 0;
+	bool skip_set_rate = false;
+	struct clk_core *old_parent;
 
-	accuracy = __clk_get_accuracy(core);
-	clk_prepare_unlock();
+	old_rate = core->rate;
 
-	return accuracy;
-}
+	if (core->new_parent)
+		best_parent_rate = core->new_parent->rate;
+	else if (core->parent)
+		best_parent_rate = core->parent->rate;
 
-/**
- * clk_get_accuracy - return the accuracy of clk
- * @clk: the clk whose accuracy is being returned
- *
- * Simply returns the cached accuracy of the clk, unless
- * CLK_GET_ACCURACY_NOCACHE flag is set, which means a recalc_rate will be
- * issued.
- * If clk is NULL then returns 0.
- */
-long clk_get_accuracy(struct clk *clk)
-{
-	if (!clk)
-		return 0;
+	if (core->new_parent && core->new_parent != core->parent) {
+		old_parent = __clk_set_parent_before(core, core->new_parent);
+		trace_clk_set_parent(core, core->new_parent);
 
-	return clk_core_get_accuracy(clk->core);
-}
-EXPORT_SYMBOL_GPL(clk_get_accuracy);
+		if (core->ops->set_rate_and_parent) {
+			skip_set_rate = true;
+			core->ops->set_rate_and_parent(core->hw, core->new_rate,
+					best_parent_rate,
+					core->new_parent_index);
+		} else if (core->ops->set_parent) {
+			core->ops->set_parent(core->hw, core->new_parent_index);
+		}
 
-static unsigned long clk_recalc(struct clk_core *core,
-				unsigned long parent_rate)
-{
-	if (core->ops->recalc_rate)
-		return core->ops->recalc_rate(core->hw, parent_rate);
-	return parent_rate;
-}
+		trace_clk_set_parent_complete(core, core->new_parent);
+		__clk_set_parent_after(core, core->new_parent, old_parent);
+	}
 
-/**
- * __clk_recalc_rates
- * @core: first clk in the subtree
- * @msg: notification type (see include/linux/clk.h)
- *
- * Walks the subtree of clks starting with clk and recalculates rates as it
- * goes.  Note that if a clk does not implement the .recalc_rate callback then
- * it is assumed that the clock will take on the rate of its parent.
- *
- * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,
- * if necessary.
- *
- * Caller must hold prepare_lock.
- */
-static void __clk_recalc_rates(struct clk_core *core, unsigned long msg)
-{
-	unsigned long old_rate;
-	unsigned long parent_rate = 0;
-	struct clk_core *child;
+	trace_clk_set_rate(core, core->new_rate);
 
-	lockdep_assert_held(&prepare_lock);
+	if (!skip_set_rate && core->ops->set_rate)
+		core->ops->set_rate(core->hw, core->new_rate, best_parent_rate);
 
-	old_rate = core->rate;
+	trace_clk_set_rate_complete(core, core->new_rate);
 
-	if (core->parent)
-		parent_rate = core->parent->rate;
+	core->rate = clk_recalc(core, best_parent_rate);
 
-	core->rate = clk_recalc(core, parent_rate);
+	if (core->notifier_count && old_rate != core->rate)
+		__clk_notify(core, POST_RATE_CHANGE, old_rate, core->rate);
 
 	/*
-	 * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE
-	 * & ABORT_RATE_CHANGE notifiers
+	 * Use safe iteration, as change_rate can actually swap parents
+	 * for certain clock types.
 	 */
-	if (core->notifier_count && msg)
-		__clk_notify(core, msg, old_rate, core->rate);
+	hlist_for_each_entry_safe(child, tmp, &core->children, child_node) {
+		/* Skip children who will be reparented to another clock */
+		if (child->new_parent && child->new_parent != core)
+			continue;
+		clk_change_rate(child);
+	}
 
-	hlist_for_each_entry(child, &core->children, child_node)
-		__clk_recalc_rates(child, msg);
+	/* handle the new child who might not be in core->children yet */
+	if (core->new_child)
+		clk_change_rate(core->new_child);
 }
 
-static unsigned long clk_core_get_rate(struct clk_core *core)
+static int clk_core_set_rate_nolock(struct clk_core *core,
+				    unsigned long req_rate)
 {
-	unsigned long rate;
+	struct clk_core *top, *fail_clk;
+	unsigned long rate = req_rate;
+	int ret = 0;
 
-	clk_prepare_lock();
+	if (!core)
+		return 0;
 
-	if (core && (core->flags & CLK_GET_RATE_NOCACHE))
-		__clk_recalc_rates(core, 0);
+	/* bail early if nothing to do */
+	if (rate == clk_core_get_rate_nolock(core))
+		return 0;
 
-	rate = clk_core_get_rate_nolock(core);
-	clk_prepare_unlock();
+	if ((core->flags & CLK_SET_RATE_GATE) && core->prepare_count)
+		return -EBUSY;
 
-	return rate;
+	/* calculate new rates and get the topmost changed clock */
+	top = clk_calc_new_rates(core, rate);
+	if (!top)
+		return -EINVAL;
+
+	/* notify that we are about to change rates */
+	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
+	if (fail_clk) {
+		pr_debug("%s: failed to set %s rate\n", __func__,
+				fail_clk->name);
+		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
+		return -EBUSY;
+	}
+
+	/* change the rates */
+	clk_change_rate(top);
+
+	core->req_rate = req_rate;
+
+	return ret;
 }
 
 /**
- * clk_get_rate - return the rate of clk
- * @clk: the clk whose rate is being returned
+ * clk_set_rate - specify a new rate for clk
+ * @clk: the clk whose rate is being changed
+ * @rate: the new rate for clk
  *
- * Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag
- * is set, which means a recalc_rate will be issued.
- * If clk is NULL then returns 0.
+ * In the simplest case clk_set_rate will only adjust the rate of clk.
+ *
+ * Setting the CLK_SET_RATE_PARENT flag allows the rate change operation to
+ * propagate up to clk's parent; whether or not this happens depends on the
+ * outcome of clk's .round_rate implementation.  If *parent_rate is unchanged
+ * after calling .round_rate then upstream parent propagation is ignored.  If
+ * *parent_rate comes back with a new rate for clk's parent then we propagate
+ * up to clk's parent and set its rate.  Upward propagation will continue
+ * until either a clk does not support the CLK_SET_RATE_PARENT flag or
+ * .round_rate stops requesting changes to clk's parent_rate.
+ *
+ * Rate changes are accomplished via tree traversal that also recalculates the
+ * rates for the clocks and fires off POST_RATE_CHANGE notifiers.
+ *
+ * Returns 0 on success, -EERROR otherwise.
  */
-unsigned long clk_get_rate(struct clk *clk)
+int clk_set_rate(struct clk *clk, unsigned long rate)
 {
+	int ret;
+
 	if (!clk)
 		return 0;
 
-	return clk_core_get_rate(clk->core);
-}
-EXPORT_SYMBOL_GPL(clk_get_rate);
-
-static int clk_fetch_parent_index(struct clk_core *core,
-				  struct clk_core *parent)
-{
-	int i;
-
-	if (!core->parents) {
-		core->parents = kcalloc(core->num_parents,
-					sizeof(struct clk *), GFP_KERNEL);
-		if (!core->parents)
-			return -ENOMEM;
-	}
-
-	/*
-	 * find index of new parent clock using cached parent ptrs,
-	 * or if not yet cached, use string name comparison and cache
-	 * them now to avoid future calls to clk_core_lookup.
-	 */
-	for (i = 0; i < core->num_parents; i++) {
-		if (core->parents[i] == parent)
-			return i;
+	/* prevent racing with updates to the clock topology */
+	clk_prepare_lock();
 
-		if (core->parents[i])
-			continue;
+	ret = clk_core_set_rate_nolock(clk->core, rate);
 
-		if (!strcmp(core->parent_names[i], parent->name)) {
-			core->parents[i] = clk_core_lookup(parent->name);
-			return i;
-		}
-	}
+	clk_prepare_unlock();
 
-	return -EINVAL;
+	return ret;
 }
+EXPORT_SYMBOL_GPL(clk_set_rate);
 
-static void clk_reparent(struct clk_core *core, struct clk_core *new_parent)
+/**
+ * clk_set_rate_range - set a rate range for a clock source
+ * @clk: clock source
+ * @min: desired minimum clock rate in Hz, inclusive
+ * @max: desired maximum clock rate in Hz, inclusive
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_rate_range(struct clk *clk, unsigned long min, unsigned long max)
 {
-	hlist_del(&core->child_node);
+	int ret = 0;
 
-	if (new_parent) {
-		/* avoid duplicate POST_RATE_CHANGE notifications */
-		if (new_parent->new_child == core)
-			new_parent->new_child = NULL;
+	if (!clk)
+		return 0;
 
-		hlist_add_head(&core->child_node, &new_parent->children);
-	} else {
-		hlist_add_head(&core->child_node, &clk_orphan_list);
+	if (min > max) {
+		pr_err("%s: clk %s dev %s con %s: invalid range [%lu, %lu]\n",
+		       __func__, clk->core->name, clk->dev_id, clk->con_id,
+		       min, max);
+		return -EINVAL;
 	}
 
-	core->parent = new_parent;
-}
-
-static struct clk_core *__clk_set_parent_before(struct clk_core *core,
-					   struct clk_core *parent)
-{
-	unsigned long flags;
-	struct clk_core *old_parent = core->parent;
+	clk_prepare_lock();
 
-	/*
-	 * Migrate prepare state between parents and prevent race with
-	 * clk_enable().
-	 *
-	 * If the clock is not prepared, then a race with
-	 * clk_enable/disable() is impossible since we already have the
-	 * prepare lock (future calls to clk_enable() need to be preceded by
-	 * a clk_prepare()).
-	 *
-	 * If the clock is prepared, migrate the prepared state to the new
-	 * parent and also protect against a race with clk_enable() by
-	 * forcing the clock and the new parent on.  This ensures that all
-	 * future calls to clk_enable() are practically NOPs with respect to
-	 * hardware and software states.
-	 *
-	 * See also: Comment for clk_set_parent() below.
-	 */
-	if (core->prepare_count) {
-		clk_core_prepare(parent);
-		clk_core_enable(parent);
-		clk_core_enable(core);
+	if (min != clk->min_rate || max != clk->max_rate) {
+		clk->min_rate = min;
+		clk->max_rate = max;
+		ret = clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
 	}
 
-	/* update the clk tree topology */
-	flags = clk_enable_lock();
-	clk_reparent(core, parent);
-	clk_enable_unlock(flags);
+	clk_prepare_unlock();
 
-	return old_parent;
+	return ret;
 }
+EXPORT_SYMBOL_GPL(clk_set_rate_range);
 
-static void __clk_set_parent_after(struct clk_core *core,
-				   struct clk_core *parent,
-				   struct clk_core *old_parent)
+/**
+ * clk_set_min_rate - set a minimum clock rate for a clock source
+ * @clk: clock source
+ * @rate: desired minimum clock rate in Hz, inclusive
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_min_rate(struct clk *clk, unsigned long rate)
 {
-	/*
-	 * Finish the migration of prepare state and undo the changes done
-	 * for preventing a race with clk_enable().
-	 */
-	if (core->prepare_count) {
-		clk_core_disable(core);
-		clk_core_disable(old_parent);
-		clk_core_unprepare(old_parent);
-	}
+	if (!clk)
+		return 0;
+
+	return clk_set_rate_range(clk, rate, clk->max_rate);
 }
+EXPORT_SYMBOL_GPL(clk_set_min_rate);
 
-static int __clk_set_parent(struct clk_core *core, struct clk_core *parent,
-			    u8 p_index)
+/**
+ * clk_set_max_rate - set a maximum clock rate for a clock source
+ * @clk: clock source
+ * @rate: desired maximum clock rate in Hz, inclusive
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_max_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long flags;
-	int ret = 0;
-	struct clk_core *old_parent;
-
-	old_parent = __clk_set_parent_before(core, parent);
-
-	trace_clk_set_parent(core, parent);
-
-	/* change clock input source */
-	if (parent && core->ops->set_parent)
-		ret = core->ops->set_parent(core->hw, p_index);
-
-	trace_clk_set_parent_complete(core, parent);
-
-	if (ret) {
-		flags = clk_enable_lock();
-		clk_reparent(core, old_parent);
-		clk_enable_unlock(flags);
-
-		if (core->prepare_count) {
-			clk_core_disable(core);
-			clk_core_disable(parent);
-			clk_core_unprepare(parent);
-		}
-		return ret;
-	}
-
-	__clk_set_parent_after(core, parent, old_parent);
+	if (!clk)
+		return 0;
 
-	return 0;
+	return clk_set_rate_range(clk, clk->min_rate, rate);
 }
+EXPORT_SYMBOL_GPL(clk_set_max_rate);
 
 /**
- * __clk_speculate_rates
- * @core: first clk in the subtree
- * @parent_rate: the "future" rate of clk's parent
- *
- * Walks the subtree of clks starting with clk, speculating rates as it
- * goes and firing off PRE_RATE_CHANGE notifications as necessary.
- *
- * Unlike clk_recalc_rates, clk_speculate_rates exists only for sending
- * pre-rate change notifications and returns early if no clks in the
- * subtree have subscribed to the notifications.  Note that if a clk does not
- * implement the .recalc_rate callback then it is assumed that the clock will
- * take on the rate of its parent.
+ * clk_get_parent - return the parent of a clk
+ * @clk: the clk whose parent gets returned
  *
- * Caller must hold prepare_lock.
+ * Simply returns clk->parent.  Returns NULL if clk is NULL.
  */
-static int __clk_speculate_rates(struct clk_core *core,
-				 unsigned long parent_rate)
+struct clk *clk_get_parent(struct clk *clk)
 {
-	struct clk_core *child;
-	unsigned long new_rate;
-	int ret = NOTIFY_DONE;
+	struct clk *parent;
 
-	lockdep_assert_held(&prepare_lock);
+	clk_prepare_lock();
+	parent = __clk_get_parent(clk);
+	clk_prepare_unlock();
 
-	new_rate = clk_recalc(core, parent_rate);
+	return parent;
+}
+EXPORT_SYMBOL_GPL(clk_get_parent);
 
-	/* abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */
-	if (core->notifier_count)
-		ret = __clk_notify(core, PRE_RATE_CHANGE, core->rate, new_rate);
+/*
+ * .get_parent is mandatory for clocks with multiple possible parents.  It is
+ * optional for single-parent clocks.  Always call .get_parent if it is
+ * available and WARN if it is missing for multi-parent clocks.
+ *
+ * For single-parent clocks without .get_parent, first check to see if the
+ * .parents array exists, and if so use it to avoid an expensive tree
+ * traversal.  If .parents does not exist then walk the tree.
+ */
+static struct clk_core *__clk_init_parent(struct clk_core *core)
+{
+	struct clk_core *ret = NULL;
+	u8 index;
 
-	if (ret & NOTIFY_STOP_MASK) {
-		pr_debug("%s: clk notifier callback for clock %s aborted with error %d\n",
-				__func__, core->name, ret);
+	/* handle the trivial cases */
+
+	if (!core->num_parents)
 		goto out;
-	}
 
-	hlist_for_each_entry(child, &core->children, child_node) {
-		ret = __clk_speculate_rates(child, new_rate);
-		if (ret & NOTIFY_STOP_MASK)
-			break;
+	if (core->num_parents == 1) {
+		if (IS_ERR_OR_NULL(core->parent))
+			core->parent = clk_core_lookup(core->parent_names[0]);
+		ret = core->parent;
+		goto out;
 	}
 
+	if (!core->ops->get_parent) {
+		WARN(!core->ops->get_parent,
+			"%s: multi-parent clocks must implement .get_parent\n",
+			__func__);
+		goto out;
+	};
+
+	/*
+	 * Do our best to cache parent clocks in core->parents.  This prevents
+	 * unnecessary and expensive lookups.  We don't set core->parent here;
+	 * that is done by the calling function.
+	 */
+
+	index = core->ops->get_parent(core->hw);
+
+	if (!core->parents)
+		core->parents =
+			kcalloc(core->num_parents, sizeof(struct clk *),
+					GFP_KERNEL);
+
+	ret = clk_core_get_parent_by_index(core, index);
+
 out:
 	return ret;
 }
 
-static void clk_calc_subtree(struct clk_core *core, unsigned long new_rate,
-			     struct clk_core *new_parent, u8 p_index)
+static void clk_core_reparent(struct clk_core *core,
+				  struct clk_core *new_parent)
 {
-	struct clk_core *child;
-
-	core->new_rate = new_rate;
-	core->new_parent = new_parent;
-	core->new_parent_index = p_index;
-	/* include clk in new parent's PRE_RATE_CHANGE notifications */
-	core->new_child = NULL;
-	if (new_parent && new_parent != core->parent)
-		new_parent->new_child = core;
-
-	hlist_for_each_entry(child, &core->children, child_node) {
-		child->new_rate = clk_recalc(child, new_rate);
-		clk_calc_subtree(child, child->new_rate, NULL, 0);
-	}
+	clk_reparent(core, new_parent);
+	__clk_recalc_accuracies(core);
+	__clk_recalc_rates(core, POST_RATE_CHANGE);
 }
 
-/*
- * calculate the new rates returning the topmost clock that has to be
- * changed.
+/**
+ * clk_has_parent - check if a clock is a possible parent for another
+ * @clk: clock source
+ * @parent: parent clock source
+ *
+ * This function can be used in drivers that need to check that a clock can be
+ * the parent of another without actually changing the parent.
+ *
+ * Returns true if @parent is a possible parent for @clk, false otherwise.
  */
-static struct clk_core *clk_calc_new_rates(struct clk_core *core,
-					   unsigned long rate)
+bool clk_has_parent(struct clk *clk, struct clk *parent)
 {
-	struct clk_core *top = core;
-	struct clk_core *old_parent, *parent;
-	struct clk_hw *parent_hw;
-	unsigned long best_parent_rate = 0;
-	unsigned long new_rate;
-	unsigned long min_rate;
-	unsigned long max_rate;
-	int p_index = 0;
-	long ret;
+	struct clk_core *core, *parent_core;
+	unsigned int i;
 
-	/* sanity */
-	if (IS_ERR_OR_NULL(core))
-		return NULL;
+	/* NULL clocks should be nops, so return success if either is NULL. */
+	if (!clk || !parent)
+		return true;
 
-	/* save parent rate, if it exists */
-	parent = old_parent = core->parent;
-	if (parent)
-		best_parent_rate = parent->rate;
+	core = clk->core;
+	parent_core = parent->core;
 
-	clk_core_get_boundaries(core, &min_rate, &max_rate);
+	/* Optimize for the case where the parent is already the parent. */
+	if (core->parent == parent_core)
+		return true;
 
-	/* find the closest rate and parent clk/rate */
-	if (core->ops->determine_rate) {
-		parent_hw = parent ? parent->hw : NULL;
-		ret = core->ops->determine_rate(core->hw, rate,
-					       min_rate,
-					       max_rate,
-					       &best_parent_rate,
-					       &parent_hw);
-		if (ret < 0)
-			return NULL;
+	for (i = 0; i < core->num_parents; i++)
+		if (strcmp(core->parent_names[i], parent_core->name) == 0)
+			return true;
 
-		new_rate = ret;
-		parent = parent_hw ? parent_hw->core : NULL;
-	} else if (core->ops->round_rate) {
-		ret = core->ops->round_rate(core->hw, rate,
-					   &best_parent_rate);
-		if (ret < 0)
-			return NULL;
+	return false;
+}
+EXPORT_SYMBOL_GPL(clk_has_parent);
 
-		new_rate = ret;
-		if (new_rate < min_rate || new_rate > max_rate)
-			return NULL;
-	} else if (!parent || !(core->flags & CLK_SET_RATE_PARENT)) {
-		/* pass-through clock without adjustable parent */
-		core->new_rate = core->rate;
-		return NULL;
-	} else {
-		/* pass-through clock with adjustable parent */
-		top = clk_calc_new_rates(parent, rate);
-		new_rate = parent->new_rate;
+static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
+{
+	int ret = 0;
+	int p_index = 0;
+	unsigned long p_rate = 0;
+
+	if (!core)
+		return 0;
+
+	/* prevent racing with updates to the clock topology */
+	clk_prepare_lock();
+
+	if (core->parent == parent)
+		goto out;
+
+	/* verify ops for for multi-parent clks */
+	if ((core->num_parents > 1) && (!core->ops->set_parent)) {
+		ret = -ENOSYS;
 		goto out;
 	}
 
-	/* some clocks must be gated to change parent */
-	if (parent != old_parent &&
-	    (core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {
-		pr_debug("%s: %s not gated but wants to reparent\n",
-			 __func__, core->name);
-		return NULL;
+	/* check that we are allowed to re-parent if the clock is in use */
+	if ((core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {
+		ret = -EBUSY;
+		goto out;
 	}
 
 	/* try finding the new parent index */
-	if (parent && core->num_parents > 1) {
+	if (parent) {
 		p_index = clk_fetch_parent_index(core, parent);
+		p_rate = parent->rate;
 		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",
-				 __func__, parent->name, core->name);
-			return NULL;
+					__func__, parent->name, core->name);
+			ret = p_index;
+			goto out;
 		}
 	}
 
-	if ((core->flags & CLK_SET_RATE_PARENT) && parent &&
-	    best_parent_rate != parent->rate)
-		top = clk_calc_new_rates(parent, best_parent_rate);
-
-out:
-	clk_calc_subtree(core, new_rate, parent, p_index);
-
-	return top;
-}
+	/* propagate PRE_RATE_CHANGE notifications */
+	ret = __clk_speculate_rates(core, p_rate);
 
-/*
- * Notify about rate changes in a subtree. Always walk down the whole tree
- * so that in case of an error we can walk down the whole tree again and
- * abort the change.
- */
-static struct clk_core *clk_propagate_rate_change(struct clk_core *core,
-						  unsigned long event)
-{
-	struct clk_core *child, *tmp_clk, *fail_clk = NULL;
-	int ret = NOTIFY_DONE;
+	/* abort if a driver objects */
+	if (ret & NOTIFY_STOP_MASK)
+		goto out;
 
-	if (core->rate == core->new_rate)
-		return NULL;
+	/* do the re-parent */
+	ret = __clk_set_parent(core, parent, p_index);
 
-	if (core->notifier_count) {
-		ret = __clk_notify(core, event, core->rate, core->new_rate);
-		if (ret & NOTIFY_STOP_MASK)
-			fail_clk = core;
+	/* propagate rate an accuracy recalculation accordingly */
+	if (ret) {
+		__clk_recalc_rates(core, ABORT_RATE_CHANGE);
+	} else {
+		__clk_recalc_rates(core, POST_RATE_CHANGE);
+		__clk_recalc_accuracies(core);
 	}
 
-	hlist_for_each_entry(child, &core->children, child_node) {
-		/* Skip children who will be reparented to another clock */
-		if (child->new_parent && child->new_parent != core)
-			continue;
-		tmp_clk = clk_propagate_rate_change(child, event);
-		if (tmp_clk)
-			fail_clk = tmp_clk;
-	}
+out:
+	clk_prepare_unlock();
 
-	/* handle the new child who might not be in core->children yet */
-	if (core->new_child) {
-		tmp_clk = clk_propagate_rate_change(core->new_child, event);
-		if (tmp_clk)
-			fail_clk = tmp_clk;
-	}
+	return ret;
+}
 
-	return fail_clk;
+/**
+ * clk_set_parent - switch the parent of a mux clk
+ * @clk: the mux clk whose input we are switching
+ * @parent: the new input to clk
+ *
+ * Re-parent clk to use parent as its new input source.  If clk is in
+ * prepared state, the clk will get enabled for the duration of this call. If
+ * that's not acceptable for a specific clk (Eg: the consumer can't handle
+ * that, the reparenting is glitchy in hardware, etc), use the
+ * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.
+ *
+ * After successfully changing clk's parent clk_set_parent will update the
+ * clk topology, sysfs topology and propagate rate recalculation via
+ * __clk_recalc_rates.
+ *
+ * Returns 0 on success, -EERROR otherwise.
+ */
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_set_parent(clk->core, parent ? parent->core : NULL);
 }
+EXPORT_SYMBOL_GPL(clk_set_parent);
 
-/*
- * walk down a subtree and set the new rates notifying the rate
- * change on the way
+/**
+ * clk_set_phase - adjust the phase shift of a clock signal
+ * @clk: clock signal source
+ * @degrees: number of degrees the signal is shifted
+ *
+ * Shifts the phase of a clock signal by the specified
+ * degrees. Returns 0 on success, -EERROR otherwise.
+ *
+ * This function makes no distinction about the input or reference
+ * signal that we adjust the clock signal phase against. For example
+ * phase locked-loop clock signal generators we may shift phase with
+ * respect to feedback clock signal input, but for other cases the
+ * clock phase may be shifted with respect to some other, unspecified
+ * signal.
+ *
+ * Additionally the concept of phase shift does not propagate through
+ * the clock tree hierarchy, which sets it apart from clock rates and
+ * clock accuracy. A parent clock phase attribute does not have an
+ * impact on the phase attribute of a child clock.
  */
-static void clk_change_rate(struct clk_core *core)
+int clk_set_phase(struct clk *clk, int degrees)
 {
-	struct clk_core *child;
-	struct hlist_node *tmp;
-	unsigned long old_rate;
-	unsigned long best_parent_rate = 0;
-	bool skip_set_rate = false;
-	struct clk_core *old_parent;
+	int ret = -EINVAL;
 
-	old_rate = core->rate;
+	if (!clk)
+		return 0;
 
-	if (core->new_parent)
-		best_parent_rate = core->new_parent->rate;
-	else if (core->parent)
-		best_parent_rate = core->parent->rate;
+	/* sanity check degrees */
+	degrees %= 360;
+	if (degrees < 0)
+		degrees += 360;
 
-	if (core->new_parent && core->new_parent != core->parent) {
-		old_parent = __clk_set_parent_before(core, core->new_parent);
-		trace_clk_set_parent(core, core->new_parent);
+	clk_prepare_lock();
 
-		if (core->ops->set_rate_and_parent) {
-			skip_set_rate = true;
-			core->ops->set_rate_and_parent(core->hw, core->new_rate,
-					best_parent_rate,
-					core->new_parent_index);
-		} else if (core->ops->set_parent) {
-			core->ops->set_parent(core->hw, core->new_parent_index);
-		}
+	trace_clk_set_phase(clk->core, degrees);
 
-		trace_clk_set_parent_complete(core, core->new_parent);
-		__clk_set_parent_after(core, core->new_parent, old_parent);
-	}
+	if (clk->core->ops->set_phase)
+		ret = clk->core->ops->set_phase(clk->core->hw, degrees);
 
-	trace_clk_set_rate(core, core->new_rate);
+	trace_clk_set_phase_complete(clk->core, degrees);
 
-	if (!skip_set_rate && core->ops->set_rate)
-		core->ops->set_rate(core->hw, core->new_rate, best_parent_rate);
+	if (!ret)
+		clk->core->phase = degrees;
 
-	trace_clk_set_rate_complete(core, core->new_rate);
+	clk_prepare_unlock();
 
-	core->rate = clk_recalc(core, best_parent_rate);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_phase);
 
-	if (core->notifier_count && old_rate != core->rate)
-		__clk_notify(core, POST_RATE_CHANGE, old_rate, core->rate);
+static int clk_core_get_phase(struct clk_core *core)
+{
+	int ret;
 
-	/*
-	 * Use safe iteration, as change_rate can actually swap parents
-	 * for certain clock types.
-	 */
-	hlist_for_each_entry_safe(child, tmp, &core->children, child_node) {
-		/* Skip children who will be reparented to another clock */
-		if (child->new_parent && child->new_parent != core)
-			continue;
-		clk_change_rate(child);
-	}
+	clk_prepare_lock();
+	ret = core->phase;
+	clk_prepare_unlock();
 
-	/* handle the new child who might not be in core->children yet */
-	if (core->new_child)
-		clk_change_rate(core->new_child);
+	return ret;
 }
 
-static int clk_core_set_rate_nolock(struct clk_core *core,
-				    unsigned long req_rate)
+/**
+ * clk_get_phase - return the phase shift of a clock signal
+ * @clk: clock signal source
+ *
+ * Returns the phase shift of a clock node in degrees, otherwise returns
+ * -EERROR.
+ */
+int clk_get_phase(struct clk *clk)
 {
-	struct clk_core *top, *fail_clk;
-	unsigned long rate = req_rate;
-	int ret = 0;
-
-	if (!core)
+	if (!clk)
 		return 0;
 
-	/* bail early if nothing to do */
-	if (rate == clk_core_get_rate_nolock(core))
-		return 0;
+	return clk_core_get_phase(clk->core);
+}
+EXPORT_SYMBOL_GPL(clk_get_phase);
 
-	if ((core->flags & CLK_SET_RATE_GATE) && core->prepare_count)
-		return -EBUSY;
+/**
+ * clk_is_match - check if two clk's point to the same hardware clock
+ * @p: clk compared against q
+ * @q: clk compared against p
+ *
+ * Returns true if the two struct clk pointers both point to the same hardware
+ * clock node. Put differently, returns true if struct clk *p and struct clk *q
+ * share the same struct clk_core object.
+ *
+ * Returns false otherwise. Note that two NULL clks are treated as matching.
+ */
+bool clk_is_match(const struct clk *p, const struct clk *q)
+{
+	/* trivial case: identical struct clk's or both NULL */
+	if (p == q)
+		return true;
 
-	/* calculate new rates and get the topmost changed clock */
-	top = clk_calc_new_rates(core, rate);
-	if (!top)
-		return -EINVAL;
+	/* true if clk->core pointers match. Avoid derefing garbage */
+	if (!IS_ERR_OR_NULL(p) && !IS_ERR_OR_NULL(q))
+		if (p->core == q->core)
+			return true;
 
-	/* notify that we are about to change rates */
-	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
-	if (fail_clk) {
-		pr_debug("%s: failed to set %s rate\n", __func__,
-				fail_clk->name);
-		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
-		return -EBUSY;
-	}
+	return false;
+}
+EXPORT_SYMBOL_GPL(clk_is_match);
 
-	/* change the rates */
-	clk_change_rate(top);
+/***        debugfs support        ***/
 
-	core->req_rate = req_rate;
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
 
-	return ret;
-}
+static struct dentry *rootdir;
+static int inited = 0;
+static DEFINE_MUTEX(clk_debug_lock);
+static HLIST_HEAD(clk_debug_list);
 
-/**
- * clk_set_rate - specify a new rate for clk
- * @clk: the clk whose rate is being changed
- * @rate: the new rate for clk
- *
- * In the simplest case clk_set_rate will only adjust the rate of clk.
- *
- * Setting the CLK_SET_RATE_PARENT flag allows the rate change operation to
- * propagate up to clk's parent; whether or not this happens depends on the
- * outcome of clk's .round_rate implementation.  If *parent_rate is unchanged
- * after calling .round_rate then upstream parent propagation is ignored.  If
- * *parent_rate comes back with a new rate for clk's parent then we propagate
- * up to clk's parent and set its rate.  Upward propagation will continue
- * until either a clk does not support the CLK_SET_RATE_PARENT flag or
- * .round_rate stops requesting changes to clk's parent_rate.
- *
- * Rate changes are accomplished via tree traversal that also recalculates the
- * rates for the clocks and fires off POST_RATE_CHANGE notifiers.
- *
- * Returns 0 on success, -EERROR otherwise.
- */
-int clk_set_rate(struct clk *clk, unsigned long rate)
+static struct hlist_head *all_lists[] = {
+	&clk_root_list,
+	&clk_orphan_list,
+	NULL,
+};
+
+static struct hlist_head *orphan_list[] = {
+	&clk_orphan_list,
+	NULL,
+};
+
+static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
+				 int level)
 {
-	int ret;
+	if (!c)
+		return;
 
-	if (!clk)
-		return 0;
+	seq_printf(s, "%*s%-*s %11d %12d %11lu %10lu %-3d\n",
+		   level * 3 + 1, "",
+		   30 - level * 3, c->name,
+		   c->enable_count, c->prepare_count, clk_core_get_rate(c),
+		   clk_core_get_accuracy(c), clk_core_get_phase(c));
+}
 
-	/* prevent racing with updates to the clock topology */
-	clk_prepare_lock();
+static void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,
+				     int level)
+{
+	struct clk_core *child;
 
-	ret = clk_core_set_rate_nolock(clk->core, rate);
+	if (!c)
+		return;
 
-	clk_prepare_unlock();
+	clk_summary_show_one(s, c, level);
 
-	return ret;
+	hlist_for_each_entry(child, &c->children, child_node)
+		clk_summary_show_subtree(s, child, level + 1);
 }
-EXPORT_SYMBOL_GPL(clk_set_rate);
 
-/**
- * clk_set_rate_range - set a rate range for a clock source
- * @clk: clock source
- * @min: desired minimum clock rate in Hz, inclusive
- * @max: desired maximum clock rate in Hz, inclusive
- *
- * Returns success (0) or negative errno.
- */
-int clk_set_rate_range(struct clk *clk, unsigned long min, unsigned long max)
+static int clk_summary_show(struct seq_file *s, void *data)
 {
-	int ret = 0;
-
-	if (!clk)
-		return 0;
+	struct clk_core *c;
+	struct hlist_head **lists = (struct hlist_head **)s->private;
 
-	if (min > max) {
-		pr_err("%s: clk %s dev %s con %s: invalid range [%lu, %lu]\n",
-		       __func__, clk->core->name, clk->dev_id, clk->con_id,
-		       min, max);
-		return -EINVAL;
-	}
+	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy   phase\n");
+	seq_puts(s, "----------------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 
-	if (min != clk->min_rate || max != clk->max_rate) {
-		clk->min_rate = min;
-		clk->max_rate = max;
-		ret = clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
-	}
+	for (; *lists; lists++)
+		hlist_for_each_entry(c, *lists, child_node)
+			clk_summary_show_subtree(s, c, 0);
 
 	clk_prepare_unlock();
 
-	return ret;
+	return 0;
 }
-EXPORT_SYMBOL_GPL(clk_set_rate_range);
-
-/**
- * clk_set_min_rate - set a minimum clock rate for a clock source
- * @clk: clock source
- * @rate: desired minimum clock rate in Hz, inclusive
- *
- * Returns success (0) or negative errno.
- */
-int clk_set_min_rate(struct clk *clk, unsigned long rate)
-{
-	if (!clk)
-		return 0;
 
-	return clk_set_rate_range(clk, rate, clk->max_rate);
-}
-EXPORT_SYMBOL_GPL(clk_set_min_rate);
 
-/**
- * clk_set_max_rate - set a maximum clock rate for a clock source
- * @clk: clock source
- * @rate: desired maximum clock rate in Hz, inclusive
- *
- * Returns success (0) or negative errno.
- */
-int clk_set_max_rate(struct clk *clk, unsigned long rate)
+static int clk_summary_open(struct inode *inode, struct file *file)
 {
-	if (!clk)
-		return 0;
-
-	return clk_set_rate_range(clk, clk->min_rate, rate);
+	return single_open(file, clk_summary_show, inode->i_private);
 }
-EXPORT_SYMBOL_GPL(clk_set_max_rate);
 
-/**
- * clk_get_parent - return the parent of a clk
- * @clk: the clk whose parent gets returned
- *
- * Simply returns clk->parent.  Returns NULL if clk is NULL.
- */
-struct clk *clk_get_parent(struct clk *clk)
-{
-	struct clk *parent;
+static const struct file_operations clk_summary_fops = {
+	.open		= clk_summary_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
-	clk_prepare_lock();
-	parent = __clk_get_parent(clk);
-	clk_prepare_unlock();
+static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
+{
+	if (!c)
+		return;
 
-	return parent;
+	seq_printf(s, "\"%s\": { ", c->name);
+	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
+	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
+	seq_printf(s, "\"rate\": %lu", clk_core_get_rate(c));
+	seq_printf(s, "\"accuracy\": %lu", clk_core_get_accuracy(c));
+	seq_printf(s, "\"phase\": %d", clk_core_get_phase(c));
 }
-EXPORT_SYMBOL_GPL(clk_get_parent);
 
-/*
- * .get_parent is mandatory for clocks with multiple possible parents.  It is
- * optional for single-parent clocks.  Always call .get_parent if it is
- * available and WARN if it is missing for multi-parent clocks.
- *
- * For single-parent clocks without .get_parent, first check to see if the
- * .parents array exists, and if so use it to avoid an expensive tree
- * traversal.  If .parents does not exist then walk the tree.
- */
-static struct clk_core *__clk_init_parent(struct clk_core *core)
+static void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)
 {
-	struct clk_core *ret = NULL;
-	u8 index;
+	struct clk_core *child;
 
-	/* handle the trivial cases */
+	if (!c)
+		return;
 
-	if (!core->num_parents)
-		goto out;
+	clk_dump_one(s, c, level);
 
-	if (core->num_parents == 1) {
-		if (IS_ERR_OR_NULL(core->parent))
-			core->parent = clk_core_lookup(core->parent_names[0]);
-		ret = core->parent;
-		goto out;
+	hlist_for_each_entry(child, &c->children, child_node) {
+		seq_printf(s, ",");
+		clk_dump_subtree(s, child, level + 1);
 	}
 
-	if (!core->ops->get_parent) {
-		WARN(!core->ops->get_parent,
-			"%s: multi-parent clocks must implement .get_parent\n",
-			__func__);
-		goto out;
-	};
-
-	/*
-	 * Do our best to cache parent clocks in core->parents.  This prevents
-	 * unnecessary and expensive lookups.  We don't set core->parent here;
-	 * that is done by the calling function.
-	 */
-
-	index = core->ops->get_parent(core->hw);
-
-	if (!core->parents)
-		core->parents =
-			kcalloc(core->num_parents, sizeof(struct clk *),
-					GFP_KERNEL);
-
-	ret = clk_core_get_parent_by_index(core, index);
-
-out:
-	return ret;
-}
-
-static void clk_core_reparent(struct clk_core *core,
-				  struct clk_core *new_parent)
-{
-	clk_reparent(core, new_parent);
-	__clk_recalc_accuracies(core);
-	__clk_recalc_rates(core, POST_RATE_CHANGE);
+	seq_printf(s, "}");
 }
 
-/**
- * clk_has_parent - check if a clock is a possible parent for another
- * @clk: clock source
- * @parent: parent clock source
- *
- * This function can be used in drivers that need to check that a clock can be
- * the parent of another without actually changing the parent.
- *
- * Returns true if @parent is a possible parent for @clk, false otherwise.
- */
-bool clk_has_parent(struct clk *clk, struct clk *parent)
+static int clk_dump(struct seq_file *s, void *data)
 {
-	struct clk_core *core, *parent_core;
-	unsigned int i;
+	struct clk_core *c;
+	bool first_node = true;
+	struct hlist_head **lists = (struct hlist_head **)s->private;
 
-	/* NULL clocks should be nops, so return success if either is NULL. */
-	if (!clk || !parent)
-		return true;
+	seq_printf(s, "{");
 
-	core = clk->core;
-	parent_core = parent->core;
+	clk_prepare_lock();
 
-	/* Optimize for the case where the parent is already the parent. */
-	if (core->parent == parent_core)
-		return true;
+	for (; *lists; lists++) {
+		hlist_for_each_entry(c, *lists, child_node) {
+			if (!first_node)
+				seq_puts(s, ",");
+			first_node = false;
+			clk_dump_subtree(s, c, 0);
+		}
+	}
 
-	for (i = 0; i < core->num_parents; i++)
-		if (strcmp(core->parent_names[i], parent_core->name) == 0)
-			return true;
+	clk_prepare_unlock();
 
-	return false;
+	seq_printf(s, "}");
+	return 0;
 }
-EXPORT_SYMBOL_GPL(clk_has_parent);
 
-static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
+
+static int clk_dump_open(struct inode *inode, struct file *file)
 {
-	int ret = 0;
-	int p_index = 0;
-	unsigned long p_rate = 0;
+	return single_open(file, clk_dump, inode->i_private);
+}
 
-	if (!core)
-		return 0;
+static const struct file_operations clk_dump_fops = {
+	.open		= clk_dump_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
-	/* prevent racing with updates to the clock topology */
-	clk_prepare_lock();
+static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
+{
+	struct dentry *d;
+	int ret = -ENOMEM;
 
-	if (core->parent == parent)
+	if (!core || !pdentry) {
+		ret = -EINVAL;
 		goto out;
+	}
 
-	/* verify ops for for multi-parent clks */
-	if ((core->num_parents > 1) && (!core->ops->set_parent)) {
-		ret = -ENOSYS;
+	d = debugfs_create_dir(core->name, pdentry);
+	if (!d)
 		goto out;
-	}
 
-	/* check that we are allowed to re-parent if the clock is in use */
-	if ((core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {
-		ret = -EBUSY;
-		goto out;
-	}
+	core->dentry = d;
+
+	d = debugfs_create_u32("clk_rate", S_IRUGO, core->dentry,
+			(u32 *)&core->rate);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_u32("clk_accuracy", S_IRUGO, core->dentry,
+			(u32 *)&core->accuracy);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_u32("clk_phase", S_IRUGO, core->dentry,
+			(u32 *)&core->phase);
+	if (!d)
+		goto err_out;
 
-	/* try finding the new parent index */
-	if (parent) {
-		p_index = clk_fetch_parent_index(core, parent);
-		p_rate = parent->rate;
-		if (p_index < 0) {
-			pr_debug("%s: clk %s can not be parent of clk %s\n",
-					__func__, parent->name, core->name);
-			ret = p_index;
-			goto out;
-		}
-	}
+	d = debugfs_create_x32("clk_flags", S_IRUGO, core->dentry,
+			(u32 *)&core->flags);
+	if (!d)
+		goto err_out;
 
-	/* propagate PRE_RATE_CHANGE notifications */
-	ret = __clk_speculate_rates(core, p_rate);
+	d = debugfs_create_u32("clk_prepare_count", S_IRUGO, core->dentry,
+			(u32 *)&core->prepare_count);
+	if (!d)
+		goto err_out;
 
-	/* abort if a driver objects */
-	if (ret & NOTIFY_STOP_MASK)
-		goto out;
+	d = debugfs_create_u32("clk_enable_count", S_IRUGO, core->dentry,
+			(u32 *)&core->enable_count);
+	if (!d)
+		goto err_out;
 
-	/* do the re-parent */
-	ret = __clk_set_parent(core, parent, p_index);
+	d = debugfs_create_u32("clk_notifier_count", S_IRUGO, core->dentry,
+			(u32 *)&core->notifier_count);
+	if (!d)
+		goto err_out;
 
-	/* propagate rate an accuracy recalculation accordingly */
-	if (ret) {
-		__clk_recalc_rates(core, ABORT_RATE_CHANGE);
-	} else {
-		__clk_recalc_rates(core, POST_RATE_CHANGE);
-		__clk_recalc_accuracies(core);
+	if (core->ops->debug_init) {
+		ret = core->ops->debug_init(core->hw, core->dentry);
+		if (ret)
+			goto err_out;
 	}
 
-out:
-	clk_prepare_unlock();
+	ret = 0;
+	goto out;
 
+err_out:
+	debugfs_remove_recursive(core->dentry);
+	core->dentry = NULL;
+out:
 	return ret;
 }
 
 /**
- * clk_set_parent - switch the parent of a mux clk
- * @clk: the mux clk whose input we are switching
- * @parent: the new input to clk
- *
- * Re-parent clk to use parent as its new input source.  If clk is in
- * prepared state, the clk will get enabled for the duration of this call. If
- * that's not acceptable for a specific clk (Eg: the consumer can't handle
- * that, the reparenting is glitchy in hardware, etc), use the
- * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.
- *
- * After successfully changing clk's parent clk_set_parent will update the
- * clk topology, sysfs topology and propagate rate recalculation via
- * __clk_recalc_rates.
+ * clk_debug_register - add a clk node to the debugfs clk tree
+ * @core: the clk being added to the debugfs clk tree
  *
- * Returns 0 on success, -EERROR otherwise.
+ * Dynamically adds a clk to the debugfs clk tree if debugfs has been
+ * initialized.  Otherwise it bails out early since the debugfs clk tree
+ * will be created lazily by clk_debug_init as part of a late_initcall.
  */
-int clk_set_parent(struct clk *clk, struct clk *parent)
+static int clk_debug_register(struct clk_core *core)
 {
-	if (!clk)
-		return 0;
+	int ret = 0;
 
-	return clk_core_set_parent(clk->core, parent ? parent->core : NULL);
+	mutex_lock(&clk_debug_lock);
+	hlist_add_head(&core->debug_node, &clk_debug_list);
+
+	if (!inited)
+		goto unlock;
+
+	ret = clk_debug_create_one(core, rootdir);
+unlock:
+	mutex_unlock(&clk_debug_lock);
+
+	return ret;
 }
-EXPORT_SYMBOL_GPL(clk_set_parent);
 
-/**
- * clk_set_phase - adjust the phase shift of a clock signal
- * @clk: clock signal source
- * @degrees: number of degrees the signal is shifted
- *
- * Shifts the phase of a clock signal by the specified
- * degrees. Returns 0 on success, -EERROR otherwise.
- *
- * This function makes no distinction about the input or reference
- * signal that we adjust the clock signal phase against. For example
- * phase locked-loop clock signal generators we may shift phase with
- * respect to feedback clock signal input, but for other cases the
- * clock phase may be shifted with respect to some other, unspecified
- * signal.
+ /**
+ * clk_debug_unregister - remove a clk node from the debugfs clk tree
+ * @core: the clk being removed from the debugfs clk tree
  *
- * Additionally the concept of phase shift does not propagate through
- * the clock tree hierarchy, which sets it apart from clock rates and
- * clock accuracy. A parent clock phase attribute does not have an
- * impact on the phase attribute of a child clock.
+ * Dynamically removes a clk and all it's children clk nodes from the
+ * debugfs clk tree if clk->dentry points to debugfs created by
+ * clk_debug_register in __clk_init.
  */
-int clk_set_phase(struct clk *clk, int degrees)
+static void clk_debug_unregister(struct clk_core *core)
 {
-	int ret = -EINVAL;
+	mutex_lock(&clk_debug_lock);
+	hlist_del_init(&core->debug_node);
+	debugfs_remove_recursive(core->dentry);
+	core->dentry = NULL;
+	mutex_unlock(&clk_debug_lock);
+}
 
-	if (!clk)
-		return 0;
+struct dentry *clk_debugfs_add_file(struct clk_hw *hw, char *name, umode_t mode,
+				void *data, const struct file_operations *fops)
+{
+	struct dentry *d = NULL;
 
-	/* sanity check degrees */
-	degrees %= 360;
-	if (degrees < 0)
-		degrees += 360;
+	if (hw->core->dentry)
+		d = debugfs_create_file(name, mode, hw->core->dentry, data,
+					fops);
 
-	clk_prepare_lock();
+	return d;
+}
+EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
 
-	trace_clk_set_phase(clk->core, degrees);
+/**
+ * clk_debug_init - lazily create the debugfs clk tree visualization
+ *
+ * clks are often initialized very early during boot before memory can
+ * be dynamically allocated and well before debugfs is setup.
+ * clk_debug_init walks the clk tree hierarchy while holding
+ * prepare_lock and creates the topology as part of a late_initcall,
+ * thus insuring that clks initialized very early will still be
+ * represented in the debugfs clk tree.  This function should only be
+ * called once at boot-time, and all other clks added dynamically will
+ * be done so with clk_debug_register.
+ */
+static int __init clk_debug_init(void)
+{
+	struct clk_core *core;
+	struct dentry *d;
 
-	if (clk->core->ops->set_phase)
-		ret = clk->core->ops->set_phase(clk->core->hw, degrees);
+	rootdir = debugfs_create_dir("clk", NULL);
 
-	trace_clk_set_phase_complete(clk->core, degrees);
+	if (!rootdir)
+		return -ENOMEM;
 
-	if (!ret)
-		clk->core->phase = degrees;
+	d = debugfs_create_file("clk_summary", S_IRUGO, rootdir, &all_lists,
+				&clk_summary_fops);
+	if (!d)
+		return -ENOMEM;
 
-	clk_prepare_unlock();
+	d = debugfs_create_file("clk_dump", S_IRUGO, rootdir, &all_lists,
+				&clk_dump_fops);
+	if (!d)
+		return -ENOMEM;
 
-	return ret;
-}
-EXPORT_SYMBOL_GPL(clk_set_phase);
+	d = debugfs_create_file("clk_orphan_summary", S_IRUGO, rootdir,
+				&orphan_list, &clk_summary_fops);
+	if (!d)
+		return -ENOMEM;
 
-static int clk_core_get_phase(struct clk_core *core)
-{
-	int ret;
+	d = debugfs_create_file("clk_orphan_dump", S_IRUGO, rootdir,
+				&orphan_list, &clk_dump_fops);
+	if (!d)
+		return -ENOMEM;
 
-	clk_prepare_lock();
-	ret = core->phase;
-	clk_prepare_unlock();
+	mutex_lock(&clk_debug_lock);
+	hlist_for_each_entry(core, &clk_debug_list, debug_node)
+		clk_debug_create_one(core, rootdir);
 
-	return ret;
-}
-EXPORT_SYMBOL_GPL(clk_get_phase);
+	inited = 1;
+	mutex_unlock(&clk_debug_lock);
 
-/**
- * clk_get_phase - return the phase shift of a clock signal
- * @clk: clock signal source
- *
- * Returns the phase shift of a clock node in degrees, otherwise returns
- * -EERROR.
- */
-int clk_get_phase(struct clk *clk)
+	return 0;
+}
+late_initcall(clk_debug_init);
+#else
+static inline int clk_debug_register(struct clk_core *core) { return 0; }
+static inline void clk_debug_reparent(struct clk_core *core,
+				      struct clk_core *new_parent)
 {
-	if (!clk)
-		return 0;
-
-	return clk_core_get_phase(clk->core);
 }
-
-/**
- * clk_is_match - check if two clk's point to the same hardware clock
- * @p: clk compared against q
- * @q: clk compared against p
- *
- * Returns true if the two struct clk pointers both point to the same hardware
- * clock node. Put differently, returns true if struct clk *p and struct clk *q
- * share the same struct clk_core object.
- *
- * Returns false otherwise. Note that two NULL clks are treated as matching.
- */
-bool clk_is_match(const struct clk *p, const struct clk *q)
+static inline void clk_debug_unregister(struct clk_core *core)
 {
-	/* trivial case: identical struct clk's or both NULL */
-	if (p == q)
-		return true;
-
-	/* true if clk->core pointers match. Avoid derefing garbage */
-	if (!IS_ERR_OR_NULL(p) && !IS_ERR_OR_NULL(q))
-		if (p->core == q->core)
-			return true;
-
-	return false;
 }
-EXPORT_SYMBOL_GPL(clk_is_match);
+#endif
 
 /**
  * __clk_init - initialize the data structures in a struct clk

commit 1f3e1983429d31ceada9a09197d79445c92a2901
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 30 14:21:56 2015 -0700

    clk: Remove impossible if condition in clk_core_get_phase()
    
    This condition can't ever be true because this function is static
    and it's always called with a non-NULL pointer.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8d36100c00ce..3e58b7453076 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2182,16 +2182,12 @@ EXPORT_SYMBOL_GPL(clk_set_phase);
 
 static int clk_core_get_phase(struct clk_core *core)
 {
-	int ret = 0;
-
-	if (!core)
-		goto out;
+	int ret;
 
 	clk_prepare_lock();
 	ret = core->phase;
 	clk_prepare_unlock();
 
-out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_get_phase);

commit d7d131512b474c902b83a314d69a012e70c55431
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 30 14:04:53 2015 -0700

    clk: Drop unnecessary OOM prints
    
    We don't need to print error messages when allocations fail.
    We'll get a nice backtrace in such situations anyway.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 88439af5d032..8d36100c00ce 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2476,14 +2476,12 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 	core = kzalloc(sizeof(*core), GFP_KERNEL);
 	if (!core) {
-		pr_err("%s: could not allocate clk\n", __func__);
 		ret = -ENOMEM;
 		goto fail_out;
 	}
 
 	core->name = kstrdup_const(hw->init->name, GFP_KERNEL);
 	if (!core->name) {
-		pr_err("%s: could not allocate clk->name\n", __func__);
 		ret = -ENOMEM;
 		goto fail_name;
 	}
@@ -2500,7 +2498,6 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 					GFP_KERNEL);
 
 	if (!core->parent_names) {
-		pr_err("%s: could not allocate clk->parent_names\n", __func__);
 		ret = -ENOMEM;
 		goto fail_parent_names;
 	}
@@ -2511,7 +2508,6 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		core->parent_names[i] = kstrdup_const(hw->init->parent_names[i],
 						GFP_KERNEL);
 		if (!core->parent_names[i]) {
-			pr_err("%s: could not copy parent_names\n", __func__);
 			ret = -ENOMEM;
 			goto fail_parent_names_copy;
 		}
@@ -2521,7 +2517,6 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 	hw->clk = __clk_create_clk(hw, NULL, NULL);
 	if (IS_ERR(hw->clk)) {
-		pr_err("%s: could not allocate per-user clk\n", __func__);
 		ret = PTR_ERR(hw->clk);
 		goto fail_parent_names_copy;
 	}

commit 864e160ae510f5223e7bd9aa4335d7e092173446
Author: Dong Aisheng <aisheng.dong@freescale.com>
Date:   Thu Apr 30 14:02:19 2015 -0700

    clk: Squash __clk_{enable,disable}() into callers
    
    These functions are only used in one place. Let's squash them
    into their respective callers to save some lines.
    
    Signed-off-by: Dong Aisheng <aisheng.dong@freescale.com>
    [sboyd@codeaurora.org: Redo commit text, add NULL check in
    clk_enable()]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0b3c914db1ca..88439af5d032 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1023,14 +1023,6 @@ static void clk_core_disable(struct clk_core *core)
 	clk_core_disable(core->parent);
 }
 
-static void __clk_disable(struct clk *clk)
-{
-	if (!clk)
-		return;
-
-	clk_core_disable(clk->core);
-}
-
 /**
  * clk_disable - gate a clock
  * @clk: the clk being gated
@@ -1051,7 +1043,7 @@ void clk_disable(struct clk *clk)
 		return;
 
 	flags = clk_enable_lock();
-	__clk_disable(clk);
+	clk_core_disable(clk->core);
 	clk_enable_unlock(flags);
 }
 EXPORT_SYMBOL_GPL(clk_disable);
@@ -1089,14 +1081,6 @@ static int clk_core_enable(struct clk_core *core)
 	return 0;
 }
 
-static int __clk_enable(struct clk *clk)
-{
-	if (!clk)
-		return 0;
-
-	return clk_core_enable(clk->core);
-}
-
 /**
  * clk_enable - ungate a clock
  * @clk: the clk being ungated
@@ -1115,8 +1099,11 @@ int clk_enable(struct clk *clk)
 	unsigned long flags;
 	int ret;
 
+	if (!clk)
+		return 0;
+
 	flags = clk_enable_lock();
-	ret = __clk_enable(clk);
+	ret = clk_core_enable(clk->core);
 	clk_enable_unlock(flags);
 
 	return ret;

commit d6968fca789700afd723347d9d583795b19224b8
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 30 13:54:13 2015 -0700

    clk: s/clk/core/ for struct clk_core
    
    While introducing struct clk_core we tried to minimize the diff
    by changing the type of 'clk' variables from struct clk to struct
    clk_core without changing the names of the variables. Now that
    the split is complete, the code is slightly confusing when it
    mixes variables called 'clk' and variables called 'core' that are
    of the same type struct clk_core. Let's be consistent and use
    'core' everywhere we have a struct clk_core pointer and 'clk'
    when we have a struct clk pointer.
    
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 459ce9da13e0..0b3c914db1ca 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -37,11 +37,11 @@ static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
 
-static long clk_core_get_accuracy(struct clk_core *clk);
-static unsigned long clk_core_get_rate(struct clk_core *clk);
-static int clk_core_get_phase(struct clk_core *clk);
-static bool clk_core_is_prepared(struct clk_core *clk);
-static bool clk_core_is_enabled(struct clk_core *clk);
+static long clk_core_get_accuracy(struct clk_core *core);
+static unsigned long clk_core_get_rate(struct clk_core *core);
+static int clk_core_get_phase(struct clk_core *core);
+static bool clk_core_is_prepared(struct clk_core *core);
+static bool clk_core_is_enabled(struct clk_core *core);
 static struct clk_core *clk_core_lookup(const char *name);
 
 /***    private data structures    ***/
@@ -293,59 +293,59 @@ static const struct file_operations clk_dump_fops = {
 	.release	= single_release,
 };
 
-static int clk_debug_create_one(struct clk_core *clk, struct dentry *pdentry)
+static int clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)
 {
 	struct dentry *d;
 	int ret = -ENOMEM;
 
-	if (!clk || !pdentry) {
+	if (!core || !pdentry) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	d = debugfs_create_dir(clk->name, pdentry);
+	d = debugfs_create_dir(core->name, pdentry);
 	if (!d)
 		goto out;
 
-	clk->dentry = d;
+	core->dentry = d;
 
-	d = debugfs_create_u32("clk_rate", S_IRUGO, clk->dentry,
-			(u32 *)&clk->rate);
+	d = debugfs_create_u32("clk_rate", S_IRUGO, core->dentry,
+			(u32 *)&core->rate);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_accuracy", S_IRUGO, clk->dentry,
-			(u32 *)&clk->accuracy);
+	d = debugfs_create_u32("clk_accuracy", S_IRUGO, core->dentry,
+			(u32 *)&core->accuracy);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_phase", S_IRUGO, clk->dentry,
-			(u32 *)&clk->phase);
+	d = debugfs_create_u32("clk_phase", S_IRUGO, core->dentry,
+			(u32 *)&core->phase);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_x32("clk_flags", S_IRUGO, clk->dentry,
-			(u32 *)&clk->flags);
+	d = debugfs_create_x32("clk_flags", S_IRUGO, core->dentry,
+			(u32 *)&core->flags);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_prepare_count", S_IRUGO, clk->dentry,
-			(u32 *)&clk->prepare_count);
+	d = debugfs_create_u32("clk_prepare_count", S_IRUGO, core->dentry,
+			(u32 *)&core->prepare_count);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_enable_count", S_IRUGO, clk->dentry,
-			(u32 *)&clk->enable_count);
+	d = debugfs_create_u32("clk_enable_count", S_IRUGO, core->dentry,
+			(u32 *)&core->enable_count);
 	if (!d)
 		goto err_out;
 
-	d = debugfs_create_u32("clk_notifier_count", S_IRUGO, clk->dentry,
-			(u32 *)&clk->notifier_count);
+	d = debugfs_create_u32("clk_notifier_count", S_IRUGO, core->dentry,
+			(u32 *)&core->notifier_count);
 	if (!d)
 		goto err_out;
 
-	if (clk->ops->debug_init) {
-		ret = clk->ops->debug_init(clk->hw, clk->dentry);
+	if (core->ops->debug_init) {
+		ret = core->ops->debug_init(core->hw, core->dentry);
 		if (ret)
 			goto err_out;
 	}
@@ -354,31 +354,31 @@ static int clk_debug_create_one(struct clk_core *clk, struct dentry *pdentry)
 	goto out;
 
 err_out:
-	debugfs_remove_recursive(clk->dentry);
-	clk->dentry = NULL;
+	debugfs_remove_recursive(core->dentry);
+	core->dentry = NULL;
 out:
 	return ret;
 }
 
 /**
  * clk_debug_register - add a clk node to the debugfs clk tree
- * @clk: the clk being added to the debugfs clk tree
+ * @core: the clk being added to the debugfs clk tree
  *
  * Dynamically adds a clk to the debugfs clk tree if debugfs has been
  * initialized.  Otherwise it bails out early since the debugfs clk tree
  * will be created lazily by clk_debug_init as part of a late_initcall.
  */
-static int clk_debug_register(struct clk_core *clk)
+static int clk_debug_register(struct clk_core *core)
 {
 	int ret = 0;
 
 	mutex_lock(&clk_debug_lock);
-	hlist_add_head(&clk->debug_node, &clk_debug_list);
+	hlist_add_head(&core->debug_node, &clk_debug_list);
 
 	if (!inited)
 		goto unlock;
 
-	ret = clk_debug_create_one(clk, rootdir);
+	ret = clk_debug_create_one(core, rootdir);
 unlock:
 	mutex_unlock(&clk_debug_lock);
 
@@ -387,18 +387,18 @@ static int clk_debug_register(struct clk_core *clk)
 
  /**
  * clk_debug_unregister - remove a clk node from the debugfs clk tree
- * @clk: the clk being removed from the debugfs clk tree
+ * @core: the clk being removed from the debugfs clk tree
  *
  * Dynamically removes a clk and all it's children clk nodes from the
  * debugfs clk tree if clk->dentry points to debugfs created by
  * clk_debug_register in __clk_init.
  */
-static void clk_debug_unregister(struct clk_core *clk)
+static void clk_debug_unregister(struct clk_core *core)
 {
 	mutex_lock(&clk_debug_lock);
-	hlist_del_init(&clk->debug_node);
-	debugfs_remove_recursive(clk->dentry);
-	clk->dentry = NULL;
+	hlist_del_init(&core->debug_node);
+	debugfs_remove_recursive(core->dentry);
+	core->dentry = NULL;
 	mutex_unlock(&clk_debug_lock);
 }
 
@@ -429,7 +429,7 @@ EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
  */
 static int __init clk_debug_init(void)
 {
-	struct clk_core *clk;
+	struct clk_core *core;
 	struct dentry *d;
 
 	rootdir = debugfs_create_dir("clk", NULL);
@@ -458,8 +458,8 @@ static int __init clk_debug_init(void)
 		return -ENOMEM;
 
 	mutex_lock(&clk_debug_lock);
-	hlist_for_each_entry(clk, &clk_debug_list, debug_node)
-		clk_debug_create_one(clk, rootdir);
+	hlist_for_each_entry(core, &clk_debug_list, debug_node)
+		clk_debug_create_one(core, rootdir);
 
 	inited = 1;
 	mutex_unlock(&clk_debug_lock);
@@ -468,59 +468,59 @@ static int __init clk_debug_init(void)
 }
 late_initcall(clk_debug_init);
 #else
-static inline int clk_debug_register(struct clk_core *clk) { return 0; }
-static inline void clk_debug_reparent(struct clk_core *clk,
+static inline int clk_debug_register(struct clk_core *core) { return 0; }
+static inline void clk_debug_reparent(struct clk_core *core,
 				      struct clk_core *new_parent)
 {
 }
-static inline void clk_debug_unregister(struct clk_core *clk)
+static inline void clk_debug_unregister(struct clk_core *core)
 {
 }
 #endif
 
 /* caller must hold prepare_lock */
-static void clk_unprepare_unused_subtree(struct clk_core *clk)
+static void clk_unprepare_unused_subtree(struct clk_core *core)
 {
 	struct clk_core *child;
 
 	lockdep_assert_held(&prepare_lock);
 
-	hlist_for_each_entry(child, &clk->children, child_node)
+	hlist_for_each_entry(child, &core->children, child_node)
 		clk_unprepare_unused_subtree(child);
 
-	if (clk->prepare_count)
+	if (core->prepare_count)
 		return;
 
-	if (clk->flags & CLK_IGNORE_UNUSED)
+	if (core->flags & CLK_IGNORE_UNUSED)
 		return;
 
-	if (clk_core_is_prepared(clk)) {
-		trace_clk_unprepare(clk);
-		if (clk->ops->unprepare_unused)
-			clk->ops->unprepare_unused(clk->hw);
-		else if (clk->ops->unprepare)
-			clk->ops->unprepare(clk->hw);
-		trace_clk_unprepare_complete(clk);
+	if (clk_core_is_prepared(core)) {
+		trace_clk_unprepare(core);
+		if (core->ops->unprepare_unused)
+			core->ops->unprepare_unused(core->hw);
+		else if (core->ops->unprepare)
+			core->ops->unprepare(core->hw);
+		trace_clk_unprepare_complete(core);
 	}
 }
 
 /* caller must hold prepare_lock */
-static void clk_disable_unused_subtree(struct clk_core *clk)
+static void clk_disable_unused_subtree(struct clk_core *core)
 {
 	struct clk_core *child;
 	unsigned long flags;
 
 	lockdep_assert_held(&prepare_lock);
 
-	hlist_for_each_entry(child, &clk->children, child_node)
+	hlist_for_each_entry(child, &core->children, child_node)
 		clk_disable_unused_subtree(child);
 
 	flags = clk_enable_lock();
 
-	if (clk->enable_count)
+	if (core->enable_count)
 		goto unlock_out;
 
-	if (clk->flags & CLK_IGNORE_UNUSED)
+	if (core->flags & CLK_IGNORE_UNUSED)
 		goto unlock_out;
 
 	/*
@@ -528,13 +528,13 @@ static void clk_disable_unused_subtree(struct clk_core *clk)
 	 * sequence.  call .disable_unused if available, otherwise fall
 	 * back to .disable
 	 */
-	if (clk_core_is_enabled(clk)) {
-		trace_clk_disable(clk);
-		if (clk->ops->disable_unused)
-			clk->ops->disable_unused(clk->hw);
-		else if (clk->ops->disable)
-			clk->ops->disable(clk->hw);
-		trace_clk_disable_complete(clk);
+	if (clk_core_is_enabled(core)) {
+		trace_clk_disable(core);
+		if (core->ops->disable_unused)
+			core->ops->disable_unused(core->hw);
+		else if (core->ops->disable)
+			core->ops->disable(core->hw);
+		trace_clk_disable_complete(core);
 	}
 
 unlock_out:
@@ -551,7 +551,7 @@ __setup("clk_ignore_unused", clk_ignore_unused_setup);
 
 static int clk_disable_unused(void)
 {
-	struct clk_core *clk;
+	struct clk_core *core;
 
 	if (clk_ignore_unused) {
 		pr_warn("clk: Not disabling unused clocks\n");
@@ -560,17 +560,17 @@ static int clk_disable_unused(void)
 
 	clk_prepare_lock();
 
-	hlist_for_each_entry(clk, &clk_root_list, child_node)
-		clk_disable_unused_subtree(clk);
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_disable_unused_subtree(core);
 
-	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
-		clk_disable_unused_subtree(clk);
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_disable_unused_subtree(core);
 
-	hlist_for_each_entry(clk, &clk_root_list, child_node)
-		clk_unprepare_unused_subtree(clk);
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_unprepare_unused_subtree(core);
 
-	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
-		clk_unprepare_unused_subtree(clk);
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_unprepare_unused_subtree(core);
 
 	clk_prepare_unlock();
 
@@ -608,18 +608,18 @@ struct clk *__clk_get_parent(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_parent);
 
-static struct clk_core *clk_core_get_parent_by_index(struct clk_core *clk,
+static struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,
 							 u8 index)
 {
-	if (!clk || index >= clk->num_parents)
+	if (!core || index >= core->num_parents)
 		return NULL;
-	else if (!clk->parents)
-		return clk_core_lookup(clk->parent_names[index]);
-	else if (!clk->parents[index])
-		return clk->parents[index] =
-			clk_core_lookup(clk->parent_names[index]);
+	else if (!core->parents)
+		return clk_core_lookup(core->parent_names[index]);
+	else if (!core->parents[index])
+		return core->parents[index] =
+			clk_core_lookup(core->parent_names[index]);
 	else
-		return clk->parents[index];
+		return core->parents[index];
 }
 
 struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
@@ -640,21 +640,21 @@ unsigned int __clk_get_enable_count(struct clk *clk)
 	return !clk ? 0 : clk->core->enable_count;
 }
 
-static unsigned long clk_core_get_rate_nolock(struct clk_core *clk)
+static unsigned long clk_core_get_rate_nolock(struct clk_core *core)
 {
 	unsigned long ret;
 
-	if (!clk) {
+	if (!core) {
 		ret = 0;
 		goto out;
 	}
 
-	ret = clk->rate;
+	ret = core->rate;
 
-	if (clk->flags & CLK_IS_ROOT)
+	if (core->flags & CLK_IS_ROOT)
 		goto out;
 
-	if (!clk->parent)
+	if (!core->parent)
 		ret = 0;
 
 out:
@@ -670,12 +670,12 @@ unsigned long __clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_rate);
 
-static unsigned long __clk_get_accuracy(struct clk_core *clk)
+static unsigned long __clk_get_accuracy(struct clk_core *core)
 {
-	if (!clk)
+	if (!core)
 		return 0;
 
-	return clk->accuracy;
+	return core->accuracy;
 }
 
 unsigned long __clk_get_flags(struct clk *clk)
@@ -684,23 +684,23 @@ unsigned long __clk_get_flags(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_flags);
 
-static bool clk_core_is_prepared(struct clk_core *clk)
+static bool clk_core_is_prepared(struct clk_core *core)
 {
 	int ret;
 
-	if (!clk)
+	if (!core)
 		return false;
 
 	/*
 	 * .is_prepared is optional for clocks that can prepare
 	 * fall back to software usage counter if it is missing
 	 */
-	if (!clk->ops->is_prepared) {
-		ret = clk->prepare_count ? 1 : 0;
+	if (!core->ops->is_prepared) {
+		ret = core->prepare_count ? 1 : 0;
 		goto out;
 	}
 
-	ret = clk->ops->is_prepared(clk->hw);
+	ret = core->ops->is_prepared(core->hw);
 out:
 	return !!ret;
 }
@@ -713,23 +713,23 @@ bool __clk_is_prepared(struct clk *clk)
 	return clk_core_is_prepared(clk->core);
 }
 
-static bool clk_core_is_enabled(struct clk_core *clk)
+static bool clk_core_is_enabled(struct clk_core *core)
 {
 	int ret;
 
-	if (!clk)
+	if (!core)
 		return false;
 
 	/*
 	 * .is_enabled is only mandatory for clocks that gate
 	 * fall back to software usage counter if .is_enabled is missing
 	 */
-	if (!clk->ops->is_enabled) {
-		ret = clk->enable_count ? 1 : 0;
+	if (!core->ops->is_enabled) {
+		ret = core->enable_count ? 1 : 0;
 		goto out;
 	}
 
-	ret = clk->ops->is_enabled(clk->hw);
+	ret = core->ops->is_enabled(core->hw);
 out:
 	return !!ret;
 }
@@ -744,15 +744,15 @@ bool __clk_is_enabled(struct clk *clk)
 EXPORT_SYMBOL_GPL(__clk_is_enabled);
 
 static struct clk_core *__clk_lookup_subtree(const char *name,
-					     struct clk_core *clk)
+					     struct clk_core *core)
 {
 	struct clk_core *child;
 	struct clk_core *ret;
 
-	if (!strcmp(clk->name, name))
-		return clk;
+	if (!strcmp(core->name, name))
+		return core;
 
-	hlist_for_each_entry(child, &clk->children, child_node) {
+	hlist_for_each_entry(child, &core->children, child_node) {
 		ret = __clk_lookup_subtree(name, child);
 		if (ret)
 			return ret;
@@ -853,7 +853,7 @@ struct clk *__clk_lookup(const char *name)
 	return !core ? NULL : core->hw->clk;
 }
 
-static void clk_core_get_boundaries(struct clk_core *clk,
+static void clk_core_get_boundaries(struct clk_core *core,
 				    unsigned long *min_rate,
 				    unsigned long *max_rate)
 {
@@ -862,10 +862,10 @@ static void clk_core_get_boundaries(struct clk_core *clk,
 	*min_rate = 0;
 	*max_rate = ULONG_MAX;
 
-	hlist_for_each_entry(clk_user, &clk->clks, clks_node)
+	hlist_for_each_entry(clk_user, &core->clks, clks_node)
 		*min_rate = max(*min_rate, clk_user->min_rate);
 
-	hlist_for_each_entry(clk_user, &clk->clks, clks_node)
+	hlist_for_each_entry(clk_user, &core->clks, clks_node)
 		*max_rate = min(*max_rate, clk_user->max_rate);
 }
 
@@ -901,26 +901,26 @@ EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
 
 /***        clk api        ***/
 
-static void clk_core_unprepare(struct clk_core *clk)
+static void clk_core_unprepare(struct clk_core *core)
 {
-	if (!clk)
+	if (!core)
 		return;
 
-	if (WARN_ON(clk->prepare_count == 0))
+	if (WARN_ON(core->prepare_count == 0))
 		return;
 
-	if (--clk->prepare_count > 0)
+	if (--core->prepare_count > 0)
 		return;
 
-	WARN_ON(clk->enable_count > 0);
+	WARN_ON(core->enable_count > 0);
 
-	trace_clk_unprepare(clk);
+	trace_clk_unprepare(core);
 
-	if (clk->ops->unprepare)
-		clk->ops->unprepare(clk->hw);
+	if (core->ops->unprepare)
+		core->ops->unprepare(core->hw);
 
-	trace_clk_unprepare_complete(clk);
-	clk_core_unprepare(clk->parent);
+	trace_clk_unprepare_complete(core);
+	clk_core_unprepare(core->parent);
 }
 
 /**
@@ -945,32 +945,32 @@ void clk_unprepare(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_unprepare);
 
-static int clk_core_prepare(struct clk_core *clk)
+static int clk_core_prepare(struct clk_core *core)
 {
 	int ret = 0;
 
-	if (!clk)
+	if (!core)
 		return 0;
 
-	if (clk->prepare_count == 0) {
-		ret = clk_core_prepare(clk->parent);
+	if (core->prepare_count == 0) {
+		ret = clk_core_prepare(core->parent);
 		if (ret)
 			return ret;
 
-		trace_clk_prepare(clk);
+		trace_clk_prepare(core);
 
-		if (clk->ops->prepare)
-			ret = clk->ops->prepare(clk->hw);
+		if (core->ops->prepare)
+			ret = core->ops->prepare(core->hw);
 
-		trace_clk_prepare_complete(clk);
+		trace_clk_prepare_complete(core);
 
 		if (ret) {
-			clk_core_unprepare(clk->parent);
+			clk_core_unprepare(core->parent);
 			return ret;
 		}
 	}
 
-	clk->prepare_count++;
+	core->prepare_count++;
 
 	return 0;
 }
@@ -1002,25 +1002,25 @@ int clk_prepare(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_prepare);
 
-static void clk_core_disable(struct clk_core *clk)
+static void clk_core_disable(struct clk_core *core)
 {
-	if (!clk)
+	if (!core)
 		return;
 
-	if (WARN_ON(clk->enable_count == 0))
+	if (WARN_ON(core->enable_count == 0))
 		return;
 
-	if (--clk->enable_count > 0)
+	if (--core->enable_count > 0)
 		return;
 
-	trace_clk_disable(clk);
+	trace_clk_disable(core);
 
-	if (clk->ops->disable)
-		clk->ops->disable(clk->hw);
+	if (core->ops->disable)
+		core->ops->disable(core->hw);
 
-	trace_clk_disable_complete(clk);
+	trace_clk_disable_complete(core);
 
-	clk_core_disable(clk->parent);
+	clk_core_disable(core->parent);
 }
 
 static void __clk_disable(struct clk *clk)
@@ -1056,36 +1056,36 @@ void clk_disable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_disable);
 
-static int clk_core_enable(struct clk_core *clk)
+static int clk_core_enable(struct clk_core *core)
 {
 	int ret = 0;
 
-	if (!clk)
+	if (!core)
 		return 0;
 
-	if (WARN_ON(clk->prepare_count == 0))
+	if (WARN_ON(core->prepare_count == 0))
 		return -ESHUTDOWN;
 
-	if (clk->enable_count == 0) {
-		ret = clk_core_enable(clk->parent);
+	if (core->enable_count == 0) {
+		ret = clk_core_enable(core->parent);
 
 		if (ret)
 			return ret;
 
-		trace_clk_enable(clk);
+		trace_clk_enable(core);
 
-		if (clk->ops->enable)
-			ret = clk->ops->enable(clk->hw);
+		if (core->ops->enable)
+			ret = core->ops->enable(core->hw);
 
-		trace_clk_enable_complete(clk);
+		trace_clk_enable_complete(core);
 
 		if (ret) {
-			clk_core_disable(clk->parent);
+			clk_core_disable(core->parent);
 			return ret;
 		}
 	}
 
-	clk->enable_count++;
+	core->enable_count++;
 	return 0;
 }
 
@@ -1123,7 +1123,7 @@ int clk_enable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_enable);
 
-static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
+static unsigned long clk_core_round_rate_nolock(struct clk_core *core,
 						unsigned long rate,
 						unsigned long min_rate,
 						unsigned long max_rate)
@@ -1134,25 +1134,25 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
 
 	lockdep_assert_held(&prepare_lock);
 
-	if (!clk)
+	if (!core)
 		return 0;
 
-	parent = clk->parent;
+	parent = core->parent;
 	if (parent)
 		parent_rate = parent->rate;
 
-	if (clk->ops->determine_rate) {
+	if (core->ops->determine_rate) {
 		parent_hw = parent ? parent->hw : NULL;
-		return clk->ops->determine_rate(clk->hw, rate,
+		return core->ops->determine_rate(core->hw, rate,
 						min_rate, max_rate,
 						&parent_rate, &parent_hw);
-	} else if (clk->ops->round_rate)
-		return clk->ops->round_rate(clk->hw, rate, &parent_rate);
-	else if (clk->flags & CLK_SET_RATE_PARENT)
-		return clk_core_round_rate_nolock(clk->parent, rate, min_rate,
+	} else if (core->ops->round_rate)
+		return core->ops->round_rate(core->hw, rate, &parent_rate);
+	else if (core->flags & CLK_SET_RATE_PARENT)
+		return clk_core_round_rate_nolock(core->parent, rate, min_rate,
 						  max_rate);
 	else
-		return clk->rate;
+		return core->rate;
 }
 
 /**
@@ -1224,7 +1224,7 @@ EXPORT_SYMBOL_GPL(clk_round_rate);
 
 /**
  * __clk_notify - call clk notifier chain
- * @clk: struct clk * that is changing rate
+ * @core: clk that is changing rate
  * @msg: clk notifier type (see include/linux/clk.h)
  * @old_rate: old clk rate
  * @new_rate: new clk rate
@@ -1236,7 +1236,7 @@ EXPORT_SYMBOL_GPL(clk_round_rate);
  * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if
  * a driver returns that.
  */
-static int __clk_notify(struct clk_core *clk, unsigned long msg,
+static int __clk_notify(struct clk_core *core, unsigned long msg,
 		unsigned long old_rate, unsigned long new_rate)
 {
 	struct clk_notifier *cn;
@@ -1247,7 +1247,7 @@ static int __clk_notify(struct clk_core *clk, unsigned long msg,
 	cnd.new_rate = new_rate;
 
 	list_for_each_entry(cn, &clk_notifier_list, node) {
-		if (cn->clk->core == clk) {
+		if (cn->clk->core == core) {
 			cnd.clk = cn->clk;
 			ret = srcu_notifier_call_chain(&cn->notifier_head, msg,
 					&cnd);
@@ -1259,7 +1259,7 @@ static int __clk_notify(struct clk_core *clk, unsigned long msg,
 
 /**
  * __clk_recalc_accuracies
- * @clk: first clk in the subtree
+ * @core: first clk in the subtree
  *
  * Walks the subtree of clks starting with clk and recalculates accuracies as
  * it goes.  Note that if a clk does not implement the .recalc_accuracy
@@ -1268,35 +1268,35 @@ static int __clk_notify(struct clk_core *clk, unsigned long msg,
  *
  * Caller must hold prepare_lock.
  */
-static void __clk_recalc_accuracies(struct clk_core *clk)
+static void __clk_recalc_accuracies(struct clk_core *core)
 {
 	unsigned long parent_accuracy = 0;
 	struct clk_core *child;
 
 	lockdep_assert_held(&prepare_lock);
 
-	if (clk->parent)
-		parent_accuracy = clk->parent->accuracy;
+	if (core->parent)
+		parent_accuracy = core->parent->accuracy;
 
-	if (clk->ops->recalc_accuracy)
-		clk->accuracy = clk->ops->recalc_accuracy(clk->hw,
+	if (core->ops->recalc_accuracy)
+		core->accuracy = core->ops->recalc_accuracy(core->hw,
 							  parent_accuracy);
 	else
-		clk->accuracy = parent_accuracy;
+		core->accuracy = parent_accuracy;
 
-	hlist_for_each_entry(child, &clk->children, child_node)
+	hlist_for_each_entry(child, &core->children, child_node)
 		__clk_recalc_accuracies(child);
 }
 
-static long clk_core_get_accuracy(struct clk_core *clk)
+static long clk_core_get_accuracy(struct clk_core *core)
 {
 	unsigned long accuracy;
 
 	clk_prepare_lock();
-	if (clk && (clk->flags & CLK_GET_ACCURACY_NOCACHE))
-		__clk_recalc_accuracies(clk);
+	if (core && (core->flags & CLK_GET_ACCURACY_NOCACHE))
+		__clk_recalc_accuracies(core);
 
-	accuracy = __clk_get_accuracy(clk);
+	accuracy = __clk_get_accuracy(core);
 	clk_prepare_unlock();
 
 	return accuracy;
@@ -1320,17 +1320,17 @@ long clk_get_accuracy(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_accuracy);
 
-static unsigned long clk_recalc(struct clk_core *clk,
+static unsigned long clk_recalc(struct clk_core *core,
 				unsigned long parent_rate)
 {
-	if (clk->ops->recalc_rate)
-		return clk->ops->recalc_rate(clk->hw, parent_rate);
+	if (core->ops->recalc_rate)
+		return core->ops->recalc_rate(core->hw, parent_rate);
 	return parent_rate;
 }
 
 /**
  * __clk_recalc_rates
- * @clk: first clk in the subtree
+ * @core: first clk in the subtree
  * @msg: notification type (see include/linux/clk.h)
  *
  * Walks the subtree of clks starting with clk and recalculates rates as it
@@ -1342,7 +1342,7 @@ static unsigned long clk_recalc(struct clk_core *clk,
  *
  * Caller must hold prepare_lock.
  */
-static void __clk_recalc_rates(struct clk_core *clk, unsigned long msg)
+static void __clk_recalc_rates(struct clk_core *core, unsigned long msg)
 {
 	unsigned long old_rate;
 	unsigned long parent_rate = 0;
@@ -1350,34 +1350,34 @@ static void __clk_recalc_rates(struct clk_core *clk, unsigned long msg)
 
 	lockdep_assert_held(&prepare_lock);
 
-	old_rate = clk->rate;
+	old_rate = core->rate;
 
-	if (clk->parent)
-		parent_rate = clk->parent->rate;
+	if (core->parent)
+		parent_rate = core->parent->rate;
 
-	clk->rate = clk_recalc(clk, parent_rate);
+	core->rate = clk_recalc(core, parent_rate);
 
 	/*
 	 * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE
 	 * & ABORT_RATE_CHANGE notifiers
 	 */
-	if (clk->notifier_count && msg)
-		__clk_notify(clk, msg, old_rate, clk->rate);
+	if (core->notifier_count && msg)
+		__clk_notify(core, msg, old_rate, core->rate);
 
-	hlist_for_each_entry(child, &clk->children, child_node)
+	hlist_for_each_entry(child, &core->children, child_node)
 		__clk_recalc_rates(child, msg);
 }
 
-static unsigned long clk_core_get_rate(struct clk_core *clk)
+static unsigned long clk_core_get_rate(struct clk_core *core)
 {
 	unsigned long rate;
 
 	clk_prepare_lock();
 
-	if (clk && (clk->flags & CLK_GET_RATE_NOCACHE))
-		__clk_recalc_rates(clk, 0);
+	if (core && (core->flags & CLK_GET_RATE_NOCACHE))
+		__clk_recalc_rates(core, 0);
 
-	rate = clk_core_get_rate_nolock(clk);
+	rate = clk_core_get_rate_nolock(core);
 	clk_prepare_unlock();
 
 	return rate;
@@ -1400,15 +1400,15 @@ unsigned long clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_rate);
 
-static int clk_fetch_parent_index(struct clk_core *clk,
+static int clk_fetch_parent_index(struct clk_core *core,
 				  struct clk_core *parent)
 {
 	int i;
 
-	if (!clk->parents) {
-		clk->parents = kcalloc(clk->num_parents,
+	if (!core->parents) {
+		core->parents = kcalloc(core->num_parents,
 					sizeof(struct clk *), GFP_KERNEL);
-		if (!clk->parents)
+		if (!core->parents)
 			return -ENOMEM;
 	}
 
@@ -1417,15 +1417,15 @@ static int clk_fetch_parent_index(struct clk_core *clk,
 	 * or if not yet cached, use string name comparison and cache
 	 * them now to avoid future calls to clk_core_lookup.
 	 */
-	for (i = 0; i < clk->num_parents; i++) {
-		if (clk->parents[i] == parent)
+	for (i = 0; i < core->num_parents; i++) {
+		if (core->parents[i] == parent)
 			return i;
 
-		if (clk->parents[i])
+		if (core->parents[i])
 			continue;
 
-		if (!strcmp(clk->parent_names[i], parent->name)) {
-			clk->parents[i] = clk_core_lookup(parent->name);
+		if (!strcmp(core->parent_names[i], parent->name)) {
+			core->parents[i] = clk_core_lookup(parent->name);
 			return i;
 		}
 	}
@@ -1433,28 +1433,28 @@ static int clk_fetch_parent_index(struct clk_core *clk,
 	return -EINVAL;
 }
 
-static void clk_reparent(struct clk_core *clk, struct clk_core *new_parent)
+static void clk_reparent(struct clk_core *core, struct clk_core *new_parent)
 {
-	hlist_del(&clk->child_node);
+	hlist_del(&core->child_node);
 
 	if (new_parent) {
 		/* avoid duplicate POST_RATE_CHANGE notifications */
-		if (new_parent->new_child == clk)
+		if (new_parent->new_child == core)
 			new_parent->new_child = NULL;
 
-		hlist_add_head(&clk->child_node, &new_parent->children);
+		hlist_add_head(&core->child_node, &new_parent->children);
 	} else {
-		hlist_add_head(&clk->child_node, &clk_orphan_list);
+		hlist_add_head(&core->child_node, &clk_orphan_list);
 	}
 
-	clk->parent = new_parent;
+	core->parent = new_parent;
 }
 
-static struct clk_core *__clk_set_parent_before(struct clk_core *clk,
+static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 					   struct clk_core *parent)
 {
 	unsigned long flags;
-	struct clk_core *old_parent = clk->parent;
+	struct clk_core *old_parent = core->parent;
 
 	/*
 	 * Migrate prepare state between parents and prevent race with
@@ -1473,15 +1473,15 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *clk,
 	 *
 	 * See also: Comment for clk_set_parent() below.
 	 */
-	if (clk->prepare_count) {
+	if (core->prepare_count) {
 		clk_core_prepare(parent);
 		clk_core_enable(parent);
-		clk_core_enable(clk);
+		clk_core_enable(core);
 	}
 
 	/* update the clk tree topology */
 	flags = clk_enable_lock();
-	clk_reparent(clk, parent);
+	clk_reparent(core, parent);
 	clk_enable_unlock(flags);
 
 	return old_parent;
@@ -1502,44 +1502,44 @@ static void __clk_set_parent_after(struct clk_core *core,
 	}
 }
 
-static int __clk_set_parent(struct clk_core *clk, struct clk_core *parent,
+static int __clk_set_parent(struct clk_core *core, struct clk_core *parent,
 			    u8 p_index)
 {
 	unsigned long flags;
 	int ret = 0;
 	struct clk_core *old_parent;
 
-	old_parent = __clk_set_parent_before(clk, parent);
+	old_parent = __clk_set_parent_before(core, parent);
 
-	trace_clk_set_parent(clk, parent);
+	trace_clk_set_parent(core, parent);
 
 	/* change clock input source */
-	if (parent && clk->ops->set_parent)
-		ret = clk->ops->set_parent(clk->hw, p_index);
+	if (parent && core->ops->set_parent)
+		ret = core->ops->set_parent(core->hw, p_index);
 
-	trace_clk_set_parent_complete(clk, parent);
+	trace_clk_set_parent_complete(core, parent);
 
 	if (ret) {
 		flags = clk_enable_lock();
-		clk_reparent(clk, old_parent);
+		clk_reparent(core, old_parent);
 		clk_enable_unlock(flags);
 
-		if (clk->prepare_count) {
-			clk_core_disable(clk);
+		if (core->prepare_count) {
+			clk_core_disable(core);
 			clk_core_disable(parent);
 			clk_core_unprepare(parent);
 		}
 		return ret;
 	}
 
-	__clk_set_parent_after(clk, parent, old_parent);
+	__clk_set_parent_after(core, parent, old_parent);
 
 	return 0;
 }
 
 /**
  * __clk_speculate_rates
- * @clk: first clk in the subtree
+ * @core: first clk in the subtree
  * @parent_rate: the "future" rate of clk's parent
  *
  * Walks the subtree of clks starting with clk, speculating rates as it
@@ -1553,7 +1553,7 @@ static int __clk_set_parent(struct clk_core *clk, struct clk_core *parent,
  *
  * Caller must hold prepare_lock.
  */
-static int __clk_speculate_rates(struct clk_core *clk,
+static int __clk_speculate_rates(struct clk_core *core,
 				 unsigned long parent_rate)
 {
 	struct clk_core *child;
@@ -1562,19 +1562,19 @@ static int __clk_speculate_rates(struct clk_core *clk,
 
 	lockdep_assert_held(&prepare_lock);
 
-	new_rate = clk_recalc(clk, parent_rate);
+	new_rate = clk_recalc(core, parent_rate);
 
 	/* abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */
-	if (clk->notifier_count)
-		ret = __clk_notify(clk, PRE_RATE_CHANGE, clk->rate, new_rate);
+	if (core->notifier_count)
+		ret = __clk_notify(core, PRE_RATE_CHANGE, core->rate, new_rate);
 
 	if (ret & NOTIFY_STOP_MASK) {
 		pr_debug("%s: clk notifier callback for clock %s aborted with error %d\n",
-				__func__, clk->name, ret);
+				__func__, core->name, ret);
 		goto out;
 	}
 
-	hlist_for_each_entry(child, &clk->children, child_node) {
+	hlist_for_each_entry(child, &core->children, child_node) {
 		ret = __clk_speculate_rates(child, new_rate);
 		if (ret & NOTIFY_STOP_MASK)
 			break;
@@ -1584,20 +1584,20 @@ static int __clk_speculate_rates(struct clk_core *clk,
 	return ret;
 }
 
-static void clk_calc_subtree(struct clk_core *clk, unsigned long new_rate,
+static void clk_calc_subtree(struct clk_core *core, unsigned long new_rate,
 			     struct clk_core *new_parent, u8 p_index)
 {
 	struct clk_core *child;
 
-	clk->new_rate = new_rate;
-	clk->new_parent = new_parent;
-	clk->new_parent_index = p_index;
+	core->new_rate = new_rate;
+	core->new_parent = new_parent;
+	core->new_parent_index = p_index;
 	/* include clk in new parent's PRE_RATE_CHANGE notifications */
-	clk->new_child = NULL;
-	if (new_parent && new_parent != clk->parent)
-		new_parent->new_child = clk;
+	core->new_child = NULL;
+	if (new_parent && new_parent != core->parent)
+		new_parent->new_child = core;
 
-	hlist_for_each_entry(child, &clk->children, child_node) {
+	hlist_for_each_entry(child, &core->children, child_node) {
 		child->new_rate = clk_recalc(child, new_rate);
 		clk_calc_subtree(child, child->new_rate, NULL, 0);
 	}
@@ -1607,10 +1607,10 @@ static void clk_calc_subtree(struct clk_core *clk, unsigned long new_rate,
  * calculate the new rates returning the topmost clock that has to be
  * changed.
  */
-static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
+static struct clk_core *clk_calc_new_rates(struct clk_core *core,
 					   unsigned long rate)
 {
-	struct clk_core *top = clk;
+	struct clk_core *top = core;
 	struct clk_core *old_parent, *parent;
 	struct clk_hw *parent_hw;
 	unsigned long best_parent_rate = 0;
@@ -1621,20 +1621,20 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 	long ret;
 
 	/* sanity */
-	if (IS_ERR_OR_NULL(clk))
+	if (IS_ERR_OR_NULL(core))
 		return NULL;
 
 	/* save parent rate, if it exists */
-	parent = old_parent = clk->parent;
+	parent = old_parent = core->parent;
 	if (parent)
 		best_parent_rate = parent->rate;
 
-	clk_core_get_boundaries(clk, &min_rate, &max_rate);
+	clk_core_get_boundaries(core, &min_rate, &max_rate);
 
 	/* find the closest rate and parent clk/rate */
-	if (clk->ops->determine_rate) {
+	if (core->ops->determine_rate) {
 		parent_hw = parent ? parent->hw : NULL;
-		ret = clk->ops->determine_rate(clk->hw, rate,
+		ret = core->ops->determine_rate(core->hw, rate,
 					       min_rate,
 					       max_rate,
 					       &best_parent_rate,
@@ -1644,8 +1644,8 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 
 		new_rate = ret;
 		parent = parent_hw ? parent_hw->core : NULL;
-	} else if (clk->ops->round_rate) {
-		ret = clk->ops->round_rate(clk->hw, rate,
+	} else if (core->ops->round_rate) {
+		ret = core->ops->round_rate(core->hw, rate,
 					   &best_parent_rate);
 		if (ret < 0)
 			return NULL;
@@ -1653,9 +1653,9 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 		new_rate = ret;
 		if (new_rate < min_rate || new_rate > max_rate)
 			return NULL;
-	} else if (!parent || !(clk->flags & CLK_SET_RATE_PARENT)) {
+	} else if (!parent || !(core->flags & CLK_SET_RATE_PARENT)) {
 		/* pass-through clock without adjustable parent */
-		clk->new_rate = clk->rate;
+		core->new_rate = core->rate;
 		return NULL;
 	} else {
 		/* pass-through clock with adjustable parent */
@@ -1666,28 +1666,28 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 
 	/* some clocks must be gated to change parent */
 	if (parent != old_parent &&
-	    (clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count) {
+	    (core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {
 		pr_debug("%s: %s not gated but wants to reparent\n",
-			 __func__, clk->name);
+			 __func__, core->name);
 		return NULL;
 	}
 
 	/* try finding the new parent index */
-	if (parent && clk->num_parents > 1) {
-		p_index = clk_fetch_parent_index(clk, parent);
+	if (parent && core->num_parents > 1) {
+		p_index = clk_fetch_parent_index(core, parent);
 		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",
-				 __func__, parent->name, clk->name);
+				 __func__, parent->name, core->name);
 			return NULL;
 		}
 	}
 
-	if ((clk->flags & CLK_SET_RATE_PARENT) && parent &&
+	if ((core->flags & CLK_SET_RATE_PARENT) && parent &&
 	    best_parent_rate != parent->rate)
 		top = clk_calc_new_rates(parent, best_parent_rate);
 
 out:
-	clk_calc_subtree(clk, new_rate, parent, p_index);
+	clk_calc_subtree(core, new_rate, parent, p_index);
 
 	return top;
 }
@@ -1697,33 +1697,33 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
  * so that in case of an error we can walk down the whole tree again and
  * abort the change.
  */
-static struct clk_core *clk_propagate_rate_change(struct clk_core *clk,
+static struct clk_core *clk_propagate_rate_change(struct clk_core *core,
 						  unsigned long event)
 {
 	struct clk_core *child, *tmp_clk, *fail_clk = NULL;
 	int ret = NOTIFY_DONE;
 
-	if (clk->rate == clk->new_rate)
+	if (core->rate == core->new_rate)
 		return NULL;
 
-	if (clk->notifier_count) {
-		ret = __clk_notify(clk, event, clk->rate, clk->new_rate);
+	if (core->notifier_count) {
+		ret = __clk_notify(core, event, core->rate, core->new_rate);
 		if (ret & NOTIFY_STOP_MASK)
-			fail_clk = clk;
+			fail_clk = core;
 	}
 
-	hlist_for_each_entry(child, &clk->children, child_node) {
+	hlist_for_each_entry(child, &core->children, child_node) {
 		/* Skip children who will be reparented to another clock */
-		if (child->new_parent && child->new_parent != clk)
+		if (child->new_parent && child->new_parent != core)
 			continue;
 		tmp_clk = clk_propagate_rate_change(child, event);
 		if (tmp_clk)
 			fail_clk = tmp_clk;
 	}
 
-	/* handle the new child who might not be in clk->children yet */
-	if (clk->new_child) {
-		tmp_clk = clk_propagate_rate_change(clk->new_child, event);
+	/* handle the new child who might not be in core->children yet */
+	if (core->new_child) {
+		tmp_clk = clk_propagate_rate_change(core->new_child, event);
 		if (tmp_clk)
 			fail_clk = tmp_clk;
 	}
@@ -1735,7 +1735,7 @@ static struct clk_core *clk_propagate_rate_change(struct clk_core *clk,
  * walk down a subtree and set the new rates notifying the rate
  * change on the way
  */
-static void clk_change_rate(struct clk_core *clk)
+static void clk_change_rate(struct clk_core *core)
 {
 	struct clk_core *child;
 	struct hlist_node *tmp;
@@ -1744,77 +1744,77 @@ static void clk_change_rate(struct clk_core *clk)
 	bool skip_set_rate = false;
 	struct clk_core *old_parent;
 
-	old_rate = clk->rate;
+	old_rate = core->rate;
 
-	if (clk->new_parent)
-		best_parent_rate = clk->new_parent->rate;
-	else if (clk->parent)
-		best_parent_rate = clk->parent->rate;
+	if (core->new_parent)
+		best_parent_rate = core->new_parent->rate;
+	else if (core->parent)
+		best_parent_rate = core->parent->rate;
 
-	if (clk->new_parent && clk->new_parent != clk->parent) {
-		old_parent = __clk_set_parent_before(clk, clk->new_parent);
-		trace_clk_set_parent(clk, clk->new_parent);
+	if (core->new_parent && core->new_parent != core->parent) {
+		old_parent = __clk_set_parent_before(core, core->new_parent);
+		trace_clk_set_parent(core, core->new_parent);
 
-		if (clk->ops->set_rate_and_parent) {
+		if (core->ops->set_rate_and_parent) {
 			skip_set_rate = true;
-			clk->ops->set_rate_and_parent(clk->hw, clk->new_rate,
+			core->ops->set_rate_and_parent(core->hw, core->new_rate,
 					best_parent_rate,
-					clk->new_parent_index);
-		} else if (clk->ops->set_parent) {
-			clk->ops->set_parent(clk->hw, clk->new_parent_index);
+					core->new_parent_index);
+		} else if (core->ops->set_parent) {
+			core->ops->set_parent(core->hw, core->new_parent_index);
 		}
 
-		trace_clk_set_parent_complete(clk, clk->new_parent);
-		__clk_set_parent_after(clk, clk->new_parent, old_parent);
+		trace_clk_set_parent_complete(core, core->new_parent);
+		__clk_set_parent_after(core, core->new_parent, old_parent);
 	}
 
-	trace_clk_set_rate(clk, clk->new_rate);
+	trace_clk_set_rate(core, core->new_rate);
 
-	if (!skip_set_rate && clk->ops->set_rate)
-		clk->ops->set_rate(clk->hw, clk->new_rate, best_parent_rate);
+	if (!skip_set_rate && core->ops->set_rate)
+		core->ops->set_rate(core->hw, core->new_rate, best_parent_rate);
 
-	trace_clk_set_rate_complete(clk, clk->new_rate);
+	trace_clk_set_rate_complete(core, core->new_rate);
 
-	clk->rate = clk_recalc(clk, best_parent_rate);
+	core->rate = clk_recalc(core, best_parent_rate);
 
-	if (clk->notifier_count && old_rate != clk->rate)
-		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
+	if (core->notifier_count && old_rate != core->rate)
+		__clk_notify(core, POST_RATE_CHANGE, old_rate, core->rate);
 
 	/*
 	 * Use safe iteration, as change_rate can actually swap parents
 	 * for certain clock types.
 	 */
-	hlist_for_each_entry_safe(child, tmp, &clk->children, child_node) {
+	hlist_for_each_entry_safe(child, tmp, &core->children, child_node) {
 		/* Skip children who will be reparented to another clock */
-		if (child->new_parent && child->new_parent != clk)
+		if (child->new_parent && child->new_parent != core)
 			continue;
 		clk_change_rate(child);
 	}
 
-	/* handle the new child who might not be in clk->children yet */
-	if (clk->new_child)
-		clk_change_rate(clk->new_child);
+	/* handle the new child who might not be in core->children yet */
+	if (core->new_child)
+		clk_change_rate(core->new_child);
 }
 
-static int clk_core_set_rate_nolock(struct clk_core *clk,
+static int clk_core_set_rate_nolock(struct clk_core *core,
 				    unsigned long req_rate)
 {
 	struct clk_core *top, *fail_clk;
 	unsigned long rate = req_rate;
 	int ret = 0;
 
-	if (!clk)
+	if (!core)
 		return 0;
 
 	/* bail early if nothing to do */
-	if (rate == clk_core_get_rate_nolock(clk))
+	if (rate == clk_core_get_rate_nolock(core))
 		return 0;
 
-	if ((clk->flags & CLK_SET_RATE_GATE) && clk->prepare_count)
+	if ((core->flags & CLK_SET_RATE_GATE) && core->prepare_count)
 		return -EBUSY;
 
 	/* calculate new rates and get the topmost changed clock */
-	top = clk_calc_new_rates(clk, rate);
+	top = clk_calc_new_rates(core, rate);
 	if (!top)
 		return -EINVAL;
 
@@ -1830,7 +1830,7 @@ static int clk_core_set_rate_nolock(struct clk_core *clk,
 	/* change the rates */
 	clk_change_rate(top);
 
-	clk->req_rate = req_rate;
+	core->req_rate = req_rate;
 
 	return ret;
 }
@@ -1969,55 +1969,55 @@ EXPORT_SYMBOL_GPL(clk_get_parent);
  * .parents array exists, and if so use it to avoid an expensive tree
  * traversal.  If .parents does not exist then walk the tree.
  */
-static struct clk_core *__clk_init_parent(struct clk_core *clk)
+static struct clk_core *__clk_init_parent(struct clk_core *core)
 {
 	struct clk_core *ret = NULL;
 	u8 index;
 
 	/* handle the trivial cases */
 
-	if (!clk->num_parents)
+	if (!core->num_parents)
 		goto out;
 
-	if (clk->num_parents == 1) {
-		if (IS_ERR_OR_NULL(clk->parent))
-			clk->parent = clk_core_lookup(clk->parent_names[0]);
-		ret = clk->parent;
+	if (core->num_parents == 1) {
+		if (IS_ERR_OR_NULL(core->parent))
+			core->parent = clk_core_lookup(core->parent_names[0]);
+		ret = core->parent;
 		goto out;
 	}
 
-	if (!clk->ops->get_parent) {
-		WARN(!clk->ops->get_parent,
+	if (!core->ops->get_parent) {
+		WARN(!core->ops->get_parent,
 			"%s: multi-parent clocks must implement .get_parent\n",
 			__func__);
 		goto out;
 	};
 
 	/*
-	 * Do our best to cache parent clocks in clk->parents.  This prevents
-	 * unnecessary and expensive lookups.  We don't set clk->parent here;
+	 * Do our best to cache parent clocks in core->parents.  This prevents
+	 * unnecessary and expensive lookups.  We don't set core->parent here;
 	 * that is done by the calling function.
 	 */
 
-	index = clk->ops->get_parent(clk->hw);
+	index = core->ops->get_parent(core->hw);
 
-	if (!clk->parents)
-		clk->parents =
-			kcalloc(clk->num_parents, sizeof(struct clk *),
+	if (!core->parents)
+		core->parents =
+			kcalloc(core->num_parents, sizeof(struct clk *),
 					GFP_KERNEL);
 
-	ret = clk_core_get_parent_by_index(clk, index);
+	ret = clk_core_get_parent_by_index(core, index);
 
 out:
 	return ret;
 }
 
-static void clk_core_reparent(struct clk_core *clk,
+static void clk_core_reparent(struct clk_core *core,
 				  struct clk_core *new_parent)
 {
-	clk_reparent(clk, new_parent);
-	__clk_recalc_accuracies(clk);
-	__clk_recalc_rates(clk, POST_RATE_CHANGE);
+	clk_reparent(core, new_parent);
+	__clk_recalc_accuracies(core);
+	__clk_recalc_rates(core, POST_RATE_CHANGE);
 }
 
 /**
@@ -2054,61 +2054,61 @@ bool clk_has_parent(struct clk *clk, struct clk *parent)
 }
 EXPORT_SYMBOL_GPL(clk_has_parent);
 
-static int clk_core_set_parent(struct clk_core *clk, struct clk_core *parent)
+static int clk_core_set_parent(struct clk_core *core, struct clk_core *parent)
 {
 	int ret = 0;
 	int p_index = 0;
 	unsigned long p_rate = 0;
 
-	if (!clk)
+	if (!core)
 		return 0;
 
 	/* prevent racing with updates to the clock topology */
 	clk_prepare_lock();
 
-	if (clk->parent == parent)
+	if (core->parent == parent)
 		goto out;
 
 	/* verify ops for for multi-parent clks */
-	if ((clk->num_parents > 1) && (!clk->ops->set_parent)) {
+	if ((core->num_parents > 1) && (!core->ops->set_parent)) {
 		ret = -ENOSYS;
 		goto out;
 	}
 
 	/* check that we are allowed to re-parent if the clock is in use */
-	if ((clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count) {
+	if ((core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {
 		ret = -EBUSY;
 		goto out;
 	}
 
 	/* try finding the new parent index */
 	if (parent) {
-		p_index = clk_fetch_parent_index(clk, parent);
+		p_index = clk_fetch_parent_index(core, parent);
 		p_rate = parent->rate;
 		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",
-					__func__, parent->name, clk->name);
+					__func__, parent->name, core->name);
 			ret = p_index;
 			goto out;
 		}
 	}
 
 	/* propagate PRE_RATE_CHANGE notifications */
-	ret = __clk_speculate_rates(clk, p_rate);
+	ret = __clk_speculate_rates(core, p_rate);
 
 	/* abort if a driver objects */
 	if (ret & NOTIFY_STOP_MASK)
 		goto out;
 
 	/* do the re-parent */
-	ret = __clk_set_parent(clk, parent, p_index);
+	ret = __clk_set_parent(core, parent, p_index);
 
 	/* propagate rate an accuracy recalculation accordingly */
 	if (ret) {
-		__clk_recalc_rates(clk, ABORT_RATE_CHANGE);
+		__clk_recalc_rates(core, ABORT_RATE_CHANGE);
 	} else {
-		__clk_recalc_rates(clk, POST_RATE_CHANGE);
-		__clk_recalc_accuracies(clk);
+		__clk_recalc_rates(core, POST_RATE_CHANGE);
+		__clk_recalc_accuracies(core);
 	}
 
 out:
@@ -2193,15 +2193,15 @@ int clk_set_phase(struct clk *clk, int degrees)
 }
 EXPORT_SYMBOL_GPL(clk_set_phase);
 
-static int clk_core_get_phase(struct clk_core *clk)
+static int clk_core_get_phase(struct clk_core *core)
 {
 	int ret = 0;
 
-	if (!clk)
+	if (!core)
 		goto out;
 
 	clk_prepare_lock();
-	ret = clk->phase;
+	ret = core->phase;
 	clk_prepare_unlock();
 
 out:
@@ -2263,67 +2263,67 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	int i, ret = 0;
 	struct clk_core *orphan;
 	struct hlist_node *tmp2;
-	struct clk_core *clk;
+	struct clk_core *core;
 	unsigned long rate;
 
 	if (!clk_user)
 		return -EINVAL;
 
-	clk = clk_user->core;
+	core = clk_user->core;
 
 	clk_prepare_lock();
 
 	/* check to see if a clock with this name is already registered */
-	if (clk_core_lookup(clk->name)) {
+	if (clk_core_lookup(core->name)) {
 		pr_debug("%s: clk %s already initialized\n",
-				__func__, clk->name);
+				__func__, core->name);
 		ret = -EEXIST;
 		goto out;
 	}
 
 	/* check that clk_ops are sane.  See Documentation/clk.txt */
-	if (clk->ops->set_rate &&
-	    !((clk->ops->round_rate || clk->ops->determine_rate) &&
-	      clk->ops->recalc_rate)) {
+	if (core->ops->set_rate &&
+	    !((core->ops->round_rate || core->ops->determine_rate) &&
+	      core->ops->recalc_rate)) {
 		pr_warning("%s: %s must implement .round_rate or .determine_rate in addition to .recalc_rate\n",
-				__func__, clk->name);
+				__func__, core->name);
 		ret = -EINVAL;
 		goto out;
 	}
 
-	if (clk->ops->set_parent && !clk->ops->get_parent) {
+	if (core->ops->set_parent && !core->ops->get_parent) {
 		pr_warning("%s: %s must implement .get_parent & .set_parent\n",
-				__func__, clk->name);
+				__func__, core->name);
 		ret = -EINVAL;
 		goto out;
 	}
 
-	if (clk->ops->set_rate_and_parent &&
-			!(clk->ops->set_parent && clk->ops->set_rate)) {
+	if (core->ops->set_rate_and_parent &&
+			!(core->ops->set_parent && core->ops->set_rate)) {
 		pr_warn("%s: %s must implement .set_parent & .set_rate\n",
-				__func__, clk->name);
+				__func__, core->name);
 		ret = -EINVAL;
 		goto out;
 	}
 
 	/* throw a WARN if any entries in parent_names are NULL */
-	for (i = 0; i < clk->num_parents; i++)
-		WARN(!clk->parent_names[i],
+	for (i = 0; i < core->num_parents; i++)
+		WARN(!core->parent_names[i],
 				"%s: invalid NULL in %s's .parent_names\n",
-				__func__, clk->name);
+				__func__, core->name);
 
 	/*
 	 * Allocate an array of struct clk *'s to avoid unnecessary string
 	 * look-ups of clk's possible parents.  This can fail for clocks passed
-	 * in to clk_init during early boot; thus any access to clk->parents[]
+	 * in to clk_init during early boot; thus any access to core->parents[]
 	 * must always check for a NULL pointer and try to populate it if
 	 * necessary.
 	 *
-	 * If clk->parents is not NULL we skip this entire block.  This allows
-	 * for clock drivers to statically initialize clk->parents.
+	 * If core->parents is not NULL we skip this entire block.  This allows
+	 * for clock drivers to statically initialize core->parents.
 	 */
-	if (clk->num_parents > 1 && !clk->parents) {
-		clk->parents = kcalloc(clk->num_parents, sizeof(struct clk *),
+	if (core->num_parents > 1 && !core->parents) {
+		core->parents = kcalloc(core->num_parents, sizeof(struct clk *),
 					GFP_KERNEL);
 		/*
 		 * clk_core_lookup returns NULL for parents that have not been
@@ -2331,16 +2331,16 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 		 * for a NULL pointer.  We can always perform lazy lookups for
 		 * missing parents later on.
 		 */
-		if (clk->parents)
-			for (i = 0; i < clk->num_parents; i++)
-				clk->parents[i] =
-					clk_core_lookup(clk->parent_names[i]);
+		if (core->parents)
+			for (i = 0; i < core->num_parents; i++)
+				core->parents[i] =
+					clk_core_lookup(core->parent_names[i]);
 	}
 
-	clk->parent = __clk_init_parent(clk);
+	core->parent = __clk_init_parent(core);
 
 	/*
-	 * Populate clk->parent if parent has already been __clk_init'd.  If
+	 * Populate core->parent if parent has already been __clk_init'd.  If
 	 * parent has not yet been __clk_init'd then place clk in the orphan
 	 * list.  If clk has set the CLK_IS_ROOT flag then place it in the root
 	 * clk list.
@@ -2349,13 +2349,13 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	 * clocks and re-parent any that are children of the clock currently
 	 * being clk_init'd.
 	 */
-	if (clk->parent)
-		hlist_add_head(&clk->child_node,
-				&clk->parent->children);
-	else if (clk->flags & CLK_IS_ROOT)
-		hlist_add_head(&clk->child_node, &clk_root_list);
+	if (core->parent)
+		hlist_add_head(&core->child_node,
+				&core->parent->children);
+	else if (core->flags & CLK_IS_ROOT)
+		hlist_add_head(&core->child_node, &clk_root_list);
 	else
-		hlist_add_head(&clk->child_node, &clk_orphan_list);
+		hlist_add_head(&core->child_node, &clk_orphan_list);
 
 	/*
 	 * Set clk's accuracy.  The preferred method is to use
@@ -2364,23 +2364,23 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	 * parent (or is orphaned) then accuracy is set to zero (perfect
 	 * clock).
 	 */
-	if (clk->ops->recalc_accuracy)
-		clk->accuracy = clk->ops->recalc_accuracy(clk->hw,
-					__clk_get_accuracy(clk->parent));
-	else if (clk->parent)
-		clk->accuracy = clk->parent->accuracy;
+	if (core->ops->recalc_accuracy)
+		core->accuracy = core->ops->recalc_accuracy(core->hw,
+					__clk_get_accuracy(core->parent));
+	else if (core->parent)
+		core->accuracy = core->parent->accuracy;
 	else
-		clk->accuracy = 0;
+		core->accuracy = 0;
 
 	/*
 	 * Set clk's phase.
 	 * Since a phase is by definition relative to its parent, just
 	 * query the current clock phase, or just assume it's in phase.
 	 */
-	if (clk->ops->get_phase)
-		clk->phase = clk->ops->get_phase(clk->hw);
+	if (core->ops->get_phase)
+		core->phase = core->ops->get_phase(core->hw);
 	else
-		clk->phase = 0;
+		core->phase = 0;
 
 	/*
 	 * Set clk's rate.  The preferred method is to use .recalc_rate.  For
@@ -2388,14 +2388,14 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	 * parent's rate.  If a clock doesn't have a parent (or is orphaned)
 	 * then rate is set to zero.
 	 */
-	if (clk->ops->recalc_rate)
-		rate = clk->ops->recalc_rate(clk->hw,
-				clk_core_get_rate_nolock(clk->parent));
-	else if (clk->parent)
-		rate = clk->parent->rate;
+	if (core->ops->recalc_rate)
+		rate = core->ops->recalc_rate(core->hw,
+				clk_core_get_rate_nolock(core->parent));
+	else if (core->parent)
+		rate = core->parent->rate;
 	else
 		rate = 0;
-	clk->rate = clk->req_rate = rate;
+	core->rate = core->req_rate = rate;
 
 	/*
 	 * walk the list of orphan clocks and reparent any that are children of
@@ -2404,14 +2404,14 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
 		if (orphan->num_parents && orphan->ops->get_parent) {
 			i = orphan->ops->get_parent(orphan->hw);
-			if (!strcmp(clk->name, orphan->parent_names[i]))
-				clk_core_reparent(orphan, clk);
+			if (!strcmp(core->name, orphan->parent_names[i]))
+				clk_core_reparent(orphan, core);
 			continue;
 		}
 
 		for (i = 0; i < orphan->num_parents; i++)
-			if (!strcmp(clk->name, orphan->parent_names[i])) {
-				clk_core_reparent(orphan, clk);
+			if (!strcmp(core->name, orphan->parent_names[i])) {
+				clk_core_reparent(orphan, core);
 				break;
 			}
 	 }
@@ -2424,15 +2424,15 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	 * Please consider other ways of solving initialization problems before
 	 * using this callback, as its use is discouraged.
 	 */
-	if (clk->ops->init)
-		clk->ops->init(clk->hw);
+	if (core->ops->init)
+		core->ops->init(core->hw);
 
-	kref_init(&clk->ref);
+	kref_init(&core->ref);
 out:
 	clk_prepare_unlock();
 
 	if (!ret)
-		clk_debug_register(clk);
+		clk_debug_register(core);
 
 	return ret;
 }
@@ -2485,34 +2485,34 @@ void __clk_free_clk(struct clk *clk)
 struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 {
 	int i, ret;
-	struct clk_core *clk;
+	struct clk_core *core;
 
-	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
-	if (!clk) {
+	core = kzalloc(sizeof(*core), GFP_KERNEL);
+	if (!core) {
 		pr_err("%s: could not allocate clk\n", __func__);
 		ret = -ENOMEM;
 		goto fail_out;
 	}
 
-	clk->name = kstrdup_const(hw->init->name, GFP_KERNEL);
-	if (!clk->name) {
+	core->name = kstrdup_const(hw->init->name, GFP_KERNEL);
+	if (!core->name) {
 		pr_err("%s: could not allocate clk->name\n", __func__);
 		ret = -ENOMEM;
 		goto fail_name;
 	}
-	clk->ops = hw->init->ops;
+	core->ops = hw->init->ops;
 	if (dev && dev->driver)
-		clk->owner = dev->driver->owner;
-	clk->hw = hw;
-	clk->flags = hw->init->flags;
-	clk->num_parents = hw->init->num_parents;
-	hw->core = clk;
+		core->owner = dev->driver->owner;
+	core->hw = hw;
+	core->flags = hw->init->flags;
+	core->num_parents = hw->init->num_parents;
+	hw->core = core;
 
 	/* allocate local copy in case parent_names is __initdata */
-	clk->parent_names = kcalloc(clk->num_parents, sizeof(char *),
+	core->parent_names = kcalloc(core->num_parents, sizeof(char *),
 					GFP_KERNEL);
 
-	if (!clk->parent_names) {
+	if (!core->parent_names) {
 		pr_err("%s: could not allocate clk->parent_names\n", __func__);
 		ret = -ENOMEM;
 		goto fail_parent_names;
@@ -2520,17 +2520,17 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 
 	/* copy each string name in case parent_names is __initdata */
-	for (i = 0; i < clk->num_parents; i++) {
-		clk->parent_names[i] = kstrdup_const(hw->init->parent_names[i],
+	for (i = 0; i < core->num_parents; i++) {
+		core->parent_names[i] = kstrdup_const(hw->init->parent_names[i],
 						GFP_KERNEL);
-		if (!clk->parent_names[i]) {
+		if (!core->parent_names[i]) {
 			pr_err("%s: could not copy parent_names\n", __func__);
 			ret = -ENOMEM;
 			goto fail_parent_names_copy;
 		}
 	}
 
-	INIT_HLIST_HEAD(&clk->clks);
+	INIT_HLIST_HEAD(&core->clks);
 
 	hw->clk = __clk_create_clk(hw, NULL, NULL);
 	if (IS_ERR(hw->clk)) {
@@ -2548,12 +2548,12 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 fail_parent_names_copy:
 	while (--i >= 0)
-		kfree_const(clk->parent_names[i]);
-	kfree(clk->parent_names);
+		kfree_const(core->parent_names[i]);
+	kfree(core->parent_names);
 fail_parent_names:
-	kfree_const(clk->name);
+	kfree_const(core->name);
 fail_name:
-	kfree(clk);
+	kfree(core);
 fail_out:
 	return ERR_PTR(ret);
 }
@@ -2565,18 +2565,18 @@ EXPORT_SYMBOL_GPL(clk_register);
  */
 static void __clk_release(struct kref *ref)
 {
-	struct clk_core *clk = container_of(ref, struct clk_core, ref);
-	int i = clk->num_parents;
+	struct clk_core *core = container_of(ref, struct clk_core, ref);
+	int i = core->num_parents;
 
 	lockdep_assert_held(&prepare_lock);
 
-	kfree(clk->parents);
+	kfree(core->parents);
 	while (--i >= 0)
-		kfree_const(clk->parent_names[i]);
+		kfree_const(core->parent_names[i]);
 
-	kfree(clk->parent_names);
-	kfree_const(clk->name);
-	kfree(clk);
+	kfree(core->parent_names);
+	kfree_const(core->name);
+	kfree(core);
 }
 
 /*

commit 03bc10ab5b0f9b8f81bffbe6e40c944f9d3dbcc5
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Sun Mar 29 03:48:48 2015 +0200

    clk: check ->determine/round_rate() return value in clk_calc_new_rates
    
    ->determine_rate() and ->round_rate() can return the closest rate to the
    requested one or an error code.
    clk_calc_new_rates is assuming these functions can't return a negative
    value, which leads to a undefined behavior when the clk implementation
    returns such an error code.
    Fix this by returning NULL in case ->determine_rate() or ->round_rate()
    returned an error code.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fa5a00e5ee41..459ce9da13e0 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1618,6 +1618,7 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 	unsigned long min_rate;
 	unsigned long max_rate;
 	int p_index = 0;
+	long ret;
 
 	/* sanity */
 	if (IS_ERR_OR_NULL(clk))
@@ -1633,15 +1634,23 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 	/* find the closest rate and parent clk/rate */
 	if (clk->ops->determine_rate) {
 		parent_hw = parent ? parent->hw : NULL;
-		new_rate = clk->ops->determine_rate(clk->hw, rate,
-						    min_rate,
-						    max_rate,
-						    &best_parent_rate,
-						    &parent_hw);
+		ret = clk->ops->determine_rate(clk->hw, rate,
+					       min_rate,
+					       max_rate,
+					       &best_parent_rate,
+					       &parent_hw);
+		if (ret < 0)
+			return NULL;
+
+		new_rate = ret;
 		parent = parent_hw ? parent_hw->core : NULL;
 	} else if (clk->ops->round_rate) {
-		new_rate = clk->ops->round_rate(clk->hw, rate,
-						&best_parent_rate);
+		ret = clk->ops->round_rate(clk->hw, rate,
+					   &best_parent_rate);
+		if (ret < 0)
+			return NULL;
+
+		new_rate = ret;
 		if (new_rate < min_rate || new_rate > max_rate)
 			return NULL;
 	} else if (!parent || !(clk->flags & CLK_SET_RATE_PARENT)) {

commit 5cf065f556cb5926127b52563f494c2dd0a878e4
Merge: 306c342f9cb1 aaa6d06282a7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Mar 11 17:07:37 2015 -0700

    Merge branch 'clk-fixes' into clk-next

commit 306c342f9cb1f573af57a6afd1b3549aa97b9281
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Feb 5 15:39:11 2015 -0800

    clk: Replace of_clk_get_by_clkspec() with of_clk_get_from_provider()
    
    of_clk_get_by_clkspec() has the same function signature as
    of_clk_get_from_provider()
    
     struct clk *of_clk_get_by_clkspec(struct of_phandle_args
     *clkspec)
     struct clk *of_clk_get_from_provider(struct of_phandle_args
     *clkspec)
    
    except of_clk_get_by_clkspec() checks to make sure clkspec is not
    NULL. Let's remove of_clk_get_by_clkspec() and replace the
    callers of it (clkconf.c) with of_clk_get_from_provider().
    
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 024d78316b38..9872ec255f9a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2857,17 +2857,6 @@ static const struct of_device_id __clk_of_table_sentinel
 static LIST_HEAD(of_clk_providers);
 static DEFINE_MUTEX(of_clk_mutex);
 
-/* of_clk_provider list locking helpers */
-void of_clk_lock(void)
-{
-	mutex_lock(&of_clk_mutex);
-}
-
-void of_clk_unlock(void)
-{
-	mutex_unlock(&of_clk_mutex);
-}
-
 struct clk *of_clk_src_simple_get(struct of_phandle_args *clkspec,
 				     void *data)
 {
@@ -2951,7 +2940,11 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 	struct of_clk_provider *provider;
 	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
 
+	if (!clkspec)
+		return ERR_PTR(-EINVAL);
+
 	/* Check if we have such a provider in our array */
+	mutex_lock(&of_clk_mutex);
 	list_for_each_entry(provider, &of_clk_providers, link) {
 		if (provider->node == clkspec->np)
 			clk = provider->get(clkspec, provider->data);
@@ -2967,19 +2960,22 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
 			break;
 		}
 	}
+	mutex_unlock(&of_clk_mutex);
 
 	return clk;
 }
 
+/**
+ * of_clk_get_from_provider() - Lookup a clock from a clock provider
+ * @clkspec: pointer to a clock specifier data structure
+ *
+ * This function looks up a struct clk from the registered list of clock
+ * providers, an input is a clock specifier data structure as returned
+ * from the of_parse_phandle_with_args() function call.
+ */
 struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 {
-	struct clk *clk;
-
-	mutex_lock(&of_clk_mutex);
-	clk = __of_clk_get_from_provider(clkspec, NULL, __func__);
-	mutex_unlock(&of_clk_mutex);
-
-	return clk;
+	return __of_clk_get_from_provider(clkspec, NULL, __func__);
 }
 
 int of_clk_get_parent_count(struct device_node *np)

commit 50595f8b9e78b3c80d341bf9da3e7848d9abbe2a
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 6 11:42:44 2015 -0800

    clk: Rename child_node to clks_node to avoid confusion
    
    The child_node member of struct clk is named the same as the
    child_node member of struct clk_core. Let's rename the struct
    clk's member to clks_node to avoid getting confused with the
    child_node member of struct clk_core and to match the name of the
    list head, clks.
    
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Alban Browaeys <alban.browaeys@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3e10cdff284b..024d78316b38 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -86,7 +86,7 @@ struct clk {
 	const char *con_id;
 	unsigned long min_rate;
 	unsigned long max_rate;
-	struct hlist_node child_node;
+	struct hlist_node clks_node;
 };
 
 /***           locking             ***/
@@ -862,10 +862,10 @@ static void clk_core_get_boundaries(struct clk_core *clk,
 	*min_rate = 0;
 	*max_rate = ULONG_MAX;
 
-	hlist_for_each_entry(clk_user, &clk->clks, child_node)
+	hlist_for_each_entry(clk_user, &clk->clks, clks_node)
 		*min_rate = max(*min_rate, clk_user->min_rate);
 
-	hlist_for_each_entry(clk_user, &clk->clks, child_node)
+	hlist_for_each_entry(clk_user, &clk->clks, clks_node)
 		*max_rate = min(*max_rate, clk_user->max_rate);
 }
 
@@ -2422,7 +2422,7 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 	clk->max_rate = ULONG_MAX;
 
 	clk_prepare_lock();
-	hlist_add_head(&clk->child_node, &hw->core->clks);
+	hlist_add_head(&clk->clks_node, &hw->core->clks);
 	clk_prepare_unlock();
 
 	return clk;
@@ -2431,7 +2431,7 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 void __clk_free_clk(struct clk *clk)
 {
 	clk_prepare_lock();
-	hlist_del(&clk->child_node);
+	hlist_del(&clk->clks_node);
 	clk_prepare_unlock();
 
 	kfree(clk);
@@ -2711,7 +2711,7 @@ void __clk_put(struct clk *clk)
 
 	clk_prepare_lock();
 
-	hlist_del(&clk->child_node);
+	hlist_del(&clk->clks_node);
 	if (clk->min_rate > clk->core->req_rate ||
 	    clk->max_rate < clk->core->req_rate)
 		clk_core_set_rate_nolock(clk->core, clk->core->req_rate);

commit b61c43c09f5e2b9bf8f340034c5ef1db8c64efa5
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Feb 2 14:11:25 2015 -0800

    clk: clk_set_parent() with current parent shouldn't fail
    
    If a driver calls clk_set_parent(clk, parent) and parent is the
    current parent of clk we shouldn't fail in any case.
    Unfortunately if clk is a read-only mux we return -ENOSYS
    because we think we can't change the parent, except for in this
    special case where we don't actually need to change the parent at
    all. Return 0 in such a situation.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 42064cec2364..3e10cdff284b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2055,16 +2055,18 @@ static int clk_core_set_parent(struct clk_core *clk, struct clk_core *parent)
 	if (!clk)
 		return 0;
 
-	/* verify ops for for multi-parent clks */
-	if ((clk->num_parents > 1) && (!clk->ops->set_parent))
-		return -ENOSYS;
-
 	/* prevent racing with updates to the clock topology */
 	clk_prepare_lock();
 
 	if (clk->parent == parent)
 		goto out;
 
+	/* verify ops for for multi-parent clks */
+	if ((clk->num_parents > 1) && (!clk->ops->set_parent)) {
+		ret = -ENOSYS;
+		goto out;
+	}
+
 	/* check that we are allowed to re-parent if the clock is in use */
 	if ((clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count) {
 		ret = -EBUSY;

commit dfc202ead3123988793ac1160849676000b77ee4
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Feb 2 14:37:41 2015 -0800

    clk: Add tracepoints for hardware operations
    
    It's useful to have tracepoints around operations that change the
    hardware state so that we can debug clock hardware performance
    and operations. Four basic types of events are supported: on/off
    events for enable, disable, prepare, unprepare that only record
    an event and a clock name, rate changing events for
    clk_set_{min_,max_}rate{_range}(), phase changing events for
    clk_set_phase() and parent changing events for clk_set_parent().
    
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0b3f39c03785..42064cec2364 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -77,6 +77,9 @@ struct clk_core {
 	struct kref		ref;
 };
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/clk.h>
+
 struct clk {
 	struct clk_core	*core;
 	const char *dev_id;
@@ -492,10 +495,12 @@ static void clk_unprepare_unused_subtree(struct clk_core *clk)
 		return;
 
 	if (clk_core_is_prepared(clk)) {
+		trace_clk_unprepare(clk);
 		if (clk->ops->unprepare_unused)
 			clk->ops->unprepare_unused(clk->hw);
 		else if (clk->ops->unprepare)
 			clk->ops->unprepare(clk->hw);
+		trace_clk_unprepare_complete(clk);
 	}
 }
 
@@ -524,10 +529,12 @@ static void clk_disable_unused_subtree(struct clk_core *clk)
 	 * back to .disable
 	 */
 	if (clk_core_is_enabled(clk)) {
+		trace_clk_disable(clk);
 		if (clk->ops->disable_unused)
 			clk->ops->disable_unused(clk->hw);
 		else if (clk->ops->disable)
 			clk->ops->disable(clk->hw);
+		trace_clk_disable_complete(clk);
 	}
 
 unlock_out:
@@ -907,9 +914,12 @@ static void clk_core_unprepare(struct clk_core *clk)
 
 	WARN_ON(clk->enable_count > 0);
 
+	trace_clk_unprepare(clk);
+
 	if (clk->ops->unprepare)
 		clk->ops->unprepare(clk->hw);
 
+	trace_clk_unprepare_complete(clk);
 	clk_core_unprepare(clk->parent);
 }
 
@@ -947,12 +957,16 @@ static int clk_core_prepare(struct clk_core *clk)
 		if (ret)
 			return ret;
 
-		if (clk->ops->prepare) {
+		trace_clk_prepare(clk);
+
+		if (clk->ops->prepare)
 			ret = clk->ops->prepare(clk->hw);
-			if (ret) {
-				clk_core_unprepare(clk->parent);
-				return ret;
-			}
+
+		trace_clk_prepare_complete(clk);
+
+		if (ret) {
+			clk_core_unprepare(clk->parent);
+			return ret;
 		}
 	}
 
@@ -999,9 +1013,13 @@ static void clk_core_disable(struct clk_core *clk)
 	if (--clk->enable_count > 0)
 		return;
 
+	trace_clk_disable(clk);
+
 	if (clk->ops->disable)
 		clk->ops->disable(clk->hw);
 
+	trace_clk_disable_complete(clk);
+
 	clk_core_disable(clk->parent);
 }
 
@@ -1054,12 +1072,16 @@ static int clk_core_enable(struct clk_core *clk)
 		if (ret)
 			return ret;
 
-		if (clk->ops->enable) {
+		trace_clk_enable(clk);
+
+		if (clk->ops->enable)
 			ret = clk->ops->enable(clk->hw);
-			if (ret) {
-				clk_core_disable(clk->parent);
-				return ret;
-			}
+
+		trace_clk_enable_complete(clk);
+
+		if (ret) {
+			clk_core_disable(clk->parent);
+			return ret;
 		}
 	}
 
@@ -1490,10 +1512,14 @@ static int __clk_set_parent(struct clk_core *clk, struct clk_core *parent,
 
 	old_parent = __clk_set_parent_before(clk, parent);
 
+	trace_clk_set_parent(clk, parent);
+
 	/* change clock input source */
 	if (parent && clk->ops->set_parent)
 		ret = clk->ops->set_parent(clk->hw, p_index);
 
+	trace_clk_set_parent_complete(clk, parent);
+
 	if (ret) {
 		flags = clk_enable_lock();
 		clk_reparent(clk, old_parent);
@@ -1719,6 +1745,7 @@ static void clk_change_rate(struct clk_core *clk)
 
 	if (clk->new_parent && clk->new_parent != clk->parent) {
 		old_parent = __clk_set_parent_before(clk, clk->new_parent);
+		trace_clk_set_parent(clk, clk->new_parent);
 
 		if (clk->ops->set_rate_and_parent) {
 			skip_set_rate = true;
@@ -1729,12 +1756,17 @@ static void clk_change_rate(struct clk_core *clk)
 			clk->ops->set_parent(clk->hw, clk->new_parent_index);
 		}
 
+		trace_clk_set_parent_complete(clk, clk->new_parent);
 		__clk_set_parent_after(clk, clk->new_parent, old_parent);
 	}
 
+	trace_clk_set_rate(clk, clk->new_rate);
+
 	if (!skip_set_rate && clk->ops->set_rate)
 		clk->ops->set_rate(clk->hw, clk->new_rate, best_parent_rate);
 
+	trace_clk_set_rate_complete(clk, clk->new_rate);
+
 	clk->rate = clk_recalc(clk, best_parent_rate);
 
 	if (clk->notifier_count && old_rate != clk->rate)
@@ -2135,9 +2167,13 @@ int clk_set_phase(struct clk *clk, int degrees)
 
 	clk_prepare_lock();
 
+	trace_clk_set_phase(clk->core, degrees);
+
 	if (clk->core->ops->set_phase)
 		ret = clk->core->ops->set_phase(clk->core->hw, degrees);
 
+	trace_clk_set_phase_complete(clk->core, degrees);
+
 	if (!ret)
 		clk->core->phase = degrees;
 

commit 08b9575660cd6d654c05314fc41d2209f2d8bdfb
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Feb 2 14:09:43 2015 -0800

    clk: Missing set_phase op is an error
    
    If a clock's clk_ops doesn't have the set_phase op set we should
    return an error from clk_set_phase(). This way clock consumers
    know that when they tried to set a phase it didn't work, as
    opposed to the current behavior where the return value is 0
    meaning success.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b0313cb4369c..0b3f39c03785 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2123,10 +2123,10 @@ EXPORT_SYMBOL_GPL(clk_set_parent);
  */
 int clk_set_phase(struct clk *clk, int degrees)
 {
-	int ret = 0;
+	int ret = -EINVAL;
 
 	if (!clk)
-		goto out;
+		return 0;
 
 	/* sanity check degrees */
 	degrees %= 360;
@@ -2135,18 +2135,14 @@ int clk_set_phase(struct clk *clk, int degrees)
 
 	clk_prepare_lock();
 
-	if (!clk->core->ops->set_phase)
-		goto out_unlock;
-
-	ret = clk->core->ops->set_phase(clk->core->hw, degrees);
+	if (clk->core->ops->set_phase)
+		ret = clk->core->ops->set_phase(clk->core->hw, degrees);
 
 	if (!ret)
 		clk->core->phase = degrees;
 
-out_unlock:
 	clk_prepare_unlock();
 
-out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_set_phase);

commit 496eadf821c2a5111a4b1b401ddda8d1fc18fb0b
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jan 9 09:28:10 2015 +0100

    clk: Use lockdep asserts to find missing hold of prepare_lock
    
    Add lockdep asserts for holding the prepare_lock to all functions
    marking this as a requirement in description. Add this to private and
    exported functions so all locking misuse could be detected during
    debugging.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index eb0152961d3c..b0313cb4369c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -480,6 +480,8 @@ static void clk_unprepare_unused_subtree(struct clk_core *clk)
 {
 	struct clk_core *child;
 
+	lockdep_assert_held(&prepare_lock);
+
 	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_unprepare_unused_subtree(child);
 
@@ -503,6 +505,8 @@ static void clk_disable_unused_subtree(struct clk_core *clk)
 	struct clk_core *child;
 	unsigned long flags;
 
+	lockdep_assert_held(&prepare_lock);
+
 	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_disable_unused_subtree(child);
 
@@ -1106,6 +1110,8 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
 	struct clk_core *parent;
 	struct clk_hw *parent_hw;
 
+	lockdep_assert_held(&prepare_lock);
+
 	if (!clk)
 		return 0;
 
@@ -1245,6 +1251,8 @@ static void __clk_recalc_accuracies(struct clk_core *clk)
 	unsigned long parent_accuracy = 0;
 	struct clk_core *child;
 
+	lockdep_assert_held(&prepare_lock);
+
 	if (clk->parent)
 		parent_accuracy = clk->parent->accuracy;
 
@@ -1318,6 +1326,8 @@ static void __clk_recalc_rates(struct clk_core *clk, unsigned long msg)
 	unsigned long parent_rate = 0;
 	struct clk_core *child;
 
+	lockdep_assert_held(&prepare_lock);
+
 	old_rate = clk->rate;
 
 	if (clk->parent)
@@ -1525,6 +1535,8 @@ static int __clk_speculate_rates(struct clk_core *clk,
 	unsigned long new_rate;
 	int ret = NOTIFY_DONE;
 
+	lockdep_assert_held(&prepare_lock);
+
 	new_rate = clk_recalc(clk, parent_rate);
 
 	/* abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */
@@ -2488,6 +2500,8 @@ static void __clk_release(struct kref *ref)
 	struct clk_core *clk = container_of(ref, struct clk_core, ref);
 	int i = clk->num_parents;
 
+	lockdep_assert_held(&prepare_lock);
+
 	kfree(clk->parents);
 	while (--i >= 0)
 		kfree_const(clk->parent_names[i]);

commit 3d3801effda19b21012b5d1981e96cc277df85fd
Author: Michael Turquette <mturquette@linaro.org>
Date:   Wed Feb 25 09:11:01 2015 -0800

    clk: introduce clk_is_match
    
    Some drivers compare struct clk pointers as a means of knowing
    if the two pointers reference the same clock hardware. This behavior is
    dubious (drivers must not dereference struct clk), but did not cause any
    regressions until the per-user struct clk patch was merged. Now the test
    for matching clk's will always fail with per-user struct clk's.
    
    clk_is_match is introduced to fix the regression and prevent drivers
    from comparing the pointers manually.
    
    Fixes: 035a61c314eb ("clk: Make clk API return per-user struct clk instances")
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>
    [arnd@arndb.de: Fix COMMON_CLK=N && HAS_CLK=Y config]
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [sboyd@codeaurora.org: const arguments to clk_is_match() and
    remove unnecessary ternary operation]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b9f85fc2ce3f..237f23f68bfc 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2169,6 +2169,32 @@ int clk_get_phase(struct clk *clk)
 	return clk_core_get_phase(clk->core);
 }
 
+/**
+ * clk_is_match - check if two clk's point to the same hardware clock
+ * @p: clk compared against q
+ * @q: clk compared against p
+ *
+ * Returns true if the two struct clk pointers both point to the same hardware
+ * clock node. Put differently, returns true if struct clk *p and struct clk *q
+ * share the same struct clk_core object.
+ *
+ * Returns false otherwise. Note that two NULL clks are treated as matching.
+ */
+bool clk_is_match(const struct clk *p, const struct clk *q)
+{
+	/* trivial case: identical struct clk's or both NULL */
+	if (p == q)
+		return true;
+
+	/* true if clk->core pointers match. Avoid derefing garbage */
+	if (!IS_ERR_OR_NULL(p) && !IS_ERR_OR_NULL(q))
+		if (p->core == q->core)
+			return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(clk_is_match);
+
 /**
  * __clk_init - initialize the data structures in a struct clk
  * @dev:	device initializing this clk, placeholder for now

commit f55ac0655a6e42d8299b78c23ee70301f7956d5e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Mar 11 17:56:31 2015 +0100

    clk: don't export static symbol
    
    The semantic patch that fixes this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    type T;
    identifier f;
    @@
    
    static T f (...) { ... }
    
    @@
    identifier r.f;
    declarer name EXPORT_SYMBOL_GPL;
    @@
    
    -EXPORT_SYMBOL_GPL(f);
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Fixes: 035a61c314eb "clk: Make clk API return per-user struct clk instances"
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index eb0152961d3c..b9f85fc2ce3f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1350,7 +1350,6 @@ static unsigned long clk_core_get_rate(struct clk_core *clk)
 
 	return rate;
 }
-EXPORT_SYMBOL_GPL(clk_core_get_rate);
 
 /**
  * clk_get_rate - return the rate of clk

commit 18a8d49973667aa016e68826eeb374788b7c63b0
Merge: c189cb8ef628 ec02ace8ca0a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 21 12:30:30 2015 -0800

    Merge tag 'clk-for-linus-3.20' of git://git.linaro.org/people/mike.turquette/linux
    
    Pull clock framework updates from Mike Turquette:
     "The clock framework changes contain the usual driver additions,
      enhancements and fixes mostly for ARM32, ARM64, MIPS and Power-based
      devices.
    
      Additionally the framework core underwent a bit of surgery with two
      major changes:
    
       - The boundary between the clock core and clock providers (e.g clock
         drivers) is now more well defined with dedicated provider helper
         functions.  struct clk no longer maps 1:1 with the hardware clock
         but is a true per-user cookie which helps us tracker users of
         hardware clocks and debug bad behavior.
    
       - The addition of rate constraints for clocks.  Rate ranges are now
         supported which are analogous to the voltage ranges in the
         regulator framework.
    
      Unfortunately these changes to the core created some breakeage.  We
      think we fixed it all up but for this reason there are lots of last
      minute commits trying to undo the damage"
    
    * tag 'clk-for-linus-3.20' of git://git.linaro.org/people/mike.turquette/linux: (113 commits)
      clk: Only recalculate the rate if needed
      Revert "clk: mxs: Fix invalid 32-bit access to frac registers"
      clk: qoriq: Add support for the platform PLL
      powerpc/corenet: Enable CLK_QORIQ
      clk: Replace explicit clk assignment with __clk_hw_set_clk
      clk: Add __clk_hw_set_clk helper function
      clk: Don't dereference parent clock if is NULL
      MIPS: Alchemy: Remove bogus args from alchemy_clk_fgcs_detr
      clkdev: Always allocate a struct clk and call __clk_get() w/ CCF
      clk: shmobile: div6: Avoid division by zero in .round_rate()
      clk: mxs: Fix invalid 32-bit access to frac registers
      clk: omap: compile legacy omap3 clocks conditionally
      clkdev: Export clk_register_clkdev
      clk: Add rate constraints to clocks
      clk: remove clk-private.h
      pci: xgene: do not use clk-private.h
      arm: omap2+ remove dead clock code
      clk: Make clk API return per-user struct clk instances
      clk: tegra: Define PLLD_DSI and remove dsia(b)_mux
      clk: tegra: Add support for the Tegra132 CAR IP block
      ...

commit ec02ace8ca0a50eef430d3676de5c5fa978b0e29
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Feb 6 15:13:01 2015 +0100

    clk: Only recalculate the rate if needed
    
    We don't really need to recalculate the effective rate of a clock when a
    per-user clock is removed, if the constraints of the later aren't
    limiting the requested rate.
    
    This was causing problems with clocks that never had a rate set before,
    as rate_req would be zero. Though this could be considered a bug in the
    implementation of those clocks, this should be checked somewhere else.
    
    Fixes: 1c8e600440c7 ("clk: Add rate constraints to clocks")
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f3a7a4425242..a27f14116cc9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2664,7 +2664,10 @@ void __clk_put(struct clk *clk)
 	clk_prepare_lock();
 
 	hlist_del(&clk->child_node);
-	clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
+	if (clk->min_rate > clk->core->req_rate ||
+	    clk->max_rate < clk->core->req_rate)
+		clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
+
 	owner = clk->core->owner;
 	kref_put(&clk->core->ref, __clk_release);
 

commit 9e0ad7d28ace92319f5aa0e314ac9f11e18b4250
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Thu Feb 12 14:58:28 2015 +0100

    clk: Don't dereference parent clock if is NULL
    
    The clock passed as an argument to clk_mux_determine_rate_flags()
    has the CLK_SET_RATE_PARENT flag set but it has no parent, then a
    NULL pointer will tried to be dereferenced.
    
    This shouldn't happen since setting that flag for a clock with no
    parent is a bug but the core should be robust to handle that case.
    
    Fixes: 035a61c314eb3 ("clk: Make clk API return per-user struct clk instances")
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5469d7714f5d..f3a7a4425242 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -800,8 +800,8 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
 	if (core->flags & CLK_SET_RATE_NO_REPARENT) {
 		parent = core->parent;
 		if (core->flags & CLK_SET_RATE_PARENT)
-			best = __clk_determine_rate(parent->hw, rate,
-						    min_rate, max_rate);
+			best = __clk_determine_rate(parent ? parent->hw : NULL,
+						    rate, min_rate, max_rate);
 		else if (parent)
 			best = clk_core_get_rate_nolock(parent);
 		else

commit 612936f21277d1254dd885de2e383aacdc7ca67f
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Fri Feb 13 14:36:33 2015 -0800

    clk: convert clock name allocations to kstrdup_const
    
    Clock subsystem frequently performs duplication of strings located in
    read-only memory section.  Replacing kstrdup by kstrdup_const allows to
    avoid such operations.
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d48ac71c6c8b..642cf37124d3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2048,7 +2048,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		goto fail_out;
 	}
 
-	clk->name = kstrdup(hw->init->name, GFP_KERNEL);
+	clk->name = kstrdup_const(hw->init->name, GFP_KERNEL);
 	if (!clk->name) {
 		pr_err("%s: could not allocate clk->name\n", __func__);
 		ret = -ENOMEM;
@@ -2075,7 +2075,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 	/* copy each string name in case parent_names is __initdata */
 	for (i = 0; i < clk->num_parents; i++) {
-		clk->parent_names[i] = kstrdup(hw->init->parent_names[i],
+		clk->parent_names[i] = kstrdup_const(hw->init->parent_names[i],
 						GFP_KERNEL);
 		if (!clk->parent_names[i]) {
 			pr_err("%s: could not copy parent_names\n", __func__);
@@ -2090,10 +2090,10 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 fail_parent_names_copy:
 	while (--i >= 0)
-		kfree(clk->parent_names[i]);
+		kfree_const(clk->parent_names[i]);
 	kfree(clk->parent_names);
 fail_parent_names:
-	kfree(clk->name);
+	kfree_const(clk->name);
 fail_name:
 	kfree(clk);
 fail_out:
@@ -2112,10 +2112,10 @@ static void __clk_release(struct kref *ref)
 
 	kfree(clk->parents);
 	while (--i >= 0)
-		kfree(clk->parent_names[i]);
+		kfree_const(clk->parent_names[i]);
 
 	kfree(clk->parent_names);
-	kfree(clk->name);
+	kfree_const(clk->name);
 	kfree(clk);
 }
 

commit 73e0e496afdac9a5190eb3b9c51fdfebcc14ebd4
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 6 11:42:43 2015 -0800

    clkdev: Always allocate a struct clk and call __clk_get() w/ CCF
    
    of_clk_get_by_clkspec() returns a struct clk pointer but it
    doesn't create a new handle for the consumers when we're using
    the common clock framework. Instead it just returns whatever the
    clk provider hands out. When the consumers go to call clk_put()
    we get an Oops.
    
    Unable to handle kernel paging request at virtual address 00200200
    pgd = c0004000
    [00200200] *pgd=00000000
    Internal error: Oops: 805 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.19.0-rc1-00104-ga251361a-dirty #992
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    task: ee00b000 ti: ee088000 task.ti: ee088000
    PC is at __clk_put+0x24/0xd0
    LR is at clk_prepare_lock+0xc/0xec
    pc : [<c03eef38>]    lr : [<c03ec1f4>]    psr: 20000153
    sp : ee089de8  ip : 00000000  fp : 00000000
    r10: ee02f480  r9 : 00000001  r8 : 00000000
    r7 : ee031cc0  r6 : ee089e08  r5 : 00000000  r4 : ee02f480
    r3 : 00100100  r2 : 00200200  r1 : 0000091e  r0 : 00000001
    Flags: nzCv  IRQs on  FIQs off  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c5387d  Table: 4000404a  DAC: 00000015
    Process swapper/0 (pid: 1, stack limit = 0xee088238)
    Stack: (0xee089de8 to 0xee08a000)
    9de0:                   ee7c8f14 c03f0ec8 ee089e08 00000000 c0718dc8 00000001
    9e00: 00000000 c04ee0f0 ee7e0844 00000001 00000181 c04edb58 ee2bd320 00000000
    9e20: 00000000 c011dc5c ee16a1e0 00000000 00000000 c0718dc8 ee16a1e0 ee2bd1e0
    9e40: c0641740 ee16a1e0 00000000 ee2bd320 c0718dc8 ee1d3e10 ee1d3e10 00000000
    9e60: c0769a88 00000000 c0718dc8 00000000 00000000 c02c3124 c02c310c ee1d3e10
    9e80: c07b4eec 00000000 c0769a88 c02c1d0c ee1d3e10 c0769a88 ee1d3e44 00000000
    9ea0: c07091dc c02c1eb8 00000000 c0769a88 c02c1e2c c02c0544 ee005478 ee1676c0
    9ec0: c0769a88 ee3a4e80 c0760ce8 c02c150c c0669b90 c0769a88 c0746cd8 c0769a88
    9ee0: c0746cd8 ee2bc4c0 c0778c00 c02c24e0 00000000 c0746cd8 c0746cd8 c07091f0
    9f00: 00000000 c0008944 c04f405c 00000025 ee00b000 60000153 c074ab00 00000000
    9f20: 00000000 c074ab90 60000153 00000000 ef7fca5d c050860c 000000b6 c0036b88
    9f40: c065ecc4 c06bc728 00000006 00000006 c074ab30 ef7fca40 c0739bdc 00000006
    9f60: c0718dbc c0778c00 000000b6 c0718dc8 c06ed598 c06edd64 00000006 00000006
    9f80: c06ed598 c003b438 00000000 c04e64f4 00000000 00000000 00000000 00000000
    9fa0: 00000000 c04e64fc 00000000 c000e838 00000000 00000000 00000000 00000000
    9fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    9fe0: 00000000 00000000 00000000 00000000 00000013 00000000 c0c0c0c0 c0c0c0c0
    [<c03eef38>] (__clk_put) from [<c03f0ec8>] (of_clk_set_defaults+0xe0/0x2c0)
    [<c03f0ec8>] (of_clk_set_defaults) from [<c02c3124>] (platform_drv_probe+0x18/0xa4)
    [<c02c3124>] (platform_drv_probe) from [<c02c1d0c>] (driver_probe_device+0x10c/0x22c)
    [<c02c1d0c>] (driver_probe_device) from [<c02c1eb8>] (__driver_attach+0x8c/0x90)
    [<c02c1eb8>] (__driver_attach) from [<c02c0544>] (bus_for_each_dev+0x54/0x88)
    [<c02c0544>] (bus_for_each_dev) from [<c02c150c>] (bus_add_driver+0xd4/0x1d0)
    [<c02c150c>] (bus_add_driver) from [<c02c24e0>] (driver_register+0x78/0xf4)
    [<c02c24e0>] (driver_register) from [<c07091f0>] (fimc_md_init+0x14/0x30)
    [<c07091f0>] (fimc_md_init) from [<c0008944>] (do_one_initcall+0x80/0x1d0)
    [<c0008944>] (do_one_initcall) from [<c06edd64>] (kernel_init_freeable+0x108/0x1d4)
    [<c06edd64>] (kernel_init_freeable) from [<c04e64fc>] (kernel_init+0x8/0xec)
    [<c04e64fc>] (kernel_init) from [<c000e838>] (ret_from_fork+0x14/0x3c)
    Code: ebfff4ae e5943014 e5942018 e3530000 (e5823000)
    
    Let's create a per-user handle here so that clk_put() can
    properly unlink it and free the handle. Now that we allocate a
    clk structure here we need to free it if __clk_get() fails so
    bury the __clk_get() call in __of_clk_get_from_provider(). We
    need to handle the same problem in clk_get_sys() so export
    __clk_free_clk() to clkdev.c and do the same thing, except let's
    use a union to make this code #ifdef free.
    
    This fixes the above crash, properly calls __clk_get() when
    of_clk_get_from_provider() is called, and cleans up the clk
    structure on the error path of clk_get_sys().
    
    Fixes: 035a61c314eb "clk: Make clk API return per-user struct clk instances"
    Reported-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Reported-by: Alban Browaeys <alban.browaeys@gmail.com>
    Tested-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Tested-by: Alban Browaeys <prahal@yahoo.com>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 113456030d66..5469d7714f5d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2382,7 +2382,7 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 	return clk;
 }
 
-static void __clk_free_clk(struct clk *clk)
+void __clk_free_clk(struct clk *clk)
 {
 	clk_prepare_lock();
 	hlist_del(&clk->child_node);
@@ -2894,7 +2894,8 @@ void of_clk_del_provider(struct device_node *np)
 }
 EXPORT_SYMBOL_GPL(of_clk_del_provider);
 
-struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec)
+struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
+				       const char *dev_id, const char *con_id)
 {
 	struct of_clk_provider *provider;
 	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
@@ -2903,8 +2904,17 @@ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec)
 	list_for_each_entry(provider, &of_clk_providers, link) {
 		if (provider->node == clkspec->np)
 			clk = provider->get(clkspec, provider->data);
-		if (!IS_ERR(clk))
+		if (!IS_ERR(clk)) {
+			clk = __clk_create_clk(__clk_get_hw(clk), dev_id,
+					       con_id);
+
+			if (!IS_ERR(clk) && !__clk_get(clk)) {
+				__clk_free_clk(clk);
+				clk = ERR_PTR(-ENOENT);
+			}
+
 			break;
+		}
 	}
 
 	return clk;
@@ -2915,7 +2925,7 @@ struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 	struct clk *clk;
 
 	mutex_lock(&of_clk_mutex);
-	clk = __of_clk_get_from_provider(clkspec);
+	clk = __of_clk_get_from_provider(clkspec, NULL, __func__);
 	mutex_unlock(&of_clk_mutex);
 
 	return clk;

commit 1c8e600440c7f5036bd9a94526d01e9c7cb68dca
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Jan 23 12:03:31 2015 +0100

    clk: Add rate constraints to clocks
    
    Adds a way for clock consumers to set maximum and minimum rates. This
    can be used for thermal drivers to set minimum rates, or by misc.
    drivers to set maximum rates to assure a minimum performance level.
    
    Changes the signature of the determine_rate callback by adding the
    parameters min_rate and max_rate.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [sboyd@codeaurora.org: set req_rate in __clk_init]
    Signed-off-by: Michael Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: min/max rate for sun6i_ahb1_clk_determine_rate
                            migrated clk-private.h changes to clk.c]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index cdc1fa58e4f1..113456030d66 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -42,8 +42,6 @@ static unsigned long clk_core_get_rate(struct clk_core *clk);
 static int clk_core_get_phase(struct clk_core *clk);
 static bool clk_core_is_prepared(struct clk_core *clk);
 static bool clk_core_is_enabled(struct clk_core *clk);
-static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
-						unsigned long rate);
 static struct clk_core *clk_core_lookup(const char *name);
 
 /***    private data structures    ***/
@@ -59,6 +57,7 @@ struct clk_core {
 	u8			num_parents;
 	u8			new_parent_index;
 	unsigned long		rate;
+	unsigned long		req_rate;
 	unsigned long		new_rate;
 	struct clk_core		*new_parent;
 	struct clk_core		*new_child;
@@ -70,6 +69,7 @@ struct clk_core {
 	struct hlist_head	children;
 	struct hlist_node	child_node;
 	struct hlist_node	debug_node;
+	struct hlist_head	clks;
 	unsigned int		notifier_count;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*dentry;
@@ -81,6 +81,9 @@ struct clk {
 	struct clk_core	*core;
 	const char *dev_id;
 	const char *con_id;
+	unsigned long min_rate;
+	unsigned long max_rate;
+	struct hlist_node child_node;
 };
 
 /***           locking             ***/
@@ -783,6 +786,8 @@ static bool mux_is_better_rate(unsigned long rate, unsigned long now,
 
 static long
 clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
+			     unsigned long min_rate,
+			     unsigned long max_rate,
 			     unsigned long *best_parent_rate,
 			     struct clk_hw **best_parent_p,
 			     unsigned long flags)
@@ -795,7 +800,8 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
 	if (core->flags & CLK_SET_RATE_NO_REPARENT) {
 		parent = core->parent;
 		if (core->flags & CLK_SET_RATE_PARENT)
-			best = clk_core_round_rate_nolock(parent, rate);
+			best = __clk_determine_rate(parent->hw, rate,
+						    min_rate, max_rate);
 		else if (parent)
 			best = clk_core_get_rate_nolock(parent);
 		else
@@ -810,7 +816,9 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
 		if (!parent)
 			continue;
 		if (core->flags & CLK_SET_RATE_PARENT)
-			parent_rate = clk_core_round_rate_nolock(parent, rate);
+			parent_rate = __clk_determine_rate(parent->hw, rate,
+							   min_rate,
+							   max_rate);
 		else
 			parent_rate = clk_core_get_rate_nolock(parent);
 		if (mux_is_better_rate(rate, parent_rate, best, flags)) {
@@ -834,25 +842,47 @@ struct clk *__clk_lookup(const char *name)
 	return !core ? NULL : core->hw->clk;
 }
 
+static void clk_core_get_boundaries(struct clk_core *clk,
+				    unsigned long *min_rate,
+				    unsigned long *max_rate)
+{
+	struct clk *clk_user;
+
+	*min_rate = 0;
+	*max_rate = ULONG_MAX;
+
+	hlist_for_each_entry(clk_user, &clk->clks, child_node)
+		*min_rate = max(*min_rate, clk_user->min_rate);
+
+	hlist_for_each_entry(clk_user, &clk->clks, child_node)
+		*max_rate = min(*max_rate, clk_user->max_rate);
+}
+
 /*
  * Helper for finding best parent to provide a given frequency. This can be used
  * directly as a determine_rate callback (e.g. for a mux), or from a more
  * complex clock that may combine a mux with other operations.
  */
 long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long min_rate,
+			      unsigned long max_rate,
 			      unsigned long *best_parent_rate,
 			      struct clk_hw **best_parent_p)
 {
-	return clk_mux_determine_rate_flags(hw, rate, best_parent_rate,
+	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
+					    best_parent_rate,
 					    best_parent_p, 0);
 }
 EXPORT_SYMBOL_GPL(__clk_mux_determine_rate);
 
 long __clk_mux_determine_rate_closest(struct clk_hw *hw, unsigned long rate,
+			      unsigned long min_rate,
+			      unsigned long max_rate,
 			      unsigned long *best_parent_rate,
 			      struct clk_hw **best_parent_p)
 {
-	return clk_mux_determine_rate_flags(hw, rate, best_parent_rate,
+	return clk_mux_determine_rate_flags(hw, rate, min_rate, max_rate,
+					    best_parent_rate,
 					    best_parent_p,
 					    CLK_MUX_ROUND_CLOSEST);
 }
@@ -1068,7 +1098,9 @@ int clk_enable(struct clk *clk)
 EXPORT_SYMBOL_GPL(clk_enable);
 
 static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
-						unsigned long rate)
+						unsigned long rate,
+						unsigned long min_rate,
+						unsigned long max_rate)
 {
 	unsigned long parent_rate = 0;
 	struct clk_core *parent;
@@ -1083,16 +1115,40 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
 
 	if (clk->ops->determine_rate) {
 		parent_hw = parent ? parent->hw : NULL;
-		return clk->ops->determine_rate(clk->hw, rate, &parent_rate,
-						&parent_hw);
+		return clk->ops->determine_rate(clk->hw, rate,
+						min_rate, max_rate,
+						&parent_rate, &parent_hw);
 	} else if (clk->ops->round_rate)
 		return clk->ops->round_rate(clk->hw, rate, &parent_rate);
 	else if (clk->flags & CLK_SET_RATE_PARENT)
-		return clk_core_round_rate_nolock(clk->parent, rate);
+		return clk_core_round_rate_nolock(clk->parent, rate, min_rate,
+						  max_rate);
 	else
 		return clk->rate;
 }
 
+/**
+ * __clk_determine_rate - get the closest rate actually supported by a clock
+ * @hw: determine the rate of this clock
+ * @rate: target rate
+ * @min_rate: returned rate must be greater than this rate
+ * @max_rate: returned rate must be less than this rate
+ *
+ * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate and
+ * .determine_rate.
+ */
+unsigned long __clk_determine_rate(struct clk_hw *hw,
+				   unsigned long rate,
+				   unsigned long min_rate,
+				   unsigned long max_rate)
+{
+	if (!hw)
+		return 0;
+
+	return clk_core_round_rate_nolock(hw->core, rate, min_rate, max_rate);
+}
+EXPORT_SYMBOL_GPL(__clk_determine_rate);
+
 /**
  * __clk_round_rate - round the given rate for a clk
  * @clk: round the rate of this clock
@@ -1102,10 +1158,15 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
  */
 unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 {
+	unsigned long min_rate;
+	unsigned long max_rate;
+
 	if (!clk)
 		return 0;
 
-	return clk_core_round_rate_nolock(clk->core, rate);
+	clk_core_get_boundaries(clk->core, &min_rate, &max_rate);
+
+	return clk_core_round_rate_nolock(clk->core, rate, min_rate, max_rate);
 }
 EXPORT_SYMBOL_GPL(__clk_round_rate);
 
@@ -1126,7 +1187,7 @@ long clk_round_rate(struct clk *clk, unsigned long rate)
 		return 0;
 
 	clk_prepare_lock();
-	ret = clk_core_round_rate_nolock(clk->core, rate);
+	ret = __clk_round_rate(clk, rate);
 	clk_prepare_unlock();
 
 	return ret;
@@ -1517,6 +1578,8 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 	struct clk_hw *parent_hw;
 	unsigned long best_parent_rate = 0;
 	unsigned long new_rate;
+	unsigned long min_rate;
+	unsigned long max_rate;
 	int p_index = 0;
 
 	/* sanity */
@@ -1528,16 +1591,22 @@ static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
 	if (parent)
 		best_parent_rate = parent->rate;
 
+	clk_core_get_boundaries(clk, &min_rate, &max_rate);
+
 	/* find the closest rate and parent clk/rate */
 	if (clk->ops->determine_rate) {
 		parent_hw = parent ? parent->hw : NULL;
 		new_rate = clk->ops->determine_rate(clk->hw, rate,
+						    min_rate,
+						    max_rate,
 						    &best_parent_rate,
 						    &parent_hw);
 		parent = parent_hw ? parent_hw->core : NULL;
 	} else if (clk->ops->round_rate) {
 		new_rate = clk->ops->round_rate(clk->hw, rate,
 						&best_parent_rate);
+		if (new_rate < min_rate || new_rate > max_rate)
+			return NULL;
 	} else if (!parent || !(clk->flags & CLK_SET_RATE_PARENT)) {
 		/* pass-through clock without adjustable parent */
 		clk->new_rate = clk->rate;
@@ -1675,6 +1744,45 @@ static void clk_change_rate(struct clk_core *clk)
 		clk_change_rate(clk->new_child);
 }
 
+static int clk_core_set_rate_nolock(struct clk_core *clk,
+				    unsigned long req_rate)
+{
+	struct clk_core *top, *fail_clk;
+	unsigned long rate = req_rate;
+	int ret = 0;
+
+	if (!clk)
+		return 0;
+
+	/* bail early if nothing to do */
+	if (rate == clk_core_get_rate_nolock(clk))
+		return 0;
+
+	if ((clk->flags & CLK_SET_RATE_GATE) && clk->prepare_count)
+		return -EBUSY;
+
+	/* calculate new rates and get the topmost changed clock */
+	top = clk_calc_new_rates(clk, rate);
+	if (!top)
+		return -EINVAL;
+
+	/* notify that we are about to change rates */
+	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
+	if (fail_clk) {
+		pr_debug("%s: failed to set %s rate\n", __func__,
+				fail_clk->name);
+		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
+		return -EBUSY;
+	}
+
+	/* change the rates */
+	clk_change_rate(top);
+
+	clk->req_rate = req_rate;
+
+	return ret;
+}
+
 /**
  * clk_set_rate - specify a new rate for clk
  * @clk: the clk whose rate is being changed
@@ -1698,8 +1806,7 @@ static void clk_change_rate(struct clk_core *clk)
  */
 int clk_set_rate(struct clk *clk, unsigned long rate)
 {
-	struct clk_core *top, *fail_clk;
-	int ret = 0;
+	int ret;
 
 	if (!clk)
 		return 0;
@@ -1707,42 +1814,81 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	/* prevent racing with updates to the clock topology */
 	clk_prepare_lock();
 
-	/* bail early if nothing to do */
-	if (rate == clk_get_rate(clk))
-		goto out;
+	ret = clk_core_set_rate_nolock(clk->core, rate);
 
-	if ((clk->core->flags & CLK_SET_RATE_GATE) &&
-	    clk->core->prepare_count) {
-		ret = -EBUSY;
-		goto out;
-	}
+	clk_prepare_unlock();
 
-	/* calculate new rates and get the topmost changed clock */
-	top = clk_calc_new_rates(clk->core, rate);
-	if (!top) {
-		ret = -EINVAL;
-		goto out;
-	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_rate);
 
-	/* notify that we are about to change rates */
-	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
-	if (fail_clk) {
-		pr_debug("%s: failed to set %s rate\n", __func__,
-				fail_clk->name);
-		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
-		ret = -EBUSY;
-		goto out;
+/**
+ * clk_set_rate_range - set a rate range for a clock source
+ * @clk: clock source
+ * @min: desired minimum clock rate in Hz, inclusive
+ * @max: desired maximum clock rate in Hz, inclusive
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_rate_range(struct clk *clk, unsigned long min, unsigned long max)
+{
+	int ret = 0;
+
+	if (!clk)
+		return 0;
+
+	if (min > max) {
+		pr_err("%s: clk %s dev %s con %s: invalid range [%lu, %lu]\n",
+		       __func__, clk->core->name, clk->dev_id, clk->con_id,
+		       min, max);
+		return -EINVAL;
 	}
 
-	/* change the rates */
-	clk_change_rate(top);
+	clk_prepare_lock();
+
+	if (min != clk->min_rate || max != clk->max_rate) {
+		clk->min_rate = min;
+		clk->max_rate = max;
+		ret = clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
+	}
 
-out:
 	clk_prepare_unlock();
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(clk_set_rate);
+EXPORT_SYMBOL_GPL(clk_set_rate_range);
+
+/**
+ * clk_set_min_rate - set a minimum clock rate for a clock source
+ * @clk: clock source
+ * @rate: desired minimum clock rate in Hz, inclusive
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_min_rate(struct clk *clk, unsigned long rate)
+{
+	if (!clk)
+		return 0;
+
+	return clk_set_rate_range(clk, rate, clk->max_rate);
+}
+EXPORT_SYMBOL_GPL(clk_set_min_rate);
+
+/**
+ * clk_set_max_rate - set a maximum clock rate for a clock source
+ * @clk: clock source
+ * @rate: desired maximum clock rate in Hz, inclusive
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_max_rate(struct clk *clk, unsigned long rate)
+{
+	if (!clk)
+		return 0;
+
+	return clk_set_rate_range(clk, clk->min_rate, rate);
+}
+EXPORT_SYMBOL_GPL(clk_set_max_rate);
 
 /**
  * clk_get_parent - return the parent of a clk
@@ -2038,6 +2184,7 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	struct clk_core *orphan;
 	struct hlist_node *tmp2;
 	struct clk_core *clk;
+	unsigned long rate;
 
 	if (!clk_user)
 		return -EINVAL;
@@ -2162,12 +2309,13 @@ static int __clk_init(struct device *dev, struct clk *clk_user)
 	 * then rate is set to zero.
 	 */
 	if (clk->ops->recalc_rate)
-		clk->rate = clk->ops->recalc_rate(clk->hw,
+		rate = clk->ops->recalc_rate(clk->hw,
 				clk_core_get_rate_nolock(clk->parent));
 	else if (clk->parent)
-		clk->rate = clk->parent->rate;
+		rate = clk->parent->rate;
 	else
-		clk->rate = 0;
+		rate = 0;
+	clk->rate = clk->req_rate = rate;
 
 	/*
 	 * walk the list of orphan clocks and reparent any that are children of
@@ -2225,10 +2373,24 @@ struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
 	clk->core = hw->core;
 	clk->dev_id = dev_id;
 	clk->con_id = con_id;
+	clk->max_rate = ULONG_MAX;
+
+	clk_prepare_lock();
+	hlist_add_head(&clk->child_node, &hw->core->clks);
+	clk_prepare_unlock();
 
 	return clk;
 }
 
+static void __clk_free_clk(struct clk *clk)
+{
+	clk_prepare_lock();
+	hlist_del(&clk->child_node);
+	clk_prepare_unlock();
+
+	kfree(clk);
+}
+
 /**
  * clk_register - allocate a new clock, register it and return an opaque cookie
  * @dev: device that is registering this clock
@@ -2288,6 +2450,8 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		}
 	}
 
+	INIT_HLIST_HEAD(&clk->clks);
+
 	hw->clk = __clk_create_clk(hw, NULL, NULL);
 	if (IS_ERR(hw->clk)) {
 		pr_err("%s: could not allocate per-user clk\n", __func__);
@@ -2299,8 +2463,9 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	if (!ret)
 		return hw->clk;
 
-	kfree(hw->clk);
+	__clk_free_clk(hw->clk);
 	hw->clk = NULL;
+
 fail_parent_names_copy:
 	while (--i >= 0)
 		kfree(clk->parent_names[i]);
@@ -2489,25 +2654,24 @@ int __clk_get(struct clk *clk)
 	return 1;
 }
 
-static void clk_core_put(struct clk_core *core)
+void __clk_put(struct clk *clk)
 {
 	struct module *owner;
 
-	owner = core->owner;
+	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
+		return;
 
 	clk_prepare_lock();
-	kref_put(&core->ref, __clk_release);
+
+	hlist_del(&clk->child_node);
+	clk_core_set_rate_nolock(clk->core, clk->core->req_rate);
+	owner = clk->core->owner;
+	kref_put(&clk->core->ref, __clk_release);
+
 	clk_prepare_unlock();
 
 	module_put(owner);
-}
-
-void __clk_put(struct clk *clk)
-{
-	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
-		return;
 
-	clk_core_put(clk->core);
 	kfree(clk);
 }
 

commit b09d6d99102504a929cfaba4cd0e07658d7f01d1
Author: Michael Turquette <mturquette@linaro.org>
Date:   Thu Jan 29 14:22:50 2015 -0800

    clk: remove clk-private.h
    
    Private clock framework data structures should be private, surprisingly.
    
    Now that all platforms and drivers have been updated to remove static
    initializations of struct clk and struct clk_core objects and all
    references to clk-private.h have been removed we can move the
    definitions of these structures into drivers/clk/clk.c and delete the
    header.
    
    Additionally the ugly DEFINE_CLK macros have been removed. Those were
    used for static definitions of struct clk objects. That practice is no
    longer allowed.
    
    Finally __clk_init is staticized as it is no longer declared in any
    header.
    
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d60c193b81aa..cdc1fa58e4f1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -9,7 +9,7 @@
  * Standard functionality for the common clock API.  See Documentation/clk.txt
  */
 
-#include <linux/clk-private.h>
+#include <linux/clk-provider.h>
 #include <linux/clk/clk-conf.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
@@ -46,6 +46,43 @@ static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
 						unsigned long rate);
 static struct clk_core *clk_core_lookup(const char *name);
 
+/***    private data structures    ***/
+
+struct clk_core {
+	const char		*name;
+	const struct clk_ops	*ops;
+	struct clk_hw		*hw;
+	struct module		*owner;
+	struct clk_core		*parent;
+	const char		**parent_names;
+	struct clk_core		**parents;
+	u8			num_parents;
+	u8			new_parent_index;
+	unsigned long		rate;
+	unsigned long		new_rate;
+	struct clk_core		*new_parent;
+	struct clk_core		*new_child;
+	unsigned long		flags;
+	unsigned int		enable_count;
+	unsigned int		prepare_count;
+	unsigned long		accuracy;
+	int			phase;
+	struct hlist_head	children;
+	struct hlist_node	child_node;
+	struct hlist_node	debug_node;
+	unsigned int		notifier_count;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*dentry;
+#endif
+	struct kref		ref;
+};
+
+struct clk {
+	struct clk_core	*core;
+	const char *dev_id;
+	const char *con_id;
+};
+
 /***           locking             ***/
 static void clk_prepare_lock(void)
 {
@@ -1995,7 +2032,7 @@ int clk_get_phase(struct clk *clk)
  * Initializes the lists in struct clk_core, queries the hardware for the
  * parent and rate and sets them both.
  */
-int __clk_init(struct device *dev, struct clk *clk_user)
+static int __clk_init(struct device *dev, struct clk *clk_user)
 {
 	int i, ret = 0;
 	struct clk_core *orphan;

commit 035a61c314eb3dab5bcc5683afaf4d412689858a
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Jan 23 12:03:30 2015 +0100

    clk: Make clk API return per-user struct clk instances
    
    Moves clock state to struct clk_core, but takes care to change as little API as
    possible.
    
    struct clk_hw still has a pointer to a struct clk, which is the
    implementation's per-user clk instance, for backwards compatibility.
    
    The struct clk that clk_get_parent() returns isn't owned by the caller, but by
    the clock implementation, so the former shouldn't call clk_put() on it.
    
    Because some boards in mach-omap2 still register clocks statically, their clock
    registration had to be updated to take into account that the clock information
    is stored in struct clk_core now.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: adapted clk_has_parent to struct clk_core
                            applied OMAP3+ DPLL fix from Tero & Tony]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b701e7c195e4..d60c193b81aa 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -37,6 +37,15 @@ static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
 
+static long clk_core_get_accuracy(struct clk_core *clk);
+static unsigned long clk_core_get_rate(struct clk_core *clk);
+static int clk_core_get_phase(struct clk_core *clk);
+static bool clk_core_is_prepared(struct clk_core *clk);
+static bool clk_core_is_enabled(struct clk_core *clk);
+static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
+						unsigned long rate);
+static struct clk_core *clk_core_lookup(const char *name);
+
 /***           locking             ***/
 static void clk_prepare_lock(void)
 {
@@ -114,7 +123,8 @@ static struct hlist_head *orphan_list[] = {
 	NULL,
 };
 
-static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
+static void clk_summary_show_one(struct seq_file *s, struct clk_core *c,
+				 int level)
 {
 	if (!c)
 		return;
@@ -122,14 +132,14 @@ static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
 	seq_printf(s, "%*s%-*s %11d %12d %11lu %10lu %-3d\n",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
-		   c->enable_count, c->prepare_count, clk_get_rate(c),
-		   clk_get_accuracy(c), clk_get_phase(c));
+		   c->enable_count, c->prepare_count, clk_core_get_rate(c),
+		   clk_core_get_accuracy(c), clk_core_get_phase(c));
 }
 
-static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
+static void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,
 				     int level)
 {
-	struct clk *child;
+	struct clk_core *child;
 
 	if (!c)
 		return;
@@ -142,7 +152,7 @@ static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
 
 static int clk_summary_show(struct seq_file *s, void *data)
 {
-	struct clk *c;
+	struct clk_core *c;
 	struct hlist_head **lists = (struct hlist_head **)s->private;
 
 	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy   phase\n");
@@ -172,7 +182,7 @@ static const struct file_operations clk_summary_fops = {
 	.release	= single_release,
 };
 
-static void clk_dump_one(struct seq_file *s, struct clk *c, int level)
+static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)
 {
 	if (!c)
 		return;
@@ -180,14 +190,14 @@ static void clk_dump_one(struct seq_file *s, struct clk *c, int level)
 	seq_printf(s, "\"%s\": { ", c->name);
 	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
-	seq_printf(s, "\"rate\": %lu", clk_get_rate(c));
-	seq_printf(s, "\"accuracy\": %lu", clk_get_accuracy(c));
-	seq_printf(s, "\"phase\": %d", clk_get_phase(c));
+	seq_printf(s, "\"rate\": %lu", clk_core_get_rate(c));
+	seq_printf(s, "\"accuracy\": %lu", clk_core_get_accuracy(c));
+	seq_printf(s, "\"phase\": %d", clk_core_get_phase(c));
 }
 
-static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
+static void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)
 {
-	struct clk *child;
+	struct clk_core *child;
 
 	if (!c)
 		return;
@@ -204,7 +214,7 @@ static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
 
 static int clk_dump(struct seq_file *s, void *data)
 {
-	struct clk *c;
+	struct clk_core *c;
 	bool first_node = true;
 	struct hlist_head **lists = (struct hlist_head **)s->private;
 
@@ -240,7 +250,7 @@ static const struct file_operations clk_dump_fops = {
 	.release	= single_release,
 };
 
-static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
+static int clk_debug_create_one(struct clk_core *clk, struct dentry *pdentry)
 {
 	struct dentry *d;
 	int ret = -ENOMEM;
@@ -315,7 +325,7 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
  * initialized.  Otherwise it bails out early since the debugfs clk tree
  * will be created lazily by clk_debug_init as part of a late_initcall.
  */
-static int clk_debug_register(struct clk *clk)
+static int clk_debug_register(struct clk_core *clk)
 {
 	int ret = 0;
 
@@ -340,7 +350,7 @@ static int clk_debug_register(struct clk *clk)
  * debugfs clk tree if clk->dentry points to debugfs created by
  * clk_debug_register in __clk_init.
  */
-static void clk_debug_unregister(struct clk *clk)
+static void clk_debug_unregister(struct clk_core *clk)
 {
 	mutex_lock(&clk_debug_lock);
 	hlist_del_init(&clk->debug_node);
@@ -354,8 +364,9 @@ struct dentry *clk_debugfs_add_file(struct clk_hw *hw, char *name, umode_t mode,
 {
 	struct dentry *d = NULL;
 
-	if (hw->clk->dentry)
-		d = debugfs_create_file(name, mode, hw->clk->dentry, data, fops);
+	if (hw->core->dentry)
+		d = debugfs_create_file(name, mode, hw->core->dentry, data,
+					fops);
 
 	return d;
 }
@@ -375,7 +386,7 @@ EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
  */
 static int __init clk_debug_init(void)
 {
-	struct clk *clk;
+	struct clk_core *clk;
 	struct dentry *d;
 
 	rootdir = debugfs_create_dir("clk", NULL);
@@ -414,19 +425,20 @@ static int __init clk_debug_init(void)
 }
 late_initcall(clk_debug_init);
 #else
-static inline int clk_debug_register(struct clk *clk) { return 0; }
-static inline void clk_debug_reparent(struct clk *clk, struct clk *new_parent)
+static inline int clk_debug_register(struct clk_core *clk) { return 0; }
+static inline void clk_debug_reparent(struct clk_core *clk,
+				      struct clk_core *new_parent)
 {
 }
-static inline void clk_debug_unregister(struct clk *clk)
+static inline void clk_debug_unregister(struct clk_core *clk)
 {
 }
 #endif
 
 /* caller must hold prepare_lock */
-static void clk_unprepare_unused_subtree(struct clk *clk)
+static void clk_unprepare_unused_subtree(struct clk_core *clk)
 {
-	struct clk *child;
+	struct clk_core *child;
 
 	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_unprepare_unused_subtree(child);
@@ -437,7 +449,7 @@ static void clk_unprepare_unused_subtree(struct clk *clk)
 	if (clk->flags & CLK_IGNORE_UNUSED)
 		return;
 
-	if (__clk_is_prepared(clk)) {
+	if (clk_core_is_prepared(clk)) {
 		if (clk->ops->unprepare_unused)
 			clk->ops->unprepare_unused(clk->hw);
 		else if (clk->ops->unprepare)
@@ -446,9 +458,9 @@ static void clk_unprepare_unused_subtree(struct clk *clk)
 }
 
 /* caller must hold prepare_lock */
-static void clk_disable_unused_subtree(struct clk *clk)
+static void clk_disable_unused_subtree(struct clk_core *clk)
 {
-	struct clk *child;
+	struct clk_core *child;
 	unsigned long flags;
 
 	hlist_for_each_entry(child, &clk->children, child_node)
@@ -467,7 +479,7 @@ static void clk_disable_unused_subtree(struct clk *clk)
 	 * sequence.  call .disable_unused if available, otherwise fall
 	 * back to .disable
 	 */
-	if (__clk_is_enabled(clk)) {
+	if (clk_core_is_enabled(clk)) {
 		if (clk->ops->disable_unused)
 			clk->ops->disable_unused(clk->hw);
 		else if (clk->ops->disable)
@@ -488,7 +500,7 @@ __setup("clk_ignore_unused", clk_ignore_unused_setup);
 
 static int clk_disable_unused(void)
 {
-	struct clk *clk;
+	struct clk_core *clk;
 
 	if (clk_ignore_unused) {
 		pr_warn("clk: Not disabling unused clocks\n");
@@ -519,48 +531,65 @@ late_initcall_sync(clk_disable_unused);
 
 const char *__clk_get_name(struct clk *clk)
 {
-	return !clk ? NULL : clk->name;
+	return !clk ? NULL : clk->core->name;
 }
 EXPORT_SYMBOL_GPL(__clk_get_name);
 
 struct clk_hw *__clk_get_hw(struct clk *clk)
 {
-	return !clk ? NULL : clk->hw;
+	return !clk ? NULL : clk->core->hw;
 }
 EXPORT_SYMBOL_GPL(__clk_get_hw);
 
 u8 __clk_get_num_parents(struct clk *clk)
 {
-	return !clk ? 0 : clk->num_parents;
+	return !clk ? 0 : clk->core->num_parents;
 }
 EXPORT_SYMBOL_GPL(__clk_get_num_parents);
 
 struct clk *__clk_get_parent(struct clk *clk)
 {
-	return !clk ? NULL : clk->parent;
+	if (!clk)
+		return NULL;
+
+	/* TODO: Create a per-user clk and change callers to call clk_put */
+	return !clk->core->parent ? NULL : clk->core->parent->hw->clk;
 }
 EXPORT_SYMBOL_GPL(__clk_get_parent);
 
-struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
+static struct clk_core *clk_core_get_parent_by_index(struct clk_core *clk,
+							 u8 index)
 {
 	if (!clk || index >= clk->num_parents)
 		return NULL;
 	else if (!clk->parents)
-		return __clk_lookup(clk->parent_names[index]);
+		return clk_core_lookup(clk->parent_names[index]);
 	else if (!clk->parents[index])
 		return clk->parents[index] =
-			__clk_lookup(clk->parent_names[index]);
+			clk_core_lookup(clk->parent_names[index]);
 	else
 		return clk->parents[index];
 }
+
+struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
+{
+	struct clk_core *parent;
+
+	if (!clk)
+		return NULL;
+
+	parent = clk_core_get_parent_by_index(clk->core, index);
+
+	return !parent ? NULL : parent->hw->clk;
+}
 EXPORT_SYMBOL_GPL(clk_get_parent_by_index);
 
 unsigned int __clk_get_enable_count(struct clk *clk)
 {
-	return !clk ? 0 : clk->enable_count;
+	return !clk ? 0 : clk->core->enable_count;
 }
 
-unsigned long __clk_get_rate(struct clk *clk)
+static unsigned long clk_core_get_rate_nolock(struct clk_core *clk)
 {
 	unsigned long ret;
 
@@ -580,9 +609,17 @@ unsigned long __clk_get_rate(struct clk *clk)
 out:
 	return ret;
 }
+
+unsigned long __clk_get_rate(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_get_rate_nolock(clk->core);
+}
 EXPORT_SYMBOL_GPL(__clk_get_rate);
 
-static unsigned long __clk_get_accuracy(struct clk *clk)
+static unsigned long __clk_get_accuracy(struct clk_core *clk)
 {
 	if (!clk)
 		return 0;
@@ -592,11 +629,11 @@ static unsigned long __clk_get_accuracy(struct clk *clk)
 
 unsigned long __clk_get_flags(struct clk *clk)
 {
-	return !clk ? 0 : clk->flags;
+	return !clk ? 0 : clk->core->flags;
 }
 EXPORT_SYMBOL_GPL(__clk_get_flags);
 
-bool __clk_is_prepared(struct clk *clk)
+static bool clk_core_is_prepared(struct clk_core *clk)
 {
 	int ret;
 
@@ -617,7 +654,15 @@ bool __clk_is_prepared(struct clk *clk)
 	return !!ret;
 }
 
-bool __clk_is_enabled(struct clk *clk)
+bool __clk_is_prepared(struct clk *clk)
+{
+	if (!clk)
+		return false;
+
+	return clk_core_is_prepared(clk->core);
+}
+
+static bool clk_core_is_enabled(struct clk_core *clk)
 {
 	int ret;
 
@@ -637,12 +682,21 @@ bool __clk_is_enabled(struct clk *clk)
 out:
 	return !!ret;
 }
+
+bool __clk_is_enabled(struct clk *clk)
+{
+	if (!clk)
+		return false;
+
+	return clk_core_is_enabled(clk->core);
+}
 EXPORT_SYMBOL_GPL(__clk_is_enabled);
 
-static struct clk *__clk_lookup_subtree(const char *name, struct clk *clk)
+static struct clk_core *__clk_lookup_subtree(const char *name,
+					     struct clk_core *clk)
 {
-	struct clk *child;
-	struct clk *ret;
+	struct clk_core *child;
+	struct clk_core *ret;
 
 	if (!strcmp(clk->name, name))
 		return clk;
@@ -656,10 +710,10 @@ static struct clk *__clk_lookup_subtree(const char *name, struct clk *clk)
 	return NULL;
 }
 
-struct clk *__clk_lookup(const char *name)
+static struct clk_core *clk_core_lookup(const char *name)
 {
-	struct clk *root_clk;
-	struct clk *ret;
+	struct clk_core *root_clk;
+	struct clk_core *ret;
 
 	if (!name)
 		return NULL;
@@ -696,32 +750,32 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
 			     struct clk_hw **best_parent_p,
 			     unsigned long flags)
 {
-	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
+	struct clk_core *core = hw->core, *parent, *best_parent = NULL;
 	int i, num_parents;
 	unsigned long parent_rate, best = 0;
 
 	/* if NO_REPARENT flag set, pass through to current parent */
-	if (clk->flags & CLK_SET_RATE_NO_REPARENT) {
-		parent = clk->parent;
-		if (clk->flags & CLK_SET_RATE_PARENT)
-			best = __clk_round_rate(parent, rate);
+	if (core->flags & CLK_SET_RATE_NO_REPARENT) {
+		parent = core->parent;
+		if (core->flags & CLK_SET_RATE_PARENT)
+			best = clk_core_round_rate_nolock(parent, rate);
 		else if (parent)
-			best = __clk_get_rate(parent);
+			best = clk_core_get_rate_nolock(parent);
 		else
-			best = __clk_get_rate(clk);
+			best = clk_core_get_rate_nolock(core);
 		goto out;
 	}
 
 	/* find the parent that can provide the fastest rate <= rate */
-	num_parents = clk->num_parents;
+	num_parents = core->num_parents;
 	for (i = 0; i < num_parents; i++) {
-		parent = clk_get_parent_by_index(clk, i);
+		parent = clk_core_get_parent_by_index(core, i);
 		if (!parent)
 			continue;
-		if (clk->flags & CLK_SET_RATE_PARENT)
-			parent_rate = __clk_round_rate(parent, rate);
+		if (core->flags & CLK_SET_RATE_PARENT)
+			parent_rate = clk_core_round_rate_nolock(parent, rate);
 		else
-			parent_rate = __clk_get_rate(parent);
+			parent_rate = clk_core_get_rate_nolock(parent);
 		if (mux_is_better_rate(rate, parent_rate, best, flags)) {
 			best_parent = parent;
 			best = parent_rate;
@@ -736,6 +790,13 @@ clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
 	return best;
 }
 
+struct clk *__clk_lookup(const char *name)
+{
+	struct clk_core *core = clk_core_lookup(name);
+
+	return !core ? NULL : core->hw->clk;
+}
+
 /*
  * Helper for finding best parent to provide a given frequency. This can be used
  * directly as a determine_rate callback (e.g. for a mux), or from a more
@@ -762,7 +823,7 @@ EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
 
 /***        clk api        ***/
 
-void __clk_unprepare(struct clk *clk)
+static void clk_core_unprepare(struct clk_core *clk)
 {
 	if (!clk)
 		return;
@@ -778,7 +839,7 @@ void __clk_unprepare(struct clk *clk)
 	if (clk->ops->unprepare)
 		clk->ops->unprepare(clk->hw);
 
-	__clk_unprepare(clk->parent);
+	clk_core_unprepare(clk->parent);
 }
 
 /**
@@ -798,12 +859,12 @@ void clk_unprepare(struct clk *clk)
 		return;
 
 	clk_prepare_lock();
-	__clk_unprepare(clk);
+	clk_core_unprepare(clk->core);
 	clk_prepare_unlock();
 }
 EXPORT_SYMBOL_GPL(clk_unprepare);
 
-int __clk_prepare(struct clk *clk)
+static int clk_core_prepare(struct clk_core *clk)
 {
 	int ret = 0;
 
@@ -811,14 +872,14 @@ int __clk_prepare(struct clk *clk)
 		return 0;
 
 	if (clk->prepare_count == 0) {
-		ret = __clk_prepare(clk->parent);
+		ret = clk_core_prepare(clk->parent);
 		if (ret)
 			return ret;
 
 		if (clk->ops->prepare) {
 			ret = clk->ops->prepare(clk->hw);
 			if (ret) {
-				__clk_unprepare(clk->parent);
+				clk_core_unprepare(clk->parent);
 				return ret;
 			}
 		}
@@ -845,15 +906,18 @@ int clk_prepare(struct clk *clk)
 {
 	int ret;
 
+	if (!clk)
+		return 0;
+
 	clk_prepare_lock();
-	ret = __clk_prepare(clk);
+	ret = clk_core_prepare(clk->core);
 	clk_prepare_unlock();
 
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_prepare);
 
-static void __clk_disable(struct clk *clk)
+static void clk_core_disable(struct clk_core *clk)
 {
 	if (!clk)
 		return;
@@ -867,7 +931,15 @@ static void __clk_disable(struct clk *clk)
 	if (clk->ops->disable)
 		clk->ops->disable(clk->hw);
 
-	__clk_disable(clk->parent);
+	clk_core_disable(clk->parent);
+}
+
+static void __clk_disable(struct clk *clk)
+{
+	if (!clk)
+		return;
+
+	clk_core_disable(clk->core);
 }
 
 /**
@@ -895,7 +967,7 @@ void clk_disable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_disable);
 
-static int __clk_enable(struct clk *clk)
+static int clk_core_enable(struct clk_core *clk)
 {
 	int ret = 0;
 
@@ -906,7 +978,7 @@ static int __clk_enable(struct clk *clk)
 		return -ESHUTDOWN;
 
 	if (clk->enable_count == 0) {
-		ret = __clk_enable(clk->parent);
+		ret = clk_core_enable(clk->parent);
 
 		if (ret)
 			return ret;
@@ -914,7 +986,7 @@ static int __clk_enable(struct clk *clk)
 		if (clk->ops->enable) {
 			ret = clk->ops->enable(clk->hw);
 			if (ret) {
-				__clk_disable(clk->parent);
+				clk_core_disable(clk->parent);
 				return ret;
 			}
 		}
@@ -924,6 +996,14 @@ static int __clk_enable(struct clk *clk)
 	return 0;
 }
 
+static int __clk_enable(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_enable(clk->core);
+}
+
 /**
  * clk_enable - ungate a clock
  * @clk: the clk being ungated
@@ -950,17 +1030,11 @@ int clk_enable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_enable);
 
-/**
- * __clk_round_rate - round the given rate for a clk
- * @clk: round the rate of this clock
- * @rate: the rate which is to be rounded
- *
- * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate
- */
-unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
+static unsigned long clk_core_round_rate_nolock(struct clk_core *clk,
+						unsigned long rate)
 {
 	unsigned long parent_rate = 0;
-	struct clk *parent;
+	struct clk_core *parent;
 	struct clk_hw *parent_hw;
 
 	if (!clk)
@@ -977,10 +1051,25 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 	} else if (clk->ops->round_rate)
 		return clk->ops->round_rate(clk->hw, rate, &parent_rate);
 	else if (clk->flags & CLK_SET_RATE_PARENT)
-		return __clk_round_rate(clk->parent, rate);
+		return clk_core_round_rate_nolock(clk->parent, rate);
 	else
 		return clk->rate;
 }
+
+/**
+ * __clk_round_rate - round the given rate for a clk
+ * @clk: round the rate of this clock
+ * @rate: the rate which is to be rounded
+ *
+ * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate
+ */
+unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_round_rate_nolock(clk->core, rate);
+}
 EXPORT_SYMBOL_GPL(__clk_round_rate);
 
 /**
@@ -996,8 +1085,11 @@ long clk_round_rate(struct clk *clk, unsigned long rate)
 {
 	unsigned long ret;
 
+	if (!clk)
+		return 0;
+
 	clk_prepare_lock();
-	ret = __clk_round_rate(clk, rate);
+	ret = clk_core_round_rate_nolock(clk->core, rate);
 	clk_prepare_unlock();
 
 	return ret;
@@ -1018,22 +1110,21 @@ EXPORT_SYMBOL_GPL(clk_round_rate);
  * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if
  * a driver returns that.
  */
-static int __clk_notify(struct clk *clk, unsigned long msg,
+static int __clk_notify(struct clk_core *clk, unsigned long msg,
 		unsigned long old_rate, unsigned long new_rate)
 {
 	struct clk_notifier *cn;
 	struct clk_notifier_data cnd;
 	int ret = NOTIFY_DONE;
 
-	cnd.clk = clk;
 	cnd.old_rate = old_rate;
 	cnd.new_rate = new_rate;
 
 	list_for_each_entry(cn, &clk_notifier_list, node) {
-		if (cn->clk == clk) {
+		if (cn->clk->core == clk) {
+			cnd.clk = cn->clk;
 			ret = srcu_notifier_call_chain(&cn->notifier_head, msg,
 					&cnd);
-			break;
 		}
 	}
 
@@ -1051,10 +1142,10 @@ static int __clk_notify(struct clk *clk, unsigned long msg,
  *
  * Caller must hold prepare_lock.
  */
-static void __clk_recalc_accuracies(struct clk *clk)
+static void __clk_recalc_accuracies(struct clk_core *clk)
 {
 	unsigned long parent_accuracy = 0;
-	struct clk *child;
+	struct clk_core *child;
 
 	if (clk->parent)
 		parent_accuracy = clk->parent->accuracy;
@@ -1069,6 +1160,20 @@ static void __clk_recalc_accuracies(struct clk *clk)
 		__clk_recalc_accuracies(child);
 }
 
+static long clk_core_get_accuracy(struct clk_core *clk)
+{
+	unsigned long accuracy;
+
+	clk_prepare_lock();
+	if (clk && (clk->flags & CLK_GET_ACCURACY_NOCACHE))
+		__clk_recalc_accuracies(clk);
+
+	accuracy = __clk_get_accuracy(clk);
+	clk_prepare_unlock();
+
+	return accuracy;
+}
+
 /**
  * clk_get_accuracy - return the accuracy of clk
  * @clk: the clk whose accuracy is being returned
@@ -1080,20 +1185,15 @@ static void __clk_recalc_accuracies(struct clk *clk)
  */
 long clk_get_accuracy(struct clk *clk)
 {
-	unsigned long accuracy;
-
-	clk_prepare_lock();
-	if (clk && (clk->flags & CLK_GET_ACCURACY_NOCACHE))
-		__clk_recalc_accuracies(clk);
-
-	accuracy = __clk_get_accuracy(clk);
-	clk_prepare_unlock();
+	if (!clk)
+		return 0;
 
-	return accuracy;
+	return clk_core_get_accuracy(clk->core);
 }
 EXPORT_SYMBOL_GPL(clk_get_accuracy);
 
-static unsigned long clk_recalc(struct clk *clk, unsigned long parent_rate)
+static unsigned long clk_recalc(struct clk_core *clk,
+				unsigned long parent_rate)
 {
 	if (clk->ops->recalc_rate)
 		return clk->ops->recalc_rate(clk->hw, parent_rate);
@@ -1114,11 +1214,11 @@ static unsigned long clk_recalc(struct clk *clk, unsigned long parent_rate)
  *
  * Caller must hold prepare_lock.
  */
-static void __clk_recalc_rates(struct clk *clk, unsigned long msg)
+static void __clk_recalc_rates(struct clk_core *clk, unsigned long msg)
 {
 	unsigned long old_rate;
 	unsigned long parent_rate = 0;
-	struct clk *child;
+	struct clk_core *child;
 
 	old_rate = clk->rate;
 
@@ -1138,15 +1238,7 @@ static void __clk_recalc_rates(struct clk *clk, unsigned long msg)
 		__clk_recalc_rates(child, msg);
 }
 
-/**
- * clk_get_rate - return the rate of clk
- * @clk: the clk whose rate is being returned
- *
- * Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag
- * is set, which means a recalc_rate will be issued.
- * If clk is NULL then returns 0.
- */
-unsigned long clk_get_rate(struct clk *clk)
+static unsigned long clk_core_get_rate(struct clk_core *clk)
 {
 	unsigned long rate;
 
@@ -1155,14 +1247,32 @@ unsigned long clk_get_rate(struct clk *clk)
 	if (clk && (clk->flags & CLK_GET_RATE_NOCACHE))
 		__clk_recalc_rates(clk, 0);
 
-	rate = __clk_get_rate(clk);
+	rate = clk_core_get_rate_nolock(clk);
 	clk_prepare_unlock();
 
 	return rate;
 }
+EXPORT_SYMBOL_GPL(clk_core_get_rate);
+
+/**
+ * clk_get_rate - return the rate of clk
+ * @clk: the clk whose rate is being returned
+ *
+ * Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag
+ * is set, which means a recalc_rate will be issued.
+ * If clk is NULL then returns 0.
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_get_rate(clk->core);
+}
 EXPORT_SYMBOL_GPL(clk_get_rate);
 
-static int clk_fetch_parent_index(struct clk *clk, struct clk *parent)
+static int clk_fetch_parent_index(struct clk_core *clk,
+				  struct clk_core *parent)
 {
 	int i;
 
@@ -1176,7 +1286,7 @@ static int clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 	/*
 	 * find index of new parent clock using cached parent ptrs,
 	 * or if not yet cached, use string name comparison and cache
-	 * them now to avoid future calls to __clk_lookup.
+	 * them now to avoid future calls to clk_core_lookup.
 	 */
 	for (i = 0; i < clk->num_parents; i++) {
 		if (clk->parents[i] == parent)
@@ -1186,7 +1296,7 @@ static int clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 			continue;
 
 		if (!strcmp(clk->parent_names[i], parent->name)) {
-			clk->parents[i] = __clk_lookup(parent->name);
+			clk->parents[i] = clk_core_lookup(parent->name);
 			return i;
 		}
 	}
@@ -1194,7 +1304,7 @@ static int clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 	return -EINVAL;
 }
 
-static void clk_reparent(struct clk *clk, struct clk *new_parent)
+static void clk_reparent(struct clk_core *clk, struct clk_core *new_parent)
 {
 	hlist_del(&clk->child_node);
 
@@ -1211,10 +1321,11 @@ static void clk_reparent(struct clk *clk, struct clk *new_parent)
 	clk->parent = new_parent;
 }
 
-static struct clk *__clk_set_parent_before(struct clk *clk, struct clk *parent)
+static struct clk_core *__clk_set_parent_before(struct clk_core *clk,
+					   struct clk_core *parent)
 {
 	unsigned long flags;
-	struct clk *old_parent = clk->parent;
+	struct clk_core *old_parent = clk->parent;
 
 	/*
 	 * Migrate prepare state between parents and prevent race with
@@ -1234,9 +1345,9 @@ static struct clk *__clk_set_parent_before(struct clk *clk, struct clk *parent)
 	 * See also: Comment for clk_set_parent() below.
 	 */
 	if (clk->prepare_count) {
-		__clk_prepare(parent);
-		clk_enable(parent);
-		clk_enable(clk);
+		clk_core_prepare(parent);
+		clk_core_enable(parent);
+		clk_core_enable(clk);
 	}
 
 	/* update the clk tree topology */
@@ -1247,25 +1358,27 @@ static struct clk *__clk_set_parent_before(struct clk *clk, struct clk *parent)
 	return old_parent;
 }
 
-static void __clk_set_parent_after(struct clk *clk, struct clk *parent,
-		struct clk *old_parent)
+static void __clk_set_parent_after(struct clk_core *core,
+				   struct clk_core *parent,
+				   struct clk_core *old_parent)
 {
 	/*
 	 * Finish the migration of prepare state and undo the changes done
 	 * for preventing a race with clk_enable().
 	 */
-	if (clk->prepare_count) {
-		clk_disable(clk);
-		clk_disable(old_parent);
-		__clk_unprepare(old_parent);
+	if (core->prepare_count) {
+		clk_core_disable(core);
+		clk_core_disable(old_parent);
+		clk_core_unprepare(old_parent);
 	}
 }
 
-static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
+static int __clk_set_parent(struct clk_core *clk, struct clk_core *parent,
+			    u8 p_index)
 {
 	unsigned long flags;
 	int ret = 0;
-	struct clk *old_parent;
+	struct clk_core *old_parent;
 
 	old_parent = __clk_set_parent_before(clk, parent);
 
@@ -1279,9 +1392,9 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
 		clk_enable_unlock(flags);
 
 		if (clk->prepare_count) {
-			clk_disable(clk);
-			clk_disable(parent);
-			__clk_unprepare(parent);
+			clk_core_disable(clk);
+			clk_core_disable(parent);
+			clk_core_unprepare(parent);
 		}
 		return ret;
 	}
@@ -1307,9 +1420,10 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
  *
  * Caller must hold prepare_lock.
  */
-static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
+static int __clk_speculate_rates(struct clk_core *clk,
+				 unsigned long parent_rate)
 {
-	struct clk *child;
+	struct clk_core *child;
 	unsigned long new_rate;
 	int ret = NOTIFY_DONE;
 
@@ -1335,10 +1449,10 @@ static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 	return ret;
 }
 
-static void clk_calc_subtree(struct clk *clk, unsigned long new_rate,
-			     struct clk *new_parent, u8 p_index)
+static void clk_calc_subtree(struct clk_core *clk, unsigned long new_rate,
+			     struct clk_core *new_parent, u8 p_index)
 {
-	struct clk *child;
+	struct clk_core *child;
 
 	clk->new_rate = new_rate;
 	clk->new_parent = new_parent;
@@ -1358,10 +1472,11 @@ static void clk_calc_subtree(struct clk *clk, unsigned long new_rate,
  * calculate the new rates returning the topmost clock that has to be
  * changed.
  */
-static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
+static struct clk_core *clk_calc_new_rates(struct clk_core *clk,
+					   unsigned long rate)
 {
-	struct clk *top = clk;
-	struct clk *old_parent, *parent;
+	struct clk_core *top = clk;
+	struct clk_core *old_parent, *parent;
 	struct clk_hw *parent_hw;
 	unsigned long best_parent_rate = 0;
 	unsigned long new_rate;
@@ -1382,7 +1497,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 		new_rate = clk->ops->determine_rate(clk->hw, rate,
 						    &best_parent_rate,
 						    &parent_hw);
-		parent = parent_hw ? parent_hw->clk : NULL;
+		parent = parent_hw ? parent_hw->core : NULL;
 	} else if (clk->ops->round_rate) {
 		new_rate = clk->ops->round_rate(clk->hw, rate,
 						&best_parent_rate);
@@ -1430,9 +1545,10 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
  * so that in case of an error we can walk down the whole tree again and
  * abort the change.
  */
-static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long event)
+static struct clk_core *clk_propagate_rate_change(struct clk_core *clk,
+						  unsigned long event)
 {
-	struct clk *child, *tmp_clk, *fail_clk = NULL;
+	struct clk_core *child, *tmp_clk, *fail_clk = NULL;
 	int ret = NOTIFY_DONE;
 
 	if (clk->rate == clk->new_rate)
@@ -1467,14 +1583,14 @@ static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long even
  * walk down a subtree and set the new rates notifying the rate
  * change on the way
  */
-static void clk_change_rate(struct clk *clk)
+static void clk_change_rate(struct clk_core *clk)
 {
-	struct clk *child;
+	struct clk_core *child;
 	struct hlist_node *tmp;
 	unsigned long old_rate;
 	unsigned long best_parent_rate = 0;
 	bool skip_set_rate = false;
-	struct clk *old_parent;
+	struct clk_core *old_parent;
 
 	old_rate = clk->rate;
 
@@ -1545,7 +1661,7 @@ static void clk_change_rate(struct clk *clk)
  */
 int clk_set_rate(struct clk *clk, unsigned long rate)
 {
-	struct clk *top, *fail_clk;
+	struct clk_core *top, *fail_clk;
 	int ret = 0;
 
 	if (!clk)
@@ -1558,13 +1674,14 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	if (rate == clk_get_rate(clk))
 		goto out;
 
-	if ((clk->flags & CLK_SET_RATE_GATE) && clk->prepare_count) {
+	if ((clk->core->flags & CLK_SET_RATE_GATE) &&
+	    clk->core->prepare_count) {
 		ret = -EBUSY;
 		goto out;
 	}
 
 	/* calculate new rates and get the topmost changed clock */
-	top = clk_calc_new_rates(clk, rate);
+	top = clk_calc_new_rates(clk->core, rate);
 	if (!top) {
 		ret = -EINVAL;
 		goto out;
@@ -1615,11 +1732,11 @@ EXPORT_SYMBOL_GPL(clk_get_parent);
  *
  * For single-parent clocks without .get_parent, first check to see if the
  * .parents array exists, and if so use it to avoid an expensive tree
- * traversal.  If .parents does not exist then walk the tree with __clk_lookup.
+ * traversal.  If .parents does not exist then walk the tree.
  */
-static struct clk *__clk_init_parent(struct clk *clk)
+static struct clk_core *__clk_init_parent(struct clk_core *clk)
 {
-	struct clk *ret = NULL;
+	struct clk_core *ret = NULL;
 	u8 index;
 
 	/* handle the trivial cases */
@@ -1629,7 +1746,7 @@ static struct clk *__clk_init_parent(struct clk *clk)
 
 	if (clk->num_parents == 1) {
 		if (IS_ERR_OR_NULL(clk->parent))
-			clk->parent = __clk_lookup(clk->parent_names[0]);
+			clk->parent = clk_core_lookup(clk->parent_names[0]);
 		ret = clk->parent;
 		goto out;
 	}
@@ -1643,8 +1760,8 @@ static struct clk *__clk_init_parent(struct clk *clk)
 
 	/*
 	 * Do our best to cache parent clocks in clk->parents.  This prevents
-	 * unnecessary and expensive calls to __clk_lookup.  We don't set
-	 * clk->parent here; that is done by the calling function
+	 * unnecessary and expensive lookups.  We don't set clk->parent here;
+	 * that is done by the calling function.
 	 */
 
 	index = clk->ops->get_parent(clk->hw);
@@ -1654,13 +1771,14 @@ static struct clk *__clk_init_parent(struct clk *clk)
 			kcalloc(clk->num_parents, sizeof(struct clk *),
 					GFP_KERNEL);
 
-	ret = clk_get_parent_by_index(clk, index);
+	ret = clk_core_get_parent_by_index(clk, index);
 
 out:
 	return ret;
 }
 
-void __clk_reparent(struct clk *clk, struct clk *new_parent)
+static void clk_core_reparent(struct clk_core *clk,
+				  struct clk_core *new_parent)
 {
 	clk_reparent(clk, new_parent);
 	__clk_recalc_accuracies(clk);
@@ -1679,42 +1797,29 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
  */
 bool clk_has_parent(struct clk *clk, struct clk *parent)
 {
+	struct clk_core *core, *parent_core;
 	unsigned int i;
 
 	/* NULL clocks should be nops, so return success if either is NULL. */
 	if (!clk || !parent)
 		return true;
 
+	core = clk->core;
+	parent_core = parent->core;
+
 	/* Optimize for the case where the parent is already the parent. */
-	if (clk->parent == parent)
+	if (core->parent == parent_core)
 		return true;
 
-	for (i = 0; i < clk->num_parents; i++)
-		if (strcmp(clk->parent_names[i], parent->name) == 0)
+	for (i = 0; i < core->num_parents; i++)
+		if (strcmp(core->parent_names[i], parent_core->name) == 0)
 			return true;
 
 	return false;
 }
 EXPORT_SYMBOL_GPL(clk_has_parent);
 
-/**
- * clk_set_parent - switch the parent of a mux clk
- * @clk: the mux clk whose input we are switching
- * @parent: the new input to clk
- *
- * Re-parent clk to use parent as its new input source.  If clk is in
- * prepared state, the clk will get enabled for the duration of this call. If
- * that's not acceptable for a specific clk (Eg: the consumer can't handle
- * that, the reparenting is glitchy in hardware, etc), use the
- * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.
- *
- * After successfully changing clk's parent clk_set_parent will update the
- * clk topology, sysfs topology and propagate rate recalculation via
- * __clk_recalc_rates.
- *
- * Returns 0 on success, -EERROR otherwise.
- */
-int clk_set_parent(struct clk *clk, struct clk *parent)
+static int clk_core_set_parent(struct clk_core *clk, struct clk_core *parent)
 {
 	int ret = 0;
 	int p_index = 0;
@@ -1774,6 +1879,31 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 
 	return ret;
 }
+
+/**
+ * clk_set_parent - switch the parent of a mux clk
+ * @clk: the mux clk whose input we are switching
+ * @parent: the new input to clk
+ *
+ * Re-parent clk to use parent as its new input source.  If clk is in
+ * prepared state, the clk will get enabled for the duration of this call. If
+ * that's not acceptable for a specific clk (Eg: the consumer can't handle
+ * that, the reparenting is glitchy in hardware, etc), use the
+ * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.
+ *
+ * After successfully changing clk's parent clk_set_parent will update the
+ * clk topology, sysfs topology and propagate rate recalculation via
+ * __clk_recalc_rates.
+ *
+ * Returns 0 on success, -EERROR otherwise.
+ */
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_set_parent(clk->core, parent ? parent->core : NULL);
+}
 EXPORT_SYMBOL_GPL(clk_set_parent);
 
 /**
@@ -1810,13 +1940,13 @@ int clk_set_phase(struct clk *clk, int degrees)
 
 	clk_prepare_lock();
 
-	if (!clk->ops->set_phase)
+	if (!clk->core->ops->set_phase)
 		goto out_unlock;
 
-	ret = clk->ops->set_phase(clk->hw, degrees);
+	ret = clk->core->ops->set_phase(clk->core->hw, degrees);
 
 	if (!ret)
-		clk->phase = degrees;
+		clk->core->phase = degrees;
 
 out_unlock:
 	clk_prepare_unlock();
@@ -1826,14 +1956,7 @@ int clk_set_phase(struct clk *clk, int degrees)
 }
 EXPORT_SYMBOL_GPL(clk_set_phase);
 
-/**
- * clk_get_phase - return the phase shift of a clock signal
- * @clk: clock signal source
- *
- * Returns the phase shift of a clock node in degrees, otherwise returns
- * -EERROR.
- */
-int clk_get_phase(struct clk *clk)
+static int clk_core_get_phase(struct clk_core *clk)
 {
 	int ret = 0;
 
@@ -1849,27 +1972,45 @@ int clk_get_phase(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_phase);
 
+/**
+ * clk_get_phase - return the phase shift of a clock signal
+ * @clk: clock signal source
+ *
+ * Returns the phase shift of a clock node in degrees, otherwise returns
+ * -EERROR.
+ */
+int clk_get_phase(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_get_phase(clk->core);
+}
+
 /**
  * __clk_init - initialize the data structures in a struct clk
  * @dev:	device initializing this clk, placeholder for now
  * @clk:	clk being initialized
  *
- * Initializes the lists in struct clk, queries the hardware for the
+ * Initializes the lists in struct clk_core, queries the hardware for the
  * parent and rate and sets them both.
  */
-int __clk_init(struct device *dev, struct clk *clk)
+int __clk_init(struct device *dev, struct clk *clk_user)
 {
 	int i, ret = 0;
-	struct clk *orphan;
+	struct clk_core *orphan;
 	struct hlist_node *tmp2;
+	struct clk_core *clk;
 
-	if (!clk)
+	if (!clk_user)
 		return -EINVAL;
 
+	clk = clk_user->core;
+
 	clk_prepare_lock();
 
 	/* check to see if a clock with this name is already registered */
-	if (__clk_lookup(clk->name)) {
+	if (clk_core_lookup(clk->name)) {
 		pr_debug("%s: clk %s already initialized\n",
 				__func__, clk->name);
 		ret = -EEXIST;
@@ -1921,7 +2062,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 		clk->parents = kcalloc(clk->num_parents, sizeof(struct clk *),
 					GFP_KERNEL);
 		/*
-		 * __clk_lookup returns NULL for parents that have not been
+		 * clk_core_lookup returns NULL for parents that have not been
 		 * clk_init'd; thus any access to clk->parents[] must check
 		 * for a NULL pointer.  We can always perform lazy lookups for
 		 * missing parents later on.
@@ -1929,7 +2070,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 		if (clk->parents)
 			for (i = 0; i < clk->num_parents; i++)
 				clk->parents[i] =
-					__clk_lookup(clk->parent_names[i]);
+					clk_core_lookup(clk->parent_names[i]);
 	}
 
 	clk->parent = __clk_init_parent(clk);
@@ -1985,7 +2126,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 	 */
 	if (clk->ops->recalc_rate)
 		clk->rate = clk->ops->recalc_rate(clk->hw,
-				__clk_get_rate(clk->parent));
+				clk_core_get_rate_nolock(clk->parent));
 	else if (clk->parent)
 		clk->rate = clk->parent->rate;
 	else
@@ -1999,13 +2140,13 @@ int __clk_init(struct device *dev, struct clk *clk)
 		if (orphan->num_parents && orphan->ops->get_parent) {
 			i = orphan->ops->get_parent(orphan->hw);
 			if (!strcmp(clk->name, orphan->parent_names[i]))
-				__clk_reparent(orphan, clk);
+				clk_core_reparent(orphan, clk);
 			continue;
 		}
 
 		for (i = 0; i < orphan->num_parents; i++)
 			if (!strcmp(clk->name, orphan->parent_names[i])) {
-				__clk_reparent(orphan, clk);
+				clk_core_reparent(orphan, clk);
 				break;
 			}
 	 }
@@ -2031,6 +2172,26 @@ int __clk_init(struct device *dev, struct clk *clk)
 	return ret;
 }
 
+struct clk *__clk_create_clk(struct clk_hw *hw, const char *dev_id,
+			     const char *con_id)
+{
+	struct clk *clk;
+
+	/* This is to allow this function to be chained to others */
+	if (!hw || IS_ERR(hw))
+		return (struct clk *) hw;
+
+	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk)
+		return ERR_PTR(-ENOMEM);
+
+	clk->core = hw->core;
+	clk->dev_id = dev_id;
+	clk->con_id = con_id;
+
+	return clk;
+}
+
 /**
  * clk_register - allocate a new clock, register it and return an opaque cookie
  * @dev: device that is registering this clock
@@ -2045,7 +2206,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 {
 	int i, ret;
-	struct clk *clk;
+	struct clk_core *clk;
 
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 	if (!clk) {
@@ -2066,7 +2227,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 	clk->hw = hw;
 	clk->flags = hw->init->flags;
 	clk->num_parents = hw->init->num_parents;
-	hw->clk = clk;
+	hw->core = clk;
 
 	/* allocate local copy in case parent_names is __initdata */
 	clk->parent_names = kcalloc(clk->num_parents, sizeof(char *),
@@ -2090,10 +2251,19 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 		}
 	}
 
-	ret = __clk_init(dev, clk);
+	hw->clk = __clk_create_clk(hw, NULL, NULL);
+	if (IS_ERR(hw->clk)) {
+		pr_err("%s: could not allocate per-user clk\n", __func__);
+		ret = PTR_ERR(hw->clk);
+		goto fail_parent_names_copy;
+	}
+
+	ret = __clk_init(dev, hw->clk);
 	if (!ret)
-		return clk;
+		return hw->clk;
 
+	kfree(hw->clk);
+	hw->clk = NULL;
 fail_parent_names_copy:
 	while (--i >= 0)
 		kfree(clk->parent_names[i]);
@@ -2113,7 +2283,7 @@ EXPORT_SYMBOL_GPL(clk_register);
  */
 static void __clk_release(struct kref *ref)
 {
-	struct clk *clk = container_of(ref, struct clk, ref);
+	struct clk_core *clk = container_of(ref, struct clk_core, ref);
 	int i = clk->num_parents;
 
 	kfree(clk->parents);
@@ -2171,12 +2341,13 @@ void clk_unregister(struct clk *clk)
 	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
 		return;
 
-	clk_debug_unregister(clk);
+	clk_debug_unregister(clk->core);
 
 	clk_prepare_lock();
 
-	if (clk->ops == &clk_nodrv_ops) {
-		pr_err("%s: unregistered clock: %s\n", __func__, clk->name);
+	if (clk->core->ops == &clk_nodrv_ops) {
+		pr_err("%s: unregistered clock: %s\n", __func__,
+		       clk->core->name);
 		return;
 	}
 	/*
@@ -2184,24 +2355,25 @@ void clk_unregister(struct clk *clk)
 	 * a reference to this clock.
 	 */
 	flags = clk_enable_lock();
-	clk->ops = &clk_nodrv_ops;
+	clk->core->ops = &clk_nodrv_ops;
 	clk_enable_unlock(flags);
 
-	if (!hlist_empty(&clk->children)) {
-		struct clk *child;
+	if (!hlist_empty(&clk->core->children)) {
+		struct clk_core *child;
 		struct hlist_node *t;
 
 		/* Reparent all children to the orphan list. */
-		hlist_for_each_entry_safe(child, t, &clk->children, child_node)
-			clk_set_parent(child, NULL);
+		hlist_for_each_entry_safe(child, t, &clk->core->children,
+					  child_node)
+			clk_core_set_parent(child, NULL);
 	}
 
-	hlist_del_init(&clk->child_node);
+	hlist_del_init(&clk->core->child_node);
 
-	if (clk->prepare_count)
+	if (clk->core->prepare_count)
 		pr_warn("%s: unregistering prepared clock: %s\n",
-					__func__, clk->name);
-	kref_put(&clk->ref, __clk_release);
+					__func__, clk->core->name);
+	kref_put(&clk->core->ref, __clk_release);
 
 	clk_prepare_unlock();
 }
@@ -2269,30 +2441,39 @@ EXPORT_SYMBOL_GPL(devm_clk_unregister);
  */
 int __clk_get(struct clk *clk)
 {
-	if (clk) {
-		if (!try_module_get(clk->owner))
+	struct clk_core *core = !clk ? NULL : clk->core;
+
+	if (core) {
+		if (!try_module_get(core->owner))
 			return 0;
 
-		kref_get(&clk->ref);
+		kref_get(&core->ref);
 	}
 	return 1;
 }
 
-void __clk_put(struct clk *clk)
+static void clk_core_put(struct clk_core *core)
 {
 	struct module *owner;
 
-	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
-		return;
+	owner = core->owner;
 
 	clk_prepare_lock();
-	owner = clk->owner;
-	kref_put(&clk->ref, __clk_release);
+	kref_put(&core->ref, __clk_release);
 	clk_prepare_unlock();
 
 	module_put(owner);
 }
 
+void __clk_put(struct clk *clk)
+{
+	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
+		return;
+
+	clk_core_put(clk->core);
+	kfree(clk);
+}
+
 /***        clk rate change notifiers        ***/
 
 /**
@@ -2345,7 +2526,7 @@ int clk_notifier_register(struct clk *clk, struct notifier_block *nb)
 
 	ret = srcu_notifier_chain_register(&cn->notifier_head, nb);
 
-	clk->notifier_count++;
+	clk->core->notifier_count++;
 
 out:
 	clk_prepare_unlock();
@@ -2382,7 +2563,7 @@ int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)
 	if (cn->clk == clk) {
 		ret = srcu_notifier_chain_unregister(&cn->notifier_head, nb);
 
-		clk->notifier_count--;
+		clk->core->notifier_count--;
 
 		/* XXX the notifier code should handle this better */
 		if (!cn->notifier_head.head) {

commit af0f349b2996f9f3d83e5aac1edf58fff727a0e0
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Jan 23 12:03:29 2015 +0100

    clk: Remove __clk_register
    
    As it has never been used.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 05986e389bf8..b701e7c195e4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2031,48 +2031,6 @@ int __clk_init(struct device *dev, struct clk *clk)
 	return ret;
 }
 
-/**
- * __clk_register - register a clock and return a cookie.
- *
- * Same as clk_register, except that the .clk field inside hw shall point to a
- * preallocated (generally statically allocated) struct clk. None of the fields
- * of the struct clk need to be initialized.
- *
- * The data pointed to by .init and .clk field shall NOT be marked as init
- * data.
- *
- * __clk_register is only exposed via clk-private.h and is intended for use with
- * very large numbers of clocks that need to be statically initialized.  It is
- * a layering violation to include clk-private.h from any code which implements
- * a clock's .ops; as such any statically initialized clock data MUST be in a
- * separate C file from the logic that implements its operations.  Returns 0
- * on success, otherwise an error code.
- */
-struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
-{
-	int ret;
-	struct clk *clk;
-
-	clk = hw->clk;
-	clk->name = hw->init->name;
-	clk->ops = hw->init->ops;
-	clk->hw = hw;
-	clk->flags = hw->init->flags;
-	clk->parent_names = hw->init->parent_names;
-	clk->num_parents = hw->init->num_parents;
-	if (dev && dev->driver)
-		clk->owner = dev->driver->owner;
-	else
-		clk->owner = NULL;
-
-	ret = __clk_init(dev, clk);
-	if (ret)
-		return ERR_PTR(ret);
-
-	return clk;
-}
-EXPORT_SYMBOL_GPL(__clk_register);
-
 /**
  * clk_register - allocate a new clock, register it and return an opaque cookie
  * @dev: device that is registering this clock

commit c440525cb96780c369879e15083c29a479eb0598
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Jan 23 12:03:28 2015 +0100

    clk: Remove unneeded NULL checks
    
    As clk_unprepare_unused_subtree and clk_disable_unused_subtree are
    always called with a valid struct clk.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index aa8a9d2d0b73..05986e389bf8 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -428,9 +428,6 @@ static void clk_unprepare_unused_subtree(struct clk *clk)
 {
 	struct clk *child;
 
-	if (!clk)
-		return;
-
 	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_unprepare_unused_subtree(child);
 
@@ -454,9 +451,6 @@ static void clk_disable_unused_subtree(struct clk *clk)
 	struct clk *child;
 	unsigned long flags;
 
-	if (!clk)
-		goto out;
-
 	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_disable_unused_subtree(child);
 
@@ -482,9 +476,6 @@ static void clk_disable_unused_subtree(struct clk *clk)
 
 unlock_out:
 	clk_enable_unlock(flags);
-
-out:
-	return;
 }
 
 static bool clk_ignore_unused;

commit 9767b04fe663f84040aae1fb76d67246b856d107
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Tue Jan 20 22:23:43 2015 +0100

    clk: Export phase functions
    
    The phase setter and getter were not exported until now, which was causing
    build breakages when callers were compiled as module. Export these two
    functions.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9fc209abcb48..aa8a9d2d0b73 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1833,6 +1833,7 @@ int clk_set_phase(struct clk *clk, int degrees)
 out:
 	return ret;
 }
+EXPORT_SYMBOL_GPL(clk_set_phase);
 
 /**
  * clk_get_phase - return the phase shift of a clock signal
@@ -1855,6 +1856,7 @@ int clk_get_phase(struct clk *clk)
 out:
 	return ret;
 }
+EXPORT_SYMBOL_GPL(clk_get_phase);
 
 /**
  * __clk_init - initialize the data structures in a struct clk

commit 15a02c1f6dd7c2bb150c61d00ffb33f584ff2288
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jan 19 18:05:28 2015 -0800

    clk: Add __clk_mux_determine_rate_closest
    
    Some clock drivers want to find the closest rate on the input of
    a mux instead of a rate that's less than or equal to the desired
    rate. Add a generic mux function to support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: Kenneth Westfield <kwestfie@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 30fff56e1f15..9fc209abcb48 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -690,14 +690,20 @@ struct clk *__clk_lookup(const char *name)
 	return NULL;
 }
 
-/*
- * Helper for finding best parent to provide a given frequency. This can be used
- * directly as a determine_rate callback (e.g. for a mux), or from a more
- * complex clock that may combine a mux with other operations.
- */
-long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
-			      unsigned long *best_parent_rate,
-			      struct clk_hw **best_parent_p)
+static bool mux_is_better_rate(unsigned long rate, unsigned long now,
+			   unsigned long best, unsigned long flags)
+{
+	if (flags & CLK_MUX_ROUND_CLOSEST)
+		return abs(now - rate) < abs(best - rate);
+
+	return now <= rate && now > best;
+}
+
+static long
+clk_mux_determine_rate_flags(struct clk_hw *hw, unsigned long rate,
+			     unsigned long *best_parent_rate,
+			     struct clk_hw **best_parent_p,
+			     unsigned long flags)
 {
 	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
 	int i, num_parents;
@@ -725,7 +731,7 @@ long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
 			parent_rate = __clk_round_rate(parent, rate);
 		else
 			parent_rate = __clk_get_rate(parent);
-		if (parent_rate <= rate && parent_rate > best) {
+		if (mux_is_better_rate(rate, parent_rate, best, flags)) {
 			best_parent = parent;
 			best = parent_rate;
 		}
@@ -738,8 +744,31 @@ long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
 
 	return best;
 }
+
+/*
+ * Helper for finding best parent to provide a given frequency. This can be used
+ * directly as a determine_rate callback (e.g. for a mux), or from a more
+ * complex clock that may combine a mux with other operations.
+ */
+long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long *best_parent_rate,
+			      struct clk_hw **best_parent_p)
+{
+	return clk_mux_determine_rate_flags(hw, rate, best_parent_rate,
+					    best_parent_p, 0);
+}
 EXPORT_SYMBOL_GPL(__clk_mux_determine_rate);
 
+long __clk_mux_determine_rate_closest(struct clk_hw *hw, unsigned long rate,
+			      unsigned long *best_parent_rate,
+			      struct clk_hw **best_parent_p)
+{
+	return clk_mux_determine_rate_flags(hw, rate, best_parent_rate,
+					    best_parent_p,
+					    CLK_MUX_ROUND_CLOSEST);
+}
+EXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);
+
 /***        clk api        ***/
 
 void __clk_unprepare(struct clk *clk)

commit 52bba9809a954d72bc77773bd560b9724b495eb7
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Mon Jan 19 09:57:13 2015 +0000

    clk: Fix debugfs clk removal before inited
    
    Some of the clks can be registered & unregistered before the clk related debugfs
    entries are initialized at late_initcall. In the unregister path checking for only
    dentry before clk_debug_init() would lead dangling pointers in the debug clk list,
    because the list is already populated in register path and the clk pointer freed in
    unregister path.
    The side effect of not removing it from the list is either a null pointer
    dereference or if lucky to boot the system, the number of clk entries in
    debugfs disappear.
    
    We could add more checks like if (inited && !clk->dentry) but just removing
    the check for dentry made more sense as debugfs_remove_recursive() seems to be
    safe with null pointers. This will ensure that the unregistering clk would be
    removed from the debug list in all the code paths.
    
    Without this patch kernel would crash with log:
    Unable to handle kernel NULL pointer dereference at virtual address 00000000
    pgd = c0204000
    [00000000] *pgd=00000000
    Internal error: Oops: 5 [#1] SMP ARM
    Modules linked in:
    CPU: 1 PID: 1 Comm: swapper/0 Tainted: G    B          3.19.0-rc3-00007-g412f9ba-dirty #840
    Hardware name: Qualcomm (Flattened Device Tree)
    task: ed948000 ti: ed944000 task.ti: ed944000
    PC is at strlen+0xc/0x40
    LR is at __create_file+0x64/0x1dc
    pc : [<c04ee604>]    lr : [<c049f1c4>]    psr: 60000013
    sp : ed945e40  ip : ed945e50  fp : ed945e4c
    r10: 00000000  r9 : c1006094  r8 : 00000000
    r7 : 000041ed  r6 : 00000000  r5 : ed4af998  r4 : c11b5e28
    r3 : 00000000  r2 : ed945e38  r1 : a0000013  r0 : 00000000
    Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c5787d  Table: 8020406a  DAC: 00000015
    Process swapper/0 (pid: 1, stack limit = 0xed944248)
    Stack: (0xed945e40 to 0xed946000)
    5e40: ed945e7c ed945e50 c049f1c4 c04ee604 c0fc2fa4 00000000 ecb748c0 c11c2b80
    5e60: c0beec04 0000011c c0fc2fa4 00000000 ed945e94 ed945e80 c049f3e0 c049f16c
    5e80: 00000000 00000000 ed945eac ed945e98 c08cbc50 c049f3c0 ecb748c0 c11c2b80
    5ea0: ed945ed4 ed945eb0 c0fc3080 c08cbc30 c0beec04 c107e1d8 ecdf0600 c107e1d8
    5ec0: c107e1d8 ecdf0600 ed945f54 ed945ed8 c0208ed4 c0fc2fb0 c026a784 c04ee628
    5ee0: ed945f0c ed945ef0 c0f5d600 c04ee604 c0f5d5ec ef7fcc7d c0b40ecc 0000011c
    5f00: ed945f54 ed945f10 c026a994 c0f5d5f8 c04ecc00 00000007 ef7fcc95 00000007
    5f20: c0e90744 c0dd0884 ed945f54 c106cde0 00000007 c117f8c0 0000011c c0f5d5ec
    5f40: c1006094 c100609c ed945f94 ed945f58 c0f5de34 c0208e50 00000007 00000007
    5f60: c0f5d5ec be9b5ae0 00000000 c117f8c0 c0af1680 00000000 00000000 00000000
    5f80: 00000000 00000000 ed945fac ed945f98 c0af169c c0f5dd2c ed944000 00000000
    5fa0: 00000000 ed945fb0 c020f298 c0af168c 00000000 00000000 00000000 00000000
    5fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    5fe0: 00000000 00000000 00000000 00000000 00000013 00000000 ebcc6d33 bfffca73
    [<c04ee604>] (strlen) from [<c049f1c4>] (__create_file+0x64/0x1dc)
    [<c049f1c4>] (__create_file) from [<c049f3e0>] (debugfs_create_dir+0x2c/0x34)
    [<c049f3e0>] (debugfs_create_dir) from [<c08cbc50>] (clk_debug_create_one+0x2c/0x16c)
    [<c08cbc50>] (clk_debug_create_one) from [<c0fc3080>] (clk_debug_init+0xdc/0x144)
    [<c0fc3080>] (clk_debug_init) from [<c0208ed4>] (do_one_initcall+0x90/0x1e0)
    [<c0208ed4>] (do_one_initcall) from [<c0f5de34>] (kernel_init_freeable+0x114/0x1e0)
    [<c0f5de34>] (kernel_init_freeable) from [<c0af169c>] (kernel_init+0x1c/0xfc)
    [<c0af169c>] (kernel_init) from [<c020f298>] (ret_from_fork+0x14/0x3c)
    Code: c0b40ecc e1a0c00d e92dd800 e24cb004 (e5d02000)
    ---[ end trace b940e45b5e25c1e7 ]---
    
    Fixes: 6314b6796e3c "clk: Don't hold prepare_lock across debugfs creation"
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7ba02e52c554..30fff56e1f15 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -343,13 +343,9 @@ static int clk_debug_register(struct clk *clk)
 static void clk_debug_unregister(struct clk *clk)
 {
 	mutex_lock(&clk_debug_lock);
-	if (!clk->dentry)
-		goto out;
-
 	hlist_del_init(&clk->debug_node);
 	debugfs_remove_recursive(clk->dentry);
 	clk->dentry = NULL;
-out:
 	mutex_unlock(&clk_debug_lock);
 }
 

commit 57386798f7db7f09d69f3b44fc66570e6db91bba
Merge: ec6415dc4160 4e88f3de89fb
Author: Michael Turquette <mturquette@linaro.org>
Date:   Sat Jan 24 16:58:40 2015 -0800

    Merge branch 'clk-has-parent' into clk-next

commit 4e88f3de89fbb7b5a5a0aca20376b276d26732ac
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Jan 21 17:13:00 2015 +0100

    clk: Introduce clk_has_parent()
    
    This new function is similar to clk_set_parent(), except that it doesn't
    actually change the parent. It merely checks that the given parent clock
    can be a parent for the given clock.
    
    A situation where this is useful is to check that a particular setup is
    valid before switching to it. One specific use-case for this is atomic
    modesetting in the DRM framework where setting a mode is divided into a
    check phase where a given configuration is validated before applying
    changes to the hardware.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f4963b7d4e17..5272ad71929f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1651,6 +1651,36 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
 	__clk_recalc_rates(clk, POST_RATE_CHANGE);
 }
 
+/**
+ * clk_has_parent - check if a clock is a possible parent for another
+ * @clk: clock source
+ * @parent: parent clock source
+ *
+ * This function can be used in drivers that need to check that a clock can be
+ * the parent of another without actually changing the parent.
+ *
+ * Returns true if @parent is a possible parent for @clk, false otherwise.
+ */
+bool clk_has_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned int i;
+
+	/* NULL clocks should be nops, so return success if either is NULL. */
+	if (!clk || !parent)
+		return true;
+
+	/* Optimize for the case where the parent is already the parent. */
+	if (clk->parent == parent)
+		return true;
+
+	for (i = 0; i < clk->num_parents; i++)
+		if (strcmp(clk->parent_names[i], parent->name) == 0)
+			return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(clk_has_parent);
+
 /**
  * clk_set_parent - switch the parent of a mux clk
  * @clk: the mux clk whose input we are switching

commit 4526e7b857076ba613cc7199fc7fd17d60e86ede
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Dec 22 11:26:42 2014 -0800

    clk: Skip fetching index for single parent clocks
    
    We don't need to fetch the parent index for clocks if they only
    have one parent. Doing this also avoid an unnecessary allocation
    for the parent cache.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d48ac71c6c8b..7f25aaf2a2b0 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1390,7 +1390,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 	}
 
 	/* try finding the new parent index */
-	if (parent) {
+	if (parent && clk->num_parents > 1) {
 		p_index = clk_fetch_parent_index(clk, parent);
 		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",

commit c7662fc59ca38517e0ec04ceaa123ed8209ab6bf
Author: Stanimir Varbanov <svarbanov@mm-sol.com>
Date:   Mon Jan 5 18:04:23 2015 +0200

    clk: fix possible null pointer dereference
    
    The commit 646cafc6 (clk: Change clk_ops->determine_rate to
    return a clk_hw as the best parent) opens a possibility for
    null pointer dereference, fix this.
    
    Signed-off-by: Stanimir Varbanov <svarbanov@mm-sol.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f4963b7d4e17..d48ac71c6c8b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1366,7 +1366,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 		new_rate = clk->ops->determine_rate(clk->hw, rate,
 						    &best_parent_rate,
 						    &parent_hw);
-		parent = parent_hw->clk;
+		parent = parent_hw ? parent_hw->clk : NULL;
 	} else if (clk->ops->round_rate) {
 		new_rate = clk->ops->round_rate(clk->hw, rate,
 						&best_parent_rate);

commit 89f7e9de59bf3e3cda2e00de12c66db22675a7cf
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Dec 12 15:04:16 2014 -0800

    clk: Really fix deadlock with mmap_sem
    
    Commit 6314b6796e3c (clk: Don't hold prepare_lock across debugfs
    creation, 2014-09-04) forgot to update one place where we hold
    the prepare_lock while creating debugfs directories. This means
    we still have the chance of a deadlock that the commit was trying
    to fix. Actually fix it by moving the debugfs creation outside
    the prepare_lock.
    
    Cc: <stable@vger.kernel.org> # 3.18
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Fixes: 6314b6796e3c "clk: Don't hold prepare_lock across debugfs creation"
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: removed lockdep_assert]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 44cdc47a6cc5..f4963b7d4e17 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -240,7 +240,6 @@ static const struct file_operations clk_dump_fops = {
 	.release	= single_release,
 };
 
-/* caller must hold prepare_lock */
 static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 {
 	struct dentry *d;
@@ -1944,7 +1943,6 @@ int __clk_init(struct device *dev, struct clk *clk)
 	else
 		clk->rate = 0;
 
-	clk_debug_register(clk);
 	/*
 	 * walk the list of orphan clocks and reparent any that are children of
 	 * this clock
@@ -1979,6 +1977,9 @@ int __clk_init(struct device *dev, struct clk *clk)
 out:
 	clk_prepare_unlock();
 
+	if (!ret)
+		clk_debug_register(clk);
+
 	return ret;
 }
 

commit 646cafc6aa4d6004d189de1cdc267ab562069ba9
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Tue Dec 2 08:54:22 2014 +0100

    clk: Change clk_ops->determine_rate to return a clk_hw as the best parent
    
    This is in preparation for clock providers to not have to deal with struct clk.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f549e8b1d5ed..44cdc47a6cc5 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -702,7 +702,7 @@ struct clk *__clk_lookup(const char *name)
  */
 long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
 			      unsigned long *best_parent_rate,
-			      struct clk **best_parent_p)
+			      struct clk_hw **best_parent_p)
 {
 	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
 	int i, num_parents;
@@ -738,7 +738,7 @@ long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
 
 out:
 	if (best_parent)
-		*best_parent_p = best_parent;
+		*best_parent_p = best_parent->hw;
 	*best_parent_rate = best;
 
 	return best;
@@ -946,6 +946,7 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 {
 	unsigned long parent_rate = 0;
 	struct clk *parent;
+	struct clk_hw *parent_hw;
 
 	if (!clk)
 		return 0;
@@ -954,10 +955,11 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 	if (parent)
 		parent_rate = parent->rate;
 
-	if (clk->ops->determine_rate)
+	if (clk->ops->determine_rate) {
+		parent_hw = parent ? parent->hw : NULL;
 		return clk->ops->determine_rate(clk->hw, rate, &parent_rate,
-						&parent);
-	else if (clk->ops->round_rate)
+						&parent_hw);
+	} else if (clk->ops->round_rate)
 		return clk->ops->round_rate(clk->hw, rate, &parent_rate);
 	else if (clk->flags & CLK_SET_RATE_PARENT)
 		return __clk_round_rate(clk->parent, rate);
@@ -1345,6 +1347,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 {
 	struct clk *top = clk;
 	struct clk *old_parent, *parent;
+	struct clk_hw *parent_hw;
 	unsigned long best_parent_rate = 0;
 	unsigned long new_rate;
 	int p_index = 0;
@@ -1360,9 +1363,11 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 
 	/* find the closest rate and parent clk/rate */
 	if (clk->ops->determine_rate) {
+		parent_hw = parent ? parent->hw : NULL;
 		new_rate = clk->ops->determine_rate(clk->hw, rate,
 						    &best_parent_rate,
-						    &parent);
+						    &parent_hw);
+		parent = parent_hw->clk;
 	} else if (clk->ops->round_rate) {
 		new_rate = clk->ops->round_rate(clk->hw, rate,
 						&best_parent_rate);

commit 61c7cddfad266ebb86176723f9c679f25cf705fe
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Tue Dec 2 08:54:21 2014 +0100

    clk: change clk_debugfs_add_file to take a struct clk_hw
    
    Instead of struct clk, as this should be only used by providers.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 73247e90ee59..f549e8b1d5ed 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -354,13 +354,13 @@ static void clk_debug_unregister(struct clk *clk)
 	mutex_unlock(&clk_debug_lock);
 }
 
-struct dentry *clk_debugfs_add_file(struct clk *clk, char *name, umode_t mode,
+struct dentry *clk_debugfs_add_file(struct clk_hw *hw, char *name, umode_t mode,
 				void *data, const struct file_operations *fops)
 {
 	struct dentry *d = NULL;
 
-	if (clk->dentry)
-		d = debugfs_create_file(name, mode, clk->dentry, data, fops);
+	if (hw->clk->dentry)
+		d = debugfs_create_file(name, mode, hw->clk->dentry, data, fops);
 
 	return d;
 }

commit 920f1c7472f35cd3b3a3add10cccb0ef12376a17
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Tue Dec 2 08:54:20 2014 +0100

    clk: Don't expose __clk_get_accuracy
    
    As it's only used internally, in drivers/clk/clk.c.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 609e9db1a69a..73247e90ee59 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -596,7 +596,7 @@ unsigned long __clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_rate);
 
-unsigned long __clk_get_accuracy(struct clk *clk)
+static unsigned long __clk_get_accuracy(struct clk *clk)
 {
 	if (!clk)
 		return 0;

commit 10cdfe54dab034311c8e2fad9ba2dffbe616caa9
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Tue Dec 2 08:54:19 2014 +0100

    clk: Don't try to use a struct clk* after it could have been freed
    
    As __clk_release could call kfree on clk and then we wouldn't have a safe way
    of getting the module that owns the clock.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Fixes: fcb0ee6a3d33 ("clk: Implement clk_unregister")
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 42f940ff5edf..609e9db1a69a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2268,14 +2268,17 @@ int __clk_get(struct clk *clk)
 
 void __clk_put(struct clk *clk)
 {
+	struct module *owner;
+
 	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
 		return;
 
 	clk_prepare_lock();
+	owner = clk->owner;
 	kref_put(&clk->ref, __clk_release);
 	clk_prepare_unlock();
 
-	module_put(clk->owner);
+	module_put(owner);
 }
 
 /***        clk rate change notifiers        ***/

commit 4afbe1760d89fec07e7a8cce58beb1b4921a194c
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Tue Dec 2 08:54:18 2014 +0100

    clk: Remove unused function __clk_get_prepare_count
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5307225684eb..42f940ff5edf 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -574,11 +574,6 @@ unsigned int __clk_get_enable_count(struct clk *clk)
 	return !clk ? 0 : clk->enable_count;
 }
 
-unsigned int __clk_get_prepare_count(struct clk *clk)
-{
-	return !clk ? 0 : clk->prepare_count;
-}
-
 unsigned long __clk_get_rate(struct clk *clk)
 {
 	unsigned long ret;

commit 40ba3f0ff261a14107f3f52c67602fff8b88d980
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Fri Nov 14 10:10:40 2014 +0800

    clk: delete a local variable's repeated assignment
    
    It's the same to the next statement, "ret = clk->parent". I think compiler will
    optimize it, it's just not looking well.
    
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4896ae9e23da..5307225684eb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1614,7 +1614,7 @@ static struct clk *__clk_init_parent(struct clk *clk)
 
 	if (clk->num_parents == 1) {
 		if (IS_ERR_OR_NULL(clk->parent))
-			ret = clk->parent = __clk_lookup(clk->parent_names[0]);
+			clk->parent = __clk_lookup(clk->parent_names[0]);
 		ret = clk->parent;
 		goto out;
 	}

commit 4dc7ed32f398fa76b9e1d243a852420b1dad0150
Merge: 5ad67d3e5e0a 9c8176bfb67f
Author: Mike Turquette <mturquette@linaro.org>
Date:   Sat Sep 27 12:52:33 2014 -0700

    Merge tag 'sunxi-clocks-for-3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/mripard/linux into clk-next
    
    Allwinner Clocks Additions for 3.18
    
    The most important part of this serie is the addition of the phase API to
    handle the MMC clocks in the Allwinner SoCs.
    
    Apart from that, the A23 gained a new mbus driver, and there's a fix for a
    incorrect divider table on the APB0 clock.

commit 9824cf73c3a5e677bee6fcba43c4807e01ff1b4a
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Mon Jul 14 13:53:27 2014 +0200

    clk: Add a function to retrieve phase
    
    The current phase API doesn't look into the actual hardware to get the phase
    value, but will rather get it from a variable only set by the set_phase
    function.
    
    This will cause issue when the client driver will never call the set_phase
    function, where we can end up having a reported phase that will not match what
    the hardware has been programmed to by the bootloader or what phase is
    programmed out of reset.
    
    Add a new get_phase function for the drivers to implement so that we can get
    this value.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d87661af0c72..113d75db371d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1933,6 +1933,16 @@ int __clk_init(struct device *dev, struct clk *clk)
 	else
 		clk->accuracy = 0;
 
+	/*
+	 * Set clk's phase.
+	 * Since a phase is by definition relative to its parent, just
+	 * query the current clock phase, or just assume it's in phase.
+	 */
+	if (clk->ops->get_phase)
+		clk->phase = clk->ops->get_phase(clk->hw);
+	else
+		clk->phase = 0;
+
 	/*
 	 * Set clk's rate.  The preferred method is to use .recalc_rate.  For
 	 * simple clocks and lazy developers the default fallback is to use the

commit e59c5371fb9d8268d1c043172e88cecab9dc934f
Author: Mike Turquette <mturquette@linaro.org>
Date:   Tue Feb 18 21:21:25 2014 -0800

    clk: introduce clk_set_phase function & callback
    
    A common operation for a clock signal generator is to shift the phase of
    that signal. This patch introduces a new function to the clk.h API to
    dynamically adjust the phase of a clock signal. Additionally this patch
    introduces support for the new function in the common clock framework
    via the .set_phase call back in struct clk_ops.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b76fa69b44cb..d87661af0c72 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -117,11 +117,11 @@ static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
 	if (!c)
 		return;
 
-	seq_printf(s, "%*s%-*s %11d %12d %11lu %10lu\n",
+	seq_printf(s, "%*s%-*s %11d %12d %11lu %10lu %-3d\n",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
 		   c->enable_count, c->prepare_count, clk_get_rate(c),
-		   clk_get_accuracy(c));
+		   clk_get_accuracy(c), clk_get_phase(c));
 }
 
 static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
@@ -143,8 +143,8 @@ static int clk_summary_show(struct seq_file *s, void *data)
 	struct clk *c;
 	struct hlist_head **lists = (struct hlist_head **)s->private;
 
-	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy\n");
-	seq_puts(s, "--------------------------------------------------------------------------------\n");
+	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy   phase\n");
+	seq_puts(s, "----------------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 
@@ -180,6 +180,7 @@ static void clk_dump_one(struct seq_file *s, struct clk *c, int level)
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
 	seq_printf(s, "\"rate\": %lu", clk_get_rate(c));
 	seq_printf(s, "\"accuracy\": %lu", clk_get_accuracy(c));
+	seq_printf(s, "\"phase\": %d", clk_get_phase(c));
 }
 
 static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
@@ -264,6 +265,11 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
+	d = debugfs_create_u32("clk_phase", S_IRUGO, clk->dentry,
+			(u32 *)&clk->phase);
+	if (!d)
+		goto err_out;
+
 	d = debugfs_create_x32("clk_flags", S_IRUGO, clk->dentry,
 			(u32 *)&clk->flags);
 	if (!d)
@@ -1738,6 +1744,77 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 }
 EXPORT_SYMBOL_GPL(clk_set_parent);
 
+/**
+ * clk_set_phase - adjust the phase shift of a clock signal
+ * @clk: clock signal source
+ * @degrees: number of degrees the signal is shifted
+ *
+ * Shifts the phase of a clock signal by the specified
+ * degrees. Returns 0 on success, -EERROR otherwise.
+ *
+ * This function makes no distinction about the input or reference
+ * signal that we adjust the clock signal phase against. For example
+ * phase locked-loop clock signal generators we may shift phase with
+ * respect to feedback clock signal input, but for other cases the
+ * clock phase may be shifted with respect to some other, unspecified
+ * signal.
+ *
+ * Additionally the concept of phase shift does not propagate through
+ * the clock tree hierarchy, which sets it apart from clock rates and
+ * clock accuracy. A parent clock phase attribute does not have an
+ * impact on the phase attribute of a child clock.
+ */
+int clk_set_phase(struct clk *clk, int degrees)
+{
+	int ret = 0;
+
+	if (!clk)
+		goto out;
+
+	/* sanity check degrees */
+	degrees %= 360;
+	if (degrees < 0)
+		degrees += 360;
+
+	clk_prepare_lock();
+
+	if (!clk->ops->set_phase)
+		goto out_unlock;
+
+	ret = clk->ops->set_phase(clk->hw, degrees);
+
+	if (!ret)
+		clk->phase = degrees;
+
+out_unlock:
+	clk_prepare_unlock();
+
+out:
+	return ret;
+}
+
+/**
+ * clk_get_phase - return the phase shift of a clock signal
+ * @clk: clock signal source
+ *
+ * Returns the phase shift of a clock node in degrees, otherwise returns
+ * -EERROR.
+ */
+int clk_get_phase(struct clk *clk)
+{
+	int ret = 0;
+
+	if (!clk)
+		goto out;
+
+	clk_prepare_lock();
+	ret = clk->phase;
+	clk_prepare_unlock();
+
+out:
+	return ret;
+}
+
 /**
  * __clk_init - initialize the data structures in a struct clk
  * @dev:	device initializing this clk, placeholder for now

commit a52ae5a755d980e9ff812c6f45a415ba27bfd33b
Merge: 0469a43bc320 8ce8ebeb572d
Author: Mike Turquette <mturquette@linaro.org>
Date:   Wed Sep 17 11:47:56 2014 -0700

    Merge branch 'clk-fixes' into clk-next

commit 6314b6796e3c070d4c8086b08dfd453a0aeac4cf
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Sep 4 23:37:49 2014 -0700

    clk: Don't hold prepare_lock across debugfs creation
    
    Rob Clark reports a lockdep splat that involves the prepare_lock
    chained with the mmap semaphore.
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.17.0-rc1-00050-g07a489b #802 Tainted: G        W
    -------------------------------------------------------
    Xorg.bin/5413 is trying to acquire lock:
     (prepare_lock){+.+.+.}, at: [<c0781280>] clk_prepare_lock+0x88/0xfc
    
    but task is already holding lock:
     (qcom_iommu_lock){+.+...}, at: [<c079f664>] qcom_iommu_unmap+0x1c/0x1f0
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #4 (qcom_iommu_lock){+.+...}:
           [<c079f860>] qcom_iommu_map+0x28/0x450
           [<c079eb50>] iommu_map+0xc8/0x12c
           [<c056c1fc>] msm_iommu_map+0xb4/0x130
           [<c05697bc>] msm_gem_get_iova_locked+0x9c/0xe8
           [<c0569854>] msm_gem_get_iova+0x4c/0x64
           [<c0562208>] mdp4_kms_init+0x4c4/0x6c0
           [<c056881c>] msm_load+0x2ac/0x34c
           [<c0545724>] drm_dev_register+0xac/0x108
           [<c0547510>] drm_platform_init+0x50/0xf0
           [<c0578a60>] try_to_bring_up_master.part.3+0xc8/0x108
           [<c0578b48>] component_master_add_with_match+0xa8/0x104
           [<c0568294>] msm_pdev_probe+0x64/0x70
           [<c057e704>] platform_drv_probe+0x2c/0x60
           [<c057cff8>] driver_probe_device+0x108/0x234
           [<c057b65c>] bus_for_each_drv+0x64/0x98
           [<c057cec0>] device_attach+0x78/0x8c
           [<c057c590>] bus_probe_device+0x88/0xac
           [<c057c9b8>] deferred_probe_work_func+0x68/0x9c
           [<c0259db4>] process_one_work+0x1a0/0x40c
           [<c025a710>] worker_thread+0x44/0x4d8
           [<c025ec54>] kthread+0xd8/0xec
           [<c020e9a8>] ret_from_fork+0x14/0x2c
    
    -> #3 (&dev->struct_mutex){+.+.+.}:
           [<c0541188>] drm_gem_mmap+0x38/0xd0
           [<c05695b8>] msm_gem_mmap+0xc/0x5c
           [<c02f0b6c>] mmap_region+0x35c/0x6c8
           [<c02f11ec>] do_mmap_pgoff+0x314/0x398
           [<c02de1e0>] vm_mmap_pgoff+0x84/0xb4
           [<c02ef83c>] SyS_mmap_pgoff+0x94/0xbc
           [<c020e8e0>] ret_fast_syscall+0x0/0x48
    
    -> #2 (&mm->mmap_sem){++++++}:
           [<c0321138>] filldir64+0x68/0x180
           [<c0333fe0>] dcache_readdir+0x188/0x22c
           [<c0320ed0>] iterate_dir+0x9c/0x11c
           [<c03213b0>] SyS_getdents64+0x78/0xe8
           [<c020e8e0>] ret_fast_syscall+0x0/0x48
    
    -> #1 (&sb->s_type->i_mutex_key#3){+.+.+.}:
           [<c03fc544>] __create_file+0x58/0x1dc
           [<c03fc70c>] debugfs_create_dir+0x1c/0x24
           [<c0781c7c>] clk_debug_create_subtree+0x20/0x170
           [<c0be2af8>] clk_debug_init+0xec/0x14c
           [<c0208c70>] do_one_initcall+0x8c/0x1c8
           [<c0b9cce4>] kernel_init_freeable+0x13c/0x1dc
           [<c0877bc4>] kernel_init+0x8/0xe8
           [<c020e9a8>] ret_from_fork+0x14/0x2c
    
    -> #0 (prepare_lock){+.+.+.}:
           [<c087c408>] mutex_lock_nested+0x70/0x3e8
           [<c0781280>] clk_prepare_lock+0x88/0xfc
           [<c0782c50>] clk_prepare+0xc/0x24
           [<c079f474>] __enable_clocks.isra.4+0x18/0xa4
           [<c079f614>] __flush_iotlb_va+0xe0/0x114
           [<c079f6f4>] qcom_iommu_unmap+0xac/0x1f0
           [<c079ea3c>] iommu_unmap+0x9c/0xe8
           [<c056c2fc>] msm_iommu_unmap+0x64/0x84
           [<c0569da4>] msm_gem_free_object+0x11c/0x338
           [<c05413ec>] drm_gem_object_handle_unreference_unlocked+0xfc/0x130
           [<c0541604>] drm_gem_object_release_handle+0x50/0x68
           [<c0447a98>] idr_for_each+0xa8/0xdc
           [<c0541c10>] drm_gem_release+0x1c/0x28
           [<c0540b3c>] drm_release+0x370/0x428
           [<c031105c>] __fput+0x98/0x1e8
           [<c025d73c>] task_work_run+0xb0/0xfc
           [<c02477ec>] do_exit+0x2ec/0x948
           [<c0247ec0>] do_group_exit+0x4c/0xb8
           [<c025180c>] get_signal+0x28c/0x6ac
           [<c0211204>] do_signal+0xc4/0x3e4
           [<c02116cc>] do_work_pending+0xb4/0xc4
           [<c020e938>] work_pending+0xc/0x20
    
    other info that might help us debug this:
    
    Chain exists of:
      prepare_lock --> &dev->struct_mutex --> qcom_iommu_lock
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(qcom_iommu_lock);
                                   lock(&dev->struct_mutex);
                                   lock(qcom_iommu_lock);
      lock(prepare_lock);
    
     *** DEADLOCK ***
    
    3 locks held by Xorg.bin/5413:
     #0:  (drm_global_mutex){+.+.+.}, at: [<c0540800>] drm_release+0x34/0x428
     #1:  (&dev->struct_mutex){+.+.+.}, at: [<c05413bc>] drm_gem_object_handle_unreference_unlocked+0xcc/0x130
     #2:  (qcom_iommu_lock){+.+...}, at: [<c079f664>] qcom_iommu_unmap+0x1c/0x1f0
    
    stack backtrace:
    CPU: 1 PID: 5413 Comm: Xorg.bin Tainted: G        W      3.17.0-rc1-00050-g07a489b #802
    [<c0216290>] (unwind_backtrace) from [<c0211d8c>] (show_stack+0x10/0x14)
    [<c0211d8c>] (show_stack) from [<c087a078>] (dump_stack+0x98/0xb8)
    [<c087a078>] (dump_stack) from [<c027f024>] (print_circular_bug+0x218/0x340)
    [<c027f024>] (print_circular_bug) from [<c0283e08>] (__lock_acquire+0x1d24/0x20b8)
    [<c0283e08>] (__lock_acquire) from [<c0284774>] (lock_acquire+0x9c/0xbc)
    [<c0284774>] (lock_acquire) from [<c087c408>] (mutex_lock_nested+0x70/0x3e8)
    [<c087c408>] (mutex_lock_nested) from [<c0781280>] (clk_prepare_lock+0x88/0xfc)
    [<c0781280>] (clk_prepare_lock) from [<c0782c50>] (clk_prepare+0xc/0x24)
    [<c0782c50>] (clk_prepare) from [<c079f474>] (__enable_clocks.isra.4+0x18/0xa4)
    [<c079f474>] (__enable_clocks.isra.4) from [<c079f614>] (__flush_iotlb_va+0xe0/0x114)
    [<c079f614>] (__flush_iotlb_va) from [<c079f6f4>] (qcom_iommu_unmap+0xac/0x1f0)
    [<c079f6f4>] (qcom_iommu_unmap) from [<c079ea3c>] (iommu_unmap+0x9c/0xe8)
    [<c079ea3c>] (iommu_unmap) from [<c056c2fc>] (msm_iommu_unmap+0x64/0x84)
    [<c056c2fc>] (msm_iommu_unmap) from [<c0569da4>] (msm_gem_free_object+0x11c/0x338)
    [<c0569da4>] (msm_gem_free_object) from [<c05413ec>] (drm_gem_object_handle_unreference_unlocked+0xfc/0x130)
    [<c05413ec>] (drm_gem_object_handle_unreference_unlocked) from [<c0541604>] (drm_gem_object_release_handle+0x50/0x68)
    [<c0541604>] (drm_gem_object_release_handle) from [<c0447a98>] (idr_for_each+0xa8/0xdc)
    [<c0447a98>] (idr_for_each) from [<c0541c10>] (drm_gem_release+0x1c/0x28)
    [<c0541c10>] (drm_gem_release) from [<c0540b3c>] (drm_release+0x370/0x428)
    [<c0540b3c>] (drm_release) from [<c031105c>] (__fput+0x98/0x1e8)
    [<c031105c>] (__fput) from [<c025d73c>] (task_work_run+0xb0/0xfc)
    [<c025d73c>] (task_work_run) from [<c02477ec>] (do_exit+0x2ec/0x948)
    [<c02477ec>] (do_exit) from [<c0247ec0>] (do_group_exit+0x4c/0xb8)
    [<c0247ec0>] (do_group_exit) from [<c025180c>] (get_signal+0x28c/0x6ac)
    [<c025180c>] (get_signal) from [<c0211204>] (do_signal+0xc4/0x3e4)
    [<c0211204>] (do_signal) from [<c02116cc>] (do_work_pending+0xb4/0xc4)
    [<c02116cc>] (do_work_pending) from [<c020e938>] (work_pending+0xc/0x20)
    
    We can break this chain if we don't hold the prepare_lock while
    creating debugfs directories. We only hold the prepare_lock right
    now because we're traversing the clock tree recursively and we
    don't want the hierarchy to change during the traversal.
    Replacing this traversal with a simple linked list walk allows us
    to only grab a list lock instead of the prepare_lock, thus
    breaking the lock chain.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b76fa69b44cb..8ca28189e4e9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -100,6 +100,8 @@ static void clk_enable_unlock(unsigned long flags)
 
 static struct dentry *rootdir;
 static int inited = 0;
+static DEFINE_MUTEX(clk_debug_lock);
+static HLIST_HEAD(clk_debug_list);
 
 static struct hlist_head *all_lists[] = {
 	&clk_root_list,
@@ -300,28 +302,6 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 	return ret;
 }
 
-/* caller must hold prepare_lock */
-static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)
-{
-	struct clk *child;
-	int ret = -EINVAL;;
-
-	if (!clk || !pdentry)
-		goto out;
-
-	ret = clk_debug_create_one(clk, pdentry);
-
-	if (ret)
-		goto out;
-
-	hlist_for_each_entry(child, &clk->children, child_node)
-		clk_debug_create_subtree(child, pdentry);
-
-	ret = 0;
-out:
-	return ret;
-}
-
 /**
  * clk_debug_register - add a clk node to the debugfs clk tree
  * @clk: the clk being added to the debugfs clk tree
@@ -329,20 +309,21 @@ static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)
  * Dynamically adds a clk to the debugfs clk tree if debugfs has been
  * initialized.  Otherwise it bails out early since the debugfs clk tree
  * will be created lazily by clk_debug_init as part of a late_initcall.
- *
- * Caller must hold prepare_lock.  Only clk_init calls this function (so
- * far) so this is taken care.
  */
 static int clk_debug_register(struct clk *clk)
 {
 	int ret = 0;
 
+	mutex_lock(&clk_debug_lock);
+	hlist_add_head(&clk->debug_node, &clk_debug_list);
+
 	if (!inited)
-		goto out;
+		goto unlock;
 
-	ret = clk_debug_create_subtree(clk, rootdir);
+	ret = clk_debug_create_one(clk, rootdir);
+unlock:
+	mutex_unlock(&clk_debug_lock);
 
-out:
 	return ret;
 }
 
@@ -353,12 +334,18 @@ static int clk_debug_register(struct clk *clk)
  * Dynamically removes a clk and all it's children clk nodes from the
  * debugfs clk tree if clk->dentry points to debugfs created by
  * clk_debug_register in __clk_init.
- *
- * Caller must hold prepare_lock.
  */
 static void clk_debug_unregister(struct clk *clk)
 {
+	mutex_lock(&clk_debug_lock);
+	if (!clk->dentry)
+		goto out;
+
+	hlist_del_init(&clk->debug_node);
 	debugfs_remove_recursive(clk->dentry);
+	clk->dentry = NULL;
+out:
+	mutex_unlock(&clk_debug_lock);
 }
 
 struct dentry *clk_debugfs_add_file(struct clk *clk, char *name, umode_t mode,
@@ -415,17 +402,12 @@ static int __init clk_debug_init(void)
 	if (!d)
 		return -ENOMEM;
 
-	clk_prepare_lock();
-
-	hlist_for_each_entry(clk, &clk_root_list, child_node)
-		clk_debug_create_subtree(clk, rootdir);
-
-	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
-		clk_debug_create_subtree(clk, rootdir);
+	mutex_lock(&clk_debug_lock);
+	hlist_for_each_entry(clk, &clk_debug_list, debug_node)
+		clk_debug_create_one(clk, rootdir);
 
 	inited = 1;
-
-	clk_prepare_unlock();
+	mutex_unlock(&clk_debug_lock);
 
 	return 0;
 }
@@ -2087,14 +2069,16 @@ void clk_unregister(struct clk *clk)
 {
 	unsigned long flags;
 
-       if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
-               return;
+	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
+		return;
+
+	clk_debug_unregister(clk);
 
 	clk_prepare_lock();
 
 	if (clk->ops == &clk_nodrv_ops) {
 		pr_err("%s: unregistered clock: %s\n", __func__, clk->name);
-		goto out;
+		return;
 	}
 	/*
 	 * Assign empty clock ops for consumers that might still hold
@@ -2113,16 +2097,13 @@ void clk_unregister(struct clk *clk)
 			clk_set_parent(child, NULL);
 	}
 
-	clk_debug_unregister(clk);
-
 	hlist_del_init(&clk->child_node);
 
 	if (clk->prepare_count)
 		pr_warn("%s: unregistering prepared clock: %s\n",
 					__func__, clk->name);
-
 	kref_put(&clk->ref, __clk_release);
-out:
+
 	clk_prepare_unlock();
 }
 EXPORT_SYMBOL_GPL(clk_unregister);

commit 067bb1741c27c8d3b74ac98c0b8fc12b31e67005
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Aug 21 16:47:45 2014 +0300

    clk: prevent erronous parsing of children during rate change
    
    In some cases, clocks can switch their parent with clk_set_rate, for
    example clk_mux can do this in some cases. Current implementation of
    clk_change_rate uses un-safe list iteration on the clock children, which
    will cause wrong clocks to be parsed in case any of the clock children
    change their parents during the change rate operation. Fixed by using
    the safe list iterator instead.
    
    The problem was detected due to some divide by zero errors generated
    by clock init on dra7-evm board, see discussion under
    http://article.gmane.org/gmane.linux.ports.arm.kernel/349180 for details.
    
    Fixes: 71472c0c06cf ("clk: add support for clock reparent on set_rate")
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reported-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b76fa69b44cb..bacc06ff939b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1467,6 +1467,7 @@ static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long even
 static void clk_change_rate(struct clk *clk)
 {
 	struct clk *child;
+	struct hlist_node *tmp;
 	unsigned long old_rate;
 	unsigned long best_parent_rate = 0;
 	bool skip_set_rate = false;
@@ -1502,7 +1503,11 @@ static void clk_change_rate(struct clk *clk)
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
 
-	hlist_for_each_entry(child, &clk->children, child_node) {
+	/*
+	 * Use safe iteration, as change_rate can actually swap parents
+	 * for certain clock types.
+	 */
+	hlist_for_each_entry_safe(child, tmp, &clk->children, child_node) {
 		/* Skip children who will be reparented to another clock */
 		if (child->new_parent && child->new_parent != clk)
 			continue;

commit abeab450bfe823079c8a3abf5123f41a0da62392
Author: Chris Brand <chris.brand@linaro.org>
Date:   Thu Jul 3 14:01:29 2014 -0700

    clk: Propagate any error return from debug_init()
    
    If the .debug_init op is provided, it will be called by
    clk_debug_create_one(). If debug_init() returns an error code,
    clk_debug_create_one() will return -ENOMEM, regardless of the
    value returned from debug_init(). Tweak the code to return
    the actual value returned by debug_init() instead.
    
    Signed-off-by: Chris Brand <chris.brand@linaro.org>
    Reviewed-by: Matt Porter <mporter@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f95590a1e28e..b76fa69b44cb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -284,9 +284,11 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
-	if (clk->ops->debug_init)
-		if (clk->ops->debug_init(clk->hw, clk->dentry))
+	if (clk->ops->debug_init) {
+		ret = clk->ops->debug_init(clk->hw, clk->dentry);
+		if (ret)
 			goto err_out;
+	}
 
 	ret = 0;
 	goto out;

commit 86be408bfbd846fab3c4ac21d6f9298bd2e4b790
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Wed Jun 18 17:29:32 2014 +0200

    clk: Support for clock parents and rates assigned from device tree
    
    This patch adds helper functions to configure clock parents and rates
    as specified through 'assigned-clock-parents', 'assigned-clock-rates'
    DT properties for a clock provider or clock consumer device.
    The helpers are now being called by the bus code for the platform, I2C
    and SPI busses, before the driver probing and also in the clock core
    after registration of a clock provider.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9ad397050471..f95590a1e28e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/clk-private.h>
+#include <linux/clk/clk-conf.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
@@ -2382,6 +2383,7 @@ int of_clk_add_provider(struct device_node *np,
 			void *data)
 {
 	struct of_clk_provider *cp;
+	int ret;
 
 	cp = kzalloc(sizeof(struct of_clk_provider), GFP_KERNEL);
 	if (!cp)
@@ -2396,7 +2398,11 @@ int of_clk_add_provider(struct device_node *np,
 	mutex_unlock(&of_clk_mutex);
 	pr_debug("Added clock from %s\n", np->full_name);
 
-	return 0;
+	ret = of_clk_set_defaults(np, true);
+	if (ret < 0)
+		of_clk_del_provider(np);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(of_clk_add_provider);
 
@@ -2573,7 +2579,10 @@ void __init of_clk_init(const struct of_device_id *matches)
 		list_for_each_entry_safe(clk_provider, next,
 					&clk_provider_list, node) {
 			if (force || parent_ready(clk_provider->np)) {
+
 				clk_provider->clk_init_cb(clk_provider->np);
+				of_clk_set_defaults(clk_provider->np, true);
+
 				list_del(&clk_provider->node);
 				kfree(clk_provider);
 				is_init_done = true;
@@ -2588,7 +2597,6 @@ void __init of_clk_init(const struct of_device_id *matches)
 		 */
 		if (!is_init_done)
 			force = true;
-
 	}
 }
 #endif

commit fb2b3c9f68574738c70b9df5fc2bea40f91dd8be
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Thu Jun 26 18:00:53 2014 +0300

    clk: define and export clk_debugs_add_file
    
    Define and export a new function clk_debugs_add_file which adds a file
    to a existing clock's debugfs directory. This can be used by clock
    providers to add debugfs entries which are not related to a specific clock
    type. Examples include the ability to measure the rate of a clock. It can
    also be used by modules to create new debugfs entries. This is useful if you
    want to expose features for testing which can potentially cause system
    instability such as allowing to change a clock's rate from userspace.
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 958967d141ee..9ad397050471 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -358,6 +358,18 @@ static void clk_debug_unregister(struct clk *clk)
 	debugfs_remove_recursive(clk->dentry);
 }
 
+struct dentry *clk_debugfs_add_file(struct clk *clk, char *name, umode_t mode,
+				void *data, const struct file_operations *fops)
+{
+	struct dentry *d = NULL;
+
+	if (clk->dentry)
+		d = debugfs_create_file(name, mode, clk->dentry, data, fops);
+
+	return d;
+}
+EXPORT_SYMBOL_GPL(clk_debugfs_add_file);
+
 /**
  * clk_debug_init - lazily create the debugfs clk tree visualization
  *

commit 6b44c854b0f75d8dd1ea7f1d37621cfd82fbd2a9
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Tue Jul 1 11:56:34 2014 +0530

    clk: Fix build warnings
    
    all_lists and orphan_list is accessed only when DEBUG_FS is defined.
    Thus, make their compilation conditional to fix the below warnings introduced
    by commit 27b8d5f723 ("clk: flatten clk tree in debugfs"):
    drivers/clk/clk.c:40:27: warning: all_lists defined but not used [-Wunused-variable]
    drivers/clk/clk.c:46:27: warning: orphan_list defined but not used [-Wunused-variable]
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Cc: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7dfb2f308b35..958967d141ee 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -36,17 +36,6 @@ static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
 
-static struct hlist_head *all_lists[] = {
-	&clk_root_list,
-	&clk_orphan_list,
-	NULL,
-};
-
-static struct hlist_head *orphan_list[] = {
-	&clk_orphan_list,
-	NULL,
-};
-
 /***           locking             ***/
 static void clk_prepare_lock(void)
 {
@@ -111,6 +100,17 @@ static void clk_enable_unlock(unsigned long flags)
 static struct dentry *rootdir;
 static int inited = 0;
 
+static struct hlist_head *all_lists[] = {
+	&clk_root_list,
+	&clk_orphan_list,
+	NULL,
+};
+
+static struct hlist_head *orphan_list[] = {
+	&clk_orphan_list,
+	NULL,
+};
+
 static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
 {
 	if (!c)

commit 27b8d5f723e64b5f7beac45a4d5785906d0a2f9d
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Fri May 30 18:03:57 2014 +0300

    clk: flatten clk tree in debugfs
    
    This patch flattens the clk tree in CCF debugfs. Instead of representing the
    clocks and their hierarchy as a directory structure under
    /sys/kernel/debug/clk, each clock gets a single directory directly under
    /sys/kernel/debug/clk. The orphans directory is replaced by a file called
    clk_orphan_summary.
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8b73edef151d..7dfb2f308b35 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -36,6 +36,17 @@ static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
 
+static struct hlist_head *all_lists[] = {
+	&clk_root_list,
+	&clk_orphan_list,
+	NULL,
+};
+
+static struct hlist_head *orphan_list[] = {
+	&clk_orphan_list,
+	NULL,
+};
+
 /***           locking             ***/
 static void clk_prepare_lock(void)
 {
@@ -98,7 +109,6 @@ static void clk_enable_unlock(unsigned long flags)
 #include <linux/debugfs.h>
 
 static struct dentry *rootdir;
-static struct dentry *orphandir;
 static int inited = 0;
 
 static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
@@ -130,17 +140,16 @@ static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
 static int clk_summary_show(struct seq_file *s, void *data)
 {
 	struct clk *c;
+	struct hlist_head **lists = (struct hlist_head **)s->private;
 
 	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy\n");
 	seq_puts(s, "--------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 
-	hlist_for_each_entry(c, &clk_root_list, child_node)
-		clk_summary_show_subtree(s, c, 0);
-
-	hlist_for_each_entry(c, &clk_orphan_list, child_node)
-		clk_summary_show_subtree(s, c, 0);
+	for (; *lists; lists++)
+		hlist_for_each_entry(c, *lists, child_node)
+			clk_summary_show_subtree(s, c, 0);
 
 	clk_prepare_unlock();
 
@@ -193,21 +202,19 @@ static int clk_dump(struct seq_file *s, void *data)
 {
 	struct clk *c;
 	bool first_node = true;
+	struct hlist_head **lists = (struct hlist_head **)s->private;
 
 	seq_printf(s, "{");
 
 	clk_prepare_lock();
 
-	hlist_for_each_entry(c, &clk_root_list, child_node) {
-		if (!first_node)
-			seq_printf(s, ",");
-		first_node = false;
-		clk_dump_subtree(s, c, 0);
-	}
-
-	hlist_for_each_entry(c, &clk_orphan_list, child_node) {
-		seq_printf(s, ",");
-		clk_dump_subtree(s, c, 0);
+	for (; *lists; lists++) {
+		hlist_for_each_entry(c, *lists, child_node) {
+			if (!first_node)
+				seq_puts(s, ",");
+			first_node = false;
+			clk_dump_subtree(s, c, 0);
+		}
 	}
 
 	clk_prepare_unlock();
@@ -305,7 +312,7 @@ static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)
 		goto out;
 
 	hlist_for_each_entry(child, &clk->children, child_node)
-		clk_debug_create_subtree(child, clk->dentry);
+		clk_debug_create_subtree(child, pdentry);
 
 	ret = 0;
 out:
@@ -325,31 +332,12 @@ static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)
  */
 static int clk_debug_register(struct clk *clk)
 {
-	struct clk *parent;
-	struct dentry *pdentry;
 	int ret = 0;
 
 	if (!inited)
 		goto out;
 
-	parent = clk->parent;
-
-	/*
-	 * Check to see if a clk is a root clk.  Also check that it is
-	 * safe to add this clk to debugfs
-	 */
-	if (!parent)
-		if (clk->flags & CLK_IS_ROOT)
-			pdentry = rootdir;
-		else
-			pdentry = orphandir;
-	else
-		if (parent->dentry)
-			pdentry = parent->dentry;
-		else
-			goto out;
-
-	ret = clk_debug_create_subtree(clk, pdentry);
+	ret = clk_debug_create_subtree(clk, rootdir);
 
 out:
 	return ret;
@@ -370,39 +358,6 @@ static void clk_debug_unregister(struct clk *clk)
 	debugfs_remove_recursive(clk->dentry);
 }
 
-/**
- * clk_debug_reparent - reparent clk node in the debugfs clk tree
- * @clk: the clk being reparented
- * @new_parent: the new clk parent, may be NULL
- *
- * Rename clk entry in the debugfs clk tree if debugfs has been
- * initialized.  Otherwise it bails out early since the debugfs clk tree
- * will be created lazily by clk_debug_init as part of a late_initcall.
- *
- * Caller must hold prepare_lock.
- */
-static void clk_debug_reparent(struct clk *clk, struct clk *new_parent)
-{
-	struct dentry *d;
-	struct dentry *new_parent_d;
-
-	if (!inited)
-		return;
-
-	if (new_parent)
-		new_parent_d = new_parent->dentry;
-	else
-		new_parent_d = orphandir;
-
-	d = debugfs_rename(clk->dentry->d_parent, clk->dentry,
-			new_parent_d, clk->name);
-	if (d)
-		clk->dentry = d;
-	else
-		pr_debug("%s: failed to rename debugfs entry for %s\n",
-				__func__, clk->name);
-}
-
 /**
  * clk_debug_init - lazily create the debugfs clk tree visualization
  *
@@ -425,19 +380,24 @@ static int __init clk_debug_init(void)
 	if (!rootdir)
 		return -ENOMEM;
 
-	d = debugfs_create_file("clk_summary", S_IRUGO, rootdir, NULL,
+	d = debugfs_create_file("clk_summary", S_IRUGO, rootdir, &all_lists,
 				&clk_summary_fops);
 	if (!d)
 		return -ENOMEM;
 
-	d = debugfs_create_file("clk_dump", S_IRUGO, rootdir, NULL,
+	d = debugfs_create_file("clk_dump", S_IRUGO, rootdir, &all_lists,
 				&clk_dump_fops);
 	if (!d)
 		return -ENOMEM;
 
-	orphandir = debugfs_create_dir("orphans", rootdir);
+	d = debugfs_create_file("clk_orphan_summary", S_IRUGO, rootdir,
+				&orphan_list, &clk_summary_fops);
+	if (!d)
+		return -ENOMEM;
 
-	if (!orphandir)
+	d = debugfs_create_file("clk_orphan_dump", S_IRUGO, rootdir,
+				&orphan_list, &clk_dump_fops);
+	if (!d)
 		return -ENOMEM;
 
 	clk_prepare_lock();
@@ -446,7 +406,7 @@ static int __init clk_debug_init(void)
 		clk_debug_create_subtree(clk, rootdir);
 
 	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
-		clk_debug_create_subtree(clk, orphandir);
+		clk_debug_create_subtree(clk, rootdir);
 
 	inited = 1;
 
@@ -1284,9 +1244,6 @@ static void __clk_set_parent_after(struct clk *clk, struct clk *parent,
 		clk_disable(old_parent);
 		__clk_unprepare(old_parent);
 	}
-
-	/* update debugfs with new clk tree topology */
-	clk_debug_reparent(clk, parent);
 }
 
 static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
@@ -1683,7 +1640,6 @@ static struct clk *__clk_init_parent(struct clk *clk)
 void __clk_reparent(struct clk *clk, struct clk *new_parent)
 {
 	clk_reparent(clk, new_parent);
-	clk_debug_reparent(clk, new_parent);
 	__clk_recalc_accuracies(clk);
 	__clk_recalc_rates(clk, POST_RATE_CHANGE);
 }

commit 1cdf8ee2f88bbc14c697a0b8a2f25f58ed57d591
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jun 3 11:40:14 2014 +0200

    clk: export __clk_round_rate for providers
    
    Commit 99cbd064b0 ("clk: qcom: Support display RCG clocks") adds
    a use of the __clk_round_rate in a clock provided that can be built
    as a loadable module.
    
    This exports the symbol to avoid the build error from compiling
    the qcom clock as a module.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2df2b26297ce..8b73edef151d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1006,6 +1006,7 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 	else
 		return clk->rate;
 }
+EXPORT_SYMBOL_GPL(__clk_round_rate);
 
 /**
  * clk_round_rate - round the given rate for a clk

commit fb8abb7aefe8454e3b478ef11da78ea25b891ad4
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Mar 25 12:16:24 2014 +0100

    clk: Neaten clk_summary output
    
      - Limit ruler to 80 characters (was: 81),
      - Widen rate column by 1 for nicer spacing,
      - Right-align numbers and their column headers,
      - Move a newline to reduce the number of seq_printf() calls,
      - Use set_puts() for fixed strings.
    
    Before:
    
       clock                        enable_cnt  prepare_cnt  rate        accuracy
    ---------------------------------------------------------------------------------
     extal                          2           2            20000000   0
        thermal                     1           1            20000000   0
        cp                          0           0            10000000   0
           tpu0                     0           0            10000000   0
           tmu0                     0           0            10000000   0
        main                        1           1            20000000   0
           pll3                     0           0            1600000000 0
              ddr                   0           0            200000000  0
              zb3d2                 0           0            200000000  0
              zb3                   0           0            400000000  0
           pll1                     4           4            1560000000 0
              oscclk                0           0            126953     0
              rclk                  1           1            31738      0
                 cmt1               0           0            31738      0
                 cmt0               1           1            31738      0
              imp                   0           0            390000000  0
    
    After:
    
       clock                         enable_cnt  prepare_cnt        rate   accuracy
    --------------------------------------------------------------------------------
     extal                                    2            2    20000000          0
        thermal                               1            1    20000000          0
        cp                                    0            0    10000000          0
           tpu0                               0            0    10000000          0
           tmu0                               0            0    10000000          0
        main                                  1            1    20000000          0
           pll3                               0            0  1600000000          0
              ddr                             0            0   200000000          0
              zb3d2                           0            0   200000000          0
              zb3                             0            0   400000000          0
           pll1                               4            4  1560000000          0
              oscclk                          0            0      126953          0
              rclk                            1            1       31738          0
                 cmt1                         0            0       31738          0
                 cmt0                         1            1       31738          0
              imp                             0            0   390000000          0
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4d562206d62f..2df2b26297ce 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -106,12 +106,11 @@ static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
 	if (!c)
 		return;
 
-	seq_printf(s, "%*s%-*s %-11d %-12d %-10lu %-11lu",
+	seq_printf(s, "%*s%-*s %11d %12d %11lu %10lu\n",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
 		   c->enable_count, c->prepare_count, clk_get_rate(c),
 		   clk_get_accuracy(c));
-	seq_printf(s, "\n");
 }
 
 static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
@@ -132,8 +131,8 @@ static int clk_summary_show(struct seq_file *s, void *data)
 {
 	struct clk *c;
 
-	seq_printf(s, "   clock                        enable_cnt  prepare_cnt  rate        accuracy\n");
-	seq_printf(s, "---------------------------------------------------------------------------------\n");
+	seq_puts(s, "   clock                         enable_cnt  prepare_cnt        rate   accuracy\n");
+	seq_puts(s, "--------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 

commit 63589e92c2d975cc63222e5bd4a9a1fa2a1187ac
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Mar 26 16:06:37 2014 -0700

    clk: Ignore error and NULL pointers passed to clk_{unprepare, disable}()
    
    This simplifies error paths in drivers that use optional clocks
    by allowing the NULL or error pointer to be passed
    unconditionally.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3c02be74fd7c..4d562206d62f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -822,6 +822,9 @@ void __clk_unprepare(struct clk *clk)
  */
 void clk_unprepare(struct clk *clk)
 {
+	if (IS_ERR_OR_NULL(clk))
+		return;
+
 	clk_prepare_lock();
 	__clk_unprepare(clk);
 	clk_prepare_unlock();
@@ -883,9 +886,6 @@ static void __clk_disable(struct clk *clk)
 	if (!clk)
 		return;
 
-	if (WARN_ON(IS_ERR(clk)))
-		return;
-
 	if (WARN_ON(clk->enable_count == 0))
 		return;
 
@@ -914,6 +914,9 @@ void clk_disable(struct clk *clk)
 {
 	unsigned long flags;
 
+	if (IS_ERR_OR_NULL(clk))
+		return;
+
 	flags = clk_enable_lock();
 	__clk_disable(clk);
 	clk_enable_unlock(flags);

commit 8f2c2db132cf5f4ffb4b9702ddb7e6bc5a343814
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Mar 26 16:06:36 2014 -0700

    clk: Consolidate recalc rate logic
    
    The same if-else statement exists four times to recalculate the
    rate of a clock. Consolidate this logic into a single function to
    save some lines.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 453cf3d210d2..3c02be74fd7c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1115,6 +1115,13 @@ long clk_get_accuracy(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_accuracy);
 
+static unsigned long clk_recalc(struct clk *clk, unsigned long parent_rate)
+{
+	if (clk->ops->recalc_rate)
+		return clk->ops->recalc_rate(clk->hw, parent_rate);
+	return parent_rate;
+}
+
 /**
  * __clk_recalc_rates
  * @clk: first clk in the subtree
@@ -1140,10 +1147,7 @@ static void __clk_recalc_rates(struct clk *clk, unsigned long msg)
 	if (clk->parent)
 		parent_rate = clk->parent->rate;
 
-	if (clk->ops->recalc_rate)
-		clk->rate = clk->ops->recalc_rate(clk->hw, parent_rate);
-	else
-		clk->rate = parent_rate;
+	clk->rate = clk_recalc(clk, parent_rate);
 
 	/*
 	 * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE
@@ -1334,10 +1338,7 @@ static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 	unsigned long new_rate;
 	int ret = NOTIFY_DONE;
 
-	if (clk->ops->recalc_rate)
-		new_rate = clk->ops->recalc_rate(clk->hw, parent_rate);
-	else
-		new_rate = parent_rate;
+	new_rate = clk_recalc(clk, parent_rate);
 
 	/* abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */
 	if (clk->notifier_count)
@@ -1373,10 +1374,7 @@ static void clk_calc_subtree(struct clk *clk, unsigned long new_rate,
 		new_parent->new_child = clk;
 
 	hlist_for_each_entry(child, &clk->children, child_node) {
-		if (child->ops->recalc_rate)
-			child->new_rate = child->ops->recalc_rate(child->hw, new_rate);
-		else
-			child->new_rate = new_rate;
+		child->new_rate = clk_recalc(child, new_rate);
 		clk_calc_subtree(child, child->new_rate, NULL, 0);
 	}
 }
@@ -1524,10 +1522,7 @@ static void clk_change_rate(struct clk *clk)
 	if (!skip_set_rate && clk->ops->set_rate)
 		clk->ops->set_rate(clk->hw, clk->new_rate, best_parent_rate);
 
-	if (clk->ops->recalc_rate)
-		clk->rate = clk->ops->recalc_rate(clk->hw, best_parent_rate);
-	else
-		clk->rate = best_parent_rate;
+	clk->rate = clk_recalc(clk, best_parent_rate);
 
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);

commit 86a612349fa58467cd63b30748114ec377d61807
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Mar 26 16:06:35 2014 -0700

    clk: Don't check for missing ops in clk_set_parent()
    
    We dereference clk->ops during clock registration so this check
    for NULL ops can't possibly ever be true.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7cf2c093cc54..453cf3d210d2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1716,9 +1716,6 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	if (!clk)
 		return 0;
 
-	if (!clk->ops)
-		return -EINVAL;
-
 	/* verify ops for for multi-parent clks */
 	if ((clk->num_parents > 1) && (!clk->ops->set_parent))
 		return -ENOSYS;

commit 874f224cc52d64c912087e68e3724be95ad80ee7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Apr 18 16:29:43 2014 -0700

    clk: Fix slab corruption in clk_unregister()
    
    When a clock is unregsitered, we iterate over the list of
    children and reparent them to NULL (i.e. orphan list). While
    iterating the list, we should use the safe iterators because the
    children list for this clock is changing when we reparent the
    children to NULL. Failure to iterate safely can lead to slab
    corruption like this:
    
    =============================================================================
    BUG kmalloc-128 (Not tainted): Poison overwritten
    -----------------------------------------------------------------------------
    
    Disabling lock debugging due to kernel taint
    INFO: 0xed0c4900-0xed0c4903. First byte 0x0 instead of 0x6b
    INFO: Allocated in clk_register+0x20/0x1bc age=297 cpu=2 pid=70
     __slab_alloc.isra.39.constprop.42+0x410/0x454
     kmem_cache_alloc_trace+0x200/0x24c
     clk_register+0x20/0x1bc
     devm_clk_register+0x34/0x68
     0xbf0000f0
     platform_drv_probe+0x18/0x48
     driver_probe_device+0x94/0x360
     __driver_attach+0x94/0x98
     bus_for_each_dev+0x54/0x88
     bus_add_driver+0xe8/0x204
     driver_register+0x78/0xf4
     do_one_initcall+0xc4/0x17c
     load_module+0x19ac/0x2294
     SyS_init_module+0xa4/0x110
     ret_fast_syscall+0x0/0x48
    INFO: Freed in clk_unregister+0xd4/0x140 age=23 cpu=2 pid=73
     __slab_free+0x38/0x41c
     clk_unregister+0xd4/0x140
     release_nodes+0x164/0x1d8
     __device_release_driver+0x60/0xb0
     driver_detach+0xb4/0xb8
     bus_remove_driver+0x5c/0xc4
     SyS_delete_module+0x148/0x1d8
     ret_fast_syscall+0x0/0x48
    INFO: Slab 0xeec50b90 objects=25 used=0 fp=0xed0c5400 flags=0x4080
    INFO: Object 0xed0c48c0 @offset=2240 fp=0xed0c4a00
    
    Bytes b4 ed0c48b0: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
    Object ed0c48c0: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
    Object ed0c48d0: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
    Object ed0c48e0: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
    Object ed0c48f0: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
    Object ed0c4900: 00 00 00 00 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  ....kkkkkkkkkkkk
    Object ed0c4910: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
    Object ed0c4920: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
    Object ed0c4930: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.
    Redzone ed0c4940: bb bb bb bb                                      ....
    Padding ed0c49e8: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
    Padding ed0c49f8: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ
    CPU: 3 PID: 75 Comm: mdev Tainted: G    B         3.14.0-11033-g2054ba5ca781 #35
    [<c0014be0>] (unwind_backtrace) from [<c0012240>] (show_stack+0x10/0x14)
    [<c0012240>] (show_stack) from [<c04b74a0>] (dump_stack+0x70/0xbc)
    [<c04b74a0>] (dump_stack) from [<c00f7a78>] (check_bytes_and_report+0xbc/0x100)
    [<c00f7a78>] (check_bytes_and_report) from [<c00f7c48>] (check_object+0x18c/0x218)
    [<c00f7c48>] (check_object) from [<c00f7efc>] (__free_slab+0x104/0x144)
    [<c00f7efc>] (__free_slab) from [<c04b6668>] (__slab_free+0x3dc/0x41c)
    [<c04b6668>] (__slab_free) from [<c014c008>] (load_elf_binary+0x88/0x12b4)
    [<c014c008>] (load_elf_binary) from [<c0105a44>] (search_binary_handler+0x78/0x18c)
    [<c0105a44>] (search_binary_handler) from [<c0106fc0>] (do_execve+0x490/0x5dc)
    [<c0106fc0>] (do_execve) from [<c0036b8c>] (____call_usermodehelper+0x134/0x168)
    [<c0036b8c>] (____call_usermodehelper) from [<c000f048>] (ret_from_fork+0x14/0x2c)
    FIX kmalloc-128: Restoring 0xed0c4900-0xed0c4903=0x6b
    
    Fixes: fcb0ee6a3d33 (clk: Implement clk_unregister)
    Cc: Jiada Wang <jiada_wang@mentor.com>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f71093bf83ab..7cf2c093cc54 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2140,9 +2140,10 @@ void clk_unregister(struct clk *clk)
 
 	if (!hlist_empty(&clk->children)) {
 		struct clk *child;
+		struct hlist_node *t;
 
 		/* Reparent all children to the orphan list. */
-		hlist_for_each_entry(child, &clk->children, child_node)
+		hlist_for_each_entry_safe(child, t, &clk->children, child_node)
 			clk_set_parent(child, NULL);
 	}
 

commit 293ba3b4a4fd54891b900f2911d1a57e1ed4a843
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Apr 18 16:29:42 2014 -0700

    clk: Fix double free due to devm_clk_register()
    
    Now that clk_unregister() frees the struct clk we're
    unregistering we'll free memory twice: first we'll call kfree()
    in __clk_release() with an address kmalloc doesn't know about and
    second we'll call kfree() in the devres layer. Remove the
    allocation of struct clk in devm_clk_register() and let
    clk_release() handle it. This fixes slab errors like:
    
    =============================================================================
    BUG kmalloc-128 (Not tainted): Invalid object pointer 0xed08e8d0
    -----------------------------------------------------------------------------
    
    Disabling lock debugging due to kernel taint
    INFO: Slab 0xeec503f8 objects=25 used=15 fp=0xed08ea00 flags=0x4081
    CPU: 2 PID: 73 Comm: rmmod Tainted: G    B         3.14.0-11032-g526e9c764381 #34
    [<c0014be0>] (unwind_backtrace) from [<c0012240>] (show_stack+0x10/0x14)
    [<c0012240>] (show_stack) from [<c04b74dc>] (dump_stack+0x70/0xbc)
    [<c04b74dc>] (dump_stack) from [<c00f6778>] (slab_err+0x74/0x84)
    [<c00f6778>] (slab_err) from [<c04b6278>] (free_debug_processing+0x2cc/0x31c)
    [<c04b6278>] (free_debug_processing) from [<c04b6300>] (__slab_free+0x38/0x41c)
    [<c04b6300>] (__slab_free) from [<c03931bc>] (clk_unregister+0xd4/0x140)
    [<c03931bc>] (clk_unregister) from [<c02fb774>] (release_nodes+0x164/0x1d8)
    [<c02fb774>] (release_nodes) from [<c02f8698>] (__device_release_driver+0x60/0xb0)
    [<c02f8698>] (__device_release_driver) from [<c02f9080>] (driver_detach+0xb4/0xb8)
    [<c02f9080>] (driver_detach) from [<c02f8480>] (bus_remove_driver+0x5c/0xc4)
    [<c02f8480>] (bus_remove_driver) from [<c008c9b8>] (SyS_delete_module+0x148/0x1d8)
    [<c008c9b8>] (SyS_delete_module) from [<c000ef80>] (ret_fast_syscall+0x0/0x48)
    FIX kmalloc-128: Object at 0xed08e8d0 not freed
    
    Fixes: fcb0ee6a3d33 (clk: Implement clk_unregister)
    Cc: Jiada Wang <jiada_wang@mentor.com>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index dff0373f53c1..f71093bf83ab 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1984,9 +1984,28 @@ struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(__clk_register);
 
-static int _clk_register(struct device *dev, struct clk_hw *hw, struct clk *clk)
+/**
+ * clk_register - allocate a new clock, register it and return an opaque cookie
+ * @dev: device that is registering this clock
+ * @hw: link to hardware-specific clock data
+ *
+ * clk_register is the primary interface for populating the clock tree with new
+ * clock nodes.  It returns a pointer to the newly allocated struct clk which
+ * cannot be dereferenced by driver code but may be used in conjuction with the
+ * rest of the clock API.  In the event of an error clk_register will return an
+ * error code; drivers must test for an error code after calling clk_register.
+ */
+struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 {
 	int i, ret;
+	struct clk *clk;
+
+	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk) {
+		pr_err("%s: could not allocate clk\n", __func__);
+		ret = -ENOMEM;
+		goto fail_out;
+	}
 
 	clk->name = kstrdup(hw->init->name, GFP_KERNEL);
 	if (!clk->name) {
@@ -2026,7 +2045,7 @@ static int _clk_register(struct device *dev, struct clk_hw *hw, struct clk *clk)
 
 	ret = __clk_init(dev, clk);
 	if (!ret)
-		return 0;
+		return clk;
 
 fail_parent_names_copy:
 	while (--i >= 0)
@@ -2035,36 +2054,6 @@ static int _clk_register(struct device *dev, struct clk_hw *hw, struct clk *clk)
 fail_parent_names:
 	kfree(clk->name);
 fail_name:
-	return ret;
-}
-
-/**
- * clk_register - allocate a new clock, register it and return an opaque cookie
- * @dev: device that is registering this clock
- * @hw: link to hardware-specific clock data
- *
- * clk_register is the primary interface for populating the clock tree with new
- * clock nodes.  It returns a pointer to the newly allocated struct clk which
- * cannot be dereferenced by driver code but may be used in conjuction with the
- * rest of the clock API.  In the event of an error clk_register will return an
- * error code; drivers must test for an error code after calling clk_register.
- */
-struct clk *clk_register(struct device *dev, struct clk_hw *hw)
-{
-	int ret;
-	struct clk *clk;
-
-	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
-	if (!clk) {
-		pr_err("%s: could not allocate clk\n", __func__);
-		ret = -ENOMEM;
-		goto fail_out;
-	}
-
-	ret = _clk_register(dev, hw, clk);
-	if (!ret)
-		return clk;
-
 	kfree(clk);
 fail_out:
 	return ERR_PTR(ret);
@@ -2173,7 +2162,7 @@ EXPORT_SYMBOL_GPL(clk_unregister);
 
 static void devm_clk_release(struct device *dev, void *res)
 {
-	clk_unregister(res);
+	clk_unregister(*(struct clk **)res);
 }
 
 /**
@@ -2188,18 +2177,18 @@ static void devm_clk_release(struct device *dev, void *res)
 struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw)
 {
 	struct clk *clk;
-	int ret;
+	struct clk **clkp;
 
-	clk = devres_alloc(devm_clk_release, sizeof(*clk), GFP_KERNEL);
-	if (!clk)
+	clkp = devres_alloc(devm_clk_release, sizeof(*clkp), GFP_KERNEL);
+	if (!clkp)
 		return ERR_PTR(-ENOMEM);
 
-	ret = _clk_register(dev, hw, clk);
-	if (!ret) {
-		devres_add(dev, clk);
+	clk = clk_register(dev, hw);
+	if (!IS_ERR(clk)) {
+		*clkp = clk;
+		devres_add(dev, clkp);
 	} else {
-		devres_free(clk);
-		clk = ERR_PTR(ret);
+		devres_free(clkp);
 	}
 
 	return clk;

commit e5ca8fb4cca90706e115f65097a775795415eca5
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Thu Mar 27 12:08:36 2014 +0100

    clk: Fix minor errors in of_clk_init() function comments
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 6b44022753cb..dff0373f53c1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2591,7 +2591,7 @@ static int parent_ready(struct device_node *np)
  * @matches: array of compatible values and init functions for providers.
  *
  * This function scans the device tree for matching clock providers
- * and calls their initialization functions. It also do it by trying
+ * and calls their initialization functions. It also does it by trying
  * to follow the dependencies.
  */
 void __init of_clk_init(const struct of_device_id *matches)
@@ -2628,7 +2628,7 @@ void __init of_clk_init(const struct of_device_id *matches)
 		}
 
 		/*
-		 * We didn't managed to initialize any of the
+		 * We didn't manage to initialize any of the
 		 * remaining providers during the last loop, so now we
 		 * initialize all the remaining ones unconditionally
 		 * in case the clock parent was not mandatory

commit 3f6d439f202243a1594f2e1b86620af0d342bbe6
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Thu Mar 27 11:43:32 2014 +0100

    clk: reverse default clk provider initialization order in of_clk_init()
    
    This restores the default clocks registration order as parsed from
    devicetree, i.e. as before commit 1771b10d605d26ccee771a7fb4b08718
    "clk: respect the clock dependencies in of_clk_init", for when there
    is no explicit parent clock dependencies between clock providers
    specified in the device tree.
    
    It prevents regressions (boot failure, division by 0 errors) on
    imx and exynos platforms.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Tested-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 1fbcb2b107e7..6b44022753cb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2612,7 +2612,7 @@ void __init of_clk_init(const struct of_device_id *matches)
 
 		parent->clk_init_cb = match->data;
 		parent->np = np;
-		list_add(&parent->node, &clk_provider_list);
+		list_add_tail(&parent->node, &clk_provider_list);
 	}
 
 	while (!list_empty(&clk_provider_list)) {

commit c646cbf10fb3347ecda290dfce96b813a423ca07
Author: Alex Elder <elder@linaro.org>
Date:   Fri Mar 21 06:43:56 2014 -0500

    clk: support hardware-specific debugfs entries
    
    Add a new clk_ops->debug_init method to allow a clock hardware
    driver to populate the clock's debugfs directory with entries
    beyond those common for every clock.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fb3c40b4fbe2..1fbcb2b107e7 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -277,6 +277,10 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
+	if (clk->ops->debug_init)
+		if (clk->ops->debug_init(clk->hw, clk->dentry))
+			goto err_out;
+
 	ret = 0;
 	goto out;
 

commit f736386160f7d7419499f877b5abb1412ab4aa32
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Jan 16 16:12:55 2014 +0100

    clk: turn rate change failed warning into pr_debug
    
    If a rate change failed it's the opportunity of the caller to handle
    this. Do not spam the log with a message.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index e1a192240055..fb3c40b4fbe2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1591,7 +1591,7 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	/* notify that we are about to change rates */
 	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
 	if (fail_clk) {
-		pr_warn("%s: failed to set %s rate\n", __func__,
+		pr_debug("%s: failed to set %s rate\n", __func__,
 				fail_clk->name);
 		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
 		ret = -EBUSY;

commit 1771b10d605d26ccee771a7fb4b08718c124097a
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Mon Feb 24 19:10:13 2014 +0100

    clk: respect the clock dependencies in of_clk_init
    
    Until now the clock providers were initialized in the order found in
    the device tree. This led to have the dependencies between the clocks
    not respected: children clocks could be initialized before their
    parent clocks.
    
    Instead of forcing each platform to manage its own initialization order,
    this patch adds this work inside the framework itself.
    
    Using the data of the device tree the of_clk_init function now delayed
    the initialization of a clock provider if its parent provider was not
    ready yet.
    
    The strict dependency check (all parents of a given clk must be
    initialized) was added by Boris BREZILLON
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Boris BREZILLON <b.brezillon@overkiz.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 895b3d204e22..e1a192240055 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2539,24 +2539,99 @@ const char *of_clk_get_parent_name(struct device_node *np, int index)
 }
 EXPORT_SYMBOL_GPL(of_clk_get_parent_name);
 
+struct clock_provider {
+	of_clk_init_cb_t clk_init_cb;
+	struct device_node *np;
+	struct list_head node;
+};
+
+static LIST_HEAD(clk_provider_list);
+
+/*
+ * This function looks for a parent clock. If there is one, then it
+ * checks that the provider for this parent clock was initialized, in
+ * this case the parent clock will be ready.
+ */
+static int parent_ready(struct device_node *np)
+{
+	int i = 0;
+
+	while (true) {
+		struct clk *clk = of_clk_get(np, i);
+
+		/* this parent is ready we can check the next one */
+		if (!IS_ERR(clk)) {
+			clk_put(clk);
+			i++;
+			continue;
+		}
+
+		/* at least one parent is not ready, we exit now */
+		if (PTR_ERR(clk) == -EPROBE_DEFER)
+			return 0;
+
+		/*
+		 * Here we make assumption that the device tree is
+		 * written correctly. So an error means that there is
+		 * no more parent. As we didn't exit yet, then the
+		 * previous parent are ready. If there is no clock
+		 * parent, no need to wait for them, then we can
+		 * consider their absence as being ready
+		 */
+		return 1;
+	}
+}
+
 /**
  * of_clk_init() - Scan and init clock providers from the DT
  * @matches: array of compatible values and init functions for providers.
  *
- * This function scans the device tree for matching clock providers and
- * calls their initialization functions
+ * This function scans the device tree for matching clock providers
+ * and calls their initialization functions. It also do it by trying
+ * to follow the dependencies.
  */
 void __init of_clk_init(const struct of_device_id *matches)
 {
 	const struct of_device_id *match;
 	struct device_node *np;
+	struct clock_provider *clk_provider, *next;
+	bool is_init_done;
+	bool force = false;
 
 	if (!matches)
 		matches = &__clk_of_table;
 
+	/* First prepare the list of the clocks providers */
 	for_each_matching_node_and_match(np, matches, &match) {
-		of_clk_init_cb_t clk_init_cb = match->data;
-		clk_init_cb(np);
+		struct clock_provider *parent =
+			kzalloc(sizeof(struct clock_provider),	GFP_KERNEL);
+
+		parent->clk_init_cb = match->data;
+		parent->np = np;
+		list_add(&parent->node, &clk_provider_list);
+	}
+
+	while (!list_empty(&clk_provider_list)) {
+		is_init_done = false;
+		list_for_each_entry_safe(clk_provider, next,
+					&clk_provider_list, node) {
+			if (force || parent_ready(clk_provider->np)) {
+				clk_provider->clk_init_cb(clk_provider->np);
+				list_del(&clk_provider->node);
+				kfree(clk_provider);
+				is_init_done = true;
+			}
+		}
+
+		/*
+		 * We didn't managed to initialize any of the
+		 * remaining providers during the last loop, so now we
+		 * initialize all the remaining ones unconditionally
+		 * in case the clock parent was not mandatory
+		 */
+		if (!is_init_done)
+			force = true;
+
 	}
 }
 #endif

commit ad077ceb8a90c7ef1fc15758ed3811448181ee80
Merge: c05ab9a0cc8e 10b7cdc0084c
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Feb 24 23:07:53 2014 -0800

    Merge branch 'clk-fixes' into clk-next

commit 00efcb1c8e1c3c5e5d3ce6f0682d66402911a84f
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Tue Jan 7 13:03:43 2014 +0100

    clk: Correct handling of NULL clk in __clk_{get, put}
    
    Ensure clk->kref is dereferenced only when clk is not NULL.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Tested-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5517944495d8..c42e608af6bb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2226,24 +2226,25 @@ EXPORT_SYMBOL_GPL(devm_clk_unregister);
  */
 int __clk_get(struct clk *clk)
 {
-	if (clk && !try_module_get(clk->owner))
-		return 0;
+	if (clk) {
+		if (!try_module_get(clk->owner))
+			return 0;
 
-	kref_get(&clk->ref);
+		kref_get(&clk->ref);
+	}
 	return 1;
 }
 
 void __clk_put(struct clk *clk)
 {
-	if (WARN_ON_ONCE(IS_ERR(clk)))
+	if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
 		return;
 
 	clk_prepare_lock();
 	kref_put(&clk->ref, __clk_release);
 	clk_prepare_unlock();
 
-	if (clk)
-		module_put(clk->owner);
+	module_put(clk->owner);
 }
 
 /***        clk rate change notifiers        ***/

commit a34cd4666f3da84228a82f70c94b8d9b692034ea
Author: Jean-Francois Moine <moinejf@free.fr>
Date:   Mon Nov 25 19:47:04 2013 +0100

    clk: return probe defer when DT clock not yet ready
    
    At probe time, a clock device may not be ready when some other device
    wants to use it.
    
    This patch lets the functions clk_get/devm_clk_get return a probe defer
    when the clock is defined in the DT but not yet available.
    
    Signed-off-by: Jean-Francois Moine <moinejf@free.fr>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Tested-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f30e6af90332..cc2ca9aebe02 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2466,7 +2466,7 @@ EXPORT_SYMBOL_GPL(of_clk_del_provider);
 struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec)
 {
 	struct of_clk_provider *provider;
-	struct clk *clk = ERR_PTR(-ENOENT);
+	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
 
 	/* Check if we have such a provider in our array */
 	list_for_each_entry(provider, &of_clk_providers, link) {

commit 86bcfa2e87c42b8af77188e7a939e952199d4da1
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Feb 24 16:08:41 2014 -0800

    clk: add pr_debug & kerneldoc around clk notifiers
    
    Both the pr_err and the additional kerneldoc aim to help when debugging
    errors thrown from within a clock rate-change notifier callback.
    
    Reported-by: Sren Brinkmann <soren.brinkmann@xilinx.com>
    Acked-by: Sren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a6f079d23eaa..f30e6af90332 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1339,8 +1339,11 @@ static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 	if (clk->notifier_count)
 		ret = __clk_notify(clk, PRE_RATE_CHANGE, clk->rate, new_rate);
 
-	if (ret & NOTIFY_STOP_MASK)
+	if (ret & NOTIFY_STOP_MASK) {
+		pr_debug("%s: clk notifier callback for clock %s aborted with error %d\n",
+				__func__, clk->name, ret);
 		goto out;
+	}
 
 	hlist_for_each_entry(child, &clk->children, child_node) {
 		ret = __clk_speculate_rates(child, new_rate);

commit 7a0fc1a3df82d29e00b4c9f88a6b37450d6711f1
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Thu Feb 13 18:02:49 2014 +0000

    clk: add clock-indices support
    
    Add a property called clock-indices to allow clock-output-names
    to be used where the index used to lookup a clock is not a 1:1
    mapping to the array position in the clock-output-names
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ea2ca9ff2677..a6f079d23eaa 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2496,8 +2496,12 @@ EXPORT_SYMBOL_GPL(of_clk_get_parent_count);
 const char *of_clk_get_parent_name(struct device_node *np, int index)
 {
 	struct of_phandle_args clkspec;
+	struct property *prop;
 	const char *clk_name;
+	const __be32 *vp;
+	u32 pv;
 	int rc;
+	int count;
 
 	if (index < 0)
 		return NULL;
@@ -2507,8 +2511,22 @@ const char *of_clk_get_parent_name(struct device_node *np, int index)
 	if (rc)
 		return NULL;
 
+	index = clkspec.args_count ? clkspec.args[0] : 0;
+	count = 0;
+
+	/* if there is an indices property, use it to transfer the index
+	 * specified into an array offset for the clock-output-names property.
+	 */
+	of_property_for_each_u32(clkspec.np, "clock-indices", prop, vp, pv) {
+		if (index == pv) {
+			index = count;
+			break;
+		}
+		count++;
+	}
+
 	if (of_property_read_string_index(clkspec.np, "clock-output-names",
-					  clkspec.args_count ? clkspec.args[0] : 0,
+					  index,
 					  &clk_name) < 0)
 		clk_name = clkspec.np->name;
 

commit 5324fda79e28d1d4db0631369b39ff263d0142b4
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Wed Jan 22 11:48:37 2014 -0800

    clk: Fix notifier documentation
    
    Contradicting to documenation, the notifier callbacks do receive
    the original clock rate in struct clk_notifier_data.old_rate and the new
    frequency struct clk_notifier_data.new_rate, independent of the
    notification reason.
    
    This behavior also seems to make more sense, since callbacks can use the
    same code to deterimine whether clocks are scaled up or down. Something
    which would not even possible in the post-rate-change case if the
    behavior was as documented.
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5517944495d8..ea2ca9ff2677 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2259,20 +2259,11 @@ void __clk_put(struct clk *clk)
  * re-enter into the clk framework by calling any top-level clk APIs;
  * this will cause a nested prepare_lock mutex.
  *
- * Pre-change notifier callbacks will be passed the current, pre-change
- * rate of the clk via struct clk_notifier_data.old_rate.  The new,
- * post-change rate of the clk is passed via struct
+ * In all notification cases cases (pre, post and abort rate change) the
+ * original clock rate is passed to the callback via struct
+ * clk_notifier_data.old_rate and the new frequency is passed via struct
  * clk_notifier_data.new_rate.
  *
- * Post-change notifiers will pass the now-current, post-change rate of
- * the clk in both struct clk_notifier_data.old_rate and struct
- * clk_notifier_data.new_rate.
- *
- * Abort-change notifiers are effectively the opposite of pre-change
- * notifiers: the original pre-change clk rate is passed in via struct
- * clk_notifier_data.new_rate and the failed post-change rate is passed
- * in via struct clk_notifier_data.old_rate.
- *
  * clk_notifier_register() must be called from non-atomic context.
  * Returns -EINVAL if called with null arguments, -ENOMEM upon
  * allocation failure; otherwise, passes along the return value of

commit 0b7f04b868ec1230cf2dd698697dbc32a509ea4d
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jan 17 19:47:17 2014 -0800

    clk: Export more clk-provider functions
    
    Allow drivers to be compiled as modules by exporting more clock
    provider functions.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 077106732550..5517944495d8 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -575,16 +575,19 @@ struct clk_hw *__clk_get_hw(struct clk *clk)
 {
 	return !clk ? NULL : clk->hw;
 }
+EXPORT_SYMBOL_GPL(__clk_get_hw);
 
 u8 __clk_get_num_parents(struct clk *clk)
 {
 	return !clk ? 0 : clk->num_parents;
 }
+EXPORT_SYMBOL_GPL(__clk_get_num_parents);
 
 struct clk *__clk_get_parent(struct clk *clk)
 {
 	return !clk ? NULL : clk->parent;
 }
+EXPORT_SYMBOL_GPL(__clk_get_parent);
 
 struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
 {
@@ -598,6 +601,7 @@ struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
 	else
 		return clk->parents[index];
 }
+EXPORT_SYMBOL_GPL(clk_get_parent_by_index);
 
 unsigned int __clk_get_enable_count(struct clk *clk)
 {
@@ -629,6 +633,7 @@ unsigned long __clk_get_rate(struct clk *clk)
 out:
 	return ret;
 }
+EXPORT_SYMBOL_GPL(__clk_get_rate);
 
 unsigned long __clk_get_accuracy(struct clk *clk)
 {
@@ -685,6 +690,7 @@ bool __clk_is_enabled(struct clk *clk)
 out:
 	return !!ret;
 }
+EXPORT_SYMBOL_GPL(__clk_is_enabled);
 
 static struct clk *__clk_lookup_subtree(const char *name, struct clk *clk)
 {
@@ -776,6 +782,7 @@ long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
 
 	return best;
 }
+EXPORT_SYMBOL_GPL(__clk_mux_determine_rate);
 
 /***        clk api        ***/
 

commit 819b4861c18d602463cfe815041d11fd81002654
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Oct 22 11:39:36 2013 +0300

    CLK: ti: add init support for clock IP blocks
    
    ti_dt_clk_init_provider() can now be used to initialize the contents of
    a single clock IP block. This parses all the clocks under the IP block
    and calls the corresponding init function for them.
    
    This patch also introduces a helper function for the TI clock drivers
    to get register info from DT and append the master IP info to this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2b38dc99063f..077106732550 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2373,8 +2373,6 @@ struct of_clk_provider {
 	void *data;
 };
 
-extern struct of_device_id __clk_of_table[];
-
 static const struct of_device_id __clk_of_table_sentinel
 	__used __section(__clk_of_table_end);
 
@@ -2534,7 +2532,7 @@ void __init of_clk_init(const struct of_device_id *matches)
 	struct device_node *np;
 
 	if (!matches)
-		matches = __clk_of_table;
+		matches = &__clk_of_table;
 
 	for_each_matching_node_and_match(np, matches, &match) {
 		of_clk_init_cb_t clk_init_cb = match->data;

commit 3fa2252b7a78a8057017471a28f47b306e95ee26
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jan 15 10:47:22 2014 -0800

    clk: Add set_rate_and_parent() op
    
    Some of Qualcomm's clocks can change their parent and rate at the
    same time with a single register write. Add support for this
    hardware to the common clock framework by adding a new
    set_rate_and_parent() op. When the clock framework determines
    that both the parent and the rate are going to change during
    clk_set_rate() it will call the .set_rate_and_parent() op if
    available and fall back to calling .set_parent() followed by
    .set_rate() otherwise.
    
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index e3e03270b95e..2b38dc99063f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1218,10 +1218,9 @@ static void clk_reparent(struct clk *clk, struct clk *new_parent)
 	clk->parent = new_parent;
 }
 
-static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
+static struct clk *__clk_set_parent_before(struct clk *clk, struct clk *parent)
 {
 	unsigned long flags;
-	int ret = 0;
 	struct clk *old_parent = clk->parent;
 
 	/*
@@ -1252,6 +1251,34 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
 	clk_reparent(clk, parent);
 	clk_enable_unlock(flags);
 
+	return old_parent;
+}
+
+static void __clk_set_parent_after(struct clk *clk, struct clk *parent,
+		struct clk *old_parent)
+{
+	/*
+	 * Finish the migration of prepare state and undo the changes done
+	 * for preventing a race with clk_enable().
+	 */
+	if (clk->prepare_count) {
+		clk_disable(clk);
+		clk_disable(old_parent);
+		__clk_unprepare(old_parent);
+	}
+
+	/* update debugfs with new clk tree topology */
+	clk_debug_reparent(clk, parent);
+}
+
+static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
+{
+	unsigned long flags;
+	int ret = 0;
+	struct clk *old_parent;
+
+	old_parent = __clk_set_parent_before(clk, parent);
+
 	/* change clock input source */
 	if (parent && clk->ops->set_parent)
 		ret = clk->ops->set_parent(clk->hw, p_index);
@@ -1269,18 +1296,8 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
 		return ret;
 	}
 
-	/*
-	 * Finish the migration of prepare state and undo the changes done
-	 * for preventing a race with clk_enable().
-	 */
-	if (clk->prepare_count) {
-		clk_disable(clk);
-		clk_disable(old_parent);
-		__clk_unprepare(old_parent);
-	}
+	__clk_set_parent_after(clk, parent, old_parent);
 
-	/* update debugfs with new clk tree topology */
-	clk_debug_reparent(clk, parent);
 	return 0;
 }
 
@@ -1465,17 +1482,32 @@ static void clk_change_rate(struct clk *clk)
 	struct clk *child;
 	unsigned long old_rate;
 	unsigned long best_parent_rate = 0;
+	bool skip_set_rate = false;
+	struct clk *old_parent;
 
 	old_rate = clk->rate;
 
-	/* set parent */
-	if (clk->new_parent && clk->new_parent != clk->parent)
-		__clk_set_parent(clk, clk->new_parent, clk->new_parent_index);
-
-	if (clk->parent)
+	if (clk->new_parent)
+		best_parent_rate = clk->new_parent->rate;
+	else if (clk->parent)
 		best_parent_rate = clk->parent->rate;
 
-	if (clk->ops->set_rate)
+	if (clk->new_parent && clk->new_parent != clk->parent) {
+		old_parent = __clk_set_parent_before(clk, clk->new_parent);
+
+		if (clk->ops->set_rate_and_parent) {
+			skip_set_rate = true;
+			clk->ops->set_rate_and_parent(clk->hw, clk->new_rate,
+					best_parent_rate,
+					clk->new_parent_index);
+		} else if (clk->ops->set_parent) {
+			clk->ops->set_parent(clk->hw, clk->new_parent_index);
+		}
+
+		__clk_set_parent_after(clk, clk->new_parent, old_parent);
+	}
+
+	if (!skip_set_rate && clk->ops->set_rate)
 		clk->ops->set_rate(clk->hw, clk->new_rate, best_parent_rate);
 
 	if (clk->ops->recalc_rate)
@@ -1770,6 +1802,14 @@ int __clk_init(struct device *dev, struct clk *clk)
 		goto out;
 	}
 
+	if (clk->ops->set_rate_and_parent &&
+			!(clk->ops->set_parent && clk->ops->set_rate)) {
+		pr_warn("%s: %s must implement .set_parent & .set_rate\n",
+				__func__, clk->name);
+		ret = -EINVAL;
+		goto out;
+	}
+
 	/* throw a WARN if any entries in parent_names are NULL */
 	for (i = 0; i < clk->num_parents; i++)
 		WARN(!clk->parent_names[i],

commit dbdf6ff51e3ce13ade5834b0d7d451522fcdb478
Merge: 391e3903e637 9ffe29d780dd
Author: Mike Turquette <mturquette@linaro.org>
Date:   Tue Dec 31 11:35:12 2013 -0800

    Merge branch 'clk-next-unregister' into clk-next
    
    Conflicts:
            drivers/clk/clk.c

commit ea72dc2cf9552631e43327ce593bdbb0b9fdf058
Author: Mike Turquette <mturquette@linaro.org>
Date:   Wed Dec 18 21:38:52 2013 -0800

    clk: remove CONFIG_COMMON_CLK_DEBUG
    
    Populate ${DEBUGS_MOUNT_POINT}/clk if CONFIG_DEBUG_FS is set. This
    eliminates the extra (annoying) step of enabling the config option
    manually.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fbe08f618d59..b7f6e99e61eb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -92,7 +92,7 @@ static void clk_enable_unlock(unsigned long flags)
 
 /***        debugfs support        ***/
 
-#ifdef CONFIG_COMMON_CLK_DEBUG
+#ifdef CONFIG_DEBUG_FS
 #include <linux/debugfs.h>
 
 static struct dentry *rootdir;

commit 5279fc402ae59361a224d641d5823b21b4206232
Author: Boris BREZILLON <b.brezillon@overkiz.com>
Date:   Sat Dec 21 10:34:47 2013 +0100

    clk: add clk accuracy retrieval support
    
    The clock accuracy is expressed in ppb (parts per billion) and represents
    the possible clock drift.
    Say you have a clock (e.g. an oscillator) which provides a fixed clock of
    20MHz with an accuracy of +- 20Hz. This accuracy expressed in ppb is
    20Hz/20MHz = 1000 ppb (or 1 ppm).
    
    Clock users may need the clock accuracy information in order to choose
    the best clock (the one with the best accuracy) across several available
    clocks.
    
    This patch adds clk accuracy retrieval support for common clk framework by
    means of a new function called clk_get_accuracy.
    This function returns the given clock accuracy expressed in ppb.
    
    In order to get the clock accuracy, this implementation adds one callback
    called recalc_accuracy to the clk_ops structure.
    This callback is given the parent clock accuracy (if the clock is not a
    root clock) and should recalculate the given clock accuracy.
    
    This callback is optional and may be implemented if the clock is not
    a perfect clock (accuracy != 0 ppb).
    
    Signed-off-by: Boris BREZILLON <b.brezillon@overkiz.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 83127363ad4c..fbe08f618d59 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -104,10 +104,11 @@ static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
 	if (!c)
 		return;
 
-	seq_printf(s, "%*s%-*s %-11d %-12d %-10lu",
+	seq_printf(s, "%*s%-*s %-11d %-12d %-10lu %-11lu",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
-		   c->enable_count, c->prepare_count, clk_get_rate(c));
+		   c->enable_count, c->prepare_count, clk_get_rate(c),
+		   clk_get_accuracy(c));
 	seq_printf(s, "\n");
 }
 
@@ -129,8 +130,8 @@ static int clk_summary_show(struct seq_file *s, void *data)
 {
 	struct clk *c;
 
-	seq_printf(s, "   clock                        enable_cnt  prepare_cnt  rate\n");
-	seq_printf(s, "---------------------------------------------------------------------\n");
+	seq_printf(s, "   clock                        enable_cnt  prepare_cnt  rate        accuracy\n");
+	seq_printf(s, "---------------------------------------------------------------------------------\n");
 
 	clk_prepare_lock();
 
@@ -167,6 +168,7 @@ static void clk_dump_one(struct seq_file *s, struct clk *c, int level)
 	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
 	seq_printf(s, "\"rate\": %lu", clk_get_rate(c));
+	seq_printf(s, "\"accuracy\": %lu", clk_get_accuracy(c));
 }
 
 static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
@@ -248,6 +250,11 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 	if (!d)
 		goto err_out;
 
+	d = debugfs_create_u32("clk_accuracy", S_IRUGO, clk->dentry,
+			(u32 *)&clk->accuracy);
+	if (!d)
+		goto err_out;
+
 	d = debugfs_create_x32("clk_flags", S_IRUGO, clk->dentry,
 			(u32 *)&clk->flags);
 	if (!d)
@@ -603,6 +610,14 @@ unsigned long __clk_get_rate(struct clk *clk)
 	return ret;
 }
 
+unsigned long __clk_get_accuracy(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	return clk->accuracy;
+}
+
 unsigned long __clk_get_flags(struct clk *clk)
 {
 	return !clk ? 0 : clk->flags;
@@ -1016,6 +1031,59 @@ static int __clk_notify(struct clk *clk, unsigned long msg,
 	return ret;
 }
 
+/**
+ * __clk_recalc_accuracies
+ * @clk: first clk in the subtree
+ *
+ * Walks the subtree of clks starting with clk and recalculates accuracies as
+ * it goes.  Note that if a clk does not implement the .recalc_accuracy
+ * callback then it is assumed that the clock will take on the accuracy of it's
+ * parent.
+ *
+ * Caller must hold prepare_lock.
+ */
+static void __clk_recalc_accuracies(struct clk *clk)
+{
+	unsigned long parent_accuracy = 0;
+	struct clk *child;
+
+	if (clk->parent)
+		parent_accuracy = clk->parent->accuracy;
+
+	if (clk->ops->recalc_accuracy)
+		clk->accuracy = clk->ops->recalc_accuracy(clk->hw,
+							  parent_accuracy);
+	else
+		clk->accuracy = parent_accuracy;
+
+	hlist_for_each_entry(child, &clk->children, child_node)
+		__clk_recalc_accuracies(child);
+}
+
+/**
+ * clk_get_accuracy - return the accuracy of clk
+ * @clk: the clk whose accuracy is being returned
+ *
+ * Simply returns the cached accuracy of the clk, unless
+ * CLK_GET_ACCURACY_NOCACHE flag is set, which means a recalc_rate will be
+ * issued.
+ * If clk is NULL then returns 0.
+ */
+long clk_get_accuracy(struct clk *clk)
+{
+	unsigned long accuracy;
+
+	clk_prepare_lock();
+	if (clk && (clk->flags & CLK_GET_ACCURACY_NOCACHE))
+		__clk_recalc_accuracies(clk);
+
+	accuracy = __clk_get_accuracy(clk);
+	clk_prepare_unlock();
+
+	return accuracy;
+}
+EXPORT_SYMBOL_GPL(clk_get_accuracy);
+
 /**
  * __clk_recalc_rates
  * @clk: first clk in the subtree
@@ -1552,6 +1620,7 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
 {
 	clk_reparent(clk, new_parent);
 	clk_debug_reparent(clk, new_parent);
+	__clk_recalc_accuracies(clk);
 	__clk_recalc_rates(clk, POST_RATE_CHANGE);
 }
 
@@ -1622,11 +1691,13 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	/* do the re-parent */
 	ret = __clk_set_parent(clk, parent, p_index);
 
-	/* propagate rate recalculation accordingly */
-	if (ret)
+	/* propagate rate an accuracy recalculation accordingly */
+	if (ret) {
 		__clk_recalc_rates(clk, ABORT_RATE_CHANGE);
-	else
+	} else {
 		__clk_recalc_rates(clk, POST_RATE_CHANGE);
+		__clk_recalc_accuracies(clk);
+	}
 
 out:
 	clk_prepare_unlock();
@@ -1730,6 +1801,21 @@ int __clk_init(struct device *dev, struct clk *clk)
 	else
 		hlist_add_head(&clk->child_node, &clk_orphan_list);
 
+	/*
+	 * Set clk's accuracy.  The preferred method is to use
+	 * .recalc_accuracy. For simple clocks and lazy developers the default
+	 * fallback is to use the parent's accuracy.  If a clock doesn't have a
+	 * parent (or is orphaned) then accuracy is set to zero (perfect
+	 * clock).
+	 */
+	if (clk->ops->recalc_accuracy)
+		clk->accuracy = clk->ops->recalc_accuracy(clk->hw,
+					__clk_get_accuracy(clk->parent));
+	else if (clk->parent)
+		clk->accuracy = clk->parent->accuracy;
+	else
+		clk->accuracy = 0;
+
 	/*
 	 * Set clk's rate.  The preferred method is to use .recalc_rate.  For
 	 * simple clocks and lazy developers the default fallback is to use the

commit 3a5aec246f294004564cbe960724fa0ace59a4c5
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Oct 16 00:40:03 2013 -0700

    clk: Fix debugfs reparenting NULL pointer dereference
    
    Adding clocks from a kernel module can cause a NULL pointer
    dereference if the parent of a clock is added after the clock is
    added. This happens because __clk_init() iterates over the list
    of orphans and reparents the orphans to the clock being
    registered before creating the debugfs entry for the clock.
    Create the debugfs entry first before reparenting the orphans.
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000028
    pgd = ef3e4000
    [00000028] *pgd=bf810831
    Internal error: Oops: 17 [#1] PREEMPT SMP ARM
    Modules linked in: mmcc_8960(+)
    CPU: 0 PID: 52 Comm: modprobe Not tainted 3.12.0-rc2-00023-g1021a28-dirty #659
    task: ef319200 ti: ef3a6000 task.ti: ef3a6000
    PC is at lock_rename+0x24/0xc4
    LR is at debugfs_rename+0x34/0x208
    pc : [<c0317238>]    lr : [<c047dfe4>]    psr: 00000013
    sp : ef3a7b88  ip : ef3a7ba8  fp : ef3a7ba4
    r10: ef3d51cc  r9 : ef3bc680  r8 : ef3d5210
    r7 : ef3bc640  r6 : eee287e0  r5 : eee287e0  r4 : 00000000
    r3 : ef3bc640  r2 : 00000000  r1 : eee287e0  r0 : 00000000
    Flags: nzcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 10c5787d  Table: af3e406a  DAC: 00000015
    Process modprobe (pid: 52, stack limit = 0xef3a6240)
    Stack: (0xef3a7b88 to 0xef3a8000)
    7b80:                   ef3bc640 ee4047e0 00000000 eee287e0 ef3a7bec ef3a7ba8
    7ba0: c047dfe4 c0317220 ef3bc680 ef3d51cc ef3a7bdc ef3a7bc0 c06e29d0 c0268784
    7bc0: c08946e8 ef3d5210 00000000 ef3bc700 ef3d5290 ef3d5210 ef3bc680 ef3d51cc
    7be0: ef3a7c0c ef3a7bf0 c05b9e9c c047dfbc 00000000 00000000 ef3d5210 ef3d5290
    7c00: ef3a7c24 ef3a7c10 c05baebc c05b9e30 00000001 00000001 ef3a7c64 ef3a7c28
    7c20: c05bb124 c05bae9c bf000cd8 ef3bc7c0 000000d0 c0ff129c bf001774 00000002
    7c40: ef3bc740 ef3d5290 ef0f9a10 bf001774 bf00042c 00000061 ef3a7c8c ef3a7c68
    7c60: c05bb480 c05baed8 bf001774 ef3d5290 ef0f9a10 bf001774 ef38bc10 ef0f9a00
    7c80: ef3a7cac ef3a7c90 c05bb5a8 c05bb3a0 bf001774 00000062 ef0f9a10 ef38bc18
    7ca0: ef3a7cec ef3a7cb0 bf00010c c05bb56c 00000000 ef38ba00 00000000 ef3d60d0
    7cc0: ef3a7cdc c0fefc24 ef0f9a10 c0a091c0 bf000d24 00000000 bf0029f0 bf006000
    7ce0: ef3a7cfc ef3a7cf0 c05156c0 bf000040 ef3a7d2c ef3a7d00 c0513f5c c05156a8
    7d00: ef3a7d2c ef0f9a10 ef0f9a10 bf000d24 ef0f9a44 c09ca588 00000000 bf006000
    7d20: ef3a7d4c ef3a7d30 c05142b8 c0513ecc ef0fd25c 00000000 bf000d24 c0514214
    7d40: ef3a7d74 ef3a7d50 c0512030 c0514220 ef0050a8 ef0fd250 ef0050f8 bf000d24
    7d60: ef37c100 c09ed150 ef3a7d84 ef3a7d78 c05139c8 c0511fd8 ef3a7
    7d80: c051344c c05139a8 bf000864 c09ca588 ef3a7db4 bf000d24 bf002
    7da0: c09ca588 00000000 ef3a7dcc ef3a7db8 c05149dc c0513360 ef3a7
    7dc0: ef3a7ddc ef3a7dd0 c0515914 c0514960 ef3a7dec ef3a7de0 bf006
    7de0: ef3a7e74 ef3a7df0 c0208800 bf00600c ef3a7e1c ef3a7e00 c04c5
    7e00: ffffffff c09d46c4 00000000 bf0029a8 ef3a7e34 ef3a7e20 c024c
    7e20: ffffffff c09d46c4 ef3a7e5c ef3a7e38 c024e2fc c024ce40 00000
    7e40: ef3a7f48 bf0029b4 bf0029a8 271aeb1c ef3a7f48 bf0029a8 00000001 ef383c00
    7e60: bf0029f0 00000001 ef3a7f3c ef3a7e78 c028fac4 c0208718 bf0029b4 00007fff
    7e80: c028cd58 000000d2 f0065000 00000000 ef3a7ebc 00000000 00000000 bf0029b4
    7ea0: 00000000 bf0029ac bf0029b4 ef3a6000 ef3a7efc c08bf128 00000000 00000000
    7ec0: 00000000 00000000 00000000 00000000 6e72656b 00006c65 00000000 00000000
    7ee0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    7f00: 00000000 00000000 00000000 271aeb1c ef3a7f2c 00016376 b6f38008 001d3774
    7f20: 00000080 c020f968 ef3a6000 00000000 ef3a7fa4 ef3a7f40 c02904dc c028e178
    7f40: c020f898 010ccfa8 f0065000 00016376 f0073f60 f0073d7d f007a1e8 00002b24
    7f60: 000039e4 00000000 00000000 00000000 0000002f 00000030 00000019 00000016
    7f80: 00000012 00000000 00000000 010de1b2 b6f38008 010ccfa8 00000000 ef3a7fa8
    7fa0: c020f6c0 c0290434 010de1b2 b6f38008 b6f38008 00016376 001d3774 00000000
    7fc0: 010de1b2 b6f38008 010ccfa8 00000080 010de1b2 bedb6f90 010de1c9 0001d8dc
    7fe0: 0000000c bedb674c 0001ce30 000094c4 60000010 b6f38008 00000008 0000001d
    [<c0317238>] (lock_rename+0x24/0xc4) from [<c047dfe4>] (debugfs_rename+0x34/0x208)
    [<c047dfe4>] (debugfs_rename+0x34/0x208) from [<c05b9e9c>] (clk_debug_reparent+0x78/0xc0)
    [<c05baebc>] (__clk_reparent+0x2c/0x3c) from [<c05bb124>] (__clk_init+0x258/0x4c8)
    [<c05bb124>] (__clk_init+0x258/0x4c8) from [<c05bb480>] (_clk_register+0xec/0x1cc)
    [<c05bb480>] (_clk_register+0xec/0x1cc) from [<c05bb5a8>] (devm_clk_register+0x48/0x7c)
    [<c05bb5a8>] (devm_clk_register+0x48/0x7c) from [<bf00010c>] (msm_mmcc_8960_probe+0xd8/0x190 [mmcc_8960])
    [<bf00010c>] (msm_mmcc_8960_probe+0xd8/0x190 [mmcc_8960]) from [<c05156c0>] (platform_drv_probe+0x24/0x28)
    [<c05156c0>] (platform_drv_probe+0x24/0x28) from [<c0513f5c>] (driver_probe_device+0x9c/0x354)
    [<c0513f5c>] (driver_probe_device+0x9c/0x354) from [<c05142b8>] (__driver_attach+0xa4/0xa8)
    [<c05142b8>] (__driver_attach+0xa4/0xa8) from [<c0512030>] (bus_for_each_dev+0x64/0x98)
    [<c0512030>] (bus_for_each_dev+0x64/0x98) from [<c05139c8>] (driver_attach+0x2c/0x30)
    [<c05139c8>] (driver_attach+0x2c/0x30) from [<c051344c>] (bus_add_driver+0xf8/0x2a8)
    [<c051344c>] (bus_add_driver+0xf8/0x2a8) from [<c05149dc>] (driver_register+0x88/0x104)
    [<c05149dc>] (driver_register+0x88/0x104) from [<c0515914>] (__platform_driver_register+0x58/0x6c)
    [<c0515914>] (__platform_driver_register+0x58/0x6c) from [<bf006018>] (msm_mmcc_8960_driver_init+0x18/0x24 [mmcc_8960])
    [<bf006018>] (msm_mmcc_8960_driver_init+0x18/0x24 [mmcc_8960]) from [<c0208800>] (do_one_initcall+0xf4/0x1b8)
    [<c0208800>] (do_one_initcall+0xf4/0x1b8) from [<c028fac4>] (load_module+0x1958/0x22bc)
    [<c028fac4>] (load_module+0x1958/0x22bc) from [<c02904dc>] (SyS_init_module+0xb4/0x120)
    [<c02904dc>] (SyS_init_module+0xb4/0x120) from [<c020f6c0>] (ret_fast_syscall+0x0/0x48)
    Code: e1500001 e1a04000 e1a05001 0a000021 (e5903028)
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 77fcd069c64a..83127363ad4c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1744,6 +1744,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 	else
 		clk->rate = 0;
 
+	clk_debug_register(clk);
 	/*
 	 * walk the list of orphan clocks and reparent any that are children of
 	 * this clock
@@ -1774,8 +1775,6 @@ int __clk_init(struct device *dev, struct clk *clk)
 	if (clk->ops->init)
 		clk->ops->init(clk->hw);
 
-	clk_debug_register(clk);
-
 out:
 	clk_prepare_unlock();
 

commit fcb0ee6a3d331fb23dbb546500021f6e4cac5689
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Sat Aug 24 15:00:10 2013 +0200

    clk: Implement clk_unregister
    
    clk_unregister() is currently not implemented and it is required when
    a clock provider module needs to be unloaded.
    
    Normally the clock supplier module is prevented to be unloaded by
    taking reference on the module in clk_get().
    
    For cases when the clock supplier module deinitializes despite the
    consumers of its clocks holding a reference on the module, e.g. when
    the driver is unbound through "unbind" sysfs attribute, there are
    empty clock ops added. These ops are assigned temporarily to struct
    clk and used until all consumers release the clock, to avoid invoking
    callbacks from the module which just got removed.
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index baa2f66a7d19..da7b33e4c5a2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -345,6 +345,21 @@ static int clk_debug_register(struct clk *clk)
 	return ret;
 }
 
+ /**
+ * clk_debug_unregister - remove a clk node from the debugfs clk tree
+ * @clk: the clk being removed from the debugfs clk tree
+ *
+ * Dynamically removes a clk and all it's children clk nodes from the
+ * debugfs clk tree if clk->dentry points to debugfs created by
+ * clk_debug_register in __clk_init.
+ *
+ * Caller must hold prepare_lock.
+ */
+static void clk_debug_unregister(struct clk *clk)
+{
+	debugfs_remove_recursive(clk->dentry);
+}
+
 /**
  * clk_debug_reparent - reparent clk node in the debugfs clk tree
  * @clk: the clk being reparented
@@ -435,6 +450,9 @@ static inline int clk_debug_register(struct clk *clk) { return 0; }
 static inline void clk_debug_reparent(struct clk *clk, struct clk *new_parent)
 {
 }
+static inline void clk_debug_unregister(struct clk *clk)
+{
+}
 #endif
 
 /* caller must hold prepare_lock */
@@ -1778,6 +1796,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 
 	clk_debug_register(clk);
 
+	kref_init(&clk->ref);
 out:
 	clk_prepare_unlock();
 
@@ -1913,13 +1932,104 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(clk_register);
 
+/*
+ * Free memory allocated for a clock.
+ * Caller must hold prepare_lock.
+ */
+static void __clk_release(struct kref *ref)
+{
+	struct clk *clk = container_of(ref, struct clk, ref);
+	int i = clk->num_parents;
+
+	kfree(clk->parents);
+	while (--i >= 0)
+		kfree(clk->parent_names[i]);
+
+	kfree(clk->parent_names);
+	kfree(clk->name);
+	kfree(clk);
+}
+
+/*
+ * Empty clk_ops for unregistered clocks. These are used temporarily
+ * after clk_unregister() was called on a clock and until last clock
+ * consumer calls clk_put() and the struct clk object is freed.
+ */
+static int clk_nodrv_prepare_enable(struct clk_hw *hw)
+{
+	return -ENXIO;
+}
+
+static void clk_nodrv_disable_unprepare(struct clk_hw *hw)
+{
+	WARN_ON_ONCE(1);
+}
+
+static int clk_nodrv_set_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long parent_rate)
+{
+	return -ENXIO;
+}
+
+static int clk_nodrv_set_parent(struct clk_hw *hw, u8 index)
+{
+	return -ENXIO;
+}
+
+static const struct clk_ops clk_nodrv_ops = {
+	.enable		= clk_nodrv_prepare_enable,
+	.disable	= clk_nodrv_disable_unprepare,
+	.prepare	= clk_nodrv_prepare_enable,
+	.unprepare	= clk_nodrv_disable_unprepare,
+	.set_rate	= clk_nodrv_set_rate,
+	.set_parent	= clk_nodrv_set_parent,
+};
+
 /**
  * clk_unregister - unregister a currently registered clock
  * @clk: clock to unregister
- *
- * Currently unimplemented.
  */
-void clk_unregister(struct clk *clk) {}
+void clk_unregister(struct clk *clk)
+{
+	unsigned long flags;
+
+       if (!clk || WARN_ON_ONCE(IS_ERR(clk)))
+               return;
+
+	clk_prepare_lock();
+
+	if (clk->ops == &clk_nodrv_ops) {
+		pr_err("%s: unregistered clock: %s\n", __func__, clk->name);
+		goto out;
+	}
+	/*
+	 * Assign empty clock ops for consumers that might still hold
+	 * a reference to this clock.
+	 */
+	flags = clk_enable_lock();
+	clk->ops = &clk_nodrv_ops;
+	clk_enable_unlock(flags);
+
+	if (!hlist_empty(&clk->children)) {
+		struct clk *child;
+
+		/* Reparent all children to the orphan list. */
+		hlist_for_each_entry(child, &clk->children, child_node)
+			clk_set_parent(child, NULL);
+	}
+
+	clk_debug_unregister(clk);
+
+	hlist_del_init(&clk->child_node);
+
+	if (clk->prepare_count)
+		pr_warn("%s: unregistering prepared clock: %s\n",
+					__func__, clk->name);
+
+	kref_put(&clk->ref, __clk_release);
+out:
+	clk_prepare_unlock();
+}
 EXPORT_SYMBOL_GPL(clk_unregister);
 
 static void devm_clk_release(struct device *dev, void *res)
@@ -1987,6 +2097,7 @@ int __clk_get(struct clk *clk)
 	if (clk && !try_module_get(clk->owner))
 		return 0;
 
+	kref_get(&clk->ref);
 	return 1;
 }
 
@@ -1995,6 +2106,10 @@ void __clk_put(struct clk *clk)
 	if (WARN_ON_ONCE(IS_ERR(clk)))
 		return;
 
+	clk_prepare_lock();
+	kref_put(&clk->ref, __clk_release);
+	clk_prepare_unlock();
+
 	if (clk)
 		module_put(clk->owner);
 }

commit ac2df527fb407b61f9c812a99035b62a75a77d6d
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Sat Aug 24 20:10:41 2013 +0200

    clk: Add common __clk_get(), __clk_put() implementations
    
    This patch adds common __clk_get(), __clk_put() clkdev helpers that
    replace their platform specific counterparts when the common clock
    API is used.
    
    The owner module pointer field is added to struct clk so a reference
    to the clock supplier module can be taken by the clock consumers.
    
    The owner module is assigned while the clock is being registered,
    in functions _clk_register() and __clk_register().
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c687dc8d0b64..baa2f66a7d19 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1813,6 +1813,10 @@ struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
 	clk->flags = hw->init->flags;
 	clk->parent_names = hw->init->parent_names;
 	clk->num_parents = hw->init->num_parents;
+	if (dev && dev->driver)
+		clk->owner = dev->driver->owner;
+	else
+		clk->owner = NULL;
 
 	ret = __clk_init(dev, clk);
 	if (ret)
@@ -1833,6 +1837,8 @@ static int _clk_register(struct device *dev, struct clk_hw *hw, struct clk *clk)
 		goto fail_name;
 	}
 	clk->ops = hw->init->ops;
+	if (dev && dev->driver)
+		clk->owner = dev->driver->owner;
 	clk->hw = hw;
 	clk->flags = hw->init->flags;
 	clk->num_parents = hw->init->num_parents;
@@ -1973,6 +1979,26 @@ void devm_clk_unregister(struct device *dev, struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(devm_clk_unregister);
 
+/*
+ * clkdev helpers
+ */
+int __clk_get(struct clk *clk)
+{
+	if (clk && !try_module_get(clk->owner))
+		return 0;
+
+	return 1;
+}
+
+void __clk_put(struct clk *clk)
+{
+	if (WARN_ON_ONCE(IS_ERR(clk)))
+		return;
+
+	if (clk)
+		module_put(clk->owner);
+}
+
 /***        clk rate change notifiers        ***/
 
 /**

commit d6782c263661abd6c7e8a375141d69fdc457f9e1
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri Aug 23 17:03:43 2013 +0200

    clk: Provide not locked variant of of_clk_get_from_provider()
    
    Add helper functions for the of_clk_providers list locking and
    an unlocked variant of of_clk_get_from_provider().
    These functions are intended to be used in the clkdev to avoid
    race condition in the device tree based clock look up in clk_get().
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 77fcd069c64a..c687dc8d0b64 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -21,6 +21,8 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 
+#include "clk.h"
+
 static DEFINE_SPINLOCK(enable_lock);
 static DEFINE_MUTEX(prepare_lock);
 
@@ -2111,7 +2113,18 @@ static const struct of_device_id __clk_of_table_sentinel
 	__used __section(__clk_of_table_end);
 
 static LIST_HEAD(of_clk_providers);
-static DEFINE_MUTEX(of_clk_lock);
+static DEFINE_MUTEX(of_clk_mutex);
+
+/* of_clk_provider list locking helpers */
+void of_clk_lock(void)
+{
+	mutex_lock(&of_clk_mutex);
+}
+
+void of_clk_unlock(void)
+{
+	mutex_unlock(&of_clk_mutex);
+}
 
 struct clk *of_clk_src_simple_get(struct of_phandle_args *clkspec,
 				     void *data)
@@ -2155,9 +2168,9 @@ int of_clk_add_provider(struct device_node *np,
 	cp->data = data;
 	cp->get = clk_src_get;
 
-	mutex_lock(&of_clk_lock);
+	mutex_lock(&of_clk_mutex);
 	list_add(&cp->link, &of_clk_providers);
-	mutex_unlock(&of_clk_lock);
+	mutex_unlock(&of_clk_mutex);
 	pr_debug("Added clock from %s\n", np->full_name);
 
 	return 0;
@@ -2172,7 +2185,7 @@ void of_clk_del_provider(struct device_node *np)
 {
 	struct of_clk_provider *cp;
 
-	mutex_lock(&of_clk_lock);
+	mutex_lock(&of_clk_mutex);
 	list_for_each_entry(cp, &of_clk_providers, link) {
 		if (cp->node == np) {
 			list_del(&cp->link);
@@ -2181,24 +2194,33 @@ void of_clk_del_provider(struct device_node *np)
 			break;
 		}
 	}
-	mutex_unlock(&of_clk_lock);
+	mutex_unlock(&of_clk_mutex);
 }
 EXPORT_SYMBOL_GPL(of_clk_del_provider);
 
-struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
+struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec)
 {
 	struct of_clk_provider *provider;
 	struct clk *clk = ERR_PTR(-ENOENT);
 
 	/* Check if we have such a provider in our array */
-	mutex_lock(&of_clk_lock);
 	list_for_each_entry(provider, &of_clk_providers, link) {
 		if (provider->node == clkspec->np)
 			clk = provider->get(clkspec, provider->data);
 		if (!IS_ERR(clk))
 			break;
 	}
-	mutex_unlock(&of_clk_lock);
+
+	return clk;
+}
+
+struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
+{
+	struct clk *clk;
+
+	mutex_lock(&of_clk_mutex);
+	clk = __of_clk_get_from_provider(clkspec);
+	mutex_unlock(&of_clk_mutex);
 
 	return clk;
 }

commit b5f98e65c0d887388eb9cbf55c76cb97fb4c2187
Author: Alex Elder <alex.elder@linaro.org>
Date:   Wed Nov 27 09:39:49 2013 -0600

    clk: clean up everything on debugfs error
    
    [Maybe the third time will be the charm. -Alex]
    
    If CONFIG_COMMON_CLK_DEBUG is defined, clk_debug_create_one() is
    called to populate a debugfs directory with a few entries that are
    common for all clock types.
    
    If an error happens after creating the first one debugfs_remove() is
    called on the clock's directory.  The problem with this is that no
    cleanup is done on the debugfs files already created in that
    directory, so the directory never actually gets removed.   This
    problem is silently ignored.
    
    Fix this by calling debugfs_remove_recursive() instead.  Reset the
    clk->dentry field to null afterward, to ensure it can't be mistaken
    as a valid pointer.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2cf2ea6b77a1..77fcd069c64a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -272,7 +272,8 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 	goto out;
 
 err_out:
-	debugfs_remove(clk->dentry);
+	debugfs_remove_recursive(clk->dentry);
+	clk->dentry = NULL;
 out:
 	return ret;
 }

commit f61027426a5bc7093aa8359a411b053a35bb4b68
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Oct 7 23:12:13 2013 -0700

    clk: of: helper for determining number of parent clocks
    
    Walks the "clocks" array of parent clock phandles and returns the
    number.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 32e2fed6d143..2cf2ea6b77a1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2202,6 +2202,12 @@ struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
 	return clk;
 }
 
+int of_clk_get_parent_count(struct device_node *np)
+{
+	return of_count_phandle_with_args(np, "clocks", "#clock-cells");
+}
+EXPORT_SYMBOL_GPL(of_clk_get_parent_count);
+
 const char *of_clk_get_parent_name(struct device_node *np, int index)
 {
 	struct of_phandle_args clkspec;

commit da0f0b2c3ad2ad9533c8c5cae84ad88d57a5e8dc
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Sun Sep 29 02:37:16 2013 +0200

    clk: Correct lookup logic in clk_fetch_parent_index()
    
    This function is supposed to iterate over all parents of given child
    clock to find the index of given parent clock in its parent list,
    using parent cache if possible and falling back to string compare
    otherwise. However currently the logic falls back to string compare in
    every iteration in which clock cache entry does not match given parent,
    due to wrong check conditions.
    
    This patch corrects the logic to continue the loop if parent cache entry
    is present and does not match requested parent clock. In addition,
    redundant checks for parent cache array presence are removed, because it
    is always allocated in the beginning of the function.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 63f9ac16dcb6..32e2fed6d143 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1097,11 +1097,14 @@ static int clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 	 * them now to avoid future calls to __clk_lookup.
 	 */
 	for (i = 0; i < clk->num_parents; i++) {
-		if (clk->parents && clk->parents[i] == parent)
+		if (clk->parents[i] == parent)
 			return i;
-		else if (!strcmp(clk->parent_names[i], parent->name)) {
-			if (clk->parents)
-				clk->parents[i] = __clk_lookup(parent->name);
+
+		if (clk->parents[i])
+			continue;
+
+		if (!strcmp(clk->parent_names[i], parent->name)) {
+			clk->parents[i] = __clk_lookup(parent->name);
 			return i;
 		}
 	}

commit 96a7ed9079a3483c5681b17f4713c37c1cf2b1c9
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Sun Sep 29 02:37:15 2013 +0200

    clk: Use kcalloc() to allocate arrays
    
    Instead of calculating sizes of arrays manually, kcalloc() can be used
    to allocate arrays of elements with defined size. This is just a cleanup
    patch without any functional changes.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9e0a8372f59c..63f9ac16dcb6 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1085,8 +1085,8 @@ static int clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 	int i;
 
 	if (!clk->parents) {
-		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
-								GFP_KERNEL);
+		clk->parents = kcalloc(clk->num_parents,
+					sizeof(struct clk *), GFP_KERNEL);
 		if (!clk->parents)
 			return -ENOMEM;
 	}
@@ -1535,7 +1535,7 @@ static struct clk *__clk_init_parent(struct clk *clk)
 
 	if (!clk->parents)
 		clk->parents =
-			kzalloc((sizeof(struct clk*) * clk->num_parents),
+			kcalloc(clk->num_parents, sizeof(struct clk *),
 					GFP_KERNEL);
 
 	ret = clk_get_parent_by_index(clk, index);
@@ -1692,8 +1692,8 @@ int __clk_init(struct device *dev, struct clk *clk)
 	 * for clock drivers to statically initialize clk->parents.
 	 */
 	if (clk->num_parents > 1 && !clk->parents) {
-		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
-				GFP_KERNEL);
+		clk->parents = kcalloc(clk->num_parents, sizeof(struct clk *),
+					GFP_KERNEL);
 		/*
 		 * __clk_lookup returns NULL for parents that have not been
 		 * clk_init'd; thus any access to clk->parents[] must check
@@ -1833,8 +1833,8 @@ static int _clk_register(struct device *dev, struct clk_hw *hw, struct clk *clk)
 	hw->clk = clk;
 
 	/* allocate local copy in case parent_names is __initdata */
-	clk->parent_names = kzalloc((sizeof(char*) * clk->num_parents),
-			GFP_KERNEL);
+	clk->parent_names = kcalloc(clk->num_parents, sizeof(char *),
+					GFP_KERNEL);
 
 	if (!clk->parent_names) {
 		pr_err("%s: could not allocate clk->parent_names\n", __func__);

commit f1c8b2edf916b5be9dc29e98989a5eaff3c6e75b
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Sun Sep 29 02:37:14 2013 +0200

    clk: Add error handling to clk_fetch_parent_index()
    
    There are at least two different error cases that can happen in
    clk_fetch_parent_index() function:
     - allocation failure,
     - parent clock lookup failure,
    however it returns only an u8, which is supposed to contain parent clock
    index.
    
    This patch modified the function to return full int instead allowing
    positive clock indices and negative error codes to be returned. All
    users of this function are adjusted as well to handle the return value
    correctly.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a004769528e6..9e0a8372f59c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1080,13 +1080,16 @@ unsigned long clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_rate);
 
-static u8 clk_fetch_parent_index(struct clk *clk, struct clk *parent)
+static int clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 {
-	u8 i;
+	int i;
 
-	if (!clk->parents)
+	if (!clk->parents) {
 		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
 								GFP_KERNEL);
+		if (!clk->parents)
+			return -ENOMEM;
+	}
 
 	/*
 	 * find index of new parent clock using cached parent ptrs,
@@ -1095,15 +1098,15 @@ static u8 clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 	 */
 	for (i = 0; i < clk->num_parents; i++) {
 		if (clk->parents && clk->parents[i] == parent)
-			break;
+			return i;
 		else if (!strcmp(clk->parent_names[i], parent->name)) {
 			if (clk->parents)
 				clk->parents[i] = __clk_lookup(parent->name);
-			break;
+			return i;
 		}
 	}
 
-	return i;
+	return -EINVAL;
 }
 
 static void clk_reparent(struct clk *clk, struct clk *new_parent)
@@ -1265,7 +1268,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 	struct clk *old_parent, *parent;
 	unsigned long best_parent_rate = 0;
 	unsigned long new_rate;
-	u8 p_index = 0;
+	int p_index = 0;
 
 	/* sanity */
 	if (IS_ERR_OR_NULL(clk))
@@ -1306,7 +1309,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 	/* try finding the new parent index */
 	if (parent) {
 		p_index = clk_fetch_parent_index(clk, parent);
-		if (p_index == clk->num_parents) {
+		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",
 				 __func__, parent->name, clk->name);
 			return NULL;
@@ -1568,7 +1571,7 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {
 	int ret = 0;
-	u8 p_index = 0;
+	int p_index = 0;
 	unsigned long p_rate = 0;
 
 	if (!clk)
@@ -1597,10 +1600,10 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	if (parent) {
 		p_index = clk_fetch_parent_index(clk, parent);
 		p_rate = parent->rate;
-		if (p_index == clk->num_parents) {
+		if (p_index < 0) {
 			pr_debug("%s: clk %s can not be parent of clk %s\n",
 					__func__, parent->name, clk->name);
-			ret = -EINVAL;
+			ret = p_index;
 			goto out;
 		}
 	}

commit 12d298865ec5d0f14dd570c3506c270880769ed7
Author: Alex Elder <alex.elder@linaro.org>
Date:   Thu Sep 5 08:33:24 2013 -0500

    clk: only call get_parent if there is one
    
    In __clk_init(), after a clock is mostly initialized, a scan is done
    of the orphan clocks to see if the clock being registered is the
    parent of any of them.
    
    This code assumes that any clock that provides a get_parent method
    actually has at least one parent, and that's not a valid assumption.
    
    As a result, an orphan clock with no parent can return *something*
    as the parent index, and that value is blindly used to dereference
    the orphan's parent_names[] array (which will be ZERO_SIZE_PTR or
    NULL).
    
    Fix this by ensuring get_parent is only called for orphans with at
    least one parent.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index cc4cb6fd7d83..a004769528e6 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1742,7 +1742,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 	 * this clock
 	 */
 	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
-		if (orphan->ops->get_parent) {
+		if (orphan->num_parents && orphan->ops->get_parent) {
 			i = orphan->ops->get_parent(orphan->hw);
 			if (!strcmp(clk->name, orphan->parent_names[i]))
 				__clk_reparent(orphan, clk);

commit b05c683637fd538686030ec46c6717439d5571ab
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Tue Sep 3 09:43:51 2013 +0200

    clk: Move symbol export to proper location
    
    The __clk_get_flags() symbol is exported immediately following the
    clk_unprepare_unused_subtree() function. This is unusual, since a symbol
    export typically follows body of the function that it exports.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 02e75d4e0a77..cc4cb6fd7d83 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -458,7 +458,6 @@ static void clk_unprepare_unused_subtree(struct clk *clk)
 			clk->ops->unprepare(clk->hw);
 	}
 }
-EXPORT_SYMBOL_GPL(__clk_get_flags);
 
 /* caller must hold prepare_lock */
 static void clk_disable_unused_subtree(struct clk *clk)
@@ -607,6 +606,7 @@ unsigned long __clk_get_flags(struct clk *clk)
 {
 	return !clk ? 0 : clk->flags;
 }
+EXPORT_SYMBOL_GPL(__clk_get_flags);
 
 bool __clk_is_prepared(struct clk *clk)
 {

commit 903efc553f738030a4ffa23fa03e7f329655c1c2
Author: James Hogan <james.hogan@imgtec.com>
Date:   Thu Aug 29 12:10:51 2013 +0100

    clk: fix new_parent dereference before null check
    
    Commit 71472c0 (clk: add support for clock reparent on set_rate) added a
    dereference of the new_parent pointer in clk_reparent(), but as detected
    by smatch clk_reparent() later checks whether new_parent is NULL.
    
    The dereference was in order to clear the new parent's new_child pointer
    to avoid duplicate POST_RATE_CHANGE notifications, so clearly isn't
    necessary if the new parent is NULL, so move it inside the "if
    (new_parent)" block.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2db08c01ef51..02e75d4e0a77 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1108,16 +1108,17 @@ static u8 clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 
 static void clk_reparent(struct clk *clk, struct clk *new_parent)
 {
-	/* avoid duplicate POST_RATE_CHANGE notifications */
-	if (new_parent->new_child == clk)
-		new_parent->new_child = NULL;
-
 	hlist_del(&clk->child_node);
 
-	if (new_parent)
+	if (new_parent) {
+		/* avoid duplicate POST_RATE_CHANGE notifications */
+		if (new_parent->new_child == clk)
+			new_parent->new_child = NULL;
+
 		hlist_add_head(&clk->child_node, &new_parent->children);
-	else
+	} else {
 		hlist_add_head(&clk->child_node, &clk_orphan_list);
+	}
 
 	clk->parent = new_parent;
 }

commit 7f7ed584d11be77a7521d170431bb14bc32a5980
Author: Alex Elder <alex.elder@linaro.org>
Date:   Thu Aug 22 11:31:31 2013 -0500

    clk: get matching entry under lock in of_clk_init()
    
    Currently of_clk_init() finds a matching device node while holding
    the device tree spinlock.  When a matching device node is found, the
    lock is dropped and then re-acquired in order to get a reference
    to the matching device id structure.
    
    Acquiring the spinlock twice is unnecessary (and it opens a
    vulnerable window that could conceivably lead to errors).
    
    There already exists an interface for both finding and taking a
    reference to a device id under lock, so use it.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Christian Daudt <csd@broadcom.com>
    Reviewed-by: Markus Mayer <markus.mayer@linaro.org>
    Reviewed-by: Matt Porter <matt.porter@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7c4376289865..2db08c01ef51 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2228,13 +2228,13 @@ EXPORT_SYMBOL_GPL(of_clk_get_parent_name);
  */
 void __init of_clk_init(const struct of_device_id *matches)
 {
+	const struct of_device_id *match;
 	struct device_node *np;
 
 	if (!matches)
 		matches = __clk_of_table;
 
-	for_each_matching_node(np, matches) {
-		const struct of_device_id *match = of_match_node(matches, np);
+	for_each_matching_node_and_match(np, matches, &match) {
 		of_clk_init_cb_t clk_init_cb = match->data;
 		clk_init_cb(np);
 	}

commit 89ac8d7ae1cde0f8c7a2f85c2e3b475d54aa9163
Author: Mike Turquette <mturquette@linaro.org>
Date:   Wed Aug 21 23:58:09 2013 -0700

    clk: handle NULL struct clk gracefully
    
    At some point changes to clk_set_rate and clk_set_parent introduced a
    bug whereby NULL struct clk pointers were treated as an error. This is
    in violation of the API in include/linux/clk.h. Reintroduce graceful
    handling of NULL clk's by bailing from clk_set_rate and clk_set_parent
    with return codes of zero.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index bc020372106b..7c4376289865 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1428,6 +1428,9 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	struct clk *top, *fail_clk;
 	int ret = 0;
 
+	if (!clk)
+		return 0;
+
 	/* prevent racing with updates to the clock topology */
 	clk_prepare_lock();
 
@@ -1567,7 +1570,10 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	u8 p_index = 0;
 	unsigned long p_rate = 0;
 
-	if (!clk || !clk->ops)
+	if (!clk)
+		return 0;
+
+	if (!clk->ops)
 		return -EINVAL;
 
 	/* verify ops for for multi-parent clks */

commit e366fdd72529c545ccf327569ee250c1673be221
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Jul 29 12:25:02 2013 +0100

    clk: clk-mux: implement remuxing on set_rate
    
    Implement clk-mux remuxing if the CLK_SET_RATE_NO_REPARENT flag isn't
    set. This implements determine_rate for clk-mux to propagate to each
    parent and to choose the best one (like clk-divider this chooses the
    parent which provides the fastest rate <= the requested rate).
    
    The determine_rate op is implemented as a core helper function so that
    it can be easily used by more complex clocks which incorporate muxes.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index f33f1ccf1b2f..bc020372106b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -692,6 +692,55 @@ struct clk *__clk_lookup(const char *name)
 	return NULL;
 }
 
+/*
+ * Helper for finding best parent to provide a given frequency. This can be used
+ * directly as a determine_rate callback (e.g. for a mux), or from a more
+ * complex clock that may combine a mux with other operations.
+ */
+long __clk_mux_determine_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long *best_parent_rate,
+			      struct clk **best_parent_p)
+{
+	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
+	int i, num_parents;
+	unsigned long parent_rate, best = 0;
+
+	/* if NO_REPARENT flag set, pass through to current parent */
+	if (clk->flags & CLK_SET_RATE_NO_REPARENT) {
+		parent = clk->parent;
+		if (clk->flags & CLK_SET_RATE_PARENT)
+			best = __clk_round_rate(parent, rate);
+		else if (parent)
+			best = __clk_get_rate(parent);
+		else
+			best = __clk_get_rate(clk);
+		goto out;
+	}
+
+	/* find the parent that can provide the fastest rate <= rate */
+	num_parents = clk->num_parents;
+	for (i = 0; i < num_parents; i++) {
+		parent = clk_get_parent_by_index(clk, i);
+		if (!parent)
+			continue;
+		if (clk->flags & CLK_SET_RATE_PARENT)
+			parent_rate = __clk_round_rate(parent, rate);
+		else
+			parent_rate = __clk_get_rate(parent);
+		if (parent_rate <= rate && parent_rate > best) {
+			best_parent = parent;
+			best = parent_rate;
+		}
+	}
+
+out:
+	if (best_parent)
+		*best_parent_p = best_parent;
+	*best_parent_rate = best;
+
+	return best;
+}
+
 /***        clk api        ***/
 
 void __clk_unprepare(struct clk *clk)

commit 71472c0c06cf9a3d1540762ea205654c584e3bc4
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Jul 29 12:25:00 2013 +0100

    clk: add support for clock reparent on set_rate
    
    Add core support to allow clock implementations to select the best
    parent clock when rounding a rate, e.g. the one which can provide the
    closest clock rate to that requested. This is by way of adding a new
    clock op, determine_rate(), which is like round_rate() but has an extra
    parameter to allow the clock implementation to optionally select a
    different parent clock. The core then takes care of reparenting the
    clock when setting the rate.
    
    The parent change takes place with the help of some new private data
    members. struct clk::new_parent specifies a clock's new parent (NULL
    indicates no change), and struct clk::new_child specifies a clock's new
    child (whose new_parent member points back to it). The purpose of these
    are to allow correct walking of the future tree for notifications prior
    to actually reparenting any clocks, specifically to skip child clocks
    who are being reparented to another clock (they will be notified via the
    new parent), and to include any new child clock. These pointers are set
    by clk_calc_subtree(), and the new_child pointer gets cleared when a
    child is actually reparented to avoid duplicate POST_RATE_CHANGE
    notifications.
    
    Each place where round_rate() is called, determine_rate() is checked
    first and called in preference. This restructures a few of the call
    sites to simplify the logic into if/else blocks.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3d57cf64c9e7..f33f1ccf1b2f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -889,21 +889,24 @@ EXPORT_SYMBOL_GPL(clk_enable);
 unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 {
 	unsigned long parent_rate = 0;
+	struct clk *parent;
 
 	if (!clk)
 		return 0;
 
-	if (!clk->ops->round_rate) {
-		if (clk->flags & CLK_SET_RATE_PARENT)
-			return __clk_round_rate(clk->parent, rate);
-		else
-			return clk->rate;
-	}
-
-	if (clk->parent)
-		parent_rate = clk->parent->rate;
-
-	return clk->ops->round_rate(clk->hw, rate, &parent_rate);
+	parent = clk->parent;
+	if (parent)
+		parent_rate = parent->rate;
+
+	if (clk->ops->determine_rate)
+		return clk->ops->determine_rate(clk->hw, rate, &parent_rate,
+						&parent);
+	else if (clk->ops->round_rate)
+		return clk->ops->round_rate(clk->hw, rate, &parent_rate);
+	else if (clk->flags & CLK_SET_RATE_PARENT)
+		return __clk_round_rate(clk->parent, rate);
+	else
+		return clk->rate;
 }
 
 /**
@@ -1056,6 +1059,10 @@ static u8 clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 
 static void clk_reparent(struct clk *clk, struct clk *new_parent)
 {
+	/* avoid duplicate POST_RATE_CHANGE notifications */
+	if (new_parent->new_child == clk)
+		new_parent->new_child = NULL;
+
 	hlist_del(&clk->child_node);
 
 	if (new_parent)
@@ -1176,18 +1183,25 @@ static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 	return ret;
 }
 
-static void clk_calc_subtree(struct clk *clk, unsigned long new_rate)
+static void clk_calc_subtree(struct clk *clk, unsigned long new_rate,
+			     struct clk *new_parent, u8 p_index)
 {
 	struct clk *child;
 
 	clk->new_rate = new_rate;
+	clk->new_parent = new_parent;
+	clk->new_parent_index = p_index;
+	/* include clk in new parent's PRE_RATE_CHANGE notifications */
+	clk->new_child = NULL;
+	if (new_parent && new_parent != clk->parent)
+		new_parent->new_child = clk;
 
 	hlist_for_each_entry(child, &clk->children, child_node) {
 		if (child->ops->recalc_rate)
 			child->new_rate = child->ops->recalc_rate(child->hw, new_rate);
 		else
 			child->new_rate = new_rate;
-		clk_calc_subtree(child, child->new_rate);
+		clk_calc_subtree(child, child->new_rate, NULL, 0);
 	}
 }
 
@@ -1198,50 +1212,63 @@ static void clk_calc_subtree(struct clk *clk, unsigned long new_rate)
 static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 {
 	struct clk *top = clk;
+	struct clk *old_parent, *parent;
 	unsigned long best_parent_rate = 0;
 	unsigned long new_rate;
+	u8 p_index = 0;
 
 	/* sanity */
 	if (IS_ERR_OR_NULL(clk))
 		return NULL;
 
 	/* save parent rate, if it exists */
-	if (clk->parent)
-		best_parent_rate = clk->parent->rate;
-
-	/* never propagate up to the parent */
-	if (!(clk->flags & CLK_SET_RATE_PARENT)) {
-		if (!clk->ops->round_rate) {
-			clk->new_rate = clk->rate;
-			return NULL;
-		}
-		new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
+	parent = old_parent = clk->parent;
+	if (parent)
+		best_parent_rate = parent->rate;
+
+	/* find the closest rate and parent clk/rate */
+	if (clk->ops->determine_rate) {
+		new_rate = clk->ops->determine_rate(clk->hw, rate,
+						    &best_parent_rate,
+						    &parent);
+	} else if (clk->ops->round_rate) {
+		new_rate = clk->ops->round_rate(clk->hw, rate,
+						&best_parent_rate);
+	} else if (!parent || !(clk->flags & CLK_SET_RATE_PARENT)) {
+		/* pass-through clock without adjustable parent */
+		clk->new_rate = clk->rate;
+		return NULL;
+	} else {
+		/* pass-through clock with adjustable parent */
+		top = clk_calc_new_rates(parent, rate);
+		new_rate = parent->new_rate;
 		goto out;
 	}
 
-	/* need clk->parent from here on out */
-	if (!clk->parent) {
-		pr_debug("%s: %s has NULL parent\n", __func__, clk->name);
+	/* some clocks must be gated to change parent */
+	if (parent != old_parent &&
+	    (clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count) {
+		pr_debug("%s: %s not gated but wants to reparent\n",
+			 __func__, clk->name);
 		return NULL;
 	}
 
-	if (!clk->ops->round_rate) {
-		top = clk_calc_new_rates(clk->parent, rate);
-		new_rate = clk->parent->new_rate;
-
-		goto out;
+	/* try finding the new parent index */
+	if (parent) {
+		p_index = clk_fetch_parent_index(clk, parent);
+		if (p_index == clk->num_parents) {
+			pr_debug("%s: clk %s can not be parent of clk %s\n",
+				 __func__, parent->name, clk->name);
+			return NULL;
+		}
 	}
 
-	new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
-
-	if (best_parent_rate != clk->parent->rate) {
-		top = clk_calc_new_rates(clk->parent, best_parent_rate);
-
-		goto out;
-	}
+	if ((clk->flags & CLK_SET_RATE_PARENT) && parent &&
+	    best_parent_rate != parent->rate)
+		top = clk_calc_new_rates(parent, best_parent_rate);
 
 out:
-	clk_calc_subtree(clk, new_rate);
+	clk_calc_subtree(clk, new_rate, parent, p_index);
 
 	return top;
 }
@@ -1253,7 +1280,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
  */
 static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long event)
 {
-	struct clk *child, *fail_clk = NULL;
+	struct clk *child, *tmp_clk, *fail_clk = NULL;
 	int ret = NOTIFY_DONE;
 
 	if (clk->rate == clk->new_rate)
@@ -1266,9 +1293,19 @@ static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long even
 	}
 
 	hlist_for_each_entry(child, &clk->children, child_node) {
-		clk = clk_propagate_rate_change(child, event);
-		if (clk)
-			fail_clk = clk;
+		/* Skip children who will be reparented to another clock */
+		if (child->new_parent && child->new_parent != clk)
+			continue;
+		tmp_clk = clk_propagate_rate_change(child, event);
+		if (tmp_clk)
+			fail_clk = tmp_clk;
+	}
+
+	/* handle the new child who might not be in clk->children yet */
+	if (clk->new_child) {
+		tmp_clk = clk_propagate_rate_change(clk->new_child, event);
+		if (tmp_clk)
+			fail_clk = tmp_clk;
 	}
 
 	return fail_clk;
@@ -1286,6 +1323,10 @@ static void clk_change_rate(struct clk *clk)
 
 	old_rate = clk->rate;
 
+	/* set parent */
+	if (clk->new_parent && clk->new_parent != clk->parent)
+		__clk_set_parent(clk, clk->new_parent, clk->new_parent_index);
+
 	if (clk->parent)
 		best_parent_rate = clk->parent->rate;
 
@@ -1300,8 +1341,16 @@ static void clk_change_rate(struct clk *clk)
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
 
-	hlist_for_each_entry(child, &clk->children, child_node)
+	hlist_for_each_entry(child, &clk->children, child_node) {
+		/* Skip children who will be reparented to another clock */
+		if (child->new_parent && child->new_parent != clk)
+			continue;
 		clk_change_rate(child);
+	}
+
+	/* handle the new child who might not be in clk->children yet */
+	if (clk->new_child)
+		clk_change_rate(clk->new_child);
 }
 
 /**
@@ -1552,8 +1601,9 @@ int __clk_init(struct device *dev, struct clk *clk)
 
 	/* check that clk_ops are sane.  See Documentation/clk.txt */
 	if (clk->ops->set_rate &&
-			!(clk->ops->round_rate && clk->ops->recalc_rate)) {
-		pr_warning("%s: %s must implement .round_rate & .recalc_rate\n",
+	    !((clk->ops->round_rate || clk->ops->determine_rate) &&
+	      clk->ops->recalc_rate)) {
+		pr_warning("%s: %s must implement .round_rate or .determine_rate in addition to .recalc_rate\n",
 				__func__, clk->name);
 		ret = -EINVAL;
 		goto out;

commit 4935b22c46ea5e2dc44ef0b72db50741649eb3a4
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Jul 29 12:24:59 2013 +0100

    clk: move some parent related functions upwards
    
    Move some parent related functions up in clk.c so they can be used by
    the modifications in the following patch which enables clock reparenting
    during set_rate. No other changes are made so this patch makes no
    functional difference in isolation. This is separate from the following
    patch primarily to ease readability of that patch.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 42c15a8ba34d..3d57cf64c9e7 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1028,6 +1028,110 @@ unsigned long clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_rate);
 
+static u8 clk_fetch_parent_index(struct clk *clk, struct clk *parent)
+{
+	u8 i;
+
+	if (!clk->parents)
+		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
+								GFP_KERNEL);
+
+	/*
+	 * find index of new parent clock using cached parent ptrs,
+	 * or if not yet cached, use string name comparison and cache
+	 * them now to avoid future calls to __clk_lookup.
+	 */
+	for (i = 0; i < clk->num_parents; i++) {
+		if (clk->parents && clk->parents[i] == parent)
+			break;
+		else if (!strcmp(clk->parent_names[i], parent->name)) {
+			if (clk->parents)
+				clk->parents[i] = __clk_lookup(parent->name);
+			break;
+		}
+	}
+
+	return i;
+}
+
+static void clk_reparent(struct clk *clk, struct clk *new_parent)
+{
+	hlist_del(&clk->child_node);
+
+	if (new_parent)
+		hlist_add_head(&clk->child_node, &new_parent->children);
+	else
+		hlist_add_head(&clk->child_node, &clk_orphan_list);
+
+	clk->parent = new_parent;
+}
+
+static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
+{
+	unsigned long flags;
+	int ret = 0;
+	struct clk *old_parent = clk->parent;
+
+	/*
+	 * Migrate prepare state between parents and prevent race with
+	 * clk_enable().
+	 *
+	 * If the clock is not prepared, then a race with
+	 * clk_enable/disable() is impossible since we already have the
+	 * prepare lock (future calls to clk_enable() need to be preceded by
+	 * a clk_prepare()).
+	 *
+	 * If the clock is prepared, migrate the prepared state to the new
+	 * parent and also protect against a race with clk_enable() by
+	 * forcing the clock and the new parent on.  This ensures that all
+	 * future calls to clk_enable() are practically NOPs with respect to
+	 * hardware and software states.
+	 *
+	 * See also: Comment for clk_set_parent() below.
+	 */
+	if (clk->prepare_count) {
+		__clk_prepare(parent);
+		clk_enable(parent);
+		clk_enable(clk);
+	}
+
+	/* update the clk tree topology */
+	flags = clk_enable_lock();
+	clk_reparent(clk, parent);
+	clk_enable_unlock(flags);
+
+	/* change clock input source */
+	if (parent && clk->ops->set_parent)
+		ret = clk->ops->set_parent(clk->hw, p_index);
+
+	if (ret) {
+		flags = clk_enable_lock();
+		clk_reparent(clk, old_parent);
+		clk_enable_unlock(flags);
+
+		if (clk->prepare_count) {
+			clk_disable(clk);
+			clk_disable(parent);
+			__clk_unprepare(parent);
+		}
+		return ret;
+	}
+
+	/*
+	 * Finish the migration of prepare state and undo the changes done
+	 * for preventing a race with clk_enable().
+	 */
+	if (clk->prepare_count) {
+		clk_disable(clk);
+		clk_disable(old_parent);
+		__clk_unprepare(old_parent);
+	}
+
+	/* update debugfs with new clk tree topology */
+	clk_debug_reparent(clk, parent);
+	return 0;
+}
+
 /**
  * __clk_speculate_rates
  * @clk: first clk in the subtree
@@ -1335,18 +1439,6 @@ static struct clk *__clk_init_parent(struct clk *clk)
 	return ret;
 }
 
-static void clk_reparent(struct clk *clk, struct clk *new_parent)
-{
-	hlist_del(&clk->child_node);
-
-	if (new_parent)
-		hlist_add_head(&clk->child_node, &new_parent->children);
-	else
-		hlist_add_head(&clk->child_node, &clk_orphan_list);
-
-	clk->parent = new_parent;
-}
-
 void __clk_reparent(struct clk *clk, struct clk *new_parent)
 {
 	clk_reparent(clk, new_parent);
@@ -1354,98 +1446,6 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
 	__clk_recalc_rates(clk, POST_RATE_CHANGE);
 }
 
-static u8 clk_fetch_parent_index(struct clk *clk, struct clk *parent)
-{
-	u8 i;
-
-	if (!clk->parents)
-		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
-								GFP_KERNEL);
-
-	/*
-	 * find index of new parent clock using cached parent ptrs,
-	 * or if not yet cached, use string name comparison and cache
-	 * them now to avoid future calls to __clk_lookup.
-	 */
-	for (i = 0; i < clk->num_parents; i++) {
-		if (clk->parents && clk->parents[i] == parent)
-			break;
-		else if (!strcmp(clk->parent_names[i], parent->name)) {
-			if (clk->parents)
-				clk->parents[i] = __clk_lookup(parent->name);
-			break;
-		}
-	}
-
-	return i;
-}
-
-static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
-{
-	unsigned long flags;
-	int ret = 0;
-	struct clk *old_parent = clk->parent;
-
-	/*
-	 * Migrate prepare state between parents and prevent race with
-	 * clk_enable().
-	 *
-	 * If the clock is not prepared, then a race with
-	 * clk_enable/disable() is impossible since we already have the
-	 * prepare lock (future calls to clk_enable() need to be preceded by
-	 * a clk_prepare()).
-	 *
-	 * If the clock is prepared, migrate the prepared state to the new
-	 * parent and also protect against a race with clk_enable() by
-	 * forcing the clock and the new parent on.  This ensures that all
-	 * future calls to clk_enable() are practically NOPs with respect to
-	 * hardware and software states.
-	 *
-	 * See also: Comment for clk_set_parent() below.
-	 */
-	if (clk->prepare_count) {
-		__clk_prepare(parent);
-		clk_enable(parent);
-		clk_enable(clk);
-	}
-
-	/* update the clk tree topology */
-	flags = clk_enable_lock();
-	clk_reparent(clk, parent);
-	clk_enable_unlock(flags);
-
-	/* change clock input source */
-	if (parent && clk->ops->set_parent)
-		ret = clk->ops->set_parent(clk->hw, p_index);
-
-	if (ret) {
-		flags = clk_enable_lock();
-		clk_reparent(clk, old_parent);
-		clk_enable_unlock(flags);
-
-		if (clk->prepare_count) {
-			clk_disable(clk);
-			clk_disable(parent);
-			__clk_unprepare(parent);
-		}
-		return ret;
-	}
-
-	/*
-	 * Finish the migration of prepare state and undo the changes done
-	 * for preventing a race with clk_enable().
-	 */
-	if (clk->prepare_count) {
-		clk_disable(clk);
-		clk_disable(old_parent);
-		__clk_unprepare(old_parent);
-	}
-
-	/* update debugfs with new clk tree topology */
-	clk_debug_reparent(clk, parent);
-	return 0;
-}
-
 /**
  * clk_set_parent - switch the parent of a mux clk
  * @clk: the mux clk whose input we are switching

commit 7ef3dcc8145263cb5a8c7059f82d44c948eb46a8
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Jul 29 12:24:58 2013 +0100

    clk: abstract parent cache
    
    Abstract access to the clock parent cache by defining
    clk_get_parent_by_index(clk, index). This allows access to parent
    clocks from clock drivers.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 56a00db61332..42c15a8ba34d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -559,6 +559,19 @@ struct clk *__clk_get_parent(struct clk *clk)
 	return !clk ? NULL : clk->parent;
 }
 
+struct clk *clk_get_parent_by_index(struct clk *clk, u8 index)
+{
+	if (!clk || index >= clk->num_parents)
+		return NULL;
+	else if (!clk->parents)
+		return __clk_lookup(clk->parent_names[index]);
+	else if (!clk->parents[index])
+		return clk->parents[index] =
+			__clk_lookup(clk->parent_names[index]);
+	else
+		return clk->parents[index];
+}
+
 unsigned int __clk_get_enable_count(struct clk *clk)
 {
 	return !clk ? 0 : clk->enable_count;
@@ -1316,13 +1329,7 @@ static struct clk *__clk_init_parent(struct clk *clk)
 			kzalloc((sizeof(struct clk*) * clk->num_parents),
 					GFP_KERNEL);
 
-	if (!clk->parents)
-		ret = __clk_lookup(clk->parent_names[index]);
-	else if (!clk->parents[index])
-		ret = clk->parents[index] =
-			__clk_lookup(clk->parent_names[index]);
-	else
-		ret = clk->parents[index];
+	ret = clk_get_parent_by_index(clk, index);
 
 out:
 	return ret;

commit 24ee1a083cbe0b0364a27404dc01a665b31839cb
Author: Peter Meerwald <pmeerw@pmeerw.net>
Date:   Sat Jun 29 15:14:19 2013 +0200

    clk: fix typos
    
    Signed-off-by: Peter Meerwald <pmeerw@pmeerw.net>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 54a191c5bbf0..56a00db61332 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -702,7 +702,7 @@ void __clk_unprepare(struct clk *clk)
 
 /**
  * clk_unprepare - undo preparation of a clock source
- * @clk: the clk being unprepare
+ * @clk: the clk being unprepared
  *
  * clk_unprepare may sleep, which differentiates it from clk_disable.  In a
  * simple case, clk_unprepare can be used instead of clk_disable to gate a clk
@@ -869,6 +869,7 @@ EXPORT_SYMBOL_GPL(clk_enable);
 /**
  * __clk_round_rate - round the given rate for a clk
  * @clk: round the rate of this clock
+ * @rate: the rate which is to be rounded
  *
  * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate
  */
@@ -956,7 +957,7 @@ static int __clk_notify(struct clk *clk, unsigned long msg,
  *
  * Walks the subtree of clks starting with clk and recalculates rates as it
  * goes.  Note that if a clk does not implement the .recalc_rate callback then
- * it is assumed that the clock will take on the rate of it's parent.
+ * it is assumed that the clock will take on the rate of its parent.
  *
  * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,
  * if necessary.
@@ -1026,7 +1027,7 @@ EXPORT_SYMBOL_GPL(clk_get_rate);
  * pre-rate change notifications and returns early if no clks in the
  * subtree have subscribed to the notifications.  Note that if a clk does not
  * implement the .recalc_rate callback then it is assumed that the clock will
- * take on the rate of it's parent.
+ * take on the rate of its parent.
  *
  * Caller must hold prepare_lock.
  */
@@ -1198,7 +1199,7 @@ static void clk_change_rate(struct clk *clk)
  * outcome of clk's .round_rate implementation.  If *parent_rate is unchanged
  * after calling .round_rate then upstream parent propagation is ignored.  If
  * *parent_rate comes back with a new rate for clk's parent then we propagate
- * up to clk's parent and set it's rate.  Upward propagation will continue
+ * up to clk's parent and set its rate.  Upward propagation will continue
  * until either a clk does not support the CLK_SET_RATE_PARENT flag or
  * .round_rate stops requesting changes to clk's parent_rate.
  *
@@ -1648,7 +1649,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 	 * The .init callback is not used by any of the basic clock types, but
 	 * exists for weird hardware that must perform initialization magic.
 	 * Please consider other ways of solving initialization problems before
-	 * using this callback, as it's use is discouraged.
+	 * using this callback, as its use is discouraged.
 	 */
 	if (clk->ops->init)
 		clk->ops->init(clk->hw);
@@ -1675,7 +1676,7 @@ int __clk_init(struct device *dev, struct clk *clk)
  * very large numbers of clocks that need to be statically initialized.  It is
  * a layering violation to include clk-private.h from any code which implements
  * a clock's .ops; as such any statically initialized clock data MUST be in a
- * separate C file from the logic that implements it's operations.  Returns 0
+ * separate C file from the logic that implements its operations.  Returns 0
  * on success, otherwise an error code.
  */
 struct clk *__clk_register(struct device *dev, struct clk_hw *hw)

commit 92295f632cefbdf15d46e9ac5f0fc3cfade35259
Merge: 750b2d7b93f2 45e3ec3784ae
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 11:54:50 2013 -0700

    Merge tag 'clk-for-linus-3.11' of git://git.linaro.org/people/mturquette/linux
    
    Pull clock framework updates from Mike Turquette:
     "The common clock framework changes for 3.11 include new clock drivers
      across several different platforms and architectures, fixes to
      existing drivers, a MAINTAINERS file fix and improvements to the basic
      clock types that allow them to be of use to more platforms than before.
    
      Only a few fixes to the core framework are included with most all of
      the changes landing in the various clock drivers themselves."
    
    * tag 'clk-for-linus-3.11' of git://git.linaro.org/people/mturquette/linux: (55 commits)
      clk: tegra: fix ifdef for tegra_periph_reset_assert inline
      clk: tegra: provide tegra_periph_reset_assert alternative
      clk: exynos4: Fix clock aliases for cpufreq related clocks
      clk: samsung: Add MUX_FA macro to pass flag and alias
      clk: add support for Rockchip gate clocks
      clk: vexpress: Make the clock drivers directly available for arm64
      clk: vexpress: Use full node name to identify individual clocks
      clk: tegra: T114: add DFLL DVCO reset control
      clk: tegra: T114: add DFLL source clocks
      clk: tegra: T114: add FCPU clock shaper programming, needed by the DFLL
      clk: gate: add CLK_GATE_HIWORD_MASK
      clk: divider: add CLK_DIVIDER_HIWORD_MASK flag
      clk: mux: add CLK_MUX_HIWORD_MASK
      clk: Always notify whole subtree when reparenting
      MAINTAINERS: make drivers/clk entry match subdirs
      clk: honor CLK_GET_RATE_NOCACHE in clk_set_rate
      clk: use clk_get_rate() for debugfs
      clk: tegra: Use override bits when needed
      clk: tegra: override bits for Tegra30 PLLM
      clk: tegra: override bits for Tegra114 PLLM
      ...

commit f3aab5d61400b794ec759b9345e93e7ba57eb369
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Tue Apr 16 10:06:50 2013 -0700

    clk: Always notify whole subtree when reparenting
    
    A clock's notifier count only reflects notifiers which are registered
    directly for that clock. A reparent operation though affects the whole
    subtree because of a potential rate change.
    When issuing the pre rate change notifications only the notifier count
    for the clock to be changed is considered and notifiers for subclocks
    may never be called. Resulting in clocks in the subtree which have
    registered notifiers, may receive a POST_- or ABORT_RATE_CHANGE
    notification, without a PRE_RATE_CHANGE_NOTIFICATION.
    Therefore always traverse the whole subtree when issueing pre rate
    change notifications during a reparent operation.
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2e669a87fb15..edf3fe100542 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1493,8 +1493,7 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	}
 
 	/* propagate PRE_RATE_CHANGE notifications */
-	if (clk->notifier_count)
-		ret = __clk_speculate_rates(clk, p_rate);
+	ret = __clk_speculate_rates(clk, p_rate);
 
 	/* abort if a driver objects */
 	if (ret & NOTIFY_STOP_MASK)

commit 34e452a152efd25d654b7bc809df429337115b03
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Wed Jun 5 18:06:36 2013 +0300

    clk: honor CLK_GET_RATE_NOCACHE in clk_set_rate
    
    clk_set_rate() uses clk->rate directly. This causes problems if the clock
    is marked as CLK_GET_RATE_NOCACHE. Hence call clk_get_rate() to get the
    current rate.
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9b2f94197dbf..2e669a87fb15 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1216,7 +1216,7 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	clk_prepare_lock();
 
 	/* bail early if nothing to do */
-	if (rate == clk->rate)
+	if (rate == clk_get_rate(clk))
 		goto out;
 
 	if ((clk->flags & CLK_SET_RATE_GATE) && clk->prepare_count) {

commit 670decdd9544eddbc2ecf14789da4845f8afdab0
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Wed Jun 5 18:06:35 2013 +0300

    clk: use clk_get_rate() for debugfs
    
    debugfs uses the rate field directly. However this ignores the
    CLK_GET_RATE_NOCACHE flag. Call clk_get_rate() instead.
    
    Tested-by: Mark Zhang <markz@nvidia.com>
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index af0dbccb375d..9b2f94197dbf 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -107,7 +107,7 @@ static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
 	seq_printf(s, "%*s%-*s %-11d %-12d %-10lu",
 		   level * 3 + 1, "",
 		   30 - level * 3, c->name,
-		   c->enable_count, c->prepare_count, c->rate);
+		   c->enable_count, c->prepare_count, clk_get_rate(c));
 	seq_printf(s, "\n");
 }
 
@@ -166,7 +166,7 @@ static void clk_dump_one(struct seq_file *s, struct clk *c, int level)
 	seq_printf(s, "\"%s\": { ", c->name);
 	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
 	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
-	seq_printf(s, "\"rate\": %lu", c->rate);
+	seq_printf(s, "\"rate\": %lu", clk_get_rate(c));
 }
 
 static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)

commit 72b5322f11ff0abf6a52b3007486656578d2c982
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Mon Jun 3 17:17:15 2013 +0800

    clk: remove notifier from list before freeing it
    
    The @cn is stay in @clk_notifier_list after it is freed, it cause
    memory corruption.
    
    Example, if @clk is registered(first), unregistered(first),
    registered(second), unregistered(second).
    
    The freed @cn will be used when @clk is registered(second),
    and the bug will be happened when @clk is unregistered(second):
    
    [  517.040000] clk_notif_dbg clk_notif_dbg.1: clk_notifier_unregister()
    [  517.040000] Unable to handle kernel paging request at virtual address 00df3008
    [  517.050000] pgd = ed858000
    [  517.050000] [00df3008] *pgd=00000000
    [  517.060000] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    [  517.060000] Modules linked in: clk_notif_dbg(O-) [last unloaded: clk_notif_dbg]
    [  517.060000] CPU: 1 PID: 499 Comm: modprobe Tainted: G           O 3.10.0-rc3-00119-ga93cb29-dirty #85
    [  517.060000] task: ee1e0180 ti: ee3e6000 task.ti: ee3e6000
    [  517.060000] PC is at srcu_readers_seq_idx+0x48/0x84
    [  517.060000] LR is at srcu_readers_seq_idx+0x60/0x84
    [  517.060000] pc : [<c0052720>]    lr : [<c0052738>]    psr: 80070013
    [  517.060000] sp : ee3e7d48  ip : 00000000  fp : ee3e7d6c
    [  517.060000] r10: 00000000  r9 : ee3e6000  r8 : 00000000
    [  517.060000] r7 : ed84fe4c  r6 : c068ec90  r5 : c068e430  r4 : 00000000
    [  517.060000] r3 : 00df3000  r2 : 00000000  r1 : 00000002  r0 : 00000000
    [  517.060000] Flags: Nzcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    [  517.060000] Control: 18c5387d  Table: 2d85804a  DAC: 00000015
    [  517.060000] Process modprobe (pid: 499, stack limit = 0xee3e6238)
    [  517.060000] Stack: (0xee3e7d48 to 0xee3e8000)
    ....
    [  517.060000] [<c0052720>] (srcu_readers_seq_idx+0x48/0x84) from [<c0052790>] (try_check_zero+0x34/0xfc)
    [  517.060000] [<c0052790>] (try_check_zero+0x34/0xfc) from [<c00528b0>] (srcu_advance_batches+0x58/0x114)
    [  517.060000] [<c00528b0>] (srcu_advance_batches+0x58/0x114) from [<c0052c30>] (__synchronize_srcu+0x114/0x1ac)
    [  517.060000] [<c0052c30>] (__synchronize_srcu+0x114/0x1ac) from [<c0052d14>] (synchronize_srcu+0x2c/0x34)
    [  517.060000] [<c0052d14>] (synchronize_srcu+0x2c/0x34) from [<c0053a08>] (srcu_notifier_chain_unregister+0x68/0x74)
    [  517.060000] [<c0053a08>] (srcu_notifier_chain_unregister+0x68/0x74) from [<c0375a78>] (clk_notifier_unregister+0x7c/0xc0)
    [  517.060000] [<c0375a78>] (clk_notifier_unregister+0x7c/0xc0) from [<bf008034>] (clk_notif_dbg_remove+0x34/0x9c [clk_notif_dbg])
    [  517.060000] [<bf008034>] (clk_notif_dbg_remove+0x34/0x9c [clk_notif_dbg]) from [<c02bb974>] (platform_drv_remove+0x24/0x28)
    [  517.060000] [<c02bb974>] (platform_drv_remove+0x24/0x28) from [<c02b9bf8>] (__device_release_driver+0x8c/0xd4)
    [  517.060000] [<c02b9bf8>] (__device_release_driver+0x8c/0xd4) from [<c02ba680>] (driver_detach+0x9c/0xc4)
    [  517.060000] [<c02ba680>] (driver_detach+0x9c/0xc4) from [<c02b99c4>] (bus_remove_driver+0xcc/0xfc)
    [  517.060000] [<c02b99c4>] (bus_remove_driver+0xcc/0xfc) from [<c02bace4>] (driver_unregister+0x54/0x78)
    [  517.060000] [<c02bace4>] (driver_unregister+0x54/0x78) from [<c02bbb44>] (platform_driver_unregister+0x1c/0x20)
    [  517.060000] [<c02bbb44>] (platform_driver_unregister+0x1c/0x20) from [<bf0081f8>] (clk_notif_dbg_driver_exit+0x14/0x1c [clk_notif_dbg])
    [  517.060000] [<bf0081f8>] (clk_notif_dbg_driver_exit+0x14/0x1c [clk_notif_dbg]) from [<c00835e4>] (SyS_delete_module+0x200/0x28c)
    [  517.060000] [<c00835e4>] (SyS_delete_module+0x200/0x28c) from [<c000edc0>] (ret_fast_syscall+0x0/0x48)
    [  517.060000] Code: e5973004 e7911102 e0833001 e2881002 (e7933101)
    
    Cc: stable@kernel.org
    Reported-by: Sren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Tested-by: Sren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: shortened $SUBJECT]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 934cfd18f72d..1144e8c7579d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1955,6 +1955,7 @@ int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)
 		/* XXX the notifier code should handle this better */
 		if (!cn->notifier_head.head) {
 			srcu_cleanup_notifier_head(&cn->notifier_head);
+			list_del(&cn->node);
 			kfree(cn);
 		}
 

commit d41d5805875a628bdef75b624bab245da436f816
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Thu May 9 11:35:01 2013 -0700

    clk: Disable unused clocks after deferred probing is done
    
    With deferred probing, late_initcall() is too soon to declare a clock as
    unused. Wait for deferred probing to finish before declaring a clock as
    unused. Since deferred probing is done in late_initcall(), do the unused
    check to late_initcall_sync.
    
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 399b0d8ac562..af0dbccb375d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -534,7 +534,7 @@ static int clk_disable_unused(void)
 
 	return 0;
 }
-late_initcall(clk_disable_unused);
+late_initcall_sync(clk_disable_unused);
 
 /***    helper functions   ***/
 

commit f8aa0bd5c9b28f80bf372d0f486737b13ff01910
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Wed May 15 21:07:24 2013 -0700

    clk: Fix race condition between clk_set_parent and clk_enable()
    
    Without this patch, the following race condition is possible.
    * clk-A has two parents - clk-X and clk-Y.
    * All three are disabled and clk-X is current parent.
    * Thread A: clk_set_parent(clk-A, clk-Y).
    * Thread A: <snip execution flow>
    * Thread A: Grabs enable lock.
    * Thread A: Sees enable count of clk-A is 0, so doesn't enable clk-Y.
    * Thread A: Updates clk-A SW parent to clk-Y
    * Thread A: Releases enable lock.
    * Thread B: clk_enable(clk-A).
    * Thread B: clk_enable() enables clk-Y, then enabled clk-A and returns.
    
    clk-A is now enabled in software, but not clocking in hardware since the
    hardware parent is still clk-X.
    
    The only way to avoid race conditions between clk_set_parent() and
    clk_enable/disable() is to ensure that clk_enable/disable() calls don't
    require changes to hardware enable state between changes to software clock
    topology and hardware clock topology.
    
    The options to achieve the above are:
    1. Grab the enable lock before changing software/hardware topology and
       release it afterwards.
    2. Keep the clock enabled for the duration of software/hardware topology
       change so that any additional enable/disable calls don't try to change
       the hardware state. Once the topology change is complete, the clock can
       be put back in its original enable state.
    
    Option (1) is not an acceptable solution since the set_parent() ops might
    need to sleep.
    
    Therefore, this patch implements option (2).
    
    This patch doesn't violate any API semantics. clk_disable() doesn't
    guarantee that the clock is actually disabled. So, no clients of a clock
    can assume that a clock is disabled after their last call to clk_disable().
    So, enabling the clock during a parent change is not a violation of any API
    semantics.
    
    This also has the nice side effect of simplifying the error handling code.
    
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: fixed up whitespace issue]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 934cfd18f72d..399b0d8ac562 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1377,23 +1377,33 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
 	unsigned long flags;
 	int ret = 0;
 	struct clk *old_parent = clk->parent;
-	bool migrated_enable = false;
 
-	/* migrate prepare */
-	if (clk->prepare_count)
+	/*
+	 * Migrate prepare state between parents and prevent race with
+	 * clk_enable().
+	 *
+	 * If the clock is not prepared, then a race with
+	 * clk_enable/disable() is impossible since we already have the
+	 * prepare lock (future calls to clk_enable() need to be preceded by
+	 * a clk_prepare()).
+	 *
+	 * If the clock is prepared, migrate the prepared state to the new
+	 * parent and also protect against a race with clk_enable() by
+	 * forcing the clock and the new parent on.  This ensures that all
+	 * future calls to clk_enable() are practically NOPs with respect to
+	 * hardware and software states.
+	 *
+	 * See also: Comment for clk_set_parent() below.
+	 */
+	if (clk->prepare_count) {
 		__clk_prepare(parent);
-
-	flags = clk_enable_lock();
-
-	/* migrate enable */
-	if (clk->enable_count) {
-		__clk_enable(parent);
-		migrated_enable = true;
+		clk_enable(parent);
+		clk_enable(clk);
 	}
 
 	/* update the clk tree topology */
+	flags = clk_enable_lock();
 	clk_reparent(clk, parent);
-
 	clk_enable_unlock(flags);
 
 	/* change clock input source */
@@ -1401,43 +1411,27 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
 		ret = clk->ops->set_parent(clk->hw, p_index);
 
 	if (ret) {
-		/*
-		 * The error handling is tricky due to that we need to release
-		 * the spinlock while issuing the .set_parent callback. This
-		 * means the new parent might have been enabled/disabled in
-		 * between, which must be considered when doing rollback.
-		 */
 		flags = clk_enable_lock();
-
 		clk_reparent(clk, old_parent);
-
-		if (migrated_enable && clk->enable_count) {
-			__clk_disable(parent);
-		} else if (migrated_enable && (clk->enable_count == 0)) {
-			__clk_disable(old_parent);
-		} else if (!migrated_enable && clk->enable_count) {
-			__clk_disable(parent);
-			__clk_enable(old_parent);
-		}
-
 		clk_enable_unlock(flags);
 
-		if (clk->prepare_count)
+		if (clk->prepare_count) {
+			clk_disable(clk);
+			clk_disable(parent);
 			__clk_unprepare(parent);
-
+		}
 		return ret;
 	}
 
-	/* clean up enable for old parent if migration was done */
-	if (migrated_enable) {
-		flags = clk_enable_lock();
-		__clk_disable(old_parent);
-		clk_enable_unlock(flags);
-	}
-
-	/* clean up prepare for old parent if migration was done */
-	if (clk->prepare_count)
+	/*
+	 * Finish the migration of prepare state and undo the changes done
+	 * for preventing a race with clk_enable().
+	 */
+	if (clk->prepare_count) {
+		clk_disable(clk);
+		clk_disable(old_parent);
 		__clk_unprepare(old_parent);
+	}
 
 	/* update debugfs with new clk tree topology */
 	clk_debug_reparent(clk, parent);
@@ -1449,12 +1443,17 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
  * @clk: the mux clk whose input we are switching
  * @parent: the new input to clk
  *
- * Re-parent clk to use parent as it's new input source.  If clk has the
- * CLK_SET_PARENT_GATE flag set then clk must be gated for this
- * operation to succeed.  After successfully changing clk's parent
- * clk_set_parent will update the clk topology, sysfs topology and
- * propagate rate recalculation via __clk_recalc_rates.  Returns 0 on
- * success, -EERROR otherwise.
+ * Re-parent clk to use parent as its new input source.  If clk is in
+ * prepared state, the clk will get enabled for the duration of this call. If
+ * that's not acceptable for a specific clk (Eg: the consumer can't handle
+ * that, the reparenting is glitchy in hardware, etc), use the
+ * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.
+ *
+ * After successfully changing clk's parent clk_set_parent will update the
+ * clk topology, sysfs topology and propagate rate recalculation via
+ * __clk_recalc_rates.
+ *
+ * Returns 0 on success, -EERROR otherwise.
  */
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {

commit 1e435256d625c203660f0105f1155cd2af283051
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Apr 27 14:10:18 2013 -0700

    clk: add clk_ignore_unused option to keep boot clocks on
    
    This is primarily useful when there's a driver that doesn't claim clocks
    properly, but the bootloader leaves them on. It's not expected to be used
    in normal cases, but for bringup and debug it's very useful to have the
    option to not gate unclaimed clocks that are still on.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: fixed up trivial merge issue]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 20ce67f82d65..934cfd18f72d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -499,10 +499,23 @@ static void clk_disable_unused_subtree(struct clk *clk)
 	return;
 }
 
+static bool clk_ignore_unused;
+static int __init clk_ignore_unused_setup(char *__unused)
+{
+	clk_ignore_unused = true;
+	return 1;
+}
+__setup("clk_ignore_unused", clk_ignore_unused_setup);
+
 static int clk_disable_unused(void)
 {
 	struct clk *clk;
 
+	if (clk_ignore_unused) {
+		pr_warn("clk: Not disabling unused clocks\n");
+		return 0;
+	}
+
 	clk_prepare_lock();
 
 	hlist_for_each_entry(clk, &clk_root_list, child_node)

commit 496620ccf8905b39058adc998475125325a7e753
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Mon Apr 15 08:59:46 2013 +0200

    clk: export __clk_get_flags for modular clock providers
    
    The common clock api provides some helpers for clk-providers but does
    not export these helpers. This hinders clk-providers to be built as modules.
    This patch adds __clk_get_flags() to the list of exported symbols.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d65ef178e6eb..20ce67f82d65 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -458,6 +458,7 @@ static void clk_unprepare_unused_subtree(struct clk *clk)
 			clk->ops->unprepare(clk->hw);
 	}
 }
+EXPORT_SYMBOL_GPL(__clk_get_flags);
 
 /* caller must hold prepare_lock */
 static void clk_disable_unused_subtree(struct clk *clk)

commit fb72a0590b770f7da6a02bde6b8a147a3d9f6168
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Wed Apr 3 12:17:12 2013 -0700

    clk: Properly handle notifier return values
    
    Notifiers may return NOTIFY_(OK|DONE|STOP|BAD). The CCF uses an
    inconsistent mix of checking against NOTIFY_STOP or NOTIFY_BAD.
    This inconsistency leaves errors undetected in some cases:
    clk_set_parent() calls __clk_speculate_rates(), which stops when it
    hits a NOTIFIER_BAD (STOP is ignored), and passes this value back to the
    caller.
    clk_set_parent() compares this return value against NOTIFY_STOP only,
    ignoring NOTIFY_BAD returns.
    
    Use NOTIFY_STOP_MASK to detect a negative notifier return value and
    document all four return value options.
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index de6b459de78e..d65ef178e6eb 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1027,16 +1027,16 @@ static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 	else
 		new_rate = parent_rate;
 
-	/* abort the rate change if a driver returns NOTIFY_BAD */
+	/* abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */
 	if (clk->notifier_count)
 		ret = __clk_notify(clk, PRE_RATE_CHANGE, clk->rate, new_rate);
 
-	if (ret == NOTIFY_BAD)
+	if (ret & NOTIFY_STOP_MASK)
 		goto out;
 
 	hlist_for_each_entry(child, &clk->children, child_node) {
 		ret = __clk_speculate_rates(child, new_rate);
-		if (ret == NOTIFY_BAD)
+		if (ret & NOTIFY_STOP_MASK)
 			break;
 	}
 
@@ -1129,7 +1129,7 @@ static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long even
 
 	if (clk->notifier_count) {
 		ret = __clk_notify(clk, event, clk->rate, clk->new_rate);
-		if (ret == NOTIFY_BAD)
+		if (ret & NOTIFY_STOP_MASK)
 			fail_clk = clk;
 	}
 
@@ -1484,7 +1484,7 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 		ret = __clk_speculate_rates(clk, p_rate);
 
 	/* abort if a driver objects */
-	if (ret == NOTIFY_STOP)
+	if (ret & NOTIFY_STOP_MASK)
 		goto out;
 
 	/* do the re-parent */

commit a68de8e4ab2756d8e125cf327f044c895b6a6b3d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 2 23:09:39 2013 +0200

    clk: Fixup locking issues for clk_set_parent
    
    Updating the clock tree topology must be protected with the spinlock
    when doing clk_set_parent, otherwise we can not handle the migration
    of the enable_count in a safe manner.
    
    While issuing the .set_parent callback to make the clk-hw perform the
    switch to the new parent, we can not hold the spinlock since it is must
    be allowed to be slow path. This complicates error handling, but is still
    possible to achieve.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c83e8e543bab..de6b459de78e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1363,31 +1363,71 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
 	unsigned long flags;
 	int ret = 0;
 	struct clk *old_parent = clk->parent;
+	bool migrated_enable = false;
 
-	/* migrate prepare and enable */
+	/* migrate prepare */
 	if (clk->prepare_count)
 		__clk_prepare(parent);
 
-	/* FIXME replace with clk_is_enabled(clk) someday */
 	flags = clk_enable_lock();
-	if (clk->enable_count)
+
+	/* migrate enable */
+	if (clk->enable_count) {
 		__clk_enable(parent);
+		migrated_enable = true;
+	}
+
+	/* update the clk tree topology */
+	clk_reparent(clk, parent);
+
 	clk_enable_unlock(flags);
 
 	/* change clock input source */
 	if (parent && clk->ops->set_parent)
 		ret = clk->ops->set_parent(clk->hw, p_index);
 
-	/* clean up old prepare and enable */
-	flags = clk_enable_lock();
-	if (clk->enable_count)
+	if (ret) {
+		/*
+		 * The error handling is tricky due to that we need to release
+		 * the spinlock while issuing the .set_parent callback. This
+		 * means the new parent might have been enabled/disabled in
+		 * between, which must be considered when doing rollback.
+		 */
+		flags = clk_enable_lock();
+
+		clk_reparent(clk, old_parent);
+
+		if (migrated_enable && clk->enable_count) {
+			__clk_disable(parent);
+		} else if (migrated_enable && (clk->enable_count == 0)) {
+			__clk_disable(old_parent);
+		} else if (!migrated_enable && clk->enable_count) {
+			__clk_disable(parent);
+			__clk_enable(old_parent);
+		}
+
+		clk_enable_unlock(flags);
+
+		if (clk->prepare_count)
+			__clk_unprepare(parent);
+
+		return ret;
+	}
+
+	/* clean up enable for old parent if migration was done */
+	if (migrated_enable) {
+		flags = clk_enable_lock();
 		__clk_disable(old_parent);
-	clk_enable_unlock(flags);
+		clk_enable_unlock(flags);
+	}
 
+	/* clean up prepare for old parent if migration was done */
 	if (clk->prepare_count)
 		__clk_unprepare(old_parent);
 
-	return ret;
+	/* update debugfs with new clk tree topology */
+	clk_debug_reparent(clk, parent);
+	return 0;
 }
 
 /**
@@ -1450,14 +1490,11 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	/* do the re-parent */
 	ret = __clk_set_parent(clk, parent, p_index);
 
-	/* propagate ABORT_RATE_CHANGE if .set_parent failed */
-	if (ret) {
+	/* propagate rate recalculation accordingly */
+	if (ret)
 		__clk_recalc_rates(clk, ABORT_RATE_CHANGE);
-		goto out;
-	}
-
-	/* propagate rate recalculation downstream */
-	__clk_reparent(clk, parent);
+	else
+		__clk_recalc_rates(clk, POST_RATE_CHANGE);
 
 out:
 	clk_prepare_unlock();

commit 031dcc9bd4164a7482b89987d5b9ecb3af5e9033
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 2 23:09:38 2013 +0200

    clk: Fixup errorhandling for clk_set_parent
    
    Fixup the broken feature of allowing reparent of a clk to the
    orhpan list and vice verse. When operating on a single-parent
    clk, the .set_parent callback for the clk hw is optional to
    implement, but for a multi-parent clk it is mandatory.
    
    Moreover improve the errorhandling by verifying the prerequisites
    before triggering clk notifiers. This will prevent unnecessary
    rollback with ABORT_RATE_CHANGE.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 013a3c7fea5b..c83e8e543bab 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1332,15 +1332,10 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
 	__clk_recalc_rates(clk, POST_RATE_CHANGE);
 }
 
-static int __clk_set_parent(struct clk *clk, struct clk *parent)
+static u8 clk_fetch_parent_index(struct clk *clk, struct clk *parent)
 {
-	struct clk *old_parent;
-	unsigned long flags;
-	int ret = -EINVAL;
 	u8 i;
 
-	old_parent = clk->parent;
-
 	if (!clk->parents)
 		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
 								GFP_KERNEL);
@@ -1360,11 +1355,14 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 		}
 	}
 
-	if (i == clk->num_parents) {
-		pr_debug("%s: clock %s is not a possible parent of clock %s\n",
-				__func__, parent->name, clk->name);
-		goto out;
-	}
+	return i;
+}
+
+static int __clk_set_parent(struct clk *clk, struct clk *parent, u8 p_index)
+{
+	unsigned long flags;
+	int ret = 0;
+	struct clk *old_parent = clk->parent;
 
 	/* migrate prepare and enable */
 	if (clk->prepare_count)
@@ -1377,7 +1375,8 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 	clk_enable_unlock(flags);
 
 	/* change clock input source */
-	ret = clk->ops->set_parent(clk->hw, i);
+	if (parent && clk->ops->set_parent)
+		ret = clk->ops->set_parent(clk->hw, p_index);
 
 	/* clean up old prepare and enable */
 	flags = clk_enable_lock();
@@ -1388,7 +1387,6 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 	if (clk->prepare_count)
 		__clk_unprepare(old_parent);
 
-out:
 	return ret;
 }
 
@@ -1407,11 +1405,14 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {
 	int ret = 0;
+	u8 p_index = 0;
+	unsigned long p_rate = 0;
 
 	if (!clk || !clk->ops)
 		return -EINVAL;
 
-	if (!clk->ops->set_parent)
+	/* verify ops for for multi-parent clks */
+	if ((clk->num_parents > 1) && (!clk->ops->set_parent))
 		return -ENOSYS;
 
 	/* prevent racing with updates to the clock topology */
@@ -1420,19 +1421,34 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	if (clk->parent == parent)
 		goto out;
 
+	/* check that we are allowed to re-parent if the clock is in use */
+	if ((clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	/* try finding the new parent index */
+	if (parent) {
+		p_index = clk_fetch_parent_index(clk, parent);
+		p_rate = parent->rate;
+		if (p_index == clk->num_parents) {
+			pr_debug("%s: clk %s can not be parent of clk %s\n",
+					__func__, parent->name, clk->name);
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
 	/* propagate PRE_RATE_CHANGE notifications */
 	if (clk->notifier_count)
-		ret = __clk_speculate_rates(clk, parent->rate);
+		ret = __clk_speculate_rates(clk, p_rate);
 
 	/* abort if a driver objects */
 	if (ret == NOTIFY_STOP)
 		goto out;
 
-	/* only re-parent if the clock is not in use */
-	if ((clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count)
-		ret = -EBUSY;
-	else
-		ret = __clk_set_parent(clk, parent);
+	/* do the re-parent */
+	ret = __clk_set_parent(clk, parent, p_index);
 
 	/* propagate ABORT_RATE_CHANGE if .set_parent failed */
 	if (ret) {

commit b33d212f4910ca44bd37d5e08422230687bd1378
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 2 23:09:37 2013 +0200

    clk: Restructure code for __clk_reparent
    
    Split __clk_reparent into three pieces, one for doing the actual
    reparent for updating the clock tree topology, one for the
    COMMON_CLK_DEBUG code and one for doing the rate recalculation.
    
    This patch also makes it possible to hold the spinlock over the
    update of the clock tree topology, which could not be done before
    when both debugfs updates and clock rate updates was done within
    the same function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0230c9d95975..013a3c7fea5b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -342,6 +342,39 @@ static int clk_debug_register(struct clk *clk)
 	return ret;
 }
 
+/**
+ * clk_debug_reparent - reparent clk node in the debugfs clk tree
+ * @clk: the clk being reparented
+ * @new_parent: the new clk parent, may be NULL
+ *
+ * Rename clk entry in the debugfs clk tree if debugfs has been
+ * initialized.  Otherwise it bails out early since the debugfs clk tree
+ * will be created lazily by clk_debug_init as part of a late_initcall.
+ *
+ * Caller must hold prepare_lock.
+ */
+static void clk_debug_reparent(struct clk *clk, struct clk *new_parent)
+{
+	struct dentry *d;
+	struct dentry *new_parent_d;
+
+	if (!inited)
+		return;
+
+	if (new_parent)
+		new_parent_d = new_parent->dentry;
+	else
+		new_parent_d = orphandir;
+
+	d = debugfs_rename(clk->dentry->d_parent, clk->dentry,
+			new_parent_d, clk->name);
+	if (d)
+		clk->dentry = d;
+	else
+		pr_debug("%s: failed to rename debugfs entry for %s\n",
+				__func__, clk->name);
+}
+
 /**
  * clk_debug_init - lazily create the debugfs clk tree visualization
  *
@@ -396,6 +429,9 @@ static int __init clk_debug_init(void)
 late_initcall(clk_debug_init);
 #else
 static inline int clk_debug_register(struct clk *clk) { return 0; }
+static inline void clk_debug_reparent(struct clk *clk, struct clk *new_parent)
+{
+}
 #endif
 
 /* caller must hold prepare_lock */
@@ -1277,16 +1313,8 @@ static struct clk *__clk_init_parent(struct clk *clk)
 	return ret;
 }
 
-void __clk_reparent(struct clk *clk, struct clk *new_parent)
+static void clk_reparent(struct clk *clk, struct clk *new_parent)
 {
-#ifdef CONFIG_COMMON_CLK_DEBUG
-	struct dentry *d;
-	struct dentry *new_parent_d;
-#endif
-
-	if (!clk || !new_parent)
-		return;
-
 	hlist_del(&clk->child_node);
 
 	if (new_parent)
@@ -1294,27 +1322,13 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
 	else
 		hlist_add_head(&clk->child_node, &clk_orphan_list);
 
-#ifdef CONFIG_COMMON_CLK_DEBUG
-	if (!inited)
-		goto out;
-
-	if (new_parent)
-		new_parent_d = new_parent->dentry;
-	else
-		new_parent_d = orphandir;
-
-	d = debugfs_rename(clk->dentry->d_parent, clk->dentry,
-			new_parent_d, clk->name);
-	if (d)
-		clk->dentry = d;
-	else
-		pr_debug("%s: failed to rename debugfs entry for %s\n",
-				__func__, clk->name);
-out:
-#endif
-
 	clk->parent = new_parent;
+}
 
+void __clk_reparent(struct clk *clk, struct clk *new_parent)
+{
+	clk_reparent(clk, new_parent);
+	clk_debug_reparent(clk, new_parent);
 	__clk_recalc_rates(clk, POST_RATE_CHANGE);
 }
 

commit 533ddeb1e86f506129ee388a6cc13796dcf31311
Author: Mike Turquette <mturquette@linaro.org>
Date:   Thu Mar 28 13:59:02 2013 -0700

    clk: allow reentrant calls into the clk framework
    
    Reentrancy into the clock framework is necessary for clock operations
    that result in nested calls to the clk api.  A common example is a clock
    that is prepared via an i2c transaction, such as a clock inside of a
    discrete audio chip or a power management IC.  The i2c subsystem itself
    will use the clk api resulting in a deadlock:
    
    clk_prepare(audio_clk)
            i2c_transfer(..)
                    clk_prepare(i2c_controller_clk)
    
    The ability to reenter the clock framework prevents this deadlock.
    
    Other use cases exist such as allowing .set_rate callbacks to call
    clk_set_parent to achieve the best rate, or to save power in certain
    configurations.  Yet another example is performing pinctrl operations
    from a clk_ops callback.  Calls into the pinctrl subsystem may call
    clk_{un}prepare on an unrelated clock.  Allowing for nested calls to
    reenter the clock framework enables both of these use cases.
    
    Reentrancy is implemented by two global pointers that track the owner
    currently holding a global lock.  One pointer tracks the owner during
    sleepable, mutex-protected operations and the other one tracks the owner
    during non-interruptible, spinlock-protected operations.
    
    When the clk framework is entered we try to hold the global lock.  If it
    is held we compare the current task against the current owner; a match
    implies a nested call and we reenter.  If the values do not match then
    we block on the lock until it is released.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0b5d61201ca1..0230c9d95975 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -19,10 +19,17 @@
 #include <linux/of.h>
 #include <linux/device.h>
 #include <linux/init.h>
+#include <linux/sched.h>
 
 static DEFINE_SPINLOCK(enable_lock);
 static DEFINE_MUTEX(prepare_lock);
 
+static struct task_struct *prepare_owner;
+static struct task_struct *enable_owner;
+
+static int prepare_refcnt;
+static int enable_refcnt;
+
 static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
@@ -30,23 +37,56 @@ static LIST_HEAD(clk_notifier_list);
 /***           locking             ***/
 static void clk_prepare_lock(void)
 {
-	mutex_lock(&prepare_lock);
+	if (!mutex_trylock(&prepare_lock)) {
+		if (prepare_owner == current) {
+			prepare_refcnt++;
+			return;
+		}
+		mutex_lock(&prepare_lock);
+	}
+	WARN_ON_ONCE(prepare_owner != NULL);
+	WARN_ON_ONCE(prepare_refcnt != 0);
+	prepare_owner = current;
+	prepare_refcnt = 1;
 }
 
 static void clk_prepare_unlock(void)
 {
+	WARN_ON_ONCE(prepare_owner != current);
+	WARN_ON_ONCE(prepare_refcnt == 0);
+
+	if (--prepare_refcnt)
+		return;
+	prepare_owner = NULL;
 	mutex_unlock(&prepare_lock);
 }
 
 static unsigned long clk_enable_lock(void)
 {
 	unsigned long flags;
-	spin_lock_irqsave(&enable_lock, flags);
+
+	if (!spin_trylock_irqsave(&enable_lock, flags)) {
+		if (enable_owner == current) {
+			enable_refcnt++;
+			return flags;
+		}
+		spin_lock_irqsave(&enable_lock, flags);
+	}
+	WARN_ON_ONCE(enable_owner != NULL);
+	WARN_ON_ONCE(enable_refcnt != 0);
+	enable_owner = current;
+	enable_refcnt = 1;
 	return flags;
 }
 
 static void clk_enable_unlock(unsigned long flags)
 {
+	WARN_ON_ONCE(enable_owner != current);
+	WARN_ON_ONCE(enable_refcnt == 0);
+
+	if (--enable_refcnt)
+		return;
+	enable_owner = NULL;
 	spin_unlock_irqrestore(&enable_lock, flags);
 }
 

commit eab89f690ee0805c02017d7959f4f930379a8c46
Author: Mike Turquette <mturquette@linaro.org>
Date:   Thu Mar 28 13:59:01 2013 -0700

    clk: abstract locking out into helper functions
    
    Create locking helpers for the global mutex and global spinlock.  The
    definitions of these helpers will be expanded upon in the next patch
    which introduces reentrancy into the locking scheme.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: Rajagopal Venkat <rajagopal.venkat@linaro.org>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 5e8ffff99362..0b5d61201ca1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -27,6 +27,29 @@ static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
 
+/***           locking             ***/
+static void clk_prepare_lock(void)
+{
+	mutex_lock(&prepare_lock);
+}
+
+static void clk_prepare_unlock(void)
+{
+	mutex_unlock(&prepare_lock);
+}
+
+static unsigned long clk_enable_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&enable_lock, flags);
+	return flags;
+}
+
+static void clk_enable_unlock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&enable_lock, flags);
+}
+
 /***        debugfs support        ***/
 
 #ifdef CONFIG_COMMON_CLK_DEBUG
@@ -69,7 +92,7 @@ static int clk_summary_show(struct seq_file *s, void *data)
 	seq_printf(s, "   clock                        enable_cnt  prepare_cnt  rate\n");
 	seq_printf(s, "---------------------------------------------------------------------\n");
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	hlist_for_each_entry(c, &clk_root_list, child_node)
 		clk_summary_show_subtree(s, c, 0);
@@ -77,7 +100,7 @@ static int clk_summary_show(struct seq_file *s, void *data)
 	hlist_for_each_entry(c, &clk_orphan_list, child_node)
 		clk_summary_show_subtree(s, c, 0);
 
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return 0;
 }
@@ -130,7 +153,7 @@ static int clk_dump(struct seq_file *s, void *data)
 
 	seq_printf(s, "{");
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	hlist_for_each_entry(c, &clk_root_list, child_node) {
 		if (!first_node)
@@ -144,7 +167,7 @@ static int clk_dump(struct seq_file *s, void *data)
 		clk_dump_subtree(s, c, 0);
 	}
 
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	seq_printf(s, "}");
 	return 0;
@@ -316,7 +339,7 @@ static int __init clk_debug_init(void)
 	if (!orphandir)
 		return -ENOMEM;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	hlist_for_each_entry(clk, &clk_root_list, child_node)
 		clk_debug_create_subtree(clk, rootdir);
@@ -326,7 +349,7 @@ static int __init clk_debug_init(void)
 
 	inited = 1;
 
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return 0;
 }
@@ -372,7 +395,7 @@ static void clk_disable_unused_subtree(struct clk *clk)
 	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_disable_unused_subtree(child);
 
-	spin_lock_irqsave(&enable_lock, flags);
+	flags = clk_enable_lock();
 
 	if (clk->enable_count)
 		goto unlock_out;
@@ -393,7 +416,7 @@ static void clk_disable_unused_subtree(struct clk *clk)
 	}
 
 unlock_out:
-	spin_unlock_irqrestore(&enable_lock, flags);
+	clk_enable_unlock(flags);
 
 out:
 	return;
@@ -403,7 +426,7 @@ static int clk_disable_unused(void)
 {
 	struct clk *clk;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	hlist_for_each_entry(clk, &clk_root_list, child_node)
 		clk_disable_unused_subtree(clk);
@@ -417,7 +440,7 @@ static int clk_disable_unused(void)
 	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
 		clk_unprepare_unused_subtree(clk);
 
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return 0;
 }
@@ -600,9 +623,9 @@ void __clk_unprepare(struct clk *clk)
  */
 void clk_unprepare(struct clk *clk)
 {
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 	__clk_unprepare(clk);
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 }
 EXPORT_SYMBOL_GPL(clk_unprepare);
 
@@ -648,9 +671,9 @@ int clk_prepare(struct clk *clk)
 {
 	int ret;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 	ret = __clk_prepare(clk);
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return ret;
 }
@@ -692,9 +715,9 @@ void clk_disable(struct clk *clk)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&enable_lock, flags);
+	flags = clk_enable_lock();
 	__clk_disable(clk);
-	spin_unlock_irqrestore(&enable_lock, flags);
+	clk_enable_unlock(flags);
 }
 EXPORT_SYMBOL_GPL(clk_disable);
 
@@ -745,9 +768,9 @@ int clk_enable(struct clk *clk)
 	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&enable_lock, flags);
+	flags = clk_enable_lock();
 	ret = __clk_enable(clk);
-	spin_unlock_irqrestore(&enable_lock, flags);
+	clk_enable_unlock(flags);
 
 	return ret;
 }
@@ -792,9 +815,9 @@ long clk_round_rate(struct clk *clk, unsigned long rate)
 {
 	unsigned long ret;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 	ret = __clk_round_rate(clk, rate);
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return ret;
 }
@@ -889,13 +912,13 @@ unsigned long clk_get_rate(struct clk *clk)
 {
 	unsigned long rate;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	if (clk && (clk->flags & CLK_GET_RATE_NOCACHE))
 		__clk_recalc_rates(clk, 0);
 
 	rate = __clk_get_rate(clk);
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return rate;
 }
@@ -1100,7 +1123,7 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	int ret = 0;
 
 	/* prevent racing with updates to the clock topology */
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	/* bail early if nothing to do */
 	if (rate == clk->rate)
@@ -1132,7 +1155,7 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	clk_change_rate(top);
 
 out:
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return ret;
 }
@@ -1148,9 +1171,9 @@ struct clk *clk_get_parent(struct clk *clk)
 {
 	struct clk *parent;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 	parent = __clk_get_parent(clk);
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return parent;
 }
@@ -1294,19 +1317,19 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 		__clk_prepare(parent);
 
 	/* FIXME replace with clk_is_enabled(clk) someday */
-	spin_lock_irqsave(&enable_lock, flags);
+	flags = clk_enable_lock();
 	if (clk->enable_count)
 		__clk_enable(parent);
-	spin_unlock_irqrestore(&enable_lock, flags);
+	clk_enable_unlock(flags);
 
 	/* change clock input source */
 	ret = clk->ops->set_parent(clk->hw, i);
 
 	/* clean up old prepare and enable */
-	spin_lock_irqsave(&enable_lock, flags);
+	flags = clk_enable_lock();
 	if (clk->enable_count)
 		__clk_disable(old_parent);
-	spin_unlock_irqrestore(&enable_lock, flags);
+	clk_enable_unlock(flags);
 
 	if (clk->prepare_count)
 		__clk_unprepare(old_parent);
@@ -1338,7 +1361,7 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 		return -ENOSYS;
 
 	/* prevent racing with updates to the clock topology */
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	if (clk->parent == parent)
 		goto out;
@@ -1367,7 +1390,7 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 	__clk_reparent(clk, parent);
 
 out:
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return ret;
 }
@@ -1390,7 +1413,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 	if (!clk)
 		return -EINVAL;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	/* check to see if a clock with this name is already registered */
 	if (__clk_lookup(clk->name)) {
@@ -1514,7 +1537,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 	clk_debug_register(clk);
 
 out:
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return ret;
 }
@@ -1748,7 +1771,7 @@ int clk_notifier_register(struct clk *clk, struct notifier_block *nb)
 	if (!clk || !nb)
 		return -EINVAL;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	/* search the list of notifiers for this clk */
 	list_for_each_entry(cn, &clk_notifier_list, node)
@@ -1772,7 +1795,7 @@ int clk_notifier_register(struct clk *clk, struct notifier_block *nb)
 	clk->notifier_count++;
 
 out:
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return ret;
 }
@@ -1797,7 +1820,7 @@ int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)
 	if (!clk || !nb)
 		return -EINVAL;
 
-	mutex_lock(&prepare_lock);
+	clk_prepare_lock();
 
 	list_for_each_entry(cn, &clk_notifier_list, node)
 		if (cn->clk == clk)
@@ -1818,7 +1841,7 @@ int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)
 		ret = -ENOENT;
 	}
 
-	mutex_unlock(&prepare_lock);
+	clk_prepare_unlock();
 
 	return ret;
 }

commit 5fda6858a49c2d8706adcc05f083b64af172d3eb
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Mar 13 15:17:49 2013 +0530

    clk: Fix incorrect return type in clk.c
    
    Return type of function clk_propagate_rate_change is a pointer.
    But 0 was being returned. Change it to NULL.
    Silences the following warning:
    drivers/clk/clk.c:977:24: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Reviewed-by: Pankaj Jangra <jangra.pankaj9@gmail.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 253792a46c08..5e8ffff99362 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1026,7 +1026,7 @@ static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long even
 	int ret = NOTIFY_DONE;
 
 	if (clk->rate == clk->new_rate)
-		return 0;
+		return NULL;
 
 	if (clk->notifier_count) {
 		ret = __clk_notify(clk, event, clk->rate, clk->new_rate);

commit 3cc8247f1dce79511de8bf0f69ab02a46cc315b7
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 12 20:26:04 2013 +0100

    clk: Introduce optional unprepare_unused callback
    
    An unprepare_unused callback is introduced due to the same reasons to
    why the disable_unused callback was added.
    
    During the clk_disable_unused sequence, those clk_hw that needs specific
    treatment with regards to being unprepared, shall implement the
    unprepare_unused callback.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c0141f3e1109..253792a46c08 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -352,9 +352,12 @@ static void clk_unprepare_unused_subtree(struct clk *clk)
 	if (clk->flags & CLK_IGNORE_UNUSED)
 		return;
 
-	if (__clk_is_prepared(clk))
-		if (clk->ops->unprepare)
+	if (__clk_is_prepared(clk)) {
+		if (clk->ops->unprepare_unused)
+			clk->ops->unprepare_unused(clk->hw);
+		else if (clk->ops->unprepare)
 			clk->ops->unprepare(clk->hw);
+	}
 }
 
 /* caller must hold prepare_lock */

commit 1c155b3dfe08351f5fc811062648969f1ba7af53
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 12 20:26:03 2013 +0100

    clk: Unprepare the unused prepared slow clocks at late init
    
    The unused ungated fast clocks are already being disabled from
    clk_disable_unused at late init. This patch extend this sequence
    to the slow unused prepared clocks to be unprepared.
    
    Unless the optional .is_prepared callback is implemented by a
    clk_hw the clk_disable_unused sequence will not unprepare any
    unused clocks, since it will fall back to use the software
    prepare counter.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: fixed hlist accessors per b67bfe0d]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7571b5054f3c..c0141f3e1109 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -335,6 +335,28 @@ late_initcall(clk_debug_init);
 static inline int clk_debug_register(struct clk *clk) { return 0; }
 #endif
 
+/* caller must hold prepare_lock */
+static void clk_unprepare_unused_subtree(struct clk *clk)
+{
+	struct clk *child;
+
+	if (!clk)
+		return;
+
+	hlist_for_each_entry(child, &clk->children, child_node)
+		clk_unprepare_unused_subtree(child);
+
+	if (clk->prepare_count)
+		return;
+
+	if (clk->flags & CLK_IGNORE_UNUSED)
+		return;
+
+	if (__clk_is_prepared(clk))
+		if (clk->ops->unprepare)
+			clk->ops->unprepare(clk->hw);
+}
+
 /* caller must hold prepare_lock */
 static void clk_disable_unused_subtree(struct clk *clk)
 {
@@ -386,6 +408,12 @@ static int clk_disable_unused(void)
 	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
 		clk_disable_unused_subtree(clk);
 
+	hlist_for_each_entry(clk, &clk_root_list, child_node)
+		clk_unprepare_unused_subtree(clk);
+
+	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
+		clk_unprepare_unused_subtree(clk);
+
 	mutex_unlock(&prepare_lock);
 
 	return 0;

commit 3d6ee287a3e341c88eafd0b4620b12d640b3736b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 12 20:26:02 2013 +0100

    clk: Introduce optional is_prepared callback
    
    To reflect whether a clk_hw is prepared the clk_hw may implement
    the optional is_prepared callback. If not implemented we fall back
    to use the software prepare counter.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ed87b2405806..7571b5054f3c 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -451,6 +451,27 @@ unsigned long __clk_get_flags(struct clk *clk)
 	return !clk ? 0 : clk->flags;
 }
 
+bool __clk_is_prepared(struct clk *clk)
+{
+	int ret;
+
+	if (!clk)
+		return false;
+
+	/*
+	 * .is_prepared is optional for clocks that can prepare
+	 * fall back to software usage counter if it is missing
+	 */
+	if (!clk->ops->is_prepared) {
+		ret = clk->prepare_count ? 1 : 0;
+		goto out;
+	}
+
+	ret = clk->ops->is_prepared(clk->hw);
+out:
+	return !!ret;
+}
+
 bool __clk_is_enabled(struct clk *clk)
 {
 	int ret;

commit b67bfe0d42cac56c512dd5da4b1b347a23f4b70a
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Feb 27 17:06:00 2013 -0800

    hlist: drop the node parameter from iterators
    
    I'm not sure why, but the hlist for each entry iterators were conceived
    
            list_for_each_entry(pos, head, member)
    
    The hlist ones were greedy and wanted an extra parameter:
    
            hlist_for_each_entry(tpos, pos, head, member)
    
    Why did they need an extra pos parameter? I'm not quite sure. Not only
    they don't really need it, it also prevents the iterator from looking
    exactly like the list iterator, which is unfortunate.
    
    Besides the semantic patch, there was some manual work required:
    
     - Fix up the actual hlist iterators in linux/list.h
     - Fix up the declaration of other iterators based on the hlist ones.
     - A very small amount of places were using the 'node' parameter, this
     was modified to use 'obj->member' instead.
     - Coccinelle didn't handle the hlist_for_each_entry_safe iterator
     properly, so those had to be fixed up manually.
    
    The semantic patch which is mostly the work of Peter Senna Tschudin is here:
    
    @@
    iterator name hlist_for_each_entry, hlist_for_each_entry_continue, hlist_for_each_entry_from, hlist_for_each_entry_rcu, hlist_for_each_entry_rcu_bh, hlist_for_each_entry_continue_rcu_bh, for_each_busy_worker, ax25_uid_for_each, ax25_for_each, inet_bind_bucket_for_each, sctp_for_each_hentry, sk_for_each, sk_for_each_rcu, sk_for_each_from, sk_for_each_safe, sk_for_each_bound, hlist_for_each_entry_safe, hlist_for_each_entry_continue_rcu, nr_neigh_for_each, nr_neigh_for_each_safe, nr_node_for_each, nr_node_for_each_safe, for_each_gfn_indirect_valid_sp, for_each_gfn_sp, for_each_host;
    
    type T;
    expression a,c,d,e;
    identifier b;
    statement S;
    @@
    
    -T b;
        <+... when != b
    (
    hlist_for_each_entry(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_continue(a,
    - b,
    c) S
    |
    hlist_for_each_entry_from(a,
    - b,
    c) S
    |
    hlist_for_each_entry_rcu(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_rcu_bh(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_continue_rcu_bh(a,
    - b,
    c) S
    |
    for_each_busy_worker(a, c,
    - b,
    d) S
    |
    ax25_uid_for_each(a,
    - b,
    c) S
    |
    ax25_for_each(a,
    - b,
    c) S
    |
    inet_bind_bucket_for_each(a,
    - b,
    c) S
    |
    sctp_for_each_hentry(a,
    - b,
    c) S
    |
    sk_for_each(a,
    - b,
    c) S
    |
    sk_for_each_rcu(a,
    - b,
    c) S
    |
    sk_for_each_from
    -(a, b)
    +(a)
    S
    + sk_for_each_from(a) S
    |
    sk_for_each_safe(a,
    - b,
    c, d) S
    |
    sk_for_each_bound(a,
    - b,
    c) S
    |
    hlist_for_each_entry_safe(a,
    - b,
    c, d, e) S
    |
    hlist_for_each_entry_continue_rcu(a,
    - b,
    c) S
    |
    nr_neigh_for_each(a,
    - b,
    c) S
    |
    nr_neigh_for_each_safe(a,
    - b,
    c, d) S
    |
    nr_node_for_each(a,
    - b,
    c) S
    |
    nr_node_for_each_safe(a,
    - b,
    c, d) S
    |
    - for_each_gfn_sp(a, c, d, b) S
    + for_each_gfn_sp(a, c, d) S
    |
    - for_each_gfn_indirect_valid_sp(a, c, d, b) S
    + for_each_gfn_indirect_valid_sp(a, c, d) S
    |
    for_each_host(a,
    - b,
    c) S
    |
    for_each_host_safe(a,
    - b,
    c, d) S
    |
    for_each_mesh_entry(a,
    - b,
    c, d) S
    )
        ...+>
    
    [akpm@linux-foundation.org: drop bogus change from net/ipv4/raw.c]
    [akpm@linux-foundation.org: drop bogus hunk from net/ipv6/raw.c]
    [akpm@linux-foundation.org: checkpatch fixes]
    [akpm@linux-foundation.org: fix warnings]
    [akpm@linux-foudnation.org: redo intrusive kvm changes]
    Tested-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index fabbfe1a9253..ed87b2405806 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -52,31 +52,29 @@ static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
 				     int level)
 {
 	struct clk *child;
-	struct hlist_node *tmp;
 
 	if (!c)
 		return;
 
 	clk_summary_show_one(s, c, level);
 
-	hlist_for_each_entry(child, tmp, &c->children, child_node)
+	hlist_for_each_entry(child, &c->children, child_node)
 		clk_summary_show_subtree(s, child, level + 1);
 }
 
 static int clk_summary_show(struct seq_file *s, void *data)
 {
 	struct clk *c;
-	struct hlist_node *tmp;
 
 	seq_printf(s, "   clock                        enable_cnt  prepare_cnt  rate\n");
 	seq_printf(s, "---------------------------------------------------------------------\n");
 
 	mutex_lock(&prepare_lock);
 
-	hlist_for_each_entry(c, tmp, &clk_root_list, child_node)
+	hlist_for_each_entry(c, &clk_root_list, child_node)
 		clk_summary_show_subtree(s, c, 0);
 
-	hlist_for_each_entry(c, tmp, &clk_orphan_list, child_node)
+	hlist_for_each_entry(c, &clk_orphan_list, child_node)
 		clk_summary_show_subtree(s, c, 0);
 
 	mutex_unlock(&prepare_lock);
@@ -111,14 +109,13 @@ static void clk_dump_one(struct seq_file *s, struct clk *c, int level)
 static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
 {
 	struct clk *child;
-	struct hlist_node *tmp;
 
 	if (!c)
 		return;
 
 	clk_dump_one(s, c, level);
 
-	hlist_for_each_entry(child, tmp, &c->children, child_node) {
+	hlist_for_each_entry(child, &c->children, child_node) {
 		seq_printf(s, ",");
 		clk_dump_subtree(s, child, level + 1);
 	}
@@ -129,21 +126,20 @@ static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
 static int clk_dump(struct seq_file *s, void *data)
 {
 	struct clk *c;
-	struct hlist_node *tmp;
 	bool first_node = true;
 
 	seq_printf(s, "{");
 
 	mutex_lock(&prepare_lock);
 
-	hlist_for_each_entry(c, tmp, &clk_root_list, child_node) {
+	hlist_for_each_entry(c, &clk_root_list, child_node) {
 		if (!first_node)
 			seq_printf(s, ",");
 		first_node = false;
 		clk_dump_subtree(s, c, 0);
 	}
 
-	hlist_for_each_entry(c, tmp, &clk_orphan_list, child_node) {
+	hlist_for_each_entry(c, &clk_orphan_list, child_node) {
 		seq_printf(s, ",");
 		clk_dump_subtree(s, c, 0);
 	}
@@ -222,7 +218,6 @@ static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)
 {
 	struct clk *child;
-	struct hlist_node *tmp;
 	int ret = -EINVAL;;
 
 	if (!clk || !pdentry)
@@ -233,7 +228,7 @@ static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)
 	if (ret)
 		goto out;
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_debug_create_subtree(child, clk->dentry);
 
 	ret = 0;
@@ -299,7 +294,6 @@ static int clk_debug_register(struct clk *clk)
 static int __init clk_debug_init(void)
 {
 	struct clk *clk;
-	struct hlist_node *tmp;
 	struct dentry *d;
 
 	rootdir = debugfs_create_dir("clk", NULL);
@@ -324,10 +318,10 @@ static int __init clk_debug_init(void)
 
 	mutex_lock(&prepare_lock);
 
-	hlist_for_each_entry(clk, tmp, &clk_root_list, child_node)
+	hlist_for_each_entry(clk, &clk_root_list, child_node)
 		clk_debug_create_subtree(clk, rootdir);
 
-	hlist_for_each_entry(clk, tmp, &clk_orphan_list, child_node)
+	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
 		clk_debug_create_subtree(clk, orphandir);
 
 	inited = 1;
@@ -345,13 +339,12 @@ static inline int clk_debug_register(struct clk *clk) { return 0; }
 static void clk_disable_unused_subtree(struct clk *clk)
 {
 	struct clk *child;
-	struct hlist_node *tmp;
 	unsigned long flags;
 
 	if (!clk)
 		goto out;
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_disable_unused_subtree(child);
 
 	spin_lock_irqsave(&enable_lock, flags);
@@ -384,14 +377,13 @@ static void clk_disable_unused_subtree(struct clk *clk)
 static int clk_disable_unused(void)
 {
 	struct clk *clk;
-	struct hlist_node *tmp;
 
 	mutex_lock(&prepare_lock);
 
-	hlist_for_each_entry(clk, tmp, &clk_root_list, child_node)
+	hlist_for_each_entry(clk, &clk_root_list, child_node)
 		clk_disable_unused_subtree(clk);
 
-	hlist_for_each_entry(clk, tmp, &clk_orphan_list, child_node)
+	hlist_for_each_entry(clk, &clk_orphan_list, child_node)
 		clk_disable_unused_subtree(clk);
 
 	mutex_unlock(&prepare_lock);
@@ -484,12 +476,11 @@ static struct clk *__clk_lookup_subtree(const char *name, struct clk *clk)
 {
 	struct clk *child;
 	struct clk *ret;
-	struct hlist_node *tmp;
 
 	if (!strcmp(clk->name, name))
 		return clk;
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+	hlist_for_each_entry(child, &clk->children, child_node) {
 		ret = __clk_lookup_subtree(name, child);
 		if (ret)
 			return ret;
@@ -502,20 +493,19 @@ struct clk *__clk_lookup(const char *name)
 {
 	struct clk *root_clk;
 	struct clk *ret;
-	struct hlist_node *tmp;
 
 	if (!name)
 		return NULL;
 
 	/* search the 'proper' clk tree first */
-	hlist_for_each_entry(root_clk, tmp, &clk_root_list, child_node) {
+	hlist_for_each_entry(root_clk, &clk_root_list, child_node) {
 		ret = __clk_lookup_subtree(name, root_clk);
 		if (ret)
 			return ret;
 	}
 
 	/* if not found, then search the orphan tree */
-	hlist_for_each_entry(root_clk, tmp, &clk_orphan_list, child_node) {
+	hlist_for_each_entry(root_clk, &clk_orphan_list, child_node) {
 		ret = __clk_lookup_subtree(name, root_clk);
 		if (ret)
 			return ret;
@@ -812,7 +802,6 @@ static void __clk_recalc_rates(struct clk *clk, unsigned long msg)
 {
 	unsigned long old_rate;
 	unsigned long parent_rate = 0;
-	struct hlist_node *tmp;
 	struct clk *child;
 
 	old_rate = clk->rate;
@@ -832,7 +821,7 @@ static void __clk_recalc_rates(struct clk *clk, unsigned long msg)
 	if (clk->notifier_count && msg)
 		__clk_notify(clk, msg, old_rate, clk->rate);
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+	hlist_for_each_entry(child, &clk->children, child_node)
 		__clk_recalc_rates(child, msg);
 }
 
@@ -878,7 +867,6 @@ EXPORT_SYMBOL_GPL(clk_get_rate);
  */
 static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 {
-	struct hlist_node *tmp;
 	struct clk *child;
 	unsigned long new_rate;
 	int ret = NOTIFY_DONE;
@@ -895,7 +883,7 @@ static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 	if (ret == NOTIFY_BAD)
 		goto out;
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+	hlist_for_each_entry(child, &clk->children, child_node) {
 		ret = __clk_speculate_rates(child, new_rate);
 		if (ret == NOTIFY_BAD)
 			break;
@@ -908,11 +896,10 @@ static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
 static void clk_calc_subtree(struct clk *clk, unsigned long new_rate)
 {
 	struct clk *child;
-	struct hlist_node *tmp;
 
 	clk->new_rate = new_rate;
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+	hlist_for_each_entry(child, &clk->children, child_node) {
 		if (child->ops->recalc_rate)
 			child->new_rate = child->ops->recalc_rate(child->hw, new_rate);
 		else
@@ -983,7 +970,6 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
  */
 static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long event)
 {
-	struct hlist_node *tmp;
 	struct clk *child, *fail_clk = NULL;
 	int ret = NOTIFY_DONE;
 
@@ -996,7 +982,7 @@ static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long even
 			fail_clk = clk;
 	}
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+	hlist_for_each_entry(child, &clk->children, child_node) {
 		clk = clk_propagate_rate_change(child, event);
 		if (clk)
 			fail_clk = clk;
@@ -1014,7 +1000,6 @@ static void clk_change_rate(struct clk *clk)
 	struct clk *child;
 	unsigned long old_rate;
 	unsigned long best_parent_rate = 0;
-	struct hlist_node *tmp;
 
 	old_rate = clk->rate;
 
@@ -1032,7 +1017,7 @@ static void clk_change_rate(struct clk *clk)
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
 
-	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_change_rate(child);
 }
 
@@ -1348,7 +1333,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 {
 	int i, ret = 0;
 	struct clk *orphan;
-	struct hlist_node *tmp, *tmp2;
+	struct hlist_node *tmp2;
 
 	if (!clk)
 		return -EINVAL;
@@ -1448,7 +1433,7 @@ int __clk_init(struct device *dev, struct clk *clk)
 	 * walk the list of orphan clocks and reparent any that are children of
 	 * this clock
 	 */
-	hlist_for_each_entry_safe(orphan, tmp, tmp2, &clk_orphan_list, child_node) {
+	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
 		if (orphan->ops->get_parent) {
 			i = orphan->ops->get_parent(orphan->hw);
 			if (!strcmp(clk->name, orphan->parent_names[i]))

commit f2f6c2556dcc432e50003bc8fa4d62d95906f149
Author: Prashant Gaikwad <pgaikwad@nvidia.com>
Date:   Fri Jan 4 12:30:52 2013 +0530

    clk: add common of_clk_init() function
    
    Modify of_clk_init function so that it will determine which
    driver to initialize based on device tree instead of each driver
    registering to it.
    
    Based on a similar patch for drivers/irqchip by Thomas Petazzoni and
    drivers/clocksource by Stephen Warren.
    
    Signed-off-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Tested-by: Tony Prisk <linux@prisktech.co.nz>
    Tested-by: Pawel Moll <pawel.moll@arm.com>
    Tested-by: Rob Herring <rob.herring@calxeda.com>
    Tested-by: Josh Cartwright <josh.cartwright@ni.com>
    Reviewed-by: Josh Cartwright <josh.cartwright@ni.com>
    Acked-by: Maxime Ripard <maxime.ripard@anandra.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: merge conflict from missing CLKSRC_OF_TABLES()]
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ad2ac94fede8..fabbfe1a9253 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/device.h>
+#include <linux/init.h>
 
 static DEFINE_SPINLOCK(enable_lock);
 static DEFINE_MUTEX(prepare_lock);
@@ -1803,6 +1804,11 @@ struct of_clk_provider {
 	void *data;
 };
 
+extern struct of_device_id __clk_of_table[];
+
+static const struct of_device_id __clk_of_table_sentinel
+	__used __section(__clk_of_table_end);
+
 static LIST_HEAD(of_clk_providers);
 static DEFINE_MUTEX(of_clk_lock);
 
@@ -1931,6 +1937,9 @@ void __init of_clk_init(const struct of_device_id *matches)
 {
 	struct device_node *np;
 
+	if (!matches)
+		matches = __clk_of_table;
+
 	for_each_matching_node(np, matches) {
 		const struct of_device_id *match = of_match_node(matches, np);
 		of_clk_init_cb_t clk_init_cb = match->data;

commit 4cfe54e57910b59444d34a05284db27df416f20b
Author: Nestor Ovroy <novroy@riseup.net>
Date:   Fri Jan 18 17:07:39 2013 +0100

    clk: Deduplicate exit code in clk_set_rate
    
    On non-out case 'return ret;' is equivalent to 'return 0;' as the ret
    variable is initialized at 0 and never changed.
    
    Signed-off-by: Nestor Ovroy <novroy@riseup.net>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 593a2e42d4af..ad2ac94fede8 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1093,9 +1093,6 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	/* change the rates */
 	clk_change_rate(top);
 
-	mutex_unlock(&prepare_lock);
-
-	return 0;
 out:
 	mutex_unlock(&prepare_lock);
 

commit bddca8944a7ab6699984c4b1b677261eb1c8d819
Author: Prashant Gaikwad <pgaikwad@nvidia.com>
Date:   Wed Dec 26 19:16:23 2012 +0530

    clk: JSON debugfs clock tree summary
    
    Clock information is dumped in JSON format which is easy
    for machines to parse.
    
    Each clock is represented as an object which has same name as
    clock and following properties
            - enable_count
            - prepare_count
            - rate
    
    Output is verified using online JSON editor.
    
    Signed-off-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8622b9de7302..593a2e42d4af 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -96,6 +96,76 @@ static const struct file_operations clk_summary_fops = {
 	.release	= single_release,
 };
 
+static void clk_dump_one(struct seq_file *s, struct clk *c, int level)
+{
+	if (!c)
+		return;
+
+	seq_printf(s, "\"%s\": { ", c->name);
+	seq_printf(s, "\"enable_count\": %d,", c->enable_count);
+	seq_printf(s, "\"prepare_count\": %d,", c->prepare_count);
+	seq_printf(s, "\"rate\": %lu", c->rate);
+}
+
+static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
+{
+	struct clk *child;
+	struct hlist_node *tmp;
+
+	if (!c)
+		return;
+
+	clk_dump_one(s, c, level);
+
+	hlist_for_each_entry(child, tmp, &c->children, child_node) {
+		seq_printf(s, ",");
+		clk_dump_subtree(s, child, level + 1);
+	}
+
+	seq_printf(s, "}");
+}
+
+static int clk_dump(struct seq_file *s, void *data)
+{
+	struct clk *c;
+	struct hlist_node *tmp;
+	bool first_node = true;
+
+	seq_printf(s, "{");
+
+	mutex_lock(&prepare_lock);
+
+	hlist_for_each_entry(c, tmp, &clk_root_list, child_node) {
+		if (!first_node)
+			seq_printf(s, ",");
+		first_node = false;
+		clk_dump_subtree(s, c, 0);
+	}
+
+	hlist_for_each_entry(c, tmp, &clk_orphan_list, child_node) {
+		seq_printf(s, ",");
+		clk_dump_subtree(s, c, 0);
+	}
+
+	mutex_unlock(&prepare_lock);
+
+	seq_printf(s, "}");
+	return 0;
+}
+
+
+static int clk_dump_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clk_dump, inode->i_private);
+}
+
+static const struct file_operations clk_dump_fops = {
+	.open		= clk_dump_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 /* caller must hold prepare_lock */
 static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 {
@@ -241,6 +311,11 @@ static int __init clk_debug_init(void)
 	if (!d)
 		return -ENOMEM;
 
+	d = debugfs_create_file("clk_dump", S_IRUGO, rootdir, NULL,
+				&clk_dump_fops);
+	if (!d)
+		return -ENOMEM;
+
 	orphandir = debugfs_create_dir("orphans", rootdir);
 
 	if (!orphandir)

commit 1af599df6bdad9ee34ae9e50efcda273e12b9d4f
Author: Prashant Gaikwad <pgaikwad@nvidia.com>
Date:   Wed Dec 26 19:16:22 2012 +0530

    clk: human-readable debugfs clock tree summary
    
    Adds debug file "clk_summary" in /sys/kernel/debug/clk dir.
    It helps to view all the clock registered in human-readable format.
    
    For example:
       clock                        enable_cnt  prepare_cnt  rate
    ---------------------------------------------------------------------
     i2s0_sync                      0           0            24000000
     spdif_in_sync                  0           0            24000000
        spdif_mux                   0           0            24000000
           spdif                    0           0            24000000
              spdif_doubler         0           0            48000000
                 spdif_div          0           0            48000000
                    spdif_2x        0           0            48000000
     clk_32k                        2           2            32768
        blink_override              1           1            32768
           blink                    1           1            32768
     clk_m                          2           2            12000000
        clk_out_3_mux               0           0            12000000
           clk_out_3                0           0            12000000
        pll_ref                     3           3            12000000
           pll_e_mux                0           0            12000000
              pll_e                 0           0            100000000
                 cml0               0           0            100000000
                 cml1               0           0            100000000
                 pciex              0           0            100000000
           pll_d2                   0           0            1000000
              pll_d2_out0           0           0            500000
           pll_d                    0           0            1000000
              pll_d_out0            0           0            500000
                 dsib_mux           0           0            500000
                    dsib            0           0            500000
                 dsia               0           0            500000
    
    Signed-off-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index eea70da02500..8622b9de7302 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -35,6 +35,67 @@ static struct dentry *rootdir;
 static struct dentry *orphandir;
 static int inited = 0;
 
+static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
+{
+	if (!c)
+		return;
+
+	seq_printf(s, "%*s%-*s %-11d %-12d %-10lu",
+		   level * 3 + 1, "",
+		   30 - level * 3, c->name,
+		   c->enable_count, c->prepare_count, c->rate);
+	seq_printf(s, "\n");
+}
+
+static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
+				     int level)
+{
+	struct clk *child;
+	struct hlist_node *tmp;
+
+	if (!c)
+		return;
+
+	clk_summary_show_one(s, c, level);
+
+	hlist_for_each_entry(child, tmp, &c->children, child_node)
+		clk_summary_show_subtree(s, child, level + 1);
+}
+
+static int clk_summary_show(struct seq_file *s, void *data)
+{
+	struct clk *c;
+	struct hlist_node *tmp;
+
+	seq_printf(s, "   clock                        enable_cnt  prepare_cnt  rate\n");
+	seq_printf(s, "---------------------------------------------------------------------\n");
+
+	mutex_lock(&prepare_lock);
+
+	hlist_for_each_entry(c, tmp, &clk_root_list, child_node)
+		clk_summary_show_subtree(s, c, 0);
+
+	hlist_for_each_entry(c, tmp, &clk_orphan_list, child_node)
+		clk_summary_show_subtree(s, c, 0);
+
+	mutex_unlock(&prepare_lock);
+
+	return 0;
+}
+
+
+static int clk_summary_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clk_summary_show, inode->i_private);
+}
+
+static const struct file_operations clk_summary_fops = {
+	.open		= clk_summary_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 /* caller must hold prepare_lock */
 static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 {
@@ -168,12 +229,18 @@ static int __init clk_debug_init(void)
 {
 	struct clk *clk;
 	struct hlist_node *tmp;
+	struct dentry *d;
 
 	rootdir = debugfs_create_dir("clk", NULL);
 
 	if (!rootdir)
 		return -ENOMEM;
 
+	d = debugfs_create_file("clk_summary", S_IRUGO, rootdir, NULL,
+				&clk_summary_fops);
+	if (!d)
+		return -ENOMEM;
+
 	orphandir = debugfs_create_dir("orphans", rootdir);
 
 	if (!orphandir)

commit 4895084c87ab0973308021d755596798160b682a
Author: Niels de Vos <ndevos@redhat.com>
Date:   Thu Dec 13 13:12:25 2012 +0100

    clk: export __clk_get_name for re-use in imx-ipu-v3 and others
    
    This fixes the following error when building for arm-imx:
    > ERROR: "__clk_get_name" [drivers/staging/imx-drm/ipu-v3/imx-ipu-v3.ko] undefined!
    > make[1]: *** [__modpost] Error 1
    > make: *** [modules] Error 2
    
    There are valid usecases to get the name of a clock, be it for debugging
    purposes or to register a children of a clock like done in this IPU driver.
    Therefore exporting __clk_get_name() and make it available for others makes
    sense.
    
    Reported-by: Peter Robinson <pbrobinson@gmail.com>
    CC: Sascha Hauer <s.hauer@pengutronix.de>
    CC: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Niels de Vos <ndevos@redhat.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: removal of inline made redundant by 65800b2]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9777466b81b9..eea70da02500 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -263,6 +263,7 @@ const char *__clk_get_name(struct clk *clk)
 {
 	return !clk ? NULL : clk->name;
 }
+EXPORT_SYMBOL_GPL(__clk_get_name);
 
 struct clk_hw *__clk_get_hw(struct clk *clk)
 {

commit 65800b2c4012e11f1c33692e6727e743a05c6efe
Author: Russ Dill <Russ.Dill@ti.com>
Date:   Mon Nov 26 11:20:09 2012 -0800

    clk: Don't mark shared helper functions as inline
    
    The helper functions that access the opaque struct clk should
    not be marked inline since they are contained in clk.c, but expected
    to be used by other compilation units. This causes compile errors
    under gcc-4.7
    
    In file included from arch/arm/mach-omap2/clockdomain.c:25:0:
    arch/arm/mach-omap2/clockdomain.c: In function clkdm_clk_disable:
    include/linux/clk-provider.h:338:12: error: inlining failed in call to always_inline __clk_get_enable_count: function body not available
    arch/arm/mach-omap2/clockdomain.c:1001:28: error: called from here
    make[1]: *** [arch/arm/mach-omap2/clockdomain.o] Error 1
    make: *** [arch/arm/mach-omap2] Error 2
    
    Signed-off-by: Russ Dill <Russ.Dill@ti.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: removed fixes made redundant by commit 93532c8a]
    [mturquette@linaro.org: improved $SUBJECT]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 251e45d6024d..9777466b81b9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -259,32 +259,32 @@ late_initcall(clk_disable_unused);
 
 /***    helper functions   ***/
 
-inline const char *__clk_get_name(struct clk *clk)
+const char *__clk_get_name(struct clk *clk)
 {
 	return !clk ? NULL : clk->name;
 }
 
-inline struct clk_hw *__clk_get_hw(struct clk *clk)
+struct clk_hw *__clk_get_hw(struct clk *clk)
 {
 	return !clk ? NULL : clk->hw;
 }
 
-inline u8 __clk_get_num_parents(struct clk *clk)
+u8 __clk_get_num_parents(struct clk *clk)
 {
 	return !clk ? 0 : clk->num_parents;
 }
 
-inline struct clk *__clk_get_parent(struct clk *clk)
+struct clk *__clk_get_parent(struct clk *clk)
 {
 	return !clk ? NULL : clk->parent;
 }
 
-inline unsigned int __clk_get_enable_count(struct clk *clk)
+unsigned int __clk_get_enable_count(struct clk *clk)
 {
 	return !clk ? 0 : clk->enable_count;
 }
 
-inline unsigned int __clk_get_prepare_count(struct clk *clk)
+unsigned int __clk_get_prepare_count(struct clk *clk)
 {
 	return !clk ? 0 : clk->prepare_count;
 }
@@ -310,7 +310,7 @@ unsigned long __clk_get_rate(struct clk *clk)
 	return ret;
 }
 
-inline unsigned long __clk_get_flags(struct clk *clk)
+unsigned long __clk_get_flags(struct clk *clk)
 {
 	return !clk ? 0 : clk->flags;
 }

commit 7c045a55c97fb83a2e5e9c6c857162c4866cc602
Author: Mike Turquette <mturquette@linaro.org>
Date:   Tue Dec 4 11:00:35 2012 -0800

    clk: introduce optional disable_unused callback
    
    Some gate clocks have special needs which must be handled during the
    disable-unused clocks sequence.  These needs might be driven by software
    due to the fact that we're disabling a clock outside of the normal
    clk_disable path and a clk's enable_count will not be accurate.  On the
    other hand a specific hardware programming sequence might need to be
    followed for this corner case.
    
    This change is needed for the upcoming OMAP port to the common clock
    framework.  Specifically, it is undesirable to treat the disable-unused
    path identically to the normal clk_disable path since other software
    layers are involved.  In this case OMAP's clockdomain code throws WARNs
    and bails early due to the clock's enable_count being set to zero.  A
    custom callback mitigates this problem nicely.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9955ad7e786e..251e45d6024d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -219,8 +219,17 @@ static void clk_disable_unused_subtree(struct clk *clk)
 	if (clk->flags & CLK_IGNORE_UNUSED)
 		goto unlock_out;
 
-	if (__clk_is_enabled(clk) && clk->ops->disable)
-		clk->ops->disable(clk->hw);
+	/*
+	 * some gate clocks have special needs during the disable-unused
+	 * sequence.  call .disable_unused if available, otherwise fall
+	 * back to .disable
+	 */
+	if (__clk_is_enabled(clk)) {
+		if (clk->ops->disable_unused)
+			clk->ops->disable_unused(clk->hw);
+		else if (clk->ops->disable)
+			clk->ops->disable(clk->hw);
+	}
 
 unlock_out:
 	spin_unlock_irqrestore(&enable_lock, flags);

commit 1f61e5f143b578606389887887af549bc5554353
Author: Martin Fuzzey <mfuzzey@parkeon.com>
Date:   Thu Nov 22 20:15:05 2012 +0100

    clk: clock multiplexers may register out of order
    
    When a clock, C is initialised any orphan clocks listing C as
    a possible parent are reparented to it regardless of the
    parent requested by the orphan's get_parent() operation.
    
    This means that multiplexers registered before their parents
    are reparented to the first parent subsequently declared,
    regardless of the selection made by the hardware registers.
    
    For example:
            static const char *sel[] = { "srcA", "srcB", "dummy", "srcC" };
    
            child = clk_register_mux(NULL, "child",  sel, ARRAY_SIZE(sel), ...);
            clk_register_fixed(NULL, "dummy", ...);
            clk_register_fixed(NULL, "srcA", ...);
            clk_register_fixed(NULL, "srcB", ...);
            clk_register_fixed(NULL, "srcC", ...);
    
    Causes child's parent to always be "dummy".
    
    To fix this, when an orphanned clock has a get_parent() operation,
    only reparent to the clock indicated by get_parent().
    
    Signed-off-by: Martin Fuzzey <mfuzzey@parkeon.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: improve $SUBJECT]

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2fd28ddd06c9..9955ad7e786e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1298,12 +1298,20 @@ int __clk_init(struct device *dev, struct clk *clk)
 	 * walk the list of orphan clocks and reparent any that are children of
 	 * this clock
 	 */
-	hlist_for_each_entry_safe(orphan, tmp, tmp2, &clk_orphan_list, child_node)
+	hlist_for_each_entry_safe(orphan, tmp, tmp2, &clk_orphan_list, child_node) {
+		if (orphan->ops->get_parent) {
+			i = orphan->ops->get_parent(orphan->hw);
+			if (!strcmp(clk->name, orphan->parent_names[i]))
+				__clk_reparent(orphan, clk);
+			continue;
+		}
+
 		for (i = 0; i < orphan->num_parents; i++)
 			if (!strcmp(clk->name, orphan->parent_names[i])) {
 				__clk_reparent(orphan, clk);
 				break;
 			}
+	 }
 
 	/*
 	 * optional platform-specific magic

commit 46c8773a58010d31f228e148b8b774d94cc9810d
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Sep 24 13:38:04 2012 -0700

    clk: Add devm_clk_{register,unregister}()
    
    Some clock drivers can be simplified if devres takes care of
    unregistering any registered clocks along error paths. Introduce
    devm_clk_register() so that clock drivers get unregistration for
    free along with simplified error paths.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index bbe52c4ae7ca..2fd28ddd06c9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -17,6 +17,7 @@
 #include <linux/list.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/device.h>
 
 static DEFINE_SPINLOCK(enable_lock);
 static DEFINE_MUTEX(prepare_lock);
@@ -1361,28 +1362,9 @@ struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(__clk_register);
 
-/**
- * clk_register - allocate a new clock, register it and return an opaque cookie
- * @dev: device that is registering this clock
- * @hw: link to hardware-specific clock data
- *
- * clk_register is the primary interface for populating the clock tree with new
- * clock nodes.  It returns a pointer to the newly allocated struct clk which
- * cannot be dereferenced by driver code but may be used in conjuction with the
- * rest of the clock API.  In the event of an error clk_register will return an
- * error code; drivers must test for an error code after calling clk_register.
- */
-struct clk *clk_register(struct device *dev, struct clk_hw *hw)
+static int _clk_register(struct device *dev, struct clk_hw *hw, struct clk *clk)
 {
 	int i, ret;
-	struct clk *clk;
-
-	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
-	if (!clk) {
-		pr_err("%s: could not allocate clk\n", __func__);
-		ret = -ENOMEM;
-		goto fail_out;
-	}
 
 	clk->name = kstrdup(hw->init->name, GFP_KERNEL);
 	if (!clk->name) {
@@ -1420,7 +1402,7 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 
 	ret = __clk_init(dev, clk);
 	if (!ret)
-		return clk;
+		return 0;
 
 fail_parent_names_copy:
 	while (--i >= 0)
@@ -1429,6 +1411,36 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 fail_parent_names:
 	kfree(clk->name);
 fail_name:
+	return ret;
+}
+
+/**
+ * clk_register - allocate a new clock, register it and return an opaque cookie
+ * @dev: device that is registering this clock
+ * @hw: link to hardware-specific clock data
+ *
+ * clk_register is the primary interface for populating the clock tree with new
+ * clock nodes.  It returns a pointer to the newly allocated struct clk which
+ * cannot be dereferenced by driver code but may be used in conjuction with the
+ * rest of the clock API.  In the event of an error clk_register will return an
+ * error code; drivers must test for an error code after calling clk_register.
+ */
+struct clk *clk_register(struct device *dev, struct clk_hw *hw)
+{
+	int ret;
+	struct clk *clk;
+
+	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk) {
+		pr_err("%s: could not allocate clk\n", __func__);
+		ret = -ENOMEM;
+		goto fail_out;
+	}
+
+	ret = _clk_register(dev, hw, clk);
+	if (!ret)
+		return clk;
+
 	kfree(clk);
 fail_out:
 	return ERR_PTR(ret);
@@ -1444,6 +1456,63 @@ EXPORT_SYMBOL_GPL(clk_register);
 void clk_unregister(struct clk *clk) {}
 EXPORT_SYMBOL_GPL(clk_unregister);
 
+static void devm_clk_release(struct device *dev, void *res)
+{
+	clk_unregister(res);
+}
+
+/**
+ * devm_clk_register - resource managed clk_register()
+ * @dev: device that is registering this clock
+ * @hw: link to hardware-specific clock data
+ *
+ * Managed clk_register(). Clocks returned from this function are
+ * automatically clk_unregister()ed on driver detach. See clk_register() for
+ * more information.
+ */
+struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw)
+{
+	struct clk *clk;
+	int ret;
+
+	clk = devres_alloc(devm_clk_release, sizeof(*clk), GFP_KERNEL);
+	if (!clk)
+		return ERR_PTR(-ENOMEM);
+
+	ret = _clk_register(dev, hw, clk);
+	if (!ret) {
+		devres_add(dev, clk);
+	} else {
+		devres_free(clk);
+		clk = ERR_PTR(ret);
+	}
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(devm_clk_register);
+
+static int devm_clk_match(struct device *dev, void *res, void *data)
+{
+	struct clk *c = res;
+	if (WARN_ON(!c))
+		return 0;
+	return c == data;
+}
+
+/**
+ * devm_clk_unregister - resource managed clk_unregister()
+ * @clk: clock to unregister
+ *
+ * Deallocate a clock allocated with devm_clk_register(). Normally
+ * this function will not need to be called and the resource management
+ * code will ensure that the resource is freed.
+ */
+void devm_clk_unregister(struct device *dev, struct clk *clk)
+{
+	WARN_ON(devres_release(dev, devm_clk_release, devm_clk_match, clk));
+}
+EXPORT_SYMBOL_GPL(devm_clk_unregister);
+
 /***        clk rate change notifiers        ***/
 
 /**

commit 2ac6b1f50a397580b8dc28f2833e54af7926fc71
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Oct 3 23:38:55 2012 -0700

    clk: Don't return negative numbers for unsigned values with !clk
    
    Some of the helper functions return negative error codes if
    passed a NULL clock. This can lead to confusing behavior when the
    expected return value is unsigned. Fix up these accessors so that
    they return unsigned values (or bool in the case of is_enabled).
    This way we can't interpret NULL clocks as having valid and
    interesting values.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 56e4495ebeb1..bbe52c4ae7ca 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -261,7 +261,7 @@ inline struct clk_hw *__clk_get_hw(struct clk *clk)
 
 inline u8 __clk_get_num_parents(struct clk *clk)
 {
-	return !clk ? -EINVAL : clk->num_parents;
+	return !clk ? 0 : clk->num_parents;
 }
 
 inline struct clk *__clk_get_parent(struct clk *clk)
@@ -269,14 +269,14 @@ inline struct clk *__clk_get_parent(struct clk *clk)
 	return !clk ? NULL : clk->parent;
 }
 
-inline int __clk_get_enable_count(struct clk *clk)
+inline unsigned int __clk_get_enable_count(struct clk *clk)
 {
-	return !clk ? -EINVAL : clk->enable_count;
+	return !clk ? 0 : clk->enable_count;
 }
 
-inline int __clk_get_prepare_count(struct clk *clk)
+inline unsigned int __clk_get_prepare_count(struct clk *clk)
 {
-	return !clk ? -EINVAL : clk->prepare_count;
+	return !clk ? 0 : clk->prepare_count;
 }
 
 unsigned long __clk_get_rate(struct clk *clk)
@@ -302,15 +302,15 @@ unsigned long __clk_get_rate(struct clk *clk)
 
 inline unsigned long __clk_get_flags(struct clk *clk)
 {
-	return !clk ? -EINVAL : clk->flags;
+	return !clk ? 0 : clk->flags;
 }
 
-int __clk_is_enabled(struct clk *clk)
+bool __clk_is_enabled(struct clk *clk)
 {
 	int ret;
 
 	if (!clk)
-		return -EINVAL;
+		return false;
 
 	/*
 	 * .is_enabled is only mandatory for clocks that gate
@@ -323,7 +323,7 @@ int __clk_is_enabled(struct clk *clk)
 
 	ret = clk->ops->is_enabled(clk->hw);
 out:
-	return ret;
+	return !!ret;
 }
 
 static struct clk *__clk_lookup_subtree(const char *name, struct clk *clk)
@@ -568,7 +568,7 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 	unsigned long parent_rate = 0;
 
 	if (!clk)
-		return -EINVAL;
+		return 0;
 
 	if (!clk->ops->round_rate) {
 		if (clk->flags & CLK_SET_RATE_PARENT)

commit 494bfec99922d54054d2d0873f1017680cfc3f13
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Aug 22 21:36:27 2012 +0800

    clk: add of_clk_src_onecell_get() support
    
    For those SoCs that have hundreds of clock outputs, their clock
    DT bindings could reasonably define #clock-cells as 1 and require
    the client device specify the index of the clock it consumes in the
    cell of its "clocks" phandle.
    
    Add a generic of_clk_src_onecell_get() function for this purpose.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Reviewed-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d9cbae06549f..56e4495ebeb1 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1587,6 +1587,20 @@ struct clk *of_clk_src_simple_get(struct of_phandle_args *clkspec,
 }
 EXPORT_SYMBOL_GPL(of_clk_src_simple_get);
 
+struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data)
+{
+	struct clk_onecell_data *clk_data = data;
+	unsigned int idx = clkspec->args[0];
+
+	if (idx >= clk_data->clk_num) {
+		pr_err("%s: invalid clock index %d\n", __func__, idx);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return clk_data->clks[idx];
+}
+EXPORT_SYMBOL_GPL(of_clk_src_onecell_get);
+
 /**
  * of_clk_add_provider() - Register a clock provider for a node
  * @np: Device node pointer associated with clock provider

commit a093bde2b45a0a745f12c018e2d13c027d58641f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Aug 31 14:21:28 2012 +0200

    clk: Provide option for clk_get_rate to issue hw for new rate
    
    By using CLK_GET_RATE_NOCACHE flag, we tell the clk_get_rate API to
    issue the hw for an updated clock rate. This can be used for a clock
    which rate may be updated without a client necessary modifying it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index efdfd009c270..d9cbae06549f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -557,25 +557,6 @@ int clk_enable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_enable);
 
-/**
- * clk_get_rate - return the rate of clk
- * @clk: the clk whose rate is being returned
- *
- * Simply returns the cached rate of the clk.  Does not query the hardware.  If
- * clk is NULL then returns 0.
- */
-unsigned long clk_get_rate(struct clk *clk)
-{
-	unsigned long rate;
-
-	mutex_lock(&prepare_lock);
-	rate = __clk_get_rate(clk);
-	mutex_unlock(&prepare_lock);
-
-	return rate;
-}
-EXPORT_SYMBOL_GPL(clk_get_rate);
-
 /**
  * __clk_round_rate - round the given rate for a clk
  * @clk: round the rate of this clock
@@ -701,6 +682,30 @@ static void __clk_recalc_rates(struct clk *clk, unsigned long msg)
 		__clk_recalc_rates(child, msg);
 }
 
+/**
+ * clk_get_rate - return the rate of clk
+ * @clk: the clk whose rate is being returned
+ *
+ * Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag
+ * is set, which means a recalc_rate will be issued.
+ * If clk is NULL then returns 0.
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long rate;
+
+	mutex_lock(&prepare_lock);
+
+	if (clk && (clk->flags & CLK_GET_RATE_NOCACHE))
+		__clk_recalc_rates(clk, 0);
+
+	rate = __clk_get_rate(clk);
+	mutex_unlock(&prepare_lock);
+
+	return rate;
+}
+EXPORT_SYMBOL_GPL(clk_get_rate);
+
 /**
  * __clk_speculate_rates
  * @clk: first clk in the subtree

commit e47c6a3408ea6bcfc5204f23d5a5b209de6e68b9
Author: Fengguang Wu <fengguang.wu@intel.com>
Date:   Mon Jul 30 14:39:54 2012 -0700

    clk: validate pointer in __clk_disable()
    
    clk_get() returns -ENOENT on error and some careless caller might
    dereference it without error checking:
    
    In mxc_rnga_remove():
    
            struct clk *clk = clk_get(&pdev->dev, "rng");
    
            // ...
    
            clk_disable(clk);
    
    Since it's insane to audit the lots of existing and future clk users,
    let's add a check in the callee to avoid kernel panic and warn about
    any buggy user.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Viresh Kumar <viresh.kumar@st.com>
    Cc: viresh kumar <viresh.linux@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c87fdd710560..efdfd009c270 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -465,6 +465,9 @@ static void __clk_disable(struct clk *clk)
 	if (!clk)
 		return;
 
+	if (WARN_ON(IS_ERR(clk)))
+		return;
+
 	if (WARN_ON(clk->enable_count == 0))
 		return;
 

commit 766e6a4ec602d0c107553b91b3434fe9c03474f4
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Apr 9 14:50:06 2012 -0500

    clk: add DT clock binding support
    
    Based on work 1st by Ben Herrenschmidt and Jeremy Kerr, then by Grant
    Likely, this patch adds support to clk_get to allow drivers to retrieve
    clock data from the device tree.
    
    Platforms scan for clocks in DT with of_clk_init and a match table, and
    the register a provider through of_clk_add_provider. The provider's
    clk_src_get function will be called when a device references the
    provider's OF node for a clock reference.
    
    v6 (Rob Herring):
        - Return error values instead of NULL to match clock framework
          expectations
    
    v5 (Rob Herring):
        - Move from drivers/of into common clock subsystem
        - Squashed "dt/clock: add a simple provider get function" and
          "dt/clock: add function to get parent clock name"
        - Rebase to 3.4-rc1
        - Drop CONFIG_OF_CLOCK and just use CONFIG_OF
        - Add missing EXPORT_SYMBOL to various functions
        - s/clock-output-name/clock-output-names/
        - Define that fixed-clock binding is a single output
    
    v4 (Rob Herring):
        - Rework for common clk subsystem
        - Add of_clk_get_parent_name function
    
    v3: - Clarified documentation
    
    v2: - fixed errant ';' causing compile error
        - Editorial fixes from Shawn Guo
        - merged in adding lookup to clkdev
        - changed property names to match established convention. After
          working with the binding a bit it really made more sense to follow the
          lead of 'reg', 'gpios' and 'interrupts' by making the input simply
          'clocks' & 'clock-names' instead of 'clock-input-*', and to only use
          clock-output* for the producer nodes. (Sorry Shawn, this will mean
          you need to change some code, but it should be trivial)
        - Add ability to inherit clocks from parent nodes by using an empty
          'clock-ranges' property.  Useful for busses.  I could use some feedback
          on the new property name, 'clock-ranges' doesn't feel right to me.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Reviewed-by: Shawn Guo <shawn.guo@freescale.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 46317cbc088f..c87fdd710560 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -16,6 +16,7 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 static DEFINE_SPINLOCK(enable_lock);
 static DEFINE_MUTEX(prepare_lock);
@@ -1550,3 +1551,142 @@ int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_notifier_unregister);
+
+#ifdef CONFIG_OF
+/**
+ * struct of_clk_provider - Clock provider registration structure
+ * @link: Entry in global list of clock providers
+ * @node: Pointer to device tree node of clock provider
+ * @get: Get clock callback.  Returns NULL or a struct clk for the
+ *       given clock specifier
+ * @data: context pointer to be passed into @get callback
+ */
+struct of_clk_provider {
+	struct list_head link;
+
+	struct device_node *node;
+	struct clk *(*get)(struct of_phandle_args *clkspec, void *data);
+	void *data;
+};
+
+static LIST_HEAD(of_clk_providers);
+static DEFINE_MUTEX(of_clk_lock);
+
+struct clk *of_clk_src_simple_get(struct of_phandle_args *clkspec,
+				     void *data)
+{
+	return data;
+}
+EXPORT_SYMBOL_GPL(of_clk_src_simple_get);
+
+/**
+ * of_clk_add_provider() - Register a clock provider for a node
+ * @np: Device node pointer associated with clock provider
+ * @clk_src_get: callback for decoding clock
+ * @data: context pointer for @clk_src_get callback.
+ */
+int of_clk_add_provider(struct device_node *np,
+			struct clk *(*clk_src_get)(struct of_phandle_args *clkspec,
+						   void *data),
+			void *data)
+{
+	struct of_clk_provider *cp;
+
+	cp = kzalloc(sizeof(struct of_clk_provider), GFP_KERNEL);
+	if (!cp)
+		return -ENOMEM;
+
+	cp->node = of_node_get(np);
+	cp->data = data;
+	cp->get = clk_src_get;
+
+	mutex_lock(&of_clk_lock);
+	list_add(&cp->link, &of_clk_providers);
+	mutex_unlock(&of_clk_lock);
+	pr_debug("Added clock from %s\n", np->full_name);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_clk_add_provider);
+
+/**
+ * of_clk_del_provider() - Remove a previously registered clock provider
+ * @np: Device node pointer associated with clock provider
+ */
+void of_clk_del_provider(struct device_node *np)
+{
+	struct of_clk_provider *cp;
+
+	mutex_lock(&of_clk_lock);
+	list_for_each_entry(cp, &of_clk_providers, link) {
+		if (cp->node == np) {
+			list_del(&cp->link);
+			of_node_put(cp->node);
+			kfree(cp);
+			break;
+		}
+	}
+	mutex_unlock(&of_clk_lock);
+}
+EXPORT_SYMBOL_GPL(of_clk_del_provider);
+
+struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
+{
+	struct of_clk_provider *provider;
+	struct clk *clk = ERR_PTR(-ENOENT);
+
+	/* Check if we have such a provider in our array */
+	mutex_lock(&of_clk_lock);
+	list_for_each_entry(provider, &of_clk_providers, link) {
+		if (provider->node == clkspec->np)
+			clk = provider->get(clkspec, provider->data);
+		if (!IS_ERR(clk))
+			break;
+	}
+	mutex_unlock(&of_clk_lock);
+
+	return clk;
+}
+
+const char *of_clk_get_parent_name(struct device_node *np, int index)
+{
+	struct of_phandle_args clkspec;
+	const char *clk_name;
+	int rc;
+
+	if (index < 0)
+		return NULL;
+
+	rc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", index,
+					&clkspec);
+	if (rc)
+		return NULL;
+
+	if (of_property_read_string_index(clkspec.np, "clock-output-names",
+					  clkspec.args_count ? clkspec.args[0] : 0,
+					  &clk_name) < 0)
+		clk_name = clkspec.np->name;
+
+	of_node_put(clkspec.np);
+	return clk_name;
+}
+EXPORT_SYMBOL_GPL(of_clk_get_parent_name);
+
+/**
+ * of_clk_init() - Scan and init clock providers from the DT
+ * @matches: array of compatible values and init functions for providers.
+ *
+ * This function scans the device tree for matching clock providers and
+ * calls their initialization functions
+ */
+void __init of_clk_init(const struct of_device_id *matches)
+{
+	struct device_node *np;
+
+	for_each_matching_node(np, matches) {
+		const struct of_device_id *match = of_match_node(matches, np);
+		of_clk_init_cb_t clk_init_cb = match->data;
+		clk_init_cb(np);
+	}
+}
+#endif

commit 9ca1c5a4bf4105d6f2f2a46892495953dd3e2fec
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Jun 6 14:41:30 2012 +0530

    clk: cache parent clocks only for muxes
    
    caching parent clocks makes sense only when a clock has more
    than one parent (mux clocks).
    Avoid doing this for every other clock.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [mturquette@linaro.org: removed extra parentheses]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9a1eb0cfa95f..46317cbc088f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1235,8 +1235,8 @@ int __clk_init(struct device *dev, struct clk *clk)
 	 * If clk->parents is not NULL we skip this entire block.  This allows
 	 * for clock drivers to statically initialize clk->parents.
 	 */
-	if (clk->num_parents && !clk->parents) {
-		clk->parents = kmalloc((sizeof(struct clk*) * clk->num_parents),
+	if (clk->num_parents > 1 && !clk->parents) {
+		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
 				GFP_KERNEL);
 		/*
 		 * __clk_lookup returns NULL for parents that have not been

commit 863b13271f1608ab3af6f7a371047d9a66693e38
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Jul 3 12:11:41 2012 +0530

    clk: fix parent validation in __clk_set_parent()
    
    The below commit introduced a bug in __clk_set_parent()
    which could cause it to *skip* the parent validation
    which makes sure the parent passed to the api is a valid
    one.
    
        commit 7975059db572eb47f0fb272a62afeae272a4b209
        Author: Rajendra Nayak <rnayak@ti.com>
        Date:   Wed Jun 6 14:41:31 2012 +0530
    
            clk: Allow late cache allocation for clk->parents
    
    This was identified by the following compiler warning..
    
        drivers/clk/clk.c: In function '__clk_set_parent':
        drivers/clk/clk.c:1083:5: warning: 'i' may be used uninitialized in this function [-Wuninitialized]
    
    .. as reported by Marc Kleine-Budde.
    
    There were various options discussed on how to fix this, one
    being initing 'i' to clk->num_parents, but the below approach
    was found to be more appropriate as it also makes the 'parent
    validation' code simpler to read.
    
    Reported-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: stable@kernel.org

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index dcbe05616090..9a1eb0cfa95f 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1067,26 +1067,24 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 
 	old_parent = clk->parent;
 
-	/* find index of new parent clock using cached parent ptrs */
-	if (clk->parents)
-		for (i = 0; i < clk->num_parents; i++)
-			if (clk->parents[i] == parent)
-				break;
-	else
+	if (!clk->parents)
 		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
 								GFP_KERNEL);
 
 	/*
-	 * find index of new parent clock using string name comparison
-	 * also try to cache the parent to avoid future calls to __clk_lookup
+	 * find index of new parent clock using cached parent ptrs,
+	 * or if not yet cached, use string name comparison and cache
+	 * them now to avoid future calls to __clk_lookup.
 	 */
-	if (i == clk->num_parents)
-		for (i = 0; i < clk->num_parents; i++)
-			if (!strcmp(clk->parent_names[i], parent->name)) {
-				if (clk->parents)
-					clk->parents[i] = __clk_lookup(parent->name);
-				break;
-			}
+	for (i = 0; i < clk->num_parents; i++) {
+		if (clk->parents && clk->parents[i] == parent)
+			break;
+		else if (!strcmp(clk->parent_names[i], parent->name)) {
+			if (clk->parents)
+				clk->parents[i] = __clk_lookup(parent->name);
+			break;
+		}
+	}
 
 	if (i == clk->num_parents) {
 		pr_debug("%s: clock %s is not a possible parent of clock %s\n",

commit bf47b4fd8f9f81cd5ce40e1945c6334d088226d1
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Fri Jun 8 14:04:06 2012 +0100

    clk: Check parent for NULL in clk_change_rate
    
    clk_change_rate() is accessing parent's rate without checking
    if the parent exists at all. In case of root clocks this will
    cause NULL pointer dereference.
    
    This patch follows what clk_calc_new_rates() does in such
    situation.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: stable@kernel.org

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index df89cbfc1bd0..dcbe05616090 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -850,18 +850,21 @@ static void clk_change_rate(struct clk *clk)
 {
 	struct clk *child;
 	unsigned long old_rate;
+	unsigned long best_parent_rate = 0;
 	struct hlist_node *tmp;
 
 	old_rate = clk->rate;
 
+	if (clk->parent)
+		best_parent_rate = clk->parent->rate;
+
 	if (clk->ops->set_rate)
-		clk->ops->set_rate(clk->hw, clk->new_rate, clk->parent->rate);
+		clk->ops->set_rate(clk->hw, clk->new_rate, best_parent_rate);
 
 	if (clk->ops->recalc_rate)
-		clk->rate = clk->ops->recalc_rate(clk->hw,
-				clk->parent->rate);
+		clk->rate = clk->ops->recalc_rate(clk->hw, best_parent_rate);
 	else
-		clk->rate = clk->parent->rate;
+		clk->rate = best_parent_rate;
 
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);

commit 7975059db572eb47f0fb272a62afeae272a4b209
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Jun 6 14:41:31 2012 +0530

    clk: Allow late cache allocation for clk->parents
    
    Parent clocks for muxes are cached in clk->parents to
    avoid frequent lookups, however the cache allocation happens
    only during clock registeration and later clk_set_parent()
    assumes a cache space available and allocated.
    
    This is not entirely true for platforms which do early clock
    registerations wherein the cache allocation using kzalloc
    could fail during clock registeration.
    
    Allow cache allocation to happen later as part of clk_set_parent()
    to help such cases and avoid crashes assuming a cache being
    available.
    
    While here also replace existing kmalloc() with kzalloc()
    in the file.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: stable@kernel.org

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 687b00d67c8a..df89cbfc1bd0 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -999,7 +999,7 @@ static struct clk *__clk_init_parent(struct clk *clk)
 
 	if (!clk->parents)
 		clk->parents =
-			kmalloc((sizeof(struct clk*) * clk->num_parents),
+			kzalloc((sizeof(struct clk*) * clk->num_parents),
 					GFP_KERNEL);
 
 	if (!clk->parents)
@@ -1065,9 +1065,13 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 	old_parent = clk->parent;
 
 	/* find index of new parent clock using cached parent ptrs */
-	for (i = 0; i < clk->num_parents; i++)
-		if (clk->parents[i] == parent)
-			break;
+	if (clk->parents)
+		for (i = 0; i < clk->num_parents; i++)
+			if (clk->parents[i] == parent)
+				break;
+	else
+		clk->parents = kzalloc((sizeof(struct clk*) * clk->num_parents),
+								GFP_KERNEL);
 
 	/*
 	 * find index of new parent clock using string name comparison
@@ -1076,7 +1080,8 @@ static int __clk_set_parent(struct clk *clk, struct clk *parent)
 	if (i == clk->num_parents)
 		for (i = 0; i < clk->num_parents; i++)
 			if (!strcmp(clk->parent_names[i], parent->name)) {
-				clk->parents[i] = __clk_lookup(parent->name);
+				if (clk->parents)
+					clk->parents[i] = __clk_lookup(parent->name);
 				break;
 			}
 

commit 7e0fa1b5fa91d9aa456d102c273b2cf0f2e95d39
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Tue May 15 13:43:42 2012 -0700

    clk: Fix CLK_SET_RATE_GATE flag validation in clk_set_rate().
    
    The clk_set_rate() code shouldn't check the clock's enable count when
    validating CLK_SET_RATE_GATE flag since the enable count could change after
    the validation. Similar to clk_set_parent(), it should instead check the
    prepare count. The prepare count should go to zero only when the end user
    expects the clock to not be enabled in the future. Since the code already
    grabs the prepare count before validation, it's not possible for prepare
    count to change after validation and by association not possible for a well
    behaving end user to enable the clock while the set rate is in progress.
    
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    Reviewed-by: Richard Zhao <richard.zhao@freescale.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a7e5dd59e19d..687b00d67c8a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -903,7 +903,7 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	if (rate == clk->rate)
 		goto out;
 
-	if ((clk->flags & CLK_SET_RATE_GATE) && __clk_is_enabled(clk)) {
+	if ((clk->flags & CLK_SET_RATE_GATE) && clk->prepare_count) {
 		ret = -EBUSY;
 		goto out;
 	}

commit 1df5c939f6d9dff7dfbe108d93133b9636baa607
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 18 09:07:12 2012 +0100

    clk: Provide dummy clk_unregister()
    
    While there's no actual implementation behind it having the call to use
    in drivers makes them feel neater from a driver author point of view. An
    actual implementation can wait for someone who needs to use the function
    in a real system.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    [mturquette@linaro.org: void return type instead of int -EINVAL]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index e5d5dc13bcfd..a7e5dd59e19d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1420,6 +1420,15 @@ struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 }
 EXPORT_SYMBOL_GPL(clk_register);
 
+/**
+ * clk_unregister - unregister a currently registered clock
+ * @clk: clock to unregister
+ *
+ * Currently unimplemented.
+ */
+void clk_unregister(struct clk *clk) {}
+EXPORT_SYMBOL_GPL(clk_unregister);
+
 /***        clk rate change notifiers        ***/
 
 /**

commit d269b974e32c5dcf043acd07f9ad96e715019ffd
Author: Mike Turquette <mturquette@linaro.org>
Date:   Wed May 2 15:45:32 2012 -0700

    clk: remove COMMON_CLK_DISABLE_UNUSED
    
    Exposing this option generates confusion and incorrect behavior for
    single-image builds across platforms.  Enable this behavior permanently.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Acked-by: Saravana Kannan <skannan@codeaurora.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 7ceca0e8645a..e5d5dc13bcfd 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -196,7 +196,6 @@ late_initcall(clk_debug_init);
 static inline int clk_debug_register(struct clk *clk) { return 0; }
 #endif
 
-#ifdef CONFIG_COMMON_CLK_DISABLE_UNUSED
 /* caller must hold prepare_lock */
 static void clk_disable_unused_subtree(struct clk *clk)
 {
@@ -246,7 +245,6 @@ static int clk_disable_unused(void)
 	return 0;
 }
 late_initcall(clk_disable_unused);
-#endif
 
 /***    helper functions   ***/
 

commit 63f5c3b2b18dcaca0fc8983b52a3f5d4d70a0590
Author: Mike Turquette <mturquette@linaro.org>
Date:   Wed May 2 16:23:43 2012 -0700

    clk: prevent spurious parent rate propagation
    
    Patch 'clk: always pass parent_rate into .round_rate' made a subtle
    change to the semantics of .round_rate.  It is now expected for the
    parent's rate to always be passed in, simplifying the implemenation of
    various .round_rate callback definitions.
    
    However the patch also introduced a bug in clk_calc_new_rates whereby a
    clock without the CLK_SET_RATE_PARENT flag set could still propagate a
    rate change up to a parent clock if the the .round_rate callback
    modified the &best_parent_rate value in any way.
    
    This patch fixes the issue at the framework level (in
    clk_calc_new_rates) by specifically handling the case where the
    CLK_SET_RATE_PARENT flag is not set.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8149764f8438..7ceca0e8645a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -774,12 +774,18 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 	if (IS_ERR_OR_NULL(clk))
 		return NULL;
 
+	/* save parent rate, if it exists */
+	if (clk->parent)
+		best_parent_rate = clk->parent->rate;
+
 	/* never propagate up to the parent */
 	if (!(clk->flags & CLK_SET_RATE_PARENT)) {
 		if (!clk->ops->round_rate) {
 			clk->new_rate = clk->rate;
 			return NULL;
 		}
+		new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
+		goto out;
 	}
 
 	/* need clk->parent from here on out */
@@ -795,7 +801,6 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 		goto out;
 	}
 
-	best_parent_rate = clk->parent->rate;
 	new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
 
 	if (best_parent_rate != clk->parent->rate) {

commit 0e1c03017549a9df513622b3f15ff38eb8d35a62
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Wed Apr 11 16:03:42 2012 +0530

    clk: clk_set_rate() must fail if CLK_SET_RATE_GATE is set and clk is enabled
    
    This is well documented but isn't implemented. clk_set_rate() must check if
    flags have CLK_SET_RATE_GATE bit set and is enabled too.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c81803b9ba35..8149764f8438 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -900,6 +900,11 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	if (rate == clk->rate)
 		goto out;
 
+	if ((clk->flags & CLK_SET_RATE_GATE) && __clk_is_enabled(clk)) {
+		ret = -EBUSY;
+		goto out;
+	}
+
 	/* calculate new rates and get the topmost changed clock */
 	top = clk_calc_new_rates(clk, rate);
 	if (!top) {

commit 0197b3ea0f66cd2a11417f58fe1812858ea77908
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Wed Apr 25 22:58:56 2012 -0700

    clk: Use a separate struct for holding init data.
    
    Create a struct clk_init_data to hold all data that needs to be passed from
    the platfrom specific driver to the common clock framework during clock
    registration. Add a pointer to this struct inside clk_hw.
    
    This has several advantages:
    * Completely hides struct clk from many clock platform drivers and static
      clock initialization code that don't care for static initialization of
      the struct clks.
    * For platforms that want to do complete static initialization, it removed
      the need to directly mess with the struct clk's fields while still
      allowing to statically allocate struct clk. This keeps the code more
      future proof even if they include clk-private.h.
    * Simplifies the generic clk_register() function and allows adding optional
      fields in the future without modifying the function signature.
    * Simplifies the static initialization of clocks on all platforms by
      removing the need for forward delcarations or convoluted macros.
    
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    [mturquette@linaro.org: kept DEFINE_CLK_* macros and __clk_init]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Jeremy Kerr <jeremy.kerr@canonical.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergman <arnd.bergmann@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Shawn Guo <shawn.guo@freescale.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jamie Iles <jamie@jamieiles.com>
    Cc: Richard Zhao <richard.zhao@linaro.org>
    Cc: Saravana Kannan <skannan@codeaurora.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Amit Kucheria <amit.kucheria@linaro.org>
    Cc: Deepak Saxena <dsaxena@linaro.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2dd20c01134d..c81803b9ba35 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1169,26 +1169,6 @@ EXPORT_SYMBOL_GPL(clk_set_parent);
  *
  * Initializes the lists in struct clk, queries the hardware for the
  * parent and rate and sets them both.
- *
- * Any struct clk passed into __clk_init must have the following members
- * populated:
- * 	.name
- * 	.ops
- * 	.hw
- * 	.parent_names
- * 	.num_parents
- * 	.flags
- *
- * Essentially, everything that would normally be passed into clk_register is
- * assumed to be initialized already in __clk_init.  The other members may be
- * populated, but are optional.
- *
- * __clk_init is only exposed via clk-private.h and is intended for use with
- * very large numbers of clocks that need to be statically initialized.  It is
- * a layering violation to include clk-private.h from any code which implements
- * a clock's .ops; as such any statically initialized clock data MUST be in a
- * separate C file from the logic that implements it's operations.  Returns 0
- * on success, otherwise an error code.
  */
 int __clk_init(struct device *dev, struct clk *clk)
 {
@@ -1320,15 +1300,48 @@ int __clk_init(struct device *dev, struct clk *clk)
 	return ret;
 }
 
+/**
+ * __clk_register - register a clock and return a cookie.
+ *
+ * Same as clk_register, except that the .clk field inside hw shall point to a
+ * preallocated (generally statically allocated) struct clk. None of the fields
+ * of the struct clk need to be initialized.
+ *
+ * The data pointed to by .init and .clk field shall NOT be marked as init
+ * data.
+ *
+ * __clk_register is only exposed via clk-private.h and is intended for use with
+ * very large numbers of clocks that need to be statically initialized.  It is
+ * a layering violation to include clk-private.h from any code which implements
+ * a clock's .ops; as such any statically initialized clock data MUST be in a
+ * separate C file from the logic that implements it's operations.  Returns 0
+ * on success, otherwise an error code.
+ */
+struct clk *__clk_register(struct device *dev, struct clk_hw *hw)
+{
+	int ret;
+	struct clk *clk;
+
+	clk = hw->clk;
+	clk->name = hw->init->name;
+	clk->ops = hw->init->ops;
+	clk->hw = hw;
+	clk->flags = hw->init->flags;
+	clk->parent_names = hw->init->parent_names;
+	clk->num_parents = hw->init->num_parents;
+
+	ret = __clk_init(dev, clk);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(__clk_register);
+
 /**
  * clk_register - allocate a new clock, register it and return an opaque cookie
  * @dev: device that is registering this clock
- * @name: clock name
- * @ops: operations this clock supports
  * @hw: link to hardware-specific clock data
- * @parent_names: array of string names for all possible parents
- * @num_parents: number of possible parents
- * @flags: framework-level hints and quirks
  *
  * clk_register is the primary interface for populating the clock tree with new
  * clock nodes.  It returns a pointer to the newly allocated struct clk which
@@ -1336,9 +1349,7 @@ int __clk_init(struct device *dev, struct clk *clk)
  * rest of the clock API.  In the event of an error clk_register will return an
  * error code; drivers must test for an error code after calling clk_register.
  */
-struct clk *clk_register(struct device *dev, const char *name,
-		const struct clk_ops *ops, struct clk_hw *hw,
-		const char **parent_names, u8 num_parents, unsigned long flags)
+struct clk *clk_register(struct device *dev, struct clk_hw *hw)
 {
 	int i, ret;
 	struct clk *clk;
@@ -1350,15 +1361,20 @@ struct clk *clk_register(struct device *dev, const char *name,
 		goto fail_out;
 	}
 
-	clk->name = name;
-	clk->ops = ops;
+	clk->name = kstrdup(hw->init->name, GFP_KERNEL);
+	if (!clk->name) {
+		pr_err("%s: could not allocate clk->name\n", __func__);
+		ret = -ENOMEM;
+		goto fail_name;
+	}
+	clk->ops = hw->init->ops;
 	clk->hw = hw;
-	clk->flags = flags;
-	clk->num_parents = num_parents;
+	clk->flags = hw->init->flags;
+	clk->num_parents = hw->init->num_parents;
 	hw->clk = clk;
 
 	/* allocate local copy in case parent_names is __initdata */
-	clk->parent_names = kzalloc((sizeof(char*) * num_parents),
+	clk->parent_names = kzalloc((sizeof(char*) * clk->num_parents),
 			GFP_KERNEL);
 
 	if (!clk->parent_names) {
@@ -1369,8 +1385,9 @@ struct clk *clk_register(struct device *dev, const char *name,
 
 
 	/* copy each string name in case parent_names is __initdata */
-	for (i = 0; i < num_parents; i++) {
-		clk->parent_names[i] = kstrdup(parent_names[i], GFP_KERNEL);
+	for (i = 0; i < clk->num_parents; i++) {
+		clk->parent_names[i] = kstrdup(hw->init->parent_names[i],
+						GFP_KERNEL);
 		if (!clk->parent_names[i]) {
 			pr_err("%s: could not copy parent_names\n", __func__);
 			ret = -ENOMEM;
@@ -1387,6 +1404,8 @@ struct clk *clk_register(struct device *dev, const char *name,
 		kfree(clk->parent_names[i]);
 	kfree(clk->parent_names);
 fail_parent_names:
+	kfree(clk->name);
+fail_name:
 	kfree(clk);
 fail_out:
 	return ERR_PTR(ret);

commit 1b2f99037a29d48d03ddd2fd0dc117888ec737f4
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Tue Apr 17 16:45:38 2012 +0530

    clk: Don't set clk->new_rate twice
    
    if (!clk->ops->round_rate && (clk->flags & CLK_SET_RATE_PARENT)) is true, then
    we don't need to set clk->new_rate here, as we will call clk_calc_subtree()
    afterwards and it also sets clk->new_rate.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index c6e8866289b4..2dd20c01134d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -790,7 +790,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 
 	if (!clk->ops->round_rate) {
 		top = clk_calc_new_rates(clk->parent, rate);
-		new_rate = clk->new_rate = clk->parent->new_rate;
+		new_rate = clk->parent->new_rate;
 
 		goto out;
 	}

commit f4d8af2e5ae6294d5e2220d3963def6f7ffc0873
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Apr 12 20:50:19 2012 +0800

    clk: propagate round_rate for CLK_SET_RATE_PARENT case
    
    Need to propagate round_rate call for the clk that has no .round_rate
    operation but with flag CLK_SET_RATE_PARENT set.
    
    For example, clk_mux is a clk with no .round_rate operation.  However,
    it could likely be in a clk_set_rate propagation path, saying it has
    parent clk who has .round_rate and .set_rate operations.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 62ecac53b0a2..c6e8866289b4 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -587,8 +587,12 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 	if (!clk)
 		return -EINVAL;
 
-	if (!clk->ops->round_rate)
-		return clk->rate;
+	if (!clk->ops->round_rate) {
+		if (clk->flags & CLK_SET_RATE_PARENT)
+			return __clk_round_rate(clk->parent, rate);
+		else
+			return clk->rate;
+	}
 
 	if (clk->parent)
 		parent_rate = clk->parent->rate;

commit 1c0035d710dd3bfa86d58f851b8737c7f11a9bbc
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Apr 12 20:50:18 2012 +0800

    clk: pass parent_rate into .set_rate
    
    For most of .set_rate implementation, parent_rate will be used, so just
    like passing parent_rate into .recalc_rate, let's pass parent_rate into
    .set_rate too.
    
    It also updates the kernel doc for .set_rate ops.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 1ab4f7e5c7ef..62ecac53b0a2 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -848,7 +848,7 @@ static void clk_change_rate(struct clk *clk)
 	old_rate = clk->rate;
 
 	if (clk->ops->set_rate)
-		clk->ops->set_rate(clk->hw, clk->new_rate);
+		clk->ops->set_rate(clk->hw, clk->new_rate, clk->parent->rate);
 
 	if (clk->ops->recalc_rate)
 		clk->rate = clk->ops->recalc_rate(clk->hw,

commit 81536e072b54e30bbfd1a9a6b8094f7b3dd5321c
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Apr 12 20:50:17 2012 +0800

    clk: always pass parent_rate into .round_rate
    
    The parent_rate will likely be used by most .round_rate implementation
    no matter whether flag CLK_SET_RATE_PARENT is set or not, so let's
    always pass parent_rate into .round_rate.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 8f7c3849c8f6..1ab4f7e5c7ef 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -582,7 +582,7 @@ EXPORT_SYMBOL_GPL(clk_get_rate);
  */
 unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long unused;
+	unsigned long parent_rate = 0;
 
 	if (!clk)
 		return -EINVAL;
@@ -590,10 +590,10 @@ unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
 	if (!clk->ops->round_rate)
 		return clk->rate;
 
-	if (clk->flags & CLK_SET_RATE_PARENT)
-		return clk->ops->round_rate(clk->hw, rate, &unused);
-	else
-		return clk->ops->round_rate(clk->hw, rate, NULL);
+	if (clk->parent)
+		parent_rate = clk->parent->rate;
+
+	return clk->ops->round_rate(clk->hw, rate, &parent_rate);
 }
 
 /**
@@ -763,7 +763,7 @@ static void clk_calc_subtree(struct clk *clk, unsigned long new_rate)
 static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 {
 	struct clk *top = clk;
-	unsigned long best_parent_rate;
+	unsigned long best_parent_rate = 0;
 	unsigned long new_rate;
 
 	/* sanity */
@@ -775,9 +775,6 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 		if (!clk->ops->round_rate) {
 			clk->new_rate = clk->rate;
 			return NULL;
-		} else {
-			new_rate = clk->ops->round_rate(clk->hw, rate, NULL);
-			goto out;
 		}
 	}
 
@@ -794,6 +791,7 @@ static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 		goto out;
 	}
 
+	best_parent_rate = clk->parent->rate;
 	new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
 
 	if (best_parent_rate != clk->parent->rate) {

commit d1302a36a7f1c33d1a8babc6a510e1401a5e5aed
Author: Mike Turquette <mturquette@linaro.org>
Date:   Thu Mar 29 14:30:40 2012 -0700

    clk: core: copy parent_names & return error codes
    
    This patch cleans up clk_register and solves a few bugs by teaching
    clk_register and __clk_init to return error codes (instead of just NULL)
    to better align with the existing clk.h api.
    
    Along with that change this patch also introduces a new behavior whereby
    clk_register copies the parent_names array, thus allowing platforms to
    declare their parent_names arrays as __initdata.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index ddade8759ea9..8f7c3849c8f6 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1185,34 +1185,41 @@ EXPORT_SYMBOL_GPL(clk_set_parent);
  * very large numbers of clocks that need to be statically initialized.  It is
  * a layering violation to include clk-private.h from any code which implements
  * a clock's .ops; as such any statically initialized clock data MUST be in a
- * separate C file from the logic that implements it's operations.
+ * separate C file from the logic that implements it's operations.  Returns 0
+ * on success, otherwise an error code.
  */
-void __clk_init(struct device *dev, struct clk *clk)
+int __clk_init(struct device *dev, struct clk *clk)
 {
-	int i;
+	int i, ret = 0;
 	struct clk *orphan;
 	struct hlist_node *tmp, *tmp2;
 
 	if (!clk)
-		return;
+		return -EINVAL;
 
 	mutex_lock(&prepare_lock);
 
 	/* check to see if a clock with this name is already registered */
-	if (__clk_lookup(clk->name))
+	if (__clk_lookup(clk->name)) {
+		pr_debug("%s: clk %s already initialized\n",
+				__func__, clk->name);
+		ret = -EEXIST;
 		goto out;
+	}
 
 	/* check that clk_ops are sane.  See Documentation/clk.txt */
 	if (clk->ops->set_rate &&
 			!(clk->ops->round_rate && clk->ops->recalc_rate)) {
 		pr_warning("%s: %s must implement .round_rate & .recalc_rate\n",
 				__func__, clk->name);
+		ret = -EINVAL;
 		goto out;
 	}
 
 	if (clk->ops->set_parent && !clk->ops->get_parent) {
 		pr_warning("%s: %s must implement .get_parent & .set_parent\n",
 				__func__, clk->name);
+		ret = -EINVAL;
 		goto out;
 	}
 
@@ -1308,7 +1315,7 @@ void __clk_init(struct device *dev, struct clk *clk)
 out:
 	mutex_unlock(&prepare_lock);
 
-	return;
+	return ret;
 }
 
 /**
@@ -1324,29 +1331,63 @@ void __clk_init(struct device *dev, struct clk *clk)
  * clk_register is the primary interface for populating the clock tree with new
  * clock nodes.  It returns a pointer to the newly allocated struct clk which
  * cannot be dereferenced by driver code but may be used in conjuction with the
- * rest of the clock API.
+ * rest of the clock API.  In the event of an error clk_register will return an
+ * error code; drivers must test for an error code after calling clk_register.
  */
 struct clk *clk_register(struct device *dev, const char *name,
 		const struct clk_ops *ops, struct clk_hw *hw,
 		const char **parent_names, u8 num_parents, unsigned long flags)
 {
+	int i, ret;
 	struct clk *clk;
 
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
-	if (!clk)
-		return NULL;
+	if (!clk) {
+		pr_err("%s: could not allocate clk\n", __func__);
+		ret = -ENOMEM;
+		goto fail_out;
+	}
 
 	clk->name = name;
 	clk->ops = ops;
 	clk->hw = hw;
 	clk->flags = flags;
-	clk->parent_names = parent_names;
 	clk->num_parents = num_parents;
 	hw->clk = clk;
 
-	__clk_init(dev, clk);
+	/* allocate local copy in case parent_names is __initdata */
+	clk->parent_names = kzalloc((sizeof(char*) * num_parents),
+			GFP_KERNEL);
+
+	if (!clk->parent_names) {
+		pr_err("%s: could not allocate clk->parent_names\n", __func__);
+		ret = -ENOMEM;
+		goto fail_parent_names;
+	}
+
+
+	/* copy each string name in case parent_names is __initdata */
+	for (i = 0; i < num_parents; i++) {
+		clk->parent_names[i] = kstrdup(parent_names[i], GFP_KERNEL);
+		if (!clk->parent_names[i]) {
+			pr_err("%s: could not copy parent_names\n", __func__);
+			ret = -ENOMEM;
+			goto fail_parent_names_copy;
+		}
+	}
+
+	ret = __clk_init(dev, clk);
+	if (!ret)
+		return clk;
 
-	return clk;
+fail_parent_names_copy:
+	while (--i >= 0)
+		kfree(clk->parent_names[i]);
+	kfree(clk->parent_names);
+fail_parent_names:
+	kfree(clk);
+fail_out:
+	return ERR_PTR(ret);
 }
 EXPORT_SYMBOL_GPL(clk_register);
 

commit d305fb78f31209596c9135d396a0d3af7ac86947
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 21 20:01:20 2012 +0000

    clk: Constify parent name arrays
    
    Drivers should be able to declare their arrays of parent names as const
    so the APIs need to accept const arguments.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    [mturquette@linaro.org: constified gate]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index a24b121747ac..ddade8759ea9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1328,7 +1328,7 @@ void __clk_init(struct device *dev, struct clk *clk)
  */
 struct clk *clk_register(struct device *dev, const char *name,
 		const struct clk_ops *ops, struct clk_hw *hw,
-		char **parent_names, u8 num_parents, unsigned long flags)
+		const char **parent_names, u8 num_parents, unsigned long flags)
 {
 	struct clk *clk;
 

commit 34e44fe87437b6a5aad856f15f7a849e5fc137aa
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Mon Mar 26 19:01:48 2012 +0530

    clk: Make clk_get_rate() return 0 on error
    
    Most users of clk_get_rate() actually assume a non zero
    return value as a valid rate returned. Returing -EINVAL
    might confuse such users, so make it instead return zero
    on error.
    
    Besides the return value of clk_get_rate seems to be
    'unsigned long'.
    
    Signed-off-by: Rajendra nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9924aec17aad..a24b121747ac 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -285,7 +285,7 @@ unsigned long __clk_get_rate(struct clk *clk)
 	unsigned long ret;
 
 	if (!clk) {
-		ret = -EINVAL;
+		ret = 0;
 		goto out;
 	}
 
@@ -295,7 +295,7 @@ unsigned long __clk_get_rate(struct clk *clk)
 		goto out;
 
 	if (!clk->parent)
-		ret = -ENODEV;
+		ret = 0;
 
 out:
 	return ret;
@@ -560,7 +560,7 @@ EXPORT_SYMBOL_GPL(clk_enable);
  * @clk: the clk whose rate is being returned
  *
  * Simply returns the cached rate of the clk.  Does not query the hardware.  If
- * clk is NULL then returns -EINVAL.
+ * clk is NULL then returns 0.
  */
 unsigned long clk_get_rate(struct clk *clk)
 {

commit d4d7e3ddc76c5ae3b4fbd15cb6f30aa78c28d788
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Mar 26 16:15:52 2012 -0700

    clk: core: enforce clk_ops consistency
    
    Documentation/clk.txt has some handsome ASCII art outlining which
    clk_ops are mandatory for a given clock, given the capability of the
    hardware.  Enforce those mandates with sanity checks in __clk_init.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index d83a9e09e1bf..9924aec17aad 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1202,6 +1202,20 @@ void __clk_init(struct device *dev, struct clk *clk)
 	if (__clk_lookup(clk->name))
 		goto out;
 
+	/* check that clk_ops are sane.  See Documentation/clk.txt */
+	if (clk->ops->set_rate &&
+			!(clk->ops->round_rate && clk->ops->recalc_rate)) {
+		pr_warning("%s: %s must implement .round_rate & .recalc_rate\n",
+				__func__, clk->name);
+		goto out;
+	}
+
+	if (clk->ops->set_parent && !clk->ops->get_parent) {
+		pr_warning("%s: %s must implement .get_parent & .set_parent\n",
+				__func__, clk->name);
+		goto out;
+	}
+
 	/* throw a WARN if any entries in parent_names are NULL */
 	for (i = 0; i < clk->num_parents; i++)
 		WARN(!clk->parent_names[i],

commit 7452b2191cd55fb3fd6ad65344466ddcdbe4676e
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Mar 26 14:45:36 2012 -0700

    clk: core: clk_calc_new_rates handles NULL parents
    
    It is possible to call clk_set_rate on a clock with a NULL parent.  One
    such example is an adjustable-rate root clock.  Ensure that
    clk_calc_new_rates does not dereference parent without checking first
    and also handle the corner cases gracefully.
    
    Reported-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4daacf5783aa..d83a9e09e1bf 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -763,25 +763,38 @@ static void clk_calc_subtree(struct clk *clk, unsigned long new_rate)
 static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
 {
 	struct clk *top = clk;
-	unsigned long best_parent_rate = clk->parent->rate;
+	unsigned long best_parent_rate;
 	unsigned long new_rate;
 
-	if (!clk->ops->round_rate && !(clk->flags & CLK_SET_RATE_PARENT)) {
-		clk->new_rate = clk->rate;
+	/* sanity */
+	if (IS_ERR_OR_NULL(clk))
+		return NULL;
+
+	/* never propagate up to the parent */
+	if (!(clk->flags & CLK_SET_RATE_PARENT)) {
+		if (!clk->ops->round_rate) {
+			clk->new_rate = clk->rate;
+			return NULL;
+		} else {
+			new_rate = clk->ops->round_rate(clk->hw, rate, NULL);
+			goto out;
+		}
+	}
+
+	/* need clk->parent from here on out */
+	if (!clk->parent) {
+		pr_debug("%s: %s has NULL parent\n", __func__, clk->name);
 		return NULL;
 	}
 
-	if (!clk->ops->round_rate && (clk->flags & CLK_SET_RATE_PARENT)) {
+	if (!clk->ops->round_rate) {
 		top = clk_calc_new_rates(clk->parent, rate);
 		new_rate = clk->new_rate = clk->parent->new_rate;
 
 		goto out;
 	}
 
-	if (clk->flags & CLK_SET_RATE_PARENT)
-		new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
-	else
-		new_rate = clk->ops->round_rate(clk->hw, rate, NULL);
+	new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
 
 	if (best_parent_rate != clk->parent->rate) {
 		top = clk_calc_new_rates(clk->parent, best_parent_rate);

commit 70d347e6cd0d2a7ecc023b44ef721bc2c2a38f22
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Mar 26 11:53:47 2012 -0700

    clk: core: remove dead code paths
    
    Some static inline dummy functions were left over from before the clock
    core was consolidated from several C files down to one.  Remove them.
    
    Reported-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3ed36d3056de..4daacf5783aa 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -194,7 +194,7 @@ static int __init clk_debug_init(void)
 late_initcall(clk_debug_init);
 #else
 static inline int clk_debug_register(struct clk *clk) { return 0; }
-#endif /* CONFIG_COMMON_CLK_DEBUG */
+#endif
 
 #ifdef CONFIG_COMMON_CLK_DISABLE_UNUSED
 /* caller must hold prepare_lock */
@@ -246,9 +246,7 @@ static int clk_disable_unused(void)
 	return 0;
 }
 late_initcall(clk_disable_unused);
-#else
-static inline int clk_disable_unused(struct clk *clk) { return 0; }
-#endif /* CONFIG_COMMON_CLK_DISABLE_UNUSED */
+#endif
 
 /***    helper functions   ***/
 

commit 5654dc94f872f823aa13941a8fdba69a3feca39c
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Mar 26 11:51:34 2012 -0700

    clk: core: correct clk_set_rate kerneldoc
    
    Remove old and misleading documentation from the previous clk_set_rate
    implementaion.
    
    Reported-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9cf6f59e3e19..3ed36d3056de 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -859,38 +859,19 @@ static void clk_change_rate(struct clk *clk)
  * @clk: the clk whose rate is being changed
  * @rate: the new rate for clk
  *
- * In the simplest case clk_set_rate will only change the rate of clk.
+ * In the simplest case clk_set_rate will only adjust the rate of clk.
  *
- * If clk has the CLK_SET_RATE_GATE flag set and it is enabled this call
- * will fail; only when the clk is disabled will it be able to change
- * its rate.
+ * Setting the CLK_SET_RATE_PARENT flag allows the rate change operation to
+ * propagate up to clk's parent; whether or not this happens depends on the
+ * outcome of clk's .round_rate implementation.  If *parent_rate is unchanged
+ * after calling .round_rate then upstream parent propagation is ignored.  If
+ * *parent_rate comes back with a new rate for clk's parent then we propagate
+ * up to clk's parent and set it's rate.  Upward propagation will continue
+ * until either a clk does not support the CLK_SET_RATE_PARENT flag or
+ * .round_rate stops requesting changes to clk's parent_rate.
  *
- * Setting the CLK_SET_RATE_PARENT flag allows clk_set_rate to
- * recursively propagate up to clk's parent; whether or not this happens
- * depends on the outcome of clk's .round_rate implementation.  If
- * *parent_rate is 0 after calling .round_rate then upstream parent
- * propagation is ignored.  If *parent_rate comes back with a new rate
- * for clk's parent then we propagate up to clk's parent and set it's
- * rate.  Upward propagation will continue until either a clk does not
- * support the CLK_SET_RATE_PARENT flag or .round_rate stops requesting
- * changes to clk's parent_rate.  If there is a failure during upstream
- * propagation then clk_set_rate will unwind and restore each clk's rate
- * that had been successfully changed.  Afterwards a rate change abort
- * notification will be propagated downstream, starting from the clk
- * that failed.
- *
- * At the end of all of the rate setting, clk_set_rate internally calls
- * __clk_recalc_rates and propagates the rate changes downstream,
- * starting from the highest clk whose rate was changed.  This has the
- * added benefit of propagating post-rate change notifiers.
- *
- * Note that while post-rate change and rate change abort notifications
- * are guaranteed to be sent to a clk only once per call to
- * clk_set_rate, pre-change notifications will be sent for every clk
- * whose rate is changed.  Stacking pre-change notifications is noisy
- * for the drivers subscribed to them, but this allows drivers to react
- * to intermediate clk rate changes up until the point where the final
- * rate is achieved at the end of upstream propagation.
+ * Rate changes are accomplished via tree traversal that also recalculates the
+ * rates for the clocks and fires off POST_RATE_CHANGE notifiers.
  *
  * Returns 0 on success, -EERROR otherwise.
  */

commit b2476490ef11134b65544d8f062cff96c53e941b
Author: Mike Turquette <mturquette@linaro.org>
Date:   Thu Mar 15 23:11:19 2012 -0700

    clk: introduce the common clock framework
    
    The common clock framework defines a common struct clk useful across
    most platforms as well as an implementation of the clk api that drivers
    can use safely for managing clocks.
    
    The net result is consolidation of many different struct clk definitions
    and platform-specific clock framework implementations.
    
    This patch introduces the common struct clk, struct clk_ops and an
    implementation of the well-known clock api in include/clk/clk.h.
    Platforms may define their own hardware-specific clock structure and
    their own clock operation callbacks, so long as it wraps an instance of
    struct clk_hw.
    
    See Documentation/clk.txt for more details.
    
    This patch is based on the work of Jeremy Kerr, which in turn was based
    on the work of Ben Herrenschmidt.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@ti.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Rob Herring <rob.herring <at> calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Jeremy Kerr <jeremy.kerr@canonical.com>
    Cc: Arnd Bergman <arnd.bergmann@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Shawn Guo <shawn.guo@freescale.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Richard Zhao <richard.zhao@linaro.org>
    Cc: Saravana Kannan <skannan@codeaurora.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Amit Kucheria <amit.kucheria@linaro.org>
    Cc: Deepak Saxena <dsaxena@linaro.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
new file mode 100644
index 000000000000..9cf6f59e3e19
--- /dev/null
+++ b/drivers/clk/clk.c
@@ -0,0 +1,1461 @@
+/*
+ * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
+ * Copyright (C) 2011-2012 Linaro Ltd <mturquette@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Standard functionality for the common clock API.  See Documentation/clk.txt
+ */
+
+#include <linux/clk-private.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+
+static DEFINE_SPINLOCK(enable_lock);
+static DEFINE_MUTEX(prepare_lock);
+
+static HLIST_HEAD(clk_root_list);
+static HLIST_HEAD(clk_orphan_list);
+static LIST_HEAD(clk_notifier_list);
+
+/***        debugfs support        ***/
+
+#ifdef CONFIG_COMMON_CLK_DEBUG
+#include <linux/debugfs.h>
+
+static struct dentry *rootdir;
+static struct dentry *orphandir;
+static int inited = 0;
+
+/* caller must hold prepare_lock */
+static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
+{
+	struct dentry *d;
+	int ret = -ENOMEM;
+
+	if (!clk || !pdentry) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	d = debugfs_create_dir(clk->name, pdentry);
+	if (!d)
+		goto out;
+
+	clk->dentry = d;
+
+	d = debugfs_create_u32("clk_rate", S_IRUGO, clk->dentry,
+			(u32 *)&clk->rate);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_x32("clk_flags", S_IRUGO, clk->dentry,
+			(u32 *)&clk->flags);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_u32("clk_prepare_count", S_IRUGO, clk->dentry,
+			(u32 *)&clk->prepare_count);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_u32("clk_enable_count", S_IRUGO, clk->dentry,
+			(u32 *)&clk->enable_count);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_u32("clk_notifier_count", S_IRUGO, clk->dentry,
+			(u32 *)&clk->notifier_count);
+	if (!d)
+		goto err_out;
+
+	ret = 0;
+	goto out;
+
+err_out:
+	debugfs_remove(clk->dentry);
+out:
+	return ret;
+}
+
+/* caller must hold prepare_lock */
+static int clk_debug_create_subtree(struct clk *clk, struct dentry *pdentry)
+{
+	struct clk *child;
+	struct hlist_node *tmp;
+	int ret = -EINVAL;;
+
+	if (!clk || !pdentry)
+		goto out;
+
+	ret = clk_debug_create_one(clk, pdentry);
+
+	if (ret)
+		goto out;
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+		clk_debug_create_subtree(child, clk->dentry);
+
+	ret = 0;
+out:
+	return ret;
+}
+
+/**
+ * clk_debug_register - add a clk node to the debugfs clk tree
+ * @clk: the clk being added to the debugfs clk tree
+ *
+ * Dynamically adds a clk to the debugfs clk tree if debugfs has been
+ * initialized.  Otherwise it bails out early since the debugfs clk tree
+ * will be created lazily by clk_debug_init as part of a late_initcall.
+ *
+ * Caller must hold prepare_lock.  Only clk_init calls this function (so
+ * far) so this is taken care.
+ */
+static int clk_debug_register(struct clk *clk)
+{
+	struct clk *parent;
+	struct dentry *pdentry;
+	int ret = 0;
+
+	if (!inited)
+		goto out;
+
+	parent = clk->parent;
+
+	/*
+	 * Check to see if a clk is a root clk.  Also check that it is
+	 * safe to add this clk to debugfs
+	 */
+	if (!parent)
+		if (clk->flags & CLK_IS_ROOT)
+			pdentry = rootdir;
+		else
+			pdentry = orphandir;
+	else
+		if (parent->dentry)
+			pdentry = parent->dentry;
+		else
+			goto out;
+
+	ret = clk_debug_create_subtree(clk, pdentry);
+
+out:
+	return ret;
+}
+
+/**
+ * clk_debug_init - lazily create the debugfs clk tree visualization
+ *
+ * clks are often initialized very early during boot before memory can
+ * be dynamically allocated and well before debugfs is setup.
+ * clk_debug_init walks the clk tree hierarchy while holding
+ * prepare_lock and creates the topology as part of a late_initcall,
+ * thus insuring that clks initialized very early will still be
+ * represented in the debugfs clk tree.  This function should only be
+ * called once at boot-time, and all other clks added dynamically will
+ * be done so with clk_debug_register.
+ */
+static int __init clk_debug_init(void)
+{
+	struct clk *clk;
+	struct hlist_node *tmp;
+
+	rootdir = debugfs_create_dir("clk", NULL);
+
+	if (!rootdir)
+		return -ENOMEM;
+
+	orphandir = debugfs_create_dir("orphans", rootdir);
+
+	if (!orphandir)
+		return -ENOMEM;
+
+	mutex_lock(&prepare_lock);
+
+	hlist_for_each_entry(clk, tmp, &clk_root_list, child_node)
+		clk_debug_create_subtree(clk, rootdir);
+
+	hlist_for_each_entry(clk, tmp, &clk_orphan_list, child_node)
+		clk_debug_create_subtree(clk, orphandir);
+
+	inited = 1;
+
+	mutex_unlock(&prepare_lock);
+
+	return 0;
+}
+late_initcall(clk_debug_init);
+#else
+static inline int clk_debug_register(struct clk *clk) { return 0; }
+#endif /* CONFIG_COMMON_CLK_DEBUG */
+
+#ifdef CONFIG_COMMON_CLK_DISABLE_UNUSED
+/* caller must hold prepare_lock */
+static void clk_disable_unused_subtree(struct clk *clk)
+{
+	struct clk *child;
+	struct hlist_node *tmp;
+	unsigned long flags;
+
+	if (!clk)
+		goto out;
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+		clk_disable_unused_subtree(child);
+
+	spin_lock_irqsave(&enable_lock, flags);
+
+	if (clk->enable_count)
+		goto unlock_out;
+
+	if (clk->flags & CLK_IGNORE_UNUSED)
+		goto unlock_out;
+
+	if (__clk_is_enabled(clk) && clk->ops->disable)
+		clk->ops->disable(clk->hw);
+
+unlock_out:
+	spin_unlock_irqrestore(&enable_lock, flags);
+
+out:
+	return;
+}
+
+static int clk_disable_unused(void)
+{
+	struct clk *clk;
+	struct hlist_node *tmp;
+
+	mutex_lock(&prepare_lock);
+
+	hlist_for_each_entry(clk, tmp, &clk_root_list, child_node)
+		clk_disable_unused_subtree(clk);
+
+	hlist_for_each_entry(clk, tmp, &clk_orphan_list, child_node)
+		clk_disable_unused_subtree(clk);
+
+	mutex_unlock(&prepare_lock);
+
+	return 0;
+}
+late_initcall(clk_disable_unused);
+#else
+static inline int clk_disable_unused(struct clk *clk) { return 0; }
+#endif /* CONFIG_COMMON_CLK_DISABLE_UNUSED */
+
+/***    helper functions   ***/
+
+inline const char *__clk_get_name(struct clk *clk)
+{
+	return !clk ? NULL : clk->name;
+}
+
+inline struct clk_hw *__clk_get_hw(struct clk *clk)
+{
+	return !clk ? NULL : clk->hw;
+}
+
+inline u8 __clk_get_num_parents(struct clk *clk)
+{
+	return !clk ? -EINVAL : clk->num_parents;
+}
+
+inline struct clk *__clk_get_parent(struct clk *clk)
+{
+	return !clk ? NULL : clk->parent;
+}
+
+inline int __clk_get_enable_count(struct clk *clk)
+{
+	return !clk ? -EINVAL : clk->enable_count;
+}
+
+inline int __clk_get_prepare_count(struct clk *clk)
+{
+	return !clk ? -EINVAL : clk->prepare_count;
+}
+
+unsigned long __clk_get_rate(struct clk *clk)
+{
+	unsigned long ret;
+
+	if (!clk) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = clk->rate;
+
+	if (clk->flags & CLK_IS_ROOT)
+		goto out;
+
+	if (!clk->parent)
+		ret = -ENODEV;
+
+out:
+	return ret;
+}
+
+inline unsigned long __clk_get_flags(struct clk *clk)
+{
+	return !clk ? -EINVAL : clk->flags;
+}
+
+int __clk_is_enabled(struct clk *clk)
+{
+	int ret;
+
+	if (!clk)
+		return -EINVAL;
+
+	/*
+	 * .is_enabled is only mandatory for clocks that gate
+	 * fall back to software usage counter if .is_enabled is missing
+	 */
+	if (!clk->ops->is_enabled) {
+		ret = clk->enable_count ? 1 : 0;
+		goto out;
+	}
+
+	ret = clk->ops->is_enabled(clk->hw);
+out:
+	return ret;
+}
+
+static struct clk *__clk_lookup_subtree(const char *name, struct clk *clk)
+{
+	struct clk *child;
+	struct clk *ret;
+	struct hlist_node *tmp;
+
+	if (!strcmp(clk->name, name))
+		return clk;
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+		ret = __clk_lookup_subtree(name, child);
+		if (ret)
+			return ret;
+	}
+
+	return NULL;
+}
+
+struct clk *__clk_lookup(const char *name)
+{
+	struct clk *root_clk;
+	struct clk *ret;
+	struct hlist_node *tmp;
+
+	if (!name)
+		return NULL;
+
+	/* search the 'proper' clk tree first */
+	hlist_for_each_entry(root_clk, tmp, &clk_root_list, child_node) {
+		ret = __clk_lookup_subtree(name, root_clk);
+		if (ret)
+			return ret;
+	}
+
+	/* if not found, then search the orphan tree */
+	hlist_for_each_entry(root_clk, tmp, &clk_orphan_list, child_node) {
+		ret = __clk_lookup_subtree(name, root_clk);
+		if (ret)
+			return ret;
+	}
+
+	return NULL;
+}
+
+/***        clk api        ***/
+
+void __clk_unprepare(struct clk *clk)
+{
+	if (!clk)
+		return;
+
+	if (WARN_ON(clk->prepare_count == 0))
+		return;
+
+	if (--clk->prepare_count > 0)
+		return;
+
+	WARN_ON(clk->enable_count > 0);
+
+	if (clk->ops->unprepare)
+		clk->ops->unprepare(clk->hw);
+
+	__clk_unprepare(clk->parent);
+}
+
+/**
+ * clk_unprepare - undo preparation of a clock source
+ * @clk: the clk being unprepare
+ *
+ * clk_unprepare may sleep, which differentiates it from clk_disable.  In a
+ * simple case, clk_unprepare can be used instead of clk_disable to gate a clk
+ * if the operation may sleep.  One example is a clk which is accessed over
+ * I2c.  In the complex case a clk gate operation may require a fast and a slow
+ * part.  It is this reason that clk_unprepare and clk_disable are not mutually
+ * exclusive.  In fact clk_disable must be called before clk_unprepare.
+ */
+void clk_unprepare(struct clk *clk)
+{
+	mutex_lock(&prepare_lock);
+	__clk_unprepare(clk);
+	mutex_unlock(&prepare_lock);
+}
+EXPORT_SYMBOL_GPL(clk_unprepare);
+
+int __clk_prepare(struct clk *clk)
+{
+	int ret = 0;
+
+	if (!clk)
+		return 0;
+
+	if (clk->prepare_count == 0) {
+		ret = __clk_prepare(clk->parent);
+		if (ret)
+			return ret;
+
+		if (clk->ops->prepare) {
+			ret = clk->ops->prepare(clk->hw);
+			if (ret) {
+				__clk_unprepare(clk->parent);
+				return ret;
+			}
+		}
+	}
+
+	clk->prepare_count++;
+
+	return 0;
+}
+
+/**
+ * clk_prepare - prepare a clock source
+ * @clk: the clk being prepared
+ *
+ * clk_prepare may sleep, which differentiates it from clk_enable.  In a simple
+ * case, clk_prepare can be used instead of clk_enable to ungate a clk if the
+ * operation may sleep.  One example is a clk which is accessed over I2c.  In
+ * the complex case a clk ungate operation may require a fast and a slow part.
+ * It is this reason that clk_prepare and clk_enable are not mutually
+ * exclusive.  In fact clk_prepare must be called before clk_enable.
+ * Returns 0 on success, -EERROR otherwise.
+ */
+int clk_prepare(struct clk *clk)
+{
+	int ret;
+
+	mutex_lock(&prepare_lock);
+	ret = __clk_prepare(clk);
+	mutex_unlock(&prepare_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_prepare);
+
+static void __clk_disable(struct clk *clk)
+{
+	if (!clk)
+		return;
+
+	if (WARN_ON(clk->enable_count == 0))
+		return;
+
+	if (--clk->enable_count > 0)
+		return;
+
+	if (clk->ops->disable)
+		clk->ops->disable(clk->hw);
+
+	__clk_disable(clk->parent);
+}
+
+/**
+ * clk_disable - gate a clock
+ * @clk: the clk being gated
+ *
+ * clk_disable must not sleep, which differentiates it from clk_unprepare.  In
+ * a simple case, clk_disable can be used instead of clk_unprepare to gate a
+ * clk if the operation is fast and will never sleep.  One example is a
+ * SoC-internal clk which is controlled via simple register writes.  In the
+ * complex case a clk gate operation may require a fast and a slow part.  It is
+ * this reason that clk_unprepare and clk_disable are not mutually exclusive.
+ * In fact clk_disable must be called before clk_unprepare.
+ */
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&enable_lock, flags);
+	__clk_disable(clk);
+	spin_unlock_irqrestore(&enable_lock, flags);
+}
+EXPORT_SYMBOL_GPL(clk_disable);
+
+static int __clk_enable(struct clk *clk)
+{
+	int ret = 0;
+
+	if (!clk)
+		return 0;
+
+	if (WARN_ON(clk->prepare_count == 0))
+		return -ESHUTDOWN;
+
+	if (clk->enable_count == 0) {
+		ret = __clk_enable(clk->parent);
+
+		if (ret)
+			return ret;
+
+		if (clk->ops->enable) {
+			ret = clk->ops->enable(clk->hw);
+			if (ret) {
+				__clk_disable(clk->parent);
+				return ret;
+			}
+		}
+	}
+
+	clk->enable_count++;
+	return 0;
+}
+
+/**
+ * clk_enable - ungate a clock
+ * @clk: the clk being ungated
+ *
+ * clk_enable must not sleep, which differentiates it from clk_prepare.  In a
+ * simple case, clk_enable can be used instead of clk_prepare to ungate a clk
+ * if the operation will never sleep.  One example is a SoC-internal clk which
+ * is controlled via simple register writes.  In the complex case a clk ungate
+ * operation may require a fast and a slow part.  It is this reason that
+ * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare
+ * must be called before clk_enable.  Returns 0 on success, -EERROR
+ * otherwise.
+ */
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&enable_lock, flags);
+	ret = __clk_enable(clk);
+	spin_unlock_irqrestore(&enable_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_enable);
+
+/**
+ * clk_get_rate - return the rate of clk
+ * @clk: the clk whose rate is being returned
+ *
+ * Simply returns the cached rate of the clk.  Does not query the hardware.  If
+ * clk is NULL then returns -EINVAL.
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long rate;
+
+	mutex_lock(&prepare_lock);
+	rate = __clk_get_rate(clk);
+	mutex_unlock(&prepare_lock);
+
+	return rate;
+}
+EXPORT_SYMBOL_GPL(clk_get_rate);
+
+/**
+ * __clk_round_rate - round the given rate for a clk
+ * @clk: round the rate of this clock
+ *
+ * Caller must hold prepare_lock.  Useful for clk_ops such as .set_rate
+ */
+unsigned long __clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long unused;
+
+	if (!clk)
+		return -EINVAL;
+
+	if (!clk->ops->round_rate)
+		return clk->rate;
+
+	if (clk->flags & CLK_SET_RATE_PARENT)
+		return clk->ops->round_rate(clk->hw, rate, &unused);
+	else
+		return clk->ops->round_rate(clk->hw, rate, NULL);
+}
+
+/**
+ * clk_round_rate - round the given rate for a clk
+ * @clk: the clk for which we are rounding a rate
+ * @rate: the rate which is to be rounded
+ *
+ * Takes in a rate as input and rounds it to a rate that the clk can actually
+ * use which is then returned.  If clk doesn't support round_rate operation
+ * then the parent rate is returned.
+ */
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long ret;
+
+	mutex_lock(&prepare_lock);
+	ret = __clk_round_rate(clk, rate);
+	mutex_unlock(&prepare_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_round_rate);
+
+/**
+ * __clk_notify - call clk notifier chain
+ * @clk: struct clk * that is changing rate
+ * @msg: clk notifier type (see include/linux/clk.h)
+ * @old_rate: old clk rate
+ * @new_rate: new clk rate
+ *
+ * Triggers a notifier call chain on the clk rate-change notification
+ * for 'clk'.  Passes a pointer to the struct clk and the previous
+ * and current rates to the notifier callback.  Intended to be called by
+ * internal clock code only.  Returns NOTIFY_DONE from the last driver
+ * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if
+ * a driver returns that.
+ */
+static int __clk_notify(struct clk *clk, unsigned long msg,
+		unsigned long old_rate, unsigned long new_rate)
+{
+	struct clk_notifier *cn;
+	struct clk_notifier_data cnd;
+	int ret = NOTIFY_DONE;
+
+	cnd.clk = clk;
+	cnd.old_rate = old_rate;
+	cnd.new_rate = new_rate;
+
+	list_for_each_entry(cn, &clk_notifier_list, node) {
+		if (cn->clk == clk) {
+			ret = srcu_notifier_call_chain(&cn->notifier_head, msg,
+					&cnd);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * __clk_recalc_rates
+ * @clk: first clk in the subtree
+ * @msg: notification type (see include/linux/clk.h)
+ *
+ * Walks the subtree of clks starting with clk and recalculates rates as it
+ * goes.  Note that if a clk does not implement the .recalc_rate callback then
+ * it is assumed that the clock will take on the rate of it's parent.
+ *
+ * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,
+ * if necessary.
+ *
+ * Caller must hold prepare_lock.
+ */
+static void __clk_recalc_rates(struct clk *clk, unsigned long msg)
+{
+	unsigned long old_rate;
+	unsigned long parent_rate = 0;
+	struct hlist_node *tmp;
+	struct clk *child;
+
+	old_rate = clk->rate;
+
+	if (clk->parent)
+		parent_rate = clk->parent->rate;
+
+	if (clk->ops->recalc_rate)
+		clk->rate = clk->ops->recalc_rate(clk->hw, parent_rate);
+	else
+		clk->rate = parent_rate;
+
+	/*
+	 * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE
+	 * & ABORT_RATE_CHANGE notifiers
+	 */
+	if (clk->notifier_count && msg)
+		__clk_notify(clk, msg, old_rate, clk->rate);
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+		__clk_recalc_rates(child, msg);
+}
+
+/**
+ * __clk_speculate_rates
+ * @clk: first clk in the subtree
+ * @parent_rate: the "future" rate of clk's parent
+ *
+ * Walks the subtree of clks starting with clk, speculating rates as it
+ * goes and firing off PRE_RATE_CHANGE notifications as necessary.
+ *
+ * Unlike clk_recalc_rates, clk_speculate_rates exists only for sending
+ * pre-rate change notifications and returns early if no clks in the
+ * subtree have subscribed to the notifications.  Note that if a clk does not
+ * implement the .recalc_rate callback then it is assumed that the clock will
+ * take on the rate of it's parent.
+ *
+ * Caller must hold prepare_lock.
+ */
+static int __clk_speculate_rates(struct clk *clk, unsigned long parent_rate)
+{
+	struct hlist_node *tmp;
+	struct clk *child;
+	unsigned long new_rate;
+	int ret = NOTIFY_DONE;
+
+	if (clk->ops->recalc_rate)
+		new_rate = clk->ops->recalc_rate(clk->hw, parent_rate);
+	else
+		new_rate = parent_rate;
+
+	/* abort the rate change if a driver returns NOTIFY_BAD */
+	if (clk->notifier_count)
+		ret = __clk_notify(clk, PRE_RATE_CHANGE, clk->rate, new_rate);
+
+	if (ret == NOTIFY_BAD)
+		goto out;
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+		ret = __clk_speculate_rates(child, new_rate);
+		if (ret == NOTIFY_BAD)
+			break;
+	}
+
+out:
+	return ret;
+}
+
+static void clk_calc_subtree(struct clk *clk, unsigned long new_rate)
+{
+	struct clk *child;
+	struct hlist_node *tmp;
+
+	clk->new_rate = new_rate;
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+		if (child->ops->recalc_rate)
+			child->new_rate = child->ops->recalc_rate(child->hw, new_rate);
+		else
+			child->new_rate = new_rate;
+		clk_calc_subtree(child, child->new_rate);
+	}
+}
+
+/*
+ * calculate the new rates returning the topmost clock that has to be
+ * changed.
+ */
+static struct clk *clk_calc_new_rates(struct clk *clk, unsigned long rate)
+{
+	struct clk *top = clk;
+	unsigned long best_parent_rate = clk->parent->rate;
+	unsigned long new_rate;
+
+	if (!clk->ops->round_rate && !(clk->flags & CLK_SET_RATE_PARENT)) {
+		clk->new_rate = clk->rate;
+		return NULL;
+	}
+
+	if (!clk->ops->round_rate && (clk->flags & CLK_SET_RATE_PARENT)) {
+		top = clk_calc_new_rates(clk->parent, rate);
+		new_rate = clk->new_rate = clk->parent->new_rate;
+
+		goto out;
+	}
+
+	if (clk->flags & CLK_SET_RATE_PARENT)
+		new_rate = clk->ops->round_rate(clk->hw, rate, &best_parent_rate);
+	else
+		new_rate = clk->ops->round_rate(clk->hw, rate, NULL);
+
+	if (best_parent_rate != clk->parent->rate) {
+		top = clk_calc_new_rates(clk->parent, best_parent_rate);
+
+		goto out;
+	}
+
+out:
+	clk_calc_subtree(clk, new_rate);
+
+	return top;
+}
+
+/*
+ * Notify about rate changes in a subtree. Always walk down the whole tree
+ * so that in case of an error we can walk down the whole tree again and
+ * abort the change.
+ */
+static struct clk *clk_propagate_rate_change(struct clk *clk, unsigned long event)
+{
+	struct hlist_node *tmp;
+	struct clk *child, *fail_clk = NULL;
+	int ret = NOTIFY_DONE;
+
+	if (clk->rate == clk->new_rate)
+		return 0;
+
+	if (clk->notifier_count) {
+		ret = __clk_notify(clk, event, clk->rate, clk->new_rate);
+		if (ret == NOTIFY_BAD)
+			fail_clk = clk;
+	}
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node) {
+		clk = clk_propagate_rate_change(child, event);
+		if (clk)
+			fail_clk = clk;
+	}
+
+	return fail_clk;
+}
+
+/*
+ * walk down a subtree and set the new rates notifying the rate
+ * change on the way
+ */
+static void clk_change_rate(struct clk *clk)
+{
+	struct clk *child;
+	unsigned long old_rate;
+	struct hlist_node *tmp;
+
+	old_rate = clk->rate;
+
+	if (clk->ops->set_rate)
+		clk->ops->set_rate(clk->hw, clk->new_rate);
+
+	if (clk->ops->recalc_rate)
+		clk->rate = clk->ops->recalc_rate(clk->hw,
+				clk->parent->rate);
+	else
+		clk->rate = clk->parent->rate;
+
+	if (clk->notifier_count && old_rate != clk->rate)
+		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
+
+	hlist_for_each_entry(child, tmp, &clk->children, child_node)
+		clk_change_rate(child);
+}
+
+/**
+ * clk_set_rate - specify a new rate for clk
+ * @clk: the clk whose rate is being changed
+ * @rate: the new rate for clk
+ *
+ * In the simplest case clk_set_rate will only change the rate of clk.
+ *
+ * If clk has the CLK_SET_RATE_GATE flag set and it is enabled this call
+ * will fail; only when the clk is disabled will it be able to change
+ * its rate.
+ *
+ * Setting the CLK_SET_RATE_PARENT flag allows clk_set_rate to
+ * recursively propagate up to clk's parent; whether or not this happens
+ * depends on the outcome of clk's .round_rate implementation.  If
+ * *parent_rate is 0 after calling .round_rate then upstream parent
+ * propagation is ignored.  If *parent_rate comes back with a new rate
+ * for clk's parent then we propagate up to clk's parent and set it's
+ * rate.  Upward propagation will continue until either a clk does not
+ * support the CLK_SET_RATE_PARENT flag or .round_rate stops requesting
+ * changes to clk's parent_rate.  If there is a failure during upstream
+ * propagation then clk_set_rate will unwind and restore each clk's rate
+ * that had been successfully changed.  Afterwards a rate change abort
+ * notification will be propagated downstream, starting from the clk
+ * that failed.
+ *
+ * At the end of all of the rate setting, clk_set_rate internally calls
+ * __clk_recalc_rates and propagates the rate changes downstream,
+ * starting from the highest clk whose rate was changed.  This has the
+ * added benefit of propagating post-rate change notifiers.
+ *
+ * Note that while post-rate change and rate change abort notifications
+ * are guaranteed to be sent to a clk only once per call to
+ * clk_set_rate, pre-change notifications will be sent for every clk
+ * whose rate is changed.  Stacking pre-change notifications is noisy
+ * for the drivers subscribed to them, but this allows drivers to react
+ * to intermediate clk rate changes up until the point where the final
+ * rate is achieved at the end of upstream propagation.
+ *
+ * Returns 0 on success, -EERROR otherwise.
+ */
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	struct clk *top, *fail_clk;
+	int ret = 0;
+
+	/* prevent racing with updates to the clock topology */
+	mutex_lock(&prepare_lock);
+
+	/* bail early if nothing to do */
+	if (rate == clk->rate)
+		goto out;
+
+	/* calculate new rates and get the topmost changed clock */
+	top = clk_calc_new_rates(clk, rate);
+	if (!top) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* notify that we are about to change rates */
+	fail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);
+	if (fail_clk) {
+		pr_warn("%s: failed to set %s rate\n", __func__,
+				fail_clk->name);
+		clk_propagate_rate_change(top, ABORT_RATE_CHANGE);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	/* change the rates */
+	clk_change_rate(top);
+
+	mutex_unlock(&prepare_lock);
+
+	return 0;
+out:
+	mutex_unlock(&prepare_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_rate);
+
+/**
+ * clk_get_parent - return the parent of a clk
+ * @clk: the clk whose parent gets returned
+ *
+ * Simply returns clk->parent.  Returns NULL if clk is NULL.
+ */
+struct clk *clk_get_parent(struct clk *clk)
+{
+	struct clk *parent;
+
+	mutex_lock(&prepare_lock);
+	parent = __clk_get_parent(clk);
+	mutex_unlock(&prepare_lock);
+
+	return parent;
+}
+EXPORT_SYMBOL_GPL(clk_get_parent);
+
+/*
+ * .get_parent is mandatory for clocks with multiple possible parents.  It is
+ * optional for single-parent clocks.  Always call .get_parent if it is
+ * available and WARN if it is missing for multi-parent clocks.
+ *
+ * For single-parent clocks without .get_parent, first check to see if the
+ * .parents array exists, and if so use it to avoid an expensive tree
+ * traversal.  If .parents does not exist then walk the tree with __clk_lookup.
+ */
+static struct clk *__clk_init_parent(struct clk *clk)
+{
+	struct clk *ret = NULL;
+	u8 index;
+
+	/* handle the trivial cases */
+
+	if (!clk->num_parents)
+		goto out;
+
+	if (clk->num_parents == 1) {
+		if (IS_ERR_OR_NULL(clk->parent))
+			ret = clk->parent = __clk_lookup(clk->parent_names[0]);
+		ret = clk->parent;
+		goto out;
+	}
+
+	if (!clk->ops->get_parent) {
+		WARN(!clk->ops->get_parent,
+			"%s: multi-parent clocks must implement .get_parent\n",
+			__func__);
+		goto out;
+	};
+
+	/*
+	 * Do our best to cache parent clocks in clk->parents.  This prevents
+	 * unnecessary and expensive calls to __clk_lookup.  We don't set
+	 * clk->parent here; that is done by the calling function
+	 */
+
+	index = clk->ops->get_parent(clk->hw);
+
+	if (!clk->parents)
+		clk->parents =
+			kmalloc((sizeof(struct clk*) * clk->num_parents),
+					GFP_KERNEL);
+
+	if (!clk->parents)
+		ret = __clk_lookup(clk->parent_names[index]);
+	else if (!clk->parents[index])
+		ret = clk->parents[index] =
+			__clk_lookup(clk->parent_names[index]);
+	else
+		ret = clk->parents[index];
+
+out:
+	return ret;
+}
+
+void __clk_reparent(struct clk *clk, struct clk *new_parent)
+{
+#ifdef CONFIG_COMMON_CLK_DEBUG
+	struct dentry *d;
+	struct dentry *new_parent_d;
+#endif
+
+	if (!clk || !new_parent)
+		return;
+
+	hlist_del(&clk->child_node);
+
+	if (new_parent)
+		hlist_add_head(&clk->child_node, &new_parent->children);
+	else
+		hlist_add_head(&clk->child_node, &clk_orphan_list);
+
+#ifdef CONFIG_COMMON_CLK_DEBUG
+	if (!inited)
+		goto out;
+
+	if (new_parent)
+		new_parent_d = new_parent->dentry;
+	else
+		new_parent_d = orphandir;
+
+	d = debugfs_rename(clk->dentry->d_parent, clk->dentry,
+			new_parent_d, clk->name);
+	if (d)
+		clk->dentry = d;
+	else
+		pr_debug("%s: failed to rename debugfs entry for %s\n",
+				__func__, clk->name);
+out:
+#endif
+
+	clk->parent = new_parent;
+
+	__clk_recalc_rates(clk, POST_RATE_CHANGE);
+}
+
+static int __clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	struct clk *old_parent;
+	unsigned long flags;
+	int ret = -EINVAL;
+	u8 i;
+
+	old_parent = clk->parent;
+
+	/* find index of new parent clock using cached parent ptrs */
+	for (i = 0; i < clk->num_parents; i++)
+		if (clk->parents[i] == parent)
+			break;
+
+	/*
+	 * find index of new parent clock using string name comparison
+	 * also try to cache the parent to avoid future calls to __clk_lookup
+	 */
+	if (i == clk->num_parents)
+		for (i = 0; i < clk->num_parents; i++)
+			if (!strcmp(clk->parent_names[i], parent->name)) {
+				clk->parents[i] = __clk_lookup(parent->name);
+				break;
+			}
+
+	if (i == clk->num_parents) {
+		pr_debug("%s: clock %s is not a possible parent of clock %s\n",
+				__func__, parent->name, clk->name);
+		goto out;
+	}
+
+	/* migrate prepare and enable */
+	if (clk->prepare_count)
+		__clk_prepare(parent);
+
+	/* FIXME replace with clk_is_enabled(clk) someday */
+	spin_lock_irqsave(&enable_lock, flags);
+	if (clk->enable_count)
+		__clk_enable(parent);
+	spin_unlock_irqrestore(&enable_lock, flags);
+
+	/* change clock input source */
+	ret = clk->ops->set_parent(clk->hw, i);
+
+	/* clean up old prepare and enable */
+	spin_lock_irqsave(&enable_lock, flags);
+	if (clk->enable_count)
+		__clk_disable(old_parent);
+	spin_unlock_irqrestore(&enable_lock, flags);
+
+	if (clk->prepare_count)
+		__clk_unprepare(old_parent);
+
+out:
+	return ret;
+}
+
+/**
+ * clk_set_parent - switch the parent of a mux clk
+ * @clk: the mux clk whose input we are switching
+ * @parent: the new input to clk
+ *
+ * Re-parent clk to use parent as it's new input source.  If clk has the
+ * CLK_SET_PARENT_GATE flag set then clk must be gated for this
+ * operation to succeed.  After successfully changing clk's parent
+ * clk_set_parent will update the clk topology, sysfs topology and
+ * propagate rate recalculation via __clk_recalc_rates.  Returns 0 on
+ * success, -EERROR otherwise.
+ */
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = 0;
+
+	if (!clk || !clk->ops)
+		return -EINVAL;
+
+	if (!clk->ops->set_parent)
+		return -ENOSYS;
+
+	/* prevent racing with updates to the clock topology */
+	mutex_lock(&prepare_lock);
+
+	if (clk->parent == parent)
+		goto out;
+
+	/* propagate PRE_RATE_CHANGE notifications */
+	if (clk->notifier_count)
+		ret = __clk_speculate_rates(clk, parent->rate);
+
+	/* abort if a driver objects */
+	if (ret == NOTIFY_STOP)
+		goto out;
+
+	/* only re-parent if the clock is not in use */
+	if ((clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count)
+		ret = -EBUSY;
+	else
+		ret = __clk_set_parent(clk, parent);
+
+	/* propagate ABORT_RATE_CHANGE if .set_parent failed */
+	if (ret) {
+		__clk_recalc_rates(clk, ABORT_RATE_CHANGE);
+		goto out;
+	}
+
+	/* propagate rate recalculation downstream */
+	__clk_reparent(clk, parent);
+
+out:
+	mutex_unlock(&prepare_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_parent);
+
+/**
+ * __clk_init - initialize the data structures in a struct clk
+ * @dev:	device initializing this clk, placeholder for now
+ * @clk:	clk being initialized
+ *
+ * Initializes the lists in struct clk, queries the hardware for the
+ * parent and rate and sets them both.
+ *
+ * Any struct clk passed into __clk_init must have the following members
+ * populated:
+ * 	.name
+ * 	.ops
+ * 	.hw
+ * 	.parent_names
+ * 	.num_parents
+ * 	.flags
+ *
+ * Essentially, everything that would normally be passed into clk_register is
+ * assumed to be initialized already in __clk_init.  The other members may be
+ * populated, but are optional.
+ *
+ * __clk_init is only exposed via clk-private.h and is intended for use with
+ * very large numbers of clocks that need to be statically initialized.  It is
+ * a layering violation to include clk-private.h from any code which implements
+ * a clock's .ops; as such any statically initialized clock data MUST be in a
+ * separate C file from the logic that implements it's operations.
+ */
+void __clk_init(struct device *dev, struct clk *clk)
+{
+	int i;
+	struct clk *orphan;
+	struct hlist_node *tmp, *tmp2;
+
+	if (!clk)
+		return;
+
+	mutex_lock(&prepare_lock);
+
+	/* check to see if a clock with this name is already registered */
+	if (__clk_lookup(clk->name))
+		goto out;
+
+	/* throw a WARN if any entries in parent_names are NULL */
+	for (i = 0; i < clk->num_parents; i++)
+		WARN(!clk->parent_names[i],
+				"%s: invalid NULL in %s's .parent_names\n",
+				__func__, clk->name);
+
+	/*
+	 * Allocate an array of struct clk *'s to avoid unnecessary string
+	 * look-ups of clk's possible parents.  This can fail for clocks passed
+	 * in to clk_init during early boot; thus any access to clk->parents[]
+	 * must always check for a NULL pointer and try to populate it if
+	 * necessary.
+	 *
+	 * If clk->parents is not NULL we skip this entire block.  This allows
+	 * for clock drivers to statically initialize clk->parents.
+	 */
+	if (clk->num_parents && !clk->parents) {
+		clk->parents = kmalloc((sizeof(struct clk*) * clk->num_parents),
+				GFP_KERNEL);
+		/*
+		 * __clk_lookup returns NULL for parents that have not been
+		 * clk_init'd; thus any access to clk->parents[] must check
+		 * for a NULL pointer.  We can always perform lazy lookups for
+		 * missing parents later on.
+		 */
+		if (clk->parents)
+			for (i = 0; i < clk->num_parents; i++)
+				clk->parents[i] =
+					__clk_lookup(clk->parent_names[i]);
+	}
+
+	clk->parent = __clk_init_parent(clk);
+
+	/*
+	 * Populate clk->parent if parent has already been __clk_init'd.  If
+	 * parent has not yet been __clk_init'd then place clk in the orphan
+	 * list.  If clk has set the CLK_IS_ROOT flag then place it in the root
+	 * clk list.
+	 *
+	 * Every time a new clk is clk_init'd then we walk the list of orphan
+	 * clocks and re-parent any that are children of the clock currently
+	 * being clk_init'd.
+	 */
+	if (clk->parent)
+		hlist_add_head(&clk->child_node,
+				&clk->parent->children);
+	else if (clk->flags & CLK_IS_ROOT)
+		hlist_add_head(&clk->child_node, &clk_root_list);
+	else
+		hlist_add_head(&clk->child_node, &clk_orphan_list);
+
+	/*
+	 * Set clk's rate.  The preferred method is to use .recalc_rate.  For
+	 * simple clocks and lazy developers the default fallback is to use the
+	 * parent's rate.  If a clock doesn't have a parent (or is orphaned)
+	 * then rate is set to zero.
+	 */
+	if (clk->ops->recalc_rate)
+		clk->rate = clk->ops->recalc_rate(clk->hw,
+				__clk_get_rate(clk->parent));
+	else if (clk->parent)
+		clk->rate = clk->parent->rate;
+	else
+		clk->rate = 0;
+
+	/*
+	 * walk the list of orphan clocks and reparent any that are children of
+	 * this clock
+	 */
+	hlist_for_each_entry_safe(orphan, tmp, tmp2, &clk_orphan_list, child_node)
+		for (i = 0; i < orphan->num_parents; i++)
+			if (!strcmp(clk->name, orphan->parent_names[i])) {
+				__clk_reparent(orphan, clk);
+				break;
+			}
+
+	/*
+	 * optional platform-specific magic
+	 *
+	 * The .init callback is not used by any of the basic clock types, but
+	 * exists for weird hardware that must perform initialization magic.
+	 * Please consider other ways of solving initialization problems before
+	 * using this callback, as it's use is discouraged.
+	 */
+	if (clk->ops->init)
+		clk->ops->init(clk->hw);
+
+	clk_debug_register(clk);
+
+out:
+	mutex_unlock(&prepare_lock);
+
+	return;
+}
+
+/**
+ * clk_register - allocate a new clock, register it and return an opaque cookie
+ * @dev: device that is registering this clock
+ * @name: clock name
+ * @ops: operations this clock supports
+ * @hw: link to hardware-specific clock data
+ * @parent_names: array of string names for all possible parents
+ * @num_parents: number of possible parents
+ * @flags: framework-level hints and quirks
+ *
+ * clk_register is the primary interface for populating the clock tree with new
+ * clock nodes.  It returns a pointer to the newly allocated struct clk which
+ * cannot be dereferenced by driver code but may be used in conjuction with the
+ * rest of the clock API.
+ */
+struct clk *clk_register(struct device *dev, const char *name,
+		const struct clk_ops *ops, struct clk_hw *hw,
+		char **parent_names, u8 num_parents, unsigned long flags)
+{
+	struct clk *clk;
+
+	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk)
+		return NULL;
+
+	clk->name = name;
+	clk->ops = ops;
+	clk->hw = hw;
+	clk->flags = flags;
+	clk->parent_names = parent_names;
+	clk->num_parents = num_parents;
+	hw->clk = clk;
+
+	__clk_init(dev, clk);
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(clk_register);
+
+/***        clk rate change notifiers        ***/
+
+/**
+ * clk_notifier_register - add a clk rate change notifier
+ * @clk: struct clk * to watch
+ * @nb: struct notifier_block * with callback info
+ *
+ * Request notification when clk's rate changes.  This uses an SRCU
+ * notifier because we want it to block and notifier unregistrations are
+ * uncommon.  The callbacks associated with the notifier must not
+ * re-enter into the clk framework by calling any top-level clk APIs;
+ * this will cause a nested prepare_lock mutex.
+ *
+ * Pre-change notifier callbacks will be passed the current, pre-change
+ * rate of the clk via struct clk_notifier_data.old_rate.  The new,
+ * post-change rate of the clk is passed via struct
+ * clk_notifier_data.new_rate.
+ *
+ * Post-change notifiers will pass the now-current, post-change rate of
+ * the clk in both struct clk_notifier_data.old_rate and struct
+ * clk_notifier_data.new_rate.
+ *
+ * Abort-change notifiers are effectively the opposite of pre-change
+ * notifiers: the original pre-change clk rate is passed in via struct
+ * clk_notifier_data.new_rate and the failed post-change rate is passed
+ * in via struct clk_notifier_data.old_rate.
+ *
+ * clk_notifier_register() must be called from non-atomic context.
+ * Returns -EINVAL if called with null arguments, -ENOMEM upon
+ * allocation failure; otherwise, passes along the return value of
+ * srcu_notifier_chain_register().
+ */
+int clk_notifier_register(struct clk *clk, struct notifier_block *nb)
+{
+	struct clk_notifier *cn;
+	int ret = -ENOMEM;
+
+	if (!clk || !nb)
+		return -EINVAL;
+
+	mutex_lock(&prepare_lock);
+
+	/* search the list of notifiers for this clk */
+	list_for_each_entry(cn, &clk_notifier_list, node)
+		if (cn->clk == clk)
+			break;
+
+	/* if clk wasn't in the notifier list, allocate new clk_notifier */
+	if (cn->clk != clk) {
+		cn = kzalloc(sizeof(struct clk_notifier), GFP_KERNEL);
+		if (!cn)
+			goto out;
+
+		cn->clk = clk;
+		srcu_init_notifier_head(&cn->notifier_head);
+
+		list_add(&cn->node, &clk_notifier_list);
+	}
+
+	ret = srcu_notifier_chain_register(&cn->notifier_head, nb);
+
+	clk->notifier_count++;
+
+out:
+	mutex_unlock(&prepare_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_notifier_register);
+
+/**
+ * clk_notifier_unregister - remove a clk rate change notifier
+ * @clk: struct clk *
+ * @nb: struct notifier_block * with callback info
+ *
+ * Request no further notification for changes to 'clk' and frees memory
+ * allocated in clk_notifier_register.
+ *
+ * Returns -EINVAL if called with null arguments; otherwise, passes
+ * along the return value of srcu_notifier_chain_unregister().
+ */
+int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)
+{
+	struct clk_notifier *cn = NULL;
+	int ret = -EINVAL;
+
+	if (!clk || !nb)
+		return -EINVAL;
+
+	mutex_lock(&prepare_lock);
+
+	list_for_each_entry(cn, &clk_notifier_list, node)
+		if (cn->clk == clk)
+			break;
+
+	if (cn->clk == clk) {
+		ret = srcu_notifier_chain_unregister(&cn->notifier_head, nb);
+
+		clk->notifier_count--;
+
+		/* XXX the notifier code should handle this better */
+		if (!cn->notifier_head.head) {
+			srcu_cleanup_notifier_head(&cn->notifier_head);
+			kfree(cn);
+		}
+
+	} else {
+		ret = -ENOENT;
+	}
+
+	mutex_unlock(&prepare_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_notifier_unregister);
