commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 2afc8df8acff..0f2e3fcf0f19 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * drivers/clk/clkdev.c
  *
  *  Copyright (C) 2008 Russell King.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Helper for the clk API to assist looking up a struct clk.
  */
 #include <linux/module.h>

commit dde4eff47c82c52a72af333d9e55370eee6d95d6
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:48 2019 -0700

    clk: Look for parents with clkdev based clk_lookups
    
    In addition to looking for DT based parents, support clkdev based
    clk_lookups. This should allow non-DT based clk drivers to participate
    in the parent lookup process.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 6f65bde696da..2afc8df8acff 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -72,7 +72,7 @@ static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 	return cl;
 }
 
-static struct clk_hw *clk_find_hw(const char *dev_id, const char *con_id)
+struct clk_hw *clk_find_hw(const char *dev_id, const char *con_id)
 {
 	struct clk_lookup *cl;
 	struct clk_hw *hw = ERR_PTR(-ENOENT);

commit d1011cba02f2f931f0a95ea093cb25bc7738ff4d
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:43 2019 -0700

    clkdev: Move clk creation outside of 'clocks_mutex'
    
    We don't need to hold the 'clocks_mutex' here when we're creating a clk
    pointer from a clk_lookup structure. Instead, we just need to make sure
    that the lookup doesn't go away while we dereference the lookup pointer
    to extract the clk_hw pointer out of it. Let's move things around
    slightly so that we have a new function to get the clk_hw out of the
    lookup with the right locking and then chain the two together for what
    used to be __clk_get_sys().
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 6e787cc9e5b9..6f65bde696da 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -72,25 +72,26 @@ static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 	return cl;
 }
 
-static struct clk *__clk_get_sys(struct device *dev, const char *dev_id,
-				 const char *con_id)
+static struct clk_hw *clk_find_hw(const char *dev_id, const char *con_id)
 {
 	struct clk_lookup *cl;
-	struct clk *clk = NULL;
+	struct clk_hw *hw = ERR_PTR(-ENOENT);
 
 	mutex_lock(&clocks_mutex);
-
 	cl = clk_find(dev_id, con_id);
-	if (!cl)
-		goto out;
-
-	clk = clk_hw_create_clk(dev, cl->clk_hw, dev_id, con_id);
-	if (IS_ERR(clk))
-		cl = NULL;
-out:
+	if (cl)
+		hw = cl->clk_hw;
 	mutex_unlock(&clocks_mutex);
 
-	return cl ? clk : ERR_PTR(-ENOENT);
+	return hw;
+}
+
+static struct clk *__clk_get_sys(struct device *dev, const char *dev_id,
+				 const char *con_id)
+{
+	struct clk_hw *hw = clk_find_hw(dev_id, con_id);
+
+	return clk_hw_create_clk(dev, hw, dev_id, con_id);
 }
 
 struct clk *clk_get_sys(const char *dev_id, const char *con_id)

commit 5a7efdacb9dda1c35fb414d57b3e16d520e2c0db
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Apr 12 11:31:42 2019 -0700

    clkdev: Hold clocks_mutex while iterating clocks list
    
    We recently introduced a change to support devm clk lookups. That change
    introduced a code-path that used clk_find() without holding the
    'clocks_mutex'. Unfortunately, clk_find() iterates over the 'clocks'
    list and so we need to prevent the list from being modified at the same
    time. Do this by holding the mutex and checking to make sure it's held
    while iterating the list.
    
    Note, we don't really care if the lookup is freed after we find it with
    clk_find() because we're just doing a pointer comparison, but if we did
    care we would need to keep holding the mutex while we dereference the
    clk_lookup pointer.
    
    Fixes: 3eee6c7d119c ("clkdev: add managed clkdev lookup registration")
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Acked-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 8c4435c53f09..6e787cc9e5b9 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -46,6 +46,8 @@ static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 	if (con_id)
 		best_possible += 1;
 
+	lockdep_assert_held(&clocks_mutex);
+
 	list_for_each_entry(p, &clocks, node) {
 		match = 0;
 		if (p->dev_id) {
@@ -402,7 +404,10 @@ void devm_clk_release_clkdev(struct device *dev, const char *con_id,
 	struct clk_lookup *cl;
 	int rval;
 
+	mutex_lock(&clocks_mutex);
 	cl = clk_find(dev_id, con_id);
+	mutex_unlock(&clocks_mutex);
+
 	WARN_ON(!cl);
 	rval = devres_release(dev, devm_clkdev_release,
 			      devm_clk_match_clkdev, cl);

commit 5dc7e84268f53f08251abe1d388a019f55ddb077
Merge: fea0b0850aad cf13f2896807
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Mar 8 10:35:01 2019 -0800

    Merge branch 'clk-parent-rewrite' (early part) into clk-next
    
    * 'clk-parent-rewrite' (early part):
      clk: Move of_clk_*() APIs into clk.c from clkdev.c
      clk: Inform the core about consumer devices
      clk: Introduce of_clk_get_hw_from_clkspec()
      clk: core: clarify the check for runtime PM
      clk: Combine __clk_get() and __clk_create_clk()

commit 3f8e7e7247e0627b4f1d758d793041fe3032b6e3
Merge: 7e2570031a1a 60b8f0ddf1a9 d3236214e7de da392a5ab411 a9ca321716c8 df446f7e6ec0
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Mar 8 10:27:21 2019 -0800

    Merge branches 'clk-optional', 'clk-devm-clkdev-register', 'clk-allwinner', 'clk-meson' and 'clk-renesas' into clk-next
    
     - Add a {devm_}clk_get_optional() API
     - Add devm_clk_hw_register_clkdev() API to manage clkdev lookups
    
    * clk-optional:
      clk: Add (devm_)clk_get_optional() functions
      clk: Add comment about __of_clk_get_by_name() error values
    
    * clk-devm-clkdev-register:
      clk: clk-st: avoid clkdev lookup leak at remove
      clk: clk-max77686: Clean clkdev lookup leak and use devm
      clkdev: add managed clkdev lookup registration
    
    * clk-allwinner:
      clk: sunxi-ng: sun8i-a23: Enable PLL-MIPI LDOs when ungating it
    
    * clk-meson: (22 commits)
      clk: meson: meson8b: fix the naming of the APB clocks
      dt-bindings: clock: meson8b: add APB clock definition
      clk: meson: Add G12A AO Clock + Reset Controller
      dt-bindings: clk: add G12A AO Clock and Reset Bindings
      clk: meson: factorise meson64 peripheral clock controller drivers
      clk: meson: g12a: add peripheral clock controller
      dt-bindings: clk: meson: add g12a periph clock controller bindings
      clk: meson: pll: update driver for the g12a
      clk: meson: rework and clean drivers dependencies
      clk: meson: axg-audio does not require syscon
      clk: meson: use CONFIG_ARCH_MESON to enter meson clk directory
      clk: export some clk_hw function symbols for module drivers
      clk: meson: ao-clkc: claim clock controller input clocks from DT
      clk: meson: axg: claim clock controller input clock from DT
      clk: meson: gxbb: claim clock controller input clock from DT
      clk: meson: meson8b: add the GPU clock tree
      clk: meson: meson8b: use a separate clock table for Meson8
      clk: meson: axg-ao: add 32k generation subtree
      clk: meson: gxbb-ao: replace cec-32k with the dual divider
      clk: meson: add dual divider clock driver
      ...
    
    * clk-renesas:
      clk: renesas: r8a774a1: Fix LAST_DT_CORE_CLK
      clk: renesas: r8a774c0: Fix LAST_DT_CORE_CLK
      clk: renesas: r8a774c0: Add TMU clock
      clk: renesas: r8a77980: Add RPC clocks
      clk: renesas: rcar-gen3: Add RPC clocks
      clk: renesas: rcar-gen3: Add spinlock
      clk: renesas: rcar-gen3: Factor out cpg_reg_modify()
      clk: renesas: r8a774c0: Correct parent clock of DU
      clk: renesas: r8a774a1: Add missing CANFD clock
      clk: renesas: r8a774c0: Add missing CANFD clock

commit cf13f2896807d516df79d118d1e82f9d2db3c336
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Dec 19 15:09:14 2018 -0800

    clk: Move of_clk_*() APIs into clk.c from clkdev.c
    
    The API between clk.c and clkdev.c is purely getting the clk_hw
    structure (or the struct clk if it's not CCF) and then turning that
    struct clk_hw pointer into a struct clk pointer via clk_hw_create_clk().
    There's no need to complicate clkdev.c with these DT parsing details
    that are only relevant to the common clk framework. Move the DT parsing
    logic into the core framework and just expose the APIs to get a clk_hw
    pointer and convert it.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index f2f4f2afd28c..d3758bf4305c 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -27,66 +27,6 @@
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
-#if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
-static struct clk_hw *of_clk_get_hw(struct device_node *np,
-				    int index, const char *con_id)
-{
-	int ret;
-	struct clk_hw *hw;
-	struct of_phandle_args clkspec;
-
-	ret = of_parse_clkspec(np, index, con_id, &clkspec);
-	if (ret)
-		return ERR_PTR(ret);
-
-	hw = of_clk_get_hw_from_clkspec(&clkspec);
-	of_node_put(clkspec.np);
-
-	return hw;
-}
-
-static struct clk *__of_clk_get(struct device_node *np,
-				int index, const char *dev_id,
-				const char *con_id)
-{
-	struct clk_hw *hw = of_clk_get_hw(np, index, con_id);
-
-	return clk_hw_create_clk(NULL, hw, dev_id, con_id);
-}
-
-struct clk *of_clk_get(struct device_node *np, int index)
-{
-	return __of_clk_get(np, index, np->full_name, NULL);
-}
-EXPORT_SYMBOL(of_clk_get);
-
-/**
- * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node
- * @np: pointer to clock consumer node
- * @name: name of consumer's clock input, or NULL for the first clock reference
- *
- * This function parses the clocks and clock-names properties,
- * and uses them to look up the struct clk from the registered list of clock
- * providers.
- */
-struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
-{
-	if (!np)
-		return ERR_PTR(-ENOENT);
-
-	return __of_clk_get(np, -1, np->full_name, name);
-}
-EXPORT_SYMBOL(of_clk_get_by_name);
-
-#else /* defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK) */
-
-static struct clk_hw *of_clk_get_hw(struct device_node *np,
-				    int index, const char *con_id)
-{
-	return ERR_PTR(-ENOENT);
-}
-#endif
-
 /*
  * Find the correct struct clk for the device and connection ID.
  * We do slightly fuzzy matching here:

commit efa850487a6b6742699e3352d8562f5aba531ae7
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 08:34:16 2018 -0800

    clk: Inform the core about consumer devices
    
    We'd like to have a pointer to the device that's consuming a particular
    clk in the clk framework so we can link the consumer to the clk provider
    with a PM device link. Add a device argument to clk_hw_create_clk() for
    this so it can be used in subsequent patches to add and remove the link.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 5ebb2119c0b9..f2f4f2afd28c 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -51,7 +51,7 @@ static struct clk *__of_clk_get(struct device_node *np,
 {
 	struct clk_hw *hw = of_clk_get_hw(np, index, con_id);
 
-	return clk_hw_create_clk(hw, dev_id, con_id);
+	return clk_hw_create_clk(NULL, hw, dev_id, con_id);
 }
 
 struct clk *of_clk_get(struct device_node *np, int index)
@@ -130,7 +130,8 @@ static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 	return cl;
 }
 
-struct clk *clk_get_sys(const char *dev_id, const char *con_id)
+static struct clk *__clk_get_sys(struct device *dev, const char *dev_id,
+				 const char *con_id)
 {
 	struct clk_lookup *cl;
 	struct clk *clk = NULL;
@@ -141,7 +142,7 @@ struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 	if (!cl)
 		goto out;
 
-	clk = clk_hw_create_clk(cl->clk_hw, dev_id, con_id);
+	clk = clk_hw_create_clk(dev, cl->clk_hw, dev_id, con_id);
 	if (IS_ERR(clk))
 		cl = NULL;
 out:
@@ -149,6 +150,11 @@ struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 
 	return cl ? clk : ERR_PTR(-ENOENT);
 }
+
+struct clk *clk_get_sys(const char *dev_id, const char *con_id)
+{
+	return __clk_get_sys(NULL, dev_id, con_id);
+}
 EXPORT_SYMBOL(clk_get_sys);
 
 struct clk *clk_get(struct device *dev, const char *con_id)
@@ -159,10 +165,10 @@ struct clk *clk_get(struct device *dev, const char *con_id)
 	if (dev && dev->of_node) {
 		hw = of_clk_get_hw(dev->of_node, 0, con_id);
 		if (!IS_ERR(hw) || PTR_ERR(hw) == -EPROBE_DEFER)
-			return clk_hw_create_clk(hw, dev_id, con_id);
+			return clk_hw_create_clk(dev, hw, dev_id, con_id);
 	}
 
-	return clk_get_sys(dev_id, con_id);
+	return __clk_get_sys(dev, dev_id, con_id);
 }
 EXPORT_SYMBOL(clk_get);
 

commit 4472287a3b2f52f4aa53f294ccb74392dde4e07d
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Dec 19 10:59:55 2018 -0800

    clk: Introduce of_clk_get_hw_from_clkspec()
    
    We want to get struct clk_hw pointers from a DT clk specifier (i.e. a
    clocks property) so that we can find parent clks without searching for
    globally unique clk names. This should save time by avoiding the global
    string search for clks that are external to the clock controller
    providing the clk and let us move away from string comparisons in
    general.
    
    Introduce of_clk_get_hw_from_clkspec() which is largely the DT parsing
    part of finding clks implemented in clkdev.c and have that return a
    clk_hw pointer instead of converting that into a clk pointer. This lets
    us push up the clk pointer creation to the caller in clk_get() and
    avoids the need to push the dev_id and con_id throughout the DT parsing
    code.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index bdeaffc950ae..5ebb2119c0b9 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -28,69 +28,37 @@ static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
 #if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
-static struct clk *__of_clk_get(struct device_node *np, int index,
-			       const char *dev_id, const char *con_id)
+static struct clk_hw *of_clk_get_hw(struct device_node *np,
+				    int index, const char *con_id)
 {
+	int ret;
+	struct clk_hw *hw;
 	struct of_phandle_args clkspec;
-	struct clk *clk;
-	int rc;
 
-	rc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", index,
-					&clkspec);
-	if (rc)
-		return ERR_PTR(rc);
+	ret = of_parse_clkspec(np, index, con_id, &clkspec);
+	if (ret)
+		return ERR_PTR(ret);
 
-	clk = __of_clk_get_from_provider(&clkspec, dev_id, con_id);
+	hw = of_clk_get_hw_from_clkspec(&clkspec);
 	of_node_put(clkspec.np);
 
-	return clk;
+	return hw;
 }
 
-struct clk *of_clk_get(struct device_node *np, int index)
+static struct clk *__of_clk_get(struct device_node *np,
+				int index, const char *dev_id,
+				const char *con_id)
 {
-	return __of_clk_get(np, index, np->full_name, NULL);
+	struct clk_hw *hw = of_clk_get_hw(np, index, con_id);
+
+	return clk_hw_create_clk(hw, dev_id, con_id);
 }
-EXPORT_SYMBOL(of_clk_get);
 
-static struct clk *__of_clk_get_by_name(struct device_node *np,
-					const char *dev_id,
-					const char *name)
+struct clk *of_clk_get(struct device_node *np, int index)
 {
-	struct clk *clk = ERR_PTR(-ENOENT);
-
-	/* Walk up the tree of devices looking for a clock that matches */
-	while (np) {
-		int index = 0;
-
-		/*
-		 * For named clocks, first look up the name in the
-		 * "clock-names" property.  If it cannot be found, then
-		 * index will be an error code, and of_clk_get() will fail.
-		 */
-		if (name)
-			index = of_property_match_string(np, "clock-names", name);
-		clk = __of_clk_get(np, index, dev_id, name);
-		if (!IS_ERR(clk)) {
-			break;
-		} else if (name && index >= 0) {
-			if (PTR_ERR(clk) != -EPROBE_DEFER)
-				pr_err("ERROR: could not get clock %pOF:%s(%i)\n",
-					np, name ? name : "", index);
-			return clk;
-		}
-
-		/*
-		 * No matching clock found on this node.  If the parent node
-		 * has a "clock-ranges" property, then we can try one of its
-		 * clocks.
-		 */
-		np = np->parent;
-		if (np && !of_get_property(np, "clock-ranges", NULL))
-			break;
-	}
-
-	return clk;
+	return __of_clk_get(np, index, np->full_name, NULL);
 }
+EXPORT_SYMBOL(of_clk_get);
 
 /**
  * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node
@@ -106,15 +74,14 @@ struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
 	if (!np)
 		return ERR_PTR(-ENOENT);
 
-	return __of_clk_get_by_name(np, np->full_name, name);
+	return __of_clk_get(np, -1, np->full_name, name);
 }
 EXPORT_SYMBOL(of_clk_get_by_name);
 
 #else /* defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK) */
 
-static struct clk *__of_clk_get_by_name(struct device_node *np,
-					const char *dev_id,
-					const char *name)
+static struct clk_hw *of_clk_get_hw(struct device_node *np,
+				    int index, const char *con_id)
 {
 	return ERR_PTR(-ENOENT);
 }
@@ -187,12 +154,12 @@ EXPORT_SYMBOL(clk_get_sys);
 struct clk *clk_get(struct device *dev, const char *con_id)
 {
 	const char *dev_id = dev ? dev_name(dev) : NULL;
-	struct clk *clk;
+	struct clk_hw *hw;
 
 	if (dev && dev->of_node) {
-		clk = __of_clk_get_by_name(dev->of_node, dev_id, con_id);
-		if (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)
-			return clk;
+		hw = of_clk_get_hw(dev->of_node, 0, con_id);
+		if (!IS_ERR(hw) || PTR_ERR(hw) == -EPROBE_DEFER)
+			return clk_hw_create_clk(hw, dev_id, con_id);
 	}
 
 	return clk_get_sys(dev_id, con_id);

commit 1df4046a93e086f77d244ea47c21591b4acad3e2
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 08:32:04 2018 -0800

    clk: Combine __clk_get() and __clk_create_clk()
    
    The __clk_get() function is practically a private clk implementation
    detail now. No architecture defines it, and given that new code should
    be using the common clk framework there isn't a need for it to keep
    existing just to serve clkdev purposes. Let's fold it into the
    __clk_create_clk() function and make that a little more generic by
    renaming it to clk_hw_create_clk(). This will allow the framework to
    create a struct clk handle to a particular clk_hw pointer and link it up
    as a consumer wherever that's needed.
    
    Doing this also lets us get rid of the __clk_free_clk() API that had to
    be kept in sync with __clk_put(). Splitting that API up into the "link
    and unlink from consumer list" phase and "free the clk pointer" phase
    allows us to reuse that logic in a couple places, simplifying the code.
    
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 9ab3db8b3988..bdeaffc950ae 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -174,16 +174,9 @@ struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 	if (!cl)
 		goto out;
 
-	clk = __clk_create_clk(cl->clk_hw, dev_id, con_id);
+	clk = clk_hw_create_clk(cl->clk_hw, dev_id, con_id);
 	if (IS_ERR(clk))
-		goto out;
-
-	if (!__clk_get(clk)) {
-		__clk_free_clk(clk);
 		cl = NULL;
-		goto out;
-	}
-
 out:
 	mutex_unlock(&clocks_mutex);
 

commit 3eee6c7d119cd8563ad25898f94d6c1b514da548
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Fri Dec 7 13:09:39 2018 +0200

    clkdev: add managed clkdev lookup registration
    
    Clkdev registration lacks of managed registration functions and it
    seems few drivers do not drop clkdev lookups at exit. Add
    devm_clk_hw_register_clkdev and devm_clk_release_clkdev to ease lookup
    releasing at exit.
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 9ab3db8b3988..4621f8a91fc0 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -401,6 +401,23 @@ static struct clk_lookup *__clk_register_clkdev(struct clk_hw *hw,
 	return cl;
 }
 
+static int do_clk_register_clkdev(struct clk_hw *hw,
+	struct clk_lookup **cl, const char *con_id, const char *dev_id)
+{
+	if (IS_ERR(hw))
+		return PTR_ERR(hw);
+	/*
+	 * Since dev_id can be NULL, and NULL is handled specially, we must
+	 * pass it as either a NULL format string, or with "%s".
+	 */
+	if (dev_id)
+		*cl = __clk_register_clkdev(hw, con_id, "%s", dev_id);
+	else
+		*cl = __clk_register_clkdev(hw, con_id, NULL);
+
+	return *cl ? 0 : -ENOMEM;
+}
+
 /**
  * clk_register_clkdev - register one clock lookup for a struct clk
  * @clk: struct clk to associate with all clk_lookups
@@ -423,17 +440,8 @@ int clk_register_clkdev(struct clk *clk, const char *con_id,
 	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 
-	/*
-	 * Since dev_id can be NULL, and NULL is handled specially, we must
-	 * pass it as either a NULL format string, or with "%s".
-	 */
-	if (dev_id)
-		cl = __clk_register_clkdev(__clk_get_hw(clk), con_id, "%s",
-					   dev_id);
-	else
-		cl = __clk_register_clkdev(__clk_get_hw(clk), con_id, NULL);
-
-	return cl ? 0 : -ENOMEM;
+	return do_clk_register_clkdev(__clk_get_hw(clk), &cl, con_id,
+					      dev_id);
 }
 EXPORT_SYMBOL(clk_register_clkdev);
 
@@ -456,18 +464,75 @@ int clk_hw_register_clkdev(struct clk_hw *hw, const char *con_id,
 {
 	struct clk_lookup *cl;
 
-	if (IS_ERR(hw))
-		return PTR_ERR(hw);
+	return do_clk_register_clkdev(hw, &cl, con_id, dev_id);
+}
+EXPORT_SYMBOL(clk_hw_register_clkdev);
 
-	/*
-	 * Since dev_id can be NULL, and NULL is handled specially, we must
-	 * pass it as either a NULL format string, or with "%s".
-	 */
-	if (dev_id)
-		cl = __clk_register_clkdev(hw, con_id, "%s", dev_id);
-	else
-		cl = __clk_register_clkdev(hw, con_id, NULL);
+static void devm_clkdev_release(struct device *dev, void *res)
+{
+	clkdev_drop(*(struct clk_lookup **)res);
+}
 
-	return cl ? 0 : -ENOMEM;
+static int devm_clk_match_clkdev(struct device *dev, void *res, void *data)
+{
+	struct clk_lookup **l = res;
+
+	return *l == data;
 }
-EXPORT_SYMBOL(clk_hw_register_clkdev);
+
+/**
+ * devm_clk_release_clkdev - Resource managed clkdev lookup release
+ * @dev: device this lookup is bound
+ * @con_id: connection ID string on device
+ * @dev_id: format string describing device name
+ *
+ * Drop the clkdev lookup created with devm_clk_hw_register_clkdev.
+ * Normally this function will not need to be called and the resource
+ * management code will ensure that the resource is freed.
+ */
+void devm_clk_release_clkdev(struct device *dev, const char *con_id,
+			     const char *dev_id)
+{
+	struct clk_lookup *cl;
+	int rval;
+
+	cl = clk_find(dev_id, con_id);
+	WARN_ON(!cl);
+	rval = devres_release(dev, devm_clkdev_release,
+			      devm_clk_match_clkdev, cl);
+	WARN_ON(rval);
+}
+EXPORT_SYMBOL(devm_clk_release_clkdev);
+
+/**
+ * devm_clk_hw_register_clkdev - managed clk lookup registration for clk_hw
+ * @dev: device this lookup is bound
+ * @hw: struct clk_hw to associate with all clk_lookups
+ * @con_id: connection ID string on device
+ * @dev_id: format string describing device name
+ *
+ * con_id or dev_id may be NULL as a wildcard, just as in the rest of
+ * clkdev.
+ *
+ * To make things easier for mass registration, we detect error clk_hws
+ * from a previous clk_hw_register_*() call, and return the error code for
+ * those.  This is to permit this function to be called immediately
+ * after clk_hw_register_*().
+ */
+int devm_clk_hw_register_clkdev(struct device *dev, struct clk_hw *hw,
+				const char *con_id, const char *dev_id)
+{
+	int rval = -ENOMEM;
+	struct clk_lookup **cl;
+
+	cl = devres_alloc(devm_clkdev_release, sizeof(*cl), GFP_KERNEL);
+	if (cl) {
+		rval = do_clk_register_clkdev(hw, cl, con_id, dev_id);
+		if (!rval)
+			devres_add(dev, cl);
+		else
+			devres_free(cl);
+	}
+	return rval;
+}
+EXPORT_SYMBOL(devm_clk_hw_register_clkdev);

commit 5c56dfe63b6e7da3d9fd84a6c553ff4d2753dd1c
Author: Phil Edworthy <phil.edworthy@renesas.com>
Date:   Mon Dec 3 11:13:08 2018 +0000

    clk: Add comment about __of_clk_get_by_name() error values
    
    It's not immediately obvious from the code that failure to get a
    clock provider can return either -ENOENT or -EINVAL. Therefore, add
    a comment to highlight this.
    
    Signed-off-by: Phil Edworthy <phil.edworthy@renesas.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Russell King <linux@armlinux.org.uk>
    [sboyd@kernel.org: Fix comment to be proper C with ==]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 9ab3db8b3988..5284fd191cca 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -52,6 +52,12 @@ struct clk *of_clk_get(struct device_node *np, int index)
 }
 EXPORT_SYMBOL(of_clk_get);
 
+/*
+ * Beware the return values when np is valid, but no clock provider is found.
+ * If name == NULL, the function returns -ENOENT.
+ * If name != NULL, the function returns -EINVAL. This is because __of_clk_get()
+ * is called even if of_property_match_string() returns an error.
+ */
 static struct clk *__of_clk_get_by_name(struct device_node *np,
 					const char *dev_id,
 					const char *name)

commit 53ccb22b8d4a9293cf4249f3b526892810038fd3
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Jun 28 15:42:20 2018 +0100

    ARM: 8778/1: clkdev: don't call __of_clk_get_by_name() unnecessarily from clk_get()
    
    The way this function is implemented caused some confusion when
    converting the TI DaVinci platform to using the common clock framework.
    
    Current kernel supports booting DaVinci boards both in device tree as
    well as legacy, board-file mode. In the latter, we always end up
    calling clk_get_sys() as of_node is NULL and __of_clk_get_by_name()
    returns -ENOENT.
    
    It was not obvious at first glance how clk_get(dev, NULL) will work in
    board-file mode since we always call __of_clk_get_by_name(). Let's make
    it clearer by checking if of_node is NULL and skipping right to
    clk_get_sys().
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: David Lechner <david@lechnology.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 02fcee2012e0..9ab3db8b3988 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -196,7 +196,7 @@ struct clk *clk_get(struct device *dev, const char *con_id)
 	const char *dev_id = dev ? dev_name(dev) : NULL;
 	struct clk *clk;
 
-	if (dev) {
+	if (dev && dev->of_node) {
 		clk = __of_clk_get_by_name(dev->of_node, dev_id, con_id);
 		if (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)
 			return clk;

commit 76672e2e5b86d330e236eabe3ca3d471a581df57
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Jun 19 15:32:05 2018 +0100

    ARM: 8776/1: clkdev: Remove duplicated negative index check from __of_clk_get()
    
    __of_clk_get() calls of_parse_phandle_with_args(), which rejects
    negative indices since commit bd69f73f2c81eed9 ("of: Create function for
    counting number of phandles in a property").
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 7513411140b6..02fcee2012e0 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -35,9 +35,6 @@ static struct clk *__of_clk_get(struct device_node *np, int index,
 	struct clk *clk;
 	int rc;
 
-	if (index < 0)
-		return ERR_PTR(-EINVAL);
-
 	rc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", index,
 					&clkspec);
 	if (rc)

commit 0d4e3d005cb3c7b45463c91b4007d2b9f195879e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jan 2 15:47:07 2018 -0800

    clk: Prepare to remove asm-generic/clkdev.h
    
    Now that all the users of asm/clkdev.h have been replaced with
    the generic file we can get rid of the asm-generic file as well
    and implement that code directly where it's used.
    
    We only have one caller of __clkdev_alloc(), in clkdev.c so we
    can easily remove that and drop the include of asm/clkdev.h in
    linux/clkdev.h by putting the __clk_get/__clk_put inlines in
    their respective location.
    
    Cc: Russell King <linux@armlinux.org.uk>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 6b2f29df3f70..7513411140b6 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -256,7 +256,7 @@ vclkdev_alloc(struct clk_hw *hw, const char *con_id, const char *dev_fmt,
 {
 	struct clk_lookup_alloc *cla;
 
-	cla = __clkdev_alloc(sizeof(*cla));
+	cla = kzalloc(sizeof(*cla), GFP_KERNEL);
 	if (!cla)
 		return NULL;
 

commit 1667393126d7c51fad8b3cb9d3798e8e0367e2ec
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:42:52 2017 -0500

    clk: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: "Emilio López" <emilio@elopez.com.ar>
    Cc: Peter De Schrijver <pdeschrijver@nvidia.com>
    Cc: Prashant Gaikwad <pgaikwad@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: James Liao <jamesjj.liao@mediatek.com>
    Acked-by: Alexandre TORGUE <alexandre.torgue@st.com>
    Reviewed-by: Matthias Brugger <matthias.bgg@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index bb8a77a5985f..6b2f29df3f70 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -77,8 +77,8 @@ static struct clk *__of_clk_get_by_name(struct device_node *np,
 			break;
 		} else if (name && index >= 0) {
 			if (PTR_ERR(clk) != -EPROBE_DEFER)
-				pr_err("ERROR: could not get clock %s:%s(%i)\n",
-					np->full_name, name ? name : "", index);
+				pr_err("ERROR: could not get clock %pOF:%s(%i)\n",
+					np, name ? name : "", index);
 			return clk;
 		}
 

commit 9388093db44356af911adf3d355b7544a13a63cd
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Nov 22 12:33:11 2016 +0100

    ARM: 8631/1: clkdev: Detect errors in clk_hw_register_clkdev() for mass registration
    
    Unlike clk_register_clkdev(), clk_hw_register_clkdev() doesn't check for
    passed error objects from a previous registration call. Hence the caller
    of clk_hw_register_*() has to check for errors before calling
    clk_hw_register_clkdev*().
    
    Make clk_hw_register_clkdev() more similar to clk_register_clkdev() by
    adding this error check, removing the burden from callers that do mass
    registration.
    
    Fixes: e4f1b49bda6d6aa2 ("clkdev: Add clk_hw based registration APIs")
    Fixes: 944b9a41e004534f ("clk: ls1x: Migrate to clk_hw based OF and registration APIs")
    Fixes: 44ce9a9ae977736f ("MIPS: TXx9: Convert to Common Clock Framework")
    Fixes: f48d947a162dfa9d ("clk: clps711x: Migrate to clk_hw based OF and registration APIs")
    Fixes: b4626a7f489238a5 ("CLK: Add Loongson1C clock support")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 97ae60fa1584..bb8a77a5985f 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -448,12 +448,20 @@ EXPORT_SYMBOL(clk_register_clkdev);
  *
  * con_id or dev_id may be NULL as a wildcard, just as in the rest of
  * clkdev.
+ *
+ * To make things easier for mass registration, we detect error clk_hws
+ * from a previous clk_hw_register_*() call, and return the error code for
+ * those.  This is to permit this function to be called immediately
+ * after clk_hw_register_*().
  */
 int clk_hw_register_clkdev(struct clk_hw *hw, const char *con_id,
 	const char *dev_id)
 {
 	struct clk_lookup *cl;
 
+	if (IS_ERR(hw))
+		return PTR_ERR(hw);
+
 	/*
 	 * Since dev_id can be NULL, and NULL is handled specially, we must
 	 * pass it as either a NULL format string, or with "%s".

commit bd721ea73e1f965569b40620538c942001f76294
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Aug 2 14:03:33 2016 -0700

    treewide: replace obsolete _refok by __ref
    
    There was only one use of __initdata_refok and __exit_refok
    
    __init_refok was used 46 times against 82 for __ref.
    
    Those definitions are obsolete since commit 312b1485fb50 ("Introduce new
    section reference annotations tags: __ref, __refdata, __refconst")
    
    This patch removes the following compatibility definitions and replaces
    them treewide.
    
    /* compatibility defines */
    #define __init_refok     __ref
    #define __initdata_refok __refdata
    #define __exit_refok     __ref
    
    I can also provide separate patches if necessary.
    (One patch per tree and check in 1 month or 2 to remove old definitions)
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/1466796271-3043-1-git-send-email-fabf@skynet.be
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 89cc700fbc37..97ae60fa1584 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -250,7 +250,7 @@ struct clk_lookup_alloc {
 	char	con_id[MAX_CON_ID];
 };
 
-static struct clk_lookup * __init_refok
+static struct clk_lookup * __ref
 vclkdev_alloc(struct clk_hw *hw, const char *con_id, const char *dev_fmt,
 	va_list ap)
 {
@@ -287,7 +287,7 @@ vclkdev_create(struct clk_hw *hw, const char *con_id, const char *dev_fmt,
 	return cl;
 }
 
-struct clk_lookup * __init_refok
+struct clk_lookup * __ref
 clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
 {
 	struct clk_lookup *cl;

commit e4f1b49bda6d6aa2e13730ff7eeccbe65a6271f1
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Feb 8 14:59:49 2016 -0800

    clkdev: Add clk_hw based registration APIs
    
    Now that we have a clk registration API that doesn't return
    struct clks, we need to have some way to hand out struct clks via
    the clk_get() APIs that doesn't involve associating struct clk
    pointers with a struct clk_lookup. Luckily, clkdev already
    operates on struct clk_hw pointers, except for the registration
    facing APIs where it converts struct clk pointers into struct
    clk_hw pointers almost immediately.
    
    Let's add clk_hw based registration APIs so that we can skip the
    conversion step and provide a way for clk provider drivers to
    operate exclusively on clk_hw structs. This way we clearly
    split the API between consumers and providers.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index ae8e40a82d34..89cc700fbc37 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -301,6 +301,20 @@ clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
 }
 EXPORT_SYMBOL(clkdev_alloc);
 
+struct clk_lookup *
+clkdev_hw_alloc(struct clk_hw *hw, const char *con_id, const char *dev_fmt, ...)
+{
+	struct clk_lookup *cl;
+	va_list ap;
+
+	va_start(ap, dev_fmt);
+	cl = vclkdev_alloc(hw, con_id, dev_fmt, ap);
+	va_end(ap);
+
+	return cl;
+}
+EXPORT_SYMBOL(clkdev_hw_alloc);
+
 /**
  * clkdev_create - allocate and add a clkdev lookup structure
  * @clk: struct clk to associate with all clk_lookups
@@ -324,6 +338,29 @@ struct clk_lookup *clkdev_create(struct clk *clk, const char *con_id,
 }
 EXPORT_SYMBOL_GPL(clkdev_create);
 
+/**
+ * clkdev_hw_create - allocate and add a clkdev lookup structure
+ * @hw: struct clk_hw to associate with all clk_lookups
+ * @con_id: connection ID string on device
+ * @dev_fmt: format string describing device name
+ *
+ * Returns a clk_lookup structure, which can be later unregistered and
+ * freed.
+ */
+struct clk_lookup *clkdev_hw_create(struct clk_hw *hw, const char *con_id,
+	const char *dev_fmt, ...)
+{
+	struct clk_lookup *cl;
+	va_list ap;
+
+	va_start(ap, dev_fmt);
+	cl = vclkdev_create(hw, con_id, dev_fmt, ap);
+	va_end(ap);
+
+	return cl;
+}
+EXPORT_SYMBOL_GPL(clkdev_hw_create);
+
 int clk_add_alias(const char *alias, const char *alias_dev_name,
 	const char *con_id, struct device *dev)
 {
@@ -402,3 +439,30 @@ int clk_register_clkdev(struct clk *clk, const char *con_id,
 	return cl ? 0 : -ENOMEM;
 }
 EXPORT_SYMBOL(clk_register_clkdev);
+
+/**
+ * clk_hw_register_clkdev - register one clock lookup for a struct clk_hw
+ * @hw: struct clk_hw to associate with all clk_lookups
+ * @con_id: connection ID string on device
+ * @dev_id: format string describing device name
+ *
+ * con_id or dev_id may be NULL as a wildcard, just as in the rest of
+ * clkdev.
+ */
+int clk_hw_register_clkdev(struct clk_hw *hw, const char *con_id,
+	const char *dev_id)
+{
+	struct clk_lookup *cl;
+
+	/*
+	 * Since dev_id can be NULL, and NULL is handled specially, we must
+	 * pass it as either a NULL format string, or with "%s".
+	 */
+	if (dev_id)
+		cl = __clk_register_clkdev(hw, con_id, "%s", dev_id);
+	else
+		cl = __clk_register_clkdev(hw, con_id, NULL);
+
+	return cl ? 0 : -ENOMEM;
+}
+EXPORT_SYMBOL(clk_hw_register_clkdev);

commit a14b9e0512404ed7d4415b888dc9f1f9785a4fa3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 5 16:40:47 2016 -0800

    clkdev: Remove clk_register_clkdevs()
    
    Now that we've converted the only caller over to another clkdev
    API, remove this one.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index eb20b941154b..ae8e40a82d34 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -402,30 +402,3 @@ int clk_register_clkdev(struct clk *clk, const char *con_id,
 	return cl ? 0 : -ENOMEM;
 }
 EXPORT_SYMBOL(clk_register_clkdev);
-
-/**
- * clk_register_clkdevs - register a set of clk_lookup for a struct clk
- * @clk: struct clk to associate with all clk_lookups
- * @cl: array of clk_lookup structures with con_id and dev_id pre-initialized
- * @num: number of clk_lookup structures to register
- *
- * To make things easier for mass registration, we detect error clks
- * from a previous clk_register() call, and return the error code for
- * those.  This is to permit this function to be called immediately
- * after clk_register().
- */
-int clk_register_clkdevs(struct clk *clk, struct clk_lookup *cl, size_t num)
-{
-	unsigned i;
-
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-
-	for (i = 0; i < num; i++, cl++) {
-		cl->clk_hw = __clk_get_hw(clk);
-		__clkdev_add(cl);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(clk_register_clkdevs);

commit 416dd13ad620a14fbabe5d73584b12e07ce8d02e
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jan 26 01:21:26 2016 +0100

    ARM: 8503/1: clk_register_clkdev: remove format string interface
    
    Many callers either use NULL or const strings for the third argument of
    clk_register_clkdev. For those that do not and use a non-const string,
    this is a risk for format strings being accidentally processed (for
    example in device names). As this interface is already used as if it
    weren't a format string (prints nothing when NULL), and there are zero
    users of the format strings, remove the format string interface to make
    sure format strings will not leak into the clkdev.
    
    $ git grep '\bclk_register_clkdev\b' | grep % | wc -l
    0
    
    Unfortunately, all the internals expect a va_list even though they treat
    a NULL format string as special. To deal with this, we must pass either
    (..., "%s", string) or (..., NULL) so that a the va_list will be created
    correctly (passing the name as an argument, not as a format string).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 779b6ff0c7ad..eb20b941154b 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -353,11 +353,25 @@ void clkdev_drop(struct clk_lookup *cl)
 }
 EXPORT_SYMBOL(clkdev_drop);
 
+static struct clk_lookup *__clk_register_clkdev(struct clk_hw *hw,
+						const char *con_id,
+						const char *dev_id, ...)
+{
+	struct clk_lookup *cl;
+	va_list ap;
+
+	va_start(ap, dev_id);
+	cl = vclkdev_create(hw, con_id, dev_id, ap);
+	va_end(ap);
+
+	return cl;
+}
+
 /**
  * clk_register_clkdev - register one clock lookup for a struct clk
  * @clk: struct clk to associate with all clk_lookups
  * @con_id: connection ID string on device
- * @dev_id: format string describing device name
+ * @dev_id: string describing device name
  *
  * con_id or dev_id may be NULL as a wildcard, just as in the rest of
  * clkdev.
@@ -368,17 +382,22 @@ EXPORT_SYMBOL(clkdev_drop);
  * after clk_register().
  */
 int clk_register_clkdev(struct clk *clk, const char *con_id,
-	const char *dev_fmt, ...)
+	const char *dev_id)
 {
 	struct clk_lookup *cl;
-	va_list ap;
 
 	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 
-	va_start(ap, dev_fmt);
-	cl = vclkdev_create(__clk_get_hw(clk), con_id, dev_fmt, ap);
-	va_end(ap);
+	/*
+	 * Since dev_id can be NULL, and NULL is handled specially, we must
+	 * pass it as either a NULL format string, or with "%s".
+	 */
+	if (dev_id)
+		cl = __clk_register_clkdev(__clk_get_hw(clk), con_id, "%s",
+					   dev_id);
+	else
+		cl = __clk_register_clkdev(__clk_get_hw(clk), con_id, NULL);
 
 	return cl ? 0 : -ENOMEM;
 }

commit 625faa6a720d26fc0db9e20b48dc0dfe4c8d8ddf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Oct 20 11:49:44 2015 +0100

    clkdev: fix clk_add_alias() with a NULL alias device name
    
    clk_add_alias() was not correctly handling the case where alias_dev_name
    was NULL: rather than producing an entry with a NULL dev_id pointer,
    it would produce a device name of (null).  Fix this.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 2568999835d7 ("clkdev: add clkdev_create() helper")
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index c0eaf0973bd2..779b6ff0c7ad 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -333,7 +333,8 @@ int clk_add_alias(const char *alias, const char *alias_dev_name,
 	if (IS_ERR(r))
 		return PTR_ERR(r);
 
-	l = clkdev_create(r, alias, "%s", alias_dev_name);
+	l = clkdev_create(r, alias, alias_dev_name ? "%s" : NULL,
+			  alias_dev_name);
 	clk_put(r);
 
 	return l ? 0 : -ENODEV;

commit 2568999835d7797afce3dcc3a3f368051ffcaf1f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Mar 2 15:40:29 2015 +0000

    clkdev: add clkdev_create() helper
    
    Add a helper to allocate and add a clk_lookup structure.  This can not
    only be used in several places in clkdev.c to simplify the code, but
    more importantly, can be used by callers of the clkdev code to simplify
    their clkdev creation and registration.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index e112e13af760..c0eaf0973bd2 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -274,6 +274,19 @@ vclkdev_alloc(struct clk_hw *hw, const char *con_id, const char *dev_fmt,
 	return &cla->cl;
 }
 
+static struct clk_lookup *
+vclkdev_create(struct clk_hw *hw, const char *con_id, const char *dev_fmt,
+	va_list ap)
+{
+	struct clk_lookup *cl;
+
+	cl = vclkdev_alloc(hw, con_id, dev_fmt, ap);
+	if (cl)
+		__clkdev_add(cl);
+
+	return cl;
+}
+
 struct clk_lookup * __init_refok
 clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
 {
@@ -288,6 +301,29 @@ clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
 }
 EXPORT_SYMBOL(clkdev_alloc);
 
+/**
+ * clkdev_create - allocate and add a clkdev lookup structure
+ * @clk: struct clk to associate with all clk_lookups
+ * @con_id: connection ID string on device
+ * @dev_fmt: format string describing device name
+ *
+ * Returns a clk_lookup structure, which can be later unregistered and
+ * freed.
+ */
+struct clk_lookup *clkdev_create(struct clk *clk, const char *con_id,
+	const char *dev_fmt, ...)
+{
+	struct clk_lookup *cl;
+	va_list ap;
+
+	va_start(ap, dev_fmt);
+	cl = vclkdev_create(__clk_get_hw(clk), con_id, dev_fmt, ap);
+	va_end(ap);
+
+	return cl;
+}
+EXPORT_SYMBOL_GPL(clkdev_create);
+
 int clk_add_alias(const char *alias, const char *alias_dev_name,
 	const char *con_id, struct device *dev)
 {
@@ -297,12 +333,10 @@ int clk_add_alias(const char *alias, const char *alias_dev_name,
 	if (IS_ERR(r))
 		return PTR_ERR(r);
 
-	l = clkdev_alloc(r, alias, alias_dev_name);
+	l = clkdev_create(r, alias, "%s", alias_dev_name);
 	clk_put(r);
-	if (!l)
-		return -ENODEV;
-	clkdev_add(l);
-	return 0;
+
+	return l ? 0 : -ENODEV;
 }
 EXPORT_SYMBOL(clk_add_alias);
 
@@ -342,15 +376,10 @@ int clk_register_clkdev(struct clk *clk, const char *con_id,
 		return PTR_ERR(clk);
 
 	va_start(ap, dev_fmt);
-	cl = vclkdev_alloc(__clk_get_hw(clk), con_id, dev_fmt, ap);
+	cl = vclkdev_create(__clk_get_hw(clk), con_id, dev_fmt, ap);
 	va_end(ap);
 
-	if (!cl)
-		return -ENOMEM;
-
-	clkdev_add(cl);
-
-	return 0;
+	return cl ? 0 : -ENOMEM;
 }
 EXPORT_SYMBOL(clk_register_clkdev);
 

commit b3d8d7e89fab374d731dfb46fe048f09766ca9c8
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Mar 9 10:43:04 2015 +0000

    clkdev: const-ify connection id to clk_add_alias()
    
    The connection id is only passed to clk_get() which is already const.
    Const-ify this argument too.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 04b59ad6d852..e112e13af760 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -288,10 +288,10 @@ clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
 }
 EXPORT_SYMBOL(clkdev_alloc);
 
-int clk_add_alias(const char *alias, const char *alias_dev_name, char *id,
-	struct device *dev)
+int clk_add_alias(const char *alias, const char *alias_dev_name,
+	const char *con_id, struct device *dev)
 {
-	struct clk *r = clk_get(dev, id);
+	struct clk *r = clk_get(dev, con_id);
 	struct clk_lookup *l;
 
 	if (IS_ERR(r))

commit fba3acd961ee167a5ffe4c094deccb7d99a0e963
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Mar 10 14:34:00 2015 +0000

    clkdev: drop __init from clkdev_add_table()
    
    We want to be able to call clkdev_add_table() from non-init code, so we
    need to drop the __init marker from it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 1bb120a3855f..04b59ad6d852 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -230,7 +230,7 @@ void clkdev_add(struct clk_lookup *cl)
 }
 EXPORT_SYMBOL(clkdev_add);
 
-void __init clkdev_add_table(struct clk_lookup *cl, size_t num)
+void clkdev_add_table(struct clk_lookup *cl, size_t num)
 {
 	mutex_lock(&clocks_mutex);
 	while (num--) {

commit d5622a9c13752be46e6fcde9d31391ce0bb0598b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Mar 2 15:45:41 2015 +0000

    clkdev: use clk_hw internally
    
    clk_add_alias() calls clk_get() followed by clk_put() but in between
    those two calls it saves away the struct clk pointer to a clk_lookup
    structure. This leaves the 'clk' member of the clk_lookup pointing at
    freed memory on configurations where CONFIG_COMMON_CLK=y. This is a
    problem because clk_get_sys() will eventually try to dereference the
    freed pointer by calling __clk_get_hw() on it. Fix this by saving away
    the struct clk_hw pointer instead of the struct clk pointer so that when
    we try to create a per-user struct clk in clk_get_sys() we don't
    dereference a junk pointer.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 1fcb6ef2cdac..1bb120a3855f 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -177,7 +177,7 @@ struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 	if (!cl)
 		goto out;
 
-	clk = __clk_create_clk(__clk_get_hw(cl->clk), dev_id, con_id);
+	clk = __clk_create_clk(cl->clk_hw, dev_id, con_id);
 	if (IS_ERR(clk))
 		goto out;
 
@@ -215,18 +215,26 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_put);
 
-void clkdev_add(struct clk_lookup *cl)
+static void __clkdev_add(struct clk_lookup *cl)
 {
 	mutex_lock(&clocks_mutex);
 	list_add_tail(&cl->node, &clocks);
 	mutex_unlock(&clocks_mutex);
 }
+
+void clkdev_add(struct clk_lookup *cl)
+{
+	if (!cl->clk_hw)
+		cl->clk_hw = __clk_get_hw(cl->clk);
+	__clkdev_add(cl);
+}
 EXPORT_SYMBOL(clkdev_add);
 
 void __init clkdev_add_table(struct clk_lookup *cl, size_t num)
 {
 	mutex_lock(&clocks_mutex);
 	while (num--) {
+		cl->clk_hw = __clk_get_hw(cl->clk);
 		list_add_tail(&cl->node, &clocks);
 		cl++;
 	}
@@ -243,7 +251,7 @@ struct clk_lookup_alloc {
 };
 
 static struct clk_lookup * __init_refok
-vclkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt,
+vclkdev_alloc(struct clk_hw *hw, const char *con_id, const char *dev_fmt,
 	va_list ap)
 {
 	struct clk_lookup_alloc *cla;
@@ -252,7 +260,7 @@ vclkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt,
 	if (!cla)
 		return NULL;
 
-	cla->cl.clk = clk;
+	cla->cl.clk_hw = hw;
 	if (con_id) {
 		strlcpy(cla->con_id, con_id, sizeof(cla->con_id));
 		cla->cl.con_id = cla->con_id;
@@ -273,7 +281,7 @@ clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
 	va_list ap;
 
 	va_start(ap, dev_fmt);
-	cl = vclkdev_alloc(clk, con_id, dev_fmt, ap);
+	cl = vclkdev_alloc(__clk_get_hw(clk), con_id, dev_fmt, ap);
 	va_end(ap);
 
 	return cl;
@@ -334,7 +342,7 @@ int clk_register_clkdev(struct clk *clk, const char *con_id,
 		return PTR_ERR(clk);
 
 	va_start(ap, dev_fmt);
-	cl = vclkdev_alloc(clk, con_id, dev_fmt, ap);
+	cl = vclkdev_alloc(__clk_get_hw(clk), con_id, dev_fmt, ap);
 	va_end(ap);
 
 	if (!cl)
@@ -365,8 +373,8 @@ int clk_register_clkdevs(struct clk *clk, struct clk_lookup *cl, size_t num)
 		return PTR_ERR(clk);
 
 	for (i = 0; i < num; i++, cl++) {
-		cl->clk = clk;
-		clkdev_add(cl);
+		cl->clk_hw = __clk_get_hw(clk);
+		__clkdev_add(cl);
 	}
 
 	return 0;

commit 306c342f9cb1f573af57a6afd1b3549aa97b9281
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Feb 5 15:39:11 2015 -0800

    clk: Replace of_clk_get_by_clkspec() with of_clk_get_from_provider()
    
    of_clk_get_by_clkspec() has the same function signature as
    of_clk_get_from_provider()
    
     struct clk *of_clk_get_by_clkspec(struct of_phandle_args
     *clkspec)
     struct clk *of_clk_get_from_provider(struct of_phandle_args
     *clkspec)
    
    except of_clk_get_by_clkspec() checks to make sure clkspec is not
    NULL. Let's remove of_clk_get_by_clkspec() and replace the
    callers of it (clkconf.c) with of_clk_get_from_provider().
    
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 043fd3633373..1fcb6ef2cdac 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -28,34 +28,6 @@ static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
 #if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
-
-static struct clk *__of_clk_get_by_clkspec(struct of_phandle_args *clkspec,
-					 const char *dev_id, const char *con_id)
-{
-	struct clk *clk;
-
-	if (!clkspec)
-		return ERR_PTR(-EINVAL);
-
-	of_clk_lock();
-	clk = __of_clk_get_from_provider(clkspec, dev_id, con_id);
-	of_clk_unlock();
-	return clk;
-}
-
-/**
- * of_clk_get_by_clkspec() - Lookup a clock form a clock provider
- * @clkspec: pointer to a clock specifier data structure
- *
- * This function looks up a struct clk from the registered list of clock
- * providers, an input is a clock specifier data structure as returned
- * from the of_parse_phandle_with_args() function call.
- */
-struct clk *of_clk_get_by_clkspec(struct of_phandle_args *clkspec)
-{
-	return __of_clk_get_by_clkspec(clkspec, NULL, __func__);
-}
-
 static struct clk *__of_clk_get(struct device_node *np, int index,
 			       const char *dev_id, const char *con_id)
 {
@@ -71,7 +43,7 @@ static struct clk *__of_clk_get(struct device_node *np, int index,
 	if (rc)
 		return ERR_PTR(rc);
 
-	clk = __of_clk_get_by_clkspec(&clkspec, dev_id, con_id);
+	clk = __of_clk_get_from_provider(&clkspec, dev_id, con_id);
 	of_node_put(clkspec.np);
 
 	return clk;

commit 73e0e496afdac9a5190eb3b9c51fdfebcc14ebd4
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 6 11:42:43 2015 -0800

    clkdev: Always allocate a struct clk and call __clk_get() w/ CCF
    
    of_clk_get_by_clkspec() returns a struct clk pointer but it
    doesn't create a new handle for the consumers when we're using
    the common clock framework. Instead it just returns whatever the
    clk provider hands out. When the consumers go to call clk_put()
    we get an Oops.
    
    Unable to handle kernel paging request at virtual address 00200200
    pgd = c0004000
    [00200200] *pgd=00000000
    Internal error: Oops: 805 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.19.0-rc1-00104-ga251361a-dirty #992
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    task: ee00b000 ti: ee088000 task.ti: ee088000
    PC is at __clk_put+0x24/0xd0
    LR is at clk_prepare_lock+0xc/0xec
    pc : [<c03eef38>]    lr : [<c03ec1f4>]    psr: 20000153
    sp : ee089de8  ip : 00000000  fp : 00000000
    r10: ee02f480  r9 : 00000001  r8 : 00000000
    r7 : ee031cc0  r6 : ee089e08  r5 : 00000000  r4 : ee02f480
    r3 : 00100100  r2 : 00200200  r1 : 0000091e  r0 : 00000001
    Flags: nzCv  IRQs on  FIQs off  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c5387d  Table: 4000404a  DAC: 00000015
    Process swapper/0 (pid: 1, stack limit = 0xee088238)
    Stack: (0xee089de8 to 0xee08a000)
    9de0:                   ee7c8f14 c03f0ec8 ee089e08 00000000 c0718dc8 00000001
    9e00: 00000000 c04ee0f0 ee7e0844 00000001 00000181 c04edb58 ee2bd320 00000000
    9e20: 00000000 c011dc5c ee16a1e0 00000000 00000000 c0718dc8 ee16a1e0 ee2bd1e0
    9e40: c0641740 ee16a1e0 00000000 ee2bd320 c0718dc8 ee1d3e10 ee1d3e10 00000000
    9e60: c0769a88 00000000 c0718dc8 00000000 00000000 c02c3124 c02c310c ee1d3e10
    9e80: c07b4eec 00000000 c0769a88 c02c1d0c ee1d3e10 c0769a88 ee1d3e44 00000000
    9ea0: c07091dc c02c1eb8 00000000 c0769a88 c02c1e2c c02c0544 ee005478 ee1676c0
    9ec0: c0769a88 ee3a4e80 c0760ce8 c02c150c c0669b90 c0769a88 c0746cd8 c0769a88
    9ee0: c0746cd8 ee2bc4c0 c0778c00 c02c24e0 00000000 c0746cd8 c0746cd8 c07091f0
    9f00: 00000000 c0008944 c04f405c 00000025 ee00b000 60000153 c074ab00 00000000
    9f20: 00000000 c074ab90 60000153 00000000 ef7fca5d c050860c 000000b6 c0036b88
    9f40: c065ecc4 c06bc728 00000006 00000006 c074ab30 ef7fca40 c0739bdc 00000006
    9f60: c0718dbc c0778c00 000000b6 c0718dc8 c06ed598 c06edd64 00000006 00000006
    9f80: c06ed598 c003b438 00000000 c04e64f4 00000000 00000000 00000000 00000000
    9fa0: 00000000 c04e64fc 00000000 c000e838 00000000 00000000 00000000 00000000
    9fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    9fe0: 00000000 00000000 00000000 00000000 00000013 00000000 c0c0c0c0 c0c0c0c0
    [<c03eef38>] (__clk_put) from [<c03f0ec8>] (of_clk_set_defaults+0xe0/0x2c0)
    [<c03f0ec8>] (of_clk_set_defaults) from [<c02c3124>] (platform_drv_probe+0x18/0xa4)
    [<c02c3124>] (platform_drv_probe) from [<c02c1d0c>] (driver_probe_device+0x10c/0x22c)
    [<c02c1d0c>] (driver_probe_device) from [<c02c1eb8>] (__driver_attach+0x8c/0x90)
    [<c02c1eb8>] (__driver_attach) from [<c02c0544>] (bus_for_each_dev+0x54/0x88)
    [<c02c0544>] (bus_for_each_dev) from [<c02c150c>] (bus_add_driver+0xd4/0x1d0)
    [<c02c150c>] (bus_add_driver) from [<c02c24e0>] (driver_register+0x78/0xf4)
    [<c02c24e0>] (driver_register) from [<c07091f0>] (fimc_md_init+0x14/0x30)
    [<c07091f0>] (fimc_md_init) from [<c0008944>] (do_one_initcall+0x80/0x1d0)
    [<c0008944>] (do_one_initcall) from [<c06edd64>] (kernel_init_freeable+0x108/0x1d4)
    [<c06edd64>] (kernel_init_freeable) from [<c04e64fc>] (kernel_init+0x8/0xec)
    [<c04e64fc>] (kernel_init) from [<c000e838>] (ret_from_fork+0x14/0x3c)
    Code: ebfff4ae e5943014 e5942018 e3530000 (e5823000)
    
    Let's create a per-user handle here so that clk_put() can
    properly unlink it and free the handle. Now that we allocate a
    clk structure here we need to free it if __clk_get() fails so
    bury the __clk_get() call in __of_clk_get_from_provider(). We
    need to handle the same problem in clk_get_sys() so export
    __clk_free_clk() to clkdev.c and do the same thing, except let's
    use a union to make this code #ifdef free.
    
    This fixes the above crash, properly calls __clk_get() when
    of_clk_get_from_provider() is called, and cleans up the clk
    structure on the error path of clk_get_sys().
    
    Fixes: 035a61c314eb "clk: Make clk API return per-user struct clk instances"
    Reported-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Reported-by: Alban Browaeys <alban.browaeys@gmail.com>
    Tested-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Tested-by: Alban Browaeys <prahal@yahoo.com>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 29a1ab7af4b8..043fd3633373 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -29,6 +29,20 @@ static DEFINE_MUTEX(clocks_mutex);
 
 #if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
 
+static struct clk *__of_clk_get_by_clkspec(struct of_phandle_args *clkspec,
+					 const char *dev_id, const char *con_id)
+{
+	struct clk *clk;
+
+	if (!clkspec)
+		return ERR_PTR(-EINVAL);
+
+	of_clk_lock();
+	clk = __of_clk_get_from_provider(clkspec, dev_id, con_id);
+	of_clk_unlock();
+	return clk;
+}
+
 /**
  * of_clk_get_by_clkspec() - Lookup a clock form a clock provider
  * @clkspec: pointer to a clock specifier data structure
@@ -39,22 +53,11 @@ static DEFINE_MUTEX(clocks_mutex);
  */
 struct clk *of_clk_get_by_clkspec(struct of_phandle_args *clkspec)
 {
-	struct clk *clk;
-
-	if (!clkspec)
-		return ERR_PTR(-EINVAL);
-
-	of_clk_lock();
-	clk = __of_clk_get_from_provider(clkspec);
-
-	if (!IS_ERR(clk) && !__clk_get(clk))
-		clk = ERR_PTR(-ENOENT);
-
-	of_clk_unlock();
-	return clk;
+	return __of_clk_get_by_clkspec(clkspec, NULL, __func__);
 }
 
-static struct clk *__of_clk_get(struct device_node *np, int index)
+static struct clk *__of_clk_get(struct device_node *np, int index,
+			       const char *dev_id, const char *con_id)
 {
 	struct of_phandle_args clkspec;
 	struct clk *clk;
@@ -68,7 +71,7 @@ static struct clk *__of_clk_get(struct device_node *np, int index)
 	if (rc)
 		return ERR_PTR(rc);
 
-	clk = of_clk_get_by_clkspec(&clkspec);
+	clk = __of_clk_get_by_clkspec(&clkspec, dev_id, con_id);
 	of_node_put(clkspec.np);
 
 	return clk;
@@ -76,12 +79,7 @@ static struct clk *__of_clk_get(struct device_node *np, int index)
 
 struct clk *of_clk_get(struct device_node *np, int index)
 {
-	struct clk *clk = __of_clk_get(np, index);
-
-	if (!IS_ERR(clk))
-		clk = __clk_create_clk(__clk_get_hw(clk), np->full_name, NULL);
-
-	return clk;
+	return __of_clk_get(np, index, np->full_name, NULL);
 }
 EXPORT_SYMBOL(of_clk_get);
 
@@ -102,12 +100,10 @@ static struct clk *__of_clk_get_by_name(struct device_node *np,
 		 */
 		if (name)
 			index = of_property_match_string(np, "clock-names", name);
-		clk = __of_clk_get(np, index);
+		clk = __of_clk_get(np, index, dev_id, name);
 		if (!IS_ERR(clk)) {
-			clk = __clk_create_clk(__clk_get_hw(clk), dev_id, name);
 			break;
-		}
-		else if (name && index >= 0) {
+		} else if (name && index >= 0) {
 			if (PTR_ERR(clk) != -EPROBE_DEFER)
 				pr_err("ERROR: could not get clock %s:%s(%i)\n",
 					np->full_name, name ? name : "", index);
@@ -209,17 +205,16 @@ struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 	if (!cl)
 		goto out;
 
-	if (!__clk_get(cl->clk)) {
+	clk = __clk_create_clk(__clk_get_hw(cl->clk), dev_id, con_id);
+	if (IS_ERR(clk))
+		goto out;
+
+	if (!__clk_get(clk)) {
+		__clk_free_clk(clk);
 		cl = NULL;
 		goto out;
 	}
 
-#if defined(CONFIG_COMMON_CLK)
-	clk = __clk_create_clk(__clk_get_hw(cl->clk), dev_id, con_id);
-#else
-	clk = cl->clk;
-#endif
-
 out:
 	mutex_unlock(&clocks_mutex);
 

commit a251361ac4cc5371a424d70fa0fd591dc9e83a5f
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Jan 23 12:03:32 2015 +0100

    clkdev: Export clk_register_clkdev
    
    So it can be used from modules such as clk-test.ko.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 901d242f38ea..29a1ab7af4b8 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -377,6 +377,7 @@ int clk_register_clkdev(struct clk *clk, const char *con_id,
 
 	return 0;
 }
+EXPORT_SYMBOL(clk_register_clkdev);
 
 /**
  * clk_register_clkdevs - register a set of clk_lookup for a struct clk

commit 035a61c314eb3dab5bcc5683afaf4d412689858a
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Jan 23 12:03:30 2015 +0100

    clk: Make clk API return per-user struct clk instances
    
    Moves clock state to struct clk_core, but takes care to change as little API as
    possible.
    
    struct clk_hw still has a pointer to a struct clk, which is the
    implementation's per-user clk instance, for backwards compatibility.
    
    The struct clk that clk_get_parent() returns isn't owned by the caller, but by
    the clock implementation, so the former shouldn't call clk_put() on it.
    
    Because some boards in mach-omap2 still register clocks statically, their clock
    registration had to be updated to take into account that the clock information
    is stored in struct clk_core now.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: adapted clk_has_parent to struct clk_core
                            applied OMAP3+ DPLL fix from Tero & Tony]

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index da4bda8b7fc7..901d242f38ea 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -19,6 +19,7 @@
 #include <linux/mutex.h>
 #include <linux/clk.h>
 #include <linux/clkdev.h>
+#include <linux/clk-provider.h>
 #include <linux/of.h>
 
 #include "clk.h"
@@ -53,7 +54,7 @@ struct clk *of_clk_get_by_clkspec(struct of_phandle_args *clkspec)
 	return clk;
 }
 
-struct clk *of_clk_get(struct device_node *np, int index)
+static struct clk *__of_clk_get(struct device_node *np, int index)
 {
 	struct of_phandle_args clkspec;
 	struct clk *clk;
@@ -69,20 +70,24 @@ struct clk *of_clk_get(struct device_node *np, int index)
 
 	clk = of_clk_get_by_clkspec(&clkspec);
 	of_node_put(clkspec.np);
+
+	return clk;
+}
+
+struct clk *of_clk_get(struct device_node *np, int index)
+{
+	struct clk *clk = __of_clk_get(np, index);
+
+	if (!IS_ERR(clk))
+		clk = __clk_create_clk(__clk_get_hw(clk), np->full_name, NULL);
+
 	return clk;
 }
 EXPORT_SYMBOL(of_clk_get);
 
-/**
- * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node
- * @np: pointer to clock consumer node
- * @name: name of consumer's clock input, or NULL for the first clock reference
- *
- * This function parses the clocks and clock-names properties,
- * and uses them to look up the struct clk from the registered list of clock
- * providers.
- */
-struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
+static struct clk *__of_clk_get_by_name(struct device_node *np,
+					const char *dev_id,
+					const char *name)
 {
 	struct clk *clk = ERR_PTR(-ENOENT);
 
@@ -97,9 +102,11 @@ struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
 		 */
 		if (name)
 			index = of_property_match_string(np, "clock-names", name);
-		clk = of_clk_get(np, index);
-		if (!IS_ERR(clk))
+		clk = __of_clk_get(np, index);
+		if (!IS_ERR(clk)) {
+			clk = __clk_create_clk(__clk_get_hw(clk), dev_id, name);
 			break;
+		}
 		else if (name && index >= 0) {
 			if (PTR_ERR(clk) != -EPROBE_DEFER)
 				pr_err("ERROR: could not get clock %s:%s(%i)\n",
@@ -119,7 +126,33 @@ struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
 
 	return clk;
 }
+
+/**
+ * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node
+ * @np: pointer to clock consumer node
+ * @name: name of consumer's clock input, or NULL for the first clock reference
+ *
+ * This function parses the clocks and clock-names properties,
+ * and uses them to look up the struct clk from the registered list of clock
+ * providers.
+ */
+struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
+{
+	if (!np)
+		return ERR_PTR(-ENOENT);
+
+	return __of_clk_get_by_name(np, np->full_name, name);
+}
 EXPORT_SYMBOL(of_clk_get_by_name);
+
+#else /* defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK) */
+
+static struct clk *__of_clk_get_by_name(struct device_node *np,
+					const char *dev_id,
+					const char *name)
+{
+	return ERR_PTR(-ENOENT);
+}
 #endif
 
 /*
@@ -168,14 +201,29 @@ static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 {
 	struct clk_lookup *cl;
+	struct clk *clk = NULL;
 
 	mutex_lock(&clocks_mutex);
+
 	cl = clk_find(dev_id, con_id);
-	if (cl && !__clk_get(cl->clk))
+	if (!cl)
+		goto out;
+
+	if (!__clk_get(cl->clk)) {
 		cl = NULL;
+		goto out;
+	}
+
+#if defined(CONFIG_COMMON_CLK)
+	clk = __clk_create_clk(__clk_get_hw(cl->clk), dev_id, con_id);
+#else
+	clk = cl->clk;
+#endif
+
+out:
 	mutex_unlock(&clocks_mutex);
 
-	return cl ? cl->clk : ERR_PTR(-ENOENT);
+	return cl ? clk : ERR_PTR(-ENOENT);
 }
 EXPORT_SYMBOL(clk_get_sys);
 
@@ -185,10 +233,8 @@ struct clk *clk_get(struct device *dev, const char *con_id)
 	struct clk *clk;
 
 	if (dev) {
-		clk = of_clk_get_by_name(dev->of_node, con_id);
-		if (!IS_ERR(clk))
-			return clk;
-		if (PTR_ERR(clk) == -EPROBE_DEFER)
+		clk = __of_clk_get_by_name(dev->of_node, dev_id, con_id);
+		if (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)
 			return clk;
 	}
 

commit d8e53c3deb46ec5b45bd7f5e1cc8ff8d35ec92ba
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 13 16:36:31 2014 -0700

    clkdev: Don't print errors on probe defer
    
    This error message can spam the logs if you have lots of probe
    deferals due to missing clocks. Just silence the error in this
    case because the driver should try again later.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index f890b901c6bc..da4bda8b7fc7 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -101,8 +101,9 @@ struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
 		if (!IS_ERR(clk))
 			break;
 		else if (name && index >= 0) {
-			pr_err("ERROR: could not get clock %s:%s(%i)\n",
-				np->full_name, name ? name : "", index);
+			if (PTR_ERR(clk) != -EPROBE_DEFER)
+				pr_err("ERROR: could not get clock %s:%s(%i)\n",
+					np->full_name, name ? name : "", index);
 			return clk;
 		}
 

commit 7f05e28f9dd3eb7a3f27c6f50b715995dc7a88c5
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Mon May 19 19:22:50 2014 +0200

    clk: Add of_clk_get_by_clkspec() helper
    
    This patch adds of_clk_get_by_clkspec() helper function, which does only
    a struct clk lookup from the clock providers. It is used in the subsequent
    patch where parsing of a clock from device tree and the lookup from
    providers needed to be split.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index a360b2eca5cb..f890b901c6bc 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -27,6 +27,32 @@ static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
 #if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
+
+/**
+ * of_clk_get_by_clkspec() - Lookup a clock form a clock provider
+ * @clkspec: pointer to a clock specifier data structure
+ *
+ * This function looks up a struct clk from the registered list of clock
+ * providers, an input is a clock specifier data structure as returned
+ * from the of_parse_phandle_with_args() function call.
+ */
+struct clk *of_clk_get_by_clkspec(struct of_phandle_args *clkspec)
+{
+	struct clk *clk;
+
+	if (!clkspec)
+		return ERR_PTR(-EINVAL);
+
+	of_clk_lock();
+	clk = __of_clk_get_from_provider(clkspec);
+
+	if (!IS_ERR(clk) && !__clk_get(clk))
+		clk = ERR_PTR(-ENOENT);
+
+	of_clk_unlock();
+	return clk;
+}
+
 struct clk *of_clk_get(struct device_node *np, int index)
 {
 	struct of_phandle_args clkspec;
@@ -41,13 +67,7 @@ struct clk *of_clk_get(struct device_node *np, int index)
 	if (rc)
 		return ERR_PTR(rc);
 
-	of_clk_lock();
-	clk = __of_clk_get_from_provider(&clkspec);
-
-	if (!IS_ERR(clk) && !__clk_get(clk))
-		clk = ERR_PTR(-ENOENT);
-
-	of_clk_unlock();
+	clk = of_clk_get_by_clkspec(&clkspec);
 	of_node_put(clkspec.np);
 	return clk;
 }

commit a34cd4666f3da84228a82f70c94b8d9b692034ea
Author: Jean-Francois Moine <moinejf@free.fr>
Date:   Mon Nov 25 19:47:04 2013 +0100

    clk: return probe defer when DT clock not yet ready
    
    At probe time, a clock device may not be ready when some other device
    wants to use it.
    
    This patch lets the functions clk_get/devm_clk_get return a probe defer
    when the clock is defined in the DT but not yet available.
    
    Signed-off-by: Jean-Francois Moine <moinejf@free.fr>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Tested-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 48f67218247c..a360b2eca5cb 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -167,6 +167,8 @@ struct clk *clk_get(struct device *dev, const char *con_id)
 		clk = of_clk_get_by_name(dev->of_node, con_id);
 		if (!IS_ERR(clk))
 			return clk;
+		if (PTR_ERR(clk) == -EPROBE_DEFER)
+			return clk;
 	}
 
 	return clk_get_sys(dev_id, con_id);

commit 3a3d2b0551d79ef476ef57424beeb8f68789fbcd
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri Aug 23 17:03:44 2013 +0200

    clkdev: Fix race condition in clock lookup from device tree
    
    There is currently a race condition in the device tree part of clk_get()
    function, since the pointer returned from of_clk_get_by_name() may become
    invalid before __clk_get() call. E.g. due to the clock provider driver
    remove() callback being called in between of_clk_get_by_name() and
    __clk_get().
    
    Fix this by doing both the look up and __clk_get() operations with the
    clock providers list mutex held. This ensures that the clock pointer
    returned from __of_clk_get_from_provider() call and passed to __clk_get()
    is valid, as long as the clock supplier module first removes its clock
    provider instance and then does clk_unregister() on the corresponding
    clocks.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Mike Turquette <mturquette@linaro.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 442a31363873..48f67218247c 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -21,6 +21,8 @@
 #include <linux/clkdev.h>
 #include <linux/of.h>
 
+#include "clk.h"
+
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
@@ -39,7 +41,13 @@ struct clk *of_clk_get(struct device_node *np, int index)
 	if (rc)
 		return ERR_PTR(rc);
 
-	clk = of_clk_get_from_provider(&clkspec);
+	of_clk_lock();
+	clk = __of_clk_get_from_provider(&clkspec);
+
+	if (!IS_ERR(clk) && !__clk_get(clk))
+		clk = ERR_PTR(-ENOENT);
+
+	of_clk_unlock();
 	of_node_put(clkspec.np);
 	return clk;
 }
@@ -157,7 +165,7 @@ struct clk *clk_get(struct device *dev, const char *con_id)
 
 	if (dev) {
 		clk = of_clk_get_by_name(dev->of_node, con_id);
-		if (!IS_ERR(clk) && __clk_get(clk))
+		if (!IS_ERR(clk))
 			return clk;
 	}
 

commit 8ef997b67f0d779c82e7e533a792c5a6837594cd
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Sep 11 19:56:23 2012 +0100

    ARM: 7534/1: clk: Make the managed clk functions generically available
    
    The managed clk functions are currently only available when the generic clk
    lookup framework is build. But the managed clk functions are merely wrappers
    around clk_get and clk_put and do not depend on any specifics of the generic
    lookup functions and there are still quite a few custom implementations of the
    clk API. So make the managed functions available whenever the clk API is
    implemented.
    
    The patch also removes the custom implementation of devm_clk_get for the
    coldfire platform.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index d423c9bdd71a..442a31363873 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -171,51 +171,6 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_put);
 
-static void devm_clk_release(struct device *dev, void *res)
-{
-	clk_put(*(struct clk **)res);
-}
-
-struct clk *devm_clk_get(struct device *dev, const char *id)
-{
-	struct clk **ptr, *clk;
-
-	ptr = devres_alloc(devm_clk_release, sizeof(*ptr), GFP_KERNEL);
-	if (!ptr)
-		return ERR_PTR(-ENOMEM);
-
-	clk = clk_get(dev, id);
-	if (!IS_ERR(clk)) {
-		*ptr = clk;
-		devres_add(dev, ptr);
-	} else {
-		devres_free(ptr);
-	}
-
-	return clk;
-}
-EXPORT_SYMBOL(devm_clk_get);
-
-static int devm_clk_match(struct device *dev, void *res, void *data)
-{
-	struct clk **c = res;
-	if (!c || !*c) {
-		WARN_ON(!c || !*c);
-		return 0;
-	}
-	return *c == data;
-}
-
-void devm_clk_put(struct device *dev, struct clk *clk)
-{
-	int ret;
-
-	ret = devres_destroy(dev, devm_clk_release, devm_clk_match, clk);
-
-	WARN_ON(ret);
-}
-EXPORT_SYMBOL(devm_clk_put);
-
 void clkdev_add(struct clk_lookup *cl)
 {
 	mutex_lock(&clocks_mutex);

commit 137f8a7213d80c1388ca48280c1ef0856b6fec30
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Jul 18 11:52:23 2012 +0800

    clk: fix compile for OF && !COMMON_CLK
    
    With commit 766e6a4ec602d0c107 (clk: add DT clock binding support),
    compiling with OF && !COMMON_CLK is broken.
    
    Reported-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Reported-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 69085e02bd58..d423c9bdd71a 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -24,7 +24,7 @@
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
-#ifdef CONFIG_OF
+#if defined(CONFIG_OF) && defined(CONFIG_COMMON_CLK)
 struct clk *of_clk_get(struct device_node *np, int index)
 {
 	struct of_phandle_args clkspec;

commit 9f1612d351a8e57d3d694e828641d3e4eeb224f8
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Jul 18 11:52:22 2012 +0800

    clk: fix clk_get on of_clk_get_by_name return check
    
    The commit 766e6a4 (clk: add DT clock binding support) plugs device
    tree clk lookup of_clk_get_by_name into clk_get, and fall on non-DT
    lookup clk_get_sys if DT lookup fails.
    
    The return check on of_clk_get_by_name takes (clk != NULL) as a
    successful DT lookup.  But it's not the case.  For any system that
    does not define clk lookup in device tree, ERR_PTR(-ENOENT) will be
    returned, and consequently, all the client drivers calling clk_get
    in their probe functions will fail to probe with error code -ENOENT
    returned.
    
    Fix the issue by checking of_clk_get_by_name return with !IS_ERR(clk),
    and update of_clk_get and of_clk_get_by_name for !CONFIG_OF build
    correspondingly.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Tested-by: Marek Vasut <marex@denx.de>
    Tested-by: Lauri Hintsala <lauri.hintsala@bluegiga.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 20649b3c88fe..69085e02bd58 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -157,7 +157,7 @@ struct clk *clk_get(struct device *dev, const char *con_id)
 
 	if (dev) {
 		clk = of_clk_get_by_name(dev->of_node, con_id);
-		if (clk && __clk_get(clk))
+		if (!IS_ERR(clk) && __clk_get(clk))
 			return clk;
 	}
 

commit 766e6a4ec602d0c107553b91b3434fe9c03474f4
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Apr 9 14:50:06 2012 -0500

    clk: add DT clock binding support
    
    Based on work 1st by Ben Herrenschmidt and Jeremy Kerr, then by Grant
    Likely, this patch adds support to clk_get to allow drivers to retrieve
    clock data from the device tree.
    
    Platforms scan for clocks in DT with of_clk_init and a match table, and
    the register a provider through of_clk_add_provider. The provider's
    clk_src_get function will be called when a device references the
    provider's OF node for a clock reference.
    
    v6 (Rob Herring):
        - Return error values instead of NULL to match clock framework
          expectations
    
    v5 (Rob Herring):
        - Move from drivers/of into common clock subsystem
        - Squashed "dt/clock: add a simple provider get function" and
          "dt/clock: add function to get parent clock name"
        - Rebase to 3.4-rc1
        - Drop CONFIG_OF_CLOCK and just use CONFIG_OF
        - Add missing EXPORT_SYMBOL to various functions
        - s/clock-output-name/clock-output-names/
        - Define that fixed-clock binding is a single output
    
    v4 (Rob Herring):
        - Rework for common clk subsystem
        - Add of_clk_get_parent_name function
    
    v3: - Clarified documentation
    
    v2: - fixed errant ';' causing compile error
        - Editorial fixes from Shawn Guo
        - merged in adding lookup to clkdev
        - changed property names to match established convention. After
          working with the binding a bit it really made more sense to follow the
          lead of 'reg', 'gpios' and 'interrupts' by making the input simply
          'clocks' & 'clock-names' instead of 'clock-input-*', and to only use
          clock-output* for the producer nodes. (Sorry Shawn, this will mean
          you need to change some code, but it should be trivial)
        - Add ability to inherit clocks from parent nodes by using an empty
          'clock-ranges' property.  Useful for busses.  I could use some feedback
          on the new property name, 'clock-ranges' doesn't feel right to me.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Reviewed-by: Shawn Guo <shawn.guo@freescale.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index c535cf8c5770..20649b3c88fe 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -19,10 +19,80 @@
 #include <linux/mutex.h>
 #include <linux/clk.h>
 #include <linux/clkdev.h>
+#include <linux/of.h>
 
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 
+#ifdef CONFIG_OF
+struct clk *of_clk_get(struct device_node *np, int index)
+{
+	struct of_phandle_args clkspec;
+	struct clk *clk;
+	int rc;
+
+	if (index < 0)
+		return ERR_PTR(-EINVAL);
+
+	rc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", index,
+					&clkspec);
+	if (rc)
+		return ERR_PTR(rc);
+
+	clk = of_clk_get_from_provider(&clkspec);
+	of_node_put(clkspec.np);
+	return clk;
+}
+EXPORT_SYMBOL(of_clk_get);
+
+/**
+ * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node
+ * @np: pointer to clock consumer node
+ * @name: name of consumer's clock input, or NULL for the first clock reference
+ *
+ * This function parses the clocks and clock-names properties,
+ * and uses them to look up the struct clk from the registered list of clock
+ * providers.
+ */
+struct clk *of_clk_get_by_name(struct device_node *np, const char *name)
+{
+	struct clk *clk = ERR_PTR(-ENOENT);
+
+	/* Walk up the tree of devices looking for a clock that matches */
+	while (np) {
+		int index = 0;
+
+		/*
+		 * For named clocks, first look up the name in the
+		 * "clock-names" property.  If it cannot be found, then
+		 * index will be an error code, and of_clk_get() will fail.
+		 */
+		if (name)
+			index = of_property_match_string(np, "clock-names", name);
+		clk = of_clk_get(np, index);
+		if (!IS_ERR(clk))
+			break;
+		else if (name && index >= 0) {
+			pr_err("ERROR: could not get clock %s:%s(%i)\n",
+				np->full_name, name ? name : "", index);
+			return clk;
+		}
+
+		/*
+		 * No matching clock found on this node.  If the parent node
+		 * has a "clock-ranges" property, then we can try one of its
+		 * clocks.
+		 */
+		np = np->parent;
+		if (np && !of_get_property(np, "clock-ranges", NULL))
+			break;
+	}
+
+	return clk;
+}
+EXPORT_SYMBOL(of_clk_get_by_name);
+#endif
+
 /*
  * Find the correct struct clk for the device and connection ID.
  * We do slightly fuzzy matching here:
@@ -83,6 +153,13 @@ EXPORT_SYMBOL(clk_get_sys);
 struct clk *clk_get(struct device *dev, const char *con_id)
 {
 	const char *dev_id = dev ? dev_name(dev) : NULL;
+	struct clk *clk;
+
+	if (dev) {
+		clk = of_clk_get_by_name(dev->of_node, con_id);
+		if (clk && __clk_get(clk))
+			return clk;
+	}
 
 	return clk_get_sys(dev_id, con_id);
 }

commit e9d7f4065408e92338a41b809e437c6e043da090
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed May 2 09:30:32 2012 +0100

    CLKDEV: provide helpers for common clock framework
    
    The common clock framework allocates clocks dynamically.  Provide a
    set of helpers to streamline the clkdev registration of the clock
    lookups to avoid repetitive code sequences.
    
    Reviewed-by: Viresh Kumar <viresh.kumar@st.com>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index d4a59931e75e..c535cf8c5770 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -166,8 +166,9 @@ struct clk_lookup_alloc {
 	char	con_id[MAX_CON_ID];
 };
 
-struct clk_lookup * __init_refok
-clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
+static struct clk_lookup * __init_refok
+vclkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt,
+	va_list ap)
 {
 	struct clk_lookup_alloc *cla;
 
@@ -182,16 +183,25 @@ clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
 	}
 
 	if (dev_fmt) {
-		va_list ap;
-
-		va_start(ap, dev_fmt);
 		vscnprintf(cla->dev_id, sizeof(cla->dev_id), dev_fmt, ap);
 		cla->cl.dev_id = cla->dev_id;
-		va_end(ap);
 	}
 
 	return &cla->cl;
 }
+
+struct clk_lookup * __init_refok
+clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
+{
+	struct clk_lookup *cl;
+	va_list ap;
+
+	va_start(ap, dev_fmt);
+	cl = vclkdev_alloc(clk, con_id, dev_fmt, ap);
+	va_end(ap);
+
+	return cl;
+}
 EXPORT_SYMBOL(clkdev_alloc);
 
 int clk_add_alias(const char *alias, const char *alias_dev_name, char *id,
@@ -223,3 +233,65 @@ void clkdev_drop(struct clk_lookup *cl)
 	kfree(cl);
 }
 EXPORT_SYMBOL(clkdev_drop);
+
+/**
+ * clk_register_clkdev - register one clock lookup for a struct clk
+ * @clk: struct clk to associate with all clk_lookups
+ * @con_id: connection ID string on device
+ * @dev_id: format string describing device name
+ *
+ * con_id or dev_id may be NULL as a wildcard, just as in the rest of
+ * clkdev.
+ *
+ * To make things easier for mass registration, we detect error clks
+ * from a previous clk_register() call, and return the error code for
+ * those.  This is to permit this function to be called immediately
+ * after clk_register().
+ */
+int clk_register_clkdev(struct clk *clk, const char *con_id,
+	const char *dev_fmt, ...)
+{
+	struct clk_lookup *cl;
+	va_list ap;
+
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	va_start(ap, dev_fmt);
+	cl = vclkdev_alloc(clk, con_id, dev_fmt, ap);
+	va_end(ap);
+
+	if (!cl)
+		return -ENOMEM;
+
+	clkdev_add(cl);
+
+	return 0;
+}
+
+/**
+ * clk_register_clkdevs - register a set of clk_lookup for a struct clk
+ * @clk: struct clk to associate with all clk_lookups
+ * @cl: array of clk_lookup structures with con_id and dev_id pre-initialized
+ * @num: number of clk_lookup structures to register
+ *
+ * To make things easier for mass registration, we detect error clks
+ * from a previous clk_register() call, and return the error code for
+ * those.  This is to permit this function to be called immediately
+ * after clk_register().
+ */
+int clk_register_clkdevs(struct clk *clk, struct clk_lookup *cl, size_t num)
+{
+	unsigned i;
+
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	for (i = 0; i < num; i++, cl++) {
+		cl->clk = clk;
+		clkdev_add(cl);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_register_clkdevs);

commit 67b508715a61962f9b5b3ef3432e045a9cba4f1e
Author: viresh kumar <viresh.kumar@st.com>
Date:   Thu Apr 19 04:23:25 2012 +0100

    ARM: 7392/1: CLKDEV: Optimize clk_find()
    
    clk_find must return as soon as it gets the correct clock. Currently it check
    all clocks until it found a lookup with both dev_id and con_id matching.
    
    If only one of them is passed, then we don't actually need to wait for both of
    them to match. We can quit as soon as the requested id (dev_id or con_id)
    matches.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index a9a113782821..d4a59931e75e 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -35,7 +35,12 @@ static DEFINE_MUTEX(clocks_mutex);
 static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 {
 	struct clk_lookup *p, *cl = NULL;
-	int match, best = 0;
+	int match, best_found = 0, best_possible = 0;
+
+	if (dev_id)
+		best_possible += 2;
+	if (con_id)
+		best_possible += 1;
 
 	list_for_each_entry(p, &clocks, node) {
 		match = 0;
@@ -50,10 +55,10 @@ static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 			match += 1;
 		}
 
-		if (match > best) {
+		if (match > best_found) {
 			cl = p;
-			if (match != 3)
-				best = match;
+			if (match != best_possible)
+				best_found = match;
 			else
 				break;
 		}

commit a8a97db984bdc5e89d42e41891543d2daaf314cb
Author: Mark Brown <broonie@sirena.org.uk>
Date:   Thu Apr 5 11:42:09 2012 +0100

    ARM: 7376/1: clkdev: Implement managed clk_get()
    
    Allow clk API users to simplify their cleanup paths by providing a
    managed version of clk_get() and clk_put().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 6db161f64ae0..a9a113782821 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -89,6 +89,51 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_put);
 
+static void devm_clk_release(struct device *dev, void *res)
+{
+	clk_put(*(struct clk **)res);
+}
+
+struct clk *devm_clk_get(struct device *dev, const char *id)
+{
+	struct clk **ptr, *clk;
+
+	ptr = devres_alloc(devm_clk_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	clk = clk_get(dev, id);
+	if (!IS_ERR(clk)) {
+		*ptr = clk;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return clk;
+}
+EXPORT_SYMBOL(devm_clk_get);
+
+static int devm_clk_match(struct device *dev, void *res, void *data)
+{
+	struct clk **c = res;
+	if (!c || !*c) {
+		WARN_ON(!c || !*c);
+		return 0;
+	}
+	return *c == data;
+}
+
+void devm_clk_put(struct device *dev, struct clk *clk)
+{
+	int ret;
+
+	ret = devres_destroy(dev, devm_clk_release, devm_clk_match, clk);
+
+	WARN_ON(ret);
+}
+EXPORT_SYMBOL(devm_clk_put);
+
 void clkdev_add(struct clk_lookup *cl)
 {
 	mutex_lock(&clocks_mutex);

commit e8bf8df9c296b782c32236c6a5893aec301320c7
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Apr 30 10:14:08 2011 +0100

    CLKDEV: Fix clkdev return value for NULL clk case
    
    clkdev may incorrectly cause a clkdev entry with a NULL clk to return
    -ENOENT.  This is not the intention of this code; -ENOENT should only
    be returned if the clock entry can not be found in the table.  Fix
    this.
    
    Reported-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 0fc0a79852de..6db161f64ae0 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -32,10 +32,9 @@ static DEFINE_MUTEX(clocks_mutex);
  * Then we take the most specific entry - with the following
  * order of precedence: dev+con > dev only > con only.
  */
-static struct clk *clk_find(const char *dev_id, const char *con_id)
+static struct clk_lookup *clk_find(const char *dev_id, const char *con_id)
 {
-	struct clk_lookup *p;
-	struct clk *clk = NULL;
+	struct clk_lookup *p, *cl = NULL;
 	int match, best = 0;
 
 	list_for_each_entry(p, &clocks, node) {
@@ -52,27 +51,27 @@ static struct clk *clk_find(const char *dev_id, const char *con_id)
 		}
 
 		if (match > best) {
-			clk = p->clk;
+			cl = p;
 			if (match != 3)
 				best = match;
 			else
 				break;
 		}
 	}
-	return clk;
+	return cl;
 }
 
 struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 {
-	struct clk *clk;
+	struct clk_lookup *cl;
 
 	mutex_lock(&clocks_mutex);
-	clk = clk_find(dev_id, con_id);
-	if (clk && !__clk_get(clk))
-		clk = NULL;
+	cl = clk_find(dev_id, con_id);
+	if (cl && !__clk_get(cl->clk))
+		cl = NULL;
 	mutex_unlock(&clocks_mutex);
 
-	return clk ? clk : ERR_PTR(-ENOENT);
+	return cl ? cl->clk : ERR_PTR(-ENOENT);
 }
 EXPORT_SYMBOL(clk_get_sys);
 

commit 6d803ba736abb5e122dede70a4720e4843dd6df4
Author: Jean-Christop PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Nov 17 10:04:33 2010 +0100

    ARM: 6483/1: arm & sh: factorised duplicated clkdev.c
    
    factorise some generic infrastructure to assist looking up struct clks
    for the ARM & SH architecture.
    
    as the code is identical at 99%
    
    put the arch specific code for allocation as example in asm/clkdev.h
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
new file mode 100644
index 000000000000..0fc0a79852de
--- /dev/null
+++ b/drivers/clk/clkdev.c
@@ -0,0 +1,176 @@
+/*
+ * drivers/clk/clkdev.c
+ *
+ *  Copyright (C) 2008 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Helper for the clk API to assist looking up a struct clk.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+
+/*
+ * Find the correct struct clk for the device and connection ID.
+ * We do slightly fuzzy matching here:
+ *  An entry with a NULL ID is assumed to be a wildcard.
+ *  If an entry has a device ID, it must match
+ *  If an entry has a connection ID, it must match
+ * Then we take the most specific entry - with the following
+ * order of precedence: dev+con > dev only > con only.
+ */
+static struct clk *clk_find(const char *dev_id, const char *con_id)
+{
+	struct clk_lookup *p;
+	struct clk *clk = NULL;
+	int match, best = 0;
+
+	list_for_each_entry(p, &clocks, node) {
+		match = 0;
+		if (p->dev_id) {
+			if (!dev_id || strcmp(p->dev_id, dev_id))
+				continue;
+			match += 2;
+		}
+		if (p->con_id) {
+			if (!con_id || strcmp(p->con_id, con_id))
+				continue;
+			match += 1;
+		}
+
+		if (match > best) {
+			clk = p->clk;
+			if (match != 3)
+				best = match;
+			else
+				break;
+		}
+	}
+	return clk;
+}
+
+struct clk *clk_get_sys(const char *dev_id, const char *con_id)
+{
+	struct clk *clk;
+
+	mutex_lock(&clocks_mutex);
+	clk = clk_find(dev_id, con_id);
+	if (clk && !__clk_get(clk))
+		clk = NULL;
+	mutex_unlock(&clocks_mutex);
+
+	return clk ? clk : ERR_PTR(-ENOENT);
+}
+EXPORT_SYMBOL(clk_get_sys);
+
+struct clk *clk_get(struct device *dev, const char *con_id)
+{
+	const char *dev_id = dev ? dev_name(dev) : NULL;
+
+	return clk_get_sys(dev_id, con_id);
+}
+EXPORT_SYMBOL(clk_get);
+
+void clk_put(struct clk *clk)
+{
+	__clk_put(clk);
+}
+EXPORT_SYMBOL(clk_put);
+
+void clkdev_add(struct clk_lookup *cl)
+{
+	mutex_lock(&clocks_mutex);
+	list_add_tail(&cl->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clkdev_add);
+
+void __init clkdev_add_table(struct clk_lookup *cl, size_t num)
+{
+	mutex_lock(&clocks_mutex);
+	while (num--) {
+		list_add_tail(&cl->node, &clocks);
+		cl++;
+	}
+	mutex_unlock(&clocks_mutex);
+}
+
+#define MAX_DEV_ID	20
+#define MAX_CON_ID	16
+
+struct clk_lookup_alloc {
+	struct clk_lookup cl;
+	char	dev_id[MAX_DEV_ID];
+	char	con_id[MAX_CON_ID];
+};
+
+struct clk_lookup * __init_refok
+clkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)
+{
+	struct clk_lookup_alloc *cla;
+
+	cla = __clkdev_alloc(sizeof(*cla));
+	if (!cla)
+		return NULL;
+
+	cla->cl.clk = clk;
+	if (con_id) {
+		strlcpy(cla->con_id, con_id, sizeof(cla->con_id));
+		cla->cl.con_id = cla->con_id;
+	}
+
+	if (dev_fmt) {
+		va_list ap;
+
+		va_start(ap, dev_fmt);
+		vscnprintf(cla->dev_id, sizeof(cla->dev_id), dev_fmt, ap);
+		cla->cl.dev_id = cla->dev_id;
+		va_end(ap);
+	}
+
+	return &cla->cl;
+}
+EXPORT_SYMBOL(clkdev_alloc);
+
+int clk_add_alias(const char *alias, const char *alias_dev_name, char *id,
+	struct device *dev)
+{
+	struct clk *r = clk_get(dev, id);
+	struct clk_lookup *l;
+
+	if (IS_ERR(r))
+		return PTR_ERR(r);
+
+	l = clkdev_alloc(r, alias, alias_dev_name);
+	clk_put(r);
+	if (!l)
+		return -ENODEV;
+	clkdev_add(l);
+	return 0;
+}
+EXPORT_SYMBOL(clk_add_alias);
+
+/*
+ * clkdev_drop - remove a clock dynamically allocated
+ */
+void clkdev_drop(struct clk_lookup *cl)
+{
+	mutex_lock(&clocks_mutex);
+	list_del(&cl->node);
+	mutex_unlock(&clocks_mutex);
+	kfree(cl);
+}
+EXPORT_SYMBOL(clkdev_drop);
