commit c0448dce56a49812c889e5f670745c9f49176b00
Author: Ben Peled <bpeled@marvell.com>
Date:   Mon Aug 5 12:03:10 2019 +0200

    clk: mvebu: ap80x: add AP807 clock support
    
    Add driver support for AP807 clock.
    
    Signed-off-by: Ben Peled <bpeled@marvell.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lkml.kernel.org/r/20190805100310.29048-9-miquel.raynal@bootlin.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index c64e2cc4a3ba..948bd1e71aea 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -102,6 +102,30 @@ static int ap806_get_sar_clocks(unsigned int freq_mode,
 	return 0;
 }
 
+static int ap807_get_sar_clocks(unsigned int freq_mode,
+				unsigned int *cpuclk_freq,
+				unsigned int *dclk_freq)
+{
+	switch (freq_mode) {
+	case 0x0:
+		*cpuclk_freq = 2000;
+		*dclk_freq = 1200;
+		break;
+	case 0x6:
+		*cpuclk_freq = 2200;
+		*dclk_freq = 1200;
+		break;
+	case 0xD:
+		*cpuclk_freq = 1600;
+		*dclk_freq = 1200;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int ap806_syscon_common_probe(struct platform_device *pdev,
 				     struct device_node *syscon_node)
 {
@@ -130,6 +154,9 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 	if (of_device_is_compatible(pdev->dev.of_node,
 				    "marvell,ap806-clock")) {
 		ret = ap806_get_sar_clocks(freq_mode, &cpuclk_freq, &dclk_freq);
+	} else if (of_device_is_compatible(pdev->dev.of_node,
+					   "marvell,ap807-clock")) {
+		ret = ap807_get_sar_clocks(freq_mode, &cpuclk_freq, &dclk_freq);
 	} else {
 		dev_err(dev, "compatible not supported\n");
 		return -EINVAL;
@@ -252,6 +279,7 @@ builtin_platform_driver(ap806_syscon_legacy_driver);
 
 static const struct of_device_id ap806_clock_of_match[] = {
 	{ .compatible = "marvell,ap806-clock", },
+	{ .compatible = "marvell,ap807-clock", },
 	{ }
 };
 

commit be69e55df9afc2eb37a2a602ad607e28e1e553d7
Author: Ben Peled <bpeled@marvell.com>
Date:   Mon Aug 5 12:03:09 2019 +0200

    clk: mvebu: ap806: Prepare the introduction of AP807 clock support
    
    Factor out the code that is only useful to AP806 so it will be easier
    to support AP807. No functional changes.
    
    Signed-off-by: Ben Peled <bpeled@marvell.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lkml.kernel.org/r/20190805100310.29048-8-miquel.raynal@bootlin.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index bc43adff02e0..c64e2cc4a3ba 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -30,100 +30,114 @@ static struct clk_onecell_data ap806_clk_data = {
 	.clk_num = AP806_CLK_NUM,
 };
 
-static int ap806_syscon_common_probe(struct platform_device *pdev,
-				     struct device_node *syscon_node)
+static int ap806_get_sar_clocks(unsigned int freq_mode,
+				unsigned int *cpuclk_freq,
+				unsigned int *dclk_freq)
 {
-	unsigned int freq_mode, cpuclk_freq, dclk_freq;
-	const char *name, *fixedclk_name;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	struct regmap *regmap;
-	u32 reg;
-	int ret;
-
-	regmap = syscon_node_to_regmap(syscon_node);
-	if (IS_ERR(regmap)) {
-		dev_err(dev, "cannot get regmap\n");
-		return PTR_ERR(regmap);
-	}
-
-	ret = regmap_read(regmap, AP806_SAR_REG, &reg);
-	if (ret) {
-		dev_err(dev, "cannot read from regmap\n");
-		return ret;
-	}
-
-	freq_mode = reg & AP806_SAR_CLKFREQ_MODE_MASK;
 	switch (freq_mode) {
 	case 0x0:
+		*cpuclk_freq = 2000;
+		*dclk_freq = 600;
+		break;
 	case 0x1:
-		cpuclk_freq = 2000;
+		*cpuclk_freq = 2000;
+		*dclk_freq = 525;
 		break;
 	case 0x6:
+		*cpuclk_freq = 1800;
+		*dclk_freq = 600;
+		break;
 	case 0x7:
-		cpuclk_freq = 1800;
+		*cpuclk_freq = 1800;
+		*dclk_freq = 525;
 		break;
 	case 0x4:
+		*cpuclk_freq = 1600;
+		*dclk_freq = 400;
+		break;
 	case 0xB:
+		*cpuclk_freq = 1600;
+		*dclk_freq = 450;
+		break;
 	case 0xD:
-		cpuclk_freq = 1600;
+		*cpuclk_freq = 1600;
+		*dclk_freq = 525;
 		break;
 	case 0x1a:
-		cpuclk_freq = 1400;
+		*cpuclk_freq = 1400;
+		*dclk_freq = 400;
 		break;
 	case 0x14:
+		*cpuclk_freq = 1300;
+		*dclk_freq = 400;
+		break;
 	case 0x17:
-		cpuclk_freq = 1300;
+		*cpuclk_freq = 1300;
+		*dclk_freq = 325;
 		break;
 	case 0x19:
-		cpuclk_freq = 1200;
+		*cpuclk_freq = 1200;
+		*dclk_freq = 400;
 		break;
 	case 0x13:
+		*cpuclk_freq = 1000;
+		*dclk_freq = 325;
+		break;
 	case 0x1d:
-		cpuclk_freq = 1000;
+		*cpuclk_freq = 1000;
+		*dclk_freq = 400;
 		break;
 	case 0x1c:
-		cpuclk_freq = 800;
+		*cpuclk_freq = 800;
+		*dclk_freq = 400;
 		break;
 	case 0x1b:
-		cpuclk_freq = 600;
+		*cpuclk_freq = 600;
+		*dclk_freq = 400;
 		break;
 	default:
-		dev_err(dev, "invalid Sample at Reset value\n");
 		return -EINVAL;
 	}
 
-	/* Get DCLK frequency (DCLK = DDR_CLK / 2) */
-	switch (freq_mode) {
-	case 0x0:
-	case 0x6:
-		/* DDR_CLK = 1200Mhz */
-		dclk_freq = 600;
-		break;
-	case 0x1:
-	case 0x7:
-	case 0xD:
-		/* DDR_CLK = 1050Mhz */
-		dclk_freq = 525;
-		break;
-	case 0x13:
-	case 0x17:
-		/* DDR_CLK = 650Mhz */
-		dclk_freq = 325;
-		break;
-	case 0x4:
-	case 0x14:
-	case 0x19:
-	case 0x1A:
-	case 0x1B:
-	case 0x1C:
-	case 0x1D:
-		/* DDR_CLK = 800Mhz */
-		dclk_freq = 400;
-		break;
-	default:
-		dclk_freq = 0;
+	return 0;
+}
+
+static int ap806_syscon_common_probe(struct platform_device *pdev,
+				     struct device_node *syscon_node)
+{
+	unsigned int freq_mode, cpuclk_freq, dclk_freq;
+	const char *name, *fixedclk_name;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct regmap *regmap;
+	u32 reg;
+	int ret;
+
+	regmap = syscon_node_to_regmap(syscon_node);
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "cannot get regmap\n");
+		return PTR_ERR(regmap);
+	}
+
+	ret = regmap_read(regmap, AP806_SAR_REG, &reg);
+	if (ret) {
+		dev_err(dev, "cannot read from regmap\n");
+		return ret;
+	}
+
+	freq_mode = reg & AP806_SAR_CLKFREQ_MODE_MASK;
+
+	if (of_device_is_compatible(pdev->dev.of_node,
+				    "marvell,ap806-clock")) {
+		ret = ap806_get_sar_clocks(freq_mode, &cpuclk_freq, &dclk_freq);
+	} else {
+		dev_err(dev, "compatible not supported\n");
+		return -EINVAL;
+	}
+
+	if (ret) {
 		dev_err(dev, "invalid Sample at Reset value\n");
+		return ret;
 	}
 
 	/* Convert to hertz */

commit 0099dc446bb6a72ce24d4f86760d0f4fe4300138
Author: Omri Itach <omrii@marvell.com>
Date:   Mon Aug 5 12:03:08 2019 +0200

    clk: mvebu: ap806: add AP-DCLK (hclk) to system controller driver
    
    Add dynamic AP-DCLK clock (hclk) to system controller driver. AP-DCLK
    is half the rate of DDR clock, so its derrived from Sample At Reset
    configuration. The clock frequency is required for AP806 AXI monitor
    profiling feature.
    
    Signed-off-by: Omri Itach <omrii@marvell.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lkml.kernel.org/r/20190805100310.29048-7-miquel.raynal@bootlin.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 2cf874f01394..bc43adff02e0 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -21,7 +21,7 @@
 #define AP806_SAR_REG			0x400
 #define AP806_SAR_CLKFREQ_MODE_MASK	0x1f
 
-#define AP806_CLK_NUM			5
+#define AP806_CLK_NUM			6
 
 static struct clk *ap806_clks[AP806_CLK_NUM];
 
@@ -33,7 +33,7 @@ static struct clk_onecell_data ap806_clk_data = {
 static int ap806_syscon_common_probe(struct platform_device *pdev,
 				     struct device_node *syscon_node)
 {
-	unsigned int freq_mode, cpuclk_freq;
+	unsigned int freq_mode, cpuclk_freq, dclk_freq;
 	const char *name, *fixedclk_name;
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
@@ -93,8 +93,42 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 		return -EINVAL;
 	}
 
+	/* Get DCLK frequency (DCLK = DDR_CLK / 2) */
+	switch (freq_mode) {
+	case 0x0:
+	case 0x6:
+		/* DDR_CLK = 1200Mhz */
+		dclk_freq = 600;
+		break;
+	case 0x1:
+	case 0x7:
+	case 0xD:
+		/* DDR_CLK = 1050Mhz */
+		dclk_freq = 525;
+		break;
+	case 0x13:
+	case 0x17:
+		/* DDR_CLK = 650Mhz */
+		dclk_freq = 325;
+		break;
+	case 0x4:
+	case 0x14:
+	case 0x19:
+	case 0x1A:
+	case 0x1B:
+	case 0x1C:
+	case 0x1D:
+		/* DDR_CLK = 800Mhz */
+		dclk_freq = 400;
+		break;
+	default:
+		dclk_freq = 0;
+		dev_err(dev, "invalid Sample at Reset value\n");
+	}
+
 	/* Convert to hertz */
 	cpuclk_freq *= 1000 * 1000;
+	dclk_freq *= 1000 * 1000;
 
 	/* CPU clocks depend on the Sample At Reset configuration */
 	name = ap_cp_unique_name(dev, syscon_node, "pll-cluster-0");
@@ -141,6 +175,14 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 		goto fail4;
 	}
 
+	/* AP-DCLK(HCLK) Clock is DDR clock divided by 2 */
+	name = ap_cp_unique_name(dev, syscon_node, "ap-dclk");
+	ap806_clks[5] = clk_register_fixed_rate(dev, name, NULL, 0, dclk_freq);
+	if (IS_ERR(ap806_clks[5])) {
+		ret = PTR_ERR(ap806_clks[5]);
+		goto fail5;
+	}
+
 	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);
 	if (ret)
 		goto fail_clk_add;
@@ -148,6 +190,8 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 	return 0;
 
 fail_clk_add:
+	clk_unregister_fixed_factor(ap806_clks[5]);
+fail5:
 	clk_unregister_fixed_factor(ap806_clks[4]);
 fail4:
 	clk_unregister_fixed_factor(ap806_clks[3]);

commit cd016cb01835e0b9f62fb675b336fbded912dcb6
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Mon Aug 5 12:03:07 2019 +0200

    clk: mvebu: ap806: be more explicit on what SaR is
    
    "SaR" means Sample at Reset. DIP switches can be changed on the board,
    their states at reset time is available through a register read.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lkml.kernel.org/r/20190805100310.29048-6-miquel.raynal@bootlin.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 73ba8fd7860f..2cf874f01394 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -89,7 +89,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 		cpuclk_freq = 600;
 		break;
 	default:
-		dev_err(dev, "invalid SAR value\n");
+		dev_err(dev, "invalid Sample at Reset value\n");
 		return -EINVAL;
 	}
 

commit baf4c10f8878d44912070561d542a74c09f05adf
Author: Gregory CLEMENT <gregory.clement@bootlin.com>
Date:   Wed Jul 10 15:43:44 2019 +0200

    clk: mvebu: ap806: Fix clock name for the cluster
    
    Actually, the clocks exposed for the cluster are not the CPU clocks, but
    the PLL clock used as entry clock for the CPU clocks. The CPU clock will
    be managed by a driver submitting in the following patches.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Link: https://lkml.kernel.org/r/20190710134346.30239-5-gregory.clement@bootlin.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 0a58824ff053..73ba8fd7860f 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -97,7 +97,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 	cpuclk_freq *= 1000 * 1000;
 
 	/* CPU clocks depend on the Sample At Reset configuration */
-	name = ap_cp_unique_name(dev, syscon_node, "cpu-cluster-0");
+	name = ap_cp_unique_name(dev, syscon_node, "pll-cluster-0");
 	ap806_clks[0] = clk_register_fixed_rate(dev, name, NULL,
 						0, cpuclk_freq);
 	if (IS_ERR(ap806_clks[0])) {
@@ -105,7 +105,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 		goto fail0;
 	}
 
-	name = ap_cp_unique_name(dev, syscon_node, "cpu-cluster-1");
+	name = ap_cp_unique_name(dev, syscon_node, "pll-cluster-1");
 	ap806_clks[1] = clk_register_fixed_rate(dev, name, NULL, 0,
 						cpuclk_freq);
 	if (IS_ERR(ap806_clks[1])) {

commit 33c0259092c805dc1cee9dd7bf66a955124702d9
Author: Gregory CLEMENT <gregory.clement@bootlin.com>
Date:   Wed Jul 10 15:43:42 2019 +0200

    clk: mvebu: add helper file for Armada AP and CP clocks
    
    Clock drivers for Armada AP and Armada CP use the same function to
    generate unique clock name. A third drivers is coming with the same
    need, so it's time to move this function in a common file.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Link: https://lkml.kernel.org/r/20190710134346.30239-3-gregory.clement@bootlin.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index ea54a874bbda..0a58824ff053 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -10,11 +10,11 @@
 
 #define pr_fmt(fmt) "ap806-system-controller: " fmt
 
+#include "armada_ap_cp_helper.h"
 #include <linux/clk-provider.h>
 #include <linux/mfd/syscon.h>
 #include <linux/init.h>
 #include <linux/of.h>
-#include <linux/of_address.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 
@@ -30,18 +30,6 @@ static struct clk_onecell_data ap806_clk_data = {
 	.clk_num = AP806_CLK_NUM,
 };
 
-static char *ap806_unique_name(struct device *dev, struct device_node *np,
-			       char *name)
-{
-	const __be32 *reg;
-	u64 addr;
-
-	reg = of_get_property(np, "reg", NULL);
-	addr = of_translate_address(np, reg);
-	return devm_kasprintf(dev, GFP_KERNEL, "%llx-%s",
-			(unsigned long long)addr, name);
-}
-
 static int ap806_syscon_common_probe(struct platform_device *pdev,
 				     struct device_node *syscon_node)
 {
@@ -109,7 +97,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 	cpuclk_freq *= 1000 * 1000;
 
 	/* CPU clocks depend on the Sample At Reset configuration */
-	name = ap806_unique_name(dev, syscon_node, "cpu-cluster-0");
+	name = ap_cp_unique_name(dev, syscon_node, "cpu-cluster-0");
 	ap806_clks[0] = clk_register_fixed_rate(dev, name, NULL,
 						0, cpuclk_freq);
 	if (IS_ERR(ap806_clks[0])) {
@@ -117,7 +105,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 		goto fail0;
 	}
 
-	name = ap806_unique_name(dev, syscon_node, "cpu-cluster-1");
+	name = ap_cp_unique_name(dev, syscon_node, "cpu-cluster-1");
 	ap806_clks[1] = clk_register_fixed_rate(dev, name, NULL, 0,
 						cpuclk_freq);
 	if (IS_ERR(ap806_clks[1])) {
@@ -126,7 +114,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 	}
 
 	/* Fixed clock is always 1200 Mhz */
-	fixedclk_name = ap806_unique_name(dev, syscon_node, "fixed");
+	fixedclk_name = ap_cp_unique_name(dev, syscon_node, "fixed");
 	ap806_clks[2] = clk_register_fixed_rate(dev, fixedclk_name, NULL,
 						0, 1200 * 1000 * 1000);
 	if (IS_ERR(ap806_clks[2])) {
@@ -135,7 +123,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 	}
 
 	/* MSS Clock is fixed clock divided by 6 */
-	name = ap806_unique_name(dev, syscon_node, "mss");
+	name = ap_cp_unique_name(dev, syscon_node, "mss");
 	ap806_clks[3] = clk_register_fixed_factor(NULL, name, fixedclk_name,
 						  0, 1, 6);
 	if (IS_ERR(ap806_clks[3])) {
@@ -144,7 +132,7 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 	}
 
 	/* SDIO(/eMMC) Clock is fixed clock divided by 3 */
-	name = ap806_unique_name(dev, syscon_node, "sdio");
+	name = ap_cp_unique_name(dev, syscon_node, "sdio");
 	ap806_clks[4] = clk_register_fixed_factor(NULL, name,
 						  fixedclk_name,
 						  0, 1, 3);

commit cd8ca3005269ec327643b3cc39681a6fcde16b0d
Merge: 5d3a48fe2cee 5beb1e60dba9 148edd50c807 e15d598b5c6f 6ffeddd6bca4 e3aaadb0f0d6
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Oct 18 15:39:08 2018 -0700

    Merge branches 'clk-mvebu-periph-pm', 'clk-meson', 'clk-allwinner', 'clk-mvebu-dup' and 'clk-davinci' into clk-next
    
     - S2RAM support for Marvell mvebu periph clks
    
    * clk-mvebu-periph-pm:
      clk: mvebu: armada-37xx-periph: add suspend/resume support
      clk: mvebu: armada-37xx-periph: save the IP base address in the driver data
    
    * clk-meson:
      clk: meson: meson8b: use the regmap in the internal reset controller
      clk: meson: meson8b: register the clock controller early
      clk: meson-axg: pcie: drop the mpll3 clock parent
      clk: meson: axg: round audio system master clocks down
      clk: meson: clk-pll: drop hard-coded rates from pll tables
      clk: meson: clk-pll: remove od parameters
      clk: meson: clk-pll: drop CLK_GET_RATE_NOCACHE where unnecessary
      clk: meson: clk-pll: add enable bit
    
    * clk-allwinner:
      dt-bindings: clock: sun50i-a64-ccu: Add PLL_VIDEO0 macro
      clk: sunxi-ng: a64: Add max. rate constraint to video PLLs
      clk: sunxi-ng: a64: Add minimal rate for video PLLs
      clk: sunxi-ng: sun50i: h6: Add 2x fixed post-divider to MMC module clocks
      clk: sunxi-ng: a83t: Add max. rate constraint to video PLLs
      clk: sunxi-ng: nkmp: Add constraint for maximum rate
      clk: sunxi-ng: r40: Add max. rate constraint to video PLLs
      clk: sunxi-ng: h3/h5: Add max. rate constraint to pll-video
      clk: sunxi-ng: Add maximum rate constraint to NM PLLs
      clk: sunxi-ng: h6: fix PWM gate/reset offset
      clk: sunxi-ng: h6: fix bus clocks' divider position
    
    * clk-mvebu-dup:
      clk: mvebu: ap806: Remove superfluous of_clk_add_provider
    
    * clk-davinci:
      clk: davinci: kill davinci_clk_reset_assert/deassert()

commit 6ffeddd6bca4cb838623d0bf4134c0eb06ad7485
Author: Gregory CLEMENT <gregory.clement@bootlin.com>
Date:   Wed Sep 12 17:35:49 2018 +0200

    clk: mvebu: ap806: Remove superfluous of_clk_add_provider
    
    While applying the commit a8309cedcdce ("clk: apn806: Add eMMC clock to
    system controller driver"), of_clk_add_provider was added wheres it was
    already present in the probe function.
    
    This extraneous call is harmless but not useful so remove it.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index fa2fbd2cef4a..cfc6b82d2448 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -155,7 +155,6 @@ static int ap806_syscon_common_probe(struct platform_device *pdev,
 		goto fail4;
 	}
 
-	of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);
 	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);
 	if (ret)
 		goto fail_clk_add;

commit c3828949a21d95326f08f02d97fea97172319300
Author: Gregory CLEMENT <gregory.clement@bootlin.com>
Date:   Wed Sep 12 15:40:17 2018 +0200

    clk: mvebu: use SPDX-License-Identifier
    
    Convert the remaining files to SPDX license description.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index fa2fbd2cef4a..9fbec3eb725f 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Marvell Armada AP806 System Controller
  *
@@ -5,9 +6,6 @@
  *
  * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  *
- * This file is licensed under the terms of the GNU General Public
- * License version 2.  This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
  */
 
 #define pr_fmt(fmt) "ap806-system-controller: " fmt

commit b90da67543e5aae5cb8162402ac5b483fb660dbd
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Wed May 31 16:07:26 2017 +0200

    clk: mvebu: ap806: introduce a new binding
    
    As for cp110, the initial intent when the binding of the ap806 system
    controller was to have one flat node. The idea being that what is
    currently a clock-only driver in drivers would become a MFD driver,
    exposing the clock, GPIO and pinctrl functionality. However, after taking
    a step back, this would lead to a messy binding. Indeed, a single node
    would be a GPIO controller, clock controller, pinmux controller, and
    more.
    
    This patch adopts a more classical solution of a top-level syscon node
    with sub-nodes for the individual devices. The main benefit will be to
    have each functional block associated to its own sub-node where we can
    put its own properties.
    
    The introduction of the Armada 7K/8K is still in the early stage so the
    plan is to remove the old binding. However, we don't want to break the
    device tree compatibility for the few devices already in the field. For
    this we still keep the support of the legacy compatible string with a big
    warning in the kernel about updating the device tree.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/cc8c8c40fa4c4e71133033358992ec38e5aa2be5.1496239589.git-series.gregory.clement@free-electrons.com

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 95ae16e203ea..fa2fbd2cef4a 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -44,7 +44,8 @@ static char *ap806_unique_name(struct device *dev, struct device_node *np,
 			(unsigned long long)addr, name);
 }
 
-static int ap806_syscon_clk_probe(struct platform_device *pdev)
+static int ap806_syscon_common_probe(struct platform_device *pdev,
+				     struct device_node *syscon_node)
 {
 	unsigned int freq_mode, cpuclk_freq;
 	const char *name, *fixedclk_name;
@@ -54,7 +55,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	u32 reg;
 	int ret;
 
-	regmap = syscon_node_to_regmap(np);
+	regmap = syscon_node_to_regmap(syscon_node);
 	if (IS_ERR(regmap)) {
 		dev_err(dev, "cannot get regmap\n");
 		return PTR_ERR(regmap);
@@ -110,7 +111,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	cpuclk_freq *= 1000 * 1000;
 
 	/* CPU clocks depend on the Sample At Reset configuration */
-	name = ap806_unique_name(dev, np, "cpu-cluster-0");
+	name = ap806_unique_name(dev, syscon_node, "cpu-cluster-0");
 	ap806_clks[0] = clk_register_fixed_rate(dev, name, NULL,
 						0, cpuclk_freq);
 	if (IS_ERR(ap806_clks[0])) {
@@ -118,7 +119,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 		goto fail0;
 	}
 
-	name = ap806_unique_name(dev, np, "cpu-cluster-1");
+	name = ap806_unique_name(dev, syscon_node, "cpu-cluster-1");
 	ap806_clks[1] = clk_register_fixed_rate(dev, name, NULL, 0,
 						cpuclk_freq);
 	if (IS_ERR(ap806_clks[1])) {
@@ -127,7 +128,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	}
 
 	/* Fixed clock is always 1200 Mhz */
-	fixedclk_name = ap806_unique_name(dev, np, "fixed");
+	fixedclk_name = ap806_unique_name(dev, syscon_node, "fixed");
 	ap806_clks[2] = clk_register_fixed_rate(dev, fixedclk_name, NULL,
 						0, 1200 * 1000 * 1000);
 	if (IS_ERR(ap806_clks[2])) {
@@ -136,7 +137,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	}
 
 	/* MSS Clock is fixed clock divided by 6 */
-	name = ap806_unique_name(dev, np, "mss");
+	name = ap806_unique_name(dev, syscon_node, "mss");
 	ap806_clks[3] = clk_register_fixed_factor(NULL, name, fixedclk_name,
 						  0, 1, 6);
 	if (IS_ERR(ap806_clks[3])) {
@@ -145,7 +146,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	}
 
 	/* SDIO(/eMMC) Clock is fixed clock divided by 3 */
-	name = ap806_unique_name(dev, np, "sdio");
+	name = ap806_unique_name(dev, syscon_node, "sdio");
 	ap806_clks[4] = clk_register_fixed_factor(NULL, name,
 						  fixedclk_name,
 						  0, 1, 3);
@@ -175,17 +176,48 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static const struct of_device_id ap806_syscon_of_match[] = {
+static int ap806_syscon_legacy_probe(struct platform_device *pdev)
+{
+	dev_warn(&pdev->dev, FW_WARN "Using legacy device tree binding\n");
+	dev_warn(&pdev->dev, FW_WARN "Update your device tree:\n");
+	dev_warn(&pdev->dev, FW_WARN
+		 "This binding won't be supported in future kernel\n");
+
+	return ap806_syscon_common_probe(pdev, pdev->dev.of_node);
+
+}
+
+static int ap806_clock_probe(struct platform_device *pdev)
+{
+	return ap806_syscon_common_probe(pdev, pdev->dev.of_node->parent);
+}
+
+static const struct of_device_id ap806_syscon_legacy_of_match[] = {
 	{ .compatible = "marvell,ap806-system-controller", },
 	{ }
 };
 
-static struct platform_driver ap806_syscon_driver = {
-	.probe = ap806_syscon_clk_probe,
+static struct platform_driver ap806_syscon_legacy_driver = {
+	.probe = ap806_syscon_legacy_probe,
 	.driver		= {
 		.name	= "marvell-ap806-system-controller",
-		.of_match_table = ap806_syscon_of_match,
+		.of_match_table = ap806_syscon_legacy_of_match,
+		.suppress_bind_attrs = true,
+	},
+};
+builtin_platform_driver(ap806_syscon_legacy_driver);
+
+static const struct of_device_id ap806_clock_of_match[] = {
+	{ .compatible = "marvell,ap806-clock", },
+	{ }
+};
+
+static struct platform_driver ap806_clock_driver = {
+	.probe = ap806_clock_probe,
+	.driver		= {
+		.name	= "marvell-ap806-clock",
+		.of_match_table = ap806_clock_of_match,
 		.suppress_bind_attrs = true,
 	},
 };
-builtin_platform_driver(ap806_syscon_driver);
+builtin_platform_driver(ap806_clock_driver);

commit 55de4d06b4589e5fba9f27b6876884e5af68890e
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Wed May 31 16:07:24 2017 +0200

    clk: mvebu: ap806: do not depend anymore of the *-clock-output-names
    
    As it was done for the cp110, this patch modifies the way the clock names
    are created. The name of each clock is now created by using its physical
    address as a prefix (as it was done for the platform device
    names). Thanks to this we have an automatic way to compute a unique name.
    
    Reviewed-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/e66cdd54d36c6bef78460a51e577f171b6ccb031.1496239589.git-series.gregory.clement@free-electrons.com

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index b2666b5c944f..95ae16e203ea 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -32,6 +32,18 @@ static struct clk_onecell_data ap806_clk_data = {
 	.clk_num = AP806_CLK_NUM,
 };
 
+static char *ap806_unique_name(struct device *dev, struct device_node *np,
+			       char *name)
+{
+	const __be32 *reg;
+	u64 addr;
+
+	reg = of_get_property(np, "reg", NULL);
+	addr = of_translate_address(np, reg);
+	return devm_kasprintf(dev, GFP_KERNEL, "%llx-%s",
+			(unsigned long long)addr, name);
+}
+
 static int ap806_syscon_clk_probe(struct platform_device *pdev)
 {
 	unsigned int freq_mode, cpuclk_freq;
@@ -98,8 +110,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	cpuclk_freq *= 1000 * 1000;
 
 	/* CPU clocks depend on the Sample At Reset configuration */
-	of_property_read_string_index(np, "clock-output-names",
-				      0, &name);
+	name = ap806_unique_name(dev, np, "cpu-cluster-0");
 	ap806_clks[0] = clk_register_fixed_rate(dev, name, NULL,
 						0, cpuclk_freq);
 	if (IS_ERR(ap806_clks[0])) {
@@ -107,8 +118,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 		goto fail0;
 	}
 
-	of_property_read_string_index(np, "clock-output-names",
-				      1, &name);
+	name = ap806_unique_name(dev, np, "cpu-cluster-1");
 	ap806_clks[1] = clk_register_fixed_rate(dev, name, NULL, 0,
 						cpuclk_freq);
 	if (IS_ERR(ap806_clks[1])) {
@@ -117,8 +127,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	}
 
 	/* Fixed clock is always 1200 Mhz */
-	of_property_read_string_index(np, "clock-output-names",
-				      2, &fixedclk_name);
+	fixedclk_name = ap806_unique_name(dev, np, "fixed");
 	ap806_clks[2] = clk_register_fixed_rate(dev, fixedclk_name, NULL,
 						0, 1200 * 1000 * 1000);
 	if (IS_ERR(ap806_clks[2])) {
@@ -127,8 +136,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	}
 
 	/* MSS Clock is fixed clock divided by 6 */
-	of_property_read_string_index(np, "clock-output-names",
-				      3, &name);
+	name = ap806_unique_name(dev, np, "mss");
 	ap806_clks[3] = clk_register_fixed_factor(NULL, name, fixedclk_name,
 						  0, 1, 6);
 	if (IS_ERR(ap806_clks[3])) {
@@ -136,20 +144,14 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 		goto fail3;
 	}
 
-	/* eMMC Clock is fixed clock divided by 3 */
-	if (of_property_read_string_index(np, "clock-output-names",
-					  4, &name)) {
-		ap806_clk_data.clk_num--;
-		dev_warn(&pdev->dev,
-			 "eMMC clock missing: update the device tree!\n");
-	} else {
-		ap806_clks[4] = clk_register_fixed_factor(NULL, name,
-							  fixedclk_name,
-							  0, 1, 3);
-		if (IS_ERR(ap806_clks[4])) {
-			ret = PTR_ERR(ap806_clks[4]);
-			goto fail4;
-		}
+	/* SDIO(/eMMC) Clock is fixed clock divided by 3 */
+	name = ap806_unique_name(dev, np, "sdio");
+	ap806_clks[4] = clk_register_fixed_factor(NULL, name,
+						  fixedclk_name,
+						  0, 1, 3);
+	if (IS_ERR(ap806_clks[4])) {
+		ret = PTR_ERR(ap806_clks[4]);
+		goto fail4;
 	}
 
 	of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);

commit d9ff21eea139430ce61bce885605f7828debf028
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Wed May 31 16:07:22 2017 +0200

    clk: mvebu: ap806: cosmetic improvement
    
    Instead of using &pdev->dev all over the place, introduce a pointer
    variable for it.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/5a55e081d96fc6d2a28331b59df90f56d32a9f24.1496239589.git-series.gregory.clement@free-electrons.com

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 8155baccc98e..b2666b5c944f 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -36,20 +36,21 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 {
 	unsigned int freq_mode, cpuclk_freq;
 	const char *name, *fixedclk_name;
-	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
 	struct regmap *regmap;
 	u32 reg;
 	int ret;
 
 	regmap = syscon_node_to_regmap(np);
 	if (IS_ERR(regmap)) {
-		dev_err(&pdev->dev, "cannot get regmap\n");
+		dev_err(dev, "cannot get regmap\n");
 		return PTR_ERR(regmap);
 	}
 
 	ret = regmap_read(regmap, AP806_SAR_REG, &reg);
 	if (ret) {
-		dev_err(&pdev->dev, "cannot read from regmap\n");
+		dev_err(dev, "cannot read from regmap\n");
 		return ret;
 	}
 
@@ -89,7 +90,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 		cpuclk_freq = 600;
 		break;
 	default:
-		dev_err(&pdev->dev, "invalid SAR value\n");
+		dev_err(dev, "invalid SAR value\n");
 		return -EINVAL;
 	}
 
@@ -99,7 +100,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	/* CPU clocks depend on the Sample At Reset configuration */
 	of_property_read_string_index(np, "clock-output-names",
 				      0, &name);
-	ap806_clks[0] = clk_register_fixed_rate(&pdev->dev, name, NULL,
+	ap806_clks[0] = clk_register_fixed_rate(dev, name, NULL,
 						0, cpuclk_freq);
 	if (IS_ERR(ap806_clks[0])) {
 		ret = PTR_ERR(ap806_clks[0]);
@@ -108,7 +109,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 
 	of_property_read_string_index(np, "clock-output-names",
 				      1, &name);
-	ap806_clks[1] = clk_register_fixed_rate(&pdev->dev, name, NULL, 0,
+	ap806_clks[1] = clk_register_fixed_rate(dev, name, NULL, 0,
 						cpuclk_freq);
 	if (IS_ERR(ap806_clks[1])) {
 		ret = PTR_ERR(ap806_clks[1]);
@@ -118,7 +119,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	/* Fixed clock is always 1200 Mhz */
 	of_property_read_string_index(np, "clock-output-names",
 				      2, &fixedclk_name);
-	ap806_clks[2] = clk_register_fixed_rate(&pdev->dev, fixedclk_name, NULL,
+	ap806_clks[2] = clk_register_fixed_rate(dev, fixedclk_name, NULL,
 						0, 1200 * 1000 * 1000);
 	if (IS_ERR(ap806_clks[2])) {
 		ret = PTR_ERR(ap806_clks[2]);

commit a82d12b8d5a626e30d2f15627079abdaa2e77c05
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Apr 11 14:37:43 2017 +0100

    clk: apn806: fix spelling mistake: "mising" -> "missing"
    
    trivial fix to spelling mistake in dev_warn message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 103fe18a3c29..8155baccc98e 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -140,7 +140,7 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 					  4, &name)) {
 		ap806_clk_data.clk_num--;
 		dev_warn(&pdev->dev,
-			 "eMMC clock mising: update the device tree!\n");
+			 "eMMC clock missing: update the device tree!\n");
 	} else {
 		ap806_clks[4] = clk_register_fixed_factor(NULL, name,
 							  fixedclk_name,

commit b92a3bcc7c3ca4ee8d228f033de32aefff3c74a4
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Thu Mar 30 17:22:54 2017 +0200

    clk: apn806: Turn the eMMC clock as optional for dts backwards compatible
    
    First version of the binding didn't have the eMMC clock. This patch
    allows to not registering the eMMC clock if it is not present in the
    device tree. Then the device tree can be backwards compatible.
    
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 901d89c4ab4a..103fe18a3c29 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -136,13 +136,19 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	}
 
 	/* eMMC Clock is fixed clock divided by 3 */
-	of_property_read_string_index(np, "clock-output-names",
-				      4, &name);
-	ap806_clks[4] = clk_register_fixed_factor(NULL, name, fixedclk_name,
-						  0, 1, 3);
-	if (IS_ERR(ap806_clks[4])) {
-		ret = PTR_ERR(ap806_clks[4]);
-		goto fail4;
+	if (of_property_read_string_index(np, "clock-output-names",
+					  4, &name)) {
+		ap806_clk_data.clk_num--;
+		dev_warn(&pdev->dev,
+			 "eMMC clock mising: update the device tree!\n");
+	} else {
+		ap806_clks[4] = clk_register_fixed_factor(NULL, name,
+							  fixedclk_name,
+							  0, 1, 3);
+		if (IS_ERR(ap806_clks[4])) {
+			ret = PTR_ERR(ap806_clks[4]);
+			goto fail4;
+		}
 	}
 
 	of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);

commit a8309cedcdce94fc6e36d49d0bf8e75d5813ebc6
Author: Konstantin Porotchkin <kostap@marvell.com>
Date:   Thu Mar 30 17:22:53 2017 +0200

    clk: apn806: Add eMMC clock to system controller driver
    
    Add fixed clock of 400MHz to system controller driver.  This clock is
    used as SD/eMMC clock source.
    
    Signed-off-by: Konstantin Porotchkin <kostap@marvell.com>
    Reviewed-by: Omri Itach <omrii@marvell.com>
    Reviewed-by: Hanna Hawa <hannah@marvell.com>
    [fixed up conflicts, added error handling --rmk]
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index f17702107ac5..901d89c4ab4a 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -23,7 +23,7 @@
 #define AP806_SAR_REG			0x400
 #define AP806_SAR_CLKFREQ_MODE_MASK	0x1f
 
-#define AP806_CLK_NUM			4
+#define AP806_CLK_NUM			5
 
 static struct clk *ap806_clks[AP806_CLK_NUM];
 
@@ -135,6 +135,17 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 		goto fail3;
 	}
 
+	/* eMMC Clock is fixed clock divided by 3 */
+	of_property_read_string_index(np, "clock-output-names",
+				      4, &name);
+	ap806_clks[4] = clk_register_fixed_factor(NULL, name, fixedclk_name,
+						  0, 1, 3);
+	if (IS_ERR(ap806_clks[4])) {
+		ret = PTR_ERR(ap806_clks[4]);
+		goto fail4;
+	}
+
+	of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);
 	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);
 	if (ret)
 		goto fail_clk_add;
@@ -142,6 +153,8 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	return 0;
 
 fail_clk_add:
+	clk_unregister_fixed_factor(ap806_clks[4]);
+fail4:
 	clk_unregister_fixed_factor(ap806_clks[3]);
 fail3:
 	clk_unregister_fixed_rate(ap806_clks[2]);

commit 0c70ffc5f300e7c3a1a76ca0530860574afc890b
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Dec 22 13:08:14 2016 +0100

    clk: mvebu: adjust AP806 CPU clock frequencies to production chip
    
    This commit adjusts the list of possible "Sample At Reset" values that
    define the CPU clock frequency of the AP806 (part of Marvell Armada
    7K/8K) to the values that have been validated with the production
    chip. Earlier values were preliminary.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 8181b919f062..f17702107ac5 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -55,21 +55,39 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 
 	freq_mode = reg & AP806_SAR_CLKFREQ_MODE_MASK;
 	switch (freq_mode) {
-	case 0x0 ... 0x5:
+	case 0x0:
+	case 0x1:
 		cpuclk_freq = 2000;
 		break;
-	case 0x6 ... 0xB:
+	case 0x6:
+	case 0x7:
 		cpuclk_freq = 1800;
 		break;
-	case 0xC ... 0x11:
+	case 0x4:
+	case 0xB:
+	case 0xD:
 		cpuclk_freq = 1600;
 		break;
-	case 0x12 ... 0x16:
+	case 0x1a:
 		cpuclk_freq = 1400;
 		break;
-	case 0x17 ... 0x19:
+	case 0x14:
+	case 0x17:
 		cpuclk_freq = 1300;
 		break;
+	case 0x19:
+		cpuclk_freq = 1200;
+		break;
+	case 0x13:
+	case 0x1d:
+		cpuclk_freq = 1000;
+		break;
+	case 0x1c:
+		cpuclk_freq = 800;
+		break;
+	case 0x1b:
+		cpuclk_freq = 600;
+		break;
 	default:
 		dev_err(&pdev->dev, "invalid SAR value\n");
 		return -EINVAL;

commit 188e8719c50d7b092868729f09c2541e677f49df
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jul 4 17:12:14 2016 -0400

    clk: mvebu: make ap806-system-controller explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    drivers/clk/mvebu/Kconfig:config ARMADA_AP806_SYSCON
    drivers/clk/mvebu/Kconfig:      bool
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the modular code that is essentially orphaned, so that
    when reading the driver there is no doubt it is builtin-only.
    
    We explicitly disallow a driver unbind, since that doesn't have a
    sensible use case anyway, and it allows us to drop the ".remove"
    code for non-modular drivers.
    
    Since module_platform_driver() uses the same init level priority as
    builtin_platform_driver() the init ordering remains unchanged with
    this commit.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    We also delete the MODULE_LICENSE tag etc. since all that information
    is already contained at the top of the file in the comments.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: linux-clk@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
index 02023baf86c9..8181b919f062 100644
--- a/drivers/clk/mvebu/ap806-system-controller.c
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -14,7 +14,7 @@
 
 #include <linux/clk-provider.h>
 #include <linux/mfd/syscon.h>
-#include <linux/module.h>
+#include <linux/init.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
@@ -135,34 +135,17 @@ static int ap806_syscon_clk_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int ap806_syscon_clk_remove(struct platform_device *pdev)
-{
-	of_clk_del_provider(pdev->dev.of_node);
-	clk_unregister_fixed_factor(ap806_clks[3]);
-	clk_unregister_fixed_rate(ap806_clks[2]);
-	clk_unregister_fixed_rate(ap806_clks[1]);
-	clk_unregister_fixed_rate(ap806_clks[0]);
-
-	return 0;
-}
-
 static const struct of_device_id ap806_syscon_of_match[] = {
 	{ .compatible = "marvell,ap806-system-controller", },
 	{ }
 };
-MODULE_DEVICE_TABLE(of, armada8k_pcie_of_match);
 
 static struct platform_driver ap806_syscon_driver = {
 	.probe = ap806_syscon_clk_probe,
-	.remove = ap806_syscon_clk_remove,
 	.driver		= {
 		.name	= "marvell-ap806-system-controller",
 		.of_match_table = ap806_syscon_of_match,
+		.suppress_bind_attrs = true,
 	},
 };
-
-module_platform_driver(ap806_syscon_driver);
-
-MODULE_DESCRIPTION("Marvell AP806 System Controller driver");
-MODULE_AUTHOR("Thomas Petazzoni <thomas.petazzoni@free-electrons.com>");
-MODULE_LICENSE("GPL");
+builtin_platform_driver(ap806_syscon_driver);

commit 89a426b1966588eb215ec08530054016ee10b0cc
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Apr 14 17:33:31 2016 +0200

    clk: mvebu: new driver for Armada AP806 system controller
    
    The Armada AP806 system controller, amongst other things, provides a
    number of clocks for the platform: the CPU cluster clocks, whose
    frequencies are found by reading the Sample At Reset register, one
    fixed clock, and another clock derived from the fixed clock, which is
    the one used by most peripherals in AP806.
    
    The AP806 is one of the two core HW blocks used in the Marvell 7K/8K
    SoCs.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    [sboyd@codeaurora.org: Silence some checkpatch noise]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/mvebu/ap806-system-controller.c b/drivers/clk/mvebu/ap806-system-controller.c
new file mode 100644
index 000000000000..02023baf86c9
--- /dev/null
+++ b/drivers/clk/mvebu/ap806-system-controller.c
@@ -0,0 +1,168 @@
+/*
+ * Marvell Armada AP806 System Controller
+ *
+ * Copyright (C) 2016 Marvell
+ *
+ * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define pr_fmt(fmt) "ap806-system-controller: " fmt
+
+#include <linux/clk-provider.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+#define AP806_SAR_REG			0x400
+#define AP806_SAR_CLKFREQ_MODE_MASK	0x1f
+
+#define AP806_CLK_NUM			4
+
+static struct clk *ap806_clks[AP806_CLK_NUM];
+
+static struct clk_onecell_data ap806_clk_data = {
+	.clks = ap806_clks,
+	.clk_num = AP806_CLK_NUM,
+};
+
+static int ap806_syscon_clk_probe(struct platform_device *pdev)
+{
+	unsigned int freq_mode, cpuclk_freq;
+	const char *name, *fixedclk_name;
+	struct device_node *np = pdev->dev.of_node;
+	struct regmap *regmap;
+	u32 reg;
+	int ret;
+
+	regmap = syscon_node_to_regmap(np);
+	if (IS_ERR(regmap)) {
+		dev_err(&pdev->dev, "cannot get regmap\n");
+		return PTR_ERR(regmap);
+	}
+
+	ret = regmap_read(regmap, AP806_SAR_REG, &reg);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot read from regmap\n");
+		return ret;
+	}
+
+	freq_mode = reg & AP806_SAR_CLKFREQ_MODE_MASK;
+	switch (freq_mode) {
+	case 0x0 ... 0x5:
+		cpuclk_freq = 2000;
+		break;
+	case 0x6 ... 0xB:
+		cpuclk_freq = 1800;
+		break;
+	case 0xC ... 0x11:
+		cpuclk_freq = 1600;
+		break;
+	case 0x12 ... 0x16:
+		cpuclk_freq = 1400;
+		break;
+	case 0x17 ... 0x19:
+		cpuclk_freq = 1300;
+		break;
+	default:
+		dev_err(&pdev->dev, "invalid SAR value\n");
+		return -EINVAL;
+	}
+
+	/* Convert to hertz */
+	cpuclk_freq *= 1000 * 1000;
+
+	/* CPU clocks depend on the Sample At Reset configuration */
+	of_property_read_string_index(np, "clock-output-names",
+				      0, &name);
+	ap806_clks[0] = clk_register_fixed_rate(&pdev->dev, name, NULL,
+						0, cpuclk_freq);
+	if (IS_ERR(ap806_clks[0])) {
+		ret = PTR_ERR(ap806_clks[0]);
+		goto fail0;
+	}
+
+	of_property_read_string_index(np, "clock-output-names",
+				      1, &name);
+	ap806_clks[1] = clk_register_fixed_rate(&pdev->dev, name, NULL, 0,
+						cpuclk_freq);
+	if (IS_ERR(ap806_clks[1])) {
+		ret = PTR_ERR(ap806_clks[1]);
+		goto fail1;
+	}
+
+	/* Fixed clock is always 1200 Mhz */
+	of_property_read_string_index(np, "clock-output-names",
+				      2, &fixedclk_name);
+	ap806_clks[2] = clk_register_fixed_rate(&pdev->dev, fixedclk_name, NULL,
+						0, 1200 * 1000 * 1000);
+	if (IS_ERR(ap806_clks[2])) {
+		ret = PTR_ERR(ap806_clks[2]);
+		goto fail2;
+	}
+
+	/* MSS Clock is fixed clock divided by 6 */
+	of_property_read_string_index(np, "clock-output-names",
+				      3, &name);
+	ap806_clks[3] = clk_register_fixed_factor(NULL, name, fixedclk_name,
+						  0, 1, 6);
+	if (IS_ERR(ap806_clks[3])) {
+		ret = PTR_ERR(ap806_clks[3]);
+		goto fail3;
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);
+	if (ret)
+		goto fail_clk_add;
+
+	return 0;
+
+fail_clk_add:
+	clk_unregister_fixed_factor(ap806_clks[3]);
+fail3:
+	clk_unregister_fixed_rate(ap806_clks[2]);
+fail2:
+	clk_unregister_fixed_rate(ap806_clks[1]);
+fail1:
+	clk_unregister_fixed_rate(ap806_clks[0]);
+fail0:
+	return ret;
+}
+
+static int ap806_syscon_clk_remove(struct platform_device *pdev)
+{
+	of_clk_del_provider(pdev->dev.of_node);
+	clk_unregister_fixed_factor(ap806_clks[3]);
+	clk_unregister_fixed_rate(ap806_clks[2]);
+	clk_unregister_fixed_rate(ap806_clks[1]);
+	clk_unregister_fixed_rate(ap806_clks[0]);
+
+	return 0;
+}
+
+static const struct of_device_id ap806_syscon_of_match[] = {
+	{ .compatible = "marvell,ap806-system-controller", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, armada8k_pcie_of_match);
+
+static struct platform_driver ap806_syscon_driver = {
+	.probe = ap806_syscon_clk_probe,
+	.remove = ap806_syscon_clk_remove,
+	.driver		= {
+		.name	= "marvell-ap806-system-controller",
+		.of_match_table = ap806_syscon_of_match,
+	},
+};
+
+module_platform_driver(ap806_syscon_driver);
+
+MODULE_DESCRIPTION("Marvell AP806 System Controller driver");
+MODULE_AUTHOR("Thomas Petazzoni <thomas.petazzoni@free-electrons.com>");
+MODULE_LICENSE("GPL");
