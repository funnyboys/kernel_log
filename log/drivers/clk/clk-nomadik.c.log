commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index a95aa96f4a68..bad2677e11ae 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Nomadik clock implementation
  * Copyright (C) 2013 ST-Ericsson AB
- * License terms: GNU General Public License (GPL) version 2
  * Author: Linus Walleij <linus.walleij@linaro.org>
  */
 

commit 9579346ecf761303fc85be908d1ad3d947fac354
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Fri Nov 23 10:06:00 2018 -0500

    clk: nomadik: Change to use DEFINE_SHOW_ATTRIBUTE macro
    
    Use macro to simplify the code.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    [sboyd@kernel.org: Rename show function to keep compiling]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 84a24875c629..a95aa96f4a68 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -455,7 +455,7 @@ static const char * const src_clk_names[] = {
 	"RNGCCLK   ",
 };
 
-static int nomadik_src_clk_show(struct seq_file *s, void *what)
+static int nomadik_src_clk_debugfs_show(struct seq_file *s, void *what)
 {
 	int i;
 	u32 src_pcksr0 = readl(src_base + SRC_PCKSR0);
@@ -479,17 +479,7 @@ static int nomadik_src_clk_show(struct seq_file *s, void *what)
 	return 0;
 }
 
-static int nomadik_src_clk_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, nomadik_src_clk_show, NULL);
-}
-
-static const struct file_operations nomadik_src_clk_debugfs_ops = {
-	.open           = nomadik_src_clk_open,
-	.read           = seq_read,
-        .llseek         = seq_lseek,
-	.release        = single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(nomadik_src_clk_debugfs);
 
 static int __init nomadik_src_clk_init_debugfs(void)
 {
@@ -499,7 +489,7 @@ static int __init nomadik_src_clk_init_debugfs(void)
 	src_pcksr0_boot = readl(src_base + SRC_PCKSR0);
 	src_pcksr1_boot = readl(src_base + SRC_PCKSR1);
 	debugfs_create_file("nomadik-src-clk", S_IFREG | S_IRUGO,
-			    NULL, NULL, &nomadik_src_clk_debugfs_ops);
+			    NULL, NULL, &nomadik_src_clk_debugfs_fops);
 	return 0;
 }
 device_initcall(nomadik_src_clk_init_debugfs);

commit e665f029a283aff4f36f0c5388f7c708be67470e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Aug 28 10:44:29 2018 -0500

    clk: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 13ad6d1e5090..84a24875c629 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -97,8 +97,8 @@ static void __init nomadik_src_init(void)
 	}
 	src_base = of_iomap(np, 0);
 	if (!src_base) {
-		pr_err("%s: must have src parent node with REGS (%s)\n",
-		       __func__, np->name);
+		pr_err("%s: must have src parent node with REGS (%pOFn)\n",
+		       __func__, np);
 		return;
 	}
 

commit 24f8186eb8d69a3a0d856ce59fb4f19ae23ff23a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Apr 20 10:04:00 2017 +0200

    clk: nomadik: Delete error messages for a failed memory allocation in two functions
    
    The script "checkpatch.pl" pointed information out like the following.
    
    WARNING: Possible unnecessary 'out of memory' message
    
    Thus remove such statements here.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 8d57ab8d6ed8..13ad6d1e5090 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -267,10 +267,8 @@ pll_clk_register(struct device *dev, const char *name,
 	}
 
 	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
-	if (!pll) {
-		pr_err("%s: could not allocate PLL clk\n", __func__);
+	if (!pll)
 		return ERR_PTR(-ENOMEM);
-	}
 
 	init.name = name;
 	init.ops = &pll_clk_ops;
@@ -356,11 +354,9 @@ src_clk_register(struct device *dev, const char *name,
 	struct clk_init_data init;
 
 	sclk = kzalloc(sizeof(*sclk), GFP_KERNEL);
-	if (!sclk) {
-		pr_err("could not allocate SRC clock %s\n",
-			name);
+	if (!sclk)
 		return ERR_PTR(-ENOMEM);
-	}
+
 	init.name = name;
 	init.ops = &src_clk_ops;
 	/* Do not force-disable the static SDRAM controller */

commit add3151133b9ae3bcfd97eab04d9a50b6606453c
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Apr 20 09:45:04 2017 +0200

    clk: nomadik: Use seq_puts() in nomadik_src_clk_show()
    
    A string which did not contain a data format specification should be put
    into a sequence. Thus use the corresponding function "seq_puts".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 71677eb12565..8d57ab8d6ed8 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -467,7 +467,7 @@ static int nomadik_src_clk_show(struct seq_file *s, void *what)
 	u32 src_pckensr0 = readl(src_base + SRC_PCKENSR0);
 	u32 src_pckensr1 = readl(src_base + SRC_PCKENSR1);
 
-	seq_printf(s, "Clock:      Boot:   Now:    Request: ASKED:\n");
+	seq_puts(s, "Clock:      Boot:   Now:    Request: ASKED:\n");
 	for (i = 0; i < ARRAY_SIZE(src_clk_names); i++) {
 		u32 pcksrb = (i < 0x20) ? src_pcksr0_boot : src_pcksr1_boot;
 		u32 pcksr = (i < 0x20) ? src_pcksr0 : src_pcksr1;

commit 7b38d1b222b42cfed197290332a8e426fb77e8fe
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Jun 1 16:15:19 2016 -0700

    clk: nomadik: Migrate to clk_hw based OF and registration APIs
    
    Now that we have clk_hw based provider APIs to register clks, we
    can get rid of struct clk pointers while registering clks in
    these drivers, allowing us to move closer to a clear split of
    consumer and provider clk APIs.
    
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index e4d8a991c58f..71677eb12565 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -253,11 +253,11 @@ static const struct clk_ops pll_clk_ops = {
 	.recalc_rate = pll_clk_recalc_rate,
 };
 
-static struct clk * __init
+static struct clk_hw * __init
 pll_clk_register(struct device *dev, const char *name,
 		 const char *parent_name, u32 id)
 {
-	struct clk *clk;
+	int ret;
 	struct clk_pll *pll;
 	struct clk_init_data init;
 
@@ -281,11 +281,13 @@ pll_clk_register(struct device *dev, const char *name,
 
 	pr_debug("register PLL1 clock \"%s\"\n", name);
 
-	clk = clk_register(dev, &pll->hw);
-	if (IS_ERR(clk))
+	ret = clk_hw_register(dev, &pll->hw);
+	if (ret) {
 		kfree(pll);
+		return ERR_PTR(ret);
+	}
 
-	return clk;
+	return &pll->hw;
 }
 
 /*
@@ -345,11 +347,11 @@ static const struct clk_ops src_clk_ops = {
 	.recalc_rate = src_clk_recalc_rate,
 };
 
-static struct clk * __init
+static struct clk_hw * __init
 src_clk_register(struct device *dev, const char *name,
 		 const char *parent_name, u8 id)
 {
-	struct clk *clk;
+	int ret;
 	struct clk_src *sclk;
 	struct clk_init_data init;
 
@@ -376,11 +378,13 @@ src_clk_register(struct device *dev, const char *name,
 	pr_debug("register clock \"%s\" ID: %d group: %d bits: %08x\n",
 		 name, id, sclk->group1, sclk->clkbit);
 
-	clk = clk_register(dev, &sclk->hw);
-	if (IS_ERR(clk))
+	ret = clk_hw_register(dev, &sclk->hw);
+	if (ret) {
 		kfree(sclk);
+		return ERR_PTR(ret);
+	}
 
-	return clk;
+	return &sclk->hw;
 }
 
 #ifdef CONFIG_DEBUG_FS
@@ -508,7 +512,7 @@ device_initcall(nomadik_src_clk_init_debugfs);
 
 static void __init of_nomadik_pll_setup(struct device_node *np)
 {
-	struct clk *clk = ERR_PTR(-EINVAL);
+	struct clk_hw *hw;
 	const char *clk_name = np->name;
 	const char *parent_name;
 	u32 pll_id;
@@ -522,16 +526,16 @@ static void __init of_nomadik_pll_setup(struct device_node *np)
 		return;
 	}
 	parent_name = of_clk_get_parent_name(np, 0);
-	clk = pll_clk_register(NULL, clk_name, parent_name, pll_id);
-	if (!IS_ERR(clk))
-		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	hw = pll_clk_register(NULL, clk_name, parent_name, pll_id);
+	if (!IS_ERR(hw))
+		of_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);
 }
 CLK_OF_DECLARE(nomadik_pll_clk,
 	"st,nomadik-pll-clock", of_nomadik_pll_setup);
 
 static void __init of_nomadik_hclk_setup(struct device_node *np)
 {
-	struct clk *clk = ERR_PTR(-EINVAL);
+	struct clk_hw *hw;
 	const char *clk_name = np->name;
 	const char *parent_name;
 
@@ -542,20 +546,20 @@ static void __init of_nomadik_hclk_setup(struct device_node *np)
 	/*
 	 * The HCLK divides PLL1 with 1 (passthru), 2, 3 or 4.
 	 */
-	clk = clk_register_divider(NULL, clk_name, parent_name,
+	hw = clk_hw_register_divider(NULL, clk_name, parent_name,
 			   0, src_base + SRC_CR,
 			   13, 2,
 			   CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,
 			   &src_lock);
-	if (!IS_ERR(clk))
-		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	if (!IS_ERR(hw))
+		of_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);
 }
 CLK_OF_DECLARE(nomadik_hclk_clk,
 	"st,nomadik-hclk-clock", of_nomadik_hclk_setup);
 
 static void __init of_nomadik_src_clk_setup(struct device_node *np)
 {
-	struct clk *clk = ERR_PTR(-EINVAL);
+	struct clk_hw *hw;
 	const char *clk_name = np->name;
 	const char *parent_name;
 	u32 clk_id;
@@ -569,9 +573,9 @@ static void __init of_nomadik_src_clk_setup(struct device_node *np)
 		return;
 	}
 	parent_name = of_clk_get_parent_name(np, 0);
-	clk = src_clk_register(NULL, clk_name, parent_name, clk_id);
-	if (!IS_ERR(clk))
-		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	hw = src_clk_register(NULL, clk_name, parent_name, clk_id);
+	if (!IS_ERR(hw))
+		of_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);
 }
 CLK_OF_DECLARE(nomadik_src_clk,
 	"st,nomadik-src-clock", of_nomadik_src_clk_setup);

commit aa1a7fc4a9203d4b53d41d0e60ac774d83c666fb
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: nomadik: Remove clk.h and clkdev.h includes
    
    Clock provider drivers generally shouldn't include clk.h because
    it's the consumer API. Remove the include here because this is a
    provider driver. This driver also includes clkdev.h even though
    it isn't used, so drop it too and add slab.h to make sure
    everything still compiles.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index c9487179f25f..e4d8a991c58f 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -8,8 +8,7 @@
 #define pr_fmt(fmt) "Nomadik SRC clocks: " fmt
 
 #include <linux/bitops.h>
-#include <linux/clk.h>
-#include <linux/clkdev.h>
+#include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/clk-provider.h>

commit 791ed0bb5558dfdc4040563bd0b7dc24450fa732
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 1 20:05:51 2015 -0400

    drivers/clk: don't use module_init in clk-nomadik.c which is non-modular
    
    The clk-nomadik.o is built for ARCH_NOMADIK -- which is bool, and
    hence this code is either present or absent.  It will never be
    modular, so using module_init as an alias for __initcall can be
    somewhat misleading.
    
    Fix this up now, so that we can relocate module_init from
    init.h into module.h in the future.  If we don't do this, we'd
    have to add module.h to obviously non-modular code, and that
    would be a worse thing.
    
    Note that direct use of __initcall is discouraged, vs. one
    of the priority categorized subgroups.  As __initcall gets
    mapped onto device_initcall, our use of device_initcall
    directly in this change means that the runtime impact is
    zero -- it will remain at level 6 in initcall ordering.
    
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 05e04ce0f148..c9487179f25f 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -503,8 +503,7 @@ static int __init nomadik_src_clk_init_debugfs(void)
 			    NULL, NULL, &nomadik_src_clk_debugfs_ops);
 	return 0;
 }
-
-module_init(nomadik_src_clk_init_debugfs);
+device_initcall(nomadik_src_clk_init_debugfs);
 
 #endif
 

commit ec6deea1a147a10baf1672dc66025a13bc259680
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 21 09:06:21 2014 +0100

    clk: nomadik: fix multiplatform problem
    
    The Nomadik debugfs screws up multiplatform boots if debugfs
    is enabled on the multiplatform image, since it's a simple
    initcall that is unconditionally executed and reads from certain
    memory locations.
    
    Fix this by checking that the driver has been properly
    initialized, so a base offset to the Nomadik SRC controller
    exists, before proceeding to register debugfs files.
    
    Reported-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 6a934a5296bd..05e04ce0f148 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -494,6 +494,9 @@ static const struct file_operations nomadik_src_clk_debugfs_ops = {
 
 static int __init nomadik_src_clk_init_debugfs(void)
 {
+	/* Vital for multiplatform */
+	if (!src_base)
+		return -ENODEV;
 	src_pcksr0_boot = readl(src_base + SRC_PCKSR0);
 	src_pcksr1_boot = readl(src_base + SRC_PCKSR1);
 	debugfs_create_file("nomadik-src-clk", S_IFREG | S_IRUGO,

commit 54bf93c49a9a7a395df3a6442c5b6bf428c945cb
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Mon Oct 7 19:53:13 2013 +0200

    clk: nomadik: fix missing __init on nomadik_src_init
    
    nomadik_src_init references __initconst sections but lacks an __init
    itself. Add __init to fix the section mismatch.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index ce2d6b32e3f5..6a934a5296bd 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -86,7 +86,7 @@ static const struct of_device_id nomadik_src_match[] __initconst = {
 	{ /* sentinel */ }
 };
 
-static void nomadik_src_init(void)
+static void __init nomadik_src_init(void)
 {
 	struct device_node *np;
 	u32 val;

commit 74227e65f9742f559f6e243ba2c9a983e1f1221d
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Tue Sep 17 00:32:34 2013 +0200

    clk: nomadik: declare OF clock provider
    
    Common clock framework allows to register clock providers to get called
    on of_clk_init() by using CLK_OF_DECLARE. This converts nomadik clock
    provider to make use of it and get rid of the mach specific clk init
    call. As clocks require system reset controller base address to be
    initialized each clock driver checks src_base and calls new
    nomadik_src_init if required.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 06b29c264dbe..ce2d6b32e3f5 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -512,6 +512,9 @@ static void __init of_nomadik_pll_setup(struct device_node *np)
 	const char *parent_name;
 	u32 pll_id;
 
+	if (!src_base)
+		nomadik_src_init();
+
 	if (of_property_read_u32(np, "pll-id", &pll_id)) {
 		pr_err("%s: PLL \"%s\" missing pll-id property\n",
 			__func__, clk_name);
@@ -522,6 +525,8 @@ static void __init of_nomadik_pll_setup(struct device_node *np)
 	if (!IS_ERR(clk))
 		of_clk_add_provider(np, of_clk_src_simple_get, clk);
 }
+CLK_OF_DECLARE(nomadik_pll_clk,
+	"st,nomadik-pll-clock", of_nomadik_pll_setup);
 
 static void __init of_nomadik_hclk_setup(struct device_node *np)
 {
@@ -529,6 +534,9 @@ static void __init of_nomadik_hclk_setup(struct device_node *np)
 	const char *clk_name = np->name;
 	const char *parent_name;
 
+	if (!src_base)
+		nomadik_src_init();
+
 	parent_name = of_clk_get_parent_name(np, 0);
 	/*
 	 * The HCLK divides PLL1 with 1 (passthru), 2, 3 or 4.
@@ -541,6 +549,8 @@ static void __init of_nomadik_hclk_setup(struct device_node *np)
 	if (!IS_ERR(clk))
 		of_clk_add_provider(np, of_clk_src_simple_get, clk);
 }
+CLK_OF_DECLARE(nomadik_hclk_clk,
+	"st,nomadik-hclk-clock", of_nomadik_hclk_setup);
 
 static void __init of_nomadik_src_clk_setup(struct device_node *np)
 {
@@ -549,6 +559,9 @@ static void __init of_nomadik_src_clk_setup(struct device_node *np)
 	const char *parent_name;
 	u32 clk_id;
 
+	if (!src_base)
+		nomadik_src_init();
+
 	if (of_property_read_u32(np, "clock-id", &clk_id)) {
 		pr_err("%s: SRC clock \"%s\" missing clock-id property\n",
 			__func__, clk_name);
@@ -559,33 +572,5 @@ static void __init of_nomadik_src_clk_setup(struct device_node *np)
 	if (!IS_ERR(clk))
 		of_clk_add_provider(np, of_clk_src_simple_get, clk);
 }
-
-static const struct of_device_id nomadik_src_clk_match[] __initconst = {
-	{
-		.compatible = "fixed-clock",
-		.data = of_fixed_clk_setup,
-	},
-	{
-		.compatible = "fixed-factor-clock",
-		.data = of_fixed_factor_clk_setup,
-	},
-	{
-		.compatible = "st,nomadik-pll-clock",
-		.data = of_nomadik_pll_setup,
-	},
-	{
-		.compatible = "st,nomadik-hclk-clock",
-		.data = of_nomadik_hclk_setup,
-	},
-	{
-		.compatible = "st,nomadik-src-clock",
-		.data = of_nomadik_src_clk_setup,
-	},
-	{ /* sentinel */ }
-};
-
-void __init nomadik_clk_init(void)
-{
-	nomadik_src_init();
-	of_clk_init(nomadik_src_clk_match);
-}
+CLK_OF_DECLARE(nomadik_src_clk,
+	"st,nomadik-src-clock", of_nomadik_src_clk_setup);

commit ea25a900f593cd34347ec884b3acac09ffe07667
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Sun Sep 22 18:17:28 2013 +0200

    clk: nomadik: move src init out of nomadik_clk_init
    
    nomadik_clk_init currently also maps system reset controller base address
    used by clocks and registers a reboot notifier. To allow further cleanup of
    nomadik clk setup, this moves system reset controller setup from
    nomadik_clk_init to its own function.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 4d978a3c88f7..06b29c264dbe 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -62,6 +62,79 @@ static DEFINE_SPINLOCK(src_lock);
 /* Base address of the SRC */
 static void __iomem *src_base;
 
+static int nomadik_clk_reboot_handler(struct notifier_block *this,
+				unsigned long code,
+				void *unused)
+{
+	u32 val;
+
+	/* The main chrystal need to be enabled for reboot to work */
+	val = readl(src_base + SRC_XTALCR);
+	val &= ~SRC_XTALCR_MXTALOVER;
+	val |= SRC_XTALCR_MXTALEN;
+	pr_crit("force-enabling MXTALO\n");
+	writel(val, src_base + SRC_XTALCR);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block nomadik_clk_reboot_notifier = {
+	.notifier_call = nomadik_clk_reboot_handler,
+};
+
+static const struct of_device_id nomadik_src_match[] __initconst = {
+	{ .compatible = "stericsson,nomadik-src" },
+	{ /* sentinel */ }
+};
+
+static void nomadik_src_init(void)
+{
+	struct device_node *np;
+	u32 val;
+
+	np = of_find_matching_node(NULL, nomadik_src_match);
+	if (!np) {
+		pr_crit("no matching node for SRC, aborting clock init\n");
+		return;
+	}
+	src_base = of_iomap(np, 0);
+	if (!src_base) {
+		pr_err("%s: must have src parent node with REGS (%s)\n",
+		       __func__, np->name);
+		return;
+	}
+
+	/* Set all timers to use the 2.4 MHz TIMCLK */
+	val = readl(src_base + SRC_CR);
+	val |= SRC_CR_T0_ENSEL;
+	val |= SRC_CR_T1_ENSEL;
+	val |= SRC_CR_T2_ENSEL;
+	val |= SRC_CR_T3_ENSEL;
+	val |= SRC_CR_T4_ENSEL;
+	val |= SRC_CR_T5_ENSEL;
+	val |= SRC_CR_T6_ENSEL;
+	val |= SRC_CR_T7_ENSEL;
+	writel(val, src_base + SRC_CR);
+
+	val = readl(src_base + SRC_XTALCR);
+	pr_info("SXTALO is %s\n",
+		(val & SRC_XTALCR_SXTALDIS) ? "disabled" : "enabled");
+	pr_info("MXTAL is %s\n",
+		(val & SRC_XTALCR_MXTALSTAT) ? "enabled" : "disabled");
+	if (of_property_read_bool(np, "disable-sxtalo")) {
+		/* The machine uses an external oscillator circuit */
+		val |= SRC_XTALCR_SXTALDIS;
+		pr_info("disabling SXTALO\n");
+	}
+	if (of_property_read_bool(np, "disable-mxtalo")) {
+		/* Disable this too: also run by external oscillator */
+		val |= SRC_XTALCR_MXTALOVER;
+		val &= ~SRC_XTALCR_MXTALEN;
+		pr_info("disabling MXTALO\n");
+	}
+	writel(val, src_base + SRC_XTALCR);
+	register_reboot_notifier(&nomadik_clk_reboot_notifier);
+}
+
 /**
  * struct clk_pll1 - Nomadik PLL1 clock
  * @hw: corresponding clock hardware entry
@@ -487,11 +560,6 @@ static void __init of_nomadik_src_clk_setup(struct device_node *np)
 		of_clk_add_provider(np, of_clk_src_simple_get, clk);
 }
 
-static const struct of_device_id nomadik_src_match[] __initconst = {
-	{ .compatible = "stericsson,nomadik-src" },
-	{ /* sentinel */ }
-};
-
 static const struct of_device_id nomadik_src_clk_match[] __initconst = {
 	{
 		.compatible = "fixed-clock",
@@ -516,72 +584,8 @@ static const struct of_device_id nomadik_src_clk_match[] __initconst = {
 	{ /* sentinel */ }
 };
 
-static int nomadik_clk_reboot_handler(struct notifier_block *this,
-				unsigned long code,
-				void *unused)
-{
-	u32 val;
-
-	/* The main chrystal need to be enabled for reboot to work */
-	val = readl(src_base + SRC_XTALCR);
-	val &= ~SRC_XTALCR_MXTALOVER;
-	val |= SRC_XTALCR_MXTALEN;
-	pr_crit("force-enabling MXTALO\n");
-	writel(val, src_base + SRC_XTALCR);
-	return NOTIFY_OK;
-}
-
-static struct notifier_block nomadik_clk_reboot_notifier = {
-	.notifier_call = nomadik_clk_reboot_handler,
-};
-
 void __init nomadik_clk_init(void)
 {
-	struct device_node *np;
-	u32 val;
-
-	np = of_find_matching_node(NULL, nomadik_src_match);
-	if (!np) {
-		pr_crit("no matching node for SRC, aborting clock init\n");
-		return;
-	}
-	src_base = of_iomap(np, 0);
-	if (!src_base) {
-		pr_err("%s: must have src parent node with REGS (%s)\n",
-		       __func__, np->name);
-		return;
-	}
-
-	/* Set all timers to use the 2.4 MHz TIMCLK */
-	val = readl(src_base + SRC_CR);
-	val |= SRC_CR_T0_ENSEL;
-	val |= SRC_CR_T1_ENSEL;
-	val |= SRC_CR_T2_ENSEL;
-	val |= SRC_CR_T3_ENSEL;
-	val |= SRC_CR_T4_ENSEL;
-	val |= SRC_CR_T5_ENSEL;
-	val |= SRC_CR_T6_ENSEL;
-	val |= SRC_CR_T7_ENSEL;
-	writel(val, src_base + SRC_CR);
-
-	val = readl(src_base + SRC_XTALCR);
-	pr_info("SXTALO is %s\n",
-		(val & SRC_XTALCR_SXTALDIS) ? "disabled" : "enabled");
-	pr_info("MXTAL is %s\n",
-		(val & SRC_XTALCR_MXTALSTAT) ? "enabled" : "disabled");
-	if (of_property_read_bool(np, "disable-sxtalo")) {
-		/* The machine uses an external oscillator circuit */
-		val |= SRC_XTALCR_SXTALDIS;
-		pr_info("disabling SXTALO\n");
-	}
-	if (of_property_read_bool(np, "disable-mxtalo")) {
-		/* Disable this too: also run by external oscillator */
-		val |= SRC_XTALCR_MXTALOVER;
-		val &= ~SRC_XTALCR_MXTALEN;
-		pr_info("disabling MXTALO\n");
-	}
-	writel(val, src_base + SRC_XTALCR);
-	register_reboot_notifier(&nomadik_clk_reboot_notifier);
-
+	nomadik_src_init();
 	of_clk_init(nomadik_src_clk_match);
 }

commit eb6b036dde364c528807f53ee8c8e5c9b0e46c34
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Sep 13 21:45:51 2013 +0200

    clk: nomadik: set all timers to use 2.4 MHz TIMCLK
    
    This fixes a regression for the Nomadik on the main system
    timers.
    
    The Nomadik seemed a bit slow and its heartbeat wasn't looking
    healthy. And it was not strange, because it has been connected
    to the 32768 Hz clock at boot, while being told by the clock driver
    that it was 2.4MHz. Actually connect the TIMCLK to 2.4MHz by
    default as this is what we want for nice scheduling, clocksource
    and clock event.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 51410c2ac2cb..4d978a3c88f7 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -27,6 +27,14 @@
  */
 
 #define SRC_CR			0x00U
+#define SRC_CR_T0_ENSEL		BIT(15)
+#define SRC_CR_T1_ENSEL		BIT(17)
+#define SRC_CR_T2_ENSEL		BIT(19)
+#define SRC_CR_T3_ENSEL		BIT(21)
+#define SRC_CR_T4_ENSEL		BIT(23)
+#define SRC_CR_T5_ENSEL		BIT(25)
+#define SRC_CR_T6_ENSEL		BIT(27)
+#define SRC_CR_T7_ENSEL		BIT(29)
 #define SRC_XTALCR		0x0CU
 #define SRC_XTALCR_XTALTIMEN	BIT(20)
 #define SRC_XTALCR_SXTALDIS	BIT(19)
@@ -543,6 +551,19 @@ void __init nomadik_clk_init(void)
 		       __func__, np->name);
 		return;
 	}
+
+	/* Set all timers to use the 2.4 MHz TIMCLK */
+	val = readl(src_base + SRC_CR);
+	val |= SRC_CR_T0_ENSEL;
+	val |= SRC_CR_T1_ENSEL;
+	val |= SRC_CR_T2_ENSEL;
+	val |= SRC_CR_T3_ENSEL;
+	val |= SRC_CR_T4_ENSEL;
+	val |= SRC_CR_T5_ENSEL;
+	val |= SRC_CR_T6_ENSEL;
+	val |= SRC_CR_T7_ENSEL;
+	writel(val, src_base + SRC_CR);
+
 	val = readl(src_base + SRC_XTALCR);
 	pr_info("SXTALO is %s\n",
 		(val & SRC_XTALCR_SXTALDIS) ? "disabled" : "enabled");

commit 330d83b1fb255963dcfd20cbdd0be34c0ed7da89
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Aug 12 14:44:00 2013 +0530

    clk: nomadik: Fix incorrect placement of __initconst
    
    __initconst should be placed between the variable name and equal
    sign for the variable to be placed in the intended section.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 6d819a37f647..51410c2ac2cb 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -479,12 +479,12 @@ static void __init of_nomadik_src_clk_setup(struct device_node *np)
 		of_clk_add_provider(np, of_clk_src_simple_get, clk);
 }
 
-static const __initconst struct of_device_id nomadik_src_match[] = {
+static const struct of_device_id nomadik_src_match[] __initconst = {
 	{ .compatible = "stericsson,nomadik-src" },
 	{ /* sentinel */ }
 };
 
-static const __initconst struct of_device_id nomadik_src_clk_match[] = {
+static const struct of_device_id nomadik_src_clk_match[] __initconst = {
 	{
 		.compatible = "fixed-clock",
 		.data = of_fixed_clk_setup,

commit ef6eb322ce574ba73658a677e83e5da3cfab301b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jun 4 23:17:21 2013 +0200

    clk: nomadik: implement the Nomadik clocks properly
    
    The Nomadik clock implementation was a stub just using
    fixed clocks.
    
    This implements the clocks properly instead of relying
    on them all being on at boot and leaving them all on.
    
    The PLLs are on the top locking to the main chrystal
    oscillator, then the HCLK for the peripherals are
    below PLL2.
    
    The gated clocks are implemented with zero cells and
    given the clock ID as a property of each node, so every
    gate need to have its own node in the device tree.
    This is because the gate registers contain both HCLK
    gates and PCLK gates, where the latter has HCLK as
    parent. As can be seen from the register layout, this
    is a complete mixup, which means all these gates need
    their own node to properly model parent/child relations
    for PCLKs apart from the HCLKs.
    
    This driver also adds a helpful debugfs file to inspect
    the hardware state of the clock gates.
    
    This is the end result in <debugfs>/clk/clk_summary
    after applying a proper device tree:
    
    ulpiclk                0   0    60000000
    mxtal                  3   3    19200000
       pll2                1   1    864000000
          clk48            3   3    48000000
             rngcclk       1   1    48000000
             usbmclk       0   0    48000000
             mshcclk       0   0    48000000
             mspclk3       0   0    48000000
             x3dclk        0   0    48000000
             skeclk        0   0    48000000
             owmclk        0   0    48000000
             mspclk2       0   0    48000000
             mspclk1       0   0    48000000
             uart2clk      0   0    48000000
             ipbmcclk      0   0    48000000
             ipi2cclk      0   0    48000000
             usbclk        0   0    48000000
             mspclk0       0   0    48000000
             uart1clk      1   2    48000000
             i2c1clk       0   0    48000000
             i2c0clk       0   0    48000000
             sdiclk        1   1    48000000
             uart0clk      0   0    48000000
             sspiclk       0   0    48000000
             irdaclk       0   0    48000000
          clk72            0   0    72000000
             difclk        0   0    72000000
             clcdclk       0   0    72000000
          clk216           0   0    216000000
             hsiclkrx      0   0    216000000
             clk108        0   0    108000000
                hsiclktx   0   0    108000000
                clk27      0   0    27000000
       pll1                1   1    264000000
          hclk             3   3    264000000
             hclkrng       1   1    264000000
             hclkusbm      0   0    264000000
             hclkcryp      0   0    264000000
             hclkhash      0   0    264000000
             hclk3d        0   0    264000000
             hclkhpi       0   0    264000000
             hclksva       0   0    264000000
             hclksaa       0   0    264000000
             hclkdif       0   0    264000000
             hclkusb       0   0    264000000
             hclkclcd      0   0    264000000
             hclkdma1      0   0    264000000
             hclksdram     0   0    264000000
             hclksmc       1   1    264000000
             hclkdma0      0   0    264000000
             pclk          7   9    264000000
                pclkmsp3   0   0    264000000
                pclkmshc   0   0    264000000
                pclkhsem   0   0    264000000
                pclkske    0   0    264000000
                pclkowm    0   0    264000000
                pclkmsp2   0   0    264000000
                pclkmsp1   0   0    264000000
                pclkuart2  0   0    264000000
                pclkxti    0   0    264000000
                pclkhsi    0   0    264000000
                pclkmsp0   0   0    264000000
                pclkuart1  1   1    264000000
                pclki2c1   0   0    264000000
                pclki2c0   0   0    264000000
                pclksdi    1   1    264000000
                pclkuart0  1   1    264000000
                pclkssp    0   0    264000000
                pclkirda   0   0    264000000
       timclk              1   1    2400000
    
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 4a1ab27ee87f..6d819a37f647 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -1,21 +1,566 @@
+/*
+ * Nomadik clock implementation
+ * Copyright (C) 2013 ST-Ericsson AB
+ * License terms: GNU General Public License (GPL) version 2
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ */
+
+#define pr_fmt(fmt) "Nomadik SRC clocks: " fmt
+
+#include <linux/bitops.h>
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/clk-provider.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/spinlock.h>
+#include <linux/reboot.h>
 
 /*
  * The Nomadik clock tree is described in the STN8815A12 DB V4.2
  * reference manual for the chip, page 94 ff.
+ * Clock IDs are in the STn8815 Reference Manual table 3, page 27.
+ */
+
+#define SRC_CR			0x00U
+#define SRC_XTALCR		0x0CU
+#define SRC_XTALCR_XTALTIMEN	BIT(20)
+#define SRC_XTALCR_SXTALDIS	BIT(19)
+#define SRC_XTALCR_MXTALSTAT	BIT(2)
+#define SRC_XTALCR_MXTALEN	BIT(1)
+#define SRC_XTALCR_MXTALOVER	BIT(0)
+#define SRC_PLLCR		0x10U
+#define SRC_PLLCR_PLLTIMEN	BIT(29)
+#define SRC_PLLCR_PLL2EN	BIT(28)
+#define SRC_PLLCR_PLL1STAT	BIT(2)
+#define SRC_PLLCR_PLL1EN	BIT(1)
+#define SRC_PLLCR_PLL1OVER	BIT(0)
+#define SRC_PLLFR		0x14U
+#define SRC_PCKEN0		0x24U
+#define SRC_PCKDIS0		0x28U
+#define SRC_PCKENSR0		0x2CU
+#define SRC_PCKSR0		0x30U
+#define SRC_PCKEN1		0x34U
+#define SRC_PCKDIS1		0x38U
+#define SRC_PCKENSR1		0x3CU
+#define SRC_PCKSR1		0x40U
+
+/* Lock protecting the SRC_CR register */
+static DEFINE_SPINLOCK(src_lock);
+/* Base address of the SRC */
+static void __iomem *src_base;
+
+/**
+ * struct clk_pll1 - Nomadik PLL1 clock
+ * @hw: corresponding clock hardware entry
+ * @id: PLL instance: 1 or 2
+ */
+struct clk_pll {
+	struct clk_hw hw;
+	int id;
+};
+
+/**
+ * struct clk_src - Nomadik src clock
+ * @hw: corresponding clock hardware entry
+ * @id: the clock ID
+ * @group1: true if the clock is in group1, else it is in group0
+ * @clkbit: bit 0...31 corresponding to the clock in each clock register
+ */
+struct clk_src {
+	struct clk_hw hw;
+	int id;
+	bool group1;
+	u32 clkbit;
+};
+
+#define to_pll(_hw) container_of(_hw, struct clk_pll, hw)
+#define to_src(_hw) container_of(_hw, struct clk_src, hw)
+
+static int pll_clk_enable(struct clk_hw *hw)
+{
+	struct clk_pll *pll = to_pll(hw);
+	u32 val;
+
+	spin_lock(&src_lock);
+	val = readl(src_base + SRC_PLLCR);
+	if (pll->id == 1) {
+		if (val & SRC_PLLCR_PLL1OVER) {
+			val |= SRC_PLLCR_PLL1EN;
+			writel(val, src_base + SRC_PLLCR);
+		}
+	} else if (pll->id == 2) {
+		val |= SRC_PLLCR_PLL2EN;
+		writel(val, src_base + SRC_PLLCR);
+	}
+	spin_unlock(&src_lock);
+	return 0;
+}
+
+static void pll_clk_disable(struct clk_hw *hw)
+{
+	struct clk_pll *pll = to_pll(hw);
+	u32 val;
+
+	spin_lock(&src_lock);
+	val = readl(src_base + SRC_PLLCR);
+	if (pll->id == 1) {
+		if (val & SRC_PLLCR_PLL1OVER) {
+			val &= ~SRC_PLLCR_PLL1EN;
+			writel(val, src_base + SRC_PLLCR);
+		}
+	} else if (pll->id == 2) {
+		val &= ~SRC_PLLCR_PLL2EN;
+		writel(val, src_base + SRC_PLLCR);
+	}
+	spin_unlock(&src_lock);
+}
+
+static int pll_clk_is_enabled(struct clk_hw *hw)
+{
+	struct clk_pll *pll = to_pll(hw);
+	u32 val;
+
+	val = readl(src_base + SRC_PLLCR);
+	if (pll->id == 1) {
+		if (val & SRC_PLLCR_PLL1OVER)
+			return !!(val & SRC_PLLCR_PLL1EN);
+	} else if (pll->id == 2) {
+		return !!(val & SRC_PLLCR_PLL2EN);
+	}
+	return 1;
+}
+
+static unsigned long pll_clk_recalc_rate(struct clk_hw *hw,
+					  unsigned long parent_rate)
+{
+	struct clk_pll *pll = to_pll(hw);
+	u32 val;
+
+	val = readl(src_base + SRC_PLLFR);
+
+	if (pll->id == 1) {
+		u8 mul;
+		u8 div;
+
+		mul = (val >> 8) & 0x3FU;
+		mul += 2;
+		div = val & 0x07U;
+		return (parent_rate * mul) >> div;
+	}
+
+	if (pll->id == 2) {
+		u8 mul;
+
+		mul = (val >> 24) & 0x3FU;
+		mul += 2;
+		return (parent_rate * mul);
+	}
+
+	/* Unknown PLL */
+	return 0;
+}
+
+
+static const struct clk_ops pll_clk_ops = {
+	.enable = pll_clk_enable,
+	.disable = pll_clk_disable,
+	.is_enabled = pll_clk_is_enabled,
+	.recalc_rate = pll_clk_recalc_rate,
+};
+
+static struct clk * __init
+pll_clk_register(struct device *dev, const char *name,
+		 const char *parent_name, u32 id)
+{
+	struct clk *clk;
+	struct clk_pll *pll;
+	struct clk_init_data init;
+
+	if (id != 1 && id != 2) {
+		pr_err("%s: the Nomadik has only PLL 1 & 2\n", __func__);
+		return ERR_PTR(-EINVAL);
+	}
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll) {
+		pr_err("%s: could not allocate PLL clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = &pll_clk_ops;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+	pll->hw.init = &init;
+	pll->id = id;
+
+	pr_debug("register PLL1 clock \"%s\"\n", name);
+
+	clk = clk_register(dev, &pll->hw);
+	if (IS_ERR(clk))
+		kfree(pll);
+
+	return clk;
+}
+
+/*
+ * The Nomadik SRC clocks are gated, but not in the sense that
+ * you read-modify-write a register. Instead there are separate
+ * clock enable and clock disable registers. Writing a '1' bit in
+ * the enable register for a certain clock ungates that clock without
+ * affecting the other clocks. The disable register works the opposite
+ * way.
  */
 
-static const __initconst struct of_device_id cpu8815_clk_match[] = {
-	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+static int src_clk_enable(struct clk_hw *hw)
+{
+	struct clk_src *sclk = to_src(hw);
+	u32 enreg = sclk->group1 ? SRC_PCKEN1 : SRC_PCKEN0;
+	u32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;
+
+	writel(sclk->clkbit, src_base + enreg);
+	/* spin until enabled */
+	while (!(readl(src_base + sreg) & sclk->clkbit))
+		cpu_relax();
+	return 0;
+}
+
+static void src_clk_disable(struct clk_hw *hw)
+{
+	struct clk_src *sclk = to_src(hw);
+	u32 disreg = sclk->group1 ? SRC_PCKDIS1 : SRC_PCKDIS0;
+	u32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;
+
+	writel(sclk->clkbit, src_base + disreg);
+	/* spin until disabled */
+	while (readl(src_base + sreg) & sclk->clkbit)
+		cpu_relax();
+}
+
+static int src_clk_is_enabled(struct clk_hw *hw)
+{
+	struct clk_src *sclk = to_src(hw);
+	u32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;
+	u32 val = readl(src_base + sreg);
+
+	return !!(val & sclk->clkbit);
+}
+
+static unsigned long
+src_clk_recalc_rate(struct clk_hw *hw,
+		    unsigned long parent_rate)
+{
+	return parent_rate;
+}
+
+static const struct clk_ops src_clk_ops = {
+	.enable = src_clk_enable,
+	.disable = src_clk_disable,
+	.is_enabled = src_clk_is_enabled,
+	.recalc_rate = src_clk_recalc_rate,
+};
+
+static struct clk * __init
+src_clk_register(struct device *dev, const char *name,
+		 const char *parent_name, u8 id)
+{
+	struct clk *clk;
+	struct clk_src *sclk;
+	struct clk_init_data init;
+
+	sclk = kzalloc(sizeof(*sclk), GFP_KERNEL);
+	if (!sclk) {
+		pr_err("could not allocate SRC clock %s\n",
+			name);
+		return ERR_PTR(-ENOMEM);
+	}
+	init.name = name;
+	init.ops = &src_clk_ops;
+	/* Do not force-disable the static SDRAM controller */
+	if (id == 2)
+		init.flags = CLK_IGNORE_UNUSED;
+	else
+		init.flags = 0;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+	sclk->hw.init = &init;
+	sclk->id = id;
+	sclk->group1 = (id > 31);
+	sclk->clkbit = BIT(id & 0x1f);
+
+	pr_debug("register clock \"%s\" ID: %d group: %d bits: %08x\n",
+		 name, id, sclk->group1, sclk->clkbit);
+
+	clk = clk_register(dev, &sclk->hw);
+	if (IS_ERR(clk))
+		kfree(sclk);
+
+	return clk;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+static u32 src_pcksr0_boot;
+static u32 src_pcksr1_boot;
+
+static const char * const src_clk_names[] = {
+	"HCLKDMA0  ",
+	"HCLKSMC   ",
+	"HCLKSDRAM ",
+	"HCLKDMA1  ",
+	"HCLKCLCD  ",
+	"PCLKIRDA  ",
+	"PCLKSSP   ",
+	"PCLKUART0 ",
+	"PCLKSDI   ",
+	"PCLKI2C0  ",
+	"PCLKI2C1  ",
+	"PCLKUART1 ",
+	"PCLMSP0   ",
+	"HCLKUSB   ",
+	"HCLKDIF   ",
+	"HCLKSAA   ",
+	"HCLKSVA   ",
+	"PCLKHSI   ",
+	"PCLKXTI   ",
+	"PCLKUART2 ",
+	"PCLKMSP1  ",
+	"PCLKMSP2  ",
+	"PCLKOWM   ",
+	"HCLKHPI   ",
+	"PCLKSKE   ",
+	"PCLKHSEM  ",
+	"HCLK3D    ",
+	"HCLKHASH  ",
+	"HCLKCRYP  ",
+	"PCLKMSHC  ",
+	"HCLKUSBM  ",
+	"HCLKRNG   ",
+	"RESERVED  ",
+	"RESERVED  ",
+	"RESERVED  ",
+	"RESERVED  ",
+	"CLDCLK    ",
+	"IRDACLK   ",
+	"SSPICLK   ",
+	"UART0CLK  ",
+	"SDICLK    ",
+	"I2C0CLK   ",
+	"I2C1CLK   ",
+	"UART1CLK  ",
+	"MSPCLK0   ",
+	"USBCLK    ",
+	"DIFCLK    ",
+	"IPI2CCLK  ",
+	"IPBMCCLK  ",
+	"HSICLKRX  ",
+	"HSICLKTX  ",
+	"UART2CLK  ",
+	"MSPCLK1   ",
+	"MSPCLK2   ",
+	"OWMCLK    ",
+	"RESERVED  ",
+	"SKECLK    ",
+	"RESERVED  ",
+	"3DCLK     ",
+	"PCLKMSP3  ",
+	"MSPCLK3   ",
+	"MSHCCLK   ",
+	"USBMCLK   ",
+	"RNGCCLK   ",
+};
+
+static int nomadik_src_clk_show(struct seq_file *s, void *what)
+{
+	int i;
+	u32 src_pcksr0 = readl(src_base + SRC_PCKSR0);
+	u32 src_pcksr1 = readl(src_base + SRC_PCKSR1);
+	u32 src_pckensr0 = readl(src_base + SRC_PCKENSR0);
+	u32 src_pckensr1 = readl(src_base + SRC_PCKENSR1);
+
+	seq_printf(s, "Clock:      Boot:   Now:    Request: ASKED:\n");
+	for (i = 0; i < ARRAY_SIZE(src_clk_names); i++) {
+		u32 pcksrb = (i < 0x20) ? src_pcksr0_boot : src_pcksr1_boot;
+		u32 pcksr = (i < 0x20) ? src_pcksr0 : src_pcksr1;
+		u32 pckreq = (i < 0x20) ? src_pckensr0 : src_pckensr1;
+		u32 mask = BIT(i & 0x1f);
+
+		seq_printf(s, "%s  %s     %s     %s\n",
+			   src_clk_names[i],
+			   (pcksrb & mask) ? "on " : "off",
+			   (pcksr & mask) ? "on " : "off",
+			   (pckreq & mask) ? "on " : "off");
+	}
+	return 0;
+}
+
+static int nomadik_src_clk_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, nomadik_src_clk_show, NULL);
+}
+
+static const struct file_operations nomadik_src_clk_debugfs_ops = {
+	.open           = nomadik_src_clk_open,
+	.read           = seq_read,
+        .llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static int __init nomadik_src_clk_init_debugfs(void)
+{
+	src_pcksr0_boot = readl(src_base + SRC_PCKSR0);
+	src_pcksr1_boot = readl(src_base + SRC_PCKSR1);
+	debugfs_create_file("nomadik-src-clk", S_IFREG | S_IRUGO,
+			    NULL, NULL, &nomadik_src_clk_debugfs_ops);
+	return 0;
+}
+
+module_init(nomadik_src_clk_init_debugfs);
+
+#endif
+
+static void __init of_nomadik_pll_setup(struct device_node *np)
+{
+	struct clk *clk = ERR_PTR(-EINVAL);
+	const char *clk_name = np->name;
+	const char *parent_name;
+	u32 pll_id;
+
+	if (of_property_read_u32(np, "pll-id", &pll_id)) {
+		pr_err("%s: PLL \"%s\" missing pll-id property\n",
+			__func__, clk_name);
+		return;
+	}
+	parent_name = of_clk_get_parent_name(np, 0);
+	clk = pll_clk_register(NULL, clk_name, parent_name, pll_id);
+	if (!IS_ERR(clk))
+		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+}
+
+static void __init of_nomadik_hclk_setup(struct device_node *np)
+{
+	struct clk *clk = ERR_PTR(-EINVAL);
+	const char *clk_name = np->name;
+	const char *parent_name;
+
+	parent_name = of_clk_get_parent_name(np, 0);
+	/*
+	 * The HCLK divides PLL1 with 1 (passthru), 2, 3 or 4.
+	 */
+	clk = clk_register_divider(NULL, clk_name, parent_name,
+			   0, src_base + SRC_CR,
+			   13, 2,
+			   CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,
+			   &src_lock);
+	if (!IS_ERR(clk))
+		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+}
+
+static void __init of_nomadik_src_clk_setup(struct device_node *np)
+{
+	struct clk *clk = ERR_PTR(-EINVAL);
+	const char *clk_name = np->name;
+	const char *parent_name;
+	u32 clk_id;
+
+	if (of_property_read_u32(np, "clock-id", &clk_id)) {
+		pr_err("%s: SRC clock \"%s\" missing clock-id property\n",
+			__func__, clk_name);
+		return;
+	}
+	parent_name = of_clk_get_parent_name(np, 0);
+	clk = src_clk_register(NULL, clk_name, parent_name, clk_id);
+	if (!IS_ERR(clk))
+		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+}
+
+static const __initconst struct of_device_id nomadik_src_match[] = {
+	{ .compatible = "stericsson,nomadik-src" },
 	{ /* sentinel */ }
 };
 
+static const __initconst struct of_device_id nomadik_src_clk_match[] = {
+	{
+		.compatible = "fixed-clock",
+		.data = of_fixed_clk_setup,
+	},
+	{
+		.compatible = "fixed-factor-clock",
+		.data = of_fixed_factor_clk_setup,
+	},
+	{
+		.compatible = "st,nomadik-pll-clock",
+		.data = of_nomadik_pll_setup,
+	},
+	{
+		.compatible = "st,nomadik-hclk-clock",
+		.data = of_nomadik_hclk_setup,
+	},
+	{
+		.compatible = "st,nomadik-src-clock",
+		.data = of_nomadik_src_clk_setup,
+	},
+	{ /* sentinel */ }
+};
+
+static int nomadik_clk_reboot_handler(struct notifier_block *this,
+				unsigned long code,
+				void *unused)
+{
+	u32 val;
+
+	/* The main chrystal need to be enabled for reboot to work */
+	val = readl(src_base + SRC_XTALCR);
+	val &= ~SRC_XTALCR_MXTALOVER;
+	val |= SRC_XTALCR_MXTALEN;
+	pr_crit("force-enabling MXTALO\n");
+	writel(val, src_base + SRC_XTALCR);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block nomadik_clk_reboot_notifier = {
+	.notifier_call = nomadik_clk_reboot_handler,
+};
+
 void __init nomadik_clk_init(void)
 {
-	of_clk_init(cpu8815_clk_match);
+	struct device_node *np;
+	u32 val;
+
+	np = of_find_matching_node(NULL, nomadik_src_match);
+	if (!np) {
+		pr_crit("no matching node for SRC, aborting clock init\n");
+		return;
+	}
+	src_base = of_iomap(np, 0);
+	if (!src_base) {
+		pr_err("%s: must have src parent node with REGS (%s)\n",
+		       __func__, np->name);
+		return;
+	}
+	val = readl(src_base + SRC_XTALCR);
+	pr_info("SXTALO is %s\n",
+		(val & SRC_XTALCR_SXTALDIS) ? "disabled" : "enabled");
+	pr_info("MXTAL is %s\n",
+		(val & SRC_XTALCR_MXTALSTAT) ? "enabled" : "disabled");
+	if (of_property_read_bool(np, "disable-sxtalo")) {
+		/* The machine uses an external oscillator circuit */
+		val |= SRC_XTALCR_SXTALDIS;
+		pr_info("disabling SXTALO\n");
+	}
+	if (of_property_read_bool(np, "disable-mxtalo")) {
+		/* Disable this too: also run by external oscillator */
+		val |= SRC_XTALCR_MXTALOVER;
+		val &= ~SRC_XTALCR_MXTALEN;
+		pr_info("disabling MXTALO\n");
+	}
+	writel(val, src_base + SRC_XTALCR);
+	register_reboot_notifier(&nomadik_clk_reboot_notifier);
+
+	of_clk_init(nomadik_src_clk_match);
 }

commit 7690fbb293df83025cffb608f9c2e81414c468a8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 16 23:44:31 2013 +0200

    ARM: nomadik: register clocksource from device tree
    
    This switches the Nomadik platform to also registering its
    clocksource from the device tree, removing unused support
    code as we go along.
    
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 19f197ccf28d..4a1ab27ee87f 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -17,20 +17,5 @@ static const __initconst struct of_device_id cpu8815_clk_match[] = {
 
 void __init nomadik_clk_init(void)
 {
-	struct clk *clk;
-
-	clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, CLK_IS_ROOT, 0);
-	clk_register_clkdev(clk, "apb_pclk", NULL);
-
-	/*
-	 * The 2.4 MHz TIMCLK reference clock is active at boot time, this is
-	 * actually the MXTALCLK @19.2 MHz divided by 8. This clock is used
-	 * by the timers and watchdog. See page 105 ff.
-	 */
-	clk = clk_register_fixed_rate(NULL, "TIMCLK", NULL, CLK_IS_ROOT,
-				      2400000);
-	clk_register_clkdev(clk, NULL, "mtu0");
-	clk_register_clkdev(clk, NULL, "mtu1");
-
 	of_clk_init(cpu8815_clk_match);
 }

commit 6e2b07a172b6ed98c7cdc301333b2d9f86c11880
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 16 21:38:29 2013 +0200

    ARM: nomadik: convert all clocks except timer to dt
    
    This moves all Nomadik clocks except the one used for the
    timer/clocksource over to the device tree.
    
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 6b4c70f7d23d..19f197ccf28d 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -3,24 +3,24 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/clk-provider.h>
+#include <linux/of.h>
 
 /*
  * The Nomadik clock tree is described in the STN8815A12 DB V4.2
  * reference manual for the chip, page 94 ff.
  */
 
+static const __initconst struct of_device_id cpu8815_clk_match[] = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ /* sentinel */ }
+};
+
 void __init nomadik_clk_init(void)
 {
 	struct clk *clk;
 
 	clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, CLK_IS_ROOT, 0);
 	clk_register_clkdev(clk, "apb_pclk", NULL);
-	clk_register_clkdev(clk, NULL, "gpio.0");
-	clk_register_clkdev(clk, NULL, "gpio.1");
-	clk_register_clkdev(clk, NULL, "gpio.2");
-	clk_register_clkdev(clk, NULL, "gpio.3");
-	clk_register_clkdev(clk, NULL, "rng");
-	clk_register_clkdev(clk, NULL, "fsmc-nand");
 
 	/*
 	 * The 2.4 MHz TIMCLK reference clock is active at boot time, this is
@@ -32,17 +32,5 @@ void __init nomadik_clk_init(void)
 	clk_register_clkdev(clk, NULL, "mtu0");
 	clk_register_clkdev(clk, NULL, "mtu1");
 
-	/*
-	 * At boot time, PLL2 is set to generate a set of fixed clocks,
-	 * one of them is CLK48, the 48 MHz clock, routed to the UART, MMC/SD
-	 * I2C, IrDA, USB and SSP blocks.
-	 */
-	clk = clk_register_fixed_rate(NULL, "CLK48", NULL, CLK_IS_ROOT,
-				      48000000);
-	clk_register_clkdev(clk, NULL, "uart0");
-	clk_register_clkdev(clk, NULL, "uart1");
-	clk_register_clkdev(clk, NULL, "mmci");
-	clk_register_clkdev(clk, NULL, "ssp");
-	clk_register_clkdev(clk, NULL, "nmk-i2c.0");
-	clk_register_clkdev(clk, NULL, "nmk-i2c.1");
+	of_clk_init(cpu8815_clk_match);
 }

commit 41863f730ff8aad86c038aabee1292d1b04c8876
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Oct 4 09:28:29 2012 +0200

    ARM: nomadik: switch over to using the FSMC driver
    
    The Nomadik NAND driver is really just a subset of the existing
    FSMC driver, so let's switch over to using that driver instead,
    since it handles more variants of this chip. The callbacks for
    setting up the chip is doing stuff now handled by the FSMC
    driver.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Alessandro Rubini <rubini@unipv.it>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
index 517a8ff7121e..6b4c70f7d23d 100644
--- a/drivers/clk/clk-nomadik.c
+++ b/drivers/clk/clk-nomadik.c
@@ -20,6 +20,7 @@ void __init nomadik_clk_init(void)
 	clk_register_clkdev(clk, NULL, "gpio.2");
 	clk_register_clkdev(clk, NULL, "gpio.3");
 	clk_register_clkdev(clk, NULL, "rng");
+	clk_register_clkdev(clk, NULL, "fsmc-nand");
 
 	/*
 	 * The 2.4 MHz TIMCLK reference clock is active at boot time, this is

commit 4a31bd28e86ac50eb620f6b5b36464c45b5fa38f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jan 11 13:52:34 2012 +0100

    ARM: nomadik: convert to generic clock
    
    Remove more custom stuff by simply converting the Nomadik machine
    to use generic clocks and move the driver to drivers/clk.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Mike Turquette <mturquette@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clk/clk-nomadik.c b/drivers/clk/clk-nomadik.c
new file mode 100644
index 000000000000..517a8ff7121e
--- /dev/null
+++ b/drivers/clk/clk-nomadik.c
@@ -0,0 +1,47 @@
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/clk-provider.h>
+
+/*
+ * The Nomadik clock tree is described in the STN8815A12 DB V4.2
+ * reference manual for the chip, page 94 ff.
+ */
+
+void __init nomadik_clk_init(void)
+{
+	struct clk *clk;
+
+	clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, CLK_IS_ROOT, 0);
+	clk_register_clkdev(clk, "apb_pclk", NULL);
+	clk_register_clkdev(clk, NULL, "gpio.0");
+	clk_register_clkdev(clk, NULL, "gpio.1");
+	clk_register_clkdev(clk, NULL, "gpio.2");
+	clk_register_clkdev(clk, NULL, "gpio.3");
+	clk_register_clkdev(clk, NULL, "rng");
+
+	/*
+	 * The 2.4 MHz TIMCLK reference clock is active at boot time, this is
+	 * actually the MXTALCLK @19.2 MHz divided by 8. This clock is used
+	 * by the timers and watchdog. See page 105 ff.
+	 */
+	clk = clk_register_fixed_rate(NULL, "TIMCLK", NULL, CLK_IS_ROOT,
+				      2400000);
+	clk_register_clkdev(clk, NULL, "mtu0");
+	clk_register_clkdev(clk, NULL, "mtu1");
+
+	/*
+	 * At boot time, PLL2 is set to generate a set of fixed clocks,
+	 * one of them is CLK48, the 48 MHz clock, routed to the UART, MMC/SD
+	 * I2C, IrDA, USB and SSP blocks.
+	 */
+	clk = clk_register_fixed_rate(NULL, "CLK48", NULL, CLK_IS_ROOT,
+				      48000000);
+	clk_register_clkdev(clk, NULL, "uart0");
+	clk_register_clkdev(clk, NULL, "uart1");
+	clk_register_clkdev(clk, NULL, "mmci");
+	clk_register_clkdev(clk, NULL, "ssp");
+	clk_register_clkdev(clk, NULL, "nmk-i2c.0");
+	clk_register_clkdev(clk, NULL, "nmk-i2c.1");
+}
