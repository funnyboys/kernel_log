commit 0e40198dc28b620ead39de6e42db291418cd1183
Author: Peng Fan <peng.fan@nxp.com>
Date:   Thu May 7 13:56:17 2020 +0800

    clk: imx: add imx8m_clk_hw_composite_bus
    
    Introduce imx8m_clk_hw_composite_bus api for bus clk root slice usage.
    Because the mux switch sequence issue, we could not reuse Peripheral
    Clock Slice code, need use composite specific mux operation.
    
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 2d9562ebddc3..d2b5af826f2c 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -205,6 +205,11 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 		div->width = PCG_CORE_DIV_WIDTH;
 		divider_ops = &clk_divider_ops;
 		mux_ops = &imx8m_clk_composite_mux_ops;
+	} else if (composite_flags & IMX_COMPOSITE_BUS) {
+		div->shift = PCG_PREDIV_SHIFT;
+		div->width = PCG_PREDIV_WIDTH;
+		divider_ops = &imx8m_clk_composite_divider_ops;
+		mux_ops = &imx8m_clk_composite_mux_ops;
 	} else {
 		div->shift = PCG_PREDIV_SHIFT;
 		div->width = PCG_PREDIV_WIDTH;

commit f90b68d6c8b008549a4538f608575ff3f9ed2905
Author: Peng Fan <peng.fan@nxp.com>
Date:   Thu May 7 13:56:16 2020 +0800

    clk: imx: add mux ops for i.MX8M composite clk
    
    The CORE/BUS root slice has following design, simplied graph:
    The difference is core not have pre_div block.
    A composite core/bus clk has 8 inputs for mux to select, saying clk[0-7].
    
    It support target(smart) interface and normal interface. Target interface
    is exported for programmer easy to configure ccm root. Normal interface
    is also exported, but we not use it in our driver, because it will
    introduce more complexity compared with target interface.
    
    The normal interface simplified as below:
                SEL_A  GA
                +--+  +-+
                |  +->+ +------+
    CLK[0-7]--->+  |  +-+      |
           |    |  |      +----v---+    +----+
           |    +--+      |pre_diva+---->    |  +---------+
           |              +--------+    |mux +--+post_div |
           |    +--+      |pre_divb+--->+    |  +---------+
           |    |  |      +----^---+    +----+
           +--->+  |  +-+      |
                |  +->+ +------+
                +--+  +-+
                SEL_B  GB
    
    The mux in the upper pic is not the target interface MUX, target
    interface MUX is hiding SEL_A and SEL_B. When you choose clk[0-7],
    you are actually writing SEL_A or SEL_B depends on the internal
    counter which will also control the internal "mux".
    
    The target interface simplified as below which is used by Linux Kernel:
    CLK[0-7]--->MUX-->Gate-->pre_div-->post_div
    
    A requirement of the Target Interface's software is that the
    target clock source is active, it means when setting SEL_A, the
    current input clk to SEL_A must be active, same to SEL_B.
    
    We touch target interface, but hardware logic actually also need
    configure normal interface.
    
    There will be system hang, when doing the following steps:
    The initial state:
      SEL_A/SEL_B are both sourcing from clk0, the internal counter
      choose SEL_A.
    1. switch mux from clk0 to clk1
       The hardware logic will choose SEL_B and configure SEL_B to clk1.
       SEL_A no changed.
    2. gate off clk0
       Disable clk0, then the input to SEL_A is off.
    3. swtich from clk1 to clk2
       The hardware logic will choose SEL_A and configure SEL_A to clk2,
       however the current SEL_A input clk0 is off, the system hang.
    
    The solution to fix the issue is in step 1, write twice to
    target interface MUX, it will make SEL_A/SEL_B both sources
    from clk1, then no need to care about the state of clk0. And
    finally system performs well.
    
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 99773519b5a5..2d9562ebddc3 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -124,6 +124,52 @@ static const struct clk_ops imx8m_clk_composite_divider_ops = {
 	.set_rate = imx8m_clk_composite_divider_set_rate,
 };
 
+static u8 imx8m_clk_composite_mux_get_parent(struct clk_hw *hw)
+{
+	return clk_mux_ops.get_parent(hw);
+}
+
+static int imx8m_clk_composite_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	u32 val = clk_mux_index_to_val(mux->table, mux->flags, index);
+	unsigned long flags = 0;
+	u32 reg;
+
+	if (mux->lock)
+		spin_lock_irqsave(mux->lock, flags);
+
+	reg = readl(mux->reg);
+	reg &= ~(mux->mask << mux->shift);
+	val = val << mux->shift;
+	reg |= val;
+	/*
+	 * write twice to make sure non-target interface
+	 * SEL_A/B point the same clk input.
+	 */
+	writel(reg, mux->reg);
+	writel(reg, mux->reg);
+
+	if (mux->lock)
+		spin_unlock_irqrestore(mux->lock, flags);
+
+	return 0;
+}
+
+static int
+imx8m_clk_composite_mux_determine_rate(struct clk_hw *hw,
+				       struct clk_rate_request *req)
+{
+	return clk_mux_ops.determine_rate(hw, req);
+}
+
+
+static const struct clk_ops imx8m_clk_composite_mux_ops = {
+	.get_parent = imx8m_clk_composite_mux_get_parent,
+	.set_parent = imx8m_clk_composite_mux_set_parent,
+	.determine_rate = imx8m_clk_composite_mux_determine_rate,
+};
+
 struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 					const char * const *parent_names,
 					int num_parents, void __iomem *reg,
@@ -136,6 +182,7 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 	struct clk_gate *gate = NULL;
 	struct clk_mux *mux = NULL;
 	const struct clk_ops *divider_ops;
+	const struct clk_ops *mux_ops;
 
 	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
 	if (!mux)
@@ -157,10 +204,12 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 		div->shift = PCG_DIV_SHIFT;
 		div->width = PCG_CORE_DIV_WIDTH;
 		divider_ops = &clk_divider_ops;
+		mux_ops = &imx8m_clk_composite_mux_ops;
 	} else {
 		div->shift = PCG_PREDIV_SHIFT;
 		div->width = PCG_PREDIV_WIDTH;
 		divider_ops = &imx8m_clk_composite_divider_ops;
+		mux_ops = &clk_mux_ops;
 	}
 
 	div->lock = &imx_ccm_lock;
@@ -176,7 +225,7 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 	gate->lock = &imx_ccm_lock;
 
 	hw = clk_hw_register_composite(NULL, name, parent_names, num_parents,
-			mux_hw, &clk_mux_ops, div_hw,
+			mux_hw, mux_ops, div_hw,
 			divider_ops, gate_hw, &clk_gate_ops, flags);
 	if (IS_ERR(hw))
 		goto fail;

commit 79ccef698ac811b3029fd01cbe2114fed3219c8a
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Wed Feb 12 17:03:00 2020 +0800

    clk: imx: drop redundant initialization
    
    No need to initialize flags as 0, remove the initialization.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 4869c16376bf..99773519b5a5 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -92,7 +92,7 @@ static int imx8m_clk_composite_divider_set_rate(struct clk_hw *hw,
 					unsigned long parent_rate)
 {
 	struct clk_divider *divider = to_clk_divider(hw);
-	unsigned long flags = 0;
+	unsigned long flags;
 	int prediv_value;
 	int div_value;
 	int ret;

commit 62668b68dc8e7d4c23cdec60f31d9c8dc1384409
Author: Peng Fan <peng.fan@nxp.com>
Date:   Tue Jan 28 05:28:36 2020 +0000

    clk: imx: composite-8m: add imx8m_clk_hw_composite_core
    
    There are several clock slices, current composite code
    only support bus/ip clock slices, it could not support core
    slice.
    
    So introduce a new API imx8m_clk_hw_composite_core to support
    core slice. To core slice, post divider with 3 bits width and
    no pre divider. Other fields are same as bus/ip slices.
    
    Add a flag IMX_COMPOSITE_CORE for the usecase.
    
    Reviewed-by: Abel Vesa <abel.vesa@nxp.com>
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 20f7c91c03d2..4869c16376bf 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -15,6 +15,7 @@
 #define PCG_PREDIV_MAX		8
 
 #define PCG_DIV_SHIFT		0
+#define PCG_CORE_DIV_WIDTH	3
 #define PCG_DIV_WIDTH		6
 #define PCG_DIV_MAX		64
 
@@ -126,6 +127,7 @@ static const struct clk_ops imx8m_clk_composite_divider_ops = {
 struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 					const char * const *parent_names,
 					int num_parents, void __iomem *reg,
+					u32 composite_flags,
 					unsigned long flags)
 {
 	struct clk_hw *hw = ERR_PTR(-ENOMEM), *mux_hw;
@@ -133,6 +135,7 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 	struct clk_divider *div = NULL;
 	struct clk_gate *gate = NULL;
 	struct clk_mux *mux = NULL;
+	const struct clk_ops *divider_ops;
 
 	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
 	if (!mux)
@@ -150,8 +153,16 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 
 	div_hw = &div->hw;
 	div->reg = reg;
-	div->shift = PCG_PREDIV_SHIFT;
-	div->width = PCG_PREDIV_WIDTH;
+	if (composite_flags & IMX_COMPOSITE_CORE) {
+		div->shift = PCG_DIV_SHIFT;
+		div->width = PCG_CORE_DIV_WIDTH;
+		divider_ops = &clk_divider_ops;
+	} else {
+		div->shift = PCG_PREDIV_SHIFT;
+		div->width = PCG_PREDIV_WIDTH;
+		divider_ops = &imx8m_clk_composite_divider_ops;
+	}
+
 	div->lock = &imx_ccm_lock;
 	div->flags = CLK_DIVIDER_ROUND_CLOSEST;
 
@@ -166,8 +177,7 @@ struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 
 	hw = clk_hw_register_composite(NULL, name, parent_names, num_parents,
 			mux_hw, &clk_mux_ops, div_hw,
-			&imx8m_clk_composite_divider_ops,
-			gate_hw, &clk_gate_ops, flags);
+			divider_ops, gate_hw, &clk_gate_ops, flags);
 	if (IS_ERR(hw))
 		goto fail;
 

commit db865ee447d46eccd641dc70c7f9acc231a3141e
Merge: 6e7a9f0c4ea8 498e165274f3 660b94e0d8fe 34bbe0361707 185dfe32d7e2 9e0cda721d18 9cd10205227c a932872f1b76
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jan 31 13:14:26 2020 -0800

    Merge branches 'clk-imx', 'clk-ti', 'clk-xilinx', 'clk-nvidia', 'clk-qcom', 'clk-freescale' and 'clk-qoriq' into clk-next
    
     - Support for Xilinx Versal platform clks
     - Display clk controller on qcom sc7180
     - Video clk controller on qcom sc7180
     - Graphics clk controller on qcom sc7180
     - CPU PLLs for qcom msm8916
     - Fixes for clk controllers on qcom msm8998 SoCs
     - Move qcom msm8974 gfx3d clk to RPM control
     - Display port clk support on qcom sdm845 SoCs
     - Global clk controller on qcom ipq6018
     - Adjust composite clk to new way of describing clk parents
     - Add a driver for BCLK of Freescale SAI cores
    
    * clk-imx: (32 commits)
      clk: imx: Add support for i.MX8MP clock driver
      dt-bindings: imx: Add clock binding doc for i.MX8MP
      clk: imx: gate4: Switch imx_clk_gate4_flags() to clk_hw based API
      clk: imx: imx8mq: Switch to clk_hw based API
      clk: imx: imx8mm: Switch to clk_hw based API
      clk: imx: imx8mn: Switch to clk_hw based API
      clk: imx: Remove __init for imx_obtain_fixed_clk_hw() API
      clk: imx: gate3: Switch to clk_hw based API
      clk: imx: add hw API imx_clk_hw_mux2_flags
      clk: imx: add imx_unregister_hw_clocks
      clk: imx: clk-composite-8m: Switch to clk_hw based API
      clk: imx: clk-pll14xx: Switch to clk_hw based API
      clk: imx7up: Rename the clks to hws
      clk: imx: Rename the imx_clk_divider_gate to imply it's clk_hw based
      clk: imx: Rename the imx_clk_pfdv2 to imply it's clk_hw based
      clk: imx: Rename the imx_clk_pllv4 to imply it's clk_hw based
      clk: imx: Rename sccg and frac pll register to suggest clk_hw
      clk: imx: imx7ulp composite: Rename to show is clk_hw based
      clk: imx: pllv2: Switch to clk_hw based API
      clk: imx: pllv1: Switch to clk_hw based API
      ...
    
    * clk-ti:
      clk: ti: clkctrl: Fix hidden dependency to node name
      clk: ti: add clkctrl data dra7 sgx
      clk: ti: omap5: Add missing AESS clock
      clk: ti: dra7: fix parent for gmac_clkctrl
      clk: ti: dra7: add vpe clkctrl data
      clk: ti: dra7: add cam clkctrl data
      dt-bindings: clock: Move ti-dra7-atl.h to dt-bindings/clock
    
    * clk-xilinx:
      clk: zynqmp: Add support for clock with CLK_DIVIDER_POWER_OF_TWO flag
      clk: zynqmp: Fix divider calculation
      clk: zynqmp: Add support for get max divider
      clk: zynqmp: Warn user if clock user are more than allowed
      clk: zynqmp: Extend driver for versal
      dt-bindings: clock: Add bindings for versal clock driver
    
    * clk-nvidia:
      clk: tegra20/30: Explicitly set parent clock for Video Decoder
      clk: tegra20/30: Don't pre-initialize displays parent clock
      clk: tegra: divider: Check UART's divider enable-bit state on rate's recalculation
      clk: tegra: clk-dfll: Remove call to pm_runtime_irq_safe()
      clk: tegra: Mark fuse clock as critical
    
    * clk-qcom: (35 commits)
      clk: qcom: rpmh: Sort OF match table
      dt-bindings: fix warnings in validation of qcom,gcc.yaml
      dt-binding: fix compilation error of the example in qcom,gcc.yaml
      clk: qcom: Add ipq6018 Global Clock Controller support
      clk: qcom: Add DT bindings for ipq6018 gcc clock controller
      clk: qcom: gcc-msm8996: Fix parent for CLKREF clocks
      clk: qcom: rpmh: Add IPA clock for SC7180
      clk: qcom: rpmh: skip undefined clocks when registering
      clk: qcom: Add video clock controller driver for SC7180
      dt-bindings: clock: Introduce SC7180 QCOM Video clock bindings
      dt-bindings: clock: Add YAML schemas for the QCOM VIDEOCC clock bindings
      clk: qcom: Add graphics clock controller driver for SC7180
      dt-bindings: clock: Introduce SC7180 QCOM Graphics clock bindings
      dt-bindings: clock: Add YAML schemas for the QCOM GPUCC clock bindings
      clk: qcom: apcs-msm8916: use clk_parent_data to specify the parent
      clk: qcom: Add display clock controller driver for SC7180
      dt-bindings: clock: Introduce QCOM sc7180 display clock bindings
      dt-bindings: clock: Add YAML schemas for the QCOM DISPCC clock bindings
      clk: qcom: clk-alpha-pll: Add support for Fabia PLL calibration
      clk: qcom: alpha-pll: Remove useless read from set rate
      ...
    
    * clk-freescale:
      clk: fsl-sai: new driver
      dt-bindings: clock: document the fsl-sai driver
      clk: composite: add _register_composite_pdata() variants
    
    * clk-qoriq:
      clk: qoriq: add ls1088a hwaccel clocks support
      clk: ls1028a: Add clock driver for Display output interface
      dt/bindings: clk: Add YAML schemas for LS1028A Display Clock bindings

commit a4b431f8038a67222fde888a48bcbd704d2daca0
Author: Peng Fan <peng.fan@nxp.com>
Date:   Thu Dec 12 02:58:48 2019 +0000

    clk: imx: clk-composite-8m: Switch to clk_hw based API
    
    Switch the imx8m_clk_hw_composite_flags function to clk_hw based API,
    rename accordingly and add a macro for clk based legacy. This allows
    us to move closer to a clear split between consumer and provider clk
    APIs.
    
    Reviewed-by: Abel Vesa <abel.vesa@nxp.com>
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 388bdb94f841..e0f25983e80f 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -123,7 +123,7 @@ static const struct clk_ops imx8m_clk_composite_divider_ops = {
 	.set_rate = imx8m_clk_composite_divider_set_rate,
 };
 
-struct clk *imx8m_clk_composite_flags(const char *name,
+struct clk_hw *imx8m_clk_hw_composite_flags(const char *name,
 					const char * const *parent_names,
 					int num_parents, void __iomem *reg,
 					unsigned long flags)
@@ -169,7 +169,7 @@ struct clk *imx8m_clk_composite_flags(const char *name,
 	if (IS_ERR(hw))
 		goto fail;
 
-	return hw->clk;
+	return hw;
 
 fail:
 	kfree(gate);

commit 073a01e8d7c23b3efb59a3d4c20aa546f9ec29a9
Author: Peng Fan <peng.fan@nxp.com>
Date:   Fri Nov 1 10:16:19 2019 +0000

    clk: imx: clk-composite-8m: add lock to gate/mux
    
    There is a lock to divider in the composite driver, but that's not
    enough. lock to gate/mux are also needed to provide exclusive access
    to the register.
    
    Fixes: d3ff9728134e ("clk: imx: Add imx composite clock")
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 388bdb94f841..d3486ee79ab5 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -142,6 +142,7 @@ struct clk *imx8m_clk_composite_flags(const char *name,
 	mux->reg = reg;
 	mux->shift = PCG_PCS_SHIFT;
 	mux->mask = PCG_PCS_MASK;
+	mux->lock = &imx_ccm_lock;
 
 	div = kzalloc(sizeof(*div), GFP_KERNEL);
 	if (!div)
@@ -161,6 +162,7 @@ struct clk *imx8m_clk_composite_flags(const char *name,
 	gate_hw = &gate->hw;
 	gate->reg = reg;
 	gate->bit_idx = PCG_CGC_SHIFT;
+	gate->lock = &imx_ccm_lock;
 
 	hw = clk_hw_register_composite(NULL, name, parent_names, num_parents,
 			mux_hw, &clk_mux_ops, div_hw,

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 574fac1a169f..388bdb94f841 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -3,9 +3,10 @@
  * Copyright 2018 NXP
  */
 
+#include <linux/clk-provider.h>
 #include <linux/errno.h>
+#include <linux/io.h>
 #include <linux/slab.h>
-#include <linux/clk-provider.h>
 
 #include "clk.h"
 

commit 65a6b7c5f31c39a47da729021cb2a5ec1339affb
Author: Abel Vesa <abel.vesa@nxp.com>
Date:   Fri Dec 14 15:30:09 2018 +0000

    clk: imx: Make parent_names const pointer in composite-8m
    
    The parent_names needs to be pointer to const pointer to const char.
    
    Signed-off-by: Abel Vesa <abel.vesa@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 527ade1d6933..574fac1a169f 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -123,7 +123,7 @@ static const struct clk_ops imx8m_clk_composite_divider_ops = {
 };
 
 struct clk *imx8m_clk_composite_flags(const char *name,
-					const char **parent_names,
+					const char * const *parent_names,
 					int num_parents, void __iomem *reg,
 					unsigned long flags)
 {

commit 33e7a8422546b5cd65d4af4dfe4ed92ea543d8df
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun Dec 9 15:08:32 2018 +0000

    clk: imx: remove redundant initialization of ret to zero
    
    The initialization of ret is redundant as it is being re-assigned to
    the return value from the call to imx8m_clk_composite_compute_dividers.
    Clean this up by removing the initialization.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
index 6d9d3714b4df..527ade1d6933 100644
--- a/drivers/clk/imx/clk-composite-8m.c
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -93,7 +93,7 @@ static int imx8m_clk_composite_divider_set_rate(struct clk_hw *hw,
 	unsigned long flags = 0;
 	int prediv_value;
 	int div_value;
-	int ret = 0;
+	int ret;
 	u32 val;
 
 	ret = imx8m_clk_composite_compute_dividers(rate, parent_rate,

commit d3ff9728134eeaa13d5bbb23c3f2e188f99cfdf9
Author: Abel Vesa <abel.vesa@nxp.com>
Date:   Sat Dec 1 10:52:14 2018 +0000

    clk: imx: Add imx composite clock
    
    Since a lot of clocks on imx8m are formed by a mux, gate, predivider and
    divider, the idea here is to combine all of those into one composite clock,
    but we need to deal with both predivider and divider at the same time and
    therefore we add the imx8m_clk_composite_divider_ops and register
    the composite clock with those.
    
    Signed-off-by: Abel Vesa <abel.vesa@nxp.com>
    Suggested-by: Sascha Hauer <s.hauer@pengutronix.de>
    Reviewed-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-composite-8m.c b/drivers/clk/imx/clk-composite-8m.c
new file mode 100644
index 000000000000..6d9d3714b4df
--- /dev/null
+++ b/drivers/clk/imx/clk-composite-8m.c
@@ -0,0 +1,178 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2018 NXP
+ */
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/clk-provider.h>
+
+#include "clk.h"
+
+#define PCG_PREDIV_SHIFT	16
+#define PCG_PREDIV_WIDTH	3
+#define PCG_PREDIV_MAX		8
+
+#define PCG_DIV_SHIFT		0
+#define PCG_DIV_WIDTH		6
+#define PCG_DIV_MAX		64
+
+#define PCG_PCS_SHIFT		24
+#define PCG_PCS_MASK		0x7
+
+#define PCG_CGC_SHIFT		28
+
+static unsigned long imx8m_clk_composite_divider_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct clk_divider *divider = to_clk_divider(hw);
+	unsigned long prediv_rate;
+	unsigned int prediv_value;
+	unsigned int div_value;
+
+	prediv_value = readl(divider->reg) >> divider->shift;
+	prediv_value &= clk_div_mask(divider->width);
+
+	prediv_rate = divider_recalc_rate(hw, parent_rate, prediv_value,
+						NULL, divider->flags,
+						divider->width);
+
+	div_value = readl(divider->reg) >> PCG_DIV_SHIFT;
+	div_value &= clk_div_mask(PCG_DIV_WIDTH);
+
+	return divider_recalc_rate(hw, prediv_rate, div_value, NULL,
+				   divider->flags, PCG_DIV_WIDTH);
+}
+
+static int imx8m_clk_composite_compute_dividers(unsigned long rate,
+						unsigned long parent_rate,
+						int *prediv, int *postdiv)
+{
+	int div1, div2;
+	int error = INT_MAX;
+	int ret = -EINVAL;
+
+	*prediv = 1;
+	*postdiv = 1;
+
+	for (div1 = 1; div1 <= PCG_PREDIV_MAX; div1++) {
+		for (div2 = 1; div2 <= PCG_DIV_MAX; div2++) {
+			int new_error = ((parent_rate / div1) / div2) - rate;
+
+			if (abs(new_error) < abs(error)) {
+				*prediv = div1;
+				*postdiv = div2;
+				error = new_error;
+				ret = 0;
+			}
+		}
+	}
+	return ret;
+}
+
+static long imx8m_clk_composite_divider_round_rate(struct clk_hw *hw,
+						unsigned long rate,
+						unsigned long *prate)
+{
+	int prediv_value;
+	int div_value;
+
+	imx8m_clk_composite_compute_dividers(rate, *prate,
+						&prediv_value, &div_value);
+	rate = DIV_ROUND_UP(*prate, prediv_value);
+
+	return DIV_ROUND_UP(rate, div_value);
+
+}
+
+static int imx8m_clk_composite_divider_set_rate(struct clk_hw *hw,
+					unsigned long rate,
+					unsigned long parent_rate)
+{
+	struct clk_divider *divider = to_clk_divider(hw);
+	unsigned long flags = 0;
+	int prediv_value;
+	int div_value;
+	int ret = 0;
+	u32 val;
+
+	ret = imx8m_clk_composite_compute_dividers(rate, parent_rate,
+						&prediv_value, &div_value);
+	if (ret)
+		return -EINVAL;
+
+	spin_lock_irqsave(divider->lock, flags);
+
+	val = readl(divider->reg);
+	val &= ~((clk_div_mask(divider->width) << divider->shift) |
+			(clk_div_mask(PCG_DIV_WIDTH) << PCG_DIV_SHIFT));
+
+	val |= (u32)(prediv_value  - 1) << divider->shift;
+	val |= (u32)(div_value - 1) << PCG_DIV_SHIFT;
+	writel(val, divider->reg);
+
+	spin_unlock_irqrestore(divider->lock, flags);
+
+	return ret;
+}
+
+static const struct clk_ops imx8m_clk_composite_divider_ops = {
+	.recalc_rate = imx8m_clk_composite_divider_recalc_rate,
+	.round_rate = imx8m_clk_composite_divider_round_rate,
+	.set_rate = imx8m_clk_composite_divider_set_rate,
+};
+
+struct clk *imx8m_clk_composite_flags(const char *name,
+					const char **parent_names,
+					int num_parents, void __iomem *reg,
+					unsigned long flags)
+{
+	struct clk_hw *hw = ERR_PTR(-ENOMEM), *mux_hw;
+	struct clk_hw *div_hw, *gate_hw;
+	struct clk_divider *div = NULL;
+	struct clk_gate *gate = NULL;
+	struct clk_mux *mux = NULL;
+
+	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+	if (!mux)
+		goto fail;
+
+	mux_hw = &mux->hw;
+	mux->reg = reg;
+	mux->shift = PCG_PCS_SHIFT;
+	mux->mask = PCG_PCS_MASK;
+
+	div = kzalloc(sizeof(*div), GFP_KERNEL);
+	if (!div)
+		goto fail;
+
+	div_hw = &div->hw;
+	div->reg = reg;
+	div->shift = PCG_PREDIV_SHIFT;
+	div->width = PCG_PREDIV_WIDTH;
+	div->lock = &imx_ccm_lock;
+	div->flags = CLK_DIVIDER_ROUND_CLOSEST;
+
+	gate = kzalloc(sizeof(*gate), GFP_KERNEL);
+	if (!gate)
+		goto fail;
+
+	gate_hw = &gate->hw;
+	gate->reg = reg;
+	gate->bit_idx = PCG_CGC_SHIFT;
+
+	hw = clk_hw_register_composite(NULL, name, parent_names, num_parents,
+			mux_hw, &clk_mux_ops, div_hw,
+			&imx8m_clk_composite_divider_ops,
+			gate_hw, &clk_gate_ops, flags);
+	if (IS_ERR(hw))
+		goto fail;
+
+	return hw->clk;
+
+fail:
+	kfree(gate);
+	kfree(div);
+	kfree(mux);
+	return ERR_CAST(hw);
+}
