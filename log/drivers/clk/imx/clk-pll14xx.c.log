commit 55a8b3cdff54a0e6faa43a41c8e1eb47e56c6831
Author: Abel Vesa <abel.vesa@nxp.com>
Date:   Wed Apr 15 11:02:46 2020 +0300

    clk: imx: pll14xx: Add the device as argument when registering
    
    In order to allow runtime PM, the device needs to be passed on
    to the register function. Audiomix clock controller, used on
    i.MX8MP and future platforms, registers a pll14xx and has runtime
    PM support.
    
    Signed-off-by: Abel Vesa <abel.vesa@nxp.com>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index a83bbbee77d9..f9eb189b93c0 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -378,9 +378,9 @@ static const struct clk_ops clk_pll1443x_ops = {
 	.set_rate	= clk_pll1443x_set_rate,
 };
 
-struct clk_hw *imx_clk_hw_pll14xx(const char *name, const char *parent_name,
-				  void __iomem *base,
-				  const struct imx_pll14xx_clk *pll_clk)
+struct clk_hw *imx_dev_clk_hw_pll14xx(struct device *dev, const char *name,
+				const char *parent_name, void __iomem *base,
+				const struct imx_pll14xx_clk *pll_clk)
 {
 	struct clk_pll14xx *pll;
 	struct clk_hw *hw;
@@ -426,7 +426,7 @@ struct clk_hw *imx_clk_hw_pll14xx(const char *name, const char *parent_name,
 
 	hw = &pll->hw;
 
-	ret = clk_hw_register(NULL, hw);
+	ret = clk_hw_register(dev, hw);
 	if (ret) {
 		pr_err("%s: failed to register pll %s %d\n",
 			__func__, name, ret);

commit 530cf8d49f2a650625eee6ce28793bd7974e14bd
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Fri Feb 21 14:31:56 2020 +0800

    clk: imx: pll14xx: Return error if pll type is invalid
    
    When pll type is invalid, ONLY output error message is NOT enough,
    should return error immediately.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 37e311e1d058..a83bbbee77d9 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -410,6 +410,8 @@ struct clk_hw *imx_clk_hw_pll14xx(const char *name, const char *parent_name,
 	default:
 		pr_err("%s: Unknown pll type for pll clk %s\n",
 		       __func__, name);
+		kfree(pll);
+		return ERR_PTR(-EINVAL);
 	};
 
 	pll->base = base;

commit 57795654fb553a78f07a9f92d87fb2582379cd93
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Thu Jan 16 14:50:49 2020 +0800

    clk: imx: pll14xx: Add new frequency entries for pll1443x table
    
    Add new frequency entries to pll1443x table to meet different
    display settings requirement.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Peng Fan <peng.fan@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 5b0519a81a7a..37e311e1d058 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -55,8 +55,10 @@ static const struct imx_pll14xx_rate_table imx_pll1416x_tbl[] = {
 };
 
 static const struct imx_pll14xx_rate_table imx_pll1443x_tbl[] = {
+	PLL_1443X_RATE(1039500000U, 173, 2, 1, 16384),
 	PLL_1443X_RATE(650000000U, 325, 3, 2, 0),
 	PLL_1443X_RATE(594000000U, 198, 2, 2, 0),
+	PLL_1443X_RATE(519750000U, 173, 2, 2, 16384),
 	PLL_1443X_RATE(393216000U, 262, 2, 3, 9437),
 	PLL_1443X_RATE(361267200U, 361, 3, 3, 17511),
 };

commit db865ee447d46eccd641dc70c7f9acc231a3141e
Merge: 6e7a9f0c4ea8 498e165274f3 660b94e0d8fe 34bbe0361707 185dfe32d7e2 9e0cda721d18 9cd10205227c a932872f1b76
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Jan 31 13:14:26 2020 -0800

    Merge branches 'clk-imx', 'clk-ti', 'clk-xilinx', 'clk-nvidia', 'clk-qcom', 'clk-freescale' and 'clk-qoriq' into clk-next
    
     - Support for Xilinx Versal platform clks
     - Display clk controller on qcom sc7180
     - Video clk controller on qcom sc7180
     - Graphics clk controller on qcom sc7180
     - CPU PLLs for qcom msm8916
     - Fixes for clk controllers on qcom msm8998 SoCs
     - Move qcom msm8974 gfx3d clk to RPM control
     - Display port clk support on qcom sdm845 SoCs
     - Global clk controller on qcom ipq6018
     - Adjust composite clk to new way of describing clk parents
     - Add a driver for BCLK of Freescale SAI cores
    
    * clk-imx: (32 commits)
      clk: imx: Add support for i.MX8MP clock driver
      dt-bindings: imx: Add clock binding doc for i.MX8MP
      clk: imx: gate4: Switch imx_clk_gate4_flags() to clk_hw based API
      clk: imx: imx8mq: Switch to clk_hw based API
      clk: imx: imx8mm: Switch to clk_hw based API
      clk: imx: imx8mn: Switch to clk_hw based API
      clk: imx: Remove __init for imx_obtain_fixed_clk_hw() API
      clk: imx: gate3: Switch to clk_hw based API
      clk: imx: add hw API imx_clk_hw_mux2_flags
      clk: imx: add imx_unregister_hw_clocks
      clk: imx: clk-composite-8m: Switch to clk_hw based API
      clk: imx: clk-pll14xx: Switch to clk_hw based API
      clk: imx7up: Rename the clks to hws
      clk: imx: Rename the imx_clk_divider_gate to imply it's clk_hw based
      clk: imx: Rename the imx_clk_pfdv2 to imply it's clk_hw based
      clk: imx: Rename the imx_clk_pllv4 to imply it's clk_hw based
      clk: imx: Rename sccg and frac pll register to suggest clk_hw
      clk: imx: imx7ulp composite: Rename to show is clk_hw based
      clk: imx: pllv2: Switch to clk_hw based API
      clk: imx: pllv1: Switch to clk_hw based API
      ...
    
    * clk-ti:
      clk: ti: clkctrl: Fix hidden dependency to node name
      clk: ti: add clkctrl data dra7 sgx
      clk: ti: omap5: Add missing AESS clock
      clk: ti: dra7: fix parent for gmac_clkctrl
      clk: ti: dra7: add vpe clkctrl data
      clk: ti: dra7: add cam clkctrl data
      dt-bindings: clock: Move ti-dra7-atl.h to dt-bindings/clock
    
    * clk-xilinx:
      clk: zynqmp: Add support for clock with CLK_DIVIDER_POWER_OF_TWO flag
      clk: zynqmp: Fix divider calculation
      clk: zynqmp: Add support for get max divider
      clk: zynqmp: Warn user if clock user are more than allowed
      clk: zynqmp: Extend driver for versal
      dt-bindings: clock: Add bindings for versal clock driver
    
    * clk-nvidia:
      clk: tegra20/30: Explicitly set parent clock for Video Decoder
      clk: tegra20/30: Don't pre-initialize displays parent clock
      clk: tegra: divider: Check UART's divider enable-bit state on rate's recalculation
      clk: tegra: clk-dfll: Remove call to pm_runtime_irq_safe()
      clk: tegra: Mark fuse clock as critical
    
    * clk-qcom: (35 commits)
      clk: qcom: rpmh: Sort OF match table
      dt-bindings: fix warnings in validation of qcom,gcc.yaml
      dt-binding: fix compilation error of the example in qcom,gcc.yaml
      clk: qcom: Add ipq6018 Global Clock Controller support
      clk: qcom: Add DT bindings for ipq6018 gcc clock controller
      clk: qcom: gcc-msm8996: Fix parent for CLKREF clocks
      clk: qcom: rpmh: Add IPA clock for SC7180
      clk: qcom: rpmh: skip undefined clocks when registering
      clk: qcom: Add video clock controller driver for SC7180
      dt-bindings: clock: Introduce SC7180 QCOM Video clock bindings
      dt-bindings: clock: Add YAML schemas for the QCOM VIDEOCC clock bindings
      clk: qcom: Add graphics clock controller driver for SC7180
      dt-bindings: clock: Introduce SC7180 QCOM Graphics clock bindings
      dt-bindings: clock: Add YAML schemas for the QCOM GPUCC clock bindings
      clk: qcom: apcs-msm8916: use clk_parent_data to specify the parent
      clk: qcom: Add display clock controller driver for SC7180
      dt-bindings: clock: Introduce QCOM sc7180 display clock bindings
      dt-bindings: clock: Add YAML schemas for the QCOM DISPCC clock bindings
      clk: qcom: clk-alpha-pll: Add support for Fabia PLL calibration
      clk: qcom: alpha-pll: Remove useless read from set rate
      ...
    
    * clk-freescale:
      clk: fsl-sai: new driver
      dt-bindings: clock: document the fsl-sai driver
      clk: composite: add _register_composite_pdata() variants
    
    * clk-qoriq:
      clk: qoriq: add ls1088a hwaccel clocks support
      clk: ls1028a: Add clock driver for Display output interface
      dt/bindings: clk: Add YAML schemas for LS1028A Display Clock bindings

commit 10c34b50f240d0e6507567e86b7bb1a79abd9ff0
Author: Peng Fan <peng.fan@nxp.com>
Date:   Thu Dec 12 02:58:42 2019 +0000

    clk: imx: clk-pll14xx: Switch to clk_hw based API
    
    Switch the imx_clk_pll14xx function to clk_hw based API, rename
    accordingly and add a macro for clk based legacy. This allows us to
    move closer to a clear split between consumer and provider clk APIs.
    
    Reviewed-by: Abel Vesa <abel.vesa@nxp.com>
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index a6d31a7262ef..968dd021800e 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -376,13 +376,14 @@ static const struct clk_ops clk_pll1443x_ops = {
 	.set_rate	= clk_pll1443x_set_rate,
 };
 
-struct clk *imx_clk_pll14xx(const char *name, const char *parent_name,
-			    void __iomem *base,
-			    const struct imx_pll14xx_clk *pll_clk)
+struct clk_hw *imx_clk_hw_pll14xx(const char *name, const char *parent_name,
+				  void __iomem *base,
+				  const struct imx_pll14xx_clk *pll_clk)
 {
 	struct clk_pll14xx *pll;
-	struct clk *clk;
+	struct clk_hw *hw;
 	struct clk_init_data init;
+	int ret;
 	u32 val;
 
 	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
@@ -419,12 +420,15 @@ struct clk *imx_clk_pll14xx(const char *name, const char *parent_name,
 	val &= ~BYPASS_MASK;
 	writel_relaxed(val, pll->base + GNRL_CTL);
 
-	clk = clk_register(NULL, &pll->hw);
-	if (IS_ERR(clk)) {
-		pr_err("%s: failed to register pll %s %lu\n",
-			__func__, name, PTR_ERR(clk));
+	hw = &pll->hw;
+
+	ret = clk_hw_register(NULL, hw);
+	if (ret) {
+		pr_err("%s: failed to register pll %s %d\n",
+			__func__, name, ret);
 		kfree(pll);
+		return ERR_PTR(ret);
 	}
 
-	return clk;
+	return hw;
 }

commit c3a5fd15ed0c1494435e4e35fbee734ae46b5073
Author: Peng Fan <peng.fan@nxp.com>
Date:   Mon Dec 9 08:19:55 2019 +0000

    clk: imx: pll14xx: fix clk_pll14xx_wait_lock
    
    The usage of readl_poll_timeout is wrong, the 3rd parameter(cond)
    should be "val & LOCK_STATUS" not "val & LOCK_TIMEOUT_US",
    It is not check whether the pll locked, LOCK_STATUS reflects the mask,
    not LOCK_TIMEOUT_US.
    
    Fixes: 8646d4dcc7fb ("clk: imx: Add PLLs driver for imx8mm soc")
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Abel Vesa <abel.vesa@nxp.com>
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 5c458199060a..3636c8035c7d 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -159,7 +159,7 @@ static int clk_pll14xx_wait_lock(struct clk_pll14xx *pll)
 {
 	u32 val;
 
-	return readl_poll_timeout(pll->base, val, val & LOCK_TIMEOUT_US, 0,
+	return readl_poll_timeout(pll->base, val, val & LOCK_STATUS, 0,
 			LOCK_TIMEOUT_US);
 }
 

commit e18f64712e9ef22054da1babe425d2a5892edcd4
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Fri Nov 22 23:45:01 2019 +0200

    clk: imx: Mark dram pll on 8mm and 8mn with CLK_GET_RATE_NOCACHE
    
    DRAM frequency switches are executed in firmware and can change the
    configuration of the DRAM PLL outside linux. Mark these CLKs with
    CLK_GET_RATE_NOCACHE so we always read back the PLL config registers and
    recalculate rates.
    
    In current DRAM frequency tables on 8mm/8mn only the maximum frequency
    uses the PLL so it's always configured in the same way. However reading
    back the PLL configuration is the correct behavior and allows additional
    setpoints in the future.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Reviewed-by: Abel Vesa <abel.vesa@nxp.com>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 5c458199060a..a6d31a7262ef 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -67,6 +67,13 @@ struct imx_pll14xx_clk imx_1443x_pll = {
 	.rate_count = ARRAY_SIZE(imx_pll1443x_tbl),
 };
 
+struct imx_pll14xx_clk imx_1443x_dram_pll = {
+	.type = PLL_1443X,
+	.rate_table = imx_pll1443x_tbl,
+	.rate_count = ARRAY_SIZE(imx_pll1443x_tbl),
+	.flags = CLK_GET_RATE_NOCACHE,
+};
+
 struct imx_pll14xx_clk imx_1416x_pll = {
 	.type = PLL_1416X,
 	.rate_table = imx_pll1416x_tbl,

commit 8f2d3c1759d19232edf1e9ef43d40a44e31493d6
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Oct 8 15:19:08 2019 +0800

    clk: imx: clk-pll14xx: Make two variables static
    
    Fix sparse warnings:
    
    drivers/clk/imx/clk-pll14xx.c:44:37:
     warning: symbol 'imx_pll1416x_tbl' was not declared. Should it be static?
    drivers/clk/imx/clk-pll14xx.c:57:37:
     warning: symbol 'imx_pll1443x_tbl' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Reviewed-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 7faad6065785..5c458199060a 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -41,7 +41,7 @@ struct clk_pll14xx {
 
 #define to_clk_pll14xx(_hw) container_of(_hw, struct clk_pll14xx, hw)
 
-const struct imx_pll14xx_rate_table imx_pll1416x_tbl[] = {
+static const struct imx_pll14xx_rate_table imx_pll1416x_tbl[] = {
 	PLL_1416X_RATE(1800000000U, 225, 3, 0),
 	PLL_1416X_RATE(1600000000U, 200, 3, 0),
 	PLL_1416X_RATE(1500000000U, 375, 3, 1),
@@ -54,7 +54,7 @@ const struct imx_pll14xx_rate_table imx_pll1416x_tbl[] = {
 	PLL_1416X_RATE(600000000U,  300, 3, 2),
 };
 
-const struct imx_pll14xx_rate_table imx_pll1443x_tbl[] = {
+static const struct imx_pll14xx_rate_table imx_pll1443x_tbl[] = {
 	PLL_1443X_RATE(650000000U, 325, 3, 2, 0),
 	PLL_1443X_RATE(594000000U, 198, 2, 2, 0),
 	PLL_1443X_RATE(393216000U, 262, 2, 3, 9437),

commit 0ae4fbc63c31fd318a7feb8590f0a05b250aa79e
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Fri Sep 6 09:34:06 2019 -0400

    clk: imx8mn: Use common 1443X/1416X PLL clock structure
    
    Use common 1413X/1416X PLL clock structure to save a lot
    of duplicated code on i.MX8MN clock driver.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 64826e22c328..7faad6065785 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -44,6 +44,8 @@ struct clk_pll14xx {
 const struct imx_pll14xx_rate_table imx_pll1416x_tbl[] = {
 	PLL_1416X_RATE(1800000000U, 225, 3, 0),
 	PLL_1416X_RATE(1600000000U, 200, 3, 0),
+	PLL_1416X_RATE(1500000000U, 375, 3, 1),
+	PLL_1416X_RATE(1400000000U, 350, 3, 1),
 	PLL_1416X_RATE(1200000000U, 300, 3, 1),
 	PLL_1416X_RATE(1000000000U, 250, 3, 1),
 	PLL_1416X_RATE(800000000U,  200, 3, 1),

commit 43cdaa1567ad3931fbde438853947d45238cc040
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Fri Sep 6 09:34:05 2019 -0400

    clk: imx8mm: Move 1443X/1416X PLL clock structure to common place
    
    Many i.MX8M SoCs use same 1443X/1416X PLL, such as i.MX8MM,
    i.MX8MN and later i.MX8M SoCs, moving these PLL definitions
    to pll14xx driver can save a lot of duplicated code on each
    platform.
    
    Meanwhile, no need to define PLL clock structure for every
    module which uses same type of PLL, e.g., audio/video/dram use
    1443X PLL, arm/gpu/vpu/sys use 1416X PLL, define 2 PLL clock
    structure for each group is enough.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 45dc7cc1f967..64826e22c328 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -41,6 +41,36 @@ struct clk_pll14xx {
 
 #define to_clk_pll14xx(_hw) container_of(_hw, struct clk_pll14xx, hw)
 
+const struct imx_pll14xx_rate_table imx_pll1416x_tbl[] = {
+	PLL_1416X_RATE(1800000000U, 225, 3, 0),
+	PLL_1416X_RATE(1600000000U, 200, 3, 0),
+	PLL_1416X_RATE(1200000000U, 300, 3, 1),
+	PLL_1416X_RATE(1000000000U, 250, 3, 1),
+	PLL_1416X_RATE(800000000U,  200, 3, 1),
+	PLL_1416X_RATE(750000000U,  250, 2, 2),
+	PLL_1416X_RATE(700000000U,  350, 3, 2),
+	PLL_1416X_RATE(600000000U,  300, 3, 2),
+};
+
+const struct imx_pll14xx_rate_table imx_pll1443x_tbl[] = {
+	PLL_1443X_RATE(650000000U, 325, 3, 2, 0),
+	PLL_1443X_RATE(594000000U, 198, 2, 2, 0),
+	PLL_1443X_RATE(393216000U, 262, 2, 3, 9437),
+	PLL_1443X_RATE(361267200U, 361, 3, 3, 17511),
+};
+
+struct imx_pll14xx_clk imx_1443x_pll = {
+	.type = PLL_1443X,
+	.rate_table = imx_pll1443x_tbl,
+	.rate_count = ARRAY_SIZE(imx_pll1443x_tbl),
+};
+
+struct imx_pll14xx_clk imx_1416x_pll = {
+	.type = PLL_1416X,
+	.rate_table = imx_pll1416x_tbl,
+	.rate_count = ARRAY_SIZE(imx_pll1416x_tbl),
+};
+
 static const struct imx_pll14xx_rate_table *imx_get_pll_settings(
 		struct clk_pll14xx *pll, unsigned long rate)
 {

commit 094234fcf46146339caaac8282aa15d225a5911a
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Wed Sep 4 12:49:18 2019 +0300

    clk: imx: pll14xx: Fix quick switch of S/K parameter
    
    The PLL14xx on imx8m can change the S and K parameter without requiring
    a reset and relock of the whole PLL.
    
    Fix clk_pll144xx_mp_change register reading and use it for pll1443 as
    well since no reset+relock is required on K changes either.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Fixes: 8646d4dcc7fb ("clk: imx: Add PLLs driver for imx8mm soc")
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 7a815ec76aa5..45dc7cc1f967 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -112,43 +112,17 @@ static unsigned long clk_pll1443x_recalc_rate(struct clk_hw *hw,
 	return fvco;
 }
 
-static inline bool clk_pll1416x_mp_change(const struct imx_pll14xx_rate_table *rate,
+static inline bool clk_pll14xx_mp_change(const struct imx_pll14xx_rate_table *rate,
 					  u32 pll_div)
 {
 	u32 old_mdiv, old_pdiv;
 
-	old_mdiv = (pll_div >> MDIV_SHIFT) & MDIV_MASK;
-	old_pdiv = (pll_div >> PDIV_SHIFT) & PDIV_MASK;
+	old_mdiv = (pll_div & MDIV_MASK) >> MDIV_SHIFT;
+	old_pdiv = (pll_div & PDIV_MASK) >> PDIV_SHIFT;
 
 	return rate->mdiv != old_mdiv || rate->pdiv != old_pdiv;
 }
 
-static inline bool clk_pll1443x_mpk_change(const struct imx_pll14xx_rate_table *rate,
-					  u32 pll_div_ctl0, u32 pll_div_ctl1)
-{
-	u32 old_mdiv, old_pdiv, old_kdiv;
-
-	old_mdiv = (pll_div_ctl0 >> MDIV_SHIFT) & MDIV_MASK;
-	old_pdiv = (pll_div_ctl0 >> PDIV_SHIFT) & PDIV_MASK;
-	old_kdiv = (pll_div_ctl1 >> KDIV_SHIFT) & KDIV_MASK;
-
-	return rate->mdiv != old_mdiv || rate->pdiv != old_pdiv ||
-		rate->kdiv != old_kdiv;
-}
-
-static inline bool clk_pll1443x_mp_change(const struct imx_pll14xx_rate_table *rate,
-					  u32 pll_div_ctl0, u32 pll_div_ctl1)
-{
-	u32 old_mdiv, old_pdiv, old_kdiv;
-
-	old_mdiv = (pll_div_ctl0 >> MDIV_SHIFT) & MDIV_MASK;
-	old_pdiv = (pll_div_ctl0 >> PDIV_SHIFT) & PDIV_MASK;
-	old_kdiv = (pll_div_ctl1 >> KDIV_SHIFT) & KDIV_MASK;
-
-	return rate->mdiv != old_mdiv || rate->pdiv != old_pdiv ||
-		rate->kdiv != old_kdiv;
-}
-
 static int clk_pll14xx_wait_lock(struct clk_pll14xx *pll)
 {
 	u32 val;
@@ -174,7 +148,7 @@ static int clk_pll1416x_set_rate(struct clk_hw *hw, unsigned long drate,
 
 	tmp = readl_relaxed(pll->base + 4);
 
-	if (!clk_pll1416x_mp_change(rate, tmp)) {
+	if (!clk_pll14xx_mp_change(rate, tmp)) {
 		tmp &= ~(SDIV_MASK) << SDIV_SHIFT;
 		tmp |= rate->sdiv << SDIV_SHIFT;
 		writel_relaxed(tmp, pll->base + 4);
@@ -239,13 +213,15 @@ static int clk_pll1443x_set_rate(struct clk_hw *hw, unsigned long drate,
 	}
 
 	tmp = readl_relaxed(pll->base + 4);
-	div_val = readl_relaxed(pll->base + 8);
 
-	if (!clk_pll1443x_mpk_change(rate, tmp, div_val)) {
+	if (!clk_pll14xx_mp_change(rate, tmp)) {
 		tmp &= ~(SDIV_MASK) << SDIV_SHIFT;
 		tmp |= rate->sdiv << SDIV_SHIFT;
 		writel_relaxed(tmp, pll->base + 4);
 
+		tmp = rate->kdiv << KDIV_SHIFT;
+		writel_relaxed(tmp, pll->base + 8);
+
 		return 0;
 	}
 

commit a9aa8306074d9519dd6e5fdf07240b01bac72e04
Author: Peng Fan <peng.fan@nxp.com>
Date:   Mon Sep 9 03:39:39 2019 +0000

    clk: imx: clk-pll14xx: unbypass PLL by default
    
    When registering the PLL, unbypass the PLL.
    The PLL has two bypass control bit, BYPASS and EXT_BYPASS.
    we will expose EXT_BYPASS to clk driver for mux usage, and keep
    BYPASS inside pll14xx usage. The PLL has a restriction that
    when M/P change, need to RESET/BYPASS pll to avoid glitch, so
    we could not expose BYPASS.
    
    To make it easy for clk driver usage, unbypass PLL which does
    not hurt current function.
    
    Fixes: 8646d4dcc7fb ("clk: imx: Add PLLs driver for imx8mm soc")
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Link: https://lkml.kernel.org/r/1568043491-20680-3-git-send-email-peng.fan@nxp.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 656f48b002dd..7a815ec76aa5 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -368,6 +368,7 @@ struct clk *imx_clk_pll14xx(const char *name, const char *parent_name,
 	struct clk_pll14xx *pll;
 	struct clk *clk;
 	struct clk_init_data init;
+	u32 val;
 
 	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
 	if (!pll)
@@ -399,6 +400,10 @@ struct clk *imx_clk_pll14xx(const char *name, const char *parent_name,
 	pll->rate_table = pll_clk->rate_table;
 	pll->rate_count = pll_clk->rate_count;
 
+	val = readl_relaxed(pll->base + GNRL_CTL);
+	val &= ~BYPASS_MASK;
+	writel_relaxed(val, pll->base + GNRL_CTL);
+
 	clk = clk_register(NULL, &pll->hw);
 	if (IS_ERR(clk)) {
 		pr_err("%s: failed to register pll %s %lu\n",

commit dee1bc9c23cd41fe32549c0adbe6cb57cab02282
Author: Peng Fan <peng.fan@nxp.com>
Date:   Mon Sep 9 03:39:34 2019 +0000

    clk: imx: pll14xx: avoid glitch when set rate
    
    According to PLL1443XA and PLL1416X spec,
    "When BYPASS is 0 and RESETB is changed from 0 to 1, FOUT starts to
    output unstable clock until lock time passes. PLL1416X/PLL1443XA may
    generate a glitch at FOUT."
    
    So set BYPASS when RESETB is changed from 0 to 1 to avoid glitch.
    In the end of set rate, BYPASS will be cleared.
    
    When prepare clock, also need to take care to avoid glitch. So
    we also follow Spec to set BYPASS before RESETB changed from 0 to 1.
    And add a check if the RESETB is already 0, directly return 0;
    
    Fixes: 8646d4dcc7fb ("clk: imx: Add PLLs driver for imx8mm soc")
    Reviewed-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Link: https://lkml.kernel.org/r/1568043491-20680-2-git-send-email-peng.fan@nxp.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index b7213023b238..656f48b002dd 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -191,6 +191,10 @@ static int clk_pll1416x_set_rate(struct clk_hw *hw, unsigned long drate,
 	tmp &= ~RST_MASK;
 	writel_relaxed(tmp, pll->base);
 
+	/* Enable BYPASS */
+	tmp |= BYPASS_MASK;
+	writel(tmp, pll->base);
+
 	div_val = (rate->mdiv << MDIV_SHIFT) | (rate->pdiv << PDIV_SHIFT) |
 		(rate->sdiv << SDIV_SHIFT);
 	writel_relaxed(div_val, pll->base + 0x4);
@@ -250,6 +254,10 @@ static int clk_pll1443x_set_rate(struct clk_hw *hw, unsigned long drate,
 	tmp &= ~RST_MASK;
 	writel_relaxed(tmp, pll->base);
 
+	/* Enable BYPASS */
+	tmp |= BYPASS_MASK;
+	writel_relaxed(tmp, pll->base);
+
 	div_val = (rate->mdiv << MDIV_SHIFT) | (rate->pdiv << PDIV_SHIFT) |
 		(rate->sdiv << SDIV_SHIFT);
 	writel_relaxed(div_val, pll->base + 0x4);
@@ -283,16 +291,28 @@ static int clk_pll14xx_prepare(struct clk_hw *hw)
 {
 	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
 	u32 val;
+	int ret;
 
 	/*
 	 * RESETB = 1 from 0, PLL starts its normal
 	 * operation after lock time
 	 */
 	val = readl_relaxed(pll->base + GNRL_CTL);
+	if (val & RST_MASK)
+		return 0;
+	val |= BYPASS_MASK;
+	writel_relaxed(val, pll->base + GNRL_CTL);
 	val |= RST_MASK;
 	writel_relaxed(val, pll->base + GNRL_CTL);
 
-	return clk_pll14xx_wait_lock(pll);
+	ret = clk_pll14xx_wait_lock(pll);
+	if (ret)
+		return ret;
+
+	val &= ~BYPASS_MASK;
+	writel_relaxed(val, pll->base + GNRL_CTL);
+
+	return 0;
 }
 
 static int clk_pll14xx_is_prepared(struct clk_hw *hw)

commit 2ed3b9103a2b5482f7e00811bda0976feb10ade0
Merge: e93c9c99a629 c2f0705f85fd c0ee0e43c049 db077febb774 6a6ba5b55a72 a5a627c67659
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue May 7 11:44:21 2019 -0700

    Merge branches 'clk-renesas', 'clk-qcom', 'clk-mtk', 'clk-milbeaut' and 'clk-imx' into clk-next
    
     - Qualcomm QCS404 CDSP clk support
     - Qualcomm QCS404 Turing clk support
     - Mediatek MT8183 clock support
     - Mediatek MT8516 clock support
     - Milbeaut M10V clk controller support
    
    * clk-renesas:
      clk: renesas: rcar-gen3: Remove unused variable
      clk: renesas: rcar-gen3: Fix cpg_sd_clock_round_rate() return value
      clk: renesas: r8a77980: Fix RPC-IF module clock's parent
      clk: renesas: rcar-gen3: Rename DRIF clocks
      clk: renesas: rcar-gen3: Correct parent clock of Audio-DMAC
      clk: renesas: rcar-gen3: Correct parent clock of SYS-DMAC
      clk: renesas: rcar-gen3: Correct parent clock of HS-USB
      clk: renesas: rcar-gen3: Correct parent clock of EHCI/OHCI
      clk: renesas: r8a774c0: Add Z2 clock
      clk: renesas: r8a77990: Add Z2 clock
      clk: renesas: rcar-gen3: Support Z and Z2 clocks with high frequency parents
      math64: New DIV64_U64_ROUND_CLOSEST helper
      clk: renesas: rcar-gen3: Remove CLK_TYPE_GEN3_Z2
      clk: renesas: rcar-gen3: Parameterise Z and Z2 clock offset
      clk: renesas: rcar-gen3: Parameterise Z and Z2 clock fixed divisor
      clk: renesas: r9a06g032: Add missing PCI USB clock
      clk: renesas: r7s9210: Always use readl()
      clk: renesas: rcar-gen3: Pass name/offset to cpg_sd_clk_register()
    
    * clk-qcom:
      clk: qcom: Skip halt checks on gcc_pcie_0_pipe_clk for 8998
      clk: qcom: Add QCS404 TuringCC
      clk: qcom: branch: Add AON clock ops
      dt-bindings: clock: Introduce Qualcomm Turing Clock controller
      clk: qcom: gcc-qcs404: Add CDSP related clocks and resets
    
    * clk-mtk:
      clk: mediatek: add clock driver for MT8516
      dt-bindings: mediatek: apmixedsys: add support for MT8516
      dt-bindings: mediatek: infracfg: add support for MT8516
      dt-bindings: mediatek: topckgen: add support for MT8516
      clk: mediatek: Allow changing PLL rate when it is off
      clk: mediatek: Add MT8183 clock support
      clk: mediatek: Add configurable pcw_chg_reg to mtk_pll_data
      clk: mediatek: Add dt-bindings for MT8183 clocks
      dt-bindings: ARM: Mediatek: Document bindings for MT8183
      clk: mediatek: Add configurable pcwibits and fmin to mtk_pll_data
      clk: mediatek: Add new clkmux register API
      clk: mediatek: Disable tuner_en before change PLL rate
    
    * clk-milbeaut:
      clock: milbeaut: Add Milbeaut M10V clock controller
      dt-bindings: clock: milbeaut: add Milbeaut clock description
    
    * clk-imx:
      clk: imx: correct pfdv2 gate_bit/vld_bit operations
      clk: imx: clk-pllv3: mark expected switch fall-throughs
      clk: imx8mq: Add dsi_ipg_div
      clk: imx: pllv4: add fractional-N pll support
      clk: imx: keep uart clock on during system boot
      clk: imx: correct i.MX7D AV PLL num/denom offset
      clk: imx6sll: Fix mispelling uart4_serial as serail
      clk: imx: pll14xx: drop unused variable
      clk: imx: rename clk-imx51-imx53.c to clk-imx5.c
      clk: imx5: Fix i.MX50 ESDHC clock registers
      clk: imx5: Fix i.MX50 mainbus clock registers
      clk: imx: Remove unused imx_get_clk_hw_fixed
      dt-bindings: clock: imx7ulp: remove SNVS clock
      clk: imx7ulp: remove snvs clock

commit a3c9e13ff0f4f41e4ed4c5111e29a0a7cfd2e119
Author: Peng Fan <peng.fan@nxp.com>
Date:   Thu Apr 25 10:14:28 2019 +0000

    clk: imx: pll14xx: drop unused variable
    
    It does not make sense to only get value from pll->base and assign
    to a local variable when recalc_rate.
    
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 1acfa3e3cfb4..12e584185daf 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -74,10 +74,9 @@ static unsigned long clk_pll1416x_recalc_rate(struct clk_hw *hw,
 						  unsigned long parent_rate)
 {
 	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
-	u32 mdiv, pdiv, sdiv, pll_gnrl, pll_div;
+	u32 mdiv, pdiv, sdiv, pll_div;
 	u64 fvco = parent_rate;
 
-	pll_gnrl = readl_relaxed(pll->base);
 	pll_div = readl_relaxed(pll->base + 4);
 	mdiv = (pll_div & MDIV_MASK) >> MDIV_SHIFT;
 	pdiv = (pll_div & PDIV_MASK) >> PDIV_SHIFT;
@@ -93,11 +92,10 @@ static unsigned long clk_pll1443x_recalc_rate(struct clk_hw *hw,
 						  unsigned long parent_rate)
 {
 	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
-	u32 mdiv, pdiv, sdiv, pll_gnrl, pll_div_ctl0, pll_div_ctl1;
+	u32 mdiv, pdiv, sdiv, pll_div_ctl0, pll_div_ctl1;
 	short int kdiv;
 	u64 fvco = parent_rate;
 
-	pll_gnrl = readl_relaxed(pll->base);
 	pll_div_ctl0 = readl_relaxed(pll->base + 4);
 	pll_div_ctl1 = readl_relaxed(pll->base + 8);
 	mdiv = (pll_div_ctl0 & MDIV_MASK) >> MDIV_SHIFT;

commit f89b9e1be7da8bb0aac667a0206a00975cefe6d3
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Fri Apr 12 14:10:03 2019 +0000

    clk: imx: Fix PLL_1416X not rounding rates
    
    Code which initializes the "clk_init_data.ops" checks pll->rate_table
    before that field is ever assigned to so it always picks
    "clk_pll1416x_min_ops".
    
    This breaks dynamic rate rounding for features such as cpufreq.
    
    Fix by checking pll_clk->rate_table instead, here pll_clk refers to
    the constant initialization data coming from per-soc clk driver.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Fixes: 8646d4dcc7fb ("clk: imx: Add PLLs driver for imx8mm soc")
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index 1acfa3e3cfb4..113d71042199 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -362,7 +362,7 @@ struct clk *imx_clk_pll14xx(const char *name, const char *parent_name,
 
 	switch (pll_clk->type) {
 	case PLL_1416X:
-		if (!pll->rate_table)
+		if (!pll_clk->rate_table)
 			init.ops = &clk_pll1416x_min_ops;
 		else
 			init.ops = &clk_pll1416x_ops;

commit 8646d4dcc7fb2e6e771f8cee500950f3f69aa1ea
Author: Bai Ping <ping.bai@nxp.com>
Date:   Tue Jan 22 09:31:41 2019 +0000

    clk: imx: Add PLLs driver for imx8mm soc
    
    New PLLs are introduced on i.MX8M Mini SOC.
    PLL1416X is Integer PLL, PLL1443X is a Frac PLL.
    
    Signed-off-by: Bai Ping <ping.bai@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
new file mode 100644
index 000000000000..1acfa3e3cfb4
--- /dev/null
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -0,0 +1,392 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2017-2018 NXP.
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+
+#include "clk.h"
+
+#define GNRL_CTL	0x0
+#define DIV_CTL		0x4
+#define LOCK_STATUS	BIT(31)
+#define LOCK_SEL_MASK	BIT(29)
+#define CLKE_MASK	BIT(11)
+#define RST_MASK	BIT(9)
+#define BYPASS_MASK	BIT(4)
+#define MDIV_SHIFT	12
+#define MDIV_MASK	GENMASK(21, 12)
+#define PDIV_SHIFT	4
+#define PDIV_MASK	GENMASK(9, 4)
+#define SDIV_SHIFT	0
+#define SDIV_MASK	GENMASK(2, 0)
+#define KDIV_SHIFT	0
+#define KDIV_MASK	GENMASK(15, 0)
+
+#define LOCK_TIMEOUT_US		10000
+
+struct clk_pll14xx {
+	struct clk_hw			hw;
+	void __iomem			*base;
+	enum imx_pll14xx_type		type;
+	const struct imx_pll14xx_rate_table *rate_table;
+	int rate_count;
+};
+
+#define to_clk_pll14xx(_hw) container_of(_hw, struct clk_pll14xx, hw)
+
+static const struct imx_pll14xx_rate_table *imx_get_pll_settings(
+		struct clk_pll14xx *pll, unsigned long rate)
+{
+	const struct imx_pll14xx_rate_table *rate_table = pll->rate_table;
+	int i;
+
+	for (i = 0; i < pll->rate_count; i++)
+		if (rate == rate_table[i].rate)
+			return &rate_table[i];
+
+	return NULL;
+}
+
+static long clk_pll14xx_round_rate(struct clk_hw *hw, unsigned long rate,
+			unsigned long *prate)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	const struct imx_pll14xx_rate_table *rate_table = pll->rate_table;
+	int i;
+
+	/* Assumming rate_table is in descending order */
+	for (i = 0; i < pll->rate_count; i++)
+		if (rate >= rate_table[i].rate)
+			return rate_table[i].rate;
+
+	/* return minimum supported value */
+	return rate_table[i - 1].rate;
+}
+
+static unsigned long clk_pll1416x_recalc_rate(struct clk_hw *hw,
+						  unsigned long parent_rate)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	u32 mdiv, pdiv, sdiv, pll_gnrl, pll_div;
+	u64 fvco = parent_rate;
+
+	pll_gnrl = readl_relaxed(pll->base);
+	pll_div = readl_relaxed(pll->base + 4);
+	mdiv = (pll_div & MDIV_MASK) >> MDIV_SHIFT;
+	pdiv = (pll_div & PDIV_MASK) >> PDIV_SHIFT;
+	sdiv = (pll_div & SDIV_MASK) >> SDIV_SHIFT;
+
+	fvco *= mdiv;
+	do_div(fvco, pdiv << sdiv);
+
+	return fvco;
+}
+
+static unsigned long clk_pll1443x_recalc_rate(struct clk_hw *hw,
+						  unsigned long parent_rate)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	u32 mdiv, pdiv, sdiv, pll_gnrl, pll_div_ctl0, pll_div_ctl1;
+	short int kdiv;
+	u64 fvco = parent_rate;
+
+	pll_gnrl = readl_relaxed(pll->base);
+	pll_div_ctl0 = readl_relaxed(pll->base + 4);
+	pll_div_ctl1 = readl_relaxed(pll->base + 8);
+	mdiv = (pll_div_ctl0 & MDIV_MASK) >> MDIV_SHIFT;
+	pdiv = (pll_div_ctl0 & PDIV_MASK) >> PDIV_SHIFT;
+	sdiv = (pll_div_ctl0 & SDIV_MASK) >> SDIV_SHIFT;
+	kdiv = pll_div_ctl1 & KDIV_MASK;
+
+	/* fvco = (m * 65536 + k) * Fin / (p * 65536) */
+	fvco *= (mdiv * 65536 + kdiv);
+	pdiv *= 65536;
+
+	do_div(fvco, pdiv << sdiv);
+
+	return fvco;
+}
+
+static inline bool clk_pll1416x_mp_change(const struct imx_pll14xx_rate_table *rate,
+					  u32 pll_div)
+{
+	u32 old_mdiv, old_pdiv;
+
+	old_mdiv = (pll_div >> MDIV_SHIFT) & MDIV_MASK;
+	old_pdiv = (pll_div >> PDIV_SHIFT) & PDIV_MASK;
+
+	return rate->mdiv != old_mdiv || rate->pdiv != old_pdiv;
+}
+
+static inline bool clk_pll1443x_mpk_change(const struct imx_pll14xx_rate_table *rate,
+					  u32 pll_div_ctl0, u32 pll_div_ctl1)
+{
+	u32 old_mdiv, old_pdiv, old_kdiv;
+
+	old_mdiv = (pll_div_ctl0 >> MDIV_SHIFT) & MDIV_MASK;
+	old_pdiv = (pll_div_ctl0 >> PDIV_SHIFT) & PDIV_MASK;
+	old_kdiv = (pll_div_ctl1 >> KDIV_SHIFT) & KDIV_MASK;
+
+	return rate->mdiv != old_mdiv || rate->pdiv != old_pdiv ||
+		rate->kdiv != old_kdiv;
+}
+
+static inline bool clk_pll1443x_mp_change(const struct imx_pll14xx_rate_table *rate,
+					  u32 pll_div_ctl0, u32 pll_div_ctl1)
+{
+	u32 old_mdiv, old_pdiv, old_kdiv;
+
+	old_mdiv = (pll_div_ctl0 >> MDIV_SHIFT) & MDIV_MASK;
+	old_pdiv = (pll_div_ctl0 >> PDIV_SHIFT) & PDIV_MASK;
+	old_kdiv = (pll_div_ctl1 >> KDIV_SHIFT) & KDIV_MASK;
+
+	return rate->mdiv != old_mdiv || rate->pdiv != old_pdiv ||
+		rate->kdiv != old_kdiv;
+}
+
+static int clk_pll14xx_wait_lock(struct clk_pll14xx *pll)
+{
+	u32 val;
+
+	return readl_poll_timeout(pll->base, val, val & LOCK_TIMEOUT_US, 0,
+			LOCK_TIMEOUT_US);
+}
+
+static int clk_pll1416x_set_rate(struct clk_hw *hw, unsigned long drate,
+				 unsigned long prate)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	const struct imx_pll14xx_rate_table *rate;
+	u32 tmp, div_val;
+	int ret;
+
+	rate = imx_get_pll_settings(pll, drate);
+	if (!rate) {
+		pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+		       drate, clk_hw_get_name(hw));
+		return -EINVAL;
+	}
+
+	tmp = readl_relaxed(pll->base + 4);
+
+	if (!clk_pll1416x_mp_change(rate, tmp)) {
+		tmp &= ~(SDIV_MASK) << SDIV_SHIFT;
+		tmp |= rate->sdiv << SDIV_SHIFT;
+		writel_relaxed(tmp, pll->base + 4);
+
+		return 0;
+	}
+
+	/* Bypass clock and set lock to pll output lock */
+	tmp = readl_relaxed(pll->base);
+	tmp |= LOCK_SEL_MASK;
+	writel_relaxed(tmp, pll->base);
+
+	/* Enable RST */
+	tmp &= ~RST_MASK;
+	writel_relaxed(tmp, pll->base);
+
+	div_val = (rate->mdiv << MDIV_SHIFT) | (rate->pdiv << PDIV_SHIFT) |
+		(rate->sdiv << SDIV_SHIFT);
+	writel_relaxed(div_val, pll->base + 0x4);
+
+	/*
+	 * According to SPEC, t3 - t2 need to be greater than
+	 * 1us and 1/FREF, respectively.
+	 * FREF is FIN / Prediv, the prediv is [1, 63], so choose
+	 * 3us.
+	 */
+	udelay(3);
+
+	/* Disable RST */
+	tmp |= RST_MASK;
+	writel_relaxed(tmp, pll->base);
+
+	/* Wait Lock */
+	ret = clk_pll14xx_wait_lock(pll);
+	if (ret)
+		return ret;
+
+	/* Bypass */
+	tmp &= ~BYPASS_MASK;
+	writel_relaxed(tmp, pll->base);
+
+	return 0;
+}
+
+static int clk_pll1443x_set_rate(struct clk_hw *hw, unsigned long drate,
+				 unsigned long prate)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	const struct imx_pll14xx_rate_table *rate;
+	u32 tmp, div_val;
+	int ret;
+
+	rate = imx_get_pll_settings(pll, drate);
+	if (!rate) {
+		pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+			drate, clk_hw_get_name(hw));
+		return -EINVAL;
+	}
+
+	tmp = readl_relaxed(pll->base + 4);
+	div_val = readl_relaxed(pll->base + 8);
+
+	if (!clk_pll1443x_mpk_change(rate, tmp, div_val)) {
+		tmp &= ~(SDIV_MASK) << SDIV_SHIFT;
+		tmp |= rate->sdiv << SDIV_SHIFT;
+		writel_relaxed(tmp, pll->base + 4);
+
+		return 0;
+	}
+
+	/* Enable RST */
+	tmp = readl_relaxed(pll->base);
+	tmp &= ~RST_MASK;
+	writel_relaxed(tmp, pll->base);
+
+	div_val = (rate->mdiv << MDIV_SHIFT) | (rate->pdiv << PDIV_SHIFT) |
+		(rate->sdiv << SDIV_SHIFT);
+	writel_relaxed(div_val, pll->base + 0x4);
+	writel_relaxed(rate->kdiv << KDIV_SHIFT, pll->base + 0x8);
+
+	/*
+	 * According to SPEC, t3 - t2 need to be greater than
+	 * 1us and 1/FREF, respectively.
+	 * FREF is FIN / Prediv, the prediv is [1, 63], so choose
+	 * 3us.
+	 */
+	udelay(3);
+
+	/* Disable RST */
+	tmp |= RST_MASK;
+	writel_relaxed(tmp, pll->base);
+
+	/* Wait Lock*/
+	ret = clk_pll14xx_wait_lock(pll);
+	if (ret)
+		return ret;
+
+	/* Bypass */
+	tmp &= ~BYPASS_MASK;
+	writel_relaxed(tmp, pll->base);
+
+	return 0;
+}
+
+static int clk_pll14xx_prepare(struct clk_hw *hw)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	u32 val;
+
+	/*
+	 * RESETB = 1 from 0, PLL starts its normal
+	 * operation after lock time
+	 */
+	val = readl_relaxed(pll->base + GNRL_CTL);
+	val |= RST_MASK;
+	writel_relaxed(val, pll->base + GNRL_CTL);
+
+	return clk_pll14xx_wait_lock(pll);
+}
+
+static int clk_pll14xx_is_prepared(struct clk_hw *hw)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	u32 val;
+
+	val = readl_relaxed(pll->base + GNRL_CTL);
+
+	return (val & RST_MASK) ? 1 : 0;
+}
+
+static void clk_pll14xx_unprepare(struct clk_hw *hw)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	u32 val;
+
+	/*
+	 * Set RST to 0, power down mode is enabled and
+	 * every digital block is reset
+	 */
+	val = readl_relaxed(pll->base + GNRL_CTL);
+	val &= ~RST_MASK;
+	writel_relaxed(val, pll->base + GNRL_CTL);
+}
+
+static const struct clk_ops clk_pll1416x_ops = {
+	.prepare	= clk_pll14xx_prepare,
+	.unprepare	= clk_pll14xx_unprepare,
+	.is_prepared	= clk_pll14xx_is_prepared,
+	.recalc_rate	= clk_pll1416x_recalc_rate,
+	.round_rate	= clk_pll14xx_round_rate,
+	.set_rate	= clk_pll1416x_set_rate,
+};
+
+static const struct clk_ops clk_pll1416x_min_ops = {
+	.recalc_rate	= clk_pll1416x_recalc_rate,
+};
+
+static const struct clk_ops clk_pll1443x_ops = {
+	.prepare	= clk_pll14xx_prepare,
+	.unprepare	= clk_pll14xx_unprepare,
+	.is_prepared	= clk_pll14xx_is_prepared,
+	.recalc_rate	= clk_pll1443x_recalc_rate,
+	.round_rate	= clk_pll14xx_round_rate,
+	.set_rate	= clk_pll1443x_set_rate,
+};
+
+struct clk *imx_clk_pll14xx(const char *name, const char *parent_name,
+			    void __iomem *base,
+			    const struct imx_pll14xx_clk *pll_clk)
+{
+	struct clk_pll14xx *pll;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = pll_clk->flags;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	switch (pll_clk->type) {
+	case PLL_1416X:
+		if (!pll->rate_table)
+			init.ops = &clk_pll1416x_min_ops;
+		else
+			init.ops = &clk_pll1416x_ops;
+		break;
+	case PLL_1443X:
+		init.ops = &clk_pll1443x_ops;
+		break;
+	default:
+		pr_err("%s: Unknown pll type for pll clk %s\n",
+		       __func__, name);
+	};
+
+	pll->base = base;
+	pll->hw.init = &init;
+	pll->type = pll_clk->type;
+	pll->rate_table = pll_clk->rate_table;
+	pll->rate_count = pll_clk->rate_count;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register pll %s %lu\n",
+			__func__, name, PTR_ERR(clk));
+		kfree(pll);
+	}
+
+	return clk;
+}
