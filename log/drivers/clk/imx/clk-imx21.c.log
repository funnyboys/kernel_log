commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/imx/clk-imx21.c b/drivers/clk/imx/clk-imx21.c
index 6e93284c397b..077b4a7123ce 100644
--- a/drivers/clk/imx/clk-imx21.c
+++ b/drivers/clk/imx/clk-imx21.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  * Copyright 2008 Martin Fuzzey, mfuzzey@gmail.com
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
  */
 
 #include <linux/clk-provider.h>

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/imx/clk-imx21.c b/drivers/clk/imx/clk-imx21.c
index e63188eb08ac..6e93284c397b 100644
--- a/drivers/clk/imx/clk-imx21.c
+++ b/drivers/clk/imx/clk-imx21.c
@@ -11,6 +11,7 @@
 
 #include <linux/clk-provider.h>
 #include <linux/clkdev.h>
+#include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <dt-bindings/clock/imx21-clock.h>

commit 663724f9905818c261f0262b1a64b141dad5e3cd
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: i.MX: Remove clk.h include
    
    Clock provider drivers generally shouldn't include clk.h because
    it's the consumer API. Remove the include here because this is a
    provider driver.
    
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/imx/clk-imx21.c b/drivers/clk/imx/clk-imx21.c
index dba987e3b89f..e63188eb08ac 100644
--- a/drivers/clk/imx/clk-imx21.c
+++ b/drivers/clk/imx/clk-imx21.c
@@ -9,7 +9,6 @@
  * of the License, or (at your option) any later version.
  */
 
-#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/clkdev.h>
 #include <linux/of.h>

commit 0931aff7226abb7e1dab018488e363294385fa66
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri May 15 11:41:39 2015 +0800

    ARM: imx: define an enum for gpt timer device type
    
    Define an enum for gpt timer device type in include/soc/imx/timer.h to
    tell the gpt block differences among SoCs.  Update non-DT users (clock
    drivers) to pass the device type.
    
    As we now have include/soc/imx/timer.h, the declaration of
    mxc_timer_init() is moved into there as the best fit.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/clk/imx/clk-imx21.c b/drivers/clk/imx/clk-imx21.c
index 0ca842cf4ca7..dba987e3b89f 100644
--- a/drivers/clk/imx/clk-imx21.c
+++ b/drivers/clk/imx/clk-imx21.c
@@ -15,6 +15,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <dt-bindings/clock/imx21-clock.h>
+#include <soc/imx/timer.h>
 #include <asm/irq.h>
 
 #include "clk.h"
@@ -156,7 +157,7 @@ int __init mx21_clocks_init(unsigned long lref, unsigned long href)
 	clk_register_clkdev(clk[IMX21_CLK_I2C_GATE], NULL, "imx21-i2c.0");
 	clk_register_clkdev(clk[IMX21_CLK_OWIRE_GATE], NULL, "mxc_w1.0");
 
-	mxc_timer_init(MX21_GPT1_BASE_ADDR, MX21_INT_GPT1);
+	mxc_timer_init(MX21_GPT1_BASE_ADDR, MX21_INT_GPT1, GPT_TYPE_IMX21);
 
 	return 0;
 }

commit 11f68120095d6040abd2eb37bf21bb9450646304
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sun Apr 26 21:54:29 2015 +0800

    ARM: imx: move clock drivers into drivers/clk
    
    After the cleanup on clock drivers, they are now ready to be moved into
    drivers/clk.  Let's move them into drivers/clk/imx folder.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/imx/clk-imx21.c b/drivers/clk/imx/clk-imx21.c
new file mode 100644
index 000000000000..0ca842cf4ca7
--- /dev/null
+++ b/drivers/clk/imx/clk-imx21.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ * Copyright 2008 Martin Fuzzey, mfuzzey@gmail.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <dt-bindings/clock/imx21-clock.h>
+#include <asm/irq.h>
+
+#include "clk.h"
+
+#define MX21_CCM_BASE_ADDR	0x10027000
+#define MX21_GPT1_BASE_ADDR	0x10003000
+#define MX21_INT_GPT1		(NR_IRQS_LEGACY + 26)
+
+static void __iomem *ccm __initdata;
+
+/* Register offsets */
+#define CCM_CSCR	(ccm + 0x00)
+#define CCM_MPCTL0	(ccm + 0x04)
+#define CCM_SPCTL0	(ccm + 0x0c)
+#define CCM_PCDR0	(ccm + 0x18)
+#define CCM_PCDR1	(ccm + 0x1c)
+#define CCM_PCCR0	(ccm + 0x20)
+#define CCM_PCCR1	(ccm + 0x24)
+
+static const char *mpll_osc_sel_clks[] = { "ckih_gate", "ckih_div1p5", };
+static const char *mpll_sel_clks[] = { "fpm_gate", "mpll_osc_sel", };
+static const char *spll_sel_clks[] = { "fpm_gate", "mpll_osc_sel", };
+static const char *ssi_sel_clks[] = { "spll_gate", "mpll_gate", };
+
+static struct clk *clk[IMX21_CLK_MAX];
+static struct clk_onecell_data clk_data;
+
+static void __init _mx21_clocks_init(unsigned long lref, unsigned long href)
+{
+	BUG_ON(!ccm);
+
+	clk[IMX21_CLK_DUMMY] = imx_clk_fixed("dummy", 0);
+	clk[IMX21_CLK_CKIL] = imx_obtain_fixed_clock("ckil", lref);
+	clk[IMX21_CLK_CKIH] = imx_obtain_fixed_clock("ckih", href);
+	clk[IMX21_CLK_FPM] = imx_clk_fixed_factor("fpm", "ckil", 512, 1);
+	clk[IMX21_CLK_CKIH_DIV1P5] = imx_clk_fixed_factor("ckih_div1p5", "ckih_gate", 2, 3);
+
+	clk[IMX21_CLK_MPLL_GATE] = imx_clk_gate("mpll_gate", "mpll", CCM_CSCR, 0);
+	clk[IMX21_CLK_SPLL_GATE] = imx_clk_gate("spll_gate", "spll", CCM_CSCR, 1);
+	clk[IMX21_CLK_FPM_GATE] = imx_clk_gate("fpm_gate", "fpm", CCM_CSCR, 2);
+	clk[IMX21_CLK_CKIH_GATE] = imx_clk_gate_dis("ckih_gate", "ckih", CCM_CSCR, 3);
+	clk[IMX21_CLK_MPLL_OSC_SEL] = imx_clk_mux("mpll_osc_sel", CCM_CSCR, 4, 1, mpll_osc_sel_clks, ARRAY_SIZE(mpll_osc_sel_clks));
+	clk[IMX21_CLK_IPG] = imx_clk_divider("ipg", "hclk", CCM_CSCR, 9, 1);
+	clk[IMX21_CLK_HCLK] = imx_clk_divider("hclk", "fclk", CCM_CSCR, 10, 4);
+	clk[IMX21_CLK_MPLL_SEL] = imx_clk_mux("mpll_sel", CCM_CSCR, 16, 1, mpll_sel_clks, ARRAY_SIZE(mpll_sel_clks));
+	clk[IMX21_CLK_SPLL_SEL] = imx_clk_mux("spll_sel", CCM_CSCR, 17, 1, spll_sel_clks, ARRAY_SIZE(spll_sel_clks));
+	clk[IMX21_CLK_SSI1_SEL] = imx_clk_mux("ssi1_sel", CCM_CSCR, 19, 1, ssi_sel_clks, ARRAY_SIZE(ssi_sel_clks));
+	clk[IMX21_CLK_SSI2_SEL] = imx_clk_mux("ssi2_sel", CCM_CSCR, 20, 1, ssi_sel_clks, ARRAY_SIZE(ssi_sel_clks));
+	clk[IMX21_CLK_USB_DIV] = imx_clk_divider("usb_div", "spll_gate", CCM_CSCR, 26, 3);
+	clk[IMX21_CLK_FCLK] = imx_clk_divider("fclk", "mpll_gate", CCM_CSCR, 29, 3);
+
+	clk[IMX21_CLK_MPLL] = imx_clk_pllv1(IMX_PLLV1_IMX21, "mpll", "mpll_sel", CCM_MPCTL0);
+
+	clk[IMX21_CLK_SPLL] = imx_clk_pllv1(IMX_PLLV1_IMX21, "spll", "spll_sel", CCM_SPCTL0);
+
+	clk[IMX21_CLK_NFC_DIV] = imx_clk_divider("nfc_div", "fclk", CCM_PCDR0, 12, 4);
+	clk[IMX21_CLK_SSI1_DIV] = imx_clk_divider("ssi1_div", "ssi1_sel", CCM_PCDR0, 16, 6);
+	clk[IMX21_CLK_SSI2_DIV] = imx_clk_divider("ssi2_div", "ssi2_sel", CCM_PCDR0, 26, 6);
+
+	clk[IMX21_CLK_PER1] = imx_clk_divider("per1", "mpll_gate", CCM_PCDR1, 0, 6);
+	clk[IMX21_CLK_PER2] = imx_clk_divider("per2", "mpll_gate", CCM_PCDR1, 8, 6);
+	clk[IMX21_CLK_PER3] = imx_clk_divider("per3", "mpll_gate", CCM_PCDR1, 16, 6);
+	clk[IMX21_CLK_PER4] = imx_clk_divider("per4", "mpll_gate", CCM_PCDR1, 24, 6);
+
+	clk[IMX21_CLK_UART1_IPG_GATE] = imx_clk_gate("uart1_ipg_gate", "ipg", CCM_PCCR0, 0);
+	clk[IMX21_CLK_UART2_IPG_GATE] = imx_clk_gate("uart2_ipg_gate", "ipg", CCM_PCCR0, 1);
+	clk[IMX21_CLK_UART3_IPG_GATE] = imx_clk_gate("uart3_ipg_gate", "ipg", CCM_PCCR0, 2);
+	clk[IMX21_CLK_UART4_IPG_GATE] = imx_clk_gate("uart4_ipg_gate", "ipg", CCM_PCCR0, 3);
+	clk[IMX21_CLK_CSPI1_IPG_GATE] = imx_clk_gate("cspi1_ipg_gate", "ipg", CCM_PCCR0, 4);
+	clk[IMX21_CLK_CSPI2_IPG_GATE] = imx_clk_gate("cspi2_ipg_gate", "ipg", CCM_PCCR0, 5);
+	clk[IMX21_CLK_SSI1_GATE] = imx_clk_gate("ssi1_gate", "ipg", CCM_PCCR0, 6);
+	clk[IMX21_CLK_SSI2_GATE] = imx_clk_gate("ssi2_gate", "ipg", CCM_PCCR0, 7);
+	clk[IMX21_CLK_SDHC1_IPG_GATE] = imx_clk_gate("sdhc1_ipg_gate", "ipg", CCM_PCCR0, 9);
+	clk[IMX21_CLK_SDHC2_IPG_GATE] = imx_clk_gate("sdhc2_ipg_gate", "ipg", CCM_PCCR0, 10);
+	clk[IMX21_CLK_GPIO_GATE] = imx_clk_gate("gpio_gate", "ipg", CCM_PCCR0, 11);
+	clk[IMX21_CLK_I2C_GATE] = imx_clk_gate("i2c_gate", "ipg", CCM_PCCR0, 12);
+	clk[IMX21_CLK_DMA_GATE] = imx_clk_gate("dma_gate", "ipg", CCM_PCCR0, 13);
+	clk[IMX21_CLK_USB_GATE] = imx_clk_gate("usb_gate", "usb_div", CCM_PCCR0, 14);
+	clk[IMX21_CLK_EMMA_GATE] = imx_clk_gate("emma_gate", "ipg", CCM_PCCR0, 15);
+	clk[IMX21_CLK_SSI2_BAUD_GATE] = imx_clk_gate("ssi2_baud_gate", "ipg", CCM_PCCR0, 16);
+	clk[IMX21_CLK_SSI1_BAUD_GATE] = imx_clk_gate("ssi1_baud_gate", "ipg", CCM_PCCR0, 17);
+	clk[IMX21_CLK_LCDC_IPG_GATE] = imx_clk_gate("lcdc_ipg_gate", "ipg", CCM_PCCR0, 18);
+	clk[IMX21_CLK_NFC_GATE] = imx_clk_gate("nfc_gate", "nfc_div", CCM_PCCR0, 19);
+	clk[IMX21_CLK_SLCDC_HCLK_GATE] = imx_clk_gate("slcdc_hclk_gate", "hclk", CCM_PCCR0, 21);
+	clk[IMX21_CLK_PER4_GATE] = imx_clk_gate("per4_gate", "per4", CCM_PCCR0, 22);
+	clk[IMX21_CLK_BMI_GATE] = imx_clk_gate("bmi_gate", "hclk", CCM_PCCR0, 23);
+	clk[IMX21_CLK_USB_HCLK_GATE] = imx_clk_gate("usb_hclk_gate", "hclk", CCM_PCCR0, 24);
+	clk[IMX21_CLK_SLCDC_GATE] = imx_clk_gate("slcdc_gate", "hclk", CCM_PCCR0, 25);
+	clk[IMX21_CLK_LCDC_HCLK_GATE] = imx_clk_gate("lcdc_hclk_gate", "hclk", CCM_PCCR0, 26);
+	clk[IMX21_CLK_EMMA_HCLK_GATE] = imx_clk_gate("emma_hclk_gate", "hclk", CCM_PCCR0, 27);
+	clk[IMX21_CLK_BROM_GATE] = imx_clk_gate("brom_gate", "hclk", CCM_PCCR0, 28);
+	clk[IMX21_CLK_DMA_HCLK_GATE] = imx_clk_gate("dma_hclk_gate", "hclk", CCM_PCCR0, 30);
+	clk[IMX21_CLK_CSI_HCLK_GATE] = imx_clk_gate("csi_hclk_gate", "hclk", CCM_PCCR0, 31);
+
+	clk[IMX21_CLK_CSPI3_IPG_GATE] = imx_clk_gate("cspi3_ipg_gate", "ipg", CCM_PCCR1, 23);
+	clk[IMX21_CLK_WDOG_GATE] = imx_clk_gate("wdog_gate", "ipg", CCM_PCCR1, 24);
+	clk[IMX21_CLK_GPT1_IPG_GATE] = imx_clk_gate("gpt1_ipg_gate", "ipg", CCM_PCCR1, 25);
+	clk[IMX21_CLK_GPT2_IPG_GATE] = imx_clk_gate("gpt2_ipg_gate", "ipg", CCM_PCCR1, 26);
+	clk[IMX21_CLK_GPT3_IPG_GATE] = imx_clk_gate("gpt3_ipg_gate", "ipg", CCM_PCCR1, 27);
+	clk[IMX21_CLK_PWM_IPG_GATE] = imx_clk_gate("pwm_ipg_gate", "ipg", CCM_PCCR1, 28);
+	clk[IMX21_CLK_RTC_GATE] = imx_clk_gate("rtc_gate", "ipg", CCM_PCCR1, 29);
+	clk[IMX21_CLK_KPP_GATE] = imx_clk_gate("kpp_gate", "ipg", CCM_PCCR1, 30);
+	clk[IMX21_CLK_OWIRE_GATE] = imx_clk_gate("owire_gate", "ipg", CCM_PCCR1, 31);
+
+	imx_check_clocks(clk, ARRAY_SIZE(clk));
+}
+
+int __init mx21_clocks_init(unsigned long lref, unsigned long href)
+{
+	ccm = ioremap(MX21_CCM_BASE_ADDR, SZ_2K);
+
+	_mx21_clocks_init(lref, href);
+
+	clk_register_clkdev(clk[IMX21_CLK_PER1], "per", "imx21-uart.0");
+	clk_register_clkdev(clk[IMX21_CLK_UART1_IPG_GATE], "ipg", "imx21-uart.0");
+	clk_register_clkdev(clk[IMX21_CLK_PER1], "per", "imx21-uart.1");
+	clk_register_clkdev(clk[IMX21_CLK_UART2_IPG_GATE], "ipg", "imx21-uart.1");
+	clk_register_clkdev(clk[IMX21_CLK_PER1], "per", "imx21-uart.2");
+	clk_register_clkdev(clk[IMX21_CLK_UART3_IPG_GATE], "ipg", "imx21-uart.2");
+	clk_register_clkdev(clk[IMX21_CLK_PER1], "per", "imx21-uart.3");
+	clk_register_clkdev(clk[IMX21_CLK_UART4_IPG_GATE], "ipg", "imx21-uart.3");
+	clk_register_clkdev(clk[IMX21_CLK_GPT1_IPG_GATE], "ipg", "imx-gpt.0");
+	clk_register_clkdev(clk[IMX21_CLK_PER1], "per", "imx-gpt.0");
+	clk_register_clkdev(clk[IMX21_CLK_PER2], "per", "imx21-cspi.0");
+	clk_register_clkdev(clk[IMX21_CLK_CSPI1_IPG_GATE], "ipg", "imx21-cspi.0");
+	clk_register_clkdev(clk[IMX21_CLK_PER2], "per", "imx21-cspi.1");
+	clk_register_clkdev(clk[IMX21_CLK_CSPI2_IPG_GATE], "ipg", "imx21-cspi.1");
+	clk_register_clkdev(clk[IMX21_CLK_PER2], "per", "imx21-cspi.2");
+	clk_register_clkdev(clk[IMX21_CLK_CSPI3_IPG_GATE], "ipg", "imx21-cspi.2");
+	clk_register_clkdev(clk[IMX21_CLK_PER3], "per", "imx21-fb.0");
+	clk_register_clkdev(clk[IMX21_CLK_LCDC_IPG_GATE], "ipg", "imx21-fb.0");
+	clk_register_clkdev(clk[IMX21_CLK_LCDC_HCLK_GATE], "ahb", "imx21-fb.0");
+	clk_register_clkdev(clk[IMX21_CLK_USB_GATE], "per", "imx21-hcd.0");
+	clk_register_clkdev(clk[IMX21_CLK_USB_HCLK_GATE], "ahb", "imx21-hcd.0");
+	clk_register_clkdev(clk[IMX21_CLK_NFC_GATE], NULL, "imx21-nand.0");
+	clk_register_clkdev(clk[IMX21_CLK_DMA_HCLK_GATE], "ahb", "imx21-dma");
+	clk_register_clkdev(clk[IMX21_CLK_DMA_GATE], "ipg", "imx21-dma");
+	clk_register_clkdev(clk[IMX21_CLK_WDOG_GATE], NULL, "imx2-wdt.0");
+	clk_register_clkdev(clk[IMX21_CLK_I2C_GATE], NULL, "imx21-i2c.0");
+	clk_register_clkdev(clk[IMX21_CLK_OWIRE_GATE], NULL, "mxc_w1.0");
+
+	mxc_timer_init(MX21_GPT1_BASE_ADDR, MX21_INT_GPT1);
+
+	return 0;
+}
+
+static void __init mx21_clocks_init_dt(struct device_node *np)
+{
+	ccm = of_iomap(np, 0);
+
+	_mx21_clocks_init(32768, 26000000);
+
+	clk_data.clks = clk;
+	clk_data.clk_num = ARRAY_SIZE(clk);
+	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
+}
+CLK_OF_DECLARE(imx27_ccm, "fsl,imx21-ccm", mx21_clocks_init_dt);
