commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 4161a6f25741..2a74a713ad59 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Clock implementation for VIA/Wondermedia SoC's
  * Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #include <linux/io.h>

commit 759fa9613245b99b21c25b0aecf9919fb0e96c31
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Jun 1 16:15:32 2016 -0700

    clk: vt8500: Migrate to clk_hw based registration APIs
    
    Now that we have clk_hw based provider APIs to register clks, we
    can get rid of struct clk pointers while registering clks in
    these drivers, allowing us to move closer to a clear split of
    consumer and provider clk APIs.
    
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 37368a399ff9..4161a6f25741 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -232,7 +232,7 @@ static const struct clk_ops vt8500_gated_divisor_clk_ops = {
 static __init void vtwm_device_clk_init(struct device_node *node)
 {
 	u32 en_reg, div_reg;
-	struct clk *clk;
+	struct clk_hw *hw;
 	struct clk_device *dev_clk;
 	const char *clk_name = node->name;
 	const char *parent_name;
@@ -301,13 +301,14 @@ static __init void vtwm_device_clk_init(struct device_node *node)
 
 	dev_clk->hw.init = &init;
 
-	clk = clk_register(NULL, &dev_clk->hw);
-	if (WARN_ON(IS_ERR(clk))) {
+	hw = &dev_clk->hw;
+	rc = clk_hw_register(NULL, hw);
+	if (WARN_ON(rc)) {
 		kfree(dev_clk);
 		return;
 	}
-	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
-	clk_register_clkdev(clk, clk_name, NULL);
+	rc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw);
+	clk_hw_register_clkdev(hw, clk_name, NULL);
 }
 CLK_OF_DECLARE(vt8500_device, "via,vt8500-device-clock", vtwm_device_clk_init);
 
@@ -681,7 +682,7 @@ static const struct clk_ops vtwm_pll_ops = {
 static __init void vtwm_pll_clk_init(struct device_node *node, int pll_type)
 {
 	u32 reg;
-	struct clk *clk;
+	struct clk_hw *hw;
 	struct clk_pll *pll_clk;
 	const char *clk_name = node->name;
 	const char *parent_name;
@@ -714,13 +715,14 @@ static __init void vtwm_pll_clk_init(struct device_node *node, int pll_type)
 
 	pll_clk->hw.init = &init;
 
-	clk = clk_register(NULL, &pll_clk->hw);
-	if (WARN_ON(IS_ERR(clk))) {
+	hw = &pll_clk->hw;
+	rc = clk_hw_register(NULL, &pll_clk->hw);
+	if (WARN_ON(rc)) {
 		kfree(pll_clk);
 		return;
 	}
-	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
-	clk_register_clkdev(clk, clk_name, NULL);
+	rc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw);
+	clk_hw_register_clkdev(hw, clk_name, NULL);
 }
 
 

commit c03d795beee49ed6e96cf3832c083bf2ecaf1408
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Wed Jun 8 00:56:10 2016 +0300

    clk: vt8500: rework wm8650_find_pll_bits()
    
    PLL clock on WM8650 is calculated in the following way:
    
    M * parent [O1] => / P [O2] => / D [O3]
    
    Where O2 is 600MHz >= (M * parent) / P >= 300MHz.
    
    Current algorithm does not met this requirement, so that the
    function may return rates which are not supported by the hardware.
    
    This patch fixes the algorithm and simplifies the code, reducing
    the calculation time by ~10000 times (according to usermode app) by
    removing the nested loops.
    
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index d5a3453970d0..37368a399ff9 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -383,47 +383,50 @@ static int vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	return 0;
 }
 
-static int wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
-				u32 *multiplier, u32 *divisor1, u32 *divisor2)
+/*
+ * M * parent [O1] => / P [O2] => / D [O3]
+ * Where O1 is 900MHz...3GHz;
+ * O2 is 600MHz >= (M * parent) / P >= 300MHz;
+ * M is 36...120 [25MHz parent]; D is 1 or 2 or 4 or 8.
+ * Possible ranges (O3):
+ * D = 8: 37,5MHz...75MHz
+ * D = 4: 75MHz...150MHz
+ * D = 2: 150MHz...300MHz
+ * D = 1: 300MHz...600MHz
+ */
+static int wm8650_find_pll_bits(unsigned long rate,
+	unsigned long parent_rate, u32 *multiplier, u32 *divisor1,
+	u32 *divisor2)
 {
-	u32 mul, div1;
-	int div2;
-	unsigned long tclk, rate_err, best_err;
-
-	best_err = (unsigned long)-1;
+	unsigned long O1, min_err, rate_err;
 
-	/* Find the closest match (lower or equal to requested) */
-	for (div1 = 5; div1 >= 3; div1--)
-		for (div2 = 3; div2 >= 0; div2--)
-			for (mul = 3; mul <= 1023; mul++) {
-				tclk = parent_rate * mul / (div1 * (1 << div2));
-				if (tclk > rate)
-					continue;
-				/* error will always be +ve */
-				rate_err = rate - tclk;
-				if (rate_err == 0) {
-					*multiplier = mul;
-					*divisor1 = div1;
-					*divisor2 = div2;
-					return 0;
-				}
+	if (!parent_rate || (rate < 37500000) || (rate > 600000000))
+		return -EINVAL;
 
-				if (rate_err < best_err) {
-					best_err = rate_err;
-					*multiplier = mul;
-					*divisor1 = div1;
-					*divisor2 = div2;
-				}
-			}
+	*divisor2 = rate <= 75000000 ? 3 : rate <= 150000000 ? 2 :
+					   rate <= 300000000 ? 1 : 0;
+	/*
+	 * Divisor P cannot be calculated. Test all divisors and find where M
+	 * will be as close as possible to the requested rate.
+	 */
+	min_err = ULONG_MAX;
+	for (*divisor1 = 5; *divisor1 >= 3; (*divisor1)--) {
+		O1 = rate * *divisor1 * (1 << (*divisor2));
+		rate_err = O1 % parent_rate;
+		if (rate_err < min_err) {
+			*multiplier = O1 / parent_rate;
+			if (rate_err == 0)
+				return 0;
+
+			min_err = rate_err;
+		}
+	}
 
-	if (best_err == (unsigned long)-1) {
-		pr_warn("%s: impossible rate %lu\n", __func__, rate);
+	if ((*multiplier < 3) || (*multiplier > 1023))
 		return -EINVAL;
-	}
 
-	/* if we got here, it wasn't an exact match */
-	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
-							rate - best_err);
+	pr_warn("%s: rate error is %lu\n", __func__, min_err);
+
 	return 0;
 }
 

commit 27a0becc26ba7f84babda8c66170827af1fa308d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 8 00:56:09 2016 +0300

    clk: vt8500: fix gcc-4.9 warnings
    
    This fixes some false positive warnings we get with older compiler
    versions:
    
    clk-vt8500.c: In function ‘wm8650_find_pll_bits’:
    clk-vt8500.c:430:12: ‘best_div2’ may be used uninitialized in this function
    clk-vt8500.c:429:12: ‘best_div1’ may be used uninitialized in this function
    clk-vt8500.c:428:14: ‘best_mul’ may be used uninitialized in this function
    clk-vt8500.c: In function ‘wm8750_find_pll_bits’:
    clk-vt8500.c:509:12: ‘best_div2’ may be used uninitialized in this function
    clk-vt8500.c:508:12: ‘best_div1’ may be used uninitialized in this function
    clk-vt8500.c:507:14: ‘best_mul’ may be used uninitialized in this function
    clk-vt8500.c: In function ‘wm8850_find_pll_bits’:
    clk-vt8500.c:560:12: ‘best_div2’ may be used uninitialized in this function
    clk-vt8500.c:559:12: ‘best_div1’ may be used uninitialized in this function
    clk-vt8500.c:558:14: ‘best_mul’ may be used uninitialized in this function
    
    As the local variables are only use for temporaries, we can just
    as well assign the final values directly, which also makes the
    code slightly shorter.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index b0f76a84f1e9..d5a3453970d0 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -388,7 +388,6 @@ static int wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 {
 	u32 mul, div1;
 	int div2;
-	u32 best_mul, best_div1, best_div2;
 	unsigned long tclk, rate_err, best_err;
 
 	best_err = (unsigned long)-1;
@@ -411,9 +410,9 @@ static int wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 
 				if (rate_err < best_err) {
 					best_err = rate_err;
-					best_mul = mul;
-					best_div1 = div1;
-					best_div2 = div2;
+					*multiplier = mul;
+					*divisor1 = div1;
+					*divisor2 = div2;
 				}
 			}
 
@@ -425,10 +424,6 @@ static int wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	/* if we got here, it wasn't an exact match */
 	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
 							rate - best_err);
-	*multiplier = best_mul;
-	*divisor1 = best_div1;
-	*divisor2 = best_div2;
-
 	return 0;
 }
 
@@ -464,7 +459,6 @@ static int wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 {
 	u32 mul;
 	int div1, div2;
-	u32 best_mul, best_div1, best_div2;
 	unsigned long tclk, rate_err, best_err;
 
 	best_err = (unsigned long)-1;
@@ -488,9 +482,9 @@ static int wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 
 				if (rate_err < best_err) {
 					best_err = rate_err;
-					best_mul = mul;
-					best_div1 = div1;
-					best_div2 = div2;
+					*multiplier = mul;
+					*divisor1 = div1;
+					*divisor2 = div2;
 				}
 			}
 
@@ -503,10 +497,7 @@ static int wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
 							rate - best_err);
 
-	*filter = wm8750_get_filter(parent_rate, best_div1);
-	*multiplier = best_mul;
-	*divisor1 = best_div1;
-	*divisor2 = best_div2;
+	*filter = wm8750_get_filter(parent_rate, *divisor1);
 
 	return 0;
 }
@@ -516,7 +507,6 @@ static int wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 {
 	u32 mul;
 	int div1, div2;
-	u32 best_mul, best_div1, best_div2;
 	unsigned long tclk, rate_err, best_err;
 
 	best_err = (unsigned long)-1;
@@ -540,9 +530,9 @@ static int wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 
 				if (rate_err < best_err) {
 					best_err = rate_err;
-					best_mul = mul;
-					best_div1 = div1;
-					best_div2 = div2;
+					*multiplier = mul;
+					*divisor1 = div1;
+					*divisor2 = div2;
 				}
 			}
 
@@ -555,10 +545,6 @@ static int wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
 							rate - best_err);
 
-	*multiplier = best_mul;
-	*divisor1 = best_div1;
-	*divisor2 = best_div2;
-
 	return 0;
 }
 

commit 7001ec560a82d1cc2ba5c0c9ac1f7fcca820b27e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Feb 1 11:19:10 2016 +0100

    clk: vt8500: don't return possibly uninitialized data
    
    The clk-vt8500.c driver would previously enter an endless loop
    when invalid settings got requested, this was now fixed. However,
    the driver will now return uninitialized data for a subset of those
    cases instead, as the gcc correctly warns:
    
    clk/clk-vt8500.c: In function 'wm8650_find_pll_bits':
    clk/clk-vt8500.c:423:12: error: 'best_div2' may be used uninitialized in this function [-Werror=maybe-uninitialized]
      *divisor2 = best_div2;
                ^
    clk/clk-vt8500.c:422:12: error: 'best_div1' may be used uninitialized in this function [-Werror=maybe-uninitialized]
      *divisor1 = best_div1;
                ^
    clk/clk-vt8500.c:421:14: error: 'best_mul' may be used uninitialized in this function [-Werror=maybe-uninitialized]
      *multiplier = best_mul;
    
    This reworks the error handling in the driver so we now return
    -EINVAL from clk_round_rate() and clk_set_rate() when we get
    impossible inputs.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 090341b0a95d ("clk: vt8500: fix sign of possible PLL values")
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 98c4492d2c0d..b0f76a84f1e9 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -355,7 +355,7 @@ CLK_OF_DECLARE(vt8500_device, "via,vt8500-device-clock", vtwm_device_clk_init);
 #define WM8850_BITS_TO_VAL(m, d1, d2)					\
 		((((m / 2) - 1) << 16) | ((d1 - 1) << 8) | d2)
 
-static void vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+static int vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *multiplier, u32 *prediv)
 {
 	unsigned long tclk;
@@ -365,7 +365,7 @@ static void vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 		pr_err("%s: requested rate out of range\n", __func__);
 		*multiplier = 0;
 		*prediv = 1;
-		return;
+		return -EINVAL;
 	}
 	if (rate <= parent_rate * 31)
 		/* use the prediv to double the resolution */
@@ -379,9 +379,11 @@ static void vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	if (tclk != rate)
 		pr_warn("%s: requested rate %lu, found rate %lu\n", __func__,
 								rate, tclk);
+
+	return 0;
 }
 
-static void wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+static int wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *multiplier, u32 *divisor1, u32 *divisor2)
 {
 	u32 mul, div1;
@@ -404,7 +406,7 @@ static void wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 					*multiplier = mul;
 					*divisor1 = div1;
 					*divisor2 = div2;
-					return;
+					return 0;
 				}
 
 				if (rate_err < best_err) {
@@ -415,12 +417,19 @@ static void wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				}
 			}
 
+	if (best_err == (unsigned long)-1) {
+		pr_warn("%s: impossible rate %lu\n", __func__, rate);
+		return -EINVAL;
+	}
+
 	/* if we got here, it wasn't an exact match */
 	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
 							rate - best_err);
 	*multiplier = best_mul;
 	*divisor1 = best_div1;
 	*divisor2 = best_div2;
+
+	return 0;
 }
 
 static u32 wm8750_get_filter(u32 parent_rate, u32 divisor1)
@@ -450,7 +459,7 @@ static u32 wm8750_get_filter(u32 parent_rate, u32 divisor1)
 	return 0;
 }
 
-static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+static int wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *filter, u32 *multiplier, u32 *divisor1, u32 *divisor2)
 {
 	u32 mul;
@@ -474,7 +483,7 @@ static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 					*multiplier = mul;
 					*divisor1 = div1;
 					*divisor2 = div2;
-					return;
+					return 0;
 				}
 
 				if (rate_err < best_err) {
@@ -485,6 +494,11 @@ static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				}
 			}
 
+	if (best_err == (unsigned long)-1) {
+		pr_warn("%s: impossible rate %lu\n", __func__, rate);
+		return -EINVAL;
+	}
+
 	/* if we got here, it wasn't an exact match */
 	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
 							rate - best_err);
@@ -493,9 +507,11 @@ static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	*multiplier = best_mul;
 	*divisor1 = best_div1;
 	*divisor2 = best_div2;
+
+	return 0;
 }
 
-static void wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+static int wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *multiplier, u32 *divisor1, u32 *divisor2)
 {
 	u32 mul;
@@ -519,7 +535,7 @@ static void wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 					*multiplier = mul;
 					*divisor1 = div1;
 					*divisor2 = div2;
-					return;
+					return 0;
 				}
 
 				if (rate_err < best_err) {
@@ -530,6 +546,11 @@ static void wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				}
 			}
 
+	if (best_err == (unsigned long)-1) {
+		pr_warn("%s: impossible rate %lu\n", __func__, rate);
+		return -EINVAL;
+	}
+
 	/* if we got here, it wasn't an exact match */
 	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
 							rate - best_err);
@@ -537,6 +558,8 @@ static void wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	*multiplier = best_mul;
 	*divisor1 = best_div1;
 	*divisor2 = best_div2;
+
+	return 0;
 }
 
 static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -546,31 +569,39 @@ static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 	u32 filter, mul, div1, div2;
 	u32 pll_val;
 	unsigned long flags = 0;
+	int ret;
 
 	/* sanity check */
 
 	switch (pll->type) {
 	case PLL_TYPE_VT8500:
-		vt8500_find_pll_bits(rate, parent_rate, &mul, &div1);
-		pll_val = VT8500_BITS_TO_VAL(mul, div1);
+		ret = vt8500_find_pll_bits(rate, parent_rate, &mul, &div1);
+		if (!ret)
+			pll_val = VT8500_BITS_TO_VAL(mul, div1);
 		break;
 	case PLL_TYPE_WM8650:
-		wm8650_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);
-		pll_val = WM8650_BITS_TO_VAL(mul, div1, div2);
+		ret = wm8650_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);
+		if (!ret)
+			pll_val = WM8650_BITS_TO_VAL(mul, div1, div2);
 		break;
 	case PLL_TYPE_WM8750:
-		wm8750_find_pll_bits(rate, parent_rate, &filter, &mul, &div1, &div2);
-		pll_val = WM8750_BITS_TO_VAL(filter, mul, div1, div2);
+		ret = wm8750_find_pll_bits(rate, parent_rate, &filter, &mul, &div1, &div2);
+		if (!ret)
+			pll_val = WM8750_BITS_TO_VAL(filter, mul, div1, div2);
 		break;
 	case PLL_TYPE_WM8850:
-		wm8850_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);
-		pll_val = WM8850_BITS_TO_VAL(mul, div1, div2);
+		ret = wm8850_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);
+		if (!ret)
+			pll_val = WM8850_BITS_TO_VAL(mul, div1, div2);
 		break;
 	default:
 		pr_err("%s: invalid pll type\n", __func__);
-		return 0;
+		ret = -EINVAL;
 	}
 
+	if (ret)
+		return ret;
+
 	spin_lock_irqsave(pll->lock, flags);
 
 	vt8500_pmc_wait_busy();
@@ -588,28 +619,36 @@ static long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,
 	struct clk_pll *pll = to_clk_pll(hw);
 	u32 filter, mul, div1, div2;
 	long round_rate;
+	int ret;
 
 	switch (pll->type) {
 	case PLL_TYPE_VT8500:
-		vt8500_find_pll_bits(rate, *prate, &mul, &div1);
-		round_rate = VT8500_BITS_TO_FREQ(*prate, mul, div1);
+		ret = vt8500_find_pll_bits(rate, *prate, &mul, &div1);
+		if (!ret)
+			round_rate = VT8500_BITS_TO_FREQ(*prate, mul, div1);
 		break;
 	case PLL_TYPE_WM8650:
-		wm8650_find_pll_bits(rate, *prate, &mul, &div1, &div2);
-		round_rate = WM8650_BITS_TO_FREQ(*prate, mul, div1, div2);
+		ret = wm8650_find_pll_bits(rate, *prate, &mul, &div1, &div2);
+		if (!ret)
+			round_rate = WM8650_BITS_TO_FREQ(*prate, mul, div1, div2);
 		break;
 	case PLL_TYPE_WM8750:
-		wm8750_find_pll_bits(rate, *prate, &filter, &mul, &div1, &div2);
-		round_rate = WM8750_BITS_TO_FREQ(*prate, mul, div1, div2);
+		ret = wm8750_find_pll_bits(rate, *prate, &filter, &mul, &div1, &div2);
+		if (!ret)
+			round_rate = WM8750_BITS_TO_FREQ(*prate, mul, div1, div2);
 		break;
 	case PLL_TYPE_WM8850:
-		wm8850_find_pll_bits(rate, *prate, &mul, &div1, &div2);
-		round_rate = WM8850_BITS_TO_FREQ(*prate, mul, div1, div2);
+		ret = wm8850_find_pll_bits(rate, *prate, &mul, &div1, &div2);
+		if (!ret)
+			round_rate = WM8850_BITS_TO_FREQ(*prate, mul, div1, div2);
 		break;
 	default:
-		round_rate = 0;
+		ret = -EINVAL;
 	}
 
+	if (ret)
+		return ret;
+
 	return round_rate;
 }
 

commit 090341b0a95d1f6d762915a75c13b393366f4ab3
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Fri Oct 2 06:49:53 2015 +0200

    clk: vt8500: fix sign of possible PLL values
    
    With unsigned values underflow in loops can occur resulting in
    theoretically infinite loops.
    
    The problem has been detected using proposed semantic patch
    scripts/coccinelle/tests/unsigned_lesser_than_zero.cocci [1].
    
    [1]: http://permalink.gmane.org/gmane.linux.kernel/2038576
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 37e928846ec5..98c4492d2c0d 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -384,7 +384,8 @@ static void vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 static void wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *multiplier, u32 *divisor1, u32 *divisor2)
 {
-	u32 mul, div1, div2;
+	u32 mul, div1;
+	int div2;
 	u32 best_mul, best_div1, best_div2;
 	unsigned long tclk, rate_err, best_err;
 
@@ -452,7 +453,8 @@ static u32 wm8750_get_filter(u32 parent_rate, u32 divisor1)
 static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *filter, u32 *multiplier, u32 *divisor1, u32 *divisor2)
 {
-	u32 mul, div1, div2;
+	u32 mul;
+	int div1, div2;
 	u32 best_mul, best_div1, best_div2;
 	unsigned long tclk, rate_err, best_err;
 
@@ -496,7 +498,8 @@ static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 static void wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *multiplier, u32 *divisor1, u32 *divisor2)
 {
-	u32 mul, div1, div2;
+	u32 mul;
+	int div1, div2;
 	u32 best_mul, best_div1, best_div2;
 	unsigned long tclk, rate_err, best_err;
 

commit 7acc3bca987adfedd62f5e32dfbbf93f0928ba60
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Oct 8 16:47:46 2013 +0530

    clk: vt8500: Staticize vtwm_pll_ops
    
    'vtwm_pll_ops' is local to this file. Make it static.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 7fd5c5e9e25d..37e928846ec5 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -641,7 +641,7 @@ static unsigned long vtwm_pll_recalc_rate(struct clk_hw *hw,
 	return pll_freq;
 }
 
-const struct clk_ops vtwm_pll_ops = {
+static const struct clk_ops vtwm_pll_ops = {
 	.round_rate = vtwm_pll_round_rate,
 	.set_rate = vtwm_pll_set_rate,
 	.recalc_rate = vtwm_pll_recalc_rate,

commit f44089a7f41c88775428f09e90df8fb2b890058a
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Wed Sep 4 14:09:39 2013 +0200

    ARM: vt8500: prepare for arch-wide .init_time callback
    
    Current vt8500 board init calls of_clk_init() from vtwm_clk_init. To allow
    consolidation of DT driven .time_init, move of_clock_init() to a temporary
    .time_init callback that will be removed when arch-wide callback is available.
    With previous pmc_base parsing helper for vt8500 clock providers, we can also
    safely remove the call to vtwm_clk_init() and get rid of some includes.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 39fe72aab1e5..7fd5c5e9e25d 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -718,13 +718,3 @@ static void __init wm8850_pll_init(struct device_node *node)
 	vtwm_pll_clk_init(node, PLL_TYPE_WM8850);
 }
 CLK_OF_DECLARE(wm8850_pll, "wm,wm8850-pll-clock", wm8850_pll_init);
-
-void __init vtwm_clk_init(void __iomem *base)
-{
-	if (!base)
-		return;
-
-	pmc_base = base;
-
-	of_clk_init(NULL);
-}

commit f9e4a18de7398bc615f9d45250bdaf31eafc5af6
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Wed Sep 4 13:58:11 2013 +0200

    clk: vt8500: parse pmc_base from clock driver
    
    Currently, clock providers for vt8500 depend on machine_init providing
    pmc_base address before calling of_clk_init. With upcoming arch-wide
    .time_init calling of_clk_init, we should make clock providers independent
    of mach code. This adds a pmc_base parsing helper to current clock provider
    that gets called if there is no pmc_base set, yet.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 82306f5fb9c2..39fe72aab1e5 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -15,11 +15,14 @@
 
 #include <linux/io.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/slab.h>
 #include <linux/bitops.h>
 #include <linux/clkdev.h>
 #include <linux/clk-provider.h>
 
+#define LEGACY_PMC_BASE		0xD8130000
+
 /* All clocks share the same lock as none can be changed concurrently */
 static DEFINE_SPINLOCK(_lock);
 
@@ -53,6 +56,21 @@ struct clk_pll {
 
 static void __iomem *pmc_base;
 
+static __init void vtwm_set_pmc_base(void)
+{
+	struct device_node *np =
+		of_find_compatible_node(NULL, NULL, "via,vt8500-pmc");
+
+	if (np)
+		pmc_base = of_iomap(np, 0);
+	else
+		pmc_base = ioremap(LEGACY_PMC_BASE, 0x1000);
+	of_node_put(np);
+
+	if (!pmc_base)
+		pr_err("%s:of_iomap(pmc) failed\n", __func__);
+}
+
 #define to_clk_device(_hw) container_of(_hw, struct clk_device, hw)
 
 #define VT8500_PMC_BUSY_MASK		0x18
@@ -222,6 +240,9 @@ static __init void vtwm_device_clk_init(struct device_node *node)
 	int rc;
 	int clk_init_flags = 0;
 
+	if (!pmc_base)
+		vtwm_set_pmc_base();
+
 	dev_clk = kzalloc(sizeof(*dev_clk), GFP_KERNEL);
 	if (WARN_ON(!dev_clk))
 		return;
@@ -636,6 +657,9 @@ static __init void vtwm_pll_clk_init(struct device_node *node, int pll_type)
 	struct clk_init_data init;
 	int rc;
 
+	if (!pmc_base)
+		vtwm_set_pmc_base();
+
 	rc = of_property_read_u32(node, "reg", &reg);
 	if (WARN_ON(rc))
 		return;

commit 92295f632cefbdf15d46e9ac5f0fc3cfade35259
Merge: 750b2d7b93f2 45e3ec3784ae
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 11:54:50 2013 -0700

    Merge tag 'clk-for-linus-3.11' of git://git.linaro.org/people/mturquette/linux
    
    Pull clock framework updates from Mike Turquette:
     "The common clock framework changes for 3.11 include new clock drivers
      across several different platforms and architectures, fixes to
      existing drivers, a MAINTAINERS file fix and improvements to the basic
      clock types that allow them to be of use to more platforms than before.
    
      Only a few fixes to the core framework are included with most all of
      the changes landing in the various clock drivers themselves."
    
    * tag 'clk-for-linus-3.11' of git://git.linaro.org/people/mturquette/linux: (55 commits)
      clk: tegra: fix ifdef for tegra_periph_reset_assert inline
      clk: tegra: provide tegra_periph_reset_assert alternative
      clk: exynos4: Fix clock aliases for cpufreq related clocks
      clk: samsung: Add MUX_FA macro to pass flag and alias
      clk: add support for Rockchip gate clocks
      clk: vexpress: Make the clock drivers directly available for arm64
      clk: vexpress: Use full node name to identify individual clocks
      clk: tegra: T114: add DFLL DVCO reset control
      clk: tegra: T114: add DFLL source clocks
      clk: tegra: T114: add FCPU clock shaper programming, needed by the DFLL
      clk: gate: add CLK_GATE_HIWORD_MASK
      clk: divider: add CLK_DIVIDER_HIWORD_MASK flag
      clk: mux: add CLK_MUX_HIWORD_MASK
      clk: Always notify whole subtree when reparenting
      MAINTAINERS: make drivers/clk entry match subdirs
      clk: honor CLK_GET_RATE_NOCACHE in clk_set_rate
      clk: use clk_get_rate() for debugfs
      clk: tegra: Use override bits when needed
      clk: tegra: override bits for Tegra30 PLLM
      clk: tegra: override bits for Tegra114 PLLM
      ...

commit 419e321df8d7d605f21f980903befc65ee66e848
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Sat May 18 09:18:49 2013 +1200

    clk: vt8500: Fix unbalanced spinlock in vt8500_dclk_set_rate()
    
    With the addition of a DVO clock, a bug is now evident in the vt8500
    clock code:
    [    0.290000] WARNING: at init/main.c:698 do_one_initcall+0x158/0x18c()
    [    0.300000] initcall wm8505fb_driver_init+0x0/0xc returned with disabled int
    
    This is caused by an unbalanced spinlock in vt8500_dclk_set_rate().
    Replace the second call to spin_lock_irqsave() with spin_unlock_irqrestore().
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index debf688afa8e..553ac35bcc91 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -183,7 +183,7 @@ static int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,
 	writel(divisor, cdev->div_reg);
 	vt8500_pmc_wait_busy();
 
-	spin_lock_irqsave(cdev->lock, flags);
+	spin_unlock_irqrestore(cdev->lock, flags);
 
 	return 0;
 }

commit 65f2c58f0f44403aa64eccc14f3a0a74d721fe7e
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Mon May 13 20:21:00 2013 +1200

    clk: vt8500: Remove unnecessary divisor adjustment in vtwm_dclk_set_rate()
    
    The divisor adjustment code to ensure that a divisor is not rounded down,
    thereby giving a rate higher than requested, is unnecessary and in some
    instances results in the actual rate being much lower than requested due to
    rounding errors.
    
    The test is already performed in vtwm_dclk_round_rate(), which is always
    called when clk_set_rate is called. Due to rounding errors in the line:
    divisor = parent_rate / rate (clk-vt8500.c:160) we will sometimes end up
    adjusting the divisor twice - first in round_rate and then again in set_rate.
    
    This patch removes the test/adjustment in vtwm_dclk_set_rate.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 6d5b6e901b96..d8fd085719bf 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -157,10 +157,6 @@ static int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,
 
 	divisor =  parent_rate / rate;
 
-	/* If prate / rate would be decimal, incr the divisor */
-	if (rate * divisor < parent_rate)
-		divisor++;
-
 	if (divisor == cdev->div_mask + 1)
 		divisor = 0;
 

commit 518d4709f1961539a64f5d5f9b5b842824c0d971
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Mon May 13 20:20:59 2013 +1200

    clk: vt8500: Add support for clocks on the WM8850 SoCs
    
    The WM8850 has a different PLL clock to the previous versions. This
    patch adds support for the WM8850-style PLL clocks.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index debf688afa8e..6d5b6e901b96 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -42,6 +42,7 @@ struct clk_device {
 #define PLL_TYPE_VT8500		0
 #define PLL_TYPE_WM8650		1
 #define PLL_TYPE_WM8750		2
+#define PLL_TYPE_WM8850		3
 
 struct clk_pll {
 	struct clk_hw	hw;
@@ -327,6 +328,15 @@ CLK_OF_DECLARE(vt8500_device, "via,vt8500-device-clock", vtwm_device_clk_init);
 #define WM8750_BITS_TO_VAL(f, m, d1, d2)				\
 		((f << 24) | ((m - 1) << 16) | ((d1 - 1) << 8) | d2)
 
+/* Helper macros for PLL_WM8850 */
+#define WM8850_PLL_MUL(x)	((((x >> 16) & 0x7F) + 1) * 2)
+#define WM8850_PLL_DIV(x)	((((x >> 8) & 1) + 1) * (1 << (x & 3)))
+
+#define WM8850_BITS_TO_FREQ(r, m, d1, d2)				\
+				(r * ((m + 1) * 2) / ((d1+1) * (1 << d2)))
+
+#define WM8850_BITS_TO_VAL(m, d1, d2)					\
+		((((m / 2) - 1) << 16) | ((d1 - 1) << 8) | d2)
 
 static void vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *multiplier, u32 *prediv)
@@ -466,6 +476,49 @@ static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	*divisor2 = best_div2;
 }
 
+static void wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+				u32 *multiplier, u32 *divisor1, u32 *divisor2)
+{
+	u32 mul, div1, div2;
+	u32 best_mul, best_div1, best_div2;
+	unsigned long tclk, rate_err, best_err;
+
+	best_err = (unsigned long)-1;
+
+	/* Find the closest match (lower or equal to requested) */
+	for (div1 = 1; div1 >= 0; div1--)
+		for (div2 = 3; div2 >= 0; div2--)
+			for (mul = 0; mul <= 127; mul++) {
+				tclk = parent_rate * ((mul + 1) * 2) /
+						((div1 + 1) * (1 << div2));
+				if (tclk > rate)
+					continue;
+				/* error will always be +ve */
+				rate_err = rate - tclk;
+				if (rate_err == 0) {
+					*multiplier = mul;
+					*divisor1 = div1;
+					*divisor2 = div2;
+					return;
+				}
+
+				if (rate_err < best_err) {
+					best_err = rate_err;
+					best_mul = mul;
+					best_div1 = div1;
+					best_div2 = div2;
+				}
+			}
+
+	/* if we got here, it wasn't an exact match */
+	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
+							rate - best_err);
+
+	*multiplier = best_mul;
+	*divisor1 = best_div1;
+	*divisor2 = best_div2;
+}
+
 static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long parent_rate)
 {
@@ -489,6 +542,10 @@ static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 		wm8750_find_pll_bits(rate, parent_rate, &filter, &mul, &div1, &div2);
 		pll_val = WM8750_BITS_TO_VAL(filter, mul, div1, div2);
 		break;
+	case PLL_TYPE_WM8850:
+		wm8850_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);
+		pll_val = WM8850_BITS_TO_VAL(mul, div1, div2);
+		break;
 	default:
 		pr_err("%s: invalid pll type\n", __func__);
 		return 0;
@@ -525,6 +582,10 @@ static long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,
 		wm8750_find_pll_bits(rate, *prate, &filter, &mul, &div1, &div2);
 		round_rate = WM8750_BITS_TO_FREQ(*prate, mul, div1, div2);
 		break;
+	case PLL_TYPE_WM8850:
+		wm8850_find_pll_bits(rate, *prate, &mul, &div1, &div2);
+		round_rate = WM8850_BITS_TO_FREQ(*prate, mul, div1, div2);
+		break;
 	default:
 		round_rate = 0;
 	}
@@ -552,6 +613,10 @@ static unsigned long vtwm_pll_recalc_rate(struct clk_hw *hw,
 		pll_freq = parent_rate * WM8750_PLL_MUL(pll_val);
 		pll_freq /= WM8750_PLL_DIV(pll_val);
 		break;
+	case PLL_TYPE_WM8850:
+		pll_freq = parent_rate * WM8850_PLL_MUL(pll_val);
+		pll_freq /= WM8850_PLL_DIV(pll_val);
+		break;
 	default:
 		pll_freq = 0;
 	}
@@ -628,6 +693,12 @@ static void __init wm8750_pll_init(struct device_node *node)
 }
 CLK_OF_DECLARE(wm8750_pll, "wm,wm8750-pll-clock", wm8750_pll_init);
 
+static void __init wm8850_pll_init(struct device_node *node)
+{
+	vtwm_pll_clk_init(node, PLL_TYPE_WM8850);
+}
+CLK_OF_DECLARE(wm8850_pll, "wm,wm8850-pll-clock", wm8850_pll_init);
+
 void __init vtwm_clk_init(void __iomem *base)
 {
 	if (!base)

commit 362ed48dee509abe24cf84b7e137c7a29a8f4d2d
Merge: 61f3d0a9883d 1e435256d625
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 29 16:43:54 2013 -0700

    Merge tag 'clk-for-linus-3.10' of git://git.linaro.org/people/mturquette/linux
    
    Pull clock framework update from Michael Turquette:
     "The common clock framework changes for 3.10 include many fixes for
      existing platforms, as well as adoption of the framework by new
      platforms and devices.
    
      Some long-needed fixes to the core framework are here as well as new
      features such as improved initialization of clocks from DT as well as
      framework reentrancy for nested clock operations."
    
    * tag 'clk-for-linus-3.10' of git://git.linaro.org/people/mturquette/linux: (44 commits)
      clk: add clk_ignore_unused option to keep boot clocks on
      clk: ux500: fix mismatched types
      clk: vexpress: Add separate SP810 driver
      clk: si5351: make clk-si5351 depend on CONFIG_OF
      clk: export __clk_get_flags for modular clock providers
      clk: vt8500: Missing breaks in vtwm_pll_round_rate/_set_rate.
      clk: sunxi: Unify oscillator clock
      clk: composite: allow fixed rates & fixed dividers
      clk: composite: rename 'div' references to 'rate'
      clk: add si5351 i2c common clock driver
      clk: add device tree fixed-factor-clock binding support
      clk: Properly handle notifier return values
      clk: ux500: abx500: Define clock tree for ab850x
      clk: ux500: Add support for sysctrl clocks
      clk: mvebu: Fix valid value range checking for cpu_freq_select
      clk: Fixup locking issues for clk_set_parent
      clk: Fixup errorhandling for clk_set_parent
      clk: Restructure code for __clk_reparent
      clk: sunxi: drop an unnecesary kmalloc
      clk: sunxi: drop CLK_IGNORE_UNUSED
      ...

commit bdca21ecc252b5d390065de03d03c5a9df491025
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Sun Apr 14 17:28:35 2013 +1200

    clk: vt8500: Missing breaks in vtwm_pll_round_rate/_set_rate.
    
    The case of PLL_TYPE_WM8750 in both these functions is missing a break
    statement causing a fall-through to the default: case.
    
    Insert the missing break statements.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index b5538bba7a10..6bc82d1bfe78 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -488,6 +488,7 @@ static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 	case PLL_TYPE_WM8750:
 		wm8750_find_pll_bits(rate, parent_rate, &filter, &mul, &div1, &div2);
 		pll_val = WM8750_BITS_TO_VAL(filter, mul, div1, div2);
+		break;
 	default:
 		pr_err("%s: invalid pll type\n", __func__);
 		return 0;
@@ -523,6 +524,7 @@ static long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,
 	case PLL_TYPE_WM8750:
 		wm8750_find_pll_bits(rate, *prate, &filter, &mul, &div1, &div2);
 		round_rate = WM8750_BITS_TO_FREQ(*prate, mul, div1, div2);
+		break;
 	default:
 		round_rate = 0;
 	}

commit d6d1053a8bbf75e5eb6ef29ddcf87e66421763c4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 1 14:12:01 2013 +0100

    clk: vt8500: Fix "fix device clock divisor calculations"
    
    Patch 72480014b8 "Fix device clock divisor calculations" was apparently
    rebased incorrectly before it got upstream, causing a build error.
    
    Replacing the "prate" pointer with the local parent_rate is most
    likely the correct solution.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index b5538bba7a10..09c63315e579 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -157,7 +157,7 @@ static int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,
 	divisor =  parent_rate / rate;
 
 	/* If prate / rate would be decimal, incr the divisor */
-	if (rate * divisor < *prate)
+	if (rate * divisor < parent_rate)
 		divisor++;
 
 	if (divisor == cdev->div_mask + 1)

commit 5b6e0adb69674c684c33503f50010644b049029c
Author: Prashant Gaikwad <pgaikwad@nvidia.com>
Date:   Fri Jan 4 12:30:56 2013 +0530

    clk: vt8500: Use common of_clk_init() function
    
    Use common of_clk_init() function for clock initialization.
    
    Signed-off-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Tested-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: added entry for wm8750-pll-clock]
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 2515d4f31758..b5538bba7a10 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -291,7 +291,7 @@ static __init void vtwm_device_clk_init(struct device_node *node)
 	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
 	clk_register_clkdev(clk, clk_name, NULL);
 }
-
+CLK_OF_DECLARE(vt8500_device, "via,vt8500-device-clock", vtwm_device_clk_init);
 
 /* PLL clock related functions */
 
@@ -612,26 +612,19 @@ static void __init vt8500_pll_init(struct device_node *node)
 {
 	vtwm_pll_clk_init(node, PLL_TYPE_VT8500);
 }
+CLK_OF_DECLARE(vt8500_pll, "via,vt8500-pll-clock", vt8500_pll_init);
 
 static void __init wm8650_pll_init(struct device_node *node)
 {
 	vtwm_pll_clk_init(node, PLL_TYPE_WM8650);
 }
+CLK_OF_DECLARE(wm8650_pll, "wm,wm8650-pll-clock", wm8650_pll_init);
 
 static void __init wm8750_pll_init(struct device_node *node)
 {
 	vtwm_pll_clk_init(node, PLL_TYPE_WM8750);
 }
-
-static const __initconst struct of_device_id clk_match[] = {
-	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
-	{ .compatible = "via,vt8500-pll-clock", .data = vt8500_pll_init, },
-	{ .compatible = "wm,wm8650-pll-clock", .data = wm8650_pll_init, },
-	{ .compatible = "wm,wm8750-pll-clock", .data = wm8750_pll_init, },
-	{ .compatible = "via,vt8500-device-clock",
-					.data = vtwm_device_clk_init, },
-	{ /* sentinel */ }
-};
+CLK_OF_DECLARE(wm8750_pll, "wm,wm8750-pll-clock", wm8750_pll_init);
 
 void __init vtwm_clk_init(void __iomem *base)
 {
@@ -640,5 +633,5 @@ void __init vtwm_clk_init(void __iomem *base)
 
 	pmc_base = base;
 
-	of_clk_init(clk_match);
+	of_clk_init(NULL);
 }

commit abb165a80b42a5dd6ca001597422f0d28b2cd59a
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Fri Dec 28 14:24:41 2012 +1300

    clk: vt8500: Add support for WM8750/WM8850 PLL clocks
    
    This patch adds support for the new PLL module found in WM8750 and
    WM8850 SoCs.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index db7d41f25046..2515d4f31758 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -41,6 +41,7 @@ struct clk_device {
 
 #define PLL_TYPE_VT8500		0
 #define PLL_TYPE_WM8650		1
+#define PLL_TYPE_WM8750		2
 
 struct clk_pll {
 	struct clk_hw	hw;
@@ -316,6 +317,16 @@ static __init void vtwm_device_clk_init(struct device_node *node)
 #define WM8650_BITS_TO_VAL(m, d1, d2)					\
 				((d2 << 13) | (d1 << 10) | (m & 0x3FF))
 
+/* Helper macros for PLL_WM8750 */
+#define WM8750_PLL_MUL(x)	(((x >> 16) & 0xFF) + 1)
+#define WM8750_PLL_DIV(x)	((((x >> 8) & 1) + 1) * (1 << (x & 7)))
+
+#define WM8750_BITS_TO_FREQ(r, m, d1, d2)				\
+				(r * (m+1) / ((d1+1) * (1 << d2)))
+
+#define WM8750_BITS_TO_VAL(f, m, d1, d2)				\
+		((f << 24) | ((m - 1) << 16) | ((d1 - 1) << 8) | d2)
+
 
 static void vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 				u32 *multiplier, u32 *prediv)
@@ -384,11 +395,82 @@ static void wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	*divisor2 = best_div2;
 }
 
+static u32 wm8750_get_filter(u32 parent_rate, u32 divisor1)
+{
+	/* calculate frequency (MHz) after pre-divisor */
+	u32 freq = (parent_rate / 1000000) / (divisor1 + 1);
+
+	if ((freq < 10) || (freq > 200))
+		pr_warn("%s: PLL recommended input frequency 10..200Mhz (requested %d Mhz)\n",
+				__func__, freq);
+
+	if (freq >= 166)
+		return 7;
+	else if (freq >= 104)
+		return 6;
+	else if (freq >= 65)
+		return 5;
+	else if (freq >= 42)
+		return 4;
+	else if (freq >= 26)
+		return 3;
+	else if (freq >= 16)
+		return 2;
+	else if (freq >= 10)
+		return 1;
+
+	return 0;
+}
+
+static void wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+				u32 *filter, u32 *multiplier, u32 *divisor1, u32 *divisor2)
+{
+	u32 mul, div1, div2;
+	u32 best_mul, best_div1, best_div2;
+	unsigned long tclk, rate_err, best_err;
+
+	best_err = (unsigned long)-1;
+
+	/* Find the closest match (lower or equal to requested) */
+	for (div1 = 1; div1 >= 0; div1--)
+		for (div2 = 7; div2 >= 0; div2--)
+			for (mul = 0; mul <= 255; mul++) {
+				tclk = parent_rate * (mul + 1) / ((div1 + 1) * (1 << div2));
+				if (tclk > rate)
+					continue;
+				/* error will always be +ve */
+				rate_err = rate - tclk;
+				if (rate_err == 0) {
+					*filter = wm8750_get_filter(parent_rate, div1);
+					*multiplier = mul;
+					*divisor1 = div1;
+					*divisor2 = div2;
+					return;
+				}
+
+				if (rate_err < best_err) {
+					best_err = rate_err;
+					best_mul = mul;
+					best_div1 = div1;
+					best_div2 = div2;
+				}
+			}
+
+	/* if we got here, it wasn't an exact match */
+	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
+							rate - best_err);
+
+	*filter = wm8750_get_filter(parent_rate, best_div1);
+	*multiplier = best_mul;
+	*divisor1 = best_div1;
+	*divisor2 = best_div2;
+}
+
 static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long parent_rate)
 {
 	struct clk_pll *pll = to_clk_pll(hw);
-	u32 mul, div1, div2;
+	u32 filter, mul, div1, div2;
 	u32 pll_val;
 	unsigned long flags = 0;
 
@@ -403,6 +485,9 @@ static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 		wm8650_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);
 		pll_val = WM8650_BITS_TO_VAL(mul, div1, div2);
 		break;
+	case PLL_TYPE_WM8750:
+		wm8750_find_pll_bits(rate, parent_rate, &filter, &mul, &div1, &div2);
+		pll_val = WM8750_BITS_TO_VAL(filter, mul, div1, div2);
 	default:
 		pr_err("%s: invalid pll type\n", __func__);
 		return 0;
@@ -423,7 +508,7 @@ static long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long *prate)
 {
 	struct clk_pll *pll = to_clk_pll(hw);
-	u32 mul, div1, div2;
+	u32 filter, mul, div1, div2;
 	long round_rate;
 
 	switch (pll->type) {
@@ -435,6 +520,9 @@ static long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,
 		wm8650_find_pll_bits(rate, *prate, &mul, &div1, &div2);
 		round_rate = WM8650_BITS_TO_FREQ(*prate, mul, div1, div2);
 		break;
+	case PLL_TYPE_WM8750:
+		wm8750_find_pll_bits(rate, *prate, &filter, &mul, &div1, &div2);
+		round_rate = WM8750_BITS_TO_FREQ(*prate, mul, div1, div2);
 	default:
 		round_rate = 0;
 	}
@@ -458,6 +546,10 @@ static unsigned long vtwm_pll_recalc_rate(struct clk_hw *hw,
 		pll_freq = parent_rate * WM8650_PLL_MUL(pll_val);
 		pll_freq /= WM8650_PLL_DIV(pll_val);
 		break;
+	case PLL_TYPE_WM8750:
+		pll_freq = parent_rate * WM8750_PLL_MUL(pll_val);
+		pll_freq /= WM8750_PLL_DIV(pll_val);
+		break;
 	default:
 		pll_freq = 0;
 	}
@@ -526,10 +618,16 @@ static void __init wm8650_pll_init(struct device_node *node)
 	vtwm_pll_clk_init(node, PLL_TYPE_WM8650);
 }
 
+static void __init wm8750_pll_init(struct device_node *node)
+{
+	vtwm_pll_clk_init(node, PLL_TYPE_WM8750);
+}
+
 static const __initconst struct of_device_id clk_match[] = {
 	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
 	{ .compatible = "via,vt8500-pll-clock", .data = vt8500_pll_init, },
 	{ .compatible = "wm,wm8650-pll-clock", .data = wm8650_pll_init, },
+	{ .compatible = "wm,wm8750-pll-clock", .data = wm8750_pll_init, },
 	{ .compatible = "via,vt8500-device-clock",
 					.data = vtwm_device_clk_init, },
 	{ /* sentinel */ }

commit 58eb5a6763deab71208fbff15b09055fac884b11
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Thu Dec 27 13:14:31 2012 +1300

    clk: vt8500: Fix division-by-0 when requested rate=0
    
    A request to vt8500_dclk_(round_rate/set_rate) with rate=0 results
    in a division-by-0 in the kernel.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 3306c2b1906c..db7d41f25046 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -121,7 +121,12 @@ static long vt8500_dclk_round_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long *prate)
 {
 	struct clk_device *cdev = to_clk_device(hw);
-	u32 divisor = *prate / rate;
+	u32 divisor;
+
+	if (rate == 0)
+		return 0;
+
+	divisor = *prate / rate;
 
 	/* If prate / rate would be decimal, incr the divisor */
 	if (rate * divisor < *prate)
@@ -142,9 +147,14 @@ static int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long parent_rate)
 {
 	struct clk_device *cdev = to_clk_device(hw);
-	u32 divisor = parent_rate / rate;
+	u32 divisor;
 	unsigned long flags = 0;
 
+	if (rate == 0)
+		return 0;
+
+	divisor =  parent_rate / rate;
+
 	/* If prate / rate would be decimal, incr the divisor */
 	if (rate * divisor < *prate)
 		divisor++;

commit 72480014b86c8b51fb51c5c6a0525876055c37c7
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Thu Dec 27 13:14:30 2012 +1300

    clk: vt8500: Fix device clock divisor calculations
    
    When calculating device clock divisor values in set_rate and
    round_rate, we do a simple integer divide. If parent_rate / rate
    has a fraction, this is dropped which results in the device clock
    being set too high.
    
    This patch corrects the problem by adding 1 to the calculated
    divisor if the division would have had a decimal result.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index 0cb26bef427d..3306c2b1906c 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -123,6 +123,10 @@ static long vt8500_dclk_round_rate(struct clk_hw *hw, unsigned long rate,
 	struct clk_device *cdev = to_clk_device(hw);
 	u32 divisor = *prate / rate;
 
+	/* If prate / rate would be decimal, incr the divisor */
+	if (rate * divisor < *prate)
+		divisor++;
+
 	/*
 	 * If this is a request for SDMMC we have to adjust the divisor
 	 * when >31 to use the fixed predivisor
@@ -141,6 +145,10 @@ static int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,
 	u32 divisor = parent_rate / rate;
 	unsigned long flags = 0;
 
+	/* If prate / rate would be decimal, incr the divisor */
+	if (rate * divisor < *prate)
+		divisor++;
+
 	if (divisor == cdev->div_mask + 1)
 		divisor = 0;
 

commit 35a5db55ab96eadb07b3d5f7258558c680ebc2f0
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Thu Dec 27 13:14:29 2012 +1300

    clk: vt8500: Fix error in PLL calculations on non-exact match.
    
    When a PLL frequency calculation is performed and a non-exact match
    is found the wrong multiplier and divisors are returned.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index fe25570874d6..0cb26bef427d 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -361,9 +361,9 @@ static void wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
 	/* if we got here, it wasn't an exact match */
 	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
 							rate - best_err);
-	*multiplier = mul;
-	*divisor1 = div1;
-	*divisor2 = div2;
+	*multiplier = best_mul;
+	*divisor1 = best_div1;
+	*divisor2 = best_div2;
 }
 
 static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,

commit 973e1d1de0f8af2be7f8c94418f2cda559bd7543
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Thu Oct 18 22:26:53 2012 +1300

    CLK: vt8500: Fix SDMMC clk special cases
    
    This patch adds some additional handling for the SDMMC special case
    in round_rate and set_rate which results in invalid divisor messages
    at boot time.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
index a885600f5270..fe25570874d6 100644
--- a/drivers/clk/clk-vt8500.c
+++ b/drivers/clk/clk-vt8500.c
@@ -120,8 +120,17 @@ static unsigned long vt8500_dclk_recalc_rate(struct clk_hw *hw,
 static long vt8500_dclk_round_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long *prate)
 {
+	struct clk_device *cdev = to_clk_device(hw);
 	u32 divisor = *prate / rate;
 
+	/*
+	 * If this is a request for SDMMC we have to adjust the divisor
+	 * when >31 to use the fixed predivisor
+	 */
+	if ((cdev->div_mask == 0x3F) && (divisor > 31)) {
+		divisor = 64 * ((divisor / 64) + 1);
+	}
+
 	return *prate / divisor;
 }
 
@@ -135,6 +144,15 @@ static int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,
 	if (divisor == cdev->div_mask + 1)
 		divisor = 0;
 
+	/* SDMMC mask may need to be corrected before testing if its valid */
+	if ((cdev->div_mask == 0x3F) && (divisor > 31)) {
+		/*
+		 * Bit 5 is a fixed /64 predivisor. If the requested divisor
+		 * is >31 then correct for the fixed divisor being required.
+		 */
+		divisor = 0x20 + (divisor / 64);
+	}
+
 	if (divisor > cdev->div_mask) {
 		pr_err("%s: invalid divisor for clock\n", __func__);
 		return -EINVAL;

commit 85814d69e677d92f66d8d63718d8bdaf72b2e2af
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Wed Aug 22 02:01:39 2012 +1200

    arm: vt8500: clk: Add Common Clock Framework support
    
    This patch adds common clock framework support for arch-vt8500.
    Support for PLL and device clocks on VT8500, WM8505 and WM8650
    are included.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-vt8500.c b/drivers/clk/clk-vt8500.c
new file mode 100644
index 000000000000..a885600f5270
--- /dev/null
+++ b/drivers/clk/clk-vt8500.c
@@ -0,0 +1,510 @@
+/*
+ * Clock implementation for VIA/Wondermedia SoC's
+ * Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/bitops.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+
+/* All clocks share the same lock as none can be changed concurrently */
+static DEFINE_SPINLOCK(_lock);
+
+struct clk_device {
+	struct clk_hw	hw;
+	void __iomem	*div_reg;
+	unsigned int	div_mask;
+	void __iomem	*en_reg;
+	int		en_bit;
+	spinlock_t	*lock;
+};
+
+/*
+ * Add new PLL_TYPE_x definitions here as required. Use the first known model
+ * to support the new type as the name.
+ * Add case statements to vtwm_pll_recalc_rate(), vtwm_pll_round_round() and
+ * vtwm_pll_set_rate() to handle the new PLL_TYPE_x
+ */
+
+#define PLL_TYPE_VT8500		0
+#define PLL_TYPE_WM8650		1
+
+struct clk_pll {
+	struct clk_hw	hw;
+	void __iomem	*reg;
+	spinlock_t	*lock;
+	int		type;
+};
+
+static void __iomem *pmc_base;
+
+#define to_clk_device(_hw) container_of(_hw, struct clk_device, hw)
+
+#define VT8500_PMC_BUSY_MASK		0x18
+
+static void vt8500_pmc_wait_busy(void)
+{
+	while (readl(pmc_base) & VT8500_PMC_BUSY_MASK)
+		cpu_relax();
+}
+
+static int vt8500_dclk_enable(struct clk_hw *hw)
+{
+	struct clk_device *cdev = to_clk_device(hw);
+	u32 en_val;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(cdev->lock, flags);
+
+	en_val = readl(cdev->en_reg);
+	en_val |= BIT(cdev->en_bit);
+	writel(en_val, cdev->en_reg);
+
+	spin_unlock_irqrestore(cdev->lock, flags);
+	return 0;
+}
+
+static void vt8500_dclk_disable(struct clk_hw *hw)
+{
+	struct clk_device *cdev = to_clk_device(hw);
+	u32 en_val;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(cdev->lock, flags);
+
+	en_val = readl(cdev->en_reg);
+	en_val &= ~BIT(cdev->en_bit);
+	writel(en_val, cdev->en_reg);
+
+	spin_unlock_irqrestore(cdev->lock, flags);
+}
+
+static int vt8500_dclk_is_enabled(struct clk_hw *hw)
+{
+	struct clk_device *cdev = to_clk_device(hw);
+	u32 en_val = (readl(cdev->en_reg) & BIT(cdev->en_bit));
+
+	return en_val ? 1 : 0;
+}
+
+static unsigned long vt8500_dclk_recalc_rate(struct clk_hw *hw,
+				unsigned long parent_rate)
+{
+	struct clk_device *cdev = to_clk_device(hw);
+	u32 div = readl(cdev->div_reg) & cdev->div_mask;
+
+	/* Special case for SDMMC devices */
+	if ((cdev->div_mask == 0x3F) && (div & BIT(5)))
+		div = 64 * (div & 0x1f);
+
+	/* div == 0 is actually the highest divisor */
+	if (div == 0)
+		div = (cdev->div_mask + 1);
+
+	return parent_rate / div;
+}
+
+static long vt8500_dclk_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *prate)
+{
+	u32 divisor = *prate / rate;
+
+	return *prate / divisor;
+}
+
+static int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct clk_device *cdev = to_clk_device(hw);
+	u32 divisor = parent_rate / rate;
+	unsigned long flags = 0;
+
+	if (divisor == cdev->div_mask + 1)
+		divisor = 0;
+
+	if (divisor > cdev->div_mask) {
+		pr_err("%s: invalid divisor for clock\n", __func__);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(cdev->lock, flags);
+
+	vt8500_pmc_wait_busy();
+	writel(divisor, cdev->div_reg);
+	vt8500_pmc_wait_busy();
+
+	spin_lock_irqsave(cdev->lock, flags);
+
+	return 0;
+}
+
+
+static const struct clk_ops vt8500_gated_clk_ops = {
+	.enable = vt8500_dclk_enable,
+	.disable = vt8500_dclk_disable,
+	.is_enabled = vt8500_dclk_is_enabled,
+};
+
+static const struct clk_ops vt8500_divisor_clk_ops = {
+	.round_rate = vt8500_dclk_round_rate,
+	.set_rate = vt8500_dclk_set_rate,
+	.recalc_rate = vt8500_dclk_recalc_rate,
+};
+
+static const struct clk_ops vt8500_gated_divisor_clk_ops = {
+	.enable = vt8500_dclk_enable,
+	.disable = vt8500_dclk_disable,
+	.is_enabled = vt8500_dclk_is_enabled,
+	.round_rate = vt8500_dclk_round_rate,
+	.set_rate = vt8500_dclk_set_rate,
+	.recalc_rate = vt8500_dclk_recalc_rate,
+};
+
+#define CLK_INIT_GATED			BIT(0)
+#define CLK_INIT_DIVISOR		BIT(1)
+#define CLK_INIT_GATED_DIVISOR		(CLK_INIT_DIVISOR | CLK_INIT_GATED)
+
+static __init void vtwm_device_clk_init(struct device_node *node)
+{
+	u32 en_reg, div_reg;
+	struct clk *clk;
+	struct clk_device *dev_clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	struct clk_init_data init;
+	int rc;
+	int clk_init_flags = 0;
+
+	dev_clk = kzalloc(sizeof(*dev_clk), GFP_KERNEL);
+	if (WARN_ON(!dev_clk))
+		return;
+
+	dev_clk->lock = &_lock;
+
+	rc = of_property_read_u32(node, "enable-reg", &en_reg);
+	if (!rc) {
+		dev_clk->en_reg = pmc_base + en_reg;
+		rc = of_property_read_u32(node, "enable-bit", &dev_clk->en_bit);
+		if (rc) {
+			pr_err("%s: enable-bit property required for gated clock\n",
+								__func__);
+			return;
+		}
+		clk_init_flags |= CLK_INIT_GATED;
+	}
+
+	rc = of_property_read_u32(node, "divisor-reg", &div_reg);
+	if (!rc) {
+		dev_clk->div_reg = pmc_base + div_reg;
+		/*
+		 * use 0x1f as the default mask since it covers
+		 * almost all the clocks and reduces dts properties
+		 */
+		dev_clk->div_mask = 0x1f;
+
+		of_property_read_u32(node, "divisor-mask", &dev_clk->div_mask);
+		clk_init_flags |= CLK_INIT_DIVISOR;
+	}
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	switch (clk_init_flags) {
+	case CLK_INIT_GATED:
+		init.ops = &vt8500_gated_clk_ops;
+		break;
+	case CLK_INIT_DIVISOR:
+		init.ops = &vt8500_divisor_clk_ops;
+		break;
+	case CLK_INIT_GATED_DIVISOR:
+		init.ops = &vt8500_gated_divisor_clk_ops;
+		break;
+	default:
+		pr_err("%s: Invalid clock description in device tree\n",
+								__func__);
+		kfree(dev_clk);
+		return;
+	}
+
+	init.name = clk_name;
+	init.flags = 0;
+	parent_name = of_clk_get_parent_name(node, 0);
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	dev_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &dev_clk->hw);
+	if (WARN_ON(IS_ERR(clk))) {
+		kfree(dev_clk);
+		return;
+	}
+	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	clk_register_clkdev(clk, clk_name, NULL);
+}
+
+
+/* PLL clock related functions */
+
+#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)
+
+/* Helper macros for PLL_VT8500 */
+#define VT8500_PLL_MUL(x)	((x & 0x1F) << 1)
+#define VT8500_PLL_DIV(x)	((x & 0x100) ? 1 : 2)
+
+#define VT8500_BITS_TO_FREQ(r, m, d)					\
+				((r / d) * m)
+
+#define VT8500_BITS_TO_VAL(m, d)					\
+				((d == 2 ? 0 : 0x100) | ((m >> 1) & 0x1F))
+
+/* Helper macros for PLL_WM8650 */
+#define WM8650_PLL_MUL(x)	(x & 0x3FF)
+#define WM8650_PLL_DIV(x)	(((x >> 10) & 7) * (1 << ((x >> 13) & 3)))
+
+#define WM8650_BITS_TO_FREQ(r, m, d1, d2)				\
+				(r * m / (d1 * (1 << d2)))
+
+#define WM8650_BITS_TO_VAL(m, d1, d2)					\
+				((d2 << 13) | (d1 << 10) | (m & 0x3FF))
+
+
+static void vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+				u32 *multiplier, u32 *prediv)
+{
+	unsigned long tclk;
+
+	/* sanity check */
+	if ((rate < parent_rate * 4) || (rate > parent_rate * 62)) {
+		pr_err("%s: requested rate out of range\n", __func__);
+		*multiplier = 0;
+		*prediv = 1;
+		return;
+	}
+	if (rate <= parent_rate * 31)
+		/* use the prediv to double the resolution */
+		*prediv = 2;
+	else
+		*prediv = 1;
+
+	*multiplier = rate / (parent_rate / *prediv);
+	tclk = (parent_rate / *prediv) * *multiplier;
+
+	if (tclk != rate)
+		pr_warn("%s: requested rate %lu, found rate %lu\n", __func__,
+								rate, tclk);
+}
+
+static void wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,
+				u32 *multiplier, u32 *divisor1, u32 *divisor2)
+{
+	u32 mul, div1, div2;
+	u32 best_mul, best_div1, best_div2;
+	unsigned long tclk, rate_err, best_err;
+
+	best_err = (unsigned long)-1;
+
+	/* Find the closest match (lower or equal to requested) */
+	for (div1 = 5; div1 >= 3; div1--)
+		for (div2 = 3; div2 >= 0; div2--)
+			for (mul = 3; mul <= 1023; mul++) {
+				tclk = parent_rate * mul / (div1 * (1 << div2));
+				if (tclk > rate)
+					continue;
+				/* error will always be +ve */
+				rate_err = rate - tclk;
+				if (rate_err == 0) {
+					*multiplier = mul;
+					*divisor1 = div1;
+					*divisor2 = div2;
+					return;
+				}
+
+				if (rate_err < best_err) {
+					best_err = rate_err;
+					best_mul = mul;
+					best_div1 = div1;
+					best_div2 = div2;
+				}
+			}
+
+	/* if we got here, it wasn't an exact match */
+	pr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,
+							rate - best_err);
+	*multiplier = mul;
+	*divisor1 = div1;
+	*divisor2 = div2;
+}
+
+static int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct clk_pll *pll = to_clk_pll(hw);
+	u32 mul, div1, div2;
+	u32 pll_val;
+	unsigned long flags = 0;
+
+	/* sanity check */
+
+	switch (pll->type) {
+	case PLL_TYPE_VT8500:
+		vt8500_find_pll_bits(rate, parent_rate, &mul, &div1);
+		pll_val = VT8500_BITS_TO_VAL(mul, div1);
+		break;
+	case PLL_TYPE_WM8650:
+		wm8650_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);
+		pll_val = WM8650_BITS_TO_VAL(mul, div1, div2);
+		break;
+	default:
+		pr_err("%s: invalid pll type\n", __func__);
+		return 0;
+	}
+
+	spin_lock_irqsave(pll->lock, flags);
+
+	vt8500_pmc_wait_busy();
+	writel(pll_val, pll->reg);
+	vt8500_pmc_wait_busy();
+
+	spin_unlock_irqrestore(pll->lock, flags);
+
+	return 0;
+}
+
+static long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *prate)
+{
+	struct clk_pll *pll = to_clk_pll(hw);
+	u32 mul, div1, div2;
+	long round_rate;
+
+	switch (pll->type) {
+	case PLL_TYPE_VT8500:
+		vt8500_find_pll_bits(rate, *prate, &mul, &div1);
+		round_rate = VT8500_BITS_TO_FREQ(*prate, mul, div1);
+		break;
+	case PLL_TYPE_WM8650:
+		wm8650_find_pll_bits(rate, *prate, &mul, &div1, &div2);
+		round_rate = WM8650_BITS_TO_FREQ(*prate, mul, div1, div2);
+		break;
+	default:
+		round_rate = 0;
+	}
+
+	return round_rate;
+}
+
+static unsigned long vtwm_pll_recalc_rate(struct clk_hw *hw,
+				unsigned long parent_rate)
+{
+	struct clk_pll *pll = to_clk_pll(hw);
+	u32 pll_val = readl(pll->reg);
+	unsigned long pll_freq;
+
+	switch (pll->type) {
+	case PLL_TYPE_VT8500:
+		pll_freq = parent_rate * VT8500_PLL_MUL(pll_val);
+		pll_freq /= VT8500_PLL_DIV(pll_val);
+		break;
+	case PLL_TYPE_WM8650:
+		pll_freq = parent_rate * WM8650_PLL_MUL(pll_val);
+		pll_freq /= WM8650_PLL_DIV(pll_val);
+		break;
+	default:
+		pll_freq = 0;
+	}
+
+	return pll_freq;
+}
+
+const struct clk_ops vtwm_pll_ops = {
+	.round_rate = vtwm_pll_round_rate,
+	.set_rate = vtwm_pll_set_rate,
+	.recalc_rate = vtwm_pll_recalc_rate,
+};
+
+static __init void vtwm_pll_clk_init(struct device_node *node, int pll_type)
+{
+	u32 reg;
+	struct clk *clk;
+	struct clk_pll *pll_clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	struct clk_init_data init;
+	int rc;
+
+	rc = of_property_read_u32(node, "reg", &reg);
+	if (WARN_ON(rc))
+		return;
+
+	pll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);
+	if (WARN_ON(!pll_clk))
+		return;
+
+	pll_clk->reg = pmc_base + reg;
+	pll_clk->lock = &_lock;
+	pll_clk->type = pll_type;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	init.name = clk_name;
+	init.ops = &vtwm_pll_ops;
+	init.flags = 0;
+	parent_name = of_clk_get_parent_name(node, 0);
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	pll_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &pll_clk->hw);
+	if (WARN_ON(IS_ERR(clk))) {
+		kfree(pll_clk);
+		return;
+	}
+	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	clk_register_clkdev(clk, clk_name, NULL);
+}
+
+
+/* Wrappers for initialization functions */
+
+static void __init vt8500_pll_init(struct device_node *node)
+{
+	vtwm_pll_clk_init(node, PLL_TYPE_VT8500);
+}
+
+static void __init wm8650_pll_init(struct device_node *node)
+{
+	vtwm_pll_clk_init(node, PLL_TYPE_WM8650);
+}
+
+static const __initconst struct of_device_id clk_match[] = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "via,vt8500-pll-clock", .data = vt8500_pll_init, },
+	{ .compatible = "wm,wm8650-pll-clock", .data = wm8650_pll_init, },
+	{ .compatible = "via,vt8500-device-clock",
+					.data = vtwm_device_clk_init, },
+	{ /* sentinel */ }
+};
+
+void __init vtwm_clk_init(void __iomem *base)
+{
+	if (!base)
+		return;
+
+	pmc_base = base;
+
+	of_clk_init(clk_match);
+}
