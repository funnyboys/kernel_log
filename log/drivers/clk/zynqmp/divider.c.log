commit 6f630784cc0d92fb58ea326e2bc01aa056279ecb
Merge: 3a2a87517421 9ac1eafa885a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 11:42:19 2020 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "This time around we have four lines of diff in the core framework,
      removing a function that isn't used anymore. Otherwise the main new
      thing for the common clk framework is that it is selectable in the
      Kconfig language now. Hopefully this will let clk drivers and clk
      consumers be testable on more than the architectures that support the
      clk framework. The goal is to introduce some Kunit tests for the
      framework.
    
      Outside of the core framework we have the usual set of various driver
      updates and non-critical fixes. The dirstat shows that the new
      Baikal-T1 driver is the largest addition this time around in terms of
      lines of code. After that the x86 (Intel), Qualcomm, and Mediatek
      drivers introduce many lines to support new or upcoming SoCs. After
      that the dirstat shows the usual suspects working on their SoC support
      by fixing minor bugs, correcting data and converting some of their DT
      bindings to YAML.
    
      Core:
       - Allow the COMMON_CLK config to be selectable
    
      New Drivers:
       - Clk driver for Baikal-T1 SoCs
       - Mediatek MT6765 clock support
       - Support for Intel Agilex clks
       - Add support for X1830 and X1000 Ingenic SoC clk controllers
       - Add support for the new Renesas RZ/G1H (R8A7742) SoC
       - Add support for Qualcomm's MSM8939 Generic Clock Controller
    
      Updates:
       - Support IDT VersaClock 5P49V5925
       - Bunch of updates for HSDK clock generation unit (CGU) driver
       - Start making audio and GPU clks work on Marvell MMP2/MMP3 SoCs
       - Add some GPU, NPU, and UFS clks to Qualcomm SM8150 driver
       - Enable supply regulators for GPU gdscs on Qualcomm SoCs
       - Add support for Si5342, Si5344 and Si5345 chips
       - Support custom flags in Xilinx zynq firmware
       - Various small fixes to the Xilinx clk driver
       - A single minor rounding fix for the legacy Allwinner clock support
       - A few patches from Abel Vesa as preparation of adding audiomix
         clock support on i.MX
       - A couple of cleanups from Anson Huang for i.MX clk-sscg-pll and
         clk-pllv3 drivers
       - Drop dependency on ARM64 for i.MX8M clock driver, to support
         aarch32 mode on aarch64 hardware
       - A series from Peng Fan to improve i.MX8M clock drivers, using
         composite clock for core and bus clk slice
       - Set a better parent clock for flexcan on i.MX6UL to support CiA102
         defined bit rates
       - A couple changes for EMC frequency scaling on Tegra210
       - Support for CPU frequency scaling on Tegra20/Tegra30
       - New clk gate for CSI test pattern generator on Tegra210
       - Regression fixes for Samsung exynos542x and exynos5433 SoCs
       - Use of fallthrough; attribute for Samsung s3c24xx
       - Updates and fixup HDMI and video clocks on Meson8b
       - Fixup reset polarity on Meson8b
       - Fix GPU glitch free mux switch on Meson gx and g12
       - A minor fix for the currently unused suspend/resume handling on
         Renesas RZ/A1 and RZ/A2
       - Two more conversions of Renesas DT bindings to json-schema
       - Add support for the USB 2.0 clock selector on Renesas R-Car M3-W+"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (155 commits)
      clk: mediatek: Remove ifr{0,1}_cfg_regs structures
      clk: baikal-t1: remove redundant assignment to variable 'divider'
      clk: baikal-t1: fix spelling mistake "Uncompatible" -> "Incompatible"
      dt-bindings: clock: Add a missing include to MMP Audio Clock binding
      dt: Add bindings for IDT VersaClock 5P49V5925
      clk: vc5: Add support for IDT VersaClock 5P49V6965
      clk: Add Baikal-T1 CCU Dividers driver
      clk: Add Baikal-T1 CCU PLLs driver
      dt-bindings: clk: Add Baikal-T1 CCU Dividers binding
      dt-bindings: clk: Add Baikal-T1 CCU PLLs binding
      clk: mediatek: assign the initial value to clk_init_data of mtk_mux
      clk: mediatek: Add MT6765 clock support
      clk: mediatek: add mt6765 clock IDs
      dt-bindings: clock: mediatek: document clk bindings vcodecsys for Mediatek MT6765 SoC
      dt-bindings: clock: mediatek: document clk bindings mipi0a for Mediatek MT6765 SoC
      dt-bindings: clock: mediatek: document clk bindings for Mediatek MT6765 SoC
      CLK: HSDK: CGU: add support for 148.5MHz clock
      CLK: HSDK: CGU: support PLL bypassing
      CLK: HSDK: CGU: check if PLL is bypassed first
      clk: clk-si5341: Add support for the Si5345 series
      ...

commit 9d66e85784f196fb7442193a1d7f3896ed418806
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Fri Apr 3 16:30:40 2020 +0800

    clk: zynqmp: Make zynqmp_clk_get_max_divisor static
    
    Fix sparse warning:
    
    drivers/clk/zynqmp/divider.c:259:5: warning:
     symbol 'zynqmp_clk_get_max_divisor' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lkml.kernel.org/r/20200403083040.37748-1-yuehaibing@huawei.com
    Reviewed-by: Michal Simek <michal.simek@xilinx.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index 79a294488e84..b22ca33e40c0 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -266,7 +266,7 @@ static const struct clk_ops zynqmp_clk_divider_ops = {
  * Return: Maximum divisor of a clock if query data is successful
  *	   U16_MAX in case of query data is not success
  */
-u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)
+static u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)
 {
 	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
 	struct zynqmp_pm_query_data qdata = {0};

commit 2ce7e495dab4647055f6cf300bc66870dc8a7cab
Author: Tejas Patel <tejas.patel@xilinx.com>
Date:   Thu Mar 12 14:31:39 2020 -0700

    clk: zynqmp: Update fraction clock check from custom type flags
    
    Older firmware version sets BIT(13) in clkflag to mark a
    divider as fractional divider. Updated firmware version sets BIT(4)
    in type flags to mark a divider as fractional divider since
    BIT(13) is defined as CLK_DUTY_CYCLE_PARENT in the common clk
    framework flags.
    
    To support both old and new firmware version, consider BIT(13) from
    clkflag and BIT(4) from type_flag to check if divider is fractional
    or not.
    
    To maintain compatibility BIT(13) of clkflag in firmware will not be
    used in future for any purpose and will be marked as unused.
    
    Signed-off-by: Tejas Patel <tejas.patel@xilinx.com>
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Signed-off-by: Jolly Shah <jolly.shah@xilinx.com>
    Link: https://lkml.kernel.org/r/1584048699-24186-3-git-send-email-jolly.shah@xilinx.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index f7b35459ad0b..79a294488e84 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -25,7 +25,8 @@
 #define to_zynqmp_clk_divider(_hw)		\
 	container_of(_hw, struct zynqmp_clk_divider, hw)
 
-#define CLK_FRAC	BIT(13) /* has a fractional parent */
+#define CLK_FRAC		BIT(13) /* has a fractional parent */
+#define CUSTOM_FLAG_CLK_FRAC	BIT(0) /* has a fractional parent in custom type flag */
 
 /**
  * struct zynqmp_clk_divider - adjustable divider clock
@@ -320,7 +321,8 @@ struct clk_hw *zynqmp_clk_register_divider(const char *name,
 	init.num_parents = 1;
 
 	/* struct clk_divider assignments */
-	div->is_frac = !!(nodes->flag & CLK_FRAC);
+	div->is_frac = !!((nodes->flag & CLK_FRAC) |
+			  (nodes->custom_type_flag & CUSTOM_FLAG_CLK_FRAC));
 	div->flags = nodes->type_flag;
 	div->hw.init = &init;
 	div->clk_id = clk_id;

commit b8c1049c68d634a412ed5980ae666ed7c8839305
Author: Tejas Patel <tejas.patel@xilinx.com>
Date:   Mon Mar 2 13:50:41 2020 -0800

    clk: zynqmp: Fix divider2 calculation
    
    zynqmp_get_divider2_val() calculates, divider value of type DIV2 clock,
    considering best possible combination of DIV1 and DIV2.
    
    To find best possible values of DIV1 and DIV2, DIV1's parent rate
    should be consider and not DIV2's parent rate since it would rate of
    div1 clock. Consider a below topology,
    
            out_clk->div2_clk->div1_clk->fixed_parent
    
    where out_clk = (fixed_parent/div1_clk) / div2_clk, so parent clock
    of div1_clk (i.e. out_clk) should be divided by div1_clk and div2_clk.
    
    Existing code divides parent rate of div2_clk's clock instead of
    div1_clk's parent rate, which is wrong.
    
    Fix the same by considering div1's parent clock rate.
    
    Fixes: 4ebd92d2e228 ("clk: zynqmp: Fix divider calculation")
    Signed-off-by: Tejas Patel <tejas.patel@xilinx.com>
    Signed-off-by: Jolly Shah <jolly.shah@xilinx.com>
    Link: https://lkml.kernel.org/r/1583185843-20707-3-git-send-email-jolly.shah@xilinx.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index 5c41ddbee646..f7b35459ad0b 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -111,23 +111,30 @@ static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
 
 static void zynqmp_get_divider2_val(struct clk_hw *hw,
 				    unsigned long rate,
-				    unsigned long parent_rate,
 				    struct zynqmp_clk_divider *divider,
 				    int *bestdiv)
 {
 	int div1;
 	int div2;
 	long error = LONG_MAX;
-	struct clk_hw *parent_hw = clk_hw_get_parent(hw);
-	struct zynqmp_clk_divider *pdivider = to_zynqmp_clk_divider(parent_hw);
+	unsigned long div1_prate;
+	struct clk_hw *div1_parent_hw;
+	struct clk_hw *div2_parent_hw = clk_hw_get_parent(hw);
+	struct zynqmp_clk_divider *pdivider =
+				to_zynqmp_clk_divider(div2_parent_hw);
 
 	if (!pdivider)
 		return;
 
+	div1_parent_hw = clk_hw_get_parent(div2_parent_hw);
+	if (!div1_parent_hw)
+		return;
+
+	div1_prate = clk_hw_get_rate(div1_parent_hw);
 	*bestdiv = 1;
 	for (div1 = 1; div1 <= pdivider->max_div;) {
 		for (div2 = 1; div2 <= divider->max_div;) {
-			long new_error = ((parent_rate / div1) / div2) - rate;
+			long new_error = ((div1_prate / div1) / div2) - rate;
 
 			if (abs(new_error) < abs(error)) {
 				*bestdiv = div2;
@@ -192,7 +199,7 @@ static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
 	 */
 	if (div_type == TYPE_DIV2 &&
 	    (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {
-		zynqmp_get_divider2_val(hw, rate, *prate, divider, &bestdiv);
+		zynqmp_get_divider2_val(hw, rate, divider, &bestdiv);
 	}
 
 	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) && divider->is_frac)

commit 0541e0217ac8daef32650ba8477ff0a55f9a94b1
Author: Rajan Vaja <rajan.vaja@xilinx.com>
Date:   Mon Mar 2 13:50:40 2020 -0800

    clk: zynqmp: Limit bestdiv with maxdiv
    
    Clock divider value should not be greater than maximum divider value.
    So use minimum of best divider or maximum divider value.
    
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Signed-off-by: Jolly Shah <jolly.shah@xilinx.com>
    Link: https://lkml.kernel.org/r/1583185843-20707-2-git-send-email-jolly.shah@xilinx.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index 4be2cc76aa2e..5c41ddbee646 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -197,6 +197,8 @@ static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
 
 	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) && divider->is_frac)
 		bestdiv = rate % *prate ? 1 : bestdiv;
+
+	bestdiv = min_t(u32, bestdiv, divider->max_div);
 	*prate = rate * bestdiv;
 
 	return rate;

commit 0667a8d144bc830d0a752f079c9789735cd4f1f8
Author: Rajan Vaja <rajan.vaja@xilinx.com>
Date:   Fri Apr 24 13:57:50 2020 -0700

    firmware: xilinx: Remove eemi ops for clock_getdivider
    
    Use direct function call instead of using eemi ops for
    clock_getdivider.
    
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Signed-off-by: Jolly Shah <jolly.shah@xilinx.com>
    Link: https://lore.kernel.org/r/1587761887-4279-9-git-send-email-jolly.shah@xilinx.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index 13041cd93968..8eed715707e3 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -83,9 +83,8 @@ static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
 	u32 div_type = divider->div_type;
 	u32 div, value;
 	int ret;
-	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
 
-	ret = eemi_ops->clock_getdivider(clk_id, &div);
+	ret = zynqmp_pm_clock_getdivider(clk_id, &div);
 
 	if (ret)
 		pr_warn_once("%s() get divider failed for %s, ret = %d\n",
@@ -163,11 +162,10 @@ static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
 	u32 div_type = divider->div_type;
 	u32 bestdiv;
 	int ret;
-	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
 
 	/* if read only, just return current value */
 	if (divider->flags & CLK_DIVIDER_READ_ONLY) {
-		ret = eemi_ops->clock_getdivider(clk_id, &bestdiv);
+		ret = zynqmp_pm_clock_getdivider(clk_id, &bestdiv);
 
 		if (ret)
 			pr_warn_once("%s() get divider failed for %s, ret = %d\n",

commit fc9fb8fb985c092f9cf01c7c50269c132efc4d58
Author: Rajan Vaja <rajan.vaja@xilinx.com>
Date:   Fri Apr 24 13:57:49 2020 -0700

    firmware: xilinx: Remove eemi ops for clock_setdivider
    
    Use direct function call instead of using eemi ops for
    clock_setdivider.
    
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Signed-off-by: Jolly Shah <jolly.shah@xilinx.com>
    Link: https://lore.kernel.org/r/1587761887-4279-8-git-send-email-jolly.shah@xilinx.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index e21f4ea421f5..13041cd93968 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -219,7 +219,6 @@ static int zynqmp_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,
 	u32 div_type = divider->div_type;
 	u32 value, div;
 	int ret;
-	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
 
 	value = zynqmp_divider_get_val(parent_rate, rate, divider->flags);
 	if (div_type == TYPE_DIV1) {
@@ -233,7 +232,7 @@ static int zynqmp_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,
 	if (divider->flags & CLK_DIVIDER_POWER_OF_TWO)
 		div = __ffs(div);
 
-	ret = eemi_ops->clock_setdivider(clk_id, div);
+	ret = zynqmp_pm_clock_setdivider(clk_id, div);
 
 	if (ret)
 		pr_warn_once("%s() set divider failed for %s, ret = %d\n",

commit 6366c1bac3149c63752c03ea1c731d461d5349a7
Author: Rajan Vaja <rajan.vaja@xilinx.com>
Date:   Fri Apr 24 13:57:45 2020 -0700

    firmware: xilinx: Remove eemi ops for query_data
    
    Use direct function call for query_data instead of using eemi ops.
    
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Signed-off-by: Jolly Shah <jolly.shah@xilinx.com>
    Link: https://lore.kernel.org/r/1587761887-4279-4-git-send-email-jolly.shah@xilinx.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index 4be2cc76aa2e..e21f4ea421f5 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -258,7 +258,6 @@ static const struct clk_ops zynqmp_clk_divider_ops = {
  */
 u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)
 {
-	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
 	struct zynqmp_pm_query_data qdata = {0};
 	u32 ret_payload[PAYLOAD_ARG_CNT];
 	int ret;
@@ -266,7 +265,7 @@ u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)
 	qdata.qid = PM_QID_CLOCK_GET_MAX_DIVISOR;
 	qdata.arg1 = clk_id;
 	qdata.arg2 = type;
-	ret = eemi_ops->query_data(qdata, ret_payload);
+	ret = zynqmp_pm_query_data(qdata, ret_payload);
 	/*
 	 * To maintain backward compatibility return maximum possible value
 	 * (0xFFFF) if query for max divisor is not successful.

commit 34bbe036170785bd288d8a74573ee8ad7946f4a1
Author: Tejas Patel <tejas.patel@xilinx.com>
Date:   Wed Dec 4 22:35:59 2019 -0800

    clk: zynqmp: Add support for clock with CLK_DIVIDER_POWER_OF_TWO flag
    
    Existing clock divider functions is not checking for
    base of divider. So, if any clock divider is power of 2
    then clock rate calculation will be wrong.
    
    Add support to calculate divider value for the clocks
    with CLK_DIVIDER_POWER_OF_TWO flag.
    
    Signed-off-by: Tejas Patel <tejas.patel@xilinx.com>
    Signed-off-by: Radhey Shyam Pandey <radhey.shyam.pandey@xilinx.com>
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Link: https://lkml.kernel.org/r/1575527759-26452-7-git-send-email-rajan.vaja@xilinx.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index c6af0c454997..4be2cc76aa2e 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -2,7 +2,7 @@
 /*
  * Zynq UltraScale+ MPSoC Divider support
  *
- *  Copyright (C) 2016-2018 Xilinx
+ *  Copyright (C) 2016-2019 Xilinx
  *
  * Adjustable divider clock implementation
  */
@@ -45,9 +45,26 @@ struct zynqmp_clk_divider {
 };
 
 static inline int zynqmp_divider_get_val(unsigned long parent_rate,
-					 unsigned long rate)
+					 unsigned long rate, u16 flags)
 {
-	return DIV_ROUND_CLOSEST(parent_rate, rate);
+	int up, down;
+	unsigned long up_rate, down_rate;
+
+	if (flags & CLK_DIVIDER_POWER_OF_TWO) {
+		up = DIV_ROUND_UP_ULL((u64)parent_rate, rate);
+		down = DIV_ROUND_DOWN_ULL((u64)parent_rate, rate);
+
+		up = __roundup_pow_of_two(up);
+		down = __rounddown_pow_of_two(down);
+
+		up_rate = DIV_ROUND_UP_ULL((u64)parent_rate, up);
+		down_rate = DIV_ROUND_UP_ULL((u64)parent_rate, down);
+
+		return (rate - up_rate) <= (down_rate - rate) ? up : down;
+
+	} else {
+		return DIV_ROUND_CLOSEST(parent_rate, rate);
+	}
 }
 
 /**
@@ -79,6 +96,9 @@ static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
 	else
 		value = div >> 16;
 
+	if (divider->flags & CLK_DIVIDER_POWER_OF_TWO)
+		value = 1 << value;
+
 	if (!value) {
 		WARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),
 		     "%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n",
@@ -157,10 +177,13 @@ static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
 		else
 			bestdiv  = bestdiv >> 16;
 
+		if (divider->flags & CLK_DIVIDER_POWER_OF_TWO)
+			bestdiv = 1 << bestdiv;
+
 		return DIV_ROUND_UP_ULL((u64)*prate, bestdiv);
 	}
 
-	bestdiv = zynqmp_divider_get_val(*prate, rate);
+	bestdiv = zynqmp_divider_get_val(*prate, rate, divider->flags);
 
 	/*
 	 * In case of two divisors, compute best divider values and return
@@ -198,7 +221,7 @@ static int zynqmp_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,
 	int ret;
 	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
 
-	value = zynqmp_divider_get_val(parent_rate, rate);
+	value = zynqmp_divider_get_val(parent_rate, rate, divider->flags);
 	if (div_type == TYPE_DIV1) {
 		div = value & 0xFFFF;
 		div |= 0xffff << 16;
@@ -207,6 +230,9 @@ static int zynqmp_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,
 		div |= value << 16;
 	}
 
+	if (divider->flags & CLK_DIVIDER_POWER_OF_TWO)
+		div = __ffs(div);
+
 	ret = eemi_ops->clock_setdivider(clk_id, div);
 
 	if (ret)

commit 4ebd92d2e228ceb33bafa273fd9cb2b16615cdd4
Author: Rajan Vaja <rajan.vaja@xilinx.com>
Date:   Wed Dec 4 22:35:58 2019 -0800

    clk: zynqmp: Fix divider calculation
    
    zynqmp_clk_divider_round_rate() returns actual divider value
    after calculating from parent rate and desired rate, even though
    that rate is not supported by single divider of hardware. It is
    also possible that such divisor value can be achieved through 2
    different dividers. As, Linux tries to set such divisor value(out
    of range) in single divider set divider is getting failed.
    
    Fix the same by computing best possible combination of two
    divisors which provides more accurate clock rate.
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>
    Signed-off-by: Tejas Patel <tejas.patel@xilinx.com>
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Link: https://lkml.kernel.org/r/1575527759-26452-6-git-send-email-rajan.vaja@xilinx.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index da6903197fc7..c6af0c454997 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -89,6 +89,42 @@ static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
 	return DIV_ROUND_UP_ULL(parent_rate, value);
 }
 
+static void zynqmp_get_divider2_val(struct clk_hw *hw,
+				    unsigned long rate,
+				    unsigned long parent_rate,
+				    struct zynqmp_clk_divider *divider,
+				    int *bestdiv)
+{
+	int div1;
+	int div2;
+	long error = LONG_MAX;
+	struct clk_hw *parent_hw = clk_hw_get_parent(hw);
+	struct zynqmp_clk_divider *pdivider = to_zynqmp_clk_divider(parent_hw);
+
+	if (!pdivider)
+		return;
+
+	*bestdiv = 1;
+	for (div1 = 1; div1 <= pdivider->max_div;) {
+		for (div2 = 1; div2 <= divider->max_div;) {
+			long new_error = ((parent_rate / div1) / div2) - rate;
+
+			if (abs(new_error) < abs(error)) {
+				*bestdiv = div2;
+				error = new_error;
+			}
+			if (divider->flags & CLK_DIVIDER_POWER_OF_TWO)
+				div2 = div2 << 1;
+			else
+				div2++;
+		}
+		if (pdivider->flags & CLK_DIVIDER_POWER_OF_TWO)
+			div1 = div1 << 1;
+		else
+			div1++;
+	}
+}
+
 /**
  * zynqmp_clk_divider_round_rate() - Round rate of divider clock
  * @hw:			handle between common and hardware-specific interfaces
@@ -126,6 +162,16 @@ static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
 
 	bestdiv = zynqmp_divider_get_val(*prate, rate);
 
+	/*
+	 * In case of two divisors, compute best divider values and return
+	 * divider2 value based on compute value. div1 will  be automatically
+	 * set to optimum based on required total divider value.
+	 */
+	if (div_type == TYPE_DIV2 &&
+	    (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {
+		zynqmp_get_divider2_val(hw, rate, *prate, divider, &bestdiv);
+	}
+
 	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) && divider->is_frac)
 		bestdiv = rate % *prate ? 1 : bestdiv;
 	*prate = rate * bestdiv;

commit e942171bbb762977afaa1eb24a312c3bd56386a5
Author: Rajan Vaja <rajan.vaja@xilinx.com>
Date:   Wed Dec 4 22:35:57 2019 -0800

    clk: zynqmp: Add support for get max divider
    
    To achieve best possible rate, maximum limit of divider is required
    while computation. Get maximum supported divisor from firmware. To
    maintain backward compatibility assign maximum possible value(0xFFFF)
    if query for max divisor is not successful.
    
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Link: https://lkml.kernel.org/r/1575527759-26452-5-git-send-email-rajan.vaja@xilinx.com
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    [sboyd@kernel.org: Remove else return and just return]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index d8f5b70d2709..da6903197fc7 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -41,6 +41,7 @@ struct zynqmp_clk_divider {
 	bool is_frac;
 	u32 clk_id;
 	u32 div_type;
+	u16 max_div;
 };
 
 static inline int zynqmp_divider_get_val(unsigned long parent_rate,
@@ -175,6 +176,35 @@ static const struct clk_ops zynqmp_clk_divider_ops = {
 	.set_rate = zynqmp_clk_divider_set_rate,
 };
 
+/**
+ * zynqmp_clk_get_max_divisor() - Get maximum supported divisor from firmware.
+ * @clk_id:		Id of clock
+ * @type:		Divider type
+ *
+ * Return: Maximum divisor of a clock if query data is successful
+ *	   U16_MAX in case of query data is not success
+ */
+u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)
+{
+	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
+	struct zynqmp_pm_query_data qdata = {0};
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+	int ret;
+
+	qdata.qid = PM_QID_CLOCK_GET_MAX_DIVISOR;
+	qdata.arg1 = clk_id;
+	qdata.arg2 = type;
+	ret = eemi_ops->query_data(qdata, ret_payload);
+	/*
+	 * To maintain backward compatibility return maximum possible value
+	 * (0xFFFF) if query for max divisor is not successful.
+	 */
+	if (ret)
+		return U16_MAX;
+
+	return ret_payload[1];
+}
+
 /**
  * zynqmp_clk_register_divider() - Register a divider clock
  * @name:		Name of this clock
@@ -215,6 +245,12 @@ struct clk_hw *zynqmp_clk_register_divider(const char *name,
 	div->clk_id = clk_id;
 	div->div_type = nodes->type;
 
+	/*
+	 * To achieve best possible rate, maximum limit of divider is required
+	 * while computation.
+	 */
+	div->max_div = zynqmp_clk_get_max_divisor(clk_id, nodes->type);
+
 	hw = &div->hw;
 	ret = clk_hw_register(NULL, hw);
 	if (ret) {

commit c06e64407e031e71c67f45f07981510ca4c880a1
Author: Michael Tretter <m.tretter@pengutronix.de>
Date:   Tue Mar 19 11:01:46 2019 +0100

    clk: zynqmp: fix check for fractional clock
    
    The firmware sets BIT(13) in clkflag to mark a divider as fractional
    divider. The clock driver copies the clkflag straight to the flags of
    the common clock framework. In the common clk framework flags, BIT(13)
    is defined as CLK_DUTY_CYCLE_PARENT.
    
    Add a new field to the zynqmp_clk_divider to specify if a divider is a
    fractional devider. Set this field based on the clkflag when registering
    a divider.
    
    At the same time, unset BIT(13) from clkflag when copying the flags to
    the common clk framework flags.
    
    Signed-off-by: Michael Tretter <m.tretter@pengutronix.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index a621c6619abe..d8f5b70d2709 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -31,12 +31,14 @@
  * struct zynqmp_clk_divider - adjustable divider clock
  * @hw:		handle between common and hardware-specific interfaces
  * @flags:	Hardware specific flags
+ * @is_frac:	The divider is a fractional divider
  * @clk_id:	Id of clock
  * @div_type:	divisor type (TYPE_DIV1 or TYPE_DIV2)
  */
 struct zynqmp_clk_divider {
 	struct clk_hw hw;
 	u8 flags;
+	bool is_frac;
 	u32 clk_id;
 	u32 div_type;
 };
@@ -123,8 +125,7 @@ static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
 
 	bestdiv = zynqmp_divider_get_val(*prate, rate);
 
-	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) &&
-	    (divider->flags & CLK_FRAC))
+	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) && divider->is_frac)
 		bestdiv = rate % *prate ? 1 : bestdiv;
 	*prate = rate * bestdiv;
 
@@ -202,11 +203,13 @@ struct clk_hw *zynqmp_clk_register_divider(const char *name,
 
 	init.name = name;
 	init.ops = &zynqmp_clk_divider_ops;
-	init.flags = nodes->flag;
+	/* CLK_FRAC is not defined in the common clk framework */
+	init.flags = nodes->flag & ~CLK_FRAC;
 	init.parent_names = parents;
 	init.num_parents = 1;
 
 	/* struct clk_divider assignments */
+	div->is_frac = !!(nodes->flag & CLK_FRAC);
 	div->flags = nodes->type_flag;
 	div->hw.init = &init;
 	div->clk_id = clk_id;

commit e91158f1be5b157329ab8f21f86728d591c8f747
Author: Michael Tretter <m.tretter@pengutronix.de>
Date:   Tue Mar 19 11:01:45 2019 +0100

    clk: zynqmp: do not export zynqmp_clk_register_* functions
    
    The zynqmp_clk_register_* functions are internal functions of the
    driver. Only clkc.c uses these functions to register these clocks.
    Therefore, there is no need to export these functions.
    
    The gate and pll already don't export their register_* functions.
    
    Signed-off-by: Michael Tretter <m.tretter@pengutronix.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index e146b6fac6b2..a621c6619abe 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -221,4 +221,3 @@ struct clk_hw *zynqmp_clk_register_divider(const char *name,
 
 	return hw;
 }
-EXPORT_SYMBOL_GPL(zynqmp_clk_register_divider);

commit 60d74e011c8e7450846563739a8530f823e5d77a
Author: Rajan Vaja <rajan.vaja@xilinx.com>
Date:   Mon Mar 4 15:27:46 2019 -0800

    drivers: clk: zynqmp: Allow zero divisor value
    
    Zero divider is valid and default for some of ZynqMP
    clocks. Allow zero divisor when CLK_DIVIDER_ALLOW_ZERO
    for the clock is set.
    
    Signed-off-by: Rajan Vaja <rajanv@xilinx.com>
    Signed-off-by: Jolly Shah <jollys@xilinx.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index a371c66e72ef..e146b6fac6b2 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -76,6 +76,13 @@ static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
 	else
 		value = div >> 16;
 
+	if (!value) {
+		WARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),
+		     "%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n",
+		     clk_name);
+		return parent_rate;
+	}
+
 	return DIV_ROUND_UP_ULL(parent_rate, value);
 }
 

commit 3fde0e16d016ecb273f0fa404b5d56b947fc0576
Author: Jolly Shah <jolly.shah@xilinx.com>
Date:   Mon Oct 8 11:21:46 2018 -0700

    drivers: clk: Add ZynqMP clock driver
    
    This patch adds CCF compliant clock driver for ZynqMP.
    Clock driver queries supported clock information from
    firmware and regiters pll and output clocks with CCF.
    
    Signed-off-by: Rajan Vaja <rajan.vaja@xilinx.com>
    Signed-off-by: Tejas Patel <tejasp@xilinx.com>
    Signed-off-by: Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
    Signed-off-by: Jolly Shah <jolly.shah@xilinx.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
new file mode 100644
index 000000000000..a371c66e72ef
--- /dev/null
+++ b/drivers/clk/zynqmp/divider.c
@@ -0,0 +1,217 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Zynq UltraScale+ MPSoC Divider support
+ *
+ *  Copyright (C) 2016-2018 Xilinx
+ *
+ * Adjustable divider clock implementation
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include "clk-zynqmp.h"
+
+/*
+ * DOC: basic adjustable divider clock that cannot gate
+ *
+ * Traits of this clock:
+ * prepare - clk_prepare only ensures that parents are prepared
+ * enable - clk_enable only ensures that parents are enabled
+ * rate - rate is adjustable.  clk->rate = ceiling(parent->rate / divisor)
+ * parent - fixed parent.  No clk_set_parent support
+ */
+
+#define to_zynqmp_clk_divider(_hw)		\
+	container_of(_hw, struct zynqmp_clk_divider, hw)
+
+#define CLK_FRAC	BIT(13) /* has a fractional parent */
+
+/**
+ * struct zynqmp_clk_divider - adjustable divider clock
+ * @hw:		handle between common and hardware-specific interfaces
+ * @flags:	Hardware specific flags
+ * @clk_id:	Id of clock
+ * @div_type:	divisor type (TYPE_DIV1 or TYPE_DIV2)
+ */
+struct zynqmp_clk_divider {
+	struct clk_hw hw;
+	u8 flags;
+	u32 clk_id;
+	u32 div_type;
+};
+
+static inline int zynqmp_divider_get_val(unsigned long parent_rate,
+					 unsigned long rate)
+{
+	return DIV_ROUND_CLOSEST(parent_rate, rate);
+}
+
+/**
+ * zynqmp_clk_divider_recalc_rate() - Recalc rate of divider clock
+ * @hw:			handle between common and hardware-specific interfaces
+ * @parent_rate:	rate of parent clock
+ *
+ * Return: 0 on success else error+reason
+ */
+static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
+						    unsigned long parent_rate)
+{
+	struct zynqmp_clk_divider *divider = to_zynqmp_clk_divider(hw);
+	const char *clk_name = clk_hw_get_name(hw);
+	u32 clk_id = divider->clk_id;
+	u32 div_type = divider->div_type;
+	u32 div, value;
+	int ret;
+	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
+
+	ret = eemi_ops->clock_getdivider(clk_id, &div);
+
+	if (ret)
+		pr_warn_once("%s() get divider failed for %s, ret = %d\n",
+			     __func__, clk_name, ret);
+
+	if (div_type == TYPE_DIV1)
+		value = div & 0xFFFF;
+	else
+		value = div >> 16;
+
+	return DIV_ROUND_UP_ULL(parent_rate, value);
+}
+
+/**
+ * zynqmp_clk_divider_round_rate() - Round rate of divider clock
+ * @hw:			handle between common and hardware-specific interfaces
+ * @rate:		rate of clock to be set
+ * @prate:		rate of parent clock
+ *
+ * Return: 0 on success else error+reason
+ */
+static long zynqmp_clk_divider_round_rate(struct clk_hw *hw,
+					  unsigned long rate,
+					  unsigned long *prate)
+{
+	struct zynqmp_clk_divider *divider = to_zynqmp_clk_divider(hw);
+	const char *clk_name = clk_hw_get_name(hw);
+	u32 clk_id = divider->clk_id;
+	u32 div_type = divider->div_type;
+	u32 bestdiv;
+	int ret;
+	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
+
+	/* if read only, just return current value */
+	if (divider->flags & CLK_DIVIDER_READ_ONLY) {
+		ret = eemi_ops->clock_getdivider(clk_id, &bestdiv);
+
+		if (ret)
+			pr_warn_once("%s() get divider failed for %s, ret = %d\n",
+				     __func__, clk_name, ret);
+		if (div_type == TYPE_DIV1)
+			bestdiv = bestdiv & 0xFFFF;
+		else
+			bestdiv  = bestdiv >> 16;
+
+		return DIV_ROUND_UP_ULL((u64)*prate, bestdiv);
+	}
+
+	bestdiv = zynqmp_divider_get_val(*prate, rate);
+
+	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) &&
+	    (divider->flags & CLK_FRAC))
+		bestdiv = rate % *prate ? 1 : bestdiv;
+	*prate = rate * bestdiv;
+
+	return rate;
+}
+
+/**
+ * zynqmp_clk_divider_set_rate() - Set rate of divider clock
+ * @hw:			handle between common and hardware-specific interfaces
+ * @rate:		rate of clock to be set
+ * @parent_rate:	rate of parent clock
+ *
+ * Return: 0 on success else error+reason
+ */
+static int zynqmp_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	struct zynqmp_clk_divider *divider = to_zynqmp_clk_divider(hw);
+	const char *clk_name = clk_hw_get_name(hw);
+	u32 clk_id = divider->clk_id;
+	u32 div_type = divider->div_type;
+	u32 value, div;
+	int ret;
+	const struct zynqmp_eemi_ops *eemi_ops = zynqmp_pm_get_eemi_ops();
+
+	value = zynqmp_divider_get_val(parent_rate, rate);
+	if (div_type == TYPE_DIV1) {
+		div = value & 0xFFFF;
+		div |= 0xffff << 16;
+	} else {
+		div = 0xffff;
+		div |= value << 16;
+	}
+
+	ret = eemi_ops->clock_setdivider(clk_id, div);
+
+	if (ret)
+		pr_warn_once("%s() set divider failed for %s, ret = %d\n",
+			     __func__, clk_name, ret);
+
+	return ret;
+}
+
+static const struct clk_ops zynqmp_clk_divider_ops = {
+	.recalc_rate = zynqmp_clk_divider_recalc_rate,
+	.round_rate = zynqmp_clk_divider_round_rate,
+	.set_rate = zynqmp_clk_divider_set_rate,
+};
+
+/**
+ * zynqmp_clk_register_divider() - Register a divider clock
+ * @name:		Name of this clock
+ * @clk_id:		Id of clock
+ * @parents:		Name of this clock's parents
+ * @num_parents:	Number of parents
+ * @nodes:		Clock topology node
+ *
+ * Return: clock hardware to registered clock divider
+ */
+struct clk_hw *zynqmp_clk_register_divider(const char *name,
+					   u32 clk_id,
+					   const char * const *parents,
+					   u8 num_parents,
+					   const struct clock_topology *nodes)
+{
+	struct zynqmp_clk_divider *div;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	/* allocate the divider */
+	div = kzalloc(sizeof(*div), GFP_KERNEL);
+	if (!div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &zynqmp_clk_divider_ops;
+	init.flags = nodes->flag;
+	init.parent_names = parents;
+	init.num_parents = 1;
+
+	/* struct clk_divider assignments */
+	div->flags = nodes->type_flag;
+	div->hw.init = &init;
+	div->clk_id = clk_id;
+	div->div_type = nodes->type;
+
+	hw = &div->hw;
+	ret = clk_hw_register(NULL, hw);
+	if (ret) {
+		kfree(div);
+		hw = ERR_PTR(ret);
+	}
+
+	return hw;
+}
+EXPORT_SYMBOL_GPL(zynqmp_clk_register_divider);
