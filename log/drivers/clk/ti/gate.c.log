commit da6a5dda5e843f0a8904c2d171d585ae360f415e
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed May 29 17:39:37 2019 +0800

    clk: ti: Remove unused functions
    
    They are not used any more since
    commit 7558562a70fb ("clk: ti: Drop legacy clk-3xxx-legacy code")
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Suggested-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 504c0e91cdc7..42389558418c 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -131,36 +131,6 @@ static struct clk *_register_gate(struct device *dev, const char *name,
 	return clk;
 }
 
-struct clk_hw *ti_clk_build_component_gate(struct ti_clk_gate *setup)
-{
-	struct clk_hw_omap *gate;
-	struct clk_omap_reg *reg;
-	const struct clk_hw_omap_ops *ops = &clkhwops_wait;
-
-	if (!setup)
-		return NULL;
-
-	gate = kzalloc(sizeof(*gate), GFP_KERNEL);
-	if (!gate)
-		return ERR_PTR(-ENOMEM);
-
-	reg = (struct clk_omap_reg *)&gate->enable_reg;
-	reg->index = setup->module;
-	reg->offset = setup->reg;
-
-	gate->enable_bit = setup->bit_shift;
-
-	if (setup->flags & CLKF_NO_WAIT)
-		ops = NULL;
-
-	if (setup->flags & CLKF_INTERFACE)
-		ops = &clkhwops_iclk_wait;
-
-	gate->ops = ops;
-
-	return &gate->hw;
-}
-
 static void __init _of_ti_gate_clk_setup(struct device_node *node,
 					 const struct clk_ops *ops,
 					 const struct clk_hw_omap_ops *hw_ops)

commit ead478250b950f1f082d4cb57bed3adeacfe53c3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Jan 15 11:15:15 2019 +0200

    clk: ti: generalize the init sequence of clk_hw_omap clocks
    
    Add a generic API for initializing clocks of clk_hw_omap type clocks,
    and convert the whole TI clock driver suite to use this for registering
    the clocks. Also, get rid of the now redundant API for adding the clocks
    to the OMAP HW clocks list; instead this is used directly from the
    register API.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Keerthy <j-keerthy@ti.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 1c78fff5513c..504c0e91cdc7 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -123,7 +123,7 @@ static struct clk *_register_gate(struct device *dev, const char *name,
 
 	init.flags = flags;
 
-	clk = ti_clk_register(NULL, &clk_hw->hw, name);
+	clk = ti_clk_register_omap_hw(NULL, &clk_hw->hw, name);
 
 	if (IS_ERR(clk))
 		kfree(clk_hw);

commit 8a69f1d4707a69faab58d9735c2cb1898140124a
Merge: cc2adbe370f1 a72d785021cb
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Oct 18 15:41:21 2018 -0700

    Merge branch 'clk-ti' into clk-next
    
    * clk-ti:
      clk: ti: Prepare for remove of OF node name
      clk: Clean up suspend/resume coding style
      clk: ti: Add functions to save/restore clk context
      clk: clk: Add clk_gate_restore_context function
      clk: Add functions to save/restore clock context en-masse
      clk: ti: dra7: add new clkctrl data
      clk: ti: dra7xx: rename existing clkctrl data as compat data
      clk: ti: am43xx: add new clkctrl data for am43xx
      clk: ti: am43xx: rename existing clkctrl data as compat data
      clk: ti: am33xx: add new clkctrl data for am33xx
      clk: ti: am33xx: rename existing clkctrl data as compat data
      clk: ti: clkctrl: replace dashes from clkdm name with underscore
      clk: ti: clkctrl: support multiple clkctrl nodes under a cm node
      dt-bindings: clock: dra7xx: add clkctrl indices for new data layout
      dt-bindings: clock: am43xx: add clkctrl indices for new data layout
      dt-bindings: clock: am33xx: add clkctrl indices for new data layout

commit d6e7bbc148f9fbec8a0117b0d0f420c9710e6d81
Author: Russ Dill <Russ.Dill@ti.com>
Date:   Tue Sep 4 12:19:37 2018 +0530

    clk: ti: Add functions to save/restore clk context
    
    SoCs like AM43XX lose clock registers context during RTC-only
    suspend. Hence add functions to save/restore the clock registers
    context.
    
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 935b2de5fb88..cf9e9f5fc007 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -33,6 +33,7 @@ static const struct clk_ops omap_gate_clkdm_clk_ops = {
 	.init		= &omap2_init_clk_clkdm,
 	.enable		= &omap2_clkops_enable_clkdm,
 	.disable	= &omap2_clkops_disable_clkdm,
+	.restore_context = clk_gate_restore_context,
 };
 
 const struct clk_ops omap_gate_clk_ops = {
@@ -40,6 +41,7 @@ const struct clk_ops omap_gate_clk_ops = {
 	.enable		= &omap2_dflt_clk_enable,
 	.disable	= &omap2_dflt_clk_disable,
 	.is_enabled	= &omap2_dflt_clk_is_enabled,
+	.restore_context = clk_gate_restore_context,
 };
 
 static const struct clk_ops omap_gate_clk_hsdiv_restore_ops = {
@@ -47,6 +49,7 @@ static const struct clk_ops omap_gate_clk_hsdiv_restore_ops = {
 	.enable		= &omap36xx_gate_clk_enable_with_hsdiv_restore,
 	.disable	= &omap2_dflt_clk_disable,
 	.is_enabled	= &omap2_dflt_clk_is_enabled,
+	.restore_context = clk_gate_restore_context,
 };
 
 /**

commit e665f029a283aff4f36f0c5388f7c708be67470e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Aug 28 10:44:29 2018 -0500

    clk: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 935b2de5fb88..d4b5638e8b99 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -179,7 +179,7 @@ static void __init _of_ti_gate_clk_setup(struct device_node *node,
 	}
 
 	if (of_clk_get_parent_count(node) != 1) {
-		pr_err("%s must have 1 parent\n", node->name);
+		pr_err("%pOFn must have 1 parent\n", node);
 		return;
 	}
 

commit 7558562a70fbd6b3fa746fa33c76c9333aa0bb32
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 14 08:32:06 2017 -0800

    clk: ti: Drop legacy clk-3xxx-legacy code
    
    We have now had omap3 booting in device tree only mode for a while
    and all this code is unused.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 7151ec3a1b07..935b2de5fb88 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -128,53 +128,6 @@ static struct clk *_register_gate(struct device *dev, const char *name,
 	return clk;
 }
 
-#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_ATAGS)
-struct clk *ti_clk_register_gate(struct ti_clk *setup)
-{
-	const struct clk_ops *ops = &omap_gate_clk_ops;
-	const struct clk_hw_omap_ops *hw_ops = NULL;
-	struct clk_omap_reg reg;
-	u32 flags = 0;
-	u8 clk_gate_flags = 0;
-	struct ti_clk_gate *gate;
-
-	gate = setup->data;
-
-	if (gate->flags & CLKF_INTERFACE)
-		return ti_clk_register_interface(setup);
-
-	if (gate->flags & CLKF_SET_RATE_PARENT)
-		flags |= CLK_SET_RATE_PARENT;
-
-	if (gate->flags & CLKF_SET_BIT_TO_DISABLE)
-		clk_gate_flags |= INVERT_ENABLE;
-
-	if (gate->flags & CLKF_HSDIV) {
-		ops = &omap_gate_clk_hsdiv_restore_ops;
-		hw_ops = &clkhwops_wait;
-	}
-
-	if (gate->flags & CLKF_DSS)
-		hw_ops = &clkhwops_omap3430es2_dss_usbhost_wait;
-
-	if (gate->flags & CLKF_WAIT)
-		hw_ops = &clkhwops_wait;
-
-	if (gate->flags & CLKF_CLKDM)
-		ops = &omap_gate_clkdm_clk_ops;
-
-	if (gate->flags & CLKF_AM35XX)
-		hw_ops = &clkhwops_am35xx_ipss_module_wait;
-
-	reg.index = gate->module;
-	reg.offset = gate->reg;
-	reg.ptr = NULL;
-
-	return _register_gate(NULL, setup->name, gate->parent, flags,
-			      &reg, gate->bit_shift,
-			      clk_gate_flags, ops, hw_ops);
-}
-
 struct clk_hw *ti_clk_build_component_gate(struct ti_clk_gate *setup)
 {
 	struct clk_hw_omap *gate;
@@ -204,7 +157,6 @@ struct clk_hw *ti_clk_build_component_gate(struct ti_clk_gate *setup)
 
 	return &gate->hw;
 }
-#endif
 
 static void __init _of_ti_gate_clk_setup(struct device_node *node,
 					 const struct clk_ops *ops,

commit 6c0afb503937a12a8d20a805fcf263e31afa9871
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 9 11:24:37 2017 +0200

    clk: ti: convert to use proper register definition for all accesses
    
    Currently, TI clock driver uses an encapsulated struct that is cast into
    a void pointer to store all register addresses. This can be considered
    as rather nasty hackery, and prevents from expanding the register
    address field also. Instead, replace all the code to use proper struct
    in place for this, which contains all the previously used data.
    
    This patch is rather large as it is touching multiple files, but this
    can't be split up as we need to avoid any boot breakage.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 77f0920e12f1..7151ec3a1b07 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -76,15 +76,15 @@ static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *hw)
 
 	/* Restore the dividers */
 	if (!ret) {
-		orig_v = ti_clk_ll_ops->clk_readl(parent->reg);
+		orig_v = ti_clk_ll_ops->clk_readl(&parent->reg);
 		dummy_v = orig_v;
 
 		/* Write any other value different from the Read value */
 		dummy_v ^= (1 << parent->shift);
-		ti_clk_ll_ops->clk_writel(dummy_v, parent->reg);
+		ti_clk_ll_ops->clk_writel(dummy_v, &parent->reg);
 
 		/* Write the original divider */
-		ti_clk_ll_ops->clk_writel(orig_v, parent->reg);
+		ti_clk_ll_ops->clk_writel(orig_v, &parent->reg);
 	}
 
 	return ret;
@@ -92,7 +92,7 @@ static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *hw)
 
 static struct clk *_register_gate(struct device *dev, const char *name,
 				  const char *parent_name, unsigned long flags,
-				  void __iomem *reg, u8 bit_idx,
+				  struct clk_omap_reg *reg, u8 bit_idx,
 				  u8 clk_gate_flags, const struct clk_ops *ops,
 				  const struct clk_hw_omap_ops *hw_ops)
 {
@@ -109,7 +109,7 @@ static struct clk *_register_gate(struct device *dev, const char *name,
 	init.name = name;
 	init.ops = ops;
 
-	clk_hw->enable_reg = reg;
+	memcpy(&clk_hw->enable_reg, reg, sizeof(*reg));
 	clk_hw->enable_bit = bit_idx;
 	clk_hw->ops = hw_ops;
 
@@ -133,8 +133,7 @@ struct clk *ti_clk_register_gate(struct ti_clk *setup)
 {
 	const struct clk_ops *ops = &omap_gate_clk_ops;
 	const struct clk_hw_omap_ops *hw_ops = NULL;
-	u32 reg;
-	struct clk_omap_reg *reg_setup;
+	struct clk_omap_reg reg;
 	u32 flags = 0;
 	u8 clk_gate_flags = 0;
 	struct ti_clk_gate *gate;
@@ -144,8 +143,6 @@ struct clk *ti_clk_register_gate(struct ti_clk *setup)
 	if (gate->flags & CLKF_INTERFACE)
 		return ti_clk_register_interface(setup);
 
-	reg_setup = (struct clk_omap_reg *)&reg;
-
 	if (gate->flags & CLKF_SET_RATE_PARENT)
 		flags |= CLK_SET_RATE_PARENT;
 
@@ -169,11 +166,12 @@ struct clk *ti_clk_register_gate(struct ti_clk *setup)
 	if (gate->flags & CLKF_AM35XX)
 		hw_ops = &clkhwops_am35xx_ipss_module_wait;
 
-	reg_setup->index = gate->module;
-	reg_setup->offset = gate->reg;
+	reg.index = gate->module;
+	reg.offset = gate->reg;
+	reg.ptr = NULL;
 
 	return _register_gate(NULL, setup->name, gate->parent, flags,
-			      (void __iomem *)reg, gate->bit_shift,
+			      &reg, gate->bit_shift,
 			      clk_gate_flags, ops, hw_ops);
 }
 
@@ -214,15 +212,14 @@ static void __init _of_ti_gate_clk_setup(struct device_node *node,
 {
 	struct clk *clk;
 	const char *parent_name;
-	void __iomem *reg = NULL;
+	struct clk_omap_reg reg;
 	u8 enable_bit = 0;
 	u32 val;
 	u32 flags = 0;
 	u8 clk_gate_flags = 0;
 
 	if (ops != &omap_gate_clkdm_clk_ops) {
-		reg = ti_clk_get_reg_addr(node, 0);
-		if (IS_ERR(reg))
+		if (ti_clk_get_reg_addr(node, 0, &reg))
 			return;
 
 		if (!of_property_read_u32(node, "ti,bit-shift", &val))
@@ -242,7 +239,7 @@ static void __init _of_ti_gate_clk_setup(struct device_node *node,
 	if (of_property_read_bool(node, "ti,set-bit-to-disable"))
 		clk_gate_flags |= INVERT_ENABLE;
 
-	clk = _register_gate(NULL, node->name, parent_name, flags, reg,
+	clk = _register_gate(NULL, node->name, parent_name, flags, &reg,
 			     enable_bit, clk_gate_flags, ops, hw_ops);
 
 	if (!IS_ERR(clk))
@@ -260,8 +257,7 @@ _of_ti_composite_gate_clk_setup(struct device_node *node,
 	if (!gate)
 		return;
 
-	gate->enable_reg = ti_clk_get_reg_addr(node, 0);
-	if (IS_ERR(gate->enable_reg))
+	if (ti_clk_get_reg_addr(node, 0, &gate->enable_reg))
 		goto cleanup;
 
 	of_property_read_u32(node, "ti,bit-shift", &val);

commit 9a00fa6843953cff1e3420002a454a61edfdd5f0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 9 11:10:19 2017 +0200

    clk: ti: gate: export gate_clk_ops locally
    
    These are going to be used by the clkctrl support that will be introduced
    later.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index a65f0827f605..77f0920e12f1 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -35,7 +35,7 @@ static const struct clk_ops omap_gate_clkdm_clk_ops = {
 	.disable	= &omap2_clkops_disable_clkdm,
 };
 
-static const struct clk_ops omap_gate_clk_ops = {
+const struct clk_ops omap_gate_clk_ops = {
 	.init		= &omap2_init_clk_clkdm,
 	.enable		= &omap2_dflt_clk_enable,
 	.disable	= &omap2_dflt_clk_disable,

commit 6dbde94756adb14fe1e3516249cb8eee725bd5e0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 9 14:45:45 2017 +0200

    clk: ti: divider: convert TI divider clock to use its own data representation
    
    Instead of using the generic clock driver data struct, use one internal
    for the TI clock driver itself. This allows modifying the register access
    parts in subsequent patch.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 5ff62e2c63d0..a65f0827f605 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -62,7 +62,7 @@ static const struct clk_ops omap_gate_clk_hsdiv_restore_ops = {
  */
 static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *hw)
 {
-	struct clk_divider *parent;
+	struct clk_omap_divider *parent;
 	struct clk_hw *parent_hw;
 	u32 dummy_v, orig_v;
 	int ret;
@@ -72,7 +72,7 @@ static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *hw)
 
 	/* Parent is the x2 node, get parent of parent for the m2 div */
 	parent_hw = clk_hw_get_parent(clk_hw_get_parent(hw));
-	parent = to_clk_divider(parent_hw);
+	parent = to_clk_omap_divider(parent_hw);
 
 	/* Restore the dividers */
 	if (!ret) {

commit c91f07801f144920f8467486a1e36e42ed9d9ff2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Jan 30 16:01:36 2017 +0200

    clk: ti: drop unnecessary MEMMAP_ADDRESSING flag
    
    This has been superceded by the usage of ti_clk_ll_ops for now.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index b3291dbca5ed..5ff62e2c63d0 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -113,7 +113,7 @@ static struct clk *_register_gate(struct device *dev, const char *name,
 	clk_hw->enable_bit = bit_idx;
 	clk_hw->ops = hw_ops;
 
-	clk_hw->flags = MEMMAP_ADDRESSING | clk_gate_flags;
+	clk_hw->flags = clk_gate_flags;
 
 	init.parent_names = &parent_name;
 	init.num_parents = 1;
@@ -203,7 +203,6 @@ struct clk_hw *ti_clk_build_component_gate(struct ti_clk_gate *setup)
 		ops = &clkhwops_iclk_wait;
 
 	gate->ops = ops;
-	gate->flags = MEMMAP_ADDRESSING;
 
 	return &gate->hw;
 }
@@ -269,7 +268,6 @@ _of_ti_composite_gate_clk_setup(struct device_node *node,
 
 	gate->enable_bit = val;
 	gate->ops = hw_ops;
-	gate->flags = MEMMAP_ADDRESSING;
 
 	if (!ti_clk_add_component(node, &gate->hw, CLK_COMPONENT_TYPE_GATE))
 		return;

commit 1ae79c46cf195ea39407bd5a2b234304d537980f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 29 12:06:40 2016 +0300

    clk: ti: use automatic clock alias generation framework
    
    Generate clock aliases automatically for all TI clock drivers.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index bc05f276f32b..b3291dbca5ed 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -120,7 +120,7 @@ static struct clk *_register_gate(struct device *dev, const char *name,
 
 	init.flags = flags;
 
-	clk = clk_register(NULL, &clk_hw->hw);
+	clk = ti_clk_register(NULL, &clk_hw->hw, name);
 
 	if (IS_ERR(clk))
 		kfree(clk_hw);

commit 5fd9c05c846db98319e75496612da24435cee208
Author: Geliang Tang <geliangtang@163.com>
Date:   Fri Jan 8 23:51:46 2016 +0800

    clk: move the common clock's to_clk_*(_hw) macros to clk-provider.h
    
    to_clk_*(_hw) macros have been repeatedly defined in many places.
    This patch moves all the to_clk_*(_hw) definitions in the common
    clock framework to public header clk-provider.h, and drop the local
    definitions.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 5429d3534363..bc05f276f32b 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -24,8 +24,6 @@
 
 #include "clock.h"
 
-#define to_clk_divider(_hw) container_of(_hw, struct clk_divider, hw)
-
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 

commit a53ad8ef3dccb0c5482c60a3f6b8c0cbd498efe5
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 30 17:20:57 2015 -0700

    clk: ti: Convert to clk_hw based provider APIs
    
    We're removing struct clk from the clk provider API, so switch
    this code to using the clk_hw based provider APIs.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 0c6fdfcd5f93..5429d3534363 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -62,7 +62,7 @@ static const struct clk_ops omap_gate_clk_hsdiv_restore_ops = {
  * (Any other value different from the Read value) to the
  * corresponding CM_CLKSEL register will refresh the dividers.
  */
-static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *clk)
+static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *hw)
 {
 	struct clk_divider *parent;
 	struct clk_hw *parent_hw;
@@ -70,10 +70,10 @@ static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *clk)
 	int ret;
 
 	/* Clear PWRDN bit of HSDIVIDER */
-	ret = omap2_dflt_clk_enable(clk);
+	ret = omap2_dflt_clk_enable(hw);
 
 	/* Parent is the x2 node, get parent of parent for the m2 div */
-	parent_hw = __clk_get_hw(__clk_get_parent(__clk_get_parent(clk->clk)));
+	parent_hw = clk_hw_get_parent(clk_hw_get_parent(hw));
 	parent = to_clk_divider(parent_hw);
 
 	/* Restore the dividers */

commit c807dbedb5e5adbd4e1e2d07574d230df924a5a7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Feb 23 21:06:08 2015 +0200

    clk: ti: fix ti_clk_get_reg_addr error handling
    
    There is a case where NULL can be a valid return value for
    ti_clk_get_reg_addr, specifically the case where both the provider index
    and register offsets are zero. In this case, the current error checking
    against a NULL pointer will fail. Thus, change the API to return a
    ERR_PTR value in an error case, and change all the users of this API to
    check against IS_ERR instead.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index d493307b73f4..0c6fdfcd5f93 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -225,7 +225,7 @@ static void __init _of_ti_gate_clk_setup(struct device_node *node,
 
 	if (ops != &omap_gate_clkdm_clk_ops) {
 		reg = ti_clk_get_reg_addr(node, 0);
-		if (!reg)
+		if (IS_ERR(reg))
 			return;
 
 		if (!of_property_read_u32(node, "ti,bit-shift", &val))
@@ -264,7 +264,7 @@ _of_ti_composite_gate_clk_setup(struct device_node *node,
 		return;
 
 	gate->enable_reg = ti_clk_get_reg_addr(node, 0);
-	if (!gate->enable_reg)
+	if (IS_ERR(gate->enable_reg))
 		goto cleanup;
 
 	of_property_read_u32(node, "ti,bit-shift", &val);

commit 6793a30a0646d2cc269e66782ca30c6025c92e1f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Feb 3 17:59:32 2015 +0100

    clk: omap: compile legacy omap3 clocks conditionally
    
    The 'ARM: OMAP3: legacy clock data move under clk driver' patch series
    causes build errors when CONFIG_OMAP3 is not set:
    
    drivers/clk/ti/dpll.c: In function 'ti_clk_register_dpll':
    drivers/clk/ti/dpll.c:199:31: error: 'omap3_dpll_ck_ops' undeclared (first use in this function)
      const struct clk_ops *ops = &omap3_dpll_ck_ops;
                                   ^
    drivers/clk/ti/dpll.c:199:31: note: each undeclared identifier is reported only once for each function it appears in
    drivers/clk/ti/dpll.c:259:10: error: 'omap3_dpll_per_ck_ops' undeclared (first use in this function)
       ops = &omap3_dpll_per_ck_ops;
              ^
    
    drivers/built-in.o: In function `ti_clk_register_gate':
    drivers/clk/ti/gate.c:179: undefined reference to `clkhwops_omap3430es2_dss_usbhost_wait'
    drivers/clk/ti/gate.c:179: undefined reference to `clkhwops_am35xx_ipss_module_wait'
    -in.o: In function `ti_clk_register_interface':
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_hsotgusb_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_dss_usbhost_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_ssi_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_am35xx_ipss_wait'
    drivers/built-in.o: In function `ti_clk_register_composite':
    :(.text+0x3da768): undefined reference to `ti_clk_build_component_gate'
    
    In order to fix that problem, this patch makes the omap3 legacy code
    compiled only when both CONFIG_OMAP3 and CONFIG_ATAGS are set.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index d4f6cb20e16e..d493307b73f4 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -130,6 +130,7 @@ static struct clk *_register_gate(struct device *dev, const char *name,
 	return clk;
 }
 
+#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_ATAGS)
 struct clk *ti_clk_register_gate(struct ti_clk *setup)
 {
 	const struct clk_ops *ops = &omap_gate_clk_ops;
@@ -208,6 +209,7 @@ struct clk_hw *ti_clk_build_component_gate(struct ti_clk_gate *setup)
 
 	return &gate->hw;
 }
+#endif
 
 static void __init _of_ti_gate_clk_setup(struct device_node *node,
 					 const struct clk_ops *ops,

commit 06524fa4289797deb9a66c1a3e681052eed0d83d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:49 2014 +0200

    clk: ti: interface: add support for legacy interface clock init
    
    Legacy clock data is initialized slightly differently compared to
    DT clocks, thus add support for this. The interface clock descriptor
    itself is overloading the gate clock descriptor, thus it needs to
    be called from the gate setup.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index ff3380ea3861..d4f6cb20e16e 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -142,6 +142,9 @@ struct clk *ti_clk_register_gate(struct ti_clk *setup)
 
 	gate = setup->data;
 
+	if (gate->flags & CLKF_INTERFACE)
+		return ti_clk_register_interface(setup);
+
 	reg_setup = (struct clk_omap_reg *)&reg;
 
 	if (gate->flags & CLKF_SET_RATE_PARENT)

commit f187616b36edafff5a18d2b66fe7eed3bbb38bf0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:48 2014 +0200

    clk: ti: gate: add support for legacy gate init
    
    Legacy clock data is initialialized slightly differently compared to
    DT clocks, thus add support for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index b326d2797feb..ff3380ea3861 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -22,6 +22,8 @@
 #include <linux/of_address.h>
 #include <linux/clk/ti.h>
 
+#include "clock.h"
+
 #define to_clk_divider(_hw) container_of(_hw, struct clk_divider, hw)
 
 #undef pr_fmt
@@ -90,63 +92,159 @@ static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *clk)
 	return ret;
 }
 
-static void __init _of_ti_gate_clk_setup(struct device_node *node,
-					 const struct clk_ops *ops,
-					 const struct clk_hw_omap_ops *hw_ops)
+static struct clk *_register_gate(struct device *dev, const char *name,
+				  const char *parent_name, unsigned long flags,
+				  void __iomem *reg, u8 bit_idx,
+				  u8 clk_gate_flags, const struct clk_ops *ops,
+				  const struct clk_hw_omap_ops *hw_ops)
 {
-	struct clk *clk;
 	struct clk_init_data init = { NULL };
 	struct clk_hw_omap *clk_hw;
-	const char *clk_name = node->name;
-	const char *parent_name;
-	u32 val;
+	struct clk *clk;
 
 	clk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);
 	if (!clk_hw)
-		return;
+		return ERR_PTR(-ENOMEM);
 
 	clk_hw->hw.init = &init;
 
-	init.name = clk_name;
+	init.name = name;
 	init.ops = ops;
 
-	if (ops != &omap_gate_clkdm_clk_ops) {
-		clk_hw->enable_reg = ti_clk_get_reg_addr(node, 0);
-		if (!clk_hw->enable_reg)
-			goto cleanup;
+	clk_hw->enable_reg = reg;
+	clk_hw->enable_bit = bit_idx;
+	clk_hw->ops = hw_ops;
 
-		if (!of_property_read_u32(node, "ti,bit-shift", &val))
-			clk_hw->enable_bit = val;
+	clk_hw->flags = MEMMAP_ADDRESSING | clk_gate_flags;
+
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	init.flags = flags;
+
+	clk = clk_register(NULL, &clk_hw->hw);
+
+	if (IS_ERR(clk))
+		kfree(clk_hw);
+
+	return clk;
+}
+
+struct clk *ti_clk_register_gate(struct ti_clk *setup)
+{
+	const struct clk_ops *ops = &omap_gate_clk_ops;
+	const struct clk_hw_omap_ops *hw_ops = NULL;
+	u32 reg;
+	struct clk_omap_reg *reg_setup;
+	u32 flags = 0;
+	u8 clk_gate_flags = 0;
+	struct ti_clk_gate *gate;
+
+	gate = setup->data;
+
+	reg_setup = (struct clk_omap_reg *)&reg;
+
+	if (gate->flags & CLKF_SET_RATE_PARENT)
+		flags |= CLK_SET_RATE_PARENT;
+
+	if (gate->flags & CLKF_SET_BIT_TO_DISABLE)
+		clk_gate_flags |= INVERT_ENABLE;
+
+	if (gate->flags & CLKF_HSDIV) {
+		ops = &omap_gate_clk_hsdiv_restore_ops;
+		hw_ops = &clkhwops_wait;
 	}
 
-	clk_hw->ops = hw_ops;
+	if (gate->flags & CLKF_DSS)
+		hw_ops = &clkhwops_omap3430es2_dss_usbhost_wait;
+
+	if (gate->flags & CLKF_WAIT)
+		hw_ops = &clkhwops_wait;
+
+	if (gate->flags & CLKF_CLKDM)
+		ops = &omap_gate_clkdm_clk_ops;
+
+	if (gate->flags & CLKF_AM35XX)
+		hw_ops = &clkhwops_am35xx_ipss_module_wait;
 
-	clk_hw->flags = MEMMAP_ADDRESSING;
+	reg_setup->index = gate->module;
+	reg_setup->offset = gate->reg;
+
+	return _register_gate(NULL, setup->name, gate->parent, flags,
+			      (void __iomem *)reg, gate->bit_shift,
+			      clk_gate_flags, ops, hw_ops);
+}
+
+struct clk_hw *ti_clk_build_component_gate(struct ti_clk_gate *setup)
+{
+	struct clk_hw_omap *gate;
+	struct clk_omap_reg *reg;
+	const struct clk_hw_omap_ops *ops = &clkhwops_wait;
+
+	if (!setup)
+		return NULL;
+
+	gate = kzalloc(sizeof(*gate), GFP_KERNEL);
+	if (!gate)
+		return ERR_PTR(-ENOMEM);
+
+	reg = (struct clk_omap_reg *)&gate->enable_reg;
+	reg->index = setup->module;
+	reg->offset = setup->reg;
+
+	gate->enable_bit = setup->bit_shift;
+
+	if (setup->flags & CLKF_NO_WAIT)
+		ops = NULL;
+
+	if (setup->flags & CLKF_INTERFACE)
+		ops = &clkhwops_iclk_wait;
+
+	gate->ops = ops;
+	gate->flags = MEMMAP_ADDRESSING;
+
+	return &gate->hw;
+}
+
+static void __init _of_ti_gate_clk_setup(struct device_node *node,
+					 const struct clk_ops *ops,
+					 const struct clk_hw_omap_ops *hw_ops)
+{
+	struct clk *clk;
+	const char *parent_name;
+	void __iomem *reg = NULL;
+	u8 enable_bit = 0;
+	u32 val;
+	u32 flags = 0;
+	u8 clk_gate_flags = 0;
+
+	if (ops != &omap_gate_clkdm_clk_ops) {
+		reg = ti_clk_get_reg_addr(node, 0);
+		if (!reg)
+			return;
+
+		if (!of_property_read_u32(node, "ti,bit-shift", &val))
+			enable_bit = val;
+	}
 
 	if (of_clk_get_parent_count(node) != 1) {
-		pr_err("%s must have 1 parent\n", clk_name);
-		goto cleanup;
+		pr_err("%s must have 1 parent\n", node->name);
+		return;
 	}
 
 	parent_name = of_clk_get_parent_name(node, 0);
-	init.parent_names = &parent_name;
-	init.num_parents = 1;
 
 	if (of_property_read_bool(node, "ti,set-rate-parent"))
-		init.flags |= CLK_SET_RATE_PARENT;
+		flags |= CLK_SET_RATE_PARENT;
 
 	if (of_property_read_bool(node, "ti,set-bit-to-disable"))
-		clk_hw->flags |= INVERT_ENABLE;
+		clk_gate_flags |= INVERT_ENABLE;
 
-	clk = clk_register(NULL, &clk_hw->hw);
+	clk = _register_gate(NULL, node->name, parent_name, flags, reg,
+			     enable_bit, clk_gate_flags, ops, hw_ops);
 
-	if (!IS_ERR(clk)) {
+	if (!IS_ERR(clk))
 		of_clk_add_provider(node, of_clk_src_simple_get, clk);
-		return;
-	}
-
-cleanup:
-	kfree(clk_hw);
 }
 
 static void __init

commit 3f6eec9969d24f91a3909d51e86e007ca5efd4c4
Merge: 963649d735c8 7e148070001a
Author: Mike Turquette <mturquette@linaro.org>
Date:   Tue Jun 10 16:53:25 2014 -0700

    Merge branch 'for-v3.16/ti-clk-drv' of github.com:t-kristo/linux-pm into clk-next

commit b3654d703de2ddf5651d2fa959879d586e685376
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Mar 5 10:03:38 2014 +0200

    CLK: TI: gate: add composite interface clock to OMAP2 only build
    
    Composite interface clock is needed by OMAP2, but it was only built
    in for OMAP3. Fixed the conditional build flag checks for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 3e2999d11d15..474c171d352c 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -185,7 +185,7 @@ of_ti_composite_no_wait_gate_clk_setup(struct device_node *node)
 CLK_OF_DECLARE(ti_composite_no_wait_gate_clk, "ti,composite-no-wait-gate-clock",
 	       of_ti_composite_no_wait_gate_clk_setup);
 
-#ifdef CONFIG_ARCH_OMAP3
+#if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)
 static void __init of_ti_composite_interface_clk_setup(struct device_node *node)
 {
 	_of_ti_composite_gate_clk_setup(node, &clkhwops_iclk_wait);

commit 826d8958419ae924ae2af12d214ee599ee713e91
Author: Rob Herring <robh@kernel.org>
Date:   Mon May 12 11:41:19 2014 -0500

    clk: ti: add missing semi-colon on CLK_OF_DECLARE
    
    With common OF_DECLARE macros, a semi-colon will be required for
    CLK_OF_DECLARE. Add the missing semi-colon to ti,gate-clock.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
index 3e2999d11d15..58734817d502 100644
--- a/drivers/clk/ti/gate.c
+++ b/drivers/clk/ti/gate.c
@@ -221,7 +221,7 @@ static void __init of_ti_gate_clk_setup(struct device_node *node)
 {
 	_of_ti_gate_clk_setup(node, &omap_gate_clk_ops, NULL);
 }
-CLK_OF_DECLARE(ti_gate_clk, "ti,gate-clock", of_ti_gate_clk_setup)
+CLK_OF_DECLARE(ti_gate_clk, "ti,gate-clock", of_ti_gate_clk_setup);
 
 static void __init of_ti_wait_gate_clk_setup(struct device_node *node)
 {

commit f60b1ea5ea7ab1aee34a5ba55520b84b6e6d482e
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Jun 18 18:55:59 2013 +0300

    CLK: TI: add support for gate clock
    
    This patch adds support for TI specific gate clocks. These behave as basic
    gate-clock, but have different ops / hw-ops for controlling the actual
    gate, for example waiting until the clock is ready. Several sub-types
    are supported:
    - ti,gate-clock: basic gate clock with default ops/hwops
    - ti,clkdm-gate-clock: clockdomain level gate control
    - ti,dss-gate-clock: gate clock with DSS specific hardware handling
    - ti,am35xx-gate-clock: gate clock with AM35xx specific hardware handling
    - ti,hsdiv-gate-clock: gate clock with OMAP36xx hardware errata handling
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/gate.c b/drivers/clk/ti/gate.c
new file mode 100644
index 000000000000..3e2999d11d15
--- /dev/null
+++ b/drivers/clk/ti/gate.c
@@ -0,0 +1,249 @@
+/*
+ * OMAP gate clock support
+ *
+ * Copyright (C) 2013 Texas Instruments, Inc.
+ *
+ * Tero Kristo <t-kristo@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/clk/ti.h>
+
+#define to_clk_divider(_hw) container_of(_hw, struct clk_divider, hw)
+
+#undef pr_fmt
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *clk);
+
+static const struct clk_ops omap_gate_clkdm_clk_ops = {
+	.init		= &omap2_init_clk_clkdm,
+	.enable		= &omap2_clkops_enable_clkdm,
+	.disable	= &omap2_clkops_disable_clkdm,
+};
+
+static const struct clk_ops omap_gate_clk_ops = {
+	.init		= &omap2_init_clk_clkdm,
+	.enable		= &omap2_dflt_clk_enable,
+	.disable	= &omap2_dflt_clk_disable,
+	.is_enabled	= &omap2_dflt_clk_is_enabled,
+};
+
+static const struct clk_ops omap_gate_clk_hsdiv_restore_ops = {
+	.init		= &omap2_init_clk_clkdm,
+	.enable		= &omap36xx_gate_clk_enable_with_hsdiv_restore,
+	.disable	= &omap2_dflt_clk_disable,
+	.is_enabled	= &omap2_dflt_clk_is_enabled,
+};
+
+/**
+ * omap36xx_gate_clk_enable_with_hsdiv_restore - enable clocks suffering
+ *         from HSDivider PWRDN problem Implements Errata ID: i556.
+ * @clk: DPLL output struct clk
+ *
+ * 3630 only: dpll3_m3_ck, dpll4_m2_ck, dpll4_m3_ck, dpll4_m4_ck,
+ * dpll4_m5_ck & dpll4_m6_ck dividers gets loaded with reset
+ * valueafter their respective PWRDN bits are set.  Any dummy write
+ * (Any other value different from the Read value) to the
+ * corresponding CM_CLKSEL register will refresh the dividers.
+ */
+static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *clk)
+{
+	struct clk_divider *parent;
+	struct clk_hw *parent_hw;
+	u32 dummy_v, orig_v;
+	int ret;
+
+	/* Clear PWRDN bit of HSDIVIDER */
+	ret = omap2_dflt_clk_enable(clk);
+
+	/* Parent is the x2 node, get parent of parent for the m2 div */
+	parent_hw = __clk_get_hw(__clk_get_parent(__clk_get_parent(clk->clk)));
+	parent = to_clk_divider(parent_hw);
+
+	/* Restore the dividers */
+	if (!ret) {
+		orig_v = ti_clk_ll_ops->clk_readl(parent->reg);
+		dummy_v = orig_v;
+
+		/* Write any other value different from the Read value */
+		dummy_v ^= (1 << parent->shift);
+		ti_clk_ll_ops->clk_writel(dummy_v, parent->reg);
+
+		/* Write the original divider */
+		ti_clk_ll_ops->clk_writel(orig_v, parent->reg);
+	}
+
+	return ret;
+}
+
+static void __init _of_ti_gate_clk_setup(struct device_node *node,
+					 const struct clk_ops *ops,
+					 const struct clk_hw_omap_ops *hw_ops)
+{
+	struct clk *clk;
+	struct clk_init_data init = { NULL };
+	struct clk_hw_omap *clk_hw;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 val;
+
+	clk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);
+	if (!clk_hw)
+		return;
+
+	clk_hw->hw.init = &init;
+
+	init.name = clk_name;
+	init.ops = ops;
+
+	if (ops != &omap_gate_clkdm_clk_ops) {
+		clk_hw->enable_reg = ti_clk_get_reg_addr(node, 0);
+		if (!clk_hw->enable_reg)
+			goto cleanup;
+
+		if (!of_property_read_u32(node, "ti,bit-shift", &val))
+			clk_hw->enable_bit = val;
+	}
+
+	clk_hw->ops = hw_ops;
+
+	clk_hw->flags = MEMMAP_ADDRESSING;
+
+	if (of_clk_get_parent_count(node) != 1) {
+		pr_err("%s must have 1 parent\n", clk_name);
+		goto cleanup;
+	}
+
+	parent_name = of_clk_get_parent_name(node, 0);
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	if (of_property_read_bool(node, "ti,set-rate-parent"))
+		init.flags |= CLK_SET_RATE_PARENT;
+
+	if (of_property_read_bool(node, "ti,set-bit-to-disable"))
+		clk_hw->flags |= INVERT_ENABLE;
+
+	clk = clk_register(NULL, &clk_hw->hw);
+
+	if (!IS_ERR(clk)) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		return;
+	}
+
+cleanup:
+	kfree(clk_hw);
+}
+
+static void __init
+_of_ti_composite_gate_clk_setup(struct device_node *node,
+				const struct clk_hw_omap_ops *hw_ops)
+{
+	struct clk_hw_omap *gate;
+	u32 val = 0;
+
+	gate = kzalloc(sizeof(*gate), GFP_KERNEL);
+	if (!gate)
+		return;
+
+	gate->enable_reg = ti_clk_get_reg_addr(node, 0);
+	if (!gate->enable_reg)
+		goto cleanup;
+
+	of_property_read_u32(node, "ti,bit-shift", &val);
+
+	gate->enable_bit = val;
+	gate->ops = hw_ops;
+	gate->flags = MEMMAP_ADDRESSING;
+
+	if (!ti_clk_add_component(node, &gate->hw, CLK_COMPONENT_TYPE_GATE))
+		return;
+
+cleanup:
+	kfree(gate);
+}
+
+static void __init
+of_ti_composite_no_wait_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_composite_gate_clk_setup(node, NULL);
+}
+CLK_OF_DECLARE(ti_composite_no_wait_gate_clk, "ti,composite-no-wait-gate-clock",
+	       of_ti_composite_no_wait_gate_clk_setup);
+
+#ifdef CONFIG_ARCH_OMAP3
+static void __init of_ti_composite_interface_clk_setup(struct device_node *node)
+{
+	_of_ti_composite_gate_clk_setup(node, &clkhwops_iclk_wait);
+}
+CLK_OF_DECLARE(ti_composite_interface_clk, "ti,composite-interface-clock",
+	       of_ti_composite_interface_clk_setup);
+#endif
+
+static void __init of_ti_composite_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_composite_gate_clk_setup(node, &clkhwops_wait);
+}
+CLK_OF_DECLARE(ti_composite_gate_clk, "ti,composite-gate-clock",
+	       of_ti_composite_gate_clk_setup);
+
+
+static void __init of_ti_clkdm_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_gate_clk_setup(node, &omap_gate_clkdm_clk_ops, NULL);
+}
+CLK_OF_DECLARE(ti_clkdm_gate_clk, "ti,clkdm-gate-clock",
+	       of_ti_clkdm_gate_clk_setup);
+
+static void __init of_ti_hsdiv_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_gate_clk_setup(node, &omap_gate_clk_hsdiv_restore_ops,
+			      &clkhwops_wait);
+}
+CLK_OF_DECLARE(ti_hsdiv_gate_clk, "ti,hsdiv-gate-clock",
+	       of_ti_hsdiv_gate_clk_setup);
+
+static void __init of_ti_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_gate_clk_setup(node, &omap_gate_clk_ops, NULL);
+}
+CLK_OF_DECLARE(ti_gate_clk, "ti,gate-clock", of_ti_gate_clk_setup)
+
+static void __init of_ti_wait_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_gate_clk_setup(node, &omap_gate_clk_ops, &clkhwops_wait);
+}
+CLK_OF_DECLARE(ti_wait_gate_clk, "ti,wait-gate-clock",
+	       of_ti_wait_gate_clk_setup);
+
+#ifdef CONFIG_ARCH_OMAP3
+static void __init of_ti_am35xx_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_gate_clk_setup(node, &omap_gate_clk_ops,
+			      &clkhwops_am35xx_ipss_module_wait);
+}
+CLK_OF_DECLARE(ti_am35xx_gate_clk, "ti,am35xx-gate-clock",
+	       of_ti_am35xx_gate_clk_setup);
+
+static void __init of_ti_dss_gate_clk_setup(struct device_node *node)
+{
+	_of_ti_gate_clk_setup(node, &omap_gate_clk_ops,
+			      &clkhwops_omap3430es2_dss_usbhost_wait);
+}
+CLK_OF_DECLARE(ti_dss_gate_clk, "ti,dss-gate-clock",
+	       of_ti_dss_gate_clk_setup);
+#endif
