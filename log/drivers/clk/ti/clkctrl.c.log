commit 852049594b9af58fa2972103699fd58a7ac165c6
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Apr 30 11:34:51 2020 +0300

    clk: ti: clkctrl: convert subclocks to use proper names also
    
    Addition of the new internal API to get the clkctrl names missed adding
    the same conversion in place for the subclocks. This leads into missed
    parent/child relationships (i.e. orphaned clocks) with mixed node name
    handling, for example with omap4/omap5 where the l4_per clocks are using
    new naming, but rest are using old. Fix by converting the subclock
    registration to pick correct names for the clocks also.
    
    Fixes: 6c3090520554 ("clk: ti: clkctrl: Fix hidden dependency to node name")
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Link: https://lkml.kernel.org/r/20200430083451.8562-1-t-kristo@ti.com
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 9019624e37bc..864c484bde1b 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -255,24 +255,53 @@ static struct clk_hw *_ti_omap4_clkctrl_xlate(struct of_phandle_args *clkspec,
 	return entry->clk;
 }
 
+/* Get clkctrl clock base name based on clkctrl_name or dts node */
+static const char * __init clkctrl_get_clock_name(struct device_node *np,
+						  const char *clkctrl_name,
+						  int offset, int index,
+						  bool legacy_naming)
+{
+	char *clock_name;
+
+	/* l4per-clkctrl:1234:0 style naming based on clkctrl_name */
+	if (clkctrl_name && !legacy_naming) {
+		clock_name = kasprintf(GFP_KERNEL, "%s-clkctrl:%04x:%d",
+				       clkctrl_name, offset, index);
+		strreplace(clock_name, '_', '-');
+
+		return clock_name;
+	}
+
+	/* l4per:1234:0 old style naming based on clkctrl_name */
+	if (clkctrl_name)
+		return kasprintf(GFP_KERNEL, "%s_cm:clk:%04x:%d",
+				 clkctrl_name, offset, index);
+
+	/* l4per_cm:1234:0 old style naming based on parent node name */
+	if (legacy_naming)
+		return kasprintf(GFP_KERNEL, "%pOFn:clk:%04x:%d",
+				 np->parent, offset, index);
+
+	/* l4per-clkctrl:1234:0 style naming based on node name */
+	return kasprintf(GFP_KERNEL, "%pOFn:%04x:%d", np, offset, index);
+}
+
 static int __init
 _ti_clkctrl_clk_register(struct omap_clkctrl_provider *provider,
 			 struct device_node *node, struct clk_hw *clk_hw,
 			 u16 offset, u8 bit, const char * const *parents,
-			 int num_parents, const struct clk_ops *ops)
+			 int num_parents, const struct clk_ops *ops,
+			 const char *clkctrl_name)
 {
 	struct clk_init_data init = { NULL };
 	struct clk *clk;
 	struct omap_clkctrl_clk *clkctrl_clk;
 	int ret = 0;
 
-	if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
-		init.name = kasprintf(GFP_KERNEL, "%pOFn:%pOFn:%04x:%d",
-				      node->parent, node, offset,
-				      bit);
-	else
-		init.name = kasprintf(GFP_KERNEL, "%pOFn:%04x:%d", node,
-				      offset, bit);
+	init.name = clkctrl_get_clock_name(node, clkctrl_name, offset, bit,
+					   ti_clk_get_features()->flags &
+					   TI_CLK_CLKCTRL_COMPAT);
+
 	clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
 	if (!init.name || !clkctrl_clk) {
 		ret = -ENOMEM;
@@ -309,7 +338,7 @@ static void __init
 _ti_clkctrl_setup_gate(struct omap_clkctrl_provider *provider,
 		       struct device_node *node, u16 offset,
 		       const struct omap_clkctrl_bit_data *data,
-		       void __iomem *reg)
+		       void __iomem *reg, const char *clkctrl_name)
 {
 	struct clk_hw_omap *clk_hw;
 
@@ -322,7 +351,7 @@ _ti_clkctrl_setup_gate(struct omap_clkctrl_provider *provider,
 
 	if (_ti_clkctrl_clk_register(provider, node, &clk_hw->hw, offset,
 				     data->bit, data->parents, 1,
-				     &omap_gate_clk_ops))
+				     &omap_gate_clk_ops, clkctrl_name))
 		kfree(clk_hw);
 }
 
@@ -330,7 +359,7 @@ static void __init
 _ti_clkctrl_setup_mux(struct omap_clkctrl_provider *provider,
 		      struct device_node *node, u16 offset,
 		      const struct omap_clkctrl_bit_data *data,
-		      void __iomem *reg)
+		      void __iomem *reg, const char *clkctrl_name)
 {
 	struct clk_omap_mux *mux;
 	int num_parents = 0;
@@ -357,7 +386,7 @@ _ti_clkctrl_setup_mux(struct omap_clkctrl_provider *provider,
 
 	if (_ti_clkctrl_clk_register(provider, node, &mux->hw, offset,
 				     data->bit, data->parents, num_parents,
-				     &ti_clk_mux_ops))
+				     &ti_clk_mux_ops, clkctrl_name))
 		kfree(mux);
 }
 
@@ -365,7 +394,7 @@ static void __init
 _ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,
 		      struct device_node *node, u16 offset,
 		      const struct omap_clkctrl_bit_data *data,
-		      void __iomem *reg)
+		      void __iomem *reg, const char *clkctrl_name)
 {
 	struct clk_omap_divider *div;
 	const struct omap_clkctrl_div_data *div_data = data->data;
@@ -393,7 +422,7 @@ _ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,
 
 	if (_ti_clkctrl_clk_register(provider, node, &div->hw, offset,
 				     data->bit, data->parents, 1,
-				     &ti_clk_divider_ops))
+				     &ti_clk_divider_ops, clkctrl_name))
 		kfree(div);
 }
 
@@ -401,7 +430,7 @@ static void __init
 _ti_clkctrl_setup_subclks(struct omap_clkctrl_provider *provider,
 			  struct device_node *node,
 			  const struct omap_clkctrl_reg_data *data,
-			  void __iomem *reg)
+			  void __iomem *reg, const char *clkctrl_name)
 {
 	const struct omap_clkctrl_bit_data *bits = data->bit_data;
 
@@ -412,17 +441,17 @@ _ti_clkctrl_setup_subclks(struct omap_clkctrl_provider *provider,
 		switch (bits->type) {
 		case TI_CLK_GATE:
 			_ti_clkctrl_setup_gate(provider, node, data->offset,
-					       bits, reg);
+					       bits, reg, clkctrl_name);
 			break;
 
 		case TI_CLK_DIVIDER:
 			_ti_clkctrl_setup_div(provider, node, data->offset,
-					      bits, reg);
+					      bits, reg, clkctrl_name);
 			break;
 
 		case TI_CLK_MUX:
 			_ti_clkctrl_setup_mux(provider, node, data->offset,
-					      bits, reg);
+					      bits, reg, clkctrl_name);
 			break;
 
 		default:
@@ -465,37 +494,6 @@ static char * __init clkctrl_get_name(struct device_node *np)
 	return NULL;
 }
 
-/* Get clkctrl clock base name based on clkctrl_name or dts node */
-static const char * __init clkctrl_get_clock_name(struct device_node *np,
-						  const char *clkctrl_name,
-						  int offset, int index,
-						  bool legacy_naming)
-{
-	char *clock_name;
-
-	/* l4per-clkctrl:1234:0 style naming based on clkctrl_name */
-	if (clkctrl_name && !legacy_naming) {
-		clock_name = kasprintf(GFP_KERNEL, "%s-clkctrl:%04x:%d",
-				       clkctrl_name, offset, index);
-		strreplace(clock_name, '_', '-');
-
-		return clock_name;
-	}
-
-	/* l4per:1234:0 old style naming based on clkctrl_name */
-	if (clkctrl_name)
-		return kasprintf(GFP_KERNEL, "%s_cm:clk:%04x:%d",
-				 clkctrl_name, offset, index);
-
-	/* l4per_cm:1234:0 old style naming based on parent node name */
-	if (legacy_naming)
-		return kasprintf(GFP_KERNEL, "%pOFn:clk:%04x:%d",
-				 np->parent, offset, index);
-
-	/* l4per-clkctrl:1234:0 style naming based on node name */
-	return kasprintf(GFP_KERNEL, "%pOFn:%04x:%d", np, offset, index);
-}
-
 static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 {
 	struct omap_clkctrl_provider *provider;
@@ -663,7 +661,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		hw->enable_reg.ptr = provider->base + reg_data->offset;
 
 		_ti_clkctrl_setup_subclks(provider, node, reg_data,
-					  hw->enable_reg.ptr);
+					  hw->enable_reg.ptr, clkctrl_name);
 
 		if (reg_data->flags & CLKF_SW_SUP)
 			hw->enable_bit = MODULEMODE_SWCTRL;

commit e1f9e0d28ff025564dfdb1001a7839b4af5db2e2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 24 15:47:25 2020 +0300

    clk: ti: clkctrl: Fix Bad of_node_put within clkctrl_get_name
    
    clkctrl_get_name incorrectly calls of_node_put when it is not really
    doing of_node_get. This causes a boot time warning later on:
    
    [    0.000000] OF: ERROR: Bad of_node_put() on /ocp/interconnect@4a000000/segmen
    t@0/target-module@5000/cm_core_aon@0/ipu-cm@500/ipu1-clkctrl@20
    
    Fix by dropping the of_node_put from the function.
    
    Reported-by: Naresh Kamboju <naresh.kamboju@linaro.org>
    Fixes: 6c3090520554 ("clk: ti: clkctrl: Fix hidden dependency to node name")
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Link: https://lkml.kernel.org/r/20200424124725.9895-1-t-kristo@ti.com
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 062266034d84..9019624e37bc 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -461,7 +461,6 @@ static char * __init clkctrl_get_name(struct device_node *np)
 			return name;
 		}
 	}
-	of_node_put(np);
 
 	return NULL;
 }

commit 6c3090520554d535db04f807c313d9a4b81a285c
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 10 09:21:04 2019 -0800

    clk: ti: clkctrl: Fix hidden dependency to node name
    
    We currently have a hidden dependency to the device tree node name for
    the clkctrl clocks. Instead of using standard node name like "clock", we
    must use "l4-per-clkctrl" type naming so the clock driver can find the
    associated clock domain. Further, if "clk" is specified for a clock node
    name, the driver sets TI_CLK_CLKCTRL_COMPAT flag that uses different
    logic for the clock name based on the parent node name for the all the
    clkctrl clocks for the SoC.
    
    If the clock node naming dependency is not understood, the related
    clockdomain is not found, or a wrong one can get used if a clock manager
    has multiple clock domains.
    
    As each clkctrl instance represents a single clock domain, let's allow
    using domain specific compatible names to specify the clock domain.
    
    This simplifies things and removes the hidden dependency to the node
    name. And then later on, after the node names have been standardized,
    we can drop the related code for parsing the node names.
    
    Let's also update the binding to use standard "clock" node naming
    instead of "clk" and add the missing description for reg.
    
    Cc: devicetree@vger.kernel.org
    Cc: Rob Herring <robh+dt@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 17b9a761242f..062266034d84 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -440,6 +440,63 @@ static void __init _clkctrl_add_provider(void *data,
 	of_clk_add_hw_provider(np, _ti_omap4_clkctrl_xlate, data);
 }
 
+/* Get clock name based on compatible string for clkctrl */
+static char * __init clkctrl_get_name(struct device_node *np)
+{
+	struct property *prop;
+	const int prefix_len = 11;
+	const char *compat;
+	char *name;
+
+	of_property_for_each_string(np, "compatible", prop, compat) {
+		if (!strncmp("ti,clkctrl-", compat, prefix_len)) {
+			/* Two letter minimum name length for l3, l4 etc */
+			if (strnlen(compat + prefix_len, 16) < 2)
+				continue;
+			name = kasprintf(GFP_KERNEL, "%s", compat + prefix_len);
+			if (!name)
+				continue;
+			strreplace(name, '-', '_');
+
+			return name;
+		}
+	}
+	of_node_put(np);
+
+	return NULL;
+}
+
+/* Get clkctrl clock base name based on clkctrl_name or dts node */
+static const char * __init clkctrl_get_clock_name(struct device_node *np,
+						  const char *clkctrl_name,
+						  int offset, int index,
+						  bool legacy_naming)
+{
+	char *clock_name;
+
+	/* l4per-clkctrl:1234:0 style naming based on clkctrl_name */
+	if (clkctrl_name && !legacy_naming) {
+		clock_name = kasprintf(GFP_KERNEL, "%s-clkctrl:%04x:%d",
+				       clkctrl_name, offset, index);
+		strreplace(clock_name, '_', '-');
+
+		return clock_name;
+	}
+
+	/* l4per:1234:0 old style naming based on clkctrl_name */
+	if (clkctrl_name)
+		return kasprintf(GFP_KERNEL, "%s_cm:clk:%04x:%d",
+				 clkctrl_name, offset, index);
+
+	/* l4per_cm:1234:0 old style naming based on parent node name */
+	if (legacy_naming)
+		return kasprintf(GFP_KERNEL, "%pOFn:clk:%04x:%d",
+				 np->parent, offset, index);
+
+	/* l4per-clkctrl:1234:0 style naming based on node name */
+	return kasprintf(GFP_KERNEL, "%pOFn:%04x:%d", np, offset, index);
+}
+
 static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 {
 	struct omap_clkctrl_provider *provider;
@@ -448,8 +505,10 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	struct clk_init_data init = { NULL };
 	struct clk_hw_omap *hw;
 	struct clk *clk;
-	struct omap_clkctrl_clk *clkctrl_clk;
+	struct omap_clkctrl_clk *clkctrl_clk = NULL;
 	const __be32 *addrp;
+	bool legacy_naming;
+	char *clkctrl_name;
 	u32 addr;
 	int ret;
 	char *c;
@@ -537,7 +596,19 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 
 	provider->base = of_iomap(node, 0);
 
-	if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT) {
+	legacy_naming = ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT;
+	clkctrl_name = clkctrl_get_name(node);
+	if (clkctrl_name) {
+		provider->clkdm_name = kasprintf(GFP_KERNEL,
+						 "%s_clkdm", clkctrl_name);
+		goto clkdm_found;
+	}
+
+	/*
+	 * The code below can be removed when all clkctrl nodes use domain
+	 * specific compatible proprerty and standard clock node naming
+	 */
+	if (legacy_naming) {
 		provider->clkdm_name = kasprintf(GFP_KERNEL, "%pOFnxxx", node->parent);
 		if (!provider->clkdm_name) {
 			kfree(provider);
@@ -573,7 +644,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 			*c = '_';
 		c++;
 	}
-
+clkdm_found:
 	INIT_LIST_HEAD(&provider->clocks);
 
 	/* Generate clocks */
@@ -612,15 +683,15 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		init.flags = 0;
 		if (reg_data->flags & CLKF_SET_RATE_PARENT)
 			init.flags |= CLK_SET_RATE_PARENT;
-		if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
-			init.name = kasprintf(GFP_KERNEL, "%pOFn:%pOFn:%04x:%d",
-					      node->parent, node,
-					      reg_data->offset, 0);
-		else
-			init.name = kasprintf(GFP_KERNEL, "%pOFn:%04x:%d",
-					      node, reg_data->offset, 0);
+
+		init.name = clkctrl_get_clock_name(node, clkctrl_name,
+						   reg_data->offset, 0,
+						   legacy_naming);
+		if (!init.name)
+			goto cleanup;
+
 		clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
-		if (!init.name || !clkctrl_clk)
+		if (!clkctrl_clk)
 			goto cleanup;
 
 		init.ops = &omap4_clkctrl_clk_ops;
@@ -642,11 +713,14 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	if (ret == -EPROBE_DEFER)
 		ti_clk_retry_init(node, provider, _clkctrl_add_provider);
 
+	kfree(clkctrl_name);
+
 	return;
 
 cleanup:
 	kfree(hw);
 	kfree(init.name);
+	kfree(clkctrl_name);
 	kfree(clkctrl_clk);
 }
 CLK_OF_DECLARE(ti_omap4_clkctrl_clock, "ti,clkctrl",

commit ddebe839c6013ab42f376bdeaaaf66bd0c0d68d6
Merge: ceb307474506 ec16ffe36d80
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 1 16:06:02 2019 -0800

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "This merge window we have one small clk provider API in the core
      framework and then a bunch of driver updates and a handful of new
      drivers. In terms of diffstat the Qualcomm and Amlogic drivers are
      high up there because of all the clk data introcued by new drivers.
      The Nvidia Tegra driver had a lot of work done this cycle too to
      support suspend/resume and memory controllers. And the OMAP clk driver
      got proper clk and reset handling in place.
    
      Rounding out the patches are various updates to remove unused data,
      mark things static, correct incorrect data in drivers, etc. All the
      little things that improve drivers and maintain code health. I will
      point out that there's a patch in here for the GPIO clk driver, that
      almost nobody uses, which changes behavior and causes clk_set_rate()
      to try to change the GPIO gate clk's parent. Other than that things
      are fairly well SoC specific here.
    
      Core:
       - Add a clk provider API to get current parent index
       - Plug a memory leak in clk_unregister() path
    
      New Drivers:
       - CGU in Ingenix X1000
       - Bitmain BM1880 clks
       - Qualcomm MSM8998 GPU clk controllers
       - Qualcomm SC7180 GCC and RPMH clk controllers
       - Qualcomm QCS404 Q6SSTOP clk controllers
       - Add support for the Renesas R-Car M3-W+ (r8a77961) SoC
       - Add support for the Renesas RZ/G2N (r8a774b1) SoC
       - Add Tegra20/30 External Memory Clock (EMC) support
    
      Updates:
       - Make gpio gate clks propagate rate setting up to parent
       - Prepare Armada 3700 for suspend to RAM by moving PCIe
         suspend/resume priority
       - Drop unused variables, enums, etc. in various clk drivers
       - Convert various drivers to use devm_platform_ioremap_resource()
       - Use struct_size() some more in various clk drivers
       - Improve Rockchip px30 clk tree
       - Add suspend/resume support to Tegra210 clk driver
       - Reimplement SOR clks on earlier Tegra SoCs, helping HDMI and DP
       - Allwinner DT exports and H6 clk tree fixes
       - Proper clk and reset handling for OMAP SoCs
       - Revamped TI divider clk to clamp max divider
       - Make 1443X/1416X PLL clock structure common for reusing among i.MX8
         SoCs
       - Drop IMX7ULP_CLK_MIPI_PLL clock, it shouldn't be used
       - Add VIDEO2_PLL clock for imx8mq
       - Add missing gate clock for pll1/2 fixed dividers on i.MX8 SoCs
       - Add sm1 support in the Amlogic audio clock controller
       - Switch some clocks on R-Car Gen2/3 to .determine_rate()
       - Remove Renesas R-Car Gen2 legacy DT clock support
       - Improve arithmetic divisions on Renesas R-Car Gen2 and Gen3
       - Improve Renesas R-Car Gen3 SD clock handling
       - Add rate table for Samsung exynos542x GPU and VPLL clks
       - Fix potential CPU performance degradation after system
         suspend/resume cycle on exynos542x SoCs"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (160 commits)
      clk: aspeed: Add RMII RCLK gates for both AST2500 MACs
      MAINTAINERS: Add entry for BM1880 SoC clock driver
      clk: Add common clock driver for BM1880 SoC
      dt-bindings: clock: Add devicetree binding for BM1880 SoC
      clk: Add clk_hw_unregister_composite helper function definition
      clk: Zero init clk_init_data in helpers
      clk: ingenic: Allow drivers to be built with COMPILE_TEST
      MAINTAINERS: Update section for Ux500 clock drivers
      clk: mark clk_disable_unused() as __init
      clk: Fix memory leak in clk_unregister()
      clk: Ingenic: Add CGU driver for X1000.
      dt-bindings: clock: Add X1000 bindings.
      clk: tegra: Use match_string() helper to simplify the code
      clk: pxa: fix one of the pxa RTC clocks
      clk: sprd: Use IS_ERR() to validate the return value of syscon_regmap_lookup_by_phandle()
      clk: armada-xp: remove unused code
      clk: tegra: Fix build error without CONFIG_PM_SLEEP
      clk: tegra: Add missing stubs for the case of !CONFIG_PM_SLEEP
      clk: tegra: Optimize PLLX restore on Tegra20/30
      clk: tegra: Add suspend and resume support on Tegra210
      ...

commit 81a41901ffd46bac6df4c95b8290ac259e0feda8
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Sep 30 08:40:01 2019 -0700

    clk: ti: clkctrl: Fix failed to enable error with double udelay timeout
    
    Commit 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if
    timekeeping is suspended") added handling for cases when timekeeping is
    suspended. But looks like we can still get occasional "failed to enable"
    errors on the PM runtime resume path with udelay() returning faster than
    expected.
    
    With ti-sysc interconnect target module driver this leads into device
    failure with PM runtime failing with "failed to enable" clkctrl error.
    
    Let's fix the issue with a delay of two times the desired delay as in
    often done for udelay() to account for the inaccuracy.
    
    Fixes: 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if timekeeping is suspended")
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lkml.kernel.org/r/20190930154001.46581-1-tony@atomide.com
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 975995eea15c..b0c0690a5a12 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -100,11 +100,12 @@ static bool _omap4_is_timeout(union omap4_timeout *time, u32 timeout)
 	 * can be from a timer that requires pm_runtime access, which
 	 * will eventually bring us here with timekeeping_suspended,
 	 * during both suspend entry and resume paths. This happens
-	 * at least on am43xx platform.
+	 * at least on am43xx platform. Account for flakeyness
+	 * with udelay() by multiplying the timeout value by 2.
 	 */
 	if (unlikely(_early_timeout || timekeeping_suspended)) {
 		if (time->cycles++ < timeout) {
-			udelay(1);
+			udelay(1 * 2);
 			return false;
 		}
 	} else {

commit a229965cfeab8ea8bb79086d6f59ac9a57de66fe
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Oct 2 15:06:09 2019 +0300

    clk: ti: divider: cleanup ti_clk_parse_divider_data API
    
    Cleanup the ti_clk_parse_divider_data to pass the divider data struct
    directly instead of individual values of it. This makes it easier
    to modify the implementation later on.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Adam Ford <aford173@gmail.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index d6cb41b55800..b8ae8c44d761 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -383,7 +383,7 @@ _ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,
 
 	if (ti_clk_parse_divider_data((int *)div_data->dividers, 0,
 				      div_data->max_div, div_flags,
-				      &div->width, &div->table)) {
+				      div)) {
 		pr_err("%s: Data parsing for %pOF:%04x:%d failed\n", __func__,
 		       node, offset, data->bit);
 		kfree(div);

commit 2209b72d41993c13de220b82c830b482925322b9
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 12 16:26:06 2019 +0300

    clk: ti: clkctrl: add new exported API for checking standby info
    
    Standby status is provided for certain clkctrl clocks to see if the
    given module has entered standby or not. This is mostly needed by
    remoteproc code to see if the remoteproc has entered standby and the clock
    can be turned off safely.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index d904a9a7626a..d6cb41b55800 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -34,6 +34,9 @@
 #define OMAP4_IDLEST_MASK		(0x3 << 16)
 #define OMAP4_IDLEST_SHIFT		16
 
+#define OMAP4_STBYST_MASK		BIT(18)
+#define OMAP4_STBYST_SHIFT		18
+
 #define CLKCTRL_IDLEST_FUNCTIONAL	0x0
 #define CLKCTRL_IDLEST_INTERFACE_IDLE	0x2
 #define CLKCTRL_IDLEST_DISABLED		0x3
@@ -647,3 +650,33 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 }
 CLK_OF_DECLARE(ti_omap4_clkctrl_clock, "ti,clkctrl",
 	       _ti_omap4_clkctrl_setup);
+
+/**
+ * ti_clk_is_in_standby - Check if clkctrl clock is in standby or not
+ * @clk: clock to check standby status for
+ *
+ * Finds whether the provided clock is in standby mode or not. Returns
+ * true if the provided clock is a clkctrl type clock and it is in standby,
+ * false otherwise.
+ */
+bool ti_clk_is_in_standby(struct clk *clk)
+{
+	struct clk_hw *hw;
+	struct clk_hw_omap *hwclk;
+	u32 val;
+
+	hw = __clk_get_hw(clk);
+
+	if (!omap2_clk_is_hw_omap(hw))
+		return false;
+
+	hwclk = to_clk_hw_omap(hw);
+
+	val = ti_clk_ll_ops->clk_readl(&hwclk->enable_reg);
+
+	if (val & OMAP4_STBYST_MASK)
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(ti_clk_is_in_standby);

commit 22a6564f716b0746b5a05add3f9f37549f89244e
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 12 16:26:05 2019 +0300

    clk: ti: clkctrl: convert to use bit helper macros instead of bitops
    
    This improves the readibility of the code slightly, and makes modifying
    the flags bit simpler.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index a914df2e9e1b..d904a9a7626a 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -24,7 +24,7 @@
 #include <linux/timekeeping.h>
 #include "clock.h"
 
-#define NO_IDLEST			0x1
+#define NO_IDLEST			0
 
 #define OMAP4_MODULEMODE_MASK		0x3
 
@@ -158,7 +158,7 @@ static int _omap4_clkctrl_clk_enable(struct clk_hw *hw)
 
 	ti_clk_ll_ops->clk_writel(val, &clk->enable_reg);
 
-	if (clk->flags & NO_IDLEST)
+	if (test_bit(NO_IDLEST, &clk->flags))
 		return 0;
 
 	/* Wait until module is enabled */
@@ -187,7 +187,7 @@ static void _omap4_clkctrl_clk_disable(struct clk_hw *hw)
 
 	ti_clk_ll_ops->clk_writel(val, &clk->enable_reg);
 
-	if (clk->flags & NO_IDLEST)
+	if (test_bit(NO_IDLEST, &clk->flags))
 		goto exit;
 
 	/* Wait until module is disabled */
@@ -596,7 +596,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		if (reg_data->flags & CLKF_HW_SUP)
 			hw->enable_bit = MODULEMODE_HWCTRL;
 		if (reg_data->flags & CLKF_NO_IDLEST)
-			hw->flags |= NO_IDLEST;
+			set_bit(NO_IDLEST, &hw->flags);
 
 		if (reg_data->clkdm_name)
 			hw->clkdm_name = reg_data->clkdm_name;

commit 581eb61a9465e1b9fc1df1a8912100702d7c2f31
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 12 16:26:04 2019 +0300

    clk: ti: clkctrl: fix setting up clkctrl clocks
    
    Apply the proper register function for clkctrl clocks, so they get
    registered under the clk_hw_omap list also. This allows checking their
    type runtime.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 975995eea15c..a914df2e9e1b 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -622,7 +622,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		init.ops = &omap4_clkctrl_clk_ops;
 		hw->hw.init = &init;
 
-		clk = ti_clk_register(NULL, &hw->hw, init.name);
+		clk = ti_clk_register_omap_hw(NULL, &hw->hw, init.name);
 		if (IS_ERR_OR_NULL(clk))
 			goto cleanup;
 

commit 41b3588dba6ef4b7995735a97e47ff0aeea6c276
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 29 23:55:57 2019 -0700

    clk: ti: clkctrl: Fix returning uninitialized data
    
    If we do a clk_get() for a clock that does not exists, we have
    _ti_omap4_clkctrl_xlate() return uninitialized data if no match
    is found. This can be seen in some cases with SLAB_DEBUG enabled:
    
    Unable to handle kernel paging request at virtual address 5a5a5a5a
    ...
    clk_hw_create_clk.part.33
    sysc_notifier_call
    notifier_call_chain
    blocking_notifier_call_chain
    device_add
    
    Let's fix this by setting a found flag only when we find a match.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Fixes: 88a172526c32 ("clk: ti: add support for clkctrl clocks")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 8e834317c97d..975995eea15c 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -229,6 +229,7 @@ static struct clk_hw *_ti_omap4_clkctrl_xlate(struct of_phandle_args *clkspec,
 {
 	struct omap_clkctrl_provider *provider = data;
 	struct omap_clkctrl_clk *entry;
+	bool found = false;
 
 	if (clkspec->args_count != 2)
 		return ERR_PTR(-EINVAL);
@@ -238,11 +239,13 @@ static struct clk_hw *_ti_omap4_clkctrl_xlate(struct of_phandle_args *clkspec,
 
 	list_for_each_entry(entry, &provider->clocks, node) {
 		if (entry->reg_offset == clkspec->args[0] &&
-		    entry->bit_offset == clkspec->args[1])
+		    entry->bit_offset == clkspec->args[1]) {
+			found = true;
 			break;
+		}
 	}
 
-	if (!entry)
+	if (!found)
 		return ERR_PTR(-EINVAL);
 
 	return entry->clk;

commit 1cc54078d104f5b4d7e9f8d55362efa5a8daffdb
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 6 14:08:54 2019 -0700

    clk: ti: clkctrl: Fix clkdm_clk handling
    
    We need to always call clkdm_clk_enable() and clkdm_clk_disable() even
    the clkctrl clock(s) enabled for the domain do not have any gate register
    bits. Otherwise clockdomains may never get enabled except when devices get
    probed with the legacy "ti,hwmods" devicetree property.
    
    Fixes: 88a172526c32 ("clk: ti: add support for clkctrl clocks")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 96d65a1cf7be..8e834317c97d 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -137,9 +137,6 @@ static int _omap4_clkctrl_clk_enable(struct clk_hw *hw)
 	int ret;
 	union omap4_timeout timeout = { 0 };
 
-	if (!clk->enable_bit)
-		return 0;
-
 	if (clk->clkdm) {
 		ret = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);
 		if (ret) {
@@ -151,6 +148,9 @@ static int _omap4_clkctrl_clk_enable(struct clk_hw *hw)
 		}
 	}
 
+	if (!clk->enable_bit)
+		return 0;
+
 	val = ti_clk_ll_ops->clk_readl(&clk->enable_reg);
 
 	val &= ~OMAP4_MODULEMODE_MASK;
@@ -179,7 +179,7 @@ static void _omap4_clkctrl_clk_disable(struct clk_hw *hw)
 	union omap4_timeout timeout = { 0 };
 
 	if (!clk->enable_bit)
-		return;
+		goto exit;
 
 	val = ti_clk_ll_ops->clk_readl(&clk->enable_reg);
 

commit 869decd1ff197c3083cb8b58f7dcac201038c381
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Apr 4 11:11:05 2019 +0300

    clk: ti: dra7: disable the RNG and TIMER12 clkctrl clocks on HS devices
    
    RNG and TIMER12 are reserved for secure side usage only on HS devices,
    so disable their clkctrl clocks on HS SoCs also.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 4cdeb8d4830c..96d65a1cf7be 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -509,6 +509,9 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		data = dm816_clkctrl_data;
 #endif
 
+	if (ti_clk_get_features()->flags & TI_CLK_DEVICE_TYPE_GP)
+		soc_mask |= CLKF_SOC_NONSEC;
+
 	while (data->addr) {
 		if (addr == data->addr)
 			break;

commit 2b1202d708fd3117bca6bad8770353f389ee0f08
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Apr 4 11:11:04 2019 +0300

    clk: ti: dra7x: prevent non-existing clkctrl clocks from registering
    
    Certain clkctrl clocks (like the USB_OTG_SS4) do not exist on some
    variants of the dra7x SoC. Append a flag for these clocks and skip
    the registration in cases where the clocks do not exist.
    
    Reported-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 639f515e08f0..4cdeb8d4830c 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -446,6 +446,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	u32 addr;
 	int ret;
 	char *c;
+	u16 soc_mask = 0;
 
 	if (!(ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT) &&
 	    of_node_name_eq(node, "clk"))
@@ -469,6 +470,13 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		else
 			data = dra7_clkctrl_data;
 	}
+
+	if (of_machine_is_compatible("ti,dra72"))
+		soc_mask = CLKF_SOC_DRA72;
+	if (of_machine_is_compatible("ti,dra74"))
+		soc_mask = CLKF_SOC_DRA74;
+	if (of_machine_is_compatible("ti,dra76"))
+		soc_mask = CLKF_SOC_DRA76;
 #endif
 #ifdef CONFIG_SOC_AM33XX
 	if (of_machine_is_compatible("ti,am33xx")) {
@@ -562,6 +570,12 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	reg_data = data->regs;
 
 	while (reg_data->parent) {
+		if ((reg_data->flags & CLKF_SOC_MASK) &&
+		    (reg_data->flags & soc_mask) == 0) {
+			reg_data++;
+			continue;
+		}
+
 		hw = kzalloc(sizeof(*hw), GFP_KERNEL);
 		if (!hw)
 			return;

commit d17a718db40df2548e99a62dc3d7e5e2b38143cc
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 7 12:10:56 2019 -0800

    clk: ti: clkctrl: Fix clkdm_name regression for TI_CLK_CLKCTRL_COMPAT
    
    Commit a72d785021cb ("clk: ti: Prepare for remove of OF node name")
    changed the code to use kasprintf() for provider->clkdm_name but also
    changed the offset used later on by three. We don't need to change the
    offset as we already have the extra three characters in the format for
    kasprintf with "%pOFnxxx".
    
    This caused the clocks with TI_CLK_CLKCTRL_COMPAT to have NULL
    clk->clkdm_name for omap4 and 5. And null clkdm_name can cause module
    reset, enable, and idle to fail.
    
    The issue can also be seen also when enabling DEBUG for clkctrl.c
    and then we start seeing "clock: could not associate" messages for
    omap4 and 5 as the generated name is something like "l4_wkclkdm" instead
    of "l4_wkup_clkdm" that's needed.
    
    Let's fix the issue with a partial revert of commit a72d785021cb ("clk:
    ti: Prepare for remove of OF node name").
    
    ALso note that in general code should not depend on the dts node names.
    And the node names should be generic types like clock-domain in this case.
    This could be fixed later by using separate compatible properties for the
    clockdomains, or by adding soc_device_match() table with reg offsets
    to the driver. But let's fix the regression first.
    
    Fixes: a72d785021cb ("clk: ti: Prepare for remove of OF node name")
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index bf32d996177f..639f515e08f0 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -530,7 +530,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		 * Create default clkdm name, replace _cm from end of parent
 		 * node name with _clkdm
 		 */
-		provider->clkdm_name[strlen(provider->clkdm_name) - 5] = 0;
+		provider->clkdm_name[strlen(provider->clkdm_name) - 2] = 0;
 	} else {
 		provider->clkdm_name = kasprintf(GFP_KERNEL, "%pOFn", node);
 		if (!provider->clkdm_name) {

commit 8aa09cf322c196df95b52ed63c4cae605296f343
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Jan 15 11:15:14 2019 +0200

    clk: ti: remove usage of CLK_IS_BASIC
    
    Remove the usage of CLK_IS_BASIC flag completely from TI clock driver.
    In most cases, the use is completely redundant, but in some cases
    we need to use the new API to check if the clock is an OMAP clock or not.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Keerthy <j-keerthy@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 40630eb950fc..bf32d996177f 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -276,7 +276,7 @@ _ti_clkctrl_clk_register(struct omap_clkctrl_provider *provider,
 	init.parent_names = parents;
 	init.num_parents = num_parents;
 	init.ops = ops;
-	init.flags = CLK_IS_BASIC;
+	init.flags = 0;
 
 	clk = ti_clk_register(NULL, clk_hw, init.name);
 	if (IS_ERR_OR_NULL(clk)) {

commit 87ab115185e116f0349ba5bd0555d0b0e935166b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:21 2018 -0600

    clk: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    For instances using of_node_cmp, this has the side effect of now using
    case sensitive comparisons. This should not matter for any FDT based
    system which all of these are.
    
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-clk@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be> (clk-mstp)
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org> (ux500)
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 469f560ae1cf..40630eb950fc 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -448,7 +448,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	char *c;
 
 	if (!(ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT) &&
-	    !strcmp(node->name, "clk"))
+	    of_node_name_eq(node, "clk"))
 		ti_clk_features.flags |= TI_CLK_CLKCTRL_COMPAT;
 
 	addrp = of_get_address(node, 0, NULL, NULL);

commit 8a69f1d4707a69faab58d9735c2cb1898140124a
Merge: cc2adbe370f1 a72d785021cb
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Oct 18 15:41:21 2018 -0700

    Merge branch 'clk-ti' into clk-next
    
    * clk-ti:
      clk: ti: Prepare for remove of OF node name
      clk: Clean up suspend/resume coding style
      clk: ti: Add functions to save/restore clk context
      clk: clk: Add clk_gate_restore_context function
      clk: Add functions to save/restore clock context en-masse
      clk: ti: dra7: add new clkctrl data
      clk: ti: dra7xx: rename existing clkctrl data as compat data
      clk: ti: am43xx: add new clkctrl data for am43xx
      clk: ti: am43xx: rename existing clkctrl data as compat data
      clk: ti: am33xx: add new clkctrl data for am33xx
      clk: ti: am33xx: rename existing clkctrl data as compat data
      clk: ti: clkctrl: replace dashes from clkdm name with underscore
      clk: ti: clkctrl: support multiple clkctrl nodes under a cm node
      dt-bindings: clock: dra7xx: add clkctrl indices for new data layout
      dt-bindings: clock: am43xx: add clkctrl indices for new data layout
      dt-bindings: clock: am33xx: add clkctrl indices for new data layout

commit a72d785021cb92cc0abd4bb3d75607c82150fade
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Oct 15 16:38:33 2018 -0700

    clk: ti: Prepare for remove of OF node name
    
    Another patch is going to change this code to use %pOFn for DT node
    names. Fix up the code to make this easy to pick this side of the merge
    instead of fixing it up in a merge commit later.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 955f2e26ab00..853a5e650ff7 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -520,8 +520,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	provider->base = of_iomap(node, 0);
 
 	if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT) {
-		provider->clkdm_name = kmalloc(strlen(node->parent->name) + 3,
-					       GFP_KERNEL);
+		provider->clkdm_name = kasprintf(GFP_KERNEL, "%pOFnxxx", node->parent);
 		if (!provider->clkdm_name) {
 			kfree(provider);
 			return;
@@ -531,10 +530,9 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		 * Create default clkdm name, replace _cm from end of parent
 		 * node name with _clkdm
 		 */
-		strcpy(provider->clkdm_name, node->parent->name);
-		provider->clkdm_name[strlen(provider->clkdm_name) - 2] = 0;
+		provider->clkdm_name[strlen(provider->clkdm_name) - 5] = 0;
 	} else {
-		provider->clkdm_name = kmalloc(strlen(node->name), GFP_KERNEL);
+		provider->clkdm_name = kasprintf(GFP_KERNEL, "%pOFn", node);
 		if (!provider->clkdm_name) {
 			kfree(provider);
 			return;
@@ -544,7 +542,6 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		 * Create default clkdm name, replace _clkctrl from end of
 		 * node name with _clkdm
 		 */
-		strcpy(provider->clkdm_name, node->name);
 		provider->clkdm_name[strlen(provider->clkdm_name) - 7] = 0;
 	}
 

commit dffa9051d54672a7d7f5951e074c4393672c03e9
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Aug 13 14:30:49 2018 +0300

    clk: ti: dra7: add new clkctrl data
    
    The new clkctrl data layout for dra7xx is split based on clockdomain
    boundaries. Previously the split was based on CM boundaries. This patch
    adds the new data as separate data entity, retaining the compatibility
    data also for now. The compatibility data can be removed once no longer
    needed.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index c1fbb3d20155..955f2e26ab00 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -463,8 +463,12 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		data = omap5_clkctrl_data;
 #endif
 #ifdef CONFIG_SOC_DRA7XX
-	if (of_machine_is_compatible("ti,dra7"))
-		data = dra7_clkctrl_compat_data;
+	if (of_machine_is_compatible("ti,dra7")) {
+		if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
+			data = dra7_clkctrl_compat_data;
+		else
+			data = dra7_clkctrl_data;
+	}
 #endif
 #ifdef CONFIG_SOC_AM33XX
 	if (of_machine_is_compatible("ti,am33xx")) {

commit 43c56e046cd8229315a466b079c53f4ab0f8dcf2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Aug 13 11:11:33 2018 +0300

    clk: ti: dra7xx: rename existing clkctrl data as compat data
    
    Rename the existing clkctrl data in preparation of upcoming clkdm
    based split for it. Once the DT data has transitioned also, the
    compat data can be removed.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 6fe10a9f3116..c1fbb3d20155 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -464,7 +464,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 #endif
 #ifdef CONFIG_SOC_DRA7XX
 	if (of_machine_is_compatible("ti,dra7"))
-		data = dra7_clkctrl_data;
+		data = dra7_clkctrl_compat_data;
 #endif
 #ifdef CONFIG_SOC_AM33XX
 	if (of_machine_is_compatible("ti,am33xx")) {

commit 76a1049b84dd57bad6260b51455bbd17053b2eb4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Aug 13 10:48:52 2018 +0300

    clk: ti: am43xx: add new clkctrl data for am43xx
    
    The new clkctrl data layout for am43xx is split based on clockdomain
    boundaries. Previously the split was based on CM boundaries. This patch
    adds the new data as separate data entity, retaining the compatibility
    data also for now. The compatibility data can be removed once no longer
    needed.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 57f352ac9371..6fe10a9f3116 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -475,10 +475,19 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	}
 #endif
 #ifdef CONFIG_SOC_AM43XX
-	if (of_machine_is_compatible("ti,am4372"))
-		data = am4_clkctrl_compat_data;
-	if (of_machine_is_compatible("ti,am438x"))
-		data = am438x_clkctrl_compat_data;
+	if (of_machine_is_compatible("ti,am4372")) {
+		if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
+			data = am4_clkctrl_compat_data;
+		else
+			data = am4_clkctrl_data;
+	}
+
+	if (of_machine_is_compatible("ti,am438x")) {
+		if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
+			data = am438x_clkctrl_compat_data;
+		else
+			data = am438x_clkctrl_data;
+	}
 #endif
 #ifdef CONFIG_SOC_TI81XX
 	if (of_machine_is_compatible("ti,dm814"))

commit 131ee08f3fba48fd39ceca9c785a908c37276667
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Aug 13 10:38:40 2018 +0300

    clk: ti: am43xx: rename existing clkctrl data as compat data
    
    Rename the existing clkctrl data in preparation of upcoming clkdm
    based split for it. Once the DT data has transitioned also, the
    compat data can be removed.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 1d78d6c6e8fc..57f352ac9371 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -476,9 +476,9 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 #endif
 #ifdef CONFIG_SOC_AM43XX
 	if (of_machine_is_compatible("ti,am4372"))
-		data = am4_clkctrl_data;
+		data = am4_clkctrl_compat_data;
 	if (of_machine_is_compatible("ti,am438x"))
-		data = am438x_clkctrl_data;
+		data = am438x_clkctrl_compat_data;
 #endif
 #ifdef CONFIG_SOC_TI81XX
 	if (of_machine_is_compatible("ti,dm814"))

commit 296e583e9987e9f8e24dbc4e96692f987cfd6d95
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 10 18:35:03 2018 +0300

    clk: ti: am33xx: add new clkctrl data for am33xx
    
    The new clkctrl data layout for am33xx is split based on clockdomain
    boundaries. Previously the split was based on CM boundaries. This patch
    adds the new data as separate data entity, retaining the compatibility
    data also for now. The compatibility data can be removed once no longer
    needed.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 82c53034b82c..1d78d6c6e8fc 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -467,8 +467,12 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		data = dra7_clkctrl_data;
 #endif
 #ifdef CONFIG_SOC_AM33XX
-	if (of_machine_is_compatible("ti,am33xx"))
-		data = am3_clkctrl_compat_data;
+	if (of_machine_is_compatible("ti,am33xx")) {
+		if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
+			data = am3_clkctrl_compat_data;
+		else
+			data = am3_clkctrl_data;
+	}
 #endif
 #ifdef CONFIG_SOC_AM43XX
 	if (of_machine_is_compatible("ti,am4372"))

commit e97017f935fcb3d505d86738817230552f58a19a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 10 18:22:02 2018 +0300

    clk: ti: am33xx: rename existing clkctrl data as compat data
    
    Rename the existing clkctrl data in preparation of upcoming clkdm
    based split for it. Once the DT data has transitioned also, the
    compat data can be removed.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index e4b431b63e6b..82c53034b82c 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -468,7 +468,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 #endif
 #ifdef CONFIG_SOC_AM33XX
 	if (of_machine_is_compatible("ti,am33xx"))
-		data = am3_clkctrl_data;
+		data = am3_clkctrl_compat_data;
 #endif
 #ifdef CONFIG_SOC_AM43XX
 	if (of_machine_is_compatible("ti,am4372"))

commit 1dc88f78da594042b549f1ea70de2fb721990e3c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Aug 30 09:58:31 2018 +0300

    clk: ti: clkctrl: replace dashes from clkdm name with underscore
    
    The change in the DTS data node naming prevents using underscore
    within the node names and force usage of dash instead. On the other
    hand, clockdomains use underscore instead of dash, so this must be
    replaced within the driver code so that the mapping between the two
    can be done properly.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 9bff57f0345d..e4b431b63e6b 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -445,6 +445,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	const __be32 *addrp;
 	u32 addr;
 	int ret;
+	char *c;
 
 	if (!(ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT) &&
 	    !strcmp(node->name, "clk"))
@@ -532,6 +533,15 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 
 	strcat(provider->clkdm_name, "clkdm");
 
+	/* Replace any dash from the clkdm name with underscore */
+	c = provider->clkdm_name;
+
+	while (*c) {
+		if (*c == '-')
+			*c = '_';
+		c++;
+	}
+
 	INIT_LIST_HEAD(&provider->clocks);
 
 	/* Generate clocks */

commit 47b00dcf141172c4c1c583701ec91923672cec39
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 10 11:29:09 2018 +0300

    clk: ti: clkctrl: support multiple clkctrl nodes under a cm node
    
    Currently, only one clkctrl node can be added under a specific CM node
    due to limitation with the implementation. Modify the code to pick-up
    clockdomain name from the clkctrl node instead of CM node if provided.
    Also, add a new flag to the TI clock driver so that both modes can
    be supported simultaneously.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 421b05392220..9bff57f0345d 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -259,8 +259,13 @@ _ti_clkctrl_clk_register(struct omap_clkctrl_provider *provider,
 	struct omap_clkctrl_clk *clkctrl_clk;
 	int ret = 0;
 
-	init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d", node->parent->name,
-			      node->name, offset, bit);
+	if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
+		init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d",
+				      node->parent->name, node->name, offset,
+				      bit);
+	else
+		init.name = kasprintf(GFP_KERNEL, "%s:%04x:%d", node->name,
+				      offset, bit);
 	clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
 	if (!init.name || !clkctrl_clk) {
 		ret = -ENOMEM;
@@ -441,6 +446,10 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	u32 addr;
 	int ret;
 
+	if (!(ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT) &&
+	    !strcmp(node->name, "clk"))
+		ti_clk_features.flags |= TI_CLK_CLKCTRL_COMPAT;
+
 	addrp = of_get_address(node, 0, NULL, NULL);
 	addr = (u32)of_translate_address(node, addrp);
 
@@ -492,19 +501,35 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 
 	provider->base = of_iomap(node, 0);
 
-	provider->clkdm_name = kmalloc(strlen(node->parent->name) + 3,
-				       GFP_KERNEL);
-	if (!provider->clkdm_name) {
-		kfree(provider);
-		return;
+	if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT) {
+		provider->clkdm_name = kmalloc(strlen(node->parent->name) + 3,
+					       GFP_KERNEL);
+		if (!provider->clkdm_name) {
+			kfree(provider);
+			return;
+		}
+
+		/*
+		 * Create default clkdm name, replace _cm from end of parent
+		 * node name with _clkdm
+		 */
+		strcpy(provider->clkdm_name, node->parent->name);
+		provider->clkdm_name[strlen(provider->clkdm_name) - 2] = 0;
+	} else {
+		provider->clkdm_name = kmalloc(strlen(node->name), GFP_KERNEL);
+		if (!provider->clkdm_name) {
+			kfree(provider);
+			return;
+		}
+
+		/*
+		 * Create default clkdm name, replace _clkctrl from end of
+		 * node name with _clkdm
+		 */
+		strcpy(provider->clkdm_name, node->name);
+		provider->clkdm_name[strlen(provider->clkdm_name) - 7] = 0;
 	}
 
-	/*
-	 * Create default clkdm name, replace _cm from end of parent node
-	 * name with _clkdm
-	 */
-	strcpy(provider->clkdm_name, node->parent->name);
-	provider->clkdm_name[strlen(provider->clkdm_name) - 2] = 0;
 	strcat(provider->clkdm_name, "clkdm");
 
 	INIT_LIST_HEAD(&provider->clocks);
@@ -539,9 +564,13 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		init.flags = 0;
 		if (reg_data->flags & CLKF_SET_RATE_PARENT)
 			init.flags |= CLK_SET_RATE_PARENT;
-		init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d",
-				      node->parent->name, node->name,
-				      reg_data->offset, 0);
+		if (ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT)
+			init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d",
+					      node->parent->name, node->name,
+					      reg_data->offset, 0);
+		else
+			init.name = kasprintf(GFP_KERNEL, "%s:%04x:%d",
+					      node->name, reg_data->offset, 0);
 		clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
 		if (!init.name || !clkctrl_clk)
 			goto cleanup;

commit e665f029a283aff4f36f0c5388f7c708be67470e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Aug 28 10:44:29 2018 -0500

    clk: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 421b05392220..240e911a3db9 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -259,8 +259,8 @@ _ti_clkctrl_clk_register(struct omap_clkctrl_provider *provider,
 	struct omap_clkctrl_clk *clkctrl_clk;
 	int ret = 0;
 
-	init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d", node->parent->name,
-			      node->name, offset, bit);
+	init.name = kasprintf(GFP_KERNEL, "%pOFn:%pOFn:%04x:%d", node->parent,
+			      node, offset, bit);
 	clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
 	if (!init.name || !clkctrl_clk) {
 		ret = -ENOMEM;
@@ -492,8 +492,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 
 	provider->base = of_iomap(node, 0);
 
-	provider->clkdm_name = kmalloc(strlen(node->parent->name) + 3,
-				       GFP_KERNEL);
+	provider->clkdm_name = kasprintf(GFP_KERNEL, "%pOFnxxx", node->parent);
 	if (!provider->clkdm_name) {
 		kfree(provider);
 		return;
@@ -503,8 +502,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	 * Create default clkdm name, replace _cm from end of parent node
 	 * name with _clkdm
 	 */
-	strcpy(provider->clkdm_name, node->parent->name);
-	provider->clkdm_name[strlen(provider->clkdm_name) - 2] = 0;
+	provider->clkdm_name[strlen(provider->clkdm_name) - 5] = 0;
 	strcat(provider->clkdm_name, "clkdm");
 
 	INIT_LIST_HEAD(&provider->clocks);
@@ -539,8 +537,8 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		init.flags = 0;
 		if (reg_data->flags & CLKF_SET_RATE_PARENT)
 			init.flags |= CLK_SET_RATE_PARENT;
-		init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d",
-				      node->parent->name, node->name,
+		init.name = kasprintf(GFP_KERNEL, "%pOFn:%pOFn:%04x:%d",
+				      node->parent, node,
 				      reg_data->offset, 0);
 		clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
 		if (!init.name || !clkctrl_clk)

commit 49159a9dc3da83f17be00acbc7b2ab84ffec1aa7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Feb 23 14:28:21 2018 +0200

    clk: ti: clkctrl: add support for CLK_SET_RATE_PARENT flag
    
    Certain clkctrl clocks, notably the display ones, use the
    CLK_SET_RATE_PARENT feature extensively. Add support for this flag
    to the clkctrl clocks.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reported-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Jyri Sarha <jsarha@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index afa0d6bfc5c1..421b05392220 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -537,6 +537,8 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		init.parent_names = &reg_data->parent;
 		init.num_parents = 1;
 		init.flags = 0;
+		if (reg_data->flags & CLKF_SET_RATE_PARENT)
+			init.flags |= CLK_SET_RATE_PARENT;
 		init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d",
 				      node->parent->name, node->name,
 				      reg_data->offset, 0);

commit 50ef50897e52c8ae7873b1692a44ac1ca8130fe3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Aug 24 15:44:14 2017 +0300

    clk: ti: dm816: add clkctrl clock data
    
    Add data for dm816 clkctrl clocks, and register it within the clkctrl
    driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index ff3312fe173e..afa0d6bfc5c1 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -469,6 +469,9 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 #ifdef CONFIG_SOC_TI81XX
 	if (of_machine_is_compatible("ti,dm814"))
 		data = dm814_clkctrl_data;
+
+	if (of_machine_is_compatible("ti,dm816"))
+		data = dm816_clkctrl_data;
 #endif
 
 	while (data->addr) {

commit 26ca2e9738449ea81fffdfb5cd62823d1be9cf00
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Aug 24 15:41:37 2017 +0300

    clk: ti: dm814: add clkctrl clock data
    
    Add data for dm814 clkctrl clocks, and register it within the clkctrl
    driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index b524bc9dfb23..ff3312fe173e 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -466,6 +466,10 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	if (of_machine_is_compatible("ti,am438x"))
 		data = am438x_clkctrl_data;
 #endif
+#ifdef CONFIG_SOC_TI81XX
+	if (of_machine_is_compatible("ti,dm814"))
+		data = dm814_clkctrl_data;
+#endif
 
 	while (data->addr) {
 		if (addr == data->addr)

commit a3da10b70978e77ccd9d3f6c14a33d54cda74141
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Aug 10 16:11:06 2017 +0300

    clk: ti: am43xx: add clkctrl clock data
    
    Add data for am43xx clkctrl clocks, and register it within the clkctrl
    driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 66548eb19bfc..b524bc9dfb23 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -460,6 +460,12 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	if (of_machine_is_compatible("ti,am33xx"))
 		data = am3_clkctrl_data;
 #endif
+#ifdef CONFIG_SOC_AM43XX
+	if (of_machine_is_compatible("ti,am4372"))
+		data = am4_clkctrl_data;
+	if (of_machine_is_compatible("ti,am438x"))
+		data = am438x_clkctrl_data;
+#endif
 
 	while (data->addr) {
 		if (addr == data->addr)

commit df54bfc5502ac67c152e1d9d36f6e8c03a07af0c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Aug 9 11:59:29 2017 +0300

    clk: ti: am33xx: add clkctrl clock data
    
    Add data for am33xx clkctrl clocks, and register it within the clkctrl
    driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 3de4cf2771b9..66548eb19bfc 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -456,6 +456,10 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	if (of_machine_is_compatible("ti,dra7"))
 		data = dra7_clkctrl_data;
 #endif
+#ifdef CONFIG_SOC_AM33XX
+	if (of_machine_is_compatible("ti,am33xx"))
+		data = am3_clkctrl_data;
+#endif
 
 	while (data->addr) {
 		if (addr == data->addr)

commit 24d504a38bef390a68c46b68aeff76c6debf4b91
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 4 17:25:08 2017 +0300

    clk: ti: dra7: add clkctrl clock data
    
    Add data for dra7 clkctrl clocks, and register it within the clkctrl
    driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 9f6706fe0616..3de4cf2771b9 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -452,6 +452,10 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	if (of_machine_is_compatible("ti,omap5"))
 		data = omap5_clkctrl_data;
 #endif
+#ifdef CONFIG_SOC_DRA7XX
+	if (of_machine_is_compatible("ti,dra7"))
+		data = dra7_clkctrl_data;
+#endif
 
 	while (data->addr) {
 		if (addr == data->addr)

commit 0ad902f62f484fc6c05b4dddf3fdc388128dae55
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Jul 31 12:16:24 2017 +0300

    clk: ti: omap5: add clkctrl clock data
    
    Add data for omap5 clkctrl clocks, and register it within the clkctrl
    driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 3bab88e4fffa..9f6706fe0616 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -448,6 +448,10 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	if (of_machine_is_compatible("ti,omap4"))
 		data = omap4_clkctrl_data;
 #endif
+#ifdef CONFIG_SOC_OMAP5
+	if (of_machine_is_compatible("ti,omap5"))
+		data = omap5_clkctrl_data;
+#endif
 
 	while (data->addr) {
 		if (addr == data->addr)

commit 49eec6fbe125d691944d077f6155c3ccac3a0e71
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Oct 11 17:56:10 2017 +0300

    clk: ti: clkctrl: fix flags for mux and divider opt clocks
    
    Flag handling was missing for these two, so add it.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 7d82fff25d5b..3bab88e4fffa 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -335,6 +335,9 @@ _ti_clkctrl_setup_mux(struct omap_clkctrl_provider *provider,
 	}
 
 	mux->mask = num_parents;
+	if (!(mux->flags & CLK_MUX_INDEX_ONE))
+		mux->mask--;
+
 	mux->mask = (1 << fls(mux->mask)) - 1;
 
 	mux->shift = data->bit;
@@ -354,6 +357,7 @@ _ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,
 {
 	struct clk_omap_divider *div;
 	const struct omap_clkctrl_div_data *div_data = data->data;
+	u8 div_flags = 0;
 
 	div = kzalloc(sizeof(*div), GFP_KERNEL);
 	if (!div)
@@ -361,9 +365,13 @@ _ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,
 
 	div->reg.ptr = reg;
 	div->shift = data->bit;
+	div->flags = div_data->flags;
+
+	if (div->flags & CLK_DIVIDER_POWER_OF_TWO)
+		div_flags |= CLKF_INDEX_POWER_OF_TWO;
 
-	if (ti_clk_parse_divider_data((int *)div_data->dividers,
-				      div_data->max_div, 0, 0,
+	if (ti_clk_parse_divider_data((int *)div_data->dividers, 0,
+				      div_data->max_div, div_flags,
 				      &div->width, &div->table)) {
 		pr_err("%s: Data parsing for %pOF:%04x:%d failed\n", __func__,
 		       node, offset, data->bit);

commit 729e13bf58e643b9accd2a14c55b555958702fb0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Oct 12 10:55:29 2017 +0300

    clk: ti: clkctrl: add support for retrying failed init
    
    In case the clkctrl node contains assigned-clock-* entries, registering
    the provider can fail with -EPROBE_DEFER. In this case, add the
    provider to the retry_init clock list so it will be cleaned up later.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 38dbcc1b7e2c..7d82fff25d5b 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -414,6 +414,12 @@ _ti_clkctrl_setup_subclks(struct omap_clkctrl_provider *provider,
 	}
 }
 
+static void __init _clkctrl_add_provider(void *data,
+					 struct device_node *np)
+{
+	of_clk_add_hw_provider(np, _ti_omap4_clkctrl_xlate, data);
+}
+
 static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 {
 	struct omap_clkctrl_provider *provider;
@@ -425,6 +431,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	struct omap_clkctrl_clk *clkctrl_clk;
 	const __be32 *addrp;
 	u32 addr;
+	int ret;
 
 	addrp = of_get_address(node, 0, NULL, NULL);
 	addr = (u32)of_translate_address(node, addrp);
@@ -519,7 +526,10 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		reg_data++;
 	}
 
-	of_clk_add_hw_provider(node, _ti_omap4_clkctrl_xlate, provider);
+	ret = of_clk_add_hw_provider(node, _ti_omap4_clkctrl_xlate, provider);
+	if (ret == -EPROBE_DEFER)
+		ti_clk_retry_init(node, provider, _clkctrl_add_provider);
+
 	return;
 
 cleanup:

commit 3d8598fb9c5a77837d9c0951efc5c36fdf91d87c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Aug 15 11:42:17 2017 +0300

    clk: ti: clkctrl: use fallback udelay approach if timekeeping is suspended
    
    In certain cases it is possible that the timekeeping has been suspended
    already when attempting to disable/enable a clkctrl clock. This will
    happen at least on am43xx platform when attempting to enable / disable
    the clockevent source itself, burping out a warning from timekeeping core.
    
    The sequence of events leading to this:
    -> timekeeping_suspend()
     -> clockevents_suspend()
      -> omap_clkevt_idle()
       -> omap_hwmod_idle()
        -> _omap4_clkctrl_clk_disable()
         -> _omap4_is_timeout()
    
    Avoid the issue by checking if the timekeeping is suspended and using
    the fallback udelay approach for checking timeouts.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 284ba449615c..38dbcc1b7e2c 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -21,6 +21,7 @@
 #include <linux/of_address.h>
 #include <linux/clk/ti.h>
 #include <linux/delay.h>
+#include <linux/timekeeping.h>
 #include "clock.h"
 
 #define NO_IDLEST			0x1
@@ -90,7 +91,18 @@ static bool _omap4_is_ready(u32 val)
 
 static bool _omap4_is_timeout(union omap4_timeout *time, u32 timeout)
 {
-	if (unlikely(_early_timeout)) {
+	/*
+	 * There are two special cases where ktime_to_ns() can't be
+	 * used to track the timeouts. First one is during early boot
+	 * when the timers haven't been initialized yet. The second
+	 * one is during suspend-resume cycle while timekeeping is
+	 * being suspended / resumed. Clocksource for the system
+	 * can be from a timer that requires pm_runtime access, which
+	 * will eventually bring us here with timekeeping_suspended,
+	 * during both suspend entry and resume paths. This happens
+	 * at least on am43xx platform.
+	 */
+	if (unlikely(_early_timeout || timekeeping_suspended)) {
 		if (time->cycles++ < timeout) {
 			udelay(1);
 			return false;

commit ddfb183e2e434acf9361d3e8b37bdf22656561e4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Sep 18 21:02:24 2017 +0300

    clk: ti: clkctrl: add support for clkdm init for clkctrl clocks
    
    Clkctrl clocks now support clockdomain init also. This will be needed
    so that hwmod core can drop the support for clockdomain handling.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 2db7d4080f25..284ba449615c 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -46,6 +46,7 @@ static bool _early_timeout = true;
 struct omap_clkctrl_provider {
 	void __iomem *base;
 	struct list_head clocks;
+	char *clkdm_name;
 };
 
 struct omap_clkctrl_clk {
@@ -208,6 +209,7 @@ static const struct clk_ops omap4_clkctrl_clk_ops = {
 	.enable		= _omap4_clkctrl_clk_enable,
 	.disable	= _omap4_clkctrl_clk_disable,
 	.is_enabled	= _omap4_clkctrl_clk_is_enabled,
+	.init		= omap2_init_clk_clkdm,
 };
 
 static struct clk_hw *_ti_omap4_clkctrl_xlate(struct of_phandle_args *clkspec,
@@ -438,6 +440,21 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 
 	provider->base = of_iomap(node, 0);
 
+	provider->clkdm_name = kmalloc(strlen(node->parent->name) + 3,
+				       GFP_KERNEL);
+	if (!provider->clkdm_name) {
+		kfree(provider);
+		return;
+	}
+
+	/*
+	 * Create default clkdm name, replace _cm from end of parent node
+	 * name with _clkdm
+	 */
+	strcpy(provider->clkdm_name, node->parent->name);
+	provider->clkdm_name[strlen(provider->clkdm_name) - 2] = 0;
+	strcat(provider->clkdm_name, "clkdm");
+
 	INIT_LIST_HEAD(&provider->clocks);
 
 	/* Generate clocks */
@@ -460,6 +477,11 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 		if (reg_data->flags & CLKF_NO_IDLEST)
 			hw->flags |= NO_IDLEST;
 
+		if (reg_data->clkdm_name)
+			hw->clkdm_name = reg_data->clkdm_name;
+		else
+			hw->clkdm_name = provider->clkdm_name;
+
 		init.parent_names = &reg_data->parent;
 		init.num_parents = 1;
 		init.flags = 0;

commit c2c296c34c98f3a430ba7a38da96a256d28c203f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Sep 18 21:01:26 2017 +0300

    clk: ti: clkctrl: fix error messages to print out node name properly
    
    Current node name does not convey any information, as it is always "clk".
    Instead, print out the full node path, which will tell us better where
    something went wrong.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index 53e71d0503ec..2db7d4080f25 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -351,8 +351,8 @@ _ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,
 	if (ti_clk_parse_divider_data((int *)div_data->dividers,
 				      div_data->max_div, 0, 0,
 				      &div->width, &div->table)) {
-		pr_err("%s: Data parsing for %s:%04x:%d failed\n", __func__,
-		       node->name, offset, data->bit);
+		pr_err("%s: Data parsing for %pOF:%04x:%d failed\n", __func__,
+		       node, offset, data->bit);
 		kfree(div);
 		return;
 	}
@@ -428,7 +428,7 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	}
 
 	if (!data->addr) {
-		pr_err("%s not found from clkctrl data.\n", node->name);
+		pr_err("%pOF not found from clkctrl data.\n", node);
 		return;
 	}
 

commit 1c881b5a4f84190f50b81bf22e251e00050f4fbb
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 9 11:34:23 2017 +0200

    clk: ti: omap4: add clkctrl clock data
    
    Add data for omap4 clkctrl clocks, and register it within the clkctrl
    driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
index bc399581dabc..53e71d0503ec 100644
--- a/drivers/clk/ti/clkctrl.c
+++ b/drivers/clk/ti/clkctrl.c
@@ -415,6 +415,11 @@ static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
 	addrp = of_get_address(node, 0, NULL, NULL);
 	addr = (u32)of_translate_address(node, addrp);
 
+#ifdef CONFIG_ARCH_OMAP4
+	if (of_machine_is_compatible("ti,omap4"))
+		data = omap4_clkctrl_data;
+#endif
+
 	while (data->addr) {
 		if (addr == data->addr)
 			break;

commit 88a172526c326b357eb6c19e0f90d8cf5bd4473d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 9 11:27:11 2017 +0200

    clk: ti: add support for clkctrl clocks
    
    Previously, hwmod core has been used for controlling the hwmod level
    clocks directly. This has certain drawbacks, like being unable to share
    the clocks for multiple users, missing usecounting and generally being
    totally incompatible with the common clock framework.
    
    This patch adds support for clkctrl clocks for addressing the above
    issues. These support the modulemode handling, which will replace the
    direct hwmod clkctrl linkage. Any optional clocks are also supported,
    gate, mux and divider.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clkctrl.c b/drivers/clk/ti/clkctrl.c
new file mode 100644
index 000000000000..bc399581dabc
--- /dev/null
+++ b/drivers/clk/ti/clkctrl.c
@@ -0,0 +1,492 @@
+/*
+ * OMAP clkctrl clock support
+ *
+ * Copyright (C) 2017 Texas Instruments, Inc.
+ *
+ * Tero Kristo <t-kristo@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/clk/ti.h>
+#include <linux/delay.h>
+#include "clock.h"
+
+#define NO_IDLEST			0x1
+
+#define OMAP4_MODULEMODE_MASK		0x3
+
+#define MODULEMODE_HWCTRL		0x1
+#define MODULEMODE_SWCTRL		0x2
+
+#define OMAP4_IDLEST_MASK		(0x3 << 16)
+#define OMAP4_IDLEST_SHIFT		16
+
+#define CLKCTRL_IDLEST_FUNCTIONAL	0x0
+#define CLKCTRL_IDLEST_INTERFACE_IDLE	0x2
+#define CLKCTRL_IDLEST_DISABLED		0x3
+
+/* These timeouts are in us */
+#define OMAP4_MAX_MODULE_READY_TIME	2000
+#define OMAP4_MAX_MODULE_DISABLE_TIME	5000
+
+static bool _early_timeout = true;
+
+struct omap_clkctrl_provider {
+	void __iomem *base;
+	struct list_head clocks;
+};
+
+struct omap_clkctrl_clk {
+	struct clk_hw *clk;
+	u16 reg_offset;
+	int bit_offset;
+	struct list_head node;
+};
+
+union omap4_timeout {
+	u32 cycles;
+	ktime_t start;
+};
+
+static const struct omap_clkctrl_data default_clkctrl_data[] __initconst = {
+	{ 0 },
+};
+
+static u32 _omap4_idlest(u32 val)
+{
+	val &= OMAP4_IDLEST_MASK;
+	val >>= OMAP4_IDLEST_SHIFT;
+
+	return val;
+}
+
+static bool _omap4_is_idle(u32 val)
+{
+	val = _omap4_idlest(val);
+
+	return val == CLKCTRL_IDLEST_DISABLED;
+}
+
+static bool _omap4_is_ready(u32 val)
+{
+	val = _omap4_idlest(val);
+
+	return val == CLKCTRL_IDLEST_FUNCTIONAL ||
+	       val == CLKCTRL_IDLEST_INTERFACE_IDLE;
+}
+
+static bool _omap4_is_timeout(union omap4_timeout *time, u32 timeout)
+{
+	if (unlikely(_early_timeout)) {
+		if (time->cycles++ < timeout) {
+			udelay(1);
+			return false;
+		}
+	} else {
+		if (!ktime_to_ns(time->start)) {
+			time->start = ktime_get();
+			return false;
+		}
+
+		if (ktime_us_delta(ktime_get(), time->start) < timeout) {
+			cpu_relax();
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static int __init _omap4_disable_early_timeout(void)
+{
+	_early_timeout = false;
+
+	return 0;
+}
+arch_initcall(_omap4_disable_early_timeout);
+
+static int _omap4_clkctrl_clk_enable(struct clk_hw *hw)
+{
+	struct clk_hw_omap *clk = to_clk_hw_omap(hw);
+	u32 val;
+	int ret;
+	union omap4_timeout timeout = { 0 };
+
+	if (!clk->enable_bit)
+		return 0;
+
+	if (clk->clkdm) {
+		ret = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);
+		if (ret) {
+			WARN(1,
+			     "%s: could not enable %s's clockdomain %s: %d\n",
+			     __func__, clk_hw_get_name(hw),
+			     clk->clkdm_name, ret);
+			return ret;
+		}
+	}
+
+	val = ti_clk_ll_ops->clk_readl(&clk->enable_reg);
+
+	val &= ~OMAP4_MODULEMODE_MASK;
+	val |= clk->enable_bit;
+
+	ti_clk_ll_ops->clk_writel(val, &clk->enable_reg);
+
+	if (clk->flags & NO_IDLEST)
+		return 0;
+
+	/* Wait until module is enabled */
+	while (!_omap4_is_ready(ti_clk_ll_ops->clk_readl(&clk->enable_reg))) {
+		if (_omap4_is_timeout(&timeout, OMAP4_MAX_MODULE_READY_TIME)) {
+			pr_err("%s: failed to enable\n", clk_hw_get_name(hw));
+			return -EBUSY;
+		}
+	}
+
+	return 0;
+}
+
+static void _omap4_clkctrl_clk_disable(struct clk_hw *hw)
+{
+	struct clk_hw_omap *clk = to_clk_hw_omap(hw);
+	u32 val;
+	union omap4_timeout timeout = { 0 };
+
+	if (!clk->enable_bit)
+		return;
+
+	val = ti_clk_ll_ops->clk_readl(&clk->enable_reg);
+
+	val &= ~OMAP4_MODULEMODE_MASK;
+
+	ti_clk_ll_ops->clk_writel(val, &clk->enable_reg);
+
+	if (clk->flags & NO_IDLEST)
+		goto exit;
+
+	/* Wait until module is disabled */
+	while (!_omap4_is_idle(ti_clk_ll_ops->clk_readl(&clk->enable_reg))) {
+		if (_omap4_is_timeout(&timeout,
+				      OMAP4_MAX_MODULE_DISABLE_TIME)) {
+			pr_err("%s: failed to disable\n", clk_hw_get_name(hw));
+			break;
+		}
+	}
+
+exit:
+	if (clk->clkdm)
+		ti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);
+}
+
+static int _omap4_clkctrl_clk_is_enabled(struct clk_hw *hw)
+{
+	struct clk_hw_omap *clk = to_clk_hw_omap(hw);
+	u32 val;
+
+	val = ti_clk_ll_ops->clk_readl(&clk->enable_reg);
+
+	if (val & clk->enable_bit)
+		return 1;
+
+	return 0;
+}
+
+static const struct clk_ops omap4_clkctrl_clk_ops = {
+	.enable		= _omap4_clkctrl_clk_enable,
+	.disable	= _omap4_clkctrl_clk_disable,
+	.is_enabled	= _omap4_clkctrl_clk_is_enabled,
+};
+
+static struct clk_hw *_ti_omap4_clkctrl_xlate(struct of_phandle_args *clkspec,
+					      void *data)
+{
+	struct omap_clkctrl_provider *provider = data;
+	struct omap_clkctrl_clk *entry;
+
+	if (clkspec->args_count != 2)
+		return ERR_PTR(-EINVAL);
+
+	pr_debug("%s: looking for %x:%x\n", __func__,
+		 clkspec->args[0], clkspec->args[1]);
+
+	list_for_each_entry(entry, &provider->clocks, node) {
+		if (entry->reg_offset == clkspec->args[0] &&
+		    entry->bit_offset == clkspec->args[1])
+			break;
+	}
+
+	if (!entry)
+		return ERR_PTR(-EINVAL);
+
+	return entry->clk;
+}
+
+static int __init
+_ti_clkctrl_clk_register(struct omap_clkctrl_provider *provider,
+			 struct device_node *node, struct clk_hw *clk_hw,
+			 u16 offset, u8 bit, const char * const *parents,
+			 int num_parents, const struct clk_ops *ops)
+{
+	struct clk_init_data init = { NULL };
+	struct clk *clk;
+	struct omap_clkctrl_clk *clkctrl_clk;
+	int ret = 0;
+
+	init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d", node->parent->name,
+			      node->name, offset, bit);
+	clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
+	if (!init.name || !clkctrl_clk) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	clk_hw->init = &init;
+	init.parent_names = parents;
+	init.num_parents = num_parents;
+	init.ops = ops;
+	init.flags = CLK_IS_BASIC;
+
+	clk = ti_clk_register(NULL, clk_hw, init.name);
+	if (IS_ERR_OR_NULL(clk)) {
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	clkctrl_clk->reg_offset = offset;
+	clkctrl_clk->bit_offset = bit;
+	clkctrl_clk->clk = clk_hw;
+
+	list_add(&clkctrl_clk->node, &provider->clocks);
+
+	return 0;
+
+cleanup:
+	kfree(init.name);
+	kfree(clkctrl_clk);
+	return ret;
+}
+
+static void __init
+_ti_clkctrl_setup_gate(struct omap_clkctrl_provider *provider,
+		       struct device_node *node, u16 offset,
+		       const struct omap_clkctrl_bit_data *data,
+		       void __iomem *reg)
+{
+	struct clk_hw_omap *clk_hw;
+
+	clk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);
+	if (!clk_hw)
+		return;
+
+	clk_hw->enable_bit = data->bit;
+	clk_hw->enable_reg.ptr = reg;
+
+	if (_ti_clkctrl_clk_register(provider, node, &clk_hw->hw, offset,
+				     data->bit, data->parents, 1,
+				     &omap_gate_clk_ops))
+		kfree(clk_hw);
+}
+
+static void __init
+_ti_clkctrl_setup_mux(struct omap_clkctrl_provider *provider,
+		      struct device_node *node, u16 offset,
+		      const struct omap_clkctrl_bit_data *data,
+		      void __iomem *reg)
+{
+	struct clk_omap_mux *mux;
+	int num_parents = 0;
+	const char * const *pname;
+
+	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+	if (!mux)
+		return;
+
+	pname = data->parents;
+	while (*pname) {
+		num_parents++;
+		pname++;
+	}
+
+	mux->mask = num_parents;
+	mux->mask = (1 << fls(mux->mask)) - 1;
+
+	mux->shift = data->bit;
+	mux->reg.ptr = reg;
+
+	if (_ti_clkctrl_clk_register(provider, node, &mux->hw, offset,
+				     data->bit, data->parents, num_parents,
+				     &ti_clk_mux_ops))
+		kfree(mux);
+}
+
+static void __init
+_ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,
+		      struct device_node *node, u16 offset,
+		      const struct omap_clkctrl_bit_data *data,
+		      void __iomem *reg)
+{
+	struct clk_omap_divider *div;
+	const struct omap_clkctrl_div_data *div_data = data->data;
+
+	div = kzalloc(sizeof(*div), GFP_KERNEL);
+	if (!div)
+		return;
+
+	div->reg.ptr = reg;
+	div->shift = data->bit;
+
+	if (ti_clk_parse_divider_data((int *)div_data->dividers,
+				      div_data->max_div, 0, 0,
+				      &div->width, &div->table)) {
+		pr_err("%s: Data parsing for %s:%04x:%d failed\n", __func__,
+		       node->name, offset, data->bit);
+		kfree(div);
+		return;
+	}
+
+	if (_ti_clkctrl_clk_register(provider, node, &div->hw, offset,
+				     data->bit, data->parents, 1,
+				     &ti_clk_divider_ops))
+		kfree(div);
+}
+
+static void __init
+_ti_clkctrl_setup_subclks(struct omap_clkctrl_provider *provider,
+			  struct device_node *node,
+			  const struct omap_clkctrl_reg_data *data,
+			  void __iomem *reg)
+{
+	const struct omap_clkctrl_bit_data *bits = data->bit_data;
+
+	if (!bits)
+		return;
+
+	while (bits->bit) {
+		switch (bits->type) {
+		case TI_CLK_GATE:
+			_ti_clkctrl_setup_gate(provider, node, data->offset,
+					       bits, reg);
+			break;
+
+		case TI_CLK_DIVIDER:
+			_ti_clkctrl_setup_div(provider, node, data->offset,
+					      bits, reg);
+			break;
+
+		case TI_CLK_MUX:
+			_ti_clkctrl_setup_mux(provider, node, data->offset,
+					      bits, reg);
+			break;
+
+		default:
+			pr_err("%s: bad subclk type: %d\n", __func__,
+			       bits->type);
+			return;
+		}
+		bits++;
+	}
+}
+
+static void __init _ti_omap4_clkctrl_setup(struct device_node *node)
+{
+	struct omap_clkctrl_provider *provider;
+	const struct omap_clkctrl_data *data = default_clkctrl_data;
+	const struct omap_clkctrl_reg_data *reg_data;
+	struct clk_init_data init = { NULL };
+	struct clk_hw_omap *hw;
+	struct clk *clk;
+	struct omap_clkctrl_clk *clkctrl_clk;
+	const __be32 *addrp;
+	u32 addr;
+
+	addrp = of_get_address(node, 0, NULL, NULL);
+	addr = (u32)of_translate_address(node, addrp);
+
+	while (data->addr) {
+		if (addr == data->addr)
+			break;
+
+		data++;
+	}
+
+	if (!data->addr) {
+		pr_err("%s not found from clkctrl data.\n", node->name);
+		return;
+	}
+
+	provider = kzalloc(sizeof(*provider), GFP_KERNEL);
+	if (!provider)
+		return;
+
+	provider->base = of_iomap(node, 0);
+
+	INIT_LIST_HEAD(&provider->clocks);
+
+	/* Generate clocks */
+	reg_data = data->regs;
+
+	while (reg_data->parent) {
+		hw = kzalloc(sizeof(*hw), GFP_KERNEL);
+		if (!hw)
+			return;
+
+		hw->enable_reg.ptr = provider->base + reg_data->offset;
+
+		_ti_clkctrl_setup_subclks(provider, node, reg_data,
+					  hw->enable_reg.ptr);
+
+		if (reg_data->flags & CLKF_SW_SUP)
+			hw->enable_bit = MODULEMODE_SWCTRL;
+		if (reg_data->flags & CLKF_HW_SUP)
+			hw->enable_bit = MODULEMODE_HWCTRL;
+		if (reg_data->flags & CLKF_NO_IDLEST)
+			hw->flags |= NO_IDLEST;
+
+		init.parent_names = &reg_data->parent;
+		init.num_parents = 1;
+		init.flags = 0;
+		init.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d",
+				      node->parent->name, node->name,
+				      reg_data->offset, 0);
+		clkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);
+		if (!init.name || !clkctrl_clk)
+			goto cleanup;
+
+		init.ops = &omap4_clkctrl_clk_ops;
+		hw->hw.init = &init;
+
+		clk = ti_clk_register(NULL, &hw->hw, init.name);
+		if (IS_ERR_OR_NULL(clk))
+			goto cleanup;
+
+		clkctrl_clk->reg_offset = reg_data->offset;
+		clkctrl_clk->clk = &hw->hw;
+
+		list_add(&clkctrl_clk->node, &provider->clocks);
+
+		reg_data++;
+	}
+
+	of_clk_add_hw_provider(node, _ti_omap4_clkctrl_xlate, provider);
+	return;
+
+cleanup:
+	kfree(hw);
+	kfree(init.name);
+	kfree(clkctrl_clk);
+}
+CLK_OF_DECLARE(ti_omap4_clkctrl_clock, "ti,clkctrl",
+	       _ti_omap4_clkctrl_setup);
