commit 6c3090520554d535db04f807c313d9a4b81a285c
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 10 09:21:04 2019 -0800

    clk: ti: clkctrl: Fix hidden dependency to node name
    
    We currently have a hidden dependency to the device tree node name for
    the clkctrl clocks. Instead of using standard node name like "clock", we
    must use "l4-per-clkctrl" type naming so the clock driver can find the
    associated clock domain. Further, if "clk" is specified for a clock node
    name, the driver sets TI_CLK_CLKCTRL_COMPAT flag that uses different
    logic for the clock name based on the parent node name for the all the
    clkctrl clocks for the SoC.
    
    If the clock node naming dependency is not understood, the related
    clockdomain is not found, or a wrong one can get used if a clock manager
    has multiple clock domains.
    
    As each clkctrl instance represents a single clock domain, let's allow
    using domain specific compatible names to specify the clock domain.
    
    This simplifies things and removes the hidden dependency to the node
    name. And then later on, after the node names have been standardized,
    we can drop the related code for parsing the node names.
    
    Let's also update the binding to use standard "clock" node naming
    instead of "clk" and add the missing description for reg.
    
    Cc: devicetree@vger.kernel.org
    Cc: Rob Herring <robh+dt@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index e0b8ed3a1e80..3da33c786d77 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -171,7 +171,9 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 		node = of_find_node_by_name(NULL, buf);
 		if (num_args && compat_mode) {
 			parent = node;
-			node = of_get_child_by_name(parent, "clk");
+			node = of_get_child_by_name(parent, "clock");
+			if (!node)
+				node = of_get_child_by_name(parent, "clk");
 			of_node_put(parent);
 		}
 

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index ba17cc5bd04b..e0b8ed3a1e80 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -19,6 +19,7 @@
 #include <linux/clk-provider.h>
 #include <linux/clkdev.h>
 #include <linux/clk/ti.h>
+#include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/list.h>

commit dc2535be1fd547fbd56aff091370280007b0a1af
Merge: fa3d493f7a57 010d5166bbe9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 14 08:46:17 2019 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk subsystem updates from Stephen Boyd:
     "We have a fairly balanced mix of clk driver updates and clk framework
      updates this time around. It's the usual pile of new drivers for new
      hardware out there and the normal small fixes and updates, but then we
      have some core framework changes too.
    
      In the core framework, we introduce support for a clk_get_optional()
      API to get clks that may not always be populated and a way to devm
      manage clkdev lookups registered by provider drivers. We also do some
      refactoring to simplify the interface between clkdev and the common
      clk framework so we can reuse the DT parsing and clk_get() path in
      provider drivers in the future. This work will continue in the next
      few cycles while we convert how providers specify clk parents.
    
      On the driver side, the biggest part of the dirstat is the Amlogic clk
      driver that got support for the G12A SoC. It dominates with almost
      half the overall diff, while the second largest part of the diff is in
      the i.MX clk driver that gained support for imx8mm SoCs. After that,
      we have the Actions Semiconductor and Qualcomm drivers rounding out
      the big part of the dirstat because they both got new hardware support
      for SoCs. The rest is just various updates and non-critical fixes for
      existing drivers.
    
      Core:
       - Convert a few clk bindings to JSON schema format
       - Add a {devm_}clk_get_optional() API
       - Add devm_clk_hw_register_clkdev() API to manage clkdev lookups
       - Start rewriting clk parent registration and supporting device links
         by moving around code that supports clk_get() and DT parsing of the
         'clocks' property
    
      New Drivers:
       - Add Qualcomm MSM8998 RPM managed clks
       - IPA clk support on Qualcomm RPMh clk controllers
       - Actions Semi S500 SoC clk support
       - Support for fixed rate clks populated from an MMIO register
       - Add RPC (QSPI/HyperFLASH) clocks on Renesas R-Car V3H
       - Add TMU (timer) clocks on Renesas RZ/G2E
       - Add Amlogic G12A Always-On Clock Controller
       - Add 32k clock generation for Amlogic AXG
       - Add support for the Mali GPU clocks on Amlogic Meson8
       - Add Amlogic G12A EE clock controller driver
       - Add missing CANFD clocks on Renesas RZ/G2M and RZ/G2E
       - Add i.MX8MM SoC clk driver support
    
      Removed Drivers:
       - Remove clps711x driver as the board support is gone
    
      Updates:
       - 3rd ECO fix for Mediatek MT2712 SoCs
       - Updates for Qualcomm MSM8998 GCC clks
       - Random static analysis fixes for clk drivers
       - Support for sleeping gpios in the clk-gpio type
       - Minor fixes for STM32MP1 clk driver (parents, critical flag, etc.)
       - Split LCDC into two clks on the Marvell MMP2 SoC
       - Various DT of_node refcount fixes
       - Get rid of CLK_IS_BASIC from TI code (yay!)
       - TI Autoidle clk support
       - Fix Amlogic Meson8 APB clock ID name
       - Claim input clocks through DT for Amlogic AXG and GXBB
       - Correct the DU (display unit) parent clock on Renesas RZ/G2E
       - Exynos5433 IMEM CMU crypto clk support (SlimSS)
       - Fix for the PLL-MIPI on the Allwinner A23
       - Fix Rockchip rk3328 PLL rate calculation
       - Add SET_RATE_PARENT flag on display clk of Rockhip rk3066
       - i.MX SCU clk driver clk_set_parent() and cpufreq support"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (150 commits)
      dt-bindings: clock: imx8mq: Fix numbering overlaps and gaps
      clk: ti: clkctrl: Fix clkdm_name regression for TI_CLK_CLKCTRL_COMPAT
      clk: fixup default index for of_clk_get_by_name()
      clk: Move of_clk_*() APIs into clk.c from clkdev.c
      clk: Inform the core about consumer devices
      clk: Introduce of_clk_get_hw_from_clkspec()
      clk: core: clarify the check for runtime PM
      clk: Combine __clk_get() and __clk_create_clk()
      clk: imx8mq: add GPIO clocks to clock tree
      clk: mediatek: correct cpu clock name for MT8173 SoC
      clk: imx: Refactor entire sccg pll clk
      clk: imx: scu: add cpu frequency scaling support
      clk: mediatek: Mark bus and DRAM related clocks as critical
      clk: mediatek: Add flags to mtk_gate
      clk: mediatek: Add MUX_FLAGS macro
      clk: qcom: gcc-sdm845: Define parent of PCIe PIPE clocks
      clk: ingenic: Remove set but not used variable 'enable'
      clk: at91: programmable: remove unneeded register read
      clk: mediatek: using CLK_MUX_ROUND_CLOSEST for the clock of dpi1_sel
      clk: mediatek: add MUX_GATE_FLAGS_2
      ...

commit 8a7f97b902f4fb0d94b355b6b3f1fbd7154cafb9
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:31 2019 -0700

    treewide: add checks for the return value of memblock_alloc*()
    
    Add check for the return value of memblock_alloc*() functions and call
    panic() in case of error.  The panic message repeats the one used by
    panicing memblock allocators with adjustment of parameters to include
    only relevant ones.
    
    The replacement was mostly automated with semantic patches like the one
    below with manual massaging of format strings.
    
      @@
      expression ptr, size, align;
      @@
      ptr = memblock_alloc(size, align);
      + if (!ptr)
      +     panic("%s: Failed to allocate %lu bytes align=0x%lx\n", __func__, size, align);
    
    [anders.roxell@linaro.org: use '%pa' with 'phys_addr_t' type]
      Link: http://lkml.kernel.org/r/20190131161046.21886-1-anders.roxell@linaro.org
    [rppt@linux.ibm.com: fix format strings for panics after memblock_alloc]
      Link: http://lkml.kernel.org/r/1548950940-15145-1-git-send-email-rppt@linux.ibm.com
    [rppt@linux.ibm.com: don't panic if the allocation in sparse_buffer_init fails]
      Link: http://lkml.kernel.org/r/20190131074018.GD28876@rapoport-lnx
    [akpm@linux-foundation.org: fix xtensa printk warning]
    Link: http://lkml.kernel.org/r/1548057848-15136-20-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Reviewed-by: Guo Ren <ren_guo@c-sky.com>                [c-sky]
    Acked-by: Paul Burton <paul.burton@mips.com>            [MIPS]
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>    [s390]
    Reviewed-by: Juergen Gross <jgross@suse.com>            [Xen]
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>  [m68k]
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>             [xtensa]
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index d0cd58534781..5d7fb2eecce4 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -351,6 +351,9 @@ void __init omap2_clk_legacy_provider_init(int index, void __iomem *mem)
 	struct clk_iomap *io;
 
 	io = memblock_alloc(sizeof(*io), SMP_CACHE_BYTES);
+	if (!io)
+		panic("%s: Failed to allocate %zu bytes\n", __func__,
+		      sizeof(*io));
 
 	io->mem = mem;
 

commit e7faa095cbd761ec9e0c0dd83a7425b19ddce510
Merge: 3f8e7e7247e0 0c91c11c7d62 0612fe604d86 5ae51d67aec9 521282237b9d 0ea8cbc15d80
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Mar 8 10:27:40 2019 -0800

    Merge branches 'clk-imx', 'clk-samsung', 'clk-ti', 'clk-uniphier-gear' and 'clk-mmp2-lcdc' into clk-next
    
     - Split LCDC into two clks on the Marvell MMP2 SoC
    
    * clk-imx:
      clk: imx8mq: add GPIO clocks to clock tree
      clk: imx: Refactor entire sccg pll clk
      clk: imx: scu: add cpu frequency scaling support
      clk: imx: imx8mm: Mark init function __init
      clk: imx8mq: Add the missing ARM clock
      dt-bindings: imx8mq-clock: Add the missing ARM clock
      clk: imx: imx8mq: Fix the rate propagation for arm pll
      clk: imx8mq: Add support for the CLKO1 clock
      clk: imx8mq: Fix the CLKO2 source select list
      clk: imx8mq: Add missing M4 clocks
      clk: imx: Add clock driver support for imx8mm
      dt-bindings: imx: Add clock binding doc for imx8mm
      clk: imx: Add PLLs driver for imx8mm soc
      clk: imx5: add imx5_SCC2_IPG_GATE
      clk: imx: scu: add set parent support
      clk: imx: scu: add fallback compatible string support
      clk: imx8mq: Make parent names arrays const pointers
      clk: imx: Make parents const pointer in mux wrappers
      clk: imx: Make parent_names const pointer in composite-8m
    
    * clk-samsung:
      clk: samsung: s3c2443: Mark expected switch fall-through
      clk: samsung: exynos5: Fix kfree() of const memory on setting driver_override
      clk: samsung: exynos5: Fix possible NULL pointer exception on platform_device_alloc() failure
      clk: samsung: exynos5433: Add selected IMEM clocks
      clk: samsung: dt-bindings: Document Exynos5433 IMEM CMU
      clk: samsung: exynos5433: Fix name typo in sssx
      clk: samsung: exynos5433: Fix definition of CLK_ACLK_IMEM_{200, 266} clocks
      clk: samsung: dt-bindings: Add Exynos5433 IMEM CMU clock IDs
    
    * clk-ti:
      clk: clk-twl6040: Fix imprecise external abort for pdmclk
      ARM: OMAP2+: hwmod: disable ick autoidling when a hwmod requires that
      clk: ti: check clock type before doing autoidle ops
      clk: ti: add a usecount for autoidle
      clk: ti: generalize the init sequence of clk_hw_omap clocks
      clk: ti: remove usage of CLK_IS_BASIC
      clk: ti: add new API for checking if a provided clock is an OMAP clock
      clk: ti: move clk_hw_omap list handling under generic part of the driver
    
    * clk-uniphier-gear:
      clk: uniphier: Fix update register for CPU-gear
    
    * clk-mmp2-lcdc:
      clk: mmp2: separate LCDC peripheral clk form the display clock
      dt-bindings: marvell,mmp2: Add clock id for the LCDC clock

commit ead478250b950f1f082d4cb57bed3adeacfe53c3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Jan 15 11:15:15 2019 +0200

    clk: ti: generalize the init sequence of clk_hw_omap clocks
    
    Add a generic API for initializing clocks of clk_hw_omap type clocks,
    and convert the whole TI clock driver suite to use this for registering
    the clocks. Also, get rid of the now redundant API for adding the clocks
    to the OMAP HW clocks list; instead this is used directly from the
    register API.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Keerthy <j-keerthy@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 122af2680833..d1f948163d6a 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -520,20 +520,31 @@ struct clk *ti_clk_register(struct device *dev, struct clk_hw *hw,
 }
 
 /**
- * omap2_init_clk_hw_omap_clocks - initialize an OMAP clock
- * @hw: struct clk_hw * to initialize
+ * ti_clk_register_omap_hw - register a clk_hw_omap to the clock framework
+ * @dev: device for this clock
+ * @hw: hardware clock handle
+ * @con: connection ID for this clock
  *
- * Add an OMAP clock @clk to the internal list of OMAP clocks.  Used
- * temporarily for autoidle handling, until this support can be
- * integrated into the common clock framework code in some way.  No
- * return value.
+ * Registers a clk_hw_omap clock to the clock framewor, adds a clock alias
+ * for it, and adds the list to the available clk_hw_omap type clocks.
+ * Returns a handle to the registered clock if successful, ERR_PTR value
+ * in failure.
  */
-void omap2_init_clk_hw_omap_clocks(struct clk_hw *hw)
+struct clk *ti_clk_register_omap_hw(struct device *dev, struct clk_hw *hw,
+				    const char *con)
 {
-	struct clk_hw_omap *c;
+	struct clk *clk;
+	struct clk_hw_omap *oclk;
 
-	c = to_clk_hw_omap(hw);
-	list_add(&c->node, &clk_hw_omap_clocks);
+	clk = ti_clk_register(dev, hw, con);
+	if (IS_ERR(clk))
+		return clk;
+
+	oclk = to_clk_hw_omap(hw);
+
+	list_add(&oclk->node, &clk_hw_omap_clocks);
+
+	return clk;
 }
 
 /**

commit 7fd79ee78a0318bd23f92c3cf3f4aba03a5dd6ad
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Jan 15 11:15:13 2019 +0200

    clk: ti: add new API for checking if a provided clock is an OMAP clock
    
    omap2_clk_is_hw_omap can now be used to verify if the provided clk_hw
    is an omap HW clock or not. This is done to replace the usage of CLK_IS_BASIC
    flag within the TI clock drivers.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Keerthy <j-keerthy@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 817284324d41..122af2680833 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -559,3 +559,22 @@ int omap2_clk_for_each(int (*fn)(struct clk_hw_omap *hw))
 
 	return ret;
 }
+
+/**
+ * omap2_clk_is_hw_omap - check if the provided clk_hw is OMAP clock
+ * @hw: clk_hw to check if it is an omap clock or not
+ *
+ * Checks if the provided clk_hw is OMAP clock or not. Returns true if
+ * it is, false otherwise.
+ */
+bool omap2_clk_is_hw_omap(struct clk_hw *hw)
+{
+	struct clk_hw_omap *oclk;
+
+	list_for_each_entry(oclk, &clk_hw_omap_clocks, node) {
+		if (&oclk->hw == hw)
+			return true;
+	}
+
+	return false;
+}

commit 77b773aea5a8abccbd25101390e1ba4b33b3fca0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Jan 15 11:15:12 2019 +0200

    clk: ti: move clk_hw_omap list handling under generic part of the driver
    
    Currently the clk_hw_omap list is handled under the autoidle code, but
    it should be accessible generically. Add a few APIs towards this, and
    update the autoidle code to use the generic implementations.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Keerthy <j-keerthy@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index d0cd58534781..817284324d41 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -31,6 +31,7 @@
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
+static LIST_HEAD(clk_hw_omap_clocks);
 struct ti_clk_ll_ops *ti_clk_ll_ops;
 static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
@@ -517,3 +518,44 @@ struct clk *ti_clk_register(struct device *dev, struct clk_hw *hw,
 
 	return clk;
 }
+
+/**
+ * omap2_init_clk_hw_omap_clocks - initialize an OMAP clock
+ * @hw: struct clk_hw * to initialize
+ *
+ * Add an OMAP clock @clk to the internal list of OMAP clocks.  Used
+ * temporarily for autoidle handling, until this support can be
+ * integrated into the common clock framework code in some way.  No
+ * return value.
+ */
+void omap2_init_clk_hw_omap_clocks(struct clk_hw *hw)
+{
+	struct clk_hw_omap *c;
+
+	c = to_clk_hw_omap(hw);
+	list_add(&c->node, &clk_hw_omap_clocks);
+}
+
+/**
+ * omap2_clk_for_each - call function for each registered clk_hw_omap
+ * @fn: pointer to a callback function
+ *
+ * Call @fn for each registered clk_hw_omap, passing @hw to each
+ * function.  @fn must return 0 for success or any other value for
+ * failure.  If @fn returns non-zero, the iteration across clocks
+ * will stop and the non-zero return value will be passed to the
+ * caller of omap2_clk_for_each().
+ */
+int omap2_clk_for_each(int (*fn)(struct clk_hw_omap *hw))
+{
+	int ret;
+	struct clk_hw_omap *hw;
+
+	list_for_each_entry(hw, &clk_hw_omap_clocks, node) {
+		ret = (*fn)(hw);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}

commit 2274d8001fbb5e1942fbcab5ad2eb15553b09ed2
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Wed Dec 26 08:21:31 2018 -0500

    clk: ti: fix refcount leak in ti_dt_clocks_register()
    
    The of_find_compatible_node() returns a node pointer with refcount
    incremented, but there is the lack of use of the of_node_put() when
    done. Add the missing of_node_put() to release the refcount.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Fixes: 5b385a45e001 ("clk: ti: add support for clkctrl aliases")
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index d0cd58534781..5174f9a91679 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -191,9 +191,13 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 			clkdev_add(&c->lk);
 		} else {
 			if (num_args && !has_clkctrl_data) {
-				if (of_find_compatible_node(NULL, NULL,
-							    "ti,clkctrl")) {
+				struct device_node *np;
+
+				np = of_find_compatible_node(NULL, NULL,
+							     "ti,clkctrl");
+				if (np) {
 					has_clkctrl_data = true;
+					of_node_put(np);
 				} else {
 					clkctrl_nodes_missing = true;
 

commit 519f64bf15dccb4f64af34b74ed186c32363ab59
Merge: 0c86e761b951 9a1d6b232bed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 31 11:08:30 2018 -0700

    Merge tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Stephen Boyd:
     "This time it looks like a quieter release cycle in the clk tree. I
      guess that's because of summer time holidays/vacations. The biggest
      change in the diffstat is in the Qualcomm clk driver, where they got
      support for CPUs and handful of SoCs. After that, the at91 driver got
      a major rewrite for newer DT bindings that should make things easier
      going forward and the TI code moved to a clockdomain based design.
    
      The long tail is mostly small driver updates for newer clks and some
      simpler SoC clock drivers such as the Hisilicon and imx support.
    
      In the core framework, we only have two small changes this time.
    
      One is a new clk API to get all clks for a device with the bulk clk
      APIs. This allows drivers that don't care about doing anything besides
      turning on all the clks to just clk_get() them all and turn them on.
    
      The other change is the beginning of a way to support save and restore
      of clk settings in the clk framework. TI is the only user right now,
      but we will want to expand upon this design in the future to support
      more save and restore of clk registers. At least this gets us started
      and works well enough for one SoC, but there's more work in the
      future.
    
      Core:
       - clk_bulk_get_all() API and friends to get all the clks for a device
       - Basic clk state save/restore hooks
    
      New Drivers:
       - Renesas RZ/A2 (R7S9210) SoC, including early clocks
       - Rensas RZ/G1N (R8A7744) and RZ/G2E (R8A774C0) SoCs
       - Rensas RZ/G2M (r8a774a1) SoC
       - Qualcomm Krait CPU clk support
       - Qualcomm QCS404 GCC support
       - Qualcomm SDM660 GCC support
       - Qualcomm SDM845 camera clock controller
       - Ingenic jz4725b CGU
       - Hisilicon 3670 SoC support
       - TI SCI clks on K3 SoCs
       - iMX6 MMDC clks
       - Reset Controller (RMU) support for Actions Semi Owl S900 and S700 SoCs
    
      Updates:
       - Rework at91 PMC clock driver for new DT bindings
       - Nvidia Tegra clk driver MBIST workaround fix
       - S2RAM support for Marvell mvebu periph clks
       - Use updated printk format for OF node names
       - Fix TI code to only search DT subnodes
       - Various static analysis finds
       - Tag various drivers with SPDX license tags
       - Support dynamic frequency switching (DFS) on qcom SDM845 GCC
       - Only use s2mps11 dt-binding defines instead of redefining them in the driver
       - Add some more missing clks to qcom MSM8996 GCC
       - Quad SPI clks on qcom SDM845
       - Add support for CMT timer clocks on R-Car V3H
       - Add support for SHDI and various timer clocks on R-Car V3M
       - Improve OSC and RCLK (watchdog) handling on R-Car Gen3 SoCs
       - Amlogic clk-pll driver improvements and updates
       - Amlogic axg audio controller system clocks
       - Register Amlogic meson8b clock controller early
       - Add support for SATA and Fine Display Processor (FDP) clocks on R-Car M3-N
       - Consolidation of system suspend related code in Exynos, S5P, S3C SoC clk drivers
       - Fixes for system suspend support on Exynos542x (Odroid boards) and Exynos5433 SoC
       - Remove obsoleted Exynos4212 ISP clock definitions
       - Migrated TI am3/4/5 and dra7 SoCs to clockdomain based design
       - TI RTC+DDR sleep mode support for clock save/restore
       - Allwinner A64 display engine support and fixes
       - Allwinner A83t display engine support and fixes"
    
    * tag 'clk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (186 commits)
      clk: qcom: Remove unused arrays in SDM845 GCC
      clk: fixed-rate: fix of_node_get-put imbalance
      clk: s2mps11: Add used attribute to s2mps11_dt_match
      clk: qcom: gcc-sdm660: Add MODULE_LICENSE
      clk: qcom: Add safe switch hook for krait mux clocks
      dt-bindings: clock: Document qcom,krait-cc
      clk: qcom: Add Krait clock controller driver
      dt-bindings: arm: Document qcom,kpss-gcc
      clk: qcom: Add KPSS ACC/GCC driver
      clk: qcom: Add support for Krait clocks
      clk: qcom: Add IPQ806X's HFPLLs
      clk: qcom: Add MSM8960/APQ8064's HFPLLs
      dt-bindings: clock: Document qcom,hfpll
      clk: qcom: Add HFPLL driver
      clk: qcom: Add support for High-Frequency PLLs (HFPLLs)
      ARM: Add Krait L2 register accessor functions
      clk: imx6q: add mmdc0 ipg clock
      clk: imx6sl: add mmdc ipg clocks
      clk: imx6sll: add mmdc1 ipg clock
      clk: imx6sx: add mmdc1 ipg clock
      ...

commit 7e1c4e27928e5f87b9b1eaf06dc31773b2f1e7f1
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:57 2018 -0700

    memblock: stop using implicit alignment to SMP_CACHE_BYTES
    
    When a memblock allocation APIs are called with align = 0, the alignment
    is implicitly set to SMP_CACHE_BYTES.
    
    Implicit alignment is done deep in the memblock allocator and it can
    come as a surprise.  Not that such an alignment would be wrong even
    when used incorrectly but it is better to be explicit for the sake of
    clarity and the prinicple of the least surprise.
    
    Replace all such uses of memblock APIs with the 'align' parameter
    explicitly set to SMP_CACHE_BYTES and stop implicit alignment assignment
    in the memblock internal allocation functions.
    
    For the case when memblock APIs are used via helper functions, e.g.  like
    iommu_arena_new_node() in Alpha, the helper functions were detected with
    Coccinelle's help and then manually examined and updated where
    appropriate.
    
    The direct memblock APIs users were updated using the semantic patch below:
    
    @@
    expression size, min_addr, max_addr, nid;
    @@
    (
    |
    - memblock_alloc_try_nid_raw(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_raw(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid_nopanic(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_nopanic(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid(size, SMP_CACHE_BYTES, min_addr, max_addr, nid)
    |
    - memblock_alloc(size, 0)
    + memblock_alloc(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_raw(size, 0)
    + memblock_alloc_raw(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from(size, 0, min_addr)
    + memblock_alloc_from(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_nopanic(size, 0)
    + memblock_alloc_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low(size, 0)
    + memblock_alloc_low(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low_nopanic(size, 0)
    + memblock_alloc_low_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from_nopanic(size, 0, min_addr)
    + memblock_alloc_from_nopanic(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_node(size, 0, nid)
    + memblock_alloc_node(size, SMP_CACHE_BYTES, nid)
    )
    
    [mhocko@suse.com: changelog update]
    [akpm@linux-foundation.org: coding-style fixes]
    [rppt@linux.ibm.com: fix missed uses of implicit alignment]
      Link: http://lkml.kernel.org/r/20181016133656.GA10925@rapoport-lnx
    Link: http://lkml.kernel.org/r/1538687224-17535-1-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Suggested-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Paul Burton <paul.burton@mips.com>    [MIPS]
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> [powerpc]
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 5b2867a33b98..e205af814582 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -342,7 +342,7 @@ void __init omap2_clk_legacy_provider_init(int index, void __iomem *mem)
 {
 	struct clk_iomap *io;
 
-	io = memblock_alloc(sizeof(*io), 0);
+	io = memblock_alloc(sizeof(*io), SMP_CACHE_BYTES);
 
 	io->mem = mem;
 

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 5c54d3734daf..5b2867a33b98 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -23,7 +23,7 @@
 #include <linux/of_address.h>
 #include <linux/list.h>
 #include <linux/regmap.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/device.h>
 
 #include "clock.h"

commit eb31d559f1e8390195372cd51cfb198da8bc84b9
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:08:04 2018 -0700

    memblock: remove _virt from APIs returning virtual address
    
    The conversion is done using
    
    sed -i 's@memblock_virt_alloc@memblock_alloc@g' \
            $(git grep -l memblock_virt_alloc)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-8-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 7d22e1af2247..5c54d3734daf 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -342,7 +342,7 @@ void __init omap2_clk_legacy_provider_init(int index, void __iomem *mem)
 {
 	struct clk_iomap *io;
 
-	io = memblock_virt_alloc(sizeof(*io), 0);
+	io = memblock_alloc(sizeof(*io), 0);
 
 	io->mem = mem;
 

commit 8a69f1d4707a69faab58d9735c2cb1898140124a
Merge: cc2adbe370f1 a72d785021cb
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Oct 18 15:41:21 2018 -0700

    Merge branch 'clk-ti' into clk-next
    
    * clk-ti:
      clk: ti: Prepare for remove of OF node name
      clk: Clean up suspend/resume coding style
      clk: ti: Add functions to save/restore clk context
      clk: clk: Add clk_gate_restore_context function
      clk: Add functions to save/restore clock context en-masse
      clk: ti: dra7: add new clkctrl data
      clk: ti: dra7xx: rename existing clkctrl data as compat data
      clk: ti: am43xx: add new clkctrl data for am43xx
      clk: ti: am43xx: rename existing clkctrl data as compat data
      clk: ti: am33xx: add new clkctrl data for am33xx
      clk: ti: am33xx: rename existing clkctrl data as compat data
      clk: ti: clkctrl: replace dashes from clkdm name with underscore
      clk: ti: clkctrl: support multiple clkctrl nodes under a cm node
      dt-bindings: clock: dra7xx: add clkctrl indices for new data layout
      dt-bindings: clock: am43xx: add clkctrl indices for new data layout
      dt-bindings: clock: am33xx: add clkctrl indices for new data layout

commit 9710ee14bec9a7ffa385342ffb03f91d274b3d07
Merge: 1affdc35e0a6 e665f029a283 00a461cc32ec 480d99fdc3ee
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Oct 18 15:33:52 2018 -0700

    Merge branches 'clk-dt-name', 'clk-ti-of-node' and 'clk-sa' into clk-next
    
      - Use updated printk format for OF node names
      - Fix TI code to only search DT subnodes
      - Various static analysis finds
    
    * clk-dt-name:
      clk: Convert to using %pOFn instead of device_node.name
    
    * clk-ti-of-node:
      clk: ti: fix OF child-node lookup
    
    * clk-sa:
      clk: mvebu: armada-37xx-tbg: Switch to clk_get and balance it in probe
      reset: hisilicon: fix potential NULL pointer dereference
      clk: cdce925: release child device nodes
      clk: qcom: clk-branch: Use true and false for boolean values

commit 47b00dcf141172c4c1c583701ec91923672cec39
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 10 11:29:09 2018 +0300

    clk: ti: clkctrl: support multiple clkctrl nodes under a cm node
    
    Currently, only one clkctrl node can be added under a specific CM node
    due to limitation with the implementation. Modify the code to pick-up
    clockdomain name from the clkctrl node instead of CM node if provided.
    Also, add a new flag to the TI clock driver so that both modes can
    be supported simultaneously.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 27e0979b3158..8b89be18e39e 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -34,7 +34,7 @@
 struct ti_clk_ll_ops *ti_clk_ll_ops;
 static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
-static struct ti_clk_features ti_clk_features;
+struct ti_clk_features ti_clk_features;
 
 struct clk_iomap {
 	struct regmap *regmap;
@@ -140,6 +140,9 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 	int ret;
 	static bool clkctrl_nodes_missing;
 	static bool has_clkctrl_data;
+	static bool compat_mode;
+
+	compat_mode = ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT;
 
 	for (c = oclks; c->node_name != NULL; c++) {
 		strcpy(buf, c->node_name);
@@ -164,7 +167,7 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 			continue;
 
 		node = of_find_node_by_name(NULL, buf);
-		if (num_args) {
+		if (num_args && compat_mode) {
 			parent = node;
 			node = of_get_child_by_name(parent, "clk");
 			of_node_put(parent);

commit 00a461cc32ec27fa7bd9c874a7b36b0c6c542c12
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Aug 22 11:03:19 2018 +0200

    clk: ti: fix OF child-node lookup
    
    Fix child-node lookup which by using the wrong OF helper was searching
    the whole tree depth-first, something which could end up matching an
    unrelated node.
    
    Also fix the related node-reference leaks.
    
    Fixes: 5b385a45e001 ("clk: ti: add support for clkctrl aliases")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 7d22e1af2247..27e0979b3158 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -129,7 +129,7 @@ int ti_clk_setup_ll_ops(struct ti_clk_ll_ops *ops)
 void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 {
 	struct ti_dt_clk *c;
-	struct device_node *node;
+	struct device_node *node, *parent;
 	struct clk *clk;
 	struct of_phandle_args clkspec;
 	char buf[64];
@@ -164,8 +164,12 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 			continue;
 
 		node = of_find_node_by_name(NULL, buf);
-		if (num_args)
-			node = of_find_node_by_name(node, "clk");
+		if (num_args) {
+			parent = node;
+			node = of_get_child_by_name(parent, "clk");
+			of_node_put(parent);
+		}
+
 		clkspec.np = node;
 		clkspec.args_count = num_args;
 		for (i = 0; i < num_args; i++) {
@@ -173,11 +177,12 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 			if (ret) {
 				pr_warn("Bad tag in %s at %d: %s\n",
 					c->node_name, i, tags[i]);
+				of_node_put(node);
 				return;
 			}
 		}
 		clk = of_clk_get_from_provider(&clkspec);
-
+		of_node_put(node);
 		if (!IS_ERR(clk)) {
 			c->lk.clk = clk;
 			clkdev_add(&c->lk);

commit e665f029a283aff4f36f0c5388f7c708be67470e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Aug 28 10:44:29 2018 -0500

    clk: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 7d22e1af2247..be04214970cf 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -223,7 +223,7 @@ int __init ti_clk_retry_init(struct device_node *node, void *user,
 {
 	struct clk_init_item *retry;
 
-	pr_debug("%s: adding to retry list...\n", node->name);
+	pr_debug("%pOFn: adding to retry list...\n", node);
 	retry = kzalloc(sizeof(*retry), GFP_KERNEL);
 	if (!retry)
 		return -ENOMEM;
@@ -258,14 +258,14 @@ int ti_clk_get_reg_addr(struct device_node *node, int index,
 	}
 
 	if (i == CLK_MAX_MEMMAPS) {
-		pr_err("clk-provider not found for %s!\n", node->name);
+		pr_err("clk-provider not found for %pOFn!\n", node);
 		return -ENOENT;
 	}
 
 	reg->index = i;
 
 	if (of_property_read_u32_index(node, "reg", index, &val)) {
-		pr_err("%s must have reg[%d]!\n", node->name, index);
+		pr_err("%pOFn must have reg[%d]!\n", node, index);
 		return -EINVAL;
 	}
 
@@ -312,7 +312,7 @@ int __init omap2_clk_provider_init(struct device_node *parent, int index,
 	/* get clocks for this parent */
 	clocks = of_get_child_by_name(parent, "clocks");
 	if (!clocks) {
-		pr_err("%s missing 'clocks' child node.\n", parent->name);
+		pr_err("%pOFn missing 'clocks' child node.\n", parent);
 		return -EINVAL;
 	}
 
@@ -365,7 +365,7 @@ void ti_dt_clk_init_retry_clks(void)
 
 	while (!list_empty(&retry_list) && retries) {
 		list_for_each_entry_safe(retry, tmp, &retry_list, link) {
-			pr_debug("retry-init: %s\n", retry->node->name);
+			pr_debug("retry-init: %pOFn\n", retry->node);
 			retry->func(retry->user, retry->node);
 			list_del(&retry->link);
 			kfree(retry);

commit e31922eda18c950d6b51450711ae459b97eae097
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Jul 26 16:47:28 2017 +0300

    clk: ti: add generic support for clock latching
    
    Certain clocks require latching to be done, so that the actual
    settings get updated on the HW that generates the clock signal.
    One example of such a clock is the dra76x GMAC DPLL H14 output,
    which requires its divider settings to be latched when updated.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 4efa2c9ea908..7d22e1af2247 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -275,6 +275,20 @@ int ti_clk_get_reg_addr(struct device_node *node, int index,
 	return 0;
 }
 
+void ti_clk_latch(struct clk_omap_reg *reg, s8 shift)
+{
+	u32 latch;
+
+	if (shift < 0)
+		return;
+
+	latch = 1 << shift;
+
+	ti_clk_ll_ops->clk_rmw(latch, latch, reg);
+	ti_clk_ll_ops->clk_rmw(0, latch, reg);
+	ti_clk_ll_ops->clk_readl(reg); /* OCP barrier */
+}
+
 /**
  * omap2_clk_provider_init - init master clock provider
  * @parent: master node

commit 4902c2025b8ade9c230d4bca25ec5f691e91cb1f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Jul 26 16:47:27 2017 +0300

    clk: ti: add support for register read-modify-write low-level operation
    
    Useful for changing few bits on a register, this makes sure for example
    that the operation is done atomically in case of syscon.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index f4d6802a8544..4efa2c9ea908 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -55,6 +55,29 @@ static void clk_memmap_writel(u32 val, const struct clk_omap_reg *reg)
 		writel_relaxed(val, io->mem + reg->offset);
 }
 
+static void _clk_rmw(u32 val, u32 mask, void __iomem *ptr)
+{
+	u32 v;
+
+	v = readl_relaxed(ptr);
+	v &= ~mask;
+	v |= val;
+	writel_relaxed(v, ptr);
+}
+
+static void clk_memmap_rmw(u32 val, u32 mask, const struct clk_omap_reg *reg)
+{
+	struct clk_iomap *io = clk_memmaps[reg->index];
+
+	if (reg->ptr) {
+		_clk_rmw(val, mask, reg->ptr);
+	} else if (io->regmap) {
+		regmap_update_bits(io->regmap, reg->offset, mask, val);
+	} else {
+		_clk_rmw(val, mask, io->mem + reg->offset);
+	}
+}
+
 static u32 clk_memmap_readl(const struct clk_omap_reg *reg)
 {
 	u32 val;
@@ -89,6 +112,7 @@ int ti_clk_setup_ll_ops(struct ti_clk_ll_ops *ops)
 	ti_clk_ll_ops = ops;
 	ops->clk_readl = clk_memmap_readl;
 	ops->clk_writel = clk_memmap_writel;
+	ops->clk_rmw = clk_memmap_rmw;
 
 	return 0;
 }

commit 7558562a70fbd6b3fa746fa33c76c9333aa0bb32
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 14 08:32:06 2017 -0800

    clk: ti: Drop legacy clk-3xxx-legacy code
    
    We have now had omap3 booting in device tree only mode for a while
    and all this code is unused.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 302c9e64e5fa..f4d6802a8544 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -336,141 +336,6 @@ void ti_dt_clk_init_retry_clks(void)
 	}
 }
 
-#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_ATAGS)
-void __init ti_clk_patch_legacy_clks(struct ti_clk **patch)
-{
-	while (*patch) {
-		memcpy((*patch)->patch, *patch, sizeof(**patch));
-		patch++;
-	}
-}
-
-struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
-{
-	struct clk *clk;
-	struct ti_clk_fixed *fixed;
-	struct ti_clk_fixed_factor *fixed_factor;
-	struct clk_hw *clk_hw;
-	int ret;
-
-	if (setup->clk)
-		return setup->clk;
-
-	switch (setup->type) {
-	case TI_CLK_FIXED:
-		fixed = setup->data;
-
-		clk = clk_register_fixed_rate(NULL, setup->name, NULL, 0,
-					      fixed->frequency);
-		if (!IS_ERR(clk)) {
-			ret = ti_clk_add_alias(NULL, clk, setup->name);
-			if (ret) {
-				clk_unregister(clk);
-				clk = ERR_PTR(ret);
-			}
-		}
-		break;
-	case TI_CLK_MUX:
-		clk = ti_clk_register_mux(setup);
-		break;
-	case TI_CLK_DIVIDER:
-		clk = ti_clk_register_divider(setup);
-		break;
-	case TI_CLK_COMPOSITE:
-		clk = ti_clk_register_composite(setup);
-		break;
-	case TI_CLK_FIXED_FACTOR:
-		fixed_factor = setup->data;
-
-		clk = clk_register_fixed_factor(NULL, setup->name,
-						fixed_factor->parent,
-						0, fixed_factor->mult,
-						fixed_factor->div);
-		if (!IS_ERR(clk)) {
-			ret = ti_clk_add_alias(NULL, clk, setup->name);
-			if (ret) {
-				clk_unregister(clk);
-				clk = ERR_PTR(ret);
-			}
-		}
-		break;
-	case TI_CLK_GATE:
-		clk = ti_clk_register_gate(setup);
-		break;
-	case TI_CLK_DPLL:
-		clk = ti_clk_register_dpll(setup);
-		break;
-	default:
-		pr_err("bad type for %s!\n", setup->name);
-		clk = ERR_PTR(-EINVAL);
-	}
-
-	if (!IS_ERR(clk)) {
-		setup->clk = clk;
-		if (setup->clkdm_name) {
-			clk_hw = __clk_get_hw(clk);
-			if (clk_hw_get_flags(clk_hw) & CLK_IS_BASIC) {
-				pr_warn("can't setup clkdm for basic clk %s\n",
-					setup->name);
-			} else {
-				to_clk_hw_omap(clk_hw)->clkdm_name =
-					setup->clkdm_name;
-				omap2_init_clk_clkdm(clk_hw);
-			}
-		}
-	}
-
-	return clk;
-}
-
-int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
-{
-	struct clk *clk;
-	bool retry;
-	struct ti_clk_alias *retry_clk;
-	struct ti_clk_alias *tmp;
-
-	while (clks->clk) {
-		clk = ti_clk_register_clk(clks->clk);
-		if (IS_ERR(clk)) {
-			if (PTR_ERR(clk) == -EAGAIN) {
-				list_add(&clks->link, &retry_list);
-			} else {
-				pr_err("register for %s failed: %ld\n",
-				       clks->clk->name, PTR_ERR(clk));
-				return PTR_ERR(clk);
-			}
-		}
-		clks++;
-	}
-
-	retry = true;
-
-	while (!list_empty(&retry_list) && retry) {
-		retry = false;
-		list_for_each_entry_safe(retry_clk, tmp, &retry_list, link) {
-			pr_debug("retry-init: %s\n", retry_clk->clk->name);
-			clk = ti_clk_register_clk(retry_clk->clk);
-			if (IS_ERR(clk)) {
-				if (PTR_ERR(clk) == -EAGAIN) {
-					continue;
-				} else {
-					pr_err("register for %s failed: %ld\n",
-					       retry_clk->clk->name,
-					       PTR_ERR(clk));
-					return PTR_ERR(clk);
-				}
-			} else {
-				retry = true;
-				list_del(&retry_clk->link);
-			}
-		}
-	}
-
-	return 0;
-}
-#endif
-
 static const struct of_device_id simple_clk_match_table[] __initconst = {
 	{ .compatible = "fixed-clock" },
 	{ .compatible = "fixed-factor-clock" },

commit ffb009b24388b896d9ca8b54e39a879302142518
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Nov 6 09:43:16 2017 +0200

    clk: ti: convert retry_init param to use void data type
    
    User data should be void type, as the core framework doesn't need to
    know what is passed through.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 10a7045408ba..302c9e64e5fa 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -178,7 +178,7 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 
 struct clk_init_item {
 	struct device_node *node;
-	struct clk_hw *hw;
+	void *user;
 	ti_of_clk_init_cb_t func;
 	struct list_head link;
 };
@@ -188,14 +188,14 @@ static LIST_HEAD(retry_list);
 /**
  * ti_clk_retry_init - retries a failed clock init at later phase
  * @node: device not for the clock
- * @hw: partially initialized clk_hw struct for the clock
+ * @user: user data pointer
  * @func: init function to be called for the clock
  *
  * Adds a failed clock init to the retry list. The retry list is parsed
  * once all the other clocks have been initialized.
  */
-int __init ti_clk_retry_init(struct device_node *node, struct clk_hw *hw,
-			      ti_of_clk_init_cb_t func)
+int __init ti_clk_retry_init(struct device_node *node, void *user,
+			     ti_of_clk_init_cb_t func)
 {
 	struct clk_init_item *retry;
 
@@ -206,7 +206,7 @@ int __init ti_clk_retry_init(struct device_node *node, struct clk_hw *hw,
 
 	retry->node = node;
 	retry->func = func;
-	retry->hw = hw;
+	retry->user = user;
 	list_add(&retry->link, &retry_list);
 
 	return 0;
@@ -328,7 +328,7 @@ void ti_dt_clk_init_retry_clks(void)
 	while (!list_empty(&retry_list) && retries) {
 		list_for_each_entry_safe(retry, tmp, &retry_list, link) {
 			pr_debug("retry-init: %s\n", retry->node->name);
-			retry->func(retry->hw, retry->node);
+			retry->func(retry->user, retry->node);
 			list_del(&retry->link);
 			kfree(retry);
 		}

commit 5b385a45e001955a8f0fb0c98c12039002280a5e
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 26 15:34:27 2017 +0300

    clk: ti: add support for clkctrl aliases
    
    hwmod core still depends on certain clocks being found by name, so we
    need to add support for adding clkctrl clock aliases. This patch can
    be reverted when no longer needed by hwmod core code.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index e5a1c8297a1d..10a7045408ba 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -108,18 +108,70 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 	struct device_node *node;
 	struct clk *clk;
 	struct of_phandle_args clkspec;
+	char buf[64];
+	char *ptr;
+	char *tags[2];
+	int i;
+	int num_args;
+	int ret;
+	static bool clkctrl_nodes_missing;
+	static bool has_clkctrl_data;
 
 	for (c = oclks; c->node_name != NULL; c++) {
-		node = of_find_node_by_name(NULL, c->node_name);
+		strcpy(buf, c->node_name);
+		ptr = buf;
+		for (i = 0; i < 2; i++)
+			tags[i] = NULL;
+		num_args = 0;
+		while (*ptr) {
+			if (*ptr == ':') {
+				if (num_args >= 2) {
+					pr_warn("Bad number of tags on %s\n",
+						c->node_name);
+					return;
+				}
+				tags[num_args++] = ptr + 1;
+				*ptr = 0;
+			}
+			ptr++;
+		}
+
+		if (num_args && clkctrl_nodes_missing)
+			continue;
+
+		node = of_find_node_by_name(NULL, buf);
+		if (num_args)
+			node = of_find_node_by_name(node, "clk");
 		clkspec.np = node;
+		clkspec.args_count = num_args;
+		for (i = 0; i < num_args; i++) {
+			ret = kstrtoint(tags[i], i ? 10 : 16, clkspec.args + i);
+			if (ret) {
+				pr_warn("Bad tag in %s at %d: %s\n",
+					c->node_name, i, tags[i]);
+				return;
+			}
+		}
 		clk = of_clk_get_from_provider(&clkspec);
 
 		if (!IS_ERR(clk)) {
 			c->lk.clk = clk;
 			clkdev_add(&c->lk);
 		} else {
-			pr_warn("failed to lookup clock node %s\n",
-				c->node_name);
+			if (num_args && !has_clkctrl_data) {
+				if (of_find_compatible_node(NULL, NULL,
+							    "ti,clkctrl")) {
+					has_clkctrl_data = true;
+				} else {
+					clkctrl_nodes_missing = true;
+
+					pr_warn("missing clkctrl nodes, please update your dts.\n");
+					continue;
+				}
+			}
+
+			pr_warn("failed to lookup clock node %s, ret=%ld\n",
+				c->node_name, PTR_ERR(clk));
 		}
 	}
 }

commit fc04f27dfc4280ef35540ab40fa14c24ff8cc799
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 19 19:44:56 2017 +0200

    clk: ti: fix building without legacy omap3
    
    When CONFIG_ATAGS or CONFIG_OMAP3 is disabled, we get a build error:
    
    In file included from include/linux/clk-provider.h:15:0,
                     from drivers/clk/ti/clk.c:19:
    drivers/clk/ti/clk.c: In function 'ti_clk_add_aliases':
    drivers/clk/ti/clk.c:438:29: error: 'simple_clk_match_table' undeclared (first use in this function); did you mean 'simple_attr_write'?
    
    Moving the match table down fixes it.
    
    Fixes: c17435c56bb1 ("clk: ti: add API for creating aliases automatically for simple clock types")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index ddbad7e8d7c9..e5a1c8297a1d 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -371,12 +371,6 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	return clk;
 }
 
-static const struct of_device_id simple_clk_match_table[] __initconst = {
-	{ .compatible = "fixed-clock" },
-	{ .compatible = "fixed-factor-clock" },
-	{ }
-};
-
 int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 {
 	struct clk *clk;
@@ -425,6 +419,12 @@ int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 }
 #endif
 
+static const struct of_device_id simple_clk_match_table[] __initconst = {
+	{ .compatible = "fixed-clock" },
+	{ .compatible = "fixed-factor-clock" },
+	{ }
+};
+
 /**
  * ti_clk_add_aliases - setup clock aliases
  *

commit 6c0afb503937a12a8d20a805fcf263e31afa9871
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 9 11:24:37 2017 +0200

    clk: ti: convert to use proper register definition for all accesses
    
    Currently, TI clock driver uses an encapsulated struct that is cast into
    a void pointer to store all register addresses. This can be considered
    as rather nasty hackery, and prevents from expanding the register
    address field also. Instead, replace all the code to use proper struct
    in place for this, which contains all the previously used data.
    
    This patch is rather large as it is touching multiple files, but this
    can't be split up as we need to avoid any boot breakage.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 024123f421d6..ddbad7e8d7c9 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -43,27 +43,29 @@ struct clk_iomap {
 
 static struct clk_iomap *clk_memmaps[CLK_MAX_MEMMAPS];
 
-static void clk_memmap_writel(u32 val, void __iomem *reg)
+static void clk_memmap_writel(u32 val, const struct clk_omap_reg *reg)
 {
-	struct clk_omap_reg *r = (struct clk_omap_reg *)&reg;
-	struct clk_iomap *io = clk_memmaps[r->index];
+	struct clk_iomap *io = clk_memmaps[reg->index];
 
-	if (io->regmap)
-		regmap_write(io->regmap, r->offset, val);
+	if (reg->ptr)
+		writel_relaxed(val, reg->ptr);
+	else if (io->regmap)
+		regmap_write(io->regmap, reg->offset, val);
 	else
-		writel_relaxed(val, io->mem + r->offset);
+		writel_relaxed(val, io->mem + reg->offset);
 }
 
-static u32 clk_memmap_readl(void __iomem *reg)
+static u32 clk_memmap_readl(const struct clk_omap_reg *reg)
 {
 	u32 val;
-	struct clk_omap_reg *r = (struct clk_omap_reg *)&reg;
-	struct clk_iomap *io = clk_memmaps[r->index];
+	struct clk_iomap *io = clk_memmaps[reg->index];
 
-	if (io->regmap)
-		regmap_read(io->regmap, r->offset, &val);
+	if (reg->ptr)
+		val = readl_relaxed(reg->ptr);
+	else if (io->regmap)
+		regmap_read(io->regmap, reg->offset, &val);
 	else
-		val = readl_relaxed(io->mem + r->offset);
+		val = readl_relaxed(io->mem + reg->offset);
 
 	return val;
 }
@@ -162,20 +164,18 @@ int __init ti_clk_retry_init(struct device_node *node, struct clk_hw *hw,
  * ti_clk_get_reg_addr - get register address for a clock register
  * @node: device node for the clock
  * @index: register index from the clock node
+ * @reg: pointer to target register struct
  *
- * Builds clock register address from device tree information. This
- * is a struct of type clk_omap_reg. Returns a pointer to the register
- * address, or a pointer error value in failure.
+ * Builds clock register address from device tree information, and returns
+ * the data via the provided output pointer @reg. Returns 0 on success,
+ * negative error value on failure.
  */
-void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
+int ti_clk_get_reg_addr(struct device_node *node, int index,
+			struct clk_omap_reg *reg)
 {
-	struct clk_omap_reg *reg;
 	u32 val;
-	u32 tmp;
 	int i;
 
-	reg = (struct clk_omap_reg *)&tmp;
-
 	for (i = 0; i < CLK_MAX_MEMMAPS; i++) {
 		if (clocks_node_ptr[i] == node->parent)
 			break;
@@ -183,19 +183,20 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 
 	if (i == CLK_MAX_MEMMAPS) {
 		pr_err("clk-provider not found for %s!\n", node->name);
-		return IOMEM_ERR_PTR(-ENOENT);
+		return -ENOENT;
 	}
 
 	reg->index = i;
 
 	if (of_property_read_u32_index(node, "reg", index, &val)) {
 		pr_err("%s must have reg[%d]!\n", node->name, index);
-		return IOMEM_ERR_PTR(-EINVAL);
+		return -EINVAL;
 	}
 
 	reg->offset = val;
+	reg->ptr = NULL;
 
-	return (__force void __iomem *)tmp;
+	return 0;
 }
 
 /**

commit 1ae79c46cf195ea39407bd5a2b234304d537980f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 29 12:06:40 2016 +0300

    clk: ti: use automatic clock alias generation framework
    
    Generate clock aliases automatically for all TI clock drivers.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 193862ed27c7..024123f421d6 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -298,6 +298,7 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	struct ti_clk_fixed *fixed;
 	struct ti_clk_fixed_factor *fixed_factor;
 	struct clk_hw *clk_hw;
+	int ret;
 
 	if (setup->clk)
 		return setup->clk;
@@ -308,6 +309,13 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 
 		clk = clk_register_fixed_rate(NULL, setup->name, NULL, 0,
 					      fixed->frequency);
+		if (!IS_ERR(clk)) {
+			ret = ti_clk_add_alias(NULL, clk, setup->name);
+			if (ret) {
+				clk_unregister(clk);
+				clk = ERR_PTR(ret);
+			}
+		}
 		break;
 	case TI_CLK_MUX:
 		clk = ti_clk_register_mux(setup);
@@ -325,6 +333,13 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 						fixed_factor->parent,
 						0, fixed_factor->mult,
 						fixed_factor->div);
+		if (!IS_ERR(clk)) {
+			ret = ti_clk_add_alias(NULL, clk, setup->name);
+			if (ret) {
+				clk_unregister(clk);
+				clk = ERR_PTR(ret);
+			}
+		}
 		break;
 	case TI_CLK_GATE:
 		clk = ti_clk_register_gate(setup);
@@ -378,9 +393,6 @@ int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 				       clks->clk->name, PTR_ERR(clk));
 				return PTR_ERR(clk);
 			}
-		} else {
-			clks->lk.clk = clk;
-			clkdev_add(&clks->lk);
 		}
 		clks++;
 	}
@@ -403,8 +415,6 @@ int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 				}
 			} else {
 				retry = true;
-				retry_clk->lk.clk = clk;
-				clkdev_add(&retry_clk->lk);
 				list_del(&retry_clk->link);
 			}
 		}

commit c17435c56bb1feb7365ebffcfbe98baae50a0fb4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 29 12:05:00 2016 +0300

    clk: ti: add API for creating aliases automatically for simple clock types
    
    This API generates clock aliases automatically for simple clock types
    (fixed-clock, fixed-factor-clock), so that we don't need to add the data
    for these statically into tables. Shall be called from the SoC specific
    clock init.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 91bad55cfd5a..193862ed27c7 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -355,6 +355,12 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	return clk;
 }
 
+static const struct of_device_id simple_clk_match_table[] __initconst = {
+	{ .compatible = "fixed-clock" },
+	{ .compatible = "fixed-factor-clock" },
+	{ }
+};
+
 int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 {
 	struct clk *clk;
@@ -408,6 +414,26 @@ int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 }
 #endif
 
+/**
+ * ti_clk_add_aliases - setup clock aliases
+ *
+ * Sets up any missing clock aliases. No return value.
+ */
+void __init ti_clk_add_aliases(void)
+{
+	struct device_node *np;
+	struct clk *clk;
+
+	for_each_matching_node(np, simple_clk_match_table) {
+		struct of_phandle_args clkspec;
+
+		clkspec.np = np;
+		clk = of_clk_get_from_provider(&clkspec);
+
+		ti_clk_add_alias(NULL, clk, np->name);
+	}
+}
+
 /**
  * ti_clk_setup_features - setup clock features flags
  * @features: features definition to use

commit 21f0bf2d3dcc7b18cebe2fa3da700e3263c3a3ce
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 29 12:00:57 2016 +0300

    clk: ti: add support for automatic clock alias generation
    
    Large portions of the OMAP framework still depend on the support of
    having clock aliases in place, so add support functions for generating
    these automatically.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 5fcf247759ac..91bad55cfd5a 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -24,6 +24,7 @@
 #include <linux/list.h>
 #include <linux/regmap.h>
 #include <linux/bootmem.h>
+#include <linux/device.h>
 
 #include "clock.h"
 
@@ -453,3 +454,66 @@ void omap2_clk_enable_init_clocks(const char **clk_names, u8 num_clocks)
 		clk_prepare_enable(init_clk);
 	}
 }
+
+/**
+ * ti_clk_add_alias - add a clock alias for a TI clock
+ * @dev: device alias for this clock
+ * @clk: clock handle to create alias for
+ * @con: connection ID for this clock
+ *
+ * Creates a clock alias for a TI clock. Allocates the clock lookup entry
+ * and assigns the data to it. Returns 0 if successful, negative error
+ * value otherwise.
+ */
+int ti_clk_add_alias(struct device *dev, struct clk *clk, const char *con)
+{
+	struct clk_lookup *cl;
+
+	if (!clk)
+		return 0;
+
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	cl = kzalloc(sizeof(*cl), GFP_KERNEL);
+	if (!cl)
+		return -ENOMEM;
+
+	if (dev)
+		cl->dev_id = dev_name(dev);
+	cl->con_id = con;
+	cl->clk = clk;
+
+	clkdev_add(cl);
+
+	return 0;
+}
+
+/**
+ * ti_clk_register - register a TI clock to the common clock framework
+ * @dev: device for this clock
+ * @hw: hardware clock handle
+ * @con: connection ID for this clock
+ *
+ * Registers a TI clock to the common clock framework, and adds a clock
+ * alias for it. Returns a handle to the registered clock if successful,
+ * ERR_PTR value in failure.
+ */
+struct clk *ti_clk_register(struct device *dev, struct clk_hw *hw,
+			    const char *con)
+{
+	struct clk *clk;
+	int ret;
+
+	clk = clk_register(dev, hw);
+	if (IS_ERR(clk))
+		return clk;
+
+	ret = ti_clk_add_alias(dev, clk, con);
+	if (ret) {
+		clk_unregister(clk);
+		return ERR_PTR(ret);
+	}
+
+	return clk;
+}

commit 45e21151a2bcddebf7f4d5a8e41a8ca82a5fbb42
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Mar 1 11:00:03 2016 -0800

    clk: ti: Remove CLK_IS_ROOT
    
    This flag is a no-op now. Remove usage of the flag.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index b5bcd77e8d0f..5fcf247759ac 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -305,8 +305,8 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	case TI_CLK_FIXED:
 		fixed = setup->data;
 
-		clk = clk_register_fixed_rate(NULL, setup->name, NULL,
-					      CLK_IS_ROOT, fixed->frequency);
+		clk = clk_register_fixed_rate(NULL, setup->name, NULL, 0,
+					      fixed->frequency);
 		break;
 	case TI_CLK_MUX:
 		clk = ti_clk_register_mux(setup);

commit 98d8a60eccee74165793379f1f8a3b1cef3131c7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jun 29 16:56:30 2015 -0700

    clk: Convert __clk_get_flags() to clk_hw_get_flags()
    
    Mostly converted with the following snippet:
    
    @@
    struct clk_hw *E;
    @@
    
    -__clk_get_flags(E->clk)
    +clk_hw_get_flags(E)
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Coquelin <mcoquelin.stm32@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index ace35047783b..b5bcd77e8d0f 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -339,11 +339,11 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	if (!IS_ERR(clk)) {
 		setup->clk = clk;
 		if (setup->clkdm_name) {
-			if (__clk_get_flags(clk) & CLK_IS_BASIC) {
+			clk_hw = __clk_get_hw(clk);
+			if (clk_hw_get_flags(clk_hw) & CLK_IS_BASIC) {
 				pr_warn("can't setup clkdm for basic clk %s\n",
 					setup->name);
 			} else {
-				clk_hw = __clk_get_hw(clk);
 				to_clk_hw_omap(clk_hw)->clkdm_name =
 					setup->clkdm_name;
 				omap2_init_clk_clkdm(clk_hw);

commit 9cfad9bc472a4bdd5ee7d9e713113a9f5a676704
Merge: 9da9e7612737 61ae76563ec3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 21 11:22:42 2015 -0700

    Merge branch 'cleanup-clk-h-includes' into clk-next
    
    * cleanup-clk-h-includes: (62 commits)
      clk: Remove clk.h from clk-provider.h
      clk: h8300: Remove clk.h and clkdev.h includes
      clk: at91: Include clk.h and slab.h
      clk: ti: Switch clk-provider.h include to clk.h
      clk: pistachio: Include clk.h
      clk: ingenic: Include clk.h
      clk: si570: Include clk.h
      clk: moxart: Include clk.h
      clk: cdce925: Include clk.h
      clk: Include clk.h in clk.c
      clk: zynq: Include clk.h
      clk: ti: Include clk.h
      clk: sunxi: Include clk.h and remove unused clkdev.h includes
      clk: st: Include clk.h
      clk: qcom: Include clk.h
      clk: highbank: Include clk.h
      clk: bcm: Include clk.h
      clk: versatile: Remove clk.h and clkdev.h includes
      clk: ux500: Remove clk.h and clkdev.h includes
      clk: tegra: Properly include clk.h
      ...

commit 14cc4e9578841a4c0025ce064133b2da53c9d1c9
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 15 12:58:22 2015 -0700

    clk: ti: Force pointer to be __iomem
    
    Add __force here so that sparse doesn't complain about us playing
    tricks with __iomem.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 0d8861cf21a8..78a47ccff19a 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -193,7 +193,7 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 
 	reg->offset = val;
 
-	return (void __iomem *)tmp;
+	return (__force void __iomem *)tmp;
 }
 
 /**

commit 3fe6d697420c706b640730dbbae17f48b3aad506
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 15 12:03:52 2015 -0700

    clk: ti: Mark ti_clk_features static
    
    This variable isn't exported outside of this file so mark it
    static. Silences the following sparse warning:
    
    drivers/clk/ti/clk.c:36:24: warning: symbol 'ti_clk_features' was not declared. Should it be static?
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 521e330e3046..0d8861cf21a8 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -32,7 +32,7 @@
 struct ti_clk_ll_ops *ti_clk_ll_ops;
 static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
-struct ti_clk_features ti_clk_features;
+static struct ti_clk_features ti_clk_features;
 
 struct clk_iomap {
 	struct regmap *regmap;

commit f645f72d876586c4950dcd5bf516744db0aeb30b
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 15 11:55:42 2015 -0700

    clk: ti: Check kzalloc() for failures
    
    smatch reports a failure to check kzalloc() here:
    
    drivers/clk/ti/clk.c:232
    omap2_clk_provider_init() error: potential null dereference 'io'.
    (kzalloc returns null)
    
    Check for an allocation failure and return -ENOMEM.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 3343bde47fe4..521e330e3046 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -227,6 +227,8 @@ int __init omap2_clk_provider_init(struct device_node *parent, int index,
 	clocks_node_ptr[index] = clocks;
 
 	io = kzalloc(sizeof(*io), GFP_KERNEL);
+	if (!io)
+		return -ENOMEM;
 
 	io->regmap = syscon;
 	io->mem = mem;

commit 4d341056202a4725777ed99897f6456405819cd4
Merge: e306479ac252 989feafb8411
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 28 11:58:26 2015 -0700

    Merge branch 'for-4.2/ti-clk-move' of https://github.com/t-kristo/linux-pm into clk-next
    
    From Tero Kristo:
      "This pull request contains the TI clock driver set to move the
       clock implementations under clock driver. Some small portions of
       the clock driver code still remain under mach-omap2 after this,
       it should be decided whether this code is now obsolete and should
       be deleted or should someone try to fix it."
    
    Slight merge conflicts with determine_rate prototype changes.

commit 1b29e60157e845869abb867df6c7164eaace88b6
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: ti: Include clk.h
    
    This clock provider uses the consumer API, so include clk.h
    explicitly.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 64bb5e8a3b8c..7132cec33f00 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -15,6 +15,7 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/clkdev.h>
 #include <linux/clk/ti.h>

commit 989feafb84118a840ff21250a1e5f516f43e3dbb
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Apr 27 22:23:06 2015 +0300

    clk: ti: move low-level access and init code under clock driver
    
    With most of the clock code under clock driver already, the low-level
    register access code, and the init code for the same, is no longer
    needed outside the clock driver. Thus, these can be moved under clock
    driver also.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 58b83e0af90f..07584e00677e 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -21,6 +21,8 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/list.h>
+#include <linux/regmap.h>
+#include <linux/bootmem.h>
 
 #include "clock.h"
 
@@ -32,6 +34,38 @@ static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
 struct ti_clk_features ti_clk_features;
 
+struct clk_iomap {
+	struct regmap *regmap;
+	void __iomem *mem;
+};
+
+static struct clk_iomap *clk_memmaps[CLK_MAX_MEMMAPS];
+
+static void clk_memmap_writel(u32 val, void __iomem *reg)
+{
+	struct clk_omap_reg *r = (struct clk_omap_reg *)&reg;
+	struct clk_iomap *io = clk_memmaps[r->index];
+
+	if (io->regmap)
+		regmap_write(io->regmap, r->offset, val);
+	else
+		writel_relaxed(val, io->mem + r->offset);
+}
+
+static u32 clk_memmap_readl(void __iomem *reg)
+{
+	u32 val;
+	struct clk_omap_reg *r = (struct clk_omap_reg *)&reg;
+	struct clk_iomap *io = clk_memmaps[r->index];
+
+	if (io->regmap)
+		regmap_read(io->regmap, r->offset, &val);
+	else
+		val = readl_relaxed(io->mem + r->offset);
+
+	return val;
+}
+
 /**
  * ti_clk_setup_ll_ops - setup low level clock operations
  * @ops: low level clock ops descriptor
@@ -49,6 +83,8 @@ int ti_clk_setup_ll_ops(struct ti_clk_ll_ops *ops)
 	}
 
 	ti_clk_ll_ops = ops;
+	ops->clk_readl = clk_memmap_readl;
+	ops->clk_writel = clk_memmap_writel;
 
 	return 0;
 }
@@ -161,28 +197,61 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 }
 
 /**
- * ti_dt_clk_init_provider - init master clock provider
+ * omap2_clk_provider_init - init master clock provider
  * @parent: master node
  * @index: internal index for clk_reg_ops
+ * @syscon: syscon regmap pointer for accessing clock registers
+ * @mem: iomem pointer for the clock provider memory area, only used if
+ *       syscon is not provided
  *
  * Initializes a master clock IP block. This basically sets up the
  * mapping from clocks node to the memory map index. All the clocks
  * are then initialized through the common of_clk_init call, and the
  * clocks will access their memory maps based on the node layout.
+ * Returns 0 in success.
  */
-void ti_dt_clk_init_provider(struct device_node *parent, int index)
+int __init omap2_clk_provider_init(struct device_node *parent, int index,
+				   struct regmap *syscon, void __iomem *mem)
 {
 	struct device_node *clocks;
+	struct clk_iomap *io;
 
 	/* get clocks for this parent */
 	clocks = of_get_child_by_name(parent, "clocks");
 	if (!clocks) {
 		pr_err("%s missing 'clocks' child node.\n", parent->name);
-		return;
+		return -EINVAL;
 	}
 
 	/* add clocks node info */
 	clocks_node_ptr[index] = clocks;
+
+	io = kzalloc(sizeof(*io), GFP_KERNEL);
+
+	io->regmap = syscon;
+	io->mem = mem;
+
+	clk_memmaps[index] = io;
+
+	return 0;
+}
+
+/**
+ * omap2_clk_legacy_provider_init - initialize a legacy clock provider
+ * @index: index for the clock provider
+ * @mem: iomem pointer for the clock provider memory area
+ *
+ * Initializes a legacy clock provider memory mapping.
+ */
+void __init omap2_clk_legacy_provider_init(int index, void __iomem *mem)
+{
+	struct clk_iomap *io;
+
+	io = memblock_virt_alloc(sizeof(*io), 0);
+
+	io->mem = mem;
+
+	clk_memmaps[index] = io;
 }
 
 /**

commit e9e63088e4f93cf4ed7999294c09905b7dcb4d32
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Apr 27 21:55:42 2015 +0300

    clk: ti: remove exported ll_ops struct, instead add an API for registration
    
    We should avoid exporting data from drivers, instead use an API for
    registering the clock low level operations.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 5baea03cfc92..58b83e0af90f 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -32,6 +32,27 @@ static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
 struct ti_clk_features ti_clk_features;
 
+/**
+ * ti_clk_setup_ll_ops - setup low level clock operations
+ * @ops: low level clock ops descriptor
+ *
+ * Sets up low level clock operations for TI clock driver. This is used
+ * to provide various callbacks for the clock driver towards platform
+ * specific code. Returns 0 on success, -EBUSY if ll_ops have been
+ * registered already.
+ */
+int ti_clk_setup_ll_ops(struct ti_clk_ll_ops *ops)
+{
+	if (ti_clk_ll_ops) {
+		pr_err("Attempt to register ll_ops multiple times.\n");
+		return -EBUSY;
+	}
+
+	ti_clk_ll_ops = ops;
+
+	return 0;
+}
+
 /**
  * ti_dt_clocks_register - register DT alias clocks during boot
  * @oclks: list of clocks to register

commit a5aa8a603efa25dd41220bff990da025c93b632b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 3 10:51:01 2015 +0200

    clk: ti: move omap2_clk_enable_init_clocks under clock driver
    
    This is no longer used outside clock driver, so move it under the driver
    and remove the export for it from the global header file.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index e65ae4acff9c..5baea03cfc92 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -336,3 +336,27 @@ const struct ti_clk_features *ti_clk_get_features(void)
 {
 	return &ti_clk_features;
 }
+
+/**
+ * omap2_clk_enable_init_clocks - prepare & enable a list of clocks
+ * @clk_names: ptr to an array of strings of clock names to enable
+ * @num_clocks: number of clock names in @clk_names
+ *
+ * Prepare and enable a list of clocks, named by @clk_names.  No
+ * return value. XXX Deprecated; only needed until these clocks are
+ * properly claimed and enabled by the drivers or core code that uses
+ * them.  XXX What code disables & calls clk_put on these clocks?
+ */
+void omap2_clk_enable_init_clocks(const char **clk_names, u8 num_clocks)
+{
+	struct clk *init_clk;
+	int i;
+
+	for (i = 0; i < num_clocks; i++) {
+		init_clk = clk_get(NULL, clk_names[i]);
+		if (WARN(IS_ERR(init_clk), "could not find init clock %s\n",
+			 clk_names[i]))
+			continue;
+		clk_prepare_enable(init_clk);
+	}
+}

commit f3b19aa5cab65f7e73613aa37f6851ce56b794d1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Feb 27 17:54:14 2015 +0200

    ARM: OMAP2+: clock: export driver API to setup/get clock features
    
    As most of the clock driver support code is going to be moved under
    drivers/clk/ti, an API for setting / getting the SoC specific clock
    features is needed. This patch provides this API and changes the
    existing code to use it.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 0ebe5c51062b..e65ae4acff9c 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -30,6 +30,8 @@
 struct ti_clk_ll_ops *ti_clk_ll_ops;
 static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
+struct ti_clk_features ti_clk_features;
+
 /**
  * ti_dt_clocks_register - register DT alias clocks during boot
  * @oclks: list of clocks to register
@@ -311,3 +313,26 @@ int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 	return 0;
 }
 #endif
+
+/**
+ * ti_clk_setup_features - setup clock features flags
+ * @features: features definition to use
+ *
+ * Initializes the clock driver features flags based on platform
+ * provided data. No return value.
+ */
+void __init ti_clk_setup_features(struct ti_clk_features *features)
+{
+	memcpy(&ti_clk_features, features, sizeof(*features));
+}
+
+/**
+ * ti_clk_get_features - get clock driver features flags
+ *
+ * Get TI clock driver features description. Returns a pointer
+ * to the current feature setup.
+ */
+const struct ti_clk_features *ti_clk_get_features(void)
+{
+	return &ti_clk_features;
+}

commit 412d6b47cc6e33a04fe03be1db725202417f4d72
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri May 1 12:59:32 2015 -0700

    clk: ti: Silence sparse warnings
    
    drivers/clk/ti/clk.c:125:31: warning: incorrect type in return expression (different address spaces)
    drivers/clk/ti/clk.c:125:31:    expected void [noderef] <asn:2>*
    drivers/clk/ti/clk.c:125:31:    got void *
    drivers/clk/ti/clk.c:132:31: warning: incorrect type in return expression (different address spaces)
    drivers/clk/ti/clk.c:132:31:    expected void [noderef] <asn:2>*
    drivers/clk/ti/clk.c:132:31:    got void *
    drivers/clk/ti/dpll.c:180:14: warning: symbol '_get_reg' was not declared. Should it be static?
    drivers/clk/ti/fapll.c:624:32: warning: Using plain integer as NULL pointer
    drivers/clk/ti/fapll.c:625:31: warning: Using plain integer as NULL pointer
    drivers/clk/ti/fapll.c:630:40: warning: Using plain integer as NULL pointer
    drivers/clk/ti/clk-dra7-atl.c:158:22: warning: symbol 'atl_clk_ops' was not declared. Should it be static?
    drivers/clk/ti/clk-dra7-atl.c:170:39: warning: Using plain integer as NULL pointer
    
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 0ebe5c51062b..64bb5e8a3b8c 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -122,14 +122,14 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 
 	if (i == CLK_MAX_MEMMAPS) {
 		pr_err("clk-provider not found for %s!\n", node->name);
-		return ERR_PTR(-ENOENT);
+		return IOMEM_ERR_PTR(-ENOENT);
 	}
 
 	reg->index = i;
 
 	if (of_property_read_u32_index(node, "reg", index, &val)) {
 		pr_err("%s must have reg[%d]!\n", node->name, index);
-		return ERR_PTR(-EINVAL);
+		return IOMEM_ERR_PTR(-EINVAL);
 	}
 
 	reg->offset = val;

commit c807dbedb5e5adbd4e1e2d07574d230df924a5a7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Feb 23 21:06:08 2015 +0200

    clk: ti: fix ti_clk_get_reg_addr error handling
    
    There is a case where NULL can be a valid return value for
    ti_clk_get_reg_addr, specifically the case where both the provider index
    and register offsets are zero. In this case, the current error checking
    against a NULL pointer will fail. Thus, change the API to return a
    ERR_PTR value in an error case, and change all the users of this API to
    check against IS_ERR instead.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index e22b95646e09..0ebe5c51062b 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -103,7 +103,8 @@ int __init ti_clk_retry_init(struct device_node *node, struct clk_hw *hw,
  * @index: register index from the clock node
  *
  * Builds clock register address from device tree information. This
- * is a struct of type clk_omap_reg.
+ * is a struct of type clk_omap_reg. Returns a pointer to the register
+ * address, or a pointer error value in failure.
  */
 void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 {
@@ -121,14 +122,14 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 
 	if (i == CLK_MAX_MEMMAPS) {
 		pr_err("clk-provider not found for %s!\n", node->name);
-		return NULL;
+		return ERR_PTR(-ENOENT);
 	}
 
 	reg->index = i;
 
 	if (of_property_read_u32_index(node, "reg", index, &val)) {
 		pr_err("%s must have reg[%d]!\n", node->name, index);
-		return NULL;
+		return ERR_PTR(-EINVAL);
 	}
 
 	reg->offset = val;

commit 6793a30a0646d2cc269e66782ca30c6025c92e1f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Feb 3 17:59:32 2015 +0100

    clk: omap: compile legacy omap3 clocks conditionally
    
    The 'ARM: OMAP3: legacy clock data move under clk driver' patch series
    causes build errors when CONFIG_OMAP3 is not set:
    
    drivers/clk/ti/dpll.c: In function 'ti_clk_register_dpll':
    drivers/clk/ti/dpll.c:199:31: error: 'omap3_dpll_ck_ops' undeclared (first use in this function)
      const struct clk_ops *ops = &omap3_dpll_ck_ops;
                                   ^
    drivers/clk/ti/dpll.c:199:31: note: each undeclared identifier is reported only once for each function it appears in
    drivers/clk/ti/dpll.c:259:10: error: 'omap3_dpll_per_ck_ops' undeclared (first use in this function)
       ops = &omap3_dpll_per_ck_ops;
              ^
    
    drivers/built-in.o: In function `ti_clk_register_gate':
    drivers/clk/ti/gate.c:179: undefined reference to `clkhwops_omap3430es2_dss_usbhost_wait'
    drivers/clk/ti/gate.c:179: undefined reference to `clkhwops_am35xx_ipss_module_wait'
    -in.o: In function `ti_clk_register_interface':
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_hsotgusb_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_dss_usbhost_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_ssi_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_am35xx_ipss_wait'
    drivers/built-in.o: In function `ti_clk_register_composite':
    :(.text+0x3da768): undefined reference to `ti_clk_build_component_gate'
    
    In order to fix that problem, this patch makes the omap3 legacy code
    compiled only when both CONFIG_OMAP3 and CONFIG_ATAGS are set.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 546dae405402..e22b95646e09 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -186,6 +186,7 @@ void ti_dt_clk_init_retry_clks(void)
 	}
 }
 
+#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_ATAGS)
 void __init ti_clk_patch_legacy_clks(struct ti_clk **patch)
 {
 	while (*patch) {
@@ -308,3 +309,4 @@ int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
 
 	return 0;
 }
+#endif

commit b26bcf9be64e26d8a0972d6df1c2105cc5076cf1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:52 2014 +0200

    clk: ti: composite: add support for legacy composite clock init
    
    Legacy clock data is initialized slightly differently compared to
    DT clocks, thus add support for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index f41a7576a3ff..546dae405402 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -217,6 +217,9 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	case TI_CLK_DIVIDER:
 		clk = ti_clk_register_divider(setup);
 		break;
+	case TI_CLK_COMPOSITE:
+		clk = ti_clk_register_composite(setup);
+		break;
 	case TI_CLK_FIXED_FACTOR:
 		fixed_factor = setup->data;
 

commit ed405a2350646a940966f471ae705fa2d81eee65
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Jan 29 22:24:28 2015 +0200

    clk: ti: dpll: add support for legacy DPLL init
    
    Legacy clock data is initialized slightly differently compared to
    DT clocks, thus add support for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index a0475e23881d..f41a7576a3ff 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -228,6 +228,9 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	case TI_CLK_GATE:
 		clk = ti_clk_register_gate(setup);
 		break;
+	case TI_CLK_DPLL:
+		clk = ti_clk_register_dpll(setup);
+		break;
 	default:
 		pr_err("bad type for %s!\n", setup->name);
 		clk = ERR_PTR(-EINVAL);

commit d96f774b25386a7a71c799bbf55b69c27129e454
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:50 2014 +0200

    clk: ti: divider: add support for legacy divider init
    
    Legacy clock data is initialized slightly differently compared to
    DT clocks, thus add support for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 676dbf170b31..a0475e23881d 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -214,6 +214,9 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 	case TI_CLK_MUX:
 		clk = ti_clk_register_mux(setup);
 		break;
+	case TI_CLK_DIVIDER:
+		clk = ti_clk_register_divider(setup);
+		break;
 	case TI_CLK_FIXED_FACTOR:
 		fixed_factor = setup->data;
 

commit f187616b36edafff5a18d2b66fe7eed3bbb38bf0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:48 2014 +0200

    clk: ti: gate: add support for legacy gate init
    
    Legacy clock data is initialialized slightly differently compared to
    DT clocks, thus add support for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 215f681053d0..676dbf170b31 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -222,6 +222,9 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 						0, fixed_factor->mult,
 						fixed_factor->div);
 		break;
+	case TI_CLK_GATE:
+		clk = ti_clk_register_gate(setup);
+		break;
 	default:
 		pr_err("bad type for %s!\n", setup->name);
 		clk = ERR_PTR(-EINVAL);

commit 7c18a65cb5295484261274b931dd4a3da88695d2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:47 2014 +0200

    clk: ti: mux: add support for legacy mux init
    
    Legacy clock data is initialized slightly differently compared to
    DT clocks, thus add support for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index a8958f1ba8a3..215f681053d0 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -211,6 +211,9 @@ struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
 		clk = clk_register_fixed_rate(NULL, setup->name, NULL,
 					      CLK_IS_ROOT, fixed->frequency);
 		break;
+	case TI_CLK_MUX:
+		clk = ti_clk_register_mux(setup);
+		break;
 	case TI_CLK_FIXED_FACTOR:
 		fixed_factor = setup->data;
 

commit c82f8957b48c628a74bf5dd8ee64e33fc70d7b8f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:46 2014 +0200

    clk: ti: add core support for initializing legacy clocks
    
    Legacy clock data for OMAP3 is being moved under clock driver, thus
    base support for this is needed. This patch adds basic definitions for
    clock init descriptors and core infrastructure for initialization,
    which will be called from the OMAP3 clock init.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 337abe5909e1..a8958f1ba8a3 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -22,6 +22,8 @@
 #include <linux/of_address.h>
 #include <linux/list.h>
 
+#include "clock.h"
+
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
@@ -183,3 +185,111 @@ void ti_dt_clk_init_retry_clks(void)
 		retries--;
 	}
 }
+
+void __init ti_clk_patch_legacy_clks(struct ti_clk **patch)
+{
+	while (*patch) {
+		memcpy((*patch)->patch, *patch, sizeof(**patch));
+		patch++;
+	}
+}
+
+struct clk __init *ti_clk_register_clk(struct ti_clk *setup)
+{
+	struct clk *clk;
+	struct ti_clk_fixed *fixed;
+	struct ti_clk_fixed_factor *fixed_factor;
+	struct clk_hw *clk_hw;
+
+	if (setup->clk)
+		return setup->clk;
+
+	switch (setup->type) {
+	case TI_CLK_FIXED:
+		fixed = setup->data;
+
+		clk = clk_register_fixed_rate(NULL, setup->name, NULL,
+					      CLK_IS_ROOT, fixed->frequency);
+		break;
+	case TI_CLK_FIXED_FACTOR:
+		fixed_factor = setup->data;
+
+		clk = clk_register_fixed_factor(NULL, setup->name,
+						fixed_factor->parent,
+						0, fixed_factor->mult,
+						fixed_factor->div);
+		break;
+	default:
+		pr_err("bad type for %s!\n", setup->name);
+		clk = ERR_PTR(-EINVAL);
+	}
+
+	if (!IS_ERR(clk)) {
+		setup->clk = clk;
+		if (setup->clkdm_name) {
+			if (__clk_get_flags(clk) & CLK_IS_BASIC) {
+				pr_warn("can't setup clkdm for basic clk %s\n",
+					setup->name);
+			} else {
+				clk_hw = __clk_get_hw(clk);
+				to_clk_hw_omap(clk_hw)->clkdm_name =
+					setup->clkdm_name;
+				omap2_init_clk_clkdm(clk_hw);
+			}
+		}
+	}
+
+	return clk;
+}
+
+int __init ti_clk_register_legacy_clks(struct ti_clk_alias *clks)
+{
+	struct clk *clk;
+	bool retry;
+	struct ti_clk_alias *retry_clk;
+	struct ti_clk_alias *tmp;
+
+	while (clks->clk) {
+		clk = ti_clk_register_clk(clks->clk);
+		if (IS_ERR(clk)) {
+			if (PTR_ERR(clk) == -EAGAIN) {
+				list_add(&clks->link, &retry_list);
+			} else {
+				pr_err("register for %s failed: %ld\n",
+				       clks->clk->name, PTR_ERR(clk));
+				return PTR_ERR(clk);
+			}
+		} else {
+			clks->lk.clk = clk;
+			clkdev_add(&clks->lk);
+		}
+		clks++;
+	}
+
+	retry = true;
+
+	while (!list_empty(&retry_list) && retry) {
+		retry = false;
+		list_for_each_entry_safe(retry_clk, tmp, &retry_list, link) {
+			pr_debug("retry-init: %s\n", retry_clk->clk->name);
+			clk = ti_clk_register_clk(retry_clk->clk);
+			if (IS_ERR(clk)) {
+				if (PTR_ERR(clk) == -EAGAIN) {
+					continue;
+				} else {
+					pr_err("register for %s failed: %ld\n",
+					       retry_clk->clk->name,
+					       PTR_ERR(clk));
+					return PTR_ERR(clk);
+				}
+			} else {
+				retry = true;
+				retry_clk->lk.clk = clk;
+				clkdev_add(&retry_clk->lk);
+				list_del(&retry_clk->link);
+			}
+		}
+	}
+
+	return 0;
+}

commit c08ee14cc6634457948bc5e26584697208baa02a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Sep 12 15:01:57 2014 +0300

    clk: ti: change clock init to use generic of_clk_init
    
    Previously, the TI clock driver initialized all the clocks hierarchically
    under each separate clock provider node. Now, each clock that requires
    IO access will instead check their parent node to find out which IO range
    to use.
    
    This patch allows the TI clock driver to use a few new features provided
    by the generic of_clk_init, and also allows registration of clock nodes
    outside the clock hierarchy (for example, any external clocks.)
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Stefan Assmann <sassmann@kpanic.de>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index b1a6f7144f3f..337abe5909e1 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -25,8 +25,8 @@
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
-static int ti_dt_clk_memmap_index;
 struct ti_clk_ll_ops *ti_clk_ll_ops;
+static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
 /**
  * ti_dt_clocks_register - register DT alias clocks during boot
@@ -108,9 +108,21 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 	struct clk_omap_reg *reg;
 	u32 val;
 	u32 tmp;
+	int i;
 
 	reg = (struct clk_omap_reg *)&tmp;
-	reg->index = ti_dt_clk_memmap_index;
+
+	for (i = 0; i < CLK_MAX_MEMMAPS; i++) {
+		if (clocks_node_ptr[i] == node->parent)
+			break;
+	}
+
+	if (i == CLK_MAX_MEMMAPS) {
+		pr_err("clk-provider not found for %s!\n", node->name);
+		return NULL;
+	}
+
+	reg->index = i;
 
 	if (of_property_read_u32_index(node, "reg", index, &val)) {
 		pr_err("%s must have reg[%d]!\n", node->name, index);
@@ -127,20 +139,14 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
  * @parent: master node
  * @index: internal index for clk_reg_ops
  *
- * Initializes a master clock IP block and its child clock nodes.
- * Regmap is provided for accessing the register space for the
- * IP block and all the clocks under it.
+ * Initializes a master clock IP block. This basically sets up the
+ * mapping from clocks node to the memory map index. All the clocks
+ * are then initialized through the common of_clk_init call, and the
+ * clocks will access their memory maps based on the node layout.
  */
 void ti_dt_clk_init_provider(struct device_node *parent, int index)
 {
-	const struct of_device_id *match;
-	struct device_node *np;
 	struct device_node *clocks;
-	of_clk_init_cb_t clk_init_cb;
-	struct clk_init_item *retry;
-	struct clk_init_item *tmp;
-
-	ti_dt_clk_memmap_index = index;
 
 	/* get clocks for this parent */
 	clocks = of_get_child_by_name(parent, "clocks");
@@ -149,19 +155,31 @@ void ti_dt_clk_init_provider(struct device_node *parent, int index)
 		return;
 	}
 
-	for_each_child_of_node(clocks, np) {
-		match = of_match_node(&__clk_of_table, np);
-		if (!match)
-			continue;
-		clk_init_cb = (of_clk_init_cb_t)match->data;
-		pr_debug("%s: initializing: %s\n", __func__, np->name);
-		clk_init_cb(np);
-	}
+	/* add clocks node info */
+	clocks_node_ptr[index] = clocks;
+}
 
-	list_for_each_entry_safe(retry, tmp, &retry_list, link) {
-		pr_debug("retry-init: %s\n", retry->node->name);
-		retry->func(retry->hw, retry->node);
-		list_del(&retry->link);
-		kfree(retry);
+/**
+ * ti_dt_clk_init_retry_clks - init clocks from the retry list
+ *
+ * Initializes any clocks that have failed to initialize before,
+ * reasons being missing parent node(s) during earlier init. This
+ * typically happens only for DPLLs which need to have both of their
+ * parent clocks ready during init.
+ */
+void ti_dt_clk_init_retry_clks(void)
+{
+	struct clk_init_item *retry;
+	struct clk_init_item *tmp;
+	int retries = 5;
+
+	while (!list_empty(&retry_list) && retries) {
+		list_for_each_entry_safe(retry, tmp, &retry_list, link) {
+			pr_debug("retry-init: %s\n", retry->node->name);
+			retry->func(retry->hw, retry->node);
+			list_del(&retry->link);
+			kfree(retry);
+		}
+		retries--;
 	}
 }

commit 819b4861c18d602463cfe815041d11fd81002654
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Oct 22 11:39:36 2013 +0300

    CLK: ti: add init support for clock IP blocks
    
    ti_dt_clk_init_provider() can now be used to initialize the contents of
    a single clock IP block. This parses all the clocks under the IP block
    and calls the corresponding init function for them.
    
    This patch also introduces a helper function for the TI clock drivers
    to get register info from DT and append the master IP info to this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index ef1a7cdecfd9..b1a6f7144f3f 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -19,10 +19,15 @@
 #include <linux/clkdev.h>
 #include <linux/clk/ti.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/list.h>
 
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
+static int ti_dt_clk_memmap_index;
+struct ti_clk_ll_ops *ti_clk_ll_ops;
+
 /**
  * ti_dt_clocks_register - register DT alias clocks during boot
  * @oclks: list of clocks to register
@@ -53,3 +58,110 @@ void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
 		}
 	}
 }
+
+struct clk_init_item {
+	struct device_node *node;
+	struct clk_hw *hw;
+	ti_of_clk_init_cb_t func;
+	struct list_head link;
+};
+
+static LIST_HEAD(retry_list);
+
+/**
+ * ti_clk_retry_init - retries a failed clock init at later phase
+ * @node: device not for the clock
+ * @hw: partially initialized clk_hw struct for the clock
+ * @func: init function to be called for the clock
+ *
+ * Adds a failed clock init to the retry list. The retry list is parsed
+ * once all the other clocks have been initialized.
+ */
+int __init ti_clk_retry_init(struct device_node *node, struct clk_hw *hw,
+			      ti_of_clk_init_cb_t func)
+{
+	struct clk_init_item *retry;
+
+	pr_debug("%s: adding to retry list...\n", node->name);
+	retry = kzalloc(sizeof(*retry), GFP_KERNEL);
+	if (!retry)
+		return -ENOMEM;
+
+	retry->node = node;
+	retry->func = func;
+	retry->hw = hw;
+	list_add(&retry->link, &retry_list);
+
+	return 0;
+}
+
+/**
+ * ti_clk_get_reg_addr - get register address for a clock register
+ * @node: device node for the clock
+ * @index: register index from the clock node
+ *
+ * Builds clock register address from device tree information. This
+ * is a struct of type clk_omap_reg.
+ */
+void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
+{
+	struct clk_omap_reg *reg;
+	u32 val;
+	u32 tmp;
+
+	reg = (struct clk_omap_reg *)&tmp;
+	reg->index = ti_dt_clk_memmap_index;
+
+	if (of_property_read_u32_index(node, "reg", index, &val)) {
+		pr_err("%s must have reg[%d]!\n", node->name, index);
+		return NULL;
+	}
+
+	reg->offset = val;
+
+	return (void __iomem *)tmp;
+}
+
+/**
+ * ti_dt_clk_init_provider - init master clock provider
+ * @parent: master node
+ * @index: internal index for clk_reg_ops
+ *
+ * Initializes a master clock IP block and its child clock nodes.
+ * Regmap is provided for accessing the register space for the
+ * IP block and all the clocks under it.
+ */
+void ti_dt_clk_init_provider(struct device_node *parent, int index)
+{
+	const struct of_device_id *match;
+	struct device_node *np;
+	struct device_node *clocks;
+	of_clk_init_cb_t clk_init_cb;
+	struct clk_init_item *retry;
+	struct clk_init_item *tmp;
+
+	ti_dt_clk_memmap_index = index;
+
+	/* get clocks for this parent */
+	clocks = of_get_child_by_name(parent, "clocks");
+	if (!clocks) {
+		pr_err("%s missing 'clocks' child node.\n", parent->name);
+		return;
+	}
+
+	for_each_child_of_node(clocks, np) {
+		match = of_match_node(&__clk_of_table, np);
+		if (!match)
+			continue;
+		clk_init_cb = (of_clk_init_cb_t)match->data;
+		pr_debug("%s: initializing: %s\n", __func__, np->name);
+		clk_init_cb(np);
+	}
+
+	list_for_each_entry_safe(retry, tmp, &retry_list, link) {
+		pr_debug("retry-init: %s\n", retry->node->name);
+		retry->func(retry->hw, retry->node);
+		list_del(&retry->link);
+		kfree(retry);
+	}
+}

commit a8aceccb4d5db0acb476b74051525fb26f57f8ae
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Jul 18 11:52:33 2013 +0300

    CLK: TI: add DT alias clock registration mechanism
    
    Some devices require their clocks to be available with a specific
    dev-id con-id mapping. With DT, the clocks can be found by default
    only with their name, or alternatively through the device node of
    the consumer. With drivers, that don't support DT fully yet, add
    mechanism to register specific clock names.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
new file mode 100644
index 000000000000..ef1a7cdecfd9
--- /dev/null
+++ b/drivers/clk/ti/clk.c
@@ -0,0 +1,55 @@
+/*
+ * TI clock support
+ *
+ * Copyright (C) 2013 Texas Instruments, Inc.
+ *
+ * Tero Kristo <t-kristo@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clk/ti.h>
+#include <linux/of.h>
+
+#undef pr_fmt
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+/**
+ * ti_dt_clocks_register - register DT alias clocks during boot
+ * @oclks: list of clocks to register
+ *
+ * Register alias or non-standard DT clock entries during boot. By
+ * default, DT clocks are found based on their node name. If any
+ * additional con-id / dev-id -> clock mapping is required, use this
+ * function to list these.
+ */
+void __init ti_dt_clocks_register(struct ti_dt_clk oclks[])
+{
+	struct ti_dt_clk *c;
+	struct device_node *node;
+	struct clk *clk;
+	struct of_phandle_args clkspec;
+
+	for (c = oclks; c->node_name != NULL; c++) {
+		node = of_find_node_by_name(NULL, c->node_name);
+		clkspec.np = node;
+		clk = of_clk_get_from_provider(&clkspec);
+
+		if (!IS_ERR(clk)) {
+			c->lk.clk = clk;
+			clkdev_add(&c->lk);
+		} else {
+			pr_warn("failed to lookup clock node %s\n",
+				c->node_name);
+		}
+	}
+}
