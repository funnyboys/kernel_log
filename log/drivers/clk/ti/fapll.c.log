commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index ed24f20f63c7..95e36ba64acc 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -13,6 +13,7 @@
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/io.h>
 #include <linux/math64.h>
 #include <linux/of.h>
 #include <linux/of_address.h>

commit e665f029a283aff4f36f0c5388f7c708be67470e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Aug 28 10:44:29 2018 -0500

    clk: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index 071af44b1ba8..ed24f20f63c7 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -555,7 +555,7 @@ static void __init ti_fapll_setup(struct device_node *node)
 
 	init->num_parents = of_clk_get_parent_count(node);
 	if (init->num_parents != 2) {
-		pr_err("%s must have two parents\n", node->name);
+		pr_err("%pOFn must have two parents\n", node);
 		goto free;
 	}
 
@@ -564,19 +564,19 @@ static void __init ti_fapll_setup(struct device_node *node)
 
 	fd->clk_ref = of_clk_get(node, 0);
 	if (IS_ERR(fd->clk_ref)) {
-		pr_err("%s could not get clk_ref\n", node->name);
+		pr_err("%pOFn could not get clk_ref\n", node);
 		goto free;
 	}
 
 	fd->clk_bypass = of_clk_get(node, 1);
 	if (IS_ERR(fd->clk_bypass)) {
-		pr_err("%s could not get clk_bypass\n", node->name);
+		pr_err("%pOFn could not get clk_bypass\n", node);
 		goto free;
 	}
 
 	fd->base = of_iomap(node, 0);
 	if (!fd->base) {
-		pr_err("%s could not get IO base\n", node->name);
+		pr_err("%pOFn could not get IO base\n", node);
 		goto free;
 	}
 

commit 7cc566a821a0e0999209a256b80375d08db2840c
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Tue Aug 22 18:41:15 2017 +0530

    clk: ti: make clk_ops const
    
    Make these const as they are only stored in the const field of a
    clk_init_data structure.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index 66a0d0ed8b55..071af44b1ba8 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -268,7 +268,7 @@ static int ti_fapll_set_rate(struct clk_hw *hw, unsigned long rate,
 	return 0;
 }
 
-static struct clk_ops ti_fapll_ops = {
+static const struct clk_ops ti_fapll_ops = {
 	.enable = ti_fapll_enable,
 	.disable = ti_fapll_disable,
 	.is_enabled = ti_fapll_is_enabled,
@@ -478,7 +478,7 @@ static int ti_fapll_synth_set_rate(struct clk_hw *hw, unsigned long rate,
 	return 0;
 }
 
-static struct clk_ops ti_fapll_synt_ops = {
+static const struct clk_ops ti_fapll_synt_ops = {
 	.enable = ti_fapll_synth_enable,
 	.disable = ti_fapll_synth_disable,
 	.is_enabled = ti_fapll_synth_is_enabled,

commit c51185b45c43737faca4574d790489a1bd8cfd11
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Nov 3 23:17:11 2015 -0500

    clk: ti: fapll: fix wrong do_div() usage
    
    do_div() is meant to be used with an unsigned dividend.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index f4b2e9888bdf..66a0d0ed8b55 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -168,7 +168,7 @@ static unsigned long ti_fapll_recalc_rate(struct clk_hw *hw,
 {
 	struct fapll_data *fd = to_fapll(hw);
 	u32 fapll_n, fapll_p, v;
-	long long rate;
+	u64 rate;
 
 	if (ti_fapll_clock_is_bypass(fd))
 		return parent_rate;
@@ -314,7 +314,7 @@ static unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,
 {
 	struct fapll_synth *synth = to_synth(hw);
 	u32 synth_div_m;
-	long long rate;
+	u64 rate;
 
 	/* The audio_pll_clk1 is hardwired to produce 32.768KiHz clock */
 	if (!synth->div)

commit 9cfad9bc472a4bdd5ee7d9e713113a9f5a676704
Merge: 9da9e7612737 61ae76563ec3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 21 11:22:42 2015 -0700

    Merge branch 'cleanup-clk-h-includes' into clk-next
    
    * cleanup-clk-h-includes: (62 commits)
      clk: Remove clk.h from clk-provider.h
      clk: h8300: Remove clk.h and clkdev.h includes
      clk: at91: Include clk.h and slab.h
      clk: ti: Switch clk-provider.h include to clk.h
      clk: pistachio: Include clk.h
      clk: ingenic: Include clk.h
      clk: si570: Include clk.h
      clk: moxart: Include clk.h
      clk: cdce925: Include clk.h
      clk: Include clk.h in clk.c
      clk: zynq: Include clk.h
      clk: ti: Include clk.h
      clk: sunxi: Include clk.h and remove unused clkdev.h includes
      clk: st: Include clk.h
      clk: qcom: Include clk.h
      clk: highbank: Include clk.h
      clk: bcm: Include clk.h
      clk: versatile: Remove clk.h and clkdev.h includes
      clk: ux500: Remove clk.h and clkdev.h includes
      clk: tegra: Properly include clk.h
      ...

commit 9da9e761273702b3afd6e3538c23ece95693e586
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Mon Jul 6 22:59:06 2015 -0500

    clk: ti: make use of of_clk_parent_fill helper function
    
    Use of_clk_parent_fill to fill in the parent clock names' array.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index 730aa62454a2..b1c741b11502 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -558,8 +558,7 @@ static void __init ti_fapll_setup(struct device_node *node)
 		goto free;
 	}
 
-	parent_name[0] = of_clk_get_parent_name(node, 0);
-	parent_name[1] = of_clk_get_parent_name(node, 1);
+	of_clk_parent_fill(node, parent_name, 2);
 	init->parent_names = parent_name;
 
 	fd->clk_ref = of_clk_get(node, 0);

commit 1b29e60157e845869abb867df6c7164eaace88b6
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: ti: Include clk.h
    
    This clock provider uses the consumer API, so include clk.h
    explicitly.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index 730aa62454a2..f158c2ab019d 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -9,6 +9,7 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/err.h>

commit 412d6b47cc6e33a04fe03be1db725202417f4d72
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri May 1 12:59:32 2015 -0700

    clk: ti: Silence sparse warnings
    
    drivers/clk/ti/clk.c:125:31: warning: incorrect type in return expression (different address spaces)
    drivers/clk/ti/clk.c:125:31:    expected void [noderef] <asn:2>*
    drivers/clk/ti/clk.c:125:31:    got void *
    drivers/clk/ti/clk.c:132:31: warning: incorrect type in return expression (different address spaces)
    drivers/clk/ti/clk.c:132:31:    expected void [noderef] <asn:2>*
    drivers/clk/ti/clk.c:132:31:    got void *
    drivers/clk/ti/dpll.c:180:14: warning: symbol '_get_reg' was not declared. Should it be static?
    drivers/clk/ti/fapll.c:624:32: warning: Using plain integer as NULL pointer
    drivers/clk/ti/fapll.c:625:31: warning: Using plain integer as NULL pointer
    drivers/clk/ti/fapll.c:630:40: warning: Using plain integer as NULL pointer
    drivers/clk/ti/clk-dra7-atl.c:158:22: warning: symbol 'atl_clk_ops' was not declared. Should it be static?
    drivers/clk/ti/clk-dra7-atl.c:170:39: warning: Using plain integer as NULL pointer
    
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index ffcd8e09e85b..730aa62454a2 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -621,13 +621,13 @@ static void __init ti_fapll_setup(struct device_node *node)
 
 		/* Check for hardwired audio_pll_clk1 */
 		if (is_audio_pll_clk1(freq)) {
-			freq = 0;
-			div = 0;
+			freq = NULL;
+			div = NULL;
 		} else {
 			/* Does the synthesizer have a FREQ register? */
 			v = readl_relaxed(freq);
 			if (!v)
-				freq = 0;
+				freq = NULL;
 		}
 		synth_clk = ti_fapll_synth_setup(fd, freq, div, output_instance,
 						 output_name, node->name,

commit c77662a4df847e7b75ff8c5f2314dd4f022377e3
Merge: 3966fab8b6ab 9089848d9afa
Author: Michael Turquette <mturquette@linaro.org>
Date:   Tue Mar 24 16:33:33 2015 -0700

    Merge branch 'for-4.1-clk-ti' of github.com:t-kristo/linux-pm into clk-next

commit 9089848d9afa34a796988b5b666c2c4e611ccb61
Author: Tony Lindgren <tony@atomide.com>
Date:   Sun Mar 22 15:35:26 2015 -0700

    clk: ti: Implement FAPLL set_rate for the PLL
    
    Since we have a fractional divider for the synthesizer, just implement
    a simple multiply logic for the PLL.
    
    It seems the PLL divider needs to have also the multiplier set for the PLL
    to lock. At least I have not yet figured out if divided rates are doable.
    
    So let's just ignore the PLL divider for now as the synthesizer has both
    integer and fractional dividers so we don't even need to use the PLL
    divider for the rates we know work with PLL locking.
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Matthijs van Duin <matthijsvanduin@gmail.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index fc06abe5eaaf..e8291c3a0e76 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -18,11 +18,20 @@
 #include <linux/clk/ti.h>
 
 /* FAPLL Control Register PLL_CTRL */
+#define FAPLL_MAIN_MULT_N_SHIFT	16
+#define FAPLL_MAIN_DIV_P_SHIFT	8
 #define FAPLL_MAIN_LOCK		BIT(7)
 #define FAPLL_MAIN_PLLEN	BIT(3)
 #define FAPLL_MAIN_BP		BIT(2)
 #define FAPLL_MAIN_LOC_CTL	BIT(0)
 
+#define FAPLL_MAIN_MAX_MULT_N	0xffff
+#define FAPLL_MAIN_MAX_DIV_P	0xff
+#define FAPLL_MAIN_CLEAR_MASK	\
+	((FAPLL_MAIN_MAX_MULT_N << FAPLL_MAIN_MULT_N_SHIFT) | \
+	 (FAPLL_MAIN_DIV_P_SHIFT << FAPLL_MAIN_DIV_P_SHIFT) | \
+	 FAPLL_MAIN_LOC_CTL)
+
 /* FAPLL powerdown register PWD */
 #define FAPLL_PWD_OFFSET	4
 
@@ -82,6 +91,48 @@ static bool ti_fapll_clock_is_bypass(struct fapll_data *fd)
 		return !!(v & FAPLL_MAIN_BP);
 }
 
+static void ti_fapll_set_bypass(struct fapll_data *fd)
+{
+	u32 v = readl_relaxed(fd->base);
+
+	if (fd->bypass_bit_inverted)
+		v &= ~FAPLL_MAIN_BP;
+	else
+		v |= FAPLL_MAIN_BP;
+	writel_relaxed(v, fd->base);
+}
+
+static void ti_fapll_clear_bypass(struct fapll_data *fd)
+{
+	u32 v = readl_relaxed(fd->base);
+
+	if (fd->bypass_bit_inverted)
+		v |= FAPLL_MAIN_BP;
+	else
+		v &= ~FAPLL_MAIN_BP;
+	writel_relaxed(v, fd->base);
+}
+
+static int ti_fapll_wait_lock(struct fapll_data *fd)
+{
+	int retries = FAPLL_MAX_RETRIES;
+	u32 v;
+
+	while ((v = readl_relaxed(fd->base))) {
+		if (v & FAPLL_MAIN_LOCK)
+			return 0;
+
+		if (retries-- <= 0)
+			break;
+
+		udelay(1);
+	}
+
+	pr_err("%s failed to lock\n", fd->name);
+
+	return -ETIMEDOUT;
+}
+
 static int ti_fapll_enable(struct clk_hw *hw)
 {
 	struct fapll_data *fd = to_fapll(hw);
@@ -89,6 +140,7 @@ static int ti_fapll_enable(struct clk_hw *hw)
 
 	v |= (1 << FAPLL_MAIN_PLLEN);
 	writel_relaxed(v, fd->base);
+	ti_fapll_wait_lock(fd);
 
 	return 0;
 }
@@ -144,12 +196,85 @@ static u8 ti_fapll_get_parent(struct clk_hw *hw)
 	return 0;
 }
 
+static int ti_fapll_set_div_mult(unsigned long rate,
+				 unsigned long parent_rate,
+				 u32 *pre_div_p, u32 *mult_n)
+{
+	/*
+	 * So far no luck getting decent clock with PLL divider,
+	 * PLL does not seem to lock and the signal does not look
+	 * right. It seems the divider can only be used together
+	 * with the multiplier?
+	 */
+	if (rate < parent_rate) {
+		pr_warn("FAPLL main divider rates unsupported\n");
+		return -EINVAL;
+	}
+
+	*mult_n = rate / parent_rate;
+	if (*mult_n > FAPLL_MAIN_MAX_MULT_N)
+		return -EINVAL;
+	*pre_div_p = 1;
+
+	return 0;
+}
+
+static long ti_fapll_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *parent_rate)
+{
+	u32 pre_div_p, mult_n;
+	int error;
+
+	if (!rate)
+		return -EINVAL;
+
+	error = ti_fapll_set_div_mult(rate, *parent_rate,
+				      &pre_div_p, &mult_n);
+	if (error)
+		return error;
+
+	rate = *parent_rate / pre_div_p;
+	rate *= mult_n;
+
+	return rate;
+}
+
+static int ti_fapll_set_rate(struct clk_hw *hw, unsigned long rate,
+			     unsigned long parent_rate)
+{
+	struct fapll_data *fd = to_fapll(hw);
+	u32 pre_div_p, mult_n, v;
+	int error;
+
+	if (!rate)
+		return -EINVAL;
+
+	error = ti_fapll_set_div_mult(rate, parent_rate,
+				      &pre_div_p, &mult_n);
+	if (error)
+		return error;
+
+	ti_fapll_set_bypass(fd);
+	v = readl_relaxed(fd->base);
+	v &= ~FAPLL_MAIN_CLEAR_MASK;
+	v |= pre_div_p << FAPLL_MAIN_DIV_P_SHIFT;
+	v |= mult_n << FAPLL_MAIN_MULT_N_SHIFT;
+	writel_relaxed(v, fd->base);
+	if (ti_fapll_is_enabled(hw))
+		ti_fapll_wait_lock(fd);
+	ti_fapll_clear_bypass(fd);
+
+	return 0;
+}
+
 static struct clk_ops ti_fapll_ops = {
 	.enable = ti_fapll_enable,
 	.disable = ti_fapll_disable,
 	.is_enabled = ti_fapll_is_enabled,
 	.recalc_rate = ti_fapll_recalc_rate,
 	.get_parent = ti_fapll_get_parent,
+	.round_rate = ti_fapll_round_rate,
+	.set_rate = ti_fapll_set_rate,
 };
 
 static int ti_fapll_synth_enable(struct clk_hw *hw)

commit cafeb002cf2cd8b0f8796b59130f9c1b91da4fcf
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Mar 16 18:04:20 2015 -0700

    clk: ti: Implement FAPLL set_rate for the synthesizer
    
    We can pretty much get any rate out of the FAPLL because of the fractional
    divider. Let's first try just adjusting the post divider, and if that is
    not enough, then reprogram both the fractional divider and the post divider.
    
    Let's also add a define for the fixed SYNTH_PHASE_K instead of using 8.
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Matthijs van Duin <matthijsvanduin@gmail.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index 97138c106a67..fc06abe5eaaf 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -12,6 +12,7 @@
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/math64.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/clk/ti.h>
@@ -47,6 +48,8 @@
 /* Synthesizer frequency register */
 #define SYNTH_LDFREQ		BIT(31)
 
+#define SYNTH_PHASE_K		8
+#define SYNTH_MAX_INT_DIV	0xf
 #define SYNTH_MAX_DIV_M		0xff
 
 struct fapll_data {
@@ -204,7 +207,7 @@ static unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,
 	/*
 	 * Synth frequency integer and fractional divider.
 	 * Note that the phase output K is 8, so the result needs
-	 * to be multiplied by 8.
+	 * to be multiplied by SYNTH_PHASE_K.
 	 */
 	if (synth->freq) {
 		u32 v, synth_int_div, synth_frac_div, synth_div_freq;
@@ -215,7 +218,7 @@ static unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,
 		synth_div_freq = (synth_int_div * 10000000) + synth_frac_div;
 		rate *= 10000000;
 		do_div(rate, synth_div_freq);
-		rate *= 8;
+		rate *= SYNTH_PHASE_K;
 	}
 
 	/* Synth post-divider M */
@@ -224,11 +227,138 @@ static unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,
 	return DIV_ROUND_UP_ULL(rate, synth_div_m);
 }
 
+static unsigned long ti_fapll_synth_get_frac_rate(struct clk_hw *hw,
+						  unsigned long parent_rate)
+{
+	struct fapll_synth *synth = to_synth(hw);
+	unsigned long current_rate, frac_rate;
+	u32 post_div_m;
+
+	current_rate = ti_fapll_synth_recalc_rate(hw, parent_rate);
+	post_div_m = readl_relaxed(synth->div) & SYNTH_MAX_DIV_M;
+	frac_rate = current_rate * post_div_m;
+
+	return frac_rate;
+}
+
+static u32 ti_fapll_synth_set_frac_rate(struct fapll_synth *synth,
+					unsigned long rate,
+					unsigned long parent_rate)
+{
+	u32 post_div_m, synth_int_div = 0, synth_frac_div = 0, v;
+
+	post_div_m = DIV_ROUND_UP_ULL((u64)parent_rate * SYNTH_PHASE_K, rate);
+	post_div_m = post_div_m / SYNTH_MAX_INT_DIV;
+	if (post_div_m > SYNTH_MAX_DIV_M)
+		return -EINVAL;
+	if (!post_div_m)
+		post_div_m = 1;
+
+	for (; post_div_m < SYNTH_MAX_DIV_M; post_div_m++) {
+		synth_int_div = DIV_ROUND_UP_ULL((u64)parent_rate *
+						 SYNTH_PHASE_K *
+						 10000000,
+						 rate * post_div_m);
+		synth_frac_div = synth_int_div % 10000000;
+		synth_int_div /= 10000000;
+
+		if (synth_int_div <= SYNTH_MAX_INT_DIV)
+			break;
+	}
+
+	if (synth_int_div > SYNTH_MAX_INT_DIV)
+		return -EINVAL;
+
+	v = readl_relaxed(synth->freq);
+	v &= ~0x1fffffff;
+	v |= (synth_int_div & SYNTH_MAX_INT_DIV) << 24;
+	v |= (synth_frac_div & 0xffffff);
+	v |= SYNTH_LDFREQ;
+	writel_relaxed(v, synth->freq);
+
+	return post_div_m;
+}
+
+static long ti_fapll_synth_round_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *parent_rate)
+{
+	struct fapll_synth *synth = to_synth(hw);
+	struct fapll_data *fd = synth->fd;
+	unsigned long r;
+
+	if (ti_fapll_clock_is_bypass(fd) || !synth->div || !rate)
+		return -EINVAL;
+
+	/* Only post divider m available with no fractional divider? */
+	if (!synth->freq) {
+		unsigned long frac_rate;
+		u32 synth_post_div_m;
+
+		frac_rate = ti_fapll_synth_get_frac_rate(hw, *parent_rate);
+		synth_post_div_m = DIV_ROUND_UP(frac_rate, rate);
+		r = DIV_ROUND_UP(frac_rate, synth_post_div_m);
+		goto out;
+	}
+
+	r = *parent_rate * SYNTH_PHASE_K;
+	if (rate > r)
+		goto out;
+
+	r = DIV_ROUND_UP_ULL(r, SYNTH_MAX_INT_DIV * SYNTH_MAX_DIV_M);
+	if (rate < r)
+		goto out;
+
+	r = rate;
+out:
+	return r;
+}
+
+static int ti_fapll_synth_set_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long parent_rate)
+{
+	struct fapll_synth *synth = to_synth(hw);
+	struct fapll_data *fd = synth->fd;
+	unsigned long frac_rate, post_rate = 0;
+	u32 post_div_m = 0, v;
+
+	if (ti_fapll_clock_is_bypass(fd) || !synth->div || !rate)
+		return -EINVAL;
+
+	/* Produce the rate with just post divider M? */
+	frac_rate = ti_fapll_synth_get_frac_rate(hw, parent_rate);
+	if (frac_rate < rate) {
+		if (!synth->freq)
+			return -EINVAL;
+	} else {
+		post_div_m = DIV_ROUND_UP(frac_rate, rate);
+		if (post_div_m && (post_div_m <= SYNTH_MAX_DIV_M))
+			post_rate = DIV_ROUND_UP(frac_rate, post_div_m);
+		if (!synth->freq && !post_rate)
+			return -EINVAL;
+	}
+
+	/* Need to recalculate the fractional divider? */
+	if ((post_rate != rate) && synth->freq)
+		post_div_m = ti_fapll_synth_set_frac_rate(synth,
+							  rate,
+							  parent_rate);
+
+	v = readl_relaxed(synth->div);
+	v &= ~SYNTH_MAX_DIV_M;
+	v |= post_div_m;
+	v |= SYNTH_LDMDIV1;
+	writel_relaxed(v, synth->div);
+
+	return 0;
+}
+
 static struct clk_ops ti_fapll_synt_ops = {
 	.enable = ti_fapll_synth_enable,
 	.disable = ti_fapll_synth_disable,
 	.is_enabled = ti_fapll_synth_is_enabled,
 	.recalc_rate = ti_fapll_synth_recalc_rate,
+	.round_rate = ti_fapll_synth_round_rate,
+	.set_rate = ti_fapll_synth_set_rate,
 };
 
 static struct clk * __init ti_fapll_synth_setup(struct fapll_data *fd,

commit 33ca29c99e8680b4c921c6eafb9fc1603c5b9779
Author: Tony Lindgren <tony@atomide.com>
Date:   Sun Mar 22 15:35:24 2015 -0700

    clk: ti: Fix FAPLL recalc_rate for rounding errors
    
    We need to round the calculated value to have it match the requested rate.
    
    While at it, let's fix a typo and use a define for SYNTH_MAX_DIV_M as we
    will need it in later patches for set_rate.
    
    And let's remove two unused includes.
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Matthijs van Duin <matthijsvanduin@gmail.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index 6ef89639a9f6..97138c106a67 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -11,12 +11,10 @@
 
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/clk/ti.h>
-#include <asm/div64.h>
 
 /* FAPLL Control Register PLL_CTRL */
 #define FAPLL_MAIN_LOCK		BIT(7)
@@ -49,6 +47,8 @@
 /* Synthesizer frequency register */
 #define SYNTH_LDFREQ		BIT(31)
 
+#define SYNTH_MAX_DIV_M		0xff
+
 struct fapll_data {
 	struct clk_hw hw;
 	void __iomem *base;
@@ -218,11 +218,10 @@ static unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,
 		rate *= 8;
 	}
 
-	/* Synth ost-divider M */
-	synth_div_m = readl_relaxed(synth->div) & 0xff;
-	do_div(rate, synth_div_m);
+	/* Synth post-divider M */
+	synth_div_m = readl_relaxed(synth->div) & SYNTH_MAX_DIV_M;
 
-	return rate;
+	return DIV_ROUND_UP_ULL(rate, synth_div_m);
 }
 
 static struct clk_ops ti_fapll_synt_ops = {

commit 03208cc69fc16a8d46de49f51f49964666e4a694
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 28 09:00:49 2015 -0800

    clk: ti: Fix FAPLL parent enable bit handling
    
    Commit 163152cbbe32 ("clk: ti: Add support for FAPLL on dm816x")
    added basic support for the FAPLL on dm818x, but has a bug for the
    parent PLL enable bit. The FAPLL_MAIN_PLLEN is defined as BIT(3)
    but the code is doing a shift on it.
    
    This means the parent PLL won't get disabled even if all it's child
    synthesizers are disabled.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
index 6ef89639a9f6..d21640634adf 100644
--- a/drivers/clk/ti/fapll.c
+++ b/drivers/clk/ti/fapll.c
@@ -84,7 +84,7 @@ static int ti_fapll_enable(struct clk_hw *hw)
 	struct fapll_data *fd = to_fapll(hw);
 	u32 v = readl_relaxed(fd->base);
 
-	v |= (1 << FAPLL_MAIN_PLLEN);
+	v |= FAPLL_MAIN_PLLEN;
 	writel_relaxed(v, fd->base);
 
 	return 0;
@@ -95,7 +95,7 @@ static void ti_fapll_disable(struct clk_hw *hw)
 	struct fapll_data *fd = to_fapll(hw);
 	u32 v = readl_relaxed(fd->base);
 
-	v &= ~(1 << FAPLL_MAIN_PLLEN);
+	v &= ~FAPLL_MAIN_PLLEN;
 	writel_relaxed(v, fd->base);
 }
 
@@ -104,7 +104,7 @@ static int ti_fapll_is_enabled(struct clk_hw *hw)
 	struct fapll_data *fd = to_fapll(hw);
 	u32 v = readl_relaxed(fd->base);
 
-	return v & (1 << FAPLL_MAIN_PLLEN);
+	return v & FAPLL_MAIN_PLLEN;
 }
 
 static unsigned long ti_fapll_recalc_rate(struct clk_hw *hw,

commit 163152cbbe32177154cb6a2832b5c15324669bc1
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 13 14:51:27 2015 -0800

    clk: ti: Add support for FAPLL on dm816x
    
    On dm816x the clocks are sourced from a FAPLL (Flying Adder PLL)
    that does not seem to be used on the other omap variants.
    
    There are four instances of the FAPLL on dm816x that each have three
    to seven child synthesizers.
    
    I've set up the FAPLL as a single fapll.c driver. Later on we could
    potentially have the PLL code generic. To do that, we would have to
    consider the following:
    
    1. Setting the PLL to bypass mode also sets the child synthesizers
       into bypass mode. As the bypass rate can also be generated by
       the PLL in regular mode, there's no way for the child synthesizers
       to detect the bypass mode based on the parent clock rate.
    
    2. The PLL registers control the power for each of the child
       syntheriser.
    
    Note that the clocks are currently still missing the set_rate
    implementation so things are still running based on the bootloader
    values. That's OK for now as most of the outputs have dividers and
    those can be set using the existing TI component clock code.
    
    I have verified that the extclk rates are correct for a few clocks,
    so adding the set_rate support should be fairly trivial later on.
    
    This code is partially based on the TI81XX-LINUX-PSP-04.04.00.02
    patches published at:
    
    http://downloads.ti.com/dsps/dsps_public_sw/psp/LinuxPSP/TI81XX_04_04/04_04_00_02/index_FDS.html
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/fapll.c b/drivers/clk/ti/fapll.c
new file mode 100644
index 000000000000..6ef89639a9f6
--- /dev/null
+++ b/drivers/clk/ti/fapll.c
@@ -0,0 +1,410 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/clk/ti.h>
+#include <asm/div64.h>
+
+/* FAPLL Control Register PLL_CTRL */
+#define FAPLL_MAIN_LOCK		BIT(7)
+#define FAPLL_MAIN_PLLEN	BIT(3)
+#define FAPLL_MAIN_BP		BIT(2)
+#define FAPLL_MAIN_LOC_CTL	BIT(0)
+
+/* FAPLL powerdown register PWD */
+#define FAPLL_PWD_OFFSET	4
+
+#define MAX_FAPLL_OUTPUTS	7
+#define FAPLL_MAX_RETRIES	1000
+
+#define to_fapll(_hw)		container_of(_hw, struct fapll_data, hw)
+#define to_synth(_hw)		container_of(_hw, struct fapll_synth, hw)
+
+/* The bypass bit is inverted on the ddr_pll.. */
+#define fapll_is_ddr_pll(va)	(((u32)(va) & 0xffff) == 0x0440)
+
+/*
+ * The audio_pll_clk1 input is hard wired to the 27MHz bypass clock,
+ * and the audio_pll_clk1 synthesizer is hardwared to 32KiHz output.
+ */
+#define is_ddr_pll_clk1(va)	(((u32)(va) & 0xffff) == 0x044c)
+#define is_audio_pll_clk1(va)	(((u32)(va) & 0xffff) == 0x04a8)
+
+/* Synthesizer divider register */
+#define SYNTH_LDMDIV1		BIT(8)
+
+/* Synthesizer frequency register */
+#define SYNTH_LDFREQ		BIT(31)
+
+struct fapll_data {
+	struct clk_hw hw;
+	void __iomem *base;
+	const char *name;
+	struct clk *clk_ref;
+	struct clk *clk_bypass;
+	struct clk_onecell_data outputs;
+	bool bypass_bit_inverted;
+};
+
+struct fapll_synth {
+	struct clk_hw hw;
+	struct fapll_data *fd;
+	int index;
+	void __iomem *freq;
+	void __iomem *div;
+	const char *name;
+	struct clk *clk_pll;
+};
+
+static bool ti_fapll_clock_is_bypass(struct fapll_data *fd)
+{
+	u32 v = readl_relaxed(fd->base);
+
+	if (fd->bypass_bit_inverted)
+		return !(v & FAPLL_MAIN_BP);
+	else
+		return !!(v & FAPLL_MAIN_BP);
+}
+
+static int ti_fapll_enable(struct clk_hw *hw)
+{
+	struct fapll_data *fd = to_fapll(hw);
+	u32 v = readl_relaxed(fd->base);
+
+	v |= (1 << FAPLL_MAIN_PLLEN);
+	writel_relaxed(v, fd->base);
+
+	return 0;
+}
+
+static void ti_fapll_disable(struct clk_hw *hw)
+{
+	struct fapll_data *fd = to_fapll(hw);
+	u32 v = readl_relaxed(fd->base);
+
+	v &= ~(1 << FAPLL_MAIN_PLLEN);
+	writel_relaxed(v, fd->base);
+}
+
+static int ti_fapll_is_enabled(struct clk_hw *hw)
+{
+	struct fapll_data *fd = to_fapll(hw);
+	u32 v = readl_relaxed(fd->base);
+
+	return v & (1 << FAPLL_MAIN_PLLEN);
+}
+
+static unsigned long ti_fapll_recalc_rate(struct clk_hw *hw,
+					  unsigned long parent_rate)
+{
+	struct fapll_data *fd = to_fapll(hw);
+	u32 fapll_n, fapll_p, v;
+	long long rate;
+
+	if (ti_fapll_clock_is_bypass(fd))
+		return parent_rate;
+
+	rate = parent_rate;
+
+	/* PLL pre-divider is P and multiplier is N */
+	v = readl_relaxed(fd->base);
+	fapll_p = (v >> 8) & 0xff;
+	if (fapll_p)
+		do_div(rate, fapll_p);
+	fapll_n = v >> 16;
+	if (fapll_n)
+		rate *= fapll_n;
+
+	return rate;
+}
+
+static u8 ti_fapll_get_parent(struct clk_hw *hw)
+{
+	struct fapll_data *fd = to_fapll(hw);
+
+	if (ti_fapll_clock_is_bypass(fd))
+		return 1;
+
+	return 0;
+}
+
+static struct clk_ops ti_fapll_ops = {
+	.enable = ti_fapll_enable,
+	.disable = ti_fapll_disable,
+	.is_enabled = ti_fapll_is_enabled,
+	.recalc_rate = ti_fapll_recalc_rate,
+	.get_parent = ti_fapll_get_parent,
+};
+
+static int ti_fapll_synth_enable(struct clk_hw *hw)
+{
+	struct fapll_synth *synth = to_synth(hw);
+	u32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);
+
+	v &= ~(1 << synth->index);
+	writel_relaxed(v, synth->fd->base + FAPLL_PWD_OFFSET);
+
+	return 0;
+}
+
+static void ti_fapll_synth_disable(struct clk_hw *hw)
+{
+	struct fapll_synth *synth = to_synth(hw);
+	u32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);
+
+	v |= 1 << synth->index;
+	writel_relaxed(v, synth->fd->base + FAPLL_PWD_OFFSET);
+}
+
+static int ti_fapll_synth_is_enabled(struct clk_hw *hw)
+{
+	struct fapll_synth *synth = to_synth(hw);
+	u32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);
+
+	return !(v & (1 << synth->index));
+}
+
+/*
+ * See dm816x TRM chapter 1.10.3 Flying Adder PLL fore more info
+ */
+static unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct fapll_synth *synth = to_synth(hw);
+	u32 synth_div_m;
+	long long rate;
+
+	/* The audio_pll_clk1 is hardwired to produce 32.768KiHz clock */
+	if (!synth->div)
+		return 32768;
+
+	/*
+	 * PLL in bypass sets the synths in bypass mode too. The PLL rate
+	 * can be also be set to 27MHz, so we can't use parent_rate to
+	 * check for bypass mode.
+	 */
+	if (ti_fapll_clock_is_bypass(synth->fd))
+		return parent_rate;
+
+	rate = parent_rate;
+
+	/*
+	 * Synth frequency integer and fractional divider.
+	 * Note that the phase output K is 8, so the result needs
+	 * to be multiplied by 8.
+	 */
+	if (synth->freq) {
+		u32 v, synth_int_div, synth_frac_div, synth_div_freq;
+
+		v = readl_relaxed(synth->freq);
+		synth_int_div = (v >> 24) & 0xf;
+		synth_frac_div = v & 0xffffff;
+		synth_div_freq = (synth_int_div * 10000000) + synth_frac_div;
+		rate *= 10000000;
+		do_div(rate, synth_div_freq);
+		rate *= 8;
+	}
+
+	/* Synth ost-divider M */
+	synth_div_m = readl_relaxed(synth->div) & 0xff;
+	do_div(rate, synth_div_m);
+
+	return rate;
+}
+
+static struct clk_ops ti_fapll_synt_ops = {
+	.enable = ti_fapll_synth_enable,
+	.disable = ti_fapll_synth_disable,
+	.is_enabled = ti_fapll_synth_is_enabled,
+	.recalc_rate = ti_fapll_synth_recalc_rate,
+};
+
+static struct clk * __init ti_fapll_synth_setup(struct fapll_data *fd,
+						void __iomem *freq,
+						void __iomem *div,
+						int index,
+						const char *name,
+						const char *parent,
+						struct clk *pll_clk)
+{
+	struct clk_init_data *init;
+	struct fapll_synth *synth;
+
+	init = kzalloc(sizeof(*init), GFP_KERNEL);
+	if (!init)
+		return ERR_PTR(-ENOMEM);
+
+	init->ops = &ti_fapll_synt_ops;
+	init->name = name;
+	init->parent_names = &parent;
+	init->num_parents = 1;
+
+	synth = kzalloc(sizeof(*synth), GFP_KERNEL);
+	if (!synth)
+		goto free;
+
+	synth->fd = fd;
+	synth->index = index;
+	synth->freq = freq;
+	synth->div = div;
+	synth->name = name;
+	synth->hw.init = init;
+	synth->clk_pll = pll_clk;
+
+	return clk_register(NULL, &synth->hw);
+
+free:
+	kfree(synth);
+	kfree(init);
+
+	return ERR_PTR(-ENOMEM);
+}
+
+static void __init ti_fapll_setup(struct device_node *node)
+{
+	struct fapll_data *fd;
+	struct clk_init_data *init = NULL;
+	const char *parent_name[2];
+	struct clk *pll_clk;
+	int i;
+
+	fd = kzalloc(sizeof(*fd), GFP_KERNEL);
+	if (!fd)
+		return;
+
+	fd->outputs.clks = kzalloc(sizeof(struct clk *) *
+				   MAX_FAPLL_OUTPUTS + 1,
+				   GFP_KERNEL);
+	if (!fd->outputs.clks)
+		goto free;
+
+	init = kzalloc(sizeof(*init), GFP_KERNEL);
+	if (!init)
+		goto free;
+
+	init->ops = &ti_fapll_ops;
+	init->name = node->name;
+
+	init->num_parents = of_clk_get_parent_count(node);
+	if (init->num_parents != 2) {
+		pr_err("%s must have two parents\n", node->name);
+		goto free;
+	}
+
+	parent_name[0] = of_clk_get_parent_name(node, 0);
+	parent_name[1] = of_clk_get_parent_name(node, 1);
+	init->parent_names = parent_name;
+
+	fd->clk_ref = of_clk_get(node, 0);
+	if (IS_ERR(fd->clk_ref)) {
+		pr_err("%s could not get clk_ref\n", node->name);
+		goto free;
+	}
+
+	fd->clk_bypass = of_clk_get(node, 1);
+	if (IS_ERR(fd->clk_bypass)) {
+		pr_err("%s could not get clk_bypass\n", node->name);
+		goto free;
+	}
+
+	fd->base = of_iomap(node, 0);
+	if (!fd->base) {
+		pr_err("%s could not get IO base\n", node->name);
+		goto free;
+	}
+
+	if (fapll_is_ddr_pll(fd->base))
+		fd->bypass_bit_inverted = true;
+
+	fd->name = node->name;
+	fd->hw.init = init;
+
+	/* Register the parent PLL */
+	pll_clk = clk_register(NULL, &fd->hw);
+	if (IS_ERR(pll_clk))
+		goto unmap;
+
+	fd->outputs.clks[0] = pll_clk;
+	fd->outputs.clk_num++;
+
+	/*
+	 * Set up the child synthesizers starting at index 1 as the
+	 * PLL output is at index 0. We need to check the clock-indices
+	 * for numbering in case there are holes in the synth mapping,
+	 * and then probe the synth register to see if it has a FREQ
+	 * register available.
+	 */
+	for (i = 0; i < MAX_FAPLL_OUTPUTS; i++) {
+		const char *output_name;
+		void __iomem *freq, *div;
+		struct clk *synth_clk;
+		int output_instance;
+		u32 v;
+
+		if (of_property_read_string_index(node, "clock-output-names",
+						  i, &output_name))
+			continue;
+
+		if (of_property_read_u32_index(node, "clock-indices", i,
+					       &output_instance))
+			output_instance = i;
+
+		freq = fd->base + (output_instance * 8);
+		div = freq + 4;
+
+		/* Check for hardwired audio_pll_clk1 */
+		if (is_audio_pll_clk1(freq)) {
+			freq = 0;
+			div = 0;
+		} else {
+			/* Does the synthesizer have a FREQ register? */
+			v = readl_relaxed(freq);
+			if (!v)
+				freq = 0;
+		}
+		synth_clk = ti_fapll_synth_setup(fd, freq, div, output_instance,
+						 output_name, node->name,
+						 pll_clk);
+		if (IS_ERR(synth_clk))
+			continue;
+
+		fd->outputs.clks[output_instance] = synth_clk;
+		fd->outputs.clk_num++;
+
+		clk_register_clkdev(synth_clk, output_name, NULL);
+	}
+
+	/* Register the child synthesizers as the FAPLL outputs */
+	of_clk_add_provider(node, of_clk_src_onecell_get, &fd->outputs);
+	/* Add clock alias for the outputs */
+
+	kfree(init);
+
+	return;
+
+unmap:
+	iounmap(fd->base);
+free:
+	if (fd->clk_bypass)
+		clk_put(fd->clk_bypass);
+	if (fd->clk_ref)
+		clk_put(fd->clk_ref);
+	kfree(fd->outputs.clks);
+	kfree(fd);
+	kfree(init);
+}
+
+CLK_OF_DECLARE(ti_fapll_clock, "ti,dm816-fapll-clock", ti_fapll_setup);
