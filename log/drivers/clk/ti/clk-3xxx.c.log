commit 0ed266d7ae5e46de4730ddfb26fe9dde69fc5549
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Aug 24 15:33:01 2017 +0300

    clk: ti: omap3: cleanup unnecessary clock aliases
    
    Most of the clock aliases are no longer needed, only leave the ones
    required by OMAP timer code in place.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index b1251cae98b8..8aa5f5793835 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -224,296 +224,43 @@ const struct clk_hw_omap_ops clkhwops_am35xx_ipss_wait = {
 };
 
 static struct ti_dt_clk omap3xxx_clks[] = {
-	DT_CLK(NULL, "apb_pclk", "dummy_apb_pclk"),
-	DT_CLK(NULL, "omap_32k_fck", "omap_32k_fck"),
-	DT_CLK(NULL, "virt_12m_ck", "virt_12m_ck"),
-	DT_CLK(NULL, "virt_13m_ck", "virt_13m_ck"),
-	DT_CLK(NULL, "virt_19200000_ck", "virt_19200000_ck"),
-	DT_CLK(NULL, "virt_26000000_ck", "virt_26000000_ck"),
-	DT_CLK(NULL, "virt_38_4m_ck", "virt_38_4m_ck"),
-	DT_CLK(NULL, "osc_sys_ck", "osc_sys_ck"),
-	DT_CLK("twl", "fck", "osc_sys_ck"),
-	DT_CLK(NULL, "sys_ck", "sys_ck"),
-	DT_CLK(NULL, "omap_96m_alwon_fck", "omap_96m_alwon_fck"),
-	DT_CLK("etb", "emu_core_alwon_ck", "emu_core_alwon_ck"),
-	DT_CLK(NULL, "sys_altclk", "sys_altclk"),
-	DT_CLK(NULL, "sys_clkout1", "sys_clkout1"),
-	DT_CLK(NULL, "dpll1_ck", "dpll1_ck"),
-	DT_CLK(NULL, "dpll1_x2_ck", "dpll1_x2_ck"),
-	DT_CLK(NULL, "dpll1_x2m2_ck", "dpll1_x2m2_ck"),
-	DT_CLK(NULL, "dpll3_ck", "dpll3_ck"),
-	DT_CLK(NULL, "core_ck", "core_ck"),
-	DT_CLK(NULL, "dpll3_x2_ck", "dpll3_x2_ck"),
-	DT_CLK(NULL, "dpll3_m2_ck", "dpll3_m2_ck"),
-	DT_CLK(NULL, "dpll3_m2x2_ck", "dpll3_m2x2_ck"),
-	DT_CLK(NULL, "dpll3_m3_ck", "dpll3_m3_ck"),
-	DT_CLK(NULL, "dpll3_m3x2_ck", "dpll3_m3x2_ck"),
-	DT_CLK(NULL, "dpll4_ck", "dpll4_ck"),
-	DT_CLK(NULL, "dpll4_x2_ck", "dpll4_x2_ck"),
-	DT_CLK(NULL, "omap_96m_fck", "omap_96m_fck"),
-	DT_CLK(NULL, "cm_96m_fck", "cm_96m_fck"),
-	DT_CLK(NULL, "omap_54m_fck", "omap_54m_fck"),
-	DT_CLK(NULL, "omap_48m_fck", "omap_48m_fck"),
-	DT_CLK(NULL, "omap_12m_fck", "omap_12m_fck"),
-	DT_CLK(NULL, "dpll4_m2_ck", "dpll4_m2_ck"),
-	DT_CLK(NULL, "dpll4_m2x2_ck", "dpll4_m2x2_ck"),
-	DT_CLK(NULL, "dpll4_m3_ck", "dpll4_m3_ck"),
-	DT_CLK(NULL, "dpll4_m3x2_ck", "dpll4_m3x2_ck"),
-	DT_CLK(NULL, "dpll4_m4_ck", "dpll4_m4_ck"),
-	DT_CLK(NULL, "dpll4_m4x2_ck", "dpll4_m4x2_ck"),
-	DT_CLK(NULL, "dpll4_m5_ck", "dpll4_m5_ck"),
-	DT_CLK(NULL, "dpll4_m5x2_ck", "dpll4_m5x2_ck"),
-	DT_CLK(NULL, "dpll4_m6_ck", "dpll4_m6_ck"),
-	DT_CLK(NULL, "dpll4_m6x2_ck", "dpll4_m6x2_ck"),
-	DT_CLK("etb", "emu_per_alwon_ck", "emu_per_alwon_ck"),
-	DT_CLK(NULL, "clkout2_src_ck", "clkout2_src_ck"),
-	DT_CLK(NULL, "sys_clkout2", "sys_clkout2"),
-	DT_CLK(NULL, "corex2_fck", "corex2_fck"),
-	DT_CLK(NULL, "dpll1_fck", "dpll1_fck"),
-	DT_CLK(NULL, "mpu_ck", "mpu_ck"),
-	DT_CLK(NULL, "arm_fck", "arm_fck"),
-	DT_CLK("etb", "emu_mpu_alwon_ck", "emu_mpu_alwon_ck"),
-	DT_CLK(NULL, "l3_ick", "l3_ick"),
-	DT_CLK(NULL, "l4_ick", "l4_ick"),
-	DT_CLK(NULL, "rm_ick", "rm_ick"),
-	DT_CLK(NULL, "gpt10_fck", "gpt10_fck"),
-	DT_CLK(NULL, "gpt11_fck", "gpt11_fck"),
-	DT_CLK(NULL, "core_96m_fck", "core_96m_fck"),
-	DT_CLK(NULL, "mmchs2_fck", "mmchs2_fck"),
-	DT_CLK(NULL, "mmchs1_fck", "mmchs1_fck"),
-	DT_CLK(NULL, "i2c3_fck", "i2c3_fck"),
-	DT_CLK(NULL, "i2c2_fck", "i2c2_fck"),
-	DT_CLK(NULL, "i2c1_fck", "i2c1_fck"),
-	DT_CLK(NULL, "core_48m_fck", "core_48m_fck"),
-	DT_CLK(NULL, "mcspi4_fck", "mcspi4_fck"),
-	DT_CLK(NULL, "mcspi3_fck", "mcspi3_fck"),
-	DT_CLK(NULL, "mcspi2_fck", "mcspi2_fck"),
-	DT_CLK(NULL, "mcspi1_fck", "mcspi1_fck"),
-	DT_CLK(NULL, "uart2_fck", "uart2_fck"),
-	DT_CLK(NULL, "uart1_fck", "uart1_fck"),
-	DT_CLK(NULL, "core_12m_fck", "core_12m_fck"),
-	DT_CLK("omap_hdq.0", "fck", "hdq_fck"),
-	DT_CLK(NULL, "hdq_fck", "hdq_fck"),
-	DT_CLK(NULL, "core_l3_ick", "core_l3_ick"),
-	DT_CLK(NULL, "sdrc_ick", "sdrc_ick"),
-	DT_CLK(NULL, "gpmc_fck", "gpmc_fck"),
-	DT_CLK(NULL, "core_l4_ick", "core_l4_ick"),
-	DT_CLK("omap_hsmmc.1", "ick", "mmchs2_ick"),
-	DT_CLK("omap_hsmmc.0", "ick", "mmchs1_ick"),
-	DT_CLK(NULL, "mmchs2_ick", "mmchs2_ick"),
-	DT_CLK(NULL, "mmchs1_ick", "mmchs1_ick"),
-	DT_CLK("omap_hdq.0", "ick", "hdq_ick"),
-	DT_CLK(NULL, "hdq_ick", "hdq_ick"),
-	DT_CLK("omap2_mcspi.4", "ick", "mcspi4_ick"),
-	DT_CLK("omap2_mcspi.3", "ick", "mcspi3_ick"),
-	DT_CLK("omap2_mcspi.2", "ick", "mcspi2_ick"),
-	DT_CLK("omap2_mcspi.1", "ick", "mcspi1_ick"),
-	DT_CLK(NULL, "mcspi4_ick", "mcspi4_ick"),
-	DT_CLK(NULL, "mcspi3_ick", "mcspi3_ick"),
-	DT_CLK(NULL, "mcspi2_ick", "mcspi2_ick"),
-	DT_CLK(NULL, "mcspi1_ick", "mcspi1_ick"),
-	DT_CLK("omap_i2c.3", "ick", "i2c3_ick"),
-	DT_CLK("omap_i2c.2", "ick", "i2c2_ick"),
-	DT_CLK("omap_i2c.1", "ick", "i2c1_ick"),
-	DT_CLK(NULL, "i2c3_ick", "i2c3_ick"),
-	DT_CLK(NULL, "i2c2_ick", "i2c2_ick"),
-	DT_CLK(NULL, "i2c1_ick", "i2c1_ick"),
-	DT_CLK(NULL, "uart2_ick", "uart2_ick"),
-	DT_CLK(NULL, "uart1_ick", "uart1_ick"),
-	DT_CLK(NULL, "gpt11_ick", "gpt11_ick"),
-	DT_CLK(NULL, "gpt10_ick", "gpt10_ick"),
-	DT_CLK(NULL, "omapctrl_ick", "omapctrl_ick"),
-	DT_CLK(NULL, "dss_tv_fck", "dss_tv_fck"),
-	DT_CLK(NULL, "dss_96m_fck", "dss_96m_fck"),
-	DT_CLK(NULL, "dss2_alwon_fck", "dss2_alwon_fck"),
-	DT_CLK(NULL, "init_60m_fclk", "dummy_ck"),
-	DT_CLK(NULL, "gpt1_fck", "gpt1_fck"),
-	DT_CLK(NULL, "aes2_ick", "aes2_ick"),
-	DT_CLK(NULL, "wkup_32k_fck", "wkup_32k_fck"),
-	DT_CLK(NULL, "gpio1_dbck", "gpio1_dbck"),
-	DT_CLK(NULL, "sha12_ick", "sha12_ick"),
-	DT_CLK(NULL, "wdt2_fck", "wdt2_fck"),
-	DT_CLK("omap_wdt", "ick", "wdt2_ick"),
-	DT_CLK(NULL, "wdt2_ick", "wdt2_ick"),
-	DT_CLK(NULL, "wdt1_ick", "wdt1_ick"),
-	DT_CLK(NULL, "gpio1_ick", "gpio1_ick"),
-	DT_CLK(NULL, "omap_32ksync_ick", "omap_32ksync_ick"),
-	DT_CLK(NULL, "gpt12_ick", "gpt12_ick"),
-	DT_CLK(NULL, "gpt1_ick", "gpt1_ick"),
-	DT_CLK(NULL, "per_96m_fck", "per_96m_fck"),
-	DT_CLK(NULL, "per_48m_fck", "per_48m_fck"),
-	DT_CLK(NULL, "uart3_fck", "uart3_fck"),
-	DT_CLK(NULL, "gpt2_fck", "gpt2_fck"),
-	DT_CLK(NULL, "gpt3_fck", "gpt3_fck"),
-	DT_CLK(NULL, "gpt4_fck", "gpt4_fck"),
-	DT_CLK(NULL, "gpt5_fck", "gpt5_fck"),
-	DT_CLK(NULL, "gpt6_fck", "gpt6_fck"),
-	DT_CLK(NULL, "gpt7_fck", "gpt7_fck"),
-	DT_CLK(NULL, "gpt8_fck", "gpt8_fck"),
-	DT_CLK(NULL, "gpt9_fck", "gpt9_fck"),
-	DT_CLK(NULL, "per_32k_alwon_fck", "per_32k_alwon_fck"),
-	DT_CLK(NULL, "gpio6_dbck", "gpio6_dbck"),
-	DT_CLK(NULL, "gpio5_dbck", "gpio5_dbck"),
-	DT_CLK(NULL, "gpio4_dbck", "gpio4_dbck"),
-	DT_CLK(NULL, "gpio3_dbck", "gpio3_dbck"),
-	DT_CLK(NULL, "gpio2_dbck", "gpio2_dbck"),
-	DT_CLK(NULL, "wdt3_fck", "wdt3_fck"),
-	DT_CLK(NULL, "per_l4_ick", "per_l4_ick"),
-	DT_CLK(NULL, "gpio6_ick", "gpio6_ick"),
-	DT_CLK(NULL, "gpio5_ick", "gpio5_ick"),
-	DT_CLK(NULL, "gpio4_ick", "gpio4_ick"),
-	DT_CLK(NULL, "gpio3_ick", "gpio3_ick"),
-	DT_CLK(NULL, "gpio2_ick", "gpio2_ick"),
-	DT_CLK(NULL, "wdt3_ick", "wdt3_ick"),
-	DT_CLK(NULL, "uart3_ick", "uart3_ick"),
-	DT_CLK(NULL, "gpt9_ick", "gpt9_ick"),
-	DT_CLK(NULL, "gpt8_ick", "gpt8_ick"),
-	DT_CLK(NULL, "gpt7_ick", "gpt7_ick"),
-	DT_CLK(NULL, "gpt6_ick", "gpt6_ick"),
-	DT_CLK(NULL, "gpt5_ick", "gpt5_ick"),
-	DT_CLK(NULL, "gpt4_ick", "gpt4_ick"),
-	DT_CLK(NULL, "gpt3_ick", "gpt3_ick"),
-	DT_CLK(NULL, "gpt2_ick", "gpt2_ick"),
-	DT_CLK(NULL, "mcbsp_clks", "mcbsp_clks"),
-	DT_CLK(NULL, "mcbsp1_ick", "mcbsp1_ick"),
-	DT_CLK(NULL, "mcbsp2_ick", "mcbsp2_ick"),
-	DT_CLK(NULL, "mcbsp3_ick", "mcbsp3_ick"),
-	DT_CLK(NULL, "mcbsp4_ick", "mcbsp4_ick"),
-	DT_CLK(NULL, "mcbsp5_ick", "mcbsp5_ick"),
-	DT_CLK(NULL, "mcbsp1_fck", "mcbsp1_fck"),
-	DT_CLK(NULL, "mcbsp2_fck", "mcbsp2_fck"),
-	DT_CLK(NULL, "mcbsp3_fck", "mcbsp3_fck"),
-	DT_CLK(NULL, "mcbsp4_fck", "mcbsp4_fck"),
-	DT_CLK(NULL, "mcbsp5_fck", "mcbsp5_fck"),
-	DT_CLK("etb", "emu_src_ck", "emu_src_ck"),
-	DT_CLK(NULL, "emu_src_ck", "emu_src_ck"),
-	DT_CLK(NULL, "pclk_fck", "pclk_fck"),
-	DT_CLK(NULL, "pclkx2_fck", "pclkx2_fck"),
-	DT_CLK(NULL, "atclk_fck", "atclk_fck"),
-	DT_CLK(NULL, "traceclk_src_fck", "traceclk_src_fck"),
-	DT_CLK(NULL, "traceclk_fck", "traceclk_fck"),
-	DT_CLK(NULL, "secure_32k_fck", "secure_32k_fck"),
-	DT_CLK(NULL, "gpt12_fck", "gpt12_fck"),
-	DT_CLK(NULL, "wdt1_fck", "wdt1_fck"),
 	DT_CLK(NULL, "timer_32k_ck", "omap_32k_fck"),
 	DT_CLK(NULL, "timer_sys_ck", "sys_ck"),
-	DT_CLK(NULL, "cpufreq_ck", "dpll1_ck"),
-	{ .node_name = NULL },
-};
-
-static struct ti_dt_clk omap34xx_omap36xx_clks[] = {
-	DT_CLK(NULL, "aes1_ick", "aes1_ick"),
-	DT_CLK("omap_rng", "ick", "rng_ick"),
-	DT_CLK("omap3-rom-rng", "ick", "rng_ick"),
-	DT_CLK(NULL, "sha11_ick", "sha11_ick"),
-	DT_CLK(NULL, "des1_ick", "des1_ick"),
-	DT_CLK(NULL, "cam_mclk", "cam_mclk"),
-	DT_CLK(NULL, "cam_ick", "cam_ick"),
-	DT_CLK(NULL, "csi2_96m_fck", "csi2_96m_fck"),
-	DT_CLK(NULL, "security_l3_ick", "security_l3_ick"),
-	DT_CLK(NULL, "pka_ick", "pka_ick"),
-	DT_CLK(NULL, "icr_ick", "icr_ick"),
-	DT_CLK("omap-aes", "ick", "aes2_ick"),
-	DT_CLK("omap-sham", "ick", "sha12_ick"),
-	DT_CLK(NULL, "des2_ick", "des2_ick"),
-	DT_CLK(NULL, "mspro_ick", "mspro_ick"),
-	DT_CLK(NULL, "mailboxes_ick", "mailboxes_ick"),
-	DT_CLK(NULL, "ssi_l4_ick", "ssi_l4_ick"),
-	DT_CLK(NULL, "sr1_fck", "sr1_fck"),
-	DT_CLK(NULL, "sr2_fck", "sr2_fck"),
-	DT_CLK(NULL, "sr_l4_ick", "sr_l4_ick"),
-	DT_CLK(NULL, "security_l4_ick2", "security_l4_ick2"),
-	DT_CLK(NULL, "wkup_l4_ick", "wkup_l4_ick"),
-	DT_CLK(NULL, "dpll2_fck", "dpll2_fck"),
-	DT_CLK(NULL, "iva2_ck", "iva2_ck"),
-	DT_CLK(NULL, "modem_fck", "modem_fck"),
-	DT_CLK(NULL, "sad2d_ick", "sad2d_ick"),
-	DT_CLK(NULL, "mad2d_ick", "mad2d_ick"),
-	DT_CLK(NULL, "mspro_fck", "mspro_fck"),
-	DT_CLK(NULL, "dpll2_ck", "dpll2_ck"),
-	DT_CLK(NULL, "dpll2_m2_ck", "dpll2_m2_ck"),
 	{ .node_name = NULL },
 };
 
 static struct ti_dt_clk omap36xx_omap3430es2plus_clks[] = {
 	DT_CLK(NULL, "ssi_ssr_fck", "ssi_ssr_fck_3430es2"),
 	DT_CLK(NULL, "ssi_sst_fck", "ssi_sst_fck_3430es2"),
-	DT_CLK("musb-omap2430", "ick", "hsotgusb_ick_3430es2"),
 	DT_CLK(NULL, "hsotgusb_ick", "hsotgusb_ick_3430es2"),
 	DT_CLK(NULL, "ssi_ick", "ssi_ick_3430es2"),
-	DT_CLK(NULL, "usim_fck", "usim_fck"),
-	DT_CLK(NULL, "usim_ick", "usim_ick"),
 	{ .node_name = NULL },
 };
 
 static struct ti_dt_clk omap3430es1_clks[] = {
-	DT_CLK(NULL, "gfx_l3_ck", "gfx_l3_ck"),
-	DT_CLK(NULL, "gfx_l3_fck", "gfx_l3_fck"),
-	DT_CLK(NULL, "gfx_l3_ick", "gfx_l3_ick"),
-	DT_CLK(NULL, "gfx_cg1_ck", "gfx_cg1_ck"),
-	DT_CLK(NULL, "gfx_cg2_ck", "gfx_cg2_ck"),
-	DT_CLK(NULL, "d2d_26m_fck", "d2d_26m_fck"),
-	DT_CLK(NULL, "fshostusb_fck", "fshostusb_fck"),
 	DT_CLK(NULL, "ssi_ssr_fck", "ssi_ssr_fck_3430es1"),
 	DT_CLK(NULL, "ssi_sst_fck", "ssi_sst_fck_3430es1"),
-	DT_CLK("musb-omap2430", "ick", "hsotgusb_ick_3430es1"),
 	DT_CLK(NULL, "hsotgusb_ick", "hsotgusb_ick_3430es1"),
-	DT_CLK(NULL, "fac_ick", "fac_ick"),
 	DT_CLK(NULL, "ssi_ick", "ssi_ick_3430es1"),
-	DT_CLK(NULL, "usb_l4_ick", "usb_l4_ick"),
 	DT_CLK(NULL, "dss1_alwon_fck", "dss1_alwon_fck_3430es1"),
-	DT_CLK("omapdss_dss", "ick", "dss_ick_3430es1"),
 	DT_CLK(NULL, "dss_ick", "dss_ick_3430es1"),
 	{ .node_name = NULL },
 };
 
 static struct ti_dt_clk omap36xx_am35xx_omap3430es2plus_clks[] = {
-	DT_CLK(NULL, "virt_16_8m_ck", "virt_16_8m_ck"),
-	DT_CLK(NULL, "dpll5_ck", "dpll5_ck"),
-	DT_CLK(NULL, "dpll5_m2_ck", "dpll5_m2_ck"),
-	DT_CLK(NULL, "sgx_fck", "sgx_fck"),
-	DT_CLK(NULL, "sgx_ick", "sgx_ick"),
-	DT_CLK(NULL, "cpefuse_fck", "cpefuse_fck"),
-	DT_CLK(NULL, "ts_fck", "ts_fck"),
-	DT_CLK(NULL, "usbtll_fck", "usbtll_fck"),
-	DT_CLK(NULL, "usbtll_ick", "usbtll_ick"),
-	DT_CLK("omap_hsmmc.2", "ick", "mmchs3_ick"),
-	DT_CLK(NULL, "mmchs3_ick", "mmchs3_ick"),
-	DT_CLK(NULL, "mmchs3_fck", "mmchs3_fck"),
 	DT_CLK(NULL, "dss1_alwon_fck", "dss1_alwon_fck_3430es2"),
-	DT_CLK("omapdss_dss", "ick", "dss_ick_3430es2"),
 	DT_CLK(NULL, "dss_ick", "dss_ick_3430es2"),
-	DT_CLK(NULL, "usbhost_120m_fck", "usbhost_120m_fck"),
-	DT_CLK(NULL, "usbhost_48m_fck", "usbhost_48m_fck"),
-	DT_CLK(NULL, "usbhost_ick", "usbhost_ick"),
 	{ .node_name = NULL },
 };
 
 static struct ti_dt_clk am35xx_clks[] = {
-	DT_CLK(NULL, "ipss_ick", "ipss_ick"),
-	DT_CLK(NULL, "rmii_ck", "rmii_ck"),
-	DT_CLK(NULL, "pclk_ck", "pclk_ck"),
-	DT_CLK(NULL, "emac_ick", "emac_ick"),
-	DT_CLK(NULL, "emac_fck", "emac_fck"),
-	DT_CLK("davinci_emac.0", NULL, "emac_ick"),
-	DT_CLK("davinci_mdio.0", NULL, "emac_fck"),
-	DT_CLK("vpfe-capture", "master", "vpfe_ick"),
-	DT_CLK("vpfe-capture", "slave", "vpfe_fck"),
 	DT_CLK(NULL, "hsotgusb_ick", "hsotgusb_ick_am35xx"),
 	DT_CLK(NULL, "hsotgusb_fck", "hsotgusb_fck_am35xx"),
-	DT_CLK(NULL, "hecc_ck", "hecc_ck"),
 	DT_CLK(NULL, "uart4_ick", "uart4_ick_am35xx"),
 	DT_CLK(NULL, "uart4_fck", "uart4_fck_am35xx"),
 	{ .node_name = NULL },
 };
 
-static struct ti_dt_clk omap36xx_clks[] = {
-	DT_CLK(NULL, "omap_192m_alwon_fck", "omap_192m_alwon_fck"),
-	DT_CLK(NULL, "uart4_fck", "uart4_fck"),
-	DT_CLK(NULL, "uart4_ick", "uart4_ick"),
-	{ .node_name = NULL },
-};
-
 static const char *enable_init_clks[] = {
 	"sdrc_ick",
 	"gpmc_fck",
@@ -579,16 +326,10 @@ static int __init omap3xxx_dt_clk_init(int soc_type)
 	    soc_type == OMAP3_SOC_OMAP3630)
 		ti_dt_clocks_register(omap36xx_omap3430es2plus_clks);
 
-	if (soc_type == OMAP3_SOC_OMAP3430_ES1 ||
-	    soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS ||
-	    soc_type == OMAP3_SOC_OMAP3630)
-		ti_dt_clocks_register(omap34xx_omap36xx_clks);
-
-	if (soc_type == OMAP3_SOC_OMAP3630)
-		ti_dt_clocks_register(omap36xx_clks);
-
 	omap2_clk_disable_autoidle_all();
 
+	ti_clk_add_aliases();
+
 	omap2_clk_enable_init_clocks(enable_init_clks,
 				     ARRAY_SIZE(enable_init_clks));
 

commit 6c0afb503937a12a8d20a805fcf263e31afa9871
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 9 11:24:37 2017 +0200

    clk: ti: convert to use proper register definition for all accesses
    
    Currently, TI clock driver uses an encapsulated struct that is cast into
    a void pointer to store all register addresses. This can be considered
    as rather nasty hackery, and prevents from expanding the register
    address field also. Instead, replace all the code to use proper struct
    in place for this, which contains all the previously used data.
    
    This patch is rather large as it is touching multiple files, but this
    can't be split up as we need to avoid any boot breakage.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 11d8aa3ec186..b1251cae98b8 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -52,14 +52,13 @@
  * @idlest_reg and @idlest_bit.  No return value.
  */
 static void omap3430es2_clk_ssi_find_idlest(struct clk_hw_omap *clk,
-					    void __iomem **idlest_reg,
+					    struct clk_omap_reg *idlest_reg,
 					    u8 *idlest_bit,
 					    u8 *idlest_val)
 {
-	u32 r;
-
-	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
-	*idlest_reg = (__force void __iomem *)r;
+	memcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));
+	idlest_reg->offset &= ~0xf0;
+	idlest_reg->offset |= 0x20;
 	*idlest_bit = OMAP3430ES2_ST_SSI_IDLE_SHIFT;
 	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
 }
@@ -85,15 +84,15 @@ const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_ssi_wait = {
  * default find_idlest code assumes that they are at the same
  * position.)  No return value.
  */
-static void omap3430es2_clk_dss_usbhost_find_idlest(struct clk_hw_omap *clk,
-						    void __iomem **idlest_reg,
-						    u8 *idlest_bit,
-						    u8 *idlest_val)
+static void
+omap3430es2_clk_dss_usbhost_find_idlest(struct clk_hw_omap *clk,
+					struct clk_omap_reg *idlest_reg,
+					u8 *idlest_bit, u8 *idlest_val)
 {
-	u32 r;
+	memcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));
 
-	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
-	*idlest_reg = (__force void __iomem *)r;
+	idlest_reg->offset &= ~0xf0;
+	idlest_reg->offset |= 0x20;
 	/* USBHOST_IDLE has same shift */
 	*idlest_bit = OMAP3430ES2_ST_DSS_IDLE_SHIFT;
 	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
@@ -122,15 +121,15 @@ const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_dss_usbhost_wait = {
  * shift from the CM_{I,F}CLKEN bit.  Pass back the correct info via
  * @idlest_reg and @idlest_bit.  No return value.
  */
-static void omap3430es2_clk_hsotgusb_find_idlest(struct clk_hw_omap *clk,
-						 void __iomem **idlest_reg,
-						 u8 *idlest_bit,
-						 u8 *idlest_val)
+static void
+omap3430es2_clk_hsotgusb_find_idlest(struct clk_hw_omap *clk,
+				     struct clk_omap_reg *idlest_reg,
+				     u8 *idlest_bit,
+				     u8 *idlest_val)
 {
-	u32 r;
-
-	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
-	*idlest_reg = (__force void __iomem *)r;
+	memcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));
+	idlest_reg->offset &= ~0xf0;
+	idlest_reg->offset |= 0x20;
 	*idlest_bit = OMAP3430ES2_ST_HSOTGUSB_IDLE_SHIFT;
 	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
 }
@@ -154,11 +153,11 @@ const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_hsotgusb_wait = {
  * bit. A value of 1 indicates that clock is enabled.
  */
 static void am35xx_clk_find_idlest(struct clk_hw_omap *clk,
-				   void __iomem **idlest_reg,
+				   struct clk_omap_reg *idlest_reg,
 				   u8 *idlest_bit,
 				   u8 *idlest_val)
 {
-	*idlest_reg = (__force void __iomem *)(clk->enable_reg);
+	memcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));
 	*idlest_bit = clk->enable_bit + AM35XX_IPSS_ICK_EN_ACK_OFFSET;
 	*idlest_val = AM35XX_IPSS_CLK_IDLEST_VAL;
 }
@@ -178,10 +177,10 @@ static void am35xx_clk_find_idlest(struct clk_hw_omap *clk,
  * avoid this issue, and remove the casts.  No return value.
  */
 static void am35xx_clk_find_companion(struct clk_hw_omap *clk,
-				      void __iomem **other_reg,
+				      struct clk_omap_reg *other_reg,
 				      u8 *other_bit)
 {
-	*other_reg = (__force void __iomem *)(clk->enable_reg);
+	memcpy(other_reg, &clk->enable_reg, sizeof(*other_reg));
 	if (clk->enable_bit & AM35XX_IPSS_ICK_MASK)
 		*other_bit = clk->enable_bit + AM35XX_IPSS_ICK_FCK_OFFSET;
 	else
@@ -205,14 +204,14 @@ const struct clk_hw_omap_ops clkhwops_am35xx_ipss_module_wait = {
  * and @idlest_bit.  No return value.
  */
 static void am35xx_clk_ipss_find_idlest(struct clk_hw_omap *clk,
-					void __iomem **idlest_reg,
+					struct clk_omap_reg *idlest_reg,
 					u8 *idlest_bit,
 					u8 *idlest_val)
 {
-	u32 r;
+	memcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));
 
-	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
-	*idlest_reg = (__force void __iomem *)r;
+	idlest_reg->offset &= ~0xf0;
+	idlest_reg->offset |= 0x20;
 	*idlest_bit = AM35XX_ST_IPSS_SHIFT;
 	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
 }

commit 035cd485a47dda64f25ccf8a90b11a07d0b7aa7a
Author: Richard Watts <rrw@kynesim.co.uk>
Date:   Fri Dec 2 23:14:38 2016 +0200

    clk: ti: omap36xx: Work around sprz319 advisory 2.1
    
    The OMAP36xx DPLL5, driving EHCI USB, can be subject to a long-term
    frequency drift. The frequency drift magnitude depends on the VCO update
    rate, which is inversely proportional to the PLL divider. The kernel
    DPLL configuration code results in a high value for the divider, leading
    to a long term drift high enough to cause USB transmission errors. In
    the worst case the USB PHY's ULPI interface can stop responding,
    breaking USB operation completely. This manifests itself on the
    Beagleboard xM by the LAN9514 reporting 'Cannot enable port 2. Maybe the
    cable is bad?' in the kernel log.
    
    Errata sprz319 advisory 2.1 documents PLL values that minimize the
    drift. Use them automatically when DPLL5 is used for USB operation,
    which we detect based on the requested clock rate. The clock framework
    will still compute the PLL parameters and resulting rate as usual, but
    the PLL M and N values will then be overridden. This can result in the
    effective clock rate being slightly different than the rate cached by
    the clock framework, but won't cause any adverse effect to USB
    operation.
    
    Signed-off-by: Richard Watts <rrw@kynesim.co.uk>
    [Upported from v3.2 to v4.9]
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Ladislav Michl <ladis@linux-mips.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 8831e1a05367..11d8aa3ec186 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -22,13 +22,6 @@
 
 #include "clock.h"
 
-/*
- * DPLL5_FREQ_FOR_USBHOST: USBHOST and USBTLL are the only clocks
- * that are sourced by DPLL5, and both of these require this clock
- * to be at 120 MHz for proper operation.
- */
-#define DPLL5_FREQ_FOR_USBHOST		120000000
-
 #define OMAP3430ES2_ST_DSS_IDLE_SHIFT			1
 #define OMAP3430ES2_ST_HSOTGUSB_IDLE_SHIFT		5
 #define OMAP3430ES2_ST_SSI_IDLE_SHIFT			8
@@ -546,14 +539,21 @@ void __init omap3_clk_lock_dpll5(void)
 	struct clk *dpll5_clk;
 	struct clk *dpll5_m2_clk;
 
+	/*
+	 * Errata sprz319f advisory 2.1 documents a USB host clock drift issue
+	 * that can be worked around using specially crafted dpll5 settings
+	 * with a dpll5_m2 divider set to 8. Set the dpll5 rate to 8x the USB
+	 * host clock rate, its .set_rate handler() will detect that frequency
+	 * and use the errata settings.
+	 */
 	dpll5_clk = clk_get(NULL, "dpll5_ck");
-	clk_set_rate(dpll5_clk, DPLL5_FREQ_FOR_USBHOST);
+	clk_set_rate(dpll5_clk, OMAP3_DPLL5_FREQ_FOR_USBHOST * 8);
 	clk_prepare_enable(dpll5_clk);
 
-	/* Program dpll5_m2_clk divider for no division */
+	/* Program dpll5_m2_clk divider */
 	dpll5_m2_clk = clk_get(NULL, "dpll5_m2_ck");
 	clk_prepare_enable(dpll5_m2_clk);
-	clk_set_rate(dpll5_m2_clk, DPLL5_FREQ_FOR_USBHOST);
+	clk_set_rate(dpll5_m2_clk, OMAP3_DPLL5_FREQ_FOR_USBHOST);
 
 	clk_disable_unprepare(dpll5_m2_clk);
 	clk_disable_unprepare(dpll5_clk);

commit 19e79687de22f23bcfb5e79cce3daba20af228d1
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Sep 29 15:01:08 2015 +0100

    clk: ti: fix dual-registration of uart4_ick
    
    On the OMAP AM3517 platform the uart4_ick gets registered
    twice, causing any power management to /dev/ttyO3 to fail
    when trying to wake the device up.
    
    This solves the following oops:
    
    [] Unhandled fault: external abort on non-linefetch (0x1028) at 0xfa09e008
    [] PC is at serial_omap_pm+0x48/0x15c
    [] LR is at _raw_spin_unlock_irqrestore+0x30/0x5c
    
    Fixes: aafd900cab87 ("CLK: TI: add omap3 clock init file")
    Cc: stable@vger.kernel.org
    Cc: mturquette@baylibre.com
    Cc: sboyd@codeaurora.org
    Cc: linux-clk@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-kernel@lists.codethink.co.uk
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 676ee8f6d813..8831e1a05367 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -374,7 +374,6 @@ static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "gpio2_ick", "gpio2_ick"),
 	DT_CLK(NULL, "wdt3_ick", "wdt3_ick"),
 	DT_CLK(NULL, "uart3_ick", "uart3_ick"),
-	DT_CLK(NULL, "uart4_ick", "uart4_ick"),
 	DT_CLK(NULL, "gpt9_ick", "gpt9_ick"),
 	DT_CLK(NULL, "gpt8_ick", "gpt8_ick"),
 	DT_CLK(NULL, "gpt7_ick", "gpt7_ick"),
@@ -519,6 +518,7 @@ static struct ti_dt_clk am35xx_clks[] = {
 static struct ti_dt_clk omap36xx_clks[] = {
 	DT_CLK(NULL, "omap_192m_alwon_fck", "omap_192m_alwon_fck"),
 	DT_CLK(NULL, "uart4_fck", "uart4_fck"),
+	DT_CLK(NULL, "uart4_ick", "uart4_ick"),
 	{ .node_name = NULL },
 };
 

commit 9cfad9bc472a4bdd5ee7d9e713113a9f5a676704
Merge: 9da9e7612737 61ae76563ec3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 21 11:22:42 2015 -0700

    Merge branch 'cleanup-clk-h-includes' into clk-next
    
    * cleanup-clk-h-includes: (62 commits)
      clk: Remove clk.h from clk-provider.h
      clk: h8300: Remove clk.h and clkdev.h includes
      clk: at91: Include clk.h and slab.h
      clk: ti: Switch clk-provider.h include to clk.h
      clk: pistachio: Include clk.h
      clk: ingenic: Include clk.h
      clk: si570: Include clk.h
      clk: moxart: Include clk.h
      clk: cdce925: Include clk.h
      clk: Include clk.h in clk.c
      clk: zynq: Include clk.h
      clk: ti: Include clk.h
      clk: sunxi: Include clk.h and remove unused clkdev.h includes
      clk: st: Include clk.h
      clk: qcom: Include clk.h
      clk: highbank: Include clk.h
      clk: bcm: Include clk.h
      clk: versatile: Remove clk.h and clkdev.h includes
      clk: ux500: Remove clk.h and clkdev.h includes
      clk: tegra: Properly include clk.h
      ...

commit 76642eb4cb040b436319e5aa747a5ef026207eef
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 15 12:04:53 2015 -0700

    clk: ti: clk-3xxx: Remove unused structures
    
    Sparse complains about these structures missing static, but they
    also don't look to be used. Remove them.
    
    drivers/clk/ti/clk-3xxx.c:74:30: warning: symbol 'clkhwops_omap3430es2_ssi_wait' was not declared. Should it be static?
    drivers/clk/ti/clk-3xxx.c:157:30: warning: symbol 'clkhwops_omap3430es2_hsotgusb_wait' was not declared. Should it be static?
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 6e33332b6b34..70eb85ac88f3 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -70,11 +70,6 @@ static void omap3430es2_clk_ssi_find_idlest(struct clk_hw_omap *clk,
 	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
 }
 
-const struct clk_hw_omap_ops clkhwops_omap3430es2_ssi_wait = {
-	.find_idlest	= omap3430es2_clk_ssi_find_idlest,
-	.find_companion	= omap2_clk_dflt_find_companion,
-};
-
 const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_ssi_wait = {
 	.allow_idle	= omap2_clkt_iclk_allow_idle,
 	.deny_idle	= omap2_clkt_iclk_deny_idle,
@@ -153,11 +148,6 @@ const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_hsotgusb_wait = {
 	.find_companion	= omap2_clk_dflt_find_companion,
 };
 
-const struct clk_hw_omap_ops clkhwops_omap3430es2_hsotgusb_wait = {
-	.find_idlest	= omap3430es2_clk_hsotgusb_find_idlest,
-	.find_companion	= omap2_clk_dflt_find_companion,
-};
-
 /**
  * am35xx_clk_find_idlest - return clock ACK info for AM35XX IPSS
  * @clk: struct clk * being enabled

commit 1b29e60157e845869abb867df6c7164eaace88b6
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: ti: Include clk.h
    
    This clock provider uses the consumer API, so include clk.h
    explicitly.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 757636d166cf..5df21b258658 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -16,6 +16,7 @@
 
 #include <linux/kernel.h>
 #include <linux/list.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/clk/ti.h>
 

commit c9a58b0a848e4b88d2dd4690ef19bae8696649eb
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 3 21:19:25 2015 +0200

    clk: ti: am3517: move remaining am3517 clock support code to clock driver
    
    With legacy clock support gone, this is no longer needed under platform,
    so move it under the clock driver itself. Make some exports be driver
    internal definitions at the same time.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 58879f0b7949..6e33332b6b34 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -34,6 +34,18 @@
 
 #define OMAP34XX_CM_IDLEST_VAL				1
 
+/*
+ * In AM35xx IPSS, the {ICK,FCK} enable bits for modules are exported
+ * in the same register at a bit offset of 0x8. The EN_ACK for ICK is
+ * at an offset of 4 from ICK enable bit.
+ */
+#define AM35XX_IPSS_ICK_MASK			0xF
+#define AM35XX_IPSS_ICK_EN_ACK_OFFSET		0x4
+#define AM35XX_IPSS_ICK_FCK_OFFSET		0x8
+#define AM35XX_IPSS_CLK_IDLEST_VAL		0
+
+#define AM35XX_ST_IPSS_SHIFT			5
+
 /**
  * omap3430es2_clk_ssi_find_idlest - return CM_IDLEST info for SSI
  * @clk: struct clk * being enabled
@@ -146,6 +158,88 @@ const struct clk_hw_omap_ops clkhwops_omap3430es2_hsotgusb_wait = {
 	.find_companion	= omap2_clk_dflt_find_companion,
 };
 
+/**
+ * am35xx_clk_find_idlest - return clock ACK info for AM35XX IPSS
+ * @clk: struct clk * being enabled
+ * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into
+ * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
+ * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
+ *
+ * The interface clocks on AM35xx IPSS reflects the clock idle status
+ * in the enable register itsel at a bit offset of 4 from the enable
+ * bit. A value of 1 indicates that clock is enabled.
+ */
+static void am35xx_clk_find_idlest(struct clk_hw_omap *clk,
+				   void __iomem **idlest_reg,
+				   u8 *idlest_bit,
+				   u8 *idlest_val)
+{
+	*idlest_reg = (__force void __iomem *)(clk->enable_reg);
+	*idlest_bit = clk->enable_bit + AM35XX_IPSS_ICK_EN_ACK_OFFSET;
+	*idlest_val = AM35XX_IPSS_CLK_IDLEST_VAL;
+}
+
+/**
+ * am35xx_clk_find_companion - find companion clock to @clk
+ * @clk: struct clk * to find the companion clock of
+ * @other_reg: void __iomem ** to return the companion clock CM_*CLKEN va in
+ * @other_bit: u8 ** to return the companion clock bit shift in
+ *
+ * Some clocks don't have companion clocks.  For example, modules with
+ * only an interface clock (such as HECC) don't have a companion
+ * clock.  Right now, this code relies on the hardware exporting a bit
+ * in the correct companion register that indicates that the
+ * nonexistent 'companion clock' is active.  Future patches will
+ * associate this type of code with per-module data structures to
+ * avoid this issue, and remove the casts.  No return value.
+ */
+static void am35xx_clk_find_companion(struct clk_hw_omap *clk,
+				      void __iomem **other_reg,
+				      u8 *other_bit)
+{
+	*other_reg = (__force void __iomem *)(clk->enable_reg);
+	if (clk->enable_bit & AM35XX_IPSS_ICK_MASK)
+		*other_bit = clk->enable_bit + AM35XX_IPSS_ICK_FCK_OFFSET;
+	else
+	*other_bit = clk->enable_bit - AM35XX_IPSS_ICK_FCK_OFFSET;
+}
+
+const struct clk_hw_omap_ops clkhwops_am35xx_ipss_module_wait = {
+	.find_idlest	= am35xx_clk_find_idlest,
+	.find_companion	= am35xx_clk_find_companion,
+};
+
+/**
+ * am35xx_clk_ipss_find_idlest - return CM_IDLEST info for IPSS
+ * @clk: struct clk * being enabled
+ * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into
+ * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
+ * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
+ *
+ * The IPSS target CM_IDLEST bit is at a different shift from the
+ * CM_{I,F}CLKEN bit.  Pass back the correct info via @idlest_reg
+ * and @idlest_bit.  No return value.
+ */
+static void am35xx_clk_ipss_find_idlest(struct clk_hw_omap *clk,
+					void __iomem **idlest_reg,
+					u8 *idlest_bit,
+					u8 *idlest_val)
+{
+	u32 r;
+
+	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
+	*idlest_reg = (__force void __iomem *)r;
+	*idlest_bit = AM35XX_ST_IPSS_SHIFT;
+	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
+}
+
+const struct clk_hw_omap_ops clkhwops_am35xx_ipss_wait = {
+	.allow_idle	= omap2_clkt_iclk_allow_idle,
+	.deny_idle	= omap2_clkt_iclk_deny_idle,
+	.find_idlest	= am35xx_clk_ipss_find_idlest,
+	.find_companion	= omap2_clk_dflt_find_companion,
+};
+
 static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "apb_pclk", "dummy_apb_pclk"),
 	DT_CLK(NULL, "omap_32k_fck", "omap_32k_fck"),

commit f2671d5c6cb4abe4636014cd66fd0eeb8190b2ca
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 3 17:28:12 2015 +0200

    clk: ti: omap34xx: move omap34xx clock type support code to clock driver
    
    With the legacy clock data gone, this is no longer needed under platform,
    so move it under the clock driver itself. Remove unnecessary declarations
    from the TI clock header also.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 5489ad8c07d4..58879f0b7949 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -28,6 +28,124 @@
  */
 #define DPLL5_FREQ_FOR_USBHOST		120000000
 
+#define OMAP3430ES2_ST_DSS_IDLE_SHIFT			1
+#define OMAP3430ES2_ST_HSOTGUSB_IDLE_SHIFT		5
+#define OMAP3430ES2_ST_SSI_IDLE_SHIFT			8
+
+#define OMAP34XX_CM_IDLEST_VAL				1
+
+/**
+ * omap3430es2_clk_ssi_find_idlest - return CM_IDLEST info for SSI
+ * @clk: struct clk * being enabled
+ * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into
+ * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
+ * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
+ *
+ * The OMAP3430ES2 SSI target CM_IDLEST bit is at a different shift
+ * from the CM_{I,F}CLKEN bit.  Pass back the correct info via
+ * @idlest_reg and @idlest_bit.  No return value.
+ */
+static void omap3430es2_clk_ssi_find_idlest(struct clk_hw_omap *clk,
+					    void __iomem **idlest_reg,
+					    u8 *idlest_bit,
+					    u8 *idlest_val)
+{
+	u32 r;
+
+	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
+	*idlest_reg = (__force void __iomem *)r;
+	*idlest_bit = OMAP3430ES2_ST_SSI_IDLE_SHIFT;
+	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
+}
+
+const struct clk_hw_omap_ops clkhwops_omap3430es2_ssi_wait = {
+	.find_idlest	= omap3430es2_clk_ssi_find_idlest,
+	.find_companion	= omap2_clk_dflt_find_companion,
+};
+
+const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_ssi_wait = {
+	.allow_idle	= omap2_clkt_iclk_allow_idle,
+	.deny_idle	= omap2_clkt_iclk_deny_idle,
+	.find_idlest	= omap3430es2_clk_ssi_find_idlest,
+	.find_companion	= omap2_clk_dflt_find_companion,
+};
+
+/**
+ * omap3430es2_clk_dss_usbhost_find_idlest - CM_IDLEST info for DSS, USBHOST
+ * @clk: struct clk * being enabled
+ * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into
+ * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
+ * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
+ *
+ * Some OMAP modules on OMAP3 ES2+ chips have both initiator and
+ * target IDLEST bits.  For our purposes, we are concerned with the
+ * target IDLEST bits, which exist at a different bit position than
+ * the *CLKEN bit position for these modules (DSS and USBHOST) (The
+ * default find_idlest code assumes that they are at the same
+ * position.)  No return value.
+ */
+static void omap3430es2_clk_dss_usbhost_find_idlest(struct clk_hw_omap *clk,
+						    void __iomem **idlest_reg,
+						    u8 *idlest_bit,
+						    u8 *idlest_val)
+{
+	u32 r;
+
+	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
+	*idlest_reg = (__force void __iomem *)r;
+	/* USBHOST_IDLE has same shift */
+	*idlest_bit = OMAP3430ES2_ST_DSS_IDLE_SHIFT;
+	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
+}
+
+const struct clk_hw_omap_ops clkhwops_omap3430es2_dss_usbhost_wait = {
+	.find_idlest	= omap3430es2_clk_dss_usbhost_find_idlest,
+	.find_companion	= omap2_clk_dflt_find_companion,
+};
+
+const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_dss_usbhost_wait = {
+	.allow_idle	= omap2_clkt_iclk_allow_idle,
+	.deny_idle	= omap2_clkt_iclk_deny_idle,
+	.find_idlest	= omap3430es2_clk_dss_usbhost_find_idlest,
+	.find_companion	= omap2_clk_dflt_find_companion,
+};
+
+/**
+ * omap3430es2_clk_hsotgusb_find_idlest - return CM_IDLEST info for HSOTGUSB
+ * @clk: struct clk * being enabled
+ * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into
+ * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
+ * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
+ *
+ * The OMAP3430ES2 HSOTGUSB target CM_IDLEST bit is at a different
+ * shift from the CM_{I,F}CLKEN bit.  Pass back the correct info via
+ * @idlest_reg and @idlest_bit.  No return value.
+ */
+static void omap3430es2_clk_hsotgusb_find_idlest(struct clk_hw_omap *clk,
+						 void __iomem **idlest_reg,
+						 u8 *idlest_bit,
+						 u8 *idlest_val)
+{
+	u32 r;
+
+	r = (((__force u32)clk->enable_reg & ~0xf0) | 0x20);
+	*idlest_reg = (__force void __iomem *)r;
+	*idlest_bit = OMAP3430ES2_ST_HSOTGUSB_IDLE_SHIFT;
+	*idlest_val = OMAP34XX_CM_IDLEST_VAL;
+}
+
+const struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_hsotgusb_wait = {
+	.allow_idle	= omap2_clkt_iclk_allow_idle,
+	.deny_idle	= omap2_clkt_iclk_deny_idle,
+	.find_idlest	= omap3430es2_clk_hsotgusb_find_idlest,
+	.find_companion	= omap2_clk_dflt_find_companion,
+};
+
+const struct clk_hw_omap_ops clkhwops_omap3430es2_hsotgusb_wait = {
+	.find_idlest	= omap3430es2_clk_hsotgusb_find_idlest,
+	.find_companion	= omap2_clk_dflt_find_companion,
+};
+
 static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "apb_pclk", "dummy_apb_pclk"),
 	DT_CLK(NULL, "omap_32k_fck", "omap_32k_fck"),

commit 0565fb168d63f89591ce7dcb85438cb19d939a92
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 3 13:27:48 2015 +0200

    clk: ti: dpll: move omap3 DPLL functionality to clock driver
    
    With the legacy clock support gone, OMAP3 generic DPLL code can now be
    moved over to the clock driver also. A few un-unused clkoutx2 functions
    are also removed at the same time.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index bb3b88359daf..5489ad8c07d4 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -21,6 +21,13 @@
 
 #include "clock.h"
 
+/*
+ * DPLL5_FREQ_FOR_USBHOST: USBHOST and USBTLL are the only clocks
+ * that are sourced by DPLL5, and both of these require this clock
+ * to be at 120 MHz for proper operation.
+ */
+#define DPLL5_FREQ_FOR_USBHOST		120000000
+
 static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "apb_pclk", "dummy_apb_pclk"),
 	DT_CLK(NULL, "omap_32k_fck", "omap_32k_fck"),
@@ -325,6 +332,30 @@ enum {
 	OMAP3_SOC_OMAP3630,
 };
 
+/**
+ * omap3_clk_lock_dpll5 - locks DPLL5
+ *
+ * Locks DPLL5 to a pre-defined frequency. This is required for proper
+ * operation of USB.
+ */
+void __init omap3_clk_lock_dpll5(void)
+{
+	struct clk *dpll5_clk;
+	struct clk *dpll5_m2_clk;
+
+	dpll5_clk = clk_get(NULL, "dpll5_ck");
+	clk_set_rate(dpll5_clk, DPLL5_FREQ_FOR_USBHOST);
+	clk_prepare_enable(dpll5_clk);
+
+	/* Program dpll5_m2_clk divider for no division */
+	dpll5_m2_clk = clk_get(NULL, "dpll5_m2_ck");
+	clk_prepare_enable(dpll5_m2_clk);
+	clk_set_rate(dpll5_m2_clk, DPLL5_FREQ_FOR_USBHOST);
+
+	clk_disable_unprepare(dpll5_m2_clk);
+	clk_disable_unprepare(dpll5_clk);
+}
+
 static int __init omap3xxx_dt_clk_init(int soc_type)
 {
 	if (soc_type == OMAP3_SOC_AM35XX || soc_type == OMAP3_SOC_OMAP3630 ||

commit a5aa8a603efa25dd41220bff990da025c93b632b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 3 10:51:01 2015 +0200

    clk: ti: move omap2_clk_enable_init_clocks under clock driver
    
    This is no longer used outside clock driver, so move it under the driver
    and remove the export for it from the global header file.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 757636d166cf..bb3b88359daf 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -19,6 +19,7 @@
 #include <linux/clk-provider.h>
 #include <linux/clk/ti.h>
 
+#include "clock.h"
 
 static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "apb_pclk", "dummy_apb_pclk"),

commit f757d1b047dfe704d459746c289f27934de6f91e
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Mon Mar 16 12:40:57 2015 +0200

    clk: ti: clk-3xxx: Correct McBSP related DT clock definitions
    
    In DT boot we do not have devices named as omap-mcbsp.X.
    Correct the McBSP2/4 ick mapping (they were 2->4 and 4->2).
    Collect the McBSP clock definition in one location at the same time.
    
    Fixes the following warning on boot:
    [    0.307739] omap_hwmod: mcbsp2: _wait_target_ready failed: -16
    [    0.307769] omap_hwmod: mcbsp2: cannot be enabled for reset (3)
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 383a06e49b09..757636d166cf 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -34,7 +34,6 @@ static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "omap_96m_alwon_fck", "omap_96m_alwon_fck"),
 	DT_CLK("etb", "emu_core_alwon_ck", "emu_core_alwon_ck"),
 	DT_CLK(NULL, "sys_altclk", "sys_altclk"),
-	DT_CLK(NULL, "mcbsp_clks", "mcbsp_clks"),
 	DT_CLK(NULL, "sys_clkout1", "sys_clkout1"),
 	DT_CLK(NULL, "dpll1_ck", "dpll1_ck"),
 	DT_CLK(NULL, "dpll1_x2_ck", "dpll1_x2_ck"),
@@ -82,8 +81,6 @@ static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "i2c3_fck", "i2c3_fck"),
 	DT_CLK(NULL, "i2c2_fck", "i2c2_fck"),
 	DT_CLK(NULL, "i2c1_fck", "i2c1_fck"),
-	DT_CLK(NULL, "mcbsp5_fck", "mcbsp5_fck"),
-	DT_CLK(NULL, "mcbsp1_fck", "mcbsp1_fck"),
 	DT_CLK(NULL, "core_48m_fck", "core_48m_fck"),
 	DT_CLK(NULL, "mcspi4_fck", "mcspi4_fck"),
 	DT_CLK(NULL, "mcspi3_fck", "mcspi3_fck"),
@@ -122,10 +119,6 @@ static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "uart1_ick", "uart1_ick"),
 	DT_CLK(NULL, "gpt11_ick", "gpt11_ick"),
 	DT_CLK(NULL, "gpt10_ick", "gpt10_ick"),
-	DT_CLK("omap-mcbsp.5", "ick", "mcbsp5_ick"),
-	DT_CLK("omap-mcbsp.1", "ick", "mcbsp1_ick"),
-	DT_CLK(NULL, "mcbsp5_ick", "mcbsp5_ick"),
-	DT_CLK(NULL, "mcbsp1_ick", "mcbsp1_ick"),
 	DT_CLK(NULL, "omapctrl_ick", "omapctrl_ick"),
 	DT_CLK(NULL, "dss_tv_fck", "dss_tv_fck"),
 	DT_CLK(NULL, "dss_96m_fck", "dss_96m_fck"),
@@ -179,15 +172,17 @@ static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "gpt4_ick", "gpt4_ick"),
 	DT_CLK(NULL, "gpt3_ick", "gpt3_ick"),
 	DT_CLK(NULL, "gpt2_ick", "gpt2_ick"),
-	DT_CLK("omap-mcbsp.2", "ick", "mcbsp2_ick"),
-	DT_CLK("omap-mcbsp.3", "ick", "mcbsp3_ick"),
-	DT_CLK("omap-mcbsp.4", "ick", "mcbsp4_ick"),
-	DT_CLK(NULL, "mcbsp4_ick", "mcbsp2_ick"),
+	DT_CLK(NULL, "mcbsp_clks", "mcbsp_clks"),
+	DT_CLK(NULL, "mcbsp1_ick", "mcbsp1_ick"),
+	DT_CLK(NULL, "mcbsp2_ick", "mcbsp2_ick"),
 	DT_CLK(NULL, "mcbsp3_ick", "mcbsp3_ick"),
-	DT_CLK(NULL, "mcbsp2_ick", "mcbsp4_ick"),
+	DT_CLK(NULL, "mcbsp4_ick", "mcbsp4_ick"),
+	DT_CLK(NULL, "mcbsp5_ick", "mcbsp5_ick"),
+	DT_CLK(NULL, "mcbsp1_fck", "mcbsp1_fck"),
 	DT_CLK(NULL, "mcbsp2_fck", "mcbsp2_fck"),
 	DT_CLK(NULL, "mcbsp3_fck", "mcbsp3_fck"),
 	DT_CLK(NULL, "mcbsp4_fck", "mcbsp4_fck"),
+	DT_CLK(NULL, "mcbsp5_fck", "mcbsp5_fck"),
 	DT_CLK("etb", "emu_src_ck", "emu_src_ck"),
 	DT_CLK(NULL, "emu_src_ck", "emu_src_ck"),
 	DT_CLK(NULL, "pclk_fck", "pclk_fck"),

commit 1a34275d347fd4602443417d11031b77d368cae9
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 13 14:51:28 2015 -0800

    clk: ti: Initialize clocks for dm816x
    
    The clocks on ti81xx are not compatible with omap3. On dm816x
    the clock source is a FAPLL (Flying Adder PLL), and on dm814x
    there seems to be an APLL (All Digital PLL).
    
    Let's fix up things for dm816x in preparation for adding the
    FAPLL support. As we already have a dummy ti81xx_dt_clk_init()
    in place, let's use that for now to avoid adding a dependency
    to the omap patches.
    
    Later on if somebody adds dm814x support we can split the
    ti81xx_dt_clk_init() clock init function as needed.
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index 0d1750a8aea4..383a06e49b09 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -327,7 +327,6 @@ enum {
 	OMAP3_SOC_OMAP3430_ES1,
 	OMAP3_SOC_OMAP3430_ES2_PLUS,
 	OMAP3_SOC_OMAP3630,
-	OMAP3_SOC_TI81XX,
 };
 
 static int __init omap3xxx_dt_clk_init(int soc_type)
@@ -370,7 +369,7 @@ static int __init omap3xxx_dt_clk_init(int soc_type)
 		(clk_get_rate(clk_get_sys(NULL, "core_ck")) / 1000000),
 		(clk_get_rate(clk_get_sys(NULL, "arm_fck")) / 1000000));
 
-	if (soc_type != OMAP3_SOC_TI81XX && soc_type != OMAP3_SOC_OMAP3430_ES1)
+	if (soc_type != OMAP3_SOC_OMAP3430_ES1)
 		omap3_clk_lock_dpll5();
 
 	return 0;
@@ -390,8 +389,3 @@ int __init am35xx_dt_clk_init(void)
 {
 	return omap3xxx_dt_clk_init(OMAP3_SOC_AM35XX);
 }
-
-int __init ti81xx_dt_clk_init(void)
-{
-	return omap3xxx_dt_clk_init(OMAP3_SOC_TI81XX);
-}

commit 3aca446acf32243029f5c83810b50aad3c32b6bf
Author: Roger Quadros <rogerq@ti.com>
Date:   Thu Feb 27 16:18:23 2014 +0200

    mfd: omap-usb-host: Get clocks based on hardware revision
    
    Not all revisions have all the clocks so get the necessary clocks
    based on hardware revision.
    
    This should avoid un-necessary clk_get failure messages that were
    observed earlier.
    
    Also remove the dummy USB host clocks from the OMAP3 clock data.
    These are no longer expected by the driver.
    
    Acked-by: Mike Turquette <mturquette@linaro.org> [OMAP3 CLK data]
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
index d3230234f07b..0d1750a8aea4 100644
--- a/drivers/clk/ti/clk-3xxx.c
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -130,10 +130,6 @@ static struct ti_dt_clk omap3xxx_clks[] = {
 	DT_CLK(NULL, "dss_tv_fck", "dss_tv_fck"),
 	DT_CLK(NULL, "dss_96m_fck", "dss_96m_fck"),
 	DT_CLK(NULL, "dss2_alwon_fck", "dss2_alwon_fck"),
-	DT_CLK(NULL, "utmi_p1_gfclk", "dummy_ck"),
-	DT_CLK(NULL, "utmi_p2_gfclk", "dummy_ck"),
-	DT_CLK(NULL, "xclk60mhsp1_ck", "dummy_ck"),
-	DT_CLK(NULL, "xclk60mhsp2_ck", "dummy_ck"),
 	DT_CLK(NULL, "init_60m_fclk", "dummy_ck"),
 	DT_CLK(NULL, "gpt1_fck", "gpt1_fck"),
 	DT_CLK(NULL, "aes2_ick", "aes2_ick"),

commit aafd900cab87d339dc3004c241eebc854005124b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 2 14:04:19 2013 +0300

    CLK: TI: add omap3 clock init file
    
    clk-3xxx.c now contains the clock init functionality for omap3, including
    DT clock registration and adding of static clkdev entries.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/clk-3xxx.c b/drivers/clk/ti/clk-3xxx.c
new file mode 100644
index 000000000000..d3230234f07b
--- /dev/null
+++ b/drivers/clk/ti/clk-3xxx.c
@@ -0,0 +1,401 @@
+/*
+ * OMAP3 Clock init
+ *
+ * Copyright (C) 2013 Texas Instruments, Inc
+ *     Tero Kristo (t-kristo@ti.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/clk-provider.h>
+#include <linux/clk/ti.h>
+
+
+static struct ti_dt_clk omap3xxx_clks[] = {
+	DT_CLK(NULL, "apb_pclk", "dummy_apb_pclk"),
+	DT_CLK(NULL, "omap_32k_fck", "omap_32k_fck"),
+	DT_CLK(NULL, "virt_12m_ck", "virt_12m_ck"),
+	DT_CLK(NULL, "virt_13m_ck", "virt_13m_ck"),
+	DT_CLK(NULL, "virt_19200000_ck", "virt_19200000_ck"),
+	DT_CLK(NULL, "virt_26000000_ck", "virt_26000000_ck"),
+	DT_CLK(NULL, "virt_38_4m_ck", "virt_38_4m_ck"),
+	DT_CLK(NULL, "osc_sys_ck", "osc_sys_ck"),
+	DT_CLK("twl", "fck", "osc_sys_ck"),
+	DT_CLK(NULL, "sys_ck", "sys_ck"),
+	DT_CLK(NULL, "omap_96m_alwon_fck", "omap_96m_alwon_fck"),
+	DT_CLK("etb", "emu_core_alwon_ck", "emu_core_alwon_ck"),
+	DT_CLK(NULL, "sys_altclk", "sys_altclk"),
+	DT_CLK(NULL, "mcbsp_clks", "mcbsp_clks"),
+	DT_CLK(NULL, "sys_clkout1", "sys_clkout1"),
+	DT_CLK(NULL, "dpll1_ck", "dpll1_ck"),
+	DT_CLK(NULL, "dpll1_x2_ck", "dpll1_x2_ck"),
+	DT_CLK(NULL, "dpll1_x2m2_ck", "dpll1_x2m2_ck"),
+	DT_CLK(NULL, "dpll3_ck", "dpll3_ck"),
+	DT_CLK(NULL, "core_ck", "core_ck"),
+	DT_CLK(NULL, "dpll3_x2_ck", "dpll3_x2_ck"),
+	DT_CLK(NULL, "dpll3_m2_ck", "dpll3_m2_ck"),
+	DT_CLK(NULL, "dpll3_m2x2_ck", "dpll3_m2x2_ck"),
+	DT_CLK(NULL, "dpll3_m3_ck", "dpll3_m3_ck"),
+	DT_CLK(NULL, "dpll3_m3x2_ck", "dpll3_m3x2_ck"),
+	DT_CLK(NULL, "dpll4_ck", "dpll4_ck"),
+	DT_CLK(NULL, "dpll4_x2_ck", "dpll4_x2_ck"),
+	DT_CLK(NULL, "omap_96m_fck", "omap_96m_fck"),
+	DT_CLK(NULL, "cm_96m_fck", "cm_96m_fck"),
+	DT_CLK(NULL, "omap_54m_fck", "omap_54m_fck"),
+	DT_CLK(NULL, "omap_48m_fck", "omap_48m_fck"),
+	DT_CLK(NULL, "omap_12m_fck", "omap_12m_fck"),
+	DT_CLK(NULL, "dpll4_m2_ck", "dpll4_m2_ck"),
+	DT_CLK(NULL, "dpll4_m2x2_ck", "dpll4_m2x2_ck"),
+	DT_CLK(NULL, "dpll4_m3_ck", "dpll4_m3_ck"),
+	DT_CLK(NULL, "dpll4_m3x2_ck", "dpll4_m3x2_ck"),
+	DT_CLK(NULL, "dpll4_m4_ck", "dpll4_m4_ck"),
+	DT_CLK(NULL, "dpll4_m4x2_ck", "dpll4_m4x2_ck"),
+	DT_CLK(NULL, "dpll4_m5_ck", "dpll4_m5_ck"),
+	DT_CLK(NULL, "dpll4_m5x2_ck", "dpll4_m5x2_ck"),
+	DT_CLK(NULL, "dpll4_m6_ck", "dpll4_m6_ck"),
+	DT_CLK(NULL, "dpll4_m6x2_ck", "dpll4_m6x2_ck"),
+	DT_CLK("etb", "emu_per_alwon_ck", "emu_per_alwon_ck"),
+	DT_CLK(NULL, "clkout2_src_ck", "clkout2_src_ck"),
+	DT_CLK(NULL, "sys_clkout2", "sys_clkout2"),
+	DT_CLK(NULL, "corex2_fck", "corex2_fck"),
+	DT_CLK(NULL, "dpll1_fck", "dpll1_fck"),
+	DT_CLK(NULL, "mpu_ck", "mpu_ck"),
+	DT_CLK(NULL, "arm_fck", "arm_fck"),
+	DT_CLK("etb", "emu_mpu_alwon_ck", "emu_mpu_alwon_ck"),
+	DT_CLK(NULL, "l3_ick", "l3_ick"),
+	DT_CLK(NULL, "l4_ick", "l4_ick"),
+	DT_CLK(NULL, "rm_ick", "rm_ick"),
+	DT_CLK(NULL, "gpt10_fck", "gpt10_fck"),
+	DT_CLK(NULL, "gpt11_fck", "gpt11_fck"),
+	DT_CLK(NULL, "core_96m_fck", "core_96m_fck"),
+	DT_CLK(NULL, "mmchs2_fck", "mmchs2_fck"),
+	DT_CLK(NULL, "mmchs1_fck", "mmchs1_fck"),
+	DT_CLK(NULL, "i2c3_fck", "i2c3_fck"),
+	DT_CLK(NULL, "i2c2_fck", "i2c2_fck"),
+	DT_CLK(NULL, "i2c1_fck", "i2c1_fck"),
+	DT_CLK(NULL, "mcbsp5_fck", "mcbsp5_fck"),
+	DT_CLK(NULL, "mcbsp1_fck", "mcbsp1_fck"),
+	DT_CLK(NULL, "core_48m_fck", "core_48m_fck"),
+	DT_CLK(NULL, "mcspi4_fck", "mcspi4_fck"),
+	DT_CLK(NULL, "mcspi3_fck", "mcspi3_fck"),
+	DT_CLK(NULL, "mcspi2_fck", "mcspi2_fck"),
+	DT_CLK(NULL, "mcspi1_fck", "mcspi1_fck"),
+	DT_CLK(NULL, "uart2_fck", "uart2_fck"),
+	DT_CLK(NULL, "uart1_fck", "uart1_fck"),
+	DT_CLK(NULL, "core_12m_fck", "core_12m_fck"),
+	DT_CLK("omap_hdq.0", "fck", "hdq_fck"),
+	DT_CLK(NULL, "hdq_fck", "hdq_fck"),
+	DT_CLK(NULL, "core_l3_ick", "core_l3_ick"),
+	DT_CLK(NULL, "sdrc_ick", "sdrc_ick"),
+	DT_CLK(NULL, "gpmc_fck", "gpmc_fck"),
+	DT_CLK(NULL, "core_l4_ick", "core_l4_ick"),
+	DT_CLK("omap_hsmmc.1", "ick", "mmchs2_ick"),
+	DT_CLK("omap_hsmmc.0", "ick", "mmchs1_ick"),
+	DT_CLK(NULL, "mmchs2_ick", "mmchs2_ick"),
+	DT_CLK(NULL, "mmchs1_ick", "mmchs1_ick"),
+	DT_CLK("omap_hdq.0", "ick", "hdq_ick"),
+	DT_CLK(NULL, "hdq_ick", "hdq_ick"),
+	DT_CLK("omap2_mcspi.4", "ick", "mcspi4_ick"),
+	DT_CLK("omap2_mcspi.3", "ick", "mcspi3_ick"),
+	DT_CLK("omap2_mcspi.2", "ick", "mcspi2_ick"),
+	DT_CLK("omap2_mcspi.1", "ick", "mcspi1_ick"),
+	DT_CLK(NULL, "mcspi4_ick", "mcspi4_ick"),
+	DT_CLK(NULL, "mcspi3_ick", "mcspi3_ick"),
+	DT_CLK(NULL, "mcspi2_ick", "mcspi2_ick"),
+	DT_CLK(NULL, "mcspi1_ick", "mcspi1_ick"),
+	DT_CLK("omap_i2c.3", "ick", "i2c3_ick"),
+	DT_CLK("omap_i2c.2", "ick", "i2c2_ick"),
+	DT_CLK("omap_i2c.1", "ick", "i2c1_ick"),
+	DT_CLK(NULL, "i2c3_ick", "i2c3_ick"),
+	DT_CLK(NULL, "i2c2_ick", "i2c2_ick"),
+	DT_CLK(NULL, "i2c1_ick", "i2c1_ick"),
+	DT_CLK(NULL, "uart2_ick", "uart2_ick"),
+	DT_CLK(NULL, "uart1_ick", "uart1_ick"),
+	DT_CLK(NULL, "gpt11_ick", "gpt11_ick"),
+	DT_CLK(NULL, "gpt10_ick", "gpt10_ick"),
+	DT_CLK("omap-mcbsp.5", "ick", "mcbsp5_ick"),
+	DT_CLK("omap-mcbsp.1", "ick", "mcbsp1_ick"),
+	DT_CLK(NULL, "mcbsp5_ick", "mcbsp5_ick"),
+	DT_CLK(NULL, "mcbsp1_ick", "mcbsp1_ick"),
+	DT_CLK(NULL, "omapctrl_ick", "omapctrl_ick"),
+	DT_CLK(NULL, "dss_tv_fck", "dss_tv_fck"),
+	DT_CLK(NULL, "dss_96m_fck", "dss_96m_fck"),
+	DT_CLK(NULL, "dss2_alwon_fck", "dss2_alwon_fck"),
+	DT_CLK(NULL, "utmi_p1_gfclk", "dummy_ck"),
+	DT_CLK(NULL, "utmi_p2_gfclk", "dummy_ck"),
+	DT_CLK(NULL, "xclk60mhsp1_ck", "dummy_ck"),
+	DT_CLK(NULL, "xclk60mhsp2_ck", "dummy_ck"),
+	DT_CLK(NULL, "init_60m_fclk", "dummy_ck"),
+	DT_CLK(NULL, "gpt1_fck", "gpt1_fck"),
+	DT_CLK(NULL, "aes2_ick", "aes2_ick"),
+	DT_CLK(NULL, "wkup_32k_fck", "wkup_32k_fck"),
+	DT_CLK(NULL, "gpio1_dbck", "gpio1_dbck"),
+	DT_CLK(NULL, "sha12_ick", "sha12_ick"),
+	DT_CLK(NULL, "wdt2_fck", "wdt2_fck"),
+	DT_CLK("omap_wdt", "ick", "wdt2_ick"),
+	DT_CLK(NULL, "wdt2_ick", "wdt2_ick"),
+	DT_CLK(NULL, "wdt1_ick", "wdt1_ick"),
+	DT_CLK(NULL, "gpio1_ick", "gpio1_ick"),
+	DT_CLK(NULL, "omap_32ksync_ick", "omap_32ksync_ick"),
+	DT_CLK(NULL, "gpt12_ick", "gpt12_ick"),
+	DT_CLK(NULL, "gpt1_ick", "gpt1_ick"),
+	DT_CLK(NULL, "per_96m_fck", "per_96m_fck"),
+	DT_CLK(NULL, "per_48m_fck", "per_48m_fck"),
+	DT_CLK(NULL, "uart3_fck", "uart3_fck"),
+	DT_CLK(NULL, "gpt2_fck", "gpt2_fck"),
+	DT_CLK(NULL, "gpt3_fck", "gpt3_fck"),
+	DT_CLK(NULL, "gpt4_fck", "gpt4_fck"),
+	DT_CLK(NULL, "gpt5_fck", "gpt5_fck"),
+	DT_CLK(NULL, "gpt6_fck", "gpt6_fck"),
+	DT_CLK(NULL, "gpt7_fck", "gpt7_fck"),
+	DT_CLK(NULL, "gpt8_fck", "gpt8_fck"),
+	DT_CLK(NULL, "gpt9_fck", "gpt9_fck"),
+	DT_CLK(NULL, "per_32k_alwon_fck", "per_32k_alwon_fck"),
+	DT_CLK(NULL, "gpio6_dbck", "gpio6_dbck"),
+	DT_CLK(NULL, "gpio5_dbck", "gpio5_dbck"),
+	DT_CLK(NULL, "gpio4_dbck", "gpio4_dbck"),
+	DT_CLK(NULL, "gpio3_dbck", "gpio3_dbck"),
+	DT_CLK(NULL, "gpio2_dbck", "gpio2_dbck"),
+	DT_CLK(NULL, "wdt3_fck", "wdt3_fck"),
+	DT_CLK(NULL, "per_l4_ick", "per_l4_ick"),
+	DT_CLK(NULL, "gpio6_ick", "gpio6_ick"),
+	DT_CLK(NULL, "gpio5_ick", "gpio5_ick"),
+	DT_CLK(NULL, "gpio4_ick", "gpio4_ick"),
+	DT_CLK(NULL, "gpio3_ick", "gpio3_ick"),
+	DT_CLK(NULL, "gpio2_ick", "gpio2_ick"),
+	DT_CLK(NULL, "wdt3_ick", "wdt3_ick"),
+	DT_CLK(NULL, "uart3_ick", "uart3_ick"),
+	DT_CLK(NULL, "uart4_ick", "uart4_ick"),
+	DT_CLK(NULL, "gpt9_ick", "gpt9_ick"),
+	DT_CLK(NULL, "gpt8_ick", "gpt8_ick"),
+	DT_CLK(NULL, "gpt7_ick", "gpt7_ick"),
+	DT_CLK(NULL, "gpt6_ick", "gpt6_ick"),
+	DT_CLK(NULL, "gpt5_ick", "gpt5_ick"),
+	DT_CLK(NULL, "gpt4_ick", "gpt4_ick"),
+	DT_CLK(NULL, "gpt3_ick", "gpt3_ick"),
+	DT_CLK(NULL, "gpt2_ick", "gpt2_ick"),
+	DT_CLK("omap-mcbsp.2", "ick", "mcbsp2_ick"),
+	DT_CLK("omap-mcbsp.3", "ick", "mcbsp3_ick"),
+	DT_CLK("omap-mcbsp.4", "ick", "mcbsp4_ick"),
+	DT_CLK(NULL, "mcbsp4_ick", "mcbsp2_ick"),
+	DT_CLK(NULL, "mcbsp3_ick", "mcbsp3_ick"),
+	DT_CLK(NULL, "mcbsp2_ick", "mcbsp4_ick"),
+	DT_CLK(NULL, "mcbsp2_fck", "mcbsp2_fck"),
+	DT_CLK(NULL, "mcbsp3_fck", "mcbsp3_fck"),
+	DT_CLK(NULL, "mcbsp4_fck", "mcbsp4_fck"),
+	DT_CLK("etb", "emu_src_ck", "emu_src_ck"),
+	DT_CLK(NULL, "emu_src_ck", "emu_src_ck"),
+	DT_CLK(NULL, "pclk_fck", "pclk_fck"),
+	DT_CLK(NULL, "pclkx2_fck", "pclkx2_fck"),
+	DT_CLK(NULL, "atclk_fck", "atclk_fck"),
+	DT_CLK(NULL, "traceclk_src_fck", "traceclk_src_fck"),
+	DT_CLK(NULL, "traceclk_fck", "traceclk_fck"),
+	DT_CLK(NULL, "secure_32k_fck", "secure_32k_fck"),
+	DT_CLK(NULL, "gpt12_fck", "gpt12_fck"),
+	DT_CLK(NULL, "wdt1_fck", "wdt1_fck"),
+	DT_CLK(NULL, "timer_32k_ck", "omap_32k_fck"),
+	DT_CLK(NULL, "timer_sys_ck", "sys_ck"),
+	DT_CLK(NULL, "cpufreq_ck", "dpll1_ck"),
+	{ .node_name = NULL },
+};
+
+static struct ti_dt_clk omap34xx_omap36xx_clks[] = {
+	DT_CLK(NULL, "aes1_ick", "aes1_ick"),
+	DT_CLK("omap_rng", "ick", "rng_ick"),
+	DT_CLK("omap3-rom-rng", "ick", "rng_ick"),
+	DT_CLK(NULL, "sha11_ick", "sha11_ick"),
+	DT_CLK(NULL, "des1_ick", "des1_ick"),
+	DT_CLK(NULL, "cam_mclk", "cam_mclk"),
+	DT_CLK(NULL, "cam_ick", "cam_ick"),
+	DT_CLK(NULL, "csi2_96m_fck", "csi2_96m_fck"),
+	DT_CLK(NULL, "security_l3_ick", "security_l3_ick"),
+	DT_CLK(NULL, "pka_ick", "pka_ick"),
+	DT_CLK(NULL, "icr_ick", "icr_ick"),
+	DT_CLK("omap-aes", "ick", "aes2_ick"),
+	DT_CLK("omap-sham", "ick", "sha12_ick"),
+	DT_CLK(NULL, "des2_ick", "des2_ick"),
+	DT_CLK(NULL, "mspro_ick", "mspro_ick"),
+	DT_CLK(NULL, "mailboxes_ick", "mailboxes_ick"),
+	DT_CLK(NULL, "ssi_l4_ick", "ssi_l4_ick"),
+	DT_CLK(NULL, "sr1_fck", "sr1_fck"),
+	DT_CLK(NULL, "sr2_fck", "sr2_fck"),
+	DT_CLK(NULL, "sr_l4_ick", "sr_l4_ick"),
+	DT_CLK(NULL, "security_l4_ick2", "security_l4_ick2"),
+	DT_CLK(NULL, "wkup_l4_ick", "wkup_l4_ick"),
+	DT_CLK(NULL, "dpll2_fck", "dpll2_fck"),
+	DT_CLK(NULL, "iva2_ck", "iva2_ck"),
+	DT_CLK(NULL, "modem_fck", "modem_fck"),
+	DT_CLK(NULL, "sad2d_ick", "sad2d_ick"),
+	DT_CLK(NULL, "mad2d_ick", "mad2d_ick"),
+	DT_CLK(NULL, "mspro_fck", "mspro_fck"),
+	DT_CLK(NULL, "dpll2_ck", "dpll2_ck"),
+	DT_CLK(NULL, "dpll2_m2_ck", "dpll2_m2_ck"),
+	{ .node_name = NULL },
+};
+
+static struct ti_dt_clk omap36xx_omap3430es2plus_clks[] = {
+	DT_CLK(NULL, "ssi_ssr_fck", "ssi_ssr_fck_3430es2"),
+	DT_CLK(NULL, "ssi_sst_fck", "ssi_sst_fck_3430es2"),
+	DT_CLK("musb-omap2430", "ick", "hsotgusb_ick_3430es2"),
+	DT_CLK(NULL, "hsotgusb_ick", "hsotgusb_ick_3430es2"),
+	DT_CLK(NULL, "ssi_ick", "ssi_ick_3430es2"),
+	DT_CLK(NULL, "usim_fck", "usim_fck"),
+	DT_CLK(NULL, "usim_ick", "usim_ick"),
+	{ .node_name = NULL },
+};
+
+static struct ti_dt_clk omap3430es1_clks[] = {
+	DT_CLK(NULL, "gfx_l3_ck", "gfx_l3_ck"),
+	DT_CLK(NULL, "gfx_l3_fck", "gfx_l3_fck"),
+	DT_CLK(NULL, "gfx_l3_ick", "gfx_l3_ick"),
+	DT_CLK(NULL, "gfx_cg1_ck", "gfx_cg1_ck"),
+	DT_CLK(NULL, "gfx_cg2_ck", "gfx_cg2_ck"),
+	DT_CLK(NULL, "d2d_26m_fck", "d2d_26m_fck"),
+	DT_CLK(NULL, "fshostusb_fck", "fshostusb_fck"),
+	DT_CLK(NULL, "ssi_ssr_fck", "ssi_ssr_fck_3430es1"),
+	DT_CLK(NULL, "ssi_sst_fck", "ssi_sst_fck_3430es1"),
+	DT_CLK("musb-omap2430", "ick", "hsotgusb_ick_3430es1"),
+	DT_CLK(NULL, "hsotgusb_ick", "hsotgusb_ick_3430es1"),
+	DT_CLK(NULL, "fac_ick", "fac_ick"),
+	DT_CLK(NULL, "ssi_ick", "ssi_ick_3430es1"),
+	DT_CLK(NULL, "usb_l4_ick", "usb_l4_ick"),
+	DT_CLK(NULL, "dss1_alwon_fck", "dss1_alwon_fck_3430es1"),
+	DT_CLK("omapdss_dss", "ick", "dss_ick_3430es1"),
+	DT_CLK(NULL, "dss_ick", "dss_ick_3430es1"),
+	{ .node_name = NULL },
+};
+
+static struct ti_dt_clk omap36xx_am35xx_omap3430es2plus_clks[] = {
+	DT_CLK(NULL, "virt_16_8m_ck", "virt_16_8m_ck"),
+	DT_CLK(NULL, "dpll5_ck", "dpll5_ck"),
+	DT_CLK(NULL, "dpll5_m2_ck", "dpll5_m2_ck"),
+	DT_CLK(NULL, "sgx_fck", "sgx_fck"),
+	DT_CLK(NULL, "sgx_ick", "sgx_ick"),
+	DT_CLK(NULL, "cpefuse_fck", "cpefuse_fck"),
+	DT_CLK(NULL, "ts_fck", "ts_fck"),
+	DT_CLK(NULL, "usbtll_fck", "usbtll_fck"),
+	DT_CLK(NULL, "usbtll_ick", "usbtll_ick"),
+	DT_CLK("omap_hsmmc.2", "ick", "mmchs3_ick"),
+	DT_CLK(NULL, "mmchs3_ick", "mmchs3_ick"),
+	DT_CLK(NULL, "mmchs3_fck", "mmchs3_fck"),
+	DT_CLK(NULL, "dss1_alwon_fck", "dss1_alwon_fck_3430es2"),
+	DT_CLK("omapdss_dss", "ick", "dss_ick_3430es2"),
+	DT_CLK(NULL, "dss_ick", "dss_ick_3430es2"),
+	DT_CLK(NULL, "usbhost_120m_fck", "usbhost_120m_fck"),
+	DT_CLK(NULL, "usbhost_48m_fck", "usbhost_48m_fck"),
+	DT_CLK(NULL, "usbhost_ick", "usbhost_ick"),
+	{ .node_name = NULL },
+};
+
+static struct ti_dt_clk am35xx_clks[] = {
+	DT_CLK(NULL, "ipss_ick", "ipss_ick"),
+	DT_CLK(NULL, "rmii_ck", "rmii_ck"),
+	DT_CLK(NULL, "pclk_ck", "pclk_ck"),
+	DT_CLK(NULL, "emac_ick", "emac_ick"),
+	DT_CLK(NULL, "emac_fck", "emac_fck"),
+	DT_CLK("davinci_emac.0", NULL, "emac_ick"),
+	DT_CLK("davinci_mdio.0", NULL, "emac_fck"),
+	DT_CLK("vpfe-capture", "master", "vpfe_ick"),
+	DT_CLK("vpfe-capture", "slave", "vpfe_fck"),
+	DT_CLK(NULL, "hsotgusb_ick", "hsotgusb_ick_am35xx"),
+	DT_CLK(NULL, "hsotgusb_fck", "hsotgusb_fck_am35xx"),
+	DT_CLK(NULL, "hecc_ck", "hecc_ck"),
+	DT_CLK(NULL, "uart4_ick", "uart4_ick_am35xx"),
+	DT_CLK(NULL, "uart4_fck", "uart4_fck_am35xx"),
+	{ .node_name = NULL },
+};
+
+static struct ti_dt_clk omap36xx_clks[] = {
+	DT_CLK(NULL, "omap_192m_alwon_fck", "omap_192m_alwon_fck"),
+	DT_CLK(NULL, "uart4_fck", "uart4_fck"),
+	{ .node_name = NULL },
+};
+
+static const char *enable_init_clks[] = {
+	"sdrc_ick",
+	"gpmc_fck",
+	"omapctrl_ick",
+};
+
+enum {
+	OMAP3_SOC_AM35XX,
+	OMAP3_SOC_OMAP3430_ES1,
+	OMAP3_SOC_OMAP3430_ES2_PLUS,
+	OMAP3_SOC_OMAP3630,
+	OMAP3_SOC_TI81XX,
+};
+
+static int __init omap3xxx_dt_clk_init(int soc_type)
+{
+	if (soc_type == OMAP3_SOC_AM35XX || soc_type == OMAP3_SOC_OMAP3630 ||
+	    soc_type == OMAP3_SOC_OMAP3430_ES1 ||
+	    soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS)
+		ti_dt_clocks_register(omap3xxx_clks);
+
+	if (soc_type == OMAP3_SOC_AM35XX)
+		ti_dt_clocks_register(am35xx_clks);
+
+	if (soc_type == OMAP3_SOC_OMAP3630 || soc_type == OMAP3_SOC_AM35XX ||
+	    soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS)
+		ti_dt_clocks_register(omap36xx_am35xx_omap3430es2plus_clks);
+
+	if (soc_type == OMAP3_SOC_OMAP3430_ES1)
+		ti_dt_clocks_register(omap3430es1_clks);
+
+	if (soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS ||
+	    soc_type == OMAP3_SOC_OMAP3630)
+		ti_dt_clocks_register(omap36xx_omap3430es2plus_clks);
+
+	if (soc_type == OMAP3_SOC_OMAP3430_ES1 ||
+	    soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS ||
+	    soc_type == OMAP3_SOC_OMAP3630)
+		ti_dt_clocks_register(omap34xx_omap36xx_clks);
+
+	if (soc_type == OMAP3_SOC_OMAP3630)
+		ti_dt_clocks_register(omap36xx_clks);
+
+	omap2_clk_disable_autoidle_all();
+
+	omap2_clk_enable_init_clocks(enable_init_clks,
+				     ARRAY_SIZE(enable_init_clks));
+
+	pr_info("Clocking rate (Crystal/Core/MPU): %ld.%01ld/%ld/%ld MHz\n",
+		(clk_get_rate(clk_get_sys(NULL, "osc_sys_ck")) / 1000000),
+		(clk_get_rate(clk_get_sys(NULL, "osc_sys_ck")) / 100000) % 10,
+		(clk_get_rate(clk_get_sys(NULL, "core_ck")) / 1000000),
+		(clk_get_rate(clk_get_sys(NULL, "arm_fck")) / 1000000));
+
+	if (soc_type != OMAP3_SOC_TI81XX && soc_type != OMAP3_SOC_OMAP3430_ES1)
+		omap3_clk_lock_dpll5();
+
+	return 0;
+}
+
+int __init omap3430_dt_clk_init(void)
+{
+	return omap3xxx_dt_clk_init(OMAP3_SOC_OMAP3430_ES2_PLUS);
+}
+
+int __init omap3630_dt_clk_init(void)
+{
+	return omap3xxx_dt_clk_init(OMAP3_SOC_OMAP3630);
+}
+
+int __init am35xx_dt_clk_init(void)
+{
+	return omap3xxx_dt_clk_init(OMAP3_SOC_AM35XX);
+}
+
+int __init ti81xx_dt_clk_init(void)
+{
+	return omap3xxx_dt_clk_init(OMAP3_SOC_TI81XX);
+}
