commit c7c1cbbc9217ebb5601b88d138d4a5358548de9d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Apr 29 16:13:39 2020 +0300

    clk: ti: composite: fix memory leak
    
    The parent_names is never released for a component clock definition,
    causing some memory leak. Fix by releasing it once it is no longer
    needed.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Link: https://lkml.kernel.org/r/20200429131341.4697-2-t-kristo@ti.com
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 6a89936ba03a..eaa43575cfa5 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -196,6 +196,7 @@ static void __init _register_composite(void *user,
 		if (!cclk->comp_clks[i])
 			continue;
 		list_del(&cclk->comp_clks[i]->link);
+		kfree(cclk->comp_clks[i]->parent_names);
 		kfree(cclk->comp_clks[i]);
 	}
 

commit e665f029a283aff4f36f0c5388f7c708be67470e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Aug 28 10:44:29 2018 -0500

    clk: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-clk@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 030e8b2c1050..6a89936ba03a 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -135,8 +135,8 @@ static void __init _register_composite(void *user,
 
 		comp = _lookup_component(cclk->comp_nodes[i]);
 		if (!comp) {
-			pr_debug("component %s not ready for %s, retry\n",
-				 cclk->comp_nodes[i]->name, node->name);
+			pr_debug("component %s not ready for %pOFn, retry\n",
+				 cclk->comp_nodes[i]->name, node);
 			if (!ti_clk_retry_init(node, hw,
 					       _register_composite))
 				return;
@@ -144,8 +144,8 @@ static void __init _register_composite(void *user,
 			goto cleanup;
 		}
 		if (cclk->comp_clks[comp->type] != NULL) {
-			pr_err("duplicate component types for %s (%s)!\n",
-			       node->name, component_clk_types[comp->type]);
+			pr_err("duplicate component types for %pOFn (%s)!\n",
+			       node, component_clk_types[comp->type]);
 			goto cleanup;
 		}
 
@@ -168,7 +168,7 @@ static void __init _register_composite(void *user,
 	}
 
 	if (!num_parents) {
-		pr_err("%s: no parents found for %s!\n", __func__, node->name);
+		pr_err("%s: no parents found for %pOFn!\n", __func__, node);
 		goto cleanup;
 	}
 
@@ -212,7 +212,7 @@ static void __init of_ti_composite_clk_setup(struct device_node *node)
 	num_clks = of_clk_get_parent_count(node);
 
 	if (!num_clks) {
-		pr_err("composite clk %s must have component(s)\n", node->name);
+		pr_err("composite clk %pOFn must have component(s)\n", node);
 		return;
 	}
 
@@ -248,7 +248,7 @@ int __init ti_clk_add_component(struct device_node *node, struct clk_hw *hw,
 	num_parents = of_clk_get_parent_count(node);
 
 	if (!num_parents) {
-		pr_err("component-clock %s must have parent(s)\n", node->name);
+		pr_err("component-clock %pOFn must have parent(s)\n", node);
 		return -EINVAL;
 	}
 

commit 7558562a70fbd6b3fa746fa33c76c9333aa0bb32
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 14 08:32:06 2017 -0800

    clk: ti: Drop legacy clk-3xxx-legacy code
    
    We have now had omap3 booting in device tree only mode for a while
    and all this code is unused.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 3eaba2d16ce4..030e8b2c1050 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -116,51 +116,6 @@ static inline struct clk_hw *_get_hw(struct clk_hw_omap_comp *clk, int idx)
 
 #define to_clk_hw_comp(_hw) container_of(_hw, struct clk_hw_omap_comp, hw)
 
-#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_ATAGS)
-struct clk *ti_clk_register_composite(struct ti_clk *setup)
-{
-	struct ti_clk_composite *comp;
-	struct clk_hw *gate;
-	struct clk_hw *mux;
-	struct clk_hw *div;
-	int num_parents = 1;
-	const char * const *parent_names = NULL;
-	struct clk *clk;
-	int ret;
-
-	comp = setup->data;
-
-	div = ti_clk_build_component_div(comp->divider);
-	gate = ti_clk_build_component_gate(comp->gate);
-	mux = ti_clk_build_component_mux(comp->mux);
-
-	if (div)
-		parent_names = &comp->divider->parent;
-
-	if (gate)
-		parent_names = &comp->gate->parent;
-
-	if (mux) {
-		num_parents = comp->mux->num_parents;
-		parent_names = comp->mux->parents;
-	}
-
-	clk = clk_register_composite(NULL, setup->name,
-				     parent_names, num_parents, mux,
-				     &ti_clk_mux_ops, div,
-				     &ti_composite_divider_ops, gate,
-				     &ti_composite_gate_ops, 0);
-
-	ret = ti_clk_add_alias(NULL, clk, setup->name);
-	if (ret) {
-		clk_unregister(clk);
-		return ERR_PTR(ret);
-	}
-
-	return clk;
-}
-#endif
-
 static void __init _register_composite(void *user,
 				       struct device_node *node)
 {

commit ffb009b24388b896d9ca8b54e39a879302142518
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Nov 6 09:43:16 2017 +0200

    clk: ti: convert retry_init param to use void data type
    
    User data should be void type, as the core framework doesn't need to
    know what is passed through.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index beea89463ca2..3eaba2d16ce4 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -161,9 +161,10 @@ struct clk *ti_clk_register_composite(struct ti_clk *setup)
 }
 #endif
 
-static void __init _register_composite(struct clk_hw *hw,
+static void __init _register_composite(void *user,
 				       struct device_node *node)
 {
+	struct clk_hw *hw = user;
 	struct clk *clk;
 	struct clk_hw_omap_comp *cclk = to_clk_hw_comp(hw);
 	struct component_clk *comp;

commit ce382d4766bd82b8fdd487bb57afb1c4f9546de2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Oct 5 15:37:02 2016 +0300

    clk: ti: enforce const types on string arrays
    
    Constant string arrays should use const char * const instead of just
    const char *. Change the implementations using these to proper type.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 3f60f990cad8..beea89463ca2 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -124,7 +124,7 @@ struct clk *ti_clk_register_composite(struct ti_clk *setup)
 	struct clk_hw *mux;
 	struct clk_hw *div;
 	int num_parents = 1;
-	const char **parent_names = NULL;
+	const char * const *parent_names = NULL;
 	struct clk *clk;
 	int ret;
 

commit 1ae79c46cf195ea39407bd5a2b234304d537980f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Sep 29 12:06:40 2016 +0300

    clk: ti: use automatic clock alias generation framework
    
    Generate clock aliases automatically for all TI clock drivers.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 1cf70f452e1e..3f60f990cad8 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -126,6 +126,7 @@ struct clk *ti_clk_register_composite(struct ti_clk *setup)
 	int num_parents = 1;
 	const char **parent_names = NULL;
 	struct clk *clk;
+	int ret;
 
 	comp = setup->data;
 
@@ -150,6 +151,12 @@ struct clk *ti_clk_register_composite(struct ti_clk *setup)
 				     &ti_composite_divider_ops, gate,
 				     &ti_composite_gate_ops, 0);
 
+	ret = ti_clk_add_alias(NULL, clk, setup->name);
+	if (ret) {
+		clk_unregister(clk);
+		return ERR_PTR(ret);
+	}
+
 	return clk;
 }
 #endif
@@ -163,6 +170,7 @@ static void __init _register_composite(struct clk_hw *hw,
 	int num_parents = 0;
 	const char **parent_names = NULL;
 	int i;
+	int ret;
 
 	/* Check for presence of each component clock */
 	for (i = 0; i < CLK_COMPONENT_TYPE_MAX; i++) {
@@ -217,8 +225,14 @@ static void __init _register_composite(struct clk_hw *hw,
 				     _get_hw(cclk, CLK_COMPONENT_TYPE_GATE),
 				     &ti_composite_gate_ops, 0);
 
-	if (!IS_ERR(clk))
+	if (!IS_ERR(clk)) {
+		ret = ti_clk_add_alias(NULL, clk, node->name);
+		if (ret) {
+			clk_unregister(clk);
+			goto cleanup;
+		}
 		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	}
 
 cleanup:
 	/* Free component clock list entries */

commit 921bacfa34d48c019bb068257c0947d728662bf3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 19 17:49:23 2016 -0800

    clk: ti: Update for of_clk_get_parent_count() returning unsigned int
    
    Change the types here to unsigned int instead of int and update
    the checks for == 0 instead < 1 to be more explicit about what's
    going on now that of_clk_get_parent_count() has changed return
    types.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 43345c417815..1cf70f452e1e 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -234,14 +234,14 @@ static void __init _register_composite(struct clk_hw *hw,
 
 static void __init of_ti_composite_clk_setup(struct device_node *node)
 {
-	int num_clks;
+	unsigned int num_clks;
 	int i;
 	struct clk_hw_omap_comp *cclk;
 
 	/* Number of component clocks to be put inside this clock */
 	num_clks = of_clk_get_parent_count(node);
 
-	if (num_clks < 1) {
+	if (!num_clks) {
 		pr_err("composite clk %s must have component(s)\n", node->name);
 		return;
 	}
@@ -271,13 +271,13 @@ CLK_OF_DECLARE(ti_composite_clock, "ti,composite-clock",
 int __init ti_clk_add_component(struct device_node *node, struct clk_hw *hw,
 				int type)
 {
-	int num_parents;
+	unsigned int num_parents;
 	const char **parent_names;
 	struct component_clk *clk;
 
 	num_parents = of_clk_get_parent_count(node);
 
-	if (num_parents < 1) {
+	if (!num_parents) {
 		pr_err("component-clock %s must have parent(s)\n", node->name);
 		return -EINVAL;
 	}

commit 5fd9c05c846db98319e75496612da24435cee208
Author: Geliang Tang <geliangtang@163.com>
Date:   Fri Jan 8 23:51:46 2016 +0800

    clk: move the common clock's to_clk_*(_hw) macros to clk-provider.h
    
    to_clk_*(_hw) macros have been repeatedly defined in many places.
    This patch moves all the to_clk_*(_hw) definitions in the common
    clock framework to public header clk-provider.h, and drop the local
    definitions.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index dbef218fe5ec..43345c417815 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -28,8 +28,6 @@
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
-#define to_clk_divider(_hw) container_of(_hw, struct clk_divider, hw)
-
 static unsigned long ti_composite_recalc_rate(struct clk_hw *hw,
 					      unsigned long parent_rate)
 {

commit 9da9e761273702b3afd6e3538c23ece95693e586
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Mon Jul 6 22:59:06 2015 -0500

    clk: ti: make use of of_clk_parent_fill helper function
    
    Use of_clk_parent_fill to fill in the parent clock names' array.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 96f83cedb4b3..dbef218fe5ec 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -276,7 +276,6 @@ int __init ti_clk_add_component(struct device_node *node, struct clk_hw *hw,
 	int num_parents;
 	const char **parent_names;
 	struct component_clk *clk;
-	int i;
 
 	num_parents = of_clk_get_parent_count(node);
 
@@ -289,8 +288,7 @@ int __init ti_clk_add_component(struct device_node *node, struct clk_hw *hw,
 	if (!parent_names)
 		return -ENOMEM;
 
-	for (i = 0; i < num_parents; i++)
-		parent_names[i] = of_clk_get_parent_name(node, i);
+	of_clk_parent_fill(node, parent_names, num_parents);
 
 	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 	if (!clk) {

commit 692d8328e8c039f9497eb862c6cf835de922c061
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Feb 18 10:59:45 2015 +0100

    clk: don't use __initconst for non-const arrays
    
    The statement
    
            static const char *name[];
    
    defines a modifiable array of pointers to constant chars. That is
    
            *name[0] = 'f';
    
    is forbidden, but
    
            name[0] = "f";
    
    is not. So marking an array that is defined as above with __initconst is
    wrong. Either an additional const must be added such that the whole
    definition reads:
    
            static const char *const name[] __initconst;
    
    or where this is not possible __initdata must be used.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 3654f61912eb..96f83cedb4b3 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -69,7 +69,7 @@ struct component_clk {
 	struct list_head link;
 };
 
-static const char * __initconst component_clk_types[] = {
+static const char * const component_clk_types[] __initconst = {
 	"gate", "divider", "mux"
 };
 

commit 6793a30a0646d2cc269e66782ca30c6025c92e1f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Feb 3 17:59:32 2015 +0100

    clk: omap: compile legacy omap3 clocks conditionally
    
    The 'ARM: OMAP3: legacy clock data move under clk driver' patch series
    causes build errors when CONFIG_OMAP3 is not set:
    
    drivers/clk/ti/dpll.c: In function 'ti_clk_register_dpll':
    drivers/clk/ti/dpll.c:199:31: error: 'omap3_dpll_ck_ops' undeclared (first use in this function)
      const struct clk_ops *ops = &omap3_dpll_ck_ops;
                                   ^
    drivers/clk/ti/dpll.c:199:31: note: each undeclared identifier is reported only once for each function it appears in
    drivers/clk/ti/dpll.c:259:10: error: 'omap3_dpll_per_ck_ops' undeclared (first use in this function)
       ops = &omap3_dpll_per_ck_ops;
              ^
    
    drivers/built-in.o: In function `ti_clk_register_gate':
    drivers/clk/ti/gate.c:179: undefined reference to `clkhwops_omap3430es2_dss_usbhost_wait'
    drivers/clk/ti/gate.c:179: undefined reference to `clkhwops_am35xx_ipss_module_wait'
    -in.o: In function `ti_clk_register_interface':
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_hsotgusb_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_dss_usbhost_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_omap3430es2_iclk_ssi_wait'
    drivers/clk/ti/interface.c:100: undefined reference to `clkhwops_am35xx_ipss_wait'
    drivers/built-in.o: In function `ti_clk_register_composite':
    :(.text+0x3da768): undefined reference to `ti_clk_build_component_gate'
    
    In order to fix that problem, this patch makes the omap3 legacy code
    compiled only when both CONFIG_OMAP3 and CONFIG_ATAGS are set.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 3a9665fce041..3654f61912eb 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -118,6 +118,7 @@ static inline struct clk_hw *_get_hw(struct clk_hw_omap_comp *clk, int idx)
 
 #define to_clk_hw_comp(_hw) container_of(_hw, struct clk_hw_omap_comp, hw)
 
+#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_ATAGS)
 struct clk *ti_clk_register_composite(struct ti_clk *setup)
 {
 	struct ti_clk_composite *comp;
@@ -153,6 +154,7 @@ struct clk *ti_clk_register_composite(struct ti_clk *setup)
 
 	return clk;
 }
+#endif
 
 static void __init _register_composite(struct clk_hw *hw,
 				       struct device_node *node)

commit b26bcf9be64e26d8a0972d6df1c2105cc5076cf1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Dec 16 18:20:52 2014 +0200

    clk: ti: composite: add support for legacy composite clock init
    
    Legacy clock data is initialized slightly differently compared to
    DT clocks, thus add support for this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 19d8980ba458..3a9665fce041 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -23,6 +23,8 @@
 #include <linux/clk/ti.h>
 #include <linux/list.h>
 
+#include "clock.h"
+
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
@@ -116,8 +118,44 @@ static inline struct clk_hw *_get_hw(struct clk_hw_omap_comp *clk, int idx)
 
 #define to_clk_hw_comp(_hw) container_of(_hw, struct clk_hw_omap_comp, hw)
 
-static void __init ti_clk_register_composite(struct clk_hw *hw,
-					     struct device_node *node)
+struct clk *ti_clk_register_composite(struct ti_clk *setup)
+{
+	struct ti_clk_composite *comp;
+	struct clk_hw *gate;
+	struct clk_hw *mux;
+	struct clk_hw *div;
+	int num_parents = 1;
+	const char **parent_names = NULL;
+	struct clk *clk;
+
+	comp = setup->data;
+
+	div = ti_clk_build_component_div(comp->divider);
+	gate = ti_clk_build_component_gate(comp->gate);
+	mux = ti_clk_build_component_mux(comp->mux);
+
+	if (div)
+		parent_names = &comp->divider->parent;
+
+	if (gate)
+		parent_names = &comp->gate->parent;
+
+	if (mux) {
+		num_parents = comp->mux->num_parents;
+		parent_names = comp->mux->parents;
+	}
+
+	clk = clk_register_composite(NULL, setup->name,
+				     parent_names, num_parents, mux,
+				     &ti_clk_mux_ops, div,
+				     &ti_composite_divider_ops, gate,
+				     &ti_composite_gate_ops, 0);
+
+	return clk;
+}
+
+static void __init _register_composite(struct clk_hw *hw,
+				       struct device_node *node)
 {
 	struct clk *clk;
 	struct clk_hw_omap_comp *cclk = to_clk_hw_comp(hw);
@@ -136,7 +174,7 @@ static void __init ti_clk_register_composite(struct clk_hw *hw,
 			pr_debug("component %s not ready for %s, retry\n",
 				 cclk->comp_nodes[i]->name, node->name);
 			if (!ti_clk_retry_init(node, hw,
-					       ti_clk_register_composite))
+					       _register_composite))
 				return;
 
 			goto cleanup;
@@ -216,7 +254,7 @@ static void __init of_ti_composite_clk_setup(struct device_node *node)
 	for (i = 0; i < num_clks; i++)
 		cclk->comp_nodes[i] = _get_component_node(node, i);
 
-	ti_clk_register_composite(&cclk->hw, node);
+	_register_composite(&cclk->hw, node);
 }
 CLK_OF_DECLARE(ti_composite_clock, "ti,composite-clock",
 	       of_ti_composite_clk_setup);

commit 6a369c584fbe98264458b9442e780f8078f2f7ad
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Sep 13 20:22:27 2013 +0300

    clk: ti: add support for basic mux clock
    
    ti,mux-clock provides now a binding for basic mux support. This is just
    using the basic clock type.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index ffb8db4829bf..19d8980ba458 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -173,7 +173,7 @@ static void __init ti_clk_register_composite(struct clk_hw *hw,
 	clk = clk_register_composite(NULL, node->name,
 				     parent_names, num_parents,
 				     _get_hw(cclk, CLK_COMPONENT_TYPE_MUX),
-				     &clk_mux_ops,
+				     &ti_clk_mux_ops,
 				     _get_hw(cclk, CLK_COMPONENT_TYPE_DIVIDER),
 				     &ti_composite_divider_ops,
 				     _get_hw(cclk, CLK_COMPONENT_TYPE_GATE),

commit b4761198bfaf29649dc58a48e8b123ea4174ba95
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Sep 13 12:02:15 2013 +0300

    CLK: ti: add support for ti divider-clock
    
    This patch adds support for TI divider clock binding, which simply uses
    the basic clock divider to provide the features needed.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
index 6539b650cae0..ffb8db4829bf 100644
--- a/drivers/clk/ti/composite.c
+++ b/drivers/clk/ti/composite.c
@@ -31,7 +31,7 @@
 static unsigned long ti_composite_recalc_rate(struct clk_hw *hw,
 					      unsigned long parent_rate)
 {
-	return clk_divider_ops.recalc_rate(hw, parent_rate);
+	return ti_clk_divider_ops.recalc_rate(hw, parent_rate);
 }
 
 static long ti_composite_round_rate(struct clk_hw *hw, unsigned long rate,

commit 975e15487d5abfd5f33fea9c1ba0b987604f0d0f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Sep 9 15:46:45 2013 +0300

    clk: ti: add composite clock support
    
    This is a multipurpose clock node, which contains support for multiple
    sub-clocks. Uses basic composite clock type to implement the actual
    functionality, and TI specific gate, mux and divider clocks.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/ti/composite.c b/drivers/clk/ti/composite.c
new file mode 100644
index 000000000000..6539b650cae0
--- /dev/null
+++ b/drivers/clk/ti/composite.c
@@ -0,0 +1,269 @@
+/*
+ * TI composite clock support
+ *
+ * Copyright (C) 2013 Texas Instruments, Inc.
+ *
+ * Tero Kristo <t-kristo@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/clk/ti.h>
+#include <linux/list.h>
+
+#undef pr_fmt
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#define to_clk_divider(_hw) container_of(_hw, struct clk_divider, hw)
+
+static unsigned long ti_composite_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	return clk_divider_ops.recalc_rate(hw, parent_rate);
+}
+
+static long ti_composite_round_rate(struct clk_hw *hw, unsigned long rate,
+				    unsigned long *prate)
+{
+	return -EINVAL;
+}
+
+static int ti_composite_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	return -EINVAL;
+}
+
+static const struct clk_ops ti_composite_divider_ops = {
+	.recalc_rate	= &ti_composite_recalc_rate,
+	.round_rate	= &ti_composite_round_rate,
+	.set_rate	= &ti_composite_set_rate,
+};
+
+static const struct clk_ops ti_composite_gate_ops = {
+	.enable		= &omap2_dflt_clk_enable,
+	.disable	= &omap2_dflt_clk_disable,
+	.is_enabled	= &omap2_dflt_clk_is_enabled,
+};
+
+struct component_clk {
+	int num_parents;
+	const char **parent_names;
+	struct device_node *node;
+	int type;
+	struct clk_hw *hw;
+	struct list_head link;
+};
+
+static const char * __initconst component_clk_types[] = {
+	"gate", "divider", "mux"
+};
+
+static LIST_HEAD(component_clks);
+
+static struct device_node *_get_component_node(struct device_node *node, int i)
+{
+	int rc;
+	struct of_phandle_args clkspec;
+
+	rc = of_parse_phandle_with_args(node, "clocks", "#clock-cells", i,
+					&clkspec);
+	if (rc)
+		return NULL;
+
+	return clkspec.np;
+}
+
+static struct component_clk *_lookup_component(struct device_node *node)
+{
+	struct component_clk *comp;
+
+	list_for_each_entry(comp, &component_clks, link) {
+		if (comp->node == node)
+			return comp;
+	}
+	return NULL;
+}
+
+struct clk_hw_omap_comp {
+	struct clk_hw hw;
+	struct device_node *comp_nodes[CLK_COMPONENT_TYPE_MAX];
+	struct component_clk *comp_clks[CLK_COMPONENT_TYPE_MAX];
+};
+
+static inline struct clk_hw *_get_hw(struct clk_hw_omap_comp *clk, int idx)
+{
+	if (!clk)
+		return NULL;
+
+	if (!clk->comp_clks[idx])
+		return NULL;
+
+	return clk->comp_clks[idx]->hw;
+}
+
+#define to_clk_hw_comp(_hw) container_of(_hw, struct clk_hw_omap_comp, hw)
+
+static void __init ti_clk_register_composite(struct clk_hw *hw,
+					     struct device_node *node)
+{
+	struct clk *clk;
+	struct clk_hw_omap_comp *cclk = to_clk_hw_comp(hw);
+	struct component_clk *comp;
+	int num_parents = 0;
+	const char **parent_names = NULL;
+	int i;
+
+	/* Check for presence of each component clock */
+	for (i = 0; i < CLK_COMPONENT_TYPE_MAX; i++) {
+		if (!cclk->comp_nodes[i])
+			continue;
+
+		comp = _lookup_component(cclk->comp_nodes[i]);
+		if (!comp) {
+			pr_debug("component %s not ready for %s, retry\n",
+				 cclk->comp_nodes[i]->name, node->name);
+			if (!ti_clk_retry_init(node, hw,
+					       ti_clk_register_composite))
+				return;
+
+			goto cleanup;
+		}
+		if (cclk->comp_clks[comp->type] != NULL) {
+			pr_err("duplicate component types for %s (%s)!\n",
+			       node->name, component_clk_types[comp->type]);
+			goto cleanup;
+		}
+
+		cclk->comp_clks[comp->type] = comp;
+
+		/* Mark this node as found */
+		cclk->comp_nodes[i] = NULL;
+	}
+
+	/* All components exists, proceed with registration */
+	for (i = CLK_COMPONENT_TYPE_MAX - 1; i >= 0; i--) {
+		comp = cclk->comp_clks[i];
+		if (!comp)
+			continue;
+		if (comp->num_parents) {
+			num_parents = comp->num_parents;
+			parent_names = comp->parent_names;
+			break;
+		}
+	}
+
+	if (!num_parents) {
+		pr_err("%s: no parents found for %s!\n", __func__, node->name);
+		goto cleanup;
+	}
+
+	clk = clk_register_composite(NULL, node->name,
+				     parent_names, num_parents,
+				     _get_hw(cclk, CLK_COMPONENT_TYPE_MUX),
+				     &clk_mux_ops,
+				     _get_hw(cclk, CLK_COMPONENT_TYPE_DIVIDER),
+				     &ti_composite_divider_ops,
+				     _get_hw(cclk, CLK_COMPONENT_TYPE_GATE),
+				     &ti_composite_gate_ops, 0);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+
+cleanup:
+	/* Free component clock list entries */
+	for (i = 0; i < CLK_COMPONENT_TYPE_MAX; i++) {
+		if (!cclk->comp_clks[i])
+			continue;
+		list_del(&cclk->comp_clks[i]->link);
+		kfree(cclk->comp_clks[i]);
+	}
+
+	kfree(cclk);
+}
+
+static void __init of_ti_composite_clk_setup(struct device_node *node)
+{
+	int num_clks;
+	int i;
+	struct clk_hw_omap_comp *cclk;
+
+	/* Number of component clocks to be put inside this clock */
+	num_clks = of_clk_get_parent_count(node);
+
+	if (num_clks < 1) {
+		pr_err("composite clk %s must have component(s)\n", node->name);
+		return;
+	}
+
+	cclk = kzalloc(sizeof(*cclk), GFP_KERNEL);
+	if (!cclk)
+		return;
+
+	/* Get device node pointers for each component clock */
+	for (i = 0; i < num_clks; i++)
+		cclk->comp_nodes[i] = _get_component_node(node, i);
+
+	ti_clk_register_composite(&cclk->hw, node);
+}
+CLK_OF_DECLARE(ti_composite_clock, "ti,composite-clock",
+	       of_ti_composite_clk_setup);
+
+/**
+ * ti_clk_add_component - add a component clock to the pool
+ * @node: device node of the component clock
+ * @hw: hardware clock definition for the component clock
+ * @type: type of the component clock
+ *
+ * Adds a component clock to the list of available components, so that
+ * it can be registered by a composite clock.
+ */
+int __init ti_clk_add_component(struct device_node *node, struct clk_hw *hw,
+				int type)
+{
+	int num_parents;
+	const char **parent_names;
+	struct component_clk *clk;
+	int i;
+
+	num_parents = of_clk_get_parent_count(node);
+
+	if (num_parents < 1) {
+		pr_err("component-clock %s must have parent(s)\n", node->name);
+		return -EINVAL;
+	}
+
+	parent_names = kzalloc((sizeof(char *) * num_parents), GFP_KERNEL);
+	if (!parent_names)
+		return -ENOMEM;
+
+	for (i = 0; i < num_parents; i++)
+		parent_names[i] = of_clk_get_parent_name(node, i);
+
+	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk) {
+		kfree(parent_names);
+		return -ENOMEM;
+	}
+
+	clk->num_parents = num_parents;
+	clk->parent_names = parent_names;
+	clk->hw = hw;
+	clk->node = node;
+	clk->type = type;
+	list_add(&clk->link, &component_clks);
+
+	return 0;
+}
