commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index d81f1d2e9129..b1e556f20911 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/clk-provider.h>
+#include <linux/io.h>
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/slab.h>

commit 0caf000817353cfc5db22363ecdac63b83d3a3f9
Merge: ff060019f4e5 90b6c5c73c69
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue May 7 11:46:02 2019 -0700

    Merge branch 'clk-ti' into clk-next
    
    * clk-ti:
      clk: Remove CLK_IS_BASIC clk flag
      clk: ti: dra7: disable the RNG and TIMER12 clkctrl clocks on HS devices
      clk: ti: dra7x: prevent non-existing clkctrl clocks from registering
      ARM: omap2+: hwmod: drop CLK_IS_BASIC flag usage
      clk: ti: export the omap2_clk_is_hw_omap call

commit 90b6c5c73c6904ac200161fc38974d867f0535b0
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 25 10:57:37 2019 -0700

    clk: Remove CLK_IS_BASIC clk flag
    
    This flag was historically used to indicate that a clk is a "basic" type
    of clk like a mux, divider, gate, etc. This never turned out to be very
    useful though because it was hard to cleanly split "basic" clks from
    other clks in a system. This one flag was a way for type introspection
    and it just didn't scale. If anything, it was used by the TI clk driver
    to indicate that a clk_hw wasn't contained in the SoC specific clk
    structure. We can get rid of this define now that TI is finding those
    clks a different way.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: <linux-mips@vger.kernel.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: <linux-pwm@vger.kernel.org>
    Cc: <linux-amlogic@lists.infradead.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index fdfe2e423d15..aa45dd257fe3 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -151,7 +151,7 @@ struct clk_hw *clk_hw_register_fractional_divider(struct device *dev,
 
 	init.name = name;
 	init.ops = &clk_fractional_divider_ops;
-	init.flags = flags | CLK_IS_BASIC;
+	init.flags = flags;
 	init.parent_names = parent_name ? &parent_name : NULL;
 	init.num_parents = parent_name ? 1 : 0;
 

commit 5834fd75e6236605da8c439a64eaa33f3c8d02fe
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Thu Apr 18 13:12:11 2019 +0200

    clk: core: replace clk_{readl,writel} with {readl,writel}
    
    Now that clk_{readl,writel} is just an alias for {readl,writel}, we can
    switch all users of clk_* to use the accessors directly and remove the
    helpers.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    [sboyd@kernel.org: Also convert renesas file so that this can be
    compile independently]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index f88df265e787..638a9bbc2ab8 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -18,7 +18,7 @@ static inline u32 clk_fd_readl(struct clk_fractional_divider *fd)
 	if (fd->flags & CLK_FRAC_DIVIDER_BIG_ENDIAN)
 		return ioread32be(fd->reg);
 
-	return clk_readl(fd->reg);
+	return readl(fd->reg);
 }
 
 static inline void clk_fd_writel(struct clk_fractional_divider *fd, u32 val)
@@ -26,7 +26,7 @@ static inline void clk_fd_writel(struct clk_fractional_divider *fd, u32 val)
 	if (fd->flags & CLK_FRAC_DIVIDER_BIG_ENDIAN)
 		iowrite32be(val, fd->reg);
 	else
-		clk_writel(val, fd->reg);
+		writel(val, fd->reg);
 }
 
 static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,

commit 58a2b4c9bdf98452fec95bb1a5eeed60c01f621a
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Thu Apr 18 13:12:05 2019 +0200

    clk: fractional-divider: add explicit big endian support
    
    Add a clock specific flag to switch register accesses to big endian, to
    allow runtime configuration of big endian fractional divider clocks.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index fdfe2e423d15..f88df265e787 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -13,6 +13,22 @@
 #include <linux/slab.h>
 #include <linux/rational.h>
 
+static inline u32 clk_fd_readl(struct clk_fractional_divider *fd)
+{
+	if (fd->flags & CLK_FRAC_DIVIDER_BIG_ENDIAN)
+		return ioread32be(fd->reg);
+
+	return clk_readl(fd->reg);
+}
+
+static inline void clk_fd_writel(struct clk_fractional_divider *fd, u32 val)
+{
+	if (fd->flags & CLK_FRAC_DIVIDER_BIG_ENDIAN)
+		iowrite32be(val, fd->reg);
+	else
+		clk_writel(val, fd->reg);
+}
+
 static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 					unsigned long parent_rate)
 {
@@ -27,7 +43,7 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 	else
 		__acquire(fd->lock);
 
-	val = clk_readl(fd->reg);
+	val = clk_fd_readl(fd);
 
 	if (fd->lock)
 		spin_unlock_irqrestore(fd->lock, flags);
@@ -115,10 +131,10 @@ static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
 	else
 		__acquire(fd->lock);
 
-	val = clk_readl(fd->reg);
+	val = clk_fd_readl(fd);
 	val &= ~(fd->mmask | fd->nmask);
 	val |= (m << fd->mshift) | (n << fd->nshift);
-	clk_writel(val, fd->reg);
+	clk_fd_writel(fd, val);
 
 	if (fd->lock)
 		spin_unlock_irqrestore(fd->lock, flags);

commit d13501a2bedfbea0983cc868d3f1dc692627f60d
Author: Katsuhiro Suzuki <katsuhiro@katsuster.net>
Date:   Mon Feb 11 00:38:06 2019 +0900

    clk: fractional-divider: check parent rate only if flag is set
    
    Custom approximation of fractional-divider may not need parent clock
    rate checking. For example Rockchip SoCs work fine using grand parent
    clock rate even if target rate is greater than parent.
    
    This patch checks parent clock rate only if CLK_SET_RATE_PARENT flag
    is set.
    
    For detailed example, clock tree of Rockchip I2S audio hardware.
      - Clock rate of CPLL is 1.2GHz, GPLL is 491.52MHz.
      - i2s1_div is integer divider can divide N (N is 1~128).
        Input clock is CPLL or GPLL. Initial divider value is N = 1.
        Ex) PLL = CPLL, N = 10, i2s1_div output rate is
          CPLL / 10 = 1.2GHz / 10 = 120MHz
      - i2s1_frac is fractional divider can divide input to x/y, x and
        y are 16bit integer.
    
    CPLL --> | selector | ---> i2s1_div -+--> | selector | --> I2S1 MCLK
    GPLL --> |          | ,--------------'    |          |
                          `--> i2s1_frac ---> |          |
    
    Clock mux system try to choose suitable one from i2s1_div and
    i2s1_frac for master clock (MCLK) of I2S1.
    
    Bad scenario as follows:
      - Try to set MCLK to 8.192MHz (32kHz audio replay)
        Candidate setting is
        - i2s1_div: GPLL / 60 = 8.192MHz
        i2s1_div candidate is exactly same as target clock rate, so mux
        choose this clock source. i2s1_div output rate is changed
        491.52MHz -> 8.192MHz
    
      - After that try to set to 11.2896MHz (44.1kHz audio replay)
        Candidate settings are
        - i2s1_div : CPLL / 107 = 11.214945MHz
        - i2s1_frac: i2s1_div   = 8.192MHz
          This is because clk_fd_round_rate() thinks target rate
          (11.2896MHz) is higher than parent rate (i2s1_div = 8.192MHz)
          and returns parent clock rate.
    
    Above is current upstreamed behavior. Clock mux system choose
    i2s1_div, but this clock rate is not acceptable for I2S driver, so
    users cannot replay audio.
    
    Expected behavior is:
      - Try to set master clock to 11.2896MHz (44.1kHz audio replay)
        Candidate settings are
        - i2s1_div : CPLL / 107          = 11.214945MHz
        - i2s1_frac: i2s1_div * 147/6400 = 11.2896MHz
                     Change i2s1_div to GPLL / 1 = 491.52MHz at same
                     time.
    
    If apply this commit, clk_fd_round_rate() calls custom approximate
    function of Rockchip even if target rate is higher than parent.
    Custom function changes both grand parent (i2s1_div) and parent
    (i2s_frac) settings at same time. Clock mux system can choose
    i2s1_frac and audio works fine.
    
    Signed-off-by: Katsuhiro Suzuki <katsuhiro@katsuster.net>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    [sboyd@kernel.org: Make function into a macro instead]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 545dceec0bbf..fdfe2e423d15 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -79,7 +79,7 @@ static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
 	unsigned long m, n;
 	u64 ret;
 
-	if (!rate || rate >= *parent_rate)
+	if (!rate || (!clk_hw_can_set_rate_parent(hw) && rate >= *parent_rate))
 		return *parent_rate;
 
 	if (fd->approximation)

commit 58c05c823b8347daf03a8448e38318820fad6645
Merge: ffe05540d180 b1260067ac3d 3cc48976e976 929914946fa6 1e3121bfe51a d360b130e210
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Dec 14 13:34:47 2018 -0800

    Merge branches 'clk-imx7ulp', 'clk-imx6-fixes', 'clk-imx-fixes', 'clk-imx8qxp' and 'clk-imx8mq' into clk-next
    
     - NXP i.MX7ULP SoC clock support
     - Support for i.MX8QXP SoC clocks
     - Support for NXP i.MX8MQ clock controllers
    
    * clk-imx7ulp:
      clk: imx: add imx7ulp clk driver
      clk: imx: implement new clk_hw based APIs
      clk: imx: make mux parent strings const
      dt-bindings: clock: add imx7ulp clock binding doc
      clk: imx: add imx7ulp composite clk support
      clk: imx: add pfdv2 support
      clk: imx: add pllv4 support
      clk: fractional-divider: add CLK_FRAC_DIVIDER_ZERO_BASED flag support
      clk: imx: add gatable clock divider support
    
    * clk-imx6-fixes:
      clk: imx6q: handle ENET PLL bypass
      clk: imx6q: optionally get CCM inputs via standard clock handles
      clk: imx6q: reset exclusive gates on init
    
    * clk-imx-fixes:
      clk: imx6q: add DCICx clocks gate
      clk: imx6sl: ensure MMDC CH0 handshake is bypassed
      clk: imx7d: remove UART1 clock setting
    
    * clk-imx8qxp:
      clk: imx: add imx8qxp lpcg driver
      clk: imx: add lpcg clock support
      clk: imx: add imx8qxp clk driver
      clk: imx: add scu clock common part
      clk: imx: add configuration option for mmio clks
      dt-bindings: clock: add imx8qxp lpcg clock binding
      dt-bindings: clock: imx8qxp: add SCU clock IDs
      firmware: imx: add pm svc headfile
      dt-bindings: fsl: scu: update power domain binding
      firmware: imx: remove resource id enums
      dt-bindings: imx: add scu resource id headfile
    
    * clk-imx8mq:
      clk: imx: Make the i.MX8MQ CCM clock driver CLK_IMX8MQ dependant
      clk: imx: remove redundant initialization of ret to zero
      clk: imx: Add SCCG PLL type
      clk: imx: Add fractional PLL output clock
      clk: imx: Add clock driver for i.MX8MQ CCM
      clk: imx: Add imx composite clock
      dt-bindings: Add binding for i.MX8MQ CCM

commit e1bd55e5a567a90c5b26238a46bbaf1c775e9661
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 09:57:48 2018 -0800

    clk: Tag basic clk types with SPDX
    
    These are all GPL-2.0 files per the existing license text. Replace the
    boiler plate with the tag.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index fdf625fb10fa..830f1361ff79 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2014 Intel Corporation
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Adjustable fractional divider clock implementation.
  * Output rate = (m / n) * parent_rate.
  * Uses rational best approximation algorithm.

commit e983da27f70e8d29f4ae7262d52e4d07129498f3
Author: A.s. Dong <aisheng.dong@nxp.com>
Date:   Wed Nov 14 13:01:39 2018 +0000

    clk: fractional-divider: add CLK_FRAC_DIVIDER_ZERO_BASED flag support
    
    Adding CLK_FRAC_DIVIDER_ZERO_BASED flag to indicate the numerator and
    denominator value in register are start from 0.
    
    This can be used to support frac dividers like below:
    Divider output clock = Divider input clock x [(frac +1) / (div +1)]
    where frac/div in register is:
    000b - Divide by 1.
    001b - Divide by 2.
    010b - Divide by 3.
    
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index fdf625fb10fa..7ccde6bd8dd5 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -40,6 +40,11 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 	m = (val & fd->mmask) >> fd->mshift;
 	n = (val & fd->nmask) >> fd->nshift;
 
+	if (fd->flags & CLK_FRAC_DIVIDER_ZERO_BASED) {
+		m++;
+		n++;
+	}
+
 	if (!n || !m)
 		return parent_rate;
 
@@ -103,6 +108,11 @@ static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
 			GENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),
 			&m, &n);
 
+	if (fd->flags & CLK_FRAC_DIVIDER_ZERO_BASED) {
+		m--;
+		n--;
+	}
+
 	if (fd->lock)
 		spin_lock_irqsave(fd->lock, flags);
 	else

commit ec52e462564b9c5bfdf1f79638c537c7103e1d2b
Author: Elaine Zhang <zhangqing@rock-chips.com>
Date:   Tue Aug 1 18:21:22 2017 +0200

    clk: fractional-divider: allow overriding of approximation
    
    Fractional dividers may have special requirements concerning numerator
    and denominator selection that differ from just getting the best
    approximation.
    
    For example on Rockchip socs the denominator must be at least 20 times
    larger than the numerator to generate precise clock frequencies.
    
    Therefore add the ability to provide custom approximation functions.
    
    Signed-off-by: Elaine Zhang <zhangqing@rock-chips.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index aab904618eb6..fdf625fb10fa 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -49,16 +49,12 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 	return ret;
 }
 
-static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
-			      unsigned long *parent_rate)
+static void clk_fd_general_approximation(struct clk_hw *hw, unsigned long rate,
+					 unsigned long *parent_rate,
+					 unsigned long *m, unsigned long *n)
 {
 	struct clk_fractional_divider *fd = to_clk_fd(hw);
 	unsigned long scale;
-	unsigned long m, n;
-	u64 ret;
-
-	if (!rate || rate >= *parent_rate)
-		return *parent_rate;
 
 	/*
 	 * Get rate closer to *parent_rate to guarantee there is no overflow
@@ -71,7 +67,23 @@ static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
 
 	rational_best_approximation(rate, *parent_rate,
 			GENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),
-			&m, &n);
+			m, n);
+}
+
+static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long *parent_rate)
+{
+	struct clk_fractional_divider *fd = to_clk_fd(hw);
+	unsigned long m, n;
+	u64 ret;
+
+	if (!rate || rate >= *parent_rate)
+		return *parent_rate;
+
+	if (fd->approximation)
+		fd->approximation(hw, rate, parent_rate, &m, &n);
+	else
+		clk_fd_general_approximation(hw, rate, parent_rate, &m, &n);
 
 	ret = (u64)*parent_rate * m;
 	do_div(ret, n);

commit 39b44cff4ad4af6d7abd9dd2acb288b005c26503
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sun Feb 7 00:15:09 2016 -0800

    clk: fractional-divider: Add hw based registration APIs
    
    Add registration APIs in the clk fractional divider code to
    return struct clk_hw pointers instead of struct clk pointers.
    This way we hide the struct clk pointer from providers unless
    they need to use consumer facing APIs.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 1abcd76b4993..aab904618eb6 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -116,14 +116,15 @@ const struct clk_ops clk_fractional_divider_ops = {
 };
 EXPORT_SYMBOL_GPL(clk_fractional_divider_ops);
 
-struct clk *clk_register_fractional_divider(struct device *dev,
+struct clk_hw *clk_hw_register_fractional_divider(struct device *dev,
 		const char *name, const char *parent_name, unsigned long flags,
 		void __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,
 		u8 clk_divider_flags, spinlock_t *lock)
 {
 	struct clk_fractional_divider *fd;
 	struct clk_init_data init;
-	struct clk *clk;
+	struct clk_hw *hw;
+	int ret;
 
 	fd = kzalloc(sizeof(*fd), GFP_KERNEL);
 	if (!fd)
@@ -146,10 +147,39 @@ struct clk *clk_register_fractional_divider(struct device *dev,
 	fd->lock = lock;
 	fd->hw.init = &init;
 
-	clk = clk_register(dev, &fd->hw);
-	if (IS_ERR(clk))
+	hw = &fd->hw;
+	ret = clk_hw_register(dev, hw);
+	if (ret) {
 		kfree(fd);
+		hw = ERR_PTR(ret);
+	}
+
+	return hw;
+}
+EXPORT_SYMBOL_GPL(clk_hw_register_fractional_divider);
 
-	return clk;
+struct clk *clk_register_fractional_divider(struct device *dev,
+		const char *name, const char *parent_name, unsigned long flags,
+		void __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,
+		u8 clk_divider_flags, spinlock_t *lock)
+{
+	struct clk_hw *hw;
+
+	hw = clk_hw_register_fractional_divider(dev, name, parent_name, flags,
+			reg, mshift, mwidth, nshift, nwidth, clk_divider_flags,
+			lock);
+	if (IS_ERR(hw))
+		return ERR_CAST(hw);
+	return hw->clk;
 }
 EXPORT_SYMBOL_GPL(clk_register_fractional_divider);
+
+void clk_hw_unregister_fractional_divider(struct clk_hw *hw)
+{
+	struct clk_fractional_divider *fd;
+
+	fd = to_clk_fd(hw);
+
+	clk_hw_unregister(hw);
+	kfree(fd);
+}

commit 5fd9c05c846db98319e75496612da24435cee208
Author: Geliang Tang <geliangtang@163.com>
Date:   Fri Jan 8 23:51:46 2016 +0800

    clk: move the common clock's to_clk_*(_hw) macros to clk-provider.h
    
    to_clk_*(_hw) macros have been repeatedly defined in many places.
    This patch moves all the to_clk_*(_hw) definitions in the common
    clock framework to public header clk-provider.h, and drop the local
    definitions.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 5c4955e33f7a..1abcd76b4993 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -16,8 +16,6 @@
 #include <linux/slab.h>
 #include <linux/rational.h>
 
-#define to_clk_fd(_hw) container_of(_hw, struct clk_fractional_divider, hw)
-
 static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 					unsigned long parent_rate)
 {

commit 0777591e715a89fd44fd598167aa8beaa49f1776
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 22 18:54:11 2015 +0300

    clk: fractional-divider: switch to rational best approximation
    
    This patch converts the code to use rational best approximation algorithm which
    is much more precise.
    
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 0282c7647a49..5c4955e33f7a 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -7,13 +7,14 @@
  *
  * Adjustable fractional divider clock implementation.
  * Output rate = (m / n) * parent_rate.
+ * Uses rational best approximation algorithm.
  */
 
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/slab.h>
-#include <linux/gcd.h>
+#include <linux/rational.h>
 
 #define to_clk_fd(_hw) container_of(_hw, struct clk_fractional_divider, hw)
 
@@ -22,7 +23,8 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 {
 	struct clk_fractional_divider *fd = to_clk_fd(hw);
 	unsigned long flags = 0;
-	u32 val, m, n;
+	unsigned long m, n;
+	u32 val;
 	u64 ret;
 
 	if (fd->lock)
@@ -53,20 +55,30 @@ static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
 			      unsigned long *parent_rate)
 {
 	struct clk_fractional_divider *fd = to_clk_fd(hw);
-	unsigned maxn = (fd->nmask >> fd->nshift) + 1;
-	unsigned div;
+	unsigned long scale;
+	unsigned long m, n;
+	u64 ret;
 
 	if (!rate || rate >= *parent_rate)
 		return *parent_rate;
 
-	div = gcd(*parent_rate, rate);
+	/*
+	 * Get rate closer to *parent_rate to guarantee there is no overflow
+	 * for m and n. In the result it will be the nearest rate left shifted
+	 * by (scale - fd->nwidth) bits.
+	 */
+	scale = fls_long(*parent_rate / rate - 1);
+	if (scale > fd->nwidth)
+		rate <<= scale - fd->nwidth;
 
-	while ((*parent_rate / div) > maxn) {
-		div <<= 1;
-		rate <<= 1;
-	}
+	rational_best_approximation(rate, *parent_rate,
+			GENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),
+			&m, &n);
 
-	return rate;
+	ret = (u64)*parent_rate * m;
+	do_div(ret, n);
+
+	return ret;
 }
 
 static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -74,13 +86,12 @@ static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
 {
 	struct clk_fractional_divider *fd = to_clk_fd(hw);
 	unsigned long flags = 0;
-	unsigned long div;
-	unsigned n, m;
+	unsigned long m, n;
 	u32 val;
 
-	div = gcd(parent_rate, rate);
-	m = rate / div;
-	n = parent_rate / div;
+	rational_best_approximation(rate, parent_rate,
+			GENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),
+			&m, &n);
 
 	if (fd->lock)
 		spin_lock_irqsave(fd->lock, flags);

commit 934e2536b1bfe663de033298f75c1b8ff9d0c9ea
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 22 18:54:09 2015 +0300

    clk: fractional-divider: keep mwidth and nwidth internally
    
    The patch adds mwidth and nwidth fields to the struct clk_fractional_divider
    for further usage. While here, use GENMASK() instead of open coding this
    functionality.
    
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 1af9c1e85d83..0282c7647a49 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -128,9 +128,11 @@ struct clk *clk_register_fractional_divider(struct device *dev,
 
 	fd->reg = reg;
 	fd->mshift = mshift;
-	fd->mmask = (BIT(mwidth) - 1) << mshift;
+	fd->mwidth = mwidth;
+	fd->mmask = GENMASK(mwidth - 1, 0) << mshift;
 	fd->nshift = nshift;
-	fd->nmask = (BIT(nwidth) - 1) << nshift;
+	fd->nwidth = nwidth;
+	fd->nmask = GENMASK(nwidth - 1, 0) << nshift;
 	fd->flags = clk_divider_flags;
 	fd->lock = lock;
 	fd->hw.init = &init;

commit f7f087c262771ab1d3be8b9c54266637f6136963
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 22 18:54:08 2015 +0300

    clk: fractional-divider: rename prate -> parent_rate
    
    Rename function parameter to be more explicit what it is for. This also makes
    it in align with struct clk_ops.
    
    There is no functional change.
    
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index e85f856b8592..1af9c1e85d83 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -50,18 +50,18 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 }
 
 static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
-			      unsigned long *prate)
+			      unsigned long *parent_rate)
 {
 	struct clk_fractional_divider *fd = to_clk_fd(hw);
 	unsigned maxn = (fd->nmask >> fd->nshift) + 1;
 	unsigned div;
 
-	if (!rate || rate >= *prate)
-		return *prate;
+	if (!rate || rate >= *parent_rate)
+		return *parent_rate;
 
-	div = gcd(*prate, rate);
+	div = gcd(*parent_rate, rate);
 
-	while ((*prate / div) > maxn) {
+	while ((*parent_rate / div) > maxn) {
 		div <<= 1;
 		rate <<= 1;
 	}

commit 661e2180cf050a2f859d466f30d74e990b9345be
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jul 24 12:21:12 2015 -0700

    clk: basic-type: Silence warnings about lock imbalances
    
    The basic clock types use conditional locking for the register
    accessor spinlocks. Add __acquire() and __release() markings in
    the right locations so that sparse isn't tripped up on the
    conditional locking.
    
    drivers/clk/clk-mux.c:68:12: warning: context imbalance in 'clk_mux_set_parent' - different lock contexts for basic block
    drivers/clk/clk-divider.c:379:12: warning: context imbalance in 'clk_divider_set_rate' - different lock contexts for basic block
    drivers/clk/clk-gate.c:71:9: warning: context imbalance in 'clk_gate_endisable' - different lock contexts for basic block
    drivers/clk/clk-fractional-divider.c:36:9: warning: context imbalance in 'clk_fd_recalc_rate' - different lock contexts for basic block
    drivers/clk/clk-fractional-divider.c:68:12: warning: context imbalance in 'clk_fd_set_rate' - different lock contexts for basic block
    
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 140eb5844dc4..e85f856b8592 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -27,11 +27,15 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 
 	if (fd->lock)
 		spin_lock_irqsave(fd->lock, flags);
+	else
+		__acquire(fd->lock);
 
 	val = clk_readl(fd->reg);
 
 	if (fd->lock)
 		spin_unlock_irqrestore(fd->lock, flags);
+	else
+		__release(fd->lock);
 
 	m = (val & fd->mmask) >> fd->mshift;
 	n = (val & fd->nmask) >> fd->nshift;
@@ -80,6 +84,8 @@ static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
 
 	if (fd->lock)
 		spin_lock_irqsave(fd->lock, flags);
+	else
+		__acquire(fd->lock);
 
 	val = clk_readl(fd->reg);
 	val &= ~(fd->mmask | fd->nmask);
@@ -88,6 +94,8 @@ static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
 
 	if (fd->lock)
 		spin_unlock_irqrestore(fd->lock, flags);
+	else
+		__release(fd->lock);
 
 	return 0;
 }

commit d122db7e86669244759226bfdd2b9d623d5c6ae8
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu May 14 16:47:10 2015 -0700

    clk: basic-types: Remove useless allocation failure printks
    
    Printing an error on kmalloc() failures is unnecessary. Remove
    the print and use *ptr in sizeof() for future-proof code.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 6aa72d9d79ba..140eb5844dc4 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -109,10 +109,8 @@ struct clk *clk_register_fractional_divider(struct device *dev,
 	struct clk *clk;
 
 	fd = kzalloc(sizeof(*fd), GFP_KERNEL);
-	if (!fd) {
-		dev_err(dev, "could not allocate fractional divider clk\n");
+	if (!fd)
 		return ERR_PTR(-ENOMEM);
-	}
 
 	init.name = name;
 	init.ops = &clk_fractional_divider_ops;

commit 6b54783620bcfaff37ad41e957d29c326211cc18
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 2 15:37:04 2015 +0200

    clk: fractional-divider: support for divider bypassing
    
    If the divider or multiplier values are 0 in the register, bypassing the
    divider and returning the parent clock rate in clk_fd_recalc_rate().
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: fixed commitlog typo]

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index 82a59d0086cc..6aa72d9d79ba 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -36,6 +36,9 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 	m = (val & fd->mmask) >> fd->mshift;
 	n = (val & fd->nmask) >> fd->nshift;
 
+	if (!n || !m)
+		return parent_rate;
+
 	ret = (u64)parent_rate * m;
 	do_div(ret, n);
 

commit feaefa0ea1f1ab3fb92519aef2099ab4d75cce05
Author: Heiko St√ºbner <heiko@sntech.de>
Date:   Thu Aug 28 12:46:10 2014 +0200

    clk: fractional-divider: cast parent_rate to u64 before multiplying
    
    On 32bit architectures, like ARM calculating the fractional rate will
    do the multiplication before converting the value to u64 when it gets
    assigned to ret, which can produce overflows.
    
    The error in question happened with a parent_rate of 386MHz, m = 3000,
    n = 60000, which resulted in a wrong rate value of 15812Hz.
    
    Therefore cast parent_rate to u64 to make sure the multiplication
    happens in a 64bit space and produces the correct 192MHz in the example.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
index ede685ca0d20..82a59d0086cc 100644
--- a/drivers/clk/clk-fractional-divider.c
+++ b/drivers/clk/clk-fractional-divider.c
@@ -36,7 +36,7 @@ static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
 	m = (val & fd->mmask) >> fd->mshift;
 	n = (val & fd->nmask) >> fd->nshift;
 
-	ret = parent_rate * m;
+	ret = (u64)parent_rate * m;
 	do_div(ret, n);
 
 	return ret;

commit e2d0e90fae82809667f1dcf4d0d9baa421691c7a
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu May 15 16:40:25 2014 +0300

    clk: new basic clk type for fractional divider
    
    Fractional divider clocks are fairly common. This adds basic
    type for them.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/clk/clk-fractional-divider.c b/drivers/clk/clk-fractional-divider.c
new file mode 100644
index 000000000000..ede685ca0d20
--- /dev/null
+++ b/drivers/clk/clk-fractional-divider.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2014 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable fractional divider clock implementation.
+ * Output rate = (m / n) * parent_rate.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/gcd.h>
+
+#define to_clk_fd(_hw) container_of(_hw, struct clk_fractional_divider, hw)
+
+static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct clk_fractional_divider *fd = to_clk_fd(hw);
+	unsigned long flags = 0;
+	u32 val, m, n;
+	u64 ret;
+
+	if (fd->lock)
+		spin_lock_irqsave(fd->lock, flags);
+
+	val = clk_readl(fd->reg);
+
+	if (fd->lock)
+		spin_unlock_irqrestore(fd->lock, flags);
+
+	m = (val & fd->mmask) >> fd->mshift;
+	n = (val & fd->nmask) >> fd->nshift;
+
+	ret = parent_rate * m;
+	do_div(ret, n);
+
+	return ret;
+}
+
+static long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long *prate)
+{
+	struct clk_fractional_divider *fd = to_clk_fd(hw);
+	unsigned maxn = (fd->nmask >> fd->nshift) + 1;
+	unsigned div;
+
+	if (!rate || rate >= *prate)
+		return *prate;
+
+	div = gcd(*prate, rate);
+
+	while ((*prate / div) > maxn) {
+		div <<= 1;
+		rate <<= 1;
+	}
+
+	return rate;
+}
+
+static int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,
+			   unsigned long parent_rate)
+{
+	struct clk_fractional_divider *fd = to_clk_fd(hw);
+	unsigned long flags = 0;
+	unsigned long div;
+	unsigned n, m;
+	u32 val;
+
+	div = gcd(parent_rate, rate);
+	m = rate / div;
+	n = parent_rate / div;
+
+	if (fd->lock)
+		spin_lock_irqsave(fd->lock, flags);
+
+	val = clk_readl(fd->reg);
+	val &= ~(fd->mmask | fd->nmask);
+	val |= (m << fd->mshift) | (n << fd->nshift);
+	clk_writel(val, fd->reg);
+
+	if (fd->lock)
+		spin_unlock_irqrestore(fd->lock, flags);
+
+	return 0;
+}
+
+const struct clk_ops clk_fractional_divider_ops = {
+	.recalc_rate = clk_fd_recalc_rate,
+	.round_rate = clk_fd_round_rate,
+	.set_rate = clk_fd_set_rate,
+};
+EXPORT_SYMBOL_GPL(clk_fractional_divider_ops);
+
+struct clk *clk_register_fractional_divider(struct device *dev,
+		const char *name, const char *parent_name, unsigned long flags,
+		void __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,
+		u8 clk_divider_flags, spinlock_t *lock)
+{
+	struct clk_fractional_divider *fd;
+	struct clk_init_data init;
+	struct clk *clk;
+
+	fd = kzalloc(sizeof(*fd), GFP_KERNEL);
+	if (!fd) {
+		dev_err(dev, "could not allocate fractional divider clk\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = &clk_fractional_divider_ops;
+	init.flags = flags | CLK_IS_BASIC;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+
+	fd->reg = reg;
+	fd->mshift = mshift;
+	fd->mmask = (BIT(mwidth) - 1) << mshift;
+	fd->nshift = nshift;
+	fd->nmask = (BIT(nwidth) - 1) << nshift;
+	fd->flags = clk_divider_flags;
+	fd->lock = lock;
+	fd->hw.init = &init;
+
+	clk = clk_register(dev, &fd->hw);
+	if (IS_ERR(clk))
+		kfree(fd);
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(clk_register_fractional_divider);
