commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
index af8ca5019639..277a240b65a1 100644
--- a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
+++ b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright 2015 Maxime Ripard
  *
  * Maxime Ripard <maxime.ripard@free-electrons.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/clk-provider.h>

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
index b6d29d1bedca..af8ca5019639 100644
--- a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
+++ b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
@@ -15,6 +15,7 @@
  */
 
 #include <linux/clk-provider.h>
+#include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/slab.h>

commit 9ca91a65583c73e4be6e9f53323a7ae04e6803ef
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 15 17:55:23 2016 +0200

    clk: sunxi: remove unused variable
    
    The only use of the local num_parents variable was remove,
    so we now get a warning:
    
    drivers/clk/sunxi/clk-sun4i-tcon-ch1.c: In function 'tcon_ch1_get_parent':
    drivers/clk/sunxi/clk-sun4i-tcon-ch1.c:82:6: error: unused variable 'num_parents' [-Werror=unused-variable]
    
    This removes the variable.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 4de2d58bc973 ("clk: sunxi: tcon-ch1: Do not return a negative error in get_parent")
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
index 248585238b1c..b6d29d1bedca 100644
--- a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
+++ b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
@@ -79,7 +79,6 @@ static int tcon_ch1_is_enabled(struct clk_hw *hw)
 static u8 tcon_ch1_get_parent(struct clk_hw *hw)
 {
 	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
-	int num_parents = clk_hw_get_num_parents(hw);
 	u32 reg;
 
 	reg = readl(tclk->reg) >> TCON_CH1_SCLK2_MUX_SHIFT;

commit 4de2d58bc973caa8988b44ddd11787e57051c843
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Wed May 11 20:57:44 2016 +0200

    clk: sunxi: tcon-ch1: Do not return a negative error in get_parent
    
    get_parent is supposed to return an unsigned 8 bit integer, so returning
    -EINVAL is a bad idea.
    
    Remove it.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
index 98a4582de56a..248585238b1c 100644
--- a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
+++ b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
@@ -85,9 +85,6 @@ static u8 tcon_ch1_get_parent(struct clk_hw *hw)
 	reg = readl(tclk->reg) >> TCON_CH1_SCLK2_MUX_SHIFT;
 	reg &= reg >> TCON_CH1_SCLK2_MUX_MASK;
 
-	if (reg >= num_parents)
-		return -EINVAL;
-
 	return reg;
 }
 

commit cc510c736b1b278a9925a4a051ecfa72ef8c21fc
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Wed Jul 1 15:48:37 2015 +0200

    clk: sunxi: Add TCON channel1 clock
    
    The TCON is a controller generating the timings to output videos signals,
    acting like both a CRTC and an encoder.
    
    It has two channels depending on the output, each channel being driven by
    its own clock (and own clock controller).
    
    Add a driver for the channel 1 clock.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
new file mode 100644
index 000000000000..98a4582de56a
--- /dev/null
+++ b/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright 2015 Maxime Ripard
+ *
+ * Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#define TCON_CH1_SCLK2_PARENTS		4
+
+#define TCON_CH1_SCLK2_GATE_BIT		BIT(31)
+#define TCON_CH1_SCLK2_MUX_MASK		3
+#define TCON_CH1_SCLK2_MUX_SHIFT	24
+#define TCON_CH1_SCLK2_DIV_MASK		0xf
+#define TCON_CH1_SCLK2_DIV_SHIFT	0
+
+#define TCON_CH1_SCLK1_GATE_BIT		BIT(15)
+#define TCON_CH1_SCLK1_HALF_BIT		BIT(11)
+
+struct tcon_ch1_clk {
+	struct clk_hw	hw;
+	spinlock_t	lock;
+	void __iomem	*reg;
+};
+
+#define hw_to_tclk(hw)	container_of(hw, struct tcon_ch1_clk, hw)
+
+static void tcon_ch1_disable(struct clk_hw *hw)
+{
+	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&tclk->lock, flags);
+	reg = readl(tclk->reg);
+	reg &= ~(TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT);
+	writel(reg, tclk->reg);
+	spin_unlock_irqrestore(&tclk->lock, flags);
+}
+
+static int tcon_ch1_enable(struct clk_hw *hw)
+{
+	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&tclk->lock, flags);
+	reg = readl(tclk->reg);
+	reg |= TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT;
+	writel(reg, tclk->reg);
+	spin_unlock_irqrestore(&tclk->lock, flags);
+
+	return 0;
+}
+
+static int tcon_ch1_is_enabled(struct clk_hw *hw)
+{
+	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
+	u32 reg;
+
+	reg = readl(tclk->reg);
+	return reg & (TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT);
+}
+
+static u8 tcon_ch1_get_parent(struct clk_hw *hw)
+{
+	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
+	int num_parents = clk_hw_get_num_parents(hw);
+	u32 reg;
+
+	reg = readl(tclk->reg) >> TCON_CH1_SCLK2_MUX_SHIFT;
+	reg &= reg >> TCON_CH1_SCLK2_MUX_MASK;
+
+	if (reg >= num_parents)
+		return -EINVAL;
+
+	return reg;
+}
+
+static int tcon_ch1_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&tclk->lock, flags);
+	reg = readl(tclk->reg);
+	reg &= ~(TCON_CH1_SCLK2_MUX_MASK << TCON_CH1_SCLK2_MUX_SHIFT);
+	reg |= index << TCON_CH1_SCLK2_MUX_SHIFT;
+	writel(reg, tclk->reg);
+	spin_unlock_irqrestore(&tclk->lock, flags);
+
+	return 0;
+};
+
+static unsigned long tcon_ch1_calc_divider(unsigned long rate,
+					   unsigned long parent_rate,
+					   u8 *div,
+					   bool *half)
+{
+	unsigned long best_rate = 0;
+	u8 best_m = 0, m;
+	bool is_double;
+
+	for (m = 1; m < 16; m++) {
+		u8 d;
+
+		for (d = 1; d < 3; d++) {
+			unsigned long tmp_rate;
+
+			tmp_rate = parent_rate / m / d;
+
+			if (tmp_rate > rate)
+				continue;
+
+			if (!best_rate ||
+			    (rate - tmp_rate) < (rate - best_rate)) {
+				best_rate = tmp_rate;
+				best_m = m;
+				is_double = d;
+			}
+		}
+	}
+
+	if (div && half) {
+		*div = best_m;
+		*half = is_double;
+	}
+
+	return best_rate;
+}
+
+static int tcon_ch1_determine_rate(struct clk_hw *hw,
+				   struct clk_rate_request *req)
+{
+	long best_rate = -EINVAL;
+	int i;
+
+	for (i = 0; i < clk_hw_get_num_parents(hw); i++) {
+		unsigned long parent_rate;
+		unsigned long tmp_rate;
+		struct clk_hw *parent;
+
+		parent = clk_hw_get_parent_by_index(hw, i);
+		if (!parent)
+			continue;
+
+		parent_rate = clk_hw_get_rate(parent);
+
+		tmp_rate = tcon_ch1_calc_divider(req->rate, parent_rate,
+						 NULL, NULL);
+
+		if (best_rate < 0 ||
+		    (req->rate - tmp_rate) < (req->rate - best_rate)) {
+			best_rate = tmp_rate;
+			req->best_parent_rate = parent_rate;
+			req->best_parent_hw = parent;
+		}
+	}
+
+	if (best_rate < 0)
+		return best_rate;
+
+	req->rate = best_rate;
+	return 0;
+}
+
+static unsigned long tcon_ch1_recalc_rate(struct clk_hw *hw,
+					  unsigned long parent_rate)
+{
+	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
+	u32 reg;
+
+	reg = readl(tclk->reg);
+
+	parent_rate /= (reg & TCON_CH1_SCLK2_DIV_MASK) + 1;
+
+	if (reg & TCON_CH1_SCLK1_HALF_BIT)
+		parent_rate /= 2;
+
+	return parent_rate;
+}
+
+static int tcon_ch1_set_rate(struct clk_hw *hw, unsigned long rate,
+			     unsigned long parent_rate)
+{
+	struct tcon_ch1_clk *tclk = hw_to_tclk(hw);
+	unsigned long flags;
+	bool half;
+	u8 div_m;
+	u32 reg;
+
+	tcon_ch1_calc_divider(rate, parent_rate, &div_m, &half);
+
+	spin_lock_irqsave(&tclk->lock, flags);
+	reg = readl(tclk->reg);
+	reg &= ~(TCON_CH1_SCLK2_DIV_MASK | TCON_CH1_SCLK1_HALF_BIT);
+	reg |= (div_m - 1) & TCON_CH1_SCLK2_DIV_MASK;
+
+	if (half)
+		reg |= TCON_CH1_SCLK1_HALF_BIT;
+
+	writel(reg, tclk->reg);
+	spin_unlock_irqrestore(&tclk->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops tcon_ch1_ops = {
+	.disable	= tcon_ch1_disable,
+	.enable		= tcon_ch1_enable,
+	.is_enabled	= tcon_ch1_is_enabled,
+
+	.get_parent	= tcon_ch1_get_parent,
+	.set_parent	= tcon_ch1_set_parent,
+
+	.determine_rate	= tcon_ch1_determine_rate,
+	.recalc_rate	= tcon_ch1_recalc_rate,
+	.set_rate	= tcon_ch1_set_rate,
+};
+
+static void __init tcon_ch1_setup(struct device_node *node)
+{
+	const char *parents[TCON_CH1_SCLK2_PARENTS];
+	const char *clk_name = node->name;
+	struct clk_init_data init;
+	struct tcon_ch1_clk *tclk;
+	struct resource res;
+	struct clk *clk;
+	void __iomem *reg;
+	int ret;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	reg = of_io_request_and_map(node, 0, of_node_full_name(node));
+	if (IS_ERR(reg)) {
+		pr_err("%s: Could not map the clock registers\n", clk_name);
+		return;
+	}
+
+	ret = of_clk_parent_fill(node, parents, TCON_CH1_SCLK2_PARENTS);
+	if (ret != TCON_CH1_SCLK2_PARENTS) {
+		pr_err("%s Could not retrieve the parents\n", clk_name);
+		goto err_unmap;
+	}
+
+	tclk = kzalloc(sizeof(*tclk), GFP_KERNEL);
+	if (!tclk)
+		goto err_unmap;
+
+	init.name = clk_name;
+	init.ops = &tcon_ch1_ops;
+	init.parent_names = parents;
+	init.num_parents = TCON_CH1_SCLK2_PARENTS;
+	init.flags = CLK_SET_RATE_PARENT;
+
+	tclk->reg = reg;
+	tclk->hw.init = &init;
+	spin_lock_init(&tclk->lock);
+
+	clk = clk_register(NULL, &tclk->hw);
+	if (IS_ERR(clk)) {
+		pr_err("%s: Couldn't register the clock\n", clk_name);
+		goto err_free_data;
+	}
+
+	ret = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	if (ret) {
+		pr_err("%s: Couldn't register our clock provider\n", clk_name);
+		goto err_unregister_clk;
+	}
+
+	return;
+
+err_unregister_clk:
+	clk_unregister(clk);
+err_free_data:
+	kfree(tclk);
+err_unmap:
+	iounmap(reg);
+	of_address_to_resource(node, 0, &res);
+	release_mem_region(res.start, resource_size(&res));
+}
+
+CLK_OF_DECLARE(tcon_ch1, "allwinner,sun4i-a10-tcon-ch1-clk",
+	       tcon_ch1_setup);
