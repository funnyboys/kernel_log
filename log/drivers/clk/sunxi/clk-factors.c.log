commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 661a73284e9f..4d8f0422b876 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2013 Emilio López <emilio@elopez.com.ar>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Adjustable factor-based clock implementation
  */
 

commit 9919d44ff2977d4da709282fa0ebedddaa3b8d85
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jan 2 16:50:27 2018 -0800

    clk: sunxi: Use CLK_IS_CRITICAL flag for critical clks
    
    We'd like to privatize __clk_get(), but the sunxi clk driver is
    calling this function to keep a reference held on the clk and
    call clk_prepare_enable() on it. We support this design in the
    clk core now with the CLK_IS_CRITICAL flag, so let's just use
    that instead.
    
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 856fef65433b..661a73284e9f 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -176,10 +176,10 @@ static const struct clk_ops clk_factors_ops = {
 	.set_rate = clk_factors_set_rate,
 };
 
-struct clk *sunxi_factors_register(struct device_node *node,
-				   const struct factors_data *data,
-				   spinlock_t *lock,
-				   void __iomem *reg)
+static struct clk *__sunxi_factors_register(struct device_node *node,
+					    const struct factors_data *data,
+					    spinlock_t *lock, void __iomem *reg,
+					    unsigned long flags)
 {
 	struct clk *clk;
 	struct clk_factors *factors;
@@ -249,7 +249,7 @@ struct clk *sunxi_factors_register(struct device_node *node,
 			parents, i,
 			mux_hw, &clk_mux_ops,
 			&factors->hw, &clk_factors_ops,
-			gate_hw, &clk_gate_ops, 0);
+			gate_hw, &clk_gate_ops, CLK_IS_CRITICAL);
 	if (IS_ERR(clk))
 		goto err_register;
 
@@ -272,6 +272,22 @@ struct clk *sunxi_factors_register(struct device_node *node,
 	return NULL;
 }
 
+struct clk *sunxi_factors_register(struct device_node *node,
+				   const struct factors_data *data,
+				   spinlock_t *lock,
+				   void __iomem *reg)
+{
+	return __sunxi_factors_register(node, data, lock, reg, 0);
+}
+
+struct clk *sunxi_factors_register_critical(struct device_node *node,
+					    const struct factors_data *data,
+					    spinlock_t *lock,
+					    void __iomem *reg)
+{
+	return __sunxi_factors_register(node, data, lock, reg, CLK_IS_CRITICAL);
+}
+
 void sunxi_factors_unregister(struct device_node *node, struct clk *clk)
 {
 	struct clk_hw *hw = __clk_get_hw(clk);

commit 02e0114ae1eb776b22f0744762fb0137208c4850
Author: Corentin LABBE <clabbe.montjoie@gmail.com>
Date:   Tue Oct 24 19:06:16 2017 +0200

    clk: sunxi: fix build warning
    
    This patch fix the following build warning:
    drivers/clk/sunxi/clk-factors.c:279:14: warning: variable 'name' set but not used [-Wunused-but-set-variable]
    
    Fixes: 4cbeaebb8af1 ("clk: sunxi: factors: Add unregister function")
    
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index dfe5e3e32d28..856fef65433b 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -276,13 +276,11 @@ void sunxi_factors_unregister(struct device_node *node, struct clk *clk)
 {
 	struct clk_hw *hw = __clk_get_hw(clk);
 	struct clk_factors *factors;
-	const char *name;
 
 	if (!hw)
 		return;
 
 	factors = to_clk_factors(hw);
-	name = clk_hw_get_name(hw);
 
 	of_clk_del_provider(node);
 	/* TODO: The composite clock stuff will leak a bit here. */

commit 439a36d7d9318c2709066d853720bd77f201033a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jul 4 17:12:18 2016 -0400

    clk: sunxi: make clk-* explicitly non-modular
    
    We have the following file --> Kconfig mapping:
    
    sunxi/clk-factors.c              obj-y
    sunxi/clk-sun6i-apb0-gates.c     CONFIG_MFD_SUN6I_PRCM (bool)
    sunxi/clk-sun6i-apb0.c           CONFIG_MFD_SUN6I_PRCM
    sunxi/clk-sun6i-ar100.c          CONFIG_MFD_SUN6I_PRCM
    sunxi/clk-sun8i-apb0.c           CONFIG_MFD_SUN6I_PRCM
    sunxi/clk-sun9i-mmc.c            obj-y
    
    Hence none of these are being built as a module by anyone.
    
    Lets remove the modular code that is essentially orphaned, so that
    when reading the drivers there is no doubt they are builtin-only.  All
    drivers get mostly the same changes, so they are handled in batch.
    
    Changes are (1) convert to builtin_platform_register, (2) use the
    init.h header, (3) delete the MODULE_LICENCE/MODULE_AUTHOR and
    associated tags, and (4) delete any ".remove" functions.
    
    There was a stray module.h in a file not using any init.h or
    module.h stuff, so we simply removed that one.
    
    In two cases, we explicitly disallow a driver unbind, since that
    doesn't have a sensible use case anyway, and it allows us to drop
    the ".remove" code for non-modular drivers.
    
    Since module_platform_driver() uses the same init level priority as
    builtin_platform_driver() the init ordering remains unchanged with
    this commit.
    
    We delete the MODULE_LICENSE etc. tags since all that information
    is already contained at the top of each file in the comments.
    
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: "Emilio López" <emilio@elopez.com.ar>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: linux-clk@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20160704211220.5685-9-paul.gortmaker@windriver.com

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index ddefe9668863..dfe5e3e32d28 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -12,7 +12,6 @@
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/io.h>
-#include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/slab.h>
 #include <linux/string.h>

commit b0b6413f0dc8d1faba98745cf3a008ed9493df59
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Tue Feb 2 09:37:15 2016 +0100

    clk: sunxi: Remove clk_register_clkdev calls
    
    Now that our protection code doesn't use the global name lookup anymore, we
    can remove the clkdev registrations.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 6e97f46c0c37..ddefe9668863 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -258,14 +258,8 @@ struct clk *sunxi_factors_register(struct device_node *node,
 	if (ret)
 		goto err_provider;
 
-	ret = clk_register_clkdev(clk, clk_name, NULL);
-	if (ret)
-		goto err_clkdev;
-
 	return clk;
 
-err_clkdev:
-	of_clk_del_provider(node);
 err_provider:
 	/* TODO: The composite clock stuff will leak a bit here. */
 	clk_unregister(clk);
@@ -291,7 +285,6 @@ void sunxi_factors_unregister(struct device_node *node, struct clk *clk)
 	factors = to_clk_factors(hw);
 	name = clk_hw_get_name(hw);
 
-	/* No unregister call for clkdev_* */
 	of_clk_del_provider(node);
 	/* TODO: The composite clock stuff will leak a bit here. */
 	clk_unregister(clk);

commit 50d6ea47bab46645f28c439d9d8fb4840e10b486
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Mon Jan 25 21:15:44 2016 +0800

    clk: sunxi: factors: Drop round_rate from clk ops
    
    The common clock framework requires either determine_rate or round_rate
    to be implemented. We use determine_rate so we can pass the parent index
    to the get_factors callback. This cannot be done easily with round_rate,
    so just drop it.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 2927b09d5e0d..6e97f46c0c37 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -89,21 +89,6 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 	return rate;
 }
 
-static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
-				   unsigned long *parent_rate)
-{
-	struct clk_factors *factors = to_clk_factors(hw);
-	struct factors_request req = {
-		.rate = rate,
-		.parent_rate = *parent_rate,
-	};
-
-	factors->get_factors(&req);
-
-
-	return rate;
-}
-
 static int clk_factors_determine_rate(struct clk_hw *hw,
 				      struct clk_rate_request *req)
 {
@@ -189,7 +174,6 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 static const struct clk_ops clk_factors_ops = {
 	.determine_rate = clk_factors_determine_rate,
 	.recalc_rate = clk_factors_recalc_rate,
-	.round_rate = clk_factors_round_rate,
 	.set_rate = clk_factors_set_rate,
 };
 

commit 435b7be1d812cdbbad997f5279293770dff21abb
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Mon Jan 25 21:15:43 2016 +0800

    clk: sunxi: factors: Support custom formulas
    
    Some clocks cannot be modelled using the standard factors clk formula,
    such as clocks with special pre-dividers on one parent, or clocks
    with all power-of-two dividers.
    
    Add support for a custom .recalc callback for factors clk. Also pass
    the current parent index to the .get_factor and .recalc callbacks.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 4a8e36a53287..2927b09d5e0d 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -63,6 +63,26 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 	if (config->pwidth != SUNXI_FACTORS_NOT_APPLICABLE)
 		p = FACTOR_GET(config->pshift, config->pwidth, reg);
 
+	if (factors->recalc) {
+		struct factors_request factors_req = {
+			.parent_rate = parent_rate,
+			.n = n,
+			.k = k,
+			.m = m,
+			.p = p,
+		};
+
+		/* get mux details from mux clk structure */
+		if (factors->mux)
+			factors_req.parent_index =
+				(reg >> factors->mux->shift) &
+				factors->mux->mask;
+
+		factors->recalc(&factors_req);
+
+		return factors_req.rate;
+	}
+
 	/* Calculate the rate */
 	rate = (parent_rate * (n + config->n_start) * (k + 1) >> p) / (m + 1);
 
@@ -87,6 +107,7 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 static int clk_factors_determine_rate(struct clk_hw *hw,
 				      struct clk_rate_request *req)
 {
+	struct clk_factors *factors = to_clk_factors(hw);
 	struct clk_hw *parent, *best_parent = NULL;
 	int i, num_parents;
 	unsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;
@@ -94,6 +115,10 @@ static int clk_factors_determine_rate(struct clk_hw *hw,
 	/* find the parent that can help provide the fastest rate <= rate */
 	num_parents = clk_hw_get_num_parents(hw);
 	for (i = 0; i < num_parents; i++) {
+		struct factors_request factors_req = {
+			.rate = req->rate,
+			.parent_index = i,
+		};
 		parent = clk_hw_get_parent_by_index(hw, i);
 		if (!parent)
 			continue;
@@ -102,8 +127,9 @@ static int clk_factors_determine_rate(struct clk_hw *hw,
 		else
 			parent_rate = clk_hw_get_rate(parent);
 
-		child_rate = clk_factors_round_rate(hw, req->rate,
-						    &parent_rate);
+		factors_req.parent_rate = parent_rate;
+		factors->get_factors(&factors_req);
+		child_rate = factors_req.rate;
 
 		if (child_rate <= req->rate && child_rate > best_child_rate) {
 			best_parent = parent;
@@ -202,6 +228,7 @@ struct clk *sunxi_factors_register(struct device_node *node,
 	factors->reg = reg;
 	factors->config = data->table;
 	factors->get_factors = data->getter;
+	factors->recalc = data->recalc;
 	factors->lock = lock;
 
 	/* Add a gate if this factor clock can be gated */

commit cfa63688603398e8de4315cd626f81516c88a4c4
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Mon Jan 25 21:15:42 2016 +0800

    clk: sunxi: factors: Consolidate get_factors parameters into a struct
    
    The .get_factors callback of factors_clk has 6 parameters. To extend
    factors_clk in any way that requires adding parameters to .get_factors
    would make that list even longer, not to mention changing all the
    function declarations.
    
    Do this once now and consolidate all the parameters into a struct.
    Also drop the space before function pointer arguments, since checkpatch
    complains.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index a6571177a5c4..4a8e36a53287 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -73,8 +73,13 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 				   unsigned long *parent_rate)
 {
 	struct clk_factors *factors = to_clk_factors(hw);
-	factors->get_factors((u32 *)&rate, (u32)*parent_rate,
-			     NULL, NULL, NULL, NULL);
+	struct factors_request req = {
+		.rate = rate,
+		.parent_rate = *parent_rate,
+	};
+
+	factors->get_factors(&req);
+
 
 	return rate;
 }
@@ -120,13 +125,16 @@ static int clk_factors_determine_rate(struct clk_hw *hw,
 static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long parent_rate)
 {
-	u8 n = 0, k = 0, m = 0, p = 0;
+	struct factors_request req = {
+		.rate = rate,
+		.parent_rate = parent_rate,
+	};
 	u32 reg;
 	struct clk_factors *factors = to_clk_factors(hw);
 	const struct clk_factors_config *config = factors->config;
 	unsigned long flags = 0;
 
-	factors->get_factors((u32 *)&rate, (u32)parent_rate, &n, &k, &m, &p);
+	factors->get_factors(&req);
 
 	if (factors->lock)
 		spin_lock_irqsave(factors->lock, flags);
@@ -135,10 +143,10 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 	reg = readl(factors->reg);
 
 	/* Set up the new factors - macros do not do anything if width is 0 */
-	reg = FACTOR_SET(config->nshift, config->nwidth, reg, n);
-	reg = FACTOR_SET(config->kshift, config->kwidth, reg, k);
-	reg = FACTOR_SET(config->mshift, config->mwidth, reg, m);
-	reg = FACTOR_SET(config->pshift, config->pwidth, reg, p);
+	reg = FACTOR_SET(config->nshift, config->nwidth, reg, req.n);
+	reg = FACTOR_SET(config->kshift, config->kwidth, reg, req.k);
+	reg = FACTOR_SET(config->mshift, config->mwidth, reg, req.m);
+	reg = FACTOR_SET(config->pshift, config->pwidth, reg, req.p);
 
 	/* Apply them now */
 	writel(reg, factors->reg);

commit 4cbeaebb8af1c86691d1a2d3328d82a01f4380a5
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Mon Jan 25 21:15:40 2016 +0800

    clk: sunxi: factors: Add unregister function
    
    sunxi's factors clk did not have an unregister function. This means
    multiple structs were leaked whenever a factors clk was unregistered.
    
    Add an unregister function for it. Also keep pointers to the mux and
    gate structs so they can be freed.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 3a18abfb6e09..a6571177a5c4 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -202,6 +202,8 @@ struct clk *sunxi_factors_register(struct device_node *node,
 		if (!gate)
 			goto err_gate;
 
+		factors->gate = gate;
+
 		/* set up gate properties */
 		gate->reg = reg;
 		gate->bit_idx = data->enable;
@@ -215,6 +217,8 @@ struct clk *sunxi_factors_register(struct device_node *node,
 		if (!mux)
 			goto err_mux;
 
+		factors->mux = mux;
+
 		/* set up gate properties */
 		mux->reg = reg;
 		mux->shift = data->mux;
@@ -255,3 +259,24 @@ struct clk *sunxi_factors_register(struct device_node *node,
 err_factors:
 	return NULL;
 }
+
+void sunxi_factors_unregister(struct device_node *node, struct clk *clk)
+{
+	struct clk_hw *hw = __clk_get_hw(clk);
+	struct clk_factors *factors;
+	const char *name;
+
+	if (!hw)
+		return;
+
+	factors = to_clk_factors(hw);
+	name = clk_hw_get_name(hw);
+
+	/* No unregister call for clkdev_* */
+	of_clk_del_provider(node);
+	/* TODO: The composite clock stuff will leak a bit here. */
+	clk_unregister(clk);
+	kfree(factors->mux);
+	kfree(factors->gate);
+	kfree(factors);
+}

commit 78ca95c76900e7587d6e076f8162a440f19431ae
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Mon Jan 25 21:15:39 2016 +0800

    clk: sunxi: factors: Add clk cleanup in sunxi_factors_register() error path
    
    sunxi_factors_register() does not check for failures or cleanup after
    clk_register_composite() or other clk-related calls.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 928c079da193..3a18abfb6e09 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -172,7 +172,7 @@ struct clk *sunxi_factors_register(struct device_node *node,
 	struct clk_hw *mux_hw = NULL;
 	const char *clk_name = node->name;
 	const char *parents[FACTORS_MAX_PARENTS];
-	int i = 0;
+	int ret, i = 0;
 
 	/* if we have a mux, we will have >1 parents */
 	i = of_clk_parent_fill(node, parents, FACTORS_MAX_PARENTS);
@@ -188,7 +188,7 @@ struct clk *sunxi_factors_register(struct device_node *node,
 
 	factors = kzalloc(sizeof(struct clk_factors), GFP_KERNEL);
 	if (!factors)
-		return NULL;
+		goto err_factors;
 
 	/* set up factors properties */
 	factors->reg = reg;
@@ -199,10 +199,8 @@ struct clk *sunxi_factors_register(struct device_node *node,
 	/* Add a gate if this factor clock can be gated */
 	if (data->enable) {
 		gate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);
-		if (!gate) {
-			kfree(factors);
-			return NULL;
-		}
+		if (!gate)
+			goto err_gate;
 
 		/* set up gate properties */
 		gate->reg = reg;
@@ -214,11 +212,8 @@ struct clk *sunxi_factors_register(struct device_node *node,
 	/* Add a mux if this factor clock can be muxed */
 	if (data->mux) {
 		mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
-		if (!mux) {
-			kfree(factors);
-			kfree(gate);
-			return NULL;
-		}
+		if (!mux)
+			goto err_mux;
 
 		/* set up gate properties */
 		mux->reg = reg;
@@ -233,11 +228,30 @@ struct clk *sunxi_factors_register(struct device_node *node,
 			mux_hw, &clk_mux_ops,
 			&factors->hw, &clk_factors_ops,
 			gate_hw, &clk_gate_ops, 0);
+	if (IS_ERR(clk))
+		goto err_register;
 
-	if (!IS_ERR(clk)) {
-		of_clk_add_provider(node, of_clk_src_simple_get, clk);
-		clk_register_clkdev(clk, clk_name, NULL);
-	}
+	ret = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	if (ret)
+		goto err_provider;
+
+	ret = clk_register_clkdev(clk, clk_name, NULL);
+	if (ret)
+		goto err_clkdev;
 
 	return clk;
+
+err_clkdev:
+	of_clk_del_provider(node);
+err_provider:
+	/* TODO: The composite clock stuff will leak a bit here. */
+	clk_unregister(clk);
+err_register:
+	kfree(mux);
+err_mux:
+	kfree(gate);
+err_gate:
+	kfree(factors);
+err_factors:
+	return NULL;
 }

commit b3e919e03ce84d9768c0e1c12066f502c5bbd485
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Mon Jan 25 21:15:38 2016 +0800

    clk: sunxi: factors: Make struct clk_factors_config table const
    
    struct clk_factors_config contains shifts/widths for the factors of
    the factors clk. This is used to read out the factors from the register
    value. In no case is it written to, so make it const.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 59428dbd607a..928c079da193 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -48,7 +48,7 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 	u32 reg;
 	unsigned long rate;
 	struct clk_factors *factors = to_clk_factors(hw);
-	struct clk_factors_config *config = factors->config;
+	const struct clk_factors_config *config = factors->config;
 
 	/* Fetch the register value */
 	reg = readl(factors->reg);
@@ -123,7 +123,7 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 	u8 n = 0, k = 0, m = 0, p = 0;
 	u32 reg;
 	struct clk_factors *factors = to_clk_factors(hw);
-	struct clk_factors_config *config = factors->config;
+	const struct clk_factors_config *config = factors->config;
 	unsigned long flags = 0;
 
 	factors->get_factors((u32 *)&rate, (u32)parent_rate, &n, &k, &m, &p);

commit 1b14afa64d2ef36f228e9540664586fd7ad67a81
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 30 17:20:57 2015 -0700

    clk: sunxi: Convert to clk_hw based provider APIs
    
    We're removing struct clk from the clk provider API, so switch
    this code to using the clk_hw based provider APIs.
    
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: "Emilio López" <emilio@elopez.com.ar>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index b8c3ee5688f4..59428dbd607a 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -82,20 +82,20 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 static int clk_factors_determine_rate(struct clk_hw *hw,
 				      struct clk_rate_request *req)
 {
-	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
+	struct clk_hw *parent, *best_parent = NULL;
 	int i, num_parents;
 	unsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;
 
 	/* find the parent that can help provide the fastest rate <= rate */
 	num_parents = clk_hw_get_num_parents(hw);
 	for (i = 0; i < num_parents; i++) {
-		parent = clk_get_parent_by_index(clk, i);
+		parent = clk_hw_get_parent_by_index(hw, i);
 		if (!parent)
 			continue;
 		if (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)
-			parent_rate = __clk_round_rate(parent, req->rate);
+			parent_rate = clk_hw_round_rate(parent, req->rate);
 		else
-			parent_rate = __clk_get_rate(parent);
+			parent_rate = clk_hw_get_rate(parent);
 
 		child_rate = clk_factors_round_rate(hw, req->rate,
 						    &parent_rate);
@@ -110,7 +110,7 @@ static int clk_factors_determine_rate(struct clk_hw *hw,
 	if (!best_parent)
 		return -EINVAL;
 
-	req->best_parent_hw = __clk_get_hw(best_parent);
+	req->best_parent_hw = best_parent;
 	req->best_parent_rate = best;
 	req->rate = best_child_rate;
 

commit 98d8a60eccee74165793379f1f8a3b1cef3131c7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jun 29 16:56:30 2015 -0700

    clk: Convert __clk_get_flags() to clk_hw_get_flags()
    
    Mostly converted with the following snippet:
    
    @@
    struct clk_hw *E;
    @@
    
    -__clk_get_flags(E->clk)
    +clk_hw_get_flags(E)
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Coquelin <mcoquelin.stm32@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 574a3da33b58..b8c3ee5688f4 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -92,7 +92,7 @@ static int clk_factors_determine_rate(struct clk_hw *hw,
 		parent = clk_get_parent_by_index(clk, i);
 		if (!parent)
 			continue;
-		if (__clk_get_flags(clk) & CLK_SET_RATE_PARENT)
+		if (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)
 			parent_rate = __clk_round_rate(parent, req->rate);
 		else
 			parent_rate = __clk_get_rate(parent);

commit 497295afb5ab070211a9963c80a89bc6fbfd6197
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 25 16:53:23 2015 -0700

    clk: Replace __clk_get_num_parents with clk_hw_get_num_parents()
    
    Mostly converted with the following semantic patch:
    
    @@
    struct clk_hw *E;
    @@
    
    -__clk_get_num_parents(E->clk)
    +clk_hw_get_num_parents(E)
    
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Chao Xie <chao.xie@marvell.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: "Emilio López" <emilio@elopez.com.ar>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index a650eae4cc49..574a3da33b58 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -87,7 +87,7 @@ static int clk_factors_determine_rate(struct clk_hw *hw,
 	unsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;
 
 	/* find the parent that can help provide the fastest rate <= rate */
-	num_parents = __clk_get_num_parents(clk);
+	num_parents = clk_hw_get_num_parents(hw);
 	for (i = 0; i < num_parents; i++) {
 		parent = clk_get_parent_by_index(clk, i);
 		if (!parent)

commit 8a53fb2bceea00081c4a6af7b477bea8ec00b74b
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Mon Jul 6 22:59:05 2015 -0500

    clk: sunxi: make use of of_clk_parent_fill helper function
    
    Use of_clk_parent_fill to fill in the parent clock names' array.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: "Emilio López" <emilio@elopez.com.ar>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 94e2570a2409..a650eae4cc49 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -175,9 +175,7 @@ struct clk *sunxi_factors_register(struct device_node *node,
 	int i = 0;
 
 	/* if we have a mux, we will have >1 parents */
-	while (i < FACTORS_MAX_PARENTS &&
-	       (parents[i] = of_clk_get_parent_name(node, i)) != NULL)
-		i++;
+	i = of_clk_parent_fill(node, parents, FACTORS_MAX_PARENTS);
 
 	/*
 	 * some factor clocks, such as pll5 and pll6, may have multiple

commit 57d866e606ddf2a0cd51f7140cfd8df1fdaa48f6
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Jul 9 22:39:38 2015 +0200

    clk: fix some determine_rate implementations
    
    Some determine_rate implementations are not returning an error
    when they failed to adapt the rate according to the rate request.
    Fix them so that they return an error instead of silently
    returning 0.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    CC: Jonathan Corbet <corbet@lwn.net>
    CC: Tony Lindgren <tony@atomide.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: "Emilio López" <emilio@elopez.com.ar>
    CC: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    CC: Peter De Schrijver <pdeschrijver@nvidia.com>
    CC: Prashant Gaikwad <pgaikwad@nvidia.com>
    CC: Stephen Warren <swarren@wwwdotorg.org>
    CC: Thierry Reding <thierry.reding@gmail.com>
    CC: Alexandre Courbot <gnurou@gmail.com>
    CC: linux-doc@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-omap@vger.kernel.org
    CC: linux-mips@linux-mips.org
    CC: linux-tegra@vger.kernel.org
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 7a485870991d..94e2570a2409 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -107,8 +107,10 @@ static int clk_factors_determine_rate(struct clk_hw *hw,
 		}
 	}
 
-	if (best_parent)
-		req->best_parent_hw = __clk_get_hw(best_parent);
+	if (!best_parent)
+		return -EINVAL;
+
+	req->best_parent_hw = __clk_get_hw(best_parent);
 	req->best_parent_rate = best;
 	req->rate = best_child_rate;
 

commit 0817b62cc037a56c5e4238c7eb7522299ea27aef
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jul 7 20:48:08 2015 +0200

    clk: change clk_ops' ->determine_rate() prototype
    
    Clock rates are stored in an unsigned long field, but ->determine_rate()
    (which returns a rounded rate from a requested one) returns a long
    value (errors are reported using negative error codes), which can lead
    to long overflow if the clock rate exceed 2Ghz.
    
    Change ->determine_rate() prototype to return 0 or an error code, and pass
    a pointer to a clk_rate_request structure containing the expected target
    rate and the rate constraints imposed by clk users.
    
    The clk_rate_request structure might be extended in the future to contain
    other kind of constraints like the rounding policy, the maximum clock
    inaccuracy or other things that are not yet supported by the CCF
    (power consumption constraints ?).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    CC: Jonathan Corbet <corbet@lwn.net>
    CC: Tony Lindgren <tony@atomide.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: "Emilio López" <emilio@elopez.com.ar>
    CC: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    CC: Peter De Schrijver <pdeschrijver@nvidia.com>
    CC: Prashant Gaikwad <pgaikwad@nvidia.com>
    CC: Stephen Warren <swarren@wwwdotorg.org>
    CC: Thierry Reding <thierry.reding@gmail.com>
    CC: Alexandre Courbot <gnurou@gmail.com>
    CC: linux-doc@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-omap@vger.kernel.org
    CC: linux-mips@linux-mips.org
    CC: linux-tegra@vger.kernel.org
    [sboyd@codeaurora.org: Fix parent dereference problem in
    __clk_determine_rate()]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: Romain Perier <romain.perier@gmail.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    [sboyd@codeaurora.org: Folded in fix from Heiko for fixed-rate
    clocks without parents or a rate determining op]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 8c20190a3e9f..7a485870991d 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -79,11 +79,8 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 	return rate;
 }
 
-static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
-				       unsigned long min_rate,
-				       unsigned long max_rate,
-				       unsigned long *best_parent_rate,
-				       struct clk_hw **best_parent_p)
+static int clk_factors_determine_rate(struct clk_hw *hw,
+				      struct clk_rate_request *req)
 {
 	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
 	int i, num_parents;
@@ -96,13 +93,14 @@ static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
 		if (!parent)
 			continue;
 		if (__clk_get_flags(clk) & CLK_SET_RATE_PARENT)
-			parent_rate = __clk_round_rate(parent, rate);
+			parent_rate = __clk_round_rate(parent, req->rate);
 		else
 			parent_rate = __clk_get_rate(parent);
 
-		child_rate = clk_factors_round_rate(hw, rate, &parent_rate);
+		child_rate = clk_factors_round_rate(hw, req->rate,
+						    &parent_rate);
 
-		if (child_rate <= rate && child_rate > best_child_rate) {
+		if (child_rate <= req->rate && child_rate > best_child_rate) {
 			best_parent = parent;
 			best = parent_rate;
 			best_child_rate = child_rate;
@@ -110,10 +108,11 @@ static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
 	}
 
 	if (best_parent)
-		*best_parent_p = __clk_get_hw(best_parent);
-	*best_parent_rate = best;
+		req->best_parent_hw = __clk_get_hw(best_parent);
+	req->best_parent_rate = best;
+	req->rate = best_child_rate;
 
-	return best_child_rate;
+	return 0;
 }
 
 static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,

commit 1c8e600440c7f5036bd9a94526d01e9c7cb68dca
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Fri Jan 23 12:03:31 2015 +0100

    clk: Add rate constraints to clocks
    
    Adds a way for clock consumers to set maximum and minimum rates. This
    can be used for thermal drivers to set minimum rates, or by misc.
    drivers to set maximum rates to assure a minimum performance level.
    
    Changes the signature of the determine_rate callback by adding the
    parameters min_rate and max_rate.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [sboyd@codeaurora.org: set req_rate in __clk_init]
    Signed-off-by: Michael Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: min/max rate for sun6i_ahb1_clk_determine_rate
                            migrated clk-private.h changes to clk.c]

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index a9ebbd207d58..8c20190a3e9f 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -80,6 +80,8 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 }
 
 static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long min_rate,
+				       unsigned long max_rate,
 				       unsigned long *best_parent_rate,
 				       struct clk_hw **best_parent_p)
 {

commit 7c74c220e9c6d756953235e1f8e5b704569ea613
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Nov 23 14:38:07 2014 +0100

    clk: sunxi: Give sunxi_factors_register a registers parameter
    
    Before this commit sunxi_factors_register uses of_iomap(node, 0) to get
    the clk registers. The sun6i prcm has factor clocks, for which we want to
    use sunxi_factors_register, but of_iomap(node, 0) does not work for the prcm
    factor clocks, because the prcm uses the mfd framework, so the registers
    are not part of the dt-node, instead they are added to the platform_device,
    as platform_device resources.
    
    This commit makes getting the registers the callers duty, so that
    sunxi_factors_register can be used with mfd instantiated platform device too.
    
    While at it also add error checking to the of_iomap calls.
    
    This commit also drops the __init function from sunxi_factors_register since
    platform driver probe functions are not __init.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 62e08fb58554..a9ebbd207d58 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -156,9 +156,10 @@ static const struct clk_ops clk_factors_ops = {
 	.set_rate = clk_factors_set_rate,
 };
 
-struct clk * __init sunxi_factors_register(struct device_node *node,
-					   const struct factors_data *data,
-					   spinlock_t *lock)
+struct clk *sunxi_factors_register(struct device_node *node,
+				   const struct factors_data *data,
+				   spinlock_t *lock,
+				   void __iomem *reg)
 {
 	struct clk *clk;
 	struct clk_factors *factors;
@@ -168,11 +169,8 @@ struct clk * __init sunxi_factors_register(struct device_node *node,
 	struct clk_hw *mux_hw = NULL;
 	const char *clk_name = node->name;
 	const char *parents[FACTORS_MAX_PARENTS];
-	void __iomem *reg;
 	int i = 0;
 
-	reg = of_iomap(node, 0);
-
 	/* if we have a mux, we will have >1 parents */
 	while (i < FACTORS_MAX_PARENTS &&
 	       (parents[i] = of_clk_get_parent_name(node, i)) != NULL)

commit 646cafc6aa4d6004d189de1cdc267ab562069ba9
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Tue Dec 2 08:54:22 2014 +0100

    clk: Change clk_ops->determine_rate to return a clk_hw as the best parent
    
    This is in preparation for clock providers to not have to deal with struct clk.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 5521e866fa5e..62e08fb58554 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -81,7 +81,7 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 
 static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
 				       unsigned long *best_parent_rate,
-				       struct clk **best_parent_p)
+				       struct clk_hw **best_parent_p)
 {
 	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
 	int i, num_parents;
@@ -108,7 +108,7 @@ static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
 	}
 
 	if (best_parent)
-		*best_parent_p = best_parent;
+		*best_parent_p = __clk_get_hw(best_parent);
 	*best_parent_rate = best;
 
 	return best_child_rate;

commit e94f8cb32d47b157b2af1906eb965290e89ee3fe
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Mon Oct 20 22:10:26 2014 +0800

    clk: sunxi: make factors clock mux mask configurable
    
    Some of the factors-style clocks on the A80 have different widths
    for the mux values in the registers.
    
    Add a .muxmask field to clk_factors_config to make it configurable.
    Passing a bitmask instead of a width parameter will allow reuse
    in case we support table-based muxes in the future.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index f83ba097126c..5521e866fa5e 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -224,7 +224,7 @@ struct clk * __init sunxi_factors_register(struct device_node *node,
 		/* set up gate properties */
 		mux->reg = reg;
 		mux->shift = data->mux;
-		mux->mask = SUNXI_FACTORS_MUX_MASK;
+		mux->mask = data->muxmask;
 		mux->lock = factors->lock;
 		mux_hw = &mux->hw;
 	}

commit 601da9d0a54c0fea7f5a208bc107d7ef1de4f570
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Fri Jul 4 22:24:52 2014 +0200

    clk: sunxi: factors: Invert the probing logic
    
    Until now, the factors clock probing was done directly by sunxi_init_clocks,
    with the factors registration being called directly with the clocks data passed
    as an argument.
    
    This approch has shown its limits when we added more clocks, since we couldn't
    really split code with such a logic in smaller files, and led to a huge file
    having all the clocks.
    
    Introduce an intermediate probing function, so that factor clocks will be able
    to directly be called by CLK_OF_DECLARE, which will in turn ease the split into
    several files.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 2057c8ac648f..f83ba097126c 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -9,18 +9,18 @@
  */
 
 #include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
 #include <linux/module.h>
+#include <linux/of_address.h>
 #include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/err.h>
 #include <linux/string.h>
 
-#include <linux/delay.h>
-
 #include "clk-factors.h"
 
 /*
- * DOC: basic adjustable factor-based clock that cannot gate
+ * DOC: basic adjustable factor-based clock
  *
  * Traits of this clock:
  * prepare - clk_prepare only ensures that parents are prepared
@@ -32,6 +32,8 @@
 
 #define to_clk_factors(_hw) container_of(_hw, struct clk_factors, hw)
 
+#define FACTORS_MAX_PARENTS		5
+
 #define SETMASK(len, pos)		(((1U << (len)) - 1) << (pos))
 #define CLRMASK(len, pos)		(~(SETMASK(len, pos)))
 #define FACTOR_GET(bit, len, reg)	(((reg) & SETMASK(len, bit)) >> (bit))
@@ -147,9 +149,96 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 	return 0;
 }
 
-const struct clk_ops clk_factors_ops = {
+static const struct clk_ops clk_factors_ops = {
 	.determine_rate = clk_factors_determine_rate,
 	.recalc_rate = clk_factors_recalc_rate,
 	.round_rate = clk_factors_round_rate,
 	.set_rate = clk_factors_set_rate,
 };
+
+struct clk * __init sunxi_factors_register(struct device_node *node,
+					   const struct factors_data *data,
+					   spinlock_t *lock)
+{
+	struct clk *clk;
+	struct clk_factors *factors;
+	struct clk_gate *gate = NULL;
+	struct clk_mux *mux = NULL;
+	struct clk_hw *gate_hw = NULL;
+	struct clk_hw *mux_hw = NULL;
+	const char *clk_name = node->name;
+	const char *parents[FACTORS_MAX_PARENTS];
+	void __iomem *reg;
+	int i = 0;
+
+	reg = of_iomap(node, 0);
+
+	/* if we have a mux, we will have >1 parents */
+	while (i < FACTORS_MAX_PARENTS &&
+	       (parents[i] = of_clk_get_parent_name(node, i)) != NULL)
+		i++;
+
+	/*
+	 * some factor clocks, such as pll5 and pll6, may have multiple
+	 * outputs, and have their name designated in factors_data
+	 */
+	if (data->name)
+		clk_name = data->name;
+	else
+		of_property_read_string(node, "clock-output-names", &clk_name);
+
+	factors = kzalloc(sizeof(struct clk_factors), GFP_KERNEL);
+	if (!factors)
+		return NULL;
+
+	/* set up factors properties */
+	factors->reg = reg;
+	factors->config = data->table;
+	factors->get_factors = data->getter;
+	factors->lock = lock;
+
+	/* Add a gate if this factor clock can be gated */
+	if (data->enable) {
+		gate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);
+		if (!gate) {
+			kfree(factors);
+			return NULL;
+		}
+
+		/* set up gate properties */
+		gate->reg = reg;
+		gate->bit_idx = data->enable;
+		gate->lock = factors->lock;
+		gate_hw = &gate->hw;
+	}
+
+	/* Add a mux if this factor clock can be muxed */
+	if (data->mux) {
+		mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
+		if (!mux) {
+			kfree(factors);
+			kfree(gate);
+			return NULL;
+		}
+
+		/* set up gate properties */
+		mux->reg = reg;
+		mux->shift = data->mux;
+		mux->mask = SUNXI_FACTORS_MUX_MASK;
+		mux->lock = factors->lock;
+		mux_hw = &mux->hw;
+	}
+
+	clk = clk_register_composite(NULL, clk_name,
+			parents, i,
+			mux_hw, &clk_mux_ops,
+			&factors->hw, &clk_factors_ops,
+			gate_hw, &clk_gate_ops, 0);
+
+	if (!IS_ERR(clk)) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		clk_register_clkdev(clk, clk_name, NULL);
+	}
+
+	return clk;
+}

commit 9a5e6c7eb5ccbb5f0d3a1dffce135f0a727f40e1
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Thu Jun 26 23:55:41 2014 +0800

    clk: sunxi: Support factor clocks with N factor starting not from 0
    
    The PLLs on newer Allwinner SoC's, such as the A31 and A23, have a
    N multiplier factor that starts from 1, not 0.
    
    This patch adds an option to the factor clk driver's config data
    structures to specify the base value of N.
    
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 3806d97e529b..2057c8ac648f 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -62,7 +62,7 @@ static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
 		p = FACTOR_GET(config->pshift, config->pwidth, reg);
 
 	/* Calculate the rate */
-	rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
+	rate = (parent_rate * (n + config->n_start) * (k + 1) >> p) / (m + 1);
 
 	return rate;
 }

commit 862b728387aef3a3776ad2a261e484aff36c5e67
Author: Emilio López <emilio@elopez.com.ar>
Date:   Fri May 2 17:57:15 2014 +0200

    clk: sunxi: factors: automatic reparenting support
    
    This commit implements .determine_rate, so that our factor clocks can be
    reparented when needed.
    
    Signed-off-by: Emilio López <emilio@elopez.com.ar>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 9e232644f07e..3806d97e529b 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -77,6 +77,41 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 	return rate;
 }
 
+static long clk_factors_determine_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long *best_parent_rate,
+				       struct clk **best_parent_p)
+{
+	struct clk *clk = hw->clk, *parent, *best_parent = NULL;
+	int i, num_parents;
+	unsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;
+
+	/* find the parent that can help provide the fastest rate <= rate */
+	num_parents = __clk_get_num_parents(clk);
+	for (i = 0; i < num_parents; i++) {
+		parent = clk_get_parent_by_index(clk, i);
+		if (!parent)
+			continue;
+		if (__clk_get_flags(clk) & CLK_SET_RATE_PARENT)
+			parent_rate = __clk_round_rate(parent, rate);
+		else
+			parent_rate = __clk_get_rate(parent);
+
+		child_rate = clk_factors_round_rate(hw, rate, &parent_rate);
+
+		if (child_rate <= rate && child_rate > best_child_rate) {
+			best_parent = parent;
+			best = parent_rate;
+			best_child_rate = child_rate;
+		}
+	}
+
+	if (best_parent)
+		*best_parent_p = best_parent;
+	*best_parent_rate = best;
+
+	return best_child_rate;
+}
+
 static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long parent_rate)
 {
@@ -113,6 +148,7 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 }
 
 const struct clk_ops clk_factors_ops = {
+	.determine_rate = clk_factors_determine_rate,
 	.recalc_rate = clk_factors_recalc_rate,
 	.round_rate = clk_factors_round_rate,
 	.set_rate = clk_factors_set_rate,

commit 40a5dcba4e79023f0b511dc0ca498bdf9eacb5db
Author: Emilio López <emilio@elopez.com.ar>
Date:   Mon Dec 23 00:32:32 2013 -0300

    clk: sunxi: register factors clocks behind composite
    
    This commit reworks factors clock registration to be done behind a
    composite clock. This allows us to additionally add a gate, mux or
    divisors, as it will be needed by some future PLLs.
    
    Signed-off-by: Emilio López <emilio@elopez.com.ar>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index f05207a27e5f..9e232644f07e 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -30,14 +30,6 @@
  * parent - fixed parent.  No clk_set_parent support
  */
 
-struct clk_factors {
-	struct clk_hw hw;
-	void __iomem *reg;
-	struct clk_factors_config *config;
-	void (*get_factors) (u32 *rate, u32 parent, u8 *n, u8 *k, u8 *m, u8 *p);
-	spinlock_t *lock;
-};
-
 #define to_clk_factors(_hw) container_of(_hw, struct clk_factors, hw)
 
 #define SETMASK(len, pos)		(((1U << (len)) - 1) << (pos))
@@ -120,61 +112,8 @@ static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 	return 0;
 }
 
-static const struct clk_ops clk_factors_ops = {
+const struct clk_ops clk_factors_ops = {
 	.recalc_rate = clk_factors_recalc_rate,
 	.round_rate = clk_factors_round_rate,
 	.set_rate = clk_factors_set_rate,
 };
-
-/**
- * clk_register_factors - register a factors clock with
- * the clock framework
- * @dev: device registering this clock
- * @name: name of this clock
- * @parent_name: name of clock's parent
- * @flags: framework-specific flags
- * @reg: register address to adjust factors
- * @config: shift and width of factors n, k, m and p
- * @get_factors: function to calculate the factors for a given frequency
- * @lock: shared register lock for this clock
- */
-struct clk *clk_register_factors(struct device *dev, const char *name,
-				 const char *parent_name,
-				 unsigned long flags, void __iomem *reg,
-				 struct clk_factors_config *config,
-				 void (*get_factors)(u32 *rate, u32 parent,
-						     u8 *n, u8 *k, u8 *m, u8 *p),
-				 spinlock_t *lock)
-{
-	struct clk_factors *factors;
-	struct clk *clk;
-	struct clk_init_data init;
-
-	/* allocate the factors */
-	factors = kzalloc(sizeof(struct clk_factors), GFP_KERNEL);
-	if (!factors) {
-		pr_err("%s: could not allocate factors clk\n", __func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	init.name = name;
-	init.ops = &clk_factors_ops;
-	init.flags = flags;
-	init.parent_names = (parent_name ? &parent_name : NULL);
-	init.num_parents = (parent_name ? 1 : 0);
-
-	/* struct clk_factors assignments */
-	factors->reg = reg;
-	factors->config = config;
-	factors->lock = lock;
-	factors->hw.init = &init;
-	factors->get_factors = get_factors;
-
-	/* register the clock */
-	clk = clk_register(dev, &factors->hw);
-
-	if (IS_ERR(clk))
-		kfree(factors);
-
-	return clk;
-}

commit 12ef06afb3959e7f6f2ae8917c4750883a3e8c14
Author: Emilio López <emilio@elopez.com.ar>
Date:   Fri Sep 20 22:03:11 2013 -0300

    clk: sunxi: factors: clear variables before using them
    
    Random bits may get into our factors if we don't clear n, k, m and p.
    
    Signed-off-by: Emilio López <emilio@elopez.com.ar>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 5687ac9bd85a..f05207a27e5f 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -88,7 +88,7 @@ static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
 static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long parent_rate)
 {
-	u8 n, k, m, p;
+	u8 n = 0, k = 0, m = 0, p = 0;
 	u32 reg;
 	struct clk_factors *factors = to_clk_factors(hw);
 	struct clk_factors_config *config = factors->config;

commit c518e84c76e12e12a2a3404a293b2465af9be5f8
Author: Emilio López <emilio@elopez.com.ar>
Date:   Fri Sep 20 22:03:10 2013 -0300

    clk: sunxi: factors: fix off-by-one masks
    
    The previous code would generate one bit too long masks, and was
    needlessly complicated. This patch replaces it by simpler code that can
    generate the masks correctly.
    
    Signed-off-by: Emilio López <emilio@elopez.com.ar>
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 88523f91d9b7..5687ac9bd85a 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -40,7 +40,7 @@ struct clk_factors {
 
 #define to_clk_factors(_hw) container_of(_hw, struct clk_factors, hw)
 
-#define SETMASK(len, pos)		(((-1U) >> (31-len))  << (pos))
+#define SETMASK(len, pos)		(((1U << (len)) - 1) << (pos))
 #define CLRMASK(len, pos)		(~(SETMASK(len, pos)))
 #define FACTOR_GET(bit, len, reg)	(((reg) & SETMASK(len, bit)) >> (bit))
 

commit e874a6697710f52fa8ab29487a99034d5d96fdcc
Author: Emilio López <emilio@elopez.com.ar>
Date:   Mon Feb 25 11:44:26 2013 -0300

    clk: arm: sunxi: Add a new clock driver for sunxi SOCs
    
    This commit implements the base CPU clocks for sunxi devices. It has
    been tested using a slightly modified cpufreq driver from the
    linux-sunxi 3.0 tree.
    
    Additionally, document the new bindings introduced by this patch.
    
    Idling:
        / # cat /sys/kernel/debug/clk/clk_summary
           clock                        enable_cnt  prepare_cnt  rate
        ---------------------------------------------------------------------
         osc32k                         0           0            32768
         osc24M_fixed                   0           0            24000000
            osc24M                      0           0            24000000
               apb1_mux                 0           0            24000000
                  apb1                  0           0            24000000
               pll1                     0           0            60000000
                  cpu                   0           0            60000000
                     axi                0           0            60000000
                        ahb             0           0            60000000
                           apb0         0           0            30000000
         dummy                          0           0            0
    
    After "yes >/dev/null &":
        / # cat /sys/kernel/debug/clk/clk_summary
           clock                        enable_cnt  prepare_cnt  rate
        ---------------------------------------------------------------------
         osc32k                         0           0            32768
         osc24M_fixed                   0           0            24000000
            osc24M                      0           0            24000000
               apb1_mux                 0           0            24000000
                  apb1                  0           0            24000000
               pll1                     0           0            1008000000
                  cpu                   0           0            1008000000
                     axi                0           0            336000000
                        ahb             0           0            168000000
                           apb0         0           0            84000000
         dummy                          0           0            0
    
    Signed-off-by: Emilio López <emilio@elopez.com.ar>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
new file mode 100644
index 000000000000..88523f91d9b7
--- /dev/null
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2013 Emilio López <emilio@elopez.com.ar>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/string.h>
+
+#include <linux/delay.h>
+
+#include "clk-factors.h"
+
+/*
+ * DOC: basic adjustable factor-based clock that cannot gate
+ *
+ * Traits of this clock:
+ * prepare - clk_prepare only ensures that parents are prepared
+ * enable - clk_enable only ensures that parents are enabled
+ * rate - rate is adjustable.
+ *        clk->rate = (parent->rate * N * (K + 1) >> P) / (M + 1)
+ * parent - fixed parent.  No clk_set_parent support
+ */
+
+struct clk_factors {
+	struct clk_hw hw;
+	void __iomem *reg;
+	struct clk_factors_config *config;
+	void (*get_factors) (u32 *rate, u32 parent, u8 *n, u8 *k, u8 *m, u8 *p);
+	spinlock_t *lock;
+};
+
+#define to_clk_factors(_hw) container_of(_hw, struct clk_factors, hw)
+
+#define SETMASK(len, pos)		(((-1U) >> (31-len))  << (pos))
+#define CLRMASK(len, pos)		(~(SETMASK(len, pos)))
+#define FACTOR_GET(bit, len, reg)	(((reg) & SETMASK(len, bit)) >> (bit))
+
+#define FACTOR_SET(bit, len, reg, val) \
+	(((reg) & CLRMASK(len, bit)) | (val << (bit)))
+
+static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
+					     unsigned long parent_rate)
+{
+	u8 n = 1, k = 0, p = 0, m = 0;
+	u32 reg;
+	unsigned long rate;
+	struct clk_factors *factors = to_clk_factors(hw);
+	struct clk_factors_config *config = factors->config;
+
+	/* Fetch the register value */
+	reg = readl(factors->reg);
+
+	/* Get each individual factor if applicable */
+	if (config->nwidth != SUNXI_FACTORS_NOT_APPLICABLE)
+		n = FACTOR_GET(config->nshift, config->nwidth, reg);
+	if (config->kwidth != SUNXI_FACTORS_NOT_APPLICABLE)
+		k = FACTOR_GET(config->kshift, config->kwidth, reg);
+	if (config->mwidth != SUNXI_FACTORS_NOT_APPLICABLE)
+		m = FACTOR_GET(config->mshift, config->mwidth, reg);
+	if (config->pwidth != SUNXI_FACTORS_NOT_APPLICABLE)
+		p = FACTOR_GET(config->pshift, config->pwidth, reg);
+
+	/* Calculate the rate */
+	rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
+
+	return rate;
+}
+
+static long clk_factors_round_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long *parent_rate)
+{
+	struct clk_factors *factors = to_clk_factors(hw);
+	factors->get_factors((u32 *)&rate, (u32)*parent_rate,
+			     NULL, NULL, NULL, NULL);
+
+	return rate;
+}
+
+static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	u8 n, k, m, p;
+	u32 reg;
+	struct clk_factors *factors = to_clk_factors(hw);
+	struct clk_factors_config *config = factors->config;
+	unsigned long flags = 0;
+
+	factors->get_factors((u32 *)&rate, (u32)parent_rate, &n, &k, &m, &p);
+
+	if (factors->lock)
+		spin_lock_irqsave(factors->lock, flags);
+
+	/* Fetch the register value */
+	reg = readl(factors->reg);
+
+	/* Set up the new factors - macros do not do anything if width is 0 */
+	reg = FACTOR_SET(config->nshift, config->nwidth, reg, n);
+	reg = FACTOR_SET(config->kshift, config->kwidth, reg, k);
+	reg = FACTOR_SET(config->mshift, config->mwidth, reg, m);
+	reg = FACTOR_SET(config->pshift, config->pwidth, reg, p);
+
+	/* Apply them now */
+	writel(reg, factors->reg);
+
+	/* delay 500us so pll stabilizes */
+	__delay((rate >> 20) * 500 / 2);
+
+	if (factors->lock)
+		spin_unlock_irqrestore(factors->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops clk_factors_ops = {
+	.recalc_rate = clk_factors_recalc_rate,
+	.round_rate = clk_factors_round_rate,
+	.set_rate = clk_factors_set_rate,
+};
+
+/**
+ * clk_register_factors - register a factors clock with
+ * the clock framework
+ * @dev: device registering this clock
+ * @name: name of this clock
+ * @parent_name: name of clock's parent
+ * @flags: framework-specific flags
+ * @reg: register address to adjust factors
+ * @config: shift and width of factors n, k, m and p
+ * @get_factors: function to calculate the factors for a given frequency
+ * @lock: shared register lock for this clock
+ */
+struct clk *clk_register_factors(struct device *dev, const char *name,
+				 const char *parent_name,
+				 unsigned long flags, void __iomem *reg,
+				 struct clk_factors_config *config,
+				 void (*get_factors)(u32 *rate, u32 parent,
+						     u8 *n, u8 *k, u8 *m, u8 *p),
+				 spinlock_t *lock)
+{
+	struct clk_factors *factors;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	/* allocate the factors */
+	factors = kzalloc(sizeof(struct clk_factors), GFP_KERNEL);
+	if (!factors) {
+		pr_err("%s: could not allocate factors clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = &clk_factors_ops;
+	init.flags = flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_factors assignments */
+	factors->reg = reg;
+	factors->config = config;
+	factors->lock = lock;
+	factors->hw.init = &init;
+	factors->get_factors = get_factors;
+
+	/* register the clock */
+	clk = clk_register(dev, &factors->hw);
+
+	if (IS_ERR(clk))
+		kfree(factors);
+
+	return clk;
+}
