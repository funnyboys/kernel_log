commit 9611b3aacc1c1af7cb96d35ca5f1e55fdd44f697
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Aug 30 08:09:21 2019 -0700

    clk: mux: Add support for specifying parents via DT/pointers
    
    After commit fc0c209c147f ("clk: Allow parents to be specified without
    string names") we can use DT or direct clk_hw pointers to specify
    parents. Create a generic function that shouldn't be used very often to
    encode the multitude of ways of registering a mux clk with different
    parent information. Then add a bunch of wrapper macros that only pass
    down what needs to be passed down to the generic function to support
    this with less arguments.
    
    Note: the msm drm driver passes an anonymous array through the macro
    which seems to confuse my compiler. Adding a parenthesis around the
    whole thing at the call site seems to fix it but it must be wrong. Maybe
    it's better to split this patch and pick out the array bits there?
    
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190830150923.259497-11-sboyd@kernel.org

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 570b6e5b603b..e54e79714818 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -145,17 +145,19 @@ const struct clk_ops clk_mux_ro_ops = {
 };
 EXPORT_SYMBOL_GPL(clk_mux_ro_ops);
 
-struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
-		const char * const *parent_names, u8 num_parents,
-		unsigned long flags,
-		void __iomem *reg, u8 shift, u32 mask,
+struct clk_hw *__clk_hw_register_mux(struct device *dev, struct device_node *np,
+		const char *name, u8 num_parents,
+		const char * const *parent_names,
+		const struct clk_hw **parent_hws,
+		const struct clk_parent_data *parent_data,
+		unsigned long flags, void __iomem *reg, u8 shift, u32 mask,
 		u8 clk_mux_flags, u32 *table, spinlock_t *lock)
 {
 	struct clk_mux *mux;
 	struct clk_hw *hw;
 	struct clk_init_data init = {};
 	u8 width = 0;
-	int ret;
+	int ret = -EINVAL;
 
 	if (clk_mux_flags & CLK_MUX_HIWORD_MASK) {
 		width = fls(mask) - ffs(mask) + 1;
@@ -177,6 +179,8 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 		init.ops = &clk_mux_ops;
 	init.flags = flags;
 	init.parent_names = parent_names;
+	init.parent_data = parent_data;
+	init.parent_hws = parent_hws;
 	init.num_parents = num_parents;
 
 	/* struct clk_mux assignments */
@@ -189,7 +193,10 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 	mux->hw.init = &init;
 
 	hw = &mux->hw;
-	ret = clk_hw_register(dev, hw);
+	if (dev || !np)
+		ret = clk_hw_register(dev, hw);
+	else if (np)
+		ret = of_clk_hw_register(np, hw);
 	if (ret) {
 		kfree(mux);
 		hw = ERR_PTR(ret);
@@ -197,53 +204,24 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 
 	return hw;
 }
-EXPORT_SYMBOL_GPL(clk_hw_register_mux_table);
+EXPORT_SYMBOL_GPL(__clk_hw_register_mux);
 
 struct clk *clk_register_mux_table(struct device *dev, const char *name,
 		const char * const *parent_names, u8 num_parents,
-		unsigned long flags,
-		void __iomem *reg, u8 shift, u32 mask,
+		unsigned long flags, void __iomem *reg, u8 shift, u32 mask,
 		u8 clk_mux_flags, u32 *table, spinlock_t *lock)
 {
 	struct clk_hw *hw;
 
-	hw = clk_hw_register_mux_table(dev, name, parent_names, num_parents,
-				       flags, reg, shift, mask, clk_mux_flags,
-				       table, lock);
+	hw = clk_hw_register_mux_table(dev, name, parent_names,
+				       num_parents, flags, reg, shift, mask,
+				       clk_mux_flags, table, lock);
 	if (IS_ERR(hw))
 		return ERR_CAST(hw);
 	return hw->clk;
 }
 EXPORT_SYMBOL_GPL(clk_register_mux_table);
 
-struct clk *clk_register_mux(struct device *dev, const char *name,
-		const char * const *parent_names, u8 num_parents,
-		unsigned long flags,
-		void __iomem *reg, u8 shift, u8 width,
-		u8 clk_mux_flags, spinlock_t *lock)
-{
-	u32 mask = BIT(width) - 1;
-
-	return clk_register_mux_table(dev, name, parent_names, num_parents,
-				      flags, reg, shift, mask, clk_mux_flags,
-				      NULL, lock);
-}
-EXPORT_SYMBOL_GPL(clk_register_mux);
-
-struct clk_hw *clk_hw_register_mux(struct device *dev, const char *name,
-		const char * const *parent_names, u8 num_parents,
-		unsigned long flags,
-		void __iomem *reg, u8 shift, u8 width,
-		u8 clk_mux_flags, spinlock_t *lock)
-{
-	u32 mask = BIT(width) - 1;
-
-	return clk_hw_register_mux_table(dev, name, parent_names, num_parents,
-				      flags, reg, shift, mask, clk_mux_flags,
-				      NULL, lock);
-}
-EXPORT_SYMBOL_GPL(clk_hw_register_mux);
-
 void clk_unregister_mux(struct clk *clk)
 {
 	struct clk_mux *mux;

commit cc819cf8d4760fac260e91dcf5c432abece3fcd2
Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
Date:   Fri Nov 15 21:58:55 2019 +0530

    clk: Zero init clk_init_data in helpers
    
    The clk_init_data struct needs to be initialized to zero for the new
    parent_map implementation to work correctly. Otherwise, the member which
    is available first will get processed.
    
    Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Link: https://lkml.kernel.org/r/20191115162901.17456-2-manivannan.sadhasivam@linaro.org
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 66e91f740508..570b6e5b603b 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -153,7 +153,7 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 {
 	struct clk_mux *mux;
 	struct clk_hw *hw;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
 	u8 width = 0;
 	int ret;
 

commit 0caf000817353cfc5db22363ecdac63b83d3a3f9
Merge: ff060019f4e5 90b6c5c73c69
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue May 7 11:46:02 2019 -0700

    Merge branch 'clk-ti' into clk-next
    
    * clk-ti:
      clk: Remove CLK_IS_BASIC clk flag
      clk: ti: dra7: disable the RNG and TIMER12 clkctrl clocks on HS devices
      clk: ti: dra7x: prevent non-existing clkctrl clocks from registering
      ARM: omap2+: hwmod: drop CLK_IS_BASIC flag usage
      clk: ti: export the omap2_clk_is_hw_omap call

commit 90b6c5c73c6904ac200161fc38974d867f0535b0
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 25 10:57:37 2019 -0700

    clk: Remove CLK_IS_BASIC clk flag
    
    This flag was historically used to indicate that a clk is a "basic" type
    of clk like a mux, divider, gate, etc. This never turned out to be very
    useful though because it was hard to cleanly split "basic" clks from
    other clks in a system. This one flag was a way for type introspection
    and it just didn't scale. If anything, it was used by the TI clk driver
    to indicate that a clk_hw wasn't contained in the SoC specific clk
    structure. We can get rid of this define now that TI is finding those
    clks a different way.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: <linux-mips@vger.kernel.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: <linux-pwm@vger.kernel.org>
    Cc: <linux-amlogic@lists.infradead.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 2ad2df2e8909..7d60d690b7f2 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -159,7 +159,7 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 		init.ops = &clk_mux_ro_ops;
 	else
 		init.ops = &clk_mux_ops;
-	init.flags = flags | CLK_IS_BASIC;
+	init.flags = flags;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;
 

commit 5834fd75e6236605da8c439a64eaa33f3c8d02fe
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Thu Apr 18 13:12:11 2019 +0200

    clk: core: replace clk_{readl,writel} with {readl,writel}
    
    Now that clk_{readl,writel} is just an alias for {readl,writel}, we can
    switch all users of clk_* to use the accessors directly and remove the
    helpers.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    [sboyd@kernel.org: Also convert renesas file so that this can be
    compile independently]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 61ad331b7ff4..893c9b285532 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -28,7 +28,7 @@ static inline u32 clk_mux_readl(struct clk_mux *mux)
 	if (mux->flags & CLK_MUX_BIG_ENDIAN)
 		return ioread32be(mux->reg);
 
-	return clk_readl(mux->reg);
+	return readl(mux->reg);
 }
 
 static inline void clk_mux_writel(struct clk_mux *mux, u32 val)
@@ -36,7 +36,7 @@ static inline void clk_mux_writel(struct clk_mux *mux, u32 val)
 	if (mux->flags & CLK_MUX_BIG_ENDIAN)
 		iowrite32be(val, mux->reg);
 	else
-		clk_writel(val, mux->reg);
+		writel(val, mux->reg);
 }
 
 int clk_mux_val_to_index(struct clk_hw *hw, u32 *table, unsigned int flags,

commit 3a727519651228d92793291516727d62c6887607
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Thu Apr 18 13:12:08 2019 +0200

    clk: mux: add explicit big endian support
    
    Add a clock specific flag to switch register accesses to big endian, to
    allow runtime configuration of big endian mux clocks.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 2ad2df2e8909..61ad331b7ff4 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -23,6 +23,22 @@
  * parent - parent is adjustable through clk_set_parent
  */
 
+static inline u32 clk_mux_readl(struct clk_mux *mux)
+{
+	if (mux->flags & CLK_MUX_BIG_ENDIAN)
+		return ioread32be(mux->reg);
+
+	return clk_readl(mux->reg);
+}
+
+static inline void clk_mux_writel(struct clk_mux *mux, u32 val)
+{
+	if (mux->flags & CLK_MUX_BIG_ENDIAN)
+		iowrite32be(val, mux->reg);
+	else
+		clk_writel(val, mux->reg);
+}
+
 int clk_mux_val_to_index(struct clk_hw *hw, u32 *table, unsigned int flags,
 			 unsigned int val)
 {
@@ -73,7 +89,7 @@ static u8 clk_mux_get_parent(struct clk_hw *hw)
 	struct clk_mux *mux = to_clk_mux(hw);
 	u32 val;
 
-	val = clk_readl(mux->reg) >> mux->shift;
+	val = clk_mux_readl(mux) >> mux->shift;
 	val &= mux->mask;
 
 	return clk_mux_val_to_index(hw, mux->table, mux->flags, val);
@@ -94,12 +110,12 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 	if (mux->flags & CLK_MUX_HIWORD_MASK) {
 		reg = mux->mask << (mux->shift + 16);
 	} else {
-		reg = clk_readl(mux->reg);
+		reg = clk_mux_readl(mux);
 		reg &= ~(mux->mask << mux->shift);
 	}
 	val = val << mux->shift;
 	reg |= val;
-	clk_writel(reg, mux->reg);
+	clk_mux_writel(mux, reg);
 
 	if (mux->lock)
 		spin_unlock_irqrestore(mux->lock, flags);

commit e1bd55e5a567a90c5b26238a46bbaf1c775e9661
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Tue Dec 11 09:57:48 2018 -0800

    clk: Tag basic clk types with SPDX
    
    These are all GPL-2.0 files per the existing license text. Replace the
    boiler plate with the tag.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 1628b93655ed..2ad2df2e8909 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
  * Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>
  * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Simple multiplexer clock implementation
  */
 

commit 4ad69b80e886a845f56ce0a3d10211208693d92b
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Mon Apr 9 15:59:20 2018 +0200

    clk: honor CLK_MUX_ROUND_CLOSEST in generic clk mux
    
    CLK_MUX_ROUND_CLOSEST is part of the clk_mux documentation but clk_mux
    directly calls __clk_mux_determine_rate(), which overrides the flag.
    As result, if clk_mux is instantiated with CLK_MUX_ROUND_CLOSEST, the
    flag will be ignored and the clock rounded down.
    
    To solve this, this patch expose clk_mux_determine_rate_flags() in the
    clk-provider API and uses it in the determine_rate() callback of clk_mux.
    
    Fixes: 15a02c1f6dd7 ("clk: Add __clk_mux_determine_rate_closest")
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index ac4a042f8658..1628b93655ed 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -112,10 +112,18 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 	return 0;
 }
 
+static int clk_mux_determine_rate(struct clk_hw *hw,
+				  struct clk_rate_request *req)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+
+	return clk_mux_determine_rate_flags(hw, req, mux->flags);
+}
+
 const struct clk_ops clk_mux_ops = {
 	.get_parent = clk_mux_get_parent,
 	.set_parent = clk_mux_set_parent,
-	.determine_rate = __clk_mux_determine_rate,
+	.determine_rate = clk_mux_determine_rate,
 };
 EXPORT_SYMBOL_GPL(clk_mux_ops);
 

commit 77deb66d262f8512130ff75ec5ea8e31070b41ed
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Wed Feb 14 14:43:34 2018 +0100

    clk: mux: add helper function for index/value translation
    
    Add helper functions for the translation between parent index and
    register value in the generic multiplexer function. The purpose of
    this change is avoid duplicating the code in other clock providers,
    using the same generic logic.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 39cabe157163..ac4a042f8658 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -26,35 +26,24 @@
  * parent - parent is adjustable through clk_set_parent
  */
 
-static u8 clk_mux_get_parent(struct clk_hw *hw)
+int clk_mux_val_to_index(struct clk_hw *hw, u32 *table, unsigned int flags,
+			 unsigned int val)
 {
-	struct clk_mux *mux = to_clk_mux(hw);
 	int num_parents = clk_hw_get_num_parents(hw);
-	u32 val;
 
-	/*
-	 * FIXME need a mux-specific flag to determine if val is bitwise or numeric
-	 * e.g. sys_clkin_ck's clksel field is 3 bits wide, but ranges from 0x1
-	 * to 0x7 (index starts at one)
-	 * OTOH, pmd_trace_clk_mux_ck uses a separate bit for each clock, so
-	 * val = 0x4 really means "bit 2, index starts at bit 0"
-	 */
-	val = clk_readl(mux->reg) >> mux->shift;
-	val &= mux->mask;
-
-	if (mux->table) {
+	if (table) {
 		int i;
 
 		for (i = 0; i < num_parents; i++)
-			if (mux->table[i] == val)
+			if (table[i] == val)
 				return i;
 		return -EINVAL;
 	}
 
-	if (val && (mux->flags & CLK_MUX_INDEX_BIT))
+	if (val && (flags & CLK_MUX_INDEX_BIT))
 		val = ffs(val) - 1;
 
-	if (val && (mux->flags & CLK_MUX_INDEX_ONE))
+	if (val && (flags & CLK_MUX_INDEX_ONE))
 		val--;
 
 	if (val >= num_parents)
@@ -62,36 +51,58 @@ static u8 clk_mux_get_parent(struct clk_hw *hw)
 
 	return val;
 }
+EXPORT_SYMBOL_GPL(clk_mux_val_to_index);
 
-static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
+unsigned int clk_mux_index_to_val(u32 *table, unsigned int flags, u8 index)
 {
-	struct clk_mux *mux = to_clk_mux(hw);
-	u32 val;
-	unsigned long flags = 0;
+	unsigned int val = index;
 
-	if (mux->table) {
-		index = mux->table[index];
+	if (table) {
+		val = table[index];
 	} else {
-		if (mux->flags & CLK_MUX_INDEX_BIT)
-			index = 1 << index;
+		if (flags & CLK_MUX_INDEX_BIT)
+			val = 1 << index;
 
-		if (mux->flags & CLK_MUX_INDEX_ONE)
-			index++;
+		if (flags & CLK_MUX_INDEX_ONE)
+			val++;
 	}
 
+	return val;
+}
+EXPORT_SYMBOL_GPL(clk_mux_index_to_val);
+
+static u8 clk_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	u32 val;
+
+	val = clk_readl(mux->reg) >> mux->shift;
+	val &= mux->mask;
+
+	return clk_mux_val_to_index(hw, mux->table, mux->flags, val);
+}
+
+static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	u32 val = clk_mux_index_to_val(mux->table, mux->flags, index);
+	unsigned long flags = 0;
+	u32 reg;
+
 	if (mux->lock)
 		spin_lock_irqsave(mux->lock, flags);
 	else
 		__acquire(mux->lock);
 
 	if (mux->flags & CLK_MUX_HIWORD_MASK) {
-		val = mux->mask << (mux->shift + 16);
+		reg = mux->mask << (mux->shift + 16);
 	} else {
-		val = clk_readl(mux->reg);
-		val &= ~(mux->mask << mux->shift);
+		reg = clk_readl(mux->reg);
+		reg &= ~(mux->mask << mux->shift);
 	}
-	val |= index << mux->shift;
-	clk_writel(val, mux->reg);
+	val = val << mux->shift;
+	reg |= val;
+	clk_writel(reg, mux->reg);
 
 	if (mux->lock)
 		spin_unlock_irqrestore(mux->lock, flags);

commit 1e28733e315e9ede15896600a475408d2a203a32
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Sep 26 17:30:06 2017 +0200

    clk: clk-mux: Improve a size determination in clk_hw_register_mux_table()
    
    Replace the specification of a data structure by a pointer dereference
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 1746dbf2f7ea..39cabe157163 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -134,7 +134,7 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 	}
 
 	/* allocate the mux */
-	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
+	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
 	if (!mux)
 		return ERR_PTR(-ENOMEM);
 

commit 0b910402cfa0d3b3de666d68d107b30bf13e164e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Sep 26 17:23:04 2017 +0200

    clk: clk-mux: Delete an error message for a failed memory allocation
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    [sboyd@codeaurora.org: Cleanup commit text]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 16a3d5717f4e..1746dbf2f7ea 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -135,10 +135,8 @@ struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 
 	/* allocate the mux */
 	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
-	if (!mux) {
-		pr_err("%s: could not allocate mux clk\n", __func__);
+	if (!mux)
 		return ERR_PTR(-ENOMEM);
-	}
 
 	init.name = name;
 	if (clk_mux_flags & CLK_MUX_READ_ONLY)

commit 264b31719735eb1fcbed47cecdb20f517e804856
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sun Feb 7 00:05:48 2016 -0800

    clk: mux: Add hw based registration APIs
    
    Add registration APIs in the clk mux code to return struct clk_hw
    pointers instead of struct clk pointers. This way we hide the
    struct clk pointer from providers unless they need to use
    consumer facing APIs.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 252188fd8bcd..16a3d5717f4e 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -113,16 +113,17 @@ const struct clk_ops clk_mux_ro_ops = {
 };
 EXPORT_SYMBOL_GPL(clk_mux_ro_ops);
 
-struct clk *clk_register_mux_table(struct device *dev, const char *name,
+struct clk_hw *clk_hw_register_mux_table(struct device *dev, const char *name,
 		const char * const *parent_names, u8 num_parents,
 		unsigned long flags,
 		void __iomem *reg, u8 shift, u32 mask,
 		u8 clk_mux_flags, u32 *table, spinlock_t *lock)
 {
 	struct clk_mux *mux;
-	struct clk *clk;
+	struct clk_hw *hw;
 	struct clk_init_data init;
 	u8 width = 0;
+	int ret;
 
 	if (clk_mux_flags & CLK_MUX_HIWORD_MASK) {
 		width = fls(mask) - ffs(mask) + 1;
@@ -157,12 +158,31 @@ struct clk *clk_register_mux_table(struct device *dev, const char *name,
 	mux->table = table;
 	mux->hw.init = &init;
 
-	clk = clk_register(dev, &mux->hw);
-
-	if (IS_ERR(clk))
+	hw = &mux->hw;
+	ret = clk_hw_register(dev, hw);
+	if (ret) {
 		kfree(mux);
+		hw = ERR_PTR(ret);
+	}
 
-	return clk;
+	return hw;
+}
+EXPORT_SYMBOL_GPL(clk_hw_register_mux_table);
+
+struct clk *clk_register_mux_table(struct device *dev, const char *name,
+		const char * const *parent_names, u8 num_parents,
+		unsigned long flags,
+		void __iomem *reg, u8 shift, u32 mask,
+		u8 clk_mux_flags, u32 *table, spinlock_t *lock)
+{
+	struct clk_hw *hw;
+
+	hw = clk_hw_register_mux_table(dev, name, parent_names, num_parents,
+				       flags, reg, shift, mask, clk_mux_flags,
+				       table, lock);
+	if (IS_ERR(hw))
+		return ERR_CAST(hw);
+	return hw->clk;
 }
 EXPORT_SYMBOL_GPL(clk_register_mux_table);
 
@@ -180,6 +200,20 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 }
 EXPORT_SYMBOL_GPL(clk_register_mux);
 
+struct clk_hw *clk_hw_register_mux(struct device *dev, const char *name,
+		const char * const *parent_names, u8 num_parents,
+		unsigned long flags,
+		void __iomem *reg, u8 shift, u8 width,
+		u8 clk_mux_flags, spinlock_t *lock)
+{
+	u32 mask = BIT(width) - 1;
+
+	return clk_hw_register_mux_table(dev, name, parent_names, num_parents,
+				      flags, reg, shift, mask, clk_mux_flags,
+				      NULL, lock);
+}
+EXPORT_SYMBOL_GPL(clk_hw_register_mux);
+
 void clk_unregister_mux(struct clk *clk)
 {
 	struct clk_mux *mux;
@@ -195,3 +229,14 @@ void clk_unregister_mux(struct clk *clk)
 	kfree(mux);
 }
 EXPORT_SYMBOL_GPL(clk_unregister_mux);
+
+void clk_hw_unregister_mux(struct clk_hw *hw)
+{
+	struct clk_mux *mux;
+
+	mux = to_clk_mux(hw);
+
+	clk_hw_unregister(hw);
+	kfree(mux);
+}
+EXPORT_SYMBOL_GPL(clk_hw_unregister_mux);

commit 5fd9c05c846db98319e75496612da24435cee208
Author: Geliang Tang <geliangtang@163.com>
Date:   Fri Jan 8 23:51:46 2016 +0800

    clk: move the common clock's to_clk_*(_hw) macros to clk-provider.h
    
    to_clk_*(_hw) macros have been repeatedly defined in many places.
    This patch moves all the to_clk_*(_hw) definitions in the common
    clock framework to public header clk-provider.h, and drop the local
    definitions.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 5ed03c8a8df9..252188fd8bcd 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -26,8 +26,6 @@
  * parent - parent is adjustable through clk_set_parent
  */
 
-#define to_clk_mux(_hw) container_of(_hw, struct clk_mux, hw)
-
 static u8 clk_mux_get_parent(struct clk_hw *hw)
 {
 	struct clk_mux *mux = to_clk_mux(hw);

commit 3837bd277abd08395588139759cbd56f00f14cb4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Nov 5 17:59:39 2015 +0900

    clk: fix codying style of if ... else blocks
    
    This code is unreadable due to the blank line between if and else
    blocks.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 7129c86a79db..5ed03c8a8df9 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -71,10 +71,9 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 	u32 val;
 	unsigned long flags = 0;
 
-	if (mux->table)
+	if (mux->table) {
 		index = mux->table[index];
-
-	else {
+	} else {
 		if (mux->flags & CLK_MUX_INDEX_BIT)
 			index = 1 << index;
 

commit 497295afb5ab070211a9963c80a89bc6fbfd6197
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 25 16:53:23 2015 -0700

    clk: Replace __clk_get_num_parents with clk_hw_get_num_parents()
    
    Mostly converted with the following semantic patch:
    
    @@
    struct clk_hw *E;
    @@
    
    -__clk_get_num_parents(E->clk)
    +clk_hw_get_num_parents(E)
    
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Chao Xie <chao.xie@marvell.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: "Emilio López" <emilio@elopez.com.ar>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 33c09a3bfa51..7129c86a79db 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -31,7 +31,7 @@
 static u8 clk_mux_get_parent(struct clk_hw *hw)
 {
 	struct clk_mux *mux = to_clk_mux(hw);
-	int num_parents = __clk_get_num_parents(hw->clk);
+	int num_parents = clk_hw_get_num_parents(hw);
 	u32 val;
 
 	/*

commit 661e2180cf050a2f859d466f30d74e990b9345be
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jul 24 12:21:12 2015 -0700

    clk: basic-type: Silence warnings about lock imbalances
    
    The basic clock types use conditional locking for the register
    accessor spinlocks. Add __acquire() and __release() markings in
    the right locations so that sparse isn't tripped up on the
    conditional locking.
    
    drivers/clk/clk-mux.c:68:12: warning: context imbalance in 'clk_mux_set_parent' - different lock contexts for basic block
    drivers/clk/clk-divider.c:379:12: warning: context imbalance in 'clk_divider_set_rate' - different lock contexts for basic block
    drivers/clk/clk-gate.c:71:9: warning: context imbalance in 'clk_gate_endisable' - different lock contexts for basic block
    drivers/clk/clk-fractional-divider.c:36:9: warning: context imbalance in 'clk_fd_recalc_rate' - different lock contexts for basic block
    drivers/clk/clk-fractional-divider.c:68:12: warning: context imbalance in 'clk_fd_set_rate' - different lock contexts for basic block
    
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index c705cf573569..33c09a3bfa51 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -84,6 +84,8 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 
 	if (mux->lock)
 		spin_lock_irqsave(mux->lock, flags);
+	else
+		__acquire(mux->lock);
 
 	if (mux->flags & CLK_MUX_HIWORD_MASK) {
 		val = mux->mask << (mux->shift + 16);
@@ -96,6 +98,8 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 
 	if (mux->lock)
 		spin_unlock_irqrestore(mux->lock, flags);
+	else
+		__release(mux->lock);
 
 	return 0;
 }

commit e715e2b1a67be39c8026cb6d77563774f989ba90
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: mux: Remove clk.h include
    
    Clock provider drivers generally shouldn't include clk.h because
    it's the consumer API. Remove the include here because this is a
    provider driver.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 6066a01b20ea..c705cf573569 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -10,7 +10,6 @@
  * Simple multiplexer clock implementation
  */
 
-#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 #include <linux/slab.h>

commit 2893c379461a208b3059f55dfe4dafa06b4aa46a
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Tue Mar 31 20:16:52 2015 +0200

    clk: make strings in parent name arrays const
    
    The clk functions and structs declare the parent_name arrays as
    'const char **parent_names' which means the parent name strings
    are const, but the array itself is not. Use
    'const char * const * parent_names' instead which also makes
    the array const. This allows us to put the parent_name arrays into
    the __initconst section.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    [sboyd@codeaurora.org: Squelch 80-character checkpatch warnings]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 69a094c3783d..6066a01b20ea 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -114,7 +114,8 @@ const struct clk_ops clk_mux_ro_ops = {
 EXPORT_SYMBOL_GPL(clk_mux_ro_ops);
 
 struct clk *clk_register_mux_table(struct device *dev, const char *name,
-		const char **parent_names, u8 num_parents, unsigned long flags,
+		const char * const *parent_names, u8 num_parents,
+		unsigned long flags,
 		void __iomem *reg, u8 shift, u32 mask,
 		u8 clk_mux_flags, u32 *table, spinlock_t *lock)
 {
@@ -166,7 +167,8 @@ struct clk *clk_register_mux_table(struct device *dev, const char *name,
 EXPORT_SYMBOL_GPL(clk_register_mux_table);
 
 struct clk *clk_register_mux(struct device *dev, const char *name,
-		const char **parent_names, u8 num_parents, unsigned long flags,
+		const char * const *parent_names, u8 num_parents,
+		unsigned long flags,
 		void __iomem *reg, u8 shift, u8 width,
 		u8 clk_mux_flags, spinlock_t *lock)
 {

commit 4e3c021fb995bcbb5d1f814d00584cb80eb904a8
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jan 5 10:52:40 2015 +0100

    clk: Add clk_unregister_{divider, gate, mux} to close memory leak
    
    The common clk_register_{divider,gate,mux} functions allocated memory
    for internal data which wasn't freed anywhere. Drivers using these
    helpers could only unregister clocks but the memory would still leak.
    
    Add corresponding unregister functions which will release all resources.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 6e1ecf94bf58..69a094c3783d 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -177,3 +177,19 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 				      NULL, lock);
 }
 EXPORT_SYMBOL_GPL(clk_register_mux);
+
+void clk_unregister_mux(struct clk *clk)
+{
+	struct clk_mux *mux;
+	struct clk_hw *hw;
+
+	hw = __clk_get_hw(clk);
+	if (!hw)
+		return;
+
+	mux = to_clk_mux(hw);
+
+	clk_unregister(clk);
+	kfree(mux);
+}
+EXPORT_SYMBOL_GPL(clk_unregister_mux);

commit 6793b3cd5da817c4be218bd8632f07cf4d2b0d26
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Nov 19 14:48:59 2014 +0100

    clk_mux: Fix set_parent doing the wrong thing when INDEX_BIT && index >= 3
    
    If CLK_MUX_INDEX_BIT is set, then each bit turns on / off a single parent,
    so theoretically multiple parents could be enabled at the same time, but in
    practice only one bit should ever be 1. So to select parent 0, set
    the register (*) to 0x01, to select parent 1 set it 0x02, parent 2, 0x04,
    parent 3, 0x08, etc.
    
    But the current code does:
    
                    if (mux->flags & CLK_MUX_INDEX_BIT)
                            index = (1 << ffs(index));
    
    Which means that:
    
    For an input index of 0, ffs returns 0, so we set the register
    to 0x01, ok.
    
    For an input index of 1, ffs returns 1, so we set the register
    to 0x02, ok.
    
    For an input index of 2, ffs returns 2, so we set the register
    to 0x04, ok.
    
    For an input index of 3, ffs returns 1, so we set the register
    to 0x02, not good!
    
    The code should simply be:
    
                    if (mux->flags & CLK_MUX_INDEX_BIT)
                            index = 1 << index;
    
    Which always does the right thing, this commit fixes this.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 4f96ff3ba728..6e1ecf94bf58 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -77,7 +77,7 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 
 	else {
 		if (mux->flags & CLK_MUX_INDEX_BIT)
-			index = (1 << ffs(index));
+			index = 1 << index;
 
 		if (mux->flags & CLK_MUX_INDEX_ONE)
 			index++;

commit aa514ce34b65e3dc01f95a0b470b39bbb7e09998
Author: Gerhard Sittig <gsi@denx.de>
Date:   Mon Jul 22 14:14:40 2013 +0200

    clk: wrap I/O access for improved portability
    
    the common clock drivers were motivated/initiated by ARM development
    and apparently assume little endian peripherals
    
    wrap register/peripherals access in the common code (div, gate, mux)
    in preparation of adding COMMON_CLK support for other platforms
    
    Signed-off-by: Gerhard Sittig <gsi@denx.de>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 0811633fcc4d..4f96ff3ba728 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -42,7 +42,7 @@ static u8 clk_mux_get_parent(struct clk_hw *hw)
 	 * OTOH, pmd_trace_clk_mux_ck uses a separate bit for each clock, so
 	 * val = 0x4 really means "bit 2, index starts at bit 0"
 	 */
-	val = readl(mux->reg) >> mux->shift;
+	val = clk_readl(mux->reg) >> mux->shift;
 	val &= mux->mask;
 
 	if (mux->table) {
@@ -89,11 +89,11 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 	if (mux->flags & CLK_MUX_HIWORD_MASK) {
 		val = mux->mask << (mux->shift + 16);
 	} else {
-		val = readl(mux->reg);
+		val = clk_readl(mux->reg);
 		val &= ~(mux->mask << mux->shift);
 	}
 	val |= index << mux->shift;
-	writel(val, mux->reg);
+	clk_writel(val, mux->reg);
 
 	if (mux->lock)
 		spin_unlock_irqrestore(mux->lock, flags);

commit e366fdd72529c545ccf327569ee250c1673be221
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Jul 29 12:25:02 2013 +0100

    clk: clk-mux: implement remuxing on set_rate
    
    Implement clk-mux remuxing if the CLK_SET_RATE_NO_REPARENT flag isn't
    set. This implements determine_rate for clk-mux to propagate to each
    parent and to choose the best one (like clk-divider this chooses the
    parent which provides the fastest rate <= the requested rate).
    
    The determine_rate op is implemented as a core helper function so that
    it can be easily used by more complex clocks which incorporate muxes.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index b918dc370bd0..0811633fcc4d 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -104,6 +104,7 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 const struct clk_ops clk_mux_ops = {
 	.get_parent = clk_mux_get_parent,
 	.set_parent = clk_mux_set_parent,
+	.determine_rate = __clk_mux_determine_rate,
 };
 EXPORT_SYMBOL_GPL(clk_mux_ops);
 

commit 5cfe10bb00e1b8c0aaa3f0c796c643bb1af6db82
Author: Mike Turquette <mturquette@linaro.org>
Date:   Thu Aug 15 19:06:29 2013 -0700

    clk: export fixed-factor, gate & mux registration
    
    These registration calls may be used by loadable modules. Export them.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 92f1a1be5319..b918dc370bd0 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -162,6 +162,7 @@ struct clk *clk_register_mux_table(struct device *dev, const char *name,
 
 	return clk;
 }
+EXPORT_SYMBOL_GPL(clk_register_mux_table);
 
 struct clk *clk_register_mux(struct device *dev, const char *name,
 		const char **parent_names, u8 num_parents, unsigned long flags,
@@ -174,3 +175,4 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 				      flags, reg, shift, mask, clk_mux_flags,
 				      NULL, lock);
 }
+EXPORT_SYMBOL_GPL(clk_register_mux);

commit c57acd14ac2d53e40f5c17701c3cc3a092a07b35
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Tue Jul 23 01:49:18 2013 +0200

    clk: mux: Add support for read-only muxes.
    
    Some platforms have read-only clock muxes that are preconfigured at
    reset and cannot be changed at runtime. This patch extends mux clock
    driver to allow handling such read-only muxes by adding new
    CLK_MUX_READ_ONLY mux flag.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 614444ca40cd..92f1a1be5319 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -107,6 +107,11 @@ const struct clk_ops clk_mux_ops = {
 };
 EXPORT_SYMBOL_GPL(clk_mux_ops);
 
+const struct clk_ops clk_mux_ro_ops = {
+	.get_parent = clk_mux_get_parent,
+};
+EXPORT_SYMBOL_GPL(clk_mux_ro_ops);
+
 struct clk *clk_register_mux_table(struct device *dev, const char *name,
 		const char **parent_names, u8 num_parents, unsigned long flags,
 		void __iomem *reg, u8 shift, u32 mask,
@@ -133,7 +138,10 @@ struct clk *clk_register_mux_table(struct device *dev, const char *name,
 	}
 
 	init.name = name;
-	init.ops = &clk_mux_ops;
+	if (clk_mux_flags & CLK_MUX_READ_ONLY)
+		init.ops = &clk_mux_ro_ops;
+	else
+		init.ops = &clk_mux_ops;
 	init.flags = flags | CLK_IS_BASIC;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;

commit ba492e900704ba00d43c7af9d94b00da4df52587
Author: Haojian Zhuang <haojian.zhuang@linaro.org>
Date:   Sat Jun 8 22:47:17 2013 +0800

    clk: mux: add CLK_MUX_HIWORD_MASK
    
    In both Hisilicon & Rockchip Cortex-A9 based chips, they don't use the
    paradigm of reading-changing-writing the register contents.
    Instead they use a hiword mask to indicate the changed bits.
    
    When b01 should be set as switching mux, it also needs to indicate
    the change by setting hiword mask (b11 << 16).
    
    The patch adds mux flag for this usage.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 25b1734560d0..614444ca40cd 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -86,8 +86,12 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 	if (mux->lock)
 		spin_lock_irqsave(mux->lock, flags);
 
-	val = readl(mux->reg);
-	val &= ~(mux->mask << mux->shift);
+	if (mux->flags & CLK_MUX_HIWORD_MASK) {
+		val = mux->mask << (mux->shift + 16);
+	} else {
+		val = readl(mux->reg);
+		val &= ~(mux->mask << mux->shift);
+	}
 	val |= index << mux->shift;
 	writel(val, mux->reg);
 
@@ -111,6 +115,15 @@ struct clk *clk_register_mux_table(struct device *dev, const char *name,
 	struct clk_mux *mux;
 	struct clk *clk;
 	struct clk_init_data init;
+	u8 width = 0;
+
+	if (clk_mux_flags & CLK_MUX_HIWORD_MASK) {
+		width = fls(mask) - ffs(mask) + 1;
+		if (width + shift > 16) {
+			pr_err("mux value exceeds LOWORD field\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
 
 	/* allocate the mux */
 	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);

commit ce4f3313b05c836c21a91ac89f87dccf84ce9561
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Fri Mar 22 14:07:53 2013 +0200

    clk: add table lookup to mux
    
    Add a table lookup feature to the mux clock. Also allow arbitrary masks
    instead of the width. This will be used by some clocks on Tegra114. Also
    adapt the tegra periph clk because it uses struct clk_mux directly.
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 508c032edce4..25b1734560d0 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -32,6 +32,7 @@
 static u8 clk_mux_get_parent(struct clk_hw *hw)
 {
 	struct clk_mux *mux = to_clk_mux(hw);
+	int num_parents = __clk_get_num_parents(hw->clk);
 	u32 val;
 
 	/*
@@ -42,7 +43,16 @@ static u8 clk_mux_get_parent(struct clk_hw *hw)
 	 * val = 0x4 really means "bit 2, index starts at bit 0"
 	 */
 	val = readl(mux->reg) >> mux->shift;
-	val &= (1 << mux->width) - 1;
+	val &= mux->mask;
+
+	if (mux->table) {
+		int i;
+
+		for (i = 0; i < num_parents; i++)
+			if (mux->table[i] == val)
+				return i;
+		return -EINVAL;
+	}
 
 	if (val && (mux->flags & CLK_MUX_INDEX_BIT))
 		val = ffs(val) - 1;
@@ -50,7 +60,7 @@ static u8 clk_mux_get_parent(struct clk_hw *hw)
 	if (val && (mux->flags & CLK_MUX_INDEX_ONE))
 		val--;
 
-	if (val >= __clk_get_num_parents(hw->clk))
+	if (val >= num_parents)
 		return -EINVAL;
 
 	return val;
@@ -62,17 +72,22 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 	u32 val;
 	unsigned long flags = 0;
 
-	if (mux->flags & CLK_MUX_INDEX_BIT)
-		index = (1 << ffs(index));
+	if (mux->table)
+		index = mux->table[index];
 
-	if (mux->flags & CLK_MUX_INDEX_ONE)
-		index++;
+	else {
+		if (mux->flags & CLK_MUX_INDEX_BIT)
+			index = (1 << ffs(index));
+
+		if (mux->flags & CLK_MUX_INDEX_ONE)
+			index++;
+	}
 
 	if (mux->lock)
 		spin_lock_irqsave(mux->lock, flags);
 
 	val = readl(mux->reg);
-	val &= ~(((1 << mux->width) - 1) << mux->shift);
+	val &= ~(mux->mask << mux->shift);
 	val |= index << mux->shift;
 	writel(val, mux->reg);
 
@@ -88,10 +103,10 @@ const struct clk_ops clk_mux_ops = {
 };
 EXPORT_SYMBOL_GPL(clk_mux_ops);
 
-struct clk *clk_register_mux(struct device *dev, const char *name,
+struct clk *clk_register_mux_table(struct device *dev, const char *name,
 		const char **parent_names, u8 num_parents, unsigned long flags,
-		void __iomem *reg, u8 shift, u8 width,
-		u8 clk_mux_flags, spinlock_t *lock)
+		void __iomem *reg, u8 shift, u32 mask,
+		u8 clk_mux_flags, u32 *table, spinlock_t *lock)
 {
 	struct clk_mux *mux;
 	struct clk *clk;
@@ -113,9 +128,10 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 	/* struct clk_mux assignments */
 	mux->reg = reg;
 	mux->shift = shift;
-	mux->width = width;
+	mux->mask = mask;
 	mux->flags = clk_mux_flags;
 	mux->lock = lock;
+	mux->table = table;
 	mux->hw.init = &init;
 
 	clk = clk_register(dev, &mux->hw);
@@ -125,3 +141,15 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 
 	return clk;
 }
+
+struct clk *clk_register_mux(struct device *dev, const char *name,
+		const char **parent_names, u8 num_parents, unsigned long flags,
+		void __iomem *reg, u8 shift, u8 width,
+		u8 clk_mux_flags, spinlock_t *lock)
+{
+	u32 mask = BIT(width) - 1;
+
+	return clk_register_mux_table(dev, name, parent_names, num_parents,
+				      flags, reg, shift, mask, clk_mux_flags,
+				      NULL, lock);
+}

commit f7d8caadfd2813cbada82ce9041b13c38e8e5282
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Jun 1 14:02:47 2012 +0530

    clk: Add CLK_IS_BASIC flag to identify basic clocks
    
    Most platforms end up using a mix of basic clock types and
    some which use clk_hw_foo struct for filling in custom platform
    information when the clocks don't fit into basic types supported.
    
    In platform code, its useful to know if a clock is using a basic
    type or clk_hw_foo, which helps platforms know if they can
    safely use to_clk_hw_foo to derive the clk_hw_foo pointer from
    clk_hw.
    
    Mark all basic clocks with a CLK_IS_BASIC flag.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index fd36a8ea73d9..508c032edce4 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -106,7 +106,7 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 
 	init.name = name;
 	init.ops = &clk_mux_ops;
-	init.flags = flags;
+	init.flags = flags | CLK_IS_BASIC;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;
 

commit 31df9db99549cd29bbe5e32da4492970e6f97191
Author: Mike Turquette <mturquette@linaro.org>
Date:   Sun May 6 18:48:11 2012 -0700

    clk: mux: assign init data
    
    The original conversion to struct clk_hw_init failed to add the pointer
    assignment in clk_register_mux.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Reported-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 8e97491902e7..fd36a8ea73d9 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -116,6 +116,7 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 	mux->width = width;
 	mux->flags = clk_mux_flags;
 	mux->lock = lock;
+	mux->hw.init = &init;
 
 	clk = clk_register(dev, &mux->hw);
 

commit 0197b3ea0f66cd2a11417f58fe1812858ea77908
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Wed Apr 25 22:58:56 2012 -0700

    clk: Use a separate struct for holding init data.
    
    Create a struct clk_init_data to hold all data that needs to be passed from
    the platfrom specific driver to the common clock framework during clock
    registration. Add a pointer to this struct inside clk_hw.
    
    This has several advantages:
    * Completely hides struct clk from many clock platform drivers and static
      clock initialization code that don't care for static initialization of
      the struct clks.
    * For platforms that want to do complete static initialization, it removed
      the need to directly mess with the struct clk's fields while still
      allowing to statically allocate struct clk. This keeps the code more
      future proof even if they include clk-private.h.
    * Simplifies the generic clk_register() function and allows adding optional
      fields in the future without modifying the function signature.
    * Simplifies the static initialization of clocks on all platforms by
      removing the need for forward delcarations or convoluted macros.
    
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    [mturquette@linaro.org: kept DEFINE_CLK_* macros and __clk_init]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Jeremy Kerr <jeremy.kerr@canonical.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergman <arnd.bergmann@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Shawn Guo <shawn.guo@freescale.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jamie Iles <jamie@jamieiles.com>
    Cc: Richard Zhao <richard.zhao@linaro.org>
    Cc: Saravana Kannan <skannan@codeaurora.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Amit Kucheria <amit.kucheria@linaro.org>
    Cc: Deepak Saxena <dsaxena@linaro.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 6e58f11ab81f..8e97491902e7 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -95,6 +95,7 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 {
 	struct clk_mux *mux;
 	struct clk *clk;
+	struct clk_init_data init;
 
 	/* allocate the mux */
 	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
@@ -103,6 +104,12 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 		return ERR_PTR(-ENOMEM);
 	}
 
+	init.name = name;
+	init.ops = &clk_mux_ops;
+	init.flags = flags;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+
 	/* struct clk_mux assignments */
 	mux->reg = reg;
 	mux->shift = shift;
@@ -110,8 +117,7 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 	mux->flags = clk_mux_flags;
 	mux->lock = lock;
 
-	clk = clk_register(dev, name, &clk_mux_ops, &mux->hw,
-			parent_names, num_parents, flags);
+	clk = clk_register(dev, &mux->hw);
 
 	if (IS_ERR(clk))
 		kfree(mux);

commit 27d545915fd49cbe18a3877d82359896e9851efb
Author: Mike Turquette <mturquette@linaro.org>
Date:   Mon Mar 26 17:51:03 2012 -0700

    clk: basic: improve parent_names & return errors
    
    This patch is the basic clk version of 'clk: core: copy parent_names &
    return error codes'.
    
    The registration functions are changed to allow the core code to copy
    the array of strings and allow platforms to declare those arrays as
    __initdata.
    
    This patch also converts all of the basic clk registration functions to
    return error codes which better aligns them with the existing clk.h api.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index bd5e598b9f1e..6e58f11ab81f 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -94,9 +94,10 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 		u8 clk_mux_flags, spinlock_t *lock)
 {
 	struct clk_mux *mux;
+	struct clk *clk;
 
+	/* allocate the mux */
 	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
-
 	if (!mux) {
 		pr_err("%s: could not allocate mux clk\n", __func__);
 		return ERR_PTR(-ENOMEM);
@@ -109,6 +110,11 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 	mux->flags = clk_mux_flags;
 	mux->lock = lock;
 
-	return clk_register(dev, name, &clk_mux_ops, &mux->hw,
+	clk = clk_register(dev, name, &clk_mux_ops, &mux->hw,
 			parent_names, num_parents, flags);
+
+	if (IS_ERR(clk))
+		kfree(mux);
+
+	return clk;
 }

commit d305fb78f31209596c9135d396a0d3af7ac86947
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 21 20:01:20 2012 +0000

    clk: Constify parent name arrays
    
    Drivers should be able to declare their arrays of parent names as const
    so the APIs need to accept const arguments.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    [mturquette@linaro.org: constified gate]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 54244889a948..bd5e598b9f1e 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -89,7 +89,7 @@ const struct clk_ops clk_mux_ops = {
 EXPORT_SYMBOL_GPL(clk_mux_ops);
 
 struct clk *clk_register_mux(struct device *dev, const char *name,
-		char **parent_names, u8 num_parents, unsigned long flags,
+		const char **parent_names, u8 num_parents, unsigned long flags,
 		void __iomem *reg, u8 shift, u8 width,
 		u8 clk_mux_flags, spinlock_t *lock)
 {

commit 822c250e154cd44cf60a4f0d647aa70abea09520
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Mar 27 15:23:22 2012 +0800

    clk: add "const" for clk_ops of basic clks
    
    The clk_ops of basic clks should have "const" to match the definition
    in "struct clk" and clk_register prototype.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 45cad61600c9..54244889a948 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -82,7 +82,7 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 	return 0;
 }
 
-struct clk_ops clk_mux_ops = {
+const struct clk_ops clk_mux_ops = {
 	.get_parent = clk_mux_get_parent,
 	.set_parent = clk_mux_set_parent,
 };

commit c0d2530c03cbf3741cb7a0f8ebae93e7a563fc58
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Mar 27 15:23:21 2012 +0800

    clk: remove unnecessary EXPORT_SYMBOL_GPL
    
    It makes no sense to have EXPORT_SYMBOL_GPL on static functions.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 50e05953c8d3..45cad61600c9 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -55,7 +55,6 @@ static u8 clk_mux_get_parent(struct clk_hw *hw)
 
 	return val;
 }
-EXPORT_SYMBOL_GPL(clk_mux_get_parent);
 
 static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 {
@@ -82,7 +81,6 @@ static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(clk_mux_set_parent);
 
 struct clk_ops clk_mux_ops = {
 	.get_parent = clk_mux_get_parent,

commit 10363b5838b4d5dcbf01db219f35e91aa94f24c6
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Mar 27 15:23:20 2012 +0800

    clk: use kzalloc in clk_register_mux
    
    Change clk_register_mux to use kzalloc, just like what all other basic
    clk registration functions do.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index c71ad1f41a97..50e05953c8d3 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -97,7 +97,7 @@ struct clk *clk_register_mux(struct device *dev, const char *name,
 {
 	struct clk_mux *mux;
 
-	mux = kmalloc(sizeof(struct clk_mux), GFP_KERNEL);
+	mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
 
 	if (!mux) {
 		pr_err("%s: could not allocate mux clk\n", __func__);

commit 9d9f78ed9af0e465d2fd15550471956e7f559b9f
Author: Mike Turquette <mturquette@linaro.org>
Date:   Thu Mar 15 23:11:20 2012 -0700

    clk: basic clock hardware types
    
    Many platforms support simple gateable clocks, fixed-rate clocks,
    adjustable divider clocks and multi-parent multiplexer clocks.
    
    This patch introduces basic clock types for the above-mentioned hardware
    which share some common characteristics.
    
    Based on original work by Jeremy Kerr and contribution by Jamie Iles.
    Dividers and multiplexor clocks originally contributed by Richard Zhao &
    Sascha Hauer.
    
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@ti.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Jeremy Kerr <jeremy.kerr@canonical.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergman <arnd.bergmann@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Shawn Guo <shawn.guo@freescale.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jamie Iles <jamie@jamieiles.com>
    Cc: Richard Zhao <richard.zhao@linaro.org>
    Cc: Saravana Kannan <skannan@codeaurora.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Amit Kucheria <amit.kucheria@linaro.org>
    Cc: Deepak Saxena <dsaxena@linaro.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
new file mode 100644
index 000000000000..c71ad1f41a97
--- /dev/null
+++ b/drivers/clk/clk-mux.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+ * Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>
+ * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Simple multiplexer clock implementation
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+
+/*
+ * DOC: basic adjustable multiplexer clock that cannot gate
+ *
+ * Traits of this clock:
+ * prepare - clk_prepare only ensures that parents are prepared
+ * enable - clk_enable only ensures that parents are enabled
+ * rate - rate is only affected by parent switching.  No clk_set_rate support
+ * parent - parent is adjustable through clk_set_parent
+ */
+
+#define to_clk_mux(_hw) container_of(_hw, struct clk_mux, hw)
+
+static u8 clk_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	u32 val;
+
+	/*
+	 * FIXME need a mux-specific flag to determine if val is bitwise or numeric
+	 * e.g. sys_clkin_ck's clksel field is 3 bits wide, but ranges from 0x1
+	 * to 0x7 (index starts at one)
+	 * OTOH, pmd_trace_clk_mux_ck uses a separate bit for each clock, so
+	 * val = 0x4 really means "bit 2, index starts at bit 0"
+	 */
+	val = readl(mux->reg) >> mux->shift;
+	val &= (1 << mux->width) - 1;
+
+	if (val && (mux->flags & CLK_MUX_INDEX_BIT))
+		val = ffs(val) - 1;
+
+	if (val && (mux->flags & CLK_MUX_INDEX_ONE))
+		val--;
+
+	if (val >= __clk_get_num_parents(hw->clk))
+		return -EINVAL;
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(clk_mux_get_parent);
+
+static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	u32 val;
+	unsigned long flags = 0;
+
+	if (mux->flags & CLK_MUX_INDEX_BIT)
+		index = (1 << ffs(index));
+
+	if (mux->flags & CLK_MUX_INDEX_ONE)
+		index++;
+
+	if (mux->lock)
+		spin_lock_irqsave(mux->lock, flags);
+
+	val = readl(mux->reg);
+	val &= ~(((1 << mux->width) - 1) << mux->shift);
+	val |= index << mux->shift;
+	writel(val, mux->reg);
+
+	if (mux->lock)
+		spin_unlock_irqrestore(mux->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(clk_mux_set_parent);
+
+struct clk_ops clk_mux_ops = {
+	.get_parent = clk_mux_get_parent,
+	.set_parent = clk_mux_set_parent,
+};
+EXPORT_SYMBOL_GPL(clk_mux_ops);
+
+struct clk *clk_register_mux(struct device *dev, const char *name,
+		char **parent_names, u8 num_parents, unsigned long flags,
+		void __iomem *reg, u8 shift, u8 width,
+		u8 clk_mux_flags, spinlock_t *lock)
+{
+	struct clk_mux *mux;
+
+	mux = kmalloc(sizeof(struct clk_mux), GFP_KERNEL);
+
+	if (!mux) {
+		pr_err("%s: could not allocate mux clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* struct clk_mux assignments */
+	mux->reg = reg;
+	mux->shift = shift;
+	mux->width = width;
+	mux->flags = clk_mux_flags;
+	mux->lock = lock;
+
+	return clk_register(dev, name, &clk_mux_ops, &mux->hw,
+			parent_names, num_parents, flags);
+}
