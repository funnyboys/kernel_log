commit b7d950b9281f1dc5a5e37eaaf04cf33067e575f6
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Wed May 27 01:20:55 2020 +0300

    clk: Add Baikal-T1 CCU PLLs driver
    
    Baikal-T1 is supposed to be supplied with a high-frequency external
    oscillator. But in order to create signals suitable for each IP-block
    embedded into the SoC the oscillator output is primarily connected to
    a set of CCU PLLs. There are five of them to create clocks for the MIPS
    P5600 cores, an embedded DDR controller, SATA, Ethernet and PCIe domains.
    The last three domains though named by the biggest system interfaces in
    fact include nearly all of the rest SoC peripherals. Each of the PLLs is
    based on True Circuits TSMC CLN28HPM IP-core with an interface wrapper
    (so called safe PLL' clocks switcher) to simplify the PLL configuration
    procedure.
    
    This driver creates the of-based hardware clocks to use them then in
    the corresponding subsystems. In order to simplify the driver code we
    split the functionality up into the PLLs clocks operations and hardware
    clocks declaration/registration procedures.
    
    Even though the PLLs are based on the same IP-core, they may have some
    differences. In particular, some CCU PLLs support the output clock change
    without gating them (like CPU or PCIe PLLs), while the others don't, some
    CCU PLLs are critical and aren't supposed to be gated. In order to cover
    all of these cases the hardware clocks driver is designed with an
    info-descriptor pattern. So there are special static descriptors declared
    for each PLL, which is then used to create a hardware clock with proper
    operations. Additionally debugfs-files are provided for each PLL' field
    to make sure the implemented rate-PLLs-dividers calculation algorithm is
    correct.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Link: https://lore.kernel.org/r/20200526222056.18072-4-Sergey.Semin@baikalelectronics.ru
    [sboyd@kernel.org: Silence sparse warning about initializing structs
    with NULL vs. integer]
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/baikal-t1/ccu-pll.h b/drivers/clk/baikal-t1/ccu-pll.h
new file mode 100644
index 000000000000..76cd9132a219
--- /dev/null
+++ b/drivers/clk/baikal-t1/ccu-pll.h
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
+ *
+ * Baikal-T1 CCU PLL interface driver
+ */
+#ifndef __CLK_BT1_CCU_PLL_H__
+#define __CLK_BT1_CCU_PLL_H__
+
+#include <linux/clk-provider.h>
+#include <linux/spinlock.h>
+#include <linux/regmap.h>
+#include <linux/bits.h>
+#include <linux/of.h>
+
+/*
+ * struct ccu_pll_init_data - CCU PLL initialization data
+ * @id: Clock private identifier.
+ * @name: Clocks name.
+ * @parent_name: Clocks parent name in a fw node.
+ * @base: PLL registers base address with respect to the sys_regs base.
+ * @sys_regs: Baikal-T1 System Controller registers map.
+ * @np: Pointer to the node describing the CCU PLLs.
+ * @flags: PLL clock flags.
+ */
+struct ccu_pll_init_data {
+	unsigned int id;
+	const char *name;
+	const char *parent_name;
+	unsigned int base;
+	struct regmap *sys_regs;
+	struct device_node *np;
+	unsigned long flags;
+};
+
+/*
+ * struct ccu_pll - CCU PLL descriptor
+ * @hw: clk_hw of the PLL.
+ * @id: Clock private identifier.
+ * @reg_ctl: PLL control register base.
+ * @reg_ctl1: PLL control1 register base.
+ * @sys_regs: Baikal-T1 System Controller registers map.
+ * @lock: PLL state change spin-lock.
+ */
+struct ccu_pll {
+	struct clk_hw hw;
+	unsigned int id;
+	unsigned int reg_ctl;
+	unsigned int reg_ctl1;
+	struct regmap *sys_regs;
+	spinlock_t lock;
+};
+#define to_ccu_pll(_hw) container_of(_hw, struct ccu_pll, hw)
+
+static inline struct clk_hw *ccu_pll_get_clk_hw(struct ccu_pll *pll)
+{
+	return pll ? &pll->hw : NULL;
+}
+
+struct ccu_pll *ccu_pll_hw_register(const struct ccu_pll_init_data *init);
+
+void ccu_pll_hw_unregister(struct ccu_pll *pll);
+
+#endif /* __CLK_BT1_CCU_PLL_H__ */
