commit 9d9cc58aff468c1589df09ac12e4e79b1eaba6db
Author: 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
Date:   Thu May 28 11:15:44 2020 +0800

    clk: Ingenic: Adjust cgu code to make it compatible with X1830.
    
    The PLL of X1830 Soc from Ingenic has been greatly changed,
    the bypass control is placed in another register, so now two
    registers may needed to control the PLL. To this end, a new
    "bypass_reg" was introduced. In addition, when calculating
    rate, the PLL of X1830 introduced an extra 2x multiplier,
    so a new "rate_multiplier" was introduced. And adjust the
    code in jz47xx-cgu.c and x1000-cgu.c, make it to be
    compatible with the new cgu code.
    
    Signed-off-by: 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
    Reviewed-by: Paul Cercueil <paul@crapouillou.net>
    Link: https://lkml.kernel.org/r/20200528031549.13846-3-zhouyanjie@wanyeetech.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index c051ecba5cf8..9ea4490ecb7f 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -9,7 +9,9 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/of.h>
+
 #include <dt-bindings/clock/jz4770-cgu.h>
+
 #include "cgu.h"
 #include "pm.h"
 
@@ -102,6 +104,7 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 		.parents = { JZ4770_CLK_EXT },
 		.pll = {
 			.reg = CGU_REG_CPPCR0,
+			.rate_multiplier = 1,
 			.m_shift = 24,
 			.m_bits = 7,
 			.m_offset = 1,
@@ -112,6 +115,7 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 			.od_bits = 2,
 			.od_max = 8,
 			.od_encoding = pll_od_encoding,
+			.bypass_reg = CGU_REG_CPPCR0,
 			.bypass_bit = 9,
 			.enable_bit = 8,
 			.stable_bit = 10,
@@ -124,6 +128,7 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 		.parents = { JZ4770_CLK_EXT },
 		.pll = {
 			.reg = CGU_REG_CPPCR1,
+			.rate_multiplier = 1,
 			.m_shift = 24,
 			.m_bits = 7,
 			.m_offset = 1,
@@ -134,9 +139,10 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 			.od_bits = 2,
 			.od_max = 8,
 			.od_encoding = pll_od_encoding,
+			.bypass_reg = CGU_REG_CPPCR1,
+			.no_bypass_bit = true,
 			.enable_bit = 7,
 			.stable_bit = 6,
-			.no_bypass_bit = true,
 		},
 	},
 

commit c067b46d731a764fc46ecc466c2967088c97089e
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Thu Feb 13 13:19:51 2020 -0300

    clk: ingenic/jz4770: Exit with error if CGU init failed
    
    Exit jz4770_cgu_init() if the 'cgu' pointer we get is NULL, since the
    pointer is passed as argument to functions later on.
    
    Fixes: 7a01c19007ad ("clk: Add Ingenic jz4770 CGU driver")
    Cc: stable@vger.kernel.org
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Link: https://lkml.kernel.org/r/20200213161952.37460-1-paul@crapouillou.net
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index 956dd653a43d..c051ecba5cf8 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -432,8 +432,10 @@ static void __init jz4770_cgu_init(struct device_node *np)
 
 	cgu = ingenic_cgu_new(jz4770_cgu_clocks,
 			      ARRAY_SIZE(jz4770_cgu_clocks), np);
-	if (!cgu)
+	if (!cgu) {
 		pr_err("%s: failed to initialise CGU\n", __func__);
+		return;
+	}
 
 	retval = ingenic_cgu_register_clocks(cgu);
 	if (retval)

commit 03d570e1a4dc669457af2888999ecc9548fc0d2a
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Sat Aug 10 14:36:20 2019 +0200

    clk: ingenic: Use CLK_OF_DECLARE_DRIVER macro
    
    By using CLK_OF_DECLARE_DRIVER instead of the CLK_OF_DECLARE macro, we
    allow the driver to probe also as a platform driver.
    
    While this driver does not have code to probe as a platform driver, this
    is still useful for probing children devices in the case where the
    device node is compatible with "simple-mfd".
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Link: https://lkml.kernel.org/r/20190810123620.27238-1-paul@crapouillou.net
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index eebc1bea3841..956dd653a43d 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -443,4 +443,4 @@ static void __init jz4770_cgu_init(struct device_node *np)
 }
 
 /* We only probe via devicetree, no need for a platform driver */
-CLK_OF_DECLARE(jz4770_cgu, "ingenic,jz4770-cgu", jz4770_cgu_init);
+CLK_OF_DECLARE_DRIVER(jz4770_cgu, "ingenic,jz4770-cgu", jz4770_cgu_init);

commit 2ee93e3c953b7263c21ce61e7c42e33d0539bef9
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Tue Jun 11 20:07:54 2019 +0200

    clk: ingenic: Handle setting the Low-Power Mode bit
    
    The Low-Power Mode, when enabled, will make the "wait" MIPS instruction
    suspend the system.
    
    This is not really clock-related, but this bit happens to be in the
    register set of the CGU.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index 2a29da442a8e..eebc1bea3841 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -9,9 +9,9 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/of.h>
-#include <linux/syscore_ops.h>
 #include <dt-bindings/clock/jz4770-cgu.h>
 #include "cgu.h"
+#include "pm.h"
 
 /*
  * CPM registers offset address definition
@@ -38,9 +38,6 @@
 #define CGU_REG_MSC2CDR		0xA8
 #define CGU_REG_BCHCDR		0xAC
 
-/* bits within the LCR register */
-#define LCR_LPM			BIT(0)		/* Low Power Mode */
-
 /* bits within the OPCR register */
 #define OPCR_SPENDH		BIT(5)		/* UHC PHY suspend */
 
@@ -429,30 +426,6 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 	},
 };
 
-#if IS_ENABLED(CONFIG_PM_SLEEP)
-static int jz4770_cgu_pm_suspend(void)
-{
-	u32 val;
-
-	val = readl(cgu->base + CGU_REG_LCR);
-	writel(val | LCR_LPM, cgu->base + CGU_REG_LCR);
-	return 0;
-}
-
-static void jz4770_cgu_pm_resume(void)
-{
-	u32 val;
-
-	val = readl(cgu->base + CGU_REG_LCR);
-	writel(val & ~LCR_LPM, cgu->base + CGU_REG_LCR);
-}
-
-static struct syscore_ops jz4770_cgu_pm_ops = {
-	.suspend = jz4770_cgu_pm_suspend,
-	.resume = jz4770_cgu_pm_resume,
-};
-#endif /* CONFIG_PM_SLEEP */
-
 static void __init jz4770_cgu_init(struct device_node *np)
 {
 	int retval;
@@ -466,9 +439,7 @@ static void __init jz4770_cgu_init(struct device_node *np)
 	if (retval)
 		pr_err("%s: failed to register CGU Clocks\n", __func__);
 
-#if IS_ENABLED(CONFIG_PM_SLEEP)
-	register_syscore_ops(&jz4770_cgu_pm_ops);
-#endif
+	ingenic_cgu_register_syscore_ops(cgu);
 }
 
 /* We only probe via devicetree, no need for a platform driver */

commit 44b06a76ad330f327fe2366472a83d7d1d06d86e
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Thu May 2 23:25:00 2019 +0200

    clk: ingenic/jz4770: Fix incorrect dividers for main clocks
    
    The main clocks (cclk, h0clk, h1clk, h2clk, c1clk, pclk) were using
    incorrect dividers, and thus reported an incorrect rate.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index dfce740c25a8..2a29da442a8e 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -87,6 +87,10 @@ static const s8 pll_od_encoding[8] = {
 	0x0, 0x1, -1, 0x2, -1, -1, -1, 0x3,
 };
 
+static const u8 jz4770_cgu_cpccr_div_table[] = {
+	1, 2, 3, 4, 6, 8, 12,
+};
+
 static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 
 	/* External clocks */
@@ -144,34 +148,52 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 	[JZ4770_CLK_CCLK] = {
 		"cclk", CGU_CLK_DIV,
 		.parents = { JZ4770_CLK_PLL0, },
-		.div = { CGU_REG_CPCCR, 0, 1, 4, 22, -1, -1 },
+		.div = {
+			CGU_REG_CPCCR, 0, 1, 4, 22, -1, -1,
+			jz4770_cgu_cpccr_div_table,
+		},
 	},
 	[JZ4770_CLK_H0CLK] = {
 		"h0clk", CGU_CLK_DIV,
 		.parents = { JZ4770_CLK_PLL0, },
-		.div = { CGU_REG_CPCCR, 4, 1, 4, 22, -1, -1 },
+		.div = {
+			CGU_REG_CPCCR, 4, 1, 4, 22, -1, -1,
+			jz4770_cgu_cpccr_div_table,
+		},
 	},
 	[JZ4770_CLK_H1CLK] = {
 		"h1clk", CGU_CLK_DIV | CGU_CLK_GATE,
 		.parents = { JZ4770_CLK_PLL0, },
-		.div = { CGU_REG_CPCCR, 24, 1, 4, 22, -1, -1 },
+		.div = {
+			CGU_REG_CPCCR, 24, 1, 4, 22, -1, -1,
+			jz4770_cgu_cpccr_div_table,
+		},
 		.gate = { CGU_REG_CLKGR1, 7 },
 	},
 	[JZ4770_CLK_H2CLK] = {
 		"h2clk", CGU_CLK_DIV,
 		.parents = { JZ4770_CLK_PLL0, },
-		.div = { CGU_REG_CPCCR, 16, 1, 4, 22, -1, -1 },
+		.div = {
+			CGU_REG_CPCCR, 16, 1, 4, 22, -1, -1,
+			jz4770_cgu_cpccr_div_table,
+		},
 	},
 	[JZ4770_CLK_C1CLK] = {
 		"c1clk", CGU_CLK_DIV | CGU_CLK_GATE,
 		.parents = { JZ4770_CLK_PLL0, },
-		.div = { CGU_REG_CPCCR, 12, 1, 4, 22, -1, -1 },
+		.div = {
+			CGU_REG_CPCCR, 12, 1, 4, 22, -1, -1,
+			jz4770_cgu_cpccr_div_table,
+		},
 		.gate = { CGU_REG_OPCR, 31, true }, // disable CCLK stop on idle
 	},
 	[JZ4770_CLK_PCLK] = {
 		"pclk", CGU_CLK_DIV,
 		.parents = { JZ4770_CLK_PLL0, },
-		.div = { CGU_REG_CPCCR, 8, 1, 4, 22, -1, -1 },
+		.div = {
+			CGU_REG_CPCCR, 8, 1, 4, 22, -1, -1,
+			jz4770_cgu_cpccr_div_table,
+		},
 	},
 
 	/* Those divided clocks can connect to PLL0 or PLL1 */

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index bf46a0df2004..dfce740c25a8 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -7,6 +7,7 @@
 #include <linux/bitops.h>
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
+#include <linux/io.h>
 #include <linux/of.h>
 #include <linux/syscore_ops.h>
 #include <dt-bindings/clock/jz4770-cgu.h>

commit 6ee3d385c263248ce0ab2fcd679835082530445d
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Sun May 20 16:31:17 2018 +0000

    clk: ingenic: jz4770: Add 150us delay after enabling VPU clock
    
    This is required, as we must not use the AHB1 bus before it is stable.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index 314f3143ca61..bf46a0df2004 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -362,7 +362,7 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 	[JZ4770_CLK_VPU] = {
 		"vpu", CGU_CLK_GATE,
 		.parents = { JZ4770_CLK_H1CLK, },
-		.gate = { CGU_REG_LCR, 30 },
+		.gate = { CGU_REG_LCR, 30, false, 150 },
 	},
 	[JZ4770_CLK_MMC0] = {
 		"mmc0", CGU_CLK_GATE,

commit a6523b6fb8b54bd53b63c1ca171bed7d9dd3f68e
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Sun May 20 16:31:16 2018 +0000

    clk: ingenic: jz4770: Enable power of AHB1 bus after ungating VPU clock
    
    This was broken before, because the AHB1 bus was enabled before the VPU
    clock was ungated, while it must be done afterwards.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index a5ad69464e57..314f3143ca61 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -154,7 +154,7 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 		"h1clk", CGU_CLK_DIV | CGU_CLK_GATE,
 		.parents = { JZ4770_CLK_PLL0, },
 		.div = { CGU_REG_CPCCR, 24, 1, 4, 22, -1, -1 },
-		.gate = { CGU_REG_LCR, 30 },
+		.gate = { CGU_REG_CLKGR1, 7 },
 	},
 	[JZ4770_CLK_H2CLK] = {
 		"h2clk", CGU_CLK_DIV,
@@ -362,7 +362,7 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 	[JZ4770_CLK_VPU] = {
 		"vpu", CGU_CLK_GATE,
 		.parents = { JZ4770_CLK_H1CLK, },
-		.gate = { CGU_REG_CLKGR1, 7 },
+		.gate = { CGU_REG_LCR, 30 },
 	},
 	[JZ4770_CLK_MMC0] = {
 		"mmc0", CGU_CLK_GATE,

commit 45ba63a29fd9b8a461110185e3abc5b4c90b806a
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Sun May 20 16:31:15 2018 +0000

    clk: ingenic: jz4770: Modify C1CLK clock to disable CPU clock stop on idle
    
    When the main processor goes idle, by default its clock is stopped.
    However, this also stops the clock of the co-processor.
    
    Here, if the C1CLK clock is enabled, we disable this functionality.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index 226c8016f6b0..a5ad69464e57 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -162,9 +162,10 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 		.div = { CGU_REG_CPCCR, 16, 1, 4, 22, -1, -1 },
 	},
 	[JZ4770_CLK_C1CLK] = {
-		"c1clk", CGU_CLK_DIV,
+		"c1clk", CGU_CLK_DIV | CGU_CLK_GATE,
 		.parents = { JZ4770_CLK_PLL0, },
 		.div = { CGU_REG_CPCCR, 12, 1, 4, 22, -1, -1 },
+		.gate = { CGU_REG_OPCR, 31, true }, // disable CCLK stop on idle
 	},
 	[JZ4770_CLK_PCLK] = {
 		"pclk", CGU_CLK_DIV,

commit 11b689a3e790791ceeb17e3fe25046ad56ac966d
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Sun May 20 16:31:14 2018 +0000

    clk: ingenic: jz4770: Change OTG from custom to standard gated clock
    
    We now have the means to express the specificities of the OTG clock with
    the common CGU code.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
index c78d369b9403..226c8016f6b0 100644
--- a/drivers/clk/ingenic/jz4770-cgu.c
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -42,7 +42,6 @@
 
 /* bits within the OPCR register */
 #define OPCR_SPENDH		BIT(5)		/* UHC PHY suspend */
-#define OPCR_SPENDN		BIT(7)		/* OTG PHY suspend */
 
 /* bits within the USBPCR1 register */
 #define USBPCR1_UHC_POWER	BIT(5)		/* UHC PHY power down */
@@ -83,37 +82,6 @@ static const struct clk_ops jz4770_uhc_phy_ops = {
 	.is_enabled = jz4770_uhc_phy_is_enabled,
 };
 
-static int jz4770_otg_phy_enable(struct clk_hw *hw)
-{
-	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
-
-	writel(readl(reg_opcr) | OPCR_SPENDN, reg_opcr);
-
-	/* Wait for the clock to be stable */
-	udelay(50);
-	return 0;
-}
-
-static void jz4770_otg_phy_disable(struct clk_hw *hw)
-{
-	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
-
-	writel(readl(reg_opcr) & ~OPCR_SPENDN, reg_opcr);
-}
-
-static int jz4770_otg_phy_is_enabled(struct clk_hw *hw)
-{
-	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
-
-	return !!(readl(reg_opcr) & OPCR_SPENDN);
-}
-
-static const struct clk_ops jz4770_otg_phy_ops = {
-	.enable = jz4770_otg_phy_enable,
-	.disable = jz4770_otg_phy_disable,
-	.is_enabled = jz4770_otg_phy_is_enabled,
-};
-
 static const s8 pll_od_encoding[8] = {
 	0x0, 0x1, -1, 0x2, -1, -1, -1, 0x3,
 };
@@ -410,6 +378,11 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 		.parents = { JZ4770_CLK_MMC2_MUX, },
 		.gate = { CGU_REG_CLKGR0, 12 },
 	},
+	[JZ4770_CLK_OTG_PHY] = {
+		"usb_phy", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_OTG },
+		.gate = { CGU_REG_OPCR, 7, true, 50 },
+	},
 
 	/* Custom clocks */
 
@@ -418,11 +391,6 @@ static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
 		.parents = { JZ4770_CLK_UHC, -1, -1, -1 },
 		.custom = { &jz4770_uhc_phy_ops },
 	},
-	[JZ4770_CLK_OTG_PHY] = {
-		"usb_phy", CGU_CLK_CUSTOM,
-		.parents = { JZ4770_CLK_OTG, -1, -1, -1 },
-		.custom = { &jz4770_otg_phy_ops },
-	},
 
 	[JZ4770_CLK_EXT512] = {
 		"ext/512", CGU_CLK_FIXDIV,

commit 7a01c19007ad3c7de15d6d8d712e01f40eeed55a
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Tue Jan 16 16:47:56 2018 +0100

    clk: Add Ingenic jz4770 CGU driver
    
    Add support for the clocks provided by the CGU in the Ingenic JZ4770
    SoC.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Maarten ter Huurne <maarten@treewalker.org>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18482/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/drivers/clk/ingenic/jz4770-cgu.c b/drivers/clk/ingenic/jz4770-cgu.c
new file mode 100644
index 000000000000..c78d369b9403
--- /dev/null
+++ b/drivers/clk/ingenic/jz4770-cgu.c
@@ -0,0 +1,483 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * JZ4770 SoC CGU driver
+ * Copyright 2018, Paul Cercueil <paul@crapouillou.net>
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/syscore_ops.h>
+#include <dt-bindings/clock/jz4770-cgu.h>
+#include "cgu.h"
+
+/*
+ * CPM registers offset address definition
+ */
+#define CGU_REG_CPCCR		0x00
+#define CGU_REG_LCR		0x04
+#define CGU_REG_CPPCR0		0x10
+#define CGU_REG_CLKGR0		0x20
+#define CGU_REG_OPCR		0x24
+#define CGU_REG_CLKGR1		0x28
+#define CGU_REG_CPPCR1		0x30
+#define CGU_REG_USBPCR1		0x48
+#define CGU_REG_USBCDR		0x50
+#define CGU_REG_I2SCDR		0x60
+#define CGU_REG_LPCDR		0x64
+#define CGU_REG_MSC0CDR		0x68
+#define CGU_REG_UHCCDR		0x6c
+#define CGU_REG_SSICDR		0x74
+#define CGU_REG_CIMCDR		0x7c
+#define CGU_REG_GPSCDR		0x80
+#define CGU_REG_PCMCDR		0x84
+#define CGU_REG_GPUCDR		0x88
+#define CGU_REG_MSC1CDR		0xA4
+#define CGU_REG_MSC2CDR		0xA8
+#define CGU_REG_BCHCDR		0xAC
+
+/* bits within the LCR register */
+#define LCR_LPM			BIT(0)		/* Low Power Mode */
+
+/* bits within the OPCR register */
+#define OPCR_SPENDH		BIT(5)		/* UHC PHY suspend */
+#define OPCR_SPENDN		BIT(7)		/* OTG PHY suspend */
+
+/* bits within the USBPCR1 register */
+#define USBPCR1_UHC_POWER	BIT(5)		/* UHC PHY power down */
+
+static struct ingenic_cgu *cgu;
+
+static int jz4770_uhc_phy_enable(struct clk_hw *hw)
+{
+	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
+	void __iomem *reg_usbpcr1	= cgu->base + CGU_REG_USBPCR1;
+
+	writel(readl(reg_opcr) & ~OPCR_SPENDH, reg_opcr);
+	writel(readl(reg_usbpcr1) | USBPCR1_UHC_POWER, reg_usbpcr1);
+	return 0;
+}
+
+static void jz4770_uhc_phy_disable(struct clk_hw *hw)
+{
+	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
+	void __iomem *reg_usbpcr1	= cgu->base + CGU_REG_USBPCR1;
+
+	writel(readl(reg_usbpcr1) & ~USBPCR1_UHC_POWER, reg_usbpcr1);
+	writel(readl(reg_opcr) | OPCR_SPENDH, reg_opcr);
+}
+
+static int jz4770_uhc_phy_is_enabled(struct clk_hw *hw)
+{
+	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
+	void __iomem *reg_usbpcr1	= cgu->base + CGU_REG_USBPCR1;
+
+	return !(readl(reg_opcr) & OPCR_SPENDH) &&
+		(readl(reg_usbpcr1) & USBPCR1_UHC_POWER);
+}
+
+static const struct clk_ops jz4770_uhc_phy_ops = {
+	.enable = jz4770_uhc_phy_enable,
+	.disable = jz4770_uhc_phy_disable,
+	.is_enabled = jz4770_uhc_phy_is_enabled,
+};
+
+static int jz4770_otg_phy_enable(struct clk_hw *hw)
+{
+	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
+
+	writel(readl(reg_opcr) | OPCR_SPENDN, reg_opcr);
+
+	/* Wait for the clock to be stable */
+	udelay(50);
+	return 0;
+}
+
+static void jz4770_otg_phy_disable(struct clk_hw *hw)
+{
+	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
+
+	writel(readl(reg_opcr) & ~OPCR_SPENDN, reg_opcr);
+}
+
+static int jz4770_otg_phy_is_enabled(struct clk_hw *hw)
+{
+	void __iomem *reg_opcr		= cgu->base + CGU_REG_OPCR;
+
+	return !!(readl(reg_opcr) & OPCR_SPENDN);
+}
+
+static const struct clk_ops jz4770_otg_phy_ops = {
+	.enable = jz4770_otg_phy_enable,
+	.disable = jz4770_otg_phy_disable,
+	.is_enabled = jz4770_otg_phy_is_enabled,
+};
+
+static const s8 pll_od_encoding[8] = {
+	0x0, 0x1, -1, 0x2, -1, -1, -1, 0x3,
+};
+
+static const struct ingenic_cgu_clk_info jz4770_cgu_clocks[] = {
+
+	/* External clocks */
+
+	[JZ4770_CLK_EXT] = { "ext", CGU_CLK_EXT },
+	[JZ4770_CLK_OSC32K] = { "osc32k", CGU_CLK_EXT },
+
+	/* PLLs */
+
+	[JZ4770_CLK_PLL0] = {
+		"pll0", CGU_CLK_PLL,
+		.parents = { JZ4770_CLK_EXT },
+		.pll = {
+			.reg = CGU_REG_CPPCR0,
+			.m_shift = 24,
+			.m_bits = 7,
+			.m_offset = 1,
+			.n_shift = 18,
+			.n_bits = 5,
+			.n_offset = 1,
+			.od_shift = 16,
+			.od_bits = 2,
+			.od_max = 8,
+			.od_encoding = pll_od_encoding,
+			.bypass_bit = 9,
+			.enable_bit = 8,
+			.stable_bit = 10,
+		},
+	},
+
+	[JZ4770_CLK_PLL1] = {
+		/* TODO: PLL1 can depend on PLL0 */
+		"pll1", CGU_CLK_PLL,
+		.parents = { JZ4770_CLK_EXT },
+		.pll = {
+			.reg = CGU_REG_CPPCR1,
+			.m_shift = 24,
+			.m_bits = 7,
+			.m_offset = 1,
+			.n_shift = 18,
+			.n_bits = 5,
+			.n_offset = 1,
+			.od_shift = 16,
+			.od_bits = 2,
+			.od_max = 8,
+			.od_encoding = pll_od_encoding,
+			.enable_bit = 7,
+			.stable_bit = 6,
+			.no_bypass_bit = true,
+		},
+	},
+
+	/* Main clocks */
+
+	[JZ4770_CLK_CCLK] = {
+		"cclk", CGU_CLK_DIV,
+		.parents = { JZ4770_CLK_PLL0, },
+		.div = { CGU_REG_CPCCR, 0, 1, 4, 22, -1, -1 },
+	},
+	[JZ4770_CLK_H0CLK] = {
+		"h0clk", CGU_CLK_DIV,
+		.parents = { JZ4770_CLK_PLL0, },
+		.div = { CGU_REG_CPCCR, 4, 1, 4, 22, -1, -1 },
+	},
+	[JZ4770_CLK_H1CLK] = {
+		"h1clk", CGU_CLK_DIV | CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_PLL0, },
+		.div = { CGU_REG_CPCCR, 24, 1, 4, 22, -1, -1 },
+		.gate = { CGU_REG_LCR, 30 },
+	},
+	[JZ4770_CLK_H2CLK] = {
+		"h2clk", CGU_CLK_DIV,
+		.parents = { JZ4770_CLK_PLL0, },
+		.div = { CGU_REG_CPCCR, 16, 1, 4, 22, -1, -1 },
+	},
+	[JZ4770_CLK_C1CLK] = {
+		"c1clk", CGU_CLK_DIV,
+		.parents = { JZ4770_CLK_PLL0, },
+		.div = { CGU_REG_CPCCR, 12, 1, 4, 22, -1, -1 },
+	},
+	[JZ4770_CLK_PCLK] = {
+		"pclk", CGU_CLK_DIV,
+		.parents = { JZ4770_CLK_PLL0, },
+		.div = { CGU_REG_CPCCR, 8, 1, 4, 22, -1, -1 },
+	},
+
+	/* Those divided clocks can connect to PLL0 or PLL1 */
+
+	[JZ4770_CLK_MMC0_MUX] = {
+		"mmc0_mux", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_MSC0CDR, 30, 1 },
+		.div = { CGU_REG_MSC0CDR, 0, 1, 7, -1, -1, 31 },
+		.gate = { CGU_REG_MSC0CDR, 31 },
+	},
+	[JZ4770_CLK_MMC1_MUX] = {
+		"mmc1_mux", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_MSC1CDR, 30, 1 },
+		.div = { CGU_REG_MSC1CDR, 0, 1, 7, -1, -1, 31 },
+		.gate = { CGU_REG_MSC1CDR, 31 },
+	},
+	[JZ4770_CLK_MMC2_MUX] = {
+		"mmc2_mux", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_MSC2CDR, 30, 1 },
+		.div = { CGU_REG_MSC2CDR, 0, 1, 7, -1, -1, 31 },
+		.gate = { CGU_REG_MSC2CDR, 31 },
+	},
+	[JZ4770_CLK_CIM] = {
+		"cim", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_CIMCDR, 31, 1 },
+		.div = { CGU_REG_CIMCDR, 0, 1, 8, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR0, 26 },
+	},
+	[JZ4770_CLK_UHC] = {
+		"uhc", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_UHCCDR, 29, 1 },
+		.div = { CGU_REG_UHCCDR, 0, 1, 4, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR0, 24 },
+	},
+	[JZ4770_CLK_GPU] = {
+		"gpu", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, -1 },
+		.mux = { CGU_REG_GPUCDR, 31, 1 },
+		.div = { CGU_REG_GPUCDR, 0, 1, 3, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR1, 9 },
+	},
+	[JZ4770_CLK_BCH] = {
+		"bch", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_BCHCDR, 31, 1 },
+		.div = { CGU_REG_BCHCDR, 0, 1, 3, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR0, 1 },
+	},
+	[JZ4770_CLK_LPCLK_MUX] = {
+		"lpclk", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_LPCDR, 29, 1 },
+		.div = { CGU_REG_LPCDR, 0, 1, 11, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR0, 28 },
+	},
+	[JZ4770_CLK_GPS] = {
+		"gps", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_PLL0, JZ4770_CLK_PLL1, },
+		.mux = { CGU_REG_GPSCDR, 31, 1 },
+		.div = { CGU_REG_GPSCDR, 0, 1, 4, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR0, 22 },
+	},
+
+	/* Those divided clocks can connect to EXT, PLL0 or PLL1 */
+
+	[JZ4770_CLK_SSI_MUX] = {
+		"ssi_mux", CGU_CLK_DIV | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_EXT, -1,
+			JZ4770_CLK_PLL0, JZ4770_CLK_PLL1 },
+		.mux = { CGU_REG_SSICDR, 30, 2 },
+		.div = { CGU_REG_SSICDR, 0, 1, 6, -1, -1, -1 },
+	},
+	[JZ4770_CLK_PCM_MUX] = {
+		"pcm_mux", CGU_CLK_DIV | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_EXT, -1,
+			JZ4770_CLK_PLL0, JZ4770_CLK_PLL1 },
+		.mux = { CGU_REG_PCMCDR, 30, 2 },
+		.div = { CGU_REG_PCMCDR, 0, 1, 9, -1, -1, -1 },
+	},
+	[JZ4770_CLK_I2S] = {
+		"i2s", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_EXT, -1,
+			JZ4770_CLK_PLL0, JZ4770_CLK_PLL1 },
+		.mux = { CGU_REG_I2SCDR, 30, 2 },
+		.div = { CGU_REG_I2SCDR, 0, 1, 9, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR1, 13 },
+	},
+	[JZ4770_CLK_OTG] = {
+		"usb", CGU_CLK_DIV | CGU_CLK_GATE | CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_EXT, -1,
+			JZ4770_CLK_PLL0, JZ4770_CLK_PLL1 },
+		.mux = { CGU_REG_USBCDR, 30, 2 },
+		.div = { CGU_REG_USBCDR, 0, 1, 8, -1, -1, -1 },
+		.gate = { CGU_REG_CLKGR0, 2 },
+	},
+
+	/* Gate-only clocks */
+
+	[JZ4770_CLK_SSI0] = {
+		"ssi0", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_SSI_MUX, },
+		.gate = { CGU_REG_CLKGR0, 4 },
+	},
+	[JZ4770_CLK_SSI1] = {
+		"ssi1", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_SSI_MUX, },
+		.gate = { CGU_REG_CLKGR0, 19 },
+	},
+	[JZ4770_CLK_SSI2] = {
+		"ssi2", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_SSI_MUX, },
+		.gate = { CGU_REG_CLKGR0, 20 },
+	},
+	[JZ4770_CLK_PCM0] = {
+		"pcm0", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_PCM_MUX, },
+		.gate = { CGU_REG_CLKGR1, 8 },
+	},
+	[JZ4770_CLK_PCM1] = {
+		"pcm1", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_PCM_MUX, },
+		.gate = { CGU_REG_CLKGR1, 10 },
+	},
+	[JZ4770_CLK_DMA] = {
+		"dma", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_H2CLK, },
+		.gate = { CGU_REG_CLKGR0, 21 },
+	},
+	[JZ4770_CLK_I2C0] = {
+		"i2c0", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 5 },
+	},
+	[JZ4770_CLK_I2C1] = {
+		"i2c1", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 6 },
+	},
+	[JZ4770_CLK_I2C2] = {
+		"i2c2", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR1, 15 },
+	},
+	[JZ4770_CLK_UART0] = {
+		"uart0", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 15 },
+	},
+	[JZ4770_CLK_UART1] = {
+		"uart1", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 16 },
+	},
+	[JZ4770_CLK_UART2] = {
+		"uart2", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 17 },
+	},
+	[JZ4770_CLK_UART3] = {
+		"uart3", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 18 },
+	},
+	[JZ4770_CLK_IPU] = {
+		"ipu", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_H0CLK, },
+		.gate = { CGU_REG_CLKGR0, 29 },
+	},
+	[JZ4770_CLK_ADC] = {
+		"adc", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 14 },
+	},
+	[JZ4770_CLK_AIC] = {
+		"aic", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_EXT, },
+		.gate = { CGU_REG_CLKGR0, 8 },
+	},
+	[JZ4770_CLK_AUX] = {
+		"aux", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_C1CLK, },
+		.gate = { CGU_REG_CLKGR1, 14 },
+	},
+	[JZ4770_CLK_VPU] = {
+		"vpu", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_H1CLK, },
+		.gate = { CGU_REG_CLKGR1, 7 },
+	},
+	[JZ4770_CLK_MMC0] = {
+		"mmc0", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_MMC0_MUX, },
+		.gate = { CGU_REG_CLKGR0, 3 },
+	},
+	[JZ4770_CLK_MMC1] = {
+		"mmc1", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_MMC1_MUX, },
+		.gate = { CGU_REG_CLKGR0, 11 },
+	},
+	[JZ4770_CLK_MMC2] = {
+		"mmc2", CGU_CLK_GATE,
+		.parents = { JZ4770_CLK_MMC2_MUX, },
+		.gate = { CGU_REG_CLKGR0, 12 },
+	},
+
+	/* Custom clocks */
+
+	[JZ4770_CLK_UHC_PHY] = {
+		"uhc_phy", CGU_CLK_CUSTOM,
+		.parents = { JZ4770_CLK_UHC, -1, -1, -1 },
+		.custom = { &jz4770_uhc_phy_ops },
+	},
+	[JZ4770_CLK_OTG_PHY] = {
+		"usb_phy", CGU_CLK_CUSTOM,
+		.parents = { JZ4770_CLK_OTG, -1, -1, -1 },
+		.custom = { &jz4770_otg_phy_ops },
+	},
+
+	[JZ4770_CLK_EXT512] = {
+		"ext/512", CGU_CLK_FIXDIV,
+		.parents = { JZ4770_CLK_EXT },
+		.fixdiv = { 512 },
+	},
+
+	[JZ4770_CLK_RTC] = {
+		"rtc", CGU_CLK_MUX,
+		.parents = { JZ4770_CLK_EXT512, JZ4770_CLK_OSC32K, },
+		.mux = { CGU_REG_OPCR, 2, 1},
+	},
+};
+
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+static int jz4770_cgu_pm_suspend(void)
+{
+	u32 val;
+
+	val = readl(cgu->base + CGU_REG_LCR);
+	writel(val | LCR_LPM, cgu->base + CGU_REG_LCR);
+	return 0;
+}
+
+static void jz4770_cgu_pm_resume(void)
+{
+	u32 val;
+
+	val = readl(cgu->base + CGU_REG_LCR);
+	writel(val & ~LCR_LPM, cgu->base + CGU_REG_LCR);
+}
+
+static struct syscore_ops jz4770_cgu_pm_ops = {
+	.suspend = jz4770_cgu_pm_suspend,
+	.resume = jz4770_cgu_pm_resume,
+};
+#endif /* CONFIG_PM_SLEEP */
+
+static void __init jz4770_cgu_init(struct device_node *np)
+{
+	int retval;
+
+	cgu = ingenic_cgu_new(jz4770_cgu_clocks,
+			      ARRAY_SIZE(jz4770_cgu_clocks), np);
+	if (!cgu)
+		pr_err("%s: failed to initialise CGU\n", __func__);
+
+	retval = ingenic_cgu_register_clocks(cgu);
+	if (retval)
+		pr_err("%s: failed to register CGU Clocks\n", __func__);
+
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+	register_syscore_ops(&jz4770_cgu_pm_ops);
+#endif
+}
+
+/* We only probe via devicetree, no need for a platform driver */
+CLK_OF_DECLARE(jz4770_cgu, "ingenic,jz4770-cgu", jz4770_cgu_init);
