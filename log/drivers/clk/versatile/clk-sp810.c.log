commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index 4fa0cd951d2e..caf0cd2fb5b6 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -1,12 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  *
  * Copyright (C) 2013 ARM Limited
  */

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index c2b6bb814742..4fa0cd951d2e 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -16,6 +16,7 @@
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>
+#include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 

commit 354e12100665a30537bc816aa1a1607436948677
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Fri Nov 30 11:07:30 2018 -0800

    clk: versatile: sp810: Remove usage of CLK_IS_BASIC
    
    This flag doesn't look to be used by any code, just set in the clk init
    structure and then never tested again. Remove it from this driver as it
    doesn't provide any benefit.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index 1fe1e8d970cf..c2b6bb814742 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -111,7 +111,7 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 
 	init.name = name;
 	init.ops = &clk_sp810_timerclken_ops;
-	init.flags = CLK_IS_BASIC;
+	init.flags = 0;
 	init.parent_names = parent_names;
 	init.num_parents = num;
 

commit ec7957a6aa0aaf981fb8356dc47a2cdd01cde03c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 24 09:39:11 2016 +0100

    clk: versatile: sp810: support reentrance
    
    Despite care take to allocate clocks state containers the
    SP810 driver actually just supports creating one instance:
    all clocks registered for every instance will end up with the
    exact same name and __clk_init() will fail.
    
    Rename the timclken<0> .. timclken<n> to sp810_<instance>_<n>
    so every clock on every instance gets a unique name.
    
    This is necessary for the RealView PBA8 which has two SP810
    blocks: the second block will not register its clocks unless
    every clock on every instance is unique and results in boot
    logs like this:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at ../drivers/clk/versatile/clk-sp810.c:137
      clk_sp810_of_setup+0x110/0x154()
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted
    4.5.0-rc2-00030-g352718fc39f6-dirty #225
    Hardware name: ARM RealView Machine (Device Tree Support)
    [<c00167f8>] (unwind_backtrace) from [<c0013204>]
                 (show_stack+0x10/0x14)
    [<c0013204>] (show_stack) from [<c01a049c>]
                 (dump_stack+0x84/0x9c)
    [<c01a049c>] (dump_stack) from [<c0024990>]
                 (warn_slowpath_common+0x74/0xb0)
    [<c0024990>] (warn_slowpath_common) from [<c0024a68>]
                 (warn_slowpath_null+0x1c/0x24)
    [<c0024a68>] (warn_slowpath_null) from [<c051eb44>]
                 (clk_sp810_of_setup+0x110/0x154)
    [<c051eb44>] (clk_sp810_of_setup) from [<c051e3a4>]
                 (of_clk_init+0x12c/0x1c8)
    [<c051e3a4>] (of_clk_init) from [<c0504714>]
                 (time_init+0x20/0x2c)
    [<c0504714>] (time_init) from [<c0501b18>]
                 (start_kernel+0x244/0x3c4)
    [<c0501b18>] (start_kernel) from [<7000807c>] (0x7000807c)
    ---[ end trace cb88537fdc8fa200 ]---
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Fixes: 6e973d2c4385 "clk: vexpress: Add separate SP810 driver"
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index e78755e0ef78..1fe1e8d970cf 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -92,6 +92,7 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 	int num = ARRAY_SIZE(parent_names);
 	char name[12];
 	struct clk_init_data init;
+	static int instance;
 	int i;
 	bool deprecated;
 
@@ -117,7 +118,7 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 	deprecated = !of_find_property(node, "assigned-clock-parents", NULL);
 
 	for (i = 0; i < ARRAY_SIZE(sp810->timerclken); i++) {
-		snprintf(name, ARRAY_SIZE(name), "timerclken%d", i);
+		snprintf(name, sizeof(name), "sp810_%d_%d", instance, i);
 
 		sp810->timerclken[i].sp810 = sp810;
 		sp810->timerclken[i].channel = i;
@@ -138,5 +139,6 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 	}
 
 	of_clk_add_provider(node, clk_sp810_timerclken_of_get, sp810);
+	instance++;
 }
 CLK_OF_DECLARE(sp810, "arm,sp810", clk_sp810_of_setup);

commit 59fe66313a41843bc4c237275e64f81cde121ac8
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Nov 20 14:22:28 2015 +0530

    clk: versatile: remove unneeded error message
    
    If kzalloc fails we will already have many messages in the log and we do
    not need another message to know that kzalloc for sp810 has failed.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index 6a36c8bcb5de..e78755e0ef78 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -95,10 +95,8 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 	int i;
 	bool deprecated;
 
-	if (!sp810) {
-		pr_err("Failed to allocate memory for SP810!\n");
+	if (!sp810)
 		return;
-	}
 
 	if (of_clk_parent_fill(node, parent_names, num) != num) {
 		pr_warn("Failed to obtain parent clocks for SP810!\n");

commit 47c5ee34d8d913a1ab1ae87544475c136ea25b26
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Nov 16 19:16:40 2015 +0530

    clk: versatile: fix memory leak
    
    If of_clk_parent_fill() fails then we printed an error message and
    returned. But we missed freeing sp810.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index a1cdef6b0f90..6a36c8bcb5de 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -102,6 +102,7 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 
 	if (of_clk_parent_fill(node, parent_names, num) != num) {
 		pr_warn("Failed to obtain parent clocks for SP810!\n");
+		kfree(sp810);
 		return;
 	}
 

commit 62f477119834d912a8471e775d2aeaca0166ab29
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 30 17:20:57 2015 -0700

    clk: versatile: Switch to assigned clock parents
    
    We're removing struct clk from the clk provider API. This code is
    calling the consumer APIs to change the parent to a 1 MHz fixed
    rate clock for each of the clocks that the driver provides. Move
    to using the assigned-clock-parents DT property for this instead.
    Because this is an ABI break, detect if the property is missing
    and fall back to setting the parent explicitly before the clocks
    are registered.
    
    Acked-by: Pawel Moll <pawel.moll@arm.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index 7fbe4d4bf35e..a1cdef6b0f90 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -33,12 +33,9 @@ struct clk_sp810_timerclken {
 
 struct clk_sp810 {
 	struct device_node *node;
-	int refclk_index, timclk_index;
 	void __iomem *base;
 	spinlock_t lock;
 	struct clk_sp810_timerclken timerclken[4];
-	struct clk *refclk;
-	struct clk *timclk;
 };
 
 static u8 clk_sp810_timerclken_get_parent(struct clk_hw *hw)
@@ -71,55 +68,7 @@ static int clk_sp810_timerclken_set_parent(struct clk_hw *hw, u8 index)
 	return 0;
 }
 
-/*
- * FIXME - setting the parent every time .prepare is invoked is inefficient.
- * This is better handled by a dedicated clock tree configuration mechanism at
- * init-time.  Revisit this later when such a mechanism exists
- */
-static int clk_sp810_timerclken_prepare(struct clk_hw *hw)
-{
-	struct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);
-	struct clk_sp810 *sp810 = timerclken->sp810;
-	struct clk *old_parent = __clk_get_parent(hw->clk);
-	struct clk *new_parent;
-
-	if (!sp810->refclk)
-		sp810->refclk = of_clk_get(sp810->node, sp810->refclk_index);
-
-	if (!sp810->timclk)
-		sp810->timclk = of_clk_get(sp810->node, sp810->timclk_index);
-
-	if (WARN_ON(IS_ERR(sp810->refclk) || IS_ERR(sp810->timclk)))
-		return -ENOENT;
-
-	/* Select fastest parent */
-	if (clk_get_rate(sp810->refclk) > clk_get_rate(sp810->timclk))
-		new_parent = sp810->refclk;
-	else
-		new_parent = sp810->timclk;
-
-	/* Switch the parent if necessary */
-	if (old_parent != new_parent) {
-		clk_prepare(new_parent);
-		clk_set_parent(hw->clk, new_parent);
-		clk_unprepare(old_parent);
-	}
-
-	return 0;
-}
-
-static void clk_sp810_timerclken_unprepare(struct clk_hw *hw)
-{
-	struct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);
-	struct clk_sp810 *sp810 = timerclken->sp810;
-
-	clk_put(sp810->timclk);
-	clk_put(sp810->refclk);
-}
-
 static const struct clk_ops clk_sp810_timerclken_ops = {
-	.prepare = clk_sp810_timerclken_prepare,
-	.unprepare = clk_sp810_timerclken_unprepare,
 	.get_parent = clk_sp810_timerclken_get_parent,
 	.set_parent = clk_sp810_timerclken_set_parent,
 };
@@ -140,24 +89,18 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 {
 	struct clk_sp810 *sp810 = kzalloc(sizeof(*sp810), GFP_KERNEL);
 	const char *parent_names[2];
+	int num = ARRAY_SIZE(parent_names);
 	char name[12];
 	struct clk_init_data init;
 	int i;
+	bool deprecated;
 
 	if (!sp810) {
 		pr_err("Failed to allocate memory for SP810!\n");
 		return;
 	}
 
-	sp810->refclk_index = of_property_match_string(node, "clock-names",
-			"refclk");
-	parent_names[0] = of_clk_get_parent_name(node, sp810->refclk_index);
-
-	sp810->timclk_index = of_property_match_string(node, "clock-names",
-			"timclk");
-	parent_names[1] = of_clk_get_parent_name(node, sp810->timclk_index);
-
-	if (!parent_names[0] || !parent_names[1]) {
+	if (of_clk_parent_fill(node, parent_names, num) != num) {
 		pr_warn("Failed to obtain parent clocks for SP810!\n");
 		return;
 	}
@@ -170,7 +113,9 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 	init.ops = &clk_sp810_timerclken_ops;
 	init.flags = CLK_IS_BASIC;
 	init.parent_names = parent_names;
-	init.num_parents = ARRAY_SIZE(parent_names);
+	init.num_parents = num;
+
+	deprecated = !of_find_property(node, "assigned-clock-parents", NULL);
 
 	for (i = 0; i < ARRAY_SIZE(sp810->timerclken); i++) {
 		snprintf(name, ARRAY_SIZE(name), "timerclken%d", i);
@@ -179,6 +124,15 @@ static void __init clk_sp810_of_setup(struct device_node *node)
 		sp810->timerclken[i].channel = i;
 		sp810->timerclken[i].hw.init = &init;
 
+		/*
+		 * If DT isn't setting the parent, force it to be
+		 * the 1 MHz clock without going through the framework.
+		 * We do this before clk_register() so that it can determine
+		 * the parent and setup the tree properly.
+		 */
+		if (deprecated)
+			init.ops->set_parent(&sp810->timerclken[i].hw, 1);
+
 		sp810->timerclken[i].clk = clk_register(NULL,
 				&sp810->timerclken[i].hw);
 		WARN_ON(IS_ERR(sp810->timerclken[i].clk));

commit 3294bee87091be5f179474f6c39d1d87769635e2
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jul 29 13:17:06 2015 +0300

    clk: versatile: off by one in clk_sp810_timerclken_of_get()
    
    The ">" should be ">=" or we end up reading beyond the end of the array.
    
    Fixes: 6e973d2c4385 ('clk: vexpress: Add separate SP810 driver')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index 64b0129a0216..7fbe4d4bf35e 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -129,8 +129,8 @@ static struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,
 {
 	struct clk_sp810 *sp810 = data;
 
-	if (WARN_ON(clkspec->args_count != 1 || clkspec->args[0] >
-			ARRAY_SIZE(sp810->timerclken)))
+	if (WARN_ON(clkspec->args_count != 1 ||
+		    clkspec->args[0] >=	ARRAY_SIZE(sp810->timerclken)))
 		return NULL;
 
 	return sp810->timerclken[clkspec->args[0]].clk;

commit 6d31e3b22e131f5aa5c9d6407ea46fec2134f986
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: versatile: Remove clk.h and clkdev.h includes
    
    Clock provider drivers generally shouldn't include clk.h because
    it's the consumer API. Remove the include here because this is a
    provider driver. Also remove clkdev.h in files that aren't using
    it and replace them with slab.h in files that were relying on the
    implicit include of slab.h in clkdev.h.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index a96dd8e53fdb..64b0129a0216 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -12,7 +12,8 @@
  */
 
 #include <linux/amba/sp810.h>
-#include <linux/clkdev.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>
 #include <linux/of.h>

commit 11bee5e19afd11a42a03df9025f82a1bab4d5595
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri May 1 13:02:26 2015 -0700

    clk: versatile: Silence sparse warnings
    
    drivers/clk/versatile/clk-sp810.c:159:29: error: incompatible types for operation (<=)
    drivers/clk/versatile/clk-sp810.c:159:29:    left side has type char const *<noident>
    drivers/clk/versatile/clk-sp810.c:159:29:    right side has type int
    drivers/clk/versatile/clk-sp810.c:159:53: error: incompatible types for operation (<=)
    drivers/clk/versatile/clk-sp810.c:159:53:    left side has type char const *<noident>
    drivers/clk/versatile/clk-sp810.c:159:53:    right side has type int
    drivers/clk/versatile/clk-sp810.c:138:13: warning: symbol 'clk_sp810_of_setup' was not declared. Should it be static?
    
    Acked: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index c6e86a9a2aa3..a96dd8e53fdb 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -135,7 +135,7 @@ static struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,
 	return sp810->timerclken[clkspec->args[0]].clk;
 }
 
-void __init clk_sp810_of_setup(struct device_node *node)
+static void __init clk_sp810_of_setup(struct device_node *node)
 {
 	struct clk_sp810 *sp810 = kzalloc(sizeof(*sp810), GFP_KERNEL);
 	const char *parent_names[2];
@@ -156,7 +156,7 @@ void __init clk_sp810_of_setup(struct device_node *node)
 			"timclk");
 	parent_names[1] = of_clk_get_parent_name(node, sp810->timclk_index);
 
-	if (parent_names[0] <= 0 || parent_names[1] <= 0) {
+	if (!parent_names[0] || !parent_names[1]) {
 		pr_warn("Failed to obtain parent clocks for SP810!\n");
 		return;
 	}

commit 14b260cef2aa075544c6a8874d22e8d5e2522b3b
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Oct 8 16:47:44 2013 +0530

    clk: versatile: Staticize clk_sp810_timerclken_of_get
    
    clk_sp810_timerclken_of_get is used only in this file. Make it static.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index bf9b15a585e1..c6e86a9a2aa3 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -123,7 +123,7 @@ static const struct clk_ops clk_sp810_timerclken_ops = {
 	.set_parent = clk_sp810_timerclken_set_parent,
 };
 
-struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,
+static struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,
 		void *data)
 {
 	struct clk_sp810 *sp810 = data;

commit 6e973d2c438502dcf956e76305258ba7d1c7d1d3
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Thu Apr 18 18:23:22 2013 +0100

    clk: vexpress: Add separate SP810 driver
    
    Factor out the SP810 clocking code into a separate driver,
    selecting better (faster) parent at clk_prepare() time.
    This is to avoid problems with clocking infrastructure
    initialisation order, in particular to avoid dependency
    of fixed clock being initialized before SP810. It also
    makes vexpress platform OF-based clock initialisation code
    unnecessary.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Tested-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>
    [mturquette@linaro.org: add .unprepare, FIXME comment, cleaned up code]

diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
new file mode 100644
index 000000000000..bf9b15a585e1
--- /dev/null
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -0,0 +1,188 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Copyright (C) 2013 ARM Limited
+ */
+
+#include <linux/amba/sp810.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#define to_clk_sp810_timerclken(_hw) \
+		container_of(_hw, struct clk_sp810_timerclken, hw)
+
+struct clk_sp810;
+
+struct clk_sp810_timerclken {
+	struct clk_hw hw;
+	struct clk *clk;
+	struct clk_sp810 *sp810;
+	int channel;
+};
+
+struct clk_sp810 {
+	struct device_node *node;
+	int refclk_index, timclk_index;
+	void __iomem *base;
+	spinlock_t lock;
+	struct clk_sp810_timerclken timerclken[4];
+	struct clk *refclk;
+	struct clk *timclk;
+};
+
+static u8 clk_sp810_timerclken_get_parent(struct clk_hw *hw)
+{
+	struct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);
+	u32 val = readl(timerclken->sp810->base + SCCTRL);
+
+	return !!(val & (1 << SCCTRL_TIMERENnSEL_SHIFT(timerclken->channel)));
+}
+
+static int clk_sp810_timerclken_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);
+	struct clk_sp810 *sp810 = timerclken->sp810;
+	u32 val, shift = SCCTRL_TIMERENnSEL_SHIFT(timerclken->channel);
+	unsigned long flags = 0;
+
+	if (WARN_ON(index > 1))
+		return -EINVAL;
+
+	spin_lock_irqsave(&sp810->lock, flags);
+
+	val = readl(sp810->base + SCCTRL);
+	val &= ~(1 << shift);
+	val |= index << shift;
+	writel(val, sp810->base + SCCTRL);
+
+	spin_unlock_irqrestore(&sp810->lock, flags);
+
+	return 0;
+}
+
+/*
+ * FIXME - setting the parent every time .prepare is invoked is inefficient.
+ * This is better handled by a dedicated clock tree configuration mechanism at
+ * init-time.  Revisit this later when such a mechanism exists
+ */
+static int clk_sp810_timerclken_prepare(struct clk_hw *hw)
+{
+	struct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);
+	struct clk_sp810 *sp810 = timerclken->sp810;
+	struct clk *old_parent = __clk_get_parent(hw->clk);
+	struct clk *new_parent;
+
+	if (!sp810->refclk)
+		sp810->refclk = of_clk_get(sp810->node, sp810->refclk_index);
+
+	if (!sp810->timclk)
+		sp810->timclk = of_clk_get(sp810->node, sp810->timclk_index);
+
+	if (WARN_ON(IS_ERR(sp810->refclk) || IS_ERR(sp810->timclk)))
+		return -ENOENT;
+
+	/* Select fastest parent */
+	if (clk_get_rate(sp810->refclk) > clk_get_rate(sp810->timclk))
+		new_parent = sp810->refclk;
+	else
+		new_parent = sp810->timclk;
+
+	/* Switch the parent if necessary */
+	if (old_parent != new_parent) {
+		clk_prepare(new_parent);
+		clk_set_parent(hw->clk, new_parent);
+		clk_unprepare(old_parent);
+	}
+
+	return 0;
+}
+
+static void clk_sp810_timerclken_unprepare(struct clk_hw *hw)
+{
+	struct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);
+	struct clk_sp810 *sp810 = timerclken->sp810;
+
+	clk_put(sp810->timclk);
+	clk_put(sp810->refclk);
+}
+
+static const struct clk_ops clk_sp810_timerclken_ops = {
+	.prepare = clk_sp810_timerclken_prepare,
+	.unprepare = clk_sp810_timerclken_unprepare,
+	.get_parent = clk_sp810_timerclken_get_parent,
+	.set_parent = clk_sp810_timerclken_set_parent,
+};
+
+struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,
+		void *data)
+{
+	struct clk_sp810 *sp810 = data;
+
+	if (WARN_ON(clkspec->args_count != 1 || clkspec->args[0] >
+			ARRAY_SIZE(sp810->timerclken)))
+		return NULL;
+
+	return sp810->timerclken[clkspec->args[0]].clk;
+}
+
+void __init clk_sp810_of_setup(struct device_node *node)
+{
+	struct clk_sp810 *sp810 = kzalloc(sizeof(*sp810), GFP_KERNEL);
+	const char *parent_names[2];
+	char name[12];
+	struct clk_init_data init;
+	int i;
+
+	if (!sp810) {
+		pr_err("Failed to allocate memory for SP810!\n");
+		return;
+	}
+
+	sp810->refclk_index = of_property_match_string(node, "clock-names",
+			"refclk");
+	parent_names[0] = of_clk_get_parent_name(node, sp810->refclk_index);
+
+	sp810->timclk_index = of_property_match_string(node, "clock-names",
+			"timclk");
+	parent_names[1] = of_clk_get_parent_name(node, sp810->timclk_index);
+
+	if (parent_names[0] <= 0 || parent_names[1] <= 0) {
+		pr_warn("Failed to obtain parent clocks for SP810!\n");
+		return;
+	}
+
+	sp810->node = node;
+	sp810->base = of_iomap(node, 0);
+	spin_lock_init(&sp810->lock);
+
+	init.name = name;
+	init.ops = &clk_sp810_timerclken_ops;
+	init.flags = CLK_IS_BASIC;
+	init.parent_names = parent_names;
+	init.num_parents = ARRAY_SIZE(parent_names);
+
+	for (i = 0; i < ARRAY_SIZE(sp810->timerclken); i++) {
+		snprintf(name, ARRAY_SIZE(name), "timerclken%d", i);
+
+		sp810->timerclken[i].sp810 = sp810;
+		sp810->timerclken[i].channel = i;
+		sp810->timerclken[i].hw.init = &init;
+
+		sp810->timerclken[i].clk = clk_register(NULL,
+				&sp810->timerclken[i].hw);
+		WARN_ON(IS_ERR(sp810->timerclken[i].clk));
+	}
+
+	of_clk_add_provider(node, clk_sp810_timerclken_of_get, sp810);
+}
+CLK_OF_DECLARE(sp810, "arm,sp810", clk_sp810_of_setup);
