commit 9952f6918daa4ab5fc81307a9f90e31a4df3b200
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:04 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 201
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 228 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.107155473@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
index e51e0023fc6e..78d5ea669fea 100644
--- a/drivers/clk/clk-oxnas.c
+++ b/drivers/clk/clk-oxnas.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2010 Broadcom
  * Copyright (C) 2012 Stephen Warren
  * Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/clk-provider.h>

commit 6df4393daf8b7a3f7c395e7858b734e2dc9b116b
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Wed Oct 5 17:07:51 2016 +0200

    clk: oxnas: Add OX820 Gate clocks
    
    Add support for the Oxford Semiconductor OX820 SoC gate clocks
    along the OX810SE SoC support.
    This rework on concerns the gate clocks since they are different.
    Future PLL handling code will be added for OX820.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20161005150752.22618-6-narmstrong@baylibre.com

diff --git a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
index b1ef3ea990f1..e51e0023fc6e 100644
--- a/drivers/clk/clk-oxnas.c
+++ b/drivers/clk/clk-oxnas.c
@@ -27,6 +27,7 @@
 #include <linux/mfd/syscon.h>
 
 #include <dt-bindings/clock/oxsemi,ox810se.h>
+#include <dt-bindings/clock/oxsemi,ox820.h>
 
 /* Standard regmap gate clocks */
 struct clk_oxnas_gate {
@@ -130,6 +131,38 @@ static struct clk_oxnas_gate *ox810se_gates[] = {
 	&ox810se_nand,
 };
 
+static OXNAS_GATE(ox820_leon, 0, osc_parents);
+static OXNAS_GATE(ox820_dma_sgdma, 1, osc_parents);
+static OXNAS_GATE(ox820_cipher, 2, osc_parents);
+static OXNAS_GATE(ox820_sd, 3, osc_parents);
+static OXNAS_GATE(ox820_sata, 4, osc_parents);
+static OXNAS_GATE(ox820_audio, 5, osc_parents);
+static OXNAS_GATE(ox820_usbmph, 6, osc_parents);
+static OXNAS_GATE(ox820_etha, 7, eth_parents);
+static OXNAS_GATE(ox820_pciea, 8, osc_parents);
+static OXNAS_GATE(ox820_nand, 9, osc_parents);
+static OXNAS_GATE(ox820_ethb, 10, eth_parents);
+static OXNAS_GATE(ox820_pcieb, 11, osc_parents);
+static OXNAS_GATE(ox820_ref600, 12, osc_parents);
+static OXNAS_GATE(ox820_usbdev, 13, osc_parents);
+
+static struct clk_oxnas_gate *ox820_gates[] = {
+	&ox820_leon,
+	&ox820_dma_sgdma,
+	&ox820_cipher,
+	&ox820_sd,
+	&ox820_sata,
+	&ox820_audio,
+	&ox820_usbmph,
+	&ox820_etha,
+	&ox820_pciea,
+	&ox820_nand,
+	&ox820_etha,
+	&ox820_pciea,
+	&ox820_ref600,
+	&ox820_usbdev,
+};
+
 static struct clk_hw_onecell_data ox810se_hw_onecell_data = {
 	.hws = {
 		[CLK_810_LEON]	= &ox810se_leon.hw,
@@ -145,6 +178,25 @@ static struct clk_hw_onecell_data ox810se_hw_onecell_data = {
 	.num = ARRAY_SIZE(ox810se_gates),
 };
 
+static struct clk_hw_onecell_data ox820_hw_onecell_data = {
+	.hws = {
+		[CLK_820_LEON]	= &ox820_leon.hw,
+		[CLK_820_DMA_SGDMA]	= &ox820_dma_sgdma.hw,
+		[CLK_820_CIPHER]	= &ox820_cipher.hw,
+		[CLK_820_SD]	= &ox820_sd.hw,
+		[CLK_820_SATA]	= &ox820_sata.hw,
+		[CLK_820_AUDIO]	= &ox820_audio.hw,
+		[CLK_820_USBMPH]	= &ox820_usbmph.hw,
+		[CLK_820_ETHA]	= &ox820_etha.hw,
+		[CLK_820_PCIEA]	= &ox820_pciea.hw,
+		[CLK_820_NAND]	= &ox820_nand.hw,
+		[CLK_820_ETHB]	= &ox820_ethb.hw,
+		[CLK_820_PCIEB]	= &ox820_pcieb.hw,
+		[CLK_820_REF600]	= &ox820_ref600.hw,
+		[CLK_820_USBDEV]	= &ox820_usbdev.hw,
+	},
+	.num = ARRAY_SIZE(ox820_gates),
+};
 
 static struct oxnas_stdclk_data ox810se_stdclk_data = {
 	.onecell_data = &ox810se_hw_onecell_data,
@@ -152,9 +204,15 @@ static struct oxnas_stdclk_data ox810se_stdclk_data = {
 	.ngates = ARRAY_SIZE(ox810se_gates),
 };
 
+static struct oxnas_stdclk_data ox820_stdclk_data = {
+	.onecell_data = &ox820_hw_onecell_data,
+	.gates = ox820_gates,
+	.ngates = ARRAY_SIZE(ox820_gates),
+};
 
 static const struct of_device_id oxnas_stdclk_dt_ids[] = {
 	{ .compatible = "oxsemi,ox810se-stdclk", &ox810se_stdclk_data },
+	{ .compatible = "oxsemi,ox820-stdclk", &ox820_stdclk_data },
 	{ }
 };
 

commit 5a9e54a81b5ef6b31ffafc2199c648083bc50248
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Wed Oct 5 17:07:50 2016 +0200

    clk: oxnas: Refactor to make use of devm_clk_hw_register()
    
    Make usage of static tables identified by the OF match table to
    feed devm_clk_hw_register() and use of_clk_add_hw_provider().
    
    This structure is cleaner and simplifies adding new SoC support while
    having common probe and gate ops code.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20161005150752.22618-5-narmstrong@baylibre.com

diff --git a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
index a76c7fbb90ca..b1ef3ea990f1 100644
--- a/drivers/clk/clk-oxnas.c
+++ b/drivers/clk/clk-oxnas.c
@@ -20,18 +20,29 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/stringify.h>
 #include <linux/regmap.h>
 #include <linux/mfd/syscon.h>
 
+#include <dt-bindings/clock/oxsemi,ox810se.h>
+
 /* Standard regmap gate clocks */
 struct clk_oxnas_gate {
 	struct clk_hw hw;
-	signed char bit;
+	unsigned int bit;
 	struct regmap *regmap;
 };
 
+struct oxnas_stdclk_data {
+	struct clk_hw_onecell_data *onecell_data;
+	struct clk_oxnas_gate **gates;
+	unsigned int ngates;
+	struct clk_oxnas_pll **plls;
+	unsigned int nplls;
+};
+
 /* Regmap offsets */
 #define CLK_STAT_REGOFFSET	0x24
 #define CLK_SET_REGOFFSET	0x2c
@@ -77,7 +88,7 @@ static const struct clk_ops oxnas_clk_gate_ops = {
 	.is_enabled = oxnas_clk_gate_is_enabled,
 };
 
-static const char *const oxnas_clk_parents[] = {
+static const char *const osc_parents[] = {
 	"oscillator",
 };
 
@@ -85,63 +96,81 @@ static const char *const eth_parents[] = {
 	"gmacclk",
 };
 
-#define DECLARE_STD_CLKP(__clk, __parent)			\
-static const struct clk_init_data clk_##__clk##_init = {	\
-	.name = __stringify(__clk),				\
-	.ops = &oxnas_clk_gate_ops,					\
-	.parent_names = __parent,				\
-	.num_parents = ARRAY_SIZE(__parent),			\
+#define OXNAS_GATE(_name, _bit, _parents)				\
+struct clk_oxnas_gate _name = {						\
+	.bit = (_bit),							\
+	.hw.init = &(struct clk_init_data) {				\
+		.name = #_name,						\
+		.ops = &oxnas_clk_gate_ops,				\
+		.parent_names = _parents,				\
+		.num_parents = ARRAY_SIZE(_parents),			\
+		.flags = (CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED),	\
+	},								\
 }
 
-#define DECLARE_STD_CLK(__clk) DECLARE_STD_CLKP(__clk, oxnas_clk_parents)
+static OXNAS_GATE(ox810se_leon, 0, osc_parents);
+static OXNAS_GATE(ox810se_dma_sgdma, 1, osc_parents);
+static OXNAS_GATE(ox810se_cipher, 2, osc_parents);
+static OXNAS_GATE(ox810se_sata, 4, osc_parents);
+static OXNAS_GATE(ox810se_audio, 5, osc_parents);
+static OXNAS_GATE(ox810se_usbmph, 6, osc_parents);
+static OXNAS_GATE(ox810se_etha, 7, eth_parents);
+static OXNAS_GATE(ox810se_pciea, 8, osc_parents);
+static OXNAS_GATE(ox810se_nand, 9, osc_parents);
+
+static struct clk_oxnas_gate *ox810se_gates[] = {
+	&ox810se_leon,
+	&ox810se_dma_sgdma,
+	&ox810se_cipher,
+	&ox810se_sata,
+	&ox810se_audio,
+	&ox810se_usbmph,
+	&ox810se_etha,
+	&ox810se_pciea,
+	&ox810se_nand,
+};
 
-/* Hardware Bit - Clock association */
-struct clk_oxnas_init_data {
-	unsigned long bit;
-	const struct clk_init_data *clk_init;
+static struct clk_hw_onecell_data ox810se_hw_onecell_data = {
+	.hws = {
+		[CLK_810_LEON]	= &ox810se_leon.hw,
+		[CLK_810_DMA_SGDMA]	= &ox810se_dma_sgdma.hw,
+		[CLK_810_CIPHER]	= &ox810se_cipher.hw,
+		[CLK_810_SATA]	= &ox810se_sata.hw,
+		[CLK_810_AUDIO]	= &ox810se_audio.hw,
+		[CLK_810_USBMPH]	= &ox810se_usbmph.hw,
+		[CLK_810_ETHA]	= &ox810se_etha.hw,
+		[CLK_810_PCIEA]	= &ox810se_pciea.hw,
+		[CLK_810_NAND]	= &ox810se_nand.hw,
+	},
+	.num = ARRAY_SIZE(ox810se_gates),
 };
 
-/* Clk init data declaration */
-DECLARE_STD_CLK(leon);
-DECLARE_STD_CLK(dma_sgdma);
-DECLARE_STD_CLK(cipher);
-DECLARE_STD_CLK(sata);
-DECLARE_STD_CLK(audio);
-DECLARE_STD_CLK(usbmph);
-DECLARE_STD_CLKP(etha, eth_parents);
-DECLARE_STD_CLK(pciea);
-DECLARE_STD_CLK(nand);
-
-/* Table index is clock indice */
-static const struct clk_oxnas_init_data clk_oxnas_init[] = {
-	[0] = {0, &clk_leon_init},
-	[1] = {1, &clk_dma_sgdma_init},
-	[2] = {2, &clk_cipher_init},
-	/* Skip & Do not touch to DDR clock */
-	[3] = {4, &clk_sata_init},
-	[4] = {5, &clk_audio_init},
-	[5] = {6, &clk_usbmph_init},
-	[6] = {7, &clk_etha_init},
-	[7] = {8, &clk_pciea_init},
-	[8] = {9, &clk_nand_init},
+
+static struct oxnas_stdclk_data ox810se_stdclk_data = {
+	.onecell_data = &ox810se_hw_onecell_data,
+	.gates = ox810se_gates,
+	.ngates = ARRAY_SIZE(ox810se_gates),
 };
 
-struct clk_oxnas_data {
-	struct clk_oxnas_gate clk_oxnas[ARRAY_SIZE(clk_oxnas_init)];
-	struct clk_onecell_data onecell_data[ARRAY_SIZE(clk_oxnas_init)];
-	struct clk *clks[ARRAY_SIZE(clk_oxnas_init)];
+
+static const struct of_device_id oxnas_stdclk_dt_ids[] = {
+	{ .compatible = "oxsemi,ox810se-stdclk", &ox810se_stdclk_data },
+	{ }
 };
 
 static int oxnas_stdclk_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
-	struct clk_oxnas_data *clk_oxnas;
+	const struct oxnas_stdclk_data *data;
+	const struct of_device_id *id;
 	struct regmap *regmap;
+	int ret;
 	int i;
 
-	clk_oxnas = devm_kzalloc(&pdev->dev, sizeof(*clk_oxnas), GFP_KERNEL);
-	if (!clk_oxnas)
-		return -ENOMEM;
+	id = of_match_device(oxnas_stdclk_dt_ids, &pdev->dev);
+	if (!id)
+		return -ENODEV;
+	data = id->data;
 
 	regmap = syscon_node_to_regmap(of_get_parent(np));
 	if (IS_ERR(regmap)) {
@@ -149,32 +178,23 @@ static int oxnas_stdclk_probe(struct platform_device *pdev)
 		return PTR_ERR(regmap);
 	}
 
-	for (i = 0; i < ARRAY_SIZE(clk_oxnas_init); i++) {
-		struct clk_oxnas_gate *_clk;
+	for (i = 0 ; i < data->ngates ; ++i)
+		data->gates[i]->regmap = regmap;
 
-		_clk = &clk_oxnas->clk_oxnas[i];
-		_clk->bit = clk_oxnas_init[i].bit;
-		_clk->hw.init = clk_oxnas_init[i].clk_init;
-		_clk->regmap = regmap;
+	for (i = 0; i < data->onecell_data->num; i++) {
+		if (!data->onecell_data->hws[i])
+			continue;
 
-		clk_oxnas->clks[i] =
-			devm_clk_register(&pdev->dev, &_clk->hw);
-		if (WARN_ON(IS_ERR(clk_oxnas->clks[i])))
-			return PTR_ERR(clk_oxnas->clks[i]);
+		ret = devm_clk_hw_register(&pdev->dev,
+					   data->onecell_data->hws[i]);
+		if (ret)
+			return ret;
 	}
 
-	clk_oxnas->onecell_data->clks = clk_oxnas->clks;
-	clk_oxnas->onecell_data->clk_num = ARRAY_SIZE(clk_oxnas_init);
-
-	return of_clk_add_provider(np, of_clk_src_onecell_get,
-				   clk_oxnas->onecell_data);
+	return of_clk_add_hw_provider(np, of_clk_hw_onecell_get,
+				      data->onecell_data);
 }
 
-static const struct of_device_id oxnas_stdclk_dt_ids[] = {
-	{ .compatible = "oxsemi,ox810se-stdclk" },
-	{ }
-};
-
 static struct platform_driver oxnas_stdclk_driver = {
 	.probe = oxnas_stdclk_probe,
 	.driver	= {

commit 1a2cfd0070c1f60fbcfced776e8329461303a702
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Wed Oct 5 17:07:49 2016 +0200

    clk: oxnas: Rename to clk_oxnas_gate
    
    Rename clock ops to clk_oxnas_gate in ops and structures.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20161005150752.22618-4-narmstrong@baylibre.com

diff --git a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
index 47649ac5d399..a76c7fbb90ca 100644
--- a/drivers/clk/clk-oxnas.c
+++ b/drivers/clk/clk-oxnas.c
@@ -26,7 +26,7 @@
 #include <linux/mfd/syscon.h>
 
 /* Standard regmap gate clocks */
-struct clk_oxnas {
+struct clk_oxnas_gate {
 	struct clk_hw hw;
 	signed char bit;
 	struct regmap *regmap;
@@ -37,14 +37,14 @@ struct clk_oxnas {
 #define CLK_SET_REGOFFSET	0x2c
 #define CLK_CLR_REGOFFSET	0x30
 
-static inline struct clk_oxnas *to_clk_oxnas(struct clk_hw *hw)
+static inline struct clk_oxnas_gate *to_clk_oxnas_gate(struct clk_hw *hw)
 {
-	return container_of(hw, struct clk_oxnas, hw);
+	return container_of(hw, struct clk_oxnas_gate, hw);
 }
 
-static int oxnas_clk_is_enabled(struct clk_hw *hw)
+static int oxnas_clk_gate_is_enabled(struct clk_hw *hw)
 {
-	struct clk_oxnas *std = to_clk_oxnas(hw);
+	struct clk_oxnas_gate *std = to_clk_oxnas_gate(hw);
 	int ret;
 	unsigned int val;
 
@@ -55,26 +55,26 @@ static int oxnas_clk_is_enabled(struct clk_hw *hw)
 	return val & BIT(std->bit);
 }
 
-static int oxnas_clk_enable(struct clk_hw *hw)
+static int oxnas_clk_gate_enable(struct clk_hw *hw)
 {
-	struct clk_oxnas *std = to_clk_oxnas(hw);
+	struct clk_oxnas_gate *std = to_clk_oxnas_gate(hw);
 
 	regmap_write(std->regmap, CLK_SET_REGOFFSET, BIT(std->bit));
 
 	return 0;
 }
 
-static void oxnas_clk_disable(struct clk_hw *hw)
+static void oxnas_clk_gate_disable(struct clk_hw *hw)
 {
-	struct clk_oxnas *std = to_clk_oxnas(hw);
+	struct clk_oxnas_gate *std = to_clk_oxnas_gate(hw);
 
 	regmap_write(std->regmap, CLK_CLR_REGOFFSET, BIT(std->bit));
 }
 
-static const struct clk_ops oxnas_clk_ops = {
-	.enable = oxnas_clk_enable,
-	.disable = oxnas_clk_disable,
-	.is_enabled = oxnas_clk_is_enabled,
+static const struct clk_ops oxnas_clk_gate_ops = {
+	.enable = oxnas_clk_gate_enable,
+	.disable = oxnas_clk_gate_disable,
+	.is_enabled = oxnas_clk_gate_is_enabled,
 };
 
 static const char *const oxnas_clk_parents[] = {
@@ -88,7 +88,7 @@ static const char *const eth_parents[] = {
 #define DECLARE_STD_CLKP(__clk, __parent)			\
 static const struct clk_init_data clk_##__clk##_init = {	\
 	.name = __stringify(__clk),				\
-	.ops = &oxnas_clk_ops,					\
+	.ops = &oxnas_clk_gate_ops,					\
 	.parent_names = __parent,				\
 	.num_parents = ARRAY_SIZE(__parent),			\
 }
@@ -127,7 +127,7 @@ static const struct clk_oxnas_init_data clk_oxnas_init[] = {
 };
 
 struct clk_oxnas_data {
-	struct clk_oxnas clk_oxnas[ARRAY_SIZE(clk_oxnas_init)];
+	struct clk_oxnas_gate clk_oxnas[ARRAY_SIZE(clk_oxnas_init)];
 	struct clk_onecell_data onecell_data[ARRAY_SIZE(clk_oxnas_init)];
 	struct clk *clks[ARRAY_SIZE(clk_oxnas_init)];
 };
@@ -150,7 +150,7 @@ static int oxnas_stdclk_probe(struct platform_device *pdev)
 	}
 
 	for (i = 0; i < ARRAY_SIZE(clk_oxnas_init); i++) {
-		struct clk_oxnas *_clk;
+		struct clk_oxnas_gate *_clk;
 
 		_clk = &clk_oxnas->clk_oxnas[i];
 		_clk->bit = clk_oxnas_init[i].bit;

commit 80c6397c37d56f4cf8e175a541b1ebbf5f7d186a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jul 4 17:12:15 2016 -0400

    clk: oxnas: make it explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    drivers/clk/Kconfig:config COMMON_CLK_OXNAS
    drivers/clk/Kconfig:    bool "Clock driver for the OXNAS SoC Family"
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the modular code that is essentially orphaned, so that
    when reading the driver there is no doubt it is builtin-only.
    
    We explicitly disallow a driver unbind, since that doesn't have a
    sensible use case anyway, and it allows us to drop the ".remove"
    code for non-modular drivers.
    
    Since module_platform_driver() uses the same init level priority as
    builtin_platform_driver() the init ordering remains unchanged with
    this commit.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Cc: linux-clk@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Michael Turquette <mturquette@baylibre.com>
    Link: lkml.kernel.org/r/20160704211220.5685-6-paul.gortmaker@windriver.com

diff --git a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
index 79bcb2e42060..47649ac5d399 100644
--- a/drivers/clk/clk-oxnas.c
+++ b/drivers/clk/clk-oxnas.c
@@ -18,7 +18,7 @@
 
 #include <linux/clk-provider.h>
 #include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/init.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/stringify.h>
@@ -170,26 +170,17 @@ static int oxnas_stdclk_probe(struct platform_device *pdev)
 				   clk_oxnas->onecell_data);
 }
 
-static int oxnas_stdclk_remove(struct platform_device *pdev)
-{
-	of_clk_del_provider(pdev->dev.of_node);
-
-	return 0;
-}
-
 static const struct of_device_id oxnas_stdclk_dt_ids[] = {
 	{ .compatible = "oxsemi,ox810se-stdclk" },
 	{ }
 };
-MODULE_DEVICE_TABLE(of, oxnas_stdclk_dt_ids);
 
 static struct platform_driver oxnas_stdclk_driver = {
 	.probe = oxnas_stdclk_probe,
-	.remove = oxnas_stdclk_remove,
 	.driver	= {
 		.name = "oxnas-stdclk",
+		.suppress_bind_attrs = true,
 		.of_match_table = oxnas_stdclk_dt_ids,
 	},
 };
-
-module_platform_driver(oxnas_stdclk_driver);
+builtin_platform_driver(oxnas_stdclk_driver);

commit a5e9b85a6540df6c4074d3a56674f6fb6c5fc830
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Fri Jun 17 17:24:23 2016 +0000

    clk: Fix return value check in oxnas_stdclk_probe()
    
    In case of error, the function syscon_node_to_regmap() returns
    ERR_PTR() and never returns NULL. The NULL test in the return
    value check should be replaced with IS_ERR().
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Fixes: 0bbd72b4c64f ("clk: Add Oxford Semiconductor OXNAS Standard Clocks")
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
index efba7d4dbcfc..79bcb2e42060 100644
--- a/drivers/clk/clk-oxnas.c
+++ b/drivers/clk/clk-oxnas.c
@@ -144,9 +144,9 @@ static int oxnas_stdclk_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	regmap = syscon_node_to_regmap(of_get_parent(np));
-	if (!regmap) {
+	if (IS_ERR(regmap)) {
 		dev_err(&pdev->dev, "failed to have parent regmap\n");
-		return -EINVAL;
+		return PTR_ERR(regmap);
 	}
 
 	for (i = 0; i < ARRAY_SIZE(clk_oxnas_init); i++) {

commit 0bbd72b4c64fc0803a6efd86ea151184bf553f97
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Mon Apr 18 12:01:35 2016 +0200

    clk: Add Oxford Semiconductor OXNAS Standard Clocks
    
    Add Oxford Semiconductor OXNAS SoC Family Standard Clocks support.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    [sboyd@codeaurora.org: Drop NULL/continue check in registration
    loop]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
new file mode 100644
index 000000000000..efba7d4dbcfc
--- /dev/null
+++ b/drivers/clk/clk-oxnas.c
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2010 Broadcom
+ * Copyright (C) 2012 Stephen Warren
+ * Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/stringify.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+/* Standard regmap gate clocks */
+struct clk_oxnas {
+	struct clk_hw hw;
+	signed char bit;
+	struct regmap *regmap;
+};
+
+/* Regmap offsets */
+#define CLK_STAT_REGOFFSET	0x24
+#define CLK_SET_REGOFFSET	0x2c
+#define CLK_CLR_REGOFFSET	0x30
+
+static inline struct clk_oxnas *to_clk_oxnas(struct clk_hw *hw)
+{
+	return container_of(hw, struct clk_oxnas, hw);
+}
+
+static int oxnas_clk_is_enabled(struct clk_hw *hw)
+{
+	struct clk_oxnas *std = to_clk_oxnas(hw);
+	int ret;
+	unsigned int val;
+
+	ret = regmap_read(std->regmap, CLK_STAT_REGOFFSET, &val);
+	if (ret < 0)
+		return ret;
+
+	return val & BIT(std->bit);
+}
+
+static int oxnas_clk_enable(struct clk_hw *hw)
+{
+	struct clk_oxnas *std = to_clk_oxnas(hw);
+
+	regmap_write(std->regmap, CLK_SET_REGOFFSET, BIT(std->bit));
+
+	return 0;
+}
+
+static void oxnas_clk_disable(struct clk_hw *hw)
+{
+	struct clk_oxnas *std = to_clk_oxnas(hw);
+
+	regmap_write(std->regmap, CLK_CLR_REGOFFSET, BIT(std->bit));
+}
+
+static const struct clk_ops oxnas_clk_ops = {
+	.enable = oxnas_clk_enable,
+	.disable = oxnas_clk_disable,
+	.is_enabled = oxnas_clk_is_enabled,
+};
+
+static const char *const oxnas_clk_parents[] = {
+	"oscillator",
+};
+
+static const char *const eth_parents[] = {
+	"gmacclk",
+};
+
+#define DECLARE_STD_CLKP(__clk, __parent)			\
+static const struct clk_init_data clk_##__clk##_init = {	\
+	.name = __stringify(__clk),				\
+	.ops = &oxnas_clk_ops,					\
+	.parent_names = __parent,				\
+	.num_parents = ARRAY_SIZE(__parent),			\
+}
+
+#define DECLARE_STD_CLK(__clk) DECLARE_STD_CLKP(__clk, oxnas_clk_parents)
+
+/* Hardware Bit - Clock association */
+struct clk_oxnas_init_data {
+	unsigned long bit;
+	const struct clk_init_data *clk_init;
+};
+
+/* Clk init data declaration */
+DECLARE_STD_CLK(leon);
+DECLARE_STD_CLK(dma_sgdma);
+DECLARE_STD_CLK(cipher);
+DECLARE_STD_CLK(sata);
+DECLARE_STD_CLK(audio);
+DECLARE_STD_CLK(usbmph);
+DECLARE_STD_CLKP(etha, eth_parents);
+DECLARE_STD_CLK(pciea);
+DECLARE_STD_CLK(nand);
+
+/* Table index is clock indice */
+static const struct clk_oxnas_init_data clk_oxnas_init[] = {
+	[0] = {0, &clk_leon_init},
+	[1] = {1, &clk_dma_sgdma_init},
+	[2] = {2, &clk_cipher_init},
+	/* Skip & Do not touch to DDR clock */
+	[3] = {4, &clk_sata_init},
+	[4] = {5, &clk_audio_init},
+	[5] = {6, &clk_usbmph_init},
+	[6] = {7, &clk_etha_init},
+	[7] = {8, &clk_pciea_init},
+	[8] = {9, &clk_nand_init},
+};
+
+struct clk_oxnas_data {
+	struct clk_oxnas clk_oxnas[ARRAY_SIZE(clk_oxnas_init)];
+	struct clk_onecell_data onecell_data[ARRAY_SIZE(clk_oxnas_init)];
+	struct clk *clks[ARRAY_SIZE(clk_oxnas_init)];
+};
+
+static int oxnas_stdclk_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct clk_oxnas_data *clk_oxnas;
+	struct regmap *regmap;
+	int i;
+
+	clk_oxnas = devm_kzalloc(&pdev->dev, sizeof(*clk_oxnas), GFP_KERNEL);
+	if (!clk_oxnas)
+		return -ENOMEM;
+
+	regmap = syscon_node_to_regmap(of_get_parent(np));
+	if (!regmap) {
+		dev_err(&pdev->dev, "failed to have parent regmap\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(clk_oxnas_init); i++) {
+		struct clk_oxnas *_clk;
+
+		_clk = &clk_oxnas->clk_oxnas[i];
+		_clk->bit = clk_oxnas_init[i].bit;
+		_clk->hw.init = clk_oxnas_init[i].clk_init;
+		_clk->regmap = regmap;
+
+		clk_oxnas->clks[i] =
+			devm_clk_register(&pdev->dev, &_clk->hw);
+		if (WARN_ON(IS_ERR(clk_oxnas->clks[i])))
+			return PTR_ERR(clk_oxnas->clks[i]);
+	}
+
+	clk_oxnas->onecell_data->clks = clk_oxnas->clks;
+	clk_oxnas->onecell_data->clk_num = ARRAY_SIZE(clk_oxnas_init);
+
+	return of_clk_add_provider(np, of_clk_src_onecell_get,
+				   clk_oxnas->onecell_data);
+}
+
+static int oxnas_stdclk_remove(struct platform_device *pdev)
+{
+	of_clk_del_provider(pdev->dev.of_node);
+
+	return 0;
+}
+
+static const struct of_device_id oxnas_stdclk_dt_ids[] = {
+	{ .compatible = "oxsemi,ox810se-stdclk" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, oxnas_stdclk_dt_ids);
+
+static struct platform_driver oxnas_stdclk_driver = {
+	.probe = oxnas_stdclk_probe,
+	.remove = oxnas_stdclk_remove,
+	.driver	= {
+		.name = "oxnas-stdclk",
+		.of_match_table = oxnas_stdclk_dt_ids,
+	},
+};
+
+module_platform_driver(oxnas_stdclk_driver);
