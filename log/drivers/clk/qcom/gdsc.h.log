commit 37416e554961b34451f3a160acd1e27656103e9f
Author: Bjorn Andersson <bjorn.andersson@linaro.org>
Date:   Fri Apr 17 00:00:41 2020 -0700

    clk: qcom: gdsc: Handle GDSC regulator supplies
    
    Certain GDSCs, such as the GPU_GX on MSM8996, requires that the upstream
    regulator supply is powered in order to be turned on.
    
    It's not guaranteed that the bootloader will leave these supplies on and
    the driver core will attempt to enable any GDSCs before allowing the
    individual drivers to probe defer on the PMIC regulator driver not yet
    being present.
    
    So the gdsc driver needs to be made aware of supplying regulators and
    probe defer on their absence, and it needs to enable and disable the
    regulator accordingly.
    
    Voltage adjustments of the supplying regulator are deferred to the
    client drivers themselves.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Link: https://lkml.kernel.org/r/20200417070044.1376212-2-bjorn.andersson@linaro.org
    Reviewed-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 64cdc8cf0d4d..c36fc26dcdff 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -10,6 +10,7 @@
 #include <linux/pm_domain.h>
 
 struct regmap;
+struct regulator;
 struct reset_controller_dev;
 
 /**
@@ -52,6 +53,9 @@ struct gdsc {
 	struct reset_controller_dev	*rcdev;
 	unsigned int			*resets;
 	unsigned int			reset_count;
+
+	const char 			*supply;
+	struct regulator		*rsupply;
 };
 
 struct gdsc_desc {

commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index bd1f2c780d0a..64cdc8cf0d4d 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2015, 2017-2018, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #ifndef __QCOM_GDSC_H__

commit 77122d6f7477899ba6d1b2d340956bd6fd9ee3b5
Merge: 36851edd7ea9 a3dcdc7e5417
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Mon Jun 4 12:34:51 2018 -0700

    Merge branch 'clk-qcom-sdm845' into clk-next
    
    * clk-qcom-sdm845:
      clk: qcom: Export clk_fabia_pll_configure()
      clk: qcom: Add video clock controller driver for SDM845
      dt-bindings: clock: Introduce QCOM Video clock bindings
      clk: qcom: Add Global Clock controller (GCC) driver for SDM845
      clk: qcom: Add DT bindings for SDM845 gcc clock controller
      clk: qcom: Configure the RCGs to a safe source as needed
      clk: qcom: Add support for BRANCH_HALT_SKIP flag for branch clocks
      clk: qcom: Simplify gdsc status checking logic
      clk: qcom: gdsc: Add support to poll CFG register to check GDSC state
      clk: qcom: gdsc: Add support to poll for higher timeout value
      clk: qcom: gdsc: Add support to reset AON and block reset logic
      clk: qcom: Add support for controlling Fabia PLL
      clk: qcom: Clear hardware clock control bit of RCG
    
    Also fixup the Kconfig mess where SDM845 GCC has msm8998 in the
    description and also the video Kconfig says things slightly differently
    from the GCC one so just make it the same.

commit fb55bea1fe436b2b00a8bcc0bad69c76409270e8
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Fri Mar 23 13:56:14 2018 +0530

    clk: qcom: gdsc: Add support for ALWAYS_ON gdscs
    
    Some GDSCs might have software control to turn them off, but we might
    want to keep them enabled always, in some cases because of lack of
    support in kernel to handle a graceful turning off/on of such GDSCs.
    Most common instances would be the GDCSs which power up the noc/bus
    fabrics, which need bus drivers to handle them and atleast support for
    which is missing on all qcom SoCs.
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 39648348e5ec..7fd78cec7e5b 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -53,6 +53,7 @@ struct gdsc {
 #define VOTABLE		BIT(0)
 #define CLAMP_IO	BIT(1)
 #define HW_CTRL		BIT(2)
+#define ALWAYS_ON	BIT(3)
 	struct reset_controller_dev	*rcdev;
 	unsigned int			*resets;
 	unsigned int			reset_count;

commit e892e17d0c0e3d1bb8a56b84d15f9995807b92fa
Author: Amit Nischal <anischal@codeaurora.org>
Date:   Tue May 1 10:33:33 2018 +0530

    clk: qcom: gdsc: Add support to poll CFG register to check GDSC state
    
    The default behavior of the GDSC enable/disable sequence is to
    poll the status bits of either the actual GDSCR or the
    corresponding HW_CTRL registers.
    
    On targets which have support for a CFG_GDSCR register, the
    status bits might not show the correct state of the GDSC,
    especially in the disable sequence, where the status bit
    will be cleared even before the core is completely power
    collapsed. On targets with this issue, poll the power on/off
    bits in the CFG_GDSCR register instead to correctly determine
    the GDSC state.
    
    Signed-off-by: Amit Nischal <anischal@codeaurora.org>
    Signed-off-by: Taniya Das <tdas@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 9279278535cd..b0cbb87dd02b 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -55,6 +55,7 @@ struct gdsc {
 #define HW_CTRL		BIT(2)
 #define SW_RESET	BIT(3)
 #define AON_RESET	BIT(4)
+#define POLL_CFG_GDSCR	BIT(5)
 	struct reset_controller_dev	*rcdev;
 	unsigned int			*resets;
 	unsigned int			reset_count;

commit 44dbeebf14453f577dd1f15f5c4f55db47ac42a4
Author: Amit Nischal <anischal@codeaurora.org>
Date:   Mon Apr 9 14:11:44 2018 +0530

    clk: qcom: gdsc: Add support to reset AON and block reset logic
    
    For some of the gdsc power domains, there could be need to reset the
    AON logic or assert/deassert the block control reset before removing
    the clamp_io. Add support for the same by introducing new flags
    SW_RESET and AON_RESET. Both SW reset and AON reset requires to be
    asserted for at least 1us before being de-asserted.
    
    Signed-off-by: Taniya Das <tdas@codeaurora.org>
    Signed-off-by: Amit Nischal <anischal@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 39648348e5ec..9279278535cd 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015, 2017-2018, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -53,6 +53,8 @@ struct gdsc {
 #define VOTABLE		BIT(0)
 #define CLAMP_IO	BIT(1)
 #define HW_CTRL		BIT(2)
+#define SW_RESET	BIT(3)
+#define AON_RESET	BIT(4)
 	struct reset_controller_dev	*rcdev;
 	unsigned int			*resets;
 	unsigned int			reset_count;

commit 904bb4f5c7de2f40ff31d43d3547d40910e46640
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Fri Nov 18 17:58:26 2016 +0530

    clk: qcom: gdsc: Add support for gdscs with HW control
    
    Some GDSCs might support a HW control mode, where in the power
    domain (gdsc) is brought in and out of low power state (while
    unsued) without any SW assistance, saving power.
    Such GDSCs can be configured in a HW control mode when powered on
    until they are explicitly requested to be powered off by software.
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index f011c4957527..39648348e5ec 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -52,6 +52,7 @@ struct gdsc {
 	const u8			flags;
 #define VOTABLE		BIT(0)
 #define CLAMP_IO	BIT(1)
+#define HW_CTRL		BIT(2)
 	struct reset_controller_dev	*rcdev;
 	unsigned int			*resets;
 	unsigned int			reset_count;

commit e7cc455fcd07c9c4ad240a392610f31e1e0460cf
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Thu Oct 20 15:08:06 2016 +0530

    clk: qcom: Handle the clamp_io assert/deassert sequence
    
    Add a flag to mark gdscs which need to support the clamp deassert/assert
    before and after the gdsc enable/disable
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 3bf497c36bdf..f011c4957527 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -39,6 +39,7 @@ struct gdsc {
 	struct regmap			*regmap;
 	unsigned int			gdscr;
 	unsigned int			gds_hw_ctrl;
+	unsigned int			clamp_io_ctrl;
 	unsigned int			*cxcs;
 	unsigned int			cxc_count;
 	const u8			pwrsts;
@@ -50,6 +51,7 @@ struct gdsc {
 #define PWRSTS_RET_ON		(PWRSTS_RET | PWRSTS_ON)
 	const u8			flags;
 #define VOTABLE		BIT(0)
+#define CLAMP_IO	BIT(1)
 	struct reset_controller_dev	*rcdev;
 	unsigned int			*resets;
 	unsigned int			reset_count;

commit a823bb9fbefbac8d8bf37d5b4879ee876f2356c5
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Tue Dec 1 21:42:13 2015 +0530

    clk: qcom: gdsc: Add support for votable gdscs
    
    Some gdscs might be controlled via voting registers and might not
    really disable when the kernel intends to disable them (due to other
    votes keeping them enabled)
    Mark these gdscs with a flag for we do not check/wait on a disable
    status for these gdscs within the kernel disable callback.
    
    Also at boot, if these GDSCs are found to be ON, we make sure we
    vote for them before we inform the genpd framework about their
    status. If genpd gets no users, it then disables (removes the vote)
    them as part of genpd_poweroff_unused()
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 66a43beb9f57..3bf497c36bdf 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -20,13 +20,6 @@
 struct regmap;
 struct reset_controller_dev;
 
-/* Powerdomain allowable state bitfields */
-#define PWRSTS_OFF		BIT(0)
-#define PWRSTS_RET		BIT(1)
-#define PWRSTS_ON		BIT(2)
-#define PWRSTS_OFF_ON		(PWRSTS_OFF | PWRSTS_ON)
-#define PWRSTS_RET_ON		(PWRSTS_RET | PWRSTS_ON)
-
 /**
  * struct gdsc - Globally Distributed Switch Controller
  * @pd: generic power domain
@@ -49,6 +42,14 @@ struct gdsc {
 	unsigned int			*cxcs;
 	unsigned int			cxc_count;
 	const u8			pwrsts;
+/* Powerdomain allowable state bitfields */
+#define PWRSTS_OFF		BIT(0)
+#define PWRSTS_RET		BIT(1)
+#define PWRSTS_ON		BIT(2)
+#define PWRSTS_OFF_ON		(PWRSTS_OFF | PWRSTS_ON)
+#define PWRSTS_RET_ON		(PWRSTS_RET | PWRSTS_ON)
+	const u8			flags;
+#define VOTABLE		BIT(0)
 	struct reset_controller_dev	*rcdev;
 	unsigned int			*resets;
 	unsigned int			reset_count;

commit 77b1067a19b4986b009f3279cc6b8ad1d29ff51c
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Tue Dec 1 21:42:12 2015 +0530

    clk: qcom: gdsc: Add support for gdscs with gds hw controller
    
    Some gdsc power domains can have a gds_hw_controller block inside
    to help ensure all slave devices within the power domain are idle
    before the gdsc is actually switched off.
    This is mainly useful in power domains which host a MMU, in which
    case its necessary to make sure there are no outstanding MMU operations
    or pending bus transactions before the power domain is turned off.
    
    In gdscs with gds_hw_controller block, its necessary to check the
    gds_hw_ctrl status bits instead of the ones in gdscr, to determine
    the state of the powerdomain.
    
    While at it, also move away from using jiffies and use ktime APIs
    instead for busy looping on status bits.
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 4e9dfc11ef57..66a43beb9f57 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -32,6 +32,7 @@ struct reset_controller_dev;
  * @pd: generic power domain
  * @regmap: regmap for MMIO accesses
  * @gdscr: gsdc control register
+ * @gds_hw_ctrl: gds_hw_ctrl register
  * @cxcs: offsets of branch registers to toggle mem/periph bits in
  * @cxc_count: number of @cxcs
  * @pwrsts: Possible powerdomain power states
@@ -44,6 +45,7 @@ struct gdsc {
 	struct generic_pm_domain	*parent;
 	struct regmap			*regmap;
 	unsigned int			gdscr;
+	unsigned int			gds_hw_ctrl;
 	unsigned int			*cxcs;
 	unsigned int			cxc_count;
 	const u8			pwrsts;

commit c2c7f0a47493ae23f9a76fabdbdd4f25e1de0925
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Tue Dec 1 21:42:11 2015 +0530

    clk: qcom: gdsc: Add support for hierarchical power domains
    
    Some qcom SoCs' can have hierarchical power domains. Let the gdsc structs
    specify the parents (if any) and the driver add genpd subdomains for them.
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 5ded26884f08..4e9dfc11ef57 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -41,6 +41,7 @@ struct reset_controller_dev;
  */
 struct gdsc {
 	struct generic_pm_domain	pd;
+	struct generic_pm_domain	*parent;
 	struct regmap			*regmap;
 	unsigned int			gdscr;
 	unsigned int			*cxcs;
@@ -51,18 +52,24 @@ struct gdsc {
 	unsigned int			reset_count;
 };
 
+struct gdsc_desc {
+	struct device *dev;
+	struct gdsc **scs;
+	size_t num;
+};
+
 #ifdef CONFIG_QCOM_GDSC
-int gdsc_register(struct device *, struct gdsc **, size_t n,
-		  struct reset_controller_dev *, struct regmap *);
-void gdsc_unregister(struct device *);
+int gdsc_register(struct gdsc_desc *desc, struct reset_controller_dev *,
+		  struct regmap *);
+void gdsc_unregister(struct gdsc_desc *desc);
 #else
-static inline int gdsc_register(struct device *d, struct gdsc **g, size_t n,
+static inline int gdsc_register(struct gdsc_desc *desc,
 				struct reset_controller_dev *rcdev,
 				struct regmap *r)
 {
 	return -ENOSYS;
 }
 
-static inline void gdsc_unregister(struct device *d) {};
+static inline void gdsc_unregister(struct gdsc_desc *desc) {};
 #endif /* CONFIG_QCOM_GDSC */
 #endif /* __QCOM_GDSC_H__ */

commit 3c53f5e2179874441a1741ec7bcbaa92fcec9c79
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Thu Aug 6 16:07:45 2015 +0530

    clk: qcom: gdsc: Add support for ON only state
    
    Certain devices can have GDSCs' which support ON as the only state.
    They can't be power collapsed to either hit RET or OFF.
    The clients drivers for these GDSCs' however would expect the state
    of the core to be reset following a GDSC disable and re-enable.
    To do this assert/deassert reset lines every time the client
    driver would request the GDSC to be powered on/off instead.
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index 0ff251a5523f..5ded26884f08 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -18,6 +18,7 @@
 #include <linux/pm_domain.h>
 
 struct regmap;
+struct reset_controller_dev;
 
 /* Powerdomain allowable state bitfields */
 #define PWRSTS_OFF		BIT(0)
@@ -34,6 +35,9 @@ struct regmap;
  * @cxcs: offsets of branch registers to toggle mem/periph bits in
  * @cxc_count: number of @cxcs
  * @pwrsts: Possible powerdomain power states
+ * @resets: ids of resets associated with this gdsc
+ * @reset_count: number of @resets
+ * @rcdev: reset controller
  */
 struct gdsc {
 	struct generic_pm_domain	pd;
@@ -42,13 +46,18 @@ struct gdsc {
 	unsigned int			*cxcs;
 	unsigned int			cxc_count;
 	const u8			pwrsts;
+	struct reset_controller_dev	*rcdev;
+	unsigned int			*resets;
+	unsigned int			reset_count;
 };
 
 #ifdef CONFIG_QCOM_GDSC
-int gdsc_register(struct device *, struct gdsc **, size_t n, struct regmap *);
+int gdsc_register(struct device *, struct gdsc **, size_t n,
+		  struct reset_controller_dev *, struct regmap *);
 void gdsc_unregister(struct device *);
 #else
 static inline int gdsc_register(struct device *d, struct gdsc **g, size_t n,
+				struct reset_controller_dev *rcdev,
 				struct regmap *r)
 {
 	return -ENOSYS;

commit 014e193ccd197d15b6f7bf6d3d616600091c14ad
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Thu Aug 6 16:07:44 2015 +0530

    clk: qcom: gdsc: Add support for Memory RET/OFF
    
    Along with the GDSC power switch, there is additional control
    to either retain all memory (core and peripheral) within a given
    powerdomain or to turn them off while the GDSC is powered down.
    Add support for these by modelling a RET state where all
    memory is retained and an OFF state where all memory gets turned
    off.
    The controls provided are granular enough to be able to support
    various differnt levels of RET states, like a 'shallow RET' with all memory
    retained and a 'deep RET' with some memory retained while some others
    are lost. The current patch does not support this and considers
    just one RET state where all memory is retained. Futher work, if
    needed can support multiple different levels of RET state.
    
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
index f578a0cce425..0ff251a5523f 100644
--- a/drivers/clk/qcom/gdsc.h
+++ b/drivers/clk/qcom/gdsc.h
@@ -19,16 +19,29 @@
 
 struct regmap;
 
+/* Powerdomain allowable state bitfields */
+#define PWRSTS_OFF		BIT(0)
+#define PWRSTS_RET		BIT(1)
+#define PWRSTS_ON		BIT(2)
+#define PWRSTS_OFF_ON		(PWRSTS_OFF | PWRSTS_ON)
+#define PWRSTS_RET_ON		(PWRSTS_RET | PWRSTS_ON)
+
 /**
  * struct gdsc - Globally Distributed Switch Controller
  * @pd: generic power domain
  * @regmap: regmap for MMIO accesses
  * @gdscr: gsdc control register
+ * @cxcs: offsets of branch registers to toggle mem/periph bits in
+ * @cxc_count: number of @cxcs
+ * @pwrsts: Possible powerdomain power states
  */
 struct gdsc {
 	struct generic_pm_domain	pd;
 	struct regmap			*regmap;
 	unsigned int			gdscr;
+	unsigned int			*cxcs;
+	unsigned int			cxc_count;
+	const u8			pwrsts;
 };
 
 #ifdef CONFIG_QCOM_GDSC

commit 45dd0e55317ccb27fe8eae639275c2b3a2fb52e5
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Aug 6 16:07:42 2015 +0530

    clk: qcom: Add support for GDSCs
    
    GDSCs (Global Distributed Switch Controllers) are responsible for
    safely collapsing and restoring power to peripherals in the SoC.
    These are best modelled as power domains using genpd and given
    the registers are scattered throughout the clock controller register
    space, its best to have the support added through the clock driver.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/qcom/gdsc.h b/drivers/clk/qcom/gdsc.h
new file mode 100644
index 000000000000..f578a0cce425
--- /dev/null
+++ b/drivers/clk/qcom/gdsc.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __QCOM_GDSC_H__
+#define __QCOM_GDSC_H__
+
+#include <linux/err.h>
+#include <linux/pm_domain.h>
+
+struct regmap;
+
+/**
+ * struct gdsc - Globally Distributed Switch Controller
+ * @pd: generic power domain
+ * @regmap: regmap for MMIO accesses
+ * @gdscr: gsdc control register
+ */
+struct gdsc {
+	struct generic_pm_domain	pd;
+	struct regmap			*regmap;
+	unsigned int			gdscr;
+};
+
+#ifdef CONFIG_QCOM_GDSC
+int gdsc_register(struct device *, struct gdsc **, size_t n, struct regmap *);
+void gdsc_unregister(struct device *);
+#else
+static inline int gdsc_register(struct device *d, struct gdsc **g, size_t n,
+				struct regmap *r)
+{
+	return -ENOSYS;
+}
+
+static inline void gdsc_unregister(struct device *d) {};
+#endif /* CONFIG_QCOM_GDSC */
+#endif /* __QCOM_GDSC_H__ */
