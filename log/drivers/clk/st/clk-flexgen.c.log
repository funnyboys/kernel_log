commit a403bbab1a73d798728d76931cab3ff0399b9560
Author: Alain Volmat <avolmat@me.com>
Date:   Sun Mar 22 15:07:40 2020 +0100

    clk: clk-flexgen: fix clock-critical handling
    
    Fixes an issue leading to having all clocks following a critical
    clocks marked as well as criticals.
    
    Fixes: fa6415affe20 ("clk: st: clk-flexgen: Detect critical clocks")
    Signed-off-by: Alain Volmat <avolmat@me.com>
    Link: https://lkml.kernel.org/r/20200322140740.3970-1-avolmat@me.com
    Reviewed-by: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 4413b6e04a8e..55873d4b7603 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -375,6 +375,7 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 			break;
 		}
 
+		flex_flags &= ~CLK_IS_CRITICAL;
 		of_clk_detect_critical(np, i, &flex_flags);
 
 		/*

commit d432d04560301c6350158dc4a7e8275b331fd480
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Sun Aug 4 22:01:51 2019 +0530

    clk: st: clk-flexgen: Add of_node_put() in st_of_flexgen_setup()
    
    In function st_of_flexgen_setup, variable pnode takes the return value
    of of_get_parent, which gets a node but does not put it. If pnode is not
    put before the function returns, it may cause a memory leak. Hence put
    pnode after its last occurrence.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lkml.kernel.org/r/20190804163151.6511-1-nishkadg.linux@gmail.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index d18e49b4976f..4413b6e04a8e 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -326,6 +326,7 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 		return;
 
 	reg = of_iomap(pnode, 0);
+	of_node_put(pnode);
 	if (!reg)
 		return;
 

commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index ca8d5350f94e..d18e49b4976f 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -1,9 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * clk-flexgen.c
  *
  * Copyright (C) ST-Microelectronics SA 2013
  * Author:  Maxime Coquelin <maxime.coquelin@st.com> for ST-Microelectronics.
- * License terms:  GNU General Public License (GPL), version 2  */
+ */
 
 #include <linux/clk.h>
 #include <linux/clk-provider.h>

commit c179c21e2c7a83b521984b75505c6bbfed23242a
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Dec 6 10:38:31 2018 -0800

    clk: st: Remove usage of CLK_IS_BASIC
    
    This flag doesn't look to be used by any code, just set in various clk
    init structures and then never tested again. Remove it from these
    drivers as it doesn't provide any benefit.
    
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 918ba3164da9..ca8d5350f94e 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -210,7 +210,7 @@ static struct clk *clk_register_flexgen(const char *name,
 
 	init.name = name;
 	init.ops = &flexgen_ops;
-	init.flags = CLK_IS_BASIC | CLK_GET_RATE_NOCACHE | flexgen_flags;
+	init.flags = CLK_GET_RATE_NOCACHE | flexgen_flags;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;
 

commit 16cd77645bddbcee951c63b964f23826dadbfd2e
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Sep 19 13:51:24 2016 +0530

    clk: st: clk-flexgen: Unmap region obtained by of_iomap
    
    Free memory mapping, if probe is not successful.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index a485f3b284b9..918ba3164da9 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -329,8 +329,10 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 		return;
 
 	parents = flexgen_get_parents(np, &num_parents);
-	if (!parents)
+	if (!parents) {
+		iounmap(reg);
 		return;
+	}
 
 	match = of_match_node(flexgen_of_match, np);
 	if (match) {
@@ -394,6 +396,7 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	return;
 
 err:
+	iounmap(reg);
 	if (clk_data)
 		kfree(clk_data->clks);
 	kfree(clk_data);

commit cb80ec768a0db73743a6f8b5d94c0b52b97e3ca4
Author: Gabriel Fernandez <gabriel.fernandez@st.com>
Date:   Mon Aug 29 14:26:58 2016 +0200

    drivers: clk: st: Handle clk synchronous mode for video clocks
    
    This patch configures the semi-synchronous mode of the video clocks
    of clkgenD2.
    
    Signed-off-by: Olivier Bideau <olivier.bideau@st.com>
    Signed-off-by: Gabriel Fernandez <gabriel.fernandez@st.com>
    Acked-by: Peter Griffin <peter.griffin@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 7ed05f0d629a..a485f3b284b9 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -17,6 +17,7 @@
 
 struct clkgen_data {
 	unsigned long flags;
+	bool mode;
 };
 
 struct flexgen {
@@ -32,9 +33,14 @@ struct flexgen {
 	struct clk_gate fgate;
 	/* Final divisor */
 	struct clk_divider fdiv;
+	/* Asynchronous mode control */
+	struct clk_gate sync;
+	/* hw control flags */
+	bool control_mode;
 };
 
 #define to_flexgen(_hw) container_of(_hw, struct flexgen, hw)
+#define to_clk_gate(_hw) container_of(_hw, struct clk_gate, hw)
 
 static int flexgen_enable(struct clk_hw *hw)
 {
@@ -143,12 +149,21 @@ static int flexgen_set_rate(struct clk_hw *hw, unsigned long rate,
 	struct flexgen *flexgen = to_flexgen(hw);
 	struct clk_hw *pdiv_hw = &flexgen->pdiv.hw;
 	struct clk_hw *fdiv_hw = &flexgen->fdiv.hw;
+	struct clk_hw *sync_hw = &flexgen->sync.hw;
+	struct clk_gate *config = to_clk_gate(sync_hw);
 	unsigned long div = 0;
 	int ret = 0;
+	u32 reg;
 
 	__clk_hw_set_clk(pdiv_hw, hw);
 	__clk_hw_set_clk(fdiv_hw, hw);
 
+	if (flexgen->control_mode) {
+		reg = readl(config->reg);
+		reg &= ~BIT(config->bit_idx);
+		writel(reg, config->reg);
+	}
+
 	div = clk_best_div(parent_rate, rate);
 
 	/*
@@ -182,7 +197,7 @@ static const struct clk_ops flexgen_ops = {
 static struct clk *clk_register_flexgen(const char *name,
 				const char **parent_names, u8 num_parents,
 				void __iomem *reg, spinlock_t *lock, u32 idx,
-				unsigned long flexgen_flags) {
+				unsigned long flexgen_flags, bool mode) {
 	struct flexgen *fgxbar;
 	struct clk *clk;
 	struct clk_init_data init;
@@ -231,6 +246,13 @@ static struct clk *clk_register_flexgen(const char *name,
 	fgxbar->fdiv.reg = fdiv_reg;
 	fgxbar->fdiv.width = 6;
 
+	/* Final divider sync config */
+	fgxbar->sync.lock = lock;
+	fgxbar->sync.reg = fdiv_reg;
+	fgxbar->sync.bit_idx = 7;
+
+	fgxbar->control_mode = mode;
+
 	fgxbar->hw.init = &init;
 
 	clk = clk_register(NULL, &fgxbar->hw);
@@ -267,11 +289,20 @@ static const struct clkgen_data clkgen_audio = {
 	.flags = CLK_SET_RATE_PARENT,
 };
 
+static const struct clkgen_data clkgen_video = {
+	.flags = CLK_SET_RATE_PARENT,
+	.mode = 1,
+};
+
 static const struct of_device_id flexgen_of_match[] = {
 	{
 		.compatible = "st,flexgen-audio",
 		.data = &clkgen_audio,
 	},
+	{
+		.compatible = "st,flexgen-video",
+		.data = &clkgen_video,
+	},
 	{}
 };
 
@@ -287,6 +318,7 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	struct clkgen_data *data = NULL;
 	unsigned long flex_flags = 0;
 	int ret;
+	bool clk_mode = 0;
 
 	pnode = of_get_parent(np);
 	if (!pnode)
@@ -304,6 +336,7 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	if (match) {
 		data = (struct clkgen_data *)match->data;
 		flex_flags = data->flags;
+		clk_mode = data->mode;
 	}
 
 	clk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);
@@ -347,7 +380,7 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 			continue;
 
 		clk = clk_register_flexgen(clk_name, parents, num_parents,
-					   reg, rlock, i, flex_flags);
+					   reg, rlock, i, flex_flags, clk_mode);
 
 		if (IS_ERR(clk))
 			goto err;

commit 26bd0a57755df51a34037d8151a443cec3688b80
Author: Gabriel Fernandez <gabriel.fernandez@st.com>
Date:   Mon Aug 29 14:26:57 2016 +0200

    drivers: clk: st: Add clock propagation for audio clocks
    
    This patch allows fine tuning of the quads FS for audio clocks
    accuracy.
    
    Signed-off-by: Olivier Bideau <olivier.bideau@st.com>
    Signed-off-by: Gabriel Fernandez <gabriel.fernandez@st.com>
    Acked-by: Peter Griffin <peter.griffin@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 546bd79c8e3a..7ed05f0d629a 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -15,6 +15,10 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 
+struct clkgen_data {
+	unsigned long flags;
+};
+
 struct flexgen {
 	struct clk_hw hw;
 
@@ -259,6 +263,18 @@ static const char ** __init flexgen_get_parents(struct device_node *np,
 	return parents;
 }
 
+static const struct clkgen_data clkgen_audio = {
+	.flags = CLK_SET_RATE_PARENT,
+};
+
+static const struct of_device_id flexgen_of_match[] = {
+	{
+		.compatible = "st,flexgen-audio",
+		.data = &clkgen_audio,
+	},
+	{}
+};
+
 static void __init st_of_flexgen_setup(struct device_node *np)
 {
 	struct device_node *pnode;
@@ -267,6 +283,9 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	const char **parents;
 	int num_parents, i;
 	spinlock_t *rlock = NULL;
+	const struct of_device_id *match;
+	struct clkgen_data *data = NULL;
+	unsigned long flex_flags = 0;
 	int ret;
 
 	pnode = of_get_parent(np);
@@ -281,6 +300,12 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	if (!parents)
 		return;
 
+	match = of_match_node(flexgen_of_match, np);
+	if (match) {
+		data = (struct clkgen_data *)match->data;
+		flex_flags = data->flags;
+	}
+
 	clk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);
 	if (!clk_data)
 		goto err;
@@ -307,7 +332,6 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	for (i = 0; i < clk_data->clk_num; i++) {
 		struct clk *clk;
 		const char *clk_name;
-		unsigned long flex_flags = 0;
 
 		if (of_property_read_string_index(np, "clock-output-names",
 						  i, &clk_name)) {

commit fa6415affe2020606799fd4e9e89f37a01fb2ae9
Author: Lee Jones <lee.jones@linaro.org>
Date:   Tue Jun 7 12:19:25 2016 +0100

    clk: st: clk-flexgen: Detect critical clocks
    
    Utilise the new Critical Clock infrastructure to mark clocks which
    much not be disabled as CRITICAL.
    
    While we're at it, reduce the coverage of the flex_flags variable,
    since it's only really used in a single for() loop.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 627267c7ec5c..546bd79c8e3a 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -267,7 +267,6 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	const char **parents;
 	int num_parents, i;
 	spinlock_t *rlock = NULL;
-	unsigned long flex_flags = 0;
 	int ret;
 
 	pnode = of_get_parent(np);
@@ -308,12 +307,15 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	for (i = 0; i < clk_data->clk_num; i++) {
 		struct clk *clk;
 		const char *clk_name;
+		unsigned long flex_flags = 0;
 
 		if (of_property_read_string_index(np, "clock-output-names",
 						  i, &clk_name)) {
 			break;
 		}
 
+		of_clk_detect_critical(np, i, &flex_flags);
+
 		/*
 		 * If we read an empty clock name then the output is unused
 		 */

commit caeb057cd30412b85e69f663a43f55a29666c79b
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 19 17:43:30 2016 -0800

    clk: st: Remove impossible check for of_clk_get_parent_count() < 0
    
    The checks for < 0 are impossible now that
    of_clk_get_parent_count() returns an unsigned int. Simplify the
    code and update the types.
    
    Cc: Gabriel Fernandez <gabriel.fernandez@st.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 24d99594c0b3..627267c7ec5c 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -244,10 +244,10 @@ static const char ** __init flexgen_get_parents(struct device_node *np,
 						       int *num_parents)
 {
 	const char **parents;
-	int nparents;
+	unsigned int nparents;
 
 	nparents = of_clk_get_parent_count(np);
-	if (WARN_ON(nparents <= 0))
+	if (WARN_ON(!nparents))
 		return NULL;
 
 	parents = kcalloc(nparents, sizeof(const char *), GFP_KERNEL);

commit a1c22a4be7983f64324e960f7ba373784c0c8289
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Thu Sep 24 16:00:16 2015 +0200

    clk: st: fix handling result of of_property_count_strings
    
    The function can return negative value.
    
    The problem has been detected using proposed semantic patch
    scripts/coccinelle/tests/assign_signed_to_unsigned.cocci [1].
    
    [1]: http://permalink.gmane.org/gmane.linux.kernel/2046107
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index bd355ee33766..24d99594c0b3 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -268,6 +268,7 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	int num_parents, i;
 	spinlock_t *rlock = NULL;
 	unsigned long flex_flags = 0;
+	int ret;
 
 	pnode = of_get_parent(np);
 	if (!pnode)
@@ -285,13 +286,13 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	if (!clk_data)
 		goto err;
 
-	clk_data->clk_num = of_property_count_strings(np ,
-			"clock-output-names");
-	if (clk_data->clk_num <= 0) {
+	ret = of_property_count_strings(np, "clock-output-names");
+	if (ret <= 0) {
 		pr_err("%s: Failed to get number of output clocks (%d)",
 				__func__, clk_data->clk_num);
 		goto err;
 	}
+	clk_data->clk_num = ret;
 
 	clk_data->clks = kcalloc(clk_data->clk_num, sizeof(struct clk *),
 			GFP_KERNEL);

commit 836ee0f7d95c3feb742bd4b3a02fea3fe75bdef3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Aug 12 11:42:23 2015 -0700

    clk: Convert __clk_get_name(hw->clk) to clk_hw_get_name(hw)
    
    Use the provider based method to get a clock's name so that we
    can get rid of the clk member in struct clk_hw one day. Mostly
    converted with the following coccinelle script.
    
    @@
    struct clk_hw *E;
    @@
    
    -__clk_get_name(E->clk)
    +clk_hw_get_name(E)
    
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Peter De Schrijver <pdeschrijver@nvidia.com>
    Cc: Prashant Gaikwad <pgaikwad@nvidia.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Andrew Bresticker <abrestic@chromium.org>
    Cc: Ezequiel Garcia <ezequiel.garcia@imgtec.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Kevin Cernekee <cernekee@chromium.org>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Ulrich Hecht <ulrich.hecht+renesas@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 965b13ba3515..bd355ee33766 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -45,7 +45,7 @@ static int flexgen_enable(struct clk_hw *hw)
 
 	clk_gate_ops.enable(fgate_hw);
 
-	pr_debug("%s: flexgen output enabled\n", __clk_get_name(hw->clk));
+	pr_debug("%s: flexgen output enabled\n", clk_hw_get_name(hw));
 	return 0;
 }
 
@@ -59,7 +59,7 @@ static void flexgen_disable(struct clk_hw *hw)
 
 	clk_gate_ops.disable(fgate_hw);
 
-	pr_debug("%s: flexgen output disabled\n", __clk_get_name(hw->clk));
+	pr_debug("%s: flexgen output disabled\n", clk_hw_get_name(hw));
 }
 
 static int flexgen_is_enabled(struct clk_hw *hw)

commit 98d8a60eccee74165793379f1f8a3b1cef3131c7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jun 29 16:56:30 2015 -0700

    clk: Convert __clk_get_flags() to clk_hw_get_flags()
    
    Mostly converted with the following snippet:
    
    @@
    struct clk_hw *E;
    @@
    
    -__clk_get_flags(E->clk)
    +clk_hw_get_flags(E)
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Coquelin <mcoquelin.stm32@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index ec20a2c6f9f3..965b13ba3515 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -109,7 +109,7 @@ static long flexgen_round_rate(struct clk_hw *hw, unsigned long rate,
 	/* Round div according to exact prate and wished rate */
 	div = clk_best_div(*prate, rate);
 
-	if (__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT) {
+	if (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {
 		*prate = rate * div;
 		return rate;
 	}

commit 9cfad9bc472a4bdd5ee7d9e713113a9f5a676704
Merge: 9da9e7612737 61ae76563ec3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 21 11:22:42 2015 -0700

    Merge branch 'cleanup-clk-h-includes' into clk-next
    
    * cleanup-clk-h-includes: (62 commits)
      clk: Remove clk.h from clk-provider.h
      clk: h8300: Remove clk.h and clkdev.h includes
      clk: at91: Include clk.h and slab.h
      clk: ti: Switch clk-provider.h include to clk.h
      clk: pistachio: Include clk.h
      clk: ingenic: Include clk.h
      clk: si570: Include clk.h
      clk: moxart: Include clk.h
      clk: cdce925: Include clk.h
      clk: Include clk.h in clk.c
      clk: zynq: Include clk.h
      clk: ti: Include clk.h
      clk: sunxi: Include clk.h and remove unused clkdev.h includes
      clk: st: Include clk.h
      clk: qcom: Include clk.h
      clk: highbank: Include clk.h
      clk: bcm: Include clk.h
      clk: versatile: Remove clk.h and clkdev.h includes
      clk: ux500: Remove clk.h and clkdev.h includes
      clk: tegra: Properly include clk.h
      ...

commit 0b4e7f0842fe5c8bd19654999f6c41c4119e7c90
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Mon Jul 6 22:59:04 2015 -0500

    clk: st: make use of of_clk_parent_fill helper function
    
    Use of_clk_parent_fill to fill in the parent clock names' array.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Tested-by Gabriel Fernandez <gabriel.fernandez@st.com>
    Cc: Peter Griffin <peter.griffin@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 8dd8cce27361..308dc2f265b1 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -243,7 +243,7 @@ static const char ** __init flexgen_get_parents(struct device_node *np,
 						       int *num_parents)
 {
 	const char **parents;
-	int nparents, i;
+	int nparents;
 
 	nparents = of_clk_get_parent_count(np);
 	if (WARN_ON(nparents <= 0))
@@ -253,10 +253,8 @@ static const char ** __init flexgen_get_parents(struct device_node *np,
 	if (!parents)
 		return NULL;
 
-	for (i = 0; i < nparents; i++)
-		parents[i] = of_clk_get_parent_name(np, i);
+	*num_parents = of_clk_parent_fill(np, parents, nparents);
 
-	*num_parents = nparents;
 	return parents;
 }
 

commit d5f728acd90e864251139ffc59294b336cf4b382
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: st: Include clk.h
    
    This clock provider uses the consumer API, so include clk.h
    explicitly.
    
    Cc: Gabriel Fernandez <gabriel.fernandez@st.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 657ca14ba709..8e0dbb1f81f8 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -5,6 +5,7 @@
  * Author:  Maxime Coquelin <maxime.coquelin@st.com> for ST-Microelectronics.
  * License terms:  GNU General Public License (GPL), version 2  */
 
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 #include <linux/slab.h>

commit 18fee4538fe534c53fa95fe9eaa7f96586814e0a
Author: Pankaj Dev <pankaj.dev@st.com>
Date:   Tue Jun 23 16:09:24 2015 +0200

    drivers: clk: st: Add CLK_GET_RATE_NOCACHE flag to clocks
    
    Add the CLK_GET_RATE_NOCACHE flag to all the clocks with recalc ops,
    so that they reflect Hw rate after CPS wake-up when a clk_get_rate()
    is called
    
    Signed-off-by: Pankaj Dev <pankaj.dev@st.com>
    Signed-off-by: Gabriel Fernandez <gabriel.fernandez@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index be06d2a79dce..8dd8cce27361 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -190,7 +190,7 @@ static struct clk *clk_register_flexgen(const char *name,
 
 	init.name = name;
 	init.ops = &flexgen_ops;
-	init.flags = CLK_IS_BASIC | flexgen_flags;
+	init.flags = CLK_IS_BASIC | CLK_GET_RATE_NOCACHE | flexgen_flags;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;
 

commit 0f4f2afd4402883a51ad27a1d9e046643bb1e3cb
Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
Date:   Tue Jun 23 16:09:23 2015 +0200

    drivers: clk: st: Fix flexgen lock init
    
    While proving lock, the following warning happens
    and it is fixed after initializing lock in the setup
    function
    
    INFO: trying to register non-static key.
    the code is fine but needs lockdep annotation.
    turning off the locking correctness validator.
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.10.27-02861-g39df285-dirty #33
    [<c00154ac>] (unwind_backtrace+0x0/0xf4) from [<c0011b50>] (show_stack+0x10/0x14)
    [<c0011b50>] (show_stack+0x10/0x14) from [<c00689ac>] (__lock_acquire+0x900/0xb14)
    [<c00689ac>] (__lock_acquire+0x900/0xb14) from [<c0069394>] (lock_acquire+0x68/0x7c)
    [<c0069394>] (lock_acquire+0x68/0x7c) from [<c04958f8>] (_raw_spin_lock_irqsave+0x48/0x5c)
    [<c04958f8>] (_raw_spin_lock_irqsave+0x48/0x5c) from [<c0381e6c>] (clk_gate_endisable+0x28/0x88)
    [<c0381e6c>] (clk_gate_endisable+0x28/0x88) from [<c0381ee0>] (clk_gate_enable+0xc/0x14)
    [<c0381ee0>] (clk_gate_enable+0xc/0x14) from [<c0386c68>] (flexgen_enable+0x28/0x40)
    [<c0386c68>] (flexgen_enable+0x28/0x40) from [<c037f260>] (__clk_enable+0x5c/0x9c)
    [<c037f260>] (__clk_enable+0x5c/0x9c) from [<c037f558>] (clk_enable+0x18/0x2c)
    [<c037f558>] (clk_enable+0x18/0x2c) from [<c064a1dc>] (st_lpc_of_register+0xc0/0x248)
    [<c064a1dc>] (st_lpc_of_register+0xc0/0x248) from [<c0649e44>] (clocksource_of_init+0x34/0x58)
    [<c0649e44>] (clocksource_of_init+0x34/0x58) from [<c0637ddc>] (sti_timer_init+0x10/0x18)
    [<c0637ddc>] (sti_timer_init+0x10/0x18) from [<c06343f8>] (time_init+0x20/0x30)
    [<c06343f8>] (time_init+0x20/0x30) from [<c0632984>] (start_kernel+0x20c/0x2e8)
    [<c0632984>] (start_kernel+0x20c/0x2e8) from [<40008074>] (0x40008074)
    
    Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
    Signed-off-by: Gabriel Fernandez <gabriel.fernandez@linaro.org>
    Fixes: b116517055b7 ("clk: st: STiH407: Support for Flexgen Clocks")
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 657ca14ba709..be06d2a79dce 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -303,6 +303,8 @@ static void __init st_of_flexgen_setup(struct device_node *np)
 	if (!rlock)
 		goto err;
 
+	spin_lock_init(rlock);
+
 	for (i = 0; i < clk_data->clk_num; i++) {
 		struct clk *clk;
 		const char *clk_name;

commit 0a65239c280bb0d56d8d84c4a9cc78bc68144925
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri May 29 11:25:46 2015 +0200

    clk: st: Use of_clk_get_parent_count() instead of open coding
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 409ed4b0b569..657ca14ba709 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -245,7 +245,7 @@ static const char ** __init flexgen_get_parents(struct device_node *np,
 	const char **parents;
 	int nparents, i;
 
-	nparents = of_count_phandle_with_args(np, "clocks", "#clock-cells");
+	nparents = of_clk_get_parent_count(np);
 	if (WARN_ON(nparents <= 0))
 		return NULL;
 

commit 8e6dd77ccc324a57d5f37c7f8b1e37319fb2e2b3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri May 1 12:45:53 2015 -0700

    clk: st: Silence sparse warnings
    
    drivers/clk/st/clkgen-mux.c:134:4: warning: symbol 'clkgena_divmux_get_parent' was not declared. Should it be static?
    drivers/clk/st/clkgen-mux.c:171:15: warning: symbol 'clkgena_divmux_recalc_rate' was not declared. Should it be static?
    drivers/clk/st/clkgen-mux.c:218:12: warning: symbol 'clk_register_genamux' was not declared. Should it be static?
    drivers/clk/st/clkgen-mux.c:388:13: warning: symbol 'st_of_clkgena_divmux_setup' was not declared. Should it be static?
    drivers/clk/st/clkgen-mux.c:488:13: warning: symbol 'st_of_clkgena_prediv_setup' was not declared. Should it be static?
    drivers/clk/st/clkgen-mux.c:625:13: warning: symbol 'st_of_clkgen_mux_setup' was not declared. Should it be static?
    drivers/clk/st/clkgen-mux.c:702:13: warning: symbol 'st_of_clkgen_vcc_setup' was not declared. Should it be static?
    drivers/clk/st/clkgen-pll.c:273:15: warning: symbol 'recalc_stm_pll800c65' was not declared. Should it be static?
    drivers/clk/st/clkgen-pll.c:300:15: warning: symbol 'recalc_stm_pll1600c65' was not declared. Should it be static?
    drivers/clk/st/clkgen-pll.c:324:15: warning: symbol 'recalc_stm_pll3200c32' was not declared. Should it be static?
    drivers/clk/st/clkgen-pll.c:346:15: warning: symbol 'recalc_stm_pll1200c32' was not declared. Should it be static?
    drivers/clk/st/clkgen-pll.c:565:19: warning: incorrect type in assignment (different address spaces)
    drivers/clk/st/clkgen-pll.c:565:19:    expected void [noderef] <asn:2>*reg
    drivers/clk/st/clkgen-pll.c:565:19:    got void *
    drivers/clk/st/clkgen-pll.c:576:18: warning: incorrect type in assignment (different address spaces)
    drivers/clk/st/clkgen-pll.c:576:18:    expected void [noderef] <asn:2>*reg
    drivers/clk/st/clkgen-pll.c:576:18:    got void *
    drivers/clk/st/clkgen-pll.c:693:53: warning: incorrect type in argument 2 (different address spaces)
    drivers/clk/st/clkgen-pll.c:693:53:    expected void *[noderef] <asn:2>reg
    drivers/clk/st/clkgen-pll.c:693:53:    got void [noderef] <asn:2>*[assigned] pll_base
    drivers/clk/st/clkgen-fsyn.c:495:5: warning: symbol 'clk_fs660c32_vco_get_rate' was not declared. Should it be static?
    drivers/clk/st/clkgen-fsyn.c:522:5: warning: symbol 'clk_fs660c32_vco_get_params' was not declared. Should it be static?
    drivers/clk/st/clk-flexgen.c:119:15: warning: symbol 'flexgen_recalc_rate' was not declared. Should it be static?
    drivers/clk/st/clk-flexgen.c:177:12: warning: symbol 'clk_register_flexgen' was not declared. Should it be static?
    drivers/clk/st/clk-flexgen.c:263:13: warning: symbol 'st_of_flexgen_setup' was not declared. Should it be static?
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index bf12a25eb3a2..409ed4b0b569 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -116,7 +116,7 @@ static long flexgen_round_rate(struct clk_hw *hw, unsigned long rate,
 	return *prate / div;
 }
 
-unsigned long flexgen_recalc_rate(struct clk_hw *hw,
+static unsigned long flexgen_recalc_rate(struct clk_hw *hw,
 		unsigned long parent_rate)
 {
 	struct flexgen *flexgen = to_flexgen(hw);
@@ -174,7 +174,7 @@ static const struct clk_ops flexgen_ops = {
 	.set_rate = flexgen_set_rate,
 };
 
-struct clk *clk_register_flexgen(const char *name,
+static struct clk *clk_register_flexgen(const char *name,
 				const char **parent_names, u8 num_parents,
 				void __iomem *reg, spinlock_t *lock, u32 idx,
 				unsigned long flexgen_flags) {
@@ -260,7 +260,7 @@ static const char ** __init flexgen_get_parents(struct device_node *np,
 	return parents;
 }
 
-void __init st_of_flexgen_setup(struct device_node *np)
+static void __init st_of_flexgen_setup(struct device_node *np)
 {
 	struct device_node *pnode;
 	void __iomem *reg;

commit 4e907ef6bd5eeb18bcc78f08bc993b94f007b79f
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Thu Feb 12 14:58:30 2015 +0100

    clk: Replace explicit clk assignment with __clk_hw_set_clk
    
    The change in the clk API to return a per-user clock instance, moved
    the clock state to struct clk_core so now the struct clk_hw .core field
    is used instead of .clk for most operations.
    
    So for hardware clocks that needs to share the same clock state, both
    the .core and .clk pointers have to be assigned but currently only the
    .clk is set. This leads to NULL pointer dereference when the operations
    try to access the hw clock .core. For example, the composite clock rate
    and mux components didn't have a .core set which leads to this error:
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000034
    pgd = c0004000
    [00000034] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.19.0-next-20150211-00002-g1fb7f0e1150d #423
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    task: ee480000 ti: ee488000 task.ti: ee488000
    PC is at clk_mux_determine_rate_flags+0x14/0x19c
    LR is at __clk_mux_determine_rate+0x24/0x2c
    pc : [<c03a355c>]    lr : [<c03a3734>]    psr: a0000113
    sp : ee489ce8  ip : ee489d84  fp : ee489d84
    r10: 0000005c  r9 : 00000001  r8 : 016e3600
    r7 : 00000000  r6 : 00000000  r5 : ee442200  r4 : ee440c98
    r3 : ffffffff  r2 : 00000000  r1 : 016e3600  r0 : ee440c98
    Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c5387d  Table: 4000406a  DAC: 00000015
    Process swapper/0 (pid: 1, stack limit = 0xee488210)
    Stack: (0xee489ce8 to 0xee48a000)
    9ce0:                   00000000 ffffffff 60000113 ee440c98 ee442200 00000000
    9d00: 016e3600 ffffffff 00000001 0000005c ee489d84 c03a3734 ee489d80 ee489d84
    9d20: 00000000 c048b130 00000400 c03a5798 ee489d80 ee489d84 c0607f60 ffffffea
    9d40: 00000001 00000001 ee489d5c c003f844 c06e3340 ee402680 ee440d0c ed935000
    9d60: 016e3600 00000003 00000001 0000005c eded3700 c03a11a0 ee489d80 ee489d84
    9d80: 016e3600 ee402680 c05b413a eddc9900 016e3600 c03a1228 00000000 ffffffff
    9da0: ffffffff eddc9900 016e3600 c03a1c1c ffffffff 016e3600 ed8c6710 c03d6ce4
    9dc0: eded3400 00000000 00000000 c03c797c 00000001 0000005c eded3700 eded3700
    9de0: 000005e0 00000001 0000005c c03db8ac c06e7e54 c03c8f08 00000000 c06e7e64
    9e00: c06b6e74 c06e7f64 000005e0 c06e7df8 c06e5100 00000000 c06e7e6c c06e7f54
    9e20: 00000000 00000000 eebd9550 00000000 c06e7da0 c06e7e54 ee7b5010 c06e7da0
    9e40: eddc9690 c06e7db4 c06b6e74 00000097 00000000 c03d4398 00000000 ee7b5010
    9e60: eebd9550 c06e7da0 00000000 c03db824 ee7b5010 fffffffe c06e7db4 c0299c7c
    9e80: ee7b5010 c072a05c 00000000 c0298858 ee7b5010 c06e7db4 ee7b5044 00000000
    9ea0: eddc9580 c0298a04 c06e7db4 00000000 c0298978 c02971d4 ee405c78 ee732b40
    9ec0: c06e7db4 eded3800 c06d6738 c0298044 c0608300 c06e7db4 00000000 c06e7db4
    9ee0: 00000000 c06beb58 c06beb58 c0299024 00000000 c068dd00 00000000 c0008944
    9f00: 00000038 c049013c ee462200 c0711920 ee480000 60000113 c06c2cb0 00000000
    9f20: 00000000 c06c2cb0 60000113 00000000 ef7fcafc 00000000 c0640194 c00389ec
    9f40: c05ec3a8 c063f824 00000006 00000006 c06c2c50 c0696444 00000006 c0696424
    9f60: c06ee1c0 c066b588 c06b6e74 00000097 00000000 c066bd44 00000006 00000006
    9f80: c066b588 c003d684 00000000 c0481938 00000000 00000000 00000000 00000000
    9fa0: 00000000 c0481940 00000000 c000e680 00000000 00000000 00000000 00000000
    9fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    9fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    [<c03a355c>] (clk_mux_determine_rate_flags) from [<c03a3734>] (__clk_mux_determine_rate+0x24/0x2c)
    [<c03a3734>] (__clk_mux_determine_rate) from [<c03a5798>] (clk_composite_determine_rate+0xbc/0x238)
    [<c03a5798>] (clk_composite_determine_rate) from [<c03a11a0>] (clk_core_round_rate_nolock+0x5c/0x9c)
    [<c03a11a0>] (clk_core_round_rate_nolock) from [<c03a1228>] (__clk_round_rate+0x38/0x40)
    [<c03a1228>] (__clk_round_rate) from [<c03a1c1c>] (clk_round_rate+0x20/0x38)
    [<c03a1c1c>] (clk_round_rate) from [<c03d6ce4>] (max98090_dai_set_sysclk+0x34/0x118)
    [<c03d6ce4>] (max98090_dai_set_sysclk) from [<c03c797c>] (snd_soc_dai_set_sysclk+0x38/0x80)
    [<c03c797c>] (snd_soc_dai_set_sysclk) from [<c03db8ac>] (snow_late_probe+0x24/0x48)
    [<c03db8ac>] (snow_late_probe) from [<c03c8f08>] (snd_soc_register_card+0xf04/0x1070)
    [<c03c8f08>] (snd_soc_register_card) from [<c03d4398>] (devm_snd_soc_register_card+0x30/0x64)
    [<c03d4398>] (devm_snd_soc_register_card) from [<c03db824>] (snow_probe+0x68/0xcc)
    [<c03db824>] (snow_probe) from [<c0299c7c>] (platform_drv_probe+0x48/0x98)
    [<c0299c7c>] (platform_drv_probe) from [<c0298858>] (driver_probe_device+0x114/0x234)
    [<c0298858>] (driver_probe_device) from [<c0298a04>] (__driver_attach+0x8c/0x90)
    [<c0298a04>] (__driver_attach) from [<c02971d4>] (bus_for_each_dev+0x54/0x88)
    [<c02971d4>] (bus_for_each_dev) from [<c0298044>] (bus_add_driver+0xd8/0x1cc)
    [<c0298044>] (bus_add_driver) from [<c0299024>] (driver_register+0x78/0xf4)
    [<c0299024>] (driver_register) from [<c0008944>] (do_one_initcall+0x80/0x1d0)
    [<c0008944>] (do_one_initcall) from [<c066bd44>] (kernel_init_freeable+0x10c/0x1d8)
    [<c066bd44>] (kernel_init_freeable) from [<c0481940>] (kernel_init+0x8/0xe4)
    [<c0481940>] (kernel_init) from [<c000e680>] (ret_from_fork+0x14/0x34)
    Code: e24dd00c e5907000 e1a08001 e88d000c (e5970034)
    
    The changes were made using the following cocinelle semantic patch:
    
    @i@
    @@
    
    @depends on i@
    identifier dst;
    @@
    
    - dst->clk = hw->clk;
    + __clk_hw_set_clk(dst, hw);
    
    @depends on i@
    identifier dst;
    @@
    
    - dst->hw.clk = hw->clk;
    + __clk_hw_set_clk(&dst->hw, hw);
    
    Fixes: 035a61c314eb3 ("clk: Make clk API return per-user struct clk instances")
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 3a484b3cb448..bf12a25eb3a2 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -37,8 +37,8 @@ static int flexgen_enable(struct clk_hw *hw)
 	struct clk_hw *pgate_hw = &flexgen->pgate.hw;
 	struct clk_hw *fgate_hw = &flexgen->fgate.hw;
 
-	pgate_hw->clk = hw->clk;
-	fgate_hw->clk = hw->clk;
+	__clk_hw_set_clk(pgate_hw, hw);
+	__clk_hw_set_clk(fgate_hw, hw);
 
 	clk_gate_ops.enable(pgate_hw);
 
@@ -54,7 +54,7 @@ static void flexgen_disable(struct clk_hw *hw)
 	struct clk_hw *fgate_hw = &flexgen->fgate.hw;
 
 	/* disable only the final gate */
-	fgate_hw->clk = hw->clk;
+	__clk_hw_set_clk(fgate_hw, hw);
 
 	clk_gate_ops.disable(fgate_hw);
 
@@ -66,7 +66,7 @@ static int flexgen_is_enabled(struct clk_hw *hw)
 	struct flexgen *flexgen = to_flexgen(hw);
 	struct clk_hw *fgate_hw = &flexgen->fgate.hw;
 
-	fgate_hw->clk = hw->clk;
+	__clk_hw_set_clk(fgate_hw, hw);
 
 	if (!clk_gate_ops.is_enabled(fgate_hw))
 		return 0;
@@ -79,7 +79,7 @@ static u8 flexgen_get_parent(struct clk_hw *hw)
 	struct flexgen *flexgen = to_flexgen(hw);
 	struct clk_hw *mux_hw = &flexgen->mux.hw;
 
-	mux_hw->clk = hw->clk;
+	__clk_hw_set_clk(mux_hw, hw);
 
 	return clk_mux_ops.get_parent(mux_hw);
 }
@@ -89,7 +89,7 @@ static int flexgen_set_parent(struct clk_hw *hw, u8 index)
 	struct flexgen *flexgen = to_flexgen(hw);
 	struct clk_hw *mux_hw = &flexgen->mux.hw;
 
-	mux_hw->clk = hw->clk;
+	__clk_hw_set_clk(mux_hw, hw);
 
 	return clk_mux_ops.set_parent(mux_hw, index);
 }
@@ -124,8 +124,8 @@ unsigned long flexgen_recalc_rate(struct clk_hw *hw,
 	struct clk_hw *fdiv_hw = &flexgen->fdiv.hw;
 	unsigned long mid_rate;
 
-	pdiv_hw->clk = hw->clk;
-	fdiv_hw->clk = hw->clk;
+	__clk_hw_set_clk(pdiv_hw, hw);
+	__clk_hw_set_clk(fdiv_hw, hw);
 
 	mid_rate = clk_divider_ops.recalc_rate(pdiv_hw, parent_rate);
 
@@ -141,8 +141,8 @@ static int flexgen_set_rate(struct clk_hw *hw, unsigned long rate,
 	unsigned long div = 0;
 	int ret = 0;
 
-	pdiv_hw->clk = hw->clk;
-	fdiv_hw->clk = hw->clk;
+	__clk_hw_set_clk(pdiv_hw, hw);
+	__clk_hw_set_clk(fdiv_hw, hw);
 
 	div = clk_best_div(parent_rate, rate);
 

commit edc30077c926d55f500c3845f5f784c148f147db
Author: Peter Griffin <peter.griffin@linaro.org>
Date:   Tue Jan 20 15:32:41 2015 +0000

    clk: st: STiH410: Fix pdiv and fdiv divisor when setting rate
    
    Debugging eMMC on upstream kernels it has been noticed that when the
    targetpack configures MMC0 clock to 200Mhz (required to switch to
    HS200) then everything works OK. However if the kernel sets the
    clock rate using clk_set_rate, then the eMMC card initialisation
    fails with timeouts. Lower clock speeds (the default being 50Mhz)
    work ok, but they we fail to get good eMMC transfer rates.
    
    Looking through the vendor kernel clock driver reveals Giuseppe
    had already fixed this issue, but the patch hasn't made its way
    upstream.
    
    The issue is fixed by changing the logic to manage the pdiv and
    fdiv divisors used for setting the rate inside the flexgen driver code.
    
    Pdiv is mainly targeted for low freq results, while fdiv should be
    used for divs =< 64. The other way can lead to 'duty cycle'
    issues.
    
    I have changed the original patch to keep the original behaviour
    in cases where the div is >64 which matches the original comment
    and patch description more closely. Although no clocks appear to hit
    this case currently when booting an upstream kernel.
    
    Signed-off-by: Peter Griffin <peter.griffin@linaro.org>
    Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
    Signed-off-by: Michael Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 2282cef9f2ff..3a484b3cb448 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -138,16 +138,27 @@ static int flexgen_set_rate(struct clk_hw *hw, unsigned long rate,
 	struct flexgen *flexgen = to_flexgen(hw);
 	struct clk_hw *pdiv_hw = &flexgen->pdiv.hw;
 	struct clk_hw *fdiv_hw = &flexgen->fdiv.hw;
-	unsigned long primary_div = 0;
+	unsigned long div = 0;
 	int ret = 0;
 
 	pdiv_hw->clk = hw->clk;
 	fdiv_hw->clk = hw->clk;
 
-	primary_div = clk_best_div(parent_rate, rate);
+	div = clk_best_div(parent_rate, rate);
 
-	clk_divider_ops.set_rate(fdiv_hw, parent_rate, parent_rate);
-	ret = clk_divider_ops.set_rate(pdiv_hw, rate, rate * primary_div);
+	/*
+	* pdiv is mainly targeted for low freq results, while fdiv
+	* should be used for div <= 64. The other way round can
+	* lead to 'duty cycle' issues.
+	*/
+
+	if (div <= 64) {
+		clk_divider_ops.set_rate(pdiv_hw, parent_rate, parent_rate);
+		ret = clk_divider_ops.set_rate(fdiv_hw, rate, rate * div);
+	} else {
+		clk_divider_ops.set_rate(fdiv_hw, parent_rate, parent_rate);
+		ret = clk_divider_ops.set_rate(pdiv_hw, rate, rate * div);
+	}
 
 	return ret;
 }

commit b116517055b7ebde85fa8ee8704071e31ea25dc3
Author: Gabriel FERNANDEZ <gabriel.fernandez@st.com>
Date:   Tue Jul 15 17:20:22 2014 +0200

    clk: st: STiH407: Support for Flexgen Clocks
    
    This patch is the Flexgen implementation reusing as much as possible
    of Common Clock Framework functions.
    
    The idea is to have an instance of "struct flexgen" per output clock.
    It represents the clock cross bar (by a mux element), and the pre and final dividers
    (using dividers and gates elements).
    
    Signed-off-by: Maxime Coquelin <maxime.coquelin@st.com>
    Signed-off-by: Olivier Bideau <olivier.bideau@st.com>
    Signed-off-by: Gabriel Fernandez <gabriel.fernandez@linaro.org>
    Acked-by: Peter Griffin <peter.griffin@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
new file mode 100644
index 000000000000..2282cef9f2ff
--- /dev/null
+++ b/drivers/clk/st/clk-flexgen.c
@@ -0,0 +1,331 @@
+/*
+ * clk-flexgen.c
+ *
+ * Copyright (C) ST-Microelectronics SA 2013
+ * Author:  Maxime Coquelin <maxime.coquelin@st.com> for ST-Microelectronics.
+ * License terms:  GNU General Public License (GPL), version 2  */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+struct flexgen {
+	struct clk_hw hw;
+
+	/* Crossbar */
+	struct clk_mux mux;
+	/* Pre-divisor's gate */
+	struct clk_gate pgate;
+	/* Pre-divisor */
+	struct clk_divider pdiv;
+	/* Final divisor's gate */
+	struct clk_gate fgate;
+	/* Final divisor */
+	struct clk_divider fdiv;
+};
+
+#define to_flexgen(_hw) container_of(_hw, struct flexgen, hw)
+
+static int flexgen_enable(struct clk_hw *hw)
+{
+	struct flexgen *flexgen = to_flexgen(hw);
+	struct clk_hw *pgate_hw = &flexgen->pgate.hw;
+	struct clk_hw *fgate_hw = &flexgen->fgate.hw;
+
+	pgate_hw->clk = hw->clk;
+	fgate_hw->clk = hw->clk;
+
+	clk_gate_ops.enable(pgate_hw);
+
+	clk_gate_ops.enable(fgate_hw);
+
+	pr_debug("%s: flexgen output enabled\n", __clk_get_name(hw->clk));
+	return 0;
+}
+
+static void flexgen_disable(struct clk_hw *hw)
+{
+	struct flexgen *flexgen = to_flexgen(hw);
+	struct clk_hw *fgate_hw = &flexgen->fgate.hw;
+
+	/* disable only the final gate */
+	fgate_hw->clk = hw->clk;
+
+	clk_gate_ops.disable(fgate_hw);
+
+	pr_debug("%s: flexgen output disabled\n", __clk_get_name(hw->clk));
+}
+
+static int flexgen_is_enabled(struct clk_hw *hw)
+{
+	struct flexgen *flexgen = to_flexgen(hw);
+	struct clk_hw *fgate_hw = &flexgen->fgate.hw;
+
+	fgate_hw->clk = hw->clk;
+
+	if (!clk_gate_ops.is_enabled(fgate_hw))
+		return 0;
+
+	return 1;
+}
+
+static u8 flexgen_get_parent(struct clk_hw *hw)
+{
+	struct flexgen *flexgen = to_flexgen(hw);
+	struct clk_hw *mux_hw = &flexgen->mux.hw;
+
+	mux_hw->clk = hw->clk;
+
+	return clk_mux_ops.get_parent(mux_hw);
+}
+
+static int flexgen_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct flexgen *flexgen = to_flexgen(hw);
+	struct clk_hw *mux_hw = &flexgen->mux.hw;
+
+	mux_hw->clk = hw->clk;
+
+	return clk_mux_ops.set_parent(mux_hw, index);
+}
+
+static inline unsigned long
+clk_best_div(unsigned long parent_rate, unsigned long rate)
+{
+	return parent_rate / rate + ((rate > (2*(parent_rate % rate))) ? 0 : 1);
+}
+
+static long flexgen_round_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long *prate)
+{
+	unsigned long div;
+
+	/* Round div according to exact prate and wished rate */
+	div = clk_best_div(*prate, rate);
+
+	if (__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT) {
+		*prate = rate * div;
+		return rate;
+	}
+
+	return *prate / div;
+}
+
+unsigned long flexgen_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct flexgen *flexgen = to_flexgen(hw);
+	struct clk_hw *pdiv_hw = &flexgen->pdiv.hw;
+	struct clk_hw *fdiv_hw = &flexgen->fdiv.hw;
+	unsigned long mid_rate;
+
+	pdiv_hw->clk = hw->clk;
+	fdiv_hw->clk = hw->clk;
+
+	mid_rate = clk_divider_ops.recalc_rate(pdiv_hw, parent_rate);
+
+	return clk_divider_ops.recalc_rate(fdiv_hw, mid_rate);
+}
+
+static int flexgen_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct flexgen *flexgen = to_flexgen(hw);
+	struct clk_hw *pdiv_hw = &flexgen->pdiv.hw;
+	struct clk_hw *fdiv_hw = &flexgen->fdiv.hw;
+	unsigned long primary_div = 0;
+	int ret = 0;
+
+	pdiv_hw->clk = hw->clk;
+	fdiv_hw->clk = hw->clk;
+
+	primary_div = clk_best_div(parent_rate, rate);
+
+	clk_divider_ops.set_rate(fdiv_hw, parent_rate, parent_rate);
+	ret = clk_divider_ops.set_rate(pdiv_hw, rate, rate * primary_div);
+
+	return ret;
+}
+
+static const struct clk_ops flexgen_ops = {
+	.enable = flexgen_enable,
+	.disable = flexgen_disable,
+	.is_enabled = flexgen_is_enabled,
+	.get_parent = flexgen_get_parent,
+	.set_parent = flexgen_set_parent,
+	.round_rate = flexgen_round_rate,
+	.recalc_rate = flexgen_recalc_rate,
+	.set_rate = flexgen_set_rate,
+};
+
+struct clk *clk_register_flexgen(const char *name,
+				const char **parent_names, u8 num_parents,
+				void __iomem *reg, spinlock_t *lock, u32 idx,
+				unsigned long flexgen_flags) {
+	struct flexgen *fgxbar;
+	struct clk *clk;
+	struct clk_init_data init;
+	u32  xbar_shift;
+	void __iomem *xbar_reg, *fdiv_reg;
+
+	fgxbar = kzalloc(sizeof(struct flexgen), GFP_KERNEL);
+	if (!fgxbar)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &flexgen_ops;
+	init.flags = CLK_IS_BASIC | flexgen_flags;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+
+	xbar_reg = reg + 0x18 + (idx & ~0x3);
+	xbar_shift = (idx % 4) * 0x8;
+	fdiv_reg = reg + 0x164 + idx * 4;
+
+	/* Crossbar element config */
+	fgxbar->mux.lock = lock;
+	fgxbar->mux.mask = BIT(6) - 1;
+	fgxbar->mux.reg = xbar_reg;
+	fgxbar->mux.shift = xbar_shift;
+	fgxbar->mux.table = NULL;
+
+
+	/* Pre-divider's gate config (in xbar register)*/
+	fgxbar->pgate.lock = lock;
+	fgxbar->pgate.reg = xbar_reg;
+	fgxbar->pgate.bit_idx = xbar_shift + 6;
+
+	/* Pre-divider config */
+	fgxbar->pdiv.lock = lock;
+	fgxbar->pdiv.reg = reg + 0x58 + idx * 4;
+	fgxbar->pdiv.width = 10;
+
+	/* Final divider's gate config */
+	fgxbar->fgate.lock = lock;
+	fgxbar->fgate.reg = fdiv_reg;
+	fgxbar->fgate.bit_idx = 6;
+
+	/* Final divider config */
+	fgxbar->fdiv.lock = lock;
+	fgxbar->fdiv.reg = fdiv_reg;
+	fgxbar->fdiv.width = 6;
+
+	fgxbar->hw.init = &init;
+
+	clk = clk_register(NULL, &fgxbar->hw);
+	if (IS_ERR(clk))
+		kfree(fgxbar);
+	else
+		pr_debug("%s: parent %s rate %u\n",
+			__clk_get_name(clk),
+			__clk_get_name(clk_get_parent(clk)),
+			(unsigned int)clk_get_rate(clk));
+	return clk;
+}
+
+static const char ** __init flexgen_get_parents(struct device_node *np,
+						       int *num_parents)
+{
+	const char **parents;
+	int nparents, i;
+
+	nparents = of_count_phandle_with_args(np, "clocks", "#clock-cells");
+	if (WARN_ON(nparents <= 0))
+		return NULL;
+
+	parents = kcalloc(nparents, sizeof(const char *), GFP_KERNEL);
+	if (!parents)
+		return NULL;
+
+	for (i = 0; i < nparents; i++)
+		parents[i] = of_clk_get_parent_name(np, i);
+
+	*num_parents = nparents;
+	return parents;
+}
+
+void __init st_of_flexgen_setup(struct device_node *np)
+{
+	struct device_node *pnode;
+	void __iomem *reg;
+	struct clk_onecell_data *clk_data;
+	const char **parents;
+	int num_parents, i;
+	spinlock_t *rlock = NULL;
+	unsigned long flex_flags = 0;
+
+	pnode = of_get_parent(np);
+	if (!pnode)
+		return;
+
+	reg = of_iomap(pnode, 0);
+	if (!reg)
+		return;
+
+	parents = flexgen_get_parents(np, &num_parents);
+	if (!parents)
+		return;
+
+	clk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		goto err;
+
+	clk_data->clk_num = of_property_count_strings(np ,
+			"clock-output-names");
+	if (clk_data->clk_num <= 0) {
+		pr_err("%s: Failed to get number of output clocks (%d)",
+				__func__, clk_data->clk_num);
+		goto err;
+	}
+
+	clk_data->clks = kcalloc(clk_data->clk_num, sizeof(struct clk *),
+			GFP_KERNEL);
+	if (!clk_data->clks)
+		goto err;
+
+	rlock = kzalloc(sizeof(spinlock_t), GFP_KERNEL);
+	if (!rlock)
+		goto err;
+
+	for (i = 0; i < clk_data->clk_num; i++) {
+		struct clk *clk;
+		const char *clk_name;
+
+		if (of_property_read_string_index(np, "clock-output-names",
+						  i, &clk_name)) {
+			break;
+		}
+
+		/*
+		 * If we read an empty clock name then the output is unused
+		 */
+		if (*clk_name == '\0')
+			continue;
+
+		clk = clk_register_flexgen(clk_name, parents, num_parents,
+					   reg, rlock, i, flex_flags);
+
+		if (IS_ERR(clk))
+			goto err;
+
+		clk_data->clks[i] = clk;
+	}
+
+	kfree(parents);
+	of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	return;
+
+err:
+	if (clk_data)
+		kfree(clk_data->clks);
+	kfree(clk_data);
+	kfree(parents);
+	kfree(rlock);
+}
+CLK_OF_DECLARE(flexgen, "st,flexgen", st_of_flexgen_setup);
