commit 1af897dff60aff3f421f12c5b9a3ebadc9e2d8a3
Author: Quentin Schulz <quentin.schulz@bootlin.com>
Date:   Fri Apr 6 09:50:45 2018 +0200

    clk: spear: fix WDT clock definition on SPEAr600
    
    There is no SPEAr600 device named "wdt". Instead, the description of the
    WDT (watchdog) was recently added to the Device Tree, and the device
    name is "fc880000.wdt", so we should associate the WDT fixed rate clock
    to this device name.
    
    Signed-off-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index f911d9f77763..47810be7f15c 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -147,7 +147,7 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 
 	clk = clk_register_fixed_factor(NULL, "wdt_clk", "osc_30m_clk", 0, 1,
 			1);
-	clk_register_clkdev(clk, NULL, "wdt");
+	clk_register_clkdev(clk, NULL, "fc880000.wdt");
 
 	/* clock derived from pll1 clk */
 	clk = clk_register_fixed_factor(NULL, "cpu_clk", "pll1_clk",

commit 1b21401307a6a705688faf1bc9e6e02663708ec1
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 17 14:46:45 2017 +0200

    clk: spear: fix ADC clock definition on SPEAr600
    
    There is no SPEAr600 device named "adc". Instead, the description of the
    ADC was recently added to the Device Tree, and the device name is
    "d820b000.adc", so we should associate the ADC gatable clock to this
    device name.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index 7c9383c3c2c6..f911d9f77763 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -313,7 +313,7 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	/* clock derived from apb clk */
 	clk = clk_register_gate(NULL, "adc_clk", "apb_clk", 0, PERIP1_CLK_ENB,
 			ADC_CLK_ENB, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "adc");
+	clk_register_clkdev(clk, NULL, "d820b000.adc");
 
 	clk = clk_register_fixed_factor(NULL, "gpio0_clk", "apb_clk", 0, 1, 1);
 	clk_register_clkdev(clk, NULL, "f0100000.gpio");

commit afb4bdc9d8987eb570ef0e9e608459d9fc016de5
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Mar 1 11:00:00 2016 -0800

    clk: spear: Remove CLK_IS_ROOT
    
    This flag is a no-op now. Remove usage of the flag.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index e24f85cd4300..7c9383c3c2c6 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -117,12 +117,10 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 {
 	struct clk *clk, *clk1;
 
-	clk = clk_register_fixed_rate(NULL, "osc_32k_clk", NULL, CLK_IS_ROOT,
-			32000);
+	clk = clk_register_fixed_rate(NULL, "osc_32k_clk", NULL, 0, 32000);
 	clk_register_clkdev(clk, "osc_32k_clk", NULL);
 
-	clk = clk_register_fixed_rate(NULL, "osc_30m_clk", NULL, CLK_IS_ROOT,
-			30000000);
+	clk = clk_register_fixed_rate(NULL, "osc_30m_clk", NULL, 0, 30000000);
 	clk_register_clkdev(clk, "osc_30m_clk", NULL);
 
 	/* clock derived from 32 KHz osc clk */

commit f36fc04e4cdda9e4c72ee504e7dc638f9a168863
Merge: 26f8b7edc9ea ba3001157733
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 31 17:26:48 2015 -0700

    Merge tag 'clk-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Michael Turquette:
     "The clk framework changes for 4.3 are mostly updates to existing
      drivers and the addition of new clock drivers.  Stephen Boyd has also
      done a lot of subsystem-wide driver clean-ups (thanks!).  There are
      also fixes to the framework core and changes to better split clock
      provider drivers from clock consumer drivers"
    
    * tag 'clk-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (227 commits)
      clk: s5pv210: add missing call to samsung_clk_of_add_provider()
      clk: pistachio: correct critical clock list
      clk: pistachio: Fix PLL rate calculation in integer mode
      clk: pistachio: Fix override of clk-pll settings from boot loader
      clk: pistachio: Fix 32bit integer overflows
      clk: tegra: Fix some static checker problems
      clk: qcom: Fix MSM8916 prng clock enable bit
      clk: Add missing header for 'bool' definition to clk-conf.h
      drivers/clk: appropriate __init annotation for const data
      clk: rockchip: register pll mux before pll itself
      clk: add bindings for the Ux500 clocks
      clk/ARM: move Ux500 PRCC bases to the device tree
      clk: remove duplicated code with __clk_set_parent_after
      clk: Convert __clk_get_name(hw->clk) to clk_hw_get_name(hw)
      clk: Constify clk_hw argument to provider APIs
      clk: Hi6220: add stub clock driver
      dt-bindings: clk: Hi6220: Document stub clock driver
      dt-bindings: arm: Hi6220: add doc for SRAM controller
      clk: atlas7: fix pll missed divide NR in fraction mode
      clk: atlas7: fix bit field and its root clk for coresight_tpiu
      ...

commit c302e1e28078fbb31e179c48d9a990fb0e9334e4
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    clk: spear: Remove clk.h include
    
    Clock provider drivers generally shouldn't include clk.h because
    it's the consumer API. Remove the include here because this is a
    provider driver.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index 4f649c9cb094..46a4dafe46a7 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -9,7 +9,6 @@
  * warranty of any kind, whether express or implied.
  */
 
-#include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/io.h>
 #include <linux/spinlock_types.h>

commit da89947b47a3a355f33a75d7672892c147ed880d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 17 16:23:50 2015 -0700

    Update Viresh Kumar's email address
    
    Switch to my kernel.org alias instead of a badly named gmail address,
    which I rarely use.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index 4f649c9cb094..231061fa73a4 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -2,7 +2,7 @@
  * SPEAr6xx machines clock framework source file
  *
  * Copyright (C) 2012 ST Microelectronics
- * Viresh Kumar <viresh.linux@gmail.com>
+ * Viresh Kumar <vireshk@kernel.org>
  *
  * This file is licensed under the terms of the GNU General Public
  * License version 2. This program is licensed "as is" without any

commit 819c1de344c5b8350bffd35be9a0fa74541292d3
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Jul 29 12:25:01 2013 +0100

    clk: add CLK_SET_RATE_NO_REPARENT flag
    
    Add a CLK_SET_RATE_NO_REPARENT clock flag, which will prevent muxes
    being reparented during clk_set_rate.
    
    To avoid breaking existing platforms, all callers of clk_register_mux()
    are adjusted to pass the new flag. Platform maintainers are encouraged
    to remove the flag if they wish to allow mux reparenting on set_rate.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Haojian Zhuang <haojian.zhuang@linaro.org>
    Cc: Chao Xie <xiechao.mail@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: "Emilio López" <emilio@elopez.com.ar>
    Cc: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Prashant Gaikwad <pgaikwad@nvidia.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Peter De Schrijver <pdeschrijver@nvidia.com>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Andrew Chew <achew@nvidia.com>
    Cc: Doug Anderson <dianders@chromium.org>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Paul Walmsley <pwalmsley@nvidia.com>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Thomas Abraham <thomas.abraham@linaro.org>
    Cc: Tomasz Figa <t.figa@samsung.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: spear-devel@list.st.com
    Cc: linux-tegra@vger.kernel.org
    Tested-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: Stephen Warren <swarren@nvidia.com> [tegra]
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> [sunxi]
    Acked-by: Sören Brinkmann <soren.brinkmann@xilinx.com> [Zynq]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index 9406f2426d64..4f649c9cb094 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -169,8 +169,9 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	clk_register_clkdev(clk1, "uart_syn_gclk", NULL);
 
 	clk = clk_register_mux(NULL, "uart_mclk", uart_parents,
-			ARRAY_SIZE(uart_parents), 0, PERIP_CLK_CFG,
-			UART_CLK_SHIFT, UART_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(uart_parents), CLK_SET_RATE_NO_REPARENT,
+			PERIP_CLK_CFG, UART_CLK_SHIFT, UART_CLK_MASK, 0,
+			&_lock);
 	clk_register_clkdev(clk, "uart_mclk", NULL);
 
 	clk = clk_register_gate(NULL, "uart0", "uart_mclk", 0, PERIP1_CLK_ENB,
@@ -188,8 +189,9 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	clk_register_clkdev(clk1, "firda_syn_gclk", NULL);
 
 	clk = clk_register_mux(NULL, "firda_mclk", firda_parents,
-			ARRAY_SIZE(firda_parents), 0, PERIP_CLK_CFG,
-			FIRDA_CLK_SHIFT, FIRDA_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(firda_parents), CLK_SET_RATE_NO_REPARENT,
+			PERIP_CLK_CFG, FIRDA_CLK_SHIFT, FIRDA_CLK_MASK, 0,
+			&_lock);
 	clk_register_clkdev(clk, "firda_mclk", NULL);
 
 	clk = clk_register_gate(NULL, "firda_clk", "firda_mclk", 0,
@@ -203,8 +205,9 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	clk_register_clkdev(clk1, "clcd_syn_gclk", NULL);
 
 	clk = clk_register_mux(NULL, "clcd_mclk", clcd_parents,
-			ARRAY_SIZE(clcd_parents), 0, PERIP_CLK_CFG,
-			CLCD_CLK_SHIFT, CLCD_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(clcd_parents), CLK_SET_RATE_NO_REPARENT,
+			PERIP_CLK_CFG, CLCD_CLK_SHIFT, CLCD_CLK_MASK, 0,
+			&_lock);
 	clk_register_clkdev(clk, "clcd_mclk", NULL);
 
 	clk = clk_register_gate(NULL, "clcd_clk", "clcd_mclk", 0,
@@ -217,13 +220,13 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	clk_register_clkdev(clk, "gpt0_1_syn_clk", NULL);
 
 	clk = clk_register_mux(NULL, "gpt0_mclk", gpt0_1_parents,
-			ARRAY_SIZE(gpt0_1_parents), 0, PERIP_CLK_CFG,
-			GPT0_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(gpt0_1_parents), CLK_SET_RATE_NO_REPARENT,
+			PERIP_CLK_CFG, GPT0_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "gpt0");
 
 	clk = clk_register_mux(NULL, "gpt1_mclk", gpt0_1_parents,
-			ARRAY_SIZE(gpt0_1_parents), 0, PERIP_CLK_CFG,
-			GPT1_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(gpt0_1_parents), CLK_SET_RATE_NO_REPARENT,
+			PERIP_CLK_CFG, GPT1_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
 	clk_register_clkdev(clk, "gpt1_mclk", NULL);
 
 	clk = clk_register_gate(NULL, "gpt1_clk", "gpt1_mclk", 0,
@@ -235,8 +238,8 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	clk_register_clkdev(clk, "gpt2_syn_clk", NULL);
 
 	clk = clk_register_mux(NULL, "gpt2_mclk", gpt2_parents,
-			ARRAY_SIZE(gpt2_parents), 0, PERIP_CLK_CFG,
-			GPT2_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(gpt2_parents), CLK_SET_RATE_NO_REPARENT,
+			PERIP_CLK_CFG, GPT2_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
 	clk_register_clkdev(clk, "gpt2_mclk", NULL);
 
 	clk = clk_register_gate(NULL, "gpt2_clk", "gpt2_mclk", 0,
@@ -248,8 +251,8 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	clk_register_clkdev(clk, "gpt3_syn_clk", NULL);
 
 	clk = clk_register_mux(NULL, "gpt3_mclk", gpt3_parents,
-			ARRAY_SIZE(gpt3_parents), 0, PERIP_CLK_CFG,
-			GPT3_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(gpt3_parents), CLK_SET_RATE_NO_REPARENT,
+			PERIP_CLK_CFG, GPT3_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
 	clk_register_clkdev(clk, "gpt3_mclk", NULL);
 
 	clk = clk_register_gate(NULL, "gpt3_clk", "gpt3_mclk", 0,
@@ -277,8 +280,8 @@ void __init spear6xx_clk_init(void __iomem *misc_base)
 	clk_register_clkdev(clk, "ahbmult2_clk", NULL);
 
 	clk = clk_register_mux(NULL, "ddr_clk", ddr_parents,
-			ARRAY_SIZE(ddr_parents), 0, PLL_CLK_CFG, MCTR_CLK_SHIFT,
-			MCTR_CLK_MASK, 0, &_lock);
+			ARRAY_SIZE(ddr_parents), CLK_SET_RATE_NO_REPARENT,
+			PLL_CLK_CFG, MCTR_CLK_SHIFT, MCTR_CLK_MASK, 0, &_lock);
 	clk_register_clkdev(clk, "ddr_clk", NULL);
 
 	clk = clk_register_divider(NULL, "apb_clk", "ahb_clk",

commit d9909ebe650f028459b9be5a2321fee520b446b0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Dec 2 17:59:57 2012 +0100

    ARM: spear: make clock driver independent of headers
    
    Device drivers should not access MMIO registers through hardcoded
    platform specific address constants. Instead, we can pass the
    MMIO token to the spear clock driver in the initialization routine
    to contain that knowledge in the platform code itself.
    
    Ideally, the clock driver would use of_iomap() or similar to
    get the address, and that can be used later, but for now, this
    is the minimal change.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index e862a333ad30..9406f2426d64 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -13,28 +13,27 @@
 #include <linux/clkdev.h>
 #include <linux/io.h>
 #include <linux/spinlock_types.h>
-#include <mach/misc_regs.h>
 #include "clk.h"
 
 static DEFINE_SPINLOCK(_lock);
 
-#define PLL1_CTR			(MISC_BASE + 0x008)
-#define PLL1_FRQ			(MISC_BASE + 0x00C)
-#define PLL2_CTR			(MISC_BASE + 0x014)
-#define PLL2_FRQ			(MISC_BASE + 0x018)
-#define PLL_CLK_CFG			(MISC_BASE + 0x020)
+#define PLL1_CTR			(misc_base + 0x008)
+#define PLL1_FRQ			(misc_base + 0x00C)
+#define PLL2_CTR			(misc_base + 0x014)
+#define PLL2_FRQ			(misc_base + 0x018)
+#define PLL_CLK_CFG			(misc_base + 0x020)
 	/* PLL_CLK_CFG register masks */
 	#define MCTR_CLK_SHIFT		28
 	#define MCTR_CLK_MASK		3
 
-#define CORE_CLK_CFG			(MISC_BASE + 0x024)
+#define CORE_CLK_CFG			(misc_base + 0x024)
 	/* CORE CLK CFG register masks */
 	#define HCLK_RATIO_SHIFT	10
 	#define HCLK_RATIO_MASK		2
 	#define PCLK_RATIO_SHIFT	8
 	#define PCLK_RATIO_MASK		2
 
-#define PERIP_CLK_CFG			(MISC_BASE + 0x028)
+#define PERIP_CLK_CFG			(misc_base + 0x028)
 	/* PERIP_CLK_CFG register masks */
 	#define CLCD_CLK_SHIFT		2
 	#define CLCD_CLK_MASK		2
@@ -48,7 +47,7 @@ static DEFINE_SPINLOCK(_lock);
 	#define GPT3_CLK_SHIFT		12
 	#define GPT_CLK_MASK		1
 
-#define PERIP1_CLK_ENB			(MISC_BASE + 0x02C)
+#define PERIP1_CLK_ENB			(misc_base + 0x02C)
 	/* PERIP1_CLK_ENB register masks */
 	#define UART0_CLK_ENB		3
 	#define UART1_CLK_ENB		4
@@ -74,13 +73,13 @@ static DEFINE_SPINLOCK(_lock);
 	#define USBH0_CLK_ENB		25
 	#define USBH1_CLK_ENB		26
 
-#define PRSC0_CLK_CFG			(MISC_BASE + 0x044)
-#define PRSC1_CLK_CFG			(MISC_BASE + 0x048)
-#define PRSC2_CLK_CFG			(MISC_BASE + 0x04C)
+#define PRSC0_CLK_CFG			(misc_base + 0x044)
+#define PRSC1_CLK_CFG			(misc_base + 0x048)
+#define PRSC2_CLK_CFG			(misc_base + 0x04C)
 
-#define CLCD_CLK_SYNT			(MISC_BASE + 0x05C)
-#define FIRDA_CLK_SYNT			(MISC_BASE + 0x060)
-#define UART_CLK_SYNT			(MISC_BASE + 0x064)
+#define CLCD_CLK_SYNT			(misc_base + 0x05C)
+#define FIRDA_CLK_SYNT			(misc_base + 0x060)
+#define UART_CLK_SYNT			(misc_base + 0x064)
 
 /* vco rate configuration table, in ascending order of rates */
 static struct pll_rate_tbl pll_rtbl[] = {
@@ -115,7 +114,7 @@ static struct gpt_rate_tbl gpt_rtbl[] = {
 	{.mscale = 1, .nscale = 0}, /* 83 MHz */
 };
 
-void __init spear6xx_clk_init(void)
+void __init spear6xx_clk_init(void __iomem *misc_base)
 {
 	struct clk *clk, *clk1;
 

commit b70e6d009a88e09805152597e02f3d97a1d6ee99
Author: Vipul Kumar Samar <vipulkumar.samar@st.com>
Date:   Sat Nov 10 12:13:47 2012 +0530

    CLK: SPEAr: Remove unused dummy apb_pclk
    
    Dummy clocks were added for ARM platforms, so that clk_get() for interface clk
    doesn't fail for amba devices from amba_probe(). Because there is no amba device
    for SPEAr that doesn't have a valid clock with dev_id for SPEAr, we don't need
    these dummy clocks. Hence, remove them.
    
    Signed-off-by: Vipul Kumar Samar <vipulkumar.samar@st.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index 8a81770be4c5..e862a333ad30 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -119,9 +119,6 @@ void __init spear6xx_clk_init(void)
 {
 	struct clk *clk, *clk1;
 
-	clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, CLK_IS_ROOT, 0);
-	clk_register_clkdev(clk, "apb_pclk", NULL);
-
 	clk = clk_register_fixed_rate(NULL, "osc_32k_clk", NULL, CLK_IS_ROOT,
 			32000);
 	clk_register_clkdev(clk, "osc_32k_clk", NULL);

commit ef0fd0a207c00b09449f33724322ba762d822d97
Author: Deepak Sikri <deepak.sikri@st.com>
Date:   Sat Nov 10 12:13:45 2012 +0530

    CLK: SPEAr: Update clock rate table
    
    This patch updates the existing rate tables with new frequencies.
    
    Signed-off-by: Deepak Sikri <deepak.sikri@st.com>
    Signed-off-by: Vipul Kumar Samar <vipulkumar.samar@st.com>
    Signed-off-by: Rajeev Kumar <rajeev-dlh.kumar@st.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index e8d2b3109b34..8a81770be4c5 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -92,6 +92,7 @@ static struct pll_rate_tbl pll_rtbl[] = {
 /* aux rate configuration table, in ascending order of rates */
 static struct aux_rate_tbl aux_rtbl[] = {
 	/* For PLL1 = 332 MHz */
+	{.xscale = 2, .yscale = 27, .eq = 0}, /* 12.296 MHz */
 	{.xscale = 2, .yscale = 8, .eq = 0}, /* 41.5 MHz */
 	{.xscale = 2, .yscale = 4, .eq = 0}, /* 83 MHz */
 	{.xscale = 1, .yscale = 2, .eq = 1}, /* 166 MHz */

commit 1249979242db10d2fe1793f26e7658d94b7bf6dc
Author: Vipul Kumar Samar <vipulkumar.samar@st.com>
Date:   Sat Nov 10 12:13:43 2012 +0530

    CLK: SPEAr: Set CLK_SET_RATE_PARENT for few clocks
    
    Flag CLK_SET_RATE_PARENT is required for a clock, where we want to
    propagate clk_set_rate to its parent. This patch adds this to multiple clocks.
    
    Signed-off-by: Vipul Kumar Samar <vipulkumar.samar@st.com>
    Signed-off-by: Shiraz Hashim <shiraz.hashim@st.com>
    Signed-off-by: Rajeev Kumar <rajeev-dlh.kumar@st.com>
    Signed-off-by: Vijay Kumar Mishra <vijay.kumar@st.com>
    Signed-off-by: Vijay Kumar Mishra <vijay.kumar@st.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index c7fa67c7c0ab..e8d2b3109b34 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -156,7 +156,8 @@ void __init spear6xx_clk_init(void)
 	clk_register_clkdev(clk, NULL, "wdt");
 
 	/* clock derived from pll1 clk */
-	clk = clk_register_fixed_factor(NULL, "cpu_clk", "pll1_clk", 0, 1, 1);
+	clk = clk_register_fixed_factor(NULL, "cpu_clk", "pll1_clk",
+			CLK_SET_RATE_PARENT, 1, 1);
 	clk_register_clkdev(clk, "cpu_clk", NULL);
 
 	clk = clk_register_divider(NULL, "ahb_clk", "pll1_clk",

commit df2449aba4749fb8d04c3c1bbfad5cf8863c323b
Author: Rajeev Kumar <rajeev-dlh.kumar@st.com>
Date:   Sat Nov 10 12:13:40 2012 +0530

    CLK: SPEAr: Fix dev_id & con_id for multiple clocks
    
    dev_id & con_id names of multiple clocks are incorrect. This patch fixes these
    names with the names that come via DT.
    
    Signed-off-by: Rajeev Kumar <rajeev-dlh.kumar@st.com>
    Signed-off-by: Shiraz Hashim <shiraz.hashim@st.com>
    Signed-off-by: Bhavna Yadav <bhavna.yadav@st.com>
    Signed-off-by: Vipul Kumar Samar <vipulkumar.samar@st.com>
    Signed-off-by: Deepak Sikri <deepak.sikri@st.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index a98d0866f541..c7fa67c7c0ab 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -261,11 +261,13 @@ void __init spear6xx_clk_init(void)
 	/* clock derived from pll3 clk */
 	clk = clk_register_gate(NULL, "usbh0_clk", "pll3_clk", 0,
 			PERIP1_CLK_ENB, USBH0_CLK_ENB, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "usbh.0_clk");
+	clk_register_clkdev(clk, NULL, "e1800000.ehci");
+	clk_register_clkdev(clk, NULL, "e1900000.ohci");
 
 	clk = clk_register_gate(NULL, "usbh1_clk", "pll3_clk", 0,
 			PERIP1_CLK_ENB, USBH1_CLK_ENB, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "usbh.1_clk");
+	clk_register_clkdev(clk, NULL, "e2000000.ehci");
+	clk_register_clkdev(clk, NULL, "e2100000.ohci");
 
 	clk = clk_register_gate(NULL, "usbd_clk", "pll3_clk", 0, PERIP1_CLK_ENB,
 			USBD_CLK_ENB, 0, &_lock);

commit a8f4bf0eb4ca7a0a578079fb5807e59b7111a1e2
Author: Vipul Kumar Samar <vipulkumar.samar@st.com>
Date:   Tue Jul 10 17:12:46 2012 +0530

    Clk:spear6xx:Fix: Rename clk ids within predefined limit
    
    The max limit of con_id is 16 and dev_id is 20. As of now for spear6xx, many clk
    ids are exceeding this predefined limit.
    
    This patch is intended to rename clk ids like:
        mux_clk -> _mclk
        gate_clk -> _gclk
        synth_clk -> syn_clk
        ras_gen1_synth_gate_clk -> ras_syn1_gclk
        pll3_48m -> pll3_
    
    Signed-off-by: Vipul Kumar Samar <vipulkumar.samar@st.com>
    Signed-off-by: Shiraz Hashim <shiraz.hashim@st.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index 61026ae564ab..a98d0866f541 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -97,13 +97,12 @@ static struct aux_rate_tbl aux_rtbl[] = {
 	{.xscale = 1, .yscale = 2, .eq = 1}, /* 166 MHz */
 };
 
-static const char *clcd_parents[] = { "pll3_48m_clk", "clcd_synth_gate_clk", };
-static const char *firda_parents[] = { "pll3_48m_clk", "firda_synth_gate_clk",
-};
-static const char *uart_parents[] = { "pll3_48m_clk", "uart_synth_gate_clk", };
-static const char *gpt0_1_parents[] = { "pll3_48m_clk", "gpt0_1_synth_clk", };
-static const char *gpt2_parents[] = { "pll3_48m_clk", "gpt2_synth_clk", };
-static const char *gpt3_parents[] = { "pll3_48m_clk", "gpt3_synth_clk", };
+static const char *clcd_parents[] = { "pll3_clk", "clcd_syn_gclk", };
+static const char *firda_parents[] = { "pll3_clk", "firda_syn_gclk", };
+static const char *uart_parents[] = { "pll3_clk", "uart_syn_gclk", };
+static const char *gpt0_1_parents[] = { "pll3_clk", "gpt0_1_syn_clk", };
+static const char *gpt2_parents[] = { "pll3_clk", "gpt2_syn_clk", };
+static const char *gpt3_parents[] = { "pll3_clk", "gpt3_syn_clk", };
 static const char *ddr_parents[] = { "ahb_clk", "ahbmult2_clk", "none",
 	"pll2_clk", };
 
@@ -136,9 +135,9 @@ void __init spear6xx_clk_init(void)
 	clk_register_clkdev(clk, NULL, "rtc-spear");
 
 	/* clock derived from 30 MHz osc clk */
-	clk = clk_register_fixed_rate(NULL, "pll3_48m_clk", "osc_24m_clk", 0,
+	clk = clk_register_fixed_rate(NULL, "pll3_clk", "osc_24m_clk", 0,
 			48000000);
-	clk_register_clkdev(clk, "pll3_48m_clk", NULL);
+	clk_register_clkdev(clk, "pll3_clk", NULL);
 
 	clk = clk_register_vco_pll("vco1_clk", "pll1_clk", NULL, "osc_30m_clk",
 			0, PLL1_CTR, PLL1_FRQ, pll_rtbl, ARRAY_SIZE(pll_rtbl),
@@ -146,9 +145,9 @@ void __init spear6xx_clk_init(void)
 	clk_register_clkdev(clk, "vco1_clk", NULL);
 	clk_register_clkdev(clk1, "pll1_clk", NULL);
 
-	clk = clk_register_vco_pll("vco2_clk", "pll2_clk", NULL,
-			"osc_30m_clk", 0, PLL2_CTR, PLL2_FRQ, pll_rtbl,
-			ARRAY_SIZE(pll_rtbl), &_lock, &clk1, NULL);
+	clk = clk_register_vco_pll("vco2_clk", "pll2_clk", NULL, "osc_30m_clk",
+			0, PLL2_CTR, PLL2_FRQ, pll_rtbl, ARRAY_SIZE(pll_rtbl),
+			&_lock, &clk1, NULL);
 	clk_register_clkdev(clk, "vco2_clk", NULL);
 	clk_register_clkdev(clk1, "pll2_clk", NULL);
 
@@ -165,111 +164,111 @@ void __init spear6xx_clk_init(void)
 			HCLK_RATIO_MASK, 0, &_lock);
 	clk_register_clkdev(clk, "ahb_clk", NULL);
 
-	clk = clk_register_aux("uart_synth_clk", "uart_synth_gate_clk",
-			"pll1_clk", 0, UART_CLK_SYNT, NULL, aux_rtbl,
-			ARRAY_SIZE(aux_rtbl), &_lock, &clk1);
-	clk_register_clkdev(clk, "uart_synth_clk", NULL);
-	clk_register_clkdev(clk1, "uart_synth_gate_clk", NULL);
+	clk = clk_register_aux("uart_syn_clk", "uart_syn_gclk", "pll1_clk", 0,
+			UART_CLK_SYNT, NULL, aux_rtbl, ARRAY_SIZE(aux_rtbl),
+			&_lock, &clk1);
+	clk_register_clkdev(clk, "uart_syn_clk", NULL);
+	clk_register_clkdev(clk1, "uart_syn_gclk", NULL);
 
-	clk = clk_register_mux(NULL, "uart_mux_clk", uart_parents,
+	clk = clk_register_mux(NULL, "uart_mclk", uart_parents,
 			ARRAY_SIZE(uart_parents), 0, PERIP_CLK_CFG,
 			UART_CLK_SHIFT, UART_CLK_MASK, 0, &_lock);
-	clk_register_clkdev(clk, "uart_mux_clk", NULL);
+	clk_register_clkdev(clk, "uart_mclk", NULL);
 
-	clk = clk_register_gate(NULL, "uart0", "uart_mux_clk", 0,
-			PERIP1_CLK_ENB, UART0_CLK_ENB, 0, &_lock);
+	clk = clk_register_gate(NULL, "uart0", "uart_mclk", 0, PERIP1_CLK_ENB,
+			UART0_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "d0000000.serial");
 
-	clk = clk_register_gate(NULL, "uart1", "uart_mux_clk", 0,
-			PERIP1_CLK_ENB, UART1_CLK_ENB, 0, &_lock);
+	clk = clk_register_gate(NULL, "uart1", "uart_mclk", 0, PERIP1_CLK_ENB,
+			UART1_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "d0080000.serial");
 
-	clk = clk_register_aux("firda_synth_clk", "firda_synth_gate_clk",
-			"pll1_clk", 0, FIRDA_CLK_SYNT, NULL, aux_rtbl,
-			ARRAY_SIZE(aux_rtbl), &_lock, &clk1);
-	clk_register_clkdev(clk, "firda_synth_clk", NULL);
-	clk_register_clkdev(clk1, "firda_synth_gate_clk", NULL);
+	clk = clk_register_aux("firda_syn_clk", "firda_syn_gclk", "pll1_clk",
+			0, FIRDA_CLK_SYNT, NULL, aux_rtbl, ARRAY_SIZE(aux_rtbl),
+			&_lock, &clk1);
+	clk_register_clkdev(clk, "firda_syn_clk", NULL);
+	clk_register_clkdev(clk1, "firda_syn_gclk", NULL);
 
-	clk = clk_register_mux(NULL, "firda_mux_clk", firda_parents,
+	clk = clk_register_mux(NULL, "firda_mclk", firda_parents,
 			ARRAY_SIZE(firda_parents), 0, PERIP_CLK_CFG,
 			FIRDA_CLK_SHIFT, FIRDA_CLK_MASK, 0, &_lock);
-	clk_register_clkdev(clk, "firda_mux_clk", NULL);
+	clk_register_clkdev(clk, "firda_mclk", NULL);
 
-	clk = clk_register_gate(NULL, "firda_clk", "firda_mux_clk", 0,
+	clk = clk_register_gate(NULL, "firda_clk", "firda_mclk", 0,
 			PERIP1_CLK_ENB, FIRDA_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "firda");
 
-	clk = clk_register_aux("clcd_synth_clk", "clcd_synth_gate_clk",
-			"pll1_clk", 0, CLCD_CLK_SYNT, NULL, aux_rtbl,
-			ARRAY_SIZE(aux_rtbl), &_lock, &clk1);
-	clk_register_clkdev(clk, "clcd_synth_clk", NULL);
-	clk_register_clkdev(clk1, "clcd_synth_gate_clk", NULL);
+	clk = clk_register_aux("clcd_syn_clk", "clcd_syn_gclk", "pll1_clk",
+			0, CLCD_CLK_SYNT, NULL, aux_rtbl, ARRAY_SIZE(aux_rtbl),
+			&_lock, &clk1);
+	clk_register_clkdev(clk, "clcd_syn_clk", NULL);
+	clk_register_clkdev(clk1, "clcd_syn_gclk", NULL);
 
-	clk = clk_register_mux(NULL, "clcd_mux_clk", clcd_parents,
+	clk = clk_register_mux(NULL, "clcd_mclk", clcd_parents,
 			ARRAY_SIZE(clcd_parents), 0, PERIP_CLK_CFG,
 			CLCD_CLK_SHIFT, CLCD_CLK_MASK, 0, &_lock);
-	clk_register_clkdev(clk, "clcd_mux_clk", NULL);
+	clk_register_clkdev(clk, "clcd_mclk", NULL);
 
-	clk = clk_register_gate(NULL, "clcd_clk", "clcd_mux_clk", 0,
+	clk = clk_register_gate(NULL, "clcd_clk", "clcd_mclk", 0,
 			PERIP1_CLK_ENB, CLCD_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "clcd");
 
 	/* gpt clocks */
-	clk = clk_register_gpt("gpt0_1_synth_clk", "pll1_clk", 0, PRSC0_CLK_CFG,
+	clk = clk_register_gpt("gpt0_1_syn_clk", "pll1_clk", 0, PRSC0_CLK_CFG,
 			gpt_rtbl, ARRAY_SIZE(gpt_rtbl), &_lock);
-	clk_register_clkdev(clk, "gpt0_1_synth_clk", NULL);
+	clk_register_clkdev(clk, "gpt0_1_syn_clk", NULL);
 
-	clk = clk_register_mux(NULL, "gpt0_mux_clk", gpt0_1_parents,
+	clk = clk_register_mux(NULL, "gpt0_mclk", gpt0_1_parents,
 			ARRAY_SIZE(gpt0_1_parents), 0, PERIP_CLK_CFG,
 			GPT0_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "gpt0");
 
-	clk = clk_register_mux(NULL, "gpt1_mux_clk", gpt0_1_parents,
+	clk = clk_register_mux(NULL, "gpt1_mclk", gpt0_1_parents,
 			ARRAY_SIZE(gpt0_1_parents), 0, PERIP_CLK_CFG,
 			GPT1_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
-	clk_register_clkdev(clk, "gpt1_mux_clk", NULL);
+	clk_register_clkdev(clk, "gpt1_mclk", NULL);
 
-	clk = clk_register_gate(NULL, "gpt1_clk", "gpt1_mux_clk", 0,
+	clk = clk_register_gate(NULL, "gpt1_clk", "gpt1_mclk", 0,
 			PERIP1_CLK_ENB, GPT1_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "gpt1");
 
-	clk = clk_register_gpt("gpt2_synth_clk", "pll1_clk", 0, PRSC1_CLK_CFG,
+	clk = clk_register_gpt("gpt2_syn_clk", "pll1_clk", 0, PRSC1_CLK_CFG,
 			gpt_rtbl, ARRAY_SIZE(gpt_rtbl), &_lock);
-	clk_register_clkdev(clk, "gpt2_synth_clk", NULL);
+	clk_register_clkdev(clk, "gpt2_syn_clk", NULL);
 
-	clk = clk_register_mux(NULL, "gpt2_mux_clk", gpt2_parents,
+	clk = clk_register_mux(NULL, "gpt2_mclk", gpt2_parents,
 			ARRAY_SIZE(gpt2_parents), 0, PERIP_CLK_CFG,
 			GPT2_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
-	clk_register_clkdev(clk, "gpt2_mux_clk", NULL);
+	clk_register_clkdev(clk, "gpt2_mclk", NULL);
 
-	clk = clk_register_gate(NULL, "gpt2_clk", "gpt2_mux_clk", 0,
+	clk = clk_register_gate(NULL, "gpt2_clk", "gpt2_mclk", 0,
 			PERIP1_CLK_ENB, GPT2_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "gpt2");
 
-	clk = clk_register_gpt("gpt3_synth_clk", "pll1_clk", 0, PRSC2_CLK_CFG,
+	clk = clk_register_gpt("gpt3_syn_clk", "pll1_clk", 0, PRSC2_CLK_CFG,
 			gpt_rtbl, ARRAY_SIZE(gpt_rtbl), &_lock);
-	clk_register_clkdev(clk, "gpt3_synth_clk", NULL);
+	clk_register_clkdev(clk, "gpt3_syn_clk", NULL);
 
-	clk = clk_register_mux(NULL, "gpt3_mux_clk", gpt3_parents,
+	clk = clk_register_mux(NULL, "gpt3_mclk", gpt3_parents,
 			ARRAY_SIZE(gpt3_parents), 0, PERIP_CLK_CFG,
 			GPT3_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
-	clk_register_clkdev(clk, "gpt3_mux_clk", NULL);
+	clk_register_clkdev(clk, "gpt3_mclk", NULL);
 
-	clk = clk_register_gate(NULL, "gpt3_clk", "gpt3_mux_clk", 0,
+	clk = clk_register_gate(NULL, "gpt3_clk", "gpt3_mclk", 0,
 			PERIP1_CLK_ENB, GPT3_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "gpt3");
 
 	/* clock derived from pll3 clk */
-	clk = clk_register_gate(NULL, "usbh0_clk", "pll3_48m_clk", 0,
+	clk = clk_register_gate(NULL, "usbh0_clk", "pll3_clk", 0,
 			PERIP1_CLK_ENB, USBH0_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "usbh.0_clk");
 
-	clk = clk_register_gate(NULL, "usbh1_clk", "pll3_48m_clk", 0,
+	clk = clk_register_gate(NULL, "usbh1_clk", "pll3_clk", 0,
 			PERIP1_CLK_ENB, USBH1_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "usbh.1_clk");
 
-	clk = clk_register_gate(NULL, "usbd_clk", "pll3_48m_clk", 0,
-			PERIP1_CLK_ENB, USBD_CLK_ENB, 0, &_lock);
+	clk = clk_register_gate(NULL, "usbd_clk", "pll3_clk", 0, PERIP1_CLK_ENB,
+			USBD_CLK_ENB, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "designware_udc");
 
 	/* clock derived from ahb clk */
@@ -278,9 +277,8 @@ void __init spear6xx_clk_init(void)
 	clk_register_clkdev(clk, "ahbmult2_clk", NULL);
 
 	clk = clk_register_mux(NULL, "ddr_clk", ddr_parents,
-			ARRAY_SIZE(ddr_parents),
-			0, PLL_CLK_CFG, MCTR_CLK_SHIFT, MCTR_CLK_MASK, 0,
-			&_lock);
+			ARRAY_SIZE(ddr_parents), 0, PLL_CLK_CFG, MCTR_CLK_SHIFT,
+			MCTR_CLK_MASK, 0, &_lock);
 	clk_register_clkdev(clk, "ddr_clk", NULL);
 
 	clk = clk_register_divider(NULL, "apb_clk", "ahb_clk",

commit 3a35fc3a13333e7c137de82d8bf12bbc18639633
Author: Stefan Roese <sr@denx.de>
Date:   Fri May 11 10:41:18 2012 +0200

    clk: SPEAr600: Fix ethernet clock name for DT based probing
    
    Signed-off-by: Stefan Roese <sr@denx.de>
    Cc: Viresh Kumar <viresh.kumar@st.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index 554d64b062a1..61026ae564ab 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -298,7 +298,7 @@ void __init spear6xx_clk_init(void)
 
 	clk = clk_register_gate(NULL, "gmac_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
 			GMAC_CLK_ENB, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "gmac");
+	clk_register_clkdev(clk, NULL, "e0800000.ethernet");
 
 	clk = clk_register_gate(NULL, "i2c_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
 			I2C_CLK_ENB, 0, &_lock);

commit 10d8935f46e5028847b179757ecbf9238b13d129
Author: Viresh Kumar <viresh.linux@gmail.com>
Date:   Wed Jun 20 12:53:02 2012 -0700

    Viresh has moved
    
    viresh.kumar@st.com email-id doesn't exist anymore as I have left the
    company.  Replace ST's id with viresh.linux@gmail.com.
    
    It also updates .mailmap file to fix address for 'git shortlog'
    
    Signed-off-by: Viresh Kumar <viresh.linux@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
index f9a20b382304..554d64b062a1 100644
--- a/drivers/clk/spear/spear6xx_clock.c
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -2,7 +2,7 @@
  * SPEAr6xx machines clock framework source file
  *
  * Copyright (C) 2012 ST Microelectronics
- * Viresh Kumar <viresh.kumar@st.com>
+ * Viresh Kumar <viresh.linux@gmail.com>
  *
  * This file is licensed under the terms of the GNU General Public
  * License version 2. This program is licensed "as is" without any

commit 5df33a62c4a028d6fc7f2dcc159827d09b7334b8
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Tue Apr 10 09:02:35 2012 +0530

    SPEAr: Switch to common clock framework
    
    SPEAr SoCs used its own clock framework since now. From now on they will move to
    use common clock framework.
    
    This patch updates existing SPEAr machine support to adapt for common clock
    framework.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Reviewed-by: Mike Turquette <mturquette@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/clk/spear/spear6xx_clock.c b/drivers/clk/spear/spear6xx_clock.c
new file mode 100644
index 000000000000..f9a20b382304
--- /dev/null
+++ b/drivers/clk/spear/spear6xx_clock.c
@@ -0,0 +1,342 @@
+/*
+ * SPEAr6xx machines clock framework source file
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/io.h>
+#include <linux/spinlock_types.h>
+#include <mach/misc_regs.h>
+#include "clk.h"
+
+static DEFINE_SPINLOCK(_lock);
+
+#define PLL1_CTR			(MISC_BASE + 0x008)
+#define PLL1_FRQ			(MISC_BASE + 0x00C)
+#define PLL2_CTR			(MISC_BASE + 0x014)
+#define PLL2_FRQ			(MISC_BASE + 0x018)
+#define PLL_CLK_CFG			(MISC_BASE + 0x020)
+	/* PLL_CLK_CFG register masks */
+	#define MCTR_CLK_SHIFT		28
+	#define MCTR_CLK_MASK		3
+
+#define CORE_CLK_CFG			(MISC_BASE + 0x024)
+	/* CORE CLK CFG register masks */
+	#define HCLK_RATIO_SHIFT	10
+	#define HCLK_RATIO_MASK		2
+	#define PCLK_RATIO_SHIFT	8
+	#define PCLK_RATIO_MASK		2
+
+#define PERIP_CLK_CFG			(MISC_BASE + 0x028)
+	/* PERIP_CLK_CFG register masks */
+	#define CLCD_CLK_SHIFT		2
+	#define CLCD_CLK_MASK		2
+	#define UART_CLK_SHIFT		4
+	#define UART_CLK_MASK		1
+	#define FIRDA_CLK_SHIFT		5
+	#define FIRDA_CLK_MASK		2
+	#define GPT0_CLK_SHIFT		8
+	#define GPT1_CLK_SHIFT		10
+	#define GPT2_CLK_SHIFT		11
+	#define GPT3_CLK_SHIFT		12
+	#define GPT_CLK_MASK		1
+
+#define PERIP1_CLK_ENB			(MISC_BASE + 0x02C)
+	/* PERIP1_CLK_ENB register masks */
+	#define UART0_CLK_ENB		3
+	#define UART1_CLK_ENB		4
+	#define SSP0_CLK_ENB		5
+	#define SSP1_CLK_ENB		6
+	#define I2C_CLK_ENB		7
+	#define JPEG_CLK_ENB		8
+	#define FSMC_CLK_ENB		9
+	#define FIRDA_CLK_ENB		10
+	#define GPT2_CLK_ENB		11
+	#define GPT3_CLK_ENB		12
+	#define GPIO2_CLK_ENB		13
+	#define SSP2_CLK_ENB		14
+	#define ADC_CLK_ENB		15
+	#define GPT1_CLK_ENB		11
+	#define RTC_CLK_ENB		17
+	#define GPIO1_CLK_ENB		18
+	#define DMA_CLK_ENB		19
+	#define SMI_CLK_ENB		21
+	#define CLCD_CLK_ENB		22
+	#define GMAC_CLK_ENB		23
+	#define USBD_CLK_ENB		24
+	#define USBH0_CLK_ENB		25
+	#define USBH1_CLK_ENB		26
+
+#define PRSC0_CLK_CFG			(MISC_BASE + 0x044)
+#define PRSC1_CLK_CFG			(MISC_BASE + 0x048)
+#define PRSC2_CLK_CFG			(MISC_BASE + 0x04C)
+
+#define CLCD_CLK_SYNT			(MISC_BASE + 0x05C)
+#define FIRDA_CLK_SYNT			(MISC_BASE + 0x060)
+#define UART_CLK_SYNT			(MISC_BASE + 0x064)
+
+/* vco rate configuration table, in ascending order of rates */
+static struct pll_rate_tbl pll_rtbl[] = {
+	{.mode = 0, .m = 0x53, .n = 0x0F, .p = 0x1}, /* vco 332 & pll 166 MHz */
+	{.mode = 0, .m = 0x85, .n = 0x0F, .p = 0x1}, /* vco 532 & pll 266 MHz */
+	{.mode = 0, .m = 0xA6, .n = 0x0F, .p = 0x1}, /* vco 664 & pll 332 MHz */
+};
+
+/* aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl aux_rtbl[] = {
+	/* For PLL1 = 332 MHz */
+	{.xscale = 2, .yscale = 8, .eq = 0}, /* 41.5 MHz */
+	{.xscale = 2, .yscale = 4, .eq = 0}, /* 83 MHz */
+	{.xscale = 1, .yscale = 2, .eq = 1}, /* 166 MHz */
+};
+
+static const char *clcd_parents[] = { "pll3_48m_clk", "clcd_synth_gate_clk", };
+static const char *firda_parents[] = { "pll3_48m_clk", "firda_synth_gate_clk",
+};
+static const char *uart_parents[] = { "pll3_48m_clk", "uart_synth_gate_clk", };
+static const char *gpt0_1_parents[] = { "pll3_48m_clk", "gpt0_1_synth_clk", };
+static const char *gpt2_parents[] = { "pll3_48m_clk", "gpt2_synth_clk", };
+static const char *gpt3_parents[] = { "pll3_48m_clk", "gpt3_synth_clk", };
+static const char *ddr_parents[] = { "ahb_clk", "ahbmult2_clk", "none",
+	"pll2_clk", };
+
+/* gpt rate configuration table, in ascending order of rates */
+static struct gpt_rate_tbl gpt_rtbl[] = {
+	/* For pll1 = 332 MHz */
+	{.mscale = 4, .nscale = 0}, /* 41.5 MHz */
+	{.mscale = 2, .nscale = 0}, /* 55.3 MHz */
+	{.mscale = 1, .nscale = 0}, /* 83 MHz */
+};
+
+void __init spear6xx_clk_init(void)
+{
+	struct clk *clk, *clk1;
+
+	clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL, CLK_IS_ROOT, 0);
+	clk_register_clkdev(clk, "apb_pclk", NULL);
+
+	clk = clk_register_fixed_rate(NULL, "osc_32k_clk", NULL, CLK_IS_ROOT,
+			32000);
+	clk_register_clkdev(clk, "osc_32k_clk", NULL);
+
+	clk = clk_register_fixed_rate(NULL, "osc_30m_clk", NULL, CLK_IS_ROOT,
+			30000000);
+	clk_register_clkdev(clk, "osc_30m_clk", NULL);
+
+	/* clock derived from 32 KHz osc clk */
+	clk = clk_register_gate(NULL, "rtc_spear", "osc_32k_clk", 0,
+			PERIP1_CLK_ENB, RTC_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "rtc-spear");
+
+	/* clock derived from 30 MHz osc clk */
+	clk = clk_register_fixed_rate(NULL, "pll3_48m_clk", "osc_24m_clk", 0,
+			48000000);
+	clk_register_clkdev(clk, "pll3_48m_clk", NULL);
+
+	clk = clk_register_vco_pll("vco1_clk", "pll1_clk", NULL, "osc_30m_clk",
+			0, PLL1_CTR, PLL1_FRQ, pll_rtbl, ARRAY_SIZE(pll_rtbl),
+			&_lock, &clk1, NULL);
+	clk_register_clkdev(clk, "vco1_clk", NULL);
+	clk_register_clkdev(clk1, "pll1_clk", NULL);
+
+	clk = clk_register_vco_pll("vco2_clk", "pll2_clk", NULL,
+			"osc_30m_clk", 0, PLL2_CTR, PLL2_FRQ, pll_rtbl,
+			ARRAY_SIZE(pll_rtbl), &_lock, &clk1, NULL);
+	clk_register_clkdev(clk, "vco2_clk", NULL);
+	clk_register_clkdev(clk1, "pll2_clk", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "wdt_clk", "osc_30m_clk", 0, 1,
+			1);
+	clk_register_clkdev(clk, NULL, "wdt");
+
+	/* clock derived from pll1 clk */
+	clk = clk_register_fixed_factor(NULL, "cpu_clk", "pll1_clk", 0, 1, 1);
+	clk_register_clkdev(clk, "cpu_clk", NULL);
+
+	clk = clk_register_divider(NULL, "ahb_clk", "pll1_clk",
+			CLK_SET_RATE_PARENT, CORE_CLK_CFG, HCLK_RATIO_SHIFT,
+			HCLK_RATIO_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "ahb_clk", NULL);
+
+	clk = clk_register_aux("uart_synth_clk", "uart_synth_gate_clk",
+			"pll1_clk", 0, UART_CLK_SYNT, NULL, aux_rtbl,
+			ARRAY_SIZE(aux_rtbl), &_lock, &clk1);
+	clk_register_clkdev(clk, "uart_synth_clk", NULL);
+	clk_register_clkdev(clk1, "uart_synth_gate_clk", NULL);
+
+	clk = clk_register_mux(NULL, "uart_mux_clk", uart_parents,
+			ARRAY_SIZE(uart_parents), 0, PERIP_CLK_CFG,
+			UART_CLK_SHIFT, UART_CLK_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "uart_mux_clk", NULL);
+
+	clk = clk_register_gate(NULL, "uart0", "uart_mux_clk", 0,
+			PERIP1_CLK_ENB, UART0_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "d0000000.serial");
+
+	clk = clk_register_gate(NULL, "uart1", "uart_mux_clk", 0,
+			PERIP1_CLK_ENB, UART1_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "d0080000.serial");
+
+	clk = clk_register_aux("firda_synth_clk", "firda_synth_gate_clk",
+			"pll1_clk", 0, FIRDA_CLK_SYNT, NULL, aux_rtbl,
+			ARRAY_SIZE(aux_rtbl), &_lock, &clk1);
+	clk_register_clkdev(clk, "firda_synth_clk", NULL);
+	clk_register_clkdev(clk1, "firda_synth_gate_clk", NULL);
+
+	clk = clk_register_mux(NULL, "firda_mux_clk", firda_parents,
+			ARRAY_SIZE(firda_parents), 0, PERIP_CLK_CFG,
+			FIRDA_CLK_SHIFT, FIRDA_CLK_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "firda_mux_clk", NULL);
+
+	clk = clk_register_gate(NULL, "firda_clk", "firda_mux_clk", 0,
+			PERIP1_CLK_ENB, FIRDA_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "firda");
+
+	clk = clk_register_aux("clcd_synth_clk", "clcd_synth_gate_clk",
+			"pll1_clk", 0, CLCD_CLK_SYNT, NULL, aux_rtbl,
+			ARRAY_SIZE(aux_rtbl), &_lock, &clk1);
+	clk_register_clkdev(clk, "clcd_synth_clk", NULL);
+	clk_register_clkdev(clk1, "clcd_synth_gate_clk", NULL);
+
+	clk = clk_register_mux(NULL, "clcd_mux_clk", clcd_parents,
+			ARRAY_SIZE(clcd_parents), 0, PERIP_CLK_CFG,
+			CLCD_CLK_SHIFT, CLCD_CLK_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "clcd_mux_clk", NULL);
+
+	clk = clk_register_gate(NULL, "clcd_clk", "clcd_mux_clk", 0,
+			PERIP1_CLK_ENB, CLCD_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "clcd");
+
+	/* gpt clocks */
+	clk = clk_register_gpt("gpt0_1_synth_clk", "pll1_clk", 0, PRSC0_CLK_CFG,
+			gpt_rtbl, ARRAY_SIZE(gpt_rtbl), &_lock);
+	clk_register_clkdev(clk, "gpt0_1_synth_clk", NULL);
+
+	clk = clk_register_mux(NULL, "gpt0_mux_clk", gpt0_1_parents,
+			ARRAY_SIZE(gpt0_1_parents), 0, PERIP_CLK_CFG,
+			GPT0_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "gpt0");
+
+	clk = clk_register_mux(NULL, "gpt1_mux_clk", gpt0_1_parents,
+			ARRAY_SIZE(gpt0_1_parents), 0, PERIP_CLK_CFG,
+			GPT1_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "gpt1_mux_clk", NULL);
+
+	clk = clk_register_gate(NULL, "gpt1_clk", "gpt1_mux_clk", 0,
+			PERIP1_CLK_ENB, GPT1_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "gpt1");
+
+	clk = clk_register_gpt("gpt2_synth_clk", "pll1_clk", 0, PRSC1_CLK_CFG,
+			gpt_rtbl, ARRAY_SIZE(gpt_rtbl), &_lock);
+	clk_register_clkdev(clk, "gpt2_synth_clk", NULL);
+
+	clk = clk_register_mux(NULL, "gpt2_mux_clk", gpt2_parents,
+			ARRAY_SIZE(gpt2_parents), 0, PERIP_CLK_CFG,
+			GPT2_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "gpt2_mux_clk", NULL);
+
+	clk = clk_register_gate(NULL, "gpt2_clk", "gpt2_mux_clk", 0,
+			PERIP1_CLK_ENB, GPT2_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "gpt2");
+
+	clk = clk_register_gpt("gpt3_synth_clk", "pll1_clk", 0, PRSC2_CLK_CFG,
+			gpt_rtbl, ARRAY_SIZE(gpt_rtbl), &_lock);
+	clk_register_clkdev(clk, "gpt3_synth_clk", NULL);
+
+	clk = clk_register_mux(NULL, "gpt3_mux_clk", gpt3_parents,
+			ARRAY_SIZE(gpt3_parents), 0, PERIP_CLK_CFG,
+			GPT3_CLK_SHIFT, GPT_CLK_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "gpt3_mux_clk", NULL);
+
+	clk = clk_register_gate(NULL, "gpt3_clk", "gpt3_mux_clk", 0,
+			PERIP1_CLK_ENB, GPT3_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "gpt3");
+
+	/* clock derived from pll3 clk */
+	clk = clk_register_gate(NULL, "usbh0_clk", "pll3_48m_clk", 0,
+			PERIP1_CLK_ENB, USBH0_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "usbh.0_clk");
+
+	clk = clk_register_gate(NULL, "usbh1_clk", "pll3_48m_clk", 0,
+			PERIP1_CLK_ENB, USBH1_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "usbh.1_clk");
+
+	clk = clk_register_gate(NULL, "usbd_clk", "pll3_48m_clk", 0,
+			PERIP1_CLK_ENB, USBD_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "designware_udc");
+
+	/* clock derived from ahb clk */
+	clk = clk_register_fixed_factor(NULL, "ahbmult2_clk", "ahb_clk", 0, 2,
+			1);
+	clk_register_clkdev(clk, "ahbmult2_clk", NULL);
+
+	clk = clk_register_mux(NULL, "ddr_clk", ddr_parents,
+			ARRAY_SIZE(ddr_parents),
+			0, PLL_CLK_CFG, MCTR_CLK_SHIFT, MCTR_CLK_MASK, 0,
+			&_lock);
+	clk_register_clkdev(clk, "ddr_clk", NULL);
+
+	clk = clk_register_divider(NULL, "apb_clk", "ahb_clk",
+			CLK_SET_RATE_PARENT, CORE_CLK_CFG, PCLK_RATIO_SHIFT,
+			PCLK_RATIO_MASK, 0, &_lock);
+	clk_register_clkdev(clk, "apb_clk", NULL);
+
+	clk = clk_register_gate(NULL, "dma_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
+			DMA_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "fc400000.dma");
+
+	clk = clk_register_gate(NULL, "fsmc_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
+			FSMC_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "d1800000.flash");
+
+	clk = clk_register_gate(NULL, "gmac_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
+			GMAC_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "gmac");
+
+	clk = clk_register_gate(NULL, "i2c_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
+			I2C_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "d0200000.i2c");
+
+	clk = clk_register_gate(NULL, "jpeg_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
+			JPEG_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "jpeg");
+
+	clk = clk_register_gate(NULL, "smi_clk", "ahb_clk", 0, PERIP1_CLK_ENB,
+			SMI_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "fc000000.flash");
+
+	/* clock derived from apb clk */
+	clk = clk_register_gate(NULL, "adc_clk", "apb_clk", 0, PERIP1_CLK_ENB,
+			ADC_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "adc");
+
+	clk = clk_register_fixed_factor(NULL, "gpio0_clk", "apb_clk", 0, 1, 1);
+	clk_register_clkdev(clk, NULL, "f0100000.gpio");
+
+	clk = clk_register_gate(NULL, "gpio1_clk", "apb_clk", 0, PERIP1_CLK_ENB,
+			GPIO1_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "fc980000.gpio");
+
+	clk = clk_register_gate(NULL, "gpio2_clk", "apb_clk", 0, PERIP1_CLK_ENB,
+			GPIO2_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "d8100000.gpio");
+
+	clk = clk_register_gate(NULL, "ssp0_clk", "apb_clk", 0, PERIP1_CLK_ENB,
+			SSP0_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ssp-pl022.0");
+
+	clk = clk_register_gate(NULL, "ssp1_clk", "apb_clk", 0, PERIP1_CLK_ENB,
+			SSP1_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ssp-pl022.1");
+
+	clk = clk_register_gate(NULL, "ssp2_clk", "apb_clk", 0, PERIP1_CLK_ENB,
+			SSP2_CLK_ENB, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ssp-pl022.2");
+}
