commit a10660f7788bcb1229534cd1aa57a8f4b36cfe74
Author: Pascal Terjan <pterjan@google.com>
Date:   Sun May 10 20:30:16 2020 +0100

    ACPI: Delete unused proc filename macros
    
    Those were used to create files in /proc/acpi long ago
    and were missed when that code was deleted.
    
    Signed-off-by: Pascal Terjan <pterjan@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index ed3d2182cf2c..606da5d77ad3 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -31,8 +31,6 @@
 ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
 #define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
-#define ACPI_PCI_LINK_FILE_INFO		"info"
-#define ACPI_PCI_LINK_FILE_STATUS	"state"
 #define ACPI_PCI_LINK_MAX_POSSIBLE	16
 
 static int acpi_pci_link_add(struct acpi_device *device,

commit 1c5e1cdd7c1f34e6d7f22f9b819a307e435e780e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Apr 13 15:09:49 2020 +0200

    ACPI/PCI: pci_link: use extended_irq union member when setting ext-irq shareable
    
    The case ACPI_RESOURCE_TYPE_EXTENDED_IRQ inside acpi_pci_link_set()
    is correctly using resource->res.data.extended_irq.foo for most settings,
    but for the shareable setting it so far has accidentally been using
    resource->res.data.irq.shareable instead of
    resource->res.data.extended_irq.shareable.
    
    Note that the old code happens to also work because the shareable field
    offset is the same for both the acpi_resource_irq and
    acpi_resource_extended_irq structs.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 00a6da2121be..ed3d2182cf2c 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -322,10 +322,10 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		resource->res.data.extended_irq.polarity =
 		    link->irq.polarity;
 		if (link->irq.triggering == ACPI_EDGE_SENSITIVE)
-			resource->res.data.irq.shareable =
+			resource->res.data.extended_irq.shareable =
 			    ACPI_EXCLUSIVE;
 		else
-			resource->res.data.irq.shareable = ACPI_SHARED;
+			resource->res.data.extended_irq.shareable = ACPI_SHARED;
 		resource->res.data.extended_irq.interrupt_count = 1;
 		resource->res.data.extended_irq.interrupts[0] = irq;
 		/* ignore resource_source, it's optional */

commit 8698fab1c69a7265282d6b2ac081122e94d72cf8
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Mon Aug 19 15:53:24 2019 +0200

    ACPI/PCI: Remove surplus parentheses from a return statement
    
    Remove unnecessary parentheses enclosing the value in a return
    statement in the drivers/acpi/pci_link.c.
    
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Reviewed-by: Andrew Murray <andrew.murray@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index db11f7771ef1..00a6da2121be 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -661,7 +661,7 @@ int acpi_pci_link_allocate_irq(acpi_handle handle, int index, int *triggering,
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Link %s is referenced\n",
 			  acpi_device_bid(link->device)));
-	return (link->irq.active);
+	return link->irq.active;
 }
 
 /*
@@ -712,7 +712,7 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 		acpi_evaluate_object(link->device->handle, "_DIS", NULL, NULL);
 
 	mutex_unlock(&acpi_link_lock);
-	return (link->irq.active);
+	return link->irq.active;
 }
 
 /* --------------------------------------------------------------------------

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index df70b1eaef58..db11f7771ef1 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  pci_link.c - ACPI PCI Interrupt Link Device Driver ($Revision: 34 $)
  *
@@ -5,20 +6,6 @@
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
  *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
  * TBD: 
  *      1. Support more than one IRQ resource entry per link device (index).
  *	2. Implement start/stop mechanism and use ACPI Bus Driver facilities

commit c163f90cc8620716b08ac7987c4c4ebf16444fd5
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Feb 15 13:36:19 2019 -0800

    ACPI/ACPICA: Trivial: fix spelling mistakes and fix whitespace formatting
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index d5eec352a6e1..df70b1eaef58 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -317,10 +317,10 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		resource->res.data.irq.polarity =
 		    link->irq.polarity;
 		if (link->irq.triggering == ACPI_EDGE_SENSITIVE)
-			resource->res.data.irq.sharable =
+			resource->res.data.irq.shareable =
 			    ACPI_EXCLUSIVE;
 		else
-			resource->res.data.irq.sharable = ACPI_SHARED;
+			resource->res.data.irq.shareable = ACPI_SHARED;
 		resource->res.data.irq.interrupt_count = 1;
 		resource->res.data.irq.interrupts[0] = irq;
 		break;
@@ -335,10 +335,10 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		resource->res.data.extended_irq.polarity =
 		    link->irq.polarity;
 		if (link->irq.triggering == ACPI_EDGE_SENSITIVE)
-			resource->res.data.irq.sharable =
+			resource->res.data.irq.shareable =
 			    ACPI_EXCLUSIVE;
 		else
-			resource->res.data.irq.sharable = ACPI_SHARED;
+			resource->res.data.irq.shareable = ACPI_SHARED;
 		resource->res.data.extended_irq.interrupt_count = 1;
 		resource->res.data.extended_irq.interrupts[0] = irq;
 		/* ignore resource_source, it's optional */

commit 92d1b381f677cbd2d4370dc3b8d0679b7f0ace32
Author: Alex Hung <alex.hung@canonical.com>
Date:   Thu Feb 22 21:43:44 2018 -0800

    ACPI / PCI: pci_link: Allow the absence of _PRS and change log level
    
    In recent Intel hardware the IRQs become non-configurable after BIOS
    initializes them in PEI phase and _PRS objects are no longer included in
    ASL.
    
    This is the same as "static (non-configurable) devices do not
    specify a _PRS object" in ACPI spec. As a result, error messages
    saying "ACPI Exception: AE_NOT_FOUND, Evaluating _PRS" does not need to
    be in kernel messenges all the time but only when debug is enabled, and
    acpi_pci_link_get_possible should not return -ENODEV when _PRS is
    absent.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 85ad679390e3..d5eec352a6e1 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -173,8 +173,8 @@ static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 	status = acpi_walk_resources(link->device->handle, METHOD_NAME__PRS,
 				     acpi_pci_link_check_possible, link);
 	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRS"));
-		return -ENODEV;
+		acpi_handle_debug(link->device->handle, "_PRS not present or invalid");
+		return 0;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit 90fd94e4aba4ddfb6764c051a6bf9a3f4f26fb50
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Jan 16 13:51:04 2018 -0500

    ACPI/PCI: pci_link: reduce verbosity when IRQ is enabled
    
    When ACPI Link object is enabled, the message is printed with a warning
    prefix. Some test tools are capturing warning and test error types as
    errors. Let's reduce the verbosity of success case.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index bc3d914dfc3e..85ad679390e3 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -612,7 +612,7 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 			acpi_isa_irq_penalty[link->irq.active] +=
 				PIRQ_PENALTY_PCI_USING;
 
-		printk(KERN_WARNING PREFIX "%s [%s] enabled at IRQ %d\n",
+		pr_info("%s [%s] enabled at IRQ %d\n",
 		       acpi_device_name(link->device),
 		       acpi_device_bid(link->device), link->irq.active);
 	}

commit 98756f5319c64c883caa910dce702d9edefe7810
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Mon Oct 24 00:31:32 2016 -0400

    ACPI/PCI: pci_link: Include PIRQ_PENALTY_PCI_USING for ISA IRQs
    
    Commit 103544d86976 ("ACPI,PCI,IRQ: reduce resource requirements")
    replaced the addition of PIRQ_PENALTY_PCI_USING in acpi_pci_link_allocate()
    with an addition in acpi_irq_pci_sharing_penalty(), but f7eca374f000
    ("ACPI,PCI,IRQ: separate ISA penalty calculation") removed the use
    of acpi_irq_pci_sharing_penalty() for ISA IRQs.
    
    Therefore, PIRQ_PENALTY_PCI_USING is missing from ISA IRQs used by
    interrupt links.  Include that penalty by adding it in the
    acpi_pci_link_allocate() path.
    
    Fixes: f7eca374f000 (ACPI,PCI,IRQ: separate ISA penalty calculation)
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Jonathan Liu <net147@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 74bf96efae95..bc3d914dfc3e 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -608,6 +608,10 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 			    acpi_device_bid(link->device));
 		return -ENODEV;
 	} else {
+		if (link->irq.active < ACPI_MAX_ISA_IRQS)
+			acpi_isa_irq_penalty[link->irq.active] +=
+				PIRQ_PENALTY_PCI_USING;
+
 		printk(KERN_WARNING PREFIX "%s [%s] enabled at IRQ %d\n",
 		       acpi_device_name(link->device),
 		       acpi_device_bid(link->device), link->irq.active);

commit f1caa61df2a3dc4c58316295c5dc5edba4c68d85
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Mon Oct 24 00:31:31 2016 -0400

    ACPI/PCI: pci_link: penalize SCI correctly
    
    Ondrej reported that IRQs stopped working in v4.7 on several
    platforms.  A typical scenario, from Ondrej's VT82C694X/694X, is:
    
    ACPI: Using PIC for interrupt routing
    ACPI: PCI Interrupt Link [LNKA] (IRQs 1 3 4 5 6 7 10 *11 12 14 15)
    ACPI: No IRQ available for PCI Interrupt Link [LNKA]
    8139too 0000:00:0f.0: PCI INT A: no GSI
    
    We're using PIC routing, so acpi_irq_balance == 0, and LNKA is already
    active at IRQ 11. In that case, acpi_pci_link_allocate() only tries
    to use the active IRQ (IRQ 11) which also happens to be the SCI.
    
    We should penalize the SCI by PIRQ_PENALTY_PCI_USING, but
    irq_get_trigger_type(11) returns something other than
    IRQ_TYPE_LEVEL_LOW, so we penalize it by PIRQ_PENALTY_ISA_ALWAYS
    instead, which makes acpi_pci_link_allocate() assume the IRQ isn't
    available and give up.
    
    Add acpi_penalize_sci_irq() so platforms can tell us the SCI IRQ,
    trigger, and polarity directly and we don't have to depend on
    irq_get_trigger_type().
    
    Fixes: 103544d86976 (ACPI,PCI,IRQ: reduce resource requirements)
    Link: http://lkml.kernel.org/r/201609251512.05657.linux@rainbow-software.org
    Reported-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Tested-by: Jonathan Liu <net147@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 6229b022a5d4..74bf96efae95 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -87,6 +87,7 @@ struct acpi_pci_link {
 
 static LIST_HEAD(acpi_link_list);
 static DEFINE_MUTEX(acpi_link_lock);
+static int sci_irq = -1, sci_penalty;
 
 /* --------------------------------------------------------------------------
                             PCI Link Device Management
@@ -496,25 +497,13 @@ static int acpi_irq_get_penalty(int irq)
 {
 	int penalty = 0;
 
-	/*
-	* Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict
-	* with PCI IRQ attributes, mark ACPI SCI as ISA_ALWAYS so it won't be
-	* use for PCI IRQs.
-	*/
-	if (irq == acpi_gbl_FADT.sci_interrupt) {
-		u32 type = irq_get_trigger_type(irq) & IRQ_TYPE_SENSE_MASK;
-
-		if (type != IRQ_TYPE_LEVEL_LOW)
-			penalty += PIRQ_PENALTY_ISA_ALWAYS;
-		else
-			penalty += PIRQ_PENALTY_PCI_USING;
-	}
+	if (irq == sci_irq)
+		penalty += sci_penalty;
 
 	if (irq < ACPI_MAX_ISA_IRQS)
 		return penalty + acpi_isa_irq_penalty[irq];
 
-	penalty += acpi_irq_pci_sharing_penalty(irq);
-	return penalty;
+	return penalty + acpi_irq_pci_sharing_penalty(irq);
 }
 
 int __init acpi_irq_penalty_init(void)
@@ -881,6 +870,17 @@ bool acpi_isa_irq_available(int irq)
 		    acpi_irq_get_penalty(irq) < PIRQ_PENALTY_ISA_ALWAYS);
 }
 
+void acpi_penalize_sci_irq(int irq, int trigger, int polarity)
+{
+	sci_irq = irq;
+
+	if (trigger == ACPI_MADT_TRIGGER_LEVEL &&
+	    polarity == ACPI_MADT_POLARITY_ACTIVE_LOW)
+		sci_penalty = PIRQ_PENALTY_PCI_USING;
+	else
+		sci_penalty = PIRQ_PENALTY_ISA_ALWAYS;
+}
+
 /*
  * Over-ride default table to reserve additional IRQs for use by ISA
  * e.g. acpi_irq_isa=5

commit eeaed4bb5a35591470b545590bb2f26dbe7653a2
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Mon Oct 24 00:31:30 2016 -0400

    ACPI/PCI/IRQ: assign ISA IRQ directly during early boot stages
    
    We do not want to store the SCI penalty in the acpi_isa_irq_penalty[]
    table because acpi_isa_irq_penalty[] only holds ISA IRQ penalties and
    there's no guarantee that the SCI is an ISA IRQ.  We add in the SCI
    penalty as a special case in acpi_irq_get_penalty().
    
    But if we called acpi_penalize_isa_irq() or acpi_irq_penalty_update()
    for an SCI that happened to be an ISA IRQ, they stored the SCI
    penalty (part of the acpi_irq_get_penalty() return value) in
    acpi_isa_irq_penalty[].  Subsequent calls to acpi_irq_get_penalty()
    returned a penalty that included *two* SCI penalties.
    
    Fixes: 103544d86976 (ACPI,PCI,IRQ: reduce resource requirements)
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Jonathan Liu <net147@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index c983bf733ad3..6229b022a5d4 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -849,7 +849,7 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 			continue;
 
 		if (used)
-			new_penalty = acpi_irq_get_penalty(irq) +
+			new_penalty = acpi_isa_irq_penalty[irq] +
 					PIRQ_PENALTY_ISA_USED;
 		else
 			new_penalty = 0;
@@ -871,7 +871,7 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 void acpi_penalize_isa_irq(int irq, int active)
 {
 	if ((irq >= 0) && (irq < ARRAY_SIZE(acpi_isa_irq_penalty)))
-		acpi_isa_irq_penalty[irq] = acpi_irq_get_penalty(irq) +
+		acpi_isa_irq_penalty[irq] +=
 		  (active ? PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING);
 }
 

commit f7eca374f000bd8bd6aacc2619475fdba0b7ecca
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Jun 29 04:27:37 2016 -0400

    ACPI,PCI,IRQ: separate ISA penalty calculation
    
    Since commit 103544d86976 (ACPI,PCI,IRQ: reduce resource requirements)
    the penalty values are calculated on the fly rather than at boot time.
    
    This works fine for PCI interrupts but not so well for ISA interrupts.
    
    The information on whether or not an ISA interrupt is in use is not
    available to the pci_link.c code directly.  That information is
    obtained from the outside via acpi_penalize_isa_irq().  [If its
    "active" argument is true, then the IRQ is in use by ISA.]
    
    Since the current code relies on PCI Link objects for determination
    of penalties, we are factoring in the PCI penalty twice after
    acpi_penalize_isa_irq() function is called.
    
    To avoid that, limit the newly added functionality to just PCI
    interrupts so that old behavior is still maintained.
    
    Fixes: 103544d86976 (ACPI,PCI,IRQ: reduce resource requirements)
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Tested-by: Wim Osterholt <wim@djo.tudelft.nl>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 606083bb3f00..c983bf733ad3 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -496,9 +496,6 @@ static int acpi_irq_get_penalty(int irq)
 {
 	int penalty = 0;
 
-	if (irq < ACPI_MAX_ISA_IRQS)
-		penalty += acpi_isa_irq_penalty[irq];
-
 	/*
 	* Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict
 	* with PCI IRQ attributes, mark ACPI SCI as ISA_ALWAYS so it won't be
@@ -513,6 +510,9 @@ static int acpi_irq_get_penalty(int irq)
 			penalty += PIRQ_PENALTY_PCI_USING;
 	}
 
+	if (irq < ACPI_MAX_ISA_IRQS)
+		return penalty + acpi_isa_irq_penalty[irq];
+
 	penalty += acpi_irq_pci_sharing_penalty(irq);
 	return penalty;
 }

commit 487cf917ed0d12afaf403d9d77684bf44b8c13be
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Jun 29 04:27:36 2016 -0400

    Revert "ACPI, PCI, IRQ: remove redundant code in acpi_irq_penalty_init()"
    
    Trying to make the ISA and PCI init functionality common turned out
    to be a bad idea, because the ISA path depends on external
    functionality.
    
    Restore the previous behavior and limit the refactoring to PCI
    interrupts only.
    
    Fixes: 1fcb6a813c4f "ACPI,PCI,IRQ: remove redundant code in acpi_irq_penalty_init()"
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Tested-by: Wim Osterholt <wim@djo.tudelft.nl>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index db7be62a8222..606083bb3f00 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -517,6 +517,42 @@ static int acpi_irq_get_penalty(int irq)
 	return penalty;
 }
 
+int __init acpi_irq_penalty_init(void)
+{
+	struct acpi_pci_link *link;
+	int i;
+
+	/*
+	 * Update penalties to facilitate IRQ balancing.
+	 */
+	list_for_each_entry(link, &acpi_link_list, list) {
+
+		/*
+		 * reflect the possible and active irqs in the penalty table --
+		 * useful for breaking ties.
+		 */
+		if (link->irq.possible_count) {
+			int penalty =
+			    PIRQ_PENALTY_PCI_POSSIBLE /
+			    link->irq.possible_count;
+
+			for (i = 0; i < link->irq.possible_count; i++) {
+				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQS)
+					acpi_isa_irq_penalty[link->irq.
+							 possible[i]] +=
+					    penalty;
+			}
+
+		} else if (link->irq.active &&
+				(link->irq.active < ACPI_MAX_ISA_IRQS)) {
+			acpi_isa_irq_penalty[link->irq.active] +=
+			    PIRQ_PENALTY_PCI_POSSIBLE;
+		}
+	}
+
+	return 0;
+}
+
 static int acpi_irq_balance = -1;	/* 0: static, 1: balance */
 
 static int acpi_pci_link_allocate(struct acpi_pci_link *link)

commit 4a6e68bf96c1fa293717d2f00a68a68c92fa4150
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Jun 29 04:27:35 2016 -0400

    ACPI,PCI,IRQ: factor in PCI possible
    
    The change introduced in commit 103544d86976 (ACPI,PCI,IRQ: reduce
    resource requirements) omitted the initially applied PCI_POSSIBLE
    penalty when the IRQ is active.
    
    Incorrect calculation of the penalty leads the ACPI code to assigning
    a wrong interrupt number to a PCI INTx interrupt.
    
    This would not be as bad as it sounds in theory.  It would just cause
    the interrupts to be shared and result in performance penalty.
    
    However, some drivers (like the parallel port driver) don't like
    interrupt sharing and in the above case they will causes all of
    the PCI drivers wanting to share the interrupt to be unable to
    request it.
    
    The issue has not been caught in testing because the behavior is
    platform-specific and depends on the peripherals ending up sharing
    the IRQ and their drivers.
    
    Before the above commit the code would add the PCI_POSSIBLE value
    divided by the number of possible IRQ users to the IRQ penalty
    during initialization.
    
    Later in that code path, if the IRQ is chosen as the active IRQ or
    if it is used by ISA; additional penalties are added.
    
    Fixes: 103544d86976 (ACPI,PCI,IRQ: reduce resource requirements)
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Tested-by: Wim Osterholt <wim@djo.tudelft.nl>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 4ed4061813e6..db7be62a8222 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -470,6 +470,7 @@ static int acpi_irq_pci_sharing_penalty(int irq)
 {
 	struct acpi_pci_link *link;
 	int penalty = 0;
+	int i;
 
 	list_for_each_entry(link, &acpi_link_list, list) {
 		/*
@@ -478,18 +479,14 @@ static int acpi_irq_pci_sharing_penalty(int irq)
 		 */
 		if (link->irq.active && link->irq.active == irq)
 			penalty += PIRQ_PENALTY_PCI_USING;
-		else {
-			int i;
-
-			/*
-			 * If a link is inactive, penalize the IRQs it
-			 * might use, but not as severely.
-			 */
-			for (i = 0; i < link->irq.possible_count; i++)
-				if (link->irq.possible[i] == irq)
-					penalty += PIRQ_PENALTY_PCI_POSSIBLE /
-						link->irq.possible_count;
-		}
+
+		/*
+		 * penalize the IRQs PCI might use, but not as severely.
+		 */
+		for (i = 0; i < link->irq.possible_count; i++)
+			if (link->irq.possible[i] == irq)
+				penalty += PIRQ_PENALTY_PCI_POSSIBLE /
+					link->irq.possible_count;
 	}
 
 	return penalty;

commit 54794580f5949253520265e46c903878ab222d84
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Jun 29 04:27:38 2016 -0400

    ACPI,PCI,IRQ: correct operator precedence
    
    The omitted parenthesis prevents the addition operation when
    acpi_penalize_isa_irq function is called.
    
    Fixes: 103544d86976 (ACPI,PCI,IRQ: reduce resource requirements)
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 8fc7323ed3e8..4ed4061813e6 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -839,7 +839,7 @@ void acpi_penalize_isa_irq(int irq, int active)
 {
 	if ((irq >= 0) && (irq < ARRAY_SIZE(acpi_isa_irq_penalty)))
 		acpi_isa_irq_penalty[irq] = acpi_irq_get_penalty(irq) +
-			active ? PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING;
+		  (active ? PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING);
 }
 
 bool acpi_isa_irq_available(int irq)

commit 9e5ed6d1fb87dc3ff0c2a94ed75fe82027a9f597
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Sun Apr 17 13:36:56 2016 -0400

    ACPI,PCI,IRQ: remove SCI penalize function
    
    Removing the SCI penalize function as the penalty is now calculated on the
    fly.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index ab39208ba7e5..8fc7323ed3e8 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -848,10 +848,6 @@ bool acpi_isa_irq_available(int irq)
 		    acpi_irq_get_penalty(irq) < PIRQ_PENALTY_ISA_ALWAYS);
 }
 
-void acpi_penalize_sci_irq(int irq, int trigger, int polarity)
-{
-}
-
 /*
  * Over-ride default table to reserve additional IRQs for use by ISA
  * e.g. acpi_irq_isa=5

commit 1fcb6a813c4f67a0ba189b0d057b70ba084f6e1a
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Sun Apr 17 13:36:55 2016 -0400

    ACPI,PCI,IRQ: remove redundant code in acpi_irq_penalty_init()
    
    acpi_irq_get_penalty is now calculating the penalty on the fly now.
    No need to maintain global list of penalties or calculate them
    at the init time. Removing duplicate code in acpi_irq_penalty_init.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 12ea78495b47..ab39208ba7e5 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -520,42 +520,6 @@ static int acpi_irq_get_penalty(int irq)
 	return penalty;
 }
 
-int __init acpi_irq_penalty_init(void)
-{
-	struct acpi_pci_link *link;
-	int i;
-
-	/*
-	 * Update penalties to facilitate IRQ balancing.
-	 */
-	list_for_each_entry(link, &acpi_link_list, list) {
-
-		/*
-		 * reflect the possible and active irqs in the penalty table --
-		 * useful for breaking ties.
-		 */
-		if (link->irq.possible_count) {
-			int penalty =
-			    PIRQ_PENALTY_PCI_POSSIBLE /
-			    link->irq.possible_count;
-
-			for (i = 0; i < link->irq.possible_count; i++) {
-				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQS)
-					acpi_isa_irq_penalty[link->irq.
-							 possible[i]] +=
-					    penalty;
-			}
-
-		} else if (link->irq.active &&
-				(link->irq.active < ACPI_MAX_ISA_IRQS)) {
-			acpi_isa_irq_penalty[link->irq.active] +=
-			    PIRQ_PENALTY_PCI_POSSIBLE;
-		}
-	}
-
-	return 0;
-}
-
 static int acpi_irq_balance = -1;	/* 0: static, 1: balance */
 
 static int acpi_pci_link_allocate(struct acpi_pci_link *link)

commit 5c5087a5539083305f1199f09ac2e7f14d855ff3
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Sun Apr 17 13:36:54 2016 -0400

    ACPI,PCI,IRQ: reduce static IRQ array size to 16
    
    Now that the supported number of PCI IRQs are no longer capped
    with 256, renaming the static array to support ISA IRQs only
    and removing the MAX_IRQS constant.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index cc0ba1651db1..12ea78495b47 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -438,8 +438,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
  * enabled system.
  */
 
-#define ACPI_MAX_IRQS		256
-#define ACPI_MAX_ISA_IRQ	16
+#define ACPI_MAX_ISA_IRQS	16
 
 #define PIRQ_PENALTY_PCI_POSSIBLE	(16*16)
 #define PIRQ_PENALTY_PCI_USING		(16*16*16)
@@ -447,7 +446,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 #define PIRQ_PENALTY_ISA_USED		(16*16*16*16*16)
 #define PIRQ_PENALTY_ISA_ALWAYS		(16*16*16*16*16*16)
 
-static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
+static int acpi_isa_irq_penalty[ACPI_MAX_ISA_IRQS] = {
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ0 timer */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ1 keyboard */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ2 cascade */
@@ -500,8 +499,8 @@ static int acpi_irq_get_penalty(int irq)
 {
 	int penalty = 0;
 
-	if (irq < ACPI_MAX_ISA_IRQ)
-		penalty += acpi_irq_penalty[irq];
+	if (irq < ACPI_MAX_ISA_IRQS)
+		penalty += acpi_isa_irq_penalty[irq];
 
 	/*
 	* Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict
@@ -541,14 +540,15 @@ int __init acpi_irq_penalty_init(void)
 			    link->irq.possible_count;
 
 			for (i = 0; i < link->irq.possible_count; i++) {
-				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)
-					acpi_irq_penalty[link->irq.
+				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQS)
+					acpi_isa_irq_penalty[link->irq.
 							 possible[i]] +=
 					    penalty;
 			}
 
-		} else if (link->irq.active) {
-			acpi_irq_penalty[link->irq.active] +=
+		} else if (link->irq.active &&
+				(link->irq.active < ACPI_MAX_ISA_IRQS)) {
+			acpi_isa_irq_penalty[link->irq.active] +=
 			    PIRQ_PENALTY_PCI_POSSIBLE;
 		}
 	}
@@ -831,7 +831,7 @@ static void acpi_pci_link_remove(struct acpi_device *device)
 }
 
 /*
- * modify acpi_irq_penalty[] from cmdline
+ * modify acpi_isa_irq_penalty[] from cmdline
  */
 static int __init acpi_irq_penalty_update(char *str, int used)
 {
@@ -840,24 +840,24 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 	for (i = 0; i < 16; i++) {
 		int retval;
 		int irq;
+		int new_penalty;
 
 		retval = get_option(&str, &irq);
 
 		if (!retval)
 			break;	/* no number found */
 
-		if (irq < 0)
-			continue;
-
-		if (irq >= ARRAY_SIZE(acpi_irq_penalty))
+		/* see if this is a ISA IRQ */
+		if ((irq < 0) || (irq >= ACPI_MAX_ISA_IRQS))
 			continue;
 
 		if (used)
-			acpi_irq_penalty[irq] = acpi_irq_get_penalty(irq) +
-				PIRQ_PENALTY_ISA_USED;
+			new_penalty = acpi_irq_get_penalty(irq) +
+					PIRQ_PENALTY_ISA_USED;
 		else
-			acpi_irq_penalty[irq] = 0;
+			new_penalty = 0;
 
+		acpi_isa_irq_penalty[irq] = new_penalty;
 		if (retval != 2)	/* no next number */
 			break;
 	}
@@ -873,14 +873,14 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  */
 void acpi_penalize_isa_irq(int irq, int active)
 {
-	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty))
-		acpi_irq_penalty[irq] = acpi_irq_get_penalty(irq) +
+	if ((irq >= 0) && (irq < ARRAY_SIZE(acpi_isa_irq_penalty)))
+		acpi_isa_irq_penalty[irq] = acpi_irq_get_penalty(irq) +
 			active ? PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING;
 }
 
 bool acpi_isa_irq_available(int irq)
 {
-	return irq >= 0 && (irq >= ARRAY_SIZE(acpi_irq_penalty) ||
+	return irq >= 0 && (irq >= ARRAY_SIZE(acpi_isa_irq_penalty) ||
 		    acpi_irq_get_penalty(irq) < PIRQ_PENALTY_ISA_ALWAYS);
 }
 

commit 103544d86976338057d6a91f721b49d3acc7df7f
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Sun Apr 17 13:36:53 2016 -0400

    ACPI,PCI,IRQ: reduce resource requirements
    
    Code has been redesigned to calculate penalty requirements on the fly. This
    significantly simplifies the implementation and removes some of the init
    calls from x86 architecture.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index ededa909df2f..cc0ba1651db1 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -36,6 +36,7 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
+#include <linux/irq.h>
 
 #include "internal.h"
 
@@ -440,7 +441,6 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 #define ACPI_MAX_IRQS		256
 #define ACPI_MAX_ISA_IRQ	16
 
-#define PIRQ_PENALTY_PCI_AVAILABLE	(0)
 #define PIRQ_PENALTY_PCI_POSSIBLE	(16*16)
 #define PIRQ_PENALTY_PCI_USING		(16*16*16)
 #define PIRQ_PENALTY_ISA_TYPICAL	(16*16*16*16)
@@ -457,9 +457,9 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ6 */
 	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ7 parallel, spurious */
 	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ8 rtc, sometimes */
-	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ9  PCI, often acpi */
-	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ10 PCI */
-	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ11 PCI */
+	0,				/* IRQ9  PCI, often acpi */
+	0,				/* IRQ10 PCI */
+	0,				/* IRQ11 PCI */
 	PIRQ_PENALTY_ISA_USED,		/* IRQ12 mouse */
 	PIRQ_PENALTY_ISA_USED,		/* IRQ13 fpe, sometimes */
 	PIRQ_PENALTY_ISA_USED,		/* IRQ14 ide0 */
@@ -467,6 +467,60 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 	/* >IRQ15 */
 };
 
+static int acpi_irq_pci_sharing_penalty(int irq)
+{
+	struct acpi_pci_link *link;
+	int penalty = 0;
+
+	list_for_each_entry(link, &acpi_link_list, list) {
+		/*
+		 * If a link is active, penalize its IRQ heavily
+		 * so we try to choose a different IRQ.
+		 */
+		if (link->irq.active && link->irq.active == irq)
+			penalty += PIRQ_PENALTY_PCI_USING;
+		else {
+			int i;
+
+			/*
+			 * If a link is inactive, penalize the IRQs it
+			 * might use, but not as severely.
+			 */
+			for (i = 0; i < link->irq.possible_count; i++)
+				if (link->irq.possible[i] == irq)
+					penalty += PIRQ_PENALTY_PCI_POSSIBLE /
+						link->irq.possible_count;
+		}
+	}
+
+	return penalty;
+}
+
+static int acpi_irq_get_penalty(int irq)
+{
+	int penalty = 0;
+
+	if (irq < ACPI_MAX_ISA_IRQ)
+		penalty += acpi_irq_penalty[irq];
+
+	/*
+	* Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict
+	* with PCI IRQ attributes, mark ACPI SCI as ISA_ALWAYS so it won't be
+	* use for PCI IRQs.
+	*/
+	if (irq == acpi_gbl_FADT.sci_interrupt) {
+		u32 type = irq_get_trigger_type(irq) & IRQ_TYPE_SENSE_MASK;
+
+		if (type != IRQ_TYPE_LEVEL_LOW)
+			penalty += PIRQ_PENALTY_ISA_ALWAYS;
+		else
+			penalty += PIRQ_PENALTY_PCI_USING;
+	}
+
+	penalty += acpi_irq_pci_sharing_penalty(irq);
+	return penalty;
+}
+
 int __init acpi_irq_penalty_init(void)
 {
 	struct acpi_pci_link *link;
@@ -547,12 +601,12 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 		 * the use of IRQs 9, 10, 11, and >15.
 		 */
 		for (i = (link->irq.possible_count - 1); i >= 0; i--) {
-			if (acpi_irq_penalty[irq] >
-			    acpi_irq_penalty[link->irq.possible[i]])
+			if (acpi_irq_get_penalty(irq) >
+			    acpi_irq_get_penalty(link->irq.possible[i]))
 				irq = link->irq.possible[i];
 		}
 	}
-	if (acpi_irq_penalty[irq] >= PIRQ_PENALTY_ISA_ALWAYS) {
+	if (acpi_irq_get_penalty(irq) >= PIRQ_PENALTY_ISA_ALWAYS) {
 		printk(KERN_ERR PREFIX "No IRQ available for %s [%s]. "
 			    "Try pci=noacpi or acpi=off\n",
 			    acpi_device_name(link->device),
@@ -568,7 +622,6 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 			    acpi_device_bid(link->device));
 		return -ENODEV;
 	} else {
-		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
 		printk(KERN_WARNING PREFIX "%s [%s] enabled at IRQ %d\n",
 		       acpi_device_name(link->device),
 		       acpi_device_bid(link->device), link->irq.active);
@@ -800,9 +853,10 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 			continue;
 
 		if (used)
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
+			acpi_irq_penalty[irq] = acpi_irq_get_penalty(irq) +
+				PIRQ_PENALTY_ISA_USED;
 		else
-			acpi_irq_penalty[irq] = PIRQ_PENALTY_PCI_AVAILABLE;
+			acpi_irq_penalty[irq] = 0;
 
 		if (retval != 2)	/* no next number */
 			break;
@@ -819,34 +873,19 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  */
 void acpi_penalize_isa_irq(int irq, int active)
 {
-	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
-		if (active)
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
-		else
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
-	}
+	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty))
+		acpi_irq_penalty[irq] = acpi_irq_get_penalty(irq) +
+			active ? PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING;
 }
 
 bool acpi_isa_irq_available(int irq)
 {
 	return irq >= 0 && (irq >= ARRAY_SIZE(acpi_irq_penalty) ||
-			    acpi_irq_penalty[irq] < PIRQ_PENALTY_ISA_ALWAYS);
+		    acpi_irq_get_penalty(irq) < PIRQ_PENALTY_ISA_ALWAYS);
 }
 
-/*
- * Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict with
- * PCI IRQ attributes, mark ACPI SCI as ISA_ALWAYS so it won't be use for
- * PCI IRQs.
- */
 void acpi_penalize_sci_irq(int irq, int trigger, int polarity)
 {
-	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
-		if (trigger != ACPI_MADT_TRIGGER_LEVEL ||
-		    polarity != ACPI_MADT_POLARITY_ACTIVE_LOW)
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_ALWAYS;
-		else
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
-	}
 }
 
 /*

commit e249714571db26cdb1ae8df7ed39971bafa041a7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 24 13:55:38 2016 +0100

    Revert "ACPI, PCI, irq: remove interrupt count restriction"
    
    Revert commit b5bd02695471 (ACPI, PCI, irq: remove interrupt count
    restriction) that introduced a boot regression on some systems
    where it caused kmalloc() to be used too early.
    
    Link: http://marc.info/?l=linux-acpi&m=145580159209240&w=2
    Reported-by: Nalla, Ravikanth <ravikanth.nalla@hpe.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 5114d8007aa0..ededa909df2f 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -4,7 +4,6 @@
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
- *  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -438,6 +437,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
  * enabled system.
  */
 
+#define ACPI_MAX_IRQS		256
 #define ACPI_MAX_ISA_IRQ	16
 
 #define PIRQ_PENALTY_PCI_AVAILABLE	(0)
@@ -447,7 +447,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 #define PIRQ_PENALTY_ISA_USED		(16*16*16*16*16)
 #define PIRQ_PENALTY_ISA_ALWAYS		(16*16*16*16*16*16)
 
-static int acpi_irq_isa_penalty[ACPI_MAX_ISA_IRQ] = {
+static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ0 timer */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ1 keyboard */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ2 cascade */
@@ -464,68 +464,9 @@ static int acpi_irq_isa_penalty[ACPI_MAX_ISA_IRQ] = {
 	PIRQ_PENALTY_ISA_USED,		/* IRQ13 fpe, sometimes */
 	PIRQ_PENALTY_ISA_USED,		/* IRQ14 ide0 */
 	PIRQ_PENALTY_ISA_USED,		/* IRQ15 ide1 */
+	/* >IRQ15 */
 };
 
-struct irq_penalty_info {
-	int irq;
-	int penalty;
-	struct list_head node;
-};
-
-static LIST_HEAD(acpi_irq_penalty_list);
-
-static int acpi_irq_get_penalty(int irq)
-{
-	struct irq_penalty_info *irq_info;
-
-	if (irq < ACPI_MAX_ISA_IRQ)
-		return acpi_irq_isa_penalty[irq];
-
-	list_for_each_entry(irq_info, &acpi_irq_penalty_list, node) {
-		if (irq_info->irq == irq)
-			return irq_info->penalty;
-	}
-
-	return 0;
-}
-
-static int acpi_irq_set_penalty(int irq, int new_penalty)
-{
-	struct irq_penalty_info *irq_info;
-
-	/* see if this is a ISA IRQ */
-	if (irq < ACPI_MAX_ISA_IRQ) {
-		acpi_irq_isa_penalty[irq] = new_penalty;
-		return 0;
-	}
-
-	/* next, try to locate from the dynamic list */
-	list_for_each_entry(irq_info, &acpi_irq_penalty_list, node) {
-		if (irq_info->irq == irq) {
-			irq_info->penalty  = new_penalty;
-			return 0;
-		}
-	}
-
-	/* nope, let's allocate a slot for this IRQ */
-	irq_info = kzalloc(sizeof(*irq_info), GFP_KERNEL);
-	if (!irq_info)
-		return -ENOMEM;
-
-	irq_info->irq = irq;
-	irq_info->penalty = new_penalty;
-	list_add_tail(&irq_info->node, &acpi_irq_penalty_list);
-
-	return 0;
-}
-
-static void acpi_irq_add_penalty(int irq, int penalty)
-{
-	int curpen = acpi_irq_get_penalty(irq);
-
-	acpi_irq_set_penalty(irq, curpen + penalty);
-}
-
 int __init acpi_irq_penalty_init(void)
 {
 	struct acpi_pci_link *link;
@@ -546,16 +487,15 @@ int __init acpi_irq_penalty_init(void)
 			    link->irq.possible_count;
 
 			for (i = 0; i < link->irq.possible_count; i++) {
-				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ) {
-					int irqpos = link->irq.possible[i];
-
-					acpi_irq_add_penalty(irqpos, penalty);
-				}
+				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)
+					acpi_irq_penalty[link->irq.
+							 possible[i]] +=
+					    penalty;
 			}
 
 		} else if (link->irq.active) {
-			acpi_irq_add_penalty(link->irq.active,
-					     PIRQ_PENALTY_PCI_POSSIBLE);
+			acpi_irq_penalty[link->irq.active] +=
+			    PIRQ_PENALTY_PCI_POSSIBLE;
 		}
 	}
 
@@ -607,12 +547,12 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 		 * the use of IRQs 9, 10, 11, and >15.
 		 */
 		for (i = (link->irq.possible_count - 1); i >= 0; i--) {
-			if (acpi_irq_get_penalty(irq) >
-			    acpi_irq_get_penalty(link->irq.possible[i]))
+			if (acpi_irq_penalty[irq] >
+			    acpi_irq_penalty[link->irq.possible[i]])
 				irq = link->irq.possible[i];
 		}
 	}
-	if (acpi_irq_get_penalty(irq) >= PIRQ_PENALTY_ISA_ALWAYS) {
+	if (acpi_irq_penalty[irq] >= PIRQ_PENALTY_ISA_ALWAYS) {
 		printk(KERN_ERR PREFIX "No IRQ available for %s [%s]. "
 			    "Try pci=noacpi or acpi=off\n",
 			    acpi_device_name(link->device),
@@ -628,8 +568,7 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 			    acpi_device_bid(link->device));
 		return -ENODEV;
 	} else {
-		acpi_irq_add_penalty(link->irq.active, PIRQ_PENALTY_PCI_USING);
-
+		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
 		printk(KERN_WARNING PREFIX "%s [%s] enabled at IRQ %d\n",
 		       acpi_device_name(link->device),
 		       acpi_device_bid(link->device), link->irq.active);
@@ -839,7 +778,7 @@ static void acpi_pci_link_remove(struct acpi_device *device)
 }
 
 /*
- * modify penalty from cmdline
+ * modify acpi_irq_penalty[] from cmdline
  */
 static int __init acpi_irq_penalty_update(char *str, int used)
 {
@@ -857,10 +796,13 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 		if (irq < 0)
 			continue;
 
+		if (irq >= ARRAY_SIZE(acpi_irq_penalty))
+			continue;
+
 		if (used)
-			acpi_irq_add_penalty(irq, PIRQ_PENALTY_ISA_USED);
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
 		else
-			acpi_irq_set_penalty(irq, PIRQ_PENALTY_PCI_AVAILABLE);
+			acpi_irq_penalty[irq] = PIRQ_PENALTY_PCI_AVAILABLE;
 
 		if (retval != 2)	/* no next number */
 			break;
@@ -877,23 +819,18 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  */
 void acpi_penalize_isa_irq(int irq, int active)
 {
-	int penalty;
-
-	if (irq < 0)
-		return;
-
-	if (active)
-		penalty = PIRQ_PENALTY_ISA_USED;
-	else
-		penalty = PIRQ_PENALTY_PCI_USING;
-
-	acpi_irq_add_penalty(irq, penalty);
+	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
+		if (active)
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
+		else
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+	}
 }
 
 bool acpi_isa_irq_available(int irq)
 {
-	return irq >= 0 &&
-		(acpi_irq_get_penalty(irq) < PIRQ_PENALTY_ISA_ALWAYS);
+	return irq >= 0 && (irq >= ARRAY_SIZE(acpi_irq_penalty) ||
+			    acpi_irq_penalty[irq] < PIRQ_PENALTY_ISA_ALWAYS);
 }
 
 /*
@@ -903,18 +840,13 @@ bool acpi_isa_irq_available(int irq)
  */
 void acpi_penalize_sci_irq(int irq, int trigger, int polarity)
 {
-	int penalty;
-
-	if (irq < 0)
-		return;
-
-	if (trigger != ACPI_MADT_TRIGGER_LEVEL ||
-	    polarity != ACPI_MADT_POLARITY_ACTIVE_LOW)
-		penalty = PIRQ_PENALTY_ISA_ALWAYS;
-	else
-		penalty = PIRQ_PENALTY_PCI_USING;
-
-	acpi_irq_add_penalty(irq, penalty);
+	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
+		if (trigger != ACPI_MADT_TRIGGER_LEVEL ||
+		    polarity != ACPI_MADT_POLARITY_ACTIVE_LOW)
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_ALWAYS;
+		else
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+	}
 }
 
 /*

commit 5ec5d10682745d3280a37e8ffee1ddcd37ecfa94
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 24 13:53:46 2016 +0100

    Revert "ACPI / PCI: Simplify acpi_penalize_isa_irq()"
    
    Revert commit 0971686954f9 "ACPI / PCI: Simplify acpi_penalize_isa_irq()"
    that depends on commit b5bd02695471 (ACPI, PCI, irq: remove interrupt
    count restriction) which introduced a regression and needs to be
    reverted for this reason.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index fa2863567eed..5114d8007aa0 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -877,9 +877,17 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  */
 void acpi_penalize_isa_irq(int irq, int active)
 {
-	if (irq >= 0)
-		acpi_irq_add_penalty(irq, active ?
-			PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING);
+	int penalty;
+
+	if (irq < 0)
+		return;
+
+	if (active)
+		penalty = PIRQ_PENALTY_ISA_USED;
+	else
+		penalty = PIRQ_PENALTY_PCI_USING;
+
+	acpi_irq_add_penalty(irq, penalty);
 }
 
 bool acpi_isa_irq_available(int irq)

commit 0971686954f9cdde502c7bce4794c5ad53ea2e66
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jan 4 22:07:39 2016 +0100

    ACPI / PCI: Simplify acpi_penalize_isa_irq()
    
    acpi_penalize_isa_irq() can be written in fewer lines of code,
    so do that.  No functional change.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Works-for: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 5114d8007aa0..fa2863567eed 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -877,17 +877,9 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  */
 void acpi_penalize_isa_irq(int irq, int active)
 {
-	int penalty;
-
-	if (irq < 0)
-		return;
-
-	if (active)
-		penalty = PIRQ_PENALTY_ISA_USED;
-	else
-		penalty = PIRQ_PENALTY_PCI_USING;
-
-	acpi_irq_add_penalty(irq, penalty);
+	if (irq >= 0)
+		acpi_irq_add_penalty(irq, active ?
+			PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING);
 }
 
 bool acpi_isa_irq_available(int irq)

commit 37c5939136d7ce42b36c5d5b46f5272903a68433
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Dec 9 11:18:28 2015 -0500

    ACPI, PCI, irq: remove interrupt number restriction
    
    The ACPI compiler uses the extended format when used interrupt numbers
    are greater than 15. The extended IRQ syntax is 32 bits according to the
    ACPI spec. The code supports parsing the extended interrupt numbers.
    However, due to used data structure type; the code silently truncates
    interrupt numbers greater than 256.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 0286f17f0fa5..5114d8007aa0 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -68,12 +68,12 @@ static struct acpi_scan_handler pci_link_handler = {
  * later even the link is disable. Instead, we just repick the active irq
  */
 struct acpi_pci_link_irq {
-	u8 active;		/* Current IRQ */
+	u32 active;		/* Current IRQ */
 	u8 triggering;		/* All IRQs */
 	u8 polarity;		/* All IRQs */
 	u8 resource_type;
 	u8 possible_count;
-	u8 possible[ACPI_PCI_LINK_MAX_POSSIBLE];
+	u32 possible[ACPI_PCI_LINK_MAX_POSSIBLE];
 	u8 initialized:1;
 	u8 reserved:7;
 };

commit b5bd0269547105046f2236d9895bd5e3038cc8bc
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Dec 9 11:18:27 2015 -0500

    ACPI, PCI, irq: remove interrupt count restriction
    
    Code currently supports 256 maximum interrupts at this moment. The patch is
    reconfiguring the penalty array as a dynamic list to remove this
    limitation.
    
    A new penalty linklist has been added for all other interrupts greater than
    16. If an IRQ is not found in the link list, an IRQ info structure will be
    dynamically allocated on the first access and will be placed on the list
    for further reuse. The list will grow by the number of supported interrupts
    in the ACPI table rather than having a 256 hard limitation.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 7c8408b946ca..0286f17f0fa5 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -4,6 +4,7 @@
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -437,7 +438,6 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
  * enabled system.
  */
 
-#define ACPI_MAX_IRQS		256
 #define ACPI_MAX_ISA_IRQ	16
 
 #define PIRQ_PENALTY_PCI_AVAILABLE	(0)
@@ -447,7 +447,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 #define PIRQ_PENALTY_ISA_USED		(16*16*16*16*16)
 #define PIRQ_PENALTY_ISA_ALWAYS		(16*16*16*16*16*16)
 
-static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
+static int acpi_irq_isa_penalty[ACPI_MAX_ISA_IRQ] = {
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ0 timer */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ1 keyboard */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ2 cascade */
@@ -464,9 +464,68 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 	PIRQ_PENALTY_ISA_USED,		/* IRQ13 fpe, sometimes */
 	PIRQ_PENALTY_ISA_USED,		/* IRQ14 ide0 */
 	PIRQ_PENALTY_ISA_USED,		/* IRQ15 ide1 */
-	/* >IRQ15 */
 };
 
+struct irq_penalty_info {
+	int irq;
+	int penalty;
+	struct list_head node;
+};
+
+static LIST_HEAD(acpi_irq_penalty_list);
+
+static int acpi_irq_get_penalty(int irq)
+{
+	struct irq_penalty_info *irq_info;
+
+	if (irq < ACPI_MAX_ISA_IRQ)
+		return acpi_irq_isa_penalty[irq];
+
+	list_for_each_entry(irq_info, &acpi_irq_penalty_list, node) {
+		if (irq_info->irq == irq)
+			return irq_info->penalty;
+	}
+
+	return 0;
+}
+
+static int acpi_irq_set_penalty(int irq, int new_penalty)
+{
+	struct irq_penalty_info *irq_info;
+
+	/* see if this is a ISA IRQ */
+	if (irq < ACPI_MAX_ISA_IRQ) {
+		acpi_irq_isa_penalty[irq] = new_penalty;
+		return 0;
+	}
+
+	/* next, try to locate from the dynamic list */
+	list_for_each_entry(irq_info, &acpi_irq_penalty_list, node) {
+		if (irq_info->irq == irq) {
+			irq_info->penalty  = new_penalty;
+			return 0;
+		}
+	}
+
+	/* nope, let's allocate a slot for this IRQ */
+	irq_info = kzalloc(sizeof(*irq_info), GFP_KERNEL);
+	if (!irq_info)
+		return -ENOMEM;
+
+	irq_info->irq = irq;
+	irq_info->penalty = new_penalty;
+	list_add_tail(&irq_info->node, &acpi_irq_penalty_list);
+
+	return 0;
+}
+
+static void acpi_irq_add_penalty(int irq, int penalty)
+{
+	int curpen = acpi_irq_get_penalty(irq);
+
+	acpi_irq_set_penalty(irq, curpen + penalty);
+}
+
 int __init acpi_irq_penalty_init(void)
 {
 	struct acpi_pci_link *link;
@@ -487,15 +546,16 @@ int __init acpi_irq_penalty_init(void)
 			    link->irq.possible_count;
 
 			for (i = 0; i < link->irq.possible_count; i++) {
-				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)
-					acpi_irq_penalty[link->irq.
-							 possible[i]] +=
-					    penalty;
+				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ) {
+					int irqpos = link->irq.possible[i];
+
+					acpi_irq_add_penalty(irqpos, penalty);
+				}
 			}
 
 		} else if (link->irq.active) {
-			acpi_irq_penalty[link->irq.active] +=
-			    PIRQ_PENALTY_PCI_POSSIBLE;
+			acpi_irq_add_penalty(link->irq.active,
+					     PIRQ_PENALTY_PCI_POSSIBLE);
 		}
 	}
 
@@ -547,12 +607,12 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 		 * the use of IRQs 9, 10, 11, and >15.
 		 */
 		for (i = (link->irq.possible_count - 1); i >= 0; i--) {
-			if (acpi_irq_penalty[irq] >
-			    acpi_irq_penalty[link->irq.possible[i]])
+			if (acpi_irq_get_penalty(irq) >
+			    acpi_irq_get_penalty(link->irq.possible[i]))
 				irq = link->irq.possible[i];
 		}
 	}
-	if (acpi_irq_penalty[irq] >= PIRQ_PENALTY_ISA_ALWAYS) {
+	if (acpi_irq_get_penalty(irq) >= PIRQ_PENALTY_ISA_ALWAYS) {
 		printk(KERN_ERR PREFIX "No IRQ available for %s [%s]. "
 			    "Try pci=noacpi or acpi=off\n",
 			    acpi_device_name(link->device),
@@ -568,7 +628,8 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 			    acpi_device_bid(link->device));
 		return -ENODEV;
 	} else {
-		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
+		acpi_irq_add_penalty(link->irq.active, PIRQ_PENALTY_PCI_USING);
+
 		printk(KERN_WARNING PREFIX "%s [%s] enabled at IRQ %d\n",
 		       acpi_device_name(link->device),
 		       acpi_device_bid(link->device), link->irq.active);
@@ -778,7 +839,7 @@ static void acpi_pci_link_remove(struct acpi_device *device)
 }
 
 /*
- * modify acpi_irq_penalty[] from cmdline
+ * modify penalty from cmdline
  */
 static int __init acpi_irq_penalty_update(char *str, int used)
 {
@@ -796,13 +857,10 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 		if (irq < 0)
 			continue;
 
-		if (irq >= ARRAY_SIZE(acpi_irq_penalty))
-			continue;
-
 		if (used)
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
+			acpi_irq_add_penalty(irq, PIRQ_PENALTY_ISA_USED);
 		else
-			acpi_irq_penalty[irq] = PIRQ_PENALTY_PCI_AVAILABLE;
+			acpi_irq_set_penalty(irq, PIRQ_PENALTY_PCI_AVAILABLE);
 
 		if (retval != 2)	/* no next number */
 			break;
@@ -819,18 +877,23 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  */
 void acpi_penalize_isa_irq(int irq, int active)
 {
-	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
-		if (active)
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
-		else
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
-	}
+	int penalty;
+
+	if (irq < 0)
+		return;
+
+	if (active)
+		penalty = PIRQ_PENALTY_ISA_USED;
+	else
+		penalty = PIRQ_PENALTY_PCI_USING;
+
+	acpi_irq_add_penalty(irq, penalty);
 }
 
 bool acpi_isa_irq_available(int irq)
 {
-	return irq >= 0 && (irq >= ARRAY_SIZE(acpi_irq_penalty) ||
-			    acpi_irq_penalty[irq] < PIRQ_PENALTY_ISA_ALWAYS);
+	return irq >= 0 &&
+		(acpi_irq_get_penalty(irq) < PIRQ_PENALTY_ISA_ALWAYS);
 }
 
 /*
@@ -840,13 +903,18 @@ bool acpi_isa_irq_available(int irq)
  */
 void acpi_penalize_sci_irq(int irq, int trigger, int polarity)
 {
-	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
-		if (trigger != ACPI_MADT_TRIGGER_LEVEL ||
-		    polarity != ACPI_MADT_POLARITY_ACTIVE_LOW)
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_ALWAYS;
-		else
-			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
-	}
+	int penalty;
+
+	if (irq < 0)
+		return;
+
+	if (trigger != ACPI_MADT_TRIGGER_LEVEL ||
+	    polarity != ACPI_MADT_POLARITY_ACTIVE_LOW)
+		penalty = PIRQ_PENALTY_ISA_ALWAYS;
+	else
+		penalty = PIRQ_PENALTY_PCI_USING;
+
+	acpi_irq_add_penalty(irq, penalty);
 }
 
 /*

commit d323efc786910bcc0c8f8b9f97780c70544ac4df
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Sep 17 14:02:46 2015 +0800

    ACPI / PCI: Remove duplicated penalty on SCI IRQ
    
    Now we have dedicated interface acpi_penalize_sci_irq() to penalize
    ISA IRQ used by ACPI SCI, so remove duplicated code to penalize ACPI SCI
    in acpi_irq_penalty_init().
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 246e50d22120..7c8408b946ca 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -498,8 +498,7 @@ int __init acpi_irq_penalty_init(void)
 			    PIRQ_PENALTY_PCI_POSSIBLE;
 		}
 	}
-	/* Add a penalty for the SCI */
-	acpi_irq_penalty[acpi_gbl_FADT.sci_interrupt] += PIRQ_PENALTY_PCI_USING;
+
 	return 0;
 }
 

commit 5ebc76035303016ec41bb752bec156ea9fde7c34
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Sep 17 14:02:45 2015 +0800

    ACPI, PCI, irq: Do not share PCI IRQ with ISA IRQ
    
    Avoid IRQs occupied by ISA IRQs when allocating IRQs for PCI link devices,
    otherwise it may cause interrupt storm due to incompatible pin attributes.
    
    This issue was triggered on a KVM virtual machine, which
     1) uses IRQ9 for SCI in high level mode.
     2) defines an PCI interrupt link device (LNKS) with IRQ9 as the only
        possible irq.
     3) has an PCI device referring to link device LNKS.
    So it causes interrupt storm when enabling the PCI device because PCI IRQ
    works in low level mode.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 3b4ea98e3ea0..246e50d22120 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -553,6 +553,13 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 				irq = link->irq.possible[i];
 		}
 	}
+	if (acpi_irq_penalty[irq] >= PIRQ_PENALTY_ISA_ALWAYS) {
+		printk(KERN_ERR PREFIX "No IRQ available for %s [%s]. "
+			    "Try pci=noacpi or acpi=off\n",
+			    acpi_device_name(link->device),
+			    acpi_device_bid(link->device));
+		return -ENODEV;
+	}
 
 	/* Attempt to enable the link device at this IRQ. */
 	if (acpi_pci_link_set(link, irq)) {
@@ -821,6 +828,12 @@ void acpi_penalize_isa_irq(int irq, int active)
 	}
 }
 
+bool acpi_isa_irq_available(int irq)
+{
+	return irq >= 0 && (irq >= ARRAY_SIZE(acpi_irq_penalty) ||
+			    acpi_irq_penalty[irq] < PIRQ_PENALTY_ISA_ALWAYS);
+}
+
 /*
  * Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict with
  * PCI IRQ attributes, mark ACPI SCI as ISA_ALWAYS so it won't be use for

commit 5d2a1a927d487d6bb60c87b837d82702d8ebcaad
Merge: ef5f5de069bd 5d0ddfebb930 b00855aecbb1 02b771b64b73 3277b4ea216e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:41:19 2015 +0200

    Merge branches 'acpi-pci', 'acpi-soc', 'acpi-ec' and 'acpi-osl'
    
    * acpi-pci:
      ACPI, PCI: Penalize legacy IRQ used by ACPI SCI
    
    * acpi-soc:
      ACPI / LPSS: Ignore 10ms delay for Braswell
    
    * acpi-ec:
      ACPI / EC: Fix an issue caused by the serialized _Qxx evaluations
    
    * acpi-osl:
      ACPI / osl: replace custom implementation of readq / writeq

commit 5d0ddfebb93069061880fc57ee4ba7246bd1e1ee
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Fri Aug 21 15:36:23 2015 +0800

    ACPI, PCI: Penalize legacy IRQ used by ACPI SCI
    
    Nick Meier reported a regression with HyperV that "
      After rebooting the VM, the following messages are logged in syslog
      when trying to load the tulip driver:
        tulip: Linux Tulip drivers version 1.1.15 (Feb 27, 2007)
        tulip: 0000:00:0a.0: PCI INT A: failed to register GSI
        tulip: Cannot enable tulip board #0, aborting
        tulip: probe of 0000:00:0a.0 failed with error -16
      Errors occur in 3.19.0 kernel
      Works in 3.17 kernel.
    "
    
    According to the ACPI dump file posted by Nick at
    https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1440072
    
    The ACPI MADT table includes an interrupt source overridden entry for
    ACPI SCI:
    [236h 0566  1]                Subtable Type : 02 <Interrupt Source Override>
    [237h 0567  1]                       Length : 0A
    [238h 0568  1]                          Bus : 00
    [239h 0569  1]                       Source : 09
    [23Ah 0570  4]                    Interrupt : 00000009
    [23Eh 0574  2]        Flags (decoded below) : 000D
                                       Polarity : 1
                                   Trigger Mode : 3
    
    And in DSDT table, we have _PRT method to define PCI interrupts, which
    eventually goes to:
            Name (PRSA, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,7,9,10,11,12,14,15}
            })
            Name (PRSB, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,7,9,10,11,12,14,15}
            })
            Name (PRSC, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,7,9,10,11,12,14,15}
            })
            Name (PRSD, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,7,9,10,11,12,14,15}
            })
    
    According to the MADT and DSDT tables, IRQ 9 may be used for:
     1) ACPI SCI in level, high mode
     2) PCI legacy IRQ in level, low mode
    So there's a conflict in polarity setting for IRQ 9.
    
    Prior to commit cd68f6bd53cf ("x86, irq, acpi: Get rid of special
    handling of GSI for ACPI SCI"), ACPI SCI is handled specially and
    there's no check for conflicts between ACPI SCI and PCI legagy IRQ.
    And it seems that the HyperV hypervisor doesn't make use of the
    polarity configuration in IOAPIC entry, so it just works.
    
    Commit cd68f6bd53cf gets rid of the specially handling of ACPI SCI,
    and then the pin attribute checking code discloses the conflicts
    between ACPI SCI and PCI legacy IRQ on HyperV virtual machine,
    and rejects the request to assign IRQ9 to PCI devices.
    
    So penalize legacy IRQ used by ACPI SCI and mark it unusable if ACPI
    SCI attributes conflict with PCI IRQ attributes.
    
    Please refer to following links for more information:
    https://bugzilla.kernel.org/show_bug.cgi?id=101301
    https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1440072
    
    Fixes: cd68f6bd53cf ("x86, irq, acpi: Get rid of special handling of GSI for ACPI SCI")
    Reported-and-tested-by: Nick Meier <nmeier@microsoft.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: 3.19+ <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index cfd7581cc19f..b09ad554430a 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -825,6 +825,22 @@ void acpi_penalize_isa_irq(int irq, int active)
 	}
 }
 
+/*
+ * Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict with
+ * PCI IRQ attributes, mark ACPI SCI as ISA_ALWAYS so it won't be use for
+ * PCI IRQs.
+ */
+void acpi_penalize_sci_irq(int irq, int trigger, int polarity)
+{
+	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
+		if (trigger != ACPI_MADT_TRIGGER_LEVEL ||
+		    polarity != ACPI_MADT_POLARITY_ACTIVE_LOW)
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_ALWAYS;
+		else
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+	}
+}
+
 /*
  * Over-ride default table to reserve additional IRQs for use by ISA
  * e.g. acpi_irq_isa=5

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index cfd7581cc19f..2f5f84ced85f 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -17,10 +17,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  * TBD: 

commit 07070e12cf5cab46a783a4753f07bb99e557473b
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu Mar 13 12:47:39 2014 +0800

    ACPI: Remove duplicate definitions of PREFIX
    
    We already have a macro for PREFIX of "ACPI: " in
    drivers/acpi/internal.h, so remove the duplicate ones
    in ACPI drivers when internal.h is included.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 9418c7a1f786..cfd7581cc19f 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -43,8 +43,6 @@
 
 #include "internal.h"
 
-#define PREFIX "ACPI: "
-
 #define _COMPONENT			ACPI_PCI_COMPONENT
 ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"

commit c071b6040c442de247a537c977ea13f97b6df6f8
Author: Rashika <rashika.kheria@gmail.com>
Date:   Tue Dec 17 14:58:31 2013 +0530

    ACPI / PCI: Include appropriate header file in pci_link.c
    
    Includes appropriate header file internal.h in pci_link.c
    because function acpi_pci_link_init() has its prototype declaration in
    internal.h.
    
    This eliminates the following warning in pci_link.c:
    drivers/acpi/pci_link.c:874:13: warning: no previous prototype for ‘acpi_pci_link_init’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index ea6b8d16dcc8..9418c7a1f786 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -41,6 +41,8 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 
+#include "internal.h"
+
 #define PREFIX "ACPI: "
 
 #define _COMPONENT			ACPI_PCI_COMPONENT

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 2652a614deeb..ea6b8d16dcc8 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -39,9 +39,7 @@
 #include <linux/pci.h>
 #include <linux/mutex.h>
 #include <linux/slab.h>
-
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
 
 #define PREFIX "ACPI: "
 

commit f084dbb939070281be7c882db63a4a428c51fcf4
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Mar 23 19:16:37 2013 +0000

    ACPI: Set length even for TYPE_END_TAG acpi resource
    
    Found with a network device in QEMU/KVM guest not working anymore.
    
    Bisected to commit c13085e5
        ACPICA: Resource Mgr: Prevent infinite loops in resource walks
    
    That commit will check acpi_resource length strictly which causes
    acpi_set_current_resources to return failure and IRQ for PCI
    devices is not set properly.
    
    Set length for all those TYPE_END_TAG acpi_resources.
    
    [rjw: Changelog]
    Bisected-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index ab764ed34a50..2652a614deeb 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -354,6 +354,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 
 	}
 	resource->end.type = ACPI_RESOURCE_TYPE_END_TAG;
+	resource->end.length = sizeof(struct acpi_resource);
 
 	/* Attempt to set the resource */
 	status = acpi_set_current_resources(link->device->handle, &buffer);

commit 4daeaf68379f75dedd120582add5206c7c5ad72e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 30 14:27:37 2013 +0100

    ACPI / PCI: Make PCI IRQ link driver use struct acpi_scan_handler
    
    Make the ACPI PCI IRQ link driver use struct acpi_scan_handler
    for representing the object used to set up ACPI interrupt links and
    to remove data structures used for this purpose before unregistering
    the corresponding ACPI device nodes.
    
    This simplifies the code slightly and reduces the kernel's memory
    footprint by avoiding the registration of a struct device_driver
    object with the driver core and creation of its sysfs directory
    which is unnecessary.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index b6592797f5b2..ab764ed34a50 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -53,23 +53,19 @@ ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_FILE_STATUS	"state"
 #define ACPI_PCI_LINK_MAX_POSSIBLE	16
 
-static int acpi_pci_link_add(struct acpi_device *device);
-static int acpi_pci_link_remove(struct acpi_device *device);
+static int acpi_pci_link_add(struct acpi_device *device,
+			     const struct acpi_device_id *not_used);
+static void acpi_pci_link_remove(struct acpi_device *device);
 
 static const struct acpi_device_id link_device_ids[] = {
 	{"PNP0C0F", 0},
 	{"", 0},
 };
-MODULE_DEVICE_TABLE(acpi, link_device_ids);
 
-static struct acpi_driver acpi_pci_link_driver = {
-	.name = "pci_link",
-	.class = ACPI_PCI_LINK_CLASS,
+static struct acpi_scan_handler pci_link_handler = {
 	.ids = link_device_ids,
-	.ops = {
-		.add = acpi_pci_link_add,
-		.remove = acpi_pci_link_remove,
-	},
+	.attach = acpi_pci_link_add,
+	.detach = acpi_pci_link_remove,
 };
 
 /*
@@ -692,7 +688,8 @@ int acpi_pci_link_free_irq(acpi_handle handle)
                                  Driver Interface
    -------------------------------------------------------------------------- */
 
-static int acpi_pci_link_add(struct acpi_device *device)
+static int acpi_pci_link_add(struct acpi_device *device,
+			     const struct acpi_device_id *not_used)
 {
 	int result;
 	struct acpi_pci_link *link;
@@ -746,7 +743,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	if (result)
 		kfree(link);
 
-	return result;
+	return result < 0 ? result : 1;
 }
 
 static int acpi_pci_link_resume(struct acpi_pci_link *link)
@@ -766,7 +763,7 @@ static void irqrouter_resume(void)
 	}
 }
 
-static int acpi_pci_link_remove(struct acpi_device *device)
+static void acpi_pci_link_remove(struct acpi_device *device)
 {
 	struct acpi_pci_link *link;
 
@@ -777,7 +774,6 @@ static int acpi_pci_link_remove(struct acpi_device *device)
 	mutex_unlock(&acpi_link_lock);
 
 	kfree(link);
-	return 0;
 }
 
 /*
@@ -874,20 +870,10 @@ static struct syscore_ops irqrouter_syscore_ops = {
 	.resume = irqrouter_resume,
 };
 
-static int __init irqrouter_init_ops(void)
-{
-	if (!acpi_disabled && !acpi_noirq)
-		register_syscore_ops(&irqrouter_syscore_ops);
-
-	return 0;
-}
-
-device_initcall(irqrouter_init_ops);
-
-static int __init acpi_pci_link_init(void)
+void __init acpi_pci_link_init(void)
 {
 	if (acpi_noirq)
-		return 0;
+		return;
 
 	if (acpi_irq_balance == -1) {
 		/* no command line switch: enable balancing in IOAPIC mode */
@@ -896,11 +882,6 @@ static int __init acpi_pci_link_init(void)
 		else
 			acpi_irq_balance = 0;
 	}
-
-	if (acpi_bus_register_driver(&acpi_pci_link_driver) < 0)
-		return -ENODEV;
-
-	return 0;
+	register_syscore_ops(&irqrouter_syscore_ops);
+	acpi_scan_add_handler(&pci_link_handler);
 }
-
-subsys_initcall(acpi_pci_link_init);

commit 51fac8388a0325a43f0ae67453ece2c373e2ec28
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 00:24:48 2013 +0100

    ACPI: Remove useless type argument of driver .remove() operation
    
    The second argument of ACPI driver .remove() operation is only used
    by the ACPI processor driver and the value passed to that driver
    through it is always available from the given struct acpi_device
    object's removal_type field.  For this reason, the second ACPI driver
    .remove() argument is in fact useless, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jiang Liu <jiang.liu@huawei.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index a12808259dfb..b6592797f5b2 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -54,7 +54,7 @@ ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_MAX_POSSIBLE	16
 
 static int acpi_pci_link_add(struct acpi_device *device);
-static int acpi_pci_link_remove(struct acpi_device *device, int type);
+static int acpi_pci_link_remove(struct acpi_device *device);
 
 static const struct acpi_device_id link_device_ids[] = {
 	{"PNP0C0F", 0},
@@ -766,7 +766,7 @@ static void irqrouter_resume(void)
 	}
 }
 
-static int acpi_pci_link_remove(struct acpi_device *device, int type)
+static int acpi_pci_link_remove(struct acpi_device *device)
 {
 	struct acpi_pci_link *link;
 

commit be96447e0d49622fe00b07474f9a86805d389ca7
Author: Kay Sievers <kay@vrfy.org>
Date:   Tue May 8 17:24:20 2012 +0200

    acpi: use KERN_CONT in printk() continuation lines
    
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 4a29763b8eb4..a12808259dfb 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -720,21 +720,21 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	       acpi_device_bid(device));
 	for (i = 0; i < link->irq.possible_count; i++) {
 		if (link->irq.active == link->irq.possible[i]) {
-			printk(" *%d", link->irq.possible[i]);
+			printk(KERN_CONT " *%d", link->irq.possible[i]);
 			found = 1;
 		} else
-			printk(" %d", link->irq.possible[i]);
+			printk(KERN_CONT " %d", link->irq.possible[i]);
 	}
 
-	printk(")");
+	printk(KERN_CONT ")");
 
 	if (!found)
-		printk(" *%d", link->irq.active);
+		printk(KERN_CONT " *%d", link->irq.active);
 
 	if (!link->device->status.enabled)
-		printk(", disabled.");
+		printk(KERN_CONT ", disabled.");
 
-	printk("\n");
+	printk(KERN_CONT "\n");
 
 	list_add_tail(&link->list, &acpi_link_list);
 

commit c3146df2b735912eddd1d7c080c9377d5df0ae94
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Mar 12 22:16:51 2011 +0100

    ACPI: Use syscore_ops instead of sysdev class and sysdev
    
    ACPI uses a sysdev class and a sysdev for executing
    irqrouter_resume() before turning on interrupts on the boot CPU.
    However, since irqrouter_resume() ignores its argument, the entire
    mechanism may be replaced with a struct syscore_ops object which
    is considerably simpler.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 9ff80a7e9f6a..4a29763b8eb4 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -29,7 +29,7 @@
  *	   for IRQ management (e.g. start()->_SRS).
  */
 
-#include <linux/sysdev.h>
+#include <linux/syscore_ops.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -757,14 +757,13 @@ static int acpi_pci_link_resume(struct acpi_pci_link *link)
 	return 0;
 }
 
-static int irqrouter_resume(struct sys_device *dev)
+static void irqrouter_resume(void)
 {
 	struct acpi_pci_link *link;
 
 	list_for_each_entry(link, &acpi_link_list, list) {
 		acpi_pci_link_resume(link);
 	}
-	return 0;
 }
 
 static int acpi_pci_link_remove(struct acpi_device *device, int type)
@@ -871,32 +870,19 @@ static int __init acpi_irq_balance_set(char *str)
 
 __setup("acpi_irq_balance", acpi_irq_balance_set);
 
-/* FIXME: we will remove this interface after all drivers call pci_disable_device */
-static struct sysdev_class irqrouter_sysdev_class = {
-	.name = "irqrouter",
+static struct syscore_ops irqrouter_syscore_ops = {
 	.resume = irqrouter_resume,
 };
 
-static struct sys_device device_irqrouter = {
-	.id = 0,
-	.cls = &irqrouter_sysdev_class,
-};
-
-static int __init irqrouter_init_sysfs(void)
+static int __init irqrouter_init_ops(void)
 {
-	int error;
+	if (!acpi_disabled && !acpi_noirq)
+		register_syscore_ops(&irqrouter_syscore_ops);
 
-	if (acpi_disabled || acpi_noirq)
-		return 0;
-
-	error = sysdev_class_register(&irqrouter_sysdev_class);
-	if (!error)
-		error = sysdev_register(&device_irqrouter);
-
-	return error;
+	return 0;
 }
 
-device_initcall(irqrouter_init_sysfs);
+device_initcall(irqrouter_init_ops);
 
 static int __init acpi_pci_link_init(void)
 {

commit 03e7c3432d40d067476eaf49ede29128b637998f
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Oct 8 13:55:17 2010 +0800

    ACPI: remove unused declaration of proc_fs.h
    
    Remove unused declaration of proc_fs.h.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 8d47a5846aeb..9ff80a7e9f6a 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -34,7 +34,6 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
-#include <linux/proc_fs.h>
 #include <linux/spinlock.h>
 #include <linux/pm.h>
 #include <linux/pci.h>

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 04b0f007c9b7..8d47a5846aeb 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -39,6 +39,7 @@
 #include <linux/pm.h>
 #include <linux/pci.h>
 #include <linux/mutex.h>
+#include <linux/slab.h>
 
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>

commit c97adf9e7bebf17a86b95e2131bf9ba76c4857c7
Author: Márton Németh <nm127@freemail.hu>
Date:   Sun Jan 10 17:15:36 2010 +0100

    acpi: make ACPI device id constant
    
    The ids field of the struct acpi_driver is constant in <linux/acpi/acpi_bus.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Márton Németh <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 394ae89409c2..04b0f007c9b7 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -56,7 +56,7 @@ ACPI_MODULE_NAME("pci_link");
 static int acpi_pci_link_add(struct acpi_device *device);
 static int acpi_pci_link_remove(struct acpi_device *device, int type);
 
-static struct acpi_device_id link_device_ids[] = {
+static const struct acpi_device_id link_device_ids[] = {
 	{"PNP0C0F", 0},
 	{"", 0},
 };

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 16e0f9d3d17c..394ae89409c2 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -43,6 +43,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#define PREFIX "ACPI: "
+
 #define _COMPONENT			ACPI_PCI_COMPONENT
 ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"

commit 5f0dccaa81e239477413d0def1133850530f1bbe
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 17 14:00:55 2009 -0700

    ACPI: pci_link: simplify list of link devices
    
    We don't need a struct containing a count and a list_head; a simple
    list_head is sufficient.  The list iterators handle empty lists
    fine.
    
    Furthermore, we don't need to check for null list entries because we
    only add non-null entries.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index dd9ebb9fda42..16e0f9d3d17c 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -86,16 +86,13 @@ struct acpi_pci_link_irq {
 };
 
 struct acpi_pci_link {
-	struct list_head		node;
+	struct list_head		list;
 	struct acpi_device		*device;
 	struct acpi_pci_link_irq	irq;
 	int				refcnt;
 };
 
-static struct {
-	int			count;
-	struct list_head	entries;
-} acpi_link;
+static LIST_HEAD(acpi_link_list);
 static DEFINE_MUTEX(acpi_link_lock);
 
 /* --------------------------------------------------------------------------
@@ -479,19 +476,13 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 
 int __init acpi_irq_penalty_init(void)
 {
-	struct list_head *node;
 	struct acpi_pci_link *link;
 	int i;
 
 	/*
 	 * Update penalties to facilitate IRQ balancing.
 	 */
-	list_for_each(node, &acpi_link.entries) {
-		link = list_entry(node, struct acpi_pci_link, node);
-		if (!link) {
-			printk(KERN_ERR PREFIX "Invalid link context\n");
-			continue;
-		}
+	list_for_each_entry(link, &acpi_link_list, list) {
 
 		/*
 		 * reflect the possible and active irqs in the penalty table --
@@ -743,9 +734,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
 
 	printk("\n");
 
-	/* TBD: Acquire/release lock */
-	list_add_tail(&link->node, &acpi_link.entries);
-	acpi_link.count++;
+	list_add_tail(&link->list, &acpi_link_list);
 
       end:
 	/* disable all links -- to be activated on use */
@@ -768,15 +757,9 @@ static int acpi_pci_link_resume(struct acpi_pci_link *link)
 
 static int irqrouter_resume(struct sys_device *dev)
 {
-	struct list_head *node;
 	struct acpi_pci_link *link;
 
-	list_for_each(node, &acpi_link.entries) {
-		link = list_entry(node, struct acpi_pci_link, node);
-		if (!link) {
-			printk(KERN_ERR PREFIX "Invalid link context\n");
-			continue;
-		}
+	list_for_each_entry(link, &acpi_link_list, list) {
 		acpi_pci_link_resume(link);
 	}
 	return 0;
@@ -789,7 +772,7 @@ static int acpi_pci_link_remove(struct acpi_device *device, int type)
 	link = acpi_driver_data(device);
 
 	mutex_lock(&acpi_link_lock);
-	list_del(&link->node);
+	list_del(&link->list);
 	mutex_unlock(&acpi_link_lock);
 
 	kfree(link);
@@ -926,9 +909,6 @@ static int __init acpi_pci_link_init(void)
 			acpi_irq_balance = 0;
 	}
 
-	acpi_link.count = 0;
-	INIT_LIST_HEAD(&acpi_link.entries);
-
 	if (acpi_bus_register_driver(&acpi_pci_link_driver) < 0)
 		return -ENODEV;
 

commit 6eca4b4ca168981d7648be371945c2a21f463a45
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 17 14:00:50 2009 -0700

    ACPI: pci_link: remove unnecessary null pointer checks
    
    Better to oops and learn about a bug than to silently cover it up.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index b59f59efb72f..dd9ebb9fda42 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -179,9 +179,6 @@ static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 {
 	acpi_status status;
 
-	if (!link)
-		return -EINVAL;
-
 	status = acpi_walk_resources(link->device->handle, METHOD_NAME__PRS,
 				     acpi_pci_link_check_possible, link);
 	if (ACPI_FAILURE(status)) {
@@ -259,9 +256,6 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 	acpi_status status;
 	int irq = 0;
 
-	if (!link)
-		return -EINVAL;
-
 	link->irq.active = 0;
 
 	/* in practice, status disabled is meaningless, ignore it */
@@ -314,7 +308,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	} *resource;
 	struct acpi_buffer buffer = { 0, NULL };
 
-	if (!link || !irq)
+	if (!irq)
 		return -EINVAL;
 
 	resource = kzalloc(sizeof(*resource) + 1, irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
@@ -712,9 +706,6 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	int i;
 	int found = 0;
 
-	if (!device)
-		return -EINVAL;
-
 	link = kzalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
 	if (!link)
 		return -ENOMEM;
@@ -795,9 +786,6 @@ static int acpi_pci_link_remove(struct acpi_device *device, int type)
 {
 	struct acpi_pci_link *link;
 
-	if (!device || !acpi_driver_data(device))
-		return -EINVAL;
-
 	link = acpi_driver_data(device);
 
 	mutex_lock(&acpi_link_lock);

commit c9d6244329c8149312dba27e78dc4a83b35a6ae5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 17 14:00:45 2009 -0700

    ACPI: pci_link: remove unnecessary casts and initializations
    
    Remove unnecessary casts and initializations.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 19bc3bcda602..b59f59efb72f 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -109,7 +109,7 @@ static acpi_status acpi_pci_link_check_possible(struct acpi_resource *resource,
 						void *context)
 {
 	struct acpi_pci_link *link = context;
-	u32 i = 0;
+	u32 i;
 
 	switch (resource->type) {
 	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
@@ -199,7 +199,7 @@ static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 static acpi_status acpi_pci_link_check_current(struct acpi_resource *resource,
 					       void *context)
 {
-	int *irq = (int *)context;
+	int *irq = context;
 
 	switch (resource->type) {
 	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
@@ -256,7 +256,7 @@ static acpi_status acpi_pci_link_check_current(struct acpi_resource *resource,
 static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 {
 	int result = 0;
-	acpi_status status = AE_OK;
+	acpi_status status;
 	int irq = 0;
 
 	if (!link)
@@ -306,8 +306,8 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 
 static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 {
-	int result = 0;
-	acpi_status status = AE_OK;
+	int result;
+	acpi_status status;
 	struct {
 		struct acpi_resource res;
 		struct acpi_resource end;
@@ -485,9 +485,9 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 
 int __init acpi_irq_penalty_init(void)
 {
-	struct list_head *node = NULL;
-	struct acpi_pci_link *link = NULL;
-	int i = 0;
+	struct list_head *node;
+	struct acpi_pci_link *link;
+	int i;
 
 	/*
 	 * Update penalties to facilitate IRQ balancing.
@@ -602,9 +602,9 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 int acpi_pci_link_allocate_irq(acpi_handle handle, int index, int *triggering,
 			       int *polarity, char **name)
 {
-	int result = 0;
-	struct acpi_device *device = NULL;
-	struct acpi_pci_link *link = NULL;
+	int result;
+	struct acpi_device *device;
+	struct acpi_pci_link *link;
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
@@ -656,8 +656,8 @@ int acpi_pci_link_allocate_irq(acpi_handle handle, int index, int *triggering,
  */
 int acpi_pci_link_free_irq(acpi_handle handle)
 {
-	struct acpi_device *device = NULL;
-	struct acpi_pci_link *link = NULL;
+	struct acpi_device *device;
+	struct acpi_pci_link *link;
 	acpi_status result;
 
 	result = acpi_bus_get_device(handle, &device);
@@ -707,9 +707,9 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 
 static int acpi_pci_link_add(struct acpi_device *device)
 {
-	int result = 0;
-	struct acpi_pci_link *link = NULL;
-	int i = 0;
+	int result;
+	struct acpi_pci_link *link;
+	int i;
 	int found = 0;
 
 	if (!device)
@@ -777,8 +777,8 @@ static int acpi_pci_link_resume(struct acpi_pci_link *link)
 
 static int irqrouter_resume(struct sys_device *dev)
 {
-	struct list_head *node = NULL;
-	struct acpi_pci_link *link = NULL;
+	struct list_head *node;
+	struct acpi_pci_link *link;
 
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
@@ -793,7 +793,7 @@ static int irqrouter_resume(struct sys_device *dev)
 
 static int acpi_pci_link_remove(struct acpi_device *device, int type)
 {
-	struct acpi_pci_link *link = NULL;
+	struct acpi_pci_link *link;
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;

commit 1c9ca3a7d41b5db884033900b539b9aeb61a399e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 17 14:00:40 2009 -0700

    ACPI: pci_link: clean up whitespace
    
    This patch makes whitespace and indentation more consistent.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 6c772ca76bd1..19bc3bcda602 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -43,13 +43,14 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-#define _COMPONENT		ACPI_PCI_COMPONENT
+#define _COMPONENT			ACPI_PCI_COMPONENT
 ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
 #define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
 #define ACPI_PCI_LINK_FILE_INFO		"info"
 #define ACPI_PCI_LINK_FILE_STATUS	"state"
-#define ACPI_PCI_LINK_MAX_POSSIBLE 16
+#define ACPI_PCI_LINK_MAX_POSSIBLE	16
+
 static int acpi_pci_link_add(struct acpi_device *device);
 static int acpi_pci_link_remove(struct acpi_device *device, int type);
 
@@ -66,7 +67,7 @@ static struct acpi_driver acpi_pci_link_driver = {
 	.ops = {
 		.add = acpi_pci_link_add,
 		.remove = acpi_pci_link_remove,
-		},
+	},
 };
 
 /*
@@ -76,7 +77,7 @@ static struct acpi_driver acpi_pci_link_driver = {
 struct acpi_pci_link_irq {
 	u8 active;		/* Current IRQ */
 	u8 triggering;		/* All IRQs */
-	u8 polarity;	/* All IRQs */
+	u8 polarity;		/* All IRQs */
 	u8 resource_type;
 	u8 possible_count;
 	u8 possible[ACPI_PCI_LINK_MAX_POSSIBLE];
@@ -85,15 +86,15 @@ struct acpi_pci_link_irq {
 };
 
 struct acpi_pci_link {
-	struct list_head node;
-	struct acpi_device *device;
-	struct acpi_pci_link_irq irq;
-	int refcnt;
+	struct list_head		node;
+	struct acpi_device		*device;
+	struct acpi_pci_link_irq	irq;
+	int				refcnt;
 };
 
 static struct {
-	int count;
-	struct list_head entries;
+	int			count;
+	struct list_head	entries;
 } acpi_link;
 static DEFINE_MUTEX(acpi_link_lock);
 
@@ -104,13 +105,12 @@ static DEFINE_MUTEX(acpi_link_lock);
 /*
  * set context (link) possible list from resource list
  */
-static acpi_status
-acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
+static acpi_status acpi_pci_link_check_possible(struct acpi_resource *resource,
+						void *context)
 {
 	struct acpi_pci_link *link = context;
 	u32 i = 0;
 
-
 	switch (resource->type) {
 	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
 	case ACPI_RESOURCE_TYPE_END_TAG:
@@ -179,7 +179,6 @@ static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 {
 	acpi_status status;
 
-
 	if (!link)
 		return -EINVAL;
 
@@ -197,12 +196,11 @@ static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 	return 0;
 }
 
-static acpi_status
-acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
+static acpi_status acpi_pci_link_check_current(struct acpi_resource *resource,
+					       void *context)
 {
 	int *irq = (int *)context;
 
-
 	switch (resource->type) {
 	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
 	case ACPI_RESOURCE_TYPE_END_TAG:
@@ -316,7 +314,6 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	} *resource;
 	struct acpi_buffer buffer = { 0, NULL };
 
-
 	if (!link || !irq)
 		return -EINVAL;
 
@@ -479,10 +476,10 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ9  PCI, often acpi */
 	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ10 PCI */
 	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ11 PCI */
-	PIRQ_PENALTY_ISA_USED,	/* IRQ12 mouse */
-	PIRQ_PENALTY_ISA_USED,	/* IRQ13 fpe, sometimes */
-	PIRQ_PENALTY_ISA_USED,	/* IRQ14 ide0 */
-	PIRQ_PENALTY_ISA_USED,	/* IRQ15 ide1 */
+	PIRQ_PENALTY_ISA_USED,		/* IRQ12 mouse */
+	PIRQ_PENALTY_ISA_USED,		/* IRQ13 fpe, sometimes */
+	PIRQ_PENALTY_ISA_USED,		/* IRQ14 ide0 */
+	PIRQ_PENALTY_ISA_USED,		/* IRQ15 ide1 */
 	/* >IRQ15 */
 };
 
@@ -492,12 +489,10 @@ int __init acpi_irq_penalty_init(void)
 	struct acpi_pci_link *link = NULL;
 	int i = 0;
 
-
 	/*
 	 * Update penalties to facilitate IRQ balancing.
 	 */
 	list_for_each(node, &acpi_link.entries) {
-
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
 			printk(KERN_ERR PREFIX "Invalid link context\n");
@@ -527,7 +522,6 @@ int __init acpi_irq_penalty_init(void)
 	}
 	/* Add a penalty for the SCI */
 	acpi_irq_penalty[acpi_gbl_FADT.sci_interrupt] += PIRQ_PENALTY_PCI_USING;
-
 	return 0;
 }
 
@@ -538,7 +532,6 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 	int irq;
 	int i;
 
-
 	if (link->irq.initialized) {
 		if (link->refcnt == 0)
 			/* This means the link is disabled but initialized */
@@ -566,11 +559,10 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 	/*
 	 * if active found, use it; else pick entry from end of possible list.
 	 */
-	if (link->irq.active) {
+	if (link->irq.active)
 		irq = link->irq.active;
-	} else {
+	else
 		irq = link->irq.possible[link->irq.possible_count - 1];
-	}
 
 	if (acpi_irq_balance || !link->irq.active) {
 		/*
@@ -599,7 +591,6 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 	}
 
 	link->irq.initialized = 1;
-
 	return 0;
 }
 
@@ -608,17 +599,13 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
  * success: return IRQ >= 0
  * failure: return -1
  */
-
-int
-acpi_pci_link_allocate_irq(acpi_handle handle,
-			   int index,
-			   int *triggering, int *polarity, char **name)
+int acpi_pci_link_allocate_irq(acpi_handle handle, int index, int *triggering,
+			       int *polarity, char **name)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
 	struct acpi_pci_link *link = NULL;
 
-
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
 		printk(KERN_ERR PREFIX "Invalid link device\n");
@@ -673,7 +660,6 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 	struct acpi_pci_link *link = NULL;
 	acpi_status result;
 
-
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
 		printk(KERN_ERR PREFIX "Invalid link device\n");
@@ -708,9 +694,9 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 			  "Link %s is dereferenced\n",
 			  acpi_device_bid(link->device)));
 
-	if (link->refcnt == 0) {
+	if (link->refcnt == 0)
 		acpi_evaluate_object(link->device->handle, "_DIS", NULL, NULL);
-	}
+
 	mutex_unlock(&acpi_link_lock);
 	return (link->irq.active);
 }
@@ -726,7 +712,6 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	int i = 0;
 	int found = 0;
 
-
 	if (!device)
 		return -EINVAL;
 
@@ -784,11 +769,10 @@ static int acpi_pci_link_add(struct acpi_device *device)
 
 static int acpi_pci_link_resume(struct acpi_pci_link *link)
 {
-
 	if (link->refcnt && link->irq.active && link->irq.initialized)
 		return (acpi_pci_link_set(link, link->irq.active));
-	else
-		return 0;
+
+	return 0;
 }
 
 static int irqrouter_resume(struct sys_device *dev)
@@ -811,7 +795,6 @@ static int acpi_pci_link_remove(struct acpi_device *device, int type)
 {
 	struct acpi_pci_link *link = NULL;
 
-
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
@@ -822,7 +805,6 @@ static int acpi_pci_link_remove(struct acpi_device *device, int type)
 	mutex_unlock(&acpi_link_lock);
 
 	kfree(link);
-
 	return 0;
 }
 
@@ -931,7 +913,6 @@ static int __init irqrouter_init_sysfs(void)
 {
 	int error;
 
-
 	if (acpi_disabled || acpi_noirq)
 		return 0;
 

commit 4d9391557b68475b118ec7626607c37b14ae8c16
Author: Frank Seidel <frank@f-seidel.de>
Date:   Wed Feb 4 17:03:07 2009 +0100

    ACPI: add missing KERN_* constants to printks
    
    According to kerneljanitors todo list all printk calls (beginning
    a new line) should have an according KERN_* constant.
    Those are the missing peaces here for the acpi subsystem.
    
    Signed-off-by: Frank Seidel <frank@f-seidel.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 1c6e73c7865e..6c772ca76bd1 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -593,7 +593,7 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 		return -ENODEV;
 	} else {
 		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
-		printk(PREFIX "%s [%s] enabled at IRQ %d\n",
+		printk(KERN_WARNING PREFIX "%s [%s] enabled at IRQ %d\n",
 		       acpi_device_name(link->device),
 		       acpi_device_bid(link->device), link->irq.active);
 	}

commit d0302bc62af7983040ea1cd1b5dd2b36e1a6a509
Merge: 106ad8d6b0a7 237889bf0a62
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 03:37:48 2009 -0500

    Merge branch 'misc' into release
    
    Conflicts:
            include/acpi/acpixf.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 8a383ef0be01e0e6e84c85f8bf35e4e6fcfb8981
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Tue Dec 9 20:45:30 2008 +0100

    ACPI: ec.c, pci_link.c, video_detec.c: static
    
    Sparse asked whether these could be static.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index e52ad91ce2dc..4869fa1b7892 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -912,7 +912,7 @@ static int __init acpi_irq_nobalance_set(char *str)
 
 __setup("acpi_irq_nobalance", acpi_irq_nobalance_set);
 
-int __init acpi_irq_balance_set(char *str)
+static int __init acpi_irq_balance_set(char *str)
 {
 	acpi_irq_balance = 1;
 	return 1;

commit 11e93130c7ce5228d484fd5e86f3984835d4256b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Dec 29 19:19:07 2008 +0100

    ACPI: Do not modify SCI_EN directly
    
    According to the ACPI specification the SCI_EN flag is controlled by
    the hardware, which sets this flag to inform the kernel that ACPI is
    enabled.  For this reason, we shouldn't try to modify SCI_EN
    directly.  Also, we don't need to do it in irqrouter_resume(), since
    lower-level resume code takes care of enabling ACPI in case it hasn't
    been enabled by the BIOS before passing control to the kernel (which
    by the way is against the ACPI specification).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index e52ad91ce2dc..e33c0bc78fa8 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -796,10 +796,6 @@ static int irqrouter_resume(struct sys_device *dev)
 	struct list_head *node = NULL;
 	struct acpi_pci_link *link = NULL;
 
-
-	/* Make sure SCI is enabled again (Apple firmware bug?) */
-	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1);
-
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {

commit 32836259ff25ce97010569706cd33ba94de81d62
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 5 16:17:52 2008 -0700

    ACPI: pci_link: remove acpi_irq_balance_set() interface
    
    This removes the acpi_irq_balance_set() interface from the PCI
    interrupt link driver.
    
    x86 used acpi_irq_balance_set() to tell the PCI interrupt link
    driver to configure links to minimize IRQ sharing.  But the link
    driver can easily figure out whether to turn on IRQ balancing
    based on the IRQ model (PIC/IOAPIC/etc), so we can get rid of
    that external interface.
    
    It's better for the driver to figure this out at init-time.  If
    we set it externally via the x86 code, the interface reduces
    modularity, and we depend on the fact that acpi_process_madt()
    happens before we process the kernel command line.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index fcfdef7b4fdd..e52ad91ce2dc 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -531,7 +531,7 @@ int __init acpi_irq_penalty_init(void)
 	return 0;
 }
 
-static int acpi_irq_balance;	/* 0: static, 1: balance */
+static int acpi_irq_balance = -1;	/* 0: static, 1: balance */
 
 static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 {
@@ -950,10 +950,17 @@ device_initcall(irqrouter_init_sysfs);
 
 static int __init acpi_pci_link_init(void)
 {
-
 	if (acpi_noirq)
 		return 0;
 
+	if (acpi_irq_balance == -1) {
+		/* no command line switch: enable balancing in IOAPIC mode */
+		if (acpi_irq_model == ACPI_IRQ_MODEL_IOAPIC)
+			acpi_irq_balance = 1;
+		else
+			acpi_irq_balance = 0;
+	}
+
 	acpi_link.count = 0;
 	INIT_LIST_HEAD(&acpi_link.entries);
 

commit 5f50ef453dcb05115fc98f244b8f10bfacd4b8b7
Merge: 530bc23bfeaa e3deda9c87ac
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:28:38 2008 -0400

    Merge branch 'misc' into test

commit 383d7a11c9989205db44c7f1be339e5097062f03
Author: donald.d.dugger@intel.com <donald.d.dugger@intel.com>
Date:   Fri Oct 17 07:49:50 2008 -0700

    ACPI: Fix possible null ptr dereference
    
    Code in `pci_link.c' is calling the internal routine `acpi_ut_evaluate_object'
    which is dangerous given that it is passing a NULL pointer when it should
    be passing a pointer to a real object.  The patch corrects the issue by
    having the code call the external routine `acpi_evaluate_object', which
    correctly handles a NULL pointer.
    
    Signed-off-by: Don Dugger <donald.d.dugger@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index cf47805a7448..65bf4fa59633 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -709,7 +709,7 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 			  acpi_device_bid(link->device)));
 
 	if (link->refcnt == 0) {
-		acpi_ut_evaluate_object(link->device->handle, "_DIS", 0, NULL);
+		acpi_evaluate_object(link->device->handle, "_DIS", NULL, NULL);
 	}
 	mutex_unlock(&acpi_link_lock);
 	return (link->irq.active);
@@ -773,7 +773,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
 
       end:
 	/* disable all links -- to be activated on use */
-	acpi_ut_evaluate_object(device->handle, "_DIS", 0, NULL);
+	acpi_evaluate_object(device->handle, "_DIS", NULL, NULL);
 	mutex_unlock(&acpi_link_lock);
 
 	if (result)

commit db89b4f0dbab837d0f3de2c3e9427a8d5393afa3
Author: Pavel Machek <pavel@suse.cz>
Date:   Mon Sep 22 14:37:34 2008 -0700

    ACPI: catch calls of acpi_driver_data on pointer of wrong type
    
    Catch attempts to use of acpi_driver_data on pointers of wrong type.
    
    akpm: rewritten to use proper C typechecking and remove the
    "function"-used-as-lvalue thing.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index cf47805a7448..54cd77a0a78e 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -737,7 +737,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	link->device = device;
 	strcpy(acpi_device_name(device), ACPI_PCI_LINK_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);
-	acpi_driver_data(device) = link;
+	device->driver_data = link;
 
 	mutex_lock(&acpi_link_lock);
 	result = acpi_pci_link_get_possible(link);

commit fa46d3526461e8aa7c0fb39cc1b98ac656695a43
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Aug 1 15:58:17 2008 -0600

    ACPI: bounds check IRQ to prevent memory corruption
    
    acpi_penalize_isa_irq() should validate irq before using it to
    index the acpi_irq_penalty[] table.
    
    Here's the path I'm concerned about:
    
        pnpacpi_parse_allocated_irqresource()
        {
            ...
            irq = acpi_register_gsi(gsi, triggering, polarity);
            if (irq >= 0)
                    pcibios_penalize_isa_irq(irq, 1);
    
    There's no guarantee that acpi_register_gsi() will return an IRQ
    within the bounds of acpi_irq_penalty[].
    
    I have not seen a failure I can attribute to this.  However,
    ACPI_MAX_IRQS is only 256, and I'm pretty sure ia64 can have
    IRQs larger than that.
    
    I think this should go in 2.6.27.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 89f3b2abfdc7..cf47805a7448 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -849,7 +849,7 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 		if (irq < 0)
 			continue;
 
-		if (irq >= ACPI_MAX_IRQS)
+		if (irq >= ARRAY_SIZE(acpi_irq_penalty))
 			continue;
 
 		if (used)
@@ -872,10 +872,12 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  */
 void acpi_penalize_isa_irq(int irq, int active)
 {
-	if (active)
-		acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
-	else
-		acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+	if (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {
+		if (active)
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
+		else
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+	}
 }
 
 /*

commit 4a5e3638b11978262ab76bbb2062e57fefaaedba
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Jul 15 09:42:57 2008 -0600

    ACPI: stop complaints about interrupt link End Tags and blank IRQ descriptors
    
    Silently ignore _PRS End Tags.  We already ignore Start Dependent Functions in
    _PRS, and we already ignore End Tags in _CRS, so we might as well ignore End
    Tags in _PRS as well.
    
    Silently ignore _PRS IRQ descriptors that mention no interrupts.  The spec
    allows this (section 6.4.2.1 in ACPI 3.0b spec), and it probably means the
    interrupt link can't be configured at all.
    
    This patch doesn't change any functional behavior; it just removes confusing
    complaints like these:
    
        ACPI: Blank IRQ resource
        ACPI: Resource is not an IRQ entry
    
    when parsing _PRS data "23 00 00 18 79 00" from an IBM xSeries 335 dual
    Pentium IV Xeon 2.40 GHz machine.  For more details, see
        http://bugzilla.kernel.org/show_bug.cgi?id=11049
    
    The "23 00 00 18" part is a three-byte-long small IRQ resource with no bits set
    in the IRQ mask ("00 00"), and level-triggered, active low, shareable ("18").
    
    The "79 00" is an End Tag (type 0x7).  It is superfluous since there is no
    Start Dependent Function tag and there are no resources after it, but it is
    harmless.
    
    Thanks to Gabriele Trombetti <g.trombetti.lkrnl1213@logicschema.com>
    (aka Kurk) for reporting this and testing the patch.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 233c40c51684..89f3b2abfdc7 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -113,20 +113,23 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 
 	switch (resource->type) {
 	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
+	case ACPI_RESOURCE_TYPE_END_TAG:
 		return AE_OK;
 	case ACPI_RESOURCE_TYPE_IRQ:
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
 			if (!p || !p->interrupt_count) {
-				printk(KERN_WARNING PREFIX "Blank IRQ resource\n");
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+						  "Blank _PRS IRQ resource\n"));
 				return AE_OK;
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
-					printk(KERN_WARNING PREFIX "Invalid IRQ %d\n",
-						      p->interrupts[i]);
+					printk(KERN_WARNING PREFIX
+					       "Invalid _PRS IRQ %d\n",
+					       p->interrupts[i]);
 					continue;
 				}
 				link->irq.possible[i] = p->interrupts[i];
@@ -143,15 +146,16 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 			    &resource->data.extended_irq;
 			if (!p || !p->interrupt_count) {
 				printk(KERN_WARNING PREFIX
-					      "Blank EXT IRQ resource\n");
+					      "Blank _PRS EXT IRQ resource\n");
 				return AE_OK;
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
-					printk(KERN_WARNING PREFIX "Invalid IRQ %d\n",
-						      p->interrupts[i]);
+					printk(KERN_WARNING PREFIX
+					       "Invalid _PRS IRQ %d\n",
+					       p->interrupts[i]);
 					continue;
 				}
 				link->irq.possible[i] = p->interrupts[i];
@@ -163,7 +167,8 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 			break;
 		}
 	default:
-		printk(KERN_ERR PREFIX "Resource is not an IRQ entry\n");
+		printk(KERN_ERR PREFIX "_PRS resource type 0x%x isn't an IRQ\n",
+		       resource->type);
 		return AE_OK;
 	}
 
@@ -199,6 +204,9 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 
 
 	switch (resource->type) {
+	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
+	case ACPI_RESOURCE_TYPE_END_TAG:
+		return AE_OK;
 	case ACPI_RESOURCE_TYPE_IRQ:
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
@@ -208,7 +216,7 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 				 * particularly those those w/ _STA disabled
 				 */
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-						  "Blank IRQ resource\n"));
+						  "Blank _CRS IRQ resource\n"));
 				return AE_OK;
 			}
 			*irq = p->interrupts[0];
@@ -224,7 +232,7 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 				 * return at least 1 IRQ
 				 */
 				printk(KERN_WARNING PREFIX
-					      "Blank EXT IRQ resource\n");
+					      "Blank _CRS EXT IRQ resource\n");
 				return AE_OK;
 			}
 			*irq = p->interrupts[0];
@@ -232,10 +240,11 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 		}
 		break;
 	default:
-		printk(KERN_ERR PREFIX "Resource %d isn't an IRQ\n", resource->type);
-	case ACPI_RESOURCE_TYPE_END_TAG:
+		printk(KERN_ERR PREFIX "_CRS resource type 0x%x isn't an IRQ\n",
+		       resource->type);
 		return AE_OK;
 	}
+
 	return AE_CTRL_TERMINATE;
 }
 

commit e5685b9d35c2cc0a98425b05df30cb837dd1e632
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:24:42 2007 +0200

    ACPI: misc cleanups
    
        This patch contains the following possible cleanups:
        - make the following needlessly global code static:
          - drivers/acpi/bay.c:dev_attr_eject
          - drivers/acpi/bay.c:dev_attr_present
          - drivers/acpi/dock.c:dev_attr_docked
          - drivers/acpi/dock.c:dev_attr_flags
          - drivers/acpi/dock.c:dev_attr_uid
          - drivers/acpi/dock.c:dev_attr_undock
          - drivers/acpi/pci_bind.c:acpi_pci_unbind()
          - drivers/acpi/pci_link.c:acpi_link_lock
          - drivers/acpi/sbs.c:acpi_sbs_callback()
          - drivers/acpi/sbshc.c:acpi_smbus_transaction()
          - drivers/acpi/sleep/main.c:acpi_sleep_prepare()
        - #if 0 the following unused global functions:
          - drivers/acpi/numa.c:acpi_unmap_pxm_to_node()
        - remove the following unused EXPORT_SYMBOL's:
          - acpi_register_gsi
          - acpi_unregister_gsi
          - acpi_strict
          - acpi_bus_receive_event
          - register_acpi_bus_type
          - unregister_acpi_bus_type
          - acpi_os_printf
          - acpi_os_sleep
          - acpi_os_stall
          - acpi_os_read_pci_configuration
          - acpi_os_create_semaphore
          - acpi_os_delete_semaphore
          - acpi_os_wait_semaphore
          - acpi_os_signal_semaphore
          - acpi_os_signal
          - acpi_pci_irq_enable
          - acpi_get_pxm
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 5400ea173f6f..233c40c51684 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -95,7 +95,7 @@ static struct {
 	int count;
 	struct list_head entries;
 } acpi_link;
-DEFINE_MUTEX(acpi_link_lock);
+static DEFINE_MUTEX(acpi_link_lock);
 
 /* --------------------------------------------------------------------------
                             PCI Link Device Management

commit af5ca3f4ec5cc4432a42a73b050dd8898ce8fd00
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Dec 20 02:09:39 2007 +0100

    Driver core: change sysdev classes to use dynamic kobject names
    
    All kobjects require a dynamically allocated name now. We no longer
    need to keep track if the name is statically assigned, we can just
    unconditionally free() all kobject names on cleanup.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index c9f526e55392..5400ea173f6f 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -911,7 +911,7 @@ __setup("acpi_irq_balance", acpi_irq_balance_set);
 
 /* FIXME: we will remove this interface after all drivers call pci_disable_device */
 static struct sysdev_class irqrouter_sysdev_class = {
-	set_kset_name("irqrouter"),
+	.name = "irqrouter",
 	.resume = irqrouter_resume,
 };
 

commit 1ba90e3a87c46500623afdc3898573e4a5ebb21b
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 23 14:44:41 2007 +0200

    ACPI: autoload modules - Create __mod_acpi_device_table symbol for all ACPI drivers
    
    modpost is going to use these to create e.g. acpi:ACPI0001
    in modules.alias.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 3448edd61dc4..c9f526e55392 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -46,7 +46,6 @@
 #define _COMPONENT		ACPI_PCI_COMPONENT
 ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
-#define ACPI_PCI_LINK_HID		"PNP0C0F"
 #define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
 #define ACPI_PCI_LINK_FILE_INFO		"info"
 #define ACPI_PCI_LINK_FILE_STATUS	"state"
@@ -54,10 +53,16 @@ ACPI_MODULE_NAME("pci_link");
 static int acpi_pci_link_add(struct acpi_device *device);
 static int acpi_pci_link_remove(struct acpi_device *device, int type);
 
+static struct acpi_device_id link_device_ids[] = {
+	{"PNP0C0F", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, link_device_ids);
+
 static struct acpi_driver acpi_pci_link_driver = {
 	.name = "pci_link",
 	.class = ACPI_PCI_LINK_CLASS,
-	.ids = ACPI_PCI_LINK_HID,
+	.ids = link_device_ids,
 	.ops = {
 		.add = acpi_pci_link_add,
 		.remove = acpi_pci_link_remove,

commit 0dc070bb0242481a6100c95e5deaa07b267399a8
Author: Dan Aloni <da-x@monatomic.org>
Date:   Mon Jul 9 11:33:18 2007 -0700

    ACPI: drivers/acpi/pci_link.c: lower printk severity
    
    Signed-off-by: Dan Aloni <da-x@monatomic.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index acc594771379..3448edd61dc4 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -733,7 +733,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	/* query and set link->irq.active */
 	acpi_pci_link_get_current(link);
 
-	printk(PREFIX "%s [%s] (IRQs", acpi_device_name(device),
+	printk(KERN_INFO PREFIX "%s [%s] (IRQs", acpi_device_name(device),
 	       acpi_device_bid(device));
 	for (i = 0; i < link->irq.possible_count; i++) {
 		if (link->irq.active == link->irq.possible[i]) {

commit 7cda93e008e1a477970adbf82dba81a5d4f0ae40
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:50:02 2007 -0500

    ACPI: delete extra #defines in /drivers/acpi/ drivers
    
    Cosmetic only.
    
    Except in a single case, #define ACPI_*_DRIVER_NAME
    were invoked 0 or 1 times.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index a95f03fa03b4..acc594771379 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -47,7 +47,6 @@
 ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
 #define ACPI_PCI_LINK_HID		"PNP0C0F"
-#define ACPI_PCI_LINK_DRIVER_NAME	"ACPI PCI Interrupt Link Driver"
 #define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
 #define ACPI_PCI_LINK_FILE_INFO		"info"
 #define ACPI_PCI_LINK_FILE_STATUS	"state"

commit c2b6705b75d9c7aff98a4602a32230639e10891c
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:33:40 2007 -0500

    ACPI: fix acpi_driver.name usage
    
    It was erroneously used as a description rather than a name.
    
    ie. turn this:
    
    lenb@se7525gp2:/sys> ls bus/acpi/drivers
    ACPI AC Adapter Driver  ACPI Embedded Controller Driver  ACPI Power Resource Driver
    ACPI Battery Driver     ACPI Fan Driver                  ACPI Processor Driver
    ACPI Button Driver      ACPI PCI Interrupt Link Driver   ACPI Thermal Zone Driver
    ACPI container driver   ACPI PCI Root Bridge Driver      hpet
    
    into this:
    
    lenb@se7525gp2:~> ls /sys/bus/acpi/drivers
    ac  battery  button  container  ec  fan  hpet  pci_link  pci_root  power  processor  thermal
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index da22c5e612a4..a95f03fa03b4 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -56,7 +56,7 @@ static int acpi_pci_link_add(struct acpi_device *device);
 static int acpi_pci_link_remove(struct acpi_device *device, int type);
 
 static struct acpi_driver acpi_pci_link_driver = {
-	.name = ACPI_PCI_LINK_DRIVER_NAME,
+	.name = "pci_link",
 	.class = ACPI_PCI_LINK_CLASS,
 	.ids = ACPI_PCI_LINK_HID,
 	.ops = {

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 0f683c8c6fbc..da22c5e612a4 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -44,7 +44,7 @@
 #include <acpi/acpi_drivers.h>
 
 #define _COMPONENT		ACPI_PCI_COMPONENT
-ACPI_MODULE_NAME("pci_link")
+ACPI_MODULE_NAME("pci_link");
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
 #define ACPI_PCI_LINK_HID		"PNP0C0F"
 #define ACPI_PCI_LINK_DRIVER_NAME	"ACPI PCI Interrupt Link Driver"

commit cee324b145a1e5488b34191de670e5ed1d346ebb
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:22 2007 +0300

    ACPICA: use new ACPI headers.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 662e4299743d..0f683c8c6fbc 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -513,7 +513,7 @@ int __init acpi_irq_penalty_init(void)
 		}
 	}
 	/* Add a penalty for the SCI */
-	acpi_irq_penalty[acpi_fadt.sci_int] += PIRQ_PENALTY_PCI_USING;
+	acpi_irq_penalty[acpi_gbl_FADT.sci_interrupt] += PIRQ_PENALTY_PCI_USING;
 
 	return 0;
 }

commit d8c71b6d3b21cf21ad775e1cf6da95bf87bd5ad4
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Feb 2 19:48:21 2007 +0300

    ACPICA: Remove obsolete Flags parameter.
    
    Remove flags parameter for acpi_{get,set}_register().
    It is no longer necessary now that these functions use a
    spinlock for mutual exclusion.
    
    Signed-off-by: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 481e633bbf41..662e4299743d 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -785,7 +785,7 @@ static int irqrouter_resume(struct sys_device *dev)
 
 
 	/* Make sure SCI is enabled again (Apple firmware bug?) */
-	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1);
 
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 812d733fe816..481e633bbf41 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -307,11 +307,10 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	if (!link || !irq)
 		return -EINVAL;
 
-	resource = kmalloc(sizeof(*resource) + 1, irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
+	resource = kzalloc(sizeof(*resource) + 1, irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
 	if (!resource)
 		return -ENOMEM;
 
-	memset(resource, 0, sizeof(*resource) + 1);
 	buffer.length = sizeof(*resource) + 1;
 	buffer.pointer = resource;
 
@@ -718,10 +717,9 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	if (!device)
 		return -EINVAL;
 
-	link = kmalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
+	link = kzalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
 	if (!link)
 		return -ENOMEM;
-	memset(link, 0, sizeof(struct acpi_pci_link));
 
 	link->device = device;
 	strcpy(acpi_device_name(device), ACPI_PCI_LINK_DEVICE_NAME);

commit cece901481bafbf14de8cbd3a89ae869ea881055
Merge: cfee47f99bc1 50dd096973f1
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 16 01:04:27 2006 -0500

    Pull style into test branch
    
    Conflicts:
    
            drivers/acpi/button.c
            drivers/acpi/ec.c
            drivers/acpi/osl.c
            drivers/acpi/sbs.c

commit 168a328f30e9d1a8bc6ff55c0501e0bdc08bee60
Author: Jiri Kosina <jikos@jikos.cz>
Date:   Thu Aug 24 00:36:19 2006 -0400

    ACPI: acpi_pci_link_set() can allocate with either GFP_ATOMIC or GFP_KERNEL
    
    acpi_pci_link_set() allocates both with interrupts on
    and with interrupts off (resume-time), so check interrupts
    and decide on GFP_ATOMIC or GFP_KERNEL at run-time.
    
    Signed-off-by: Jiri Kosina <jikos@jikos.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 7f3e7e77e794..d53bd9878ca2 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -307,7 +307,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	if (!link || !irq)
 		return -EINVAL;
 
-	resource = kmalloc(sizeof(*resource) + 1, GFP_ATOMIC);
+	resource = kmalloc(sizeof(*resource) + 1, irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
 	if (!resource)
 		return -ENOMEM;
 

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 7f3e7e77e794..6718198bfae7 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -103,7 +103,7 @@ DEFINE_MUTEX(acpi_link_lock);
 static acpi_status
 acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 {
-	struct acpi_pci_link *link = (struct acpi_pci_link *)context;
+	struct acpi_pci_link *link = context;
 	u32 i = 0;
 
 
@@ -613,7 +613,7 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 		return -1;
 	}
 
-	link = (struct acpi_pci_link *)acpi_driver_data(device);
+	link = acpi_driver_data(device);
 	if (!link) {
 		printk(KERN_ERR PREFIX "Invalid link context\n");
 		return -1;
@@ -668,7 +668,7 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 		return -1;
 	}
 
-	link = (struct acpi_pci_link *)acpi_driver_data(device);
+	link = acpi_driver_data(device);
 	if (!link) {
 		printk(KERN_ERR PREFIX "Invalid link context\n");
 		return -1;
@@ -808,7 +808,7 @@ static int acpi_pci_link_remove(struct acpi_device *device, int type)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
-	link = (struct acpi_pci_link *)acpi_driver_data(device);
+	link = acpi_driver_data(device);
 
 	mutex_lock(&acpi_link_lock);
 	list_del(&link->node);

commit e21c1ca3f98529921c829a792dfdbfc5a5dc393b
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jul 10 01:35:51 2006 -0400

    ACPI: acpi_os_allocate() fixes
    
    Replace acpi_in_resume with a more general hack
    to check irqs_disabled() on any kmalloc() from ACPI.
    While setting (system_state != SYSTEM_RUNNING) on resume
    seemed more general, Andrew Morton preferred this approach.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Make acpi_os_allocate() into an inline function to
    allow /proc/slab_allocators to work.
    
    Delete some memset() that could fault on allocation failure.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 8197c0e40769..7f3e7e77e794 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -780,11 +780,6 @@ static int acpi_pci_link_resume(struct acpi_pci_link *link)
 		return 0;
 }
 
-/*
- * FIXME: this is a workaround to avoid nasty warning.  It will be removed
- * after every device calls pci_disable_device in .resume.
- */
-int acpi_in_resume;
 static int irqrouter_resume(struct sys_device *dev)
 {
 	struct list_head *node = NULL;
@@ -794,7 +789,6 @@ static int irqrouter_resume(struct sys_device *dev)
 	/* Make sure SCI is enabled again (Apple firmware bug?) */
 	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1, ACPI_MTX_DO_NOT_LOCK);
 
-	acpi_in_resume = 1;
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
@@ -803,7 +797,6 @@ static int irqrouter_resume(struct sys_device *dev)
 		}
 		acpi_pci_link_resume(link);
 	}
-	acpi_in_resume = 0;
 	return 0;
 }
 

commit e0e4e117d4c898b0df749d5b88c86955151abf53
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:50 2006 -0400

    ACPI: pci_link: Remove unneeded acpi_handle from driver.
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 68ee80a6e6f7..8197c0e40769 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -83,7 +83,6 @@ struct acpi_pci_link_irq {
 struct acpi_pci_link {
 	struct list_head node;
 	struct acpi_device *device;
-	acpi_handle handle;
 	struct acpi_pci_link_irq irq;
 	int refcnt;
 };
@@ -249,8 +248,7 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 	acpi_status status = AE_OK;
 	int irq = 0;
 
-
-	if (!link || !link->handle)
+	if (!link)
 		return -EINVAL;
 
 	link->irq.active = 0;
@@ -726,7 +724,6 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	memset(link, 0, sizeof(struct acpi_pci_link));
 
 	link->device = device;
-	link->handle = device->handle;
 	strcpy(acpi_device_name(device), ACPI_PCI_LINK_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);
 	acpi_driver_data(device) = link;

commit 67a7136573b24a0d1f85a4aab131558a02910d25
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:42 2006 -0400

    ACPI: pci_link: Use acpi_device's handle instead of driver's
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 1badce27a83f..68ee80a6e6f7 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -175,7 +175,7 @@ static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 	if (!link)
 		return -EINVAL;
 
-	status = acpi_walk_resources(link->handle, METHOD_NAME__PRS,
+	status = acpi_walk_resources(link->device->handle, METHOD_NAME__PRS,
 				     acpi_pci_link_check_possible, link);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRS"));
@@ -274,7 +274,7 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 	 * Query and parse _CRS to get the current IRQ assignment. 
 	 */
 
-	status = acpi_walk_resources(link->handle, METHOD_NAME__CRS,
+	status = acpi_walk_resources(link->device->handle, METHOD_NAME__CRS,
 				     acpi_pci_link_check_current, &irq);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _CRS"));
@@ -360,7 +360,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	resource->end.type = ACPI_RESOURCE_TYPE_END_TAG;
 
 	/* Attempt to set the resource */
-	status = acpi_set_current_resources(link->handle, &buffer);
+	status = acpi_set_current_resources(link->device->handle, &buffer);
 
 	/* check for total failure */
 	if (ACPI_FAILURE(status)) {
@@ -699,7 +699,7 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 			  acpi_device_bid(link->device)));
 
 	if (link->refcnt == 0) {
-		acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
+		acpi_ut_evaluate_object(link->device->handle, "_DIS", 0, NULL);
 	}
 	mutex_unlock(&acpi_link_lock);
 	return (link->irq.active);
@@ -765,7 +765,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
 
       end:
 	/* disable all links -- to be activated on use */
-	acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
+	acpi_ut_evaluate_object(device->handle, "_DIS", 0, NULL);
 	mutex_unlock(&acpi_link_lock);
 
 	if (result)

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index d7aa9c10335c..1badce27a83f 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -107,17 +107,16 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 	struct acpi_pci_link *link = (struct acpi_pci_link *)context;
 	u32 i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_check_possible");
 
 	switch (resource->type) {
 	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
-		return_ACPI_STATUS(AE_OK);
+		return AE_OK;
 	case ACPI_RESOURCE_TYPE_IRQ:
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
 			if (!p || !p->interrupt_count) {
 				printk(KERN_WARNING PREFIX "Blank IRQ resource\n");
-				return_ACPI_STATUS(AE_OK);
+				return AE_OK;
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
@@ -142,7 +141,7 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 			if (!p || !p->interrupt_count) {
 				printk(KERN_WARNING PREFIX
 					      "Blank EXT IRQ resource\n");
-				return_ACPI_STATUS(AE_OK);
+				return AE_OK;
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
@@ -162,33 +161,32 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 		}
 	default:
 		printk(KERN_ERR PREFIX "Resource is not an IRQ entry\n");
-		return_ACPI_STATUS(AE_OK);
+		return AE_OK;
 	}
 
-	return_ACPI_STATUS(AE_CTRL_TERMINATE);
+	return AE_CTRL_TERMINATE;
 }
 
 static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 {
 	acpi_status status;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_get_possible");
 
 	if (!link)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	status = acpi_walk_resources(link->handle, METHOD_NAME__PRS,
 				     acpi_pci_link_check_possible, link);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRS"));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Found %d possible IRQs\n",
 			  link->irq.possible_count));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static acpi_status
@@ -196,7 +194,6 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 {
 	int *irq = (int *)context;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_check_current");
 
 	switch (resource->type) {
 	case ACPI_RESOURCE_TYPE_IRQ:
@@ -209,7 +206,7 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 				 */
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 						  "Blank IRQ resource\n"));
-				return_ACPI_STATUS(AE_OK);
+				return AE_OK;
 			}
 			*irq = p->interrupts[0];
 			break;
@@ -225,7 +222,7 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 				 */
 				printk(KERN_WARNING PREFIX
 					      "Blank EXT IRQ resource\n");
-				return_ACPI_STATUS(AE_OK);
+				return AE_OK;
 			}
 			*irq = p->interrupts[0];
 			break;
@@ -234,9 +231,9 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 	default:
 		printk(KERN_ERR PREFIX "Resource %d isn't an IRQ\n", resource->type);
 	case ACPI_RESOURCE_TYPE_END_TAG:
-		return_ACPI_STATUS(AE_OK);
+		return AE_OK;
 	}
-	return_ACPI_STATUS(AE_CTRL_TERMINATE);
+	return AE_CTRL_TERMINATE;
 }
 
 /*
@@ -252,10 +249,9 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 	acpi_status status = AE_OK;
 	int irq = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_get_current");
 
 	if (!link || !link->handle)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	link->irq.active = 0;
 
@@ -270,7 +266,7 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 
 		if (!link->device->status.enabled) {
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link disabled\n"));
-			return_VALUE(0);
+			return 0;
 		}
 	}
 
@@ -296,7 +292,7 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link at IRQ %d \n", link->irq.active));
 
       end:
-	return_VALUE(result);
+	return result;
 }
 
 static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
@@ -309,14 +305,13 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	} *resource;
 	struct acpi_buffer buffer = { 0, NULL };
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
 
 	if (!link || !irq)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	resource = kmalloc(sizeof(*resource) + 1, GFP_ATOMIC);
 	if (!resource)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 
 	memset(resource, 0, sizeof(*resource) + 1);
 	buffer.length = sizeof(*resource) + 1;
@@ -413,7 +408,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 
       end:
 	kfree(resource);
-	return_VALUE(result);
+	return result;
 }
 
 /* --------------------------------------------------------------------------
@@ -487,7 +482,6 @@ int __init acpi_irq_penalty_init(void)
 	struct acpi_pci_link *link = NULL;
 	int i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_irq_penalty_init");
 
 	/*
 	 * Update penalties to facilitate IRQ balancing.
@@ -524,7 +518,7 @@ int __init acpi_irq_penalty_init(void)
 	/* Add a penalty for the SCI */
 	acpi_irq_penalty[acpi_fadt.sci_int] += PIRQ_PENALTY_PCI_USING;
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_irq_balance;	/* 0: static, 1: balance */
@@ -534,13 +528,12 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 	int irq;
 	int i;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate");
 
 	if (link->irq.initialized) {
 		if (link->refcnt == 0)
 			/* This means the link is disabled but initialized */
 			acpi_pci_link_set(link, link->irq.active);
-		return_VALUE(0);
+		return 0;
 	}
 
 	/*
@@ -587,7 +580,7 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 			    "Try pci=noacpi or acpi=off\n",
 			    acpi_device_name(link->device),
 			    acpi_device_bid(link->device));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	} else {
 		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
 		printk(PREFIX "%s [%s] enabled at IRQ %d\n",
@@ -597,7 +590,7 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 
 	link->irq.initialized = 1;
 
-	return_VALUE(0);
+	return 0;
 }
 
 /*
@@ -615,36 +608,35 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 	struct acpi_device *device = NULL;
 	struct acpi_pci_link *link = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate_irq");
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
 		printk(KERN_ERR PREFIX "Invalid link device\n");
-		return_VALUE(-1);
+		return -1;
 	}
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
 		printk(KERN_ERR PREFIX "Invalid link context\n");
-		return_VALUE(-1);
+		return -1;
 	}
 
 	/* TBD: Support multiple index (IRQ) entries per Link Device */
 	if (index) {
 		printk(KERN_ERR PREFIX "Invalid index %d\n", index);
-		return_VALUE(-1);
+		return -1;
 	}
 
 	mutex_lock(&acpi_link_lock);
 	if (acpi_pci_link_allocate(link)) {
 		mutex_unlock(&acpi_link_lock);
-		return_VALUE(-1);
+		return -1;
 	}
 
 	if (!link->irq.active) {
 		mutex_unlock(&acpi_link_lock);
 		printk(KERN_ERR PREFIX "Link active IRQ is 0!\n");
-		return_VALUE(-1);
+		return -1;
 	}
 	link->refcnt++;
 	mutex_unlock(&acpi_link_lock);
@@ -658,7 +650,7 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Link %s is referenced\n",
 			  acpi_device_bid(link->device)));
-	return_VALUE(link->irq.active);
+	return (link->irq.active);
 }
 
 /*
@@ -671,25 +663,24 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 	struct acpi_pci_link *link = NULL;
 	acpi_status result;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_free_irq");
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
 		printk(KERN_ERR PREFIX "Invalid link device\n");
-		return_VALUE(-1);
+		return -1;
 	}
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
 		printk(KERN_ERR PREFIX "Invalid link context\n");
-		return_VALUE(-1);
+		return -1;
 	}
 
 	mutex_lock(&acpi_link_lock);
 	if (!link->irq.initialized) {
 		mutex_unlock(&acpi_link_lock);
 		printk(KERN_ERR PREFIX "Link isn't initialized\n");
-		return_VALUE(-1);
+		return -1;
 	}
 #ifdef	FUTURE_USE
 	/*
@@ -711,7 +702,7 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 		acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
 	}
 	mutex_unlock(&acpi_link_lock);
-	return_VALUE(link->irq.active);
+	return (link->irq.active);
 }
 
 /* --------------------------------------------------------------------------
@@ -725,14 +716,13 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	int i = 0;
 	int found = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_add");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	link = kmalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
 	if (!link)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	memset(link, 0, sizeof(struct acpi_pci_link));
 
 	link->device = device;
@@ -781,17 +771,16 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	if (result)
 		kfree(link);
 
-	return_VALUE(result);
+	return result;
 }
 
 static int acpi_pci_link_resume(struct acpi_pci_link *link)
 {
-	ACPI_FUNCTION_TRACE("acpi_pci_link_resume");
 
 	if (link->refcnt && link->irq.active && link->irq.initialized)
-		return_VALUE(acpi_pci_link_set(link, link->irq.active));
+		return (acpi_pci_link_set(link, link->irq.active));
 	else
-		return_VALUE(0);
+		return 0;
 }
 
 /*
@@ -804,7 +793,6 @@ static int irqrouter_resume(struct sys_device *dev)
 	struct list_head *node = NULL;
 	struct acpi_pci_link *link = NULL;
 
-	ACPI_FUNCTION_TRACE("irqrouter_resume");
 
 	/* Make sure SCI is enabled again (Apple firmware bug?) */
 	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1, ACPI_MTX_DO_NOT_LOCK);
@@ -819,17 +807,16 @@ static int irqrouter_resume(struct sys_device *dev)
 		acpi_pci_link_resume(link);
 	}
 	acpi_in_resume = 0;
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_pci_link_remove(struct acpi_device *device, int type)
 {
 	struct acpi_pci_link *link = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_remove");
 
 	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 
@@ -839,7 +826,7 @@ static int acpi_pci_link_remove(struct acpi_device *device, int type)
 
 	kfree(link);
 
-	return_VALUE(0);
+	return 0;
 }
 
 /*
@@ -945,34 +932,32 @@ static int __init irqrouter_init_sysfs(void)
 {
 	int error;
 
-	ACPI_FUNCTION_TRACE("irqrouter_init_sysfs");
 
 	if (acpi_disabled || acpi_noirq)
-		return_VALUE(0);
+		return 0;
 
 	error = sysdev_class_register(&irqrouter_sysdev_class);
 	if (!error)
 		error = sysdev_register(&device_irqrouter);
 
-	return_VALUE(error);
+	return error;
 }
 
 device_initcall(irqrouter_init_sysfs);
 
 static int __init acpi_pci_link_init(void)
 {
-	ACPI_FUNCTION_TRACE("acpi_pci_link_init");
 
 	if (acpi_noirq)
-		return_VALUE(0);
+		return 0;
 
 	acpi_link.count = 0;
 	INIT_LIST_HEAD(&acpi_link.entries);
 
 	if (acpi_bus_register_driver(&acpi_pci_link_driver) < 0)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
-	return_VALUE(0);
+	return 0;
 }
 
 subsys_initcall(acpi_pci_link_init);

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 6d903bfe5197..d7aa9c10335c 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -161,7 +161,7 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 			break;
 		}
 	default:
-		ACPI_ERROR((AE_INFO, "Resource is not an IRQ entry\n"));
+		printk(KERN_ERR PREFIX "Resource is not an IRQ entry\n");
 		return_ACPI_STATUS(AE_OK);
 	}
 
@@ -232,7 +232,7 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 		}
 		break;
 	default:
-		ACPI_ERROR((AE_INFO, "Resource %d isn't an IRQ", resource->type));
+		printk(KERN_ERR PREFIX "Resource %d isn't an IRQ\n", resource->type);
 	case ACPI_RESOURCE_TYPE_END_TAG:
 		return_ACPI_STATUS(AE_OK);
 	}
@@ -264,7 +264,7 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 		/* Query _STA, set link->device->status */
 		result = acpi_bus_get_status(link->device);
 		if (result) {
-			ACPI_ERROR((AE_INFO, "Unable to read status"));
+			printk(KERN_ERR PREFIX "Unable to read status\n");
 			goto end;
 		}
 
@@ -287,7 +287,7 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 	}
 
 	if (acpi_strict && !irq) {
-		ACPI_ERROR((AE_INFO, "_CRS returned 0"));
+		printk(KERN_ERR PREFIX "_CRS returned 0\n");
 		result = -ENODEV;
 	}
 
@@ -357,7 +357,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		/* ignore resource_source, it's optional */
 		break;
 	default:
-		ACPI_ERROR((AE_INFO, "Invalid Resource_type %d\n", link->irq.resource_type));
+		printk(KERN_ERR PREFIX "Invalid Resource_type %d\n", link->irq.resource_type);
 		result = -EINVAL;
 		goto end;
 
@@ -377,7 +377,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	/* Query _STA, set device->status */
 	result = acpi_bus_get_status(link->device);
 	if (result) {
-		ACPI_ERROR((AE_INFO, "Unable to read status"));
+		printk(KERN_ERR PREFIX "Unable to read status\n");
 		goto end;
 	}
 	if (!link->device->status.enabled) {
@@ -496,7 +496,7 @@ int __init acpi_irq_penalty_init(void)
 
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
-			ACPI_ERROR((AE_INFO, "Invalid link context"));
+			printk(KERN_ERR PREFIX "Invalid link context\n");
 			continue;
 		}
 
@@ -583,10 +583,10 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 
 	/* Attempt to enable the link device at this IRQ. */
 	if (acpi_pci_link_set(link, irq)) {
-		ACPI_ERROR((AE_INFO, "Unable to set IRQ for %s [%s]. "
-			    "Try pci=noacpi or acpi=off",
+		printk(KERN_ERR PREFIX "Unable to set IRQ for %s [%s]. "
+			    "Try pci=noacpi or acpi=off\n",
 			    acpi_device_name(link->device),
-			    acpi_device_bid(link->device)));
+			    acpi_device_bid(link->device));
 		return_VALUE(-ENODEV);
 	} else {
 		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
@@ -619,19 +619,19 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
-		ACPI_ERROR((AE_INFO, "Invalid link device"));
+		printk(KERN_ERR PREFIX "Invalid link device\n");
 		return_VALUE(-1);
 	}
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
-		ACPI_ERROR((AE_INFO, "Invalid link context"));
+		printk(KERN_ERR PREFIX "Invalid link context\n");
 		return_VALUE(-1);
 	}
 
 	/* TBD: Support multiple index (IRQ) entries per Link Device */
 	if (index) {
-		ACPI_ERROR((AE_INFO, "Invalid index %d", index));
+		printk(KERN_ERR PREFIX "Invalid index %d\n", index);
 		return_VALUE(-1);
 	}
 
@@ -643,7 +643,7 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 
 	if (!link->irq.active) {
 		mutex_unlock(&acpi_link_lock);
-		ACPI_ERROR((AE_INFO, "Link active IRQ is 0!"));
+		printk(KERN_ERR PREFIX "Link active IRQ is 0!\n");
 		return_VALUE(-1);
 	}
 	link->refcnt++;
@@ -675,20 +675,20 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
-		ACPI_ERROR((AE_INFO, "Invalid link device"));
+		printk(KERN_ERR PREFIX "Invalid link device\n");
 		return_VALUE(-1);
 	}
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
-		ACPI_ERROR((AE_INFO, "Invalid link context"));
+		printk(KERN_ERR PREFIX "Invalid link context\n");
 		return_VALUE(-1);
 	}
 
 	mutex_lock(&acpi_link_lock);
 	if (!link->irq.initialized) {
 		mutex_unlock(&acpi_link_lock);
-		ACPI_ERROR((AE_INFO, "Link isn't initialized"));
+		printk(KERN_ERR PREFIX "Link isn't initialized\n");
 		return_VALUE(-1);
 	}
 #ifdef	FUTURE_USE
@@ -813,7 +813,7 @@ static int irqrouter_resume(struct sys_device *dev)
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
-			ACPI_ERROR((AE_INFO, "Invalid link context"));
+			printk(KERN_ERR PREFIX "Invalid link context\n");
 			continue;
 		}
 		acpi_pci_link_resume(link);

commit cece92969762b8ed7930d4e23008b76b06411dee
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:04:31 2006 -0400

    ACPI: un-export ACPI_WARNING() -- use printk(KERN_WARNING...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 415b2628fe85..6d903bfe5197 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -116,15 +116,15 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
 			if (!p || !p->interrupt_count) {
-				ACPI_WARNING((AE_INFO, "Blank IRQ resource"));
+				printk(KERN_WARNING PREFIX "Blank IRQ resource\n");
 				return_ACPI_STATUS(AE_OK);
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
-					ACPI_WARNING((AE_INFO, "Invalid IRQ %d",
-						      p->interrupts[i]));
+					printk(KERN_WARNING PREFIX "Invalid IRQ %d\n",
+						      p->interrupts[i]);
 					continue;
 				}
 				link->irq.possible[i] = p->interrupts[i];
@@ -140,16 +140,16 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 			struct acpi_resource_extended_irq *p =
 			    &resource->data.extended_irq;
 			if (!p || !p->interrupt_count) {
-				ACPI_WARNING((AE_INFO,
-					      "Blank EXT IRQ resource"));
+				printk(KERN_WARNING PREFIX
+					      "Blank EXT IRQ resource\n");
 				return_ACPI_STATUS(AE_OK);
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
-					ACPI_WARNING((AE_INFO, "Invalid IRQ %d",
-						      p->interrupts[i]));
+					printk(KERN_WARNING PREFIX "Invalid IRQ %d\n",
+						      p->interrupts[i]);
 					continue;
 				}
 				link->irq.possible[i] = p->interrupts[i];
@@ -223,8 +223,8 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 				 * extended IRQ descriptors must
 				 * return at least 1 IRQ
 				 */
-				ACPI_WARNING((AE_INFO,
-					      "Blank EXT IRQ resource"));
+				printk(KERN_WARNING PREFIX
+					      "Blank EXT IRQ resource\n");
 				return_ACPI_STATUS(AE_OK);
 			}
 			*irq = p->interrupts[0];
@@ -381,10 +381,10 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		goto end;
 	}
 	if (!link->device->status.enabled) {
-		ACPI_WARNING((AE_INFO,
-			      "%s [%s] disabled and referenced, BIOS bug",
+		printk(KERN_WARNING PREFIX
+			      "%s [%s] disabled and referenced, BIOS bug\n",
 			      acpi_device_name(link->device),
-			      acpi_device_bid(link->device)));
+			      acpi_device_bid(link->device));
 	}
 
 	/* Query _CRS, set link->irq.active */
@@ -402,10 +402,10 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		 * policy: when _CRS doesn't return what we just _SRS
 		 * assume _SRS worked and override _CRS value.
 		 */
-		ACPI_WARNING((AE_INFO,
-			      "%s [%s] BIOS reported IRQ %d, using IRQ %d",
+		printk(KERN_WARNING PREFIX
+			      "%s [%s] BIOS reported IRQ %d, using IRQ %d\n",
 			      acpi_device_name(link->device),
-			      acpi_device_bid(link->device), link->irq.active, irq));
+			      acpi_device_bid(link->device), link->irq.active, irq);
 		link->irq.active = irq;
 	}
 
@@ -555,8 +555,8 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 	 */
 	if (i == link->irq.possible_count) {
 		if (acpi_strict)
-			ACPI_WARNING((AE_INFO, "_CRS %d not found"
-				      " in _PRS", link->irq.active));
+			printk(KERN_WARNING PREFIX "_CRS %d not found"
+				      " in _PRS\n", link->irq.active);
 		link->irq.active = 0;
 	}
 

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 228bdb626502..415b2628fe85 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -116,17 +116,15 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
 			if (!p || !p->interrupt_count) {
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-						  "Blank IRQ resource\n"));
+				ACPI_WARNING((AE_INFO, "Blank IRQ resource"));
 				return_ACPI_STATUS(AE_OK);
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
-					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-							  "Invalid IRQ %d\n",
-							  p->interrupts[i]));
+					ACPI_WARNING((AE_INFO, "Invalid IRQ %d",
+						      p->interrupts[i]));
 					continue;
 				}
 				link->irq.possible[i] = p->interrupts[i];
@@ -142,17 +140,16 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 			struct acpi_resource_extended_irq *p =
 			    &resource->data.extended_irq;
 			if (!p || !p->interrupt_count) {
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-						  "Blank EXT IRQ resource\n"));
+				ACPI_WARNING((AE_INFO,
+					      "Blank EXT IRQ resource"));
 				return_ACPI_STATUS(AE_OK);
 			}
 			for (i = 0;
 			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
-					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-							  "Invalid IRQ %d\n",
-							  p->interrupts[i]));
+					ACPI_WARNING((AE_INFO, "Invalid IRQ %d",
+						      p->interrupts[i]));
 					continue;
 				}
 				link->irq.possible[i] = p->interrupts[i];
@@ -164,8 +161,7 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 			break;
 		}
 	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Resource is not an IRQ entry\n"));
+		ACPI_ERROR((AE_INFO, "Resource is not an IRQ entry\n"));
 		return_ACPI_STATUS(AE_OK);
 	}
 
@@ -184,7 +180,7 @@ static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 	status = acpi_walk_resources(link->handle, METHOD_NAME__PRS,
 				     acpi_pci_link_check_possible, link);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRS\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRS"));
 		return_VALUE(-ENODEV);
 	}
 
@@ -227,8 +223,8 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 				 * extended IRQ descriptors must
 				 * return at least 1 IRQ
 				 */
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-						  "Blank EXT IRQ resource\n"));
+				ACPI_WARNING((AE_INFO,
+					      "Blank EXT IRQ resource"));
 				return_ACPI_STATUS(AE_OK);
 			}
 			*irq = p->interrupts[0];
@@ -236,7 +232,7 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 		}
 		break;
 	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Resource %d isn't an IRQ\n", resource->type));
+		ACPI_ERROR((AE_INFO, "Resource %d isn't an IRQ", resource->type));
 	case ACPI_RESOURCE_TYPE_END_TAG:
 		return_ACPI_STATUS(AE_OK);
 	}
@@ -268,8 +264,7 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 		/* Query _STA, set link->device->status */
 		result = acpi_bus_get_status(link->device);
 		if (result) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-					  "Unable to read status\n"));
+			ACPI_ERROR((AE_INFO, "Unable to read status"));
 			goto end;
 		}
 
@@ -286,13 +281,13 @@ static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 	status = acpi_walk_resources(link->handle, METHOD_NAME__CRS,
 				     acpi_pci_link_check_current, &irq);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _CRS\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _CRS"));
 		result = -ENODEV;
 		goto end;
 	}
 
 	if (acpi_strict && !irq) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "_CRS returned 0\n"));
+		ACPI_ERROR((AE_INFO, "_CRS returned 0"));
 		result = -ENODEV;
 	}
 
@@ -362,7 +357,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		/* ignore resource_source, it's optional */
 		break;
 	default:
-		printk("ACPI BUG: resource_type %d\n", link->irq.resource_type);
+		ACPI_ERROR((AE_INFO, "Invalid Resource_type %d\n", link->irq.resource_type));
 		result = -EINVAL;
 		goto end;
 
@@ -374,7 +369,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 
 	/* check for total failure */
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SRS\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _SRS"));
 		result = -ENODEV;
 		goto end;
 	}
@@ -382,14 +377,14 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	/* Query _STA, set device->status */
 	result = acpi_bus_get_status(link->device);
 	if (result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+		ACPI_ERROR((AE_INFO, "Unable to read status"));
 		goto end;
 	}
 	if (!link->device->status.enabled) {
-		printk(KERN_WARNING PREFIX
-		       "%s [%s] disabled and referenced, BIOS bug.\n",
-		       acpi_device_name(link->device),
-		       acpi_device_bid(link->device));
+		ACPI_WARNING((AE_INFO,
+			      "%s [%s] disabled and referenced, BIOS bug",
+			      acpi_device_name(link->device),
+			      acpi_device_bid(link->device)));
 	}
 
 	/* Query _CRS, set link->irq.active */
@@ -407,10 +402,10 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		 * policy: when _CRS doesn't return what we just _SRS
 		 * assume _SRS worked and override _CRS value.
 		 */
-		printk(KERN_WARNING PREFIX
-		       "%s [%s] BIOS reported IRQ %d, using IRQ %d\n",
-		       acpi_device_name(link->device),
-		       acpi_device_bid(link->device), link->irq.active, irq);
+		ACPI_WARNING((AE_INFO,
+			      "%s [%s] BIOS reported IRQ %d, using IRQ %d",
+			      acpi_device_name(link->device),
+			      acpi_device_bid(link->device), link->irq.active, irq));
 		link->irq.active = irq;
 	}
 
@@ -501,8 +496,7 @@ int __init acpi_irq_penalty_init(void)
 
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-					  "Invalid link context\n"));
+			ACPI_ERROR((AE_INFO, "Invalid link context"));
 			continue;
 		}
 
@@ -561,8 +555,8 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 	 */
 	if (i == link->irq.possible_count) {
 		if (acpi_strict)
-			printk(KERN_WARNING PREFIX "_CRS %d not found"
-			       " in _PRS\n", link->irq.active);
+			ACPI_WARNING((AE_INFO, "_CRS %d not found"
+				      " in _PRS", link->irq.active));
 		link->irq.active = 0;
 	}
 
@@ -589,11 +583,10 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 
 	/* Attempt to enable the link device at this IRQ. */
 	if (acpi_pci_link_set(link, irq)) {
-		printk(PREFIX
-		       "Unable to set IRQ for %s [%s] (likely buggy ACPI BIOS).\n"
-		       "Try pci=noacpi or acpi=off\n",
-		       acpi_device_name(link->device),
-		       acpi_device_bid(link->device));
+		ACPI_ERROR((AE_INFO, "Unable to set IRQ for %s [%s]. "
+			    "Try pci=noacpi or acpi=off",
+			    acpi_device_name(link->device),
+			    acpi_device_bid(link->device)));
 		return_VALUE(-ENODEV);
 	} else {
 		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
@@ -626,19 +619,19 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link device\n"));
+		ACPI_ERROR((AE_INFO, "Invalid link device"));
 		return_VALUE(-1);
 	}
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+		ACPI_ERROR((AE_INFO, "Invalid link context"));
 		return_VALUE(-1);
 	}
 
 	/* TBD: Support multiple index (IRQ) entries per Link Device */
 	if (index) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid index %d\n", index));
+		ACPI_ERROR((AE_INFO, "Invalid index %d", index));
 		return_VALUE(-1);
 	}
 
@@ -650,7 +643,7 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 
 	if (!link->irq.active) {
 		mutex_unlock(&acpi_link_lock);
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link active IRQ is 0!\n"));
+		ACPI_ERROR((AE_INFO, "Link active IRQ is 0!"));
 		return_VALUE(-1);
 	}
 	link->refcnt++;
@@ -682,20 +675,20 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link device\n"));
+		ACPI_ERROR((AE_INFO, "Invalid link device"));
 		return_VALUE(-1);
 	}
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+		ACPI_ERROR((AE_INFO, "Invalid link context"));
 		return_VALUE(-1);
 	}
 
 	mutex_lock(&acpi_link_lock);
 	if (!link->irq.initialized) {
 		mutex_unlock(&acpi_link_lock);
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link isn't initialized\n"));
+		ACPI_ERROR((AE_INFO, "Link isn't initialized"));
 		return_VALUE(-1);
 	}
 #ifdef	FUTURE_USE
@@ -820,8 +813,7 @@ static int irqrouter_resume(struct sys_device *dev)
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-					  "Invalid link context\n"));
+			ACPI_ERROR((AE_INFO, "Invalid link context"));
 			continue;
 		}
 		acpi_pci_link_resume(link);

commit 37224470c8c6d90a4062e76a08d4dc1fcf91fc89
Merge: e83319510b04 ae6c859b7dcd
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Jun 23 07:52:36 2006 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (65 commits)
      ACPI: suppress power button event on S3 resume
      ACPI: resolve merge conflict between sem2mutex and processor_perflib.c
      ACPI: use for_each_possible_cpu() instead of for_each_cpu()
      ACPI: delete newly added debugging macros in processor_perflib.c
      ACPI: UP build fix for bugzilla-5737
      Enable P-state software coordination via _PDC
      P-state software coordination for speedstep-centrino
      P-state software coordination for acpi-cpufreq
      P-state software coordination for ACPI core
      ACPI: create acpi_thermal_resume()
      ACPI: create acpi_fan_suspend()/acpi_fan_resume()
      ACPI: pass pm_message_t from acpi_device_suspend() to root_suspend()
      ACPI: create acpi_device_suspend()/acpi_device_resume()
      ACPI: replace spin_lock_irq with mutex for ec poll mode
      ACPI: Allow a WAN module enable/disable on a Thinkpad X60.
      sem2mutex: acpi, acpi_link_lock
      ACPI: delete unused acpi_bus_drivers_lock
      sem2mutex: drivers/acpi/processor_perflib.c
      ACPI add ia64 exports to build acpi_memhotplug as a module
      ACPI: asus_acpi_init(): propagate correct return value
      ...
    
    Manual resolve of conflicts in:
    
            arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
            arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
            include/acpi/processor.h

commit 5603509137940f4cbc577281cee62110d4097b1b
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jun 19 18:05:09 2006 -0700

    Make sure to re-enable SCI after an ACPI suspend
    
    According to the ACPI spec, it should be enabled on return from suspend,
    but bugs happen.  Apparently especially on the Apple Intel Macs.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 07bc6dfe662b..8920e8c6e246 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -812,6 +812,9 @@ static int irqrouter_resume(struct sys_device *dev)
 
 	ACPI_FUNCTION_TRACE("irqrouter_resume");
 
+	/* Make sure SCI is enabled again (Apple firmware bug?) */
+	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+
 	acpi_in_resume = 1;
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);

commit 36e430951af0b0d1bdfd50ce22e70079d02646df
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Apr 27 05:25:00 2006 -0400

    sem2mutex: acpi, acpi_link_lock
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 07bc6dfe662b..b55ad1add1b0 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -38,6 +38,7 @@
 #include <linux/spinlock.h>
 #include <linux/pm.h>
 #include <linux/pci.h>
+#include <linux/mutex.h>
 
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
@@ -91,7 +92,7 @@ static struct {
 	int count;
 	struct list_head entries;
 } acpi_link;
-DECLARE_MUTEX(acpi_link_lock);
+DEFINE_MUTEX(acpi_link_lock);
 
 /* --------------------------------------------------------------------------
                             PCI Link Device Management
@@ -641,19 +642,19 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 		return_VALUE(-1);
 	}
 
-	down(&acpi_link_lock);
+	mutex_lock(&acpi_link_lock);
 	if (acpi_pci_link_allocate(link)) {
-		up(&acpi_link_lock);
+		mutex_unlock(&acpi_link_lock);
 		return_VALUE(-1);
 	}
 
 	if (!link->irq.active) {
-		up(&acpi_link_lock);
+		mutex_unlock(&acpi_link_lock);
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link active IRQ is 0!\n"));
 		return_VALUE(-1);
 	}
 	link->refcnt++;
-	up(&acpi_link_lock);
+	mutex_unlock(&acpi_link_lock);
 
 	if (triggering)
 		*triggering = link->irq.triggering;
@@ -691,9 +692,9 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 		return_VALUE(-1);
 	}
 
-	down(&acpi_link_lock);
+	mutex_lock(&acpi_link_lock);
 	if (!link->irq.initialized) {
-		up(&acpi_link_lock);
+		mutex_unlock(&acpi_link_lock);
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link isn't initialized\n"));
 		return_VALUE(-1);
 	}
@@ -716,7 +717,7 @@ int acpi_pci_link_free_irq(acpi_handle handle)
 	if (link->refcnt == 0) {
 		acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
 	}
-	up(&acpi_link_lock);
+	mutex_unlock(&acpi_link_lock);
 	return_VALUE(link->irq.active);
 }
 
@@ -747,7 +748,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
 	strcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);
 	acpi_driver_data(device) = link;
 
-	down(&acpi_link_lock);
+	mutex_lock(&acpi_link_lock);
 	result = acpi_pci_link_get_possible(link);
 	if (result)
 		goto end;
@@ -782,7 +783,7 @@ static int acpi_pci_link_add(struct acpi_device *device)
       end:
 	/* disable all links -- to be activated on use */
 	acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
-	up(&acpi_link_lock);
+	mutex_unlock(&acpi_link_lock);
 
 	if (result)
 		kfree(link);
@@ -837,9 +838,9 @@ static int acpi_pci_link_remove(struct acpi_device *device, int type)
 
 	link = (struct acpi_pci_link *)acpi_driver_data(device);
 
-	down(&acpi_link_lock);
+	mutex_lock(&acpi_link_lock);
 	list_del(&link->node);
-	up(&acpi_link_lock);
+	mutex_unlock(&acpi_link_lock);
 
 	kfree(link);
 

commit d4ec6c7cc9a15a7a529719bc3b84f46812f9842e
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jan 26 17:23:38 2006 -0500

    [ACPI] remove "Resource isn't an IRQ" warning
    
    In the case where a (broken) BIOS gives  us a blank _CRS for
    a PCI Interrupt Link Device, the acpi_walk_resources()
    will not terminate, but will then give the callback
    the resource end tag.  Ignore the end tag.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 1ffc77115367..07bc6dfe662b 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -233,8 +233,10 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 			*irq = p->interrupts[0];
 			break;
 		}
+		break;
 	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Resource isn't an IRQ\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Resource %d isn't an IRQ\n", resource->type));
+	case ACPI_RESOURCE_TYPE_END_TAG:
 		return_ACPI_STATUS(AE_OK);
 	}
 	return_ACPI_STATUS(AE_CTRL_TERMINATE);

commit ed03f430cdc8c802652467e9097606fedc2c7abc
Merge: ed349a8a0a78 6f957eaf7935
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jan 7 03:50:18 2006 -0500

    Pull pnpacpi into acpica branch

commit a64882e795cc1d890e3359d0aa143af1cf67e8d4
Author: Dave Jones <davej@redhat.com>
Date:   Mon Dec 12 00:37:40 2005 -0800

    [PATCH] ACPI: fix sleeping whilst atomic warnings on resume
    
    This has been broken for months.  On resume, we call acpi_pci_link_set()
    with interrupts off, so we get a warning when we try to do a kmalloc of non
    atomic memory.  The actual allocation is just 2 long's (plus extra byte for
    some reason I can't fathom), so a simple conversion to GFP_ATOMIC is
    probably the safest way to fix this.
    
    The error looks like this..
    
    Debug: sleeping function called from invalid context at mm/slab.c:2486
    in_atomic():0, irqs_disabled():1
     [<c0143f6c>] kmem_cache_alloc+0x40/0x56
     [<c0206a2e>] acpi_pci_link_set+0x3f/0x17f
     [<c0206f96>] irqrouter_resume+0x1e/0x3c
     [<c0239bca>] __sysdev_resume+0x11/0x6b
     [<c0239e88>] sysdev_resume+0x34/0x52
     [<c023de21>] device_power_up+0x5/0xa
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 82292b77e5c6..78927c0f1551 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -316,7 +316,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	if (!link || !irq)
 		return_VALUE(-EINVAL);
 
-	resource = kmalloc(sizeof(*resource) + 1, GFP_KERNEL);
+	resource = kmalloc(sizeof(*resource) + 1, GFP_ATOMIC);
 	if (!resource)
 		return_VALUE(-ENOMEM);
 

commit 50eca3eb89d73d9f0aa070b126c7ee6a616016ab
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Sep 30 19:03:00 2005 -0400

    [ACPI] ACPICA 20050930
    
    Completed a major overhaul of the Resource Manager code -
    specifically, optimizations in the area of the AML/internal
    resource conversion code. The code has been optimized to
    simplify and eliminate duplicated code, CPU stack use has
    been decreased by optimizing function parameters and local
    variables, and naming conventions across the manager have
    been standardized for clarity and ease of maintenance (this
    includes function, parameter, variable, and struct/typedef
    names.)
    
    All Resource Manager dispatch and information tables have
    been moved to a single location for clarity and ease of
    maintenance. One new file was created, named "rsinfo.c".
    
    The ACPI return macros (return_ACPI_STATUS, etc.) have
    been modified to guarantee that the argument is
    not evaluated twice, making them less prone to macro
    side-effects. However, since there exists the possibility
    of additional stack use if a particular compiler cannot
    optimize them (such as in the debug generation case),
    the original macros are optionally available.  Note that
    some invocations of the return_VALUE macro may now cause
    size mismatch warnings; the return_UINT8 and return_UINT32
    macros are provided to eliminate these. (From Randy Dunlap)
    
    Implemented a new mechanism to enable debug tracing for
    individual control methods. A new external interface,
    acpi_debug_trace(), is provided to enable this mechanism. The
    intent is to allow the host OS to easily enable and disable
    tracing for problematic control methods. This interface
    can be easily exposed to a user or debugger interface if
    desired. See the file psxface.c for details.
    
    acpi_ut_callocate() will now return a valid pointer if a
    length of zero is specified - a length of one is used
    and a warning is issued. This matches the behavior of
    acpi_ut_allocate().
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index d8956c0bf143..492170373494 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -70,8 +70,8 @@ static struct acpi_driver acpi_pci_link_driver = {
  */
 struct acpi_pci_link_irq {
 	u8 active;		/* Current IRQ */
-	u8 edge_level;		/* All IRQs */
-	u8 active_high_low;	/* All IRQs */
+	u8 triggering;		/* All IRQs */
+	u8 polarity;	/* All IRQs */
 	u8 resource_type;
 	u8 possible_count;
 	u8 possible[ACPI_PCI_LINK_MAX_POSSIBLE];
@@ -109,18 +109,18 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 	ACPI_FUNCTION_TRACE("acpi_pci_link_check_possible");
 
 	switch (resource->type) {
-	case ACPI_RSTYPE_START_DPF:
+	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
 		return_ACPI_STATUS(AE_OK);
-	case ACPI_RSTYPE_IRQ:
+	case ACPI_RESOURCE_TYPE_IRQ:
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
-			if (!p || !p->number_of_interrupts) {
+			if (!p || !p->interrupt_count) {
 				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
 						  "Blank IRQ resource\n"));
 				return_ACPI_STATUS(AE_OK);
 			}
 			for (i = 0;
-			     (i < p->number_of_interrupts
+			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
 					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
@@ -131,22 +131,22 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 				link->irq.possible[i] = p->interrupts[i];
 				link->irq.possible_count++;
 			}
-			link->irq.edge_level = p->edge_level;
-			link->irq.active_high_low = p->active_high_low;
-			link->irq.resource_type = ACPI_RSTYPE_IRQ;
+			link->irq.triggering = p->triggering;
+			link->irq.polarity = p->polarity;
+			link->irq.resource_type = ACPI_RESOURCE_TYPE_IRQ;
 			break;
 		}
-	case ACPI_RSTYPE_EXT_IRQ:
+	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
 		{
-			struct acpi_resource_ext_irq *p =
+			struct acpi_resource_extended_irq *p =
 			    &resource->data.extended_irq;
-			if (!p || !p->number_of_interrupts) {
+			if (!p || !p->interrupt_count) {
 				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
 						  "Blank EXT IRQ resource\n"));
 				return_ACPI_STATUS(AE_OK);
 			}
 			for (i = 0;
-			     (i < p->number_of_interrupts
+			     (i < p->interrupt_count
 			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
 				if (!p->interrupts[i]) {
 					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
@@ -157,9 +157,9 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 				link->irq.possible[i] = p->interrupts[i];
 				link->irq.possible_count++;
 			}
-			link->irq.edge_level = p->edge_level;
-			link->irq.active_high_low = p->active_high_low;
-			link->irq.resource_type = ACPI_RSTYPE_EXT_IRQ;
+			link->irq.triggering = p->triggering;
+			link->irq.polarity = p->polarity;
+			link->irq.resource_type = ACPI_RESOURCE_TYPE_EXTENDED_IRQ;
 			break;
 		}
 	default:
@@ -202,10 +202,10 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 	ACPI_FUNCTION_TRACE("acpi_pci_link_check_current");
 
 	switch (resource->type) {
-	case ACPI_RSTYPE_IRQ:
+	case ACPI_RESOURCE_TYPE_IRQ:
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
-			if (!p || !p->number_of_interrupts) {
+			if (!p || !p->interrupt_count) {
 				/*
 				 * IRQ descriptors may have no IRQ# bits set,
 				 * particularly those those w/ _STA disabled
@@ -217,11 +217,11 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 			*irq = p->interrupts[0];
 			break;
 		}
-	case ACPI_RSTYPE_EXT_IRQ:
+	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
 		{
-			struct acpi_resource_ext_irq *p =
+			struct acpi_resource_extended_irq *p =
 			    &resource->data.extended_irq;
-			if (!p || !p->number_of_interrupts) {
+			if (!p || !p->interrupt_count) {
 				/*
 				 * extended IRQ descriptors must
 				 * return at least 1 IRQ
@@ -325,36 +325,36 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 	buffer.pointer = resource;
 
 	switch (link->irq.resource_type) {
-	case ACPI_RSTYPE_IRQ:
-		resource->res.type = ACPI_RSTYPE_IRQ;
+	case ACPI_RESOURCE_TYPE_IRQ:
+		resource->res.type = ACPI_RESOURCE_TYPE_IRQ;
 		resource->res.length = sizeof(struct acpi_resource);
-		resource->res.data.irq.edge_level = link->irq.edge_level;
-		resource->res.data.irq.active_high_low =
-		    link->irq.active_high_low;
-		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
-			resource->res.data.irq.shared_exclusive =
+		resource->res.data.irq.triggering = link->irq.triggering;
+		resource->res.data.irq.polarity =
+		    link->irq.polarity;
+		if (link->irq.triggering == ACPI_EDGE_SENSITIVE)
+			resource->res.data.irq.sharable =
 			    ACPI_EXCLUSIVE;
 		else
-			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
-		resource->res.data.irq.number_of_interrupts = 1;
+			resource->res.data.irq.sharable = ACPI_SHARED;
+		resource->res.data.irq.interrupt_count = 1;
 		resource->res.data.irq.interrupts[0] = irq;
 		break;
 
-	case ACPI_RSTYPE_EXT_IRQ:
-		resource->res.type = ACPI_RSTYPE_EXT_IRQ;
+	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
+		resource->res.type = ACPI_RESOURCE_TYPE_EXTENDED_IRQ;
 		resource->res.length = sizeof(struct acpi_resource);
 		resource->res.data.extended_irq.producer_consumer =
 		    ACPI_CONSUMER;
-		resource->res.data.extended_irq.edge_level =
-		    link->irq.edge_level;
-		resource->res.data.extended_irq.active_high_low =
-		    link->irq.active_high_low;
-		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
-			resource->res.data.irq.shared_exclusive =
+		resource->res.data.extended_irq.triggering =
+		    link->irq.triggering;
+		resource->res.data.extended_irq.polarity =
+		    link->irq.polarity;
+		if (link->irq.triggering == ACPI_EDGE_SENSITIVE)
+			resource->res.data.irq.sharable =
 			    ACPI_EXCLUSIVE;
 		else
-			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
-		resource->res.data.extended_irq.number_of_interrupts = 1;
+			resource->res.data.irq.sharable = ACPI_SHARED;
+		resource->res.data.extended_irq.interrupt_count = 1;
 		resource->res.data.extended_irq.interrupts[0] = irq;
 		/* ignore resource_source, it's optional */
 		break;
@@ -364,7 +364,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		goto end;
 
 	}
-	resource->end.type = ACPI_RSTYPE_END_TAG;
+	resource->end.type = ACPI_RESOURCE_TYPE_END_TAG;
 
 	/* Attempt to set the resource */
 	status = acpi_set_current_resources(link->handle, &buffer);
@@ -613,7 +613,7 @@ static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 int
 acpi_pci_link_allocate_irq(acpi_handle handle,
 			   int index,
-			   int *edge_level, int *active_high_low, char **name)
+			   int *triggering, int *polarity, char **name)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
@@ -653,10 +653,10 @@ acpi_pci_link_allocate_irq(acpi_handle handle,
 	link->refcnt++;
 	up(&acpi_link_lock);
 
-	if (edge_level)
-		*edge_level = link->irq.edge_level;
-	if (active_high_low)
-		*active_high_low = link->irq.active_high_low;
+	if (triggering)
+		*triggering = link->irq.triggering;
+	if (polarity)
+		*polarity = link->irq.polarity;
 	if (name)
 		*name = acpi_device_bid(link->device);
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit eca008c8134df15262a0362623edb59902628c95
Author: Len Brown <len.brown@intel.com>
Date:   Thu Sep 22 00:25:18 2005 -0400

    [ACPI] handle ACPICA 20050916's acpi_resource.type rename
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 82292b77e5c6..d8956c0bf143 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -108,7 +108,7 @@ acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_check_possible");
 
-	switch (resource->id) {
+	switch (resource->type) {
 	case ACPI_RSTYPE_START_DPF:
 		return_ACPI_STATUS(AE_OK);
 	case ACPI_RSTYPE_IRQ:
@@ -201,7 +201,7 @@ acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_check_current");
 
-	switch (resource->id) {
+	switch (resource->type) {
 	case ACPI_RSTYPE_IRQ:
 		{
 			struct acpi_resource_irq *p = &resource->data.irq;
@@ -326,7 +326,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 
 	switch (link->irq.resource_type) {
 	case ACPI_RSTYPE_IRQ:
-		resource->res.id = ACPI_RSTYPE_IRQ;
+		resource->res.type = ACPI_RSTYPE_IRQ;
 		resource->res.length = sizeof(struct acpi_resource);
 		resource->res.data.irq.edge_level = link->irq.edge_level;
 		resource->res.data.irq.active_high_low =
@@ -341,7 +341,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		break;
 
 	case ACPI_RSTYPE_EXT_IRQ:
-		resource->res.id = ACPI_RSTYPE_EXT_IRQ;
+		resource->res.type = ACPI_RSTYPE_EXT_IRQ;
 		resource->res.length = sizeof(struct acpi_resource);
 		resource->res.data.extended_irq.producer_consumer =
 		    ACPI_CONSUMER;
@@ -364,7 +364,7 @@ static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 		goto end;
 
 	}
-	resource->end.id = ACPI_RSTYPE_END_TAG;
+	resource->end.type = ACPI_RSTYPE_END_TAG;
 
 	/* Attempt to set the resource */
 	status = acpi_set_current_resources(link->handle, &buffer);

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index e8334ce84d84..82292b77e5c6 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -42,30 +42,26 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-
 #define _COMPONENT		ACPI_PCI_COMPONENT
-ACPI_MODULE_NAME		("pci_link")
-
+ACPI_MODULE_NAME("pci_link")
 #define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
 #define ACPI_PCI_LINK_HID		"PNP0C0F"
 #define ACPI_PCI_LINK_DRIVER_NAME	"ACPI PCI Interrupt Link Driver"
 #define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
 #define ACPI_PCI_LINK_FILE_INFO		"info"
 #define ACPI_PCI_LINK_FILE_STATUS	"state"
-
 #define ACPI_PCI_LINK_MAX_POSSIBLE 16
-
-static int acpi_pci_link_add (struct acpi_device *device);
-static int acpi_pci_link_remove (struct acpi_device *device, int type);
+static int acpi_pci_link_add(struct acpi_device *device);
+static int acpi_pci_link_remove(struct acpi_device *device, int type);
 
 static struct acpi_driver acpi_pci_link_driver = {
-	.name =		ACPI_PCI_LINK_DRIVER_NAME,
-	.class =	ACPI_PCI_LINK_CLASS,
-	.ids =		ACPI_PCI_LINK_HID,
-	.ops =		{
-				.add =    acpi_pci_link_add,
-				.remove = acpi_pci_link_remove,
-			},
+	.name = ACPI_PCI_LINK_DRIVER_NAME,
+	.class = ACPI_PCI_LINK_CLASS,
+	.ids = ACPI_PCI_LINK_HID,
+	.ops = {
+		.add = acpi_pci_link_add,
+		.remove = acpi_pci_link_remove,
+		},
 };
 
 /*
@@ -73,31 +69,30 @@ static struct acpi_driver acpi_pci_link_driver = {
  * later even the link is disable. Instead, we just repick the active irq
  */
 struct acpi_pci_link_irq {
-	u8			active;			/* Current IRQ */
-	u8			edge_level;		/* All IRQs */
-	u8			active_high_low;	/* All IRQs */
-	u8			resource_type;
-	u8			possible_count;
-	u8			possible[ACPI_PCI_LINK_MAX_POSSIBLE];
-	u8			initialized:1;
-	u8			reserved:7;
+	u8 active;		/* Current IRQ */
+	u8 edge_level;		/* All IRQs */
+	u8 active_high_low;	/* All IRQs */
+	u8 resource_type;
+	u8 possible_count;
+	u8 possible[ACPI_PCI_LINK_MAX_POSSIBLE];
+	u8 initialized:1;
+	u8 reserved:7;
 };
 
 struct acpi_pci_link {
-	struct list_head	node;
-	struct acpi_device	*device;
-	acpi_handle		handle;
+	struct list_head node;
+	struct acpi_device *device;
+	acpi_handle handle;
 	struct acpi_pci_link_irq irq;
-	int			refcnt;
+	int refcnt;
 };
 
 static struct {
-	int			count;
-	struct list_head	entries;
-}				acpi_link;
+	int count;
+	struct list_head entries;
+} acpi_link;
 DECLARE_MUTEX(acpi_link_lock);
 
-
 /* --------------------------------------------------------------------------
                             PCI Link Device Management
    -------------------------------------------------------------------------- */
@@ -106,12 +101,10 @@ DECLARE_MUTEX(acpi_link_lock);
  * set context (link) possible list from resource list
  */
 static acpi_status
-acpi_pci_link_check_possible (
-	struct acpi_resource	*resource,
-	void			*context)
+acpi_pci_link_check_possible(struct acpi_resource *resource, void *context)
 {
-	struct acpi_pci_link	*link = (struct acpi_pci_link *) context;
-	u32			i = 0;
+	struct acpi_pci_link *link = (struct acpi_pci_link *)context;
+	u32 i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_check_possible");
 
@@ -119,61 +112,68 @@ acpi_pci_link_check_possible (
 	case ACPI_RSTYPE_START_DPF:
 		return_ACPI_STATUS(AE_OK);
 	case ACPI_RSTYPE_IRQ:
-	{
-		struct acpi_resource_irq *p = &resource->data.irq;
-		if (!p || !p->number_of_interrupts) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Blank IRQ resource\n"));
-			return_ACPI_STATUS(AE_OK);
-		}
-		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
-			if (!p->interrupts[i]) {
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
-				continue;
+		{
+			struct acpi_resource_irq *p = &resource->data.irq;
+			if (!p || !p->number_of_interrupts) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+						  "Blank IRQ resource\n"));
+				return_ACPI_STATUS(AE_OK);
 			}
-			link->irq.possible[i] = p->interrupts[i];
-			link->irq.possible_count++;
+			for (i = 0;
+			     (i < p->number_of_interrupts
+			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+				if (!p->interrupts[i]) {
+					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+							  "Invalid IRQ %d\n",
+							  p->interrupts[i]));
+					continue;
+				}
+				link->irq.possible[i] = p->interrupts[i];
+				link->irq.possible_count++;
+			}
+			link->irq.edge_level = p->edge_level;
+			link->irq.active_high_low = p->active_high_low;
+			link->irq.resource_type = ACPI_RSTYPE_IRQ;
+			break;
 		}
-		link->irq.edge_level = p->edge_level;
-		link->irq.active_high_low = p->active_high_low;
-		link->irq.resource_type = ACPI_RSTYPE_IRQ;
-		break;
-	}
 	case ACPI_RSTYPE_EXT_IRQ:
-	{
-		struct acpi_resource_ext_irq *p = &resource->data.extended_irq;
-		if (!p || !p->number_of_interrupts) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-				"Blank EXT IRQ resource\n"));
-			return_ACPI_STATUS(AE_OK);
-		}
-		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
-			if (!p->interrupts[i]) {
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
-				continue;
+		{
+			struct acpi_resource_ext_irq *p =
+			    &resource->data.extended_irq;
+			if (!p || !p->number_of_interrupts) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+						  "Blank EXT IRQ resource\n"));
+				return_ACPI_STATUS(AE_OK);
+			}
+			for (i = 0;
+			     (i < p->number_of_interrupts
+			      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+				if (!p->interrupts[i]) {
+					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+							  "Invalid IRQ %d\n",
+							  p->interrupts[i]));
+					continue;
+				}
+				link->irq.possible[i] = p->interrupts[i];
+				link->irq.possible_count++;
 			}
-			link->irq.possible[i] = p->interrupts[i];
-			link->irq.possible_count++;
+			link->irq.edge_level = p->edge_level;
+			link->irq.active_high_low = p->active_high_low;
+			link->irq.resource_type = ACPI_RSTYPE_EXT_IRQ;
+			break;
 		}
-		link->irq.edge_level = p->edge_level;
-		link->irq.active_high_low = p->active_high_low;
-		link->irq.resource_type = ACPI_RSTYPE_EXT_IRQ;
-		break;
-	}
 	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Resource is not an IRQ entry\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Resource is not an IRQ entry\n"));
 		return_ACPI_STATUS(AE_OK);
 	}
 
 	return_ACPI_STATUS(AE_CTRL_TERMINATE);
 }
 
-
-static int
-acpi_pci_link_get_possible (
-	struct acpi_pci_link	*link)
+static int acpi_pci_link_get_possible(struct acpi_pci_link *link)
 {
-	acpi_status		status;
+	acpi_status status;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_get_possible");
 
@@ -181,62 +181,60 @@ acpi_pci_link_get_possible (
 		return_VALUE(-EINVAL);
 
 	status = acpi_walk_resources(link->handle, METHOD_NAME__PRS,
-			acpi_pci_link_check_possible, link);
+				     acpi_pci_link_check_possible, link);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRS\n"));
 		return_VALUE(-ENODEV);
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Found %d possible IRQs\n", link->irq.possible_count));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Found %d possible IRQs\n",
+			  link->irq.possible_count));
 
 	return_VALUE(0);
 }
 
-
 static acpi_status
-acpi_pci_link_check_current (
-	struct acpi_resource	*resource,
-	void			*context)
+acpi_pci_link_check_current(struct acpi_resource *resource, void *context)
 {
-	int			*irq = (int *) context;
+	int *irq = (int *)context;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_check_current");
 
 	switch (resource->id) {
 	case ACPI_RSTYPE_IRQ:
-	{
-		struct acpi_resource_irq *p = &resource->data.irq;
-		if (!p || !p->number_of_interrupts) {
-			/*
-			 * IRQ descriptors may have no IRQ# bits set,
-			 * particularly those those w/ _STA disabled
-			 */
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"Blank IRQ resource\n")); 
-			return_ACPI_STATUS(AE_OK);
+		{
+			struct acpi_resource_irq *p = &resource->data.irq;
+			if (!p || !p->number_of_interrupts) {
+				/*
+				 * IRQ descriptors may have no IRQ# bits set,
+				 * particularly those those w/ _STA disabled
+				 */
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+						  "Blank IRQ resource\n"));
+				return_ACPI_STATUS(AE_OK);
+			}
+			*irq = p->interrupts[0];
+			break;
 		}
-		*irq = p->interrupts[0];
-		break;
-	}
 	case ACPI_RSTYPE_EXT_IRQ:
-	{
-		struct acpi_resource_ext_irq *p = &resource->data.extended_irq;
-		if (!p || !p->number_of_interrupts) {
-			/*
-			 * extended IRQ descriptors must
-			 * return at least 1 IRQ
-			 */
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				"Blank EXT IRQ resource\n"));
-			return_ACPI_STATUS(AE_OK);
+		{
+			struct acpi_resource_ext_irq *p =
+			    &resource->data.extended_irq;
+			if (!p || !p->number_of_interrupts) {
+				/*
+				 * extended IRQ descriptors must
+				 * return at least 1 IRQ
+				 */
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+						  "Blank EXT IRQ resource\n"));
+				return_ACPI_STATUS(AE_OK);
+			}
+			*irq = p->interrupts[0];
+			break;
 		}
-		*irq = p->interrupts[0];
-		break;
-	}
 	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Resource isn't an IRQ\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Resource isn't an IRQ\n"));
 		return_ACPI_STATUS(AE_OK);
 	}
 	return_ACPI_STATUS(AE_CTRL_TERMINATE);
@@ -249,13 +247,11 @@ acpi_pci_link_check_current (
  * 0 - success
  * !0 - failure
  */
-static int
-acpi_pci_link_get_current (
-	struct acpi_pci_link	*link)
+static int acpi_pci_link_get_current(struct acpi_pci_link *link)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	int			irq = 0;
+	int result = 0;
+	acpi_status status = AE_OK;
+	int irq = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_get_current");
 
@@ -269,7 +265,8 @@ acpi_pci_link_get_current (
 		/* Query _STA, set link->device->status */
 		result = acpi_bus_get_status(link->device);
 		if (result) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Unable to read status\n"));
 			goto end;
 		}
 
@@ -284,7 +281,7 @@ acpi_pci_link_get_current (
 	 */
 
 	status = acpi_walk_resources(link->handle, METHOD_NAME__CRS,
-			acpi_pci_link_check_current, &irq);
+				     acpi_pci_link_check_current, &irq);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _CRS\n"));
 		result = -ENODEV;
@@ -300,58 +297,61 @@ acpi_pci_link_get_current (
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link at IRQ %d \n", link->irq.active));
 
-end:
+      end:
 	return_VALUE(result);
 }
 
-static int
-acpi_pci_link_set (
-	struct acpi_pci_link	*link,
-	int			irq)
+static int acpi_pci_link_set(struct acpi_pci_link *link, int irq)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
+	int result = 0;
+	acpi_status status = AE_OK;
 	struct {
-		struct acpi_resource	res;
-		struct acpi_resource	end;
-	}    *resource;
-	struct acpi_buffer	buffer = {0, NULL};
+		struct acpi_resource res;
+		struct acpi_resource end;
+	} *resource;
+	struct acpi_buffer buffer = { 0, NULL };
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
 
 	if (!link || !irq)
 		return_VALUE(-EINVAL);
 
-	resource = kmalloc( sizeof(*resource)+1, GFP_KERNEL);
-	if(!resource)
+	resource = kmalloc(sizeof(*resource) + 1, GFP_KERNEL);
+	if (!resource)
 		return_VALUE(-ENOMEM);
 
-	memset(resource, 0, sizeof(*resource)+1);
-	buffer.length = sizeof(*resource) +1;
+	memset(resource, 0, sizeof(*resource) + 1);
+	buffer.length = sizeof(*resource) + 1;
 	buffer.pointer = resource;
 
-	switch(link->irq.resource_type) {
+	switch (link->irq.resource_type) {
 	case ACPI_RSTYPE_IRQ:
 		resource->res.id = ACPI_RSTYPE_IRQ;
 		resource->res.length = sizeof(struct acpi_resource);
 		resource->res.data.irq.edge_level = link->irq.edge_level;
-		resource->res.data.irq.active_high_low = link->irq.active_high_low;
+		resource->res.data.irq.active_high_low =
+		    link->irq.active_high_low;
 		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
-			resource->res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
+			resource->res.data.irq.shared_exclusive =
+			    ACPI_EXCLUSIVE;
 		else
 			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
 		resource->res.data.irq.number_of_interrupts = 1;
 		resource->res.data.irq.interrupts[0] = irq;
 		break;
-	   
+
 	case ACPI_RSTYPE_EXT_IRQ:
 		resource->res.id = ACPI_RSTYPE_EXT_IRQ;
 		resource->res.length = sizeof(struct acpi_resource);
-		resource->res.data.extended_irq.producer_consumer = ACPI_CONSUMER;
-		resource->res.data.extended_irq.edge_level = link->irq.edge_level;
-		resource->res.data.extended_irq.active_high_low = link->irq.active_high_low;
+		resource->res.data.extended_irq.producer_consumer =
+		    ACPI_CONSUMER;
+		resource->res.data.extended_irq.edge_level =
+		    link->irq.edge_level;
+		resource->res.data.extended_irq.active_high_low =
+		    link->irq.active_high_low;
 		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
-			resource->res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
+			resource->res.data.irq.shared_exclusive =
+			    ACPI_EXCLUSIVE;
 		else
 			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
 		resource->res.data.extended_irq.number_of_interrupts = 1;
@@ -384,9 +384,9 @@ acpi_pci_link_set (
 	}
 	if (!link->device->status.enabled) {
 		printk(KERN_WARNING PREFIX
-			"%s [%s] disabled and referenced, BIOS bug.\n",
-			acpi_device_name(link->device),
-			acpi_device_bid(link->device));
+		       "%s [%s] disabled and referenced, BIOS bug.\n",
+		       acpi_device_name(link->device),
+		       acpi_device_bid(link->device));
 	}
 
 	/* Query _CRS, set link->irq.active */
@@ -404,22 +404,20 @@ acpi_pci_link_set (
 		 * policy: when _CRS doesn't return what we just _SRS
 		 * assume _SRS worked and override _CRS value.
 		 */
-		printk(KERN_WARNING PREFIX 
-			"%s [%s] BIOS reported IRQ %d, using IRQ %d\n",
-			acpi_device_name(link->device),
-			acpi_device_bid(link->device),
-			link->irq.active, irq);
+		printk(KERN_WARNING PREFIX
+		       "%s [%s] BIOS reported IRQ %d, using IRQ %d\n",
+		       acpi_device_name(link->device),
+		       acpi_device_bid(link->device), link->irq.active, irq);
 		link->irq.active = irq;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Set IRQ %d\n", link->irq.active));
-	
-end:
+
+      end:
 	kfree(resource);
 	return_VALUE(result);
 }
 
-
 /* --------------------------------------------------------------------------
                             PCI Link IRQ Management
    -------------------------------------------------------------------------- */
@@ -469,8 +467,8 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ0 timer */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ1 keyboard */
 	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ2 cascade */
-	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ3	serial */
-	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ4	serial */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ3 serial */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ4 serial */
 	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ5 sometimes SoundBlaster */
 	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ6 */
 	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ7 parallel, spurious */
@@ -482,15 +480,14 @@ static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
 	PIRQ_PENALTY_ISA_USED,	/* IRQ13 fpe, sometimes */
 	PIRQ_PENALTY_ISA_USED,	/* IRQ14 ide0 */
 	PIRQ_PENALTY_ISA_USED,	/* IRQ15 ide1 */
-			/* >IRQ15 */
+	/* >IRQ15 */
 };
 
-int __init
-acpi_irq_penalty_init(void)
+int __init acpi_irq_penalty_init(void)
 {
-	struct list_head	*node = NULL;
-	struct acpi_pci_link    *link = NULL;
-	int			i = 0;
+	struct list_head *node = NULL;
+	struct acpi_pci_link *link = NULL;
+	int i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_irq_penalty_init");
 
@@ -501,7 +498,8 @@ acpi_irq_penalty_init(void)
 
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Invalid link context\n"));
 			continue;
 		}
 
@@ -510,15 +508,20 @@ acpi_irq_penalty_init(void)
 		 * useful for breaking ties.
 		 */
 		if (link->irq.possible_count) {
-			int penalty = PIRQ_PENALTY_PCI_POSSIBLE / link->irq.possible_count;
+			int penalty =
+			    PIRQ_PENALTY_PCI_POSSIBLE /
+			    link->irq.possible_count;
 
 			for (i = 0; i < link->irq.possible_count; i++) {
 				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)
-					acpi_irq_penalty[link->irq.possible[i]] += penalty;
+					acpi_irq_penalty[link->irq.
+							 possible[i]] +=
+					    penalty;
 			}
 
 		} else if (link->irq.active) {
-			acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_POSSIBLE;
+			acpi_irq_penalty[link->irq.active] +=
+			    PIRQ_PENALTY_PCI_POSSIBLE;
 		}
 	}
 	/* Add a penalty for the SCI */
@@ -529,10 +532,10 @@ acpi_irq_penalty_init(void)
 
 static int acpi_irq_balance;	/* 0: static, 1: balance */
 
-static int acpi_pci_link_allocate(struct acpi_pci_link	*link)
+static int acpi_pci_link_allocate(struct acpi_pci_link *link)
 {
-	int			irq;
-	int			i;
+	int irq;
+	int i;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate");
 
@@ -556,7 +559,7 @@ static int acpi_pci_link_allocate(struct acpi_pci_link	*link)
 	if (i == link->irq.possible_count) {
 		if (acpi_strict)
 			printk(KERN_WARNING PREFIX "_CRS %d not found"
-				" in _PRS\n", link->irq.active);
+			       " in _PRS\n", link->irq.active);
 		link->irq.active = 0;
 	}
 
@@ -575,23 +578,25 @@ static int acpi_pci_link_allocate(struct acpi_pci_link	*link)
 		 * the use of IRQs 9, 10, 11, and >15.
 		 */
 		for (i = (link->irq.possible_count - 1); i >= 0; i--) {
-			if (acpi_irq_penalty[irq] > acpi_irq_penalty[link->irq.possible[i]])
+			if (acpi_irq_penalty[irq] >
+			    acpi_irq_penalty[link->irq.possible[i]])
 				irq = link->irq.possible[i];
 		}
 	}
 
 	/* Attempt to enable the link device at this IRQ. */
 	if (acpi_pci_link_set(link, irq)) {
-		printk(PREFIX "Unable to set IRQ for %s [%s] (likely buggy ACPI BIOS).\n"
-				"Try pci=noacpi or acpi=off\n",
-			acpi_device_name(link->device),
-			acpi_device_bid(link->device));
+		printk(PREFIX
+		       "Unable to set IRQ for %s [%s] (likely buggy ACPI BIOS).\n"
+		       "Try pci=noacpi or acpi=off\n",
+		       acpi_device_name(link->device),
+		       acpi_device_bid(link->device));
 		return_VALUE(-ENODEV);
 	} else {
 		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
-		printk(PREFIX "%s [%s] enabled at IRQ %d\n", 
-			acpi_device_name(link->device),
-			acpi_device_bid(link->device), link->irq.active);
+		printk(PREFIX "%s [%s] enabled at IRQ %d\n",
+		       acpi_device_name(link->device),
+		       acpi_device_bid(link->device), link->irq.active);
 	}
 
 	link->irq.initialized = 1;
@@ -606,16 +611,13 @@ static int acpi_pci_link_allocate(struct acpi_pci_link	*link)
  */
 
 int
-acpi_pci_link_allocate_irq (
-	acpi_handle		handle,
-	int			index,
-	int			*edge_level,
-	int			*active_high_low,
-	char			**name)
+acpi_pci_link_allocate_irq(acpi_handle handle,
+			   int index,
+			   int *edge_level, int *active_high_low, char **name)
 {
-	int                     result = 0;
-	struct acpi_device	*device = NULL;
-	struct acpi_pci_link	*link = NULL;
+	int result = 0;
+	struct acpi_device *device = NULL;
+	struct acpi_pci_link *link = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate_irq");
 
@@ -625,7 +627,7 @@ acpi_pci_link_allocate_irq (
 		return_VALUE(-1);
 	}
 
-	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
 		return_VALUE(-1);
@@ -642,20 +644,24 @@ acpi_pci_link_allocate_irq (
 		up(&acpi_link_lock);
 		return_VALUE(-1);
 	}
-	   
+
 	if (!link->irq.active) {
 		up(&acpi_link_lock);
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link active IRQ is 0!\n"));
 		return_VALUE(-1);
 	}
-	link->refcnt ++;
+	link->refcnt++;
 	up(&acpi_link_lock);
 
-	if (edge_level) *edge_level = link->irq.edge_level;
-	if (active_high_low) *active_high_low = link->irq.active_high_low;
-	if (name) *name = acpi_device_bid(link->device);
+	if (edge_level)
+		*edge_level = link->irq.edge_level;
+	if (active_high_low)
+		*active_high_low = link->irq.active_high_low;
+	if (name)
+		*name = acpi_device_bid(link->device);
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-		"Link %s is referenced\n", acpi_device_bid(link->device)));
+			  "Link %s is referenced\n",
+			  acpi_device_bid(link->device)));
 	return_VALUE(link->irq.active);
 }
 
@@ -663,12 +669,11 @@ acpi_pci_link_allocate_irq (
  * We don't change link's irq information here.  After it is reenabled, we
  * continue use the info
  */
-int
-acpi_pci_link_free_irq(acpi_handle handle)
+int acpi_pci_link_free_irq(acpi_handle handle)
 {
-	struct acpi_device	*device = NULL;
-	struct acpi_pci_link	*link = NULL;
-	acpi_status		result;
+	struct acpi_device *device = NULL;
+	struct acpi_pci_link *link = NULL;
+	acpi_status result;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_free_irq");
 
@@ -678,7 +683,7 @@ acpi_pci_link_free_irq(acpi_handle handle)
 		return_VALUE(-1);
 	}
 
-	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	link = (struct acpi_pci_link *)acpi_driver_data(device);
 	if (!link) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
 		return_VALUE(-1);
@@ -690,7 +695,6 @@ acpi_pci_link_free_irq(acpi_handle handle)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link isn't initialized\n"));
 		return_VALUE(-1);
 	}
-
 #ifdef	FUTURE_USE
 	/*
 	 * The Link reference count allows us to _DISable an unused link
@@ -701,10 +705,11 @@ acpi_pci_link_free_irq(acpi_handle handle)
 	 * to prevent duplicate acpi_pci_link_set()
 	 * which would harm some systems
 	 */
-	link->refcnt --;
+	link->refcnt--;
 #endif
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-		"Link %s is dereferenced\n", acpi_device_bid(link->device)));
+			  "Link %s is dereferenced\n",
+			  acpi_device_bid(link->device)));
 
 	if (link->refcnt == 0) {
 		acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
@@ -712,17 +717,17 @@ acpi_pci_link_free_irq(acpi_handle handle)
 	up(&acpi_link_lock);
 	return_VALUE(link->irq.active);
 }
+
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
 
-static int
-acpi_pci_link_add(struct acpi_device *device)
+static int acpi_pci_link_add(struct acpi_device *device)
 {
-	int			result = 0;
-	struct acpi_pci_link	*link = NULL;
-	int			i = 0;
-	int			found = 0;
+	int result = 0;
+	struct acpi_pci_link *link = NULL;
+	int i = 0;
+	int found = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_add");
 
@@ -749,13 +754,12 @@ acpi_pci_link_add(struct acpi_device *device)
 	acpi_pci_link_get_current(link);
 
 	printk(PREFIX "%s [%s] (IRQs", acpi_device_name(device),
-		acpi_device_bid(device));
+	       acpi_device_bid(device));
 	for (i = 0; i < link->irq.possible_count; i++) {
 		if (link->irq.active == link->irq.possible[i]) {
 			printk(" *%d", link->irq.possible[i]);
 			found = 1;
-		}
-		else
+		} else
 			printk(" %d", link->irq.possible[i]);
 	}
 
@@ -764,7 +768,7 @@ acpi_pci_link_add(struct acpi_device *device)
 	if (!found)
 		printk(" *%d", link->irq.active);
 
-	if(!link->device->status.enabled)
+	if (!link->device->status.enabled)
 		printk(", disabled.");
 
 	printk("\n");
@@ -773,7 +777,7 @@ acpi_pci_link_add(struct acpi_device *device)
 	list_add_tail(&link->node, &acpi_link.entries);
 	acpi_link.count++;
 
-end:
+      end:
 	/* disable all links -- to be activated on use */
 	acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
 	up(&acpi_link_lock);
@@ -784,9 +788,7 @@ acpi_pci_link_add(struct acpi_device *device)
 	return_VALUE(result);
 }
 
-static int
-acpi_pci_link_resume(
-	struct acpi_pci_link *link)
+static int acpi_pci_link_resume(struct acpi_pci_link *link)
 {
 	ACPI_FUNCTION_TRACE("acpi_pci_link_resume");
 
@@ -801,11 +803,10 @@ acpi_pci_link_resume(
  * after every device calls pci_disable_device in .resume.
  */
 int acpi_in_resume;
-static int
-irqrouter_resume(struct sys_device *dev)
+static int irqrouter_resume(struct sys_device *dev)
 {
-	struct list_head        *node = NULL;
-	struct acpi_pci_link    *link = NULL;
+	struct list_head *node = NULL;
+	struct acpi_pci_link *link = NULL;
 
 	ACPI_FUNCTION_TRACE("irqrouter_resume");
 
@@ -814,7 +815,7 @@ irqrouter_resume(struct sys_device *dev)
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
 			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				"Invalid link context\n"));
+					  "Invalid link context\n"));
 			continue;
 		}
 		acpi_pci_link_resume(link);
@@ -823,9 +824,7 @@ irqrouter_resume(struct sys_device *dev)
 	return_VALUE(0);
 }
 
-
-static int
-acpi_pci_link_remove(struct acpi_device *device, int type)
+static int acpi_pci_link_remove(struct acpi_device *device, int type)
 {
 	struct acpi_pci_link *link = NULL;
 
@@ -834,7 +833,7 @@ acpi_pci_link_remove(struct acpi_device *device, int type)
 	if (!device || !acpi_driver_data(device))
 		return_VALUE(-EINVAL);
 
-	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	link = (struct acpi_pci_link *)acpi_driver_data(device);
 
 	down(&acpi_link_lock);
 	list_del(&link->node);
@@ -856,14 +855,14 @@ static int __init acpi_irq_penalty_update(char *str, int used)
 		int retval;
 		int irq;
 
-		retval = get_option(&str,&irq);
+		retval = get_option(&str, &irq);
 
 		if (!retval)
 			break;	/* no number found */
 
 		if (irq < 0)
 			continue;
-		
+
 		if (irq >= ACPI_MAX_IRQS)
 			continue;
 
@@ -902,6 +901,7 @@ static int __init acpi_irq_isa(char *str)
 {
 	return acpi_irq_penalty_update(str, 1);
 }
+
 __setup("acpi_irq_isa=", acpi_irq_isa);
 
 /*
@@ -913,6 +913,7 @@ static int __init acpi_irq_pci(char *str)
 {
 	return acpi_irq_penalty_update(str, 0);
 }
+
 __setup("acpi_irq_pci=", acpi_irq_pci);
 
 static int __init acpi_irq_nobalance_set(char *str)
@@ -920,6 +921,7 @@ static int __init acpi_irq_nobalance_set(char *str)
 	acpi_irq_balance = 0;
 	return 1;
 }
+
 __setup("acpi_irq_nobalance", acpi_irq_nobalance_set);
 
 int __init acpi_irq_balance_set(char *str)
@@ -927,22 +929,20 @@ int __init acpi_irq_balance_set(char *str)
 	acpi_irq_balance = 1;
 	return 1;
 }
-__setup("acpi_irq_balance", acpi_irq_balance_set);
 
+__setup("acpi_irq_balance", acpi_irq_balance_set);
 
 /* FIXME: we will remove this interface after all drivers call pci_disable_device */
 static struct sysdev_class irqrouter_sysdev_class = {
-        set_kset_name("irqrouter"),
-        .resume = irqrouter_resume,
+	set_kset_name("irqrouter"),
+	.resume = irqrouter_resume,
 };
 
-
 static struct sys_device device_irqrouter = {
-	.id     = 0,
-	.cls    = &irqrouter_sysdev_class,
+	.id = 0,
+	.cls = &irqrouter_sysdev_class,
 };
 
-
 static int __init irqrouter_init_sysfs(void)
 {
 	int error;
@@ -957,12 +957,11 @@ static int __init irqrouter_init_sysfs(void)
 		error = sysdev_register(&device_irqrouter);
 
 	return_VALUE(error);
-}                                        
+}
 
 device_initcall(irqrouter_init_sysfs);
 
-
-static int __init acpi_pci_link_init (void)
+static int __init acpi_pci_link_init(void)
 {
 	ACPI_FUNCTION_TRACE("acpi_pci_link_init");
 

commit c65ade4dc8b486e8c8b9b0a6399789a5428e2039
Author: Pavel Machek <pavel@suze.cz>
Date:   Fri Aug 5 00:37:45 2005 -0400

    [ACPI] whitespace
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 26aa3829f1de..e8334ce84d84 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -529,8 +529,7 @@ acpi_irq_penalty_init(void)
 
 static int acpi_irq_balance;	/* 0: static, 1: balance */
 
-static int acpi_pci_link_allocate(
-	struct acpi_pci_link	*link)
+static int acpi_pci_link_allocate(struct acpi_pci_link	*link)
 {
 	int			irq;
 	int			i;
@@ -718,8 +717,7 @@ acpi_pci_link_free_irq(acpi_handle handle)
    -------------------------------------------------------------------------- */
 
 static int
-acpi_pci_link_add (
-	struct acpi_device *device)
+acpi_pci_link_add(struct acpi_device *device)
 {
 	int			result = 0;
 	struct acpi_pci_link	*link = NULL;
@@ -827,9 +825,7 @@ irqrouter_resume(struct sys_device *dev)
 
 
 static int
-acpi_pci_link_remove (
-	struct acpi_device	*device,
-	int			type)
+acpi_pci_link_remove(struct acpi_device *device, int type)
 {
 	struct acpi_pci_link *link = NULL;
 

commit 1d492eb41371d9a5145651e8eb64bea1042a4057
Merge: 5d2a22079c82 cbfc1bae55bb
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:31:42 2005 -0400

    [ACPI] Merge acpi-2.6.12 branch into 2.6.13-rc3
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 4fdcf0804598f44b0f48da9e5281af48a4db393f
Author: Andrew Morton <len.brown@intel.com>
Date:   Sat Jul 30 04:18:00 2005 -0400

    [ACPI] lint: irqrouter_suspend() takes a pm_message_t, not a u32
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 0091dbdf7ef9..a0df2f3606d3 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -786,10 +786,7 @@ acpi_pci_link_add (
 	return_VALUE(result);
 }
 
-static int
-irqrouter_suspend(
-	struct sys_device *dev,
-	u32	state)
+static int irqrouter_suspend(struct sys_device *dev, pm_message_t state)
 {
 	struct list_head        *node = NULL;
 	struct acpi_pci_link    *link = NULL;

commit 11e981f1e02c2a36465cbb208b21cb8b6480f399
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Wed Aug 3 23:46:33 2005 -0400

    [ACPI] S3 resume: avoid kmalloc() might_sleep oops symptom
    
    ACPI now uses kmalloc(...,GPF_ATOMIC) during suspend/resume.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 65cea07abbc3..834c2ceff1aa 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -798,6 +798,11 @@ acpi_pci_link_resume(
 		return_VALUE(0);
 }
 
+/*
+ * FIXME: this is a workaround to avoid nasty warning.  It will be removed
+ * after every device calls pci_disable_device in .resume.
+ */
+int acpi_in_resume;
 static int
 irqrouter_resume(
 	struct sys_device *dev)
@@ -807,6 +812,7 @@ irqrouter_resume(
 
 	ACPI_FUNCTION_TRACE("irqrouter_resume");
 
+	acpi_in_resume = 1;
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
@@ -816,6 +822,7 @@ irqrouter_resume(
 		}
 		acpi_pci_link_resume(link);
 	}
+	acpi_in_resume = 0;
 	return_VALUE(0);
 }
 

commit 8066eff0a1a0703ad901dbe5646a47dbfc089ef2
Merge: 9a351e30d72d 79cda7d0e1c8
Author: Len Brown <len.brown@intel.com>
Date:   Wed Aug 3 18:15:15 2005 -0400

    /home/lenb/src/to-linus branch 'acpi-2.6.12'

commit ecc21ebe603af31f172c43b8b261df79040790ef
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Wed Aug 3 11:00:11 2005 -0400

    [ACPI] PCI interrupt link suspend/resume - revert to 2.6.12 behaviour
    
    This patch disables the PCI Interrupt Link refernece counts,
    which should not co-exist with the 2.6.12 irq_router.resume
    method or else a double acpi_pci_link_set() could result
    on resume.
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 6a29610edc11..0091dbdf7ef9 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -692,7 +692,18 @@ acpi_pci_link_free_irq(acpi_handle handle)
 		return_VALUE(-1);
 	}
 
+#ifdef	FUTURE_USE
+	/*
+	 * The Link reference count allows us to _DISable an unused link
+	 * and suspend time, and set it again  on resume.
+	 * However, 2.6.12 still has irq_router.resume
+	 * which blindly restores the link state.
+	 * So we disable the reference count method
+	 * to prevent duplicate acpi_pci_link_set()
+	 * which would harm some systems
+	 */
 	link->refcnt --;
+#endif
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Link %s is dereferenced\n", acpi_device_bid(link->device)));
 

commit 697a2d63a3844caaa2b6565ab7f3d69086af94d4
Author: Linus Torvalds <torvalds@evo.osdl.org>
Date:   Mon Aug 1 12:37:54 2005 -0700

    Revert ACPI interrupt resume changes
    
    If there are devices that use interrupts over a suspend event, ACPI must
    restore the PCI interrupt links on resume.  Anything else breaks any
    device that hasn't been converted to the new (dubious) PM rules.
    
    Drivers that need the irq free/re-aquire sequence can be done one by one
    independently of this one.

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 6a29610edc11..d9a9b86ecb28 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -776,15 +776,25 @@ acpi_pci_link_add (
 }
 
 static int
-irqrouter_suspend(
-	struct sys_device *dev,
-	u32	state)
+acpi_pci_link_resume(
+	struct acpi_pci_link *link)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_link_resume");
+
+	if (link->refcnt && link->irq.active && link->irq.initialized)
+		return_VALUE(acpi_pci_link_set(link, link->irq.active));
+	else
+		return_VALUE(0);
+}
+
+static int
+irqrouter_resume(
+	struct sys_device *dev)
 {
 	struct list_head        *node = NULL;
 	struct acpi_pci_link    *link = NULL;
-	int			ret = 0;
 
-	ACPI_FUNCTION_TRACE("irqrouter_suspend");
+	ACPI_FUNCTION_TRACE("irqrouter_resume");
 
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
@@ -793,21 +803,9 @@ irqrouter_suspend(
 				"Invalid link context\n"));
 			continue;
 		}
-		if (link->irq.initialized && link->refcnt != 0
-			/* We ignore legacy IDE device irq */
-			&& link->irq.active != 14 && link->irq.active !=15) {
-			printk(KERN_WARNING PREFIX
-				"%d drivers with interrupt %d neglected to call"
-				" pci_disable_device at .suspend\n",
-				link->refcnt,
-				link->irq.active);
-			printk(KERN_WARNING PREFIX
-				"Fix the driver, or rmmod before suspend\n");
-			link->refcnt = 0;
-			ret = -EINVAL;
-		}
+		acpi_pci_link_resume(link);
 	}
-	return_VALUE(ret);
+	return_VALUE(0);
 }
 
 
@@ -922,7 +920,7 @@ __setup("acpi_irq_balance", acpi_irq_balance_set);
 /* FIXME: we will remove this interface after all drivers call pci_disable_device */
 static struct sysdev_class irqrouter_sysdev_class = {
         set_kset_name("irqrouter"),
-        .suspend = irqrouter_suspend,
+        .resume = irqrouter_resume,
 };
 
 

commit 87bec66b9691522414862dd8d41e430b063735ef
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Wed Jul 27 23:02:00 2005 -0400

    [ACPI] suspend/resume ACPI PCI Interrupt Links
    
    Add reference count and disable ACPI PCI Interrupt Link
    when no device still uses it.
    
    Warn when drivers have not released Link at suspend time.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 6ad0e77df9b3..6a29610edc11 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -68,6 +68,10 @@ static struct acpi_driver acpi_pci_link_driver = {
 			},
 };
 
+/*
+ * If a link is initialized, we never change its active and initialized
+ * later even the link is disable. Instead, we just repick the active irq
+ */
 struct acpi_pci_link_irq {
 	u8			active;			/* Current IRQ */
 	u8			edge_level;		/* All IRQs */
@@ -76,8 +80,7 @@ struct acpi_pci_link_irq {
 	u8			possible_count;
 	u8			possible[ACPI_PCI_LINK_MAX_POSSIBLE];
 	u8			initialized:1;
-	u8			suspend_resume:1;
-	u8			reserved:6;
+	u8			reserved:7;
 };
 
 struct acpi_pci_link {
@@ -85,12 +88,14 @@ struct acpi_pci_link {
 	struct acpi_device	*device;
 	acpi_handle		handle;
 	struct acpi_pci_link_irq irq;
+	int			refcnt;
 };
 
 static struct {
 	int			count;
 	struct list_head	entries;
 }				acpi_link;
+DECLARE_MUTEX(acpi_link_lock);
 
 
 /* --------------------------------------------------------------------------
@@ -532,12 +537,12 @@ static int acpi_pci_link_allocate(
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate");
 
-	if (link->irq.suspend_resume) {
-		acpi_pci_link_set(link, link->irq.active);
-		link->irq.suspend_resume = 0;
-	}
-	if (link->irq.initialized)
+	if (link->irq.initialized) {
+		if (link->refcnt == 0)
+			/* This means the link is disabled but initialized */
+			acpi_pci_link_set(link, link->irq.active);
 		return_VALUE(0);
+	}
 
 	/*
 	 * search for active IRQ in list of possible IRQs.
@@ -596,13 +601,13 @@ static int acpi_pci_link_allocate(
 }
 
 /*
- * acpi_pci_link_get_irq
+ * acpi_pci_link_allocate_irq
  * success: return IRQ >= 0
  * failure: return -1
  */
 
 int
-acpi_pci_link_get_irq (
+acpi_pci_link_allocate_irq (
 	acpi_handle		handle,
 	int			index,
 	int			*edge_level,
@@ -613,7 +618,7 @@ acpi_pci_link_get_irq (
 	struct acpi_device	*device = NULL;
 	struct acpi_pci_link	*link = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_get_irq");
+	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate_irq");
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
@@ -633,21 +638,70 @@ acpi_pci_link_get_irq (
 		return_VALUE(-1);
 	}
 
-	if (acpi_pci_link_allocate(link))
+	down(&acpi_link_lock);
+	if (acpi_pci_link_allocate(link)) {
+		up(&acpi_link_lock);
 		return_VALUE(-1);
+	}
 	   
 	if (!link->irq.active) {
+		up(&acpi_link_lock);
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link active IRQ is 0!\n"));
 		return_VALUE(-1);
 	}
+	link->refcnt ++;
+	up(&acpi_link_lock);
 
 	if (edge_level) *edge_level = link->irq.edge_level;
 	if (active_high_low) *active_high_low = link->irq.active_high_low;
 	if (name) *name = acpi_device_bid(link->device);
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"Link %s is referenced\n", acpi_device_bid(link->device)));
 	return_VALUE(link->irq.active);
 }
 
+/*
+ * We don't change link's irq information here.  After it is reenabled, we
+ * continue use the info
+ */
+int
+acpi_pci_link_free_irq(acpi_handle handle)
+{
+	struct acpi_device	*device = NULL;
+	struct acpi_pci_link	*link = NULL;
+	acpi_status		result;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_free_irq");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link device\n"));
+		return_VALUE(-1);
+	}
 
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	if (!link) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+		return_VALUE(-1);
+	}
+
+	down(&acpi_link_lock);
+	if (!link->irq.initialized) {
+		up(&acpi_link_lock);
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link isn't initialized\n"));
+		return_VALUE(-1);
+	}
+
+	link->refcnt --;
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"Link %s is dereferenced\n", acpi_device_bid(link->device)));
+
+	if (link->refcnt == 0) {
+		acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
+	}
+	up(&acpi_link_lock);
+	return_VALUE(link->irq.active);
+}
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -677,6 +731,7 @@ acpi_pci_link_add (
 	strcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);
 	acpi_driver_data(device) = link;
 
+	down(&acpi_link_lock);
 	result = acpi_pci_link_get_possible(link);
 	if (result)
 		goto end;
@@ -712,6 +767,7 @@ acpi_pci_link_add (
 end:
 	/* disable all links -- to be activated on use */
 	acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
+	up(&acpi_link_lock);
 
 	if (result)
 		kfree(link);
@@ -726,19 +782,32 @@ irqrouter_suspend(
 {
 	struct list_head        *node = NULL;
 	struct acpi_pci_link    *link = NULL;
+	int			ret = 0;
 
 	ACPI_FUNCTION_TRACE("irqrouter_suspend");
 
 	list_for_each(node, &acpi_link.entries) {
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Invalid link context\n"));
 			continue;
 		}
-		if (link->irq.active && link->irq.initialized)
-			link->irq.suspend_resume = 1;
+		if (link->irq.initialized && link->refcnt != 0
+			/* We ignore legacy IDE device irq */
+			&& link->irq.active != 14 && link->irq.active !=15) {
+			printk(KERN_WARNING PREFIX
+				"%d drivers with interrupt %d neglected to call"
+				" pci_disable_device at .suspend\n",
+				link->refcnt,
+				link->irq.active);
+			printk(KERN_WARNING PREFIX
+				"Fix the driver, or rmmod before suspend\n");
+			link->refcnt = 0;
+			ret = -EINVAL;
+		}
 	}
-	return_VALUE(0);
+	return_VALUE(ret);
 }
 
 
@@ -756,8 +825,9 @@ acpi_pci_link_remove (
 
 	link = (struct acpi_pci_link *) acpi_driver_data(device);
 
-	/* TBD: Acquire/release lock */
+	down(&acpi_link_lock);
 	list_del(&link->node);
+	up(&acpi_link_lock);
 
 	kfree(link);
 
@@ -849,6 +919,7 @@ int __init acpi_irq_balance_set(char *str)
 __setup("acpi_irq_balance", acpi_irq_balance_set);
 
 
+/* FIXME: we will remove this interface after all drivers call pci_disable_device */
 static struct sysdev_class irqrouter_sysdev_class = {
         set_kset_name("irqrouter"),
         .suspend = irqrouter_suspend,

commit c9c3e457de24cca2ca688fa397d93a241f472048
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Fri Apr 1 00:07:31 2005 -0500

    [ACPI] PNPACPI vs sound IRQ
    
    http://bugme.osdl.org/show_bug.cgi?id=4016
    
    Written-by: David Shaohua Li <shaohua.li@intel.com>
    Acked-by: Adam Belay <abelay@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index f2271173bbd5..6ad0e77df9b3 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -804,9 +804,12 @@ static int __init acpi_irq_penalty_update(char *str, int used)
  * There is no ISA_POSSIBLE weight, so we simply use
  * the (small) PCI_USING penalty.
  */
-void acpi_penalize_isa_irq(int irq)
+void acpi_penalize_isa_irq(int irq, int active)
 {
-	acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+	if (active)
+		acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
+	else
+		acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
 }
 
 /*

commit 362b06bb70b5a5779b2e852e0f2bdb437061106e
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Fri Mar 18 16:30:29 2005 -0500

    [ACPI] S3 Suspend to RAM: interrupt resume fix
    
    Delete PCI Interrupt Link Device .resume method --
    it is the device driver's job to request interrupts,
    not the Link's job to remember what the devices want.
    
    This addresses the issue of attempting to run
    the ACPI interpreter too early in resume, when
    interrupts are still disabled.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index 520b28ad0740..f2271173bbd5 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -72,10 +72,12 @@ struct acpi_pci_link_irq {
 	u8			active;			/* Current IRQ */
 	u8			edge_level;		/* All IRQs */
 	u8			active_high_low;	/* All IRQs */
-	u8			initialized;
 	u8			resource_type;
 	u8			possible_count;
 	u8			possible[ACPI_PCI_LINK_MAX_POSSIBLE];
+	u8			initialized:1;
+	u8			suspend_resume:1;
+	u8			reserved:6;
 };
 
 struct acpi_pci_link {
@@ -530,6 +532,10 @@ static int acpi_pci_link_allocate(
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate");
 
+	if (link->irq.suspend_resume) {
+		acpi_pci_link_set(link, link->irq.active);
+		link->irq.suspend_resume = 0;
+	}
 	if (link->irq.initialized)
 		return_VALUE(0);
 
@@ -713,38 +719,24 @@ acpi_pci_link_add (
 	return_VALUE(result);
 }
 
-
-static int
-acpi_pci_link_resume (
-	struct acpi_pci_link	*link)
-{
-	ACPI_FUNCTION_TRACE("acpi_pci_link_resume");
-	
-	if (link->irq.active && link->irq.initialized)
-		return_VALUE(acpi_pci_link_set(link, link->irq.active));
-	else
-		return_VALUE(0);
-}
-
-
 static int
-irqrouter_resume(
-	struct sys_device *dev)
+irqrouter_suspend(
+	struct sys_device *dev,
+	u32	state)
 {
 	struct list_head        *node = NULL;
 	struct acpi_pci_link    *link = NULL;
 
-	ACPI_FUNCTION_TRACE("irqrouter_resume");
+	ACPI_FUNCTION_TRACE("irqrouter_suspend");
 
 	list_for_each(node, &acpi_link.entries) {
-
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
 			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
 			continue;
 		}
-
-		acpi_pci_link_resume(link);
+		if (link->irq.active && link->irq.initialized)
+			link->irq.suspend_resume = 1;
 	}
 	return_VALUE(0);
 }
@@ -856,7 +848,7 @@ __setup("acpi_irq_balance", acpi_irq_balance_set);
 
 static struct sysdev_class irqrouter_sysdev_class = {
         set_kset_name("irqrouter"),
-        .resume = irqrouter_resume,
+        .suspend = irqrouter_suspend,
 };
 
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
new file mode 100644
index 000000000000..520b28ad0740
--- /dev/null
+++ b/drivers/acpi/pci_link.c
@@ -0,0 +1,904 @@
+/*
+ *  pci_link.c - ACPI PCI Interrupt Link Device Driver ($Revision: 34 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * TBD: 
+ *      1. Support more than one IRQ resource entry per link device (index).
+ *	2. Implement start/stop mechanism and use ACPI Bus Driver facilities
+ *	   for IRQ management (e.g. start()->_SRS).
+ */
+
+#include <linux/sysdev.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_link")
+
+#define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
+#define ACPI_PCI_LINK_HID		"PNP0C0F"
+#define ACPI_PCI_LINK_DRIVER_NAME	"ACPI PCI Interrupt Link Driver"
+#define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
+#define ACPI_PCI_LINK_FILE_INFO		"info"
+#define ACPI_PCI_LINK_FILE_STATUS	"state"
+
+#define ACPI_PCI_LINK_MAX_POSSIBLE 16
+
+static int acpi_pci_link_add (struct acpi_device *device);
+static int acpi_pci_link_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_pci_link_driver = {
+	.name =		ACPI_PCI_LINK_DRIVER_NAME,
+	.class =	ACPI_PCI_LINK_CLASS,
+	.ids =		ACPI_PCI_LINK_HID,
+	.ops =		{
+				.add =    acpi_pci_link_add,
+				.remove = acpi_pci_link_remove,
+			},
+};
+
+struct acpi_pci_link_irq {
+	u8			active;			/* Current IRQ */
+	u8			edge_level;		/* All IRQs */
+	u8			active_high_low;	/* All IRQs */
+	u8			initialized;
+	u8			resource_type;
+	u8			possible_count;
+	u8			possible[ACPI_PCI_LINK_MAX_POSSIBLE];
+};
+
+struct acpi_pci_link {
+	struct list_head	node;
+	struct acpi_device	*device;
+	acpi_handle		handle;
+	struct acpi_pci_link_irq irq;
+};
+
+static struct {
+	int			count;
+	struct list_head	entries;
+}				acpi_link;
+
+
+/* --------------------------------------------------------------------------
+                            PCI Link Device Management
+   -------------------------------------------------------------------------- */
+
+/*
+ * set context (link) possible list from resource list
+ */
+static acpi_status
+acpi_pci_link_check_possible (
+	struct acpi_resource	*resource,
+	void			*context)
+{
+	struct acpi_pci_link	*link = (struct acpi_pci_link *) context;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_check_possible");
+
+	switch (resource->id) {
+	case ACPI_RSTYPE_START_DPF:
+		return_ACPI_STATUS(AE_OK);
+	case ACPI_RSTYPE_IRQ:
+	{
+		struct acpi_resource_irq *p = &resource->data.irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Blank IRQ resource\n"));
+			return_ACPI_STATUS(AE_OK);
+		}
+		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+			if (!p->interrupts[i]) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
+				continue;
+			}
+			link->irq.possible[i] = p->interrupts[i];
+			link->irq.possible_count++;
+		}
+		link->irq.edge_level = p->edge_level;
+		link->irq.active_high_low = p->active_high_low;
+		link->irq.resource_type = ACPI_RSTYPE_IRQ;
+		break;
+	}
+	case ACPI_RSTYPE_EXT_IRQ:
+	{
+		struct acpi_resource_ext_irq *p = &resource->data.extended_irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+				"Blank EXT IRQ resource\n"));
+			return_ACPI_STATUS(AE_OK);
+		}
+		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+			if (!p->interrupts[i]) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
+				continue;
+			}
+			link->irq.possible[i] = p->interrupts[i];
+			link->irq.possible_count++;
+		}
+		link->irq.edge_level = p->edge_level;
+		link->irq.active_high_low = p->active_high_low;
+		link->irq.resource_type = ACPI_RSTYPE_EXT_IRQ;
+		break;
+	}
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Resource is not an IRQ entry\n"));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	return_ACPI_STATUS(AE_CTRL_TERMINATE);
+}
+
+
+static int
+acpi_pci_link_get_possible (
+	struct acpi_pci_link	*link)
+{
+	acpi_status		status;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_possible");
+
+	if (!link)
+		return_VALUE(-EINVAL);
+
+	status = acpi_walk_resources(link->handle, METHOD_NAME__PRS,
+			acpi_pci_link_check_possible, link);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRS\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Found %d possible IRQs\n", link->irq.possible_count));
+
+	return_VALUE(0);
+}
+
+
+static acpi_status
+acpi_pci_link_check_current (
+	struct acpi_resource	*resource,
+	void			*context)
+{
+	int			*irq = (int *) context;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_check_current");
+
+	switch (resource->id) {
+	case ACPI_RSTYPE_IRQ:
+	{
+		struct acpi_resource_irq *p = &resource->data.irq;
+		if (!p || !p->number_of_interrupts) {
+			/*
+			 * IRQ descriptors may have no IRQ# bits set,
+			 * particularly those those w/ _STA disabled
+			 */
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"Blank IRQ resource\n")); 
+			return_ACPI_STATUS(AE_OK);
+		}
+		*irq = p->interrupts[0];
+		break;
+	}
+	case ACPI_RSTYPE_EXT_IRQ:
+	{
+		struct acpi_resource_ext_irq *p = &resource->data.extended_irq;
+		if (!p || !p->number_of_interrupts) {
+			/*
+			 * extended IRQ descriptors must
+			 * return at least 1 IRQ
+			 */
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				"Blank EXT IRQ resource\n"));
+			return_ACPI_STATUS(AE_OK);
+		}
+		*irq = p->interrupts[0];
+		break;
+	}
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Resource isn't an IRQ\n"));
+		return_ACPI_STATUS(AE_OK);
+	}
+	return_ACPI_STATUS(AE_CTRL_TERMINATE);
+}
+
+/*
+ * Run _CRS and set link->irq.active
+ *
+ * return value:
+ * 0 - success
+ * !0 - failure
+ */
+static int
+acpi_pci_link_get_current (
+	struct acpi_pci_link	*link)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	int			irq = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_current");
+
+	if (!link || !link->handle)
+		return_VALUE(-EINVAL);
+
+	link->irq.active = 0;
+
+	/* in practice, status disabled is meaningless, ignore it */
+	if (acpi_strict) {
+		/* Query _STA, set link->device->status */
+		result = acpi_bus_get_status(link->device);
+		if (result) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+			goto end;
+		}
+
+		if (!link->device->status.enabled) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link disabled\n"));
+			return_VALUE(0);
+		}
+	}
+
+	/* 
+	 * Query and parse _CRS to get the current IRQ assignment. 
+	 */
+
+	status = acpi_walk_resources(link->handle, METHOD_NAME__CRS,
+			acpi_pci_link_check_current, &irq);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _CRS\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	if (acpi_strict && !irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "_CRS returned 0\n"));
+		result = -ENODEV;
+	}
+
+	link->irq.active = irq;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link at IRQ %d \n", link->irq.active));
+
+end:
+	return_VALUE(result);
+}
+
+static int
+acpi_pci_link_set (
+	struct acpi_pci_link	*link,
+	int			irq)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct {
+		struct acpi_resource	res;
+		struct acpi_resource	end;
+	}    *resource;
+	struct acpi_buffer	buffer = {0, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
+
+	if (!link || !irq)
+		return_VALUE(-EINVAL);
+
+	resource = kmalloc( sizeof(*resource)+1, GFP_KERNEL);
+	if(!resource)
+		return_VALUE(-ENOMEM);
+
+	memset(resource, 0, sizeof(*resource)+1);
+	buffer.length = sizeof(*resource) +1;
+	buffer.pointer = resource;
+
+	switch(link->irq.resource_type) {
+	case ACPI_RSTYPE_IRQ:
+		resource->res.id = ACPI_RSTYPE_IRQ;
+		resource->res.length = sizeof(struct acpi_resource);
+		resource->res.data.irq.edge_level = link->irq.edge_level;
+		resource->res.data.irq.active_high_low = link->irq.active_high_low;
+		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
+			resource->res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
+		else
+			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
+		resource->res.data.irq.number_of_interrupts = 1;
+		resource->res.data.irq.interrupts[0] = irq;
+		break;
+	   
+	case ACPI_RSTYPE_EXT_IRQ:
+		resource->res.id = ACPI_RSTYPE_EXT_IRQ;
+		resource->res.length = sizeof(struct acpi_resource);
+		resource->res.data.extended_irq.producer_consumer = ACPI_CONSUMER;
+		resource->res.data.extended_irq.edge_level = link->irq.edge_level;
+		resource->res.data.extended_irq.active_high_low = link->irq.active_high_low;
+		if (link->irq.edge_level == ACPI_EDGE_SENSITIVE)
+			resource->res.data.irq.shared_exclusive = ACPI_EXCLUSIVE;
+		else
+			resource->res.data.irq.shared_exclusive = ACPI_SHARED;
+		resource->res.data.extended_irq.number_of_interrupts = 1;
+		resource->res.data.extended_irq.interrupts[0] = irq;
+		/* ignore resource_source, it's optional */
+		break;
+	default:
+		printk("ACPI BUG: resource_type %d\n", link->irq.resource_type);
+		result = -EINVAL;
+		goto end;
+
+	}
+	resource->end.id = ACPI_RSTYPE_END_TAG;
+
+	/* Attempt to set the resource */
+	status = acpi_set_current_resources(link->handle, &buffer);
+
+	/* check for total failure */
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SRS\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/* Query _STA, set device->status */
+	result = acpi_bus_get_status(link->device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+		goto end;
+	}
+	if (!link->device->status.enabled) {
+		printk(KERN_WARNING PREFIX
+			"%s [%s] disabled and referenced, BIOS bug.\n",
+			acpi_device_name(link->device),
+			acpi_device_bid(link->device));
+	}
+
+	/* Query _CRS, set link->irq.active */
+	result = acpi_pci_link_get_current(link);
+	if (result) {
+		goto end;
+	}
+
+	/*
+	 * Is current setting not what we set?
+	 * set link->irq.active
+	 */
+	if (link->irq.active != irq) {
+		/*
+		 * policy: when _CRS doesn't return what we just _SRS
+		 * assume _SRS worked and override _CRS value.
+		 */
+		printk(KERN_WARNING PREFIX 
+			"%s [%s] BIOS reported IRQ %d, using IRQ %d\n",
+			acpi_device_name(link->device),
+			acpi_device_bid(link->device),
+			link->irq.active, irq);
+		link->irq.active = irq;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Set IRQ %d\n", link->irq.active));
+	
+end:
+	kfree(resource);
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                            PCI Link IRQ Management
+   -------------------------------------------------------------------------- */
+
+/*
+ * "acpi_irq_balance" (default in APIC mode) enables ACPI to use PIC Interrupt
+ * Link Devices to move the PIRQs around to minimize sharing.
+ * 
+ * "acpi_irq_nobalance" (default in PIC mode) tells ACPI not to move any PIC IRQs
+ * that the BIOS has already set to active.  This is necessary because
+ * ACPI has no automatic means of knowing what ISA IRQs are used.  Note that
+ * if the BIOS doesn't set a Link Device active, ACPI needs to program it
+ * even if acpi_irq_nobalance is set.
+ *
+ * A tables of penalties avoids directing PCI interrupts to well known
+ * ISA IRQs. Boot params are available to over-ride the default table:
+ *
+ * List interrupts that are free for PCI use.
+ * acpi_irq_pci=n[,m]
+ *
+ * List interrupts that should not be used for PCI:
+ * acpi_irq_isa=n[,m]
+ *
+ * Note that PCI IRQ routers have a list of possible IRQs,
+ * which may not include the IRQs this table says are available.
+ * 
+ * Since this heuristic can't tell the difference between a link
+ * that no device will attach to, vs. a link which may be shared
+ * by multiple active devices -- it is not optimal.
+ *
+ * If interrupt performance is that important, get an IO-APIC system
+ * with a pin dedicated to each device.  Or for that matter, an MSI
+ * enabled system.
+ */
+
+#define ACPI_MAX_IRQS		256
+#define ACPI_MAX_ISA_IRQ	16
+
+#define PIRQ_PENALTY_PCI_AVAILABLE	(0)
+#define PIRQ_PENALTY_PCI_POSSIBLE	(16*16)
+#define PIRQ_PENALTY_PCI_USING		(16*16*16)
+#define PIRQ_PENALTY_ISA_TYPICAL	(16*16*16*16)
+#define PIRQ_PENALTY_ISA_USED		(16*16*16*16*16)
+#define PIRQ_PENALTY_ISA_ALWAYS		(16*16*16*16*16*16)
+
+static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
+	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ0 timer */
+	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ1 keyboard */
+	PIRQ_PENALTY_ISA_ALWAYS,	/* IRQ2 cascade */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ3	serial */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ4	serial */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ5 sometimes SoundBlaster */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ6 */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ7 parallel, spurious */
+	PIRQ_PENALTY_ISA_TYPICAL,	/* IRQ8 rtc, sometimes */
+	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ9  PCI, often acpi */
+	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ10 PCI */
+	PIRQ_PENALTY_PCI_AVAILABLE,	/* IRQ11 PCI */
+	PIRQ_PENALTY_ISA_USED,	/* IRQ12 mouse */
+	PIRQ_PENALTY_ISA_USED,	/* IRQ13 fpe, sometimes */
+	PIRQ_PENALTY_ISA_USED,	/* IRQ14 ide0 */
+	PIRQ_PENALTY_ISA_USED,	/* IRQ15 ide1 */
+			/* >IRQ15 */
+};
+
+int __init
+acpi_irq_penalty_init(void)
+{
+	struct list_head	*node = NULL;
+	struct acpi_pci_link    *link = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_irq_penalty_init");
+
+	/*
+	 * Update penalties to facilitate IRQ balancing.
+	 */
+	list_for_each(node, &acpi_link.entries) {
+
+		link = list_entry(node, struct acpi_pci_link, node);
+		if (!link) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			continue;
+		}
+
+		/*
+		 * reflect the possible and active irqs in the penalty table --
+		 * useful for breaking ties.
+		 */
+		if (link->irq.possible_count) {
+			int penalty = PIRQ_PENALTY_PCI_POSSIBLE / link->irq.possible_count;
+
+			for (i = 0; i < link->irq.possible_count; i++) {
+				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)
+					acpi_irq_penalty[link->irq.possible[i]] += penalty;
+			}
+
+		} else if (link->irq.active) {
+			acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_POSSIBLE;
+		}
+	}
+	/* Add a penalty for the SCI */
+	acpi_irq_penalty[acpi_fadt.sci_int] += PIRQ_PENALTY_PCI_USING;
+
+	return_VALUE(0);
+}
+
+static int acpi_irq_balance;	/* 0: static, 1: balance */
+
+static int acpi_pci_link_allocate(
+	struct acpi_pci_link	*link)
+{
+	int			irq;
+	int			i;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate");
+
+	if (link->irq.initialized)
+		return_VALUE(0);
+
+	/*
+	 * search for active IRQ in list of possible IRQs.
+	 */
+	for (i = 0; i < link->irq.possible_count; ++i) {
+		if (link->irq.active == link->irq.possible[i])
+			break;
+	}
+	/*
+	 * forget active IRQ that is not in possible list
+	 */
+	if (i == link->irq.possible_count) {
+		if (acpi_strict)
+			printk(KERN_WARNING PREFIX "_CRS %d not found"
+				" in _PRS\n", link->irq.active);
+		link->irq.active = 0;
+	}
+
+	/*
+	 * if active found, use it; else pick entry from end of possible list.
+	 */
+	if (link->irq.active) {
+		irq = link->irq.active;
+	} else {
+		irq = link->irq.possible[link->irq.possible_count - 1];
+	}
+
+	if (acpi_irq_balance || !link->irq.active) {
+		/*
+		 * Select the best IRQ.  This is done in reverse to promote
+		 * the use of IRQs 9, 10, 11, and >15.
+		 */
+		for (i = (link->irq.possible_count - 1); i >= 0; i--) {
+			if (acpi_irq_penalty[irq] > acpi_irq_penalty[link->irq.possible[i]])
+				irq = link->irq.possible[i];
+		}
+	}
+
+	/* Attempt to enable the link device at this IRQ. */
+	if (acpi_pci_link_set(link, irq)) {
+		printk(PREFIX "Unable to set IRQ for %s [%s] (likely buggy ACPI BIOS).\n"
+				"Try pci=noacpi or acpi=off\n",
+			acpi_device_name(link->device),
+			acpi_device_bid(link->device));
+		return_VALUE(-ENODEV);
+	} else {
+		acpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;
+		printk(PREFIX "%s [%s] enabled at IRQ %d\n", 
+			acpi_device_name(link->device),
+			acpi_device_bid(link->device), link->irq.active);
+	}
+
+	link->irq.initialized = 1;
+
+	return_VALUE(0);
+}
+
+/*
+ * acpi_pci_link_get_irq
+ * success: return IRQ >= 0
+ * failure: return -1
+ */
+
+int
+acpi_pci_link_get_irq (
+	acpi_handle		handle,
+	int			index,
+	int			*edge_level,
+	int			*active_high_low,
+	char			**name)
+{
+	int                     result = 0;
+	struct acpi_device	*device = NULL;
+	struct acpi_pci_link	*link = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_irq");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link device\n"));
+		return_VALUE(-1);
+	}
+
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	if (!link) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+		return_VALUE(-1);
+	}
+
+	/* TBD: Support multiple index (IRQ) entries per Link Device */
+	if (index) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid index %d\n", index));
+		return_VALUE(-1);
+	}
+
+	if (acpi_pci_link_allocate(link))
+		return_VALUE(-1);
+	   
+	if (!link->irq.active) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link active IRQ is 0!\n"));
+		return_VALUE(-1);
+	}
+
+	if (edge_level) *edge_level = link->irq.edge_level;
+	if (active_high_low) *active_high_low = link->irq.active_high_low;
+	if (name) *name = acpi_device_bid(link->device);
+	return_VALUE(link->irq.active);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_pci_link_add (
+	struct acpi_device *device)
+{
+	int			result = 0;
+	struct acpi_pci_link	*link = NULL;
+	int			i = 0;
+	int			found = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	link = kmalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
+	if (!link)
+		return_VALUE(-ENOMEM);
+	memset(link, 0, sizeof(struct acpi_pci_link));
+
+	link->device = device;
+	link->handle = device->handle;
+	strcpy(acpi_device_name(device), ACPI_PCI_LINK_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);
+	acpi_driver_data(device) = link;
+
+	result = acpi_pci_link_get_possible(link);
+	if (result)
+		goto end;
+
+	/* query and set link->irq.active */
+	acpi_pci_link_get_current(link);
+
+	printk(PREFIX "%s [%s] (IRQs", acpi_device_name(device),
+		acpi_device_bid(device));
+	for (i = 0; i < link->irq.possible_count; i++) {
+		if (link->irq.active == link->irq.possible[i]) {
+			printk(" *%d", link->irq.possible[i]);
+			found = 1;
+		}
+		else
+			printk(" %d", link->irq.possible[i]);
+	}
+
+	printk(")");
+
+	if (!found)
+		printk(" *%d", link->irq.active);
+
+	if(!link->device->status.enabled)
+		printk(", disabled.");
+
+	printk("\n");
+
+	/* TBD: Acquire/release lock */
+	list_add_tail(&link->node, &acpi_link.entries);
+	acpi_link.count++;
+
+end:
+	/* disable all links -- to be activated on use */
+	acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
+
+	if (result)
+		kfree(link);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_link_resume (
+	struct acpi_pci_link	*link)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_link_resume");
+	
+	if (link->irq.active && link->irq.initialized)
+		return_VALUE(acpi_pci_link_set(link, link->irq.active));
+	else
+		return_VALUE(0);
+}
+
+
+static int
+irqrouter_resume(
+	struct sys_device *dev)
+{
+	struct list_head        *node = NULL;
+	struct acpi_pci_link    *link = NULL;
+
+	ACPI_FUNCTION_TRACE("irqrouter_resume");
+
+	list_for_each(node, &acpi_link.entries) {
+
+		link = list_entry(node, struct acpi_pci_link, node);
+		if (!link) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			continue;
+		}
+
+		acpi_pci_link_resume(link);
+	}
+	return_VALUE(0);
+}
+
+
+static int
+acpi_pci_link_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_pci_link *link = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+
+	/* TBD: Acquire/release lock */
+	list_del(&link->node);
+
+	kfree(link);
+
+	return_VALUE(0);
+}
+
+/*
+ * modify acpi_irq_penalty[] from cmdline
+ */
+static int __init acpi_irq_penalty_update(char *str, int used)
+{
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		int retval;
+		int irq;
+
+		retval = get_option(&str,&irq);
+
+		if (!retval)
+			break;	/* no number found */
+
+		if (irq < 0)
+			continue;
+		
+		if (irq >= ACPI_MAX_IRQS)
+			continue;
+
+		if (used)
+			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
+		else
+			acpi_irq_penalty[irq] = PIRQ_PENALTY_PCI_AVAILABLE;
+
+		if (retval != 2)	/* no next number */
+			break;
+	}
+	return 1;
+}
+
+/*
+ * We'd like PNP to call this routine for the
+ * single ISA_USED value for each legacy device.
+ * But instead it calls us with each POSSIBLE setting.
+ * There is no ISA_POSSIBLE weight, so we simply use
+ * the (small) PCI_USING penalty.
+ */
+void acpi_penalize_isa_irq(int irq)
+{
+	acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+}
+
+/*
+ * Over-ride default table to reserve additional IRQs for use by ISA
+ * e.g. acpi_irq_isa=5
+ * Useful for telling ACPI how not to interfere with your ISA sound card.
+ */
+static int __init acpi_irq_isa(char *str)
+{
+	return acpi_irq_penalty_update(str, 1);
+}
+__setup("acpi_irq_isa=", acpi_irq_isa);
+
+/*
+ * Over-ride default table to free additional IRQs for use by PCI
+ * e.g. acpi_irq_pci=7,15
+ * Used for acpi_irq_balance to free up IRQs to reduce PCI IRQ sharing.
+ */
+static int __init acpi_irq_pci(char *str)
+{
+	return acpi_irq_penalty_update(str, 0);
+}
+__setup("acpi_irq_pci=", acpi_irq_pci);
+
+static int __init acpi_irq_nobalance_set(char *str)
+{
+	acpi_irq_balance = 0;
+	return 1;
+}
+__setup("acpi_irq_nobalance", acpi_irq_nobalance_set);
+
+int __init acpi_irq_balance_set(char *str)
+{
+	acpi_irq_balance = 1;
+	return 1;
+}
+__setup("acpi_irq_balance", acpi_irq_balance_set);
+
+
+static struct sysdev_class irqrouter_sysdev_class = {
+        set_kset_name("irqrouter"),
+        .resume = irqrouter_resume,
+};
+
+
+static struct sys_device device_irqrouter = {
+	.id     = 0,
+	.cls    = &irqrouter_sysdev_class,
+};
+
+
+static int __init irqrouter_init_sysfs(void)
+{
+	int error;
+
+	ACPI_FUNCTION_TRACE("irqrouter_init_sysfs");
+
+	if (acpi_disabled || acpi_noirq)
+		return_VALUE(0);
+
+	error = sysdev_class_register(&irqrouter_sysdev_class);
+	if (!error)
+		error = sysdev_register(&device_irqrouter);
+
+	return_VALUE(error);
+}                                        
+
+device_initcall(irqrouter_init_sysfs);
+
+
+static int __init acpi_pci_link_init (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_link_init");
+
+	if (acpi_noirq)
+		return_VALUE(0);
+
+	acpi_link.count = 0;
+	INIT_LIST_HEAD(&acpi_link.entries);
+
+	if (acpi_bus_register_driver(&acpi_pci_link_driver) < 0)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+subsys_initcall(acpi_pci_link_init);
