commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index b34d05e365b7..d73b4535e79d 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2012, Intel Corporation
  * Copyright (c) 2015, Red Hat, Inc.
  * Copyright (c) 2015, 2016 Linaro Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #define pr_fmt(fmt) "ACPI: SPCR: " fmt

commit 603fadf33604a2e170eb833f99f569d3597f1f09
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 25 13:34:00 2019 -0500

    ACPI: Fix comment typos
    
    Fix some misspellings in comments.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index c336784d0bcb..b34d05e365b7 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -28,7 +28,7 @@ EXPORT_SYMBOL(qdf2400_e44_present);
 
 /*
  * Some Qualcomm Datacenter Technologies SoCs have a defective UART BUSY bit.
- * Detect them by examining the OEM fields in the SPCR header, similiar to PCI
+ * Detect them by examining the OEM fields in the SPCR header, similar to PCI
  * quirk detection in pci_mcfg.c.
  */
 static bool qdf2400_erratum_44_present(struct acpi_table_header *h)

commit b413b1abeb21b4a152c0bf8d1379efa30759b6e3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Nov 21 15:43:37 2018 +0200

    ACPI: SPCR: Consider baud rate 0 as preconfigured state
    
    Since SPCR 1.04 [1] the baud rate of 0 means a preconfigured state of UART.
    Assume firmware or bootloader configures console correctly.
    
    [1]: https://docs.microsoft.com/en-us/windows-hardware/drivers/serports/serial-port-console-redirection-table
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 9d52743080a4..c336784d0bcb 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -148,6 +148,13 @@ int __init acpi_parse_spcr(bool enable_earlycon, bool enable_console)
 	}
 
 	switch (table->baud_rate) {
+	case 0:
+		/*
+		 * SPCR 1.04 defines 0 as a preconfigured state of UART.
+		 * Assume firmware or bootloader configures console correctly.
+		 */
+		baud_rate = 0;
+		break;
 	case 3:
 		baud_rate = 9600;
 		break;
@@ -196,6 +203,10 @@ int __init acpi_parse_spcr(bool enable_earlycon, bool enable_console)
 		 * UART so don't attempt to change to the baud rate state
 		 * in the table because driver cannot calculate the dividers
 		 */
+		baud_rate = 0;
+	}
+
+	if (!baud_rate) {
 		snprintf(opts, sizeof(opts), "%s,%s,0x%llx", uart, iotype,
 			 table->serial_port.address);
 	} else {

commit 5a9e59e8d9dd9586d78c244b9d96fb18156daad3
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 9 12:08:21 2018 -0600

    ACPI: SPCR: Mark expected switch fall-through in acpi_parse_spcr
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 1465078
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 89e97d21a89c..9d52743080a4 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -115,6 +115,7 @@ int __init acpi_parse_spcr(bool enable_earlycon, bool enable_console)
 			table->serial_port.access_width))) {
 		default:
 			pr_err("Unexpected SPCR Access Width.  Defaulting to byte size\n");
+			/* fall through */
 		case 8:
 			iotype = "mmio";
 			break;

commit 0231d00082f61cfe03f2b7c27e5356f8cdf0312c
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Jan 18 10:09:51 2018 -0500

    ACPI: SPCR: Make SPCR available to x86
    
    SPCR is currently only enabled or ARM64 and x86 can use SPCR to setup
    an early console.
    
    General fixes include updating Documentation & Kconfig (for x86),
    updating comments, and changing parse_spcr() to acpi_parse_spcr(),
    and earlycon_init_is_deferred to earlycon_acpi_spcr_enable to be
    more descriptive.
    
    On x86, many systems have a valid SPCR table but the table version is
    not 2 so the table version check must be a warning.
    
    On ARM64 when the kernel parameter earlycon is used both the early console
    and console are enabled.  On x86, only the earlycon should be enabled by
    by default.  Modify acpi_parse_spcr() to allow options for initializing
    the early console and console separately.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Mark Salter <msalter@redhat.com>
    Tested-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 324b35bfe781..89e97d21a89c 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -21,7 +21,7 @@
  * occasionally getting stuck as 1. To avoid the potential for a hang, check
  * TXFE == 0 instead of BUSY == 1. This may not be suitable for all UART
  * implementations, so only do so if an affected platform is detected in
- * parse_spcr().
+ * acpi_parse_spcr().
  */
 bool qdf2400_e44_present;
 EXPORT_SYMBOL(qdf2400_e44_present);
@@ -74,19 +74,21 @@ static bool xgene_8250_erratum_present(struct acpi_table_spcr *tb)
 }
 
 /**
- * parse_spcr() - parse ACPI SPCR table and add preferred console
+ * acpi_parse_spcr() - parse ACPI SPCR table and add preferred console
  *
- * @earlycon: set up earlycon for the console specified by the table
+ * @enable_earlycon: set up earlycon for the console specified by the table
+ * @enable_console: setup the console specified by the table.
  *
  * For the architectures with support for ACPI, CONFIG_ACPI_SPCR_TABLE may be
  * defined to parse ACPI SPCR table.  As a result of the parsing preferred
- * console is registered and if @earlycon is true, earlycon is set up.
+ * console is registered and if @enable_earlycon is true, earlycon is set up.
+ * If @enable_console is true the system console is also configured.
  *
  * When CONFIG_ACPI_SPCR_TABLE is defined, this function should be called
  * from arch initialization code as soon as the DT/ACPI decision is made.
  *
  */
-int __init parse_spcr(bool earlycon)
+int __init acpi_parse_spcr(bool enable_earlycon, bool enable_console)
 {
 	static char opts[64];
 	struct acpi_table_spcr *table;
@@ -105,11 +107,8 @@ int __init parse_spcr(bool earlycon)
 	if (ACPI_FAILURE(status))
 		return -ENOENT;
 
-	if (table->header.revision < 2) {
-		err = -ENOENT;
-		pr_err("wrong table version\n");
-		goto done;
-	}
+	if (table->header.revision < 2)
+		pr_info("SPCR table version %d\n", table->header.revision);
 
 	if (table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
 		switch (ACPI_ACCESS_BIT_WIDTH((
@@ -185,7 +184,7 @@ int __init parse_spcr(bool earlycon)
 	 */
 	if (qdf2400_erratum_44_present(&table->header)) {
 		qdf2400_e44_present = true;
-		if (earlycon)
+		if (enable_earlycon)
 			uart = "qdf2400_e44";
 	}
 
@@ -205,11 +204,13 @@ int __init parse_spcr(bool earlycon)
 
 	pr_info("console: %s\n", opts);
 
-	if (earlycon)
+	if (enable_earlycon)
 		setup_earlycon(opts);
 
-	err = add_preferred_console(uart, 0, opts + strlen(uart) + 1);
-
+	if (enable_console)
+		err = add_preferred_console(uart, 0, opts + strlen(uart) + 1);
+	else
+		err = 0;
 done:
 	acpi_put_table((struct acpi_table_header *)table);
 	return err;

commit 940c8df63a534e004a5828182712ecf0036c26f7
Merge: 01d2f105a428 1f59ab2783ae 82d2b6105867 03c3876f2e3b 19dc7134805f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 3 23:54:29 2017 +0200

    Merge branches 'acpi-video', 'acpi-battery', 'acpi-spcr' and 'acpi-misc'
    
    * acpi-video:
      ACPI / video: Add force_none quirk for Dell OptiPlex 9020M
    
    * acpi-battery:
      ACPI: make device_attribute const
    
    * acpi-spcr:
      ACPI: SPCR: work around clock issue on xgene UART
      ACPI: SPCR: extend XGENE 8250 workaround to m400
    
    * acpi-misc:
      ACPI / dock: constify attribute_group structure
      MAINTAINERS: Add Tony and Boris as ACPI/APEI reviewers
      ACPI / lpat: Fix typos in comments and kerneldoc style
      MAINTAINERS: device property: ACPI: add fwnode.h

commit b2a84eedca1b827c6e513a8139e47b394f2d988d
Merge: 569dbb88e80d 4a9673dd50c2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 3 23:53:05 2017 +0200

    Merge branch 'acpica'
    
    * acpica: (32 commits)
      ACPICA: Update version to 20170728
      ACPICA: Revert "Update resource descriptor handling"
      ACPICA: Resources: Allow _DMA method in walk resources
      ACPICA: Ensure all instances of AE_AML_INTERNAL have error messages
      ACPICA: Implement deferred resolution of reference package elements
      ACPICA: Debugger: Improve support for Alias objects
      ACPICA: Interpreter: Update handling for Alias operator
      ACPICA: EFI/EDK2: Cleanup to enable /WX for MSVC builds
      ACPICA: acpidump: Add DSDT/FACS instance support for Linux and EFI
      ACPICA: CLib: Add short multiply/shift support
      ACPICA: EFI/EDK2: Sort acpi.h inclusion order
      ACPICA: Add a comment, no functional change
      ACPICA: Namespace: Update/fix an error message
      ACPICA: iASL: Add support for the SDEI table
      ACPICA: Divergences: reduce access size definitions
      ACPICA: Update version to 20170629
      ACPICA: Update resource descriptor handling
      ACPICA: iasl: Update to IORT SMMUv3 disassembling
      ACPICA: Disassembler: skip parsing of incorrect external declarations
      ACPICA: iASL: Ensure that the target node is valid in acpi_ex_create_alias
      ...

commit 03c3876f2e3b4c79ced7d1d227e5a7fe645ed666
Author: Graeme Gregory <graeme.gregory@linaro.org>
Date:   Fri Aug 4 22:49:44 2017 +0100

    ACPI: SPCR: work around clock issue on xgene UART
    
    xgene v1/v2 8250 UARTs don't run at the standard clock rate expected by
    the driver and there is no information on clocking available from the
    SPCR table. As there has been no progress on relevant vendors updating
    DBG2/SPCR specifications to fix this work around this using the previous
    xgene quirk handling to avoid setting a baud rate and therefore using
    the UART as configured by firmware.
    
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Tested-by: Mark Salter <msalter@redhat.com>
    Reviewed-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 2c156941b371..40a56b538b9f 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -188,11 +188,19 @@ int __init parse_spcr(bool earlycon)
 			uart = "qdf2400_e44";
 	}
 
-	if (xgene_8250_erratum_present(table))
+	if (xgene_8250_erratum_present(table)) {
 		iotype = "mmio32";
 
-	snprintf(opts, sizeof(opts), "%s,%s,0x%llx,%d", uart, iotype,
-		 table->serial_port.address, baud_rate);
+		/* for xgene v1 and v2 we don't know the clock rate of the
+		 * UART so don't attempt to change to the baud rate state
+		 * in the table because driver cannot calculate the dividers
+		 */
+		snprintf(opts, sizeof(opts), "%s,%s,0x%llx", uart, iotype,
+			 table->serial_port.address);
+	} else {
+		snprintf(opts, sizeof(opts), "%s,%s,0x%llx,%d", uart, iotype,
+			 table->serial_port.address, baud_rate);
+	}
 
 	pr_info("console: %s\n", opts);
 

commit dee82bc1e653126408f4108cd994d1e96949d064
Author: Graeme Gregory <graeme.gregory@linaro.org>
Date:   Fri Aug 4 22:49:43 2017 +0100

    ACPI: SPCR: extend XGENE 8250 workaround to m400
    
    xgene v1/v2 chips are also used on moonshot cartridges that have
    different table headers to the ones on Mustang. Extend the quirk
    so it also recognises the Moonshot M400 variant too.
    
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Tested-by: Mark Salter <msalter@redhat.com>
    Reviewed-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 98aa8c808a33..2c156941b371 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -53,17 +53,24 @@ static bool qdf2400_erratum_44_present(struct acpi_table_header *h)
  */
 static bool xgene_8250_erratum_present(struct acpi_table_spcr *tb)
 {
+	bool xgene_8250 = false;
+
 	if (tb->interface_type != ACPI_DBG2_16550_COMPATIBLE)
 		return false;
 
-	if (memcmp(tb->header.oem_id, "APMC0D", ACPI_OEM_ID_SIZE))
+	if (memcmp(tb->header.oem_id, "APMC0D", ACPI_OEM_ID_SIZE) &&
+	    memcmp(tb->header.oem_id, "HPE   ", ACPI_OEM_ID_SIZE))
 		return false;
 
 	if (!memcmp(tb->header.oem_table_id, "XGENESPC",
 	    ACPI_OEM_TABLE_ID_SIZE) && tb->header.oem_revision == 0)
-		return true;
+		xgene_8250 = true;
 
-	return false;
+	if (!memcmp(tb->header.oem_table_id, "ProLiant",
+	    ACPI_OEM_TABLE_ID_SIZE) && tb->header.oem_revision == 1)
+		xgene_8250 = true;
+
+	return xgene_8250;
 }
 
 /**

commit 4eebedd8f1a6609739c2e9a9b020791b23cbcceb
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Aug 3 14:26:19 2017 +0800

    ACPICA: Divergences: reduce access size definitions
    
    ACPICA commit cf27b3c98883d2a15d932016792fcb8272ace96d
    
    The following commit introduces definition of access width to ACPICA.
      Commit: 2bece49394872d36bbc5767fd643deac05920c55
      Subject: ACPI: SPCR: Use access width to determine mmio usage
    
    Actually the access bit width can be calculated via access width. It
    would be better to define a macro calculating bit width rather than
    defining fixed values. This patch thus cleans up the definitions to
    reduce divergences.
    
    Link: https://github.com/acpica/acpica/commit/cf27b3c9
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 4ac3e06b41d8..1230f969256b 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -95,16 +95,17 @@ int __init parse_spcr(bool earlycon)
 	}
 
 	if (table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
-		switch (table->serial_port.access_width) {
+		switch (ACPI_ACCESS_BIT_WIDTH((
+			table->serial_port.access_width))) {
 		default:
 			pr_err("Unexpected SPCR Access Width.  Defaulting to byte size\n");
-		case ACPI_ACCESS_SIZE_BYTE:
+		case 8:
 			iotype = "mmio";
 			break;
-		case ACPI_ACCESS_SIZE_WORD:
+		case 16:
 			iotype = "mmio16";
 			break;
-		case ACPI_ACCESS_SIZE_DWORD:
+		case 32:
 			iotype = "mmio32";
 			break;
 		}

commit 37ef38f3f83891a2f413fb872bae7d0f9bb95b27
Author: Timur Tabi <timur@codeaurora.org>
Date:   Thu Jul 27 16:15:52 2017 -0500

    tty: pl011: fix initialization order of QDF2400 E44
    
    The work-around for Qualcomm Technologies QDF2400 Erratum 44 hinges on a
    global variable defined in the pl011 driver.  The ACPI SPCR parsing code
    determines whether the work-around is needed, and if so, it changes the
    console name from "pl011" to "qdf2400_e44".  The expectation is that
    the pl011 driver will implement the work-around when it sees the console
    name.  The global variable qdf2400_e44_present is set when that happens.
    
    The problem is that work-around needs to be enabled when the pl011
    driver probes, not when the console name is queried.  However, sbsa_probe()
    is called before pl011_console_match().  The work-around appeared to work
    previously because the default console on QDF2400 platforms was always
    ttyAMA1.  The first time sbsa_probe() is called (for ttyAMA0),
    qdf2400_e44_present is still false.  Then pl011_console_match() is called,
    and it sets qdf2400_e44_present to true.  All subsequent calls to
    sbsa_probe() enable the work-around.
    
    The solution is to move the global variable into spcr.c and let the
    pl011 driver query it during probe time.  This works because all QDF2400
    platforms require SPCR, so parse_spcr() will always be called.
    pl011_console_match still checks for the "qdf2400_e44" console name,
    but it doesn't do anything else special.
    
    Fixes: 5a0722b898f8 ("tty: pl011: use "qdf2400_e44" as the earlycon name for QDF2400 E44")
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Timur Tabi <timur@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 4ac3e06b41d8..98aa8c808a33 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -16,6 +16,16 @@
 #include <linux/kernel.h>
 #include <linux/serial_core.h>
 
+/*
+ * Erratum 44 for QDF2432v1 and QDF2400v1 SoCs describes the BUSY bit as
+ * occasionally getting stuck as 1. To avoid the potential for a hang, check
+ * TXFE == 0 instead of BUSY == 1. This may not be suitable for all UART
+ * implementations, so only do so if an affected platform is detected in
+ * parse_spcr().
+ */
+bool qdf2400_e44_present;
+EXPORT_SYMBOL(qdf2400_e44_present);
+
 /*
  * Some Qualcomm Datacenter Technologies SoCs have a defective UART BUSY bit.
  * Detect them by examining the OEM fields in the SPCR header, similiar to PCI
@@ -147,8 +157,30 @@ int __init parse_spcr(bool earlycon)
 		goto done;
 	}
 
-	if (qdf2400_erratum_44_present(&table->header))
-		uart = "qdf2400_e44";
+	/*
+	 * If the E44 erratum is required, then we need to tell the pl011
+	 * driver to implement the work-around.
+	 *
+	 * The global variable is used by the probe function when it
+	 * creates the UARTs, whether or not they're used as a console.
+	 *
+	 * If the user specifies "traditional" earlycon, the qdf2400_e44
+	 * console name matches the EARLYCON_DECLARE() statement, and
+	 * SPCR is not used.  Parameter "earlycon" is false.
+	 *
+	 * If the user specifies "SPCR" earlycon, then we need to update
+	 * the console name so that it also says "qdf2400_e44".  Parameter
+	 * "earlycon" is true.
+	 *
+	 * For consistency, if we change the console name, then we do it
+	 * for everyone, not just earlycon.
+	 */
+	if (qdf2400_erratum_44_present(&table->header)) {
+		qdf2400_e44_present = true;
+		if (earlycon)
+			uart = "qdf2400_e44";
+	}
+
 	if (xgene_8250_erratum_present(table))
 		iotype = "mmio32";
 

commit 79a648328d2a604524a30523ca763fbeca0f70e3
Author: Loc Ho <lho@apm.com>
Date:   Mon Jul 3 14:33:09 2017 -0700

    ACPI: SPCR: Workaround for APM X-Gene 8250 UART 32-alignment errata
    
    APM X-Gene verion 1 and 2 have an 8250 UART with its register
    aligned to 32-bit. In addition, the latest released BIOS
    encodes the access field as 8-bit access instead 32-bit access.
    This causes no console with ACPI boot as the console
    will not match X-Gene UART port due to the lack of mmio32
    option.
    
    Signed-off-by: Loc Ho <lho@apm.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 29050630f3da..4ac3e06b41d8 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -36,6 +36,26 @@ static bool qdf2400_erratum_44_present(struct acpi_table_header *h)
 	return false;
 }
 
+/*
+ * APM X-Gene v1 and v2 UART hardware is an 16550 like device but has its
+ * register aligned to 32-bit. In addition, the BIOS also encoded the
+ * access width to be 8 bits. This function detects this errata condition.
+ */
+static bool xgene_8250_erratum_present(struct acpi_table_spcr *tb)
+{
+	if (tb->interface_type != ACPI_DBG2_16550_COMPATIBLE)
+		return false;
+
+	if (memcmp(tb->header.oem_id, "APMC0D", ACPI_OEM_ID_SIZE))
+		return false;
+
+	if (!memcmp(tb->header.oem_table_id, "XGENESPC",
+	    ACPI_OEM_TABLE_ID_SIZE) && tb->header.oem_revision == 0)
+		return true;
+
+	return false;
+}
+
 /**
  * parse_spcr() - parse ACPI SPCR table and add preferred console
  *
@@ -129,6 +149,8 @@ int __init parse_spcr(bool earlycon)
 
 	if (qdf2400_erratum_44_present(&table->header))
 		uart = "qdf2400_e44";
+	if (xgene_8250_erratum_present(table))
+		iotype = "mmio32";
 
 	snprintf(opts, sizeof(opts), "%s,%s,0x%llx,%d", uart, iotype,
 		 table->serial_port.address, baud_rate);

commit 2bece49394872d36bbc5767fd643deac05920c55
Author: Loc Ho <lho@apm.com>
Date:   Mon Jul 3 14:33:08 2017 -0700

    ACPI: SPCR: Use access width to determine mmio usage
    
    The current SPCR code does not check the access width of the MMIO, and
    uses a default of 8bit register accesses.  This prevents devices that
    only do 16 or 32bit register accesses from working.  By simply checking
    this field and setting the MMIO string appropriately, this issue can be
    corrected.  To prevent any legacy issues, the code will default to 8bit
    accesses if the value is anything but 16 or 32.
    
    Signed-off-by: Jon Mason <jon.mason@broadcom.com>
    Signed-off-by: Loc Ho <lho@apm.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 3afa8c1fa127..29050630f3da 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -74,8 +74,22 @@ int __init parse_spcr(bool earlycon)
 		goto done;
 	}
 
-	iotype = table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY ?
-			"mmio" : "io";
+	if (table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		switch (table->serial_port.access_width) {
+		default:
+			pr_err("Unexpected SPCR Access Width.  Defaulting to byte size\n");
+		case ACPI_ACCESS_SIZE_BYTE:
+			iotype = "mmio";
+			break;
+		case ACPI_ACCESS_SIZE_WORD:
+			iotype = "mmio16";
+			break;
+		case ACPI_ACCESS_SIZE_DWORD:
+			iotype = "mmio32";
+			break;
+		}
+	} else
+		iotype = "io";
 
 	switch (table->interface_type) {
 	case ACPI_DBG2_ARM_SBSA_32BIT:

commit 542ed784671d4678406c77ed6dd01593a0cdbea1
Author: Timur Tabi <timur@codeaurora.org>
Date:   Tue Feb 28 14:30:33 2017 -0600

    tty: acpi/spcr: QDF2400 E44 checks for wrong OEM revision
    
    For Qualcomm Technologies QDF2400 SOCs that are affected by erratum E44,
    the ACPI oem_revision field is actually set to 1, not 0.
    
    Fixes: d8a4995bcea1 ("tty: pl011: Work around QDF2400 E44 stuck BUSY bit")
    
    Tested-by: Manoj Iyer <manoj.iyer@canonical.com>
    Signed-off-by: Timur Tabi <timur@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 01c94669a2b0..3afa8c1fa127 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -30,7 +30,7 @@ static bool qdf2400_erratum_44_present(struct acpi_table_header *h)
 		return true;
 
 	if (!memcmp(h->oem_table_id, "QDF2400 ", ACPI_OEM_TABLE_ID_SIZE) &&
-			h->oem_revision == 0)
+			h->oem_revision == 1)
 		return true;
 
 	return false;

commit 183b8021fc0a5fadecdf9c0ccac1f48b5c326278
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 27 14:29:20 2017 -0800

    scripts/spelling.txt: add "intialization" pattern and fix typo instances
    
    Fix typos and add the following to the scripts/spelling.txt:
    
      intialization||initialization
    
    The "inintialization" in drivers/acpi/spcr.c is a different pattern but
    I fixed it as well in this commit.
    
    Link: http://lkml.kernel.org/r/1481573103-11329-16-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index 2b5d0fac81f0..01c94669a2b0 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -46,7 +46,7 @@ static bool qdf2400_erratum_44_present(struct acpi_table_header *h)
  * console is registered and if @earlycon is true, earlycon is set up.
  *
  * When CONFIG_ACPI_SPCR_TABLE is defined, this function should be called
- * from arch inintialization code as soon as the DT/ACPI decision is made.
+ * from arch initialization code as soon as the DT/ACPI decision is made.
  *
  */
 int __init parse_spcr(bool earlycon)

commit d8a4995bcea168dfac8ee41c28c79109907e4fba
Author: Christopher Covington <cov@codeaurora.org>
Date:   Wed Feb 15 16:39:43 2017 -0500

    tty: pl011: Work around QDF2400 E44 stuck BUSY bit
    
    The Qualcomm Datacenter Technologies QDF2400 family of SoCs contains a
    custom (non-PrimeCell) implementation of the SBSA UART. Occasionally the
    BUSY bit in the Flag Register gets stuck as 1, erratum 44 for both 2432v1
    and 2400v1 SoCs.Checking that the Transmit FIFO Empty (TXFE) bit is 0,
    instead of checking that the BUSY bit is 1, works around the issue.
    
    To facilitate this substitution of flags and values, introduce
    vendor-specific inversion of Feature Register bits when UART AMBA Port
    (UAP) data is available. For the earlycon case, prior to UAP availability,
    implement alternative putc and early_write functions.
    
    Similar to what how ARMv8 ACPI PCI quirks are detected during MCFG parsing,
    check the OEM fields of the Serial Port Console Redirection (SPCR) ACPI
    table to determine if the current platform is known to be affected by the
    erratum.
    
    Signed-off-by: Christopher Covington <cov@codeaurora.org>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Acked-by: Timur Tabi <timur@codeaurora.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index b8019c4c1d38..2b5d0fac81f0 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -16,6 +16,26 @@
 #include <linux/kernel.h>
 #include <linux/serial_core.h>
 
+/*
+ * Some Qualcomm Datacenter Technologies SoCs have a defective UART BUSY bit.
+ * Detect them by examining the OEM fields in the SPCR header, similiar to PCI
+ * quirk detection in pci_mcfg.c.
+ */
+static bool qdf2400_erratum_44_present(struct acpi_table_header *h)
+{
+	if (memcmp(h->oem_id, "QCOM  ", ACPI_OEM_ID_SIZE))
+		return false;
+
+	if (!memcmp(h->oem_table_id, "QDF2432 ", ACPI_OEM_TABLE_ID_SIZE))
+		return true;
+
+	if (!memcmp(h->oem_table_id, "QDF2400 ", ACPI_OEM_TABLE_ID_SIZE) &&
+			h->oem_revision == 0)
+		return true;
+
+	return false;
+}
+
 /**
  * parse_spcr() - parse ACPI SPCR table and add preferred console
  *
@@ -93,6 +113,9 @@ int __init parse_spcr(bool earlycon)
 		goto done;
 	}
 
+	if (qdf2400_erratum_44_present(&table->header))
+		uart = "qdf2400_e44";
+
 	snprintf(opts, sizeof(opts), "%s,%s,0x%llx,%d", uart, iotype,
 		 table->serial_port.address, baud_rate);
 

commit 6b11d1d677132816252004426ef220ccd3c92d2f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 14 15:04:39 2016 +0800

    ACPI / osl: Remove acpi_get_table_with_size()/early_acpi_os_unmap_memory() users
    
    This patch removes the users of the deprectated APIs:
     acpi_get_table_with_size()
     early_acpi_os_unmap_memory()
    The following APIs should be used instead of:
     acpi_get_table()
     acpi_put_table()
    
    The deprecated APIs are invented to be a replacement of acpi_get_table()
    during the early stage so that the early mapped pointer will not be stored
    in ACPICA core and thus the late stage acpi_get_table() won't return a
    wrong pointer. The mapping size is returned just because it is required by
    early_acpi_os_unmap_memory() to unmap the pointer during early stage.
    
    But as the mapping size equals to the acpi_table_header.length
    (see acpi_tb_init_table_descriptor() and acpi_tb_validate_table()), when
    such a convenient result is returned, driver code will start to use it
    instead of accessing acpi_table_header to obtain the length.
    
    Thus this patch cleans up the drivers by replacing returned table size with
    acpi_table_header.length, and should be a no-op.
    
    Reported-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index e8d7bc7d4da8..b8019c4c1d38 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -33,7 +33,6 @@ int __init parse_spcr(bool earlycon)
 {
 	static char opts[64];
 	struct acpi_table_spcr *table;
-	acpi_size table_size;
 	acpi_status status;
 	char *uart;
 	char *iotype;
@@ -43,9 +42,8 @@ int __init parse_spcr(bool earlycon)
 	if (acpi_disabled)
 		return -ENODEV;
 
-	status = acpi_get_table_with_size(ACPI_SIG_SPCR, 0,
-					  (struct acpi_table_header **)&table,
-					  &table_size);
+	status = acpi_get_table(ACPI_SIG_SPCR, 0,
+				(struct acpi_table_header **)&table);
 
 	if (ACPI_FAILURE(status))
 		return -ENOENT;
@@ -106,6 +104,6 @@ int __init parse_spcr(bool earlycon)
 	err = add_preferred_console(uart, 0, opts + strlen(uart) + 1);
 
 done:
-	early_acpi_os_unmap_memory((void __iomem *)table, table_size);
+	acpi_put_table((struct acpi_table_header *)table);
 	return err;
 }

commit ad1696f6f09daacfdf2bf04bc83cd8f48d80e34a
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Tue Sep 27 23:54:13 2016 +0300

    ACPI: parse SPCR and enable matching console
    
    'ARM Server Base Boot Requiremets' [1] mentions SPCR (Serial Port
    Console Redirection Table) [2] as a mandatory ACPI table that
    specifies the configuration of serial console.
    
    Defer initialization of DT earlycon until ACPI/DT decision is made.
    
    Parse the ACPI SPCR table, setup earlycon if required,
    enable specified console.
    
    Thanks to Peter Hurley for explaining how this should work.
    
    [1] http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0044a/index.html
    [2] https://msdn.microsoft.com/en-us/library/windows/hardware/dn639132(v=vs.85).aspx
    
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Tested-by: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
new file mode 100644
index 000000000000..e8d7bc7d4da8
--- /dev/null
+++ b/drivers/acpi/spcr.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2012, Intel Corporation
+ * Copyright (c) 2015, Red Hat, Inc.
+ * Copyright (c) 2015, 2016 Linaro Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#define pr_fmt(fmt) "ACPI: SPCR: " fmt
+
+#include <linux/acpi.h>
+#include <linux/console.h>
+#include <linux/kernel.h>
+#include <linux/serial_core.h>
+
+/**
+ * parse_spcr() - parse ACPI SPCR table and add preferred console
+ *
+ * @earlycon: set up earlycon for the console specified by the table
+ *
+ * For the architectures with support for ACPI, CONFIG_ACPI_SPCR_TABLE may be
+ * defined to parse ACPI SPCR table.  As a result of the parsing preferred
+ * console is registered and if @earlycon is true, earlycon is set up.
+ *
+ * When CONFIG_ACPI_SPCR_TABLE is defined, this function should be called
+ * from arch inintialization code as soon as the DT/ACPI decision is made.
+ *
+ */
+int __init parse_spcr(bool earlycon)
+{
+	static char opts[64];
+	struct acpi_table_spcr *table;
+	acpi_size table_size;
+	acpi_status status;
+	char *uart;
+	char *iotype;
+	int baud_rate;
+	int err;
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	status = acpi_get_table_with_size(ACPI_SIG_SPCR, 0,
+					  (struct acpi_table_header **)&table,
+					  &table_size);
+
+	if (ACPI_FAILURE(status))
+		return -ENOENT;
+
+	if (table->header.revision < 2) {
+		err = -ENOENT;
+		pr_err("wrong table version\n");
+		goto done;
+	}
+
+	iotype = table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY ?
+			"mmio" : "io";
+
+	switch (table->interface_type) {
+	case ACPI_DBG2_ARM_SBSA_32BIT:
+		iotype = "mmio32";
+		/* fall through */
+	case ACPI_DBG2_ARM_PL011:
+	case ACPI_DBG2_ARM_SBSA_GENERIC:
+	case ACPI_DBG2_BCM2835:
+		uart = "pl011";
+		break;
+	case ACPI_DBG2_16550_COMPATIBLE:
+	case ACPI_DBG2_16550_SUBSET:
+		uart = "uart";
+		break;
+	default:
+		err = -ENOENT;
+		goto done;
+	}
+
+	switch (table->baud_rate) {
+	case 3:
+		baud_rate = 9600;
+		break;
+	case 4:
+		baud_rate = 19200;
+		break;
+	case 6:
+		baud_rate = 57600;
+		break;
+	case 7:
+		baud_rate = 115200;
+		break;
+	default:
+		err = -ENOENT;
+		goto done;
+	}
+
+	snprintf(opts, sizeof(opts), "%s,%s,0x%llx,%d", uart, iotype,
+		 table->serial_port.address, baud_rate);
+
+	pr_info("console: %s\n", opts);
+
+	if (earlycon)
+		setup_earlycon(opts);
+
+	err = add_preferred_console(uart, 0, opts + strlen(uart) + 1);
+
+done:
+	early_acpi_os_unmap_memory((void __iomem *)table, table_size);
+	return err;
+}
