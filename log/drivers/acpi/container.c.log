commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 12c240903c18..9ea5f55d97e3 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * container.c  - ACPI Generic Container Driver
  *
@@ -7,20 +8,6 @@
  * Copyright (C) 2004 FUJITSU LIMITED
  * Copyright (C) 2004, 2013 Intel Corp.
  * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 #include <linux/acpi.h>
 #include <linux/container.h>

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index c8ead9f97375..12c240903c18 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -20,10 +20,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 #include <linux/acpi.h>

commit 8ab17fc92e49bc2b8fff9d220c19bf50ec9c1158
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 21 02:58:18 2014 +0200

    ACPI / hotplug: Generate online uevents for ACPI containers
    
    Commit 46394fd01 (ACPI / hotplug: Move container-specific code out of
    the core) removed the generation of "online" uevents for containers,
    because "add" uevents are now generated for them automatically when
    container system devices are registered.  However, there are user
    space tools that need to be notified when the container and all of
    its children have been enumerated, which doesn't happen any more.
    
    For this reason, add a mechanism allowing "online" uevents to be
    generated for ACPI containers after enumerating the container along
    with all of its children.
    
    Fixes: 46394fd01 (ACPI / hotplug: Move container-specific code out of the core)
    Reported-and-tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 76f7cff64594..c8ead9f97375 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -99,6 +99,13 @@ static void container_device_detach(struct acpi_device *adev)
 		device_unregister(dev);
 }
 
+static void container_device_online(struct acpi_device *adev)
+{
+	struct device *dev = acpi_driver_data(adev);
+
+	kobject_uevent(&dev->kobj, KOBJ_ONLINE);
+}
+
 static struct acpi_scan_handler container_handler = {
 	.ids = container_device_ids,
 	.attach = container_device_attach,
@@ -106,6 +113,7 @@ static struct acpi_scan_handler container_handler = {
 	.hotplug = {
 		.enabled = true,
 		.demand_offline = true,
+		.notify_online = container_device_online,
 	},
 };
 

commit a1ec657213b4abb00e59385171554a3e11eec27c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 30 04:28:20 2014 +0200

    ACPI / scan: always register container scan handler
    
    Prevent platform devices from being created for ACPI containers
    if CONFIG_ACPI_CONTAINER is unset by compiling out the container
    scan handler's callbacks only in that case and still compiling
    its device ID list in and registering the scan handler in either
    case.
    
    This change is based on a prototype from Zhang Rui.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 63119d09b354..76f7cff64594 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -41,6 +41,8 @@ static const struct acpi_device_id container_device_ids[] = {
 	{"", 0},
 };
 
+#ifdef CONFIG_ACPI_CONTAINER
+
 static int acpi_container_offline(struct container_dev *cdev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(&cdev->dev);
@@ -107,7 +109,20 @@ static struct acpi_scan_handler container_handler = {
 	},
 };
 
+void __init acpi_container_init(void)
+{
+	acpi_scan_add_handler(&container_handler);
+}
+
+#else
+
+static struct acpi_scan_handler container_handler = {
+	.ids = container_device_ids,
+};
+
 void __init acpi_container_init(void)
 {
 	acpi_scan_add_handler_with_hotplug(&container_handler, "container");
 }
+
+#endif /* CONFIG_ACPI_CONTAINER */

commit e25c5abf4125526d62417f8b5a314e743eefe900
Merge: c730d30c313a 07070e12cf5c a59ffb2062df c1aaae673f68 e1c748179754 0bf6368ee8f2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 20 13:20:47 2014 +0100

    Merge branches 'acpi-cleanup', 'acpi-thermal', 'acpi-pci', 'acpi-lpss' and 'acpi-button'
    
    * acpi-cleanup:
      ACPI: Remove duplicate definitions of PREFIX
      ACPI / tables: Replace printk with pr_*
    
    * acpi-thermal:
      ACPI / thermal: make acpi_thermal_check asynchronous on resume
    
    * acpi-pci:
      ACPI / PCI: Do not call ISA-specific code if ISA is not supported
    
    * acpi-lpss:
      ACPI / LPSS: Add Intel BayTrail ACPI mode PWM
    
    * acpi-button:
      ACPI / button: Add ACPI Button event via netlink routine

commit 07070e12cf5cab46a783a4753f07bb99e557473b
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu Mar 13 12:47:39 2014 +0800

    ACPI: Remove duplicate definitions of PREFIX
    
    We already have a macro for PREFIX of "ACPI: " in
    drivers/acpi/internal.h, so remove the duplicate ones
    in ACPI drivers when internal.h is included.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 368f9ddb8480..dceba8310c4f 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -31,8 +31,6 @@
 
 #include "internal.h"
 
-#define PREFIX "ACPI: "
-
 #define _COMPONENT			ACPI_CONTAINER_COMPONENT
 ACPI_MODULE_NAME("container");
 

commit 6621c5a69a1dac50852ef09d5cf33154a174805a
Merge: d983f9332804 d901188f0021
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 17 13:47:14 2014 +0100

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI / hotplug: Rework deferred execution of acpi_device_hotplug()
      ACPI / dock: Update copyright notice
      ACPI / dock: Drop remove_dock_dependent_devices()
      ACPI / dock: Drop struct acpi_dock_ops and all code related to it
      ACPI / ATA: Add hotplug contexts to ACPI companions of SATA devices
      ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context
      ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts
      ACPI / dock: Use ACPI device object pointers instead of ACPI handles
      ACPI / hotplug: Add .fixup() callback to struct acpi_hotplug_context
      ACPI / hotplug / PCI: Do not clear event callback pointer for docks
      ACPI / dock: Associate dock platform devices with ACPI device objects
      ACPI / dock: Pass ACPI device pointer to acpi_device_is_battery()
      ACPI / dock: Dispatch dock notifications from the global notify handler

commit 1e2380cd144f6a9619f72f80ad9a93268f63b8dc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 16 01:51:01 2014 +0100

    ACPI / dock: Dispatch dock notifications from the global notify handler
    
    The ACPI dock station code carries out an extra namespace scan
    before the main one in order to find and register all of the dock
    device objects.  Then, it registers a notify handler for each of
    them for handling dock events.
    
    However, dock device objects need not be scanned for upfront.  They
    very well can be enumerated and registered during the first phase
    of the main namespace scan, before attaching scan handlers and ACPI
    drivers to ACPI device objects.  Then, the dependent devices can be
    added to the in the second phase.  That makes it possible to drop
    the extra namespace scan, so do it.
    
    Moreover, it is not necessary to register notify handlers for all
    of the dock stations' namespace nodes, becuase notifications may
    be dispatched from the global notify handler for them.  Do that and
    drop two functions used for dock notify handling, acpi_dock_deferred_cb()
    and dock_notify_handler(), that aren't necessary any more.
    
    Finally, some dock station objects have _HID objects matching the
    ACPI container scan handler which causes it to claim those objects
    and try to handle their hotplug, but that is not a good idea,
    because those objects have their own special hotplug handling anyway.
    For this reason, the hotplug_notify flag should not be set for ACPI
    device objects representing dock stations and the container scan
    handler should be made ignore those objects, so make that happen.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 0b6ae6eb5c4a..9c35765ac5e9 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -68,6 +68,9 @@ static int container_device_attach(struct acpi_device *adev,
 	struct device *dev;
 	int ret;
 
+	if (adev->flags.is_dock_station)
+		return 0;
+
 	cdev = kzalloc(sizeof(*cdev), GFP_KERNEL);
 	if (!cdev)
 		return -ENOMEM;

commit 0f6aa09e40c38d734f5d70762056116ca4a76126
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 12 00:52:49 2014 +0100

    ACPI / container: Fix error code path in container_device_attach()
    
    To avoid leaking memory on errors from device_register(), do a
    put_device() on the device object in question in the error code
    path of container_device_attach().
    
    Fixes: caa73ea158de (ACPI / hotplug / driver core: Handle containers in a special way)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 0b6ae6eb5c4a..368f9ddb8480 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -79,9 +79,10 @@ static int container_device_attach(struct acpi_device *adev,
 	ACPI_COMPANION_SET(dev, adev);
 	dev->release = acpi_container_release;
 	ret = device_register(dev);
-	if (ret)
+	if (ret) {
+		put_device(dev);
 		return ret;
-
+	}
 	adev->driver_data = dev;
 	return 1;
 }

commit caa73ea158de9419f08e456f2716c71d1f06012a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 29 15:25:48 2013 +0100

    ACPI / hotplug / driver core: Handle containers in a special way
    
    ACPI container devices require special hotplug handling, at least
    on some systems, since generally user space needs to carry out
    system-specific cleanup before it makes sense to offline devices in
    the container.  However, the current ACPI hotplug code for containers
    first attempts to offline devices in the container and only then it
    notifies user space of the container offline.
    
    Moreover, after commit 202317a573b2 (ACPI / scan: Add acpi_device
    objects for all device nodes in the namespace), ACPI device objects
    representing containers are present as long as the ACPI namespace
    nodes corresponding to them are present, which may be forever, even
    if the container devices are physically detached from the system (the
    return values of the corresponding _STA methods change in those
    cases, but generally the namespace nodes themselves are still there).
    Thus it is useful to introduce entities representing containers that
    will go away during container hot-unplug.
    
    The goal of this change is to address both the above issues.
    
    The idea is to create a "companion" container system device for each
    of the ACPI container device objects during the initial namespace
    scan or on a hotplug event making the container present.  That system
    device will be unregistered on container removal.  A new bus type
    for container devices is added for this purpose, because device
    offline and online operations need to be defined for them.  The
    online operation is a trivial function that is always successful
    and the offline uses a callback pointed to by the container device's
    offline member.
    
    For ACPI containers that callback simply walks the list of ACPI
    device objects right below the container object (its children) and
    checks if all of their physical companion devices are offline.  If
    that's not the case, it returns -EBUSY and the container system
    devivce cannot be put offline.  Consequently, to put the container
    system device offline, it is necessary to put all of the physical
    devices depending on its ACPI companion object offline beforehand.
    
    Container system devices created for ACPI container objects are
    initially online.  They are created by the container ACPI scan
    handler whose hotplug.demand_offline flag is set.  That causes
    acpi_scan_hot_remove() to check if the companion container system
    device is offline before attempting to remove an ACPI container or
    any devices below it.  If the check fails, a KOBJ_CHANGE uevent is
    emitted for the container system device in question and user space
    is expected to offline all devices below the container and the
    container itself in response to it.  Then, user space can finalize
    the removal of the container with the help of its ACPI device
    object's eject attribute in sysfs.
    
    Tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 83d232c10f13..0b6ae6eb5c4a 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -27,8 +27,7 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 #include <linux/acpi.h>
-
-#include "internal.h"
+#include <linux/container.h>
 
 #include "internal.h"
 
@@ -44,16 +43,56 @@ static const struct acpi_device_id container_device_ids[] = {
 	{"", 0},
 };
 
+static int acpi_container_offline(struct container_dev *cdev)
+{
+	struct acpi_device *adev = ACPI_COMPANION(&cdev->dev);
+	struct acpi_device *child;
+
+	/* Check all of the dependent devices' physical companions. */
+	list_for_each_entry(child, &adev->children, node)
+		if (!acpi_scan_is_offline(child, false))
+			return -EBUSY;
+
+	return 0;
+}
+
+static void acpi_container_release(struct device *dev)
+{
+	kfree(to_container_dev(dev));
+}
+
 static int container_device_attach(struct acpi_device *adev,
 				   const struct acpi_device_id *not_used)
 {
-	kobject_uevent(&adev->dev.kobj, KOBJ_ONLINE);
+	struct container_dev *cdev;
+	struct device *dev;
+	int ret;
+
+	cdev = kzalloc(sizeof(*cdev), GFP_KERNEL);
+	if (!cdev)
+		return -ENOMEM;
+
+	cdev->offline = acpi_container_offline;
+	dev = &cdev->dev;
+	dev->bus = &container_subsys;
+	dev_set_name(dev, "%s", dev_name(&adev->dev));
+	ACPI_COMPANION_SET(dev, adev);
+	dev->release = acpi_container_release;
+	ret = device_register(dev);
+	if (ret)
+		return ret;
+
+	adev->driver_data = dev;
 	return 1;
 }
 
 static void container_device_detach(struct acpi_device *adev)
 {
-	kobject_uevent(&adev->dev.kobj, KOBJ_OFFLINE);
+	struct device *dev = acpi_driver_data(adev);
+
+	adev->driver_data = NULL;
+	if (dev)
+		device_unregister(dev);
 }
 
 static struct acpi_scan_handler container_handler = {
@@ -62,6 +101,7 @@ static struct acpi_scan_handler container_handler = {
 	.detach = container_device_detach,
 	.hotplug = {
 		.enabled = true,
+		.demand_offline = true,
 	},
 };
 

commit 46394fd017c0615982a3d29d45ced14bea9c526d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:55:32 2013 +0100

    ACPI / hotplug: Move container-specific code out of the core
    
    Move container-specific uevents from the core hotplug code to the
    container scan handler's .attach() and .detach() callbacks.
    
    This way the core will not have to special-case containers and
    the uevents will be guaranteed to happen every time a container
    is either scanned or trimmed as appropriate.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index e23151667655..83d232c10f13 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -44,19 +44,24 @@ static const struct acpi_device_id container_device_ids[] = {
 	{"", 0},
 };
 
-static int container_device_attach(struct acpi_device *device,
+static int container_device_attach(struct acpi_device *adev,
 				   const struct acpi_device_id *not_used)
 {
-	/* This is necessary for container hotplug to work. */
+	kobject_uevent(&adev->dev.kobj, KOBJ_ONLINE);
 	return 1;
 }
 
+static void container_device_detach(struct acpi_device *adev)
+{
+	kobject_uevent(&adev->dev.kobj, KOBJ_OFFLINE);
+}
+
 static struct acpi_scan_handler container_handler = {
 	.ids = container_device_ids,
 	.attach = container_device_attach,
+	.detach = container_device_detach,
 	.hotplug = {
 		.enabled = true,
-		.mode = AHM_CONTAINER,
 	},
 };
 

commit c940c8ce1db3ed3909d31c02aef01a864565519c
Merge: 34bdb1a458ba 94a409319561
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Apr 28 01:54:08 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted: (21 commits)
      ACPI / thermal: do not always return THERMAL_TREND_RAISING for active trip points
      ACPI: video: correct acpi_video_bus_add error processing
      ACPI: Fix wrong parameter passed to memblock_reserve
      acpi: video: enhance the quirk detect logic of _BQC
      ACPI: update comments for acpi_event_status
      ACPI: remove "config ACPI_DEBUG_FUNC_TRACE"
      PCI / ACPI: Don't query OSC support with all possible controls
      ACPI / processor_thermal: avoid null pointer deference error
      ACPI / fan: avoid null pointer deference error
      ACPI / video: Fix applying indexed initial brightness value.
      ACPI / video: Make logic a little easier to understand.
      ACPI / video: Fix brightness control initialization for some laptops.
      ACPI: Use resource_size() in osl.c
      ACPI / acpi_pad: Used PTR_RET
      ACPI: suppress compiler warning in container.c
      ACPI: suppress compiler warning in battery.c
      ACPI: suppress compiler warnings in processor_throttling.c
      ACPI: suppress compiler warnings in button.c
      ACPI: replace kmalloc+memcpy with kmemdup
      ACPI: Remove acpi_pci_bind_root() definition
      ...

commit 2f9b06fc95486e396dd533670dcb25de5e2612ea
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 11 09:17:07 2013 +0000

    ACPI: suppress compiler warning in container.c
    
    This patch fixes following compiler warning when build via make W=1:
    
    drivers/acpi/container.c:183:116: warning: no previous prototype for ‘acpi_container_init’ [-Wmissing-prototypes]
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 5523ba7d764d..6624c0139d9d 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -35,6 +35,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#include "internal.h"
+
 #define PREFIX "ACPI: "
 
 #define _COMPONENT			ACPI_CONTAINER_COMPONENT

commit 79917f34ac83140c20b06303b608ce6d740f0266
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:08:45 2013 +0100

    ACPI / container: Use hotplug profile user space interface
    
    Make the ACPI container driver register its ACPI scan handler object
    using acpi_scan_add_handler_with_hotplug() to allow user space to
    manipulate its hotplug profile attributes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 7f08dd68c524..f9f8a08827fa 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -49,7 +49,7 @@ static int container_device_attach(struct acpi_device *device,
 	return 1;
 }
 
-static struct acpi_scan_handler container_device_handler = {
+static struct acpi_scan_handler container_handler = {
 	.ids = container_device_ids,
 	.attach = container_device_attach,
 	.hotplug = {
@@ -60,5 +60,5 @@ static struct acpi_scan_handler container_device_handler = {
 
 void __init acpi_container_init(void)
 {
-	acpi_scan_add_handler(&container_device_handler);
+	acpi_scan_add_handler_with_hotplug(&container_handler, "container");
 }

commit 68a67f6c78b80525d9b3c6672e7782de95e56a83
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:05:55 2013 +0100

    ACPI / container: Use common hotplug code
    
    Switch the ACPI container driver to using common device hotplug code
    introduced previously.  This reduces the driver down to a trivial
    definition and registration of a struct acpi_scan_handler object.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 5523ba7d764d..7f08dd68c524 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -1,12 +1,12 @@
 /*
- * acpi_container.c  - ACPI Generic Container Driver
- * ($Revision: )
+ * container.c  - ACPI Generic Container Driver
  *
  * Copyright (C) 2004 Anil S Keshavamurthy (anil.s.keshavamurthy@intel.com)
  * Copyright (C) 2004 Keiichiro Tokunaga (tokunaga.keiich@jp.fujitsu.com)
  * Copyright (C) 2004 Motoyuki Ito (motoyuki@soft.fujitsu.com)
- * Copyright (C) 2004 Intel Corp.
  * Copyright (C) 2004 FUJITSU LIMITED
+ * Copyright (C) 2004, 2013 Intel Corp.
+ * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -26,14 +26,9 @@
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/types.h>
 #include <linux/acpi.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
+
+#include "internal.h"
 
 #define PREFIX "ACPI: "
 
@@ -50,141 +45,20 @@ static const struct acpi_device_id container_device_ids[] = {
 static int container_device_attach(struct acpi_device *device,
 				   const struct acpi_device_id *not_used)
 {
-	/*
-	 * FIXME: This is necessary, so that acpi_eject_store() doesn't return
-	 * -ENODEV for containers.
-	 */
+	/* This is necessary for container hotplug to work. */
 	return 1;
 }
 
 static struct acpi_scan_handler container_device_handler = {
 	.ids = container_device_ids,
 	.attach = container_device_attach,
+	.hotplug = {
+		.enabled = true,
+		.mode = AHM_CONTAINER,
+	},
 };
 
-static int is_device_present(acpi_handle handle)
-{
-	acpi_handle temp;
-	acpi_status status;
-	unsigned long long sta;
-
-
-	status = acpi_get_handle(handle, "_STA", &temp);
-	if (ACPI_FAILURE(status))
-		return 1;	/* _STA not found, assume device present */
-
-	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
-	if (ACPI_FAILURE(status))
-		return 0;	/* Firmware error */
-
-	return ((sta & ACPI_STA_DEVICE_PRESENT) == ACPI_STA_DEVICE_PRESENT);
-}
-
-static void container_notify_cb(acpi_handle handle, u32 type, void *context)
-{
-	struct acpi_device *device = NULL;
-	int result;
-	int present;
-	acpi_status status;
-	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE; /* default */
-
-	acpi_scan_lock_acquire();
-
-	switch (type) {
-	case ACPI_NOTIFY_BUS_CHECK:
-		/* Fall through */
-	case ACPI_NOTIFY_DEVICE_CHECK:
-		pr_debug("Container driver received %s event\n",
-		       (type == ACPI_NOTIFY_BUS_CHECK) ?
-		       "ACPI_NOTIFY_BUS_CHECK" : "ACPI_NOTIFY_DEVICE_CHECK");
-
-		present = is_device_present(handle);
-		status = acpi_bus_get_device(handle, &device);
-		if (!present) {
-			if (ACPI_SUCCESS(status)) {
-				/* device exist and this is a remove request */
-				device->flags.eject_pending = 1;
-				kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
-				goto out;
-			}
-			break;
-		}
-
-		if (!ACPI_FAILURE(status) || device)
-			break;
-
-		result = acpi_bus_scan(handle);
-		if (result) {
-			acpi_handle_warn(handle, "Failed to add container\n");
-			break;
-		}
-		result = acpi_bus_get_device(handle, &device);
-		if (result) {
-			acpi_handle_warn(handle, "Missing device object\n");
-			break;
-		}
-
-		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
-		ost_code = ACPI_OST_SC_SUCCESS;
-		break;
-
-	case ACPI_NOTIFY_EJECT_REQUEST:
-		if (!acpi_bus_get_device(handle, &device) && device) {
-			device->flags.eject_pending = 1;
-			kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
-			goto out;
-		}
-		break;
-
-	default:
-		/* non-hotplug event; possibly handled by other handler */
-		goto out;
-	}
-
-	/* Inform firmware that the hotplug operation has completed */
-	(void) acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
-
- out:
-	acpi_scan_lock_release();
-}
-
-static bool is_container(acpi_handle handle)
-{
-	struct acpi_device_info *info;
-	bool ret = false;
-
-	if (ACPI_FAILURE(acpi_get_object_info(handle, &info)))
-		return false;
-
-	if (info->valid & ACPI_VALID_HID) {
-		const struct acpi_device_id *id;
-
-		for (id = container_device_ids; id->id[0]; id++) {
-			ret = !strcmp((char *)id->id, info->hardware_id.string);
-			if (ret)
-				break;
-		}
-	}
-	kfree(info);
-	return ret;
-}
-
-static acpi_status acpi_container_register_notify_handler(acpi_handle handle,
-							  u32 lvl, void *ctxt,
-							  void **retv)
-{
-	if (is_container(handle))
-		acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-					    container_notify_cb, NULL);
-
-	return AE_OK;
-}
-
 void __init acpi_container_init(void)
 {
-	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-			    acpi_container_register_notify_handler, NULL,
-			    NULL, NULL);
-
 	acpi_scan_add_handler(&container_device_handler);
 }

commit 3757b94802fb65d8f696597a74053cf21738da0b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 13 14:36:47 2013 +0100

    ACPI / hotplug: Fix concurrency issues and memory leaks
    
    This changeset is aimed at fixing a few different but related
    problems in the ACPI hotplug infrastructure.
    
    First of all, since notify handlers may be run in parallel with
    acpi_bus_scan(), acpi_bus_trim() and acpi_bus_hot_remove_device()
    and some of them are installed for ACPI handles that have no struct
    acpi_device objects attached (i.e. before those objects are created),
    those notify handlers have to take acpi_scan_lock to prevent races
    from taking place (e.g. a struct acpi_device is found to be present
    for the given ACPI handle, but right after that it is removed by
    acpi_bus_trim() running in parallel to the given notify handler).
    Moreover, since some of them call acpi_bus_scan() and
    acpi_bus_trim(), this leads to the conclusion that acpi_scan_lock
    should be acquired by the callers of these two funtions rather by
    these functions themselves.
    
    For these reasons, make all notify handlers that can handle device
    addition and eject events take acpi_scan_lock and remove the
    acpi_scan_lock locking from acpi_bus_scan() and acpi_bus_trim().
    Accordingly, update all of their users to make sure that they
    are always called under acpi_scan_lock.
    
    Furthermore, since eject operations are carried out asynchronously
    with respect to the notify events that trigger them, with the help
    of acpi_bus_hot_remove_device(), even if notify handlers take the
    ACPI scan lock, it still is possible that, for example,
    acpi_bus_trim() will run between acpi_bus_hot_remove_device() and
    the notify handler that scheduled its execution and that
    acpi_bus_trim() will remove the device node passed to
    acpi_bus_hot_remove_device() for ejection.  In that case, the struct
    acpi_device object obtained by acpi_bus_hot_remove_device() will be
    invalid and not-so-funny things will ensue.  To protect agaist that,
    make the users of acpi_bus_hot_remove_device() run get_device() on
    ACPI device node objects that are about to be passed to it and make
    acpi_bus_hot_remove_device() run put_device() on them and check if
    their ACPI handles are not NULL (make acpi_device_unregister() clear
    the device nodes' ACPI handles for that check to work).
    
    Finally, observe that acpi_os_hotplug_execute() actually can fail,
    in which case its caller ought to free memory allocated for the
    context object to prevent leaks from happening.  It also needs to
    run put_device() on the device node that it ran get_device() on
    previously in that case.  Modify the code accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 4cc2937cc022..5523ba7d764d 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -88,6 +88,8 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 	acpi_status status;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE; /* default */
 
+	acpi_scan_lock_acquire();
+
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		/* Fall through */
@@ -103,7 +105,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 				/* device exist and this is a remove request */
 				device->flags.eject_pending = 1;
 				kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
-				return;
+				goto out;
 			}
 			break;
 		}
@@ -130,18 +132,20 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 		if (!acpi_bus_get_device(handle, &device) && device) {
 			device->flags.eject_pending = 1;
 			kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
-			return;
+			goto out;
 		}
 		break;
 
 	default:
 		/* non-hotplug event; possibly handled by other handler */
-		return;
+		goto out;
 	}
 
 	/* Inform firmware that the hotplug operation has completed */
 	(void) acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
-	return;
+
+ out:
+	acpi_scan_lock_release();
 }
 
 static bool is_container(acpi_handle handle)

commit 87d4a4da7353c8582049dab50b880798d88ff9d7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 9 01:08:20 2013 +0100

    ACPI: Drop the container.h header file
    
    The include/acpi/container.h only contains a definition of a
    structure that is not used any more, so drop it entirely.
    
    Similar change was proposed earlier by Toshi Kani.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 9053e86e9904..4cc2937cc022 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -34,7 +34,6 @@
 #include <linux/acpi.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
-#include <acpi/container.h>
 
 #define PREFIX "ACPI: "
 

commit 737f1a9f808280c481681b1f46254fd67023ec2f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 8 23:52:39 2013 +0100

    ACPI / scan: Make container driver use struct acpi_scan_handler
    
    Make the ACPI container driver use struct acpi_scan_handler for
    representing the object used to initialize ACPI containers and remove
    the ACPI driver structure used previously and the data structures
    created by it, since in fact they were not used for any purpose.
    
    This simplifies the code and reduces the kernel's memory footprint by
    avoiding the registration of a struct device_driver object with the
    driver core and creation of its sysfs directory which is unnecessary.
    
    In addition to that, make the namespace walk callback used for
    installing the notify handlers for ACPI containers more
    straightforward.
    
    This change includes fixes from Toshi Kani.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index cc0bf4613e0d..9053e86e9904 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -38,42 +38,31 @@
 
 #define PREFIX "ACPI: "
 
-#define ACPI_CONTAINER_DEVICE_NAME	"ACPI container device"
-#define ACPI_CONTAINER_CLASS		"container"
-
-#define INSTALL_NOTIFY_HANDLER		1
-#define UNINSTALL_NOTIFY_HANDLER	2
-
 #define _COMPONENT			ACPI_CONTAINER_COMPONENT
 ACPI_MODULE_NAME("container");
 
-MODULE_AUTHOR("Anil S Keshavamurthy");
-MODULE_DESCRIPTION("ACPI container driver");
-MODULE_LICENSE("GPL");
-
-static int acpi_container_add(struct acpi_device *device);
-static int acpi_container_remove(struct acpi_device *device);
-
 static const struct acpi_device_id container_device_ids[] = {
 	{"ACPI0004", 0},
 	{"PNP0A05", 0},
 	{"PNP0A06", 0},
 	{"", 0},
 };
-MODULE_DEVICE_TABLE(acpi, container_device_ids);
 
-static struct acpi_driver acpi_container_driver = {
-	.name = "container",
-	.class = ACPI_CONTAINER_CLASS,
+static int container_device_attach(struct acpi_device *device,
+				   const struct acpi_device_id *not_used)
+{
+	/*
+	 * FIXME: This is necessary, so that acpi_eject_store() doesn't return
+	 * -ENODEV for containers.
+	 */
+	return 1;
+}
+
+static struct acpi_scan_handler container_device_handler = {
 	.ids = container_device_ids,
-	.ops = {
-		.add = acpi_container_add,
-		.remove = acpi_container_remove,
-		},
+	.attach = container_device_attach,
 };
 
-/*******************************************************************/
-
 static int is_device_present(acpi_handle handle)
 {
 	acpi_handle temp;
@@ -92,49 +81,6 @@ static int is_device_present(acpi_handle handle)
 	return ((sta & ACPI_STA_DEVICE_PRESENT) == ACPI_STA_DEVICE_PRESENT);
 }
 
-static bool is_container_device(const char *hid)
-{
-	const struct acpi_device_id *container_id;
-
-	for (container_id = container_device_ids;
-	     container_id->id[0]; container_id++) {
-		if (!strcmp((char *)container_id->id, hid))
-			return true;
-	}
-
-	return false;
-}
-
-/*******************************************************************/
-static int acpi_container_add(struct acpi_device *device)
-{
-	struct acpi_container *container;
-
-	container = kzalloc(sizeof(struct acpi_container), GFP_KERNEL);
-	if (!container)
-		return -ENOMEM;
-
-	container->handle = device->handle;
-	strcpy(acpi_device_name(device), ACPI_CONTAINER_DEVICE_NAME);
-	strcpy(acpi_device_class(device), ACPI_CONTAINER_CLASS);
-	device->driver_data = container;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device <%s> bid <%s>\n",
-			  acpi_device_name(device), acpi_device_bid(device)));
-
-	return 0;
-}
-
-static int acpi_container_remove(struct acpi_device *device)
-{
-	acpi_status status = AE_OK;
-	struct acpi_container *pc = NULL;
-
-	pc = acpi_driver_data(device);
-	kfree(pc);
-	return status;
-}
-
 static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 {
 	struct acpi_device *device = NULL;
@@ -199,84 +145,43 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 	return;
 }
 
-static acpi_status
-container_walk_namespace_cb(acpi_handle handle,
-			    u32 lvl, void *context, void **rv)
+static bool is_container(acpi_handle handle)
 {
-	char *hid = NULL;
 	struct acpi_device_info *info;
-	acpi_status status;
-	int *action = context;
-
-	status = acpi_get_object_info(handle, &info);
-	if (ACPI_FAILURE(status)) {
-		return AE_OK;
-	}
+	bool ret = false;
 
-	if (info->valid & ACPI_VALID_HID)
-		hid = info->hardware_id.string;
+	if (ACPI_FAILURE(acpi_get_object_info(handle, &info)))
+		return false;
 
-	if (hid == NULL) {
-		goto end;
-	}
-
-	if (!is_container_device(hid))
-		goto end;
+	if (info->valid & ACPI_VALID_HID) {
+		const struct acpi_device_id *id;
 
-	switch (*action) {
-	case INSTALL_NOTIFY_HANDLER:
-		acpi_install_notify_handler(handle,
-					    ACPI_SYSTEM_NOTIFY,
-					    container_notify_cb, NULL);
-		break;
-	case UNINSTALL_NOTIFY_HANDLER:
-		acpi_remove_notify_handler(handle,
-					   ACPI_SYSTEM_NOTIFY,
-					   container_notify_cb);
-		break;
-	default:
-		break;
+		for (id = container_device_ids; id->id[0]; id++) {
+			ret = !strcmp((char *)id->id, info->hardware_id.string);
+			if (ret)
+				break;
+		}
 	}
-
-      end:
 	kfree(info);
-
-	return AE_OK;
+	return ret;
 }
 
-static int __init acpi_container_init(void)
+static acpi_status acpi_container_register_notify_handler(acpi_handle handle,
+							  u32 lvl, void *ctxt,
+							  void **retv)
 {
-	int result = 0;
-	int action = INSTALL_NOTIFY_HANDLER;
-
-	result = acpi_bus_register_driver(&acpi_container_driver);
-	if (result < 0) {
-		return (result);
-	}
-
-	/* register notify handler to every container device */
-	acpi_walk_namespace(ACPI_TYPE_DEVICE,
-			    ACPI_ROOT_OBJECT,
-			    ACPI_UINT32_MAX,
-			    container_walk_namespace_cb, NULL, &action, NULL);
+	if (is_container(handle))
+		acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+					    container_notify_cb, NULL);
 
-	return (0);
+	return AE_OK;
 }
 
-static void __exit acpi_container_exit(void)
+void __init acpi_container_init(void)
 {
-	int action = UNINSTALL_NOTIFY_HANDLER;
-
-
-	acpi_walk_namespace(ACPI_TYPE_DEVICE,
-			    ACPI_ROOT_OBJECT,
-			    ACPI_UINT32_MAX,
-			    container_walk_namespace_cb, NULL, &action, NULL);
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+			    acpi_container_register_notify_handler, NULL,
+			    NULL, NULL);
 
-	acpi_bus_unregister_driver(&acpi_container_driver);
-
-	return;
+	acpi_scan_add_handler(&container_device_handler);
 }
-
-module_init(acpi_container_init);
-module_exit(acpi_container_exit);

commit 51fac8388a0325a43f0ae67453ece2c373e2ec28
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 00:24:48 2013 +0100

    ACPI: Remove useless type argument of driver .remove() operation
    
    The second argument of ACPI driver .remove() operation is only used
    by the ACPI processor driver and the value passed to that driver
    through it is always available from the given struct acpi_device
    object's removal_type field.  For this reason, the second ACPI driver
    .remove() argument is in fact useless, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jiang Liu <jiang.liu@huawei.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index cc79d3e53a39..cc0bf4613e0d 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -52,7 +52,7 @@ MODULE_DESCRIPTION("ACPI container driver");
 MODULE_LICENSE("GPL");
 
 static int acpi_container_add(struct acpi_device *device);
-static int acpi_container_remove(struct acpi_device *device, int type);
+static int acpi_container_remove(struct acpi_device *device);
 
 static const struct acpi_device_id container_device_ids[] = {
 	{"ACPI0004", 0},
@@ -125,7 +125,7 @@ static int acpi_container_add(struct acpi_device *device)
 	return 0;
 }
 
-static int acpi_container_remove(struct acpi_device *device, int type)
+static int acpi_container_remove(struct acpi_device *device)
 {
 	acpi_status status = AE_OK;
 	struct acpi_container *pc = NULL;

commit b8bd759acd05281abf88cddef30c57313c109697
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 19 01:27:35 2013 +0100

    ACPI / scan: Drop acpi_bus_add() and use acpi_bus_scan() instead
    
    The only difference between acpi_bus_scan() and acpi_bus_add() is the
    invocation of acpi_update_all_gpes() in the latter which in fact is
    unnecessary, because acpi_update_all_gpes() has already been called
    by acpi_scan_init() and the way it is implemented guarantees the next
    invocations of it to do nothing.
    
    For this reason, drop acpi_bus_add() and make all its callers use
    acpi_bus_scan() directly instead of it.  Additionally, rearrange the
    code in acpi_scan_init() slightly to improve the visibility of the
    acpi_update_all_gpes() call in there.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index f8fb2281f34a..cc79d3e53a39 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -166,7 +166,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 		if (!ACPI_FAILURE(status) || device)
 			break;
 
-		result = acpi_bus_add(handle);
+		result = acpi_bus_scan(handle);
 		if (result) {
 			acpi_handle_warn(handle, "Failed to add container\n");
 			break;

commit 0cd6ac52b333f66ee64e50ed216ec99231092dcd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:49 2012 +0100

    ACPI: Make acpi_bus_scan() and acpi_bus_add() take only one argument
    
    The callers of acpi_bus_add() usually assume that if it has
    succeeded, then a struct acpi_device object has been attached to
    the handle passed as the first argument.  Unfortunately, however,
    this assumption is wrong, because acpi_bus_scan(), and acpi_bus_add()
    too as a result, may return a pointer to a different struct
    acpi_device object on success (it may be an object corresponding to
    one of the descendant ACPI nodes in the namespace scope below that
    handle).
    
    For this reason, the callers of acpi_bus_add() who care about
    whether or not a struct acpi_device object has been created for
    its first argument need to check that using acpi_bus_get_device()
    anyway, so the second argument of acpi_bus_add() is not really
    useful for them.  The same observation applies to acpi_bus_scan()
    executed directly from acpi_scan_init().
    
    Therefore modify the relevant callers of acpi_bus_add() to check the
    existence of the struct acpi_device in question with the help of
    acpi_bus_get_device() and drop the no longer necessary second
    argument of acpi_bus_add().  Accordingly, modify acpi_scan_init() to
    use acpi_bus_get_device() to get acpi_root and drop the no longer
    needed second argument of acpi_bus_scan().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 0688f83bc436..f8fb2281f34a 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -166,11 +166,16 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 		if (!ACPI_FAILURE(status) || device)
 			break;
 
-		result = acpi_bus_add(handle, &device);
+		result = acpi_bus_add(handle);
 		if (result) {
 			acpi_handle_warn(handle, "Failed to add container\n");
 			break;
 		}
+		result = acpi_bus_get_device(handle, &device);
+		if (result) {
+			acpi_handle_warn(handle, "Missing device object\n");
+			break;
+		}
 
 		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
 		ost_code = ACPI_OST_SC_SUCCESS;

commit 636458de36f1fb4cdd318387d2f45604e451b17a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:47 2012 +0100

    ACPI: Remove the arguments of acpi_bus_add() that are not used
    
    Notice that acpi_bus_add() uses only 2 of its 4 arguments and
    redefine its header to match the body.  Update all of its callers as
    necessary and observe that this leads to quite a number of removed
    lines of code (Linus will like that).
    
    Add a kerneldoc comment documenting acpi_bus_add() and wonder how
    its callers make wrong assumptions about the second argument (make
    note to self to take care of that later).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 98b85e3e4781..0688f83bc436 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -135,20 +135,6 @@ static int acpi_container_remove(struct acpi_device *device, int type)
 	return status;
 }
 
-static int container_device_add(struct acpi_device **device, acpi_handle handle)
-{
-	acpi_handle phandle;
-	struct acpi_device *pdev;
-
-	if (acpi_get_parent(handle, &phandle))
-		return -ENODEV;
-
-	if (acpi_bus_get_device(phandle, &pdev))
-		return -ENODEV;
-
-	return acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_DEVICE);
-}
-
 static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 {
 	struct acpi_device *device = NULL;
@@ -180,7 +166,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 		if (!ACPI_FAILURE(status) || device)
 			break;
 
-		result = container_device_add(&device, handle);
+		result = acpi_bus_add(handle, &device);
 		if (result) {
 			acpi_handle_warn(handle, "Failed to add container\n");
 			break;

commit 02f57c67a8677ae55dcdd256a2a7abaf41e4cc1f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:46 2012 +0100

    ACPI: Remove acpi_start_single_object() and acpi_bus_start()
    
    The ACPI PCI root bridge driver was the only ACPI driver implementing
    the .start() callback, which isn't used by any ACPI drivers any more
    now.
    
    For this reason, acpi_start_single_object() has no purpose any more,
    so remove it and all references to it.  Also remove
    acpi_bus_start_device(), whose only purpose was to call
    acpi_start_single_object().
    
    Moreover, since after the removal of acpi_bus_start_device() the
    only purpose of acpi_bus_start() remains to call
    acpi_update_all_gpes(), move that into acpi_bus_add() and drop
    acpi_bus_start() too, remove its header from acpi_bus.h and
    update all of its former users accordingly.
    
    This change was previously proposed in a different from by
    Yinghai Lu.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 811910b50b75..98b85e3e4781 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -139,24 +139,14 @@ static int container_device_add(struct acpi_device **device, acpi_handle handle)
 {
 	acpi_handle phandle;
 	struct acpi_device *pdev;
-	int result;
-
-
-	if (acpi_get_parent(handle, &phandle)) {
-		return -ENODEV;
-	}
 
-	if (acpi_bus_get_device(phandle, &pdev)) {
+	if (acpi_get_parent(handle, &phandle))
 		return -ENODEV;
-	}
 
-	if (acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_DEVICE)) {
+	if (acpi_bus_get_device(phandle, &pdev))
 		return -ENODEV;
-	}
-
-	result = acpi_bus_start(*device);
 
-	return result;
+	return acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_DEVICE);
 }
 
 static void container_notify_cb(acpi_handle handle, u32 type, void *context)

commit 3d78bd9ef746d6468b1dbb2518b1287092b997b5
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Tue Nov 20 23:42:29 2012 +0000

    ACPI: Update Container hotplug error messages
    
    Updated Container hotplug error messages with acpi_handle_<level>()
    and pr_<level>().  Removed an unnecessary check to the device arg
    in acpi_container_add().
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 69e2d6be910c..811910b50b75 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -110,12 +110,6 @@ static int acpi_container_add(struct acpi_device *device)
 {
 	struct acpi_container *container;
 
-
-	if (!device) {
-		printk(KERN_ERR PREFIX "device is NULL\n");
-		return -EINVAL;
-	}
-
 	container = kzalloc(sizeof(struct acpi_container), GFP_KERNEL);
 	if (!container)
 		return -ENOMEM;
@@ -177,7 +171,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 	case ACPI_NOTIFY_BUS_CHECK:
 		/* Fall through */
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		printk(KERN_WARNING "Container driver received %s event\n",
+		pr_debug("Container driver received %s event\n",
 		       (type == ACPI_NOTIFY_BUS_CHECK) ?
 		       "ACPI_NOTIFY_BUS_CHECK" : "ACPI_NOTIFY_DEVICE_CHECK");
 
@@ -198,7 +192,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 
 		result = container_device_add(&device, handle);
 		if (result) {
-			printk(KERN_WARNING "Failed to add container\n");
+			acpi_handle_warn(handle, "Failed to add container\n");
 			break;
 		}
 

commit 594df89a59cf2a2afc22fe27f508dd864d1edb5f
Author: Tang Chen <tangchen@cn.fujitsu.com>
Date:   Fri Oct 26 13:38:16 2012 +0200

    ACPI: Fix a hard coding style when determining if a device is a container, v3
    
    "ACPI0004","PNP0A05" and "PNP0A06" are all defined in array
    container_device_ids[], so use it, but not the hard coding style.
    
    Also, introduce a new API is_container_device() to determine if a
    device is a container device.
    
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Signed-off-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 1f9f7d7d7bc5..69e2d6be910c 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -92,6 +92,19 @@ static int is_device_present(acpi_handle handle)
 	return ((sta & ACPI_STA_DEVICE_PRESENT) == ACPI_STA_DEVICE_PRESENT);
 }
 
+static bool is_container_device(const char *hid)
+{
+	const struct acpi_device_id *container_id;
+
+	for (container_id = container_device_ids;
+	     container_id->id[0]; container_id++) {
+		if (!strcmp((char *)container_id->id, hid))
+			return true;
+	}
+
+	return false;
+}
+
 /*******************************************************************/
 static int acpi_container_add(struct acpi_device *device)
 {
@@ -232,10 +245,8 @@ container_walk_namespace_cb(acpi_handle handle,
 		goto end;
 	}
 
-	if (strcmp(hid, "ACPI0004") && strcmp(hid, "PNP0A05") &&
-	    strcmp(hid, "PNP0A06")) {
+	if (!is_container_device(hid))
 		goto end;
-	}
 
 	switch (*action) {
 	case INSTALL_NOTIFY_HANDLER:

commit 0c67dc242cf73b9c99a05bfd0122fc9ba1970d37
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Wed May 23 20:25:23 2012 -0600

    ACPI: Add _OST support for ACPI container hotplug
    
    Changed container_notify_cb() to call ACPI _OST method when ACPI
    container hotplug operation has completed. Slightly restructured
    the code with the same logic. The function sets eject_pending bit
    for an eject request since it does not initiate hot-remove operation.
    This bit is checked by the sysfs eject handler to determine if the
    request is originated from an ACPI eject notification.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 45cd03b4630e..1f9f7d7d7bc5 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -158,9 +158,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 	int result;
 	int present;
 	acpi_status status;
-
-
-	present = is_device_present(handle);
+	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE; /* default */
 
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
@@ -169,32 +167,47 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 		printk(KERN_WARNING "Container driver received %s event\n",
 		       (type == ACPI_NOTIFY_BUS_CHECK) ?
 		       "ACPI_NOTIFY_BUS_CHECK" : "ACPI_NOTIFY_DEVICE_CHECK");
+
+		present = is_device_present(handle);
 		status = acpi_bus_get_device(handle, &device);
-		if (present) {
-			if (ACPI_FAILURE(status) || !device) {
-				result = container_device_add(&device, handle);
-				if (!result)
-					kobject_uevent(&device->dev.kobj,
-						       KOBJ_ONLINE);
-				else
-					printk(KERN_WARNING
-					       "Failed to add container\n");
-			}
-		} else {
+		if (!present) {
 			if (ACPI_SUCCESS(status)) {
 				/* device exist and this is a remove request */
+				device->flags.eject_pending = 1;
 				kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
+				return;
 			}
+			break;
+		}
+
+		if (!ACPI_FAILURE(status) || device)
+			break;
+
+		result = container_device_add(&device, handle);
+		if (result) {
+			printk(KERN_WARNING "Failed to add container\n");
+			break;
 		}
+
+		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
+		ost_code = ACPI_OST_SC_SUCCESS;
 		break;
+
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		if (!acpi_bus_get_device(handle, &device) && device) {
+			device->flags.eject_pending = 1;
 			kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
+			return;
 		}
 		break;
+
 	default:
-		break;
+		/* non-hotplug event; possibly handled by other handler */
+		return;
 	}
+
+	/* Inform firmware that the hotplug operation has completed */
+	(void) acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 	return;
 }
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 5faf6c21257d..45cd03b4630e 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -29,6 +29,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/acpi.h>
 #include <acpi/acpi_bus.h>

commit 2263576cfc6e8f6ab038126c3254404b9fcb1c33
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Nov 13 10:06:08 2009 +0800

    ACPICA: Add post-order callback to acpi_walk_namespace
    
    The existing interface only has a pre-order callback. This change
    adds an additional parameter for a post-order callback which will
    be more useful for bus scans. ACPICA BZ 779.
    
    Also update the external calls to acpi_walk_namespace.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=779
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 642bb305cb65..5faf6c21257d 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -258,7 +258,7 @@ static int __init acpi_container_init(void)
 	acpi_walk_namespace(ACPI_TYPE_DEVICE,
 			    ACPI_ROOT_OBJECT,
 			    ACPI_UINT32_MAX,
-			    container_walk_namespace_cb, &action, NULL);
+			    container_walk_namespace_cb, NULL, &action, NULL);
 
 	return (0);
 }
@@ -271,7 +271,7 @@ static void __exit acpi_container_exit(void)
 	acpi_walk_namespace(ACPI_TYPE_DEVICE,
 			    ACPI_ROOT_OBJECT,
 			    ACPI_UINT32_MAX,
-			    container_walk_namespace_cb, &action, NULL);
+			    container_walk_namespace_cb, NULL, &action, NULL);
 
 	acpi_bus_unregister_driver(&acpi_container_driver);
 

commit 985f38781d19101aba121df423f92c87b208c6df
Merge: d093d70a81b0 c9766237afa9
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 01:45:22 2009 -0400

    Merge branch 'acpica' into release

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index fe0cdf83641a..5f2c3c00a315 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -35,6 +35,8 @@
 #include <acpi/acpi_drivers.h>
 #include <acpi/container.h>
 
+#define PREFIX "ACPI: "
+
 #define ACPI_CONTAINER_DEVICE_NAME	"ACPI container device"
 #define ACPI_CONTAINER_CLASS		"container"
 

commit 15b8dd53f5ffaf8e2d9095c423f713423f576c0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:39:29 2009 +0800

    ACPICA: Major update for acpi_get_object_info external interface
    
    Completed a major update for the acpi_get_object_info external interface.
    Changes include:
     - Support for variable, unlimited length HID, UID, and CID strings
     - Support Processor objects the same as Devices (HID,UID,CID,ADR,STA, etc.)
     - Call the _SxW power methods on behalf of a device object
     - Determine if a device is a PCI root bridge
     - Change the ACPI_BUFFER parameter to ACPI_DEVICE_INFO.
    These changes will require an update to all callers of this interface.
    See the ACPICA Programmer Reference for details.
    
    Also, update all invocations of acpi_get_object_info interface
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index fe0cdf83641a..2aee8c24dc56 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -200,20 +200,17 @@ container_walk_namespace_cb(acpi_handle handle,
 			    u32 lvl, void *context, void **rv)
 {
 	char *hid = NULL;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	struct acpi_device_info *info;
 	acpi_status status;
 	int *action = context;
 
-
-	status = acpi_get_object_info(handle, &buffer);
-	if (ACPI_FAILURE(status) || !buffer.pointer) {
+	status = acpi_get_object_info(handle, &info);
+	if (ACPI_FAILURE(status)) {
 		return AE_OK;
 	}
 
-	info = buffer.pointer;
 	if (info->valid & ACPI_VALID_HID)
-		hid = info->hardware_id.value;
+		hid = info->hardware_id.string;
 
 	if (hid == NULL) {
 		goto end;
@@ -240,7 +237,7 @@ container_walk_namespace_cb(acpi_handle handle,
 	}
 
       end:
-	kfree(buffer.pointer);
+	kfree(info);
 
 	return AE_OK;
 }

commit 4d9391557b68475b118ec7626607c37b14ae8c16
Author: Frank Seidel <frank@f-seidel.de>
Date:   Wed Feb 4 17:03:07 2009 +0100

    ACPI: add missing KERN_* constants to printks
    
    According to kerneljanitors todo list all printk calls (beginning
    a new line) should have an according KERN_* constant.
    Those are the missing peaces here for the acpi subsystem.
    
    Signed-off-by: Frank Seidel <frank@f-seidel.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 17020c12623c..fe0cdf83641a 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -163,7 +163,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 	case ACPI_NOTIFY_BUS_CHECK:
 		/* Fall through */
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		printk("Container driver received %s event\n",
+		printk(KERN_WARNING "Container driver received %s event\n",
 		       (type == ACPI_NOTIFY_BUS_CHECK) ?
 		       "ACPI_NOTIFY_BUS_CHECK" : "ACPI_NOTIFY_DEVICE_CHECK");
 		status = acpi_bus_get_device(handle, &device);
@@ -174,7 +174,8 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 					kobject_uevent(&device->dev.kobj,
 						       KOBJ_ONLINE);
 				else
-					printk("Failed to add container\n");
+					printk(KERN_WARNING
+					       "Failed to add container\n");
 			}
 		} else {
 			if (ACPI_SUCCESS(status)) {

commit 89595b8f2850a080d290bf778ec933ea1d99f78e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Nov 7 16:57:45 2008 -0700

    ACPI: consolidate ACPI_*_COMPONENT definitions in acpi_drivers.h
    
    Move all the component definitions for drivers to a single shared place,
    include/acpi/acpi_drivers.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 134818b265a9..17020c12623c 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -41,7 +41,6 @@
 #define INSTALL_NOTIFY_HANDLER		1
 #define UNINSTALL_NOTIFY_HANDLER	2
 
-#define ACPI_CONTAINER_COMPONENT	0x01000000
 #define _COMPONENT			ACPI_CONTAINER_COMPONENT
 ACPI_MODULE_NAME("container");
 

commit 7674416db4ee3d43813dddb650364ca994755256
Merge: 0ca9413c234a 27663c5855b1
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:33:29 2008 -0400

    Merge branch 'ull' into test
    
    Conflicts:
            drivers/acpi/bay.c
            drivers/acpi/dock.c
            drivers/ata/libata-acpi.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 27663c5855b10af9ec67bc7dfba001426ba21222
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Oct 10 02:22:59 2008 -0400

    ACPI: Change acpi_evaluate_integer to support 64-bit on 32-bit kernels
    
    As of version 2.0, ACPI can return 64-bit integers.  The current
    acpi_evaluate_integer only supports 64-bit integers on 64-bit platforms.
    Change the argument to take a pointer to an acpi_integer so we support
    64-bit integers on all platforms.
    
    lenb: replaced use of "acpi_integer" with "unsigned long long"
    lenb: fixed bug in acpi_thermal_trips_update()
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 3c25ec7a1871..cfa5fd68168a 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -76,7 +76,7 @@ static int is_device_present(acpi_handle handle)
 {
 	acpi_handle temp;
 	acpi_status status;
-	unsigned long sta;
+	unsigned long long sta;
 
 
 	status = acpi_get_handle(handle, "_STA", &temp);

commit db89b4f0dbab837d0f3de2c3e9427a8d5393afa3
Author: Pavel Machek <pavel@suse.cz>
Date:   Mon Sep 22 14:37:34 2008 -0700

    ACPI: catch calls of acpi_driver_data on pointer of wrong type
    
    Catch attempts to use of acpi_driver_data on pointers of wrong type.
    
    akpm: rewritten to use proper C typechecking and remove the
    "function"-used-as-lvalue thing.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 3c25ec7a1871..03ea8478e393 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -108,7 +108,7 @@ static int acpi_container_add(struct acpi_device *device)
 	container->handle = device->handle;
 	strcpy(acpi_device_name(device), ACPI_CONTAINER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_CONTAINER_CLASS);
-	acpi_driver_data(device) = container;
+	device->driver_data = container;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device <%s> bid <%s>\n",
 			  acpi_device_name(device), acpi_device_bid(device)));

commit 1ba90e3a87c46500623afdc3898573e4a5ebb21b
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 23 14:44:41 2007 +0200

    ACPI: autoload modules - Create __mod_acpi_device_table symbol for all ACPI drivers
    
    modpost is going to use these to create e.g. acpi:ACPI0001
    in modules.alias.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 0dd3bf7c0ed1..3c25ec7a1871 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -52,10 +52,18 @@ MODULE_LICENSE("GPL");
 static int acpi_container_add(struct acpi_device *device);
 static int acpi_container_remove(struct acpi_device *device, int type);
 
+static const struct acpi_device_id container_device_ids[] = {
+	{"ACPI0004", 0},
+	{"PNP0A05", 0},
+	{"PNP0A06", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, container_device_ids);
+
 static struct acpi_driver acpi_container_driver = {
 	.name = "container",
 	.class = ACPI_CONTAINER_CLASS,
-	.ids = "ACPI0004,PNP0A05,PNP0A06",
+	.ids = container_device_ids,
 	.ops = {
 		.add = acpi_container_add,
 		.remove = acpi_container_remove,

commit a0bd4ac498acfe60f7533d15ba60d5efdd4e9ca5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Apr 25 14:17:39 2007 -0400

    ACPI: Remove duplicate definitions for _STA bits
    
    No need to duplicate the existing definitions in include/acpi/actypes.h.
    
    syntax only -- no functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 0930d9413dfa..0dd3bf7c0ed1 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -49,8 +49,6 @@ MODULE_AUTHOR("Anil S Keshavamurthy");
 MODULE_DESCRIPTION("ACPI container driver");
 MODULE_LICENSE("GPL");
 
-#define ACPI_STA_PRESENT		(0x00000001)
-
 static int acpi_container_add(struct acpi_device *device);
 static int acpi_container_remove(struct acpi_device *device, int type);
 
@@ -75,13 +73,13 @@ static int is_device_present(acpi_handle handle)
 
 	status = acpi_get_handle(handle, "_STA", &temp);
 	if (ACPI_FAILURE(status))
-		return 1;	/* _STA not found, assmue device present */
+		return 1;	/* _STA not found, assume device present */
 
 	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
 	if (ACPI_FAILURE(status))
 		return 0;	/* Firmware error */
 
-	return ((sta & ACPI_STA_PRESENT) == ACPI_STA_PRESENT);
+	return ((sta & ACPI_STA_DEVICE_PRESENT) == ACPI_STA_DEVICE_PRESENT);
 }
 
 /*******************************************************************/

commit 7cda93e008e1a477970adbf82dba81a5d4f0ae40
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:50:02 2007 -0500

    ACPI: delete extra #defines in /drivers/acpi/ drivers
    
    Cosmetic only.
    
    Except in a single case, #define ACPI_*_DRIVER_NAME
    were invoked 0 or 1 times.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 0e36062dc1f5..0930d9413dfa 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -35,7 +35,6 @@
 #include <acpi/acpi_drivers.h>
 #include <acpi/container.h>
 
-#define ACPI_CONTAINER_DRIVER_NAME	"ACPI container driver"
 #define ACPI_CONTAINER_DEVICE_NAME	"ACPI container device"
 #define ACPI_CONTAINER_CLASS		"container"
 
@@ -47,7 +46,7 @@
 ACPI_MODULE_NAME("container");
 
 MODULE_AUTHOR("Anil S Keshavamurthy");
-MODULE_DESCRIPTION(ACPI_CONTAINER_DRIVER_NAME);
+MODULE_DESCRIPTION("ACPI container driver");
 MODULE_LICENSE("GPL");
 
 #define ACPI_STA_PRESENT		(0x00000001)

commit c2b6705b75d9c7aff98a4602a32230639e10891c
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:33:40 2007 -0500

    ACPI: fix acpi_driver.name usage
    
    It was erroneously used as a description rather than a name.
    
    ie. turn this:
    
    lenb@se7525gp2:/sys> ls bus/acpi/drivers
    ACPI AC Adapter Driver  ACPI Embedded Controller Driver  ACPI Power Resource Driver
    ACPI Battery Driver     ACPI Fan Driver                  ACPI Processor Driver
    ACPI Button Driver      ACPI PCI Interrupt Link Driver   ACPI Thermal Zone Driver
    ACPI container driver   ACPI PCI Root Bridge Driver      hpet
    
    into this:
    
    lenb@se7525gp2:~> ls /sys/bus/acpi/drivers
    ac  battery  button  container  ec  fan  hpet  pci_link  pci_root  power  processor  thermal
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index f3e59af419e5..0e36062dc1f5 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -56,7 +56,7 @@ static int acpi_container_add(struct acpi_device *device);
 static int acpi_container_remove(struct acpi_device *device, int type);
 
 static struct acpi_driver acpi_container_driver = {
-	.name = ACPI_CONTAINER_DRIVER_NAME,
+	.name = "container",
 	.class = ACPI_CONTAINER_CLASS,
 	.ids = "ACPI0004,PNP0A05,PNP0A06",
 	.ops = {

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 69a68fd394cf..f3e59af419e5 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -44,9 +44,9 @@
 
 #define ACPI_CONTAINER_COMPONENT	0x01000000
 #define _COMPONENT			ACPI_CONTAINER_COMPONENT
-ACPI_MODULE_NAME("acpi_container")
+ACPI_MODULE_NAME("container");
 
-    MODULE_AUTHOR("Anil S Keshavamurthy");
+MODULE_AUTHOR("Anil S Keshavamurthy");
 MODULE_DESCRIPTION(ACPI_CONTAINER_DRIVER_NAME);
 MODULE_LICENSE("GPL");
 

commit 975a8e3ed2b9eab9f062a1e0ba7fe180e15204e1
Merge: 1fcb71b84b05 bfd80223d73f
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 3 01:14:35 2007 -0500

    Pull sysfs into test branch
    
    Conflicts:
    
            Documentation/feature-removal-schedule.txt
            include/acpi/acpi_drivers.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index a15381789462..0a1863ec91f3 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -96,11 +96,10 @@ static int acpi_container_add(struct acpi_device *device)
 		return -EINVAL;
 	}
 
-	container = kmalloc(sizeof(struct acpi_container), GFP_KERNEL);
+	container = kzalloc(sizeof(struct acpi_container), GFP_KERNEL);
 	if (!container)
 		return -ENOMEM;
 
-	memset(container, 0, sizeof(struct acpi_container));
 	container->handle = device->handle;
 	strcpy(acpi_device_name(device), ACPI_CONTAINER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_CONTAINER_CLASS);

commit f883d9db008deb20d4969c26475100cec2b7f6f8
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:38 2006 +0800

    ACPI: convert to sysfs framework
    
    Setup new sysfs framework
    
    1.      Remove /sys/firmware/acpi
    2.      Add ACPI device in device tree.
    
    File "eject" for every device that has _EJ0 method is moved from
    /sys/firmware to /sys/devices.
    Operation on this file is exactly the same as before.
    i.e. echo 1 to "eject" will cause hot removal of this device.
    Corresponding changes should be made in userspace for hot removal.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui<rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 871aa520ece7..914f56ae4b44 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -168,7 +168,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 			if (ACPI_FAILURE(status) || !device) {
 				result = container_device_add(&device, handle);
 				if (!result)
-					kobject_uevent(&device->kobj,
+					kobject_uevent(&device->dev.kobj,
 						       KOBJ_ONLINE);
 				else
 					printk("Failed to add container\n");
@@ -176,13 +176,13 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 		} else {
 			if (ACPI_SUCCESS(status)) {
 				/* device exist and this is a remove request */
-				kobject_uevent(&device->kobj, KOBJ_OFFLINE);
+				kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
 			}
 		}
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		if (!acpi_bus_get_device(handle, &device) && device) {
-			kobject_uevent(&device->kobj, KOBJ_OFFLINE);
+			kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
 		}
 		break;
 	default:

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 871aa520ece7..a15381789462 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -117,7 +117,7 @@ static int acpi_container_remove(struct acpi_device *device, int type)
 	acpi_status status = AE_OK;
 	struct acpi_container *pc = NULL;
 
-	pc = (struct acpi_container *)acpi_driver_data(device);
+	pc = acpi_driver_data(device);
 	kfree(pc);
 	return status;
 }

commit 02438d8771ae6a4b215938959827692026380bf9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 30 03:19:10 2006 -0400

    ACPI: delete acpi_os_free(), use kfree() directly
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 7f7e41d40a3b..871aa520ece7 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -236,7 +236,7 @@ container_walk_namespace_cb(acpi_handle handle,
 	}
 
       end:
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 
 	return AE_OK;
 }

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index e2fcef4a83df..7f7e41d40a3b 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -73,17 +73,16 @@ static int is_device_present(acpi_handle handle)
 	acpi_status status;
 	unsigned long sta;
 
-	ACPI_FUNCTION_TRACE("is_device_present");
 
 	status = acpi_get_handle(handle, "_STA", &temp);
 	if (ACPI_FAILURE(status))
-		return_VALUE(1);	/* _STA not found, assmue device present */
+		return 1;	/* _STA not found, assmue device present */
 
 	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
 	if (ACPI_FAILURE(status))
-		return_VALUE(0);	/* Firmware error */
+		return 0;	/* Firmware error */
 
-	return_VALUE((sta & ACPI_STA_PRESENT) == ACPI_STA_PRESENT);
+	return ((sta & ACPI_STA_PRESENT) == ACPI_STA_PRESENT);
 }
 
 /*******************************************************************/
@@ -91,16 +90,15 @@ static int acpi_container_add(struct acpi_device *device)
 {
 	struct acpi_container *container;
 
-	ACPI_FUNCTION_TRACE("acpi_container_add");
 
 	if (!device) {
 		printk(KERN_ERR PREFIX "device is NULL\n");
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 	}
 
 	container = kmalloc(sizeof(struct acpi_container), GFP_KERNEL);
 	if (!container)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 
 	memset(container, 0, sizeof(struct acpi_container));
 	container->handle = device->handle;
@@ -111,7 +109,7 @@ static int acpi_container_add(struct acpi_device *device)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device <%s> bid <%s>\n",
 			  acpi_device_name(device), acpi_device_bid(device)));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_container_remove(struct acpi_device *device, int type)
@@ -130,23 +128,22 @@ static int container_device_add(struct acpi_device **device, acpi_handle handle)
 	struct acpi_device *pdev;
 	int result;
 
-	ACPI_FUNCTION_TRACE("container_device_add");
 
 	if (acpi_get_parent(handle, &phandle)) {
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	if (acpi_bus_get_device(phandle, &pdev)) {
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	if (acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_DEVICE)) {
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	result = acpi_bus_start(*device);
 
-	return_VALUE(result);
+	return result;
 }
 
 static void container_notify_cb(acpi_handle handle, u32 type, void *context)
@@ -156,7 +153,6 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 	int present;
 	acpi_status status;
 
-	ACPI_FUNCTION_TRACE("container_notify_cb");
 
 	present = is_device_present(handle);
 
@@ -192,7 +188,7 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 	default:
 		break;
 	}
-	return_VOID;
+	return;
 }
 
 static acpi_status
@@ -205,11 +201,10 @@ container_walk_namespace_cb(acpi_handle handle,
 	acpi_status status;
 	int *action = context;
 
-	ACPI_FUNCTION_TRACE("container_walk_namespace_cb");
 
 	status = acpi_get_object_info(handle, &buffer);
 	if (ACPI_FAILURE(status) || !buffer.pointer) {
-		return_ACPI_STATUS(AE_OK);
+		return AE_OK;
 	}
 
 	info = buffer.pointer;
@@ -243,7 +238,7 @@ container_walk_namespace_cb(acpi_handle handle,
       end:
 	acpi_os_free(buffer.pointer);
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 
 static int __init acpi_container_init(void)
@@ -269,7 +264,6 @@ static void __exit acpi_container_exit(void)
 {
 	int action = UNINSTALL_NOTIFY_HANDLER;
 
-	ACPI_FUNCTION_TRACE("acpi_container_exit");
 
 	acpi_walk_namespace(ACPI_TYPE_DEVICE,
 			    ACPI_ROOT_OBJECT,
@@ -278,7 +272,7 @@ static void __exit acpi_container_exit(void)
 
 	acpi_bus_unregister_driver(&acpi_container_driver);
 
-	return_VOID;
+	return;
 }
 
 module_init(acpi_container_init);

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 53625fc3d715..e2fcef4a83df 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -94,7 +94,7 @@ static int acpi_container_add(struct acpi_device *device)
 	ACPI_FUNCTION_TRACE("acpi_container_add");
 
 	if (!device) {
-		ACPI_ERROR((AE_INFO, "device is NULL"));
+		printk(KERN_ERR PREFIX "device is NULL\n");
 		return_VALUE(-EINVAL);
 	}
 

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index b69a8cad82b7..53625fc3d715 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -94,7 +94,7 @@ static int acpi_container_add(struct acpi_device *device)
 	ACPI_FUNCTION_TRACE("acpi_container_add");
 
 	if (!device) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "device is NULL\n"));
+		ACPI_ERROR((AE_INFO, "device is NULL"));
 		return_VALUE(-EINVAL);
 	}
 

commit 312c004d36ce6c739512bac83b452f4c20ab1f62
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Wed Nov 16 09:00:00 2005 +0100

    [PATCH] driver core: replace "hotplug" by "uevent"
    
    Leave the overloaded "hotplug" word to susbsystems which are handling
    real devices. The driver core does not "plug" anything, it just exports
    the state to userspace and generates events.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 27ec12c1fab0..b69a8cad82b7 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -172,21 +172,21 @@ static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 			if (ACPI_FAILURE(status) || !device) {
 				result = container_device_add(&device, handle);
 				if (!result)
-					kobject_hotplug(&device->kobj,
-							KOBJ_ONLINE);
+					kobject_uevent(&device->kobj,
+						       KOBJ_ONLINE);
 				else
 					printk("Failed to add container\n");
 			}
 		} else {
 			if (ACPI_SUCCESS(status)) {
 				/* device exist and this is a remove request */
-				kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+				kobject_uevent(&device->kobj, KOBJ_OFFLINE);
 			}
 		}
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		if (!acpi_bus_get_device(handle, &device) && device) {
-			kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+			kobject_uevent(&device->kobj, KOBJ_OFFLINE);
 		}
 		break;
 	default:

commit 6044ec8882c726e325017bd948aa0cd94ad33abc
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:32 2005 -0800

    [PATCH] kfree cleanup: misc remaining drivers
    
    This is the remaining misc drivers/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in misc files in
    drivers/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Acked-by: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: "Antonino A. Daplas" <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 10dd695a1dd9..27ec12c1fab0 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -118,11 +118,9 @@ static int acpi_container_remove(struct acpi_device *device, int type)
 {
 	acpi_status status = AE_OK;
 	struct acpi_container *pc = NULL;
-	pc = (struct acpi_container *)acpi_driver_data(device);
-
-	if (pc)
-		kfree(pc);
 
+	pc = (struct acpi_container *)acpi_driver_data(device);
+	kfree(pc);
 	return status;
 }
 

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 97013ddfa202..10dd695a1dd9 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -44,9 +44,9 @@
 
 #define ACPI_CONTAINER_COMPONENT	0x01000000
 #define _COMPONENT			ACPI_CONTAINER_COMPONENT
-ACPI_MODULE_NAME			("acpi_container")
+ACPI_MODULE_NAME("acpi_container")
 
-MODULE_AUTHOR("Anil S Keshavamurthy");
+    MODULE_AUTHOR("Anil S Keshavamurthy");
 MODULE_DESCRIPTION(ACPI_CONTAINER_DRIVER_NAME);
 MODULE_LICENSE("GPL");
 
@@ -56,41 +56,38 @@ static int acpi_container_add(struct acpi_device *device);
 static int acpi_container_remove(struct acpi_device *device, int type);
 
 static struct acpi_driver acpi_container_driver = {
-	.name =		ACPI_CONTAINER_DRIVER_NAME,
-	.class =	ACPI_CONTAINER_CLASS,
-	.ids =		"ACPI0004,PNP0A05,PNP0A06",
-	.ops =		{
-				.add =		acpi_container_add,
-				.remove =	acpi_container_remove,
-			},
+	.name = ACPI_CONTAINER_DRIVER_NAME,
+	.class = ACPI_CONTAINER_CLASS,
+	.ids = "ACPI0004,PNP0A05,PNP0A06",
+	.ops = {
+		.add = acpi_container_add,
+		.remove = acpi_container_remove,
+		},
 };
 
-
 /*******************************************************************/
 
-static int
-is_device_present(acpi_handle handle)
+static int is_device_present(acpi_handle handle)
 {
-	acpi_handle		temp;
-	acpi_status		status;
-	unsigned long	sta;
+	acpi_handle temp;
+	acpi_status status;
+	unsigned long sta;
 
 	ACPI_FUNCTION_TRACE("is_device_present");
 
 	status = acpi_get_handle(handle, "_STA", &temp);
 	if (ACPI_FAILURE(status))
-		return_VALUE(1); /* _STA not found, assmue device present */
+		return_VALUE(1);	/* _STA not found, assmue device present */
 
 	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
 	if (ACPI_FAILURE(status))
-		return_VALUE(0); /* Firmware error */
+		return_VALUE(0);	/* Firmware error */
 
 	return_VALUE((sta & ACPI_STA_PRESENT) == ACPI_STA_PRESENT);
 }
 
 /*******************************************************************/
-static int
-acpi_container_add(struct acpi_device *device)
+static int acpi_container_add(struct acpi_device *device)
 {
 	struct acpi_container *container;
 
@@ -102,28 +99,26 @@ acpi_container_add(struct acpi_device *device)
 	}
 
 	container = kmalloc(sizeof(struct acpi_container), GFP_KERNEL);
-	if(!container)
+	if (!container)
 		return_VALUE(-ENOMEM);
-	
+
 	memset(container, 0, sizeof(struct acpi_container));
 	container->handle = device->handle;
 	strcpy(acpi_device_name(device), ACPI_CONTAINER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_CONTAINER_CLASS);
 	acpi_driver_data(device) = container;
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device <%s> bid <%s>\n",	\
-		acpi_device_name(device), acpi_device_bid(device)));
-
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device <%s> bid <%s>\n",
+			  acpi_device_name(device), acpi_device_bid(device)));
 
 	return_VALUE(0);
 }
 
-static int
-acpi_container_remove(struct acpi_device *device, int type)
+static int acpi_container_remove(struct acpi_device *device, int type)
 {
-	acpi_status		status = AE_OK;
-	struct acpi_container	*pc = NULL;
-	pc = (struct acpi_container*) acpi_driver_data(device);
+	acpi_status status = AE_OK;
+	struct acpi_container *pc = NULL;
+	pc = (struct acpi_container *)acpi_driver_data(device);
 
 	if (pc)
 		kfree(pc);
@@ -131,9 +126,7 @@ acpi_container_remove(struct acpi_device *device, int type)
 	return status;
 }
 
-
-static int
-container_device_add(struct acpi_device **device, acpi_handle handle)
+static int container_device_add(struct acpi_device **device, acpi_handle handle)
 {
 	acpi_handle phandle;
 	struct acpi_device *pdev;
@@ -158,10 +151,9 @@ container_device_add(struct acpi_device **device, acpi_handle handle)
 	return_VALUE(result);
 }
 
-static void
-container_notify_cb(acpi_handle handle, u32 type, void *context)
+static void container_notify_cb(acpi_handle handle, u32 type, void *context)
 {
-	struct acpi_device		*device = NULL;
+	struct acpi_device *device = NULL;
 	int result;
 	int present;
 	acpi_status status;
@@ -169,14 +161,14 @@ container_notify_cb(acpi_handle handle, u32 type, void *context)
 	ACPI_FUNCTION_TRACE("container_notify_cb");
 
 	present = is_device_present(handle);
-	
+
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		/* Fall through */
 	case ACPI_NOTIFY_DEVICE_CHECK:
 		printk("Container driver received %s event\n",
-			(type == ACPI_NOTIFY_BUS_CHECK)?
-			"ACPI_NOTIFY_BUS_CHECK":"ACPI_NOTIFY_DEVICE_CHECK");
+		       (type == ACPI_NOTIFY_BUS_CHECK) ?
+		       "ACPI_NOTIFY_BUS_CHECK" : "ACPI_NOTIFY_DEVICE_CHECK");
 		status = acpi_bus_get_device(handle, &device);
 		if (present) {
 			if (ACPI_FAILURE(status) || !device) {
@@ -207,15 +199,13 @@ container_notify_cb(acpi_handle handle, u32 type, void *context)
 
 static acpi_status
 container_walk_namespace_cb(acpi_handle handle,
-	u32 lvl,
-	void *context,
-	void **rv)
+			    u32 lvl, void *context, void **rv)
 {
-	char 				*hid = NULL;
-	struct acpi_buffer 		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	struct acpi_device_info 	*info;
-	acpi_status 			status;
-	int 				*action = context;
+	char *hid = NULL;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_device_info *info;
+	acpi_status status;
+	int *action = context;
 
 	ACPI_FUNCTION_TRACE("container_walk_namespace_cb");
 
@@ -233,66 +223,60 @@ container_walk_namespace_cb(acpi_handle handle,
 	}
 
 	if (strcmp(hid, "ACPI0004") && strcmp(hid, "PNP0A05") &&
-			strcmp(hid, "PNP0A06")) {
+	    strcmp(hid, "PNP0A06")) {
 		goto end;
 	}
 
-	switch(*action) {
+	switch (*action) {
 	case INSTALL_NOTIFY_HANDLER:
 		acpi_install_notify_handler(handle,
-			ACPI_SYSTEM_NOTIFY,
-			container_notify_cb,
-			NULL);
+					    ACPI_SYSTEM_NOTIFY,
+					    container_notify_cb, NULL);
 		break;
 	case UNINSTALL_NOTIFY_HANDLER:
 		acpi_remove_notify_handler(handle,
-			ACPI_SYSTEM_NOTIFY,
-			container_notify_cb);
+					   ACPI_SYSTEM_NOTIFY,
+					   container_notify_cb);
 		break;
 	default:
 		break;
 	}
 
-end:
+      end:
 	acpi_os_free(buffer.pointer);
 
 	return_ACPI_STATUS(AE_OK);
 }
 
-
-static int __init
-acpi_container_init(void)
+static int __init acpi_container_init(void)
 {
-	int	result = 0;
-	int	action = INSTALL_NOTIFY_HANDLER;
+	int result = 0;
+	int action = INSTALL_NOTIFY_HANDLER;
 
 	result = acpi_bus_register_driver(&acpi_container_driver);
 	if (result < 0) {
-		return(result);
+		return (result);
 	}
 
 	/* register notify handler to every container device */
 	acpi_walk_namespace(ACPI_TYPE_DEVICE,
-				     ACPI_ROOT_OBJECT,
-				     ACPI_UINT32_MAX,
-				     container_walk_namespace_cb,
-				     &action, NULL);
+			    ACPI_ROOT_OBJECT,
+			    ACPI_UINT32_MAX,
+			    container_walk_namespace_cb, &action, NULL);
 
-	return(0);
+	return (0);
 }
 
-static void __exit
-acpi_container_exit(void)
+static void __exit acpi_container_exit(void)
 {
-	int			action = UNINSTALL_NOTIFY_HANDLER;
+	int action = UNINSTALL_NOTIFY_HANDLER;
 
 	ACPI_FUNCTION_TRACE("acpi_container_exit");
 
 	acpi_walk_namespace(ACPI_TYPE_DEVICE,
-				     ACPI_ROOT_OBJECT,
-				     ACPI_UINT32_MAX,
-				     container_walk_namespace_cb,
-				     &action, NULL);
+			    ACPI_ROOT_OBJECT,
+			    ACPI_UINT32_MAX,
+			    container_walk_namespace_cb, &action, NULL);
 
 	acpi_bus_unregister_driver(&acpi_container_driver);
 

commit 3fb02738b0fd36f47710a2bf207129efd2f5daa2
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:52 2005 -0700

    [PATCH] acpi bridge hotadd: Allow ACPI .add and .start operations to be done independently
    
    Create new interfaces to recursively add an acpi namespace object to the acpi
    device list, and recursively start the namespace object.  This is needed for
    ACPI based hotplug of a root bridge hierarchy where the add operation must be
    performed first and the start operation must be performed separately after the
    hot-plugged devices have been properly configured.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index 5a0adbf8bc04..97013ddfa202 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -153,7 +153,7 @@ container_device_add(struct acpi_device **device, acpi_handle handle)
 		return_VALUE(-ENODEV);
 	}
 
-	result = acpi_bus_scan(*device);
+	result = acpi_bus_start(*device);
 
 	return_VALUE(result);
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
new file mode 100644
index 000000000000..5a0adbf8bc04
--- /dev/null
+++ b/drivers/acpi/container.c
@@ -0,0 +1,303 @@
+/*
+ * acpi_container.c  - ACPI Generic Container Driver
+ * ($Revision: )
+ *
+ * Copyright (C) 2004 Anil S Keshavamurthy (anil.s.keshavamurthy@intel.com)
+ * Copyright (C) 2004 Keiichiro Tokunaga (tokunaga.keiich@jp.fujitsu.com)
+ * Copyright (C) 2004 Motoyuki Ito (motoyuki@soft.fujitsu.com)
+ * Copyright (C) 2004 Intel Corp.
+ * Copyright (C) 2004 FUJITSU LIMITED
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/container.h>
+
+#define ACPI_CONTAINER_DRIVER_NAME	"ACPI container driver"
+#define ACPI_CONTAINER_DEVICE_NAME	"ACPI container device"
+#define ACPI_CONTAINER_CLASS		"container"
+
+#define INSTALL_NOTIFY_HANDLER		1
+#define UNINSTALL_NOTIFY_HANDLER	2
+
+#define ACPI_CONTAINER_COMPONENT	0x01000000
+#define _COMPONENT			ACPI_CONTAINER_COMPONENT
+ACPI_MODULE_NAME			("acpi_container")
+
+MODULE_AUTHOR("Anil S Keshavamurthy");
+MODULE_DESCRIPTION(ACPI_CONTAINER_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define ACPI_STA_PRESENT		(0x00000001)
+
+static int acpi_container_add(struct acpi_device *device);
+static int acpi_container_remove(struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_container_driver = {
+	.name =		ACPI_CONTAINER_DRIVER_NAME,
+	.class =	ACPI_CONTAINER_CLASS,
+	.ids =		"ACPI0004,PNP0A05,PNP0A06",
+	.ops =		{
+				.add =		acpi_container_add,
+				.remove =	acpi_container_remove,
+			},
+};
+
+
+/*******************************************************************/
+
+static int
+is_device_present(acpi_handle handle)
+{
+	acpi_handle		temp;
+	acpi_status		status;
+	unsigned long	sta;
+
+	ACPI_FUNCTION_TRACE("is_device_present");
+
+	status = acpi_get_handle(handle, "_STA", &temp);
+	if (ACPI_FAILURE(status))
+		return_VALUE(1); /* _STA not found, assmue device present */
+
+	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status))
+		return_VALUE(0); /* Firmware error */
+
+	return_VALUE((sta & ACPI_STA_PRESENT) == ACPI_STA_PRESENT);
+}
+
+/*******************************************************************/
+static int
+acpi_container_add(struct acpi_device *device)
+{
+	struct acpi_container *container;
+
+	ACPI_FUNCTION_TRACE("acpi_container_add");
+
+	if (!device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "device is NULL\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	container = kmalloc(sizeof(struct acpi_container), GFP_KERNEL);
+	if(!container)
+		return_VALUE(-ENOMEM);
+	
+	memset(container, 0, sizeof(struct acpi_container));
+	container->handle = device->handle;
+	strcpy(acpi_device_name(device), ACPI_CONTAINER_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_CONTAINER_CLASS);
+	acpi_driver_data(device) = container;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device <%s> bid <%s>\n",	\
+		acpi_device_name(device), acpi_device_bid(device)));
+
+
+	return_VALUE(0);
+}
+
+static int
+acpi_container_remove(struct acpi_device *device, int type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_container	*pc = NULL;
+	pc = (struct acpi_container*) acpi_driver_data(device);
+
+	if (pc)
+		kfree(pc);
+
+	return status;
+}
+
+
+static int
+container_device_add(struct acpi_device **device, acpi_handle handle)
+{
+	acpi_handle phandle;
+	struct acpi_device *pdev;
+	int result;
+
+	ACPI_FUNCTION_TRACE("container_device_add");
+
+	if (acpi_get_parent(handle, &phandle)) {
+		return_VALUE(-ENODEV);
+	}
+
+	if (acpi_bus_get_device(phandle, &pdev)) {
+		return_VALUE(-ENODEV);
+	}
+
+	if (acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_DEVICE)) {
+		return_VALUE(-ENODEV);
+	}
+
+	result = acpi_bus_scan(*device);
+
+	return_VALUE(result);
+}
+
+static void
+container_notify_cb(acpi_handle handle, u32 type, void *context)
+{
+	struct acpi_device		*device = NULL;
+	int result;
+	int present;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE("container_notify_cb");
+
+	present = is_device_present(handle);
+	
+	switch (type) {
+	case ACPI_NOTIFY_BUS_CHECK:
+		/* Fall through */
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		printk("Container driver received %s event\n",
+			(type == ACPI_NOTIFY_BUS_CHECK)?
+			"ACPI_NOTIFY_BUS_CHECK":"ACPI_NOTIFY_DEVICE_CHECK");
+		status = acpi_bus_get_device(handle, &device);
+		if (present) {
+			if (ACPI_FAILURE(status) || !device) {
+				result = container_device_add(&device, handle);
+				if (!result)
+					kobject_hotplug(&device->kobj,
+							KOBJ_ONLINE);
+				else
+					printk("Failed to add container\n");
+			}
+		} else {
+			if (ACPI_SUCCESS(status)) {
+				/* device exist and this is a remove request */
+				kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+			}
+		}
+		break;
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		if (!acpi_bus_get_device(handle, &device) && device) {
+			kobject_hotplug(&device->kobj, KOBJ_OFFLINE);
+		}
+		break;
+	default:
+		break;
+	}
+	return_VOID;
+}
+
+static acpi_status
+container_walk_namespace_cb(acpi_handle handle,
+	u32 lvl,
+	void *context,
+	void **rv)
+{
+	char 				*hid = NULL;
+	struct acpi_buffer 		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_device_info 	*info;
+	acpi_status 			status;
+	int 				*action = context;
+
+	ACPI_FUNCTION_TRACE("container_walk_namespace_cb");
+
+	status = acpi_get_object_info(handle, &buffer);
+	if (ACPI_FAILURE(status) || !buffer.pointer) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	info = buffer.pointer;
+	if (info->valid & ACPI_VALID_HID)
+		hid = info->hardware_id.value;
+
+	if (hid == NULL) {
+		goto end;
+	}
+
+	if (strcmp(hid, "ACPI0004") && strcmp(hid, "PNP0A05") &&
+			strcmp(hid, "PNP0A06")) {
+		goto end;
+	}
+
+	switch(*action) {
+	case INSTALL_NOTIFY_HANDLER:
+		acpi_install_notify_handler(handle,
+			ACPI_SYSTEM_NOTIFY,
+			container_notify_cb,
+			NULL);
+		break;
+	case UNINSTALL_NOTIFY_HANDLER:
+		acpi_remove_notify_handler(handle,
+			ACPI_SYSTEM_NOTIFY,
+			container_notify_cb);
+		break;
+	default:
+		break;
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+static int __init
+acpi_container_init(void)
+{
+	int	result = 0;
+	int	action = INSTALL_NOTIFY_HANDLER;
+
+	result = acpi_bus_register_driver(&acpi_container_driver);
+	if (result < 0) {
+		return(result);
+	}
+
+	/* register notify handler to every container device */
+	acpi_walk_namespace(ACPI_TYPE_DEVICE,
+				     ACPI_ROOT_OBJECT,
+				     ACPI_UINT32_MAX,
+				     container_walk_namespace_cb,
+				     &action, NULL);
+
+	return(0);
+}
+
+static void __exit
+acpi_container_exit(void)
+{
+	int			action = UNINSTALL_NOTIFY_HANDLER;
+
+	ACPI_FUNCTION_TRACE("acpi_container_exit");
+
+	acpi_walk_namespace(ACPI_TYPE_DEVICE,
+				     ACPI_ROOT_OBJECT,
+				     ACPI_UINT32_MAX,
+				     container_walk_namespace_cb,
+				     &action, NULL);
+
+	acpi_bus_unregister_driver(&acpi_container_driver);
+
+	return_VOID;
+}
+
+module_init(acpi_container_init);
+module_exit(acpi_container_exit);
