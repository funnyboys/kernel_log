commit 7f49a5cb94e68a0aae4ccd619798daf5a92c0533
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jan 30 22:15:33 2020 -0800

    ACPI: thermal: switch to use <linux/units.h> helpers
    
    This switches the ACPI thermal zone driver to use
    celsius_to_deci_kelvin(), deci_kelvin_to_celsius(), and
    deci_kelvin_to_millicelsius_with_offset() in <linux/units.h> instead of
    helpers in <linux/thermal.h>.
    
    This is preparation for centralizing the kelvin to/from Celsius
    conversion helpers in <linux/units.h>.
    
    Link: http://lkml.kernel.org/r/1576386975-7941-3-git-send-email-akinobu.mita@gmail.com
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Sujith Thomas <sujith.thomas@intel.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Andy Shevchenko <andy@infradead.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Amit Kucheria <amit.kucheria@verdurent.com>
    Cc: Jean Delvare <jdelvare@suse.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Keith Busch <kbusch@kernel.org>
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Sagi Grimberg <sagi@grimberg.me>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Luca Coelho <luciano.coelho@intel.com>
    Cc: Peter Meerwald-Stadler <pmeerw@pmeerw.net>
    Cc: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index d831a61e0010..19067a5e5293 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -27,6 +27,7 @@
 #include <linux/acpi.h>
 #include <linux/workqueue.h>
 #include <linux/uaccess.h>
+#include <linux/units.h>
 
 #define PREFIX "ACPI: "
 
@@ -172,7 +173,7 @@ struct acpi_thermal {
 	struct acpi_handle_list devices;
 	struct thermal_zone_device *thermal_zone;
 	int tz_enabled;
-	int kelvin_offset;
+	int kelvin_offset;	/* in millidegrees */
 	struct work_struct thermal_check_work;
 };
 
@@ -297,7 +298,8 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			if (crt == -1) {
 				tz->trips.critical.flags.valid = 0;
 			} else if (crt > 0) {
-				unsigned long crt_k = CELSIUS_TO_DECI_KELVIN(crt);
+				unsigned long crt_k = celsius_to_deci_kelvin(crt);
+
 				/*
 				 * Allow override critical threshold
 				 */
@@ -333,7 +335,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		if (psv == -1) {
 			status = AE_SUPPORT;
 		} else if (psv > 0) {
-			tmp = CELSIUS_TO_DECI_KELVIN(psv);
+			tmp = celsius_to_deci_kelvin(psv);
 			status = AE_OK;
 		} else {
 			status = acpi_evaluate_integer(tz->device->handle,
@@ -413,7 +415,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 					break;
 				if (i == 1)
 					tz->trips.active[0].temperature =
-						CELSIUS_TO_DECI_KELVIN(act);
+						celsius_to_deci_kelvin(act);
 				else
 					/*
 					 * Don't allow override higher than
@@ -421,9 +423,9 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 					 */
 					tz->trips.active[i - 1].temperature =
 						(tz->trips.active[i - 2].temperature <
-						CELSIUS_TO_DECI_KELVIN(act) ?
+						celsius_to_deci_kelvin(act) ?
 						tz->trips.active[i - 2].temperature :
-						CELSIUS_TO_DECI_KELVIN(act));
+						celsius_to_deci_kelvin(act));
 				break;
 			} else {
 				tz->trips.active[i].temperature = tmp;
@@ -519,7 +521,7 @@ static int thermal_get_temp(struct thermal_zone_device *thermal, int *temp)
 	if (result)
 		return result;
 
-	*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(tz->temperature,
+	*temp = deci_kelvin_to_millicelsius_with_offset(tz->temperature,
 							tz->kelvin_offset);
 	return 0;
 }
@@ -624,7 +626,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.critical.flags.valid) {
 		if (!trip) {
-			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+			*temp = deci_kelvin_to_millicelsius_with_offset(
 				tz->trips.critical.temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -634,7 +636,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.hot.flags.valid) {
 		if (!trip) {
-			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+			*temp = deci_kelvin_to_millicelsius_with_offset(
 				tz->trips.hot.temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -644,7 +646,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.passive.flags.valid) {
 		if (!trip) {
-			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+			*temp = deci_kelvin_to_millicelsius_with_offset(
 				tz->trips.passive.temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -655,7 +657,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
 		tz->trips.active[i].flags.valid; i++) {
 		if (!trip) {
-			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+			*temp = deci_kelvin_to_millicelsius_with_offset(
 				tz->trips.active[i].temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -672,7 +674,7 @@ static int thermal_get_crit_temp(struct thermal_zone_device *thermal,
 	struct acpi_thermal *tz = thermal->devdata;
 
 	if (tz->trips.critical.flags.valid) {
-		*temperature = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+		*temperature = deci_kelvin_to_millicelsius_with_offset(
 				tz->trips.critical.temperature,
 				tz->kelvin_offset);
 		return 0;
@@ -692,7 +694,7 @@ static int thermal_get_trend(struct thermal_zone_device *thermal,
 
 	if (type == THERMAL_TRIP_ACTIVE) {
 		int trip_temp;
-		int temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+		int temp = deci_kelvin_to_millicelsius_with_offset(
 					tz->temperature, tz->kelvin_offset);
 		if (thermal_get_trip_temp(thermal, trip, &trip_temp))
 			return -EINVAL;
@@ -1043,9 +1045,9 @@ static void acpi_thermal_guess_offset(struct acpi_thermal *tz)
 {
 	if (tz->trips.critical.flags.valid &&
 	    (tz->trips.critical.temperature % 5) == 1)
-		tz->kelvin_offset = 2731;
+		tz->kelvin_offset = 273100;
 	else
-		tz->kelvin_offset = 2732;
+		tz->kelvin_offset = 273200;
 }
 
 static void acpi_thermal_check_fn(struct work_struct *work)
@@ -1087,7 +1089,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 	INIT_WORK(&tz->thermal_check_work, acpi_thermal_check_fn);
 
 	pr_info(PREFIX "%s [%s] (%ld C)\n", acpi_device_name(device),
-		acpi_device_bid(device), DECI_KELVIN_TO_CELSIUS(tz->temperature));
+		acpi_device_bid(device), deci_kelvin_to_celsius(tz->temperature));
 	goto end;
 
 free_memory:

commit e88c7409c983fb611f783918c270cd18c11a6c50
Author: Kelsey Skunberg <skunberg.kelsey@gmail.com>
Date:   Sun Jul 21 20:35:30 2019 -0600

    ACPI: thermal: Remove redundant acpi_has_method() calls
    
    The following acpi_has_method() calls are unnecessary since
    acpi_execute_simple_method() and acpi_evaluate_reference() will
    return an error if the given method does not exist.
    
    Remove acpi_has_method() calls to avoid additional work.
    
    Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 00f12a86ecbd..d831a61e0010 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -225,13 +225,9 @@ static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 	if (!tz)
 		return -EINVAL;
 
-	if (!acpi_has_method(tz->device->handle, "_SCP")) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
+	if (ACPI_FAILURE(acpi_execute_simple_method(tz->device->handle,
+						    "_SCP", mode)))
 		return -ENODEV;
-	} else if (ACPI_FAILURE(acpi_execute_simple_method(tz->device->handle,
-							   "_SCP", mode))) {
-		return -ENODEV;
-	}
 
 	return 0;
 }
@@ -463,8 +459,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			break;
 	}
 
-	if ((flag & ACPI_TRIPS_DEVICES)
-	    && acpi_has_method(tz->device->handle, "_TZD")) {
+	if (flag & ACPI_TRIPS_DEVICES) {
 		memset(&devices, 0, sizeof(devices));
 		status = acpi_evaluate_reference(tz->device->handle, "_TZD",
 						NULL, &devices);

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 551b71a24b85..00f12a86ecbd 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1,30 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  acpi_thermal.c - ACPI Thermal Zone Driver ($Revision: 41 $)
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
  *  This driver fully implements the ACPI thermal policy as described in the
  *  ACPI 2.0 Specification.
  *
  *  TBD: 1. Implement passive cooling hysteresis.
  *       2. Enhance passive cooling (CPU) states/limit interface to support
  *          concepts of 'multiple limiters', upper/lower limits, etc.
- *
  */
 
 #include <linux/kernel.h>

commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 14 11:59:30 2017 +0200

    dmi: Mark all struct dmi_system_id instances const
    
    ... and __initconst if applicable.
    
    Based on similar work for an older kernel in the Grsecurity patch.
    
    [JD: fix toshiba-wmi build]
    [JD: add htcpen]
    [JD: move __initconst where checkscript wants it]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1d0417b87cb7..551b71a24b85 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1209,7 +1209,7 @@ static int thermal_psv(const struct dmi_system_id *d) {
 	return 0;
 }
 
-static struct dmi_system_id thermal_dmi_table[] __initdata = {
+static const struct dmi_system_id thermal_dmi_table[] __initconst = {
 	/*
 	 * Award BIOS on this AOpen makes thermal control almost worthless.
 	 * http://bugzilla.kernel.org/show_bug.cgi?id=8842

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 35e8fbca10ad..1d0417b87cb7 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -40,7 +40,7 @@
 #include <linux/thermal.h>
 #include <linux/acpi.h>
 #include <linux/workqueue.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #define PREFIX "ACPI: "
 

commit 0e70f466fb910ae54c4c71243b99385129e93feb
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Aug 26 16:21:16 2016 -0700

    thermal: Enhance thermal_zone_device_update for events
    
    Added one additional parameter to thermal_zone_device_update() to provide
    caller with an optional capability to specify reason.
    Currently this event is used by user space governor to trigger different
    processing based on event code. Also it saves an additional call to read
    temperature when the event is received.
    The following events are cuurently defined:
    - Unspecified event
    - New temperature sample
    - Trip point violated
    - Trip point changed
    - thermal device up and down
    - thermal device power capability changed
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index f4ebe39539af..35e8fbca10ad 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -520,7 +520,8 @@ static void acpi_thermal_check(void *data)
 	if (!tz->tz_enabled)
 		return;
 
-	thermal_zone_device_update(tz->thermal_zone);
+	thermal_zone_device_update(tz->thermal_zone,
+				   THERMAL_EVENT_UNSPECIFIED);
 }
 
 /* sys I/F for generic thermal sysfs support */

commit e053dc909352837a95676f7826aafa8701bf0dca
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Tue Jun 7 08:45:40 2016 +0530

    ACPI / thermal: Remove create_workqueue()
    
    alloc_workqueue replaces deprecated create_workqueue().
    
    A dedicated workqueue has been used since the workqueue
    acpi_thermal_pm_queue with workitem &tz->thermal_check_work
    (maps to acpi_thermal_check_fn), is involved in thermal zone polling.
    Wallclock time is actually important and getting delayed in handling
    critical temperature event can actually lead to unnecessary hardware
    damage. So while this is not used during memory reclaim, we still want
    forward progress guarantee and be generally snappy in servicing it.
    Hence, WQ_MEM_RECLAIM and WQ_HIGHPRI have been used here.
    
    Since there are only a fixed number of work items, explicit concurrency
    limit is unnecessary here.
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 82707f9824ca..f4ebe39539af 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1259,7 +1259,8 @@ static int __init acpi_thermal_init(void)
 		return -ENODEV;
 	}
 
-	acpi_thermal_pm_queue = create_workqueue("acpi_thermal_pm");
+	acpi_thermal_pm_queue = alloc_workqueue("acpi_thermal_pm",
+						WQ_HIGHPRI | WQ_MEM_RECLAIM, 0);
 	if (!acpi_thermal_pm_queue)
 		return -ENODEV;
 

commit e866a2e3950fe2f708d5cc67d641b1725ef7a708
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Oct 1 23:45:31 2015 +0200

    linux/thermal.h: rename KELVIN_TO_CELSIUS to DECI_KELVIN_TO_CELSIUS
    
    The macros KELVIN_TO_CELSIUS and CELSIUS_TO_KELVIN actually convert
    between deciKelvins and Celsius, so rename them to reflect that. While
    at it, use a statement expression in DECI_KELVIN_TO_CELSIUS to prevent
    expanding the argument multiple times and get rid of a few casts.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 30d8518b25fb..82707f9824ca 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -315,7 +315,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			if (crt == -1) {
 				tz->trips.critical.flags.valid = 0;
 			} else if (crt > 0) {
-				unsigned long crt_k = CELSIUS_TO_KELVIN(crt);
+				unsigned long crt_k = CELSIUS_TO_DECI_KELVIN(crt);
 				/*
 				 * Allow override critical threshold
 				 */
@@ -351,7 +351,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		if (psv == -1) {
 			status = AE_SUPPORT;
 		} else if (psv > 0) {
-			tmp = CELSIUS_TO_KELVIN(psv);
+			tmp = CELSIUS_TO_DECI_KELVIN(psv);
 			status = AE_OK;
 		} else {
 			status = acpi_evaluate_integer(tz->device->handle,
@@ -431,7 +431,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 					break;
 				if (i == 1)
 					tz->trips.active[0].temperature =
-						CELSIUS_TO_KELVIN(act);
+						CELSIUS_TO_DECI_KELVIN(act);
 				else
 					/*
 					 * Don't allow override higher than
@@ -439,9 +439,9 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 					 */
 					tz->trips.active[i - 1].temperature =
 						(tz->trips.active[i - 2].temperature <
-						CELSIUS_TO_KELVIN(act) ?
+						CELSIUS_TO_DECI_KELVIN(act) ?
 						tz->trips.active[i - 2].temperature :
-						CELSIUS_TO_KELVIN(act));
+						CELSIUS_TO_DECI_KELVIN(act));
 				break;
 			} else {
 				tz->trips.active[i].temperature = tmp;
@@ -1105,7 +1105,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 	INIT_WORK(&tz->thermal_check_work, acpi_thermal_check_fn);
 
 	pr_info(PREFIX "%s [%s] (%ld C)\n", acpi_device_name(device),
-		acpi_device_bid(device), KELVIN_TO_CELSIUS(tz->temperature));
+		acpi_device_bid(device), DECI_KELVIN_TO_CELSIUS(tz->temperature));
 	goto end;
 
 free_memory:

commit 9ebd051a7d5aa7b0ce813c3c2e5b9c851e7774b9
Merge: 51a73ba5f409 5a924a07f882
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 11 16:13:47 2015 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal updates from Zhang Rui:
    
     - use int instead of unsigned long to represent temperature to avoid
       bogus overheat detection when negative temperature reported.  From
       Sascha Hauer.
    
     - export available thermal governors information to user space via
       sysfs.  From Wei Ni.
    
     - introduce new thermal driver for Wildcat Point platform controller
       hub, which uses PCH thermal sensor and associated critical and hot
       trip points.  From Tushar Dave.
    
     - add suuport for Intel Skylake and Denlow platforms in powerclamp
       driver.
    
     - some small cleanups in thermal core.
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux:
      thermal: Add Intel PCH thermal driver
      thermal: Add comment explaining test for critical temperature
      thermal: Use IS_ENABLED instead of #ifdef
      thermal: remove unnecessary call to thermal_zone_device_set_polling
      thermal: trivial: fix typo in comment
      thermal: consistently use int for temperatures
      thermal: add available policies sysfs attribute
      thermal/powerclamp: add cpu id for denlow platform
      thermal/powerclamp: add cpu id for Skylake u/y
      thermal/powerclamp: add cpu id for skylake h/s

commit 17e8351a77397e8a83727eb17e3a3e9b8ab5257a
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Fri Jul 24 08:12:54 2015 +0200

    thermal: consistently use int for temperatures
    
    The thermal code uses int, long and unsigned long for temperatures
    in different places.
    
    Using an unsigned type limits the thermal framework to positive
    temperatures without need. Also several drivers currently will report
    temperatures near UINT_MAX for temperatures below 0°C. This will probably
    immediately shut the machine down due to overtemperature if started below
    0°C.
    
    'long' is 64bit on several architectures. This is not needed since INT_MAX °mC
    is above the melting point of all known materials.
    
    Consistently use a plain 'int' for temperatures throughout the thermal code and
    the drivers. This only changes the places in the drivers where the temperature
    is passed around as pointer, when drivers internally use another type this is
    not changed.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Lukasz Majewski <l.majewski@samsung.com>
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Peter Feuerer <peter@piie.net>
    Cc: Punit Agrawal <punit.agrawal@arm.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Eduardo Valentin <edubezval@gmail.com>
    Cc: linux-pm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Jean Delvare <jdelvare@suse.de>
    Cc: Peter Feuerer <peter@piie.net>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Lukasz Majewski <l.majewski@samsung.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: platform-driver-x86@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: lm-sensors@lm-sensors.org
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 6d4e44ea74ac..e66ad25d112f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -529,8 +529,7 @@ static void acpi_thermal_check(void *data)
 
 /* sys I/F for generic thermal sysfs support */
 
-static int thermal_get_temp(struct thermal_zone_device *thermal,
-			    unsigned long *temp)
+static int thermal_get_temp(struct thermal_zone_device *thermal, int *temp)
 {
 	struct acpi_thermal *tz = thermal->devdata;
 	int result;
@@ -637,7 +636,7 @@ static int thermal_get_trip_type(struct thermal_zone_device *thermal,
 }
 
 static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
-				 int trip, unsigned long *temp)
+				 int trip, int *temp)
 {
 	struct acpi_thermal *tz = thermal->devdata;
 	int i;
@@ -690,7 +689,8 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 }
 
 static int thermal_get_crit_temp(struct thermal_zone_device *thermal,
-				unsigned long *temperature) {
+				int *temperature)
+{
 	struct acpi_thermal *tz = thermal->devdata;
 
 	if (tz->trips.critical.flags.valid) {
@@ -713,8 +713,8 @@ static int thermal_get_trend(struct thermal_zone_device *thermal,
 		return -EINVAL;
 
 	if (type == THERMAL_TRIP_ACTIVE) {
-		unsigned long trip_temp;
-		unsigned long temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+		int trip_temp;
+		int temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
 					tz->temperature, tz->kelvin_offset);
 		if (thermal_get_trip_temp(thermal, trip, &trip_temp))
 			return -EINVAL;

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 6d4e44ea74ac..fc28b9f5aa84 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -16,10 +16,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  *  This driver fully implements the ACPI thermal policy as described in the

commit 6cd9e9f629f11b9412d4e9aa294c029dbb36b3cf
Author: Kapileshwar Singh <kapileshwar.singh@arm.com>
Date:   Wed Feb 18 16:04:21 2015 +0000

    thermal: of: fix cooling device weights in device tree
    
    Currently you can specify the weight of the cooling device in the device
    tree but that information is not populated to the
    thermal_bind_params where the fair share governor expects it to
    be.  The of thermal zone device doesn't have a thermal_bind_params
    structure and arguably it's better to pass the weight inside the
    thermal_instance as it is specific to the bind of a cooling device to a
    thermal zone parameter.
    
    Core thermal code is fixed to populate the weight in the instance from
    the thermal_bind_params, so platform code that was passing the weight
    inside the thermal_bind_params continue to work seamlessly.
    
    While we are at it, create a default value for the weight parameter for
    those thermal zones that currently don't define it and remove the
    hardcoded default in of-thermal.
    
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Peter Feuerer <peter@piie.net>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Eduardo Valentin <edubezval@gmail.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Kapileshwar Singh <kapileshwar.singh@arm.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index d24fa1964eb8..6d4e44ea74ac 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -800,7 +800,8 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 				result =
 					thermal_zone_bind_cooling_device
 					(thermal, trip, cdev,
-					 THERMAL_NO_LIMIT, THERMAL_NO_LIMIT);
+					 THERMAL_NO_LIMIT, THERMAL_NO_LIMIT,
+					 THERMAL_WEIGHT_DEFAULT);
 			else
 				result =
 					thermal_zone_unbind_cooling_device
@@ -824,7 +825,8 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 			if (bind)
 				result = thermal_zone_bind_cooling_device
 					(thermal, trip, cdev,
-					 THERMAL_NO_LIMIT, THERMAL_NO_LIMIT);
+					 THERMAL_NO_LIMIT, THERMAL_NO_LIMIT,
+					 THERMAL_WEIGHT_DEFAULT);
 			else
 				result = thermal_zone_unbind_cooling_device
 					(thermal, trip, cdev);
@@ -841,7 +843,8 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 				result = thermal_zone_bind_cooling_device
 						(thermal, THERMAL_TRIPS_NONE,
 						 cdev, THERMAL_NO_LIMIT,
-						 THERMAL_NO_LIMIT);
+						 THERMAL_NO_LIMIT,
+						 THERMAL_WEIGHT_DEFAULT);
 			else
 				result = thermal_zone_unbind_cooling_device
 						(thermal, THERMAL_TRIPS_NONE,

commit 7b83fd9d91a411158f72d36958103c708c3b5a86
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Mar 25 10:40:09 2014 +0800

    Thermal: move the KELVIN_TO_MILLICELSIUS macro to thermal.h
    
    This macro can be used by other component so move it to a common header,
    but in a slightly different way: define two macros, one macro with an
    offset and the other doesn't.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 112817e963e0..d24fa1964eb8 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -528,7 +528,6 @@ static void acpi_thermal_check(void *data)
 }
 
 /* sys I/F for generic thermal sysfs support */
-#define KELVIN_TO_MILLICELSIUS(t, off) (((t) - (off)) * 100)
 
 static int thermal_get_temp(struct thermal_zone_device *thermal,
 			    unsigned long *temp)
@@ -543,7 +542,8 @@ static int thermal_get_temp(struct thermal_zone_device *thermal,
 	if (result)
 		return result;
 
-	*temp = KELVIN_TO_MILLICELSIUS(tz->temperature, tz->kelvin_offset);
+	*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(tz->temperature,
+							tz->kelvin_offset);
 	return 0;
 }
 
@@ -647,7 +647,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.critical.flags.valid) {
 		if (!trip) {
-			*temp = KELVIN_TO_MILLICELSIUS(
+			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
 				tz->trips.critical.temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -657,7 +657,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.hot.flags.valid) {
 		if (!trip) {
-			*temp = KELVIN_TO_MILLICELSIUS(
+			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
 				tz->trips.hot.temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -667,7 +667,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.passive.flags.valid) {
 		if (!trip) {
-			*temp = KELVIN_TO_MILLICELSIUS(
+			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
 				tz->trips.passive.temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -678,7 +678,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
 		tz->trips.active[i].flags.valid; i++) {
 		if (!trip) {
-			*temp = KELVIN_TO_MILLICELSIUS(
+			*temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
 				tz->trips.active[i].temperature,
 				tz->kelvin_offset);
 			return 0;
@@ -694,7 +694,7 @@ static int thermal_get_crit_temp(struct thermal_zone_device *thermal,
 	struct acpi_thermal *tz = thermal->devdata;
 
 	if (tz->trips.critical.flags.valid) {
-		*temperature = KELVIN_TO_MILLICELSIUS(
+		*temperature = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
 				tz->trips.critical.temperature,
 				tz->kelvin_offset);
 		return 0;
@@ -714,8 +714,8 @@ static int thermal_get_trend(struct thermal_zone_device *thermal,
 
 	if (type == THERMAL_TRIP_ACTIVE) {
 		unsigned long trip_temp;
-		unsigned long temp = KELVIN_TO_MILLICELSIUS(tz->temperature,
-							tz->kelvin_offset);
+		unsigned long temp = DECI_KELVIN_TO_MILLICELSIUS_WITH_OFFSET(
+					tz->temperature, tz->kelvin_offset);
 		if (thermal_get_trip_temp(thermal, trip, &trip_temp))
 			return -EINVAL;
 

commit f70977fbd6359efb17bb93adac37b9f226d910a7
Merge: 2807bd18cc60 e6f8a4d60b90
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 29 13:28:14 2014 +0200

    Merge back earlier ACPI thermal material.

commit e6f8a4d60b905eae1a20cbb0c72c67b26b2f02fd
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue May 20 20:59:22 2014 +0800

    ACPI / thermal: Use acpi_bus_attach_private_data() to attach private data
    
    Use acpi_bus_attach_private_data() to attach private data
    instead of acpi_attach_data().
    
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index c1e31a41f949..ae195fde858d 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -925,13 +925,10 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 	if (result)
 		return result;
 
-	status = acpi_attach_data(tz->device->handle,
-				  acpi_bus_private_data_handler,
-				  tz->thermal_zone);
-	if (ACPI_FAILURE(status)) {
-		pr_err(PREFIX "Error attaching device data\n");
+	status =  acpi_bus_attach_private_data(tz->device->handle,
+					       tz->thermal_zone);
+	if (ACPI_FAILURE(status))
 		return -ENODEV;
-	}
 
 	tz->tz_enabled = 1;
 
@@ -946,7 +943,7 @@ static void acpi_thermal_unregister_thermal_zone(struct acpi_thermal *tz)
 	sysfs_remove_link(&tz->thermal_zone->device.kobj, "device");
 	thermal_zone_device_unregister(tz->thermal_zone);
 	tz->thermal_zone = NULL;
-	acpi_detach_data(tz->device->handle, acpi_bus_private_data_handler);
+	acpi_bus_detach_private_data(tz->device->handle);
 }
 
 

commit 2807bd18cc60ec471917b5158e98e4d7b7e030fb
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Mon May 26 14:34:07 2014 +0200

    ACPI / thermal: fix workqueue destroy order
    
    When the thermal module is to be removed, we should destroy the wq
    acpi_thermal_pm_queue after the ACPI driver's remove callback is
    executed as we will need to flush the workqueue there, or a NULL pointer
    access will be hit.
    
    Reported-and-tested-by: Kui Zhang <kuizhang@gmail.com>
    References: http://www.spinics.net/lists/kernel/msg1747251.html
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index c1e31a41f949..25bbc55dca89 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1278,8 +1278,8 @@ static int __init acpi_thermal_init(void)
 
 static void __exit acpi_thermal_exit(void)
 {
-	destroy_workqueue(acpi_thermal_pm_queue);
 	acpi_bus_unregister_driver(&acpi_thermal_driver);
+	destroy_workqueue(acpi_thermal_pm_queue);
 
 	return;
 }

commit ee17fdf24bf815650c87b3bb35fbab42681523a8
Author: Zhihui Zhang <zzhsuny@gmail.com>
Date:   Sat Mar 29 09:25:47 2014 -0400

    ACPI / thermal: Fix wrong variable usage in debug statement
    
    A debug statement in acpi_thermal_trips_update() uses a wrong trip
    point (tz->trips.critical instead of tz->trips.hot) to get the
    temperature value from.  Fix that.
    
    Signed-off-by: Zhihui Zhang <zzhsuny@gmail.com>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 964068553334..c1e31a41f949 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -344,7 +344,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			tz->trips.hot.flags.valid = 1;
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					"Found hot threshold [%lu]\n",
-					tz->trips.critical.temperature));
+					tz->trips.hot.temperature));
 		}
 	}
 

commit a59ffb2062df3a5c346dbed931fa1e587fd0f0f3
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Mar 4 14:24:46 2014 +0800

    ACPI / thermal: make acpi_thermal_check asynchronous on resume
    
    On resume we do not need to wait for acpi_thermal_check to finish.
    Instead, we can run it asynchronously and not block the whole system
    resume. Also, we make sure when we are suspending again, previously
    queued work for acpi_thermal_check is done.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 08626c851be7..964068553334 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -43,6 +43,7 @@
 #include <linux/device.h>
 #include <linux/thermal.h>
 #include <linux/acpi.h>
+#include <linux/workqueue.h>
 #include <asm/uaccess.h>
 
 #define PREFIX "ACPI: "
@@ -90,6 +91,8 @@ static int psv;
 module_param(psv, int, 0644);
 MODULE_PARM_DESC(psv, "Disable or override all passive trip points.");
 
+static struct workqueue_struct *acpi_thermal_pm_queue;
+
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device);
 static void acpi_thermal_notify(struct acpi_device *device, u32 event);
@@ -101,11 +104,13 @@ static const struct acpi_device_id  thermal_device_ids[] = {
 MODULE_DEVICE_TABLE(acpi, thermal_device_ids);
 
 #ifdef CONFIG_PM_SLEEP
+static int acpi_thermal_suspend(struct device *dev);
 static int acpi_thermal_resume(struct device *dev);
 #else
+#define acpi_thermal_suspend NULL
 #define acpi_thermal_resume NULL
 #endif
-static SIMPLE_DEV_PM_OPS(acpi_thermal_pm, NULL, acpi_thermal_resume);
+static SIMPLE_DEV_PM_OPS(acpi_thermal_pm, acpi_thermal_suspend, acpi_thermal_resume);
 
 static struct acpi_driver acpi_thermal_driver = {
 	.name = "thermal",
@@ -186,6 +191,7 @@ struct acpi_thermal {
 	struct thermal_zone_device *thermal_zone;
 	int tz_enabled;
 	int kelvin_offset;
+	struct work_struct thermal_check_work;
 };
 
 /* --------------------------------------------------------------------------
@@ -1064,6 +1070,13 @@ static void acpi_thermal_guess_offset(struct acpi_thermal *tz)
 		tz->kelvin_offset = 2732;
 }
 
+static void acpi_thermal_check_fn(struct work_struct *work)
+{
+	struct acpi_thermal *tz = container_of(work, struct acpi_thermal,
+					       thermal_check_work);
+	acpi_thermal_check(tz);
+}
+
 static int acpi_thermal_add(struct acpi_device *device)
 {
 	int result = 0;
@@ -1093,6 +1106,8 @@ static int acpi_thermal_add(struct acpi_device *device)
 	if (result)
 		goto free_memory;
 
+	INIT_WORK(&tz->thermal_check_work, acpi_thermal_check_fn);
+
 	pr_info(PREFIX "%s [%s] (%ld C)\n", acpi_device_name(device),
 		acpi_device_bid(device), KELVIN_TO_CELSIUS(tz->temperature));
 	goto end;
@@ -1110,6 +1125,7 @@ static int acpi_thermal_remove(struct acpi_device *device)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
+	flush_workqueue(acpi_thermal_pm_queue);
 	tz = acpi_driver_data(device);
 
 	acpi_thermal_unregister_thermal_zone(tz);
@@ -1118,6 +1134,13 @@ static int acpi_thermal_remove(struct acpi_device *device)
 }
 
 #ifdef CONFIG_PM_SLEEP
+static int acpi_thermal_suspend(struct device *dev)
+{
+	/* Make sure the previously queued thermal check work has been done */
+	flush_workqueue(acpi_thermal_pm_queue);
+	return 0;
+}
+
 static int acpi_thermal_resume(struct device *dev)
 {
 	struct acpi_thermal *tz;
@@ -1148,7 +1171,7 @@ static int acpi_thermal_resume(struct device *dev)
 		tz->state.active |= tz->trips.active[i].flags.enabled;
 	}
 
-	acpi_thermal_check(tz);
+	queue_work(acpi_thermal_pm_queue, &tz->thermal_check_work);
 
 	return AE_OK;
 }
@@ -1240,16 +1263,22 @@ static int __init acpi_thermal_init(void)
 		return -ENODEV;
 	}
 
+	acpi_thermal_pm_queue = create_workqueue("acpi_thermal_pm");
+	if (!acpi_thermal_pm_queue)
+		return -ENODEV;
+
 	result = acpi_bus_register_driver(&acpi_thermal_driver);
-	if (result < 0)
+	if (result < 0) {
+		destroy_workqueue(acpi_thermal_pm_queue);
 		return -ENODEV;
+	}
 
 	return 0;
 }
 
 static void __exit acpi_thermal_exit(void)
 {
-
+	destroy_workqueue(acpi_thermal_pm_queue);
 	acpi_bus_unregister_driver(&acpi_thermal_driver);
 
 	return;

commit fae9e2a4b1c59d11edfa7c99c34293bf9fbf2bde
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Wed Feb 12 20:19:10 2014 -0700

    ACPI / thermal: fix thermal driver compile error when CONFIG_PM_SLEEP is undefined
    
    The ACPI thermal driver defines acpi_thermal_resume() when
    CONFIG_PM_SLEEP is defined. This results in the following compile
    error when CONFIG_PM_SLEEP is undefined.
    
      CC      drivers/acpi/thermal.o
    drivers/acpi/thermal.c:107:8: error: ‘acpi_thermal_resume’ undeclared here (not in a function)
    make[2]: *** [drivers/acpi/thermal.o] Error 1
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 8349a555b92b..08626c851be7 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -102,6 +102,8 @@ MODULE_DEVICE_TABLE(acpi, thermal_device_ids);
 
 #ifdef CONFIG_PM_SLEEP
 static int acpi_thermal_resume(struct device *dev);
+#else
+#define acpi_thermal_resume NULL
 #endif
 static SIMPLE_DEV_PM_OPS(acpi_thermal_pm, NULL, acpi_thermal_resume);
 

commit bcc7201a91176f815f48f8ad889a20c5c829d9a9
Merge: fbb9c10d40f8 42b946bb35ef 2d4054d84224 ec9c9c2ec1d1 b981513f806d 5c551e624abb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:46:55 2014 +0100

    Merge branches 'acpi-gpe', 'acpi-video', 'acpi-thermal', 'acpi-processor', 'acpi-sleep'
    
    * acpi-gpe:
      ACPI / EC: disable GPE before removing GPE handler
      ACPI / Button: Fix enabling button GPEs twice
    
    * acpi-video:
      ACPI: Blacklist Win8 OSI for some HP laptop 2013 models
      ACPI / video: Fix typo in video_detect.c
    
    * acpi-thermal:
      ACPI / thermal: remove const from thermal_zone_device_ops declaration
    
    * acpi-processor:
      ACPI / scan: bail out early if failed to parse APIC ID for CPU
    
    * acpi-sleep:
      ACPI / sleep: remove panic in case hardware has changed after S4

commit ec9c9c2ec1d164f3c5f3c9ac41f43de40040e43c
Author: Emil Goode <emilgoode@gmail.com>
Date:   Tue Jan 7 17:24:55 2014 +0100

    ACPI / thermal: remove const from thermal_zone_device_ops declaration
    
    The following commit introduced the requirement to not declare
    thermal_zone_device_ops structs as const in order to allow
    changing the .get_temp callback.
    
    commit 4e5e4705bf69ea450f58fc709ac5888f321a9299
    Author: Eduardo Valentin <eduardo.valentin@ti.com>
    Date:   Wed Jul 3 15:35:39 2013 -0400
    
        thermal: introduce device tree parser
    
    Modify acpi_thermal_zone_ops to follow the new requirement.
    
    Signed-off-by: Emil Goode <emilgoode@gmail.com>
    Acked-by: Eduardo Valentin <eduardo.valentin@ti.com>
    [rjw: Changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 0d9f46b5ae6d..9eaf3bf013f0 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -862,7 +862,7 @@ acpi_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,
 	return acpi_thermal_cooling_device_cb(thermal, cdev, false);
 }
 
-static const struct thermal_zone_device_ops acpi_thermal_zone_ops = {
+static struct thermal_zone_device_ops acpi_thermal_zone_ops = {
 	.bind = acpi_thermal_bind_cooling_device,
 	.unbind	= acpi_thermal_unbind_cooling_device,
 	.get_temp = thermal_get_temp,

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 0d9f46b5ae6d..1fd21ad69c98 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -41,10 +41,9 @@
 #include <linux/kmod.h>
 #include <linux/reboot.h>
 #include <linux/device.h>
-#include <asm/uaccess.h>
 #include <linux/thermal.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
+#include <asm/uaccess.h>
 
 #define PREFIX "ACPI: "
 

commit 549608eadb31eac5d579ed70a21ac722bdf72861
Merge: 2f466d33f5f6 86e0a0bdf81c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 14 14:42:31 2013 +0900

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal management updates from Zhang Rui:
     "This time we only have a few changes as there are no soc thermal
      changes from Eduardo.  The only big change is the introduction of
      TMON, a tool to help visualize, tune, and test the thermal subsystem.
      The rest is mostly cleanups and fixes all over.
    
      Specifics:
    
       - introduce TMON, a tool base on thermal sysfs I/F.  It can be used
         to visualize, tune and test the thermal subsystem.
    
       - fix a zone/cooling device binding problem, when both thermal zone
         bind parameters and .bind() callback are available"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux:
      tools/thermal: Introduce tmon, a tool for thermal subsystem
      thermal: Fix binding problem when there is thermal zone params
      thermal: cpu_cooling: fix return value check in cpufreq_cooling_register()
      Thermal: Check for validity before doing kfree
      thermal/intel_powerclamp: Add newer CPU models
      Thermal: Tidy up error handling in powerclamp_init
      thermal: Kconfig: cosmetic fixes
      ACPI/thermal : Remove zone disabled warning
      typo in drivers/thermal/Kconfig: lpatform instead of platform

commit 766a8a6dd89268107df1f6783f6a6338efcbf07e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Sep 13 18:15:46 2013 +0300

    ACPI / thermal: convert printk(LEVEL...) to pr_<lvl>
    
    Convert printks to pr_* format. Additionally re-use PREFIX constant instead of
    hardcoded strings.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 6a0329340b42..e600b5dbfcb6 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -299,8 +299,8 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					  "No critical threshold\n"));
 		} else if (tmp <= 2732) {
-			printk(KERN_WARNING FW_BUG "Invalid critical threshold "
-			       "(%llu)\n", tmp);
+			pr_warn(FW_BUG "Invalid critical threshold (%llu)\n",
+				tmp);
 			tz->trips.critical.flags.valid = 0;
 		} else {
 			tz->trips.critical.flags.valid = 1;
@@ -317,8 +317,8 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 				 * Allow override critical threshold
 				 */
 				if (crt_k > tz->trips.critical.temperature)
-					printk(KERN_WARNING PREFIX
-						"Critical threshold %d C\n", crt);
+					pr_warn(PREFIX "Critical threshold %d C\n",
+						crt);
 				tz->trips.critical.temperature = crt_k;
 			}
 		}
@@ -390,8 +390,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		status = acpi_evaluate_reference(tz->device->handle, "_PSL",
 							NULL, &devices);
 		if (ACPI_FAILURE(status)) {
-			printk(KERN_WARNING PREFIX
-				"Invalid passive threshold\n");
+			pr_warn(PREFIX "Invalid passive threshold\n");
 			tz->trips.passive.flags.valid = 0;
 		}
 		else
@@ -453,8 +452,8 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			status = acpi_evaluate_reference(tz->device->handle,
 						name, NULL, &devices);
 			if (ACPI_FAILURE(status)) {
-				printk(KERN_WARNING PREFIX
-					"Invalid active%d threshold\n", i);
+				pr_warn(PREFIX "Invalid active%d threshold\n",
+					i);
 				tz->trips.active[i].flags.valid = 0;
 			}
 			else
@@ -505,7 +504,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 		valid |= tz->trips.active[i].flags.valid;
 
 	if (!valid) {
-		printk(KERN_WARNING FW_BUG "No valid trip found\n");
+		pr_warn(FW_BUG "No valid trip found\n");
 		return -ENODEV;
 	}
 	return 0;
@@ -923,8 +922,7 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 				  acpi_bus_private_data_handler,
 				  tz->thermal_zone);
 	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX
-				"Error attaching device data\n");
+		pr_err(PREFIX "Error attaching device data\n");
 		return -ENODEV;
 	}
 
@@ -1094,9 +1092,8 @@ static int acpi_thermal_add(struct acpi_device *device)
 	if (result)
 		goto free_memory;
 
-	printk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",
-	       acpi_device_name(device), acpi_device_bid(device),
-	       KELVIN_TO_CELSIUS(tz->temperature));
+	pr_info(PREFIX "%s [%s] (%ld C)\n", acpi_device_name(device),
+		acpi_device_bid(device), KELVIN_TO_CELSIUS(tz->temperature));
 	goto end;
 
 free_memory:
@@ -1159,24 +1156,24 @@ static int acpi_thermal_resume(struct device *dev)
 static int thermal_act(const struct dmi_system_id *d) {
 
 	if (act == 0) {
-		printk(KERN_NOTICE "ACPI: %s detected: "
-			"disabling all active thermal trip points\n", d->ident);
+		pr_notice(PREFIX "%s detected: "
+			  "disabling all active thermal trip points\n", d->ident);
 		act = -1;
 	}
 	return 0;
 }
 static int thermal_nocrt(const struct dmi_system_id *d) {
 
-	printk(KERN_NOTICE "ACPI: %s detected: "
-		"disabling all critical thermal trip point actions.\n", d->ident);
+	pr_notice(PREFIX "%s detected: "
+		  "disabling all critical thermal trip point actions.\n", d->ident);
 	nocrt = 1;
 	return 0;
 }
 static int thermal_tzp(const struct dmi_system_id *d) {
 
 	if (tzp == 0) {
-		printk(KERN_NOTICE "ACPI: %s detected: "
-			"enabling thermal zone polling\n", d->ident);
+		pr_notice(PREFIX "%s detected: "
+			  "enabling thermal zone polling\n", d->ident);
 		tzp = 300;	/* 300 dS = 30 Seconds */
 	}
 	return 0;
@@ -1184,8 +1181,8 @@ static int thermal_tzp(const struct dmi_system_id *d) {
 static int thermal_psv(const struct dmi_system_id *d) {
 
 	if (psv == 0) {
-		printk(KERN_NOTICE "ACPI: %s detected: "
-			"disabling all passive thermal trip points\n", d->ident);
+		pr_notice(PREFIX "%s detected: "
+			  "disabling all passive thermal trip points\n", d->ident);
 		psv = -1;
 	}
 	return 0;
@@ -1238,7 +1235,7 @@ static int __init acpi_thermal_init(void)
 	dmi_check_system(thermal_dmi_table);
 
 	if (off) {
-		printk(KERN_NOTICE "ACPI: thermal control disabled\n");
+		pr_notice(PREFIX "thermal control disabled\n");
 		return -ENODEV;
 	}
 

commit e994d713a73716b54085a092b267099e40aa5513
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Sep 25 09:29:50 2013 -0700

    ACPI/thermal : Remove zone disabled warning
    
    Once thermal zone is disabled to move thermal control to user space,
    too many warnings printed in logs. Remove pr_warn from this path,
    instead warn when user mode issues request to disable thermal zone.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Acked-by: Eduardo Valentin <eduardo.valentin@ti.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 6a0329340b42..92bebb9d9438 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -515,10 +515,9 @@ static void acpi_thermal_check(void *data)
 {
 	struct acpi_thermal *tz = data;
 
-	if (!tz->tz_enabled) {
-		pr_warn("thermal zone is disabled \n");
+	if (!tz->tz_enabled)
 		return;
-	}
+
 	thermal_zone_device_update(tz->thermal_zone);
 }
 
@@ -570,9 +569,10 @@ static int thermal_set_mode(struct thermal_zone_device *thermal,
 	 */
 	if (mode == THERMAL_DEVICE_ENABLED)
 		enable = 1;
-	else if (mode == THERMAL_DEVICE_DISABLED)
+	else if (mode == THERMAL_DEVICE_DISABLED) {
 		enable = 0;
-	else
+		pr_warn("thermal zone will be disabled\n");
+	} else
 		return -EINVAL;
 
 	if (enable != tz->tz_enabled) {

commit da48afb26b40ebb5d6b0e84793e0662859c7ea20
Merge: 7a330a5416de 524f42fab787
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Aug 30 14:13:50 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / EC: Add ASUSTEK L4R to quirk list in order to validate ECDT
      ACPI / thermal: Add check of "_TZD" availability and evaluating result

commit 668e02004462487df8ec6c65c665ddb8af78dc12
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Aug 27 16:29:31 2013 +0800

    ACPI / thermal: Add check of "_TZD" availability and evaluating result
    
    Some machines don't provide _TZD, so check the availability of it
    before carrying out futher operations.
    
    If _TZD is present, also check the result of its evaluation.
    
    [rjw: Changelog]
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index ccf9527d7ed3..0055c83c26c0 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -485,14 +485,14 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			break;
 	}
 
-	if (flag & ACPI_TRIPS_DEVICES) {
-		memset(&devices, 0, sizeof(struct acpi_handle_list));
+	if ((flag & ACPI_TRIPS_DEVICES)
+	    && acpi_has_method(tz->device->handle, "_TZD")) {
+		memset(&devices, 0, sizeof(devices));
 		status = acpi_evaluate_reference(tz->device->handle, "_TZD",
 						NULL, &devices);
-		if (memcmp(&tz->devices, &devices,
-				sizeof(struct acpi_handle_list))) {
-			memcpy(&tz->devices, &devices,
-				sizeof(struct acpi_handle_list));
+		if (ACPI_SUCCESS(status)
+		    && memcmp(&tz->devices, &devices, sizeof(devices))) {
+			tz->devices = devices;
 			ACPI_THERMAL_TRIPS_EXCEPTION(flag, "device");
 		}
 	}

commit 0c581415b522267138d807814e526aa7534b9a61
Merge: afdca01c9821 7702ae0dd9b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:29:04 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / osl: Kill macro INVALID_TABLE().
      earlycpio.c: Fix the confusing comment of find_cpio_data().
      ACPI / x86: Print Hot-Pluggable Field in SRAT.
      ACPI / thermal: Use THERMAL_TRIPS_NONE macro to replace number
      ACPI / thermal: Remove unused macros in the driver/acpi/thermal.c
      ACPI / thermal: Remove the unused lock of struct acpi_thermal
      ACPI / osl: Fix osi_setup_entries[] __initdata attribute location
      ACPI / numa: Fix __init attribute location in slit_valid()
      ACPI / dock: Fix __init attribute location in find_dock_and_bay()
      ACPI / Sleep: Fix incorrect placement of __initdata
      ACPI / processor: Fix incorrect placement of __initdata
      ACPI / EC: Fix incorrect placement of __initdata
      ACPI / scan: Drop unnecessary label from acpi_create_platform_device()
      ACPI: Move acpi_bus_get_device() from bus.c to scan.c
      ACPI / scan: Allow platform device creation without any IO resources
      ACPI: Cleanup sparse warning on acpi_os_initialize1()
      platform / thinkpad: Remove deprecated hotkey_report_mode parameter
      ACPI: Remove the old /proc/acpi/event interface

commit 70f2903b506100396dbdb301ae1ead74842a6894
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Aug 14 21:00:39 2013 +0800

    ACPI / thermal: Use THERMAL_TRIPS_NONE macro to replace number
    
    It's unreadable to pass "-1" as trip parameter directly to
    thermal_zone_bind_cooling_device().  Use THERMAL_TRIPS_NONE instead.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index eccd22dfa032..ccf9527d7ed3 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -843,12 +843,13 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 		if (ACPI_SUCCESS(status) && (dev == device)) {
 			if (bind)
 				result = thermal_zone_bind_cooling_device
-						(thermal, -1, cdev,
-						 THERMAL_NO_LIMIT,
+						(thermal, THERMAL_TRIPS_NONE,
+						 cdev, THERMAL_NO_LIMIT,
 						 THERMAL_NO_LIMIT);
 			else
 				result = thermal_zone_unbind_cooling_device
-						(thermal, -1, cdev);
+						(thermal, THERMAL_TRIPS_NONE,
+						 cdev);
 			if (result)
 				goto failed;
 		}

commit b22131c254a9a3cfe0184b234ab8bd737b4c8ba2
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Aug 14 21:00:38 2013 +0800

    ACPI / thermal: Remove unused macros in the driver/acpi/thermal.c
    
    The ACPI_THERMAL_FILE* macros are not used now, so remove them.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index dc1ba6c9ef5d..eccd22dfa032 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -50,11 +50,6 @@
 
 #define ACPI_THERMAL_CLASS		"thermal_zone"
 #define ACPI_THERMAL_DEVICE_NAME	"Thermal Zone"
-#define ACPI_THERMAL_FILE_STATE		"state"
-#define ACPI_THERMAL_FILE_TEMPERATURE	"temperature"
-#define ACPI_THERMAL_FILE_TRIP_POINTS	"trip_points"
-#define ACPI_THERMAL_FILE_COOLING_MODE	"cooling_mode"
-#define ACPI_THERMAL_FILE_POLLING_FREQ	"polling_frequency"
 #define ACPI_THERMAL_NOTIFY_TEMPERATURE	0x80
 #define ACPI_THERMAL_NOTIFY_THRESHOLDS	0x81
 #define ACPI_THERMAL_NOTIFY_DEVICES	0x82

commit 8a6036b92620a4ea0a1285d5c134ac9610ff4b32
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Aug 14 21:00:37 2013 +0800

    ACPI / thermal: Remove the unused lock of struct acpi_thermal
    
    The acpi_thermal->lock now just is initialized when a thermal zone
    device is added and destroyed when the thermal zone is removed.
    It is never used in any other places, so remove it.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 547a906a7662..dc1ba6c9ef5d 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -190,7 +190,6 @@ struct acpi_thermal {
 	struct thermal_zone_device *thermal_zone;
 	int tz_enabled;
 	int kelvin_offset;
-	struct mutex lock;
 };
 
 /* --------------------------------------------------------------------------
@@ -1098,8 +1097,6 @@ static int acpi_thermal_add(struct acpi_device *device)
 	strcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);
 	device->driver_data = tz;
-	mutex_init(&tz->lock);
-
 
 	result = acpi_thermal_get_info(tz);
 	if (result)
@@ -1132,7 +1129,6 @@ static int acpi_thermal_remove(struct acpi_device *device)
 	tz = acpi_driver_data(device);
 
 	acpi_thermal_unregister_thermal_zone(tz);
-	mutex_destroy(&tz->lock);
 	kfree(tz);
 	return 0;
 }

commit 1696d9dc57e062ce5200f6a42a6aaada15b434bb
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 15 10:15:09 2013 +0200

    ACPI: Remove the old /proc/acpi/event interface
    
    It is quite some time that this one has been deprecated.
    Get rid of it.
    
    Should some really important user be overseen, it may be reverted and
    the userspace program worked on first, but it is time to do something
    to get rid of this old stuff...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Matthew Garrett <matthew.garrett@nebula.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index a33821ca3895..547a906a7662 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -769,7 +769,6 @@ static int thermal_notify(struct thermal_zone_device *thermal, int trip,
 	else
 		return 0;
 
-	acpi_bus_generate_proc_event(tz->device, type, 1);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
 					dev_name(&tz->device->dev), type, 1);
 
@@ -980,14 +979,12 @@ static void acpi_thermal_notify(struct acpi_device *device, u32 event)
 	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
 		acpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_THRESHOLDS);
 		acpi_thermal_check(tz);
-		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event, 0);
 		break;
 	case ACPI_THERMAL_NOTIFY_DEVICES:
 		acpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_DEVICES);
 		acpi_thermal_check(tz);
-		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event, 0);
 		break;

commit 0db98202605c3d32e023d43c30b5bd878f520976
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:39 2013 +0800

    ACPI: introduce helper function acpi_execute_simple_method()
    
    Introduce helper function acpi_execute_simple_method() and use it in
    a number of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index a33821ca3895..94523c79dc5f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -239,26 +239,16 @@ static int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)
 
 static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 {
-	acpi_status status = AE_OK;
-	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
-	struct acpi_object_list arg_list = { 1, &arg0 };
-	acpi_handle handle = NULL;
-
-
 	if (!tz)
 		return -EINVAL;
 
-	status = acpi_get_handle(tz->device->handle, "_SCP", &handle);
-	if (ACPI_FAILURE(status)) {
+	if (!acpi_has_method(tz->device->handle, "_SCP")) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
 		return -ENODEV;
-	}
-
-	arg0.integer.value = mode;
-
-	status = acpi_evaluate_object(handle, NULL, &arg_list, NULL);
-	if (ACPI_FAILURE(status))
+	} else if (ACPI_FAILURE(acpi_execute_simple_method(tz->device->handle,
+							   "_SCP", mode))) {
 		return -ENODEV;
+	}
 
 	return 0;
 }

commit 94a409319561ec1847fd9bf996a2d5843ad00932
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Apr 26 09:19:53 2013 +0000

    ACPI / thermal: do not always return THERMAL_TREND_RAISING for active trip points
    
    Commit 4ae46be "Thermal: Introduce thermal_zone_trip_update()"
    introduced a regression causing the fan to be always on even when
    the system is idle.
    
    My original idea in that commit is that:
     - when the current temperature is above the trip point,
       keep the fan on, even if the temperature is dropping.
     - when the current temperature is below the trip point,
       turn on the fan when the temperature is raising,
       turn off the fan when the temperature is dropping.
    
    But this is what the code actually does:
     - when the current temperature is above the trip point,
       the fan keeps on.
     - when the current temperature is below the trip point,
       the fan is always on because thermal_get_trend()
       in driver/acpi/thermal.c returns THERMAL_TREND_RAISING.
    Thus the fan keeps running even if the system is idle.
    
    Fix this in drivers/acpi/thermal.c.
    
    [rjw: Changelog]
    References: https://bugzilla.kernel.org/show_bug.cgi?id=56591
    References: https://bugzilla.kernel.org/show_bug.cgi?id=56601
    References: https://bugzilla.kernel.org/show_bug.cgi?id=50041#c45
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Matthias <morpheusxyz123@yahoo.de>
    Tested-by: Ville Syrjälä <syrjala@sci.fi>
    Cc: 3.7+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 8470771e5eae..a33821ca3895 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -723,9 +723,19 @@ static int thermal_get_trend(struct thermal_zone_device *thermal,
 		return -EINVAL;
 
 	if (type == THERMAL_TRIP_ACTIVE) {
-		/* aggressive active cooling */
-		*trend = THERMAL_TREND_RAISING;
-		return 0;
+		unsigned long trip_temp;
+		unsigned long temp = KELVIN_TO_MILLICELSIUS(tz->temperature,
+							tz->kelvin_offset);
+		if (thermal_get_trip_temp(thermal, trip, &trip_temp))
+			return -EINVAL;
+
+		if (temp > trip_temp) {
+			*trend = THERMAL_TREND_RAISING;
+			return 0;
+		} else {
+			/* Fall back on default trend */
+			return -EINVAL;
+		}
 	}
 
 	/*

commit a68d35323b091f51e0957313f0f871f187879143
Merge: e8f71df72333 66f2fda93b67
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 15 13:58:43 2013 +0100

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI: Add DMI entry for Sony VGN-FW41E_H
      ACPI: fix obsolete comment in custom_method.c
      ACPI / thermal: Use mode to enable/disable kernel thermal processing
      ACPI thermal: remove unnecessary newline from exception message
      ACPI sysfs: remove unnecessary newline from exception
      ACPI video: remove unnecessary newline from error messages
      ACPI: SRAT: report non-volatile memory in debug
      ACPI: Rework acpi_get_child() to be more efficient

commit 51fac8388a0325a43f0ae67453ece2c373e2ec28
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 00:24:48 2013 +0100

    ACPI: Remove useless type argument of driver .remove() operation
    
    The second argument of ACPI driver .remove() operation is only used
    by the ACPI processor driver and the value passed to that driver
    through it is always available from the given struct acpi_device
    object's removal_type field.  For this reason, the second ACPI driver
    .remove() argument is in fact useless, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jiang Liu <jiang.liu@huawei.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 506fbd4b5733..da079d4e0baa 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -97,7 +97,7 @@ module_param(psv, int, 0644);
 MODULE_PARM_DESC(psv, "Disable or override all passive trip points.");
 
 static int acpi_thermal_add(struct acpi_device *device);
-static int acpi_thermal_remove(struct acpi_device *device, int type);
+static int acpi_thermal_remove(struct acpi_device *device);
 static void acpi_thermal_notify(struct acpi_device *device, u32 event);
 
 static const struct acpi_device_id  thermal_device_ids[] = {
@@ -1111,7 +1111,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 	return result;
 }
 
-static int acpi_thermal_remove(struct acpi_device *device, int type)
+static int acpi_thermal_remove(struct acpi_device *device)
 {
 	struct acpi_thermal *tz = NULL;
 

commit ca4e713080dd7f23cd1cf5d3871e0b717ee9b254
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Jan 15 23:57:16 2013 +0100

    ACPI / thermal: Use mode to enable/disable kernel thermal processing
    
    As per documentation, "mode" sysfs interface should be able to
    enable/disable thermal processing in the kernel, so that user space
    is able to take more control.
    
    Currently, ACPI thermal driver is not following this setting, so
    modify it to match the interface documentation.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index f46c44048e44..dc047336cc37 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -531,6 +531,10 @@ static void acpi_thermal_check(void *data)
 {
 	struct acpi_thermal *tz = data;
 
+	if (!tz->tz_enabled) {
+		pr_warn("thermal zone is disabled \n");
+		return;
+	}
 	thermal_zone_device_update(tz->thermal_zone);
 }
 

commit 7e3cf246b532a640ff1176d0b988aa0a9338e36f
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Nov 29 11:53:16 2012 +0000

    ACPI thermal: remove unnecessary newline from exception message
    
    ACPI_EXCEPTION() already appends a newline, so there is no
    need for the thermal trip point message to include one too.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 506fbd4b5733..f46c44048e44 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -288,7 +288,7 @@ do {	\
 	if (flags != ACPI_TRIPS_INIT)	\
 		ACPI_EXCEPTION((AE_INFO, AE_ERROR,	\
 		"ACPI thermal trip point %s changed\n"	\
-		"Please send acpidump to linux-acpi@vger.kernel.org\n", str)); \
+		"Please send acpidump to linux-acpi@vger.kernel.org", str)); \
 } while (0)
 
 static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)

commit 50851c6248e1a13c45d97c41f6ebcf716093aa5e
Merge: 99b8f42ee2ab 1f53ef17d3ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 12 07:57:13 2012 -0800

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal management update from Zhang Rui:
     "Highlights:
    
       - Introduction of thermal policy support, together with three new
         thermal governors, including step_wise, user_space, fire_share.
    
       - Introduction of ST-Ericsson db8500_thermal driver and ST-Ericsson
         db8500_cpufreq_cooling driver.
    
       - Thermal Kconfig file and Makefile refactor.
    
       - Fixes for generic thermal layer, generic cpucooling, rcar thermal
         driver and Exynos thermal driver."
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (36 commits)
      Thermal: Fix DEFAULT_THERMAL_GOVERNOR
      Thermal: fix a NULL pointer dereference when generic thermal layer is built as a module
      thermal: rcar: add rcar_zone_to_priv() macro
      thermal: rcar: fixup the unit of temperature
      thermal: cpu cooling: allow module builds
      thermal: cpu cooling: use const parameter while registering
      Thermal: Add ST-Ericsson DB8500 thermal properties and platform data.
      Thermal: Add ST-Ericsson DB8500 thermal driver.
      drivers/thermal/Makefile refactor
      Exynos: Add missing dependency
      Refactor drivers/thermal/Kconfig
      thermal: cpu_cooling: Make 'notify_device' static
      Thermal: Remove the cooling_cpufreq_list.
      Thermal: fix bug of counting cpu frequencies.
      Thermal: add indent for code alignment.
      thermal: rcar_thermal: remove explicitly used devm_kfree/iounap()
      thermal: user_space: Add missing static storage class specifiers
      thermal: fair_share: Add missing static storage class specifiers
      thermal: step_wise: Add missing static storage class specifiers
      Thermal: Fix oops and unlocking in thermal_sys.c
      ...

commit 261cba2deb7d3bebd180c35d5dbf8961f6e9afc4
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Nov 27 20:42:11 2012 +0100

    ACPI / thermal: _TMP and _CRT/_HOT/_PSV/_ACx dependency fix
    
    On some platforms, _TMP and _CRT/_HOT/_PSV/_ACx have dependency.
    And there is no way for OS to detect this dependency.
    
    commit 9bcb8118965ab4631a65ee0726e6518f75cda6c5 shows us a problem
    that _TMP must be evaluate after _CRT/_HOT/_PSV/_ACx, or else
    firmware will shutdown the system.
    
    But the machine in https://bugzilla.kernel.org/show_bug.cgi?id=43284
    shows us that _PSV would return valid value only if _TMP has been
    evaluated once.
    
    With this patch, all of the control methods will be evaluated once,
    in the _CRT/_HOT/_PSV/_CRT/_TMP order, before they are actually used.
    
    [rjw: Added a local variable for the handle and modified the loop
     slightly.]
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: katabami <katabami@lavabit.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 804204d41999..6e8cc16b54c1 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -984,6 +984,38 @@ static void acpi_thermal_notify(struct acpi_device *device, u32 event)
 	}
 }
 
+/*
+ * On some platforms, the AML code has dependency about
+ * the evaluating order of _TMP and _CRT/_HOT/_PSV/_ACx.
+ * 1. On HP Pavilion G4-1016tx, _TMP must be invoked after
+ *    /_CRT/_HOT/_PSV/_ACx, or else system will be power off.
+ * 2. On HP Compaq 6715b/6715s, the return value of _PSV is 0
+ *    if _TMP has never been evaluated.
+ *
+ * As this dependency is totally transparent to OS, evaluate
+ * all of them once, in the order of _CRT/_HOT/_PSV/_ACx,
+ * _TMP, before they are actually used.
+ */
+static void acpi_thermal_aml_dependency_fix(struct acpi_thermal *tz)
+{
+	acpi_handle handle = tz->device->handle;
+	unsigned long long value;
+	int i;
+
+	acpi_evaluate_integer(handle, "_CRT", NULL, &value);
+	acpi_evaluate_integer(handle, "_HOT", NULL, &value);
+	acpi_evaluate_integer(handle, "_PSV", NULL, &value);
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
+		char name[5] = { '_', 'A', 'C', ('0' + i), '\0' };
+		acpi_status status;
+
+		status = acpi_evaluate_integer(handle, name, NULL, &value);
+		if (status == AE_NOT_FOUND)
+			break;
+	}
+	acpi_evaluate_integer(handle, "_TMP", NULL, &value);
+}
+
 static int acpi_thermal_get_info(struct acpi_thermal *tz)
 {
 	int result = 0;
@@ -992,6 +1024,8 @@ static int acpi_thermal_get_info(struct acpi_thermal *tz)
 	if (!tz)
 		return -EINVAL;
 
+	acpi_thermal_aml_dependency_fix(tz);
+
 	/* Get trip points [_CRT, _PSV, etc.] (required) */
 	result = acpi_thermal_get_trip_points(tz);
 	if (result)

commit 50125a9b27dd09e9afdc1b8712ba0b3859886c68
Author: Durgadoss R <durgadoss.r@intel.com>
Date:   Tue Sep 18 11:04:56 2012 +0530

    Thermal: Pass zone parameters as argument to tzd_register
    
    This patch adds the thermal zone parameter as an argument to
    the tzd_register() function call; and updates other drivers
    using this function.
    
    Signed-off-by: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 804204d41999..1794468223c4 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -900,14 +900,14 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 	if (tz->trips.passive.flags.valid)
 		tz->thermal_zone =
 			thermal_zone_device_register("acpitz", trips, 0, tz,
-						     &acpi_thermal_zone_ops,
+						&acpi_thermal_zone_ops, NULL,
 						     tz->trips.passive.tsp*100,
 						     tz->polling_frequency*100);
 	else
 		tz->thermal_zone =
 			thermal_zone_device_register("acpitz", trips, 0, tz,
-						     &acpi_thermal_zone_ops, 0,
-						     tz->polling_frequency*100);
+						&acpi_thermal_zone_ops, NULL,
+						0, tz->polling_frequency*100);
 	if (IS_ERR(tz->thermal_zone))
 		return -ENODEV;
 

commit 29b19e250434c6193c8b8e4c34c9c6284dd4f101
Merge: 125c4c706b68 c072fed95c98
Author: Len Brown <len.brown@intel.com>
Date:   Tue Oct 9 01:35:52 2012 -0400

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux into thermal
    
    Conflicts:
            drivers/staging/omap-thermal/omap-thermal-common.
                    OMAP supplied dummy TC1 and TC2,
                    at the same time that the thermal tree removed them
                    from thermal_zone_device_register()
    
            drivers/thermal/cpu_cooling.c b/drivers/thermal/cpu_cooling.c
                    propogate the upstream MAX_IDR_LEVEL re-name
                            to prevent a build failure
    
            Previously-fixed-by: Stephen Rothwell <sfr@canb.auug.org.au>
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 4ae46befb49d4173122e0afa995c4e93d01948a2
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Jun 27 10:05:39 2012 +0800

    Thermal: Introduce thermal_zone_trip_update()
    
    This function is used to update the cooling state of
    all the cooling devices that are bound to an active trip point.
    
    This will be used for passive cooling as well, in the future patches.
    as both active and passive cooling can share the same algorithm,
    which is
    
    1. if the temperature is higher than a trip point,
       a. if the trend is THERMAL_TREND_RAISING, use higher cooling
          state for this trip point
       b. if the trend is THERMAL_TREND_DROPPING, use lower cooling
          state for this trip point
    
    2. if the temperature is lower than a trip point, use lower
       cooling state for this trip point.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Eduardo Valentin <eduardo.valentin@ti.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 07cb2172bd09..bd66bd28a43f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -716,9 +716,11 @@ static int thermal_get_trend(struct thermal_zone_device *thermal,
 	if (thermal_get_trip_type(thermal, trip, &type))
 		return -EINVAL;
 
-	/* Only PASSIVE trip points need TREND */
-	if (type != THERMAL_TRIP_PASSIVE)
-		return -EINVAL;
+	if (type == THERMAL_TRIP_ACTIVE) {
+		/* aggressive active cooling */
+		*trend = THERMAL_TREND_RAISING;
+		return 0;
+	}
 
 	/*
 	 * tz->temperature has already been updated by generic thermal layer,

commit 1b7ddb840c3908464b19d4aa4f6dc4c463302442
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Jun 27 09:51:12 2012 +0800

    Thermal: Remove tc1/tc2 in generic thermal layer.
    
    Remove tc1/tc2 in generic thermal layer.
    .get_trend() callback starts to take effect from this patch.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Valentin, Eduardo <eduardo.valentin@ti.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index bb95709a6be8..07cb2172bd09 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -897,15 +897,12 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 		tz->thermal_zone =
 			thermal_zone_device_register("acpitz", trips, 0, tz,
 						     &acpi_thermal_zone_ops,
-						     tz->trips.passive.tc1,
-						     tz->trips.passive.tc2,
 						     tz->trips.passive.tsp*100,
 						     tz->polling_frequency*100);
 	else
 		tz->thermal_zone =
 			thermal_zone_device_register("acpitz", trips, 0, tz,
-						     &acpi_thermal_zone_ops,
-						     0, 0, 0,
+						     &acpi_thermal_zone_ops, 0,
 						     tz->polling_frequency*100);
 	if (IS_ERR(tz->thermal_zone))
 		return -ENODEV;

commit 601f3d4242be6ed6f72a2aadabc91e8255dad811
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Jun 27 09:54:33 2012 +0800

    Thermal: Introduce .get_trend() callback.
    
    According to ACPI spec, tc1 and tc2 are used by OSPM
    to anticipate the temperature trends.
    We introduced the same concept to the generic thermal layer
    for passive cooling, but now it seems that these values
    are hard to be used on other platforms.
    
    So We introduce .get_trend() as a more general solution.
    
    For the platform thermal drivers that have their own way to
    anticipate the temperature trends, they should provide
    their own .get_trend() callback.
    Or else, we will calculate the temperature trends by simply
    comparing the current temperature and the cached previous
    temperature reading.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Valentin, Eduardo <eduardo.valentin@ti.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index d7ef69d835f2..bb95709a6be8 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -706,6 +706,38 @@ static int thermal_get_crit_temp(struct thermal_zone_device *thermal,
 		return -EINVAL;
 }
 
+static int thermal_get_trend(struct thermal_zone_device *thermal,
+				int trip, enum thermal_trend *trend)
+{
+	struct acpi_thermal *tz = thermal->devdata;
+	enum thermal_trip_type type;
+	int i;
+
+	if (thermal_get_trip_type(thermal, trip, &type))
+		return -EINVAL;
+
+	/* Only PASSIVE trip points need TREND */
+	if (type != THERMAL_TRIP_PASSIVE)
+		return -EINVAL;
+
+	/*
+	 * tz->temperature has already been updated by generic thermal layer,
+	 * before this callback being invoked
+	 */
+	i = (tz->trips.passive.tc1 * (tz->temperature - tz->last_temperature))
+		+ (tz->trips.passive.tc2
+		* (tz->temperature - tz->trips.passive.temperature));
+
+	if (i > 0)
+		*trend = THERMAL_TREND_RAISING;
+	else if (i < 0)
+		*trend = THERMAL_TREND_DROPPING;
+	else
+		*trend = THERMAL_TREND_STABLE;
+	return 0;
+}
+
+
 static int thermal_notify(struct thermal_zone_device *thermal, int trip,
 			   enum thermal_trip_type trip_type)
 {
@@ -838,6 +870,7 @@ static const struct thermal_zone_device_ops acpi_thermal_zone_ops = {
 	.get_trip_type = thermal_get_trip_type,
 	.get_trip_temp = thermal_get_trip_temp,
 	.get_crit_temp = thermal_get_crit_temp,
+	.get_trend = thermal_get_trend,
 	.notify = thermal_notify,
 };
 

commit 9d99842f99d847191ebd0c28469d2c70fcc5bf9e
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jun 26 16:35:57 2012 +0800

    Thermal: set upper and lower limits
    
    set upper and lower limits when binding
    a thermal cooling device to a thermal zone device.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Eduardo Valentin <eduardo.valentin@ti.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 9fe90e9fecb5..d7ef69d835f2 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -729,11 +729,9 @@ static int thermal_notify(struct thermal_zone_device *thermal, int trip,
 	return 0;
 }
 
-typedef int (*cb)(struct thermal_zone_device *, int,
-		  struct thermal_cooling_device *);
 static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 					struct thermal_cooling_device *cdev,
-					cb action)
+					bool bind)
 {
 	struct acpi_device *device = cdev->devdata;
 	struct acpi_thermal *tz = thermal->devdata;
@@ -757,11 +755,19 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 		    i++) {
 			handle = tz->trips.passive.devices.handles[i];
 			status = acpi_bus_get_device(handle, &dev);
-			if (ACPI_SUCCESS(status) && (dev == device)) {
-				result = action(thermal, trip, cdev);
-				if (result)
-					goto failed;
-			}
+			if (ACPI_FAILURE(status) || dev != device)
+				continue;
+			if (bind)
+				result =
+					thermal_zone_bind_cooling_device
+					(thermal, trip, cdev,
+					 THERMAL_NO_LIMIT, THERMAL_NO_LIMIT);
+			else
+				result =
+					thermal_zone_unbind_cooling_device
+					(thermal, trip, cdev);
+			if (result)
+				goto failed;
 		}
 	}
 
@@ -774,11 +780,17 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 		    j++) {
 			handle = tz->trips.active[i].devices.handles[j];
 			status = acpi_bus_get_device(handle, &dev);
-			if (ACPI_SUCCESS(status) && (dev == device)) {
-				result = action(thermal, trip, cdev);
-				if (result)
-					goto failed;
-			}
+			if (ACPI_FAILURE(status) || dev != device)
+				continue;
+			if (bind)
+				result = thermal_zone_bind_cooling_device
+					(thermal, trip, cdev,
+					 THERMAL_NO_LIMIT, THERMAL_NO_LIMIT);
+			else
+				result = thermal_zone_unbind_cooling_device
+					(thermal, trip, cdev);
+			if (result)
+				goto failed;
 		}
 	}
 
@@ -786,7 +798,14 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 		handle = tz->devices.handles[i];
 		status = acpi_bus_get_device(handle, &dev);
 		if (ACPI_SUCCESS(status) && (dev == device)) {
-			result = action(thermal, -1, cdev);
+			if (bind)
+				result = thermal_zone_bind_cooling_device
+						(thermal, -1, cdev,
+						 THERMAL_NO_LIMIT,
+						 THERMAL_NO_LIMIT);
+			else
+				result = thermal_zone_unbind_cooling_device
+						(thermal, -1, cdev);
 			if (result)
 				goto failed;
 		}
@@ -800,16 +819,14 @@ static int
 acpi_thermal_bind_cooling_device(struct thermal_zone_device *thermal,
 					struct thermal_cooling_device *cdev)
 {
-	return acpi_thermal_cooling_device_cb(thermal, cdev,
-				thermal_zone_bind_cooling_device);
+	return acpi_thermal_cooling_device_cb(thermal, cdev, true);
 }
 
 static int
 acpi_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,
 					struct thermal_cooling_device *cdev)
 {
-	return acpi_thermal_cooling_device_cb(thermal, cdev,
-				thermal_zone_unbind_cooling_device);
+	return acpi_thermal_cooling_device_cb(thermal, cdev, false);
 }
 
 static const struct thermal_zone_device_ops acpi_thermal_zone_ops = {

commit 9069240480e24a2d6ce23404c9ad6cabf59b7258
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 9 23:00:02 2012 +0200

    ACPI / PM: Fix unused function warnings for CONFIG_PM_SLEEP
    
    According to compiler warnings, several suspend/resume functions
    in ACPI drivers are not used for CONFIG_PM_SLEEP unset, so add
    #ifdefs to prevent them from being built in that case.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 9fe90e9fecb5..edda74a43406 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -106,7 +106,9 @@ static const struct acpi_device_id  thermal_device_ids[] = {
 };
 MODULE_DEVICE_TABLE(acpi, thermal_device_ids);
 
+#ifdef CONFIG_PM_SLEEP
 static int acpi_thermal_resume(struct device *dev);
+#endif
 static SIMPLE_DEV_PM_OPS(acpi_thermal_pm, NULL, acpi_thermal_resume);
 
 static struct acpi_driver acpi_thermal_driver = {
@@ -1041,6 +1043,7 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
 static int acpi_thermal_resume(struct device *dev)
 {
 	struct acpi_thermal *tz;
@@ -1075,6 +1078,7 @@ static int acpi_thermal_resume(struct device *dev)
 
 	return AE_OK;
 }
+#endif
 
 static int thermal_act(const struct dmi_system_id *d) {
 

commit 476525004ac7e2f990b6956efcd44d0780c2ab4c
Merge: bd22dc17e499 ec033d0a0290
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 14:28:55 2012 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux
    
    Pull ACPI & power management update from Len Brown:
     "Re-write of the turbostat tool.
         lower overhead was necessary for measuring very large system when
         they are very idle.
    
      IVB support in intel_idle
         It's what I run on my IVB, others should be able to also:-)
    
      ACPICA core update
         We have found some bugs due to divergence between Linux and the
         upstream ACPICA base.  Most of these patches are to reduce that
         divergence to reduce the risk of future bugs.
    
      Some cpuidle updates, mostly for non-Intel
         More will be coming, as they depend on this part.
    
      Some thermal management changes needed by non-ACPI systems.
    
      Some _OST (OS Status Indication) updates for hot ACPI hot-plug."
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux: (51 commits)
      Thermal: Documentation update
      Thermal: Add Hysteresis attributes
      Thermal: Make Thermal trip points writeable
      ACPI/AC: prevent OOPS on some boxes due to missing check power_supply_register() return value check
      tools/power: turbostat: fix large c1% issue
      tools/power: turbostat v2 - re-write for efficiency
      ACPICA: Update to version 20120711
      ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
      ACPICA: Update header files copyrights to 2012
      ACPICA: Add new ACPI table load/unload external interfaces
      ACPICA: Split file: tbxface.c -> tbxfload.c
      ACPICA: Add PCC address space to space ID decode function
      ACPICA: Fix some comment fields
      ACPICA: Table manager: deploy new firmware error/warning interfaces
      ACPICA: Add new interfaces for BIOS(firmware) errors and warnings
      ACPICA: Split exception code utilities to a new file, utexcep.c
      ACPI: acpi_pad: tune round_robin_time
      ACPICA: Update to version 20120620
      ACPICA: Add support for implicit notify on multiple devices
      ACPICA: Update comments; no functional change
      ...

commit 8eaa8d6ca27788aa23659082362a608c1fabcdfe
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Jul 25 10:11:00 2012 +0800

    Thermal: Documentation update
    
    With commit 6503e5df08008b9a47022b5e9ebba658c8fa69af,
    the value of /sys/class/thermal/thermal_zoneX/mode has been changed
    from user/kernel to enabled/disabled.
    Update the documentation so that users won't be confused.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 2107d1bb84af..8275e7b06962 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -550,8 +550,6 @@ static int thermal_get_temp(struct thermal_zone_device *thermal,
 	return 0;
 }
 
-static const char enabled[] = "kernel";
-static const char disabled[] = "user";
 static int thermal_get_mode(struct thermal_zone_device *thermal,
 				enum thermal_device_mode *mode)
 {
@@ -588,8 +586,8 @@ static int thermal_set_mode(struct thermal_zone_device *thermal,
 	if (enable != tz->tz_enabled) {
 		tz->tz_enabled = enable;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"%s ACPI thermal control\n",
-			tz->tz_enabled ? enabled : disabled));
+			"%s kernel ACPI thermal control\n",
+			tz->tz_enabled ? "Enable" : "Disable"));
 		acpi_thermal_check(tz);
 	}
 	return 0;

commit c56f5c0342dfee11a1a13d2f5bb7618de5b17590
Author: Durgadoss R <dugardoss.r@intel.com>
Date:   Wed Jul 25 10:10:58 2012 +0800

    Thermal: Make Thermal trip points writeable
    
    Some of the thermal drivers using the Generic Thermal Framework
    require (all/some) trip points to be writeable. This patch makes
    the trip point temperatures writeable on a per-trip point basis,
    and modifies the required function call in thermal.c. This patch
    also updates the Documentation to reflect the new change.
    
    Signed-off-by: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 7dbebea1ec31..2107d1bb84af 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -845,7 +845,7 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 
 	if (tz->trips.passive.flags.valid)
 		tz->thermal_zone =
-			thermal_zone_device_register("acpitz", trips, tz,
+			thermal_zone_device_register("acpitz", trips, 0, tz,
 						     &acpi_thermal_zone_ops,
 						     tz->trips.passive.tc1,
 						     tz->trips.passive.tc2,
@@ -853,7 +853,7 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 						     tz->polling_frequency*100);
 	else
 		tz->thermal_zone =
-			thermal_zone_device_register("acpitz", trips, tz,
+			thermal_zone_device_register("acpitz", trips, 0, tz,
 						     &acpi_thermal_zone_ops,
 						     0, 0, 0,
 						     tz->polling_frequency*100);

commit 167cffb646aa4a7f3267b07eae1af16b54bc0e9b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 27 23:26:18 2012 +0200

    ACPI: Use struct dev_pm_ops for power management in the thermal driver
    
    Make the ACPI thermal driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct acpi_device_ops.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 7dbebea1ec31..21dd4c268aef 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -98,7 +98,6 @@ MODULE_PARM_DESC(psv, "Disable or override all passive trip points.");
 
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);
-static int acpi_thermal_resume(struct acpi_device *device);
 static void acpi_thermal_notify(struct acpi_device *device, u32 event);
 
 static const struct acpi_device_id  thermal_device_ids[] = {
@@ -107,6 +106,9 @@ static const struct acpi_device_id  thermal_device_ids[] = {
 };
 MODULE_DEVICE_TABLE(acpi, thermal_device_ids);
 
+static int acpi_thermal_resume(struct device *dev);
+static SIMPLE_DEV_PM_OPS(acpi_thermal_pm, NULL, acpi_thermal_resume);
+
 static struct acpi_driver acpi_thermal_driver = {
 	.name = "thermal",
 	.class = ACPI_THERMAL_CLASS,
@@ -114,9 +116,9 @@ static struct acpi_driver acpi_thermal_driver = {
 	.ops = {
 		.add = acpi_thermal_add,
 		.remove = acpi_thermal_remove,
-		.resume = acpi_thermal_resume,
 		.notify = acpi_thermal_notify,
 		},
+	.drv.pm = &acpi_thermal_pm,
 };
 
 struct acpi_thermal_state {
@@ -1041,16 +1043,17 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
-static int acpi_thermal_resume(struct acpi_device *device)
+static int acpi_thermal_resume(struct device *dev)
 {
-	struct acpi_thermal *tz = NULL;
+	struct acpi_thermal *tz;
 	int i, j, power_state, result;
 
-
-	if (!device || !acpi_driver_data(device))
+	if (!dev)
 		return -EINVAL;
 
-	tz = acpi_driver_data(device);
+	tz = acpi_driver_data(to_acpi_device(dev));
+	if (!tz)
+		return -EINVAL;
 
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
 		if (!(&tz->trips.active[i]))

commit 9bcb8118965ab4631a65ee0726e6518f75cda6c5
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Feb 1 10:26:54 2012 -0500

    ACPI: Evaluate thermal trip points before reading temperature
    
    An HP laptop (Pavilion G4-1016tx) has the following code in _TMP:
    
           Store (\_SB.PCI0.LPCB.EC0.RTMP, Local0)
           If (LGreaterEqual (Local0, S4TP))
           {
               Store (One, HTS4)
           }
    
    S4TP is initialised at 0 and not programmed further until either _HOT or
    _CRT is called. If we evaluate _TMP before the trip points then HTS4 will
    always be set, causing the firmware to generate a message on boot
    complaining that the system shut down because of overheating. The simplest
    solution is just to reverse the checking of trip points and _TMP in thermal
    init.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 48fbc647b178..7dbebea1ec31 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -941,13 +941,13 @@ static int acpi_thermal_get_info(struct acpi_thermal *tz)
 	if (!tz)
 		return -EINVAL;
 
-	/* Get temperature [_TMP] (required) */
-	result = acpi_thermal_get_temperature(tz);
+	/* Get trip points [_CRT, _PSV, etc.] (required) */
+	result = acpi_thermal_get_trip_points(tz);
 	if (result)
 		return result;
 
-	/* Get trip points [_CRT, _PSV, etc.] (required) */
-	result = acpi_thermal_get_trip_points(tz);
+	/* Get temperature [_TMP] (required) */
+	result = acpi_thermal_get_temperature(tz);
 	if (result)
 		return result;
 

commit 9c8b04be443b33939f374a811c82abeebe0a61d1
Author: Vasiliy Kulikov <segoon@openwall.com>
Date:   Sat Jun 25 21:07:52 2011 +0400

    ACPI: constify ops structs
    
    Structs battery_file, acpi_dock_ops, file_operations,
    thermal_cooling_device_ops, thermal_zone_device_ops, kernel_param_ops
    are not changed in runtime.  It is safe to make them const.
    register_hotplug_dock_device() was altered to take const "ops" argument
    to respect acpi_dock_ops' const notion.
    
    Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 2607e17b520f..48fbc647b178 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -812,7 +812,7 @@ acpi_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,
 				thermal_zone_unbind_cooling_device);
 }
 
-static struct thermal_zone_device_ops acpi_thermal_zone_ops = {
+static const struct thermal_zone_device_ops acpi_thermal_zone_ops = {
 	.bind = acpi_thermal_bind_cooling_device,
 	.unbind	= acpi_thermal_unbind_cooling_device,
 	.get_temp = thermal_get_temp,

commit 488a76c52606199100adf09c8eb7cbedbd94e9d9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:11:24 2010 +0100

    ACPI / Fan: Rework the handling of power resources
    
    Use the new function acpi_bus_update_power() for manipulating power
    resources used by ACPI fan devices, which allows them to be put into
    the right state during initialization and resume.  Consequently,
    remove the flags.force_power_state field from struct acpi_device,
    which is not necessary any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5a27b0a31315..2607e17b520f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1059,8 +1059,9 @@ static int acpi_thermal_resume(struct acpi_device *device)
 			break;
 		tz->trips.active[i].flags.enabled = 1;
 		for (j = 0; j < tz->trips.active[i].devices.count; j++) {
-			result = acpi_bus_get_power(tz->trips.active[i].devices.
-			    handles[j], &power_state);
+			result = acpi_bus_update_power(
+					tz->trips.active[i].devices.handles[j],
+					&power_state);
 			if (result || (power_state != ACPI_STATE_D0)) {
 				tz->trips.active[i].flags.enabled = 0;
 				break;

commit c57b62f5b1e6dd69ff8c96f6db7f86ea31c0e21f
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Oct 8 13:55:06 2010 +0800

    ACPI thermal: remove deprecated procfs I/F
    
    Remove the deprecated ACPI thermal driver procfs I/F,
    as stated in the changelog of commit 43d9f87b79804f2d75d9d8a81c862b179f055a15
    
    sysfs I/F is available at /sys/class/thermal/thermal_zoneX/
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 2f8f17131d9f..5a27b0a31315 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -37,12 +37,6 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/types.h>
-
-#ifdef CONFIG_ACPI_PROCFS
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#endif
-
 #include <linux/jiffies.h>
 #include <linux/kmod.h>
 #include <linux/reboot.h>
@@ -195,61 +189,6 @@ struct acpi_thermal {
 	struct mutex lock;
 };
 
-#ifdef CONFIG_ACPI_PROCFS
-static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_cooling_mode(struct file *,
-					       const char __user *, size_t,
-					       loff_t *);
-static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_polling(struct file *, const char __user *,
-					  size_t, loff_t *);
-
-static const struct file_operations acpi_thermal_state_fops = {
-	.owner = THIS_MODULE,
-	.open = acpi_thermal_state_open_fs,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations acpi_thermal_temp_fops = {
-	.owner = THIS_MODULE,
-	.open = acpi_thermal_temp_open_fs,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations acpi_thermal_trip_fops = {
-	.owner = THIS_MODULE,
-	.open = acpi_thermal_trip_open_fs,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations acpi_thermal_cooling_fops = {
-	.owner = THIS_MODULE,
-	.open = acpi_thermal_cooling_open_fs,
-	.read = seq_read,
-	.write = acpi_thermal_write_cooling_mode,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations acpi_thermal_polling_fops = {
-	.owner = THIS_MODULE,
-	.open = acpi_thermal_polling_open_fs,
-	.read = seq_read,
-	.write = acpi_thermal_write_polling,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-#endif /* CONFIG_ACPI_PROCFS*/
-
 /* --------------------------------------------------------------------------
                              Thermal Zone Management
    -------------------------------------------------------------------------- */
@@ -957,358 +896,6 @@ static void acpi_thermal_unregister_thermal_zone(struct acpi_thermal *tz)
 }
 
 
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-#ifdef CONFIG_ACPI_PROCFS
-static struct proc_dir_entry *acpi_thermal_dir;
-
-static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_thermal *tz = seq->private;
-
-
-	if (!tz)
-		goto end;
-
-	seq_puts(seq, "state:                   ");
-
-	if (!tz->state.critical && !tz->state.hot && !tz->state.passive
-	    && !tz->state.active)
-		seq_puts(seq, "ok\n");
-	else {
-		if (tz->state.critical)
-			seq_puts(seq, "critical ");
-		if (tz->state.hot)
-			seq_puts(seq, "hot ");
-		if (tz->state.passive)
-			seq_puts(seq, "passive ");
-		if (tz->state.active)
-			seq_printf(seq, "active[%d]", tz->state.active_index);
-		seq_puts(seq, "\n");
-	}
-
-      end:
-	return 0;
-}
-
-static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_thermal_state_seq_show, PDE(inode)->data);
-}
-
-static int acpi_thermal_temp_seq_show(struct seq_file *seq, void *offset)
-{
-	int result = 0;
-	struct acpi_thermal *tz = seq->private;
-
-
-	if (!tz)
-		goto end;
-
-	result = acpi_thermal_get_temperature(tz);
-	if (result)
-		goto end;
-
-	seq_printf(seq, "temperature:             %ld C\n",
-		   KELVIN_TO_CELSIUS(tz->temperature));
-
-      end:
-	return 0;
-}
-
-static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_thermal_temp_seq_show, PDE(inode)->data);
-}
-
-static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_thermal *tz = seq->private;
-	struct acpi_device *device;
-	acpi_status status;
-
-	int i = 0;
-	int j = 0;
-
-
-	if (!tz)
-		goto end;
-
-	if (tz->trips.critical.flags.valid)
-		seq_printf(seq, "critical (S5):           %ld C%s",
-			   KELVIN_TO_CELSIUS(tz->trips.critical.temperature),
-			   nocrt ? " <disabled>\n" : "\n");
-
-	if (tz->trips.hot.flags.valid)
-		seq_printf(seq, "hot (S4):                %ld C%s",
-			   KELVIN_TO_CELSIUS(tz->trips.hot.temperature),
-			   nocrt ? " <disabled>\n" : "\n");
-
-	if (tz->trips.passive.flags.valid) {
-		seq_printf(seq,
-			   "passive:                 %ld C: tc1=%lu tc2=%lu tsp=%lu devices=",
-			   KELVIN_TO_CELSIUS(tz->trips.passive.temperature),
-			   tz->trips.passive.tc1, tz->trips.passive.tc2,
-			   tz->trips.passive.tsp);
-		for (j = 0; j < tz->trips.passive.devices.count; j++) {
-			status = acpi_bus_get_device(tz->trips.passive.devices.
-						     handles[j], &device);
-			seq_printf(seq, "%4.4s ", status ? "" :
-				   acpi_device_bid(device));
-		}
-		seq_puts(seq, "\n");
-	} else {
-		seq_printf(seq, "passive (forced):");
-		if (tz->thermal_zone->forced_passive)
-			seq_printf(seq, "        %i C\n",
-				   tz->thermal_zone->forced_passive / 1000);
-		else
-			seq_printf(seq, "<not set>\n");
-	}
-
-	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
-		if (!(tz->trips.active[i].flags.valid))
-			break;
-		seq_printf(seq, "active[%d]:               %ld C: devices=",
-			   i,
-			   KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
-		for (j = 0; j < tz->trips.active[i].devices.count; j++){
-			status = acpi_bus_get_device(tz->trips.active[i].
-						     devices.handles[j],
-						     &device);
-			seq_printf(seq, "%4.4s ", status ? "" :
-				   acpi_device_bid(device));
-		}
-		seq_puts(seq, "\n");
-	}
-
-      end:
-	return 0;
-}
-
-static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_thermal_trip_seq_show, PDE(inode)->data);
-}
-
-static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_thermal *tz = seq->private;
-
-
-	if (!tz)
-		goto end;
-
-	if (!tz->flags.cooling_mode)
-		seq_puts(seq, "<setting not supported>\n");
-	else
-		seq_puts(seq, "0 - Active; 1 - Passive\n");
-
-      end:
-	return 0;
-}
-
-static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_thermal_cooling_seq_show,
-			   PDE(inode)->data);
-}
-
-static ssize_t
-acpi_thermal_write_cooling_mode(struct file *file,
-				const char __user * buffer,
-				size_t count, loff_t * ppos)
-{
-	struct seq_file *m = file->private_data;
-	struct acpi_thermal *tz = m->private;
-	int result = 0;
-	char mode_string[12] = { '\0' };
-
-
-	if (!tz || (count > sizeof(mode_string) - 1))
-		return -EINVAL;
-
-	if (!tz->flags.cooling_mode)
-		return -ENODEV;
-
-	if (copy_from_user(mode_string, buffer, count))
-		return -EFAULT;
-
-	mode_string[count] = '\0';
-
-	result = acpi_thermal_set_cooling_mode(tz,
-					       simple_strtoul(mode_string, NULL,
-							      0));
-	if (result)
-		return result;
-
-	acpi_thermal_check(tz);
-
-	return count;
-}
-
-static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_thermal *tz = seq->private;
-
-
-	if (!tz)
-		goto end;
-
-	if (!tz->thermal_zone->polling_delay) {
-		seq_puts(seq, "<polling disabled>\n");
-		goto end;
-	}
-
-	seq_printf(seq, "polling frequency:       %d seconds\n",
-		   (tz->thermal_zone->polling_delay / 1000));
-
-      end:
-	return 0;
-}
-
-static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_thermal_polling_seq_show,
-			   PDE(inode)->data);
-}
-
-static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
-{
-	if (!tz)
-		return -EINVAL;
-
-	/* Convert value to deci-seconds */
-	tz->polling_frequency = seconds * 10;
-
-	tz->thermal_zone->polling_delay = seconds * 1000;
-
-	if (tz->tz_enabled)
-		thermal_zone_device_update(tz->thermal_zone);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			  "Polling frequency set to %lu seconds\n",
-			  tz->polling_frequency/10));
-
-	return 0;
-}
-
-static ssize_t
-acpi_thermal_write_polling(struct file *file,
-			   const char __user * buffer,
-			   size_t count, loff_t * ppos)
-{
-	struct seq_file *m = file->private_data;
-	struct acpi_thermal *tz = m->private;
-	int result = 0;
-	char polling_string[12] = { '\0' };
-	int seconds = 0;
-
-
-	if (!tz || (count > sizeof(polling_string) - 1))
-		return -EINVAL;
-
-	if (copy_from_user(polling_string, buffer, count))
-		return -EFAULT;
-
-	polling_string[count] = '\0';
-
-	seconds = simple_strtoul(polling_string, NULL, 0);
-
-	result = acpi_thermal_set_polling(tz, seconds);
-	if (result)
-		return result;
-
-	acpi_thermal_check(tz);
-
-	return count;
-}
-
-static int acpi_thermal_add_fs(struct acpi_device *device)
-{
-	struct proc_dir_entry *entry = NULL;
-
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-						     acpi_thermal_dir);
-		if (!acpi_device_dir(device))
-			return -ENODEV;
-	}
-
-	/* 'state' [R] */
-	entry = proc_create_data(ACPI_THERMAL_FILE_STATE,
-				 S_IRUGO, acpi_device_dir(device),
-				 &acpi_thermal_state_fops,
-				 acpi_driver_data(device));
-	if (!entry)
-		return -ENODEV;
-
-	/* 'temperature' [R] */
-	entry = proc_create_data(ACPI_THERMAL_FILE_TEMPERATURE,
-				 S_IRUGO, acpi_device_dir(device),
-				 &acpi_thermal_temp_fops,
-				 acpi_driver_data(device));
-	if (!entry)
-		return -ENODEV;
-
-	/* 'trip_points' [R] */
-	entry = proc_create_data(ACPI_THERMAL_FILE_TRIP_POINTS,
-				 S_IRUGO,
-				 acpi_device_dir(device),
-				 &acpi_thermal_trip_fops,
-				 acpi_driver_data(device));
-	if (!entry)
-		return -ENODEV;
-
-	/* 'cooling_mode' [R/W] */
-	entry = proc_create_data(ACPI_THERMAL_FILE_COOLING_MODE,
-				 S_IFREG | S_IRUGO | S_IWUSR,
-				 acpi_device_dir(device),
-				 &acpi_thermal_cooling_fops,
-				 acpi_driver_data(device));
-	if (!entry)
-		return -ENODEV;
-
-	/* 'polling_frequency' [R/W] */
-	entry = proc_create_data(ACPI_THERMAL_FILE_POLLING_FREQ,
-				 S_IFREG | S_IRUGO | S_IWUSR,
-				 acpi_device_dir(device),
-				 &acpi_thermal_polling_fops,
-				 acpi_driver_data(device));
-	if (!entry)
-		return -ENODEV;
-	return 0;
-}
-
-static int acpi_thermal_remove_fs(struct acpi_device *device)
-{
-
-	if (acpi_device_dir(device)) {
-		remove_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
-				  acpi_device_dir(device));
-		remove_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
-				  acpi_device_dir(device));
-		remove_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
-				  acpi_device_dir(device));
-		remove_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
-				  acpi_device_dir(device));
-		remove_proc_entry(ACPI_THERMAL_FILE_STATE,
-				  acpi_device_dir(device));
-		remove_proc_entry(acpi_device_bid(device), acpi_thermal_dir);
-		acpi_device_dir(device) = NULL;
-	}
-
-	return 0;
-}
-#else
-static inline int acpi_thermal_add_fs(struct acpi_device *device) { return 0; }
-static inline int acpi_thermal_remove_fs(struct acpi_device *device)
-{
-	return 0;
-}
-#endif /* CONFIG_ACPI_PROCFS */
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -1428,17 +1015,11 @@ static int acpi_thermal_add(struct acpi_device *device)
 	if (result)
 		goto free_memory;
 
-	result = acpi_thermal_add_fs(device);
-	if (result)
-		goto unregister_thermal_zone;
-
 	printk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",
 	       acpi_device_name(device), acpi_device_bid(device),
 	       KELVIN_TO_CELSIUS(tz->temperature));
 	goto end;
 
-unregister_thermal_zone:
-	thermal_zone_device_unregister(tz->thermal_zone);
 free_memory:
 	kfree(tz);
 end:
@@ -1454,7 +1035,6 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 
 	tz = acpi_driver_data(device);
 
-	acpi_thermal_remove_fs(device);
 	acpi_thermal_unregister_thermal_zone(tz);
 	mutex_destroy(&tz->lock);
 	kfree(tz);
@@ -1580,19 +1160,9 @@ static int __init acpi_thermal_init(void)
 		return -ENODEV;
 	}
 
-#ifdef CONFIG_ACPI_PROCFS
-	acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, acpi_root_dir);
-	if (!acpi_thermal_dir)
-		return -ENODEV;
-#endif
-
 	result = acpi_bus_register_driver(&acpi_thermal_driver);
-	if (result < 0) {
-#ifdef CONFIG_ACPI_PROCFS
-		remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
-#endif
+	if (result < 0)
 		return -ENODEV;
-	}
 
 	return 0;
 }
@@ -1602,10 +1172,6 @@ static void __exit acpi_thermal_exit(void)
 
 	acpi_bus_unregister_driver(&acpi_thermal_driver);
 
-#ifdef CONFIG_ACPI_PROCFS
-	remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
-#endif
-
 	return;
 }
 

commit 43d9f87b79804f2d75d9d8a81c862b179f055a15
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jul 15 10:46:44 2010 +0800

    ACPI thermal: make procfs I/F depend on CONFIG_ACPI_PROCFS
    
    Mark the ACPI thermal procfs I/F deprecated, because /sys/class/thermal/
    is already available and has been working for years w/o any problem.
    
    The ACPI thermal procfs I/F will be removed in 2.6.37.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index efad1f33aeb5..2f8f17131d9f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -37,10 +37,14 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+
+#ifdef CONFIG_ACPI_PROCFS
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#endif
+
 #include <linux/jiffies.h>
 #include <linux/kmod.h>
-#include <linux/seq_file.h>
 #include <linux/reboot.h>
 #include <linux/device.h>
 #include <asm/uaccess.h>
@@ -102,16 +106,6 @@ static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);
 static int acpi_thermal_resume(struct acpi_device *device);
 static void acpi_thermal_notify(struct acpi_device *device, u32 event);
-static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_cooling_mode(struct file *,
-					       const char __user *, size_t,
-					       loff_t *);
-static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_polling(struct file *, const char __user *,
-					  size_t, loff_t *);
 
 static const struct acpi_device_id  thermal_device_ids[] = {
 	{ACPI_THERMAL_HID, 0},
@@ -201,6 +195,18 @@ struct acpi_thermal {
 	struct mutex lock;
 };
 
+#ifdef CONFIG_ACPI_PROCFS
+static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
+static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
+static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
+static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file);
+static ssize_t acpi_thermal_write_cooling_mode(struct file *,
+					       const char __user *, size_t,
+					       loff_t *);
+static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file);
+static ssize_t acpi_thermal_write_polling(struct file *, const char __user *,
+					  size_t, loff_t *);
+
 static const struct file_operations acpi_thermal_state_fops = {
 	.owner = THIS_MODULE,
 	.open = acpi_thermal_state_open_fs,
@@ -242,6 +248,7 @@ static const struct file_operations acpi_thermal_polling_fops = {
 	.llseek = seq_lseek,
 	.release = single_release,
 };
+#endif /* CONFIG_ACPI_PROCFS*/
 
 /* --------------------------------------------------------------------------
                              Thermal Zone Management
@@ -287,26 +294,6 @@ static int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)
 	return 0;
 }
 
-static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
-{
-
-	if (!tz)
-		return -EINVAL;
-
-	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
-
-	tz->thermal_zone->polling_delay = seconds * 1000;
-
-	if (tz->tz_enabled)
-		thermal_zone_device_update(tz->thermal_zone);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			  "Polling frequency set to %lu seconds\n",
-			  tz->polling_frequency/10));
-
-	return 0;
-}
-
 static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 {
 	acpi_status status = AE_OK;
@@ -973,7 +960,7 @@ static void acpi_thermal_unregister_thermal_zone(struct acpi_thermal *tz)
 /* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
-
+#ifdef CONFIG_ACPI_PROCFS
 static struct proc_dir_entry *acpi_thermal_dir;
 
 static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
@@ -1187,6 +1174,26 @@ static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file)
 			   PDE(inode)->data);
 }
 
+static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
+{
+	if (!tz)
+		return -EINVAL;
+
+	/* Convert value to deci-seconds */
+	tz->polling_frequency = seconds * 10;
+
+	tz->thermal_zone->polling_delay = seconds * 1000;
+
+	if (tz->tz_enabled)
+		thermal_zone_device_update(tz->thermal_zone);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Polling frequency set to %lu seconds\n",
+			  tz->polling_frequency/10));
+
+	return 0;
+}
+
 static ssize_t
 acpi_thermal_write_polling(struct file *file,
 			   const char __user * buffer,
@@ -1295,7 +1302,13 @@ static int acpi_thermal_remove_fs(struct acpi_device *device)
 
 	return 0;
 }
-
+#else
+static inline int acpi_thermal_add_fs(struct acpi_device *device) { return 0; }
+static inline int acpi_thermal_remove_fs(struct acpi_device *device)
+{
+	return 0;
+}
+#endif /* CONFIG_ACPI_PROCFS */
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -1566,13 +1579,18 @@ static int __init acpi_thermal_init(void)
 		printk(KERN_NOTICE "ACPI: thermal control disabled\n");
 		return -ENODEV;
 	}
+
+#ifdef CONFIG_ACPI_PROCFS
 	acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, acpi_root_dir);
 	if (!acpi_thermal_dir)
 		return -ENODEV;
+#endif
 
 	result = acpi_bus_register_driver(&acpi_thermal_driver);
 	if (result < 0) {
+#ifdef CONFIG_ACPI_PROCFS
 		remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
+#endif
 		return -ENODEV;
 	}
 
@@ -1584,7 +1602,9 @@ static void __exit acpi_thermal_exit(void)
 
 	acpi_bus_unregister_driver(&acpi_thermal_driver);
 
+#ifdef CONFIG_ACPI_PROCFS
 	remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
+#endif
 
 	return;
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5d3893558cf7..efad1f33aeb5 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -35,6 +35,7 @@
 #include <linux/module.h>
 #include <linux/dmi.h>
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/proc_fs.h>
 #include <linux/jiffies.h>

commit ec28dcc6b4c00b78ad269ad5b85ebd5c2d504825
Merge: c67fcd670b55 d06070509147 f6bb13aa1ea3 0c99c5288eb9 4c81ba4900ab 7e0e9c042790 149fe9c293f7 cffdde993a01 fa80945269f3 8b7ef6d8f162 70287db87cfc 38bcb37a6f63
Author: Len Brown <len.brown@intel.com>
Date:   Sun Mar 14 21:30:17 2010 -0400

    Merge branches 'battery-2.6.34', 'bugzilla-10805', 'bugzilla-14668', 'bugzilla-531916-power-state', 'ht-warn-2.6.34', 'pnp', 'processor-rename', 'sony-2.6.34', 'suse-bugzilla-531547', 'tz-check', 'video' and 'misc-2.6.34' into release

commit fa80945269f312bc609e8384302f58b03c916e12
Author: Thomas Renninger <trenn@suse.de>
Date:   Sat Feb 20 11:44:27 2010 +0100

    ACPI thermal: Don't invalidate thermal zone if critical trip point is bad
    
    V2: Corrected integer/long conversion.
    
    Some BIOSes return a negative value for the critical trip point.
    Especially since Windows 2006...
    We currently invalidate the whole thermal zone in this case.
    But it may still be needed for cooling, also without critical
    trip point.
    
    This patch invalidates the critical trip point if no _CRT
    function is found or if it returns negative values, but does
    not invalidate the whole thermal zone in this case.
    
    Reference: http://bugzilla.novell.com/show_bug.cgi?id=531547
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Tested-by: clarkt@cnsp.com
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 9073ada88835..77b8e1eaa717 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -368,7 +368,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 	int valid = 0;
 	int i;
 
-	/* Critical Shutdown (required) */
+	/* Critical Shutdown */
 	if (flag & ACPI_TRIPS_CRITICAL) {
 		status = acpi_evaluate_integer(tz->device->handle,
 				"_CRT", NULL, &tmp);
@@ -379,17 +379,19 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		 * Below zero (Celsius) values clearly aren't right for sure..
 		 * ... so lets discard those as invalid.
 		 */
-		if (ACPI_FAILURE(status) ||
-				tz->trips.critical.temperature <= 2732) {
+		if (ACPI_FAILURE(status)) {
+			tz->trips.critical.flags.valid = 0;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "No critical threshold\n"));
+		} else if (tmp <= 2732) {
+			printk(KERN_WARNING FW_BUG "Invalid critical threshold "
+			       "(%llu)\n", tmp);
 			tz->trips.critical.flags.valid = 0;
-			ACPI_EXCEPTION((AE_INFO, status,
-					"No or invalid critical threshold"));
-			return -ENODEV;
 		} else {
 			tz->trips.critical.flags.valid = 1;
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-					"Found critical threshold [%lu]\n",
-					tz->trips.critical.temperature));
+					  "Found critical threshold [%lu]\n",
+					  tz->trips.critical.temperature));
 		}
 		if (tz->trips.critical.flags.valid == 1) {
 			if (crt == -1) {

commit 8b7ef6d8f16274da42344cd50746ddb1c93c25ea
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Feb 16 22:55:51 2010 +0100

    ACPI thermal: Check for thermal zone requirement
    
    ACPI spec says (11.5 Thermal Zone Interface Requirements):
       A thermal zone must contain at least one trip point
       (critical, near critical, active, or passive)
    
    Check this once at init time.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Tested-by: clarkt@cnsp.com
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 9073ada88835..e9f28e075cf8 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -575,7 +575,23 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 
 static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 {
-	return acpi_thermal_trips_update(tz, ACPI_TRIPS_INIT);
+	int i, valid, ret = acpi_thermal_trips_update(tz, ACPI_TRIPS_INIT);
+
+	if (ret)
+		return ret;
+
+	valid = tz->trips.critical.flags.valid |
+		tz->trips.hot.flags.valid |
+		tz->trips.passive.flags.valid;
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)
+		valid |= tz->trips.active[i].flags.valid;
+
+	if (!valid) {
+		printk(KERN_WARNING FW_BUG "No valid trip found\n");
+		return -ENODEV;
+	}
+	return 0;
 }
 
 static void acpi_thermal_check(void *data)

commit 7fb2616e249184e217f9818a7662596165710ea4
Author: Frans Pop <elendil@planet.nl>
Date:   Mon Oct 26 08:39:01 2009 +0100

    acpi: thermal: display forced passive trip points in proc
    
    Users can force a passive trip point for a thermal zone that does not
    have _PSV defined in ACPI by setting the passive attribute in sysfs.
    It's useful to display such trip points in /proc/acpi/thermal_zone.
    
    .../TZ1/cooling_mode:<setting not supported>
    .../TZ1/polling_frequency:polling frequency:       10 seconds
    .../TZ1/state:state:                   ok
    .../TZ1/temperature:temperature:             53 C
    .../TZ1/trip_points:critical (S5):           110 C
    .../TZ1/trip_points:passive (forced):        95 C
    
    And if not set (passive is 0):
    .../TZ1/trip_points:passive (forced):<not set>
    
    Signed-off-by: Frans Pop <elendil@planet.nl>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 65f67815902a..9073ada88835 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1052,6 +1052,13 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 				   acpi_device_bid(device));
 		}
 		seq_puts(seq, "\n");
+	} else {
+		seq_printf(seq, "passive (forced):");
+		if (tz->thermal_zone->forced_passive)
+			seq_printf(seq, "        %i C\n",
+				   tz->thermal_zone->forced_passive / 1000);
+		else
+			seq_printf(seq, "<not set>\n");
 	}
 
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 564ea1424288..65f67815902a 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -47,6 +47,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#define PREFIX "ACPI: "
+
 #define ACPI_THERMAL_CLASS		"thermal_zone"
 #define ACPI_THERMAL_DEVICE_NAME	"Thermal Zone"
 #define ACPI_THERMAL_FILE_STATE		"state"

commit 67405439bca28c4dbecd3fefd97fbdb282a302d9
Author: Matthew Garrett <mjg59@srcf.ucam.org>
Date:   Tue Apr 14 20:16:45 2009 +0100

    thermal: Fix polling frequency for systems without passive cooling
    
    The polling interval (in deciseconds) was accidently interpreted as
    being in milliseconds in one codepath, resulting in excessively frequent
    polling. Ensure that the conversion is performed.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 9cd15e8c8932..564ea1424288 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -909,7 +909,7 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 			thermal_zone_device_register("acpitz", trips, tz,
 						     &acpi_thermal_zone_ops,
 						     0, 0, 0,
-						     tz->polling_frequency);
+						     tz->polling_frequency*100);
 	if (IS_ERR(tz->thermal_zone))
 		return -ENODEV;
 

commit 8897c1859521cf33077256725b2377164b130c75
Merge: 18b2646fe3ba db954b5898dd fdbdc7fc79c0 13614e37e94d 33b571501553 f61bb93927fb
Author: Len Brown <len.brown@intel.com>
Date:   Tue Apr 7 18:18:42 2009 -0400

    Merge branches 'release', 'APERF', 'ARAT', 'misc', 'kelvin', 'device-lock' and 'bjorn.notify' into release

commit 342d550db1bc0b879007a8cdb38645558e839680
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Apr 7 15:37:06 2009 +0000

    ACPI: thermal: use .notify method instead of installing handler directly
    
    This patch adds a .notify() method.  The presence of .notify() causes
    Linux/ACPI to manage event handlers and notify handlers on our behalf,
    so we don't have to install and remove them ourselves.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index e8c143caf0fd..0914eaa9a097 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -98,6 +98,7 @@ MODULE_PARM_DESC(psv, "Disable or override all passive trip points.");
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);
 static int acpi_thermal_resume(struct acpi_device *device);
+static void acpi_thermal_notify(struct acpi_device *device, u32 event);
 static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
@@ -123,6 +124,7 @@ static struct acpi_driver acpi_thermal_driver = {
 		.add = acpi_thermal_add,
 		.remove = acpi_thermal_remove,
 		.resume = acpi_thermal_resume,
+		.notify = acpi_thermal_notify,
 		},
 };
 
@@ -1264,17 +1266,14 @@ static int acpi_thermal_remove_fs(struct acpi_device *device)
                                  Driver Interface
    -------------------------------------------------------------------------- */
 
-static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
+static void acpi_thermal_notify(struct acpi_device *device, u32 event)
 {
-	struct acpi_thermal *tz = data;
-	struct acpi_device *device = NULL;
+	struct acpi_thermal *tz = acpi_driver_data(device);
 
 
 	if (!tz)
 		return;
 
-	device = tz->device;
-
 	switch (event) {
 	case ACPI_THERMAL_NOTIFY_TEMPERATURE:
 		acpi_thermal_check(tz);
@@ -1298,8 +1297,6 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 				  "Unsupported event [0x%x]\n", event));
 		break;
 	}
-
-	return;
 }
 
 static int acpi_thermal_get_info(struct acpi_thermal *tz)
@@ -1337,7 +1334,6 @@ static int acpi_thermal_get_info(struct acpi_thermal *tz)
 static int acpi_thermal_add(struct acpi_device *device)
 {
 	int result = 0;
-	acpi_status status = AE_OK;
 	struct acpi_thermal *tz = NULL;
 
 
@@ -1368,21 +1364,11 @@ static int acpi_thermal_add(struct acpi_device *device)
 	if (result)
 		goto unregister_thermal_zone;
 
-	status = acpi_install_notify_handler(device->handle,
-					     ACPI_DEVICE_NOTIFY,
-					     acpi_thermal_notify, tz);
-	if (ACPI_FAILURE(status)) {
-		result = -ENODEV;
-		goto remove_fs;
-	}
-
 	printk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",
 	       acpi_device_name(device), acpi_device_bid(device),
 	       KELVIN_TO_CELSIUS(tz->temperature));
 	goto end;
 
-remove_fs:
-	acpi_thermal_remove_fs(device);
 unregister_thermal_zone:
 	thermal_zone_device_unregister(tz->thermal_zone);
 free_memory:
@@ -1393,7 +1379,6 @@ static int acpi_thermal_add(struct acpi_device *device)
 
 static int acpi_thermal_remove(struct acpi_device *device, int type)
 {
-	acpi_status status = AE_OK;
 	struct acpi_thermal *tz = NULL;
 
 	if (!device || !acpi_driver_data(device))
@@ -1401,10 +1386,6 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 
 	tz = acpi_driver_data(device);
 
-	status = acpi_remove_notify_handler(device->handle,
-					    ACPI_DEVICE_NOTIFY,
-					    acpi_thermal_notify);
-
 	acpi_thermal_remove_fs(device);
 	acpi_thermal_unregister_thermal_zone(tz);
 	mutex_destroy(&tz->lock);

commit 13614e37e94da4606a300ee6fe25c8c4a19ee670
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Apr 6 16:01:46 2009 +0200

    ACPI: Adjust Kelvin offset to match local implementation
    
    The exact offset between Kelvin and degree Celsius is 273.15. However
    ACPI handles temperature values with a single decimal place. As a
    consequence, some implementations use an offset of 273.1 and others
    use an offset of 273.2. Try to find out which one is being used, to
    present the most accurate and visually appealing number.
    
    Tested on a Sony Vaio PGC-GR214EP (which uses 273.1) and a Lenovo
    Thinkpad T60p (which uses 273.2).
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index e8c143caf0fd..ddbb7c8f994d 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -192,6 +192,7 @@ struct acpi_thermal {
 	struct acpi_handle_list devices;
 	struct thermal_zone_device *thermal_zone;
 	int tz_enabled;
+	int kelvin_offset;
 	struct mutex lock;
 };
 
@@ -581,7 +582,7 @@ static void acpi_thermal_check(void *data)
 }
 
 /* sys I/F for generic thermal sysfs support */
-#define KELVIN_TO_MILLICELSIUS(t) (t * 100 - 273200)
+#define KELVIN_TO_MILLICELSIUS(t, off) (((t) - (off)) * 100)
 
 static int thermal_get_temp(struct thermal_zone_device *thermal,
 			    unsigned long *temp)
@@ -596,7 +597,7 @@ static int thermal_get_temp(struct thermal_zone_device *thermal,
 	if (result)
 		return result;
 
-	*temp = KELVIN_TO_MILLICELSIUS(tz->temperature);
+	*temp = KELVIN_TO_MILLICELSIUS(tz->temperature, tz->kelvin_offset);
 	return 0;
 }
 
@@ -702,7 +703,8 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 	if (tz->trips.critical.flags.valid) {
 		if (!trip) {
 			*temp = KELVIN_TO_MILLICELSIUS(
-				tz->trips.critical.temperature);
+				tz->trips.critical.temperature,
+				tz->kelvin_offset);
 			return 0;
 		}
 		trip--;
@@ -711,7 +713,8 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 	if (tz->trips.hot.flags.valid) {
 		if (!trip) {
 			*temp = KELVIN_TO_MILLICELSIUS(
-				tz->trips.hot.temperature);
+				tz->trips.hot.temperature,
+				tz->kelvin_offset);
 			return 0;
 		}
 		trip--;
@@ -720,7 +723,8 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 	if (tz->trips.passive.flags.valid) {
 		if (!trip) {
 			*temp = KELVIN_TO_MILLICELSIUS(
-				tz->trips.passive.temperature);
+				tz->trips.passive.temperature,
+				tz->kelvin_offset);
 			return 0;
 		}
 		trip--;
@@ -730,7 +734,8 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 		tz->trips.active[i].flags.valid; i++) {
 		if (!trip) {
 			*temp = KELVIN_TO_MILLICELSIUS(
-				tz->trips.active[i].temperature);
+				tz->trips.active[i].temperature,
+				tz->kelvin_offset);
 			return 0;
 		}
 		trip--;
@@ -745,7 +750,8 @@ static int thermal_get_crit_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.critical.flags.valid) {
 		*temperature = KELVIN_TO_MILLICELSIUS(
-				tz->trips.critical.temperature);
+				tz->trips.critical.temperature,
+				tz->kelvin_offset);
 		return 0;
 	} else
 		return -EINVAL;
@@ -1334,6 +1340,25 @@ static int acpi_thermal_get_info(struct acpi_thermal *tz)
 	return 0;
 }
 
+/*
+ * The exact offset between Kelvin and degree Celsius is 273.15. However ACPI
+ * handles temperature values with a single decimal place. As a consequence,
+ * some implementations use an offset of 273.1 and others use an offset of
+ * 273.2. Try to find out which one is being used, to present the most
+ * accurate and visually appealing number.
+ *
+ * The heuristic below should work for all ACPI thermal zones which have a
+ * critical trip point with a value being a multiple of 0.5 degree Celsius.
+ */
+static void acpi_thermal_guess_offset(struct acpi_thermal *tz)
+{
+	if (tz->trips.critical.flags.valid &&
+	    (tz->trips.critical.temperature % 5) == 1)
+		tz->kelvin_offset = 2731;
+	else
+		tz->kelvin_offset = 2732;
+}
+
 static int acpi_thermal_add(struct acpi_device *device)
 {
 	int result = 0;
@@ -1360,6 +1385,8 @@ static int acpi_thermal_add(struct acpi_device *device)
 	if (result)
 		goto free_memory;
 
+	acpi_thermal_guess_offset(tz);
+
 	result = acpi_thermal_register_thermal_zone(tz);
 	if (result)
 		goto free_memory;

commit 478c6a43fcbc6c11609f8cee7c7b57223907754f
Merge: 8a3f257c704e 6bb597507f98
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 02:14:15 2009 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/cpu/cpufreq/longhaul.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 811158b147a503fbdf9773224004ffd32002d1fe
Merge: 4e76c5ccd5ac b26e0ed4936b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 3 15:24:35 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (28 commits)
      trivial: Update my email address
      trivial: NULL noise: drivers/mtd/tests/mtd_*test.c
      trivial: NULL noise: drivers/media/dvb/frontends/drx397xD_fw.h
      trivial: Fix misspelling of "Celsius".
      trivial: remove unused variable 'path' in alloc_file()
      trivial: fix a pdlfush -> pdflush typo in comment
      trivial: jbd header comment typo fix for JBD_PARANOID_IOFAIL
      trivial: wusb: Storage class should be before const qualifier
      trivial: drivers/char/bsr.c: Storage class should be before const qualifier
      trivial: h8300: Storage class should be before const qualifier
      trivial: fix where cgroup documentation is not correctly referred to
      trivial: Give the right path in Documentation example
      trivial: MTD: remove EOL from MODULE_DESCRIPTION
      trivial: Fix typo in bio_split()'s documentation
      trivial: PWM: fix of #endif comment
      trivial: fix typos/grammar errors in Kconfig texts
      trivial: Fix misspelling of firmware
      trivial: cgroups: documentation typo and spelling corrections
      trivial: Update contact info for Jochen Hein
      trivial: fix typo "resgister" -> "register"
      ...

commit 99b76233803beab302123d243eea9e41149804f3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 25 22:48:06 2009 +0300

    proc 2/2: remove struct proc_dir_entry::owner
    
    Setting ->owner as done currently (pde->owner = THIS_MODULE) is racy
    as correctly noted at bug #12454. Someone can lookup entry with NULL
    ->owner, thus not pinning enything, and release it later resulting
    in module refcount underflow.
    
    We can keep ->owner and supply it at registration time like ->proc_fops
    and ->data.
    
    But this leaves ->owner as easy-manipulative field (just one C assignment)
    and somebody will forget to unpin previous/pin current module when
    switching ->owner. ->proc_fops is declared as "const" which should give
    some thoughts.
    
    ->read_proc/->write_proc were just fixed to not require ->owner for
    protection.
    
    rmmod'ed directories will be empty and return "." and ".." -- no harm.
    And directories with tricky enough readdir and lookup shouldn't be modular.
    We definitely don't want such modular code.
    
    Removing ->owner will also make PDE smaller.
    
    So, let's nuke it.
    
    Kudos to Jeff Layton for reminding about this, let's say, oversight.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12454
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 99e6f1f8ea45..c11f9aeca706 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1506,7 +1506,6 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 						     acpi_thermal_dir);
 		if (!acpi_device_dir(device))
 			return -ENODEV;
-		acpi_device_dir(device)->owner = THIS_MODULE;
 	}
 
 	/* 'state' [R] */
@@ -1875,7 +1874,6 @@ static int __init acpi_thermal_init(void)
 	acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, acpi_root_dir);
 	if (!acpi_thermal_dir)
 		return -ENODEV;
-	acpi_thermal_dir->owner = THIS_MODULE;
 
 	result = acpi_bus_register_driver(&acpi_thermal_driver);
 	if (result < 0) {

commit b731d7b6a7b4c2ca4b5e9384cb5197e4e8204651
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Fri Mar 13 12:15:26 2009 -0400

    trivial: Fix misspelling of "Celsius".
    
    A few comments say "Celcius"; this fixes them. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 99e6f1f8ea45..0c30ec094575 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -367,7 +367,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		/*
 		 * Treat freezing temperatures as invalid as well; some
 		 * BIOSes return really low values and cause reboots at startup.
-		 * Below zero (Celcius) values clearly aren't right for sure..
+		 * Below zero (Celsius) values clearly aren't right for sure..
 		 * ... so lets discard those as invalid.
 		 */
 		if (ACPI_FAILURE(status) ||

commit f6f5c45e06e86d94621cd5c1c4508bdee1952fc8
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Mar 3 12:47:17 2009 +1100

    ACPI: update thermal for bus_id removal
    
    > drivers/acpi/thermal.c: In function 'thermal_notify':
    > drivers/acpi/thermal.c:768: error: 'struct device' has no member named 'bus_id'
    >
    > Caused by commit b1569e99c795bf83b4ddf41c4f1c42761ab7f75e ("ACPI: move
    > thermal trip handling to generic thermal layer") interacting with commit
    > d4a078fca590911cdf87a8eaffee1b6e643c2558 ("driver core: get rid of struct
    > device's bus_id string array").
    >
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 0ec48d2f85c5..6b959976b7a4 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -41,6 +41,7 @@
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
 #include <linux/reboot.h>
+#include <linux/device.h>
 #include <asm/uaccess.h>
 #include <linux/thermal.h>
 #include <acpi/acpi_bus.h>
@@ -765,7 +766,7 @@ static int thermal_notify(struct thermal_zone_device *thermal, int trip,
 
 	acpi_bus_generate_proc_event(tz->device, type, 1);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
-					tz->device->dev.bus_id, type, 1);
+					dev_name(&tz->device->dev), type, 1);
 
 	if (trip_type == THERMAL_TRIP_CRITICAL && nocrt)
 		return 1;

commit b1569e99c795bf83b4ddf41c4f1c42761ab7f75e
Author: Matthew Garrett <mjg59@srcf.ucam.org>
Date:   Wed Dec 3 17:55:32 2008 +0000

    ACPI: move thermal trip handling to generic thermal layer
    
    The ACPI code currently carries its own thermal trip handling, meaning that
    any other thermal implementation will need to reimplement it. Move the code
    to the generic thermal layer.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1c410ef859c6..0ec48d2f85c5 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -37,7 +37,6 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/proc_fs.h>
-#include <linux/timer.h>
 #include <linux/jiffies.h>
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
@@ -190,7 +189,6 @@ struct acpi_thermal {
 	struct acpi_thermal_state state;
 	struct acpi_thermal_trips trips;
 	struct acpi_handle_list devices;
-	struct timer_list timer;
 	struct thermal_zone_device *thermal_zone;
 	int tz_enabled;
 	struct mutex lock;
@@ -290,6 +288,11 @@ static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
 
 	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
 
+	tz->thermal_zone->polling_delay = seconds * 1000;
+
+	if (tz->tz_enabled)
+		thermal_zone_device_update(tz->thermal_zone);
+
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Polling frequency set to %lu seconds\n",
 			  tz->polling_frequency/10));
@@ -569,386 +572,11 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 	return acpi_thermal_trips_update(tz, ACPI_TRIPS_INIT);
 }
 
-static int acpi_thermal_critical(struct acpi_thermal *tz)
-{
-	if (!tz || !tz->trips.critical.flags.valid)
-		return -EINVAL;
-
-	if (tz->temperature >= tz->trips.critical.temperature) {
-		printk(KERN_WARNING PREFIX "Critical trip point\n");
-		tz->trips.critical.flags.enabled = 1;
-	} else if (tz->trips.critical.flags.enabled)
-		tz->trips.critical.flags.enabled = 0;
-
-	acpi_bus_generate_proc_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
-				tz->trips.critical.flags.enabled);
-	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
-					  dev_name(&tz->device->dev),
-					  ACPI_THERMAL_NOTIFY_CRITICAL,
-					  tz->trips.critical.flags.enabled);
-
-	/* take no action if nocrt is set */
-	if(!nocrt) {
-		printk(KERN_EMERG
-			"Critical temperature reached (%ld C), shutting down.\n",
-			KELVIN_TO_CELSIUS(tz->temperature));
-		orderly_poweroff(true);
-	}
-
-	return 0;
-}
-
-static int acpi_thermal_hot(struct acpi_thermal *tz)
-{
-	if (!tz || !tz->trips.hot.flags.valid)
-		return -EINVAL;
-
-	if (tz->temperature >= tz->trips.hot.temperature) {
-		printk(KERN_WARNING PREFIX "Hot trip point\n");
-		tz->trips.hot.flags.enabled = 1;
-	} else if (tz->trips.hot.flags.enabled)
-		tz->trips.hot.flags.enabled = 0;
-
-	acpi_bus_generate_proc_event(tz->device, ACPI_THERMAL_NOTIFY_HOT,
-				tz->trips.hot.flags.enabled);
-	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
-					  dev_name(&tz->device->dev),
-					  ACPI_THERMAL_NOTIFY_HOT,
-					  tz->trips.hot.flags.enabled);
-
-	/* TBD: Call user-mode "sleep(S4)" function if nocrt is cleared */
-
-	return 0;
-}
-
-static void acpi_thermal_passive(struct acpi_thermal *tz)
-{
-	int result = 1;
-	struct acpi_thermal_passive *passive = NULL;
-	int trend = 0;
-	int i = 0;
-
-
-	if (!tz || !tz->trips.passive.flags.valid)
-		return;
-
-	passive = &(tz->trips.passive);
-
-	/*
-	 * Above Trip?
-	 * -----------
-	 * Calculate the thermal trend (using the passive cooling equation)
-	 * and modify the performance limit for all passive cooling devices
-	 * accordingly.  Note that we assume symmetry.
-	 */
-	if (tz->temperature >= passive->temperature) {
-		trend =
-		    (passive->tc1 * (tz->temperature - tz->last_temperature)) +
-		    (passive->tc2 * (tz->temperature - passive->temperature));
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "trend[%d]=(tc1[%lu]*(tmp[%lu]-last[%lu]))+(tc2[%lu]*(tmp[%lu]-psv[%lu]))\n",
-				  trend, passive->tc1, tz->temperature,
-				  tz->last_temperature, passive->tc2,
-				  tz->temperature, passive->temperature));
-		passive->flags.enabled = 1;
-		/* Heating up? */
-		if (trend > 0)
-			for (i = 0; i < passive->devices.count; i++)
-				acpi_processor_set_thermal_limit(passive->
-								 devices.
-								 handles[i],
-								 ACPI_PROCESSOR_LIMIT_INCREMENT);
-		/* Cooling off? */
-		else if (trend < 0) {
-			for (i = 0; i < passive->devices.count; i++)
-				/*
-				 * assume that we are on highest
-				 * freq/lowest thrott and can leave
-				 * passive mode, even in error case
-				 */
-				if (!acpi_processor_set_thermal_limit
-				    (passive->devices.handles[i],
-				     ACPI_PROCESSOR_LIMIT_DECREMENT))
-					result = 0;
-			/*
-			 * Leave cooling mode, even if the temp might
-			 * higher than trip point This is because some
-			 * machines might have long thermal polling
-			 * frequencies (tsp) defined. We will fall back
-			 * into passive mode in next cycle (probably quicker)
-			 */
-			if (result) {
-				passive->flags.enabled = 0;
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-						  "Disabling passive cooling, still above threshold,"
-						  " but we are cooling down\n"));
-			}
-		}
-		return;
-	}
-
-	/*
-	 * Below Trip?
-	 * -----------
-	 * Implement passive cooling hysteresis to slowly increase performance
-	 * and avoid thrashing around the passive trip point.  Note that we
-	 * assume symmetry.
-	 */
-	if (!passive->flags.enabled)
-		return;
-	for (i = 0; i < passive->devices.count; i++)
-		if (!acpi_processor_set_thermal_limit
-		    (passive->devices.handles[i],
-		     ACPI_PROCESSOR_LIMIT_DECREMENT))
-			result = 0;
-	if (result) {
-		passive->flags.enabled = 0;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Disabling passive cooling (zone is cool)\n"));
-	}
-}
-
-static void acpi_thermal_active(struct acpi_thermal *tz)
-{
-	int result = 0;
-	struct acpi_thermal_active *active = NULL;
-	int i = 0;
-	int j = 0;
-	unsigned long maxtemp = 0;
-
-
-	if (!tz)
-		return;
-
-	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
-		active = &(tz->trips.active[i]);
-		if (!active || !active->flags.valid)
-			break;
-		if (tz->temperature >= active->temperature) {
-			/*
-			 * Above Threshold?
-			 * ----------------
-			 * If not already enabled, turn ON all cooling devices
-			 * associated with this active threshold.
-			 */
-			if (active->temperature > maxtemp)
-				tz->state.active_index = i;
-			maxtemp = active->temperature;
-			if (active->flags.enabled)
-				continue;
-			for (j = 0; j < active->devices.count; j++) {
-				result =
-				    acpi_bus_set_power(active->devices.
-						       handles[j],
-						       ACPI_STATE_D0);
-				if (result) {
-					printk(KERN_WARNING PREFIX
-						      "Unable to turn cooling device [%p] 'on'\n",
-						      active->devices.
-						      handles[j]);
-					continue;
-				}
-				active->flags.enabled = 1;
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-						  "Cooling device [%p] now 'on'\n",
-						  active->devices.handles[j]));
-			}
-			continue;
-		}
-		if (!active->flags.enabled)
-			continue;
-		/*
-		 * Below Threshold?
-		 * ----------------
-		 * Turn OFF all cooling devices associated with this
-		 * threshold.
-		 */
-		for (j = 0; j < active->devices.count; j++) {
-			result = acpi_bus_set_power(active->devices.handles[j],
-						    ACPI_STATE_D3);
-			if (result) {
-				printk(KERN_WARNING PREFIX
-					      "Unable to turn cooling device [%p] 'off'\n",
-					      active->devices.handles[j]);
-				continue;
-			}
-			active->flags.enabled = 0;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-					  "Cooling device [%p] now 'off'\n",
-					  active->devices.handles[j]));
-		}
-	}
-}
-
-static void acpi_thermal_check(void *context);
-
-static void acpi_thermal_run(unsigned long data)
-{
-	struct acpi_thermal *tz = (struct acpi_thermal *)data;
-	if (!tz->zombie)
-		acpi_os_execute(OSL_GPE_HANDLER, acpi_thermal_check, (void *)data);
-}
-
-static void acpi_thermal_active_off(void *data)
-{
-	int result = 0;
-	struct acpi_thermal *tz = data;
-	int i = 0;
-	int j = 0;
-	struct acpi_thermal_active *active = NULL;
-
-	if (!tz) {
-		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
-		return;
-	}
-
-	result = acpi_thermal_get_temperature(tz);
-	if (result)
-		return;
-
-	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
-		active = &(tz->trips.active[i]);
-		if (!active || !active->flags.valid)
-			break;
-		if (tz->temperature >= active->temperature) {
-			/*
-			 * If the thermal temperature is greater than the
-			 * active threshod, unnecessary to turn off the
-			 * the active cooling device.
-			 */
-			continue;
-		}
-		/*
-		 * Below Threshold?
-		 * ----------------
-		 * Turn OFF all cooling devices associated with this
-		 * threshold.
-		 */
-		for (j = 0; j < active->devices.count; j++)
-			result = acpi_bus_set_power(active->devices.handles[j],
-						    ACPI_STATE_D3);
-	}
-}
-
 static void acpi_thermal_check(void *data)
 {
-	int result = 0;
 	struct acpi_thermal *tz = data;
-	unsigned long sleep_time = 0;
-	unsigned long timeout_jiffies = 0;
-	int i = 0;
-	struct acpi_thermal_state state;
-
-
-	if (!tz) {
-		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
-		return;
-	}
-
-	/* Check if someone else is already running */
-	if (!mutex_trylock(&tz->lock))
-		return;
-
-	state = tz->state;
-
-	result = acpi_thermal_get_temperature(tz);
-	if (result)
-		goto unlock;
-
-	if (!tz->tz_enabled)
-		goto unlock;
-
-	memset(&tz->state, 0, sizeof(tz->state));
-
-	/*
-	 * Check Trip Points
-	 * -----------------
-	 * Compare the current temperature to the trip point values to see
-	 * if we've entered one of the thermal policy states.  Note that
-	 * this function determines when a state is entered, but the 
-	 * individual policy decides when it is exited (e.g. hysteresis).
-	 */
-	if (tz->trips.critical.flags.valid)
-		state.critical |=
-		    (tz->temperature >= tz->trips.critical.temperature);
-	if (tz->trips.hot.flags.valid)
-		state.hot |= (tz->temperature >= tz->trips.hot.temperature);
-	if (tz->trips.passive.flags.valid)
-		state.passive |=
-		    (tz->temperature >= tz->trips.passive.temperature);
-	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)
-		if (tz->trips.active[i].flags.valid)
-			state.active |=
-			    (tz->temperature >=
-			     tz->trips.active[i].temperature);
-
-	/*
-	 * Invoke Policy
-	 * -------------
-	 * Separated from the above check to allow individual policy to 
-	 * determine when to exit a given state.
-	 */
-	if (state.critical)
-		acpi_thermal_critical(tz);
-	if (state.hot)
-		acpi_thermal_hot(tz);
-	if (state.passive)
-		acpi_thermal_passive(tz);
-	if (state.active)
-		acpi_thermal_active(tz);
-
-	/*
-	 * Calculate State
-	 * ---------------
-	 * Again, separated from the above two to allow independent policy
-	 * decisions.
-	 */
-	tz->state.critical = tz->trips.critical.flags.enabled;
-	tz->state.hot = tz->trips.hot.flags.enabled;
-	tz->state.passive = tz->trips.passive.flags.enabled;
-	tz->state.active = 0;
-	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)
-		tz->state.active |= tz->trips.active[i].flags.enabled;
-
-	/*
-	 * Calculate Sleep Time
-	 * --------------------
-	 * If we're in the passive state, use _TSP's value.  Otherwise
-	 * use the default polling frequency (e.g. _TZP).  If no polling
-	 * frequency is specified then we'll wait forever (at least until
-	 * a thermal event occurs).  Note that _TSP and _TZD values are
-	 * given in 1/10th seconds (we must covert to milliseconds).
-	 */
-	if (tz->state.passive) {
-		sleep_time = tz->trips.passive.tsp * 100;
-		timeout_jiffies =  jiffies + (HZ * sleep_time) / 1000;
-	} else if (tz->polling_frequency > 0) {
-		sleep_time = tz->polling_frequency * 100;
-		timeout_jiffies =  round_jiffies(jiffies + (HZ * sleep_time) / 1000);
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n",
-			  tz->name, tz->temperature, sleep_time));
 
-	/*
-	 * Schedule Next Poll
-	 * ------------------
-	 */
-	if (!sleep_time) {
-		if (timer_pending(&(tz->timer)))
-			del_timer(&(tz->timer));
-	} else {
-		if (timer_pending(&(tz->timer)))
-			mod_timer(&(tz->timer), timeout_jiffies);
-		else {
-			tz->timer.data = (unsigned long)tz;
-			tz->timer.function = acpi_thermal_run;
-			tz->timer.expires = timeout_jiffies;
-			add_timer(&(tz->timer));
-		}
-	}
-      unlock:
-	mutex_unlock(&tz->lock);
+	thermal_zone_device_update(tz->thermal_zone);
 }
 
 /* sys I/F for generic thermal sysfs support */
@@ -1122,6 +750,29 @@ static int thermal_get_crit_temp(struct thermal_zone_device *thermal,
 		return -EINVAL;
 }
 
+static int thermal_notify(struct thermal_zone_device *thermal, int trip,
+			   enum thermal_trip_type trip_type)
+{
+	u8 type = 0;
+	struct acpi_thermal *tz = thermal->devdata;
+
+	if (trip_type == THERMAL_TRIP_CRITICAL)
+		type = ACPI_THERMAL_NOTIFY_CRITICAL;
+	else if (trip_type == THERMAL_TRIP_HOT)
+		type = ACPI_THERMAL_NOTIFY_HOT;
+	else
+		return 0;
+
+	acpi_bus_generate_proc_event(tz->device, type, 1);
+	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
+					tz->device->dev.bus_id, type, 1);
+
+	if (trip_type == THERMAL_TRIP_CRITICAL && nocrt)
+		return 1;
+
+	return 0;
+}
+
 typedef int (*cb)(struct thermal_zone_device *, int,
 		  struct thermal_cooling_device *);
 static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
@@ -1214,6 +865,7 @@ static struct thermal_zone_device_ops acpi_thermal_zone_ops = {
 	.get_trip_type = thermal_get_trip_type,
 	.get_trip_temp = thermal_get_trip_temp,
 	.get_crit_temp = thermal_get_crit_temp,
+	.notify = thermal_notify,
 };
 
 static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
@@ -1234,8 +886,21 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
 			tz->trips.active[i].flags.valid; i++, trips++);
-	tz->thermal_zone = thermal_zone_device_register("acpitz",
-					trips, tz, &acpi_thermal_zone_ops);
+
+	if (tz->trips.passive.flags.valid)
+		tz->thermal_zone =
+			thermal_zone_device_register("acpitz", trips, tz,
+						     &acpi_thermal_zone_ops,
+						     tz->trips.passive.tc1,
+						     tz->trips.passive.tc2,
+						     tz->trips.passive.tsp*100,
+						     tz->polling_frequency*100);
+	else
+		tz->thermal_zone =
+			thermal_zone_device_register("acpitz", trips, tz,
+						     &acpi_thermal_zone_ops,
+						     0, 0, 0,
+						     tz->polling_frequency);
 	if (IS_ERR(tz->thermal_zone))
 		return -ENODEV;
 
@@ -1467,13 +1132,13 @@ static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
 	if (!tz)
 		goto end;
 
-	if (!tz->polling_frequency) {
+	if (!tz->thermal_zone->polling_delay) {
 		seq_puts(seq, "<polling disabled>\n");
 		goto end;
 	}
 
-	seq_printf(seq, "polling frequency:       %lu seconds\n",
-		   (tz->polling_frequency / 10));
+	seq_printf(seq, "polling frequency:       %d seconds\n",
+		   (tz->thermal_zone->polling_delay / 1000));
 
       end:
 	return 0;
@@ -1703,12 +1368,6 @@ static int acpi_thermal_add(struct acpi_device *device)
 	if (result)
 		goto unregister_thermal_zone;
 
-	init_timer(&tz->timer);
-
-	acpi_thermal_active_off(tz);
-
-	acpi_thermal_check(tz);
-
 	status = acpi_install_notify_handler(device->handle,
 					     ACPI_DEVICE_NOTIFY,
 					     acpi_thermal_notify, tz);
@@ -1737,36 +1396,15 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	acpi_status status = AE_OK;
 	struct acpi_thermal *tz = NULL;
 
-
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
 	tz = acpi_driver_data(device);
 
-	/* avoid timer adding new defer task */
-	tz->zombie = 1;
-	/* wait for running timer (on other CPUs) finish */
-	del_timer_sync(&(tz->timer));
-	/* synchronize deferred task */
-	acpi_os_wait_events_complete(NULL);
-	/* deferred task may reinsert timer */
-	del_timer_sync(&(tz->timer));
-
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_DEVICE_NOTIFY,
 					    acpi_thermal_notify);
 
-	/* Terminate policy */
-	if (tz->trips.passive.flags.valid && tz->trips.passive.flags.enabled) {
-		tz->trips.passive.flags.enabled = 0;
-		acpi_thermal_passive(tz);
-	}
-	if (tz->trips.active[0].flags.valid
-	    && tz->trips.active[0].flags.enabled) {
-		tz->trips.active[0].flags.enabled = 0;
-		acpi_thermal_active(tz);
-	}
-
 	acpi_thermal_remove_fs(device);
 	acpi_thermal_unregister_thermal_zone(tz);
 	mutex_destroy(&tz->lock);

commit 6503e5df08008b9a47022b5e9ebba658c8fa69af
Author: Matthew Garrett <mjg59@srcf.ucam.org>
Date:   Thu Nov 27 17:48:13 2008 +0000

    thermal: use integers rather than strings for thermal values
    
    The thermal API currently uses strings to pass values to userspace. This
    makes it difficult to use from within the kernel. Change the interface
    to use integers and fix up the consumers.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 99e6f1f8ea45..1c410ef859c6 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -954,7 +954,8 @@ static void acpi_thermal_check(void *data)
 /* sys I/F for generic thermal sysfs support */
 #define KELVIN_TO_MILLICELSIUS(t) (t * 100 - 273200)
 
-static int thermal_get_temp(struct thermal_zone_device *thermal, char *buf)
+static int thermal_get_temp(struct thermal_zone_device *thermal,
+			    unsigned long *temp)
 {
 	struct acpi_thermal *tz = thermal->devdata;
 	int result;
@@ -966,25 +967,28 @@ static int thermal_get_temp(struct thermal_zone_device *thermal, char *buf)
 	if (result)
 		return result;
 
-	return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(tz->temperature));
+	*temp = KELVIN_TO_MILLICELSIUS(tz->temperature);
+	return 0;
 }
 
 static const char enabled[] = "kernel";
 static const char disabled[] = "user";
 static int thermal_get_mode(struct thermal_zone_device *thermal,
-				char *buf)
+				enum thermal_device_mode *mode)
 {
 	struct acpi_thermal *tz = thermal->devdata;
 
 	if (!tz)
 		return -EINVAL;
 
-	return sprintf(buf, "%s\n", tz->tz_enabled ?
-			enabled : disabled);
+	*mode = tz->tz_enabled ? THERMAL_DEVICE_ENABLED :
+		THERMAL_DEVICE_DISABLED;
+
+	return 0;
 }
 
 static int thermal_set_mode(struct thermal_zone_device *thermal,
-				const char *buf)
+				enum thermal_device_mode mode)
 {
 	struct acpi_thermal *tz = thermal->devdata;
 	int enable;
@@ -995,9 +999,9 @@ static int thermal_set_mode(struct thermal_zone_device *thermal,
 	/*
 	 * enable/disable thermal management from ACPI thermal driver
 	 */
-	if (!strncmp(buf, enabled, sizeof enabled - 1))
+	if (mode == THERMAL_DEVICE_ENABLED)
 		enable = 1;
-	else if (!strncmp(buf, disabled, sizeof disabled - 1))
+	else if (mode == THERMAL_DEVICE_DISABLED)
 		enable = 0;
 	else
 		return -EINVAL;
@@ -1013,7 +1017,7 @@ static int thermal_set_mode(struct thermal_zone_device *thermal,
 }
 
 static int thermal_get_trip_type(struct thermal_zone_device *thermal,
-				 int trip, char *buf)
+				 int trip, enum thermal_trip_type *type)
 {
 	struct acpi_thermal *tz = thermal->devdata;
 	int i;
@@ -1022,27 +1026,35 @@ static int thermal_get_trip_type(struct thermal_zone_device *thermal,
 		return -EINVAL;
 
 	if (tz->trips.critical.flags.valid) {
-		if (!trip)
-			return sprintf(buf, "critical\n");
+		if (!trip) {
+			*type = THERMAL_TRIP_CRITICAL;
+			return 0;
+		}
 		trip--;
 	}
 
 	if (tz->trips.hot.flags.valid) {
-		if (!trip)
-			return sprintf(buf, "hot\n");
+		if (!trip) {
+			*type = THERMAL_TRIP_HOT;
+			return 0;
+		}
 		trip--;
 	}
 
 	if (tz->trips.passive.flags.valid) {
-		if (!trip)
-			return sprintf(buf, "passive\n");
+		if (!trip) {
+			*type = THERMAL_TRIP_PASSIVE;
+			return 0;
+		}
 		trip--;
 	}
 
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
 		tz->trips.active[i].flags.valid; i++) {
-		if (!trip)
-			return sprintf(buf, "active%d\n", i);
+		if (!trip) {
+			*type = THERMAL_TRIP_ACTIVE;
+			return 0;
+		}
 		trip--;
 	}
 
@@ -1050,7 +1062,7 @@ static int thermal_get_trip_type(struct thermal_zone_device *thermal,
 }
 
 static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
-				 int trip, char *buf)
+				 int trip, unsigned long *temp)
 {
 	struct acpi_thermal *tz = thermal->devdata;
 	int i;
@@ -1059,31 +1071,39 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 		return -EINVAL;
 
 	if (tz->trips.critical.flags.valid) {
-		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
-				tz->trips.critical.temperature));
+		if (!trip) {
+			*temp = KELVIN_TO_MILLICELSIUS(
+				tz->trips.critical.temperature);
+			return 0;
+		}
 		trip--;
 	}
 
 	if (tz->trips.hot.flags.valid) {
-		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
-					tz->trips.hot.temperature));
+		if (!trip) {
+			*temp = KELVIN_TO_MILLICELSIUS(
+				tz->trips.hot.temperature);
+			return 0;
+		}
 		trip--;
 	}
 
 	if (tz->trips.passive.flags.valid) {
-		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
-					tz->trips.passive.temperature));
+		if (!trip) {
+			*temp = KELVIN_TO_MILLICELSIUS(
+				tz->trips.passive.temperature);
+			return 0;
+		}
 		trip--;
 	}
 
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
 		tz->trips.active[i].flags.valid; i++) {
-		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
-					tz->trips.active[i].temperature));
+		if (!trip) {
+			*temp = KELVIN_TO_MILLICELSIUS(
+				tz->trips.active[i].temperature);
+			return 0;
+		}
 		trip--;
 	}
 

commit 0e4240d94628530a912d216cad1e32d2e3827327
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Jan 16 12:53:42 2009 -0500

    thermal fixup for broken BIOS which has invalid trip points.
    
    ACPI thermal driver only re-evaluate VALID trip points.
    
    For the broken BIOS show in
    http://bugzilla.kernel.org/show_bug.cgi?id=8544
    the active[0] is set to invalid at boot time
    and it will not be re-evaluated again.
    We can still get a single warning message at boot time.
    
    http://marc.info/?l=linux-kernel&m=120496222629983&w=2
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12203
    
    Signed-off-by: Zhang Rui<rui.zhang@intel.com>
    Tested-by: Márton Németh <nm127@freemail.hu>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 073ff09218a9..99e6f1f8ea45 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -416,7 +416,8 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 	}
 
 	/* Passive (optional) */
-	if (flag & ACPI_TRIPS_PASSIVE) {
+	if (((flag & ACPI_TRIPS_PASSIVE) && tz->trips.passive.flags.valid) ||
+		(flag == ACPI_TRIPS_INIT)) {
 		valid = tz->trips.passive.flags.valid;
 		if (psv == -1) {
 			status = AE_SUPPORT;
@@ -462,8 +463,11 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		memset(&devices, 0, sizeof(struct acpi_handle_list));
 		status = acpi_evaluate_reference(tz->device->handle, "_PSL",
 							NULL, &devices);
-		if (ACPI_FAILURE(status))
+		if (ACPI_FAILURE(status)) {
+			printk(KERN_WARNING PREFIX
+				"Invalid passive threshold\n");
 			tz->trips.passive.flags.valid = 0;
+		}
 		else
 			tz->trips.passive.flags.valid = 1;
 
@@ -487,7 +491,8 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		if (act == -1)
 			break; /* disable all active trip points */
 
-		if (flag & ACPI_TRIPS_ACTIVE) {
+		if ((flag == ACPI_TRIPS_INIT) || ((flag & ACPI_TRIPS_ACTIVE) &&
+			tz->trips.active[i].flags.valid)) {
 			status = acpi_evaluate_integer(tz->device->handle,
 							name, NULL, &tmp);
 			if (ACPI_FAILURE(status)) {
@@ -521,8 +526,11 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			memset(&devices, 0, sizeof(struct acpi_handle_list));
 			status = acpi_evaluate_reference(tz->device->handle,
 						name, NULL, &devices);
-			if (ACPI_FAILURE(status))
+			if (ACPI_FAILURE(status)) {
+				printk(KERN_WARNING PREFIX
+					"Invalid active%d threshold\n", i);
 				tz->trips.active[i].flags.valid = 0;
+			}
 			else
 				tz->trips.active[i].flags.valid = 1;
 

commit 9b5a56ddfd615a27e3a0856ceae1592a24021e42
Merge: a0017f471054 0794469da3f7
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 11 21:14:49 2008 -0500

    Merge branch 'sysfs' into release

commit 89595b8f2850a080d290bf778ec933ea1d99f78e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Nov 7 16:57:45 2008 -0700

    ACPI: consolidate ACPI_*_COMPONENT definitions in acpi_drivers.h
    
    Move all the component definitions for drivers to a single shared place,
    include/acpi/acpi_drivers.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index ad6cae938f0b..a6da1d9918c7 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -47,7 +47,6 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-#define ACPI_THERMAL_COMPONENT		0x04000000
 #define ACPI_THERMAL_CLASS		"thermal_zone"
 #define ACPI_THERMAL_DEVICE_NAME	"Thermal Zone"
 #define ACPI_THERMAL_FILE_STATE		"state"

commit 0794469da3f7b2093575cbdfc1108308dd3641ce
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:18:59 2008 +0100

    ACPI: struct device - replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    We want to submit a patch to -next, which will remove bus_id from
    "struct device", to find the remaining pieces to convert, and finally
    switch over to the new api, which will remove the 20 bytes array
    and does no longer have a size limitation.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index ad6cae938f0b..462b16878851 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -576,7 +576,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 	acpi_bus_generate_proc_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
 				tz->trips.critical.flags.enabled);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
-					  tz->device->dev.bus_id,
+					  dev_name(&tz->device->dev),
 					  ACPI_THERMAL_NOTIFY_CRITICAL,
 					  tz->trips.critical.flags.enabled);
 
@@ -605,7 +605,7 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 	acpi_bus_generate_proc_event(tz->device, ACPI_THERMAL_NOTIFY_HOT,
 				tz->trips.hot.flags.enabled);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
-					  tz->device->dev.bus_id,
+					  dev_name(&tz->device->dev),
 					  ACPI_THERMAL_NOTIFY_HOT,
 					  tz->trips.hot.flags.enabled);
 
@@ -1592,14 +1592,14 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 		acpi_thermal_check(tz);
 		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
-						  device->dev.bus_id, event, 0);
+						  dev_name(&device->dev), event, 0);
 		break;
 	case ACPI_THERMAL_NOTIFY_DEVICES:
 		acpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_DEVICES);
 		acpi_thermal_check(tz);
 		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
-						  device->dev.bus_id, event, 0);
+						  dev_name(&device->dev), event, 0);
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit 7674416db4ee3d43813dddb650364ca994755256
Merge: 0ca9413c234a 27663c5855b1
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:33:29 2008 -0400

    Merge branch 'ull' into test
    
    Conflicts:
            drivers/acpi/bay.c
            drivers/acpi/dock.c
            drivers/ata/libata-acpi.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 5f50ef453dcb05115fc98f244b8f10bfacd4b8b7
Merge: 530bc23bfeaa e3deda9c87ac
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:28:38 2008 -0400

    Merge branch 'misc' into test

commit 55ac9a018f83e4f42f3c6ce98a8dbda73b985935
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Sun Sep 28 14:51:56 2008 +0800

    ACPI: replace ACPI_DEBUG_PRINT((ACPI_DB_ERROR, ...) with printk
    
    ACPI_DB_ERROR and ACPI_DB_WARN were removed from ACPICA core.
    So replace ACPI_DEBUG_PRINT((ACPI_DB_ERROR, ...) with printk(KERN_ERR PREFIX ...)
    and ACPI_DEBUG_PRINT((ACPI_DB_WARN, ...) with printk(KERN_WARNING PREFIX ...)
    
    We do not use ACPI_ERROR/ACPI_WARNING since they're not exported, see
    -------------------------------------------------------------
    commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
    Author: Len Brown <len.brown@intel.com>
    Date:   Mon Jun 26 23:41:38 2006 -0400
    
        ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    -------------------------------------------------------------
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 912703691d36..263ec08a9011 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1213,8 +1213,8 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 				  acpi_bus_private_data_handler,
 				  tz->thermal_zone);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				"Error attaching device data\n"));
+		printk(KERN_ERR PREFIX
+				"Error attaching device data\n");
 		return -ENODEV;
 	}
 

commit 22a94d79a34bf010d11996d30eed8ee3fc1a4fbf
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Oct 17 02:41:20 2008 -0400

    ACPI: Allow overriding to higher critical trip point.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9129
    
    lenb: Note that overriding a critical trip point
    may simply fool the user into thinking that they
    have control that they do not actually have.
    For it is EC firmware that decides when the EC
    sends Linux temperature change events, and the
    EC may or may not decide to send Linux these events
    anywhere in the neighborhood of the fake
    override trip points.  Beware.
    
    note also that thermal.nocrt is already available
    to disable crtical trip point actios,
    and thermal.crt=-1 is already available to
    disabled critical trip points entirely.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index e052a75c29ce..e9e17dfc5dc2 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -388,10 +388,12 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 			} else if (crt > 0) {
 				unsigned long crt_k = CELSIUS_TO_KELVIN(crt);
 				/*
-				 * Allow override to lower critical threshold
+				 * Allow override critical threshold
 				 */
-				if (crt_k < tz->trips.critical.temperature)
-					tz->trips.critical.temperature = crt_k;
+				if (crt_k > tz->trips.critical.temperature)
+					printk(KERN_WARNING PREFIX
+						"Critical threshold %d C\n", crt);
+				tz->trips.critical.temperature = crt_k;
 			}
 		}
 	}

commit 27663c5855b10af9ec67bc7dfba001426ba21222
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Oct 10 02:22:59 2008 -0400

    ACPI: Change acpi_evaluate_integer to support 64-bit on 32-bit kernels
    
    As of version 2.0, ACPI can return 64-bit integers.  The current
    acpi_evaluate_integer only supports 64-bit integers on 64-bit platforms.
    Change the argument to take a pointer to an acpi_integer so we support
    64-bit integers on all platforms.
    
    lenb: replaced use of "acpi_integer" with "unsigned long long"
    lenb: fixed bug in acpi_thermal_trips_update()
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 912703691d36..47abb94bdfb9 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -246,18 +246,18 @@ static const struct file_operations acpi_thermal_polling_fops = {
 static int acpi_thermal_get_temperature(struct acpi_thermal *tz)
 {
 	acpi_status status = AE_OK;
-
+	unsigned long long tmp;
 
 	if (!tz)
 		return -EINVAL;
 
 	tz->last_temperature = tz->temperature;
 
-	status =
-	    acpi_evaluate_integer(tz->device->handle, "_TMP", NULL, &tz->temperature);
+	status = acpi_evaluate_integer(tz->device->handle, "_TMP", NULL, &tmp);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
+	tz->temperature = tmp;
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n",
 			  tz->temperature));
 
@@ -267,17 +267,16 @@ static int acpi_thermal_get_temperature(struct acpi_thermal *tz)
 static int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)
 {
 	acpi_status status = AE_OK;
-
+	unsigned long long tmp;
 
 	if (!tz)
 		return -EINVAL;
 
-	status =
-	    acpi_evaluate_integer(tz->device->handle, "_TZP", NULL,
-				  &tz->polling_frequency);
+	status = acpi_evaluate_integer(tz->device->handle, "_TZP", NULL, &tmp);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
+	tz->polling_frequency = tmp;
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n",
 			  tz->polling_frequency));
 
@@ -356,6 +355,7 @@ do {	\
 static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 {
 	acpi_status status = AE_OK;
+	unsigned long long tmp;
 	struct acpi_handle_list devices;
 	int valid = 0;
 	int i;
@@ -363,7 +363,8 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 	/* Critical Shutdown (required) */
 	if (flag & ACPI_TRIPS_CRITICAL) {
 		status = acpi_evaluate_integer(tz->device->handle,
-				"_CRT", NULL, &tz->trips.critical.temperature);
+				"_CRT", NULL, &tmp);
+		tz->trips.critical.temperature = tmp;
 		/*
 		 * Treat freezing temperatures as invalid as well; some
 		 * BIOSes return really low values and cause reboots at startup.
@@ -399,12 +400,13 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 	/* Critical Sleep (optional) */
 	if (flag & ACPI_TRIPS_HOT) {
 		status = acpi_evaluate_integer(tz->device->handle,
-				"_HOT", NULL, &tz->trips.hot.temperature);
+				"_HOT", NULL, &tmp);
 		if (ACPI_FAILURE(status)) {
 			tz->trips.hot.flags.valid = 0;
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					"No hot threshold\n"));
 		} else {
+			tz->trips.hot.temperature = tmp;
 			tz->trips.hot.flags.valid = 1;
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					"Found hot threshold [%lu]\n",
@@ -418,33 +420,40 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 		if (psv == -1) {
 			status = AE_SUPPORT;
 		} else if (psv > 0) {
-			tz->trips.passive.temperature = CELSIUS_TO_KELVIN(psv);
+			tmp = CELSIUS_TO_KELVIN(psv);
 			status = AE_OK;
 		} else {
 			status = acpi_evaluate_integer(tz->device->handle,
-				"_PSV", NULL, &tz->trips.passive.temperature);
+				"_PSV", NULL, &tmp);
 		}
 
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 		else {
+			tz->trips.passive.temperature = tmp;
 			tz->trips.passive.flags.valid = 1;
 			if (flag == ACPI_TRIPS_INIT) {
 				status = acpi_evaluate_integer(
 						tz->device->handle, "_TC1",
-						NULL, &tz->trips.passive.tc1);
+						NULL, &tmp);
 				if (ACPI_FAILURE(status))
 					tz->trips.passive.flags.valid = 0;
+				else
+					tz->trips.passive.tc1 = tmp;
 				status = acpi_evaluate_integer(
 						tz->device->handle, "_TC2",
-						NULL, &tz->trips.passive.tc2);
+						NULL, &tmp);
 				if (ACPI_FAILURE(status))
 					tz->trips.passive.flags.valid = 0;
+				else
+					tz->trips.passive.tc2 = tmp;
 				status = acpi_evaluate_integer(
 						tz->device->handle, "_TSP",
-						NULL, &tz->trips.passive.tsp);
+						NULL, &tmp);
 				if (ACPI_FAILURE(status))
 					tz->trips.passive.flags.valid = 0;
+				else
+					tz->trips.passive.tsp = tmp;
 			}
 		}
 	}
@@ -479,7 +488,7 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 
 		if (flag & ACPI_TRIPS_ACTIVE) {
 			status = acpi_evaluate_integer(tz->device->handle,
-				name, NULL, &tz->trips.active[i].temperature);
+							name, NULL, &tmp);
 			if (ACPI_FAILURE(status)) {
 				tz->trips.active[i].flags.valid = 0;
 				if (i == 0)
@@ -500,8 +509,10 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 						tz->trips.active[i - 2].temperature :
 						CELSIUS_TO_KELVIN(act));
 				break;
-			} else
+			} else {
+				tz->trips.active[i].temperature = tmp;
 				tz->trips.active[i].flags.valid = 1;
+			}
 		}
 
 		name[2] = 'L';

commit db89b4f0dbab837d0f3de2c3e9427a8d5393afa3
Author: Pavel Machek <pavel@suse.cz>
Date:   Mon Sep 22 14:37:34 2008 -0700

    ACPI: catch calls of acpi_driver_data on pointer of wrong type
    
    Catch attempts to use of acpi_driver_data on pointers of wrong type.
    
    akpm: rewritten to use proper C typechecking and remove the
    "function"-used-as-lvalue thing.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 912703691d36..e052a75c29ce 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1647,7 +1647,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 	strcpy(tz->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);
-	acpi_driver_data(device) = tz;
+	device->driver_data = tz;
 	mutex_init(&tz->lock);
 
 

commit 1481b9109fe771ec8b035d7760f42e36d2bed5d4
Merge: 5042d99795d3 f88133d76ea3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 24 13:57:37 2008 -0700

    Merge branch 'release-2.6.27' of git://git.kernel.org/pub/scm/linux/kernel/git/ak/linux-acpi-2.6
    
    * 'release-2.6.27' of git://git.kernel.org/pub/scm/linux/kernel/git/ak/linux-acpi-2.6:
      acpi: fix crash in core ACPI code, triggered by CONFIG_ACPI_PCI_SLOT=y
      ACPI: thinkpad-acpi: don't misdetect in get_thinkpad_model_data() on -ENOMEM
      ACPI: thinkpad-acpi: bump up version to 0.21
      ACPI: thinkpad-acpi: add bluetooth and WWAN rfkill support
      ACPI: thinkpad-acpi: WLSW overrides other rfkill switches
      ACPI: thinkpad-acpi: prepare for bluetooth and wwan rfkill support
      ACPI: thinkpad-acpi: consolidate wlsw notification function
      ACPI: thinkpad-acpi: minor refactor on radio switch init
      Revert "ACPI: don't walk tables if ACPI was disabled"
      Revert "dock: bay: Don't call acpi_walk_namespace() when ACPI is disabled."
      Revert "Fix FADT parsing"
      ACPI : Set FAN device to correct state in boot phase
      ACPI: Ignore _BQC object when registering backlight device
      ACPI: stop complaints about interrupt link End Tags and blank IRQ descriptors

commit fc3a8828b139c24aade3f9d608775e36c248f8f5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 2 06:02:41 2008 +0200

    driver core: fix a lot of printk usages of bus_id
    
    We have the dev_printk() variants for this kind of thing, use them
    instead of directly trying to access the bus_id field of struct device.
    
    This is done in order to remove bus_id entirely.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 84c795fb9b1e..30a341337933 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1179,8 +1179,8 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 
 	tz->tz_enabled = 1;
 
-	printk(KERN_INFO PREFIX "%s is registered as thermal_zone%d\n",
-			tz->device->dev.bus_id, tz->thermal_zone->id);
+	dev_info(&tz->device->dev, "registered as thermal_zone%d\n",
+		 tz->thermal_zone->id);
 	return 0;
 }
 

commit ea51011a27db48ea0a80a5e20de3969b292d5d4d
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Jul 14 15:14:03 2008 +0800

    ACPI : Set FAN device to correct state in boot phase
    
    Subject:ACPI: Set FAN device to correct state in boot phase
    From: Zhao Yakui <yakui.zhao@intel.com>
    
    On some laptops when ACPI FAN driver is loaded, maybe the FAN device will be
    turned on. But if the temperature is below the threshold, the corresponding
    FAN device should be turned off in the course of loading thermal driver.
    
    So it is necessary to set the FAN device to the correct state in course of loading
    the thermal driver.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8049
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 84c795fb9b1e..9adfd180df6a 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -769,6 +769,47 @@ static void acpi_thermal_run(unsigned long data)
 		acpi_os_execute(OSL_GPE_HANDLER, acpi_thermal_check, (void *)data);
 }
 
+static void acpi_thermal_active_off(void *data)
+{
+	int result = 0;
+	struct acpi_thermal *tz = data;
+	int i = 0;
+	int j = 0;
+	struct acpi_thermal_active *active = NULL;
+
+	if (!tz) {
+		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
+		return;
+	}
+
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		return;
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
+		active = &(tz->trips.active[i]);
+		if (!active || !active->flags.valid)
+			break;
+		if (tz->temperature >= active->temperature) {
+			/*
+			 * If the thermal temperature is greater than the
+			 * active threshod, unnecessary to turn off the
+			 * the active cooling device.
+			 */
+			continue;
+		}
+		/*
+		 * Below Threshold?
+		 * ----------------
+		 * Turn OFF all cooling devices associated with this
+		 * threshold.
+		 */
+		for (j = 0; j < active->devices.count; j++)
+			result = acpi_bus_set_power(active->devices.handles[j],
+						    ACPI_STATE_D3);
+	}
+}
+
 static void acpi_thermal_check(void *data)
 {
 	int result = 0;
@@ -1624,6 +1665,8 @@ static int acpi_thermal_add(struct acpi_device *device)
 
 	init_timer(&tz->timer);
 
+	acpi_thermal_active_off(tz);
+
 	acpi_thermal_check(tz);
 
 	status = acpi_install_notify_handler(device->handle,

commit a39a2d7c72b358c6253a2ec28e17b023b7f6f41c
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon May 19 15:55:15 2008 -0700

    ACPI: Reject below-freezing temperatures as invalid critical temperatures
    
    My laptop thinks that it's a good idea to give -73C as the critical
    CPU temperature.... which isn't the best thing since it causes a shutdown
    right at bootup.
    
    Temperatures below freezing are clearly invalid critical thresholds
    so just reject these as such.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 504385b1f211..84c795fb9b1e 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -364,10 +364,17 @@ static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
 	if (flag & ACPI_TRIPS_CRITICAL) {
 		status = acpi_evaluate_integer(tz->device->handle,
 				"_CRT", NULL, &tz->trips.critical.temperature);
-		if (ACPI_FAILURE(status)) {
+		/*
+		 * Treat freezing temperatures as invalid as well; some
+		 * BIOSes return really low values and cause reboots at startup.
+		 * Below zero (Celcius) values clearly aren't right for sure..
+		 * ... so lets discard those as invalid.
+		 */
+		if (ACPI_FAILURE(status) ||
+				tz->trips.critical.temperature <= 2732) {
 			tz->trips.critical.flags.valid = 0;
 			ACPI_EXCEPTION((AE_INFO, status,
-					"No critical threshold"));
+					"No or invalid critical threshold"));
 			return -ENODEV;
 		} else {
 			tz->trips.critical.flags.valid = 1;

commit 08acd4f8af42affd8cbed81cc1b69fa12ddb213f
Merge: ccf2779544ee 008238b54ac2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 30 11:52:52 2008 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (179 commits)
      ACPI: Fix acpi_processor_idle and idle= boot parameters interaction
      acpi: fix section mismatch warning in pnpacpi
      intel_menlo: fix build warning
      ACPI: Cleanup: Remove unneeded, multiple local dummy variables
      ACPI: video - fix permissions on some proc entries
      ACPI: video - properly handle errors when registering proc elements
      ACPI: video - do not store invalid entries in attached_array list
      ACPI: re-name acpi_pm_ops to acpi_suspend_ops
      ACER_WMI/ASUS_LAPTOP: fix build bug
      thinkpad_acpi: fix possible NULL pointer dereference if kstrdup failed
      ACPI: check a return value correctly in acpi_power_get_context()
      #if 0 acpi/bay.c:eject_removable_drive()
      eeepc-laptop: add hwmon fan control
      eeepc-laptop: add backlight
      eeepc-laptop: add base driver
      ACPI: thinkpad-acpi: bump up version to 0.20
      ACPI: thinkpad-acpi: fix selects in Kconfig
      ACPI: thinkpad-acpi: use a private workqueue
      ACPI: thinkpad-acpi: fluff really minor fix
      ACPI: thinkpad-acpi: use uppercase for "LED" on user documentation
      ...
    
    Fixed conflicts in drivers/acpi/video.c and drivers/misc/intel_menlow.c
    manually.

commit cf7acfab032ff262f42954328cdfd20a5d9aaaac
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Apr 29 01:02:27 2008 -0700

    acpi: use non-racy method for proc entries creation
    
    Use proc_create()/proc_create_data() to make sure that ->proc_fops and ->data
    be setup before gluing PDE to main tree.
    
    Add correct ->owner to proc_fops to fix reading/module unloading race.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 766bd25d3376..0815ac3ae3d6 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -198,6 +198,7 @@ struct acpi_thermal {
 };
 
 static const struct file_operations acpi_thermal_state_fops = {
+	.owner = THIS_MODULE,
 	.open = acpi_thermal_state_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
@@ -205,6 +206,7 @@ static const struct file_operations acpi_thermal_state_fops = {
 };
 
 static const struct file_operations acpi_thermal_temp_fops = {
+	.owner = THIS_MODULE,
 	.open = acpi_thermal_temp_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
@@ -212,6 +214,7 @@ static const struct file_operations acpi_thermal_temp_fops = {
 };
 
 static const struct file_operations acpi_thermal_trip_fops = {
+	.owner = THIS_MODULE,
 	.open = acpi_thermal_trip_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
@@ -219,6 +222,7 @@ static const struct file_operations acpi_thermal_trip_fops = {
 };
 
 static const struct file_operations acpi_thermal_cooling_fops = {
+	.owner = THIS_MODULE,
 	.open = acpi_thermal_cooling_open_fs,
 	.read = seq_read,
 	.write = acpi_thermal_write_cooling_mode,
@@ -227,6 +231,7 @@ static const struct file_operations acpi_thermal_cooling_fops = {
 };
 
 static const struct file_operations acpi_thermal_polling_fops = {
+	.owner = THIS_MODULE,
 	.open = acpi_thermal_polling_open_fs,
 	.read = seq_read,
 	.write = acpi_thermal_write_polling,
@@ -1419,63 +1424,47 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 	}
 
 	/* 'state' [R] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
-				  S_IRUGO, acpi_device_dir(device));
+	entry = proc_create_data(ACPI_THERMAL_FILE_STATE,
+				 S_IRUGO, acpi_device_dir(device),
+				 &acpi_thermal_state_fops,
+				 acpi_driver_data(device));
 	if (!entry)
 		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_thermal_state_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
 
 	/* 'temperature' [R] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
-				  S_IRUGO, acpi_device_dir(device));
+	entry = proc_create_data(ACPI_THERMAL_FILE_TEMPERATURE,
+				 S_IRUGO, acpi_device_dir(device),
+				 &acpi_thermal_temp_fops,
+				 acpi_driver_data(device));
 	if (!entry)
 		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_thermal_temp_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
 
 	/* 'trip_points' [R] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
-				  S_IRUGO,
-				  acpi_device_dir(device));
+	entry = proc_create_data(ACPI_THERMAL_FILE_TRIP_POINTS,
+				 S_IRUGO,
+				 acpi_device_dir(device),
+				 &acpi_thermal_trip_fops,
+				 acpi_driver_data(device));
 	if (!entry)
 		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_thermal_trip_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
 
 	/* 'cooling_mode' [R/W] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
-				  S_IFREG | S_IRUGO | S_IWUSR,
-				  acpi_device_dir(device));
+	entry = proc_create_data(ACPI_THERMAL_FILE_COOLING_MODE,
+				 S_IFREG | S_IRUGO | S_IWUSR,
+				 acpi_device_dir(device),
+				 &acpi_thermal_cooling_fops,
+				 acpi_driver_data(device));
 	if (!entry)
 		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_thermal_cooling_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
 
 	/* 'polling_frequency' [R/W] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
-				  S_IFREG | S_IRUGO | S_IWUSR,
-				  acpi_device_dir(device));
+	entry = proc_create_data(ACPI_THERMAL_FILE_POLLING_FREQ,
+				 S_IFREG | S_IRUGO | S_IWUSR,
+				 acpi_device_dir(device),
+				 &acpi_thermal_polling_fops,
+				 acpi_driver_data(device));
 	if (!entry)
 		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_thermal_polling_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
 	return 0;
 }
 

commit 76ecb4f2d7ea5c3aac8970b9529775316507c6d2
Author: Zhang, Rui <rui.zhang@intel.com>
Date:   Thu Apr 10 16:20:23 2008 +0800

    ACPI: update thermal temperature
    
    Fix the problem that thermal_get_temp returns the cached value,
    which causes the temperature in generic thermal never updates.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5e9641c93fcd..782c2250443e 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -884,10 +884,15 @@ static void acpi_thermal_check(void *data)
 static int thermal_get_temp(struct thermal_zone_device *thermal, char *buf)
 {
 	struct acpi_thermal *tz = thermal->devdata;
+	int result;
 
 	if (!tz)
 		return -EINVAL;
 
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		return result;
+
 	return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(tz->temperature));
 }
 

commit e9ae71078b2c8657c0e8de808b76b76049806906
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Apr 22 08:50:09 2008 +0800

    thermal: update the documentation
    
    Update the documentation for the thermal driver hwmon sys I/F.
    
    Change the ACPI thermal zone type to be consistent with hwmon.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index ec707ed1a70f..5e9641c93fcd 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1136,7 +1136,7 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
 			tz->trips.active[i].flags.valid; i++, trips++);
-	tz->thermal_zone = thermal_zone_device_register("ACPI thermal zone",
+	tz->thermal_zone = thermal_zone_device_register("acpitz",
 					trips, tz, &acpi_thermal_zone_ops);
 	if (IS_ERR(tz->thermal_zone))
 		return -ENODEV;

commit 9ec732ff80b7e8a9096666f78ae584d3b393bc84
Author: Zhang, Rui <rui.zhang@intel.com>
Date:   Thu Apr 10 16:13:10 2008 +0800

    thermal: add new get_crit_temp callback
    
    Add a new callback so that the generic thermal can get
    the critical trip point info of a thermal zone,
    which is needed for building the tempX_crit hwmon sysfs attribute.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 766bd25d3376..ec707ed1a70f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1012,6 +1012,18 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 	return -EINVAL;
 }
 
+static int thermal_get_crit_temp(struct thermal_zone_device *thermal,
+				unsigned long *temperature) {
+	struct acpi_thermal *tz = thermal->devdata;
+
+	if (tz->trips.critical.flags.valid) {
+		*temperature = KELVIN_TO_MILLICELSIUS(
+				tz->trips.critical.temperature);
+		return 0;
+	} else
+		return -EINVAL;
+}
+
 typedef int (*cb)(struct thermal_zone_device *, int,
 		  struct thermal_cooling_device *);
 static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
@@ -1103,6 +1115,7 @@ static struct thermal_zone_device_ops acpi_thermal_zone_ops = {
 	.set_mode = thermal_set_mode,
 	.get_trip_type = thermal_get_trip_type,
 	.get_trip_temp = thermal_get_trip_temp,
+	.get_crit_temp = thermal_get_crit_temp,
 };
 
 static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)

commit d83fd8a26769c75d51a6b05d8dcb3e36302dd8ba
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Apr 28 02:14:13 2008 -0700

    drivers/acpi/thermal.c: fix build with CONFIG_DMI=n
    
    drivers/acpi/thermal.c: In function 'acpi_thermal_init':
    drivers/acpi/thermal.c:1794: error: 'thermal_dmi_table' undeclared (first use in this function)
    drivers/acpi/thermal.c:1794: error: (Each undeclared identifier is reported only once
    drivers/acpi/thermal.c:1794: error: for each function it appears in.)
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1bcecc7dd2ca..766bd25d3376 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1710,7 +1710,6 @@ static int acpi_thermal_resume(struct acpi_device *device)
 	return AE_OK;
 }
 
-#ifdef CONFIG_DMI
 static int thermal_act(const struct dmi_system_id *d) {
 
 	if (act == 0) {
@@ -1785,7 +1784,6 @@ static struct dmi_system_id thermal_dmi_table[] __initdata = {
 	},
 	{}
 };
-#endif /* CONFIG_DMI */
 
 static int __init acpi_thermal_init(void)
 {

commit bb070e43497d4fcfea7d8b52003fe1376c218343
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Tue Apr 8 17:41:52 2008 -0700

    acpi thermal: fix result check
    
    thermal_zone_device_register() uses the ERR_PTR macro on its return values.  A
    correct check is to use the IS_ERR() macro.
    
    The 2.6.25 kernels panic on Compaq AP550 without this patch as it has more
    then 10 (THERMAL_MAX_TRIPS) trip points (there are 12).
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index c4e00ac8ea85..1bcecc7dd2ca 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1125,7 +1125,7 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 			tz->trips.active[i].flags.valid; i++, trips++);
 	tz->thermal_zone = thermal_zone_device_register("ACPI thermal zone",
 					trips, tz, &acpi_thermal_zone_ops);
-	if (!tz->thermal_zone)
+	if (IS_ERR(tz->thermal_zone))
 		return -ENODEV;
 
 	result = sysfs_create_link(&tz->device->dev.kobj,

commit 5e012760dfd5ec24c41b9eab9e654a88360bb026
Author: Zhang, Rui <rui.zhang@intel.com>
Date:   Thu Feb 28 07:51:30 2008 +0800

    ACPI: thermal: show temperature in millidegree Celsius
    
    as now required by the generic thermal I/F
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 8d4b79b4f933..c4e00ac8ea85 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -879,6 +879,8 @@ static void acpi_thermal_check(void *data)
 }
 
 /* sys I/F for generic thermal sysfs support */
+#define KELVIN_TO_MILLICELSIUS(t) (t * 100 - 273200)
+
 static int thermal_get_temp(struct thermal_zone_device *thermal, char *buf)
 {
 	struct acpi_thermal *tz = thermal->devdata;
@@ -886,7 +888,7 @@ static int thermal_get_temp(struct thermal_zone_device *thermal, char *buf)
 	if (!tz)
 		return -EINVAL;
 
-	return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(tz->temperature));
+	return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(tz->temperature));
 }
 
 static const char enabled[] = "kernel";
@@ -980,21 +982,21 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 
 	if (tz->trips.critical.flags.valid) {
 		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
 				tz->trips.critical.temperature));
 		trip--;
 	}
 
 	if (tz->trips.hot.flags.valid) {
 		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
 					tz->trips.hot.temperature));
 		trip--;
 	}
 
 	if (tz->trips.passive.flags.valid) {
 		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
 					tz->trips.passive.temperature));
 		trip--;
 	}
@@ -1002,7 +1004,7 @@ static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
 		tz->trips.active[i].flags.valid; i++) {
 		if (!trip)
-			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+			return sprintf(buf, "%ld\n", KELVIN_TO_MILLICELSIUS(
 					tz->trips.active[i].temperature));
 		trip--;
 	}

commit 26b6f2236615649a0ae6a0de2e9e71a2f9ffeba7
Merge: e5e54bc86a1f e5e54bc86a1f 3c602840528c
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:18:04 2008 -0500

    Merge branches 'release' and 'menlo' into release
    
    Conflicts:
    
            drivers/acpi/video.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 653a00c9662304ef72a3eb4e681c91720960e0b4
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 17 15:51:18 2008 +0800

    ACPI: thermal fixup
    
    The alias name may be used in _PSL, _ALx and _TZD,
    so we bind the cooling device only if the acpi_device node matches.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Thomas Sujith <sujith.thomas@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index aee371f9daf8..73f276bc6e4f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1015,7 +1015,9 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 {
 	struct acpi_device *device = cdev->devdata;
 	struct acpi_thermal *tz = thermal->devdata;
-	acpi_handle handle = device->handle;
+	struct acpi_device *dev;
+	acpi_status status;
+	acpi_handle handle;
 	int i;
 	int j;
 	int trip = -1;
@@ -1031,12 +1033,13 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 		trip++;
 		for (i = 0; i < tz->trips.passive.devices.count;
 		    i++) {
-			if (tz->trips.passive.devices.handles[i] !=
-				handle)
-				continue;
-			result = action(thermal, trip, cdev);
-			if (result)
-				goto failed;
+			handle = tz->trips.passive.devices.handles[i];
+			status = acpi_bus_get_device(handle, &dev);
+			if (ACPI_SUCCESS(status) && (dev == device)) {
+				result = action(thermal, trip, cdev);
+				if (result)
+					goto failed;
+			}
 		}
 	}
 
@@ -1047,21 +1050,24 @@ static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
 		for (j = 0;
 		    j < tz->trips.active[i].devices.count;
 		    j++) {
-			if (tz->trips.active[i].devices.
-						handles[j] != handle)
-				continue;
-			result = action(thermal, trip, cdev);
-			if (result)
-				goto failed;
+			handle = tz->trips.active[i].devices.handles[j];
+			status = acpi_bus_get_device(handle, &dev);
+			if (ACPI_SUCCESS(status) && (dev == device)) {
+				result = action(thermal, trip, cdev);
+				if (result)
+					goto failed;
+			}
 		}
 	}
 
 	for (i = 0; i < tz->devices.count; i++) {
-		if (tz->devices.handles[i] != handle)
-			continue;
-		result = action(thermal, -1, cdev);
-		if (result)
-			goto failed;
+		handle = tz->devices.handles[i];
+		status = acpi_bus_get_device(handle, &dev);
+		if (ACPI_SUCCESS(status) && (dev == device)) {
+			result = action(thermal, -1, cdev);
+			if (result)
+				goto failed;
+		}
 	}
 
 failed:

commit 041d4bbf128f645fe53bb22309efb9db14dbf5b5
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 17 15:51:19 2008 +0800

    ACPI: CELSIUS_TO_KELVIN fixup
    
    Fix an imprecision in CELSIUS_TO_KELVIN and move these
    two macroes to a proper place.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Thomas Sujith <sujith.thomas@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 740036355722..aee371f9daf8 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -65,9 +65,6 @@
 #define ACPI_THERMAL_MAX_ACTIVE	10
 #define ACPI_THERMAL_MAX_LIMIT_STR_LEN 65
 
-#define KELVIN_TO_CELSIUS(t)    (long)(((long)t-2732>=0) ? ((long)t-2732+5)/10 : ((long)t-2732-5)/10)
-#define CELSIUS_TO_KELVIN(t)	((t+273)*10)
-
 #define _COMPONENT		ACPI_THERMAL_COMPONENT
 ACPI_MODULE_NAME("thermal");
 

commit 207339398ecb0835331c748612898dad2a09fdec
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 17 15:51:21 2008 +0800

    ACPI: attach thermal zone info
    
    Intel menlow driver needs to get the pointer of themal_zone_device
    structure of an ACPI thermal zone.
    Attach this to each ACPI thermal zone device object.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Thomas Sujith <sujith.thomas@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index d317da5c6e9c..740036355722 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1101,6 +1101,7 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 {
 	int trips = 0;
 	int result;
+	acpi_status status;
 	int i;
 
 	if (tz->trips.critical.flags.valid)
@@ -1129,6 +1130,15 @@ static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
 	if (result)
 		return result;
 
+	status = acpi_attach_data(tz->device->handle,
+				  acpi_bus_private_data_handler,
+				  tz->thermal_zone);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Error attaching device data\n"));
+		return -ENODEV;
+	}
+
 	tz->tz_enabled = 1;
 
 	printk(KERN_INFO PREFIX "%s is registered as thermal_zone%d\n",
@@ -1142,6 +1152,7 @@ static void acpi_thermal_unregister_thermal_zone(struct acpi_thermal *tz)
 	sysfs_remove_link(&tz->thermal_zone->device.kobj, "device");
 	thermal_zone_device_unregister(tz->thermal_zone);
 	tz->thermal_zone = NULL;
+	acpi_detach_data(tz->device->handle, acpi_bus_private_data_handler);
 }
 
 

commit ce44e19701ac1de004815c225585ff617c5948b4
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 17 15:51:25 2008 +0800

    ACPI: ACPI thermal zone handle notification correctly
    
    Change the ACPI thermal action upon notification 0x81 and 0x82.
    
    According to the ACPI spec, we should:
    re-evaluate _PSV and _ACx methods upon notification 0x81
    re-evaluate _PSL and _ALx and _TZD upon notificaiton 0x82.
    But the current code re-evaluates all the trip points for 0x81 while
    only re-evaluates _TZD for 0x82.
    
    Fix this violation of ACPI spec.
    
    TODO: devices in _PSL, _ALx and _TZD may change after a notification 0x82.
          At this time, we need to re-bind the cooling devices with the thermal zone.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Thomas Sujith <sujith.thomas@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index c6cfce4c0122..d317da5c6e9c 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -323,173 +323,221 @@ static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 	return 0;
 }
 
-static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
-{
-	acpi_status status = AE_OK;
-	int i = 0;
+#define ACPI_TRIPS_CRITICAL	0x01
+#define ACPI_TRIPS_HOT		0x02
+#define ACPI_TRIPS_PASSIVE	0x04
+#define ACPI_TRIPS_ACTIVE	0x08
+#define ACPI_TRIPS_DEVICES	0x10
 
+#define ACPI_TRIPS_REFRESH_THRESHOLDS	(ACPI_TRIPS_PASSIVE | ACPI_TRIPS_ACTIVE)
+#define ACPI_TRIPS_REFRESH_DEVICES	ACPI_TRIPS_DEVICES
 
-	if (!tz)
-		return -EINVAL;
+#define ACPI_TRIPS_INIT      (ACPI_TRIPS_CRITICAL | ACPI_TRIPS_HOT |	\
+			      ACPI_TRIPS_PASSIVE | ACPI_TRIPS_ACTIVE |	\
+			      ACPI_TRIPS_DEVICES)
 
-	/* Critical Shutdown (required) */
-
-	status = acpi_evaluate_integer(tz->device->handle, "_CRT", NULL,
-				       &tz->trips.critical.temperature);
-	if (ACPI_FAILURE(status)) {
-		tz->trips.critical.flags.valid = 0;
-		ACPI_EXCEPTION((AE_INFO, status, "No critical threshold"));
-		return -ENODEV;
-	} else {
-		tz->trips.critical.flags.valid = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Found critical threshold [%lu]\n",
-				  tz->trips.critical.temperature));
-	}
+/*
+ * This exception is thrown out in two cases:
+ * 1.An invalid trip point becomes invalid or a valid trip point becomes invalid
+ *   when re-evaluating the AML code.
+ * 2.TODO: Devices listed in _PSL, _ALx, _TZD may change.
+ *   We need to re-bind the cooling devices of a thermal zone when this occurs.
+ */
+#define ACPI_THERMAL_TRIPS_EXCEPTION(flags, str)	\
+do {	\
+	if (flags != ACPI_TRIPS_INIT)	\
+		ACPI_EXCEPTION((AE_INFO, AE_ERROR,	\
+		"ACPI thermal trip point %s changed\n"	\
+		"Please send acpidump to linux-acpi@vger.kernel.org\n", str)); \
+} while (0)
+
+static int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)
+{
+	acpi_status status = AE_OK;
+	struct acpi_handle_list devices;
+	int valid = 0;
+	int i;
 
-	if (tz->trips.critical.flags.valid == 1) {
-		if (crt == -1) {
+	/* Critical Shutdown (required) */
+	if (flag & ACPI_TRIPS_CRITICAL) {
+		status = acpi_evaluate_integer(tz->device->handle,
+				"_CRT", NULL, &tz->trips.critical.temperature);
+		if (ACPI_FAILURE(status)) {
 			tz->trips.critical.flags.valid = 0;
-		} else if (crt > 0) {
-			unsigned long crt_k = CELSIUS_TO_KELVIN(crt);
-
-			/*
-			 * Allow override to lower critical threshold
-			 */
-			if (crt_k < tz->trips.critical.temperature)
-				tz->trips.critical.temperature = crt_k;
+			ACPI_EXCEPTION((AE_INFO, status,
+					"No critical threshold"));
+			return -ENODEV;
+		} else {
+			tz->trips.critical.flags.valid = 1;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"Found critical threshold [%lu]\n",
+					tz->trips.critical.temperature));
+		}
+		if (tz->trips.critical.flags.valid == 1) {
+			if (crt == -1) {
+				tz->trips.critical.flags.valid = 0;
+			} else if (crt > 0) {
+				unsigned long crt_k = CELSIUS_TO_KELVIN(crt);
+				/*
+				 * Allow override to lower critical threshold
+				 */
+				if (crt_k < tz->trips.critical.temperature)
+					tz->trips.critical.temperature = crt_k;
+			}
 		}
 	}
 
 	/* Critical Sleep (optional) */
-
-	status =
-	    acpi_evaluate_integer(tz->device->handle, "_HOT", NULL,
-				  &tz->trips.hot.temperature);
-	if (ACPI_FAILURE(status)) {
-		tz->trips.hot.flags.valid = 0;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No hot threshold\n"));
-	} else {
-		tz->trips.hot.flags.valid = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%lu]\n",
-				  tz->trips.hot.temperature));
-	}
-
-	/* Passive: Processors (optional) */
-
-	if (psv == -1) {
-		status = AE_SUPPORT;
-	} else if (psv > 0) {
-		tz->trips.passive.temperature = CELSIUS_TO_KELVIN(psv);
-		status = AE_OK;
-	} else {
+	if (flag & ACPI_TRIPS_HOT) {
 		status = acpi_evaluate_integer(tz->device->handle,
-			"_PSV", NULL, &tz->trips.passive.temperature);
+				"_HOT", NULL, &tz->trips.hot.temperature);
+		if (ACPI_FAILURE(status)) {
+			tz->trips.hot.flags.valid = 0;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"No hot threshold\n"));
+		} else {
+			tz->trips.hot.flags.valid = 1;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"Found hot threshold [%lu]\n",
+					tz->trips.critical.temperature));
+		}
 	}
 
-	if (ACPI_FAILURE(status)) {
-		tz->trips.passive.flags.valid = 0;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No passive threshold\n"));
-	} else {
-		tz->trips.passive.flags.valid = 1;
-
-		status =
-		    acpi_evaluate_integer(tz->device->handle, "_TC1", NULL,
-					  &tz->trips.passive.tc1);
-		if (ACPI_FAILURE(status))
-			tz->trips.passive.flags.valid = 0;
-
-		status =
-		    acpi_evaluate_integer(tz->device->handle, "_TC2", NULL,
-					  &tz->trips.passive.tc2);
-		if (ACPI_FAILURE(status))
-			tz->trips.passive.flags.valid = 0;
+	/* Passive (optional) */
+	if (flag & ACPI_TRIPS_PASSIVE) {
+		valid = tz->trips.passive.flags.valid;
+		if (psv == -1) {
+			status = AE_SUPPORT;
+		} else if (psv > 0) {
+			tz->trips.passive.temperature = CELSIUS_TO_KELVIN(psv);
+			status = AE_OK;
+		} else {
+			status = acpi_evaluate_integer(tz->device->handle,
+				"_PSV", NULL, &tz->trips.passive.temperature);
+		}
 
-		status =
-		    acpi_evaluate_integer(tz->device->handle, "_TSP", NULL,
-					  &tz->trips.passive.tsp);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
-
-		status =
-		    acpi_evaluate_reference(tz->device->handle, "_PSL", NULL,
-					    &tz->trips.passive.devices);
+		else {
+			tz->trips.passive.flags.valid = 1;
+			if (flag == ACPI_TRIPS_INIT) {
+				status = acpi_evaluate_integer(
+						tz->device->handle, "_TC1",
+						NULL, &tz->trips.passive.tc1);
+				if (ACPI_FAILURE(status))
+					tz->trips.passive.flags.valid = 0;
+				status = acpi_evaluate_integer(
+						tz->device->handle, "_TC2",
+						NULL, &tz->trips.passive.tc2);
+				if (ACPI_FAILURE(status))
+					tz->trips.passive.flags.valid = 0;
+				status = acpi_evaluate_integer(
+						tz->device->handle, "_TSP",
+						NULL, &tz->trips.passive.tsp);
+				if (ACPI_FAILURE(status))
+					tz->trips.passive.flags.valid = 0;
+			}
+		}
+	}
+	if ((flag & ACPI_TRIPS_DEVICES) && tz->trips.passive.flags.valid) {
+		memset(&devices, 0, sizeof(struct acpi_handle_list));
+		status = acpi_evaluate_reference(tz->device->handle, "_PSL",
+							NULL, &devices);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
-
-		if (!tz->trips.passive.flags.valid)
-			printk(KERN_WARNING PREFIX "Invalid passive threshold\n");
 		else
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-					  "Found passive threshold [%lu]\n",
-					  tz->trips.passive.temperature));
-	}
+			tz->trips.passive.flags.valid = 1;
 
-	/* Active: Fans, etc. (optional) */
+		if (memcmp(&tz->trips.passive.devices, &devices,
+				sizeof(struct acpi_handle_list))) {
+			memcpy(&tz->trips.passive.devices, &devices,
+				sizeof(struct acpi_handle_list));
+			ACPI_THERMAL_TRIPS_EXCEPTION(flag, "device");
+		}
+	}
+	if ((flag & ACPI_TRIPS_PASSIVE) || (flag & ACPI_TRIPS_DEVICES)) {
+		if (valid != tz->trips.passive.flags.valid)
+				ACPI_THERMAL_TRIPS_EXCEPTION(flag, "state");
+	}
 
+	/* Active (optional) */
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
-
 		char name[5] = { '_', 'A', 'C', ('0' + i), '\0' };
+		valid = tz->trips.active[i].flags.valid;
 
 		if (act == -1)
-			break;	/* disable all active trip points */
-
-		status = acpi_evaluate_integer(tz->device->handle,
-			name, NULL, &tz->trips.active[i].temperature);
-
-		if (ACPI_FAILURE(status)) {
-			if (i == 0)	/* no active trip points */
+			break; /* disable all active trip points */
+
+		if (flag & ACPI_TRIPS_ACTIVE) {
+			status = acpi_evaluate_integer(tz->device->handle,
+				name, NULL, &tz->trips.active[i].temperature);
+			if (ACPI_FAILURE(status)) {
+				tz->trips.active[i].flags.valid = 0;
+				if (i == 0)
+					break;
+				if (act <= 0)
+					break;
+				if (i == 1)
+					tz->trips.active[0].temperature =
+						CELSIUS_TO_KELVIN(act);
+				else
+					/*
+					 * Don't allow override higher than
+					 * the next higher trip point
+					 */
+					tz->trips.active[i - 1].temperature =
+						(tz->trips.active[i - 2].temperature <
+						CELSIUS_TO_KELVIN(act) ?
+						tz->trips.active[i - 2].temperature :
+						CELSIUS_TO_KELVIN(act));
 				break;
-			if (act <= 0)	/* no override requested */
-				break;
-			if (i == 1) {	/* 1 trip point */
-				tz->trips.active[0].temperature =
-					CELSIUS_TO_KELVIN(act);
-			} else {	/* multiple trips */
-				/*
-				 * Don't allow override higher than
-				 * the next higher trip point
-				 */
-				tz->trips.active[i - 1].temperature =
-				    (tz->trips.active[i - 2].temperature <
-					CELSIUS_TO_KELVIN(act) ?
-					tz->trips.active[i - 2].temperature :
-					CELSIUS_TO_KELVIN(act));
-			}
-			break;
+			} else
+				tz->trips.active[i].flags.valid = 1;
 		}
 
 		name[2] = 'L';
-		status =
-		    acpi_evaluate_reference(tz->device->handle, name, NULL,
-					    &tz->trips.active[i].devices);
-		if (ACPI_SUCCESS(status)) {
-			tz->trips.active[i].flags.valid = 1;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-					  "Found active threshold [%d]:[%lu]\n",
-					  i, tz->trips.active[i].temperature));
-		} else
-			ACPI_EXCEPTION((AE_INFO, status,
-					"Invalid active threshold [%d]", i));
+		if ((flag & ACPI_TRIPS_DEVICES) && tz->trips.active[i].flags.valid ) {
+			memset(&devices, 0, sizeof(struct acpi_handle_list));
+			status = acpi_evaluate_reference(tz->device->handle,
+						name, NULL, &devices);
+			if (ACPI_FAILURE(status))
+				tz->trips.active[i].flags.valid = 0;
+			else
+				tz->trips.active[i].flags.valid = 1;
+
+			if (memcmp(&tz->trips.active[i].devices, &devices,
+					sizeof(struct acpi_handle_list))) {
+				memcpy(&tz->trips.active[i].devices, &devices,
+					sizeof(struct acpi_handle_list));
+				ACPI_THERMAL_TRIPS_EXCEPTION(flag, "device");
+			}
+		}
+		if ((flag & ACPI_TRIPS_ACTIVE) || (flag & ACPI_TRIPS_DEVICES))
+			if (valid != tz->trips.active[i].flags.valid)
+				ACPI_THERMAL_TRIPS_EXCEPTION(flag, "state");
+
+		if (!tz->trips.active[i].flags.valid)
+			break;
+	}
+
+	if (flag & ACPI_TRIPS_DEVICES) {
+		memset(&devices, 0, sizeof(struct acpi_handle_list));
+		status = acpi_evaluate_reference(tz->device->handle, "_TZD",
+						NULL, &devices);
+		if (memcmp(&tz->devices, &devices,
+				sizeof(struct acpi_handle_list))) {
+			memcpy(&tz->devices, &devices,
+				sizeof(struct acpi_handle_list));
+			ACPI_THERMAL_TRIPS_EXCEPTION(flag, "device");
+		}
 	}
 
 	return 0;
 }
 
-static int acpi_thermal_get_devices(struct acpi_thermal *tz)
+static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 {
-	acpi_status status = AE_OK;
-
-
-	if (!tz)
-		return -EINVAL;
-
-	status =
-	    acpi_evaluate_reference(tz->device->handle, "_TZD", NULL, &tz->devices);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	return 0;
+	return acpi_thermal_trips_update(tz, ACPI_TRIPS_INIT);
 }
 
 static int acpi_thermal_critical(struct acpi_thermal *tz)
@@ -1453,15 +1501,15 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 		acpi_thermal_check(tz);
 		break;
 	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
-		acpi_thermal_get_trip_points(tz);
+		acpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_THRESHOLDS);
 		acpi_thermal_check(tz);
 		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  device->dev.bus_id, event, 0);
 		break;
 	case ACPI_THERMAL_NOTIFY_DEVICES:
-		if (tz->flags.devices)
-			acpi_thermal_get_devices(tz);
+		acpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_DEVICES);
+		acpi_thermal_check(tz);
 		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  device->dev.bus_id, event, 0);
@@ -1504,11 +1552,6 @@ static int acpi_thermal_get_info(struct acpi_thermal *tz)
 	else
 		acpi_thermal_get_polling_frequency(tz);
 
-	/* Get devices in this thermal zone [_TZD] (optional) */
-	result = acpi_thermal_get_devices(tz);
-	if (!result)
-		tz->flags.devices = 1;
-
 	return 0;
 }
 

commit 3f655ef8c439e0775ffb7d1ead5d1d4f060e1f8b
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 17 15:51:11 2008 +0800

    ACPI: register ACPI thermal zone as generic thermal zone devices
    
    Register ACPI thermal zone as thermal zone device.
    
    the new sys I/F for ACPI thermal zone will be like this:
    
    /sys/class/thermal:
    |thermal_zone1:
            |-----type:                     "ACPI thermal zone". RO
            |-----temp:                     the current temperature. RO
            |-----mode:                     the current working mode. RW.
                                            the default value is "kernel"  which means  thermal
                                            management is done by ACPI thermal driver.
                                            "echo user > mode" prevents all the ACPI thermal driver
                                            actions upon any trip points.
            |-----trip_point_0_temp:        the threshold of trip point 0. RO.
            |-----trip_point_0_type:        "critical". RO.
                                            the type of trip point 0
                                            This may be one of critical/hot/passive/active[x]
                                            for an ACPI thermal zone.
            ...
            |-----trip_point_3_temp:
            |-----trip_point_3_type:        "active[1]"
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Thomas Sujith <sujith.thomas@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5f79b4451212..c6cfce4c0122 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -43,7 +43,7 @@
 #include <linux/seq_file.h>
 #include <linux/reboot.h>
 #include <asm/uaccess.h>
-
+#include <linux/thermal.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
@@ -195,6 +195,8 @@ struct acpi_thermal {
 	struct acpi_thermal_trips trips;
 	struct acpi_handle_list devices;
 	struct timer_list timer;
+	struct thermal_zone_device *thermal_zone;
+	int tz_enabled;
 	struct mutex lock;
 };
 
@@ -732,6 +734,9 @@ static void acpi_thermal_check(void *data)
 	if (result)
 		goto unlock;
 
+	if (!tz->tz_enabled)
+		goto unlock;
+
 	memset(&tz->state, 0, sizeof(tz->state));
 
 	/*
@@ -825,6 +830,273 @@ static void acpi_thermal_check(void *data)
 	mutex_unlock(&tz->lock);
 }
 
+/* sys I/F for generic thermal sysfs support */
+static int thermal_get_temp(struct thermal_zone_device *thermal, char *buf)
+{
+	struct acpi_thermal *tz = thermal->devdata;
+
+	if (!tz)
+		return -EINVAL;
+
+	return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(tz->temperature));
+}
+
+static const char enabled[] = "kernel";
+static const char disabled[] = "user";
+static int thermal_get_mode(struct thermal_zone_device *thermal,
+				char *buf)
+{
+	struct acpi_thermal *tz = thermal->devdata;
+
+	if (!tz)
+		return -EINVAL;
+
+	return sprintf(buf, "%s\n", tz->tz_enabled ?
+			enabled : disabled);
+}
+
+static int thermal_set_mode(struct thermal_zone_device *thermal,
+				const char *buf)
+{
+	struct acpi_thermal *tz = thermal->devdata;
+	int enable;
+
+	if (!tz)
+		return -EINVAL;
+
+	/*
+	 * enable/disable thermal management from ACPI thermal driver
+	 */
+	if (!strncmp(buf, enabled, sizeof enabled - 1))
+		enable = 1;
+	else if (!strncmp(buf, disabled, sizeof disabled - 1))
+		enable = 0;
+	else
+		return -EINVAL;
+
+	if (enable != tz->tz_enabled) {
+		tz->tz_enabled = enable;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"%s ACPI thermal control\n",
+			tz->tz_enabled ? enabled : disabled));
+		acpi_thermal_check(tz);
+	}
+	return 0;
+}
+
+static int thermal_get_trip_type(struct thermal_zone_device *thermal,
+				 int trip, char *buf)
+{
+	struct acpi_thermal *tz = thermal->devdata;
+	int i;
+
+	if (!tz || trip < 0)
+		return -EINVAL;
+
+	if (tz->trips.critical.flags.valid) {
+		if (!trip)
+			return sprintf(buf, "critical\n");
+		trip--;
+	}
+
+	if (tz->trips.hot.flags.valid) {
+		if (!trip)
+			return sprintf(buf, "hot\n");
+		trip--;
+	}
+
+	if (tz->trips.passive.flags.valid) {
+		if (!trip)
+			return sprintf(buf, "passive\n");
+		trip--;
+	}
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
+		tz->trips.active[i].flags.valid; i++) {
+		if (!trip)
+			return sprintf(buf, "active%d\n", i);
+		trip--;
+	}
+
+	return -EINVAL;
+}
+
+static int thermal_get_trip_temp(struct thermal_zone_device *thermal,
+				 int trip, char *buf)
+{
+	struct acpi_thermal *tz = thermal->devdata;
+	int i;
+
+	if (!tz || trip < 0)
+		return -EINVAL;
+
+	if (tz->trips.critical.flags.valid) {
+		if (!trip)
+			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+				tz->trips.critical.temperature));
+		trip--;
+	}
+
+	if (tz->trips.hot.flags.valid) {
+		if (!trip)
+			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+					tz->trips.hot.temperature));
+		trip--;
+	}
+
+	if (tz->trips.passive.flags.valid) {
+		if (!trip)
+			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+					tz->trips.passive.temperature));
+		trip--;
+	}
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
+		tz->trips.active[i].flags.valid; i++) {
+		if (!trip)
+			return sprintf(buf, "%ld\n", KELVIN_TO_CELSIUS(
+					tz->trips.active[i].temperature));
+		trip--;
+	}
+
+	return -EINVAL;
+}
+
+typedef int (*cb)(struct thermal_zone_device *, int,
+		  struct thermal_cooling_device *);
+static int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
+					struct thermal_cooling_device *cdev,
+					cb action)
+{
+	struct acpi_device *device = cdev->devdata;
+	struct acpi_thermal *tz = thermal->devdata;
+	acpi_handle handle = device->handle;
+	int i;
+	int j;
+	int trip = -1;
+	int result = 0;
+
+	if (tz->trips.critical.flags.valid)
+		trip++;
+
+	if (tz->trips.hot.flags.valid)
+		trip++;
+
+	if (tz->trips.passive.flags.valid) {
+		trip++;
+		for (i = 0; i < tz->trips.passive.devices.count;
+		    i++) {
+			if (tz->trips.passive.devices.handles[i] !=
+				handle)
+				continue;
+			result = action(thermal, trip, cdev);
+			if (result)
+				goto failed;
+		}
+	}
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
+		if (!tz->trips.active[i].flags.valid)
+			break;
+		trip++;
+		for (j = 0;
+		    j < tz->trips.active[i].devices.count;
+		    j++) {
+			if (tz->trips.active[i].devices.
+						handles[j] != handle)
+				continue;
+			result = action(thermal, trip, cdev);
+			if (result)
+				goto failed;
+		}
+	}
+
+	for (i = 0; i < tz->devices.count; i++) {
+		if (tz->devices.handles[i] != handle)
+			continue;
+		result = action(thermal, -1, cdev);
+		if (result)
+			goto failed;
+	}
+
+failed:
+	return result;
+}
+
+static int
+acpi_thermal_bind_cooling_device(struct thermal_zone_device *thermal,
+					struct thermal_cooling_device *cdev)
+{
+	return acpi_thermal_cooling_device_cb(thermal, cdev,
+				thermal_zone_bind_cooling_device);
+}
+
+static int
+acpi_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,
+					struct thermal_cooling_device *cdev)
+{
+	return acpi_thermal_cooling_device_cb(thermal, cdev,
+				thermal_zone_unbind_cooling_device);
+}
+
+static struct thermal_zone_device_ops acpi_thermal_zone_ops = {
+	.bind = acpi_thermal_bind_cooling_device,
+	.unbind	= acpi_thermal_unbind_cooling_device,
+	.get_temp = thermal_get_temp,
+	.get_mode = thermal_get_mode,
+	.set_mode = thermal_set_mode,
+	.get_trip_type = thermal_get_trip_type,
+	.get_trip_temp = thermal_get_trip_temp,
+};
+
+static int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)
+{
+	int trips = 0;
+	int result;
+	int i;
+
+	if (tz->trips.critical.flags.valid)
+		trips++;
+
+	if (tz->trips.hot.flags.valid)
+		trips++;
+
+	if (tz->trips.passive.flags.valid)
+		trips++;
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&
+			tz->trips.active[i].flags.valid; i++, trips++);
+	tz->thermal_zone = thermal_zone_device_register("ACPI thermal zone",
+					trips, tz, &acpi_thermal_zone_ops);
+	if (!tz->thermal_zone)
+		return -ENODEV;
+
+	result = sysfs_create_link(&tz->device->dev.kobj,
+				   &tz->thermal_zone->device.kobj, "thermal_zone");
+	if (result)
+		return result;
+
+	result = sysfs_create_link(&tz->thermal_zone->device.kobj,
+				   &tz->device->dev.kobj, "device");
+	if (result)
+		return result;
+
+	tz->tz_enabled = 1;
+
+	printk(KERN_INFO PREFIX "%s is registered as thermal_zone%d\n",
+			tz->device->dev.bus_id, tz->thermal_zone->id);
+	return 0;
+}
+
+static void acpi_thermal_unregister_thermal_zone(struct acpi_thermal *tz)
+{
+	sysfs_remove_link(&tz->device->dev.kobj, "thermal_zone");
+	sysfs_remove_link(&tz->thermal_zone->device.kobj, "device");
+	thermal_zone_device_unregister(tz->thermal_zone);
+	tz->thermal_zone = NULL;
+}
+
+
 /* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
@@ -1260,13 +1532,19 @@ static int acpi_thermal_add(struct acpi_device *device)
 	strcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);
 	acpi_driver_data(device) = tz;
 	mutex_init(&tz->lock);
+
+
 	result = acpi_thermal_get_info(tz);
 	if (result)
-		goto end;
+		goto free_memory;
+
+	result = acpi_thermal_register_thermal_zone(tz);
+	if (result)
+		goto free_memory;
 
 	result = acpi_thermal_add_fs(device);
 	if (result)
-		goto end;
+		goto unregister_thermal_zone;
 
 	init_timer(&tz->timer);
 
@@ -1277,19 +1555,21 @@ static int acpi_thermal_add(struct acpi_device *device)
 					     acpi_thermal_notify, tz);
 	if (ACPI_FAILURE(status)) {
 		result = -ENODEV;
-		goto end;
+		goto remove_fs;
 	}
 
 	printk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",
 	       acpi_device_name(device), acpi_device_bid(device),
 	       KELVIN_TO_CELSIUS(tz->temperature));
+	goto end;
 
-      end:
-	if (result) {
-		acpi_thermal_remove_fs(device);
-		kfree(tz);
-	}
-
+remove_fs:
+	acpi_thermal_remove_fs(device);
+unregister_thermal_zone:
+	thermal_zone_device_unregister(tz->thermal_zone);
+free_memory:
+	kfree(tz);
+end:
 	return result;
 }
 
@@ -1329,6 +1609,7 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	}
 
 	acpi_thermal_remove_fs(device);
+	acpi_thermal_unregister_thermal_zone(tz);
 	mutex_destroy(&tz->lock);
 	kfree(tz);
 	return 0;

commit 223630fe3dc564b94e51ff4eb839828c9083f2f6
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Dec 6 23:36:35 2007 -0500

    export thermal notification to userspace when nocrt is set
    
    module parameter is used to prevent the thermal_zone action upon
    critical trip points.
    But exporting this notification to userspace is still useful.
    By setting nocrt with this patch applied, ACPI will take no action
    but exporting the events to userspace upon critical/hot trip points.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9139
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5f79b4451212..3a0af9a8cd27 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -492,7 +492,7 @@ static int acpi_thermal_get_devices(struct acpi_thermal *tz)
 
 static int acpi_thermal_critical(struct acpi_thermal *tz)
 {
-	if (!tz || !tz->trips.critical.flags.valid || nocrt)
+	if (!tz || !tz->trips.critical.flags.valid)
 		return -EINVAL;
 
 	if (tz->temperature >= tz->trips.critical.temperature) {
@@ -501,9 +501,6 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 	} else if (tz->trips.critical.flags.enabled)
 		tz->trips.critical.flags.enabled = 0;
 
-	printk(KERN_EMERG
-	       "Critical temperature reached (%ld C), shutting down.\n",
-	       KELVIN_TO_CELSIUS(tz->temperature));
 	acpi_bus_generate_proc_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
 				tz->trips.critical.flags.enabled);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
@@ -511,14 +508,20 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 					  ACPI_THERMAL_NOTIFY_CRITICAL,
 					  tz->trips.critical.flags.enabled);
 
-	orderly_poweroff(true);
+	/* take no action if nocrt is set */
+	if(!nocrt) {
+		printk(KERN_EMERG
+			"Critical temperature reached (%ld C), shutting down.\n",
+			KELVIN_TO_CELSIUS(tz->temperature));
+		orderly_poweroff(true);
+	}
 
 	return 0;
 }
 
 static int acpi_thermal_hot(struct acpi_thermal *tz)
 {
-	if (!tz || !tz->trips.hot.flags.valid || nocrt)
+	if (!tz || !tz->trips.hot.flags.valid)
 		return -EINVAL;
 
 	if (tz->temperature >= tz->trips.hot.temperature) {
@@ -534,7 +537,7 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 					  ACPI_THERMAL_NOTIFY_HOT,
 					  tz->trips.hot.flags.enabled);
 
-	/* TBD: Call user-mode "sleep(S4)" function */
+	/* TBD: Call user-mode "sleep(S4)" function if nocrt is cleared */
 
 	return 0;
 }

commit c4ec20717313daafba59225f812db89595952b83
Merge: ec2626815bf9 00a2b433557f
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Oct 19 13:12:46 2007 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (41 commits)
      ACPICA: hw: Don't carry spinlock over suspend
      ACPICA: hw: remove use_lock flag from acpi_hw_register_{read, write}
      ACPI: cpuidle: port idle timer suspend/resume workaround to cpuidle
      ACPI: clean up acpi_enter_sleep_state_prep
      Hibernation: Make sure that ACPI is enabled in acpi_hibernation_finish
      ACPI: suppress uninitialized var warning
      cpuidle: consolidate 2.6.22 cpuidle branch into one patch
      ACPI: thinkpad-acpi: skip blanks before the data when parsing sysfs
      ACPI: AC: Add sysfs interface
      ACPI: SBS: Add sysfs alarm
      ACPI: SBS: Add ACPI_PROCFS around procfs handling code.
      ACPI: SBS: Add support for power_supply class (and sysfs)
      ACPI: SBS: Make SBS reads table-driven.
      ACPI: SBS: Simplify data structures in SBS
      ACPI: SBS: Split host controller (ACPI0001) from SBS driver (ACPI0002)
      ACPI: EC: Add new query handler to list head.
      ACPI: Add acpi_bus_generate_event4() function
      ACPI: Battery: add sysfs alarm
      ACPI: Battery: Add sysfs support
      ACPI: Battery: Misc clean-ups, no functional changes
      ...
    
    Fix up conflicts in drivers/misc/thinkpad_acpi.[ch] manually

commit 1855256c497ecfefc730df6032243f26855ce52c
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Oct 3 15:15:40 2007 -0400

    drivers/firmware: const-ify DMI API and internals
    
    Three main sets of changes:
    
    1) dmi_get_system_info() return value should have been marked const,
       since callers should not be changing that data.
    
    2) const-ify DMI internals, since DMI firmware tables should,
       whenever possible, be marked const to ensure we never ever write to
       that data area.
    
    3) const-ify DMI API, to enable marking tables const where possible
       in low-level drivers.
    
    And if we're really lucky, this might enable some additional
    optimizations on the part of the compiler.
    
    The bulk of the changes are #2 and #3, which are interrelated.  #1 could
    have been a separate patch, but it was so small compared to the others,
    it was easier to roll it into this changeset.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index bc6d5866ef98..ad898e10c1a9 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1360,7 +1360,7 @@ static int acpi_thermal_resume(struct acpi_device *device)
 }
 
 #ifdef CONFIG_DMI
-static int thermal_act(struct dmi_system_id *d) {
+static int thermal_act(const struct dmi_system_id *d) {
 
 	if (act == 0) {
 		printk(KERN_NOTICE "ACPI: %s detected: "
@@ -1369,14 +1369,14 @@ static int thermal_act(struct dmi_system_id *d) {
 	}
 	return 0;
 }
-static int thermal_nocrt(struct dmi_system_id *d) {
+static int thermal_nocrt(const struct dmi_system_id *d) {
 
 	printk(KERN_NOTICE "ACPI: %s detected: "
 		"disabling all critical thermal trip point actions.\n", d->ident);
 	nocrt = 1;
 	return 0;
 }
-static int thermal_tzp(struct dmi_system_id *d) {
+static int thermal_tzp(const struct dmi_system_id *d) {
 
 	if (tzp == 0) {
 		printk(KERN_NOTICE "ACPI: %s detected: "
@@ -1385,7 +1385,7 @@ static int thermal_tzp(struct dmi_system_id *d) {
 	}
 	return 0;
 }
-static int thermal_psv(struct dmi_system_id *d) {
+static int thermal_psv(const struct dmi_system_id *d) {
 
 	if (psv == 0) {
 		printk(KERN_NOTICE "ACPI: %s detected: "

commit 6e2157858ac94530fddbf19dc59ab6b392baf1f3
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Sat Sep 1 00:11:59 2007 +0400

    ACPI: Thermal: Drop concurrent thermal checks
    
    Fix for #3686, where get_temperature() may cause thermal notify, which
    causes one more get_temperature().
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 15d5fdc66a96..69ec73b0239d 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -195,6 +195,7 @@ struct acpi_thermal {
 	struct acpi_thermal_trips trips;
 	struct acpi_handle_list devices;
 	struct timer_list timer;
+	struct mutex lock;
 };
 
 static const struct file_operations acpi_thermal_state_fops = {
@@ -721,11 +722,15 @@ static void acpi_thermal_check(void *data)
 		return;
 	}
 
+	/* Check if someone else is already running */
+	if (!mutex_trylock(&tz->lock))
+		return;
+
 	state = tz->state;
 
 	result = acpi_thermal_get_temperature(tz);
 	if (result)
-		return;
+		goto unlock;
 
 	memset(&tz->state, 0, sizeof(tz->state));
 
@@ -816,8 +821,8 @@ static void acpi_thermal_check(void *data)
 			add_timer(&(tz->timer));
 		}
 	}
-
-	return;
+      unlock:
+	mutex_unlock(&tz->lock);
 }
 
 /* --------------------------------------------------------------------------
@@ -1254,7 +1259,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 	strcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);
 	acpi_driver_data(device) = tz;
-
+	mutex_init(&tz->lock);
 	result = acpi_thermal_get_info(tz);
 	if (result)
 		goto end;
@@ -1324,7 +1329,7 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	}
 
 	acpi_thermal_remove_fs(device);
-
+	mutex_destroy(&tz->lock);
 	kfree(tz);
 	return 0;
 }

commit 21bc42ab852549f4a547d18d77e0e4d1b24ffd96
Author: Len Brown <len.brown@intel.com>
Date:   Tue Sep 4 12:49:22 2007 -0400

    ACPI: thermal: use round_jiffies when thermal zone polling is enabled
    
    Properly functioning systems do not use thermal zone polling,
    they use event-based notification.
    
    However, some users enable periodic thermal zone polling
    to work around bugs on their platforms, and at least one
    platform exists with a real _TZP that requests polling.
    
    While thermal zone polling (_TZP) is specified in units to 0.1 seconds,
    it actually has a maximum granularity of 1 second.  Thus, we can safely
    round up the _TZP timeout to occur on the next 1-second boundary.
    This will batch it with other 1-second-granularity timers in the
    system and thus potentially extend processor idle duration.
    
    Note that the same timer is used both for _TZP
    and for passive processor thermal throttling.
    We can not round up the timeout when it is used
    for passive thermal throttling.
    
    Also, we can not make this a deferrable timer,
    as temperature is just as relevant during idle
    as it is during non-idle.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index bc6d5866ef98..15d5fdc66a96 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -711,6 +711,7 @@ static void acpi_thermal_check(void *data)
 	int result = 0;
 	struct acpi_thermal *tz = data;
 	unsigned long sleep_time = 0;
+	unsigned long timeout_jiffies = 0;
 	int i = 0;
 	struct acpi_thermal_state state;
 
@@ -787,10 +788,13 @@ static void acpi_thermal_check(void *data)
 	 * a thermal event occurs).  Note that _TSP and _TZD values are
 	 * given in 1/10th seconds (we must covert to milliseconds).
 	 */
-	if (tz->state.passive)
+	if (tz->state.passive) {
 		sleep_time = tz->trips.passive.tsp * 100;
-	else if (tz->polling_frequency > 0)
+		timeout_jiffies =  jiffies + (HZ * sleep_time) / 1000;
+	} else if (tz->polling_frequency > 0) {
 		sleep_time = tz->polling_frequency * 100;
+		timeout_jiffies =  round_jiffies(jiffies + (HZ * sleep_time) / 1000);
+	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n",
 			  tz->name, tz->temperature, sleep_time));
@@ -804,12 +808,11 @@ static void acpi_thermal_check(void *data)
 			del_timer(&(tz->timer));
 	} else {
 		if (timer_pending(&(tz->timer)))
-			mod_timer(&(tz->timer),
-					jiffies + (HZ * sleep_time) / 1000);
+			mod_timer(&(tz->timer), timeout_jiffies);
 		else {
 			tz->timer.data = (unsigned long)tz;
 			tz->timer.function = acpi_thermal_run;
-			tz->timer.expires = jiffies + (HZ * sleep_time) / 1000;
+			tz->timer.expires = timeout_jiffies;
 			add_timer(&(tz->timer));
 		}
 	}

commit 25c87f7f2a4fc3e50a7912b1c78405d454d1c4d9
Merge: a4fd4946214f 3e069ee0c30d
Author: Len Brown <len.brown@intel.com>
Date:   Sat Aug 25 01:44:01 2007 -0400

    Pull events into release branch
    
    Conflicts:
    
            drivers/acpi/video.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 2db9ccba8d4bb8e3aa6d0cd8e7544c5736963bbc
Author: Pavel Machek <pavel@ucw.cz>
Date:   Fri Aug 24 11:45:50 2007 +0200

    ACPI: /proc/acpi/thermal_zone trip points are now read-only, mark them as such
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 39479b0befa4..7e8f48b7f9af 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1085,9 +1085,9 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 		entry->owner = THIS_MODULE;
 	}
 
-	/* 'trip_points' [R/W] */
+	/* 'trip_points' [R] */
 	entry = create_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
-				  S_IFREG | S_IRUGO | S_IWUSR,
+				  S_IRUGO,
 				  acpi_device_dir(device));
 	if (!entry)
 		return -ENODEV;

commit 14e04fb34ffa82ee61ae69f98d8fca12d2e8e31c
Author: Len Brown <len.brown@intel.com>
Date:   Thu Aug 23 15:20:26 2007 -0400

    ACPI: Schedule /proc/acpi/event for removal
    
    Schedule /proc/acpi/event for removal in 6 months.
    
    Re-name acpi_bus_generate_event() to acpi_bus_generate_proc_event()
    to make sure there is no confusion that it is for /proc/acpi/event only.
    
    Add CONFIG_ACPI_PROC_EVENT to allow removal of /proc/acpi/event.
    There is no functional change if CONFIG_ACPI_PROC_EVENT=y
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 291758c9a4d6..2c9cfe297f73 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -485,7 +485,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 	printk(KERN_EMERG
 	       "Critical temperature reached (%ld C), shutting down.\n",
 	       KELVIN_TO_CELSIUS(tz->temperature));
-	acpi_bus_generate_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
+	acpi_bus_generate_proc_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
 				tz->trips.critical.flags.enabled);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
 					  tz->device->dev.bus_id,
@@ -508,7 +508,7 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 	} else if (tz->trips.hot.flags.enabled)
 		tz->trips.hot.flags.enabled = 0;
 
-	acpi_bus_generate_event(tz->device, ACPI_THERMAL_NOTIFY_HOT,
+	acpi_bus_generate_proc_event(tz->device, ACPI_THERMAL_NOTIFY_HOT,
 				tz->trips.hot.flags.enabled);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
 					  tz->device->dev.bus_id,
@@ -1157,14 +1157,14 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
 		acpi_thermal_get_trip_points(tz);
 		acpi_thermal_check(tz);
-		acpi_bus_generate_event(device, event, 0);
+		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  device->dev.bus_id, event, 0);
 		break;
 	case ACPI_THERMAL_NOTIFY_DEVICES:
 		if (tz->flags.devices)
 			acpi_thermal_get_devices(tz);
-		acpi_bus_generate_event(device, event, 0);
+		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  device->dev.bus_id, event, 0);
 		break;

commit 962ce8ca0604af0c3c5609f7613d4ec5fcfac623
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Aug 23 01:24:31 2007 +0800

    ACPI: don't duplicate input events on netlink
    
    The previous events patch added a netlink event for every
    user of the legacy /proc/acpi/event interface.
    
    However, some users of /proc/acpi/event are really input events,
    and they already report their events via the input layer.
    
    Introduce a new interface, acpi_bus_generate_netlink_event(),
    which is explicitly called by devices that want to repoprt
    events via netlink.  This allows the input-like events
    to opt-out of generating netlink events.  In summary:
    
    events that are sent via netlink:
            ac/battery/sbs
            thermal
            processor
            thinkpad_acpi dock/bay
    
    events that are sent via input layer:
            button
            video hotkey
            thinkpad_acpi hotkey
            asus_acpi/asus-laptop hotkey
            sonypi/sonylaptop
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1e06159fd9c4..291758c9a4d6 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -487,6 +487,10 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 	       KELVIN_TO_CELSIUS(tz->temperature));
 	acpi_bus_generate_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
 				tz->trips.critical.flags.enabled);
+	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
+					  tz->device->dev.bus_id,
+					  ACPI_THERMAL_NOTIFY_CRITICAL,
+					  tz->trips.critical.flags.enabled);
 
 	orderly_poweroff(true);
 
@@ -506,6 +510,10 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 
 	acpi_bus_generate_event(tz->device, ACPI_THERMAL_NOTIFY_HOT,
 				tz->trips.hot.flags.enabled);
+	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
+					  tz->device->dev.bus_id,
+					  ACPI_THERMAL_NOTIFY_HOT,
+					  tz->trips.hot.flags.enabled);
 
 	/* TBD: Call user-mode "sleep(S4)" function */
 
@@ -1150,11 +1158,15 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 		acpi_thermal_get_trip_points(tz);
 		acpi_thermal_check(tz);
 		acpi_bus_generate_event(device, event, 0);
+		acpi_bus_generate_netlink_event(device->pnp.device_class,
+						  device->dev.bus_id, event, 0);
 		break;
 	case ACPI_THERMAL_NOTIFY_DEVICES:
 		if (tz->flags.devices)
 			acpi_thermal_get_devices(tz);
 		acpi_bus_generate_event(device, event, 0);
+		acpi_bus_generate_netlink_event(device->pnp.device_class,
+						  device->dev.bus_id, event, 0);
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit 8c99fdce30787b0d1fc00b907d4cd55a714e4cdd
Author: Len Brown <len.brown@intel.com>
Date:   Mon Aug 20 18:46:50 2007 -0400

    ACPI: thermal: set "thermal.nocrt" via DMI on Gigabyte GA-7ZX
    
    This system BIOS sets a critical temperature to 65C,
    which is too low.
    
    https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=155496
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 4c420feba207..39479b0befa4 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -89,7 +89,7 @@ MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.");
 
 static int nocrt;
 module_param(nocrt, int, 0);
-MODULE_PARM_DESC(nocrt, "Set to disable action on ACPI thermal zone critical and hot trips.");
+MODULE_PARM_DESC(nocrt, "Set to take no action upon ACPI thermal zone critical trips points.");
 
 static int off;
 module_param(off, int, 0);
@@ -1357,6 +1357,13 @@ static int thermal_act(struct dmi_system_id *d) {
 	}
 	return 0;
 }
+static int thermal_nocrt(struct dmi_system_id *d) {
+
+	printk(KERN_NOTICE "ACPI: %s detected: "
+		"disabling all critical thermal trip point actions.\n", d->ident);
+	nocrt = 1;
+	return 0;
+}
 static int thermal_tzp(struct dmi_system_id *d) {
 
 	if (tzp == 0) {
@@ -1405,6 +1412,14 @@ static struct dmi_system_id thermal_dmi_table[] __initdata = {
 		DMI_MATCH(DMI_BOARD_NAME, "i915GMm-HFS"),
 		},
 	},
+	{
+	 .callback = thermal_nocrt,
+	 .ident = "Gigabyte GA-7ZX",
+	 .matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "Gigabyte Technology Co., Ltd."),
+		DMI_MATCH(DMI_BOARD_NAME, "7ZX"),
+		},
+	},
 	{}
 };
 #endif /* CONFIG_DMI */

commit c52a7419af18594426bc601d1ea346dbbcf71e28
Author: Len Brown <len.brown@intel.com>
Date:   Tue Aug 14 15:49:32 2007 -0400

    ACPI: thermal: create "thermal.crt=C" bootparam
    
    Some hardware will malfunction at a temperature below
    the BIOS provided critical shutdown threshold.
    
    This hook allows moving the critical trip points down
    to a temperature which provokes a graceful shutdown
    before the hardware malfunction.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8884
    
    WARNING: A trip-point override will not get noticed
    until the system delivers a temperature change event,
    or unless thermal zone polling is enabled.
    eg. "thermal.tzp=10"
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 9b31f36481d2..4c420feba207 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -79,6 +79,10 @@ static int act;
 module_param(act, int, 0644);
 MODULE_PARM_DESC(act, "Disable or override all lowest active trip points.");
 
+static int crt;
+module_param(crt, int, 0644);
+MODULE_PARM_DESC(crt, "Disable or lower all critical trip points.");
+
 static int tzp;
 module_param(tzp, int, 0444);
 MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.");
@@ -340,6 +344,20 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 				  tz->trips.critical.temperature));
 	}
 
+	if (tz->trips.critical.flags.valid == 1) {
+		if (crt == -1) {
+			tz->trips.critical.flags.valid = 0;
+		} else if (crt > 0) {
+			unsigned long crt_k = CELSIUS_TO_KELVIN(crt);
+
+			/*
+			 * Allow override to lower critical threshold
+			 */
+			if (crt_k < tz->trips.critical.temperature)
+				tz->trips.critical.temperature = crt_k;
+		}
+	}
+
 	/* Critical Sleep (optional) */
 
 	status =

commit 3c1d36da1d5ed36979340efd233ddaacc45b0a02
Author: Len Brown <len.brown@intel.com>
Date:   Tue Aug 14 15:12:56 2007 -0400

    ACPI: thermal: clean up MODULE_PARM_DESC newlines
    
    Reported-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1e06159fd9c4..9b31f36481d2 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -77,23 +77,23 @@ MODULE_LICENSE("GPL");
 
 static int act;
 module_param(act, int, 0644);
-MODULE_PARM_DESC(act, "Disable or override all lowest active trip points.\n");
+MODULE_PARM_DESC(act, "Disable or override all lowest active trip points.");
 
 static int tzp;
 module_param(tzp, int, 0444);
-MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
+MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.");
 
 static int nocrt;
 module_param(nocrt, int, 0);
-MODULE_PARM_DESC(nocrt, "Set to disable action on ACPI thermal zone critical and hot trips.\n");
+MODULE_PARM_DESC(nocrt, "Set to disable action on ACPI thermal zone critical and hot trips.");
 
 static int off;
 module_param(off, int, 0);
-MODULE_PARM_DESC(off, "Set to disable ACPI thermal support.\n");
+MODULE_PARM_DESC(off, "Set to disable ACPI thermal support.");
 
 static int psv;
 module_param(psv, int, 0644);
-MODULE_PARM_DESC(psv, "Disable or override all passive trip points.\n");
+MODULE_PARM_DESC(psv, "Disable or override all passive trip points.");
 
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);

commit 0b5bfa1cbefdc6e4c60f30ed545389b5ffe0f75f
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 12 00:13:02 2007 -0400

    ACPI: thermal: add DMI hooks to handle AOpen's broken Award BIOS
    
    Use DMI to:
    1. enable polling (BIOS thermal events are broken)
    2. disable active trip points (BIOS fan control is broken)
    3. disable passive trip point (BIOS hard-codes it too low)
    
    The actual temperature reading does work,
    and with the aid of polling, the critical
    trip point should work too.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8842
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 3521c37bbd33..1e06159fd9c4 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -33,6 +33,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/dmi.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/proc_fs.h>
@@ -1328,10 +1329,74 @@ static int acpi_thermal_resume(struct acpi_device *device)
 	return AE_OK;
 }
 
+#ifdef CONFIG_DMI
+static int thermal_act(struct dmi_system_id *d) {
+
+	if (act == 0) {
+		printk(KERN_NOTICE "ACPI: %s detected: "
+			"disabling all active thermal trip points\n", d->ident);
+		act = -1;
+	}
+	return 0;
+}
+static int thermal_tzp(struct dmi_system_id *d) {
+
+	if (tzp == 0) {
+		printk(KERN_NOTICE "ACPI: %s detected: "
+			"enabling thermal zone polling\n", d->ident);
+		tzp = 300;	/* 300 dS = 30 Seconds */
+	}
+	return 0;
+}
+static int thermal_psv(struct dmi_system_id *d) {
+
+	if (psv == 0) {
+		printk(KERN_NOTICE "ACPI: %s detected: "
+			"disabling all passive thermal trip points\n", d->ident);
+		psv = -1;
+	}
+	return 0;
+}
+
+static struct dmi_system_id thermal_dmi_table[] __initdata = {
+	/*
+	 * Award BIOS on this AOpen makes thermal control almost worthless.
+	 * http://bugzilla.kernel.org/show_bug.cgi?id=8842
+	 */
+	{
+	 .callback = thermal_act,
+	 .ident = "AOpen i915GMm-HFS",
+	 .matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "AOpen"),
+		DMI_MATCH(DMI_BOARD_NAME, "i915GMm-HFS"),
+		},
+	},
+	{
+	 .callback = thermal_psv,
+	 .ident = "AOpen i915GMm-HFS",
+	 .matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "AOpen"),
+		DMI_MATCH(DMI_BOARD_NAME, "i915GMm-HFS"),
+		},
+	},
+	{
+	 .callback = thermal_tzp,
+	 .ident = "AOpen i915GMm-HFS",
+	 .matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "AOpen"),
+		DMI_MATCH(DMI_BOARD_NAME, "i915GMm-HFS"),
+		},
+	},
+	{}
+};
+#endif /* CONFIG_DMI */
+
 static int __init acpi_thermal_init(void)
 {
 	int result = 0;
 
+	dmi_check_system(thermal_dmi_table);
+
 	if (off) {
 		printk(KERN_NOTICE "ACPI: thermal control disabled\n");
 		return -ENODEV;

commit f8707ec9643769957065405b5090e4aa64fd8214
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 12 00:12:54 2007 -0400

    ACPI: thermal: create "thermal.act=" to disable or override active trip point
    
    thermal.act=-1 disables all active trip points
    in all ACPI thermal zones.
    
    thermal.act=C, where C > 0, overrides all lowest temperature
    active trip points in all thermal zones to C degrees Celsius.
    Raising this trip-point may allow you to keep your system silent
    up to a higher temperature.  However, it will not allow you to
    raise the lowest temperature trip point above the next higher
    trip point (if there is one).  Lowering this trip point may
    kick in the fan sooner.
    
    Note that overriding this trip-point will disable any BIOS attempts
    to implement hysteresis around the lowest temperature trip point.
    This may result in the fan starting and stopping frequently
    if temperature frequently crosses C.
    
    WARNING: raising trip points above the manufacturer's defaults
    may cause the system to run at higher temperature and shorten
    its life.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 57d05ff44dd1..3521c37bbd33 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -74,6 +74,10 @@ MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION("ACPI Thermal Zone Driver");
 MODULE_LICENSE("GPL");
 
+static int act;
+module_param(act, int, 0644);
+MODULE_PARM_DESC(act, "Disable or override all lowest active trip points.\n");
+
 static int tzp;
 module_param(tzp, int, 0444);
 MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
@@ -405,11 +409,33 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 
 		char name[5] = { '_', 'A', 'C', ('0' + i), '\0' };
 
-		status =
-		    acpi_evaluate_integer(tz->device->handle, name, NULL,
-					  &tz->trips.active[i].temperature);
-		if (ACPI_FAILURE(status))
+		if (act == -1)
+			break;	/* disable all active trip points */
+
+		status = acpi_evaluate_integer(tz->device->handle,
+			name, NULL, &tz->trips.active[i].temperature);
+
+		if (ACPI_FAILURE(status)) {
+			if (i == 0)	/* no active trip points */
+				break;
+			if (act <= 0)	/* no override requested */
+				break;
+			if (i == 1) {	/* 1 trip point */
+				tz->trips.active[0].temperature =
+					CELSIUS_TO_KELVIN(act);
+			} else {	/* multiple trips */
+				/*
+				 * Don't allow override higher than
+				 * the next higher trip point
+				 */
+				tz->trips.active[i - 1].temperature =
+				    (tz->trips.active[i - 2].temperature <
+					CELSIUS_TO_KELVIN(act) ?
+					tz->trips.active[i - 2].temperature :
+					CELSIUS_TO_KELVIN(act));
+			}
 			break;
+		}
 
 		name[2] = 'L';
 		status =

commit f54871456162aff557d57bec51639b1288d4a84b
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 12 00:12:44 2007 -0400

    ACPI: thermal: create "thermal.nocrt" to disable critical actions
    
    thermal.nocrt=1 disables actions on _CRT and _HOT
    ACPI thermal zone trip-points.  They will be marked
    as <disabled> in /proc/acpi/thermal_zone/*/trip_points.
    
    There are two cases where this option is used:
    
    1. Debugging a hot system crossing valid trip point.
    
       If your system fan is spinning at full speed,
       be sure that the vent is not clogged with dust.
       Many laptops have very fine thermal fins that are easily blocked.
    
       Check that the processor fan-sink is properly seated,
       has the proper thermal grease, and is really spinning.
    
       Check for fan related options in BIOS SETUP.
       Sometimes there is a performance vs quiet option.
       Defaults are generally the most conservative.
    
       If your fan is not spinning, yet /proc/acpi/fan/
       has files in it, please file a Linux/ACPI bug.
    
       WARNING: you risk shortening the lifetime of your
       hardware if you use this parameter on a hot system.
       Note that this refers to all system components,
       including the disk drive.
    
    2. Working around a cool system crossing critical
       trip point due to erroneous temperature reading.
    
       Try again with CONFIG_HWMON=n
       There is known potential for conflict between the
       the hwmon sub-system and the ACPI BIOS.
       If this fixes it, notify lm-sensors@lm-sensors.org
       and linux-acpi@vger.kernel.org
    
       Otherwise, file a Linux/ACPI bug, or notify
       just linux-acpi@vger.kernel.org.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 74e25be8abc9..57d05ff44dd1 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -78,6 +78,10 @@ static int tzp;
 module_param(tzp, int, 0444);
 MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
 
+static int nocrt;
+module_param(nocrt, int, 0);
+MODULE_PARM_DESC(nocrt, "Set to disable action on ACPI thermal zone critical and hot trips.\n");
+
 static int off;
 module_param(off, int, 0);
 MODULE_PARM_DESC(off, "Set to disable ACPI thermal support.\n");
@@ -442,7 +446,7 @@ static int acpi_thermal_get_devices(struct acpi_thermal *tz)
 
 static int acpi_thermal_critical(struct acpi_thermal *tz)
 {
-	if (!tz || !tz->trips.critical.flags.valid)
+	if (!tz || !tz->trips.critical.flags.valid || nocrt)
 		return -EINVAL;
 
 	if (tz->temperature >= tz->trips.critical.temperature) {
@@ -464,7 +468,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 
 static int acpi_thermal_hot(struct acpi_thermal *tz)
 {
-	if (!tz || !tz->trips.hot.flags.valid)
+	if (!tz || !tz->trips.hot.flags.valid || nocrt)
 		return -EINVAL;
 
 	if (tz->temperature >= tz->trips.hot.temperature) {
@@ -839,12 +843,14 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 		goto end;
 
 	if (tz->trips.critical.flags.valid)
-		seq_printf(seq, "critical (S5):           %ld C\n",
-			   KELVIN_TO_CELSIUS(tz->trips.critical.temperature));
+		seq_printf(seq, "critical (S5):           %ld C%s",
+			   KELVIN_TO_CELSIUS(tz->trips.critical.temperature),
+			   nocrt ? " <disabled>\n" : "\n");
 
 	if (tz->trips.hot.flags.valid)
-		seq_printf(seq, "hot (S4):                %ld C\n",
-			   KELVIN_TO_CELSIUS(tz->trips.hot.temperature));
+		seq_printf(seq, "hot (S4):                %ld C%s",
+			   KELVIN_TO_CELSIUS(tz->trips.hot.temperature),
+			   nocrt ? " <disabled>\n" : "\n");
 
 	if (tz->trips.passive.flags.valid) {
 		seq_printf(seq,

commit a70cdc5200b0eb9fc3ef64efb29baac9b2cf2431
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 12 00:12:35 2007 -0400

    ACPI: thermal: create "thermal.psv=" to override passive trip points
    
    "thermal.psv=-1" disables passive trip points
    for all ACPI thermal zones.
    
    "thermal.psv=C", where 'C' is degrees Celsius,
    overrides all existing passive trip points
    for all ACPI thermal zones.
    
    thermal.psv is checked at module load time,
    and in response to trip-point change events.
    
    Note that if the system does not deliver thermal zone
    temperature change events near the new trip-point,
    then it will not be noticed.  To force your custom
    trip point to be noticed, you may need to enable polling:
    eg. thermal.tzp=3000 invokes polling every 5 minutes.
    
    Note that once passive thermal throttling is invoked,
    it has its own internal Thermal Sampling Period (_TSP),
    that is unrelated to _TZP.
    
    WARNING: disabling or raising a thermal trip point
    may result in increased running temperature and
    shorter hardware lifetime on some systems.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index b6b3bec84547..74e25be8abc9 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -82,6 +82,10 @@ static int off;
 module_param(off, int, 0);
 MODULE_PARM_DESC(off, "Set to disable ACPI thermal support.\n");
 
+static int psv;
+module_param(psv, int, 0644);
+MODULE_PARM_DESC(psv, "Disable or override all passive trip points.\n");
+
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);
 static int acpi_thermal_resume(struct acpi_device *device);
@@ -343,9 +347,16 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 
 	/* Passive: Processors (optional) */
 
-	status =
-	    acpi_evaluate_integer(tz->device->handle, "_PSV", NULL,
-				  &tz->trips.passive.temperature);
+	if (psv == -1) {
+		status = AE_SUPPORT;
+	} else if (psv > 0) {
+		tz->trips.passive.temperature = CELSIUS_TO_KELVIN(psv);
+		status = AE_OK;
+	} else {
+		status = acpi_evaluate_integer(tz->device->handle,
+			"_PSV", NULL, &tz->trips.passive.temperature);
+	}
+
 	if (ACPI_FAILURE(status)) {
 		tz->trips.passive.flags.valid = 0;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No passive threshold\n"));

commit 730ff34de766a6fddee25ac1c32bc49c1a2fd758
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 12 00:12:26 2007 -0400

    ACPI: thermal: expose "thermal.tzp=" to set global polling frequency
    
    Thermal Zone Polling frequency (_TZP) is an optional ACPI object
    recommending the rate that the OS should poll the associated thermal zone.
    
    If _TZP is 0, no polling should be used.
    If _TZP is non-zero, then the platform recommends that
    the OS poll the thermal zone at the specified rate.
    The minimum period is 30 seconds.
    The maximum period is 5 minutes.
    
    (note _TZP and thermal.tzp units are in deci-seconds,
     so _TZP = 300 corresponds to 30 seconds)
    
    If _TZP is not present, ACPI 3.0b recommends that the
    thermal zone be polled at an "OS provided default frequency".
    
    However, common industry practice is:
    1. The BIOS never specifies any _TZP
    2. High volume OS's from this century never poll any thermal zones
    
    Ie. The OS depends on the platform's ability to
    provoke thermal events when necessary, and
    the "OS provided default frequency" is "never":-)
    
    There is a proposal that ACPI 4.0 be updated to reflect
    common industry practice -- ie. no _TZP, no polling.
    
    The Linux kernel already follows this practice --
    thermal zones are not polled unless _TZP is present and non-zero.
    
    But thermal zone polling is useful as a workaround for systems
    which have ACPI thermal control, but have an issue preventing
    thermal events.  Indeed, some Linux distributions still
    set a non-zero thermal polling frequency for this reason.
    
    But rather than ask the user to write a polling frequency
    into all the /proc/acpi/thermal_zone/*/polling_frequency
    files, here we simply document and expose the already
    existing module parameter to do the same at system level,
    to simplify debugging those broken platforms.
    
    Note that thermal.tzp is a module-load time parameter only.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 61337d969d7f..b6b3bec84547 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -75,7 +75,7 @@ MODULE_DESCRIPTION("ACPI Thermal Zone Driver");
 MODULE_LICENSE("GPL");
 
 static int tzp;
-module_param(tzp, int, 0);
+module_param(tzp, int, 0444);
 MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
 
 static int off;

commit 72b33ef8bb1ac7f6c5a16d23304ab25ddc73d93d
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 12 00:12:17 2007 -0400

    ACPI: thermal: create "thermal.off=1" to disable ACPI thermal support
    
    "thermal.off=1" disables all ACPI thermal support at boot time.
    
    CONFIG_ACPI_THERMAL=n can do this at build time.
    "# rmmod thermal" can do this at run time,
    as long as thermal is built as a module.
    
    WARNING: On some systems, disabling ACPI thermal support
    will cause the system to run hotter and reduce the
    lifetime of the hardware.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5a62de1b7f2a..61337d969d7f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -78,6 +78,10 @@ static int tzp;
 module_param(tzp, int, 0);
 MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
 
+static int off;
+module_param(off, int, 0);
+MODULE_PARM_DESC(off, "Set to disable ACPI thermal support.\n");
+
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);
 static int acpi_thermal_resume(struct acpi_device *device);
@@ -1285,7 +1289,10 @@ static int __init acpi_thermal_init(void)
 {
 	int result = 0;
 
-
+	if (off) {
+		printk(KERN_NOTICE "ACPI: thermal control disabled\n");
+		return -ENODEV;
+	}
 	acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, acpi_root_dir);
 	if (!acpi_thermal_dir)
 		return -ENODEV;

commit 1ba90e3a87c46500623afdc3898573e4a5ebb21b
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 23 14:44:41 2007 +0200

    ACPI: autoload modules - Create __mod_acpi_device_table symbol for all ACPI drivers
    
    modpost is going to use these to create e.g. acpi:ACPI0001
    in modules.alias.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 58f1338981bc..5a62de1b7f2a 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -92,10 +92,16 @@ static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file);
 static ssize_t acpi_thermal_write_polling(struct file *, const char __user *,
 					  size_t, loff_t *);
 
+static const struct acpi_device_id  thermal_device_ids[] = {
+	{ACPI_THERMAL_HID, 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, thermal_device_ids);
+
 static struct acpi_driver acpi_thermal_driver = {
 	.name = "thermal",
 	.class = ACPI_THERMAL_CLASS,
-	.ids = ACPI_THERMAL_HID,
+	.ids = thermal_device_ids,
 	.ops = {
 		.add = acpi_thermal_add,
 		.remove = acpi_thermal_remove,

commit 10a0a8d4e3f6bf2d077f94344441909abe670f5a
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:02 2007 -0700

    Add common orderly_poweroff()
    
    Various pieces of code around the kernel want to be able to trigger an
    orderly poweroff.  This pulls them together into a single
    implementation.
    
    By default the poweroff command is /sbin/poweroff, but it can be set
    via sysctl: kernel/poweroff_cmd.  This is split at whitespace, so it
    can include command-line arguments.
    
    This patch replaces four other instances of invoking either "poweroff"
    or "shutdown -h now": two sbus drivers, and acpi thermal
    management.
    
    sparc64 has its own "powerd"; still need to determine whether it should
    be replaced by orderly_poweroff().
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 88a6fc7fd271..58f1338981bc 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -40,6 +40,7 @@
 #include <linux/jiffies.h>
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
+#include <linux/reboot.h>
 #include <asm/uaccess.h>
 
 #include <acpi/acpi_bus.h>
@@ -59,7 +60,6 @@
 #define ACPI_THERMAL_NOTIFY_CRITICAL	0xF0
 #define ACPI_THERMAL_NOTIFY_HOT		0xF1
 #define ACPI_THERMAL_MODE_ACTIVE	0x00
-#define ACPI_THERMAL_PATH_POWEROFF	"/sbin/poweroff"
 
 #define ACPI_THERMAL_MAX_ACTIVE	10
 #define ACPI_THERMAL_MAX_LIMIT_STR_LEN 65
@@ -419,26 +419,6 @@ static int acpi_thermal_get_devices(struct acpi_thermal *tz)
 	return 0;
 }
 
-static int acpi_thermal_call_usermode(char *path)
-{
-	char *argv[2] = { NULL, NULL };
-	char *envp[3] = { NULL, NULL, NULL };
-
-
-	if (!path)
-		return -EINVAL;
-
-	argv[0] = path;
-
-	/* minimal command environment */
-	envp[0] = "HOME=/";
-	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
-
-	call_usermodehelper(argv[0], argv, envp, 0);
-
-	return 0;
-}
-
 static int acpi_thermal_critical(struct acpi_thermal *tz)
 {
 	if (!tz || !tz->trips.critical.flags.valid)
@@ -456,7 +436,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 	acpi_bus_generate_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
 				tz->trips.critical.flags.enabled);
 
-	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
+	orderly_poweroff(true);
 
 	return 0;
 }

commit e7c746ef098770f863ba294adac5b30d124ba469
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 18 00:40:51 2007 -0400

    ACPI: gracefully print null trip-point device
    
    if acpi_bus_get_device() returns NULL, print nothing
    instead of "<NUL" in /proc/acpi/thermal_zone/*/trip_points
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 194ecfe8b360..88a6fc7fd271 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -828,6 +828,8 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_thermal *tz = seq->private;
 	struct acpi_device *device;
+	acpi_status status;
+
 	int i = 0;
 	int j = 0;
 
@@ -850,8 +852,10 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 			   tz->trips.passive.tc1, tz->trips.passive.tc2,
 			   tz->trips.passive.tsp);
 		for (j = 0; j < tz->trips.passive.devices.count; j++) {
-			acpi_bus_get_device(tz->trips.passive.devices.handles[j], &device);
-			seq_printf(seq, "%4.4s ", acpi_device_bid(device));
+			status = acpi_bus_get_device(tz->trips.passive.devices.
+						     handles[j], &device);
+			seq_printf(seq, "%4.4s ", status ? "" :
+				   acpi_device_bid(device));
 		}
 		seq_puts(seq, "\n");
 	}
@@ -863,8 +867,11 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 			   i,
 			   KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
 		for (j = 0; j < tz->trips.active[i].devices.count; j++){
-			acpi_bus_get_device(tz->trips.active[i].devices.handles[j], &device);
-			seq_printf(seq, "%4.4s ", acpi_device_bid(device));
+			status = acpi_bus_get_device(tz->trips.active[i].
+						     devices.handles[j],
+						     &device);
+			seq_printf(seq, "%4.4s ", status ? "" :
+				   acpi_device_bid(device));
 		}
 		seq_puts(seq, "\n");
 	}

commit 68ccfaa8222f2a26f0689fad9e8c0c3f4c19f599
Author: Thomas Renninger <trenn@suse.de>
Date:   Sun Nov 19 23:01:40 2006 +0100

    ACPI: thermal: Replace pointer with name in trip_points
    
    For users with active thermal trip points, they need
    the fan's name, rather than its address, to understand
    where to look to observe and control fan state.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1ada017d01ef..194ecfe8b360 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -827,6 +827,7 @@ static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file)
 static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_thermal *tz = seq->private;
+	struct acpi_device *device;
 	int i = 0;
 	int j = 0;
 
@@ -849,9 +850,8 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 			   tz->trips.passive.tc1, tz->trips.passive.tc2,
 			   tz->trips.passive.tsp);
 		for (j = 0; j < tz->trips.passive.devices.count; j++) {
-
-			seq_printf(seq, "0x%p ",
-				   tz->trips.passive.devices.handles[j]);
+			acpi_bus_get_device(tz->trips.passive.devices.handles[j], &device);
+			seq_printf(seq, "%4.4s ", acpi_device_bid(device));
 		}
 		seq_puts(seq, "\n");
 	}
@@ -862,9 +862,10 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 		seq_printf(seq, "active[%d]:               %ld C: devices=",
 			   i,
 			   KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
-		for (j = 0; j < tz->trips.active[i].devices.count; j++)
-			seq_printf(seq, "0x%p ",
-				   tz->trips.active[i].devices.handles[j]);
+		for (j = 0; j < tz->trips.active[i].devices.count; j++){
+			acpi_bus_get_device(tz->trips.active[i].devices.handles[j], &device);
+			seq_printf(seq, "%4.4s ", acpi_device_bid(device));
+		}
 		seq_puts(seq, "\n");
 	}
 

commit eaca2d3f6c4de9d4274a4e2be54c9693e76b0303
Author: Len Brown <len.brown@intel.com>
Date:   Mon Apr 30 23:27:43 2007 -0400

    ACPI: delete un-reliable concept of cooling mode
    
    The scheme where the thermal driver displayed the
    cooling mode /proc/acpi/thermal_zone/*/cooling_mode
    was flawed in two ways.
    
    First, the success of _SCP doesn't actually mean
    that the BIOS moved any trip points.
    On many BIOS, _SCP is present, but does nothing.
    So displaying what _SCP executed actually
    was wrong more times than it was right.
    
    Second, examining the relative position of the
    trip points when the thermal_zone is added
    is insufficient -- as the BIOS reserves the right
    to change the trip points at run-time.
    
    The only reliable way for the user to determine if
    the thermal zone is in active, passive, or critical
    mode is to examine the relative position of the trip points.
    The user can do this without the kernel doing it
    for them by looking in /proc/acpi/thermal_zone/*/trip_points
    
    New contents for /proc/acpi/thermal_zone/*/cooling_mode:
    
    If _SCP available:
    "0 - Active; 1 - Passive\n"
    
    If _SCP unavailable:
    "<setting not supported>\n"
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 73b6fe7093e9..1ada017d01ef 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -59,8 +59,6 @@
 #define ACPI_THERMAL_NOTIFY_CRITICAL	0xF0
 #define ACPI_THERMAL_NOTIFY_HOT		0xF1
 #define ACPI_THERMAL_MODE_ACTIVE	0x00
-#define ACPI_THERMAL_MODE_PASSIVE	0x01
-#define ACPI_THERMAL_MODE_CRITICAL   	0xff
 #define ACPI_THERMAL_PATH_POWEROFF	"/sbin/poweroff"
 
 #define ACPI_THERMAL_MAX_ACTIVE	10
@@ -164,7 +162,6 @@ struct acpi_thermal {
 	unsigned long temperature;
 	unsigned long last_temperature;
 	unsigned long polling_frequency;
-	u8 cooling_mode;
 	volatile u8 zombie;
 	struct acpi_thermal_flags flags;
 	struct acpi_thermal_state state;
@@ -293,11 +290,6 @@ static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	tz->cooling_mode = mode;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n",
-			  mode ? "passive" : "active"));
-
 	return 0;
 }
 
@@ -893,15 +885,10 @@ static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
 	if (!tz)
 		goto end;
 
-	if (!tz->flags.cooling_mode) {
+	if (!tz->flags.cooling_mode)
 		seq_puts(seq, "<setting not supported>\n");
-	}
-
-	if (tz->cooling_mode == ACPI_THERMAL_MODE_CRITICAL)
-		seq_printf(seq, "cooling mode:	critical\n");
 	else
-		seq_printf(seq, "cooling mode:	%s\n",
-			   tz->cooling_mode ? "passive" : "active");
+		seq_puts(seq, "0 - Active; 1 - Passive\n");
 
       end:
 	return 0;
@@ -1158,28 +1145,6 @@ static int acpi_thermal_get_info(struct acpi_thermal *tz)
 	result = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);
 	if (!result)
 		tz->flags.cooling_mode = 1;
-	else {
-		/* Oh,we have not _SCP method.
-		   Generally show cooling_mode by _ACx, _PSV,spec 12.2 */
-		tz->flags.cooling_mode = 0;
-		if (tz->trips.active[0].flags.valid
-		    && tz->trips.passive.flags.valid) {
-			if (tz->trips.passive.temperature >
-			    tz->trips.active[0].temperature)
-				tz->cooling_mode = ACPI_THERMAL_MODE_ACTIVE;
-			else
-				tz->cooling_mode = ACPI_THERMAL_MODE_PASSIVE;
-		} else if (!tz->trips.active[0].flags.valid
-			   && tz->trips.passive.flags.valid) {
-			tz->cooling_mode = ACPI_THERMAL_MODE_PASSIVE;
-		} else if (tz->trips.active[0].flags.valid
-			   && !tz->trips.passive.flags.valid) {
-			tz->cooling_mode = ACPI_THERMAL_MODE_ACTIVE;
-		} else {
-			/* _ACx and _PSV are optional, but _CRT is required */
-			tz->cooling_mode = ACPI_THERMAL_MODE_CRITICAL;
-		}
-	}
 
 	/* Get default polling frequency [_TZP] (optional) */
 	if (tzp)

commit 11ccc0f249cb01a129f54760b8ff087f242935d4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Apr 30 22:36:01 2007 -0400

    ACPI: thermal trip points are read-only
    
    /proc/acpi/thermal_zone/*/trip_points displays
    what the kernel reads from the BIOS via ACPI.
    
    If you echo a string of ':' deliminted numbers to this file
    then it will change what it displays.
    
    But it shouldn't, since the kernel has no way to communicate
    these changes to ACPI thermal zones.  ACPI thermal zone
    trip points are read-only.
    
    The kernel does have the opportunity to ask the BIOS to change
    the trip points with _SCP - Set Cooling Policy.
    
    Request Active Cooling Mode:
    # echo 0 > /proc/acpi/thermal_zone/*/cooling_policy
    
    Request Passive Cooling Mode:
    # echo 1 > /proc/acpi/thermal_zone/*/cooling_policy
    
    However, in practice it is quite rare for the BIOS
    to support the optional _SCP, and it is even more rare
    for the BIOS to export an _SCP that actually changes
    the trip points.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 589b98b7b216..73b6fe7093e9 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -86,9 +86,6 @@ static int acpi_thermal_resume(struct acpi_device *device);
 static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_trip_points(struct file *,
-					      const char __user *, size_t,
-					      loff_t *);
 static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file);
 static ssize_t acpi_thermal_write_cooling_mode(struct file *,
 					       const char __user *, size_t,
@@ -193,7 +190,6 @@ static const struct file_operations acpi_thermal_temp_fops = {
 static const struct file_operations acpi_thermal_trip_fops = {
 	.open = acpi_thermal_trip_open_fs,
 	.read = seq_read,
-	.write = acpi_thermal_write_trip_points,
 	.llseek = seq_lseek,
 	.release = single_release,
 };
@@ -889,67 +885,6 @@ static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_thermal_trip_seq_show, PDE(inode)->data);
 }
 
-static ssize_t
-acpi_thermal_write_trip_points(struct file *file,
-			       const char __user * buffer,
-			       size_t count, loff_t * ppos)
-{
-	struct seq_file *m = file->private_data;
-	struct acpi_thermal *tz = m->private;
-
-	char *limit_string;
-	int num, critical, hot, passive;
-	int *active;
-	int i = 0;
-
-
-	limit_string = kzalloc(ACPI_THERMAL_MAX_LIMIT_STR_LEN, GFP_KERNEL);
-	if (!limit_string)
-		return -ENOMEM;
-
-	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE * sizeof(int), GFP_KERNEL);
-	if (!active) {
-		kfree(limit_string);
-		return -ENOMEM;
-	}
-
-	if (!tz || (count > ACPI_THERMAL_MAX_LIMIT_STR_LEN - 1)) {
-		count = -EINVAL;
-		goto end;
-	}
-
-	if (copy_from_user(limit_string, buffer, count)) {
-		count = -EFAULT;
-		goto end;
-	}
-
-	limit_string[count] = '\0';
-
-	num = sscanf(limit_string, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
-		     &critical, &hot, &passive,
-		     &active[0], &active[1], &active[2], &active[3], &active[4],
-		     &active[5], &active[6], &active[7], &active[8],
-		     &active[9]);
-	if (!(num >= 5 && num < (ACPI_THERMAL_MAX_ACTIVE + 3))) {
-		count = -EINVAL;
-		goto end;
-	}
-
-	tz->trips.critical.temperature = CELSIUS_TO_KELVIN(critical);
-	tz->trips.hot.temperature = CELSIUS_TO_KELVIN(hot);
-	tz->trips.passive.temperature = CELSIUS_TO_KELVIN(passive);
-	for (i = 0; i < num - 3; i++) {
-		if (!(tz->trips.active[i].flags.valid))
-			break;
-		tz->trips.active[i].temperature = CELSIUS_TO_KELVIN(active[i]);
-	}
-
-      end:
-	kfree(active);
-	kfree(limit_string);
-	return count;
-}
-
 static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_thermal *tz = seq->private;

commit 94e22e13ad063c614b458a019b428ffc118e5c06
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Apr 23 14:41:13 2007 -0700

    acpi-thermal: fix mod_timer() interval
    
    Use relative time, not absolute.  Discovered by Jung-Ik (John) Lee
    <jilee@google.com>.
    
    Cc: Jung-Ik (John) Lee <jilee@google.com>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 0ae8b9310cbf..589b98b7b216 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -758,7 +758,8 @@ static void acpi_thermal_check(void *data)
 			del_timer(&(tz->timer));
 	} else {
 		if (timer_pending(&(tz->timer)))
-			mod_timer(&(tz->timer), (HZ * sleep_time) / 1000);
+			mod_timer(&(tz->timer),
+					jiffies + (HZ * sleep_time) / 1000);
 		else {
 			tz->timer.data = (unsigned long)tz;
 			tz->timer.function = acpi_thermal_run;

commit 08e4a10ec82faf5ba67c8d0115b7bc9e58071555
Merge: 4559b438225b b1028c545ced
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:11:50 2007 -0500

    Pull bugzilla-7570 into release branch

commit c0cd79d11412969b6b8fa1624cdc1277db82e2fe
Merge: 81450b73dde0 db2d4ccdc8f9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:10:32 2007 -0500

    Pull fluff into release branch
    
    Conflicts:
    
            arch/x86_64/pci/mmconfig.c
            drivers/acpi/bay.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 81450b73dde07f473a4a7208b209b4c8b7251d90
Merge: 8a03d9a498ea 0539771d7236
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 18:52:41 2007 -0500

    Pull misc-for-upstream into release branch
    
    Conflicts:
    
            drivers/usb/misc/appledisplay.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit b1028c545ced13590dd9a9a8086543aef26c7187
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Fri Feb 16 02:23:07 2007 -0500

    ACPI: fix fan after resume from S3
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7570
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 986afd470a14..7118ac67ef68 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1357,28 +1357,32 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 static int acpi_thermal_resume(struct acpi_device *device)
 {
 	struct acpi_thermal *tz = NULL;
-	int i;
+	int i, j, power_state, result;
+
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
 	tz = acpi_driver_data(device);
 
-	acpi_thermal_get_temperature(tz);
-
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
-		if (tz->trips.active[i].flags.valid) {
- 			tz->temperature = tz->trips.active[i].temperature;
-			tz->trips.active[i].flags.enabled = 0;
-
-			acpi_thermal_active(tz);
-
-			tz->state.active |= tz->trips.active[i].flags.enabled;
-			tz->state.active_index = i;
+		if (!(&tz->trips.active[i]))
+			break;
+		if (!tz->trips.active[i].flags.valid)
+			break;
+		tz->trips.active[i].flags.enabled = 1;
+		for (j = 0; j < tz->trips.active[i].devices.count; j++) {
+			result = acpi_bus_get_power(tz->trips.active[i].devices.
+			    handles[j], &power_state);
+			if (result || (power_state != ACPI_STATE_D0)) {
+				tz->trips.active[i].flags.enabled = 0;
+				break;
+			}
 		}
+		tz->state.active |= tz->trips.active[i].flags.enabled;
 	}
 
- 	acpi_thermal_check(tz);
+	acpi_thermal_check(tz);
 
 	return AE_OK;
 }

commit 636cedf9df6a6442364e78b51925f306a1056e43
Author: Sanjoy Mahajan <sanjoy@mrao.cam.ac.uk>
Date:   Fri Feb 16 01:24:43 2007 -0500

    ACPI: thermal: fix units in debug output
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4972
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index f76d3168c2b2..ff078d9b52f6 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -269,7 +269,7 @@ static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Polling frequency set to %lu seconds\n",
-			  tz->polling_frequency));
+			  tz->polling_frequency/10));
 
 	return 0;
 }

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index f76d3168c2b2..986afd470a14 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -36,7 +36,8 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/proc_fs.h>
-#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>

commit 7cda93e008e1a477970adbf82dba81a5d4f0ae40
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:50:02 2007 -0500

    ACPI: delete extra #defines in /drivers/acpi/ drivers
    
    Cosmetic only.
    
    Except in a single case, #define ACPI_*_DRIVER_NAME
    were invoked 0 or 1 times.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index c34a89d34560..f50a405d0134 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -46,7 +46,6 @@
 
 #define ACPI_THERMAL_COMPONENT		0x04000000
 #define ACPI_THERMAL_CLASS		"thermal_zone"
-#define ACPI_THERMAL_DRIVER_NAME	"ACPI Thermal Zone Driver"
 #define ACPI_THERMAL_DEVICE_NAME	"Thermal Zone"
 #define ACPI_THERMAL_FILE_STATE		"state"
 #define ACPI_THERMAL_FILE_TEMPERATURE	"temperature"
@@ -73,7 +72,7 @@
 ACPI_MODULE_NAME("thermal");
 
 MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);
+MODULE_DESCRIPTION("ACPI Thermal Zone Driver");
 MODULE_LICENSE("GPL");
 
 static int tzp;

commit c2b6705b75d9c7aff98a4602a32230639e10891c
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:33:40 2007 -0500

    ACPI: fix acpi_driver.name usage
    
    It was erroneously used as a description rather than a name.
    
    ie. turn this:
    
    lenb@se7525gp2:/sys> ls bus/acpi/drivers
    ACPI AC Adapter Driver  ACPI Embedded Controller Driver  ACPI Power Resource Driver
    ACPI Battery Driver     ACPI Fan Driver                  ACPI Processor Driver
    ACPI Button Driver      ACPI PCI Interrupt Link Driver   ACPI Thermal Zone Driver
    ACPI container driver   ACPI PCI Root Bridge Driver      hpet
    
    into this:
    
    lenb@se7525gp2:~> ls /sys/bus/acpi/drivers
    ac  battery  button  container  ec  fan  hpet  pci_link  pci_root  power  processor  thermal
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index bf0a9f2e37e0..c34a89d34560 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -98,7 +98,7 @@ static ssize_t acpi_thermal_write_polling(struct file *, const char __user *,
 					  size_t, loff_t *);
 
 static struct acpi_driver acpi_thermal_driver = {
-	.name = ACPI_THERMAL_DRIVER_NAME,
+	.name = "thermal",
 	.class = ACPI_THERMAL_CLASS,
 	.ids = ACPI_THERMAL_HID,
 	.ops = {

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index f76d3168c2b2..bf0a9f2e37e0 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -70,7 +70,7 @@
 #define CELSIUS_TO_KELVIN(t)	((t+273)*10)
 
 #define _COMPONENT		ACPI_THERMAL_COMPONENT
-ACPI_MODULE_NAME("acpi_thermal")
+ACPI_MODULE_NAME("thermal");
 
 MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);

commit 975a8e3ed2b9eab9f062a1e0ba7fe180e15204e1
Merge: 1fcb71b84b05 bfd80223d73f
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 3 01:14:35 2007 -0500

    Pull sysfs into test branch
    
    Conflicts:
    
            Documentation/feature-removal-schedule.txt
            include/acpi/acpi_drivers.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 4d75085ca2d2..40ddb4dd9631 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -902,12 +902,10 @@ acpi_thermal_write_trip_points(struct file *file,
 	int i = 0;
 
 
-	limit_string = kmalloc(ACPI_THERMAL_MAX_LIMIT_STR_LEN, GFP_KERNEL);
+	limit_string = kzalloc(ACPI_THERMAL_MAX_LIMIT_STR_LEN, GFP_KERNEL);
 	if (!limit_string)
 		return -ENOMEM;
 
-	memset(limit_string, 0, ACPI_THERMAL_MAX_LIMIT_STR_LEN);
-
 	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE * sizeof(int), GFP_KERNEL);
 	if (!active) {
 		kfree(limit_string);
@@ -1271,10 +1269,9 @@ static int acpi_thermal_add(struct acpi_device *device)
 	if (!device)
 		return -EINVAL;
 
-	tz = kmalloc(sizeof(struct acpi_thermal), GFP_KERNEL);
+	tz = kzalloc(sizeof(struct acpi_thermal), GFP_KERNEL);
 	if (!tz)
 		return -ENOMEM;
-	memset(tz, 0, sizeof(struct acpi_thermal));
 
 	tz->device = device;
 	strcpy(tz->name, device->pnp.bus_id);

commit 5d9464a46918ced087c351a10f38cee95725f85b
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:27 2006 +0800

    ACPI: add ACPI bus_type for driver model
    
    Add ACPI bus_type for Linux driver model.
    
    1.      .shutdown method is added into acpi_driver.ops
            needed by bus_type operations.
    2.      remove useless parameter 'int state' in .resume method.
    3.      change parameter 'int state'
            to 'pm_message_t state' in .suspend method.
    
    Note:   The new .uevent method mark ACPI drivers by PNPID instead of by name.
            Udev script needs to look for "HWID=" or "COMPTID=" to load
            ACPI drivers as a result.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5753d06b7860..3650654f878e 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -82,7 +82,7 @@ MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
 
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);
-static int acpi_thermal_resume(struct acpi_device *device, int state);
+static int acpi_thermal_resume(struct acpi_device *device);
 static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
@@ -1356,7 +1356,7 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
-static int acpi_thermal_resume(struct acpi_device *device, int state)
+static int acpi_thermal_resume(struct acpi_device *device)
 {
 	struct acpi_thermal *tz = NULL;
 	int i;

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 5753d06b7860..4d75085ca2d2 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -663,7 +663,7 @@ static void acpi_thermal_run(unsigned long data)
 static void acpi_thermal_check(void *data)
 {
 	int result = 0;
-	struct acpi_thermal *tz = (struct acpi_thermal *)data;
+	struct acpi_thermal *tz = data;
 	unsigned long sleep_time = 0;
 	int i = 0;
 	struct acpi_thermal_state state;
@@ -778,7 +778,7 @@ static struct proc_dir_entry *acpi_thermal_dir;
 
 static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = seq->private;
 
 
 	if (!tz)
@@ -813,7 +813,7 @@ static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file)
 static int acpi_thermal_temp_seq_show(struct seq_file *seq, void *offset)
 {
 	int result = 0;
-	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = seq->private;
 
 
 	if (!tz)
@@ -837,7 +837,7 @@ static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file)
 
 static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = seq->private;
 	int i = 0;
 	int j = 0;
 
@@ -893,8 +893,8 @@ acpi_thermal_write_trip_points(struct file *file,
 			       const char __user * buffer,
 			       size_t count, loff_t * ppos)
 {
-	struct seq_file *m = (struct seq_file *)file->private_data;
-	struct acpi_thermal *tz = (struct acpi_thermal *)m->private;
+	struct seq_file *m = file->private_data;
+	struct acpi_thermal *tz = m->private;
 
 	char *limit_string;
 	int num, critical, hot, passive;
@@ -953,7 +953,7 @@ acpi_thermal_write_trip_points(struct file *file,
 
 static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = seq->private;
 
 
 	if (!tz)
@@ -984,8 +984,8 @@ acpi_thermal_write_cooling_mode(struct file *file,
 				const char __user * buffer,
 				size_t count, loff_t * ppos)
 {
-	struct seq_file *m = (struct seq_file *)file->private_data;
-	struct acpi_thermal *tz = (struct acpi_thermal *)m->private;
+	struct seq_file *m = file->private_data;
+	struct acpi_thermal *tz = m->private;
 	int result = 0;
 	char mode_string[12] = { '\0' };
 
@@ -1014,7 +1014,7 @@ acpi_thermal_write_cooling_mode(struct file *file,
 
 static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = seq->private;
 
 
 	if (!tz)
@@ -1043,8 +1043,8 @@ acpi_thermal_write_polling(struct file *file,
 			   const char __user * buffer,
 			   size_t count, loff_t * ppos)
 {
-	struct seq_file *m = (struct seq_file *)file->private_data;
-	struct acpi_thermal *tz = (struct acpi_thermal *)m->private;
+	struct seq_file *m = file->private_data;
+	struct acpi_thermal *tz = m->private;
 	int result = 0;
 	char polling_string[12] = { '\0' };
 	int seconds = 0;
@@ -1170,7 +1170,7 @@ static int acpi_thermal_remove_fs(struct acpi_device *device)
 
 static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 {
-	struct acpi_thermal *tz = (struct acpi_thermal *)data;
+	struct acpi_thermal *tz = data;
 	struct acpi_device *device = NULL;
 
 
@@ -1324,7 +1324,7 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
-	tz = (struct acpi_thermal *)acpi_driver_data(device);
+	tz = acpi_driver_data(device);
 
 	/* avoid timer adding new defer task */
 	tz->zombie = 1;
@@ -1364,7 +1364,7 @@ static int acpi_thermal_resume(struct acpi_device *device, int state)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
-	tz = (struct acpi_thermal *)acpi_driver_data(device);
+	tz = acpi_driver_data(device);
 
 	acpi_thermal_get_temperature(tz);
 

commit c80dc60b03d633047c7f96be87fd59cdcdbb929f
Merge: 90ca9a2ff4d6 0466684907ea
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jul 10 15:14:38 2006 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6:
      ACPI: ACPI_DOCK: Initialize the atomic notifier list
      ACPI: acpi_os_allocate() fixes
      ACPI: SBS: fix initialization, sem2mutex
      ACPI: add 'const' to several ACPI file_operations
      ACPI: delete some defaults from ACPI Kconfig
      ACPI: "Device `[%s]' is not power manageable" make message debug only
      ACPI: ACPI_DOCK Kconfig
      Revert "Revert "ACPI: dock driver""
      ACPI: acpi_os_get_thread_id() returns current
      ACPI: ACPICA 20060707

commit bed936f7eab946c60170bc92a1aea597da158e02
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Mon Jul 10 04:44:26 2006 -0700

    [PATCH] ACPI: fix fan/thermal resume
    
    Daniel Ritz <daniel.ritz-ml@swissonline.ch> says:
    
    The acpi driver suspend/resume patches that went in recently caused a regression
    on my box (toshiba tecra 8000 laptop): after resume from swsusp the fan turns on
    keeping blowing cold air out of my notebook. before the patches, the fan was off
    and would only make noise when required. it's the same thing described in
    bugzilla.kernel.org #5000. the acpi suspend/resume patches or at least parts of
    them originate in this bug. now the last patch in the report (attach id 8438)
    actually fixes the problem - for me and the reporter. this is a trimmed down
    version of that patch.
    
    Signed-off-by: Daniel Ritz <daniel.ritz@gmx.ch>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Sanjoy Mahajan <sanjoy@mrao.cam.ac.uk>
    Cc: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 503c0b99db12..fdba4879603f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1359,13 +1359,28 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 static int acpi_thermal_resume(struct acpi_device *device, int state)
 {
 	struct acpi_thermal *tz = NULL;
+	int i;
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
 	tz = (struct acpi_thermal *)acpi_driver_data(device);
 
-	acpi_thermal_check(tz);
+	acpi_thermal_get_temperature(tz);
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
+		if (tz->trips.active[i].flags.valid) {
+ 			tz->temperature = tz->trips.active[i].temperature;
+			tz->trips.active[i].flags.enabled = 0;
+
+			acpi_thermal_active(tz);
+
+			tz->state.active |= tz->trips.active[i].flags.enabled;
+			tz->state.active_index = i;
+		}
+	}
+
+ 	acpi_thermal_check(tz);
 
 	return AE_OK;
 }

commit d75080328affb4b268da430b7074cc8139cc662a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Jul 4 13:06:00 2006 -0400

    ACPI: add 'const' to several ACPI file_operations
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 503c0b99db12..480a31796886 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -176,21 +176,21 @@ struct acpi_thermal {
 	struct timer_list timer;
 };
 
-static struct file_operations acpi_thermal_state_fops = {
+static const struct file_operations acpi_thermal_state_fops = {
 	.open = acpi_thermal_state_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
 	.release = single_release,
 };
 
-static struct file_operations acpi_thermal_temp_fops = {
+static const struct file_operations acpi_thermal_temp_fops = {
 	.open = acpi_thermal_temp_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
 	.release = single_release,
 };
 
-static struct file_operations acpi_thermal_trip_fops = {
+static const struct file_operations acpi_thermal_trip_fops = {
 	.open = acpi_thermal_trip_open_fs,
 	.read = seq_read,
 	.write = acpi_thermal_write_trip_points,
@@ -198,7 +198,7 @@ static struct file_operations acpi_thermal_trip_fops = {
 	.release = single_release,
 };
 
-static struct file_operations acpi_thermal_cooling_fops = {
+static const struct file_operations acpi_thermal_cooling_fops = {
 	.open = acpi_thermal_cooling_open_fs,
 	.read = seq_read,
 	.write = acpi_thermal_write_cooling_mode,
@@ -206,7 +206,7 @@ static struct file_operations acpi_thermal_cooling_fops = {
 	.release = single_release,
 };
 
-static struct file_operations acpi_thermal_polling_fops = {
+static const struct file_operations acpi_thermal_polling_fops = {
 	.open = acpi_thermal_polling_open_fs,
 	.read = seq_read,
 	.write = acpi_thermal_write_polling,

commit 8a4444bf5a3fd890441e6cbd5022a3c24edbe69a
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:51 2006 -0400

    ACPI: thermal: Remove unneeded acpi_handle from driver.
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 56358e149b2b..503c0b99db12 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -162,7 +162,6 @@ struct acpi_thermal_flags {
 };
 
 struct acpi_thermal {
-	acpi_handle handle;
 	struct acpi_device * device;
 	acpi_bus_id name;
 	unsigned long temperature;
@@ -1277,7 +1276,6 @@ static int acpi_thermal_add(struct acpi_device *device)
 		return -ENOMEM;
 	memset(tz, 0, sizeof(struct acpi_thermal));
 
-	tz->handle = device->handle;
 	tz->device = device;
 	strcpy(tz->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);

commit 38ba7c9ed2e1a222103332031f76c28b726573f5
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:48 2006 -0400

    ACPI: thermal: Use acpi_device's handle instead of driver's
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1d8c250c3c73..56358e149b2b 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -230,7 +230,7 @@ static int acpi_thermal_get_temperature(struct acpi_thermal *tz)
 	tz->last_temperature = tz->temperature;
 
 	status =
-	    acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
+	    acpi_evaluate_integer(tz->device->handle, "_TMP", NULL, &tz->temperature);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -249,7 +249,7 @@ static int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)
 		return -EINVAL;
 
 	status =
-	    acpi_evaluate_integer(tz->handle, "_TZP", NULL,
+	    acpi_evaluate_integer(tz->device->handle, "_TZP", NULL,
 				  &tz->polling_frequency);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
@@ -286,7 +286,7 @@ static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 	if (!tz)
 		return -EINVAL;
 
-	status = acpi_get_handle(tz->handle, "_SCP", &handle);
+	status = acpi_get_handle(tz->device->handle, "_SCP", &handle);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
 		return -ENODEV;
@@ -317,7 +317,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 
 	/* Critical Shutdown (required) */
 
-	status = acpi_evaluate_integer(tz->handle, "_CRT", NULL,
+	status = acpi_evaluate_integer(tz->device->handle, "_CRT", NULL,
 				       &tz->trips.critical.temperature);
 	if (ACPI_FAILURE(status)) {
 		tz->trips.critical.flags.valid = 0;
@@ -333,7 +333,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 	/* Critical Sleep (optional) */
 
 	status =
-	    acpi_evaluate_integer(tz->handle, "_HOT", NULL,
+	    acpi_evaluate_integer(tz->device->handle, "_HOT", NULL,
 				  &tz->trips.hot.temperature);
 	if (ACPI_FAILURE(status)) {
 		tz->trips.hot.flags.valid = 0;
@@ -347,7 +347,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 	/* Passive: Processors (optional) */
 
 	status =
-	    acpi_evaluate_integer(tz->handle, "_PSV", NULL,
+	    acpi_evaluate_integer(tz->device->handle, "_PSV", NULL,
 				  &tz->trips.passive.temperature);
 	if (ACPI_FAILURE(status)) {
 		tz->trips.passive.flags.valid = 0;
@@ -356,25 +356,25 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 		tz->trips.passive.flags.valid = 1;
 
 		status =
-		    acpi_evaluate_integer(tz->handle, "_TC1", NULL,
+		    acpi_evaluate_integer(tz->device->handle, "_TC1", NULL,
 					  &tz->trips.passive.tc1);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 
 		status =
-		    acpi_evaluate_integer(tz->handle, "_TC2", NULL,
+		    acpi_evaluate_integer(tz->device->handle, "_TC2", NULL,
 					  &tz->trips.passive.tc2);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 
 		status =
-		    acpi_evaluate_integer(tz->handle, "_TSP", NULL,
+		    acpi_evaluate_integer(tz->device->handle, "_TSP", NULL,
 					  &tz->trips.passive.tsp);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 
 		status =
-		    acpi_evaluate_reference(tz->handle, "_PSL", NULL,
+		    acpi_evaluate_reference(tz->device->handle, "_PSL", NULL,
 					    &tz->trips.passive.devices);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
@@ -394,14 +394,14 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 		char name[5] = { '_', 'A', 'C', ('0' + i), '\0' };
 
 		status =
-		    acpi_evaluate_integer(tz->handle, name, NULL,
+		    acpi_evaluate_integer(tz->device->handle, name, NULL,
 					  &tz->trips.active[i].temperature);
 		if (ACPI_FAILURE(status))
 			break;
 
 		name[2] = 'L';
 		status =
-		    acpi_evaluate_reference(tz->handle, name, NULL,
+		    acpi_evaluate_reference(tz->device->handle, name, NULL,
 					    &tz->trips.active[i].devices);
 		if (ACPI_SUCCESS(status)) {
 			tz->trips.active[i].flags.valid = 1;
@@ -425,7 +425,7 @@ static int acpi_thermal_get_devices(struct acpi_thermal *tz)
 		return -EINVAL;
 
 	status =
-	    acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
+	    acpi_evaluate_reference(tz->device->handle, "_TZD", NULL, &tz->devices);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -1296,7 +1296,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 
 	acpi_thermal_check(tz);
 
-	status = acpi_install_notify_handler(tz->handle,
+	status = acpi_install_notify_handler(device->handle,
 					     ACPI_DEVICE_NOTIFY,
 					     acpi_thermal_notify, tz);
 	if (ACPI_FAILURE(status)) {
@@ -1337,7 +1337,7 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	/* deferred task may reinsert timer */
 	del_timer_sync(&(tz->timer));
 
-	status = acpi_remove_notify_handler(tz->handle,
+	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_DEVICE_NOTIFY,
 					    acpi_thermal_notify);
 

commit 8348e1b19a06b1932f65e84e1d59be29e1626c2b
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:40 2006 -0400

    ACPI: thermal: add struct acpi_device to struct acpi_thermal.
    
    - Use it instead of acpi_bus_get_device() where we can..
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index c855f4446b5f..1d8c250c3c73 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -163,6 +163,7 @@ struct acpi_thermal_flags {
 
 struct acpi_thermal {
 	acpi_handle handle;
+	struct acpi_device * device;
 	acpi_bus_id name;
 	unsigned long temperature;
 	unsigned long last_temperature;
@@ -453,10 +454,6 @@ static int acpi_thermal_call_usermode(char *path)
 
 static int acpi_thermal_critical(struct acpi_thermal *tz)
 {
-	int result = 0;
-	struct acpi_device *device = NULL;
-
-
 	if (!tz || !tz->trips.critical.flags.valid)
 		return -EINVAL;
 
@@ -466,14 +463,10 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 	} else if (tz->trips.critical.flags.enabled)
 		tz->trips.critical.flags.enabled = 0;
 
-	result = acpi_bus_get_device(tz->handle, &device);
-	if (result)
-		return result;
-
 	printk(KERN_EMERG
 	       "Critical temperature reached (%ld C), shutting down.\n",
 	       KELVIN_TO_CELSIUS(tz->temperature));
-	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_CRITICAL,
+	acpi_bus_generate_event(tz->device, ACPI_THERMAL_NOTIFY_CRITICAL,
 				tz->trips.critical.flags.enabled);
 
 	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
@@ -483,10 +476,6 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 
 static int acpi_thermal_hot(struct acpi_thermal *tz)
 {
-	int result = 0;
-	struct acpi_device *device = NULL;
-
-
 	if (!tz || !tz->trips.hot.flags.valid)
 		return -EINVAL;
 
@@ -496,11 +485,7 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 	} else if (tz->trips.hot.flags.enabled)
 		tz->trips.hot.flags.enabled = 0;
 
-	result = acpi_bus_get_device(tz->handle, &device);
-	if (result)
-		return result;
-
-	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT,
+	acpi_bus_generate_event(tz->device, ACPI_THERMAL_NOTIFY_HOT,
 				tz->trips.hot.flags.enabled);
 
 	/* TBD: Call user-mode "sleep(S4)" function */
@@ -1193,8 +1178,7 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 	if (!tz)
 		return;
 
-	if (acpi_bus_get_device(tz->handle, &device))
-		return;
+	device = tz->device;
 
 	switch (event) {
 	case ACPI_THERMAL_NOTIFY_TEMPERATURE:
@@ -1294,6 +1278,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 	memset(tz, 0, sizeof(struct acpi_thermal));
 
 	tz->handle = device->handle;
+	tz->device = device;
 	strcpy(tz->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 1b9754919f72..c855f4446b5f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -222,51 +222,48 @@ static int acpi_thermal_get_temperature(struct acpi_thermal *tz)
 {
 	acpi_status status = AE_OK;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_temperature");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	tz->last_temperature = tz->temperature;
 
 	status =
 	    acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n",
 			  tz->temperature));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)
 {
 	acpi_status status = AE_OK;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_polling_frequency");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	status =
 	    acpi_evaluate_integer(tz->handle, "_TZP", NULL,
 				  &tz->polling_frequency);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n",
 			  tz->polling_frequency));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
 {
-	ACPI_FUNCTION_TRACE("acpi_thermal_set_polling");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
 
@@ -274,7 +271,7 @@ static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
 			  "Polling frequency set to %lu seconds\n",
 			  tz->polling_frequency));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
@@ -284,29 +281,28 @@ static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 	struct acpi_object_list arg_list = { 1, &arg0 };
 	acpi_handle handle = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_set_cooling_mode");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	status = acpi_get_handle(tz->handle, "_SCP", &handle);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	arg0.integer.value = mode;
 
 	status = acpi_evaluate_object(handle, NULL, &arg_list, NULL);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	tz->cooling_mode = mode;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n",
 			  mode ? "passive" : "active"));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
@@ -314,10 +310,9 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 	acpi_status status = AE_OK;
 	int i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_trip_points");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* Critical Shutdown (required) */
 
@@ -326,7 +321,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 	if (ACPI_FAILURE(status)) {
 		tz->trips.critical.flags.valid = 0;
 		ACPI_EXCEPTION((AE_INFO, status, "No critical threshold"));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	} else {
 		tz->trips.critical.flags.valid = 1;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
@@ -417,24 +412,23 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 					"Invalid active threshold [%d]", i));
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_get_devices(struct acpi_thermal *tz)
 {
 	acpi_status status = AE_OK;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_devices");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	status =
 	    acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_call_usermode(char *path)
@@ -442,10 +436,9 @@ static int acpi_thermal_call_usermode(char *path)
 	char *argv[2] = { NULL, NULL };
 	char *envp[3] = { NULL, NULL, NULL };
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_call_usermode");
 
 	if (!path)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	argv[0] = path;
 
@@ -455,7 +448,7 @@ static int acpi_thermal_call_usermode(char *path)
 
 	call_usermodehelper(argv[0], argv, envp, 0);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_critical(struct acpi_thermal *tz)
@@ -463,10 +456,9 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 	int result = 0;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_critical");
 
 	if (!tz || !tz->trips.critical.flags.valid)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (tz->temperature >= tz->trips.critical.temperature) {
 		printk(KERN_WARNING PREFIX "Critical trip point\n");
@@ -476,7 +468,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 
 	result = acpi_bus_get_device(tz->handle, &device);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	printk(KERN_EMERG
 	       "Critical temperature reached (%ld C), shutting down.\n",
@@ -486,7 +478,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 
 	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_hot(struct acpi_thermal *tz)
@@ -494,10 +486,9 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 	int result = 0;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_hot");
 
 	if (!tz || !tz->trips.hot.flags.valid)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (tz->temperature >= tz->trips.hot.temperature) {
 		printk(KERN_WARNING PREFIX "Hot trip point\n");
@@ -507,14 +498,14 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 
 	result = acpi_bus_get_device(tz->handle, &device);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT,
 				tz->trips.hot.flags.enabled);
 
 	/* TBD: Call user-mode "sleep(S4)" function */
 
-	return_VALUE(0);
+	return 0;
 }
 
 static void acpi_thermal_passive(struct acpi_thermal *tz)
@@ -524,7 +515,6 @@ static void acpi_thermal_passive(struct acpi_thermal *tz)
 	int trend = 0;
 	int i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_passive");
 
 	if (!tz || !tz->trips.passive.flags.valid)
 		return;
@@ -613,7 +603,6 @@ static void acpi_thermal_active(struct acpi_thermal *tz)
 	int j = 0;
 	unsigned long maxtemp = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_active");
 
 	if (!tz)
 		return;
@@ -695,18 +684,17 @@ static void acpi_thermal_check(void *data)
 	int i = 0;
 	struct acpi_thermal_state state;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_check");
 
 	if (!tz) {
 		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
-		return_VOID;
+		return;
 	}
 
 	state = tz->state;
 
 	result = acpi_thermal_get_temperature(tz);
 	if (result)
-		return_VOID;
+		return;
 
 	memset(&tz->state, 0, sizeof(tz->state));
 
@@ -795,7 +783,7 @@ static void acpi_thermal_check(void *data)
 		}
 	}
 
-	return_VOID;
+	return;
 }
 
 /* --------------------------------------------------------------------------
@@ -808,7 +796,6 @@ static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_state_seq_show");
 
 	if (!tz)
 		goto end;
@@ -831,7 +818,7 @@ static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
 	}
 
       end:
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file)
@@ -844,7 +831,6 @@ static int acpi_thermal_temp_seq_show(struct seq_file *seq, void *offset)
 	int result = 0;
 	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_temp_seq_show");
 
 	if (!tz)
 		goto end;
@@ -857,7 +843,7 @@ static int acpi_thermal_temp_seq_show(struct seq_file *seq, void *offset)
 		   KELVIN_TO_CELSIUS(tz->temperature));
 
       end:
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file)
@@ -871,7 +857,6 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 	int i = 0;
 	int j = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_trip_seq_show");
 
 	if (!tz)
 		goto end;
@@ -911,7 +896,7 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 	}
 
       end:
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file)
@@ -932,18 +917,17 @@ acpi_thermal_write_trip_points(struct file *file,
 	int *active;
 	int i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_write_trip_points");
 
 	limit_string = kmalloc(ACPI_THERMAL_MAX_LIMIT_STR_LEN, GFP_KERNEL);
 	if (!limit_string)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 
 	memset(limit_string, 0, ACPI_THERMAL_MAX_LIMIT_STR_LEN);
 
 	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE * sizeof(int), GFP_KERNEL);
 	if (!active) {
 		kfree(limit_string);
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	}
 
 	if (!tz || (count > ACPI_THERMAL_MAX_LIMIT_STR_LEN - 1)) {
@@ -980,14 +964,13 @@ acpi_thermal_write_trip_points(struct file *file,
       end:
 	kfree(active);
 	kfree(limit_string);
-	return_VALUE(count);
+	return count;
 }
 
 static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_cooling_seq_show");
 
 	if (!tz)
 		goto end;
@@ -1003,7 +986,7 @@ static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
 			   tz->cooling_mode ? "passive" : "active");
 
       end:
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file)
@@ -1022,16 +1005,15 @@ acpi_thermal_write_cooling_mode(struct file *file,
 	int result = 0;
 	char mode_string[12] = { '\0' };
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_write_cooling_mode");
 
 	if (!tz || (count > sizeof(mode_string) - 1))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (!tz->flags.cooling_mode)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	if (copy_from_user(mode_string, buffer, count))
-		return_VALUE(-EFAULT);
+		return -EFAULT;
 
 	mode_string[count] = '\0';
 
@@ -1039,18 +1021,17 @@ acpi_thermal_write_cooling_mode(struct file *file,
 					       simple_strtoul(mode_string, NULL,
 							      0));
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	acpi_thermal_check(tz);
 
-	return_VALUE(count);
+	return count;
 }
 
 static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_polling_seq_show");
 
 	if (!tz)
 		goto end;
@@ -1064,7 +1045,7 @@ static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
 		   (tz->polling_frequency / 10));
 
       end:
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file)
@@ -1084,13 +1065,12 @@ acpi_thermal_write_polling(struct file *file,
 	char polling_string[12] = { '\0' };
 	int seconds = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_write_polling");
 
 	if (!tz || (count > sizeof(polling_string) - 1))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (copy_from_user(polling_string, buffer, count))
-		return_VALUE(-EFAULT);
+		return -EFAULT;
 
 	polling_string[count] = '\0';
 
@@ -1098,24 +1078,23 @@ acpi_thermal_write_polling(struct file *file,
 
 	result = acpi_thermal_set_polling(tz, seconds);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	acpi_thermal_check(tz);
 
-	return_VALUE(count);
+	return count;
 }
 
 static int acpi_thermal_add_fs(struct acpi_device *device)
 {
 	struct proc_dir_entry *entry = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_add_fs");
 
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 						     acpi_thermal_dir);
 		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
+			return -ENODEV;
 		acpi_device_dir(device)->owner = THIS_MODULE;
 	}
 
@@ -1123,7 +1102,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_thermal_state_fops;
 		entry->data = acpi_driver_data(device);
@@ -1134,7 +1113,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_thermal_temp_fops;
 		entry->data = acpi_driver_data(device);
@@ -1146,7 +1125,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_thermal_trip_fops;
 		entry->data = acpi_driver_data(device);
@@ -1158,7 +1137,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_thermal_cooling_fops;
 		entry->data = acpi_driver_data(device);
@@ -1170,19 +1149,18 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_thermal_polling_fops;
 		entry->data = acpi_driver_data(device);
 		entry->owner = THIS_MODULE;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_remove_fs(struct acpi_device *device)
 {
-	ACPI_FUNCTION_TRACE("acpi_thermal_remove_fs");
 
 	if (acpi_device_dir(device)) {
 		remove_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
@@ -1199,7 +1177,7 @@ static int acpi_thermal_remove_fs(struct acpi_device *device)
 		acpi_device_dir(device) = NULL;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 /* --------------------------------------------------------------------------
@@ -1211,13 +1189,12 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 	struct acpi_thermal *tz = (struct acpi_thermal *)data;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_notify");
 
 	if (!tz)
-		return_VOID;
+		return;
 
 	if (acpi_bus_get_device(tz->handle, &device))
-		return_VOID;
+		return;
 
 	switch (event) {
 	case ACPI_THERMAL_NOTIFY_TEMPERATURE:
@@ -1239,27 +1216,26 @@ static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 		break;
 	}
 
-	return_VOID;
+	return;
 }
 
 static int acpi_thermal_get_info(struct acpi_thermal *tz)
 {
 	int result = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_info");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* Get temperature [_TMP] (required) */
 	result = acpi_thermal_get_temperature(tz);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	/* Get trip points [_CRT, _PSV, etc.] (required) */
 	result = acpi_thermal_get_trip_points(tz);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	/* Set the cooling mode [_SCP] to active cooling (default) */
 	result = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);
@@ -1299,7 +1275,7 @@ static int acpi_thermal_get_info(struct acpi_thermal *tz)
 	if (!result)
 		tz->flags.devices = 1;
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_add(struct acpi_device *device)
@@ -1308,14 +1284,13 @@ static int acpi_thermal_add(struct acpi_device *device)
 	acpi_status status = AE_OK;
 	struct acpi_thermal *tz = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_add");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	tz = kmalloc(sizeof(struct acpi_thermal), GFP_KERNEL);
 	if (!tz)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	memset(tz, 0, sizeof(struct acpi_thermal));
 
 	tz->handle = device->handle;
@@ -1354,7 +1329,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 		kfree(tz);
 	}
 
-	return_VALUE(result);
+	return result;
 }
 
 static int acpi_thermal_remove(struct acpi_device *device, int type)
@@ -1362,10 +1337,9 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	acpi_status status = AE_OK;
 	struct acpi_thermal *tz = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_remove");
 
 	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	tz = (struct acpi_thermal *)acpi_driver_data(device);
 
@@ -1396,7 +1370,7 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	acpi_thermal_remove_fs(device);
 
 	kfree(tz);
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_thermal_resume(struct acpi_device *device, int state)
@@ -1404,7 +1378,7 @@ static int acpi_thermal_resume(struct acpi_device *device, int state)
 	struct acpi_thermal *tz = NULL;
 
 	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	tz = (struct acpi_thermal *)acpi_driver_data(device);
 
@@ -1417,31 +1391,29 @@ static int __init acpi_thermal_init(void)
 {
 	int result = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_thermal_init");
 
 	acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, acpi_root_dir);
 	if (!acpi_thermal_dir)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	acpi_thermal_dir->owner = THIS_MODULE;
 
 	result = acpi_bus_register_driver(&acpi_thermal_driver);
 	if (result < 0) {
 		remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 static void __exit acpi_thermal_exit(void)
 {
-	ACPI_FUNCTION_TRACE("acpi_thermal_exit");
 
 	acpi_bus_unregister_driver(&acpi_thermal_driver);
 
 	remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
 
-	return_VOID;
+	return;
 }
 
 module_init(acpi_thermal_init);

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 6e9157a1d92d..1b9754919f72 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -698,7 +698,7 @@ static void acpi_thermal_check(void *data)
 	ACPI_FUNCTION_TRACE("acpi_thermal_check");
 
 	if (!tz) {
-		ACPI_ERROR((AE_INFO, "Invalid (NULL) context"));
+		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
 		return_VOID;
 	}
 

commit cece92969762b8ed7930d4e23008b76b06411dee
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:04:31 2006 -0400

    ACPI: un-export ACPI_WARNING() -- use printk(KERN_WARNING...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 44fffe16767e..6e9157a1d92d 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -384,7 +384,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 			tz->trips.passive.flags.valid = 0;
 
 		if (!tz->trips.passive.flags.valid)
-			ACPI_WARNING((AE_INFO, "Invalid passive threshold"));
+			printk(KERN_WARNING PREFIX "Invalid passive threshold\n");
 		else
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					  "Found passive threshold [%lu]\n",
@@ -469,7 +469,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 		return_VALUE(-EINVAL);
 
 	if (tz->temperature >= tz->trips.critical.temperature) {
-		ACPI_WARNING((AE_INFO, "Critical trip point"));
+		printk(KERN_WARNING PREFIX "Critical trip point\n");
 		tz->trips.critical.flags.enabled = 1;
 	} else if (tz->trips.critical.flags.enabled)
 		tz->trips.critical.flags.enabled = 0;
@@ -500,7 +500,7 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 		return_VALUE(-EINVAL);
 
 	if (tz->temperature >= tz->trips.hot.temperature) {
-		ACPI_WARNING((AE_INFO, "Hot trip point"));
+		printk(KERN_WARNING PREFIX "Hot trip point\n");
 		tz->trips.hot.flags.enabled = 1;
 	} else if (tz->trips.hot.flags.enabled)
 		tz->trips.hot.flags.enabled = 0;
@@ -640,10 +640,10 @@ static void acpi_thermal_active(struct acpi_thermal *tz)
 						       handles[j],
 						       ACPI_STATE_D0);
 				if (result) {
-					ACPI_WARNING((AE_INFO,
-						      "Unable to turn cooling device [%p] 'on'",
+					printk(KERN_WARNING PREFIX
+						      "Unable to turn cooling device [%p] 'on'\n",
 						      active->devices.
-						      handles[j]));
+						      handles[j]);
 					continue;
 				}
 				active->flags.enabled = 1;
@@ -665,9 +665,9 @@ static void acpi_thermal_active(struct acpi_thermal *tz)
 			result = acpi_bus_set_power(active->devices.handles[j],
 						    ACPI_STATE_D3);
 			if (result) {
-				ACPI_WARNING((AE_INFO,
-					      "Unable to turn cooling device [%p] 'off'",
-					      active->devices.handles[j]));
+				printk(KERN_WARNING PREFIX
+					      "Unable to turn cooling device [%p] 'off'\n",
+					      active->devices.handles[j]);
 				continue;
 			}
 			active->flags.enabled = 0;

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index e7fe3a14fdaf..44fffe16767e 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -325,7 +325,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 				       &tz->trips.critical.temperature);
 	if (ACPI_FAILURE(status)) {
 		tz->trips.critical.flags.valid = 0;
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No critical threshold\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "No critical threshold"));
 		return_VALUE(-ENODEV);
 	} else {
 		tz->trips.critical.flags.valid = 1;
@@ -384,8 +384,7 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 			tz->trips.passive.flags.valid = 0;
 
 		if (!tz->trips.passive.flags.valid)
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-					  "Invalid passive threshold\n"));
+			ACPI_WARNING((AE_INFO, "Invalid passive threshold"));
 		else
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					  "Found passive threshold [%lu]\n",
@@ -414,9 +413,8 @@ static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 					  "Found active threshold [%d]:[%lu]\n",
 					  i, tz->trips.active[i].temperature));
 		} else
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-					  "Invalid active threshold [%d]\n",
-					  i));
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Invalid active threshold [%d]", i));
 	}
 
 	return_VALUE(0);
@@ -471,7 +469,7 @@ static int acpi_thermal_critical(struct acpi_thermal *tz)
 		return_VALUE(-EINVAL);
 
 	if (tz->temperature >= tz->trips.critical.temperature) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Critical trip point\n"));
+		ACPI_WARNING((AE_INFO, "Critical trip point"));
 		tz->trips.critical.flags.enabled = 1;
 	} else if (tz->trips.critical.flags.enabled)
 		tz->trips.critical.flags.enabled = 0;
@@ -502,7 +500,7 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 		return_VALUE(-EINVAL);
 
 	if (tz->temperature >= tz->trips.hot.temperature) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Hot trip point\n"));
+		ACPI_WARNING((AE_INFO, "Hot trip point"));
 		tz->trips.hot.flags.enabled = 1;
 	} else if (tz->trips.hot.flags.enabled)
 		tz->trips.hot.flags.enabled = 0;
@@ -642,10 +640,10 @@ static void acpi_thermal_active(struct acpi_thermal *tz)
 						       handles[j],
 						       ACPI_STATE_D0);
 				if (result) {
-					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-							  "Unable to turn cooling device [%p] 'on'\n",
-							  active->devices.
-							  handles[j]));
+					ACPI_WARNING((AE_INFO,
+						      "Unable to turn cooling device [%p] 'on'",
+						      active->devices.
+						      handles[j]));
 					continue;
 				}
 				active->flags.enabled = 1;
@@ -667,9 +665,9 @@ static void acpi_thermal_active(struct acpi_thermal *tz)
 			result = acpi_bus_set_power(active->devices.handles[j],
 						    ACPI_STATE_D3);
 			if (result) {
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-						  "Unable to turn cooling device [%p] 'off'\n",
-						  active->devices.handles[j]));
+				ACPI_WARNING((AE_INFO,
+					      "Unable to turn cooling device [%p] 'off'",
+					      active->devices.handles[j]));
 				continue;
 			}
 			active->flags.enabled = 0;
@@ -700,7 +698,7 @@ static void acpi_thermal_check(void *data)
 	ACPI_FUNCTION_TRACE("acpi_thermal_check");
 
 	if (!tz) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		ACPI_ERROR((AE_INFO, "Invalid (NULL) context"));
 		return_VOID;
 	}
 
@@ -949,13 +947,11 @@ acpi_thermal_write_trip_points(struct file *file,
 	}
 
 	if (!tz || (count > ACPI_THERMAL_MAX_LIMIT_STR_LEN - 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
 		count = -EINVAL;
 		goto end;
 	}
 
 	if (copy_from_user(limit_string, buffer, count)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
 		count = -EFAULT;
 		goto end;
 	}
@@ -968,7 +964,6 @@ acpi_thermal_write_trip_points(struct file *file,
 		     &active[5], &active[6], &active[7], &active[8],
 		     &active[9]);
 	if (!(num >= 5 && num < (ACPI_THERMAL_MAX_ACTIVE + 3))) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
 		count = -EINVAL;
 		goto end;
 	}
@@ -1128,9 +1123,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_THERMAL_FILE_STATE));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_thermal_state_fops;
 		entry->data = acpi_driver_data(device);
@@ -1141,9 +1134,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_THERMAL_FILE_TEMPERATURE));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_thermal_temp_fops;
 		entry->data = acpi_driver_data(device);
@@ -1155,9 +1146,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_THERMAL_FILE_TRIP_POINTS));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_thermal_trip_fops;
 		entry->data = acpi_driver_data(device);
@@ -1169,9 +1158,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_THERMAL_FILE_COOLING_MODE));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_thermal_cooling_fops;
 		entry->data = acpi_driver_data(device);
@@ -1183,9 +1170,7 @@ static int acpi_thermal_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_THERMAL_FILE_POLLING_FREQ));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_thermal_polling_fops;
 		entry->data = acpi_driver_data(device);
@@ -1355,8 +1340,6 @@ static int acpi_thermal_add(struct acpi_device *device)
 					     ACPI_DEVICE_NOTIFY,
 					     acpi_thermal_notify, tz);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Error installing notify handler\n"));
 		result = -ENODEV;
 		goto end;
 	}
@@ -1398,9 +1381,6 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	status = acpi_remove_notify_handler(tz->handle,
 					    ACPI_DEVICE_NOTIFY,
 					    acpi_thermal_notify);
-	if (ACPI_FAILURE(status))
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Error removing notify handler\n"));
 
 	/* Terminate policy */
 	if (tz->trips.passive.flags.valid && tz->trips.passive.flags.enabled) {

commit 8f2ddb37e564a9616c05fa0d5652e0049072a730
Merge: 5b542e442276 74ce1468128e
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 21:36:11 2006 -0400

    Pull bugzilla-5000 into release branch

commit bf891bd65de65284f3964216fcde493dba5149db
Merge: de59e3aa6eda 9c576ff1bc9a
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 21:31:17 2006 -0400

    Pull trivial2 into release branch

commit 36a557d1f48669c57f59e37d9334400a29e4e53c
Merge: 4e8f10b7ccf1 6665bda76461
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 15:40:39 2006 -0400

    Pull trivial into release branch

commit b8d35192c55fb055792ff0641408eaaec7c88988
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri May 5 03:23:00 2006 -0400

    ACPI: execute Notify() handlers on new thread
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5534
    
    Thanks to Peter Wainwright for isolating the issue.
    Thanks to Andi Kleen and Bob Moore for feedback.
    Thanks to Richard Mace and others for testing.
    Updates by Konstantin Karasyov.
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 19f3ea48475e..fba9c230a84d 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -684,8 +684,7 @@ static void acpi_thermal_run(unsigned long data)
 {
 	struct acpi_thermal *tz = (struct acpi_thermal *)data;
 	if (!tz->zombie)
-		acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
-					    acpi_thermal_check, (void *)data);
+		acpi_os_execute(OSL_GPE_HANDLER, acpi_thermal_check, (void *)data);
 }
 
 static void acpi_thermal_check(void *data)

commit 74ce1468128e299fe6a85e7e78e528e45e72d6d9
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Mon May 8 08:32:00 2006 -0400

    ACPI: create acpi_thermal_resume()
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4364
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 19f3ea48475e..928dcf9e77c7 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -82,6 +82,7 @@ MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
 
 static int acpi_thermal_add(struct acpi_device *device);
 static int acpi_thermal_remove(struct acpi_device *device, int type);
+static int acpi_thermal_resume(struct acpi_device *device, int state);
 static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
@@ -103,6 +104,7 @@ static struct acpi_driver acpi_thermal_driver = {
 	.ops = {
 		.add = acpi_thermal_add,
 		.remove = acpi_thermal_remove,
+		.resume = acpi_thermal_resume,
 		},
 };
 
@@ -1416,6 +1418,20 @@ static int acpi_thermal_remove(struct acpi_device *device, int type)
 	return_VALUE(0);
 }
 
+static int acpi_thermal_resume(struct acpi_device *device, int state)
+{
+	struct acpi_thermal *tz = NULL;
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	tz = (struct acpi_thermal *)acpi_driver_data(device);
+
+	acpi_thermal_check(tz);
+
+	return AE_OK;
+}
+
 static int __init acpi_thermal_init(void)
 {
 	int result = 0;

commit 09047e75f69428dcfa977b326256085154068b65
Author: Vasily Averin <vvs@sw.ru>
Date:   Thu Apr 27 05:25:00 2006 -0400

    ACPI: fix memory leak in acpi_thermal_add() error path
    
    Signed-off-by: Vasily Averin <vvs@sw.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 19f3ea48475e..82389b178130 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1342,7 +1342,7 @@ static int acpi_thermal_add(struct acpi_device *device)
 
 	result = acpi_thermal_add_fs(device);
 	if (result)
-		return_VALUE(result);
+		goto end;
 
 	init_timer(&tz->timer);
 

commit fdc136ccd3332938e989439c025c363f8479f3e6
Author: Dave Jones <davej@redhat.com>
Date:   Wed Mar 8 22:12:00 2006 -0500

    [ACPI] fix possible acpi thermal leak in failure path
    
    Coverity: #601
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 19f3ea48475e..d0b44ce2ec5a 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -942,8 +942,10 @@ acpi_thermal_write_trip_points(struct file *file,
 	memset(limit_string, 0, ACPI_THERMAL_MAX_LIMIT_STR_LEN);
 
 	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE * sizeof(int), GFP_KERNEL);
-	if (!active)
+	if (!active) {
+		kfree(limit_string);
 		return_VALUE(-ENOMEM);
+	}
 
 	if (!tz || (count > ACPI_THERMAL_MAX_LIMIT_STR_LEN - 1)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));

commit 1cbf4c563c0eaaf11c552a88b374e213181c6ddd
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Sep 16 11:07:00 2004 -0400

    [ACPI] Allow return to active cooling mode once passive mode is entered
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3410
    https://bugzilla.novell.com/show_bug.cgi?id=131543
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
    Signed-off-by: Yu Luming <luming.yu@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index a24847c08f7f..19f3ea48475e 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -72,7 +72,7 @@
 #define _COMPONENT		ACPI_THERMAL_COMPONENT
 ACPI_MODULE_NAME("acpi_thermal")
 
-    MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);
 MODULE_LICENSE("GPL");
 
@@ -517,9 +517,9 @@ static int acpi_thermal_hot(struct acpi_thermal *tz)
 	return_VALUE(0);
 }
 
-static int acpi_thermal_passive(struct acpi_thermal *tz)
+static void acpi_thermal_passive(struct acpi_thermal *tz)
 {
-	int result = 0;
+	int result = 1;
 	struct acpi_thermal_passive *passive = NULL;
 	int trend = 0;
 	int i = 0;
@@ -527,7 +527,7 @@ static int acpi_thermal_passive(struct acpi_thermal *tz)
 	ACPI_FUNCTION_TRACE("acpi_thermal_passive");
 
 	if (!tz || !tz->trips.passive.flags.valid)
-		return_VALUE(-EINVAL);
+		return;
 
 	passive = &(tz->trips.passive);
 
@@ -547,7 +547,7 @@ static int acpi_thermal_passive(struct acpi_thermal *tz)
 				  trend, passive->tc1, tz->temperature,
 				  tz->last_temperature, passive->tc2,
 				  tz->temperature, passive->temperature));
-		tz->trips.passive.flags.enabled = 1;
+		passive->flags.enabled = 1;
 		/* Heating up? */
 		if (trend > 0)
 			for (i = 0; i < passive->devices.count; i++)
@@ -556,12 +556,32 @@ static int acpi_thermal_passive(struct acpi_thermal *tz)
 								 handles[i],
 								 ACPI_PROCESSOR_LIMIT_INCREMENT);
 		/* Cooling off? */
-		else if (trend < 0)
+		else if (trend < 0) {
 			for (i = 0; i < passive->devices.count; i++)
-				acpi_processor_set_thermal_limit(passive->
-								 devices.
-								 handles[i],
-								 ACPI_PROCESSOR_LIMIT_DECREMENT);
+				/*
+				 * assume that we are on highest
+				 * freq/lowest thrott and can leave
+				 * passive mode, even in error case
+				 */
+				if (!acpi_processor_set_thermal_limit
+				    (passive->devices.handles[i],
+				     ACPI_PROCESSOR_LIMIT_DECREMENT))
+					result = 0;
+			/*
+			 * Leave cooling mode, even if the temp might
+			 * higher than trip point This is because some
+			 * machines might have long thermal polling
+			 * frequencies (tsp) defined. We will fall back
+			 * into passive mode in next cycle (probably quicker)
+			 */
+			if (result) {
+				passive->flags.enabled = 0;
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+						  "Disabling passive cooling, still above threshold,"
+						  " but we are cooling down\n"));
+			}
+		}
+		return;
 	}
 
 	/*
@@ -571,23 +591,21 @@ static int acpi_thermal_passive(struct acpi_thermal *tz)
 	 * and avoid thrashing around the passive trip point.  Note that we
 	 * assume symmetry.
 	 */
-	else if (tz->trips.passive.flags.enabled) {
-		for (i = 0; i < passive->devices.count; i++)
-			result =
-			    acpi_processor_set_thermal_limit(passive->devices.
-							     handles[i],
-							     ACPI_PROCESSOR_LIMIT_DECREMENT);
-		if (result == 1) {
-			tz->trips.passive.flags.enabled = 0;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-					  "Disabling passive cooling (zone is cool)\n"));
-		}
+	if (!passive->flags.enabled)
+		return;
+	for (i = 0; i < passive->devices.count; i++)
+		if (!acpi_processor_set_thermal_limit
+		    (passive->devices.handles[i],
+		     ACPI_PROCESSOR_LIMIT_DECREMENT))
+			result = 0;
+	if (result) {
+		passive->flags.enabled = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Disabling passive cooling (zone is cool)\n"));
 	}
-
-	return_VALUE(0);
 }
 
-static int acpi_thermal_active(struct acpi_thermal *tz)
+static void acpi_thermal_active(struct acpi_thermal *tz)
 {
 	int result = 0;
 	struct acpi_thermal_active *active = NULL;
@@ -598,74 +616,66 @@ static int acpi_thermal_active(struct acpi_thermal *tz)
 	ACPI_FUNCTION_TRACE("acpi_thermal_active");
 
 	if (!tz)
-		return_VALUE(-EINVAL);
+		return;
 
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
-
 		active = &(tz->trips.active[i]);
 		if (!active || !active->flags.valid)
 			break;
-
-		/*
-		 * Above Threshold?
-		 * ----------------
-		 * If not already enabled, turn ON all cooling devices
-		 * associated with this active threshold.
-		 */
 		if (tz->temperature >= active->temperature) {
+			/*
+			 * Above Threshold?
+			 * ----------------
+			 * If not already enabled, turn ON all cooling devices
+			 * associated with this active threshold.
+			 */
 			if (active->temperature > maxtemp)
-				tz->state.active_index = i, maxtemp =
-				    active->temperature;
-			if (!active->flags.enabled) {
-				for (j = 0; j < active->devices.count; j++) {
-					result =
-					    acpi_bus_set_power(active->devices.
-							       handles[j],
-							       ACPI_STATE_D0);
-					if (result) {
-						ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-								  "Unable to turn cooling device [%p] 'on'\n",
-								  active->
-								  devices.
-								  handles[j]));
-						continue;
-					}
-					active->flags.enabled = 1;
-					ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-							  "Cooling device [%p] now 'on'\n",
-							  active->devices.
-							  handles[j]));
-				}
-			}
-		}
-		/*
-		 * Below Threshold?
-		 * ----------------
-		 * Turn OFF all cooling devices associated with this
-		 * threshold.
-		 */
-		else if (active->flags.enabled) {
+				tz->state.active_index = i;
+			maxtemp = active->temperature;
+			if (active->flags.enabled)
+				continue;
 			for (j = 0; j < active->devices.count; j++) {
 				result =
 				    acpi_bus_set_power(active->devices.
 						       handles[j],
-						       ACPI_STATE_D3);
+						       ACPI_STATE_D0);
 				if (result) {
 					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-							  "Unable to turn cooling device [%p] 'off'\n",
+							  "Unable to turn cooling device [%p] 'on'\n",
 							  active->devices.
 							  handles[j]));
 					continue;
 				}
-				active->flags.enabled = 0;
+				active->flags.enabled = 1;
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-						  "Cooling device [%p] now 'off'\n",
+						  "Cooling device [%p] now 'on'\n",
 						  active->devices.handles[j]));
 			}
+			continue;
+		}
+		if (!active->flags.enabled)
+			continue;
+		/*
+		 * Below Threshold?
+		 * ----------------
+		 * Turn OFF all cooling devices associated with this
+		 * threshold.
+		 */
+		for (j = 0; j < active->devices.count; j++) {
+			result = acpi_bus_set_power(active->devices.handles[j],
+						    ACPI_STATE_D3);
+			if (result) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+						  "Unable to turn cooling device [%p] 'off'\n",
+						  active->devices.handles[j]));
+				continue;
+			}
+			active->flags.enabled = 0;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Cooling device [%p] now 'off'\n",
+					  active->devices.handles[j]));
 		}
 	}
-
-	return_VALUE(0);
 }
 
 static void acpi_thermal_check(void *context);
@@ -744,15 +754,12 @@ static void acpi_thermal_check(void *data)
 	 * Again, separated from the above two to allow independent policy
 	 * decisions.
 	 */
-	if (tz->trips.critical.flags.enabled)
-		tz->state.critical = 1;
-	if (tz->trips.hot.flags.enabled)
-		tz->state.hot = 1;
-	if (tz->trips.passive.flags.enabled)
-		tz->state.passive = 1;
+	tz->state.critical = tz->trips.critical.flags.enabled;
+	tz->state.hot = tz->trips.hot.flags.enabled;
+	tz->state.passive = tz->trips.passive.flags.enabled;
+	tz->state.active = 0;
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)
-		if (tz->trips.active[i].flags.enabled)
-			tz->state.active = 1;
+		tz->state.active |= tz->trips.active[i].flags.enabled;
 
 	/*
 	 * Calculate Sleep Time

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 79c3a686bc44..a24847c08f7f 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -70,9 +70,9 @@
 #define CELSIUS_TO_KELVIN(t)	((t+273)*10)
 
 #define _COMPONENT		ACPI_THERMAL_COMPONENT
-ACPI_MODULE_NAME		("acpi_thermal")
+ACPI_MODULE_NAME("acpi_thermal")
 
-MODULE_AUTHOR("Paul Diefenbaugh");
+    MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);
 MODULE_LICENSE("GPL");
 
@@ -80,143 +80,145 @@ static int tzp;
 module_param(tzp, int, 0);
 MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
 
-
-static int acpi_thermal_add (struct acpi_device *device);
-static int acpi_thermal_remove (struct acpi_device *device, int type);
+static int acpi_thermal_add(struct acpi_device *device);
+static int acpi_thermal_remove(struct acpi_device *device, int type);
 static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_trip_points (struct file*,const char __user *,size_t,loff_t *);
+static ssize_t acpi_thermal_write_trip_points(struct file *,
+					      const char __user *, size_t,
+					      loff_t *);
 static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_cooling_mode (struct file*,const char __user *,size_t,loff_t *);
+static ssize_t acpi_thermal_write_cooling_mode(struct file *,
+					       const char __user *, size_t,
+					       loff_t *);
 static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file);
-static ssize_t acpi_thermal_write_polling(struct file*,const char __user *,size_t,loff_t *);
+static ssize_t acpi_thermal_write_polling(struct file *, const char __user *,
+					  size_t, loff_t *);
 
 static struct acpi_driver acpi_thermal_driver = {
-	.name =		ACPI_THERMAL_DRIVER_NAME,
-	.class =	ACPI_THERMAL_CLASS,
-	.ids =		ACPI_THERMAL_HID,
-	.ops =		{
-				.add =		acpi_thermal_add,
-				.remove =	acpi_thermal_remove,
-			},
+	.name = ACPI_THERMAL_DRIVER_NAME,
+	.class = ACPI_THERMAL_CLASS,
+	.ids = ACPI_THERMAL_HID,
+	.ops = {
+		.add = acpi_thermal_add,
+		.remove = acpi_thermal_remove,
+		},
 };
 
 struct acpi_thermal_state {
-	u8			critical:1;
-	u8			hot:1;
-	u8			passive:1;
-	u8			active:1;
-	u8			reserved:4;
-	int			active_index;
+	u8 critical:1;
+	u8 hot:1;
+	u8 passive:1;
+	u8 active:1;
+	u8 reserved:4;
+	int active_index;
 };
 
 struct acpi_thermal_state_flags {
-	u8			valid:1;
-	u8			enabled:1;
-	u8			reserved:6;
+	u8 valid:1;
+	u8 enabled:1;
+	u8 reserved:6;
 };
 
 struct acpi_thermal_critical {
 	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
+	unsigned long temperature;
 };
 
 struct acpi_thermal_hot {
 	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
+	unsigned long temperature;
 };
 
 struct acpi_thermal_passive {
 	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
-	unsigned long		tc1;
-	unsigned long		tc2;
-	unsigned long		tsp;
-	struct acpi_handle_list	devices;
+	unsigned long temperature;
+	unsigned long tc1;
+	unsigned long tc2;
+	unsigned long tsp;
+	struct acpi_handle_list devices;
 };
 
 struct acpi_thermal_active {
 	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
-	struct acpi_handle_list	devices;
+	unsigned long temperature;
+	struct acpi_handle_list devices;
 };
 
 struct acpi_thermal_trips {
 	struct acpi_thermal_critical critical;
-	struct acpi_thermal_hot	hot;
+	struct acpi_thermal_hot hot;
 	struct acpi_thermal_passive passive;
 	struct acpi_thermal_active active[ACPI_THERMAL_MAX_ACTIVE];
 };
 
 struct acpi_thermal_flags {
-	u8			cooling_mode:1;		/* _SCP */
-	u8			devices:1;		/* _TZD */
-	u8			reserved:6;
+	u8 cooling_mode:1;	/* _SCP */
+	u8 devices:1;		/* _TZD */
+	u8 reserved:6;
 };
 
 struct acpi_thermal {
-	acpi_handle		handle;
-	acpi_bus_id		name;
-	unsigned long		temperature;
-	unsigned long		last_temperature;
-	unsigned long		polling_frequency;
-	u8			cooling_mode;
-	volatile u8		zombie;
+	acpi_handle handle;
+	acpi_bus_id name;
+	unsigned long temperature;
+	unsigned long last_temperature;
+	unsigned long polling_frequency;
+	u8 cooling_mode;
+	volatile u8 zombie;
 	struct acpi_thermal_flags flags;
 	struct acpi_thermal_state state;
 	struct acpi_thermal_trips trips;
-	struct acpi_handle_list	devices;
-	struct timer_list	timer;
+	struct acpi_handle_list devices;
+	struct timer_list timer;
 };
 
 static struct file_operations acpi_thermal_state_fops = {
-	.open		= acpi_thermal_state_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_thermal_state_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 static struct file_operations acpi_thermal_temp_fops = {
-	.open		= acpi_thermal_temp_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_thermal_temp_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 static struct file_operations acpi_thermal_trip_fops = {
-	.open		= acpi_thermal_trip_open_fs,
-	.read		= seq_read,
-	.write		= acpi_thermal_write_trip_points,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_thermal_trip_open_fs,
+	.read = seq_read,
+	.write = acpi_thermal_write_trip_points,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 static struct file_operations acpi_thermal_cooling_fops = {
-	.open		= acpi_thermal_cooling_open_fs,
-	.read		= seq_read,
-	.write		= acpi_thermal_write_cooling_mode,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_thermal_cooling_open_fs,
+	.read = seq_read,
+	.write = acpi_thermal_write_cooling_mode,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 static struct file_operations acpi_thermal_polling_fops = {
-	.open		= acpi_thermal_polling_open_fs,
-	.read		= seq_read,
-	.write		= acpi_thermal_write_polling,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_thermal_polling_open_fs,
+	.read = seq_read,
+	.write = acpi_thermal_write_polling,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 /* --------------------------------------------------------------------------
                              Thermal Zone Management
    -------------------------------------------------------------------------- */
 
-static int
-acpi_thermal_get_temperature (
-	struct acpi_thermal *tz)
+static int acpi_thermal_get_temperature(struct acpi_thermal *tz)
 {
-	acpi_status		status = AE_OK;
+	acpi_status status = AE_OK;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_get_temperature");
 
@@ -225,41 +227,39 @@ acpi_thermal_get_temperature (
 
 	tz->last_temperature = tz->temperature;
 
-	status = acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
+	status =
+	    acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
 	if (ACPI_FAILURE(status))
 		return_VALUE(-ENODEV);
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n", tz->temperature));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n",
+			  tz->temperature));
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_get_polling_frequency (
-	struct acpi_thermal	*tz)
+static int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)
 {
-	acpi_status		status = AE_OK;
+	acpi_status status = AE_OK;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_get_polling_frequency");
 
 	if (!tz)
 		return_VALUE(-EINVAL);
 
-	status = acpi_evaluate_integer(tz->handle, "_TZP", NULL, &tz->polling_frequency);
+	status =
+	    acpi_evaluate_integer(tz->handle, "_TZP", NULL,
+				  &tz->polling_frequency);
 	if (ACPI_FAILURE(status))
 		return_VALUE(-ENODEV);
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n", tz->polling_frequency));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n",
+			  tz->polling_frequency));
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_set_polling (
-	struct acpi_thermal	*tz,
-	int			seconds)
+static int acpi_thermal_set_polling(struct acpi_thermal *tz, int seconds)
 {
 	ACPI_FUNCTION_TRACE("acpi_thermal_set_polling");
 
@@ -268,21 +268,19 @@ acpi_thermal_set_polling (
 
 	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency set to %lu seconds\n", tz->polling_frequency));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Polling frequency set to %lu seconds\n",
+			  tz->polling_frequency));
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_set_cooling_mode (
-	struct acpi_thermal	*tz,
-	int			mode)
+static int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)
 {
-	acpi_status		status = AE_OK;
-	union acpi_object	arg0 = {ACPI_TYPE_INTEGER};
-	struct acpi_object_list	arg_list = {1, &arg0};
-	acpi_handle		handle = NULL;
+	acpi_status status = AE_OK;
+	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &arg0 };
+	acpi_handle handle = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_set_cooling_mode");
 
@@ -303,19 +301,16 @@ acpi_thermal_set_cooling_mode (
 
 	tz->cooling_mode = mode;
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n", 
-		mode?"passive":"active"));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n",
+			  mode ? "passive" : "active"));
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_get_trip_points (
-	struct acpi_thermal *tz)
+static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
 {
-	acpi_status		status = AE_OK;
-	int			i = 0;
+	acpi_status status = AE_OK;
+	int i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_get_trip_points");
 
@@ -324,111 +319,128 @@ acpi_thermal_get_trip_points (
 
 	/* Critical Shutdown (required) */
 
-	status = acpi_evaluate_integer(tz->handle, "_CRT", NULL, 
-		&tz->trips.critical.temperature);
+	status = acpi_evaluate_integer(tz->handle, "_CRT", NULL,
+				       &tz->trips.critical.temperature);
 	if (ACPI_FAILURE(status)) {
 		tz->trips.critical.flags.valid = 0;
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No critical threshold\n"));
 		return_VALUE(-ENODEV);
-	}
-	else {
+	} else {
 		tz->trips.critical.flags.valid = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found critical threshold [%lu]\n", tz->trips.critical.temperature));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Found critical threshold [%lu]\n",
+				  tz->trips.critical.temperature));
 	}
 
 	/* Critical Sleep (optional) */
 
-	status = acpi_evaluate_integer(tz->handle, "_HOT", NULL, &tz->trips.hot.temperature);
+	status =
+	    acpi_evaluate_integer(tz->handle, "_HOT", NULL,
+				  &tz->trips.hot.temperature);
 	if (ACPI_FAILURE(status)) {
 		tz->trips.hot.flags.valid = 0;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No hot threshold\n"));
-	}
-	else {
+	} else {
 		tz->trips.hot.flags.valid = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%lu]\n", tz->trips.hot.temperature));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%lu]\n",
+				  tz->trips.hot.temperature));
 	}
 
 	/* Passive: Processors (optional) */
 
-	status = acpi_evaluate_integer(tz->handle, "_PSV", NULL, &tz->trips.passive.temperature);
+	status =
+	    acpi_evaluate_integer(tz->handle, "_PSV", NULL,
+				  &tz->trips.passive.temperature);
 	if (ACPI_FAILURE(status)) {
 		tz->trips.passive.flags.valid = 0;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No passive threshold\n"));
-	}
-	else {
+	} else {
 		tz->trips.passive.flags.valid = 1;
 
-		status = acpi_evaluate_integer(tz->handle, "_TC1", NULL, &tz->trips.passive.tc1);
+		status =
+		    acpi_evaluate_integer(tz->handle, "_TC1", NULL,
+					  &tz->trips.passive.tc1);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 
-		status = acpi_evaluate_integer(tz->handle, "_TC2", NULL, &tz->trips.passive.tc2);
+		status =
+		    acpi_evaluate_integer(tz->handle, "_TC2", NULL,
+					  &tz->trips.passive.tc2);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 
-		status = acpi_evaluate_integer(tz->handle, "_TSP", NULL, &tz->trips.passive.tsp);
+		status =
+		    acpi_evaluate_integer(tz->handle, "_TSP", NULL,
+					  &tz->trips.passive.tsp);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 
-		status = acpi_evaluate_reference(tz->handle, "_PSL", NULL, &tz->trips.passive.devices);
+		status =
+		    acpi_evaluate_reference(tz->handle, "_PSL", NULL,
+					    &tz->trips.passive.devices);
 		if (ACPI_FAILURE(status))
 			tz->trips.passive.flags.valid = 0;
 
 		if (!tz->trips.passive.flags.valid)
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid passive threshold\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+					  "Invalid passive threshold\n"));
 		else
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found passive threshold [%lu]\n", tz->trips.passive.temperature));
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Found passive threshold [%lu]\n",
+					  tz->trips.passive.temperature));
 	}
 
 	/* Active: Fans, etc. (optional) */
 
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
 
-		char name[5] = {'_','A','C',('0'+i),'\0'};
+		char name[5] = { '_', 'A', 'C', ('0' + i), '\0' };
 
-		status = acpi_evaluate_integer(tz->handle, name, NULL, &tz->trips.active[i].temperature);
+		status =
+		    acpi_evaluate_integer(tz->handle, name, NULL,
+					  &tz->trips.active[i].temperature);
 		if (ACPI_FAILURE(status))
 			break;
 
 		name[2] = 'L';
-		status = acpi_evaluate_reference(tz->handle, name, NULL, &tz->trips.active[i].devices);
+		status =
+		    acpi_evaluate_reference(tz->handle, name, NULL,
+					    &tz->trips.active[i].devices);
 		if (ACPI_SUCCESS(status)) {
 			tz->trips.active[i].flags.valid = 1;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found active threshold [%d]:[%lu]\n", i, tz->trips.active[i].temperature));
-		}
-		else
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid active threshold [%d]\n", i));
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Found active threshold [%d]:[%lu]\n",
+					  i, tz->trips.active[i].temperature));
+		} else
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Invalid active threshold [%d]\n",
+					  i));
 	}
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_get_devices (
-	struct acpi_thermal	*tz)
+static int acpi_thermal_get_devices(struct acpi_thermal *tz)
 {
-	acpi_status		status = AE_OK;
+	acpi_status status = AE_OK;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_get_devices");
 
 	if (!tz)
 		return_VALUE(-EINVAL);
 
-	status = acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
+	status =
+	    acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
 	if (ACPI_FAILURE(status))
 		return_VALUE(-ENODEV);
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_call_usermode (
-	char			*path)
+static int acpi_thermal_call_usermode(char *path)
 {
-	char			*argv[2] = {NULL, NULL};
-	char			*envp[3] = {NULL, NULL, NULL};
+	char *argv[2] = { NULL, NULL };
+	char *envp[3] = { NULL, NULL, NULL };
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_call_usermode");
 
@@ -440,19 +452,16 @@ acpi_thermal_call_usermode (
 	/* minimal command environment */
 	envp[0] = "HOME=/";
 	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
-	
+
 	call_usermodehelper(argv[0], argv, envp, 0);
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_critical (
-	struct acpi_thermal	*tz)
+static int acpi_thermal_critical(struct acpi_thermal *tz)
 {
-	int			result = 0;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_critical");
 
@@ -462,29 +471,28 @@ acpi_thermal_critical (
 	if (tz->temperature >= tz->trips.critical.temperature) {
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Critical trip point\n"));
 		tz->trips.critical.flags.enabled = 1;
-	}
-	else if (tz->trips.critical.flags.enabled)
+	} else if (tz->trips.critical.flags.enabled)
 		tz->trips.critical.flags.enabled = 0;
 
 	result = acpi_bus_get_device(tz->handle, &device);
 	if (result)
 		return_VALUE(result);
 
-	printk(KERN_EMERG "Critical temperature reached (%ld C), shutting down.\n", KELVIN_TO_CELSIUS(tz->temperature));
-	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_CRITICAL, tz->trips.critical.flags.enabled);
+	printk(KERN_EMERG
+	       "Critical temperature reached (%ld C), shutting down.\n",
+	       KELVIN_TO_CELSIUS(tz->temperature));
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_CRITICAL,
+				tz->trips.critical.flags.enabled);
 
 	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_hot (
-	struct acpi_thermal	*tz)
+static int acpi_thermal_hot(struct acpi_thermal *tz)
 {
-	int			result = 0;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_hot");
 
@@ -494,30 +502,27 @@ acpi_thermal_hot (
 	if (tz->temperature >= tz->trips.hot.temperature) {
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Hot trip point\n"));
 		tz->trips.hot.flags.enabled = 1;
-	}
-	else if (tz->trips.hot.flags.enabled)
+	} else if (tz->trips.hot.flags.enabled)
 		tz->trips.hot.flags.enabled = 0;
 
 	result = acpi_bus_get_device(tz->handle, &device);
 	if (result)
 		return_VALUE(result);
 
-	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT, tz->trips.hot.flags.enabled);
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT,
+				tz->trips.hot.flags.enabled);
 
 	/* TBD: Call user-mode "sleep(S4)" function */
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_passive (
-	struct acpi_thermal	*tz)
+static int acpi_thermal_passive(struct acpi_thermal *tz)
 {
-	int			result = 0;
+	int result = 0;
 	struct acpi_thermal_passive *passive = NULL;
-	int			trend = 0;
-	int			i = 0;
+	int trend = 0;
+	int i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_passive");
 
@@ -534,25 +539,29 @@ acpi_thermal_passive (
 	 * accordingly.  Note that we assume symmetry.
 	 */
 	if (tz->temperature >= passive->temperature) {
-		trend = (passive->tc1 * (tz->temperature - tz->last_temperature)) + (passive->tc2 * (tz->temperature - passive->temperature));
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"trend[%d]=(tc1[%lu]*(tmp[%lu]-last[%lu]))+(tc2[%lu]*(tmp[%lu]-psv[%lu]))\n", 
-			trend, passive->tc1, tz->temperature, 
-			tz->last_temperature, passive->tc2, 
-			tz->temperature, passive->temperature));
+		trend =
+		    (passive->tc1 * (tz->temperature - tz->last_temperature)) +
+		    (passive->tc2 * (tz->temperature - passive->temperature));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "trend[%d]=(tc1[%lu]*(tmp[%lu]-last[%lu]))+(tc2[%lu]*(tmp[%lu]-psv[%lu]))\n",
+				  trend, passive->tc1, tz->temperature,
+				  tz->last_temperature, passive->tc2,
+				  tz->temperature, passive->temperature));
 		tz->trips.passive.flags.enabled = 1;
 		/* Heating up? */
 		if (trend > 0)
-			for (i=0; i<passive->devices.count; i++)
-				acpi_processor_set_thermal_limit(
-					passive->devices.handles[i], 
-					ACPI_PROCESSOR_LIMIT_INCREMENT);
+			for (i = 0; i < passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(passive->
+								 devices.
+								 handles[i],
+								 ACPI_PROCESSOR_LIMIT_INCREMENT);
 		/* Cooling off? */
 		else if (trend < 0)
-			for (i=0; i<passive->devices.count; i++)
-				acpi_processor_set_thermal_limit(
-					passive->devices.handles[i], 
-					ACPI_PROCESSOR_LIMIT_DECREMENT);
+			for (i = 0; i < passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(passive->
+								 devices.
+								 handles[i],
+								 ACPI_PROCESSOR_LIMIT_DECREMENT);
 	}
 
 	/*
@@ -563,37 +572,35 @@ acpi_thermal_passive (
 	 * assume symmetry.
 	 */
 	else if (tz->trips.passive.flags.enabled) {
-		for (i=0; i<passive->devices.count; i++)
-			result = acpi_processor_set_thermal_limit(
-				passive->devices.handles[i], 
-				ACPI_PROCESSOR_LIMIT_DECREMENT);
+		for (i = 0; i < passive->devices.count; i++)
+			result =
+			    acpi_processor_set_thermal_limit(passive->devices.
+							     handles[i],
+							     ACPI_PROCESSOR_LIMIT_DECREMENT);
 		if (result == 1) {
 			tz->trips.passive.flags.enabled = 0;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-				"Disabling passive cooling (zone is cool)\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Disabling passive cooling (zone is cool)\n"));
 		}
 	}
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_active (
-	struct acpi_thermal	*tz)
+static int acpi_thermal_active(struct acpi_thermal *tz)
 {
-	int			result = 0;
+	int result = 0;
 	struct acpi_thermal_active *active = NULL;
-	int                     i = 0;
-	int			j = 0;
-	unsigned long		maxtemp = 0;
+	int i = 0;
+	int j = 0;
+	unsigned long maxtemp = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_active");
 
 	if (!tz)
 		return_VALUE(-EINVAL);
 
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
 
 		active = &(tz->trips.active[i]);
 		if (!active || !active->flags.valid)
@@ -607,16 +614,27 @@ acpi_thermal_active (
 		 */
 		if (tz->temperature >= active->temperature) {
 			if (active->temperature > maxtemp)
-				tz->state.active_index = i, maxtemp = active->temperature;
+				tz->state.active_index = i, maxtemp =
+				    active->temperature;
 			if (!active->flags.enabled) {
 				for (j = 0; j < active->devices.count; j++) {
-					result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D0);
+					result =
+					    acpi_bus_set_power(active->devices.
+							       handles[j],
+							       ACPI_STATE_D0);
 					if (result) {
-						ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'on'\n", active->devices.handles[j]));
+						ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+								  "Unable to turn cooling device [%p] 'on'\n",
+								  active->
+								  devices.
+								  handles[j]));
 						continue;
 					}
 					active->flags.enabled = 1;
-					ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'on'\n", active->devices.handles[j]));
+					ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+							  "Cooling device [%p] now 'on'\n",
+							  active->devices.
+							  handles[j]));
 				}
 			}
 		}
@@ -628,13 +646,21 @@ acpi_thermal_active (
 		 */
 		else if (active->flags.enabled) {
 			for (j = 0; j < active->devices.count; j++) {
-				result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D3);
+				result =
+				    acpi_bus_set_power(active->devices.
+						       handles[j],
+						       ACPI_STATE_D3);
 				if (result) {
-					ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'off'\n", active->devices.handles[j]));
+					ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+							  "Unable to turn cooling device [%p] 'off'\n",
+							  active->devices.
+							  handles[j]));
 					continue;
 				}
 				active->flags.enabled = 0;
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'off'\n", active->devices.handles[j]));
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+						  "Cooling device [%p] now 'off'\n",
+						  active->devices.handles[j]));
 			}
 		}
 	}
@@ -642,28 +668,22 @@ acpi_thermal_active (
 	return_VALUE(0);
 }
 
+static void acpi_thermal_check(void *context);
 
-static void acpi_thermal_check (void *context);
-
-static void
-acpi_thermal_run (
-	unsigned long		data)
+static void acpi_thermal_run(unsigned long data)
 {
 	struct acpi_thermal *tz = (struct acpi_thermal *)data;
 	if (!tz->zombie)
-		acpi_os_queue_for_execution(OSD_PRIORITY_GPE,  
-			acpi_thermal_check, (void *) data);
+		acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
+					    acpi_thermal_check, (void *)data);
 }
 
-
-static void
-acpi_thermal_check (
-	void                    *data)
+static void acpi_thermal_check(void *data)
 {
-	int			result = 0;
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	unsigned long		sleep_time = 0;
-	int			i = 0;
+	int result = 0;
+	struct acpi_thermal *tz = (struct acpi_thermal *)data;
+	unsigned long sleep_time = 0;
+	int i = 0;
 	struct acpi_thermal_state state;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_check");
@@ -678,9 +698,9 @@ acpi_thermal_check (
 	result = acpi_thermal_get_temperature(tz);
 	if (result)
 		return_VOID;
-	
+
 	memset(&tz->state, 0, sizeof(tz->state));
-	
+
 	/*
 	 * Check Trip Points
 	 * -----------------
@@ -690,14 +710,18 @@ acpi_thermal_check (
 	 * individual policy decides when it is exited (e.g. hysteresis).
 	 */
 	if (tz->trips.critical.flags.valid)
-		state.critical |= (tz->temperature >= tz->trips.critical.temperature);
+		state.critical |=
+		    (tz->temperature >= tz->trips.critical.temperature);
 	if (tz->trips.hot.flags.valid)
 		state.hot |= (tz->temperature >= tz->trips.hot.temperature);
 	if (tz->trips.passive.flags.valid)
-		state.passive |= (tz->temperature >= tz->trips.passive.temperature);
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+		state.passive |=
+		    (tz->temperature >= tz->trips.passive.temperature);
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)
 		if (tz->trips.active[i].flags.valid)
-			state.active |= (tz->temperature >= tz->trips.active[i].temperature);
+			state.active |=
+			    (tz->temperature >=
+			     tz->trips.active[i].temperature);
 
 	/*
 	 * Invoke Policy
@@ -726,7 +750,7 @@ acpi_thermal_check (
 		tz->state.hot = 1;
 	if (tz->trips.passive.flags.enabled)
 		tz->state.passive = 1;
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)
 		if (tz->trips.active[i].flags.enabled)
 			tz->state.active = 1;
 
@@ -744,8 +768,8 @@ acpi_thermal_check (
 	else if (tz->polling_frequency > 0)
 		sleep_time = tz->polling_frequency * 100;
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n", 
-		tz->name, tz->temperature, sleep_time));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n",
+			  tz->name, tz->temperature, sleep_time));
 
 	/*
 	 * Schedule Next Poll
@@ -754,12 +778,11 @@ acpi_thermal_check (
 	if (!sleep_time) {
 		if (timer_pending(&(tz->timer)))
 			del_timer(&(tz->timer));
-	}
-	else {
+	} else {
 		if (timer_pending(&(tz->timer)))
 			mod_timer(&(tz->timer), (HZ * sleep_time) / 1000);
 		else {
-			tz->timer.data = (unsigned long) tz;
+			tz->timer.data = (unsigned long)tz;
 			tz->timer.function = acpi_thermal_run;
 			tz->timer.expires = jiffies + (HZ * sleep_time) / 1000;
 			add_timer(&(tz->timer));
@@ -769,16 +792,15 @@ acpi_thermal_check (
 	return_VOID;
 }
 
-
 /* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
 
-static struct proc_dir_entry	*acpi_thermal_dir;
+static struct proc_dir_entry *acpi_thermal_dir;
 
 static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_state_seq_show");
 
@@ -787,7 +809,8 @@ static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
 
 	seq_puts(seq, "state:                   ");
 
-	if (!tz->state.critical && !tz->state.hot && !tz->state.passive && !tz->state.active)
+	if (!tz->state.critical && !tz->state.hot && !tz->state.passive
+	    && !tz->state.active)
 		seq_puts(seq, "ok\n");
 	else {
 		if (tz->state.critical)
@@ -801,7 +824,7 @@ static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
 		seq_puts(seq, "\n");
 	}
 
-end:
+      end:
 	return_VALUE(0);
 }
 
@@ -810,11 +833,10 @@ static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_thermal_state_seq_show, PDE(inode)->data);
 }
 
-
 static int acpi_thermal_temp_seq_show(struct seq_file *seq, void *offset)
 {
-	int			result = 0;
-	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+	int result = 0;
+	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_temp_seq_show");
 
@@ -825,10 +847,10 @@ static int acpi_thermal_temp_seq_show(struct seq_file *seq, void *offset)
 	if (result)
 		goto end;
 
-	seq_printf(seq, "temperature:             %ld C\n", 
-		KELVIN_TO_CELSIUS(tz->temperature));
+	seq_printf(seq, "temperature:             %ld C\n",
+		   KELVIN_TO_CELSIUS(tz->temperature));
 
-end:
+      end:
 	return_VALUE(0);
 }
 
@@ -837,12 +859,11 @@ static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_thermal_temp_seq_show, PDE(inode)->data);
 }
 
-
 static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
-	int			i = 0;
-	int			j = 0;
+	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
+	int i = 0;
+	int j = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_trip_seq_show");
 
@@ -851,21 +872,22 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 
 	if (tz->trips.critical.flags.valid)
 		seq_printf(seq, "critical (S5):           %ld C\n",
-			KELVIN_TO_CELSIUS(tz->trips.critical.temperature));
+			   KELVIN_TO_CELSIUS(tz->trips.critical.temperature));
 
 	if (tz->trips.hot.flags.valid)
 		seq_printf(seq, "hot (S4):                %ld C\n",
-			KELVIN_TO_CELSIUS(tz->trips.hot.temperature));
+			   KELVIN_TO_CELSIUS(tz->trips.hot.temperature));
 
 	if (tz->trips.passive.flags.valid) {
-		seq_printf(seq, "passive:                 %ld C: tc1=%lu tc2=%lu tsp=%lu devices=",
-			KELVIN_TO_CELSIUS(tz->trips.passive.temperature),
-			tz->trips.passive.tc1,
-			tz->trips.passive.tc2, 
-			tz->trips.passive.tsp);
-		for (j=0; j<tz->trips.passive.devices.count; j++) {
-
-			seq_printf(seq, "0x%p ", tz->trips.passive.devices.handles[j]);
+		seq_printf(seq,
+			   "passive:                 %ld C: tc1=%lu tc2=%lu tsp=%lu devices=",
+			   KELVIN_TO_CELSIUS(tz->trips.passive.temperature),
+			   tz->trips.passive.tc1, tz->trips.passive.tc2,
+			   tz->trips.passive.tsp);
+		for (j = 0; j < tz->trips.passive.devices.count; j++) {
+
+			seq_printf(seq, "0x%p ",
+				   tz->trips.passive.devices.handles[j]);
 		}
 		seq_puts(seq, "\n");
 	}
@@ -874,14 +896,15 @@ static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
 		if (!(tz->trips.active[i].flags.valid))
 			break;
 		seq_printf(seq, "active[%d]:               %ld C: devices=",
-			i, KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
-		for (j = 0; j < tz->trips.active[i].devices.count; j++) 
+			   i,
+			   KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
+		for (j = 0; j < tz->trips.active[i].devices.count; j++)
 			seq_printf(seq, "0x%p ",
-				tz->trips.active[i].devices.handles[j]);
+				   tz->trips.active[i].devices.handles[j]);
 		seq_puts(seq, "\n");
 	}
 
-end:
+      end:
 	return_VALUE(0);
 }
 
@@ -891,30 +914,28 @@ static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file)
 }
 
 static ssize_t
-acpi_thermal_write_trip_points (
-        struct file		*file,
-        const char		__user *buffer,
-        size_t			count,
-        loff_t			*ppos)
+acpi_thermal_write_trip_points(struct file *file,
+			       const char __user * buffer,
+			       size_t count, loff_t * ppos)
 {
-	struct seq_file		*m = (struct seq_file *)file->private_data;
-	struct acpi_thermal	*tz = (struct acpi_thermal *)m->private;
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct acpi_thermal *tz = (struct acpi_thermal *)m->private;
 
-	char			*limit_string; 
-	int			num, critical, hot, passive;
-	int			*active; 
-	int			i = 0;
+	char *limit_string;
+	int num, critical, hot, passive;
+	int *active;
+	int i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_write_trip_points");
 
 	limit_string = kmalloc(ACPI_THERMAL_MAX_LIMIT_STR_LEN, GFP_KERNEL);
-	if(!limit_string)
+	if (!limit_string)
 		return_VALUE(-ENOMEM);
 
 	memset(limit_string, 0, ACPI_THERMAL_MAX_LIMIT_STR_LEN);
 
-	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE *sizeof(int), GFP_KERNEL);
-	if(!active)
+	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE * sizeof(int), GFP_KERNEL);
+	if (!active)
 		return_VALUE(-ENOMEM);
 
 	if (!tz || (count > ACPI_THERMAL_MAX_LIMIT_STR_LEN - 1)) {
@@ -922,20 +943,21 @@ acpi_thermal_write_trip_points (
 		count = -EINVAL;
 		goto end;
 	}
-	
+
 	if (copy_from_user(limit_string, buffer, count)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
 		count = -EFAULT;
 		goto end;
 	}
-	
+
 	limit_string[count] = '\0';
 
 	num = sscanf(limit_string, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
-				&critical, &hot, &passive,
-				&active[0], &active[1], &active[2], &active[3], &active[4],
-				&active[5], &active[6], &active[7], &active[8], &active[9]);
-	if(!(num >=5 && num < (ACPI_THERMAL_MAX_ACTIVE + 3))) {
+		     &critical, &hot, &passive,
+		     &active[0], &active[1], &active[2], &active[3], &active[4],
+		     &active[5], &active[6], &active[7], &active[8],
+		     &active[9]);
+	if (!(num >= 5 && num < (ACPI_THERMAL_MAX_ACTIVE + 3))) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
 		count = -EINVAL;
 		goto end;
@@ -949,17 +971,16 @@ acpi_thermal_write_trip_points (
 			break;
 		tz->trips.active[i].temperature = CELSIUS_TO_KELVIN(active[i]);
 	}
-	
-end:
+
+      end:
 	kfree(active);
 	kfree(limit_string);
 	return_VALUE(count);
 }
 
-
 static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_cooling_seq_show");
 
@@ -970,33 +991,31 @@ static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
 		seq_puts(seq, "<setting not supported>\n");
 	}
 
-	if ( tz->cooling_mode == ACPI_THERMAL_MODE_CRITICAL )
+	if (tz->cooling_mode == ACPI_THERMAL_MODE_CRITICAL)
 		seq_printf(seq, "cooling mode:	critical\n");
 	else
 		seq_printf(seq, "cooling mode:	%s\n",
-			tz->cooling_mode?"passive":"active");
+			   tz->cooling_mode ? "passive" : "active");
 
-end:
+      end:
 	return_VALUE(0);
 }
 
 static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file)
 {
 	return single_open(file, acpi_thermal_cooling_seq_show,
-							PDE(inode)->data);
+			   PDE(inode)->data);
 }
 
 static ssize_t
-acpi_thermal_write_cooling_mode (
-	struct file		*file,
-	const char		__user *buffer,
-	size_t			count,
-	loff_t			*ppos)
+acpi_thermal_write_cooling_mode(struct file *file,
+				const char __user * buffer,
+				size_t count, loff_t * ppos)
 {
-	struct seq_file		*m = (struct seq_file *)file->private_data;
-	struct acpi_thermal	*tz = (struct acpi_thermal *)m->private;
-	int			result = 0;
-	char			mode_string[12] = {'\0'};
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct acpi_thermal *tz = (struct acpi_thermal *)m->private;
+	int result = 0;
+	char mode_string[12] = { '\0' };
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_write_cooling_mode");
 
@@ -1008,11 +1027,12 @@ acpi_thermal_write_cooling_mode (
 
 	if (copy_from_user(mode_string, buffer, count))
 		return_VALUE(-EFAULT);
-	
+
 	mode_string[count] = '\0';
-	
-	result = acpi_thermal_set_cooling_mode(tz, 
-		simple_strtoul(mode_string, NULL, 0));
+
+	result = acpi_thermal_set_cooling_mode(tz,
+					       simple_strtoul(mode_string, NULL,
+							      0));
 	if (result)
 		return_VALUE(result);
 
@@ -1021,10 +1041,9 @@ acpi_thermal_write_cooling_mode (
 	return_VALUE(count);
 }
 
-
 static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+	struct acpi_thermal *tz = (struct acpi_thermal *)seq->private;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_polling_seq_show");
 
@@ -1037,43 +1056,41 @@ static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
 	}
 
 	seq_printf(seq, "polling frequency:       %lu seconds\n",
-		(tz->polling_frequency / 10));
+		   (tz->polling_frequency / 10));
 
-end:
+      end:
 	return_VALUE(0);
 }
 
 static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file)
 {
 	return single_open(file, acpi_thermal_polling_seq_show,
-							PDE(inode)->data);
+			   PDE(inode)->data);
 }
 
 static ssize_t
-acpi_thermal_write_polling (
-	struct file		*file,
-	const char		__user *buffer,
-	size_t			count,
-	loff_t			*ppos)
+acpi_thermal_write_polling(struct file *file,
+			   const char __user * buffer,
+			   size_t count, loff_t * ppos)
 {
-	struct seq_file		*m = (struct seq_file *)file->private_data;
-	struct acpi_thermal	*tz = (struct acpi_thermal *)m->private;
-	int			result = 0;
-	char			polling_string[12] = {'\0'};
-	int			seconds = 0;
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct acpi_thermal *tz = (struct acpi_thermal *)m->private;
+	int result = 0;
+	char polling_string[12] = { '\0' };
+	int seconds = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_write_polling");
 
 	if (!tz || (count > sizeof(polling_string) - 1))
 		return_VALUE(-EINVAL);
-	
+
 	if (copy_from_user(polling_string, buffer, count))
 		return_VALUE(-EFAULT);
-	
+
 	polling_string[count] = '\0';
 
 	seconds = simple_strtoul(polling_string, NULL, 0);
-	
+
 	result = acpi_thermal_set_polling(tz, seconds);
 	if (result)
 		return_VALUE(result);
@@ -1083,18 +1100,15 @@ acpi_thermal_write_polling (
 	return_VALUE(count);
 }
 
-
-static int
-acpi_thermal_add_fs (
-	struct acpi_device	*device)
+static int acpi_thermal_add_fs(struct acpi_device *device)
 {
-	struct proc_dir_entry	*entry = NULL;
+	struct proc_dir_entry *entry = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_add_fs");
 
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_thermal_dir);
+						     acpi_thermal_dir);
 		if (!acpi_device_dir(device))
 			return_VALUE(-ENODEV);
 		acpi_device_dir(device)->owner = THIS_MODULE;
@@ -1102,11 +1116,11 @@ acpi_thermal_add_fs (
 
 	/* 'state' [R] */
 	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
-		S_IRUGO, acpi_device_dir(device));
+				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_STATE));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_THERMAL_FILE_STATE));
 	else {
 		entry->proc_fops = &acpi_thermal_state_fops;
 		entry->data = acpi_driver_data(device);
@@ -1115,11 +1129,11 @@ acpi_thermal_add_fs (
 
 	/* 'temperature' [R] */
 	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
-		S_IRUGO, acpi_device_dir(device));
+				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_TEMPERATURE));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_THERMAL_FILE_TEMPERATURE));
 	else {
 		entry->proc_fops = &acpi_thermal_temp_fops;
 		entry->data = acpi_driver_data(device);
@@ -1128,11 +1142,12 @@ acpi_thermal_add_fs (
 
 	/* 'trip_points' [R/W] */
 	entry = create_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+				  S_IFREG | S_IRUGO | S_IWUSR,
+				  acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_TRIP_POINTS));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_THERMAL_FILE_TRIP_POINTS));
 	else {
 		entry->proc_fops = &acpi_thermal_trip_fops;
 		entry->data = acpi_driver_data(device);
@@ -1141,11 +1156,12 @@ acpi_thermal_add_fs (
 
 	/* 'cooling_mode' [R/W] */
 	entry = create_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+				  S_IFREG | S_IRUGO | S_IWUSR,
+				  acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_COOLING_MODE));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_THERMAL_FILE_COOLING_MODE));
 	else {
 		entry->proc_fops = &acpi_thermal_cooling_fops;
 		entry->data = acpi_driver_data(device);
@@ -1154,11 +1170,12 @@ acpi_thermal_add_fs (
 
 	/* 'polling_frequency' [R/W] */
 	entry = create_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+				  S_IFREG | S_IRUGO | S_IWUSR,
+				  acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_POLLING_FREQ));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_THERMAL_FILE_POLLING_FREQ));
 	else {
 		entry->proc_fops = &acpi_thermal_polling_fops;
 		entry->data = acpi_driver_data(device);
@@ -1168,10 +1185,7 @@ acpi_thermal_add_fs (
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_remove_fs (
-	struct acpi_device	*device)
+static int acpi_thermal_remove_fs(struct acpi_device *device)
 {
 	ACPI_FUNCTION_TRACE("acpi_thermal_remove_fs");
 
@@ -1193,19 +1207,14 @@ acpi_thermal_remove_fs (
 	return_VALUE(0);
 }
 
-
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
 
-static void
-acpi_thermal_notify (
-	acpi_handle 		handle,
-	u32 			event,
-	void 			*data)
+static void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)
 {
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	struct acpi_device	*device = NULL;
+	struct acpi_thermal *tz = (struct acpi_thermal *)data;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_notify");
 
@@ -1231,19 +1240,16 @@ acpi_thermal_notify (
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
+				  "Unsupported event [0x%x]\n", event));
 		break;
 	}
 
 	return_VOID;
 }
 
-
-static int
-acpi_thermal_get_info (
-	struct acpi_thermal	*tz)
+static int acpi_thermal_get_info(struct acpi_thermal *tz)
 {
-	int			result = 0;
+	int result = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_get_info");
 
@@ -1262,20 +1268,24 @@ acpi_thermal_get_info (
 
 	/* Set the cooling mode [_SCP] to active cooling (default) */
 	result = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);
-	if (!result) 
+	if (!result)
 		tz->flags.cooling_mode = 1;
-	else { 
+	else {
 		/* Oh,we have not _SCP method.
-		   Generally show cooling_mode by _ACx, _PSV,spec 12.2*/
+		   Generally show cooling_mode by _ACx, _PSV,spec 12.2 */
 		tz->flags.cooling_mode = 0;
-		if ( tz->trips.active[0].flags.valid && tz->trips.passive.flags.valid ) {
-			if ( tz->trips.passive.temperature > tz->trips.active[0].temperature )
+		if (tz->trips.active[0].flags.valid
+		    && tz->trips.passive.flags.valid) {
+			if (tz->trips.passive.temperature >
+			    tz->trips.active[0].temperature)
 				tz->cooling_mode = ACPI_THERMAL_MODE_ACTIVE;
-			else 
+			else
 				tz->cooling_mode = ACPI_THERMAL_MODE_PASSIVE;
-		} else if ( !tz->trips.active[0].flags.valid && tz->trips.passive.flags.valid ) {
+		} else if (!tz->trips.active[0].flags.valid
+			   && tz->trips.passive.flags.valid) {
 			tz->cooling_mode = ACPI_THERMAL_MODE_PASSIVE;
-		} else if ( tz->trips.active[0].flags.valid && !tz->trips.passive.flags.valid ) {
+		} else if (tz->trips.active[0].flags.valid
+			   && !tz->trips.passive.flags.valid) {
 			tz->cooling_mode = ACPI_THERMAL_MODE_ACTIVE;
 		} else {
 			/* _ACx and _PSV are optional, but _CRT is required */
@@ -1297,14 +1307,11 @@ acpi_thermal_get_info (
 	return_VALUE(0);
 }
 
-
-static int
-acpi_thermal_add (
-	struct acpi_device 		*device)
+static int acpi_thermal_add(struct acpi_device *device)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_thermal	*tz = NULL;
+	int result = 0;
+	acpi_status status = AE_OK;
+	struct acpi_thermal *tz = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_add");
 
@@ -1335,19 +1342,20 @@ acpi_thermal_add (
 	acpi_thermal_check(tz);
 
 	status = acpi_install_notify_handler(tz->handle,
-		ACPI_DEVICE_NOTIFY, acpi_thermal_notify, tz);
+					     ACPI_DEVICE_NOTIFY,
+					     acpi_thermal_notify, tz);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error installing notify handler\n"));
+				  "Error installing notify handler\n"));
 		result = -ENODEV;
 		goto end;
 	}
 
 	printk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",
-		acpi_device_name(device), acpi_device_bid(device),
-		KELVIN_TO_CELSIUS(tz->temperature));
+	       acpi_device_name(device), acpi_device_bid(device),
+	       KELVIN_TO_CELSIUS(tz->temperature));
 
-end:
+      end:
 	if (result) {
 		acpi_thermal_remove_fs(device);
 		kfree(tz);
@@ -1356,21 +1364,17 @@ acpi_thermal_add (
 	return_VALUE(result);
 }
 
-
-static int
-acpi_thermal_remove (
-	struct acpi_device	*device,
-	int			type)
+static int acpi_thermal_remove(struct acpi_device *device, int type)
 {
-	acpi_status		status = AE_OK;
-	struct acpi_thermal	*tz = NULL;
+	acpi_status status = AE_OK;
+	struct acpi_thermal *tz = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_remove");
 
 	if (!device || !acpi_driver_data(device))
 		return_VALUE(-EINVAL);
 
-	tz = (struct acpi_thermal *) acpi_driver_data(device);
+	tz = (struct acpi_thermal *)acpi_driver_data(device);
 
 	/* avoid timer adding new defer task */
 	tz->zombie = 1;
@@ -1382,19 +1386,19 @@ acpi_thermal_remove (
 	del_timer_sync(&(tz->timer));
 
 	status = acpi_remove_notify_handler(tz->handle,
-		ACPI_DEVICE_NOTIFY, acpi_thermal_notify);
+					    ACPI_DEVICE_NOTIFY,
+					    acpi_thermal_notify);
 	if (ACPI_FAILURE(status))
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error removing notify handler\n"));
+				  "Error removing notify handler\n"));
 
 	/* Terminate policy */
-	if (tz->trips.passive.flags.valid
-		&& tz->trips.passive.flags.enabled) {
+	if (tz->trips.passive.flags.valid && tz->trips.passive.flags.enabled) {
 		tz->trips.passive.flags.enabled = 0;
 		acpi_thermal_passive(tz);
 	}
 	if (tz->trips.active[0].flags.valid
-		&& tz->trips.active[0].flags.enabled) {
+	    && tz->trips.active[0].flags.enabled) {
 		tz->trips.active[0].flags.enabled = 0;
 		acpi_thermal_active(tz);
 	}
@@ -1405,11 +1409,9 @@ acpi_thermal_remove (
 	return_VALUE(0);
 }
 
-
-static int __init
-acpi_thermal_init (void)
+static int __init acpi_thermal_init(void)
 {
-	int			result = 0;
+	int result = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_thermal_init");
 
@@ -1427,9 +1429,7 @@ acpi_thermal_init (void)
 	return_VALUE(0);
 }
 
-
-static void __exit
-acpi_thermal_exit (void)
+static void __exit acpi_thermal_exit(void)
 {
 	ACPI_FUNCTION_TRACE("acpi_thermal_exit");
 
@@ -1440,6 +1440,5 @@ acpi_thermal_exit (void)
 	return_VOID;
 }
 
-
 module_init(acpi_thermal_init);
 module_exit(acpi_thermal_exit);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
new file mode 100644
index 000000000000..79c3a686bc44
--- /dev/null
+++ b/drivers/acpi/thermal.c
@@ -0,0 +1,1445 @@
+/*
+ *  acpi_thermal.c - ACPI Thermal Zone Driver ($Revision: 41 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This driver fully implements the ACPI thermal policy as described in the
+ *  ACPI 2.0 Specification.
+ *
+ *  TBD: 1. Implement passive cooling hysteresis.
+ *       2. Enhance passive cooling (CPU) states/limit interface to support
+ *          concepts of 'multiple limiters', upper/lower limits, etc.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/kmod.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+#define ACPI_THERMAL_COMPONENT		0x04000000
+#define ACPI_THERMAL_CLASS		"thermal_zone"
+#define ACPI_THERMAL_DRIVER_NAME	"ACPI Thermal Zone Driver"
+#define ACPI_THERMAL_DEVICE_NAME	"Thermal Zone"
+#define ACPI_THERMAL_FILE_STATE		"state"
+#define ACPI_THERMAL_FILE_TEMPERATURE	"temperature"
+#define ACPI_THERMAL_FILE_TRIP_POINTS	"trip_points"
+#define ACPI_THERMAL_FILE_COOLING_MODE	"cooling_mode"
+#define ACPI_THERMAL_FILE_POLLING_FREQ	"polling_frequency"
+#define ACPI_THERMAL_NOTIFY_TEMPERATURE	0x80
+#define ACPI_THERMAL_NOTIFY_THRESHOLDS	0x81
+#define ACPI_THERMAL_NOTIFY_DEVICES	0x82
+#define ACPI_THERMAL_NOTIFY_CRITICAL	0xF0
+#define ACPI_THERMAL_NOTIFY_HOT		0xF1
+#define ACPI_THERMAL_MODE_ACTIVE	0x00
+#define ACPI_THERMAL_MODE_PASSIVE	0x01
+#define ACPI_THERMAL_MODE_CRITICAL   	0xff
+#define ACPI_THERMAL_PATH_POWEROFF	"/sbin/poweroff"
+
+#define ACPI_THERMAL_MAX_ACTIVE	10
+#define ACPI_THERMAL_MAX_LIMIT_STR_LEN 65
+
+#define KELVIN_TO_CELSIUS(t)    (long)(((long)t-2732>=0) ? ((long)t-2732+5)/10 : ((long)t-2732-5)/10)
+#define CELSIUS_TO_KELVIN(t)	((t+273)*10)
+
+#define _COMPONENT		ACPI_THERMAL_COMPONENT
+ACPI_MODULE_NAME		("acpi_thermal")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+static int tzp;
+module_param(tzp, int, 0);
+MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
+
+
+static int acpi_thermal_add (struct acpi_device *device);
+static int acpi_thermal_remove (struct acpi_device *device, int type);
+static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
+static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
+static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
+static ssize_t acpi_thermal_write_trip_points (struct file*,const char __user *,size_t,loff_t *);
+static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file);
+static ssize_t acpi_thermal_write_cooling_mode (struct file*,const char __user *,size_t,loff_t *);
+static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file);
+static ssize_t acpi_thermal_write_polling(struct file*,const char __user *,size_t,loff_t *);
+
+static struct acpi_driver acpi_thermal_driver = {
+	.name =		ACPI_THERMAL_DRIVER_NAME,
+	.class =	ACPI_THERMAL_CLASS,
+	.ids =		ACPI_THERMAL_HID,
+	.ops =		{
+				.add =		acpi_thermal_add,
+				.remove =	acpi_thermal_remove,
+			},
+};
+
+struct acpi_thermal_state {
+	u8			critical:1;
+	u8			hot:1;
+	u8			passive:1;
+	u8			active:1;
+	u8			reserved:4;
+	int			active_index;
+};
+
+struct acpi_thermal_state_flags {
+	u8			valid:1;
+	u8			enabled:1;
+	u8			reserved:6;
+};
+
+struct acpi_thermal_critical {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+};
+
+struct acpi_thermal_hot {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+};
+
+struct acpi_thermal_passive {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+	unsigned long		tc1;
+	unsigned long		tc2;
+	unsigned long		tsp;
+	struct acpi_handle_list	devices;
+};
+
+struct acpi_thermal_active {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+	struct acpi_handle_list	devices;
+};
+
+struct acpi_thermal_trips {
+	struct acpi_thermal_critical critical;
+	struct acpi_thermal_hot	hot;
+	struct acpi_thermal_passive passive;
+	struct acpi_thermal_active active[ACPI_THERMAL_MAX_ACTIVE];
+};
+
+struct acpi_thermal_flags {
+	u8			cooling_mode:1;		/* _SCP */
+	u8			devices:1;		/* _TZD */
+	u8			reserved:6;
+};
+
+struct acpi_thermal {
+	acpi_handle		handle;
+	acpi_bus_id		name;
+	unsigned long		temperature;
+	unsigned long		last_temperature;
+	unsigned long		polling_frequency;
+	u8			cooling_mode;
+	volatile u8		zombie;
+	struct acpi_thermal_flags flags;
+	struct acpi_thermal_state state;
+	struct acpi_thermal_trips trips;
+	struct acpi_handle_list	devices;
+	struct timer_list	timer;
+};
+
+static struct file_operations acpi_thermal_state_fops = {
+	.open		= acpi_thermal_state_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct file_operations acpi_thermal_temp_fops = {
+	.open		= acpi_thermal_temp_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct file_operations acpi_thermal_trip_fops = {
+	.open		= acpi_thermal_trip_open_fs,
+	.read		= seq_read,
+	.write		= acpi_thermal_write_trip_points,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct file_operations acpi_thermal_cooling_fops = {
+	.open		= acpi_thermal_cooling_open_fs,
+	.read		= seq_read,
+	.write		= acpi_thermal_write_cooling_mode,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct file_operations acpi_thermal_polling_fops = {
+	.open		= acpi_thermal_polling_open_fs,
+	.read		= seq_read,
+	.write		= acpi_thermal_write_polling,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* --------------------------------------------------------------------------
+                             Thermal Zone Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_thermal_get_temperature (
+	struct acpi_thermal *tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_temperature");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	tz->last_temperature = tz->temperature;
+
+	status = acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n", tz->temperature));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_polling_frequency (
+	struct acpi_thermal	*tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_polling_frequency");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(tz->handle, "_TZP", NULL, &tz->polling_frequency);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n", tz->polling_frequency));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_set_polling (
+	struct acpi_thermal	*tz,
+	int			seconds)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_set_polling");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency set to %lu seconds\n", tz->polling_frequency));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_set_cooling_mode (
+	struct acpi_thermal	*tz,
+	int			mode)
+{
+	acpi_status		status = AE_OK;
+	union acpi_object	arg0 = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg0};
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_set_cooling_mode");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_get_handle(tz->handle, "_SCP", &handle);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	arg0.integer.value = mode;
+
+	status = acpi_evaluate_object(handle, NULL, &arg_list, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	tz->cooling_mode = mode;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n", 
+		mode?"passive":"active"));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_trip_points (
+	struct acpi_thermal *tz)
+{
+	acpi_status		status = AE_OK;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_trip_points");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	/* Critical Shutdown (required) */
+
+	status = acpi_evaluate_integer(tz->handle, "_CRT", NULL, 
+		&tz->trips.critical.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.critical.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No critical threshold\n"));
+		return_VALUE(-ENODEV);
+	}
+	else {
+		tz->trips.critical.flags.valid = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found critical threshold [%lu]\n", tz->trips.critical.temperature));
+	}
+
+	/* Critical Sleep (optional) */
+
+	status = acpi_evaluate_integer(tz->handle, "_HOT", NULL, &tz->trips.hot.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.hot.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No hot threshold\n"));
+	}
+	else {
+		tz->trips.hot.flags.valid = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%lu]\n", tz->trips.hot.temperature));
+	}
+
+	/* Passive: Processors (optional) */
+
+	status = acpi_evaluate_integer(tz->handle, "_PSV", NULL, &tz->trips.passive.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.passive.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No passive threshold\n"));
+	}
+	else {
+		tz->trips.passive.flags.valid = 1;
+
+		status = acpi_evaluate_integer(tz->handle, "_TC1", NULL, &tz->trips.passive.tc1);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_integer(tz->handle, "_TC2", NULL, &tz->trips.passive.tc2);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_integer(tz->handle, "_TSP", NULL, &tz->trips.passive.tsp);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_reference(tz->handle, "_PSL", NULL, &tz->trips.passive.devices);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		if (!tz->trips.passive.flags.valid)
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid passive threshold\n"));
+		else
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found passive threshold [%lu]\n", tz->trips.passive.temperature));
+	}
+
+	/* Active: Fans, etc. (optional) */
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+
+		char name[5] = {'_','A','C',('0'+i),'\0'};
+
+		status = acpi_evaluate_integer(tz->handle, name, NULL, &tz->trips.active[i].temperature);
+		if (ACPI_FAILURE(status))
+			break;
+
+		name[2] = 'L';
+		status = acpi_evaluate_reference(tz->handle, name, NULL, &tz->trips.active[i].devices);
+		if (ACPI_SUCCESS(status)) {
+			tz->trips.active[i].flags.valid = 1;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found active threshold [%d]:[%lu]\n", i, tz->trips.active[i].temperature));
+		}
+		else
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid active threshold [%d]\n", i));
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_devices (
+	struct acpi_thermal	*tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_devices");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_call_usermode (
+	char			*path)
+{
+	char			*argv[2] = {NULL, NULL};
+	char			*envp[3] = {NULL, NULL, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_call_usermode");
+
+	if (!path)
+		return_VALUE(-EINVAL);
+
+	argv[0] = path;
+
+	/* minimal command environment */
+	envp[0] = "HOME=/";
+	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	
+	call_usermodehelper(argv[0], argv, envp, 0);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_critical (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_critical");
+
+	if (!tz || !tz->trips.critical.flags.valid)
+		return_VALUE(-EINVAL);
+
+	if (tz->temperature >= tz->trips.critical.temperature) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Critical trip point\n"));
+		tz->trips.critical.flags.enabled = 1;
+	}
+	else if (tz->trips.critical.flags.enabled)
+		tz->trips.critical.flags.enabled = 0;
+
+	result = acpi_bus_get_device(tz->handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	printk(KERN_EMERG "Critical temperature reached (%ld C), shutting down.\n", KELVIN_TO_CELSIUS(tz->temperature));
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_CRITICAL, tz->trips.critical.flags.enabled);
+
+	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_hot (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_hot");
+
+	if (!tz || !tz->trips.hot.flags.valid)
+		return_VALUE(-EINVAL);
+
+	if (tz->temperature >= tz->trips.hot.temperature) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Hot trip point\n"));
+		tz->trips.hot.flags.enabled = 1;
+	}
+	else if (tz->trips.hot.flags.enabled)
+		tz->trips.hot.flags.enabled = 0;
+
+	result = acpi_bus_get_device(tz->handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT, tz->trips.hot.flags.enabled);
+
+	/* TBD: Call user-mode "sleep(S4)" function */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_passive (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_thermal_passive *passive = NULL;
+	int			trend = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_passive");
+
+	if (!tz || !tz->trips.passive.flags.valid)
+		return_VALUE(-EINVAL);
+
+	passive = &(tz->trips.passive);
+
+	/*
+	 * Above Trip?
+	 * -----------
+	 * Calculate the thermal trend (using the passive cooling equation)
+	 * and modify the performance limit for all passive cooling devices
+	 * accordingly.  Note that we assume symmetry.
+	 */
+	if (tz->temperature >= passive->temperature) {
+		trend = (passive->tc1 * (tz->temperature - tz->last_temperature)) + (passive->tc2 * (tz->temperature - passive->temperature));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"trend[%d]=(tc1[%lu]*(tmp[%lu]-last[%lu]))+(tc2[%lu]*(tmp[%lu]-psv[%lu]))\n", 
+			trend, passive->tc1, tz->temperature, 
+			tz->last_temperature, passive->tc2, 
+			tz->temperature, passive->temperature));
+		tz->trips.passive.flags.enabled = 1;
+		/* Heating up? */
+		if (trend > 0)
+			for (i=0; i<passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(
+					passive->devices.handles[i], 
+					ACPI_PROCESSOR_LIMIT_INCREMENT);
+		/* Cooling off? */
+		else if (trend < 0)
+			for (i=0; i<passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(
+					passive->devices.handles[i], 
+					ACPI_PROCESSOR_LIMIT_DECREMENT);
+	}
+
+	/*
+	 * Below Trip?
+	 * -----------
+	 * Implement passive cooling hysteresis to slowly increase performance
+	 * and avoid thrashing around the passive trip point.  Note that we
+	 * assume symmetry.
+	 */
+	else if (tz->trips.passive.flags.enabled) {
+		for (i=0; i<passive->devices.count; i++)
+			result = acpi_processor_set_thermal_limit(
+				passive->devices.handles[i], 
+				ACPI_PROCESSOR_LIMIT_DECREMENT);
+		if (result == 1) {
+			tz->trips.passive.flags.enabled = 0;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+				"Disabling passive cooling (zone is cool)\n"));
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_active (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_thermal_active *active = NULL;
+	int                     i = 0;
+	int			j = 0;
+	unsigned long		maxtemp = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_active");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+
+		active = &(tz->trips.active[i]);
+		if (!active || !active->flags.valid)
+			break;
+
+		/*
+		 * Above Threshold?
+		 * ----------------
+		 * If not already enabled, turn ON all cooling devices
+		 * associated with this active threshold.
+		 */
+		if (tz->temperature >= active->temperature) {
+			if (active->temperature > maxtemp)
+				tz->state.active_index = i, maxtemp = active->temperature;
+			if (!active->flags.enabled) {
+				for (j = 0; j < active->devices.count; j++) {
+					result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D0);
+					if (result) {
+						ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'on'\n", active->devices.handles[j]));
+						continue;
+					}
+					active->flags.enabled = 1;
+					ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'on'\n", active->devices.handles[j]));
+				}
+			}
+		}
+		/*
+		 * Below Threshold?
+		 * ----------------
+		 * Turn OFF all cooling devices associated with this
+		 * threshold.
+		 */
+		else if (active->flags.enabled) {
+			for (j = 0; j < active->devices.count; j++) {
+				result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D3);
+				if (result) {
+					ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'off'\n", active->devices.handles[j]));
+					continue;
+				}
+				active->flags.enabled = 0;
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'off'\n", active->devices.handles[j]));
+			}
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static void acpi_thermal_check (void *context);
+
+static void
+acpi_thermal_run (
+	unsigned long		data)
+{
+	struct acpi_thermal *tz = (struct acpi_thermal *)data;
+	if (!tz->zombie)
+		acpi_os_queue_for_execution(OSD_PRIORITY_GPE,  
+			acpi_thermal_check, (void *) data);
+}
+
+
+static void
+acpi_thermal_check (
+	void                    *data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	unsigned long		sleep_time = 0;
+	int			i = 0;
+	struct acpi_thermal_state state;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_check");
+
+	if (!tz) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		return_VOID;
+	}
+
+	state = tz->state;
+
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		return_VOID;
+	
+	memset(&tz->state, 0, sizeof(tz->state));
+	
+	/*
+	 * Check Trip Points
+	 * -----------------
+	 * Compare the current temperature to the trip point values to see
+	 * if we've entered one of the thermal policy states.  Note that
+	 * this function determines when a state is entered, but the 
+	 * individual policy decides when it is exited (e.g. hysteresis).
+	 */
+	if (tz->trips.critical.flags.valid)
+		state.critical |= (tz->temperature >= tz->trips.critical.temperature);
+	if (tz->trips.hot.flags.valid)
+		state.hot |= (tz->temperature >= tz->trips.hot.temperature);
+	if (tz->trips.passive.flags.valid)
+		state.passive |= (tz->temperature >= tz->trips.passive.temperature);
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+		if (tz->trips.active[i].flags.valid)
+			state.active |= (tz->temperature >= tz->trips.active[i].temperature);
+
+	/*
+	 * Invoke Policy
+	 * -------------
+	 * Separated from the above check to allow individual policy to 
+	 * determine when to exit a given state.
+	 */
+	if (state.critical)
+		acpi_thermal_critical(tz);
+	if (state.hot)
+		acpi_thermal_hot(tz);
+	if (state.passive)
+		acpi_thermal_passive(tz);
+	if (state.active)
+		acpi_thermal_active(tz);
+
+	/*
+	 * Calculate State
+	 * ---------------
+	 * Again, separated from the above two to allow independent policy
+	 * decisions.
+	 */
+	if (tz->trips.critical.flags.enabled)
+		tz->state.critical = 1;
+	if (tz->trips.hot.flags.enabled)
+		tz->state.hot = 1;
+	if (tz->trips.passive.flags.enabled)
+		tz->state.passive = 1;
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+		if (tz->trips.active[i].flags.enabled)
+			tz->state.active = 1;
+
+	/*
+	 * Calculate Sleep Time
+	 * --------------------
+	 * If we're in the passive state, use _TSP's value.  Otherwise
+	 * use the default polling frequency (e.g. _TZP).  If no polling
+	 * frequency is specified then we'll wait forever (at least until
+	 * a thermal event occurs).  Note that _TSP and _TZD values are
+	 * given in 1/10th seconds (we must covert to milliseconds).
+	 */
+	if (tz->state.passive)
+		sleep_time = tz->trips.passive.tsp * 100;
+	else if (tz->polling_frequency > 0)
+		sleep_time = tz->polling_frequency * 100;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n", 
+		tz->name, tz->temperature, sleep_time));
+
+	/*
+	 * Schedule Next Poll
+	 * ------------------
+	 */
+	if (!sleep_time) {
+		if (timer_pending(&(tz->timer)))
+			del_timer(&(tz->timer));
+	}
+	else {
+		if (timer_pending(&(tz->timer)))
+			mod_timer(&(tz->timer), (HZ * sleep_time) / 1000);
+		else {
+			tz->timer.data = (unsigned long) tz;
+			tz->timer.function = acpi_thermal_run;
+			tz->timer.expires = jiffies + (HZ * sleep_time) / 1000;
+			add_timer(&(tz->timer));
+		}
+	}
+
+	return_VOID;
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+static struct proc_dir_entry	*acpi_thermal_dir;
+
+static int acpi_thermal_state_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_state_seq_show");
+
+	if (!tz)
+		goto end;
+
+	seq_puts(seq, "state:                   ");
+
+	if (!tz->state.critical && !tz->state.hot && !tz->state.passive && !tz->state.active)
+		seq_puts(seq, "ok\n");
+	else {
+		if (tz->state.critical)
+			seq_puts(seq, "critical ");
+		if (tz->state.hot)
+			seq_puts(seq, "hot ");
+		if (tz->state.passive)
+			seq_puts(seq, "passive ");
+		if (tz->state.active)
+			seq_printf(seq, "active[%d]", tz->state.active_index);
+		seq_puts(seq, "\n");
+	}
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_thermal_state_seq_show, PDE(inode)->data);
+}
+
+
+static int acpi_thermal_temp_seq_show(struct seq_file *seq, void *offset)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_temp_seq_show");
+
+	if (!tz)
+		goto end;
+
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		goto end;
+
+	seq_printf(seq, "temperature:             %ld C\n", 
+		KELVIN_TO_CELSIUS(tz->temperature));
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_thermal_temp_seq_show, PDE(inode)->data);
+}
+
+
+static int acpi_thermal_trip_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+	int			i = 0;
+	int			j = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_trip_seq_show");
+
+	if (!tz)
+		goto end;
+
+	if (tz->trips.critical.flags.valid)
+		seq_printf(seq, "critical (S5):           %ld C\n",
+			KELVIN_TO_CELSIUS(tz->trips.critical.temperature));
+
+	if (tz->trips.hot.flags.valid)
+		seq_printf(seq, "hot (S4):                %ld C\n",
+			KELVIN_TO_CELSIUS(tz->trips.hot.temperature));
+
+	if (tz->trips.passive.flags.valid) {
+		seq_printf(seq, "passive:                 %ld C: tc1=%lu tc2=%lu tsp=%lu devices=",
+			KELVIN_TO_CELSIUS(tz->trips.passive.temperature),
+			tz->trips.passive.tc1,
+			tz->trips.passive.tc2, 
+			tz->trips.passive.tsp);
+		for (j=0; j<tz->trips.passive.devices.count; j++) {
+
+			seq_printf(seq, "0x%p ", tz->trips.passive.devices.handles[j]);
+		}
+		seq_puts(seq, "\n");
+	}
+
+	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
+		if (!(tz->trips.active[i].flags.valid))
+			break;
+		seq_printf(seq, "active[%d]:               %ld C: devices=",
+			i, KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
+		for (j = 0; j < tz->trips.active[i].devices.count; j++) 
+			seq_printf(seq, "0x%p ",
+				tz->trips.active[i].devices.handles[j]);
+		seq_puts(seq, "\n");
+	}
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_thermal_trip_seq_show, PDE(inode)->data);
+}
+
+static ssize_t
+acpi_thermal_write_trip_points (
+        struct file		*file,
+        const char		__user *buffer,
+        size_t			count,
+        loff_t			*ppos)
+{
+	struct seq_file		*m = (struct seq_file *)file->private_data;
+	struct acpi_thermal	*tz = (struct acpi_thermal *)m->private;
+
+	char			*limit_string; 
+	int			num, critical, hot, passive;
+	int			*active; 
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_trip_points");
+
+	limit_string = kmalloc(ACPI_THERMAL_MAX_LIMIT_STR_LEN, GFP_KERNEL);
+	if(!limit_string)
+		return_VALUE(-ENOMEM);
+
+	memset(limit_string, 0, ACPI_THERMAL_MAX_LIMIT_STR_LEN);
+
+	active = kmalloc(ACPI_THERMAL_MAX_ACTIVE *sizeof(int), GFP_KERNEL);
+	if(!active)
+		return_VALUE(-ENOMEM);
+
+	if (!tz || (count > ACPI_THERMAL_MAX_LIMIT_STR_LEN - 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
+		count = -EINVAL;
+		goto end;
+	}
+	
+	if (copy_from_user(limit_string, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
+		count = -EFAULT;
+		goto end;
+	}
+	
+	limit_string[count] = '\0';
+
+	num = sscanf(limit_string, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
+				&critical, &hot, &passive,
+				&active[0], &active[1], &active[2], &active[3], &active[4],
+				&active[5], &active[6], &active[7], &active[8], &active[9]);
+	if(!(num >=5 && num < (ACPI_THERMAL_MAX_ACTIVE + 3))) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
+		count = -EINVAL;
+		goto end;
+	}
+
+	tz->trips.critical.temperature = CELSIUS_TO_KELVIN(critical);
+	tz->trips.hot.temperature = CELSIUS_TO_KELVIN(hot);
+	tz->trips.passive.temperature = CELSIUS_TO_KELVIN(passive);
+	for (i = 0; i < num - 3; i++) {
+		if (!(tz->trips.active[i].flags.valid))
+			break;
+		tz->trips.active[i].temperature = CELSIUS_TO_KELVIN(active[i]);
+	}
+	
+end:
+	kfree(active);
+	kfree(limit_string);
+	return_VALUE(count);
+}
+
+
+static int acpi_thermal_cooling_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_cooling_seq_show");
+
+	if (!tz)
+		goto end;
+
+	if (!tz->flags.cooling_mode) {
+		seq_puts(seq, "<setting not supported>\n");
+	}
+
+	if ( tz->cooling_mode == ACPI_THERMAL_MODE_CRITICAL )
+		seq_printf(seq, "cooling mode:	critical\n");
+	else
+		seq_printf(seq, "cooling mode:	%s\n",
+			tz->cooling_mode?"passive":"active");
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_thermal_cooling_seq_show,
+							PDE(inode)->data);
+}
+
+static ssize_t
+acpi_thermal_write_cooling_mode (
+	struct file		*file,
+	const char		__user *buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	struct seq_file		*m = (struct seq_file *)file->private_data;
+	struct acpi_thermal	*tz = (struct acpi_thermal *)m->private;
+	int			result = 0;
+	char			mode_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_cooling_mode");
+
+	if (!tz || (count > sizeof(mode_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (!tz->flags.cooling_mode)
+		return_VALUE(-ENODEV);
+
+	if (copy_from_user(mode_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	mode_string[count] = '\0';
+	
+	result = acpi_thermal_set_cooling_mode(tz, 
+		simple_strtoul(mode_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	acpi_thermal_check(tz);
+
+	return_VALUE(count);
+}
+
+
+static int acpi_thermal_polling_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *)seq->private;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_polling_seq_show");
+
+	if (!tz)
+		goto end;
+
+	if (!tz->polling_frequency) {
+		seq_puts(seq, "<polling disabled>\n");
+		goto end;
+	}
+
+	seq_printf(seq, "polling frequency:       %lu seconds\n",
+		(tz->polling_frequency / 10));
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_thermal_polling_seq_show,
+							PDE(inode)->data);
+}
+
+static ssize_t
+acpi_thermal_write_polling (
+	struct file		*file,
+	const char		__user *buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	struct seq_file		*m = (struct seq_file *)file->private_data;
+	struct acpi_thermal	*tz = (struct acpi_thermal *)m->private;
+	int			result = 0;
+	char			polling_string[12] = {'\0'};
+	int			seconds = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_polling");
+
+	if (!tz || (count > sizeof(polling_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(polling_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	polling_string[count] = '\0';
+
+	seconds = simple_strtoul(polling_string, NULL, 0);
+	
+	result = acpi_thermal_set_polling(tz, seconds);
+	if (result)
+		return_VALUE(result);
+
+	acpi_thermal_check(tz);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_thermal_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_thermal_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+		acpi_device_dir(device)->owner = THIS_MODULE;
+	}
+
+	/* 'state' [R] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_STATE));
+	else {
+		entry->proc_fops = &acpi_thermal_state_fops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'temperature' [R] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_TEMPERATURE));
+	else {
+		entry->proc_fops = &acpi_thermal_temp_fops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'trip_points' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_TRIP_POINTS));
+	else {
+		entry->proc_fops = &acpi_thermal_trip_fops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'cooling_mode' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_COOLING_MODE));
+	else {
+		entry->proc_fops = &acpi_thermal_cooling_fops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'polling_frequency' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_POLLING_FREQ));
+	else {
+		entry->proc_fops = &acpi_thermal_polling_fops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
+				  acpi_device_dir(device));
+		remove_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
+				  acpi_device_dir(device));
+		remove_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
+				  acpi_device_dir(device));
+		remove_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
+				  acpi_device_dir(device));
+		remove_proc_entry(ACPI_THERMAL_FILE_STATE,
+				  acpi_device_dir(device));
+		remove_proc_entry(acpi_device_bid(device), acpi_thermal_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_thermal_notify (
+	acpi_handle 		handle,
+	u32 			event,
+	void 			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_notify");
+
+	if (!tz)
+		return_VOID;
+
+	if (acpi_bus_get_device(tz->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_THERMAL_NOTIFY_TEMPERATURE:
+		acpi_thermal_check(tz);
+		break;
+	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
+		acpi_thermal_get_trip_points(tz);
+		acpi_thermal_check(tz);
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	case ACPI_THERMAL_NOTIFY_DEVICES:
+		if (tz->flags.devices)
+			acpi_thermal_get_devices(tz);
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_thermal_get_info (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_info");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	/* Get temperature [_TMP] (required) */
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		return_VALUE(result);
+
+	/* Get trip points [_CRT, _PSV, etc.] (required) */
+	result = acpi_thermal_get_trip_points(tz);
+	if (result)
+		return_VALUE(result);
+
+	/* Set the cooling mode [_SCP] to active cooling (default) */
+	result = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);
+	if (!result) 
+		tz->flags.cooling_mode = 1;
+	else { 
+		/* Oh,we have not _SCP method.
+		   Generally show cooling_mode by _ACx, _PSV,spec 12.2*/
+		tz->flags.cooling_mode = 0;
+		if ( tz->trips.active[0].flags.valid && tz->trips.passive.flags.valid ) {
+			if ( tz->trips.passive.temperature > tz->trips.active[0].temperature )
+				tz->cooling_mode = ACPI_THERMAL_MODE_ACTIVE;
+			else 
+				tz->cooling_mode = ACPI_THERMAL_MODE_PASSIVE;
+		} else if ( !tz->trips.active[0].flags.valid && tz->trips.passive.flags.valid ) {
+			tz->cooling_mode = ACPI_THERMAL_MODE_PASSIVE;
+		} else if ( tz->trips.active[0].flags.valid && !tz->trips.passive.flags.valid ) {
+			tz->cooling_mode = ACPI_THERMAL_MODE_ACTIVE;
+		} else {
+			/* _ACx and _PSV are optional, but _CRT is required */
+			tz->cooling_mode = ACPI_THERMAL_MODE_CRITICAL;
+		}
+	}
+
+	/* Get default polling frequency [_TZP] (optional) */
+	if (tzp)
+		tz->polling_frequency = tzp;
+	else
+		acpi_thermal_get_polling_frequency(tz);
+
+	/* Get devices in this thermal zone [_TZD] (optional) */
+	result = acpi_thermal_get_devices(tz);
+	if (!result)
+		tz->flags.devices = 1;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_add (
+	struct acpi_device 		*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_thermal	*tz = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	tz = kmalloc(sizeof(struct acpi_thermal), GFP_KERNEL);
+	if (!tz)
+		return_VALUE(-ENOMEM);
+	memset(tz, 0, sizeof(struct acpi_thermal));
+
+	tz->handle = device->handle;
+	strcpy(tz->name, device->pnp.bus_id);
+	strcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);
+	acpi_driver_data(device) = tz;
+
+	result = acpi_thermal_get_info(tz);
+	if (result)
+		goto end;
+
+	result = acpi_thermal_add_fs(device);
+	if (result)
+		return_VALUE(result);
+
+	init_timer(&tz->timer);
+
+	acpi_thermal_check(tz);
+
+	status = acpi_install_notify_handler(tz->handle,
+		ACPI_DEVICE_NOTIFY, acpi_thermal_notify, tz);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		KELVIN_TO_CELSIUS(tz->temperature));
+
+end:
+	if (result) {
+		acpi_thermal_remove_fs(device);
+		kfree(tz);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_thermal_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_thermal	*tz = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	tz = (struct acpi_thermal *) acpi_driver_data(device);
+
+	/* avoid timer adding new defer task */
+	tz->zombie = 1;
+	/* wait for running timer (on other CPUs) finish */
+	del_timer_sync(&(tz->timer));
+	/* synchronize deferred task */
+	acpi_os_wait_events_complete(NULL);
+	/* deferred task may reinsert timer */
+	del_timer_sync(&(tz->timer));
+
+	status = acpi_remove_notify_handler(tz->handle,
+		ACPI_DEVICE_NOTIFY, acpi_thermal_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	/* Terminate policy */
+	if (tz->trips.passive.flags.valid
+		&& tz->trips.passive.flags.enabled) {
+		tz->trips.passive.flags.enabled = 0;
+		acpi_thermal_passive(tz);
+	}
+	if (tz->trips.active[0].flags.valid
+		&& tz->trips.active[0].flags.enabled) {
+		tz->trips.active[0].flags.enabled = 0;
+		acpi_thermal_active(tz);
+	}
+
+	acpi_thermal_remove_fs(device);
+
+	kfree(tz);
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_thermal_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_init");
+
+	acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, acpi_root_dir);
+	if (!acpi_thermal_dir)
+		return_VALUE(-ENODEV);
+	acpi_thermal_dir->owner = THIS_MODULE;
+
+	result = acpi_bus_register_driver(&acpi_thermal_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_thermal_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_exit");
+
+	acpi_bus_unregister_driver(&acpi_thermal_driver);
+
+	remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_thermal_init);
+module_exit(acpi_thermal_exit);
