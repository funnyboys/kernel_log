commit 627ead724eff33673597216f5020b72118827de4
Author: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
Date:   Thu Nov 28 15:58:29 2019 +0530

    ACPI: bus: Fix NULL pointer check in acpi_bus_get_private_data()
    
    kmemleak reported backtrace:
        [<bbee0454>] kmem_cache_alloc_trace+0x128/0x260
        [<6677f215>] i2c_acpi_install_space_handler+0x4b/0xe0
        [<1180f4fc>] i2c_register_adapter+0x186/0x400
        [<6083baf7>] i2c_add_adapter+0x4e/0x70
        [<a3ddf966>] intel_gmbus_setup+0x1a2/0x2c0 [i915]
        [<84cb69ae>] i915_driver_probe+0x8d8/0x13a0 [i915]
        [<81911d4b>] i915_pci_probe+0x48/0x160 [i915]
        [<4b159af1>] pci_device_probe+0xdc/0x160
        [<b3c64704>] really_probe+0x1ee/0x450
        [<bc029f5a>] driver_probe_device+0x142/0x1b0
        [<d8829d20>] device_driver_attach+0x49/0x50
        [<de71f045>] __driver_attach+0xc9/0x150
        [<df33ac83>] bus_for_each_dev+0x56/0xa0
        [<80089bba>] driver_attach+0x19/0x20
        [<cc73f583>] bus_add_driver+0x177/0x220
        [<7b29d8c7>] driver_register+0x56/0xf0
    
    In i2c_acpi_remove_space_handler(), a leak occurs whenever the
    "data" parameter is initialized to 0 before being passed to
    acpi_bus_get_private_data().
    
    This is because the NULL pointer check in acpi_bus_get_private_data()
    (condition->if(!*data)) returns EINVAL and, in consequence, memory is
    never freed in i2c_acpi_remove_space_handler().
    
    Fix the NULL pointer check in acpi_bus_get_private_data() to follow
    the analogous check in acpi_get_data_full().
    
    Signed-off-by: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
    [ rjw: Subject & changelog ]
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 48bc96d45bab..54002670cb7a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -153,7 +153,7 @@ int acpi_bus_get_private_data(acpi_handle handle, void **data)
 {
 	acpi_status status;
 
-	if (!*data)
+	if (!data)
 		return -EINVAL;
 
 	status = acpi_get_data(handle, acpi_bus_private_data_handler, data);

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index eec263c9019e..48bc96d45bab 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  acpi_bus.c - ACPI Bus Driver ($Revision: 80 $)
  *
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
 #include <linux/module.h>

commit aa9aaa4d61c0048d3faad056893cd7860bbc084c
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Thu Mar 21 18:20:21 2019 -0700

    ACPI: use different default debug value than ACPICA
    
    Rather than setting debug output flags during early init, its makes
    more sense to simply re-define ACPI_DEBUG_DEFAULT specifically for
    Linux.
    
    ACPICA commit 60903715711f4b00ca1831779a8a23279a66497d
    
    Link: https://github.com/acpica/acpica/commit/60903715
    Fixes: ce5cbf53496b ("ACPI: Set debug output flags independent of ACPICA")
    Reported-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Tested-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 6ecbbabf1233..eec263c9019e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1043,9 +1043,6 @@ void __init acpi_early_init(void)
 
 	acpi_permanent_mmap = true;
 
-	/* Initialize debug output. Linux does not use ACPICA defaults */
-	acpi_dbg_level = ACPI_LV_INFO | ACPI_LV_REPAIR;
-
 #ifdef CONFIG_X86
 	/*
 	 * If the machine falls into the DMI check table,

commit 886ca88be6b357fd2bc5f04ffb45fdcc26a7453d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 25 18:05:39 2019 +0300

    ACPI / bus: Respect PRP0001 when retrieving device match data
    
    In the PRP0001 case, the compatible string may have additional data
    affiliated with the device.  When we call device_get_match_data() on
    such device, we will get nothing since currently
    acpi_device_get_match_data() doesn't respect PRP0001.
    
    To fix the above, try acpi_of_match_device() if there is no ACPI
    table in the driver.
    
    Anyway, note that the device is expected to get its own proper
    ACPI ID.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 147f6c7ea59c..6ecbbabf1233 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -799,10 +799,24 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);
 
+static const void *acpi_of_device_get_match_data(const struct device *dev)
+{
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	const struct of_device_id *match = NULL;
+
+	if (!acpi_of_match_device(adev, dev->driver->of_match_table, &match))
+		return NULL;
+
+	return match->data;
+}
+
 const void *acpi_device_get_match_data(const struct device *dev)
 {
 	const struct acpi_device_id *match;
 
+	if (!dev->driver->acpi_match_table)
+		return acpi_of_device_get_match_data(dev);
+
 	match = acpi_match_device(dev->driver->acpi_match_table, dev);
 	if (!match)
 		return NULL;

commit ce5cbf53496bfebe1b7478a532820373342e8302
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Tue Feb 5 16:14:00 2019 -0800

    ACPI: Set debug output flags independent of ACPICA
    
    There was a divergence between Linux and ACPICA on the definition of
    ACPI_DEBUG_DEFAULT. This divergence was solved by taking ACPICA's
    definition in 4c1379d7bb42. After resolving the divergence, it was
    clear that Linux users wanted to use their old set of debug flags.
    This change fixes the divergence by setting these debug flags during
    acpi_early_init() rather than during global variable initialization
    in acpixf.h (owned by ACPICA).
    
    Fixes: 4c1379d7bb42 ("ACPICA: Debug output: Add option to display method/object evaluation")
    Reported-by: Michael J Ruhl <michael.j.ruhl@intel.com>
    Reported-by: Alex Gagniuc <Alex_Gagniuc@Dellteam.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 5c093ce01bcd..147f6c7ea59c 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1029,6 +1029,9 @@ void __init acpi_early_init(void)
 
 	acpi_permanent_mmap = true;
 
+	/* Initialize debug output. Linux does not use ACPICA defaults */
+	acpi_dbg_level = ACPI_LV_INFO | ACPI_LV_REPAIR;
+
 #ifdef CONFIG_X86
 	/*
 	 * If the machine falls into the DMI check table,

commit b1c0330823fe842dbb34641f1410f0afa51c29d3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 9 00:34:37 2019 +0100

    ACPI: EC: Look for ECDT EC after calling acpi_load_tables()
    
    Some systems have had functional issues since commit 5a8361f7ecce
    (ACPICA: Integrate package handling with module-level code) that,
    among other things, changed the initial values of the
    acpi_gbl_group_module_level_code and acpi_gbl_parse_table_as_term_list
    global flags in ACPICA which implicitly caused acpi_ec_ecdt_probe() to
    be called before acpi_load_tables() on the vast majority of platforms.
    
    Namely, before commit 5a8361f7ecce, acpi_load_tables() was called from
    acpi_early_init() if acpi_gbl_parse_table_as_term_list was FALSE and
    acpi_gbl_group_module_level_code was TRUE, which almost always was
    the case as FALSE and TRUE were their initial values, respectively.
    The acpi_gbl_parse_table_as_term_list value would be changed to TRUE
    for a couple of platforms in acpi_quirks_dmi_table[], but it remained
    FALSE in the vast majority of cases.
    
    After commit 5a8361f7ecce, the initial values of the two flags have
    been reversed, so in effect acpi_load_tables() has not been called
    from acpi_early_init() any more.  That, in turn, affects
    acpi_ec_ecdt_probe() which is invoked before acpi_load_tables() now
    and it is not possible to evaluate the _REG method for the EC address
    space handler installed by it.  That effectively causes the EC address
    space to be inaccessible to AML on platforms with an ECDT matching the
    EC device definition in the DSDT and functional problems ensue in
    there.
    
    Because the default behavior before commit 5a8361f7ecce was to call
    acpi_ec_ecdt_probe() after acpi_load_tables(), it should be safe to
    do that again.  Moreover, the EC address space handler installed by
    acpi_ec_ecdt_probe() is only needed for AML to be able to access the
    EC address space and the only AML that can run during acpi_load_tables()
    is module-level code which only is allowed to access address spaces
    with default handlers (memory, I/O and PCI config space).
    
    For this reason, move the acpi_ec_ecdt_probe() invocation back to
    acpi_bus_init(), from where it was taken away by commit d737f333b211
    (ACPI: probe ECDT before loading AML tables regardless of module-level
    code flag), and put it after the invocation of acpi_load_tables() to
    restore the original code ordering from before commit 5a8361f7ecce.
    
    Fixes: 5a8361f7ecce ("ACPICA: Integrate package handling with module-level code")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=199981
    Reported-by: step-ali <sunmooon15@gmail.com>
    Reported-by: Charles Stanhope <charles.stanhope@gmail.com>
    Tested-by: Charles Stanhope <charles.stanhope@gmail.com>
    Reported-by: Paulo Nascimento <paulo.ulusu@googlemail.com>
    Reported-by: David Purton <dcpurton@marshwiggle.net>
    Reported-by: Adam Harvey <adam@adamharvey.name>
    Reported-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Jean-Marc Lenoir <archlinux@jihemel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 99d820a693a8..5c093ce01bcd 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1054,18 +1054,6 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
-	/*
-	 * ACPI 2.0 requires the EC driver to be loaded and work before
-	 * the EC device is found in the namespace (i.e. before
-	 * acpi_load_tables() is called).
-	 *
-	 * This is accomplished by looking for the ECDT table, and getting
-	 * the EC parameters out of that.
-	 *
-	 * Ignore the result. Not having an ECDT is not fatal.
-	 */
-	status = acpi_ec_ecdt_probe();
-
 #ifdef CONFIG_X86
 	if (!acpi_ioapic) {
 		/* compatible (0) means level (3) */
@@ -1142,6 +1130,18 @@ static int __init acpi_bus_init(void)
 		goto error1;
 	}
 
+	/*
+	 * ACPI 2.0 requires the EC driver to be loaded and work before the EC
+	 * device is found in the namespace.
+	 *
+	 * This is accomplished by looking for the ECDT table and getting the EC
+	 * parameters out of that.
+	 *
+	 * Do that before calling acpi_initialize_objects() which may trigger EC
+	 * address space accesses.
+	 */
+	acpi_ec_ecdt_probe();
+
 	status = acpi_enable_subsystem(ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX

commit 7847a1455fc4574d53e349d60feb1e1106cdc012
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri Nov 9 17:21:35 2018 +0300

    ACPI / glue: Add acpi_platform_notify() function
    
    Instead of relying on the "platform_notify" callback hook,
    introducing separate notification function
    acpi_platform_notify() and calling that directly from
    drivers core when device entries are added and removed.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index bb3d96dea6db..99d820a693a8 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1237,7 +1237,6 @@ static int __init acpi_init(void)
 		acpi_kobj = NULL;
 	}
 
-	init_acpi_device_notify();
 	result = acpi_bus_init();
 	if (result) {
 		disable_acpi();

commit d737f333b211361b6e239fc753b84c3be2634aaa
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Oct 17 15:41:21 2018 -0700

    ACPI: probe ECDT before loading AML tables regardless of module-level code flag
    
    It was discovered that AML tables were loaded before or after the
    ECDT depending on acpi_gbl_execute_tables_as_methods. According to
    the ACPI spec, the ECDT should be loaded before the namespace is
    populated by loading AML tables (DSDT and SSDT). Since the ECDT
    should be loaded early in the boot process, this change moves the
    ECDT probing to acpi_early_init.
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index d2e29a19890d..bb3d96dea6db 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1054,15 +1054,17 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
-	if (!acpi_gbl_execute_tables_as_methods &&
-	    acpi_gbl_group_module_level_code) {
-		status = acpi_load_tables();
-		if (ACPI_FAILURE(status)) {
-			printk(KERN_ERR PREFIX
-			       "Unable to load the System Description Tables\n");
-			goto error0;
-		}
-	}
+	/*
+	 * ACPI 2.0 requires the EC driver to be loaded and work before
+	 * the EC device is found in the namespace (i.e. before
+	 * acpi_load_tables() is called).
+	 *
+	 * This is accomplished by looking for the ECDT table, and getting
+	 * the EC parameters out of that.
+	 *
+	 * Ignore the result. Not having an ECDT is not fatal.
+	 */
+	status = acpi_ec_ecdt_probe();
 
 #ifdef CONFIG_X86
 	if (!acpi_ioapic) {
@@ -1133,25 +1135,11 @@ static int __init acpi_bus_init(void)
 
 	acpi_os_initialize1();
 
-	/*
-	 * ACPI 2.0 requires the EC driver to be loaded and work before
-	 * the EC device is found in the namespace (i.e. before
-	 * acpi_load_tables() is called).
-	 *
-	 * This is accomplished by looking for the ECDT table, and getting
-	 * the EC parameters out of that.
-	 */
-	status = acpi_ec_ecdt_probe();
-	/* Ignore result. Not having an ECDT is not fatal. */
-
-	if (acpi_gbl_execute_tables_as_methods ||
-	    !acpi_gbl_group_module_level_code) {
-		status = acpi_load_tables();
-		if (ACPI_FAILURE(status)) {
-			printk(KERN_ERR PREFIX
-			       "Unable to load the System Description Tables\n");
-			goto error1;
-		}
+	status = acpi_load_tables();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX
+		       "Unable to load the System Description Tables\n");
+		goto error1;
 	}
 
 	status = acpi_enable_subsystem(ACPI_NO_ACPI_ENABLE);

commit 5d128fbd8b20f8a48cb13c3eced789d1f9573ecd
Author: Jean Delvare <jdelvare@suse.de>
Date:   Tue Sep 4 14:55:26 2018 +0200

    ACPI / bus: Only call dmi_check_system() on X86
    
    Calling dmi_check_system() early only works on X86. Other
    architectures initialize the DMI subsystem later so it's not
    ready yet when ACPI itself gets initialized.
    
    In the best case it results in a useless call to a function which
    will do nothing. But depending on the dmi implementation, it could
    also result in warnings. Best is to not call the function when it
    can't work and isn't needed.
    
    Additionally, if anyone ever needs to add non-x86 quirks, it would
    surprisingly not work, so document the limitation to avoid confusion.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Fixes: cce4f632db20 (ACPI: fix early DSDT dmi check warnings on ia64)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 292088fcc624..d2e29a19890d 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -35,11 +35,11 @@
 #include <linux/delay.h>
 #ifdef CONFIG_X86
 #include <asm/mpspec.h>
+#include <linux/dmi.h>
 #endif
 #include <linux/acpi_iort.h>
 #include <linux/pci.h>
 #include <acpi/apei.h>
-#include <linux/dmi.h>
 #include <linux/suspend.h>
 
 #include "internal.h"
@@ -82,10 +82,6 @@ static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	},
 	{}
 };
-#else
-static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
-	{}
-};
 #endif
 
 /* --------------------------------------------------------------------------
@@ -1033,11 +1029,16 @@ void __init acpi_early_init(void)
 
 	acpi_permanent_mmap = true;
 
+#ifdef CONFIG_X86
 	/*
 	 * If the machine falls into the DMI check table,
-	 * DSDT will be copied to memory
+	 * DSDT will be copied to memory.
+	 * Note that calling dmi_check_system() here on other architectures
+	 * would not be OK because only x86 initializes dmi early enough.
+	 * Thankfully only x86 systems need such quirks for now.
 	 */
 	dmi_check_system(dsdt_dmi_table);
+#endif
 
 	status = acpi_reallocate_root_table();
 	if (ACPI_FAILURE(status)) {

commit 67fbd0a3a802bc80218f6c33d594f34f0ecb02f9
Author: Tom Todd <thomas.m.a.todd@gmail.com>
Date:   Wed Aug 8 01:52:02 2018 +0100

    ACPI: bus: Fix a pointer coding style issue
    
    Fix white space in the argument list of acpi_device_remove().
    
    Signed-off-by: Tom Todd <thomas.m.a.todd@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index f61f8927d843..292088fcc624 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -935,7 +935,7 @@ static int acpi_device_probe(struct device *dev)
 	return 0;
 }
 
-static int acpi_device_remove(struct device * dev)
+static int acpi_device_remove(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = acpi_dev->driver;

commit ae976358cd7b0272ccfbd2517edaf0d46f2a356b
Author: Kai Heng Feng <kai.heng.feng@canonical.com>
Date:   Thu Jul 19 19:00:30 2018 +0800

    Revert "ACPI / bus: Parse tables as term_list for Dell XPS 9570 and Precision M5530"
    
    Reverts commit 36904703aeee (ACPI / bus: Parse tables as term_list
    for Dell XPS 9570 and Precision M5530).
    
    Since commit 5a8361f7ecce (ACPICA: Integrate package handling with
    module-level code), acpi_gbl_execute_tables_as_methods is always
    true, so we can remove the quirk for XPS 9570/Precision M5530.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 84b4a62018eb..f61f8927d843 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -66,37 +66,10 @@ static int set_copy_dsdt(const struct dmi_system_id *id)
 	return 0;
 }
 #endif
-static int set_gbl_term_list(const struct dmi_system_id *id)
-{
-	acpi_gbl_execute_tables_as_methods = 1;
-	return 0;
-}
 
-static const struct dmi_system_id acpi_quirks_dmi_table[] __initconst = {
-	/*
-	 * Touchpad on Dell XPS 9570/Precision M5530 doesn't work under I2C
-	 * mode.
-	 * https://bugzilla.kernel.org/show_bug.cgi?id=198515
-	 */
-	{
-		.callback = set_gbl_term_list,
-		.ident = "Dell Precision M5530",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Precision M5530"),
-		},
-	},
-	{
-		.callback = set_gbl_term_list,
-		.ident = "Dell XPS 15 9570",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "XPS 15 9570"),
-		},
-	},
+static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	/*
 	 * Invoke DSDT corruption work-around on all Toshiba Satellite.
-	 * DSDT will be copied to memory.
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
 	 */
 	{
@@ -110,7 +83,7 @@ static const struct dmi_system_id acpi_quirks_dmi_table[] __initconst = {
 	{}
 };
 #else
-static const struct dmi_system_id acpi_quirks_dmi_table[] __initconst = {
+static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	{}
 };
 #endif
@@ -1060,8 +1033,11 @@ void __init acpi_early_init(void)
 
 	acpi_permanent_mmap = true;
 
-	/* Check machine-specific quirks */
-	dmi_check_system(acpi_quirks_dmi_table);
+	/*
+	 * If the machine falls into the DMI check table,
+	 * DSDT will be copied to memory
+	 */
+	dmi_check_system(dsdt_dmi_table);
 
 	status = acpi_reallocate_root_table();
 	if (ACPI_FAILURE(status)) {

commit e7d970f6fca8bc7b9587f77bf8b11fa78abd9280
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Mar 14 16:13:06 2018 -0700

    ACPICA: Rename a global for clarity, no functional change
    
    Was acpi_gbl_parse_table_as_term_list, changed to:
    acpi_gbl_execute_tables_as_methods.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 0dad0bd9327b..84b4a62018eb 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -68,7 +68,7 @@ static int set_copy_dsdt(const struct dmi_system_id *id)
 #endif
 static int set_gbl_term_list(const struct dmi_system_id *id)
 {
-	acpi_gbl_parse_table_as_term_list = 1;
+	acpi_gbl_execute_tables_as_methods = 1;
 	return 0;
 }
 
@@ -1077,7 +1077,7 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
-	if (!acpi_gbl_parse_table_as_term_list &&
+	if (!acpi_gbl_execute_tables_as_methods &&
 	    acpi_gbl_group_module_level_code) {
 		status = acpi_load_tables();
 		if (ACPI_FAILURE(status)) {
@@ -1167,7 +1167,7 @@ static int __init acpi_bus_init(void)
 	status = acpi_ec_ecdt_probe();
 	/* Ignore result. Not having an ECDT is not fatal. */
 
-	if (acpi_gbl_parse_table_as_term_list ||
+	if (acpi_gbl_execute_tables_as_methods ||
 	    !acpi_gbl_group_module_level_code) {
 		status = acpi_load_tables();
 		if (ACPI_FAILURE(status)) {

commit 67dcc26d208ca5578f08c3c78cb254418c24e9ec
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 9 17:38:36 2018 +0200

    device property: Constify device_get_match_data()
    
    Constify device_get_match_data() as OF and ACPI variants return
    constant value.
    
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e6285b5ce0d5..0dad0bd9327b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -830,7 +830,7 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);
 
-void *acpi_device_get_match_data(const struct device *dev)
+const void *acpi_device_get_match_data(const struct device *dev)
 {
 	const struct acpi_device_id *match;
 
@@ -838,7 +838,7 @@ void *acpi_device_get_match_data(const struct device *dev)
 	if (!match)
 		return NULL;
 
-	return (void *)match->driver_data;
+	return (const void *)match->driver_data;
 }
 EXPORT_SYMBOL_GPL(acpi_device_get_match_data);
 

commit 29d5325a14ab49375476e3a6442ff40a008a8c9a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 9 17:38:35 2018 +0200

    ACPI / bus: Rename acpi_get_match_data() to acpi_device_get_match_data()
    
    Do the renaming to be consistent with its sibling, i.e.
    of_device_get_match_data().
    
    No functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ca4af098b1bf..e6285b5ce0d5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -830,7 +830,7 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);
 
-void *acpi_get_match_data(const struct device *dev)
+void *acpi_device_get_match_data(const struct device *dev)
 {
 	const struct acpi_device_id *match;
 
@@ -840,7 +840,7 @@ void *acpi_get_match_data(const struct device *dev)
 
 	return (void *)match->driver_data;
 }
-EXPORT_SYMBOL_GPL(acpi_get_match_data);
+EXPORT_SYMBOL_GPL(acpi_device_get_match_data);
 
 int acpi_match_device_ids(struct acpi_device *device,
 			  const struct acpi_device_id *ids)

commit 8ff277c5bf87d750a44a656d4f113462493acbfc
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 9 17:38:34 2018 +0200

    ACPI / bus: Remove checks in acpi_get_match_data()
    
    As well as its sibling of_device_get_match_data() has no such checks,
    no need to do it in acpi_get_match_data().
    
    First of all, we are not supposed to call fwnode API like this without
    driver attached.
    
    Second, since __acpi_match_device() does check input parameter there is
    no need to duplicate it outside.
    
    And last but not least one, the API should still serve the cases when
    ACPI device is enumerated via PRP0001. In such case driver has neither
    ACPI table nor driver data there.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index f1384e107eed..ca4af098b1bf 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -834,12 +834,6 @@ void *acpi_get_match_data(const struct device *dev)
 {
 	const struct acpi_device_id *match;
 
-	if (!dev->driver)
-		return NULL;
-
-	if (!dev->driver->acpi_match_table)
-		return NULL;
-
 	match = acpi_match_device(dev->driver->acpi_match_table, dev);
 	if (!match)
 		return NULL;

commit 4222f38ca3b7ae30ace582077677cec8b88fac36
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 9 17:38:33 2018 +0200

    ACPI / bus: Do not traverse through non-existed device table
    
    When __acpi_match_device() is called it would be possible to have
    ACPI ID table a NULL pointer. To avoid potential dereference,
    check for this before traverse.
    
    While here, remove redundant 'else'.
    
    Note, this patch implies a bit of refactoring acpi_of_match_device()
    to return pointer to OF ID when matched followed by refactoring
    __acpi_match_device() to return either ACPI or OF ID when matches.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 676c9788e1c8..f1384e107eed 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -660,13 +660,15 @@ struct acpi_device *acpi_companion_match(const struct device *dev)
  * acpi_of_match_device - Match device object using the "compatible" property.
  * @adev: ACPI device object to match.
  * @of_match_table: List of device IDs to match against.
+ * @of_id: OF ID if matched
  *
  * If @dev has an ACPI companion which has ACPI_DT_NAMESPACE_HID in its list of
  * identifiers and a _DSD object with the "compatible" property, use that
  * property to match against the given list of identifiers.
  */
 static bool acpi_of_match_device(struct acpi_device *adev,
-				 const struct of_device_id *of_match_table)
+				 const struct of_device_id *of_match_table,
+				 const struct of_device_id **of_id)
 {
 	const union acpi_object *of_compatible, *obj;
 	int i, nval;
@@ -690,8 +692,11 @@ static bool acpi_of_match_device(struct acpi_device *adev,
 		const struct of_device_id *id;
 
 		for (id = of_match_table; id->compatible[0]; id++)
-			if (!strcasecmp(obj->string.pointer, id->compatible))
+			if (!strcasecmp(obj->string.pointer, id->compatible)) {
+				if (of_id)
+					*of_id = id;
 				return true;
+			}
 	}
 
 	return false;
@@ -762,10 +767,11 @@ static bool __acpi_match_device_cls(const struct acpi_device_id *id,
 	return true;
 }
 
-static const struct acpi_device_id *__acpi_match_device(
-	struct acpi_device *device,
-	const struct acpi_device_id *ids,
-	const struct of_device_id *of_ids)
+static bool __acpi_match_device(struct acpi_device *device,
+				const struct acpi_device_id *acpi_ids,
+				const struct of_device_id *of_ids,
+				const struct acpi_device_id **acpi_id,
+				const struct of_device_id **of_id)
 {
 	const struct acpi_device_id *id;
 	struct acpi_hardware_id *hwid;
@@ -775,30 +781,32 @@ static const struct acpi_device_id *__acpi_match_device(
 	 * driver for it.
 	 */
 	if (!device || !device->status.present)
-		return NULL;
+		return false;
 
 	list_for_each_entry(hwid, &device->pnp.ids, list) {
 		/* First, check the ACPI/PNP IDs provided by the caller. */
-		for (id = ids; id->id[0] || id->cls; id++) {
-			if (id->id[0] && !strcmp((char *) id->id, hwid->id))
-				return id;
-			else if (id->cls && __acpi_match_device_cls(id, hwid))
-				return id;
+		if (acpi_ids) {
+			for (id = acpi_ids; id->id[0] || id->cls; id++) {
+				if (id->id[0] && !strcmp((char *)id->id, hwid->id))
+					goto out_acpi_match;
+				if (id->cls && __acpi_match_device_cls(id, hwid))
+					goto out_acpi_match;
+			}
 		}
 
 		/*
 		 * Next, check ACPI_DT_NAMESPACE_HID and try to match the
 		 * "compatible" property if found.
-		 *
-		 * The id returned by the below is not valid, but the only
-		 * caller passing non-NULL of_ids here is only interested in
-		 * whether or not the return value is NULL.
 		 */
-		if (!strcmp(ACPI_DT_NAMESPACE_HID, hwid->id)
-		    && acpi_of_match_device(device, of_ids))
-			return id;
+		if (!strcmp(ACPI_DT_NAMESPACE_HID, hwid->id))
+			return acpi_of_match_device(device, of_ids, of_id);
 	}
-	return NULL;
+	return false;
+
+out_acpi_match:
+	if (acpi_id)
+		*acpi_id = id;
+	return true;
 }
 
 /**
@@ -815,7 +823,10 @@ static const struct acpi_device_id *__acpi_match_device(
 const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 					       const struct device *dev)
 {
-	return __acpi_match_device(acpi_companion_match(dev), ids, NULL);
+	const struct acpi_device_id *id = NULL;
+
+	__acpi_match_device(acpi_companion_match(dev), ids, NULL, &id, NULL);
+	return id;
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);
 
@@ -840,7 +851,7 @@ EXPORT_SYMBOL_GPL(acpi_get_match_data);
 int acpi_match_device_ids(struct acpi_device *device,
 			  const struct acpi_device_id *ids)
 {
-	return __acpi_match_device(device, ids, NULL) ? 0 : -ENOENT;
+	return __acpi_match_device(device, ids, NULL, NULL, NULL) ? 0 : -ENOENT;
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 
@@ -849,10 +860,12 @@ bool acpi_driver_match_device(struct device *dev,
 {
 	if (!drv->acpi_match_table)
 		return acpi_of_match_device(ACPI_COMPANION(dev),
-					    drv->of_match_table);
+					    drv->of_match_table,
+					    NULL);
 
-	return !!__acpi_match_device(acpi_companion_match(dev),
-				     drv->acpi_match_table, drv->of_match_table);
+	return __acpi_match_device(acpi_companion_match(dev),
+				   drv->acpi_match_table, drv->of_match_table,
+				   NULL, NULL);
 }
 EXPORT_SYMBOL_GPL(acpi_driver_match_device);
 

commit 54ce685cae30c106f062d714c11e644ab1b93b51
Merge: a051c14b8db3 d4abd46b7e72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 9 09:44:25 2018 -0800

    Merge tag 'acpi-part2-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups, a few new quirks, a couple of
      updates related to the handling of ACPI tables and ACPICA copyrights
      refreshment.
    
      Specifics:
    
       - Update the ACPICA kernel code to upstream revision 20180105
         including:
           * Assorted fixes (Jung-uk Kim)
           * Support for X32 ABI compilation (Anuj Mittal)
           * Update of ACPICA copyrights to 2018 (Bob Moore)
    
       - Prepare for future modifications to avoid executing the _STA
         control method too early (Hans de Goede)
    
       - Make the processor performance control library code ignore _PPC
         notifications if they cannot be handled and fix up the C1 idle
         state definition when it is used as a fallback state (Chen Yu,
         Yazen Ghannam)
    
       - Make it possible to use the SPCR table on x86 and to replace the
         original IORT table with a new one from initrd (Prarit Bhargava,
         Shunyong Yang)
    
       - Add battery-related quirks for Asus UX360UA and UX410UAK and add
         quirks for table parsing on Dell XPS 9570 and Precision M5530 (Kai
         Heng Feng)
    
       - Address static checker warnings in the CPPC code (Gustavo Silva)
    
       - Avoid printing a raw pointer to the kernel log in the smart battery
         driver (Greg Kroah-Hartman)"
    
    * tag 'acpi-part2-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: sbshc: remove raw pointer from printk() message
      ACPI: SPCR: Make SPCR available to x86
      ACPI / CPPC: Use 64-bit arithmetic instead of 32-bit
      ACPI / tables: Add IORT to injectable table list
      ACPI / bus: Parse tables as term_list for Dell XPS 9570 and Precision M5530
      ACPICA: Update version to 20180105
      ACPICA: All acpica: Update copyrights to 2018
      ACPI / processor: Set default C1 idle state description
      ACPI / battery: Add quirk for Asus UX360UA and UX410UAK
      ACPI: processor_perflib: Do not send _PPC change notification if not ready
      ACPI / scan: Use acpi_bus_get_status() to initialize ACPI_TYPE_DEVICE devs
      ACPI / bus: Do not call _STA on battery devices with unmet dependencies
      PCI: acpiphp_ibm: prepare for acpi_get_object_info() no longer returning status
      ACPI: export acpi_bus_get_status_handle()
      ACPICA: Add a missing pair of parentheses
      ACPICA: Prefer ACPI_TO_POINTER() over ACPI_ADD_PTR()
      ACPICA: Avoid NULL pointer arithmetic
      ACPICA: Linux: add support for X32 ABI compilation
      ACPI / video: Use true for boolean value

commit 36904703aeeeb6cd31993f1353c8325006229f9a
Author: Kai Heng Feng <kai.heng.feng@canonical.com>
Date:   Mon Feb 5 13:19:24 2018 +0800

    ACPI / bus: Parse tables as term_list for Dell XPS 9570 and Precision M5530
    
    The i2c touchpad on Dell XPS 9570 and Precision M5530 doesn't work out
    of box.
    
    The touchpad relies on its _INI method to update its _HID value from
    XXXX0000 to SYNA2393.
    
    Also, the _STA relies on value of I2CN to report correct status.
    
    Set acpi_gbl_parse_table_as_term_list so the value of I2CN can be
    correctly set up, and _INI can get run. The ACPI table in this machine
    is designed to get parsed this way.
    
    Also, change the quirk table to a more generic name.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198515
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 433bb5a3f327..5c00e5e18da8 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -66,10 +66,37 @@ static int set_copy_dsdt(const struct dmi_system_id *id)
 	return 0;
 }
 #endif
+static int set_gbl_term_list(const struct dmi_system_id *id)
+{
+	acpi_gbl_parse_table_as_term_list = 1;
+	return 0;
+}
 
-static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
+static const struct dmi_system_id acpi_quirks_dmi_table[] __initconst = {
+	/*
+	 * Touchpad on Dell XPS 9570/Precision M5530 doesn't work under I2C
+	 * mode.
+	 * https://bugzilla.kernel.org/show_bug.cgi?id=198515
+	 */
+	{
+		.callback = set_gbl_term_list,
+		.ident = "Dell Precision M5530",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Precision M5530"),
+		},
+	},
+	{
+		.callback = set_gbl_term_list,
+		.ident = "Dell XPS 15 9570",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "XPS 15 9570"),
+		},
+	},
 	/*
 	 * Invoke DSDT corruption work-around on all Toshiba Satellite.
+	 * DSDT will be copied to memory.
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
 	 */
 	{
@@ -83,7 +110,7 @@ static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	{}
 };
 #else
-static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
+static const struct dmi_system_id acpi_quirks_dmi_table[] __initconst = {
 	{}
 };
 #endif
@@ -1008,11 +1035,8 @@ void __init acpi_early_init(void)
 
 	acpi_permanent_mmap = true;
 
-	/*
-	 * If the machine falls into the DMI check table,
-	 * DSDT will be copied to memory
-	 */
-	dmi_check_system(dsdt_dmi_table);
+	/* Check machine-specific quirks */
+	dmi_check_system(acpi_quirks_dmi_table);
 
 	status = acpi_reallocate_root_table();
 	if (ACPI_FAILURE(status)) {

commit 54ddce7062242036402242242c07c60c0b505f84
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jan 26 16:02:58 2018 +0100

    ACPI / bus: Do not call _STA on battery devices with unmet dependencies
    
    The battery code uses acpi_device->dep_unmet to check for unmet deps and
    if there are unmet deps it does not bind to the device to avoid errors
    about missing OpRegions when calling ACPI methods on the device.
    
    The missing OpRegions when there are unmet deps problem also applies to
    the _STA method of some battery devices and calling it too early results
    in errors like these:
    
    [    0.123579] ACPI Error: No handler for Region [ECRM] (00000000ba9edc4c)
                   [GenericSerialBus] (20170831/evregion-166)
    [    0.123601] ACPI Error: Region GenericSerialBus (ID=9) has no handler
                   (20170831/exfldio-299)
    [    0.123618] ACPI Error: Method parse/execution failed
                   \_SB.I2C1.BAT1._STA, AE_NOT_EXIST (20170831/psparse-550)
    
    This commit fixes these errors happening when acpi_get_bus_status gets
    called by checking dep_unmet for battery devices and reporting a status
    of 0 until all dependencies are met.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index d44d2c287b91..433bb5a3f327 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -120,6 +120,12 @@ int acpi_bus_get_status(struct acpi_device *device)
 		return 0;
 	}
 
+	/* Battery devices must have their deps met before calling _STA */
+	if (acpi_device_is_battery(device) && device->dep_unmet) {
+		acpi_set_device_status(device, 0);
+		return 0;
+	}
+
 	status = acpi_bus_get_status_handle(device->handle, &sta);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;

commit 5a98231f554779fb1649f477b70bed1fd17222f2
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jan 26 16:02:56 2018 +0100

    ACPI: export acpi_bus_get_status_handle()
    
    Some modular drivers need this, export it.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 4d0979e02a28..d44d2c287b91 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -108,6 +108,7 @@ acpi_status acpi_bus_get_status_handle(acpi_handle handle,
 	}
 	return status;
 }
+EXPORT_SYMBOL_GPL(acpi_bus_get_status_handle);
 
 int acpi_bus_get_status(struct acpi_device *device)
 {

commit 80212a162329e590fde02d8457af16ea0ab0a55f
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Dec 13 02:20:48 2017 -0500

    ACPI / bus: Introduce acpi_get_match_data() function
    
    OF has of_device_get_match_data() function to extract driver specific data
    structure. Add a similar function for ACPI.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 4d0979e02a28..f87ed3be779a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -785,6 +785,24 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);
 
+void *acpi_get_match_data(const struct device *dev)
+{
+	const struct acpi_device_id *match;
+
+	if (!dev->driver)
+		return NULL;
+
+	if (!dev->driver->acpi_match_table)
+		return NULL;
+
+	match = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (!match)
+		return NULL;
+
+	return (void *)match->driver_data;
+}
+EXPORT_SYMBOL_GPL(acpi_get_match_data);
+
 int acpi_match_device_ids(struct acpi_device *device,
 			  const struct acpi_device_id *ids)
 {

commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 14 11:59:30 2017 +0200

    dmi: Mark all struct dmi_system_id instances const
    
    ... and __initconst if applicable.
    
    Based on similar work for an older kernel in the Grsecurity patch.
    
    [JD: fix toshiba-wmi build]
    [JD: add htcpen]
    [JD: move __initconst where checkscript wants it]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 59f2f96fdb7e..4d0979e02a28 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -67,7 +67,7 @@ static int set_copy_dsdt(const struct dmi_system_id *id)
 }
 #endif
 
-static struct dmi_system_id dsdt_dmi_table[] __initdata = {
+static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	/*
 	 * Invoke DSDT corruption work-around on all Toshiba Satellite.
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
@@ -83,7 +83,7 @@ static struct dmi_system_id dsdt_dmi_table[] __initdata = {
 	{}
 };
 #else
-static struct dmi_system_id dsdt_dmi_table[] __initdata = {
+static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	{}
 };
 #endif

commit 023e2ee16c51da7f6a9455ac936e4fb00295f47a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 10 15:23:45 2017 +0800

    ACPICA: Tables: Change table duplication check to be related to acpi_gbl_verify_table_checksum
    
    ACPICA commit 3d837b5d4b1033942b4d91c7d3801a09c3157918
    
    acpi_gbl_verify_table_checksum is used to avoid validating (mapping) an entire
    table in OS boot stage. 2nd "Reload" check in acpi_tb_install_standard_table()
    is prepared for the same purpose. So this patch combines them together
    using a renamed acpi_gbl_enable_table_validation flag. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/3d837b5d
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index af74b420ec83..59f2f96fdb7e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -995,9 +995,6 @@ void __init acpi_early_init(void)
 
 	printk(KERN_INFO PREFIX "Core revision %08x\n", ACPI_CA_VERSION);
 
-	/* It's safe to verify table checksums during late stage */
-	acpi_gbl_verify_table_checksum = TRUE;
-
 	/* enable workarounds, unless strict ACPI spec. compliance */
 	if (!acpi_strict)
 		acpi_gbl_enable_interpreter_slack = TRUE;

commit f19e80b394808ed763e2669b08aea480adcc46be
Merge: eceeae414edc 79a648328d2a 5438bc573a2c 9a4d8d60df3b d429e5c12269 9e4de6a8eee2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 10 22:46:21 2017 +0200

    Merge branches 'acpi-spcr', 'acpi-osi', 'acpi-bus', 'acpi-scan' and 'acpi-misc'
    
    * acpi-spcr:
      ACPI: SPCR: Workaround for APM X-Gene 8250 UART 32-alignment errata
      ACPI: SPCR: Use access width to determine mmio usage
    
    * acpi-osi:
      ACPI / osi: Make local function acpi_osi_dmi_linux() static
    
    * acpi-bus:
      ACPI / bus: handle ACPI hotplug schedule errors completely
    
    * acpi-scan:
      ACPI / scan: Indicate to platform when hot remove returns busy
    
    * acpi-misc:
      ACPI / DPTF: constify attribute_group structures
      ACPI / LPSS: constify attribute_group structures
      ACPI: BGRT: constify attribute_group structures
      ACPI / power: constify attribute_group structures

commit 9a4d8d60df3bc26236fa9cc3bc806ff99e5e5625
Author: Lee, Chun-Yi <joeyli.kernel@gmail.com>
Date:   Fri Jun 30 15:25:38 2017 +0800

    ACPI / bus: handle ACPI hotplug schedule errors completely
    
    Kernel should decrements the reference count of ACPI device
    when the scheduling of ACPI hotplug work failed, and evaluates
    _OST to notify BIOS the failure.
    
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: "Lee, Chun-Yi" <jlee@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 784bda663d16..9d4fea6433f5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -432,11 +432,15 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
 		driver->ops.notify(adev, type);
 
-	if (hotplug_event && ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
+	if (!hotplug_event) {
+		acpi_bus_put_acpi_device(adev);
+		return;
+	}
+
+	if (ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
 		return;
 
 	acpi_bus_put_acpi_device(adev);
-	return;
 
  err:
 	acpi_evaluate_ost(handle, type, ost_code, NULL);

commit 94116f8126de9762751fd92731581b73b56292e5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jun 5 19:40:46 2017 +0300

    ACPI: Switch to use generic guid_t in acpi_evaluate_dsm()
    
    acpi_evaluate_dsm() and friends take a pointer to a raw buffer of 16
    bytes. Instead we convert them to use guid_t type. At the same time we
    convert current users.
    
    acpi_str_to_uuid() becomes useless after the conversion and it's safe to
    get rid of it.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Yisen Zhuang <yisen.zhuang@huawei.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 042cd16265b3..5a6fbe0fcaf2 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -196,29 +196,6 @@ static void acpi_print_osc_error(acpi_handle handle,
 	pr_debug("\n");
 }
 
-acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
-{
-	int i;
-	static int opc_map_to_uuid[16] = {6, 4, 2, 0, 11, 9, 16, 14, 19, 21,
-		24, 26, 28, 30, 32, 34};
-
-	if (strlen(str) != 36)
-		return AE_BAD_PARAMETER;
-	for (i = 0; i < 36; i++) {
-		if (i == 8 || i == 13 || i == 18 || i == 23) {
-			if (str[i] != '-')
-				return AE_BAD_PARAMETER;
-		} else if (!isxdigit(str[i]))
-			return AE_BAD_PARAMETER;
-	}
-	for (i = 0; i < 16; i++) {
-		uuid[i] = hex_to_bin(str[opc_map_to_uuid[i]]) << 4;
-		uuid[i] |= hex_to_bin(str[opc_map_to_uuid[i] + 1]);
-	}
-	return AE_OK;
-}
-EXPORT_SYMBOL_GPL(acpi_str_to_uuid);
-
 acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 {
 	acpi_status status;

commit dfcaad8faeec3208bb1905ca3c1e4fd4cef46113
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jun 5 19:40:44 2017 +0300

    ACPI / bus: Switch to use new generic UUID API
    
    There are new types and helpers that are supposed to be used in new code.
    
    As a preparation to get rid of legacy types and API functions do
    the conversion here.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 784bda663d16..042cd16265b3 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -225,13 +225,13 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 	struct acpi_object_list input;
 	union acpi_object in_params[4];
 	union acpi_object *out_obj;
-	u8 uuid[16];
+	guid_t guid;
 	u32 errors;
 	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
 
 	if (!context)
 		return AE_ERROR;
-	if (ACPI_FAILURE(acpi_str_to_uuid(context->uuid_str, uuid)))
+	if (guid_parse(context->uuid_str, &guid))
 		return AE_ERROR;
 	context->ret.length = ACPI_ALLOCATE_BUFFER;
 	context->ret.pointer = NULL;
@@ -241,7 +241,7 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 	input.pointer = in_params;
 	in_params[0].type 		= ACPI_TYPE_BUFFER;
 	in_params[0].buffer.length 	= 16;
-	in_params[0].buffer.pointer	= uuid;
+	in_params[0].buffer.pointer	= (u8 *)&guid;
 	in_params[1].type 		= ACPI_TYPE_INTEGER;
 	in_params[1].integer.value 	= context->rev;
 	in_params[2].type 		= ACPI_TYPE_INTEGER;

commit b7ecf663c75eed1e764f57281f9508c49c18516e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Apr 21 12:47:40 2017 +0200

    ACPI / bus: Introduce a list of ids for "always present" devices
    
    Several Bay / Cherry Trail devices (all of which ship with Windows 10) hide
    the LPSS PWM controller in ACPI, typically the _STA method looks like this:
    
        Method (_STA, 0, NotSerialized)  // _STA: Status
        {
            If (OSID == One)
            {
                Return (Zero)
            }
    
            Return (0x0F)
        }
    
    Where OSID is some dark magic seen in all Cherry Trail ACPI tables making
    the machine behave differently depending on which OS it *thinks* it is
    booting, this gets set in a number of ways which we cannot control, on
    some newer machines it simple hardcoded to "One" aka win10.
    
    This causes the PWM controller to get hidden, which means Linux cannot
    control the backlight level on cht based tablets / laptops.
    
    Since loading the driver for this does no harm (the only in kernel user
    of it is the i915 driver, which will only uses it when it needs it), this
    commit makes acpi_bus_get_status() always set status to ACPI_STA_DEFAULT
    for the LPSS PWM device, fixing the lack of backlight control.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    [ rjw: Rename the new file to utils.c ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 34fbe027e73a..784bda663d16 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -114,6 +114,11 @@ int acpi_bus_get_status(struct acpi_device *device)
 	acpi_status status;
 	unsigned long long sta;
 
+	if (acpi_device_always_present(device)) {
+		acpi_set_device_status(device, ACPI_STA_DEFAULT);
+		return 0;
+	}
+
 	status = acpi_bus_get_status_handle(device->handle, &sta);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;

commit c962cff17dfa11f4a8227ac16de2b28aea3312e4
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Fri Mar 3 16:02:23 2017 +0800

    Revert "x86/acpi: Set persistent cpuid <-> nodeid mapping when booting"
    
    Revert: dc6db24d2476 ("x86/acpi: Set persistent cpuid <-> nodeid mapping when booting")
    
    The mapping of "cpuid <-> nodeid" is established at boot time via ACPI
    tables to keep associations of workqueues and other node related items
    consistent across cpu hotplug.
    
    But, ACPI tables are unreliable and failures with that boot time mapping
    have been reported on machines where the ACPI table and the physical
    information which is retrieved at actual hotplug is inconsistent.
    
    Revert the mapping implementation so it can be replaced with a less error
    prone approach.
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Tested-by: Xiaolong Ye <xiaolong.ye@intel.com>
    Cc: rjw@rjwysocki.net
    Cc: linux-acpi@vger.kernel.org
    Cc: guzheng1@huawei.com
    Cc: izumi.taku@jp.fujitsu.com
    Cc: lenb@kernel.org
    Link: http://lkml.kernel.org/r/1488528147-2279-2-git-send-email-douly.fnst@cn.fujitsu.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 80cb5eb75b63..34fbe027e73a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1249,7 +1249,6 @@ static int __init acpi_init(void)
 	acpi_wakeup_device_init();
 	acpi_debugger_init();
 	acpi_setup_sb_notify_handler();
-	acpi_set_processor_mapping();
 	return 0;
 }
 

commit 51ede5d9668f14d57ea6ba6eaa1b11d5b8ed2780
Author: Dan O'Donovan <dan@emutex.com>
Date:   Sun Feb 5 16:30:12 2017 +0000

    ACPI / bus: Introduce acpi_of_modalias() equiv of of_modalias_node()
    
    When using devicetree stuff like i2c_client.name or spi_device.modalias
    is initialized to the first DT compatible id with the vendor prefix
    stripped. Since some drivers rely on this try to replicate it when using
    ACPI with DT ids.
    
    Signed-off-by: Dan O'Donovan <dan@emutex.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 95855cb9d6fb..80cb5eb75b63 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -677,6 +677,48 @@ static bool acpi_of_match_device(struct acpi_device *adev,
 	return false;
 }
 
+static bool acpi_of_modalias(struct acpi_device *adev,
+			     char *modalias, size_t len)
+{
+	const union acpi_object *of_compatible;
+	const union acpi_object *obj;
+	const char *str, *chr;
+
+	of_compatible = adev->data.of_compatible;
+	if (!of_compatible)
+		return false;
+
+	if (of_compatible->type == ACPI_TYPE_PACKAGE)
+		obj = of_compatible->package.elements;
+	else /* Must be ACPI_TYPE_STRING. */
+		obj = of_compatible;
+
+	str = obj->string.pointer;
+	chr = strchr(str, ',');
+	strlcpy(modalias, chr ? chr + 1 : str, len);
+
+	return true;
+}
+
+/**
+ * acpi_set_modalias - Set modalias using "compatible" property or supplied ID
+ * @adev:	ACPI device object to match
+ * @default_id:	ID string to use as default if no compatible string found
+ * @modalias:   Pointer to buffer that modalias value will be copied into
+ * @len:	Length of modalias buffer
+ *
+ * This is a counterpart of of_modalias_node() for struct acpi_device objects.
+ * If there is a compatible string for @adev, it will be copied to @modalias
+ * with the vendor prefix stripped; otherwise, @default_id will be used.
+ */
+void acpi_set_modalias(struct acpi_device *adev, const char *default_id,
+		       char *modalias, size_t len)
+{
+	if (!acpi_of_modalias(adev, modalias, len))
+		strlcpy(modalias, default_id, len);
+}
+EXPORT_SYMBOL_GPL(acpi_set_modalias);
+
 static bool __acpi_match_device_cls(const struct acpi_device_id *id,
 				    struct acpi_hardware_id *hwid)
 {

commit c8e008e2a6f9ec007a0e22e18eeb5bace5bf16c8
Merge: 7ae123edd37a 8d3523fb3b72 7020bcb82838
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 22 14:34:24 2016 +0100

    Merge branches 'acpica' and 'acpi-scan'
    
    * acpica:
      ACPI / osl: Remove deprecated acpi_get_table_with_size()/early_acpi_os_unmap_memory()
      ACPI / osl: Remove acpi_get_table_with_size()/early_acpi_os_unmap_memory() users
      ACPICA: Tables: Allow FADT to be customized with virtual address
      ACPICA: Tables: Back port acpi_get_table_with_size() and early_acpi_os_unmap_memory() from Linux kernel
    
    * acpi-scan:
      ACPI: do not warn if _BQC does not exist

commit 8d3523fb3b727478ac528b307cb84460faa1c39e
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 14 15:04:46 2016 +0800

    ACPI / osl: Remove deprecated acpi_get_table_with_size()/early_acpi_os_unmap_memory()
    
    Since all users are cleaned up, remove the 2 deprecated APIs due to no
    users.
    As a Linux variable rather than an ACPICA variable, acpi_gbl_permanent_mmap
    is renamed to acpi_permanent_mmap to have a consistent coding style across
    entire Linux ACPI subsystem.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 56190d00fd87..77468be75b3c 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -964,7 +964,7 @@ void __init acpi_early_init(void)
 	if (!acpi_strict)
 		acpi_gbl_enable_interpreter_slack = TRUE;
 
-	acpi_gbl_permanent_mmap = 1;
+	acpi_permanent_mmap = true;
 
 	/*
 	 * If the machine falls into the DMI check table,

commit de966cf4a4fa8d4e0357b08204bc791f34deb3fb
Author: Tim Chen <tim.c.chen@linux.intel.com>
Date:   Tue Nov 29 10:43:27 2016 -0800

    sched/x86: Change CONFIG_SCHED_ITMT to CONFIG_SCHED_MC_PRIO
    
    Rename CONFIG_SCHED_ITMT for Intel Turbo Boost Max Technology 3.0
    to CONFIG_SCHED_MC_PRIO.  This makes the configuration extensible
    in future to other architectures that wish to similarly establish
    CPU core priorities support in the scheduler.
    
    The description in Kconfig is updated to reflect this change with
    added details for better clarity.  The configuration is explicitly
    default-y, to enable the feature on CPUs that have this feature.
    
    It has no effect on non-TBM3 CPUs.
    
    Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bp@suse.de
    Cc: jolsa@redhat.com
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Cc: rjw@rjwysocki.net
    Link: http://lkml.kernel.org/r/2b2ee29d93e3f162922d72d0165a1405864fbb23.1480444902.git.tim.c.chen@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 806db0d6e6e8..5cbefd7621f0 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -338,7 +338,7 @@ static void acpi_bus_osc_support(void)
 	}
 #endif
 
-	if (IS_ENABLED(CONFIG_SCHED_ITMT))
+	if (IS_ENABLED(CONFIG_SCHED_MC_PRIO))
 		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPC_DIVERSE_HIGH_SUPPORT;
 
 	if (!ghes_disable)

commit 8b533a0eeefc5861cea57163dd3cec2798a77f6c
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Nov 22 12:23:59 2016 -0800

    acpi/bus: Set _OSC for diverse core support
    
    Set the OSC_SB_CPC_DIVERSE_HIGH_SUPPORT (bit 12) to enable diverse
    core support.
    
    This is required to enable the BIOS support of the Intel Turbo Boost Max
    Technology 3.0 feature.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: linux-pm@vger.kernel.org
    Cc: peterz@infradead.org
    Cc: jolsa@redhat.com
    Cc: rjw@rjwysocki.net
    Cc: linux-acpi@vger.kernel.org
    Cc: bp@suse.de
    Link: http://lkml.kernel.org/r/a023623a727e86040a1715797055f6402caefd7e.1479844244.git.tim.c.chen@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2f381ba1e1f2..806db0d6e6e8 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -338,6 +338,9 @@ static void acpi_bus_osc_support(void)
 	}
 #endif
 
+	if (IS_ENABLED(CONFIG_SCHED_ITMT))
+		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPC_DIVERSE_HIGH_SUPPORT;
+
 	if (!ghes_disable)
 		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_APEI_SUPPORT;
 	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))

commit 5c2832e91a3ed45f35531ae1c5afba8eac22c81f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Nov 22 12:23:58 2016 -0800

    acpi/bus: Enable HWP CPPC objects
    
    Need to set platform wide _OSC bits to enable CPPC and CPPC version 2.
    If platform supports CPPC, then BIOS exposes CPPC tables.
    
    The primary reason to enable CPPC support is to get the maximum
    performance of each CPU to check and enable Intel Turbo Boost Max
    Technology 3.0 (ITMT).
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: linux-pm@vger.kernel.org
    Cc: peterz@infradead.org
    Cc: jolsa@redhat.com
    Cc: rjw@rjwysocki.net
    Cc: linux-acpi@vger.kernel.org
    Cc: bp@suse.de
    Link: http://lkml.kernel.org/r/a696f6b17843cee9a542482fae6abab087be9587.1479844244.git.tim.c.chen@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 56190d00fd87..2f381ba1e1f2 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -331,6 +331,13 @@ static void acpi_bus_osc_support(void)
 	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_HOTPLUG_OST_SUPPORT;
 	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PCLPI_SUPPORT;
 
+#ifdef CONFIG_X86
+	if (boot_cpu_has(X86_FEATURE_HWP)) {
+		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPC_SUPPORT;
+		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPCV2_SUPPORT;
+	}
+#endif
+
 	if (!ghes_disable)
 		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_APEI_SUPPORT;
 	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))

commit 999dcbe2414e15e19cdc1f91497d01f262c6e1cf
Merge: 5e1b834b27fb 4cd13c21b207
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 3 19:10:15 2016 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "The irq departement proudly presents:
    
       - A rework of the core infrastructure to optimally spread interrupt
         for multiqueue devices. The first version was a bit naive and
         failed to take thread siblings and other details into account.
         Developed in cooperation with Christoph and Keith.
    
       - Proper delegation of softirqs to ksoftirqd, so if ksoftirqd is
         active then no further softirq processsing on interrupt return
         happens. Otherwise we try to delegate and still run another batch
         of network packets in the irq return path, which then tries to
         delegate to ksoftirqd .....
    
       - A proper machine parseable sysfs based alternative for
         /proc/interrupts.
    
       - ACPI support for the GICV3-ITS and ARM interrupt remapping
    
       - Two new irq chips from the ARM SoC zoo: STM32-EXTI and MVEBU-PIC
    
       - A new irq chip for the JCore (SuperH)
    
       - The usual pile of small fixlets in core and irqchip drivers"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (42 commits)
      softirq: Let ksoftirqd do its job
      genirq: Make function __irq_do_set_handler() static
      ARM/dts: Add EXTI controller node to stm32f429
      ARM/STM32: Select external interrupts controller
      drivers/irqchip: Add STM32 external interrupts support
      Documentation/dt-bindings: Document STM32 EXTI controller bindings
      irqchip/mips-gic: Use for_each_set_bit to iterate over local IRQs
      pci/msi: Retrieve affinity for a vector
      genirq/affinity: Remove old irq spread infrastructure
      genirq/msi: Switch to new irq spreading infrastructure
      genirq/affinity: Provide smarter irq spreading infrastructure
      genirq/msi: Add cpumask allocation to alloc_msi_entry
      genirq: Expose interrupt information through sysfs
      irqchip/gicv3-its: Use MADT ITS subtable to do PCI/MSI domain initialization
      irqchip/gicv3-its: Factor out PCI-MSI part that might be reused for ACPI
      irqchip/gicv3-its: Probe ITS in the ACPI way
      irqchip/gicv3-its: Refactor ITS DT init code to prepare for ACPI
      irqchip/gicv3-its: Cleanup for ITS domain initialization
      PCI/MSI: Setup MSI domain on a per-device basis using IORT ACPI table
      ACPI: Add new IORT functions to support MSI domain handling
      ...

commit 110a9e42b68719f584879c5c5c727bbae90d15f9
Merge: af79ad2b1f33 eb6296dec19f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 3 15:36:06 2016 -0700

    Merge branch 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 apic updates from Ingo Molnar:
     "The main changes are:
    
       - Persistent CPU/node numbering across CPU hotplug/unplug events.
         This is a pretty involved series of changes that first fetches all
         the information during bootup and then uses it for the various
         hotplug/unplug methods. (Gu Zheng, Dou Liyang)
    
       - IO-APIC hot-add/remove fixes and enhancements. (Rui Wang)
    
       - ... various fixes, cleanups and enhancements"
    
    * 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (22 commits)
      x86/apic: Fix silent & fatal merge conflict in __generic_processor_info()
      acpi: Fix broken error check in map_processor()
      acpi: Validate processor id when mapping the processor
      acpi: Provide mechanism to validate processors in the ACPI tables
      x86/acpi: Set persistent cpuid <-> nodeid mapping when booting
      x86/acpi: Enable MADT APIs to return disabled apicids
      x86/acpi: Introduce persistent storage for cpuid <-> apicid mapping
      x86/acpi: Enable acpi to register all possible cpus at boot time
      x86/numa: Online memory-less nodes at boot time
      x86/apic: Get rid of apic_version[] array
      x86/apic: Order irq_enter/exit() calls correctly vs. ack_APIC_irq()
      x86/ioapic: Ignore root bridges without a companion ACPI device
      x86/apic: Update comment about disabling processor focus
      x86/smpboot: Check APIC ID before setting up default routing
      x86/ioapic: Fix IOAPIC failing to request resource
      x86/ioapic: Fix lost IOAPIC resource after hot-removal and hotadd
      x86/ioapic: Fix setup_res() failing to get resource
      x86/ioapic: Support hot-removal of IOAPICs present during boot
      x86/ioapic: Change prototype of acpi_ioapic_add()
      x86/apic, ACPI: Fix incorrect assignment when handling apic/x2apic entries
      ...

commit 1ef356681ef412abfd93d1c36f15917a126833f5
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Sep 23 11:26:49 2016 +0800

    ACPI / bus: Adjust ACPI subsystem initialization for new table loading mode
    
    This patch enables the following initialization order for the
    new table loading mode (which is enabled by setting
    acpi_gbl_parse_table_as_term_list to TRUE):
    
      1. Install default region handlers (SystemMemory, SystemIo, PciConfig,
         EmbeddedControl via ECDT) without evaluating _REG;
    
      2. Load the table and execute the module level AML opcodes instantly.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 85b7d07fe5c8..658b4c4f169f 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -985,7 +985,8 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
-	if (acpi_gbl_group_module_level_code) {
+	if (!acpi_gbl_parse_table_as_term_list &&
+	    acpi_gbl_group_module_level_code) {
 		status = acpi_load_tables();
 		if (ACPI_FAILURE(status)) {
 			printk(KERN_ERR PREFIX
@@ -1074,7 +1075,8 @@ static int __init acpi_bus_init(void)
 	status = acpi_ec_ecdt_probe();
 	/* Ignore result. Not having an ECDT is not fatal. */
 
-	if (!acpi_gbl_group_module_level_code) {
+	if (acpi_gbl_parse_table_as_term_list ||
+	    !acpi_gbl_group_module_level_code) {
 		status = acpi_load_tables();
 		if (ACPI_FAILURE(status)) {
 			printk(KERN_ERR PREFIX

commit dc6db24d2476cd09c0ecf2b8d80313539f737a89
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Thu Aug 25 16:35:18 2016 +0800

    x86/acpi: Set persistent cpuid <-> nodeid mapping when booting
    
    The whole patch-set aims at making cpuid <-> nodeid mapping persistent. So that,
    when node online/offline happens, cache based on cpuid <-> nodeid mapping such as
    wq_numa_possible_cpumask will not cause any problem.
    It contains 4 steps:
    1. Enable apic registeration flow to handle both enabled and disabled cpus.
    2. Introduce a new array storing all possible cpuid <-> apicid mapping.
    3. Enable _MAT and MADT relative apis to return non-present or disabled cpus' apicid.
    4. Establish all possible cpuid <-> nodeid mapping.
    
    This patch finishes step 4.
    
    This patch set the persistent cpuid <-> nodeid mapping for all enabled/disabled
    processors at boot time via an additional acpi namespace walk for processors.
    
    [ tglx: Remove the unneeded exports ]
    
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Signed-off-by: Zhu Guihua <zhugh.fnst@cn.fujitsu.com>
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: mika.j.penttila@gmail.com
    Cc: len.brown@intel.com
    Cc: rafael@kernel.org
    Cc: rjw@rjwysocki.net
    Cc: yasu.isimatu@gmail.com
    Cc: linux-mm@kvack.org
    Cc: linux-acpi@vger.kernel.org
    Cc: isimatu.yasuaki@jp.fujitsu.com
    Cc: gongzhaogang@inspur.com
    Cc: tj@kernel.org
    Cc: izumi.taku@jp.fujitsu.com
    Cc: cl@linux.com
    Cc: chen.tang@easystack.cn
    Cc: akpm@linux-foundation.org
    Cc: kamezawa.hiroyu@jp.fujitsu.com
    Cc: lenb@kernel.org
    Link: http://lkml.kernel.org/r/1472114120-3281-6-git-send-email-douly.fnst@cn.fujitsu.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 85b7d07fe5c8..a760dac656ea 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1193,6 +1193,7 @@ static int __init acpi_init(void)
 	acpi_wakeup_device_init();
 	acpi_debugger_init();
 	acpi_setup_sb_notify_handler();
+	acpi_set_processor_mapping();
 	return 0;
 }
 

commit 88ef16d888a094587b2ac77de60927df5da5d56d
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Mon Sep 12 20:54:20 2016 +0200

    ACPI: I/O Remapping Table (IORT) initial support
    
    IORT shows representation of IO topology for ARM based systems.
    It describes how various components are connected together on
    parent-child basis e.g. PCI RC -> SMMU -> ITS. Also see IORT spec.
    http://infocenter.arm.com/help/topic/com.arm.doc.den0049b/DEN0049B_IO_Remapping_Table.pdf
    
    Initial support allows to detect IORT table presence and save its
    root pointer obtained through acpi_get_table(). The pointer validity
    depends on acpi_gbl_permanent_mmap because if acpi_gbl_permanent_mmap
    is not set while using IORT nodes we would dereference unmapped pointers.
    
    For the aforementioned reason call acpi_iort_init() from acpi_init()
    which guarantees acpi_gbl_permanent_mmap to be set at that point.
    
    Add generic helpers which are helpful for scanning and retrieving
    information from IORT table content. List of the most important helpers:
    - iort_find_dev_node() finds IORT node for a given device
    - iort_node_map_rid() maps device RID and returns IORT node which provides
      final translation
    
    IORT support is placed under drivers/acpi/arm64/ new directory due to its
    ARM64 specific nature. The code there is considered only for ARM64.
    The long term plan is to keep all ARM64 specific tables support
    in this place e.g. GTDT table.
    
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 85b7d07fe5c8..e56e6438515a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -36,6 +36,7 @@
 #ifdef CONFIG_X86
 #include <asm/mpspec.h>
 #endif
+#include <linux/acpi_iort.h>
 #include <linux/pci.h>
 #include <acpi/apei.h>
 #include <linux/dmi.h>
@@ -1186,6 +1187,7 @@ static int __init acpi_init(void)
 	}
 
 	pci_mmcfg_late_init();
+	acpi_iort_init();
 	acpi_scan_init();
 	acpi_ec_init();
 	acpi_debugfs_init();

commit 6149dffcb54b9de3a42b2ea01bc4f9d38eeff7e0
Merge: f6bc0a168ef9 8fc85c6ad849 866ae696e26e a3e2acc5e37b 2c85025c75df
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 25 13:42:25 2016 +0200

    Merge branches 'acpi-processor', 'acpi-cppc', 'acpi-apei' and 'acpi-sleep'
    
    * acpi-processor:
      ACPI: enable ACPI_PROCESSOR_IDLE on ARM64
      arm64: add support for ACPI Low Power Idle(LPI)
      drivers: firmware: psci: initialise idle states using ACPI LPI
      cpuidle: introduce CPU_PM_CPU_IDLE_ENTER macro for ARM{32, 64}
      arm64: cpuidle: drop __init section marker to arm_cpuidle_init
      ACPI / processor_idle: Add support for Low Power Idle(LPI) states
      ACPI / processor_idle: introduce ACPI_PROCESSOR_CSTATE
    
    * acpi-cppc:
      mailbox: pcc: Add PCC request and free channel declarations
      ACPI / CPPC: Prevent cpc_desc_ptr points to the invalid data
      ACPI: CPPC: Return error if _CPC is invalid on a CPU
    
    * acpi-apei:
      ACPI / APEI: Add Boot Error Record Table (BERT) support
      ACPI / einj: Make error paths more talkative
      ACPI / einj: Convert EINJ_PFX to proper pr_fmt
    
    * acpi-sleep:
      ACPI: Execute _PTS before system reboot

commit 25474279e8fc6f15eebf89f43ac9ceedac475f57
Merge: d5f017b79661 baa0c019b4c6 ffaab0aa2c3e b4219a898f48 1461d8a5a0e4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 25 13:41:25 2016 +0200

    Merge branches 'acpi-bus', 'acpi-pci', 'acpica' and 'acpi-doc'
    
    * acpi-bus:
      ACPI / bus: Support for platform initiated graceful shutdown
      ACPI / bus: Correct the comments about acpi_subsystem_init()
      ACPI / bus: Use acpi_handle_debug() in acpi_print_osc_error()
    
    * acpi-pci:
      ACPI / PCI: make pci_slot explicitly non-modular
      ACPI / PCI: pci_slot: Use generic pr_debug utility
      ACPI / PCI: pci_slot: Use more common logging style
    
    * acpica:
      ACPICA: Linux: Enable ACPI_MUTEX_DEBUG for Linux kernel
    
    * acpi-doc:
      ACPI / debugger: Add AML debugger documentation
      ACPI: Add documentation describing ACPICA release automation

commit a36a7fecfe6071732075ad5aa31196adce13181b
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Thu Jul 21 17:18:07 2016 +0100

    ACPI / processor_idle: Add support for Low Power Idle(LPI) states
    
    ACPI 6.0 introduced an optional object _LPI that provides an alternate
    method to describe Low Power Idle states. It defines the local power
    states for each node in a hierarchical processor topology. The OSPM can
    use _LPI object to select a local power state for each level of processor
    hierarchy in the system. They used to produce a composite power state
    request that is presented to the platform by the OSPM.
    
    Since multiple processors affect the idle state for any non-leaf hierarchy
    node, coordination of idle state requests between the processors is
    required. ACPI supports two different coordination schemes: Platform
    coordinated and  OS initiated.
    
    This patch adds initial support for Platform coordination scheme of LPI.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 262ca31b86d9..80ebb05e387c 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -302,6 +302,14 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 EXPORT_SYMBOL(acpi_run_osc);
 
 bool osc_sb_apei_support_acked;
+
+/*
+ * ACPI 6.0 Section 8.4.4.2 Idle State Coordination
+ * OSPM supports platform coordinated low power idle(LPI) states
+ */
+bool osc_pc_lpi_support_confirmed;
+EXPORT_SYMBOL_GPL(osc_pc_lpi_support_confirmed);
+
 static u8 sb_uuid_str[] = "0811B06E-4A27-44F9-8D60-3CBBC22E7B48";
 static void acpi_bus_osc_support(void)
 {
@@ -322,6 +330,7 @@ static void acpi_bus_osc_support(void)
 		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PPC_OST_SUPPORT;
 
 	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_HOTPLUG_OST_SUPPORT;
+	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PCLPI_SUPPORT;
 
 	if (!ghes_disable)
 		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_APEI_SUPPORT;
@@ -329,9 +338,12 @@ static void acpi_bus_osc_support(void)
 		return;
 	if (ACPI_SUCCESS(acpi_run_osc(handle, &context))) {
 		u32 *capbuf_ret = context.ret.pointer;
-		if (context.ret.length > OSC_SUPPORT_DWORD)
+		if (context.ret.length > OSC_SUPPORT_DWORD) {
 			osc_sb_apei_support_acked =
 				capbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_APEI_SUPPORT;
+			osc_pc_lpi_support_confirmed =
+				capbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_PCLPI_SUPPORT;
+		}
 		kfree(context.ret.pointer);
 	}
 	/* do we need to check other returned cap? Sounds no */

commit 68bdb6773289f8c9a36633f9f6525b127c093258
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Jul 8 19:13:09 2016 +0300

    ACPI: add support for ACPI reconfiguration notifiers
    
    Add support for ACPI reconfiguration notifiers to allow subsystems
    to react to changes in the ACPI tables that happen after the initial
    enumeration. This is similar with the way dynamic device tree
    notifications work.
    
    The reconfigure notifications supported for now are device add and
    device remove.
    
    Since ACPICA allows only one table notification handler, this patch
    makes the table notifier function generic and moves it out of the
    sysfs specific code.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 262ca31b86d9..97e270e06653 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -990,6 +990,13 @@ void __init acpi_subsystem_init(void)
 	}
 }
 
+static acpi_status acpi_bus_table_handler(u32 event, void *table, void *context)
+{
+	acpi_scan_table_handler(event, table, context);
+
+	return acpi_sysfs_table_handler(event, table, context);
+}
+
 static int __init acpi_bus_init(void)
 {
 	int result;
@@ -1043,6 +1050,8 @@ static int __init acpi_bus_init(void)
 	 * _PDC control method may load dynamic SSDT tables,
 	 * and we need to install the table handler before that.
 	 */
+	status = acpi_install_table_handler(acpi_bus_table_handler, NULL);
+
 	acpi_sysfs_init();
 
 	acpi_early_processor_set_pdc();

commit baa0c019b4c6eb1759cf55e7858badca4758c143
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Thu Jun 23 12:24:26 2016 -0600

    ACPI / bus: Support for platform initiated graceful shutdown
    
    This patch adds support for platform initited graceful shutdown as
    described in sections 5.6.6(Table-143) and 6.3.5.1 of ACPI 6.1 spec
    
    The OSPM will get a graceful shutdown request via a Notify operator
    on \_SB device with a value of 0x81 per section 5.6.6. Following the
    shutdown request from platform the OSPM needs to follow the
    processing sequence as described in section 6.2.5.1.
    
    v3
    * Switched to regular work with delays from delayed work
    * Dropped changes to actypes.h
    * Small style changes
    
    v2
    * Switched from standalone driver to a simple notify handler
    
    v1
    * Initial
    
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9342f4b46a4e..64a3fb0bf188 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -30,6 +30,9 @@
 #include <linux/acpi.h>
 #include <linux/slab.h>
 #include <linux/regulator/machine.h>
+#include <linux/workqueue.h>
+#include <linux/reboot.h>
+#include <linux/delay.h>
 #ifdef CONFIG_X86
 #include <asm/mpspec.h>
 #endif
@@ -470,6 +473,56 @@ static void acpi_device_remove_notify_handler(struct acpi_device *device)
 					   acpi_device_notify);
 }
 
+/* Handle events targeting \_SB device (at present only graceful shutdown) */
+
+#define ACPI_SB_NOTIFY_SHUTDOWN_REQUEST 0x81
+#define ACPI_SB_INDICATE_INTERVAL	10000
+
+static void sb_notify_work(struct work_struct *dummy)
+{
+	acpi_handle sb_handle;
+
+	orderly_poweroff(true);
+
+	/*
+	 * After initiating graceful shutdown, the ACPI spec requires OSPM
+	 * to evaluate _OST method once every 10seconds to indicate that
+	 * the shutdown is in progress
+	 */
+	acpi_get_handle(NULL, "\\_SB", &sb_handle);
+	while (1) {
+		pr_info("Graceful shutdown in progress.\n");
+		acpi_evaluate_ost(sb_handle, ACPI_OST_EC_OSPM_SHUTDOWN,
+				ACPI_OST_SC_OS_SHUTDOWN_IN_PROGRESS, NULL);
+		msleep(ACPI_SB_INDICATE_INTERVAL);
+	}
+}
+
+static void acpi_sb_notify(acpi_handle handle, u32 event, void *data)
+{
+	static DECLARE_WORK(acpi_sb_work, sb_notify_work);
+
+	if (event == ACPI_SB_NOTIFY_SHUTDOWN_REQUEST) {
+		if (!work_busy(&acpi_sb_work))
+			schedule_work(&acpi_sb_work);
+	} else
+		pr_warn("event %x is not supported by \\_SB device\n", event);
+}
+
+static int __init acpi_setup_sb_notify_handler(void)
+{
+	acpi_handle sb_handle;
+
+	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &sb_handle)))
+		return -ENXIO;
+
+	if (ACPI_FAILURE(acpi_install_notify_handler(sb_handle, ACPI_DEVICE_NOTIFY,
+						acpi_sb_notify, NULL)))
+		return -EINVAL;
+
+	return 0;
+}
+
 /* --------------------------------------------------------------------------
                              Device Matching
    -------------------------------------------------------------------------- */
@@ -1118,6 +1171,7 @@ static int __init acpi_init(void)
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();
 	acpi_debugger_init();
+	acpi_setup_sb_notify_handler();
 	return 0;
 }
 

commit 3af03f77cb6638c8384c712f8fc7febe07ae2424
Author: Baoquan He <bhe@redhat.com>
Date:   Mon Jul 4 11:13:59 2016 +0800

    ACPI / bus: Correct the comments about acpi_subsystem_init()
    
    In acpi_subsystem_init(), function acpi_enable_subsystem() is
    called to do the real job. However with different flags passed to
    acpi_enable_subsystem(), different code is executed.
    
    In acpi_subsystem_init(), with "~ACPI_NO_ACPI_ENABLE" passed in, it
    will only switch over the platform to the ACPI mode. The remaining
    part of acpi_enable_subsystem() is done when acpi_bus_init() is
    called.
    
    So the comments above acpi_subsystem_init() is not exact, change it
    here.
    
    Signed-off-by: Baoquan He <bhe@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a6bb8aef2573..9342f4b46a4e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -956,8 +956,7 @@ void __init acpi_early_init(void)
 /**
  * acpi_subsystem_init - Finalize the early initialization of ACPI.
  *
- * Switch over the platform to the ACPI mode (if possible), initialize the
- * handling of ACPI events, install the interrupt and global lock handlers.
+ * Switch over the platform to the ACPI mode (if possible).
  *
  * Doing this too early is generally unsafe, but at the same time it needs to be
  * done before all things that really depend on ACPI.  The right spot appears to

commit f26f5c8b8b182c38074d942e9124679238aa04ef
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 16 17:23:09 2016 +0200

    ACPI / bus: Use acpi_handle_debug() in acpi_print_osc_error()
    
    acpi_print_osc_error() basically duplicates the functionalit of
    acpi_handle_debug(), so use that one in there.
    
    While at it, convert the explicit KERN_DEBUG prints to pr_debug()
    (and apply it to continuation messages too).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 262ca31b86d9..a6bb8aef2573 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -174,22 +174,17 @@ void acpi_bus_detach_private_data(acpi_handle handle)
 EXPORT_SYMBOL_GPL(acpi_bus_detach_private_data);
 
 static void acpi_print_osc_error(acpi_handle handle,
-	struct acpi_osc_context *context, char *error)
+				 struct acpi_osc_context *context, char *error)
 {
-	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER};
 	int i;
 
-	if (ACPI_FAILURE(acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer)))
-		printk(KERN_DEBUG "%s: %s\n", context->uuid_str, error);
-	else {
-		printk(KERN_DEBUG "%s (%s): %s\n",
-		       (char *)buffer.pointer, context->uuid_str, error);
-		kfree(buffer.pointer);
-	}
-	printk(KERN_DEBUG "_OSC request data:");
+	acpi_handle_debug(handle, "(%s): %s\n", context->uuid_str, error);
+
+	pr_debug("_OSC request data:");
 	for (i = 0; i < context->cap.length; i += sizeof(u32))
-		printk(" %x", *((u32 *)(context->cap.pointer + i)));
-	printk("\n");
+		pr_debug(" %x", *((u32 *)(context->cap.pointer + i)));
+
+	pr_debug("\n");
 }
 
 acpi_status acpi_str_to_uuid(char *str, u8 *uuid)

commit dcf15cbded656a12335bc4151f3f75f10080a375
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Jun 3 10:26:12 2016 +0800

    ACPI / EC: Fix a boot EC regresion by restoring boot EC support for the DSDT EC
    
    According to the Windows probing result, during the table loading, the EC
    device described in the ECDT should be used. And the ECDT EC is also
    effective during the period the namespace objects are initialized (we can
    see a separate process executing _STA/_INI on Windows before executing
    other device specific control methods, for example, EC._REG). During the
    device enumration, the EC device described in the DSDT should be used. But
    there are differences between Linux and Windows around the device probing
    order. Thus in Linux, we should enable the DSDT EC as early as possible
    before enumerating devices in order not to trigger issues related to the
    device enumeration order differences.
    
    This patch thus converts acpi_boot_ec_enable() into acpi_ec_dsdt_probe() to
    fix the gap. This also fixes a user reported regression triggered after we
    switched the "table loading"/"ECDT support" to be ACPI spec 2.0 compliant.
    
    Fixes: 59f0aa9480cf (ACPI 2.0 / ECDT: Remove early namespace reference from EC)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=119261
    Reported-and-tested-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 31e8da648fff..262ca31b86d9 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1051,7 +1051,7 @@ static int __init acpi_bus_init(void)
 	 * Maybe EC region is required at bus_scan/acpi_get_devices. So it
 	 * is necessary to enable it as early as possible.
 	 */
-	acpi_boot_ec_enable();
+	acpi_ec_dsdt_probe();
 
 	printk(KERN_INFO PREFIX "Interpreter enabled\n");
 

commit fe6cbea0f096bfdb7eafdc7b937570cea8fca00e
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Mar 24 10:43:00 2016 +0800

    ACPI 2.0 / ECDT: Enable correct ECDT initialization order
    
    With wrong ECDT fixes reverted, it is possible to put ECDT probing before
    acpi_enable_subsystem().
    
    But the ultimate purpose of ECDT re-enabling is to put the ECDT probing
    before the namespace initialization (acpi_load_tables()). This patch
    achieves this with protections so that we can enable it later when all
    necessary corrections are upstreamed.
    
    Link 4: https://bugzilla.kernel.org/show_bug.cgi?id=112911
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Tested-by: Chris Bainbridge <chris.bainbridge@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c068c829b453..31e8da648fff 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -925,11 +925,13 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
-	status = acpi_load_tables();
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX
-		       "Unable to load the System Description Tables\n");
-		goto error0;
+	if (acpi_gbl_group_module_level_code) {
+		status = acpi_load_tables();
+		if (ACPI_FAILURE(status)) {
+			printk(KERN_ERR PREFIX
+			       "Unable to load the System Description Tables\n");
+			goto error0;
+		}
 	}
 
 #ifdef CONFIG_X86
@@ -995,17 +997,10 @@ static int __init acpi_bus_init(void)
 
 	acpi_os_initialize1();
 
-	status = acpi_enable_subsystem(ACPI_NO_ACPI_ENABLE);
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX
-		       "Unable to start the ACPI Interpreter\n");
-		goto error1;
-	}
-
 	/*
 	 * ACPI 2.0 requires the EC driver to be loaded and work before
-	 * the EC device is found in the namespace (i.e. before acpi_initialize_objects()
-	 * is called).
+	 * the EC device is found in the namespace (i.e. before
+	 * acpi_load_tables() is called).
 	 *
 	 * This is accomplished by looking for the ECDT table, and getting
 	 * the EC parameters out of that.
@@ -1013,6 +1008,22 @@ static int __init acpi_bus_init(void)
 	status = acpi_ec_ecdt_probe();
 	/* Ignore result. Not having an ECDT is not fatal. */
 
+	if (!acpi_gbl_group_module_level_code) {
+		status = acpi_load_tables();
+		if (ACPI_FAILURE(status)) {
+			printk(KERN_ERR PREFIX
+			       "Unable to load the System Description Tables\n");
+			goto error1;
+		}
+	}
+
+	status = acpi_enable_subsystem(ACPI_NO_ACPI_ENABLE);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX
+		       "Unable to start the ACPI Interpreter\n");
+		goto error1;
+	}
+
 	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to initialize ACPI objects\n");

commit 8fbd4ade93dc67f035914cd4030f1c58797d9e59
Merge: f55532a0c0b8 a21211672c9a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 2 01:17:36 2016 +0200

    Merge branch 'acpi-processor'
    
    * acpi-processor:
      ACPI / processor: Request native thermal interrupt handling via _OSC

commit a21211672c9a1d730a39aa65d4a5b3414700adfb
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Mar 23 21:07:39 2016 -0700

    ACPI / processor: Request native thermal interrupt handling via _OSC
    
    There are several reports of freeze on enabling HWP (Hardware PStates)
    feature on Skylake-based systems by the Intel P-states driver. The root
    cause is identified as the HWP interrupts causing BIOS code to freeze.
    
    HWP interrupts use the thermal LVT which can be handled by Linux
    natively, but on the affected Skylake-based systems SMM will respond
    to it by default.  This is a problem for several reasons:
     - On the affected systems the SMM thermal LVT handler is broken (it
       will crash when invoked) and a BIOS update is necessary to fix it.
     - With thermal interrupt handled in SMM we lose all of the reporting
       features of the arch/x86/kernel/cpu/mcheck/therm_throt driver.
     - Some thermal drivers like x86-package-temp depend on the thermal
       threshold interrupts signaled via the thermal LVT.
     - The HWP interrupts are useful for debugging and tuning
       performance (if the kernel can handle them).
    The native handling of thermal interrupts needs to be enabled
    because of that.
    
    This requires some way to tell SMM that the OS can handle thermal
    interrupts.  That can be done by using _OSC/_PDC in processor
    scope very early during ACPI initialization.
    
    The meaning of _OSC/_PDC bit 12 in processor scope is whether or
    not the OS supports native handling of interrupts for Collaborative
    Processor Performance Control (CPPC) notifications.  Since on
    HWP-capable systems CPPC is a firmware interface to HWP, setting
    this bit effectively tells the firmware that the OS will handle
    thermal interrupts natively going forward.
    
    For details on _OSC/_PDC refer to:
    http://www.intel.com/content/www/us/en/standards/processor-vendor-specific-acpi-specification.html
    
    To implement the _OSC/_PDC handshake as described, introduce a new
    function, acpi_early_processor_osc(), that walks the ACPI
    namespace looking for ACPI processor objects and invokes _OSC for
    them with bit 12 in the capabilities buffer set and terminates the
    namespace walk on the first success.
    
    Also modify intel_thermal_interrupt() to clear HWP status bits in
    the HWP_STATUS MSR to acknowledge HWP interrupts (which prevents
    them from firing continuously).
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    [ rjw: Subject & changelog, function rename ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 891c42d1cd65..f9081b791b81 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1005,6 +1005,9 @@ static int __init acpi_bus_init(void)
 		goto error1;
 	}
 
+	/* Set capability bits for _OSC under processor scope */
+	acpi_early_processor_osc();
+
 	/*
 	 * _OSC method may exist in module level code,
 	 * so it must be run after ACPI_FULL_INITIALIZATION

commit 3b95bd160547f56a68aeb972c33ae9511e7a8380
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Tue Feb 16 15:52:38 2016 +0300

    ACPI: introduce a function to find the first physical device
    
    Factor out the code that finds the first physical device
    of a given ACPI device.  It is used in several places.
    
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 891c42d1cd65..0e8567846f1a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -479,24 +479,38 @@ static void acpi_device_remove_notify_handler(struct acpi_device *device)
                              Device Matching
    -------------------------------------------------------------------------- */
 
-static struct acpi_device *acpi_primary_dev_companion(struct acpi_device *adev,
-						      const struct device *dev)
+/**
+ * acpi_get_first_physical_node - Get first physical node of an ACPI device
+ * @adev:	ACPI device in question
+ *
+ * Return: First physical node of ACPI device @adev
+ */
+struct device *acpi_get_first_physical_node(struct acpi_device *adev)
 {
 	struct mutex *physical_node_lock = &adev->physical_node_lock;
+	struct device *phys_dev;
 
 	mutex_lock(physical_node_lock);
 	if (list_empty(&adev->physical_node_list)) {
-		adev = NULL;
+		phys_dev = NULL;
 	} else {
 		const struct acpi_device_physical_node *node;
 
 		node = list_first_entry(&adev->physical_node_list,
 					struct acpi_device_physical_node, node);
-		if (node->dev != dev)
-			adev = NULL;
+
+		phys_dev = node->dev;
 	}
 	mutex_unlock(physical_node_lock);
-	return adev;
+	return phys_dev;
+}
+
+static struct acpi_device *acpi_primary_dev_companion(struct acpi_device *adev,
+						      const struct device *dev)
+{
+	const struct device *phys_dev = acpi_get_first_physical_node(adev);
+
+	return phys_dev && phys_dev == dev ? adev : NULL;
 }
 
 /**

commit 42d287d1a1e805ec98b5bdc4cca2660a56720ebd
Merge: b12745cce2c9 edc345d88462 76c599bcab26 9d128ed17c67 cd7f84c02825
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 12 01:10:03 2016 +0100

    Merge branches 'acpi-scan', 'acpi-bus', 'acpi-osl' and 'acpi-pm'
    
    * acpi-scan:
      ACPI: Fix white space in a structure definition
      ACPI / utils: Add acpi_dev_present()
      ACPI / scan: Fix acpi_bus_id_list bookkeeping
      ACPI / scan: set status to 0 if _STA failed
    
    * acpi-bus:
      ACPI / bus: Show _OSC UUID when _OSC fails
      ACPI / bus: Tidy up _OSC error spacing
    
    * acpi-osl:
      ACPI / OSL: Add kerneldoc comments to memory mapping functions
    
    * acpi-pm:
      ACPI / PM: Support D3 COLD device in old BIOS for ZPODD

commit 76c599bcab26795b0669694e1e32a78274cb901b
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Dec 15 08:37:40 2015 -0800

    ACPI / bus: Show _OSC UUID when _OSC fails
    
    When _OSC fails and especially when it fails due to an invalid UUID,
    it's helpful to show the UUID that we tried.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2177ef0b16e4..fcfdf6cbc6a8 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -180,9 +180,10 @@ static void acpi_print_osc_error(acpi_handle handle,
 	int i;
 
 	if (ACPI_FAILURE(acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer)))
-		printk(KERN_DEBUG "%s\n", error);
+		printk(KERN_DEBUG "%s: %s\n", context->uuid_str, error);
 	else {
-		printk(KERN_DEBUG "%s: %s\n", (char *)buffer.pointer, error);
+		printk(KERN_DEBUG "%s (%s): %s\n",
+		       (char *)buffer.pointer, context->uuid_str, error);
 		kfree(buffer.pointer);
 	}
 	printk(KERN_DEBUG "_OSC request data:");

commit 50fe763cc8fa00bef9ff78e58645dbfdcaa998da
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Dec 15 08:37:39 2015 -0800

    ACPI / bus: Tidy up _OSC error spacing
    
    The whitespace in _OSC error reports is weird.  Improve it.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a212cefae524..2177ef0b16e4 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -182,12 +182,12 @@ static void acpi_print_osc_error(acpi_handle handle,
 	if (ACPI_FAILURE(acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer)))
 		printk(KERN_DEBUG "%s\n", error);
 	else {
-		printk(KERN_DEBUG "%s:%s\n", (char *)buffer.pointer, error);
+		printk(KERN_DEBUG "%s: %s\n", (char *)buffer.pointer, error);
 		kfree(buffer.pointer);
 	}
-	printk(KERN_DEBUG"_OSC request data:");
+	printk(KERN_DEBUG "_OSC request data:");
 	for (i = 0; i < context->cap.length; i += sizeof(u32))
-		printk("%x ", *((u32 *)(context->cap.pointer + i)));
+		printk(" %x", *((u32 *)(context->cap.pointer + i)));
 	printk("\n");
 }
 

commit 836d0830188a97d5c73e8eb514f346a857c086b9
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Dec 3 10:43:14 2015 +0800

    ACPI / debugger: Add module support for ACPI debugger
    
    This patch converts AML debugger into a loadable module.
    
    Note that, it implements driver unloading at the level dependent on the
    module reference count. Which means if ACPI debugger is being used by a
    userspace program, "rmmod acpi_dbg" should result in failure.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 06fbba92099b..1a40111e1c86 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -37,7 +37,6 @@
 #include <acpi/apei.h>
 #include <linux/dmi.h>
 #include <linux/suspend.h>
-#include <linux/acpi_dbg.h>
 
 #include "internal.h"
 
@@ -1095,7 +1094,7 @@ static int __init acpi_init(void)
 	acpi_debugfs_init();
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();
-	acpi_aml_init();
+	acpi_debugger_init();
 	return 0;
 }
 

commit 8cfb0cdf07e2c260c4d1a102bfec35183907834f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Dec 3 10:43:00 2015 +0800

    ACPI / debugger: Add IO interface to access debugger functionalities
    
    This patch adds /sys/kernel/debug/acpi/acpidbg, which can be used by
    userspace programs to access ACPICA debugger functionalities.
    
    Known issue:
    1. IO flush support
       acpi_os_notify_command_complete() and acpi_os_wait_command_ready() can
       be used by acpi_dbg module to implement .flush() filesystem operation.
       While this patch doesn't go that far. It then becomes userspace tool's
       duty now to flush old commands before executing new batch mode commands.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a212cefae524..06fbba92099b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -37,6 +37,7 @@
 #include <acpi/apei.h>
 #include <linux/dmi.h>
 #include <linux/suspend.h>
+#include <linux/acpi_dbg.h>
 
 #include "internal.h"
 
@@ -1094,6 +1095,7 @@ static int __init acpi_init(void)
 	acpi_debugfs_init();
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();
+	acpi_aml_init();
 	return 0;
 }
 

commit bcb2b0b2bae2de744223c68521cd51c57feb486c
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Mon Sep 14 16:01:55 2015 +0100

    ACPI: Eliminate CONFIG_.*{, _MODULE} #ifdef in favor of IS_ENABLED()
    
    This commit removes all CONFIG_.*{,_MODULE} in ACPI code, replacing it
    with IS_ENABLED().
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 46506e7687cd..a212cefae524 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -315,14 +315,10 @@ static void acpi_bus_osc_support(void)
 
 	capbuf[OSC_QUERY_DWORD] = OSC_QUERY_ENABLE;
 	capbuf[OSC_SUPPORT_DWORD] = OSC_SB_PR3_SUPPORT; /* _PR3 is in use */
-#if defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR) ||\
-			defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE)
-	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PAD_SUPPORT;
-#endif
-
-#if defined(CONFIG_ACPI_PROCESSOR) || defined(CONFIG_ACPI_PROCESSOR_MODULE)
-	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PPC_OST_SUPPORT;
-#endif
+	if (IS_ENABLED(CONFIG_ACPI_PROCESSOR_AGGREGATOR))
+		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PAD_SUPPORT;
+	if (IS_ENABLED(CONFIG_ACPI_PROCESSOR))
+		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PPC_OST_SUPPORT;
 
 	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_HOTPLUG_OST_SUPPORT;
 

commit ef5f5de069bd9081a7ddf6998269b58fc65e27ef
Merge: 73990fc810bf e91a398c31ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:38:43 2015 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / bus: Move duplicate code to a separate new function
      mfd: Add support for Intel Sunrisepoint LPSS devices
      dmaengine: add a driver for Intel integrated DMA 64-bit
      mfd: make mfd_remove_devices() iterate in reverse order
      driver core: implement device_for_each_child_reverse()
      klist: implement klist_prev()
      Driver core: wakeup the parent device before trying probe
      ACPI / PM: Attach ACPI power domain only once
      PM / QoS: Make it possible to expose device latency tolerance to userspace
      ACPI / PM: Update the copyright notice and description of power.c

commit 73990fc810bf84c5338d9596f8af8d70fe90ac72
Merge: 94f2bb9b599f 1dcc3d3362b0 b6fc6072b126 10742619ac63
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:38:22 2015 +0200

    Merge branches 'acpi-scan', 'acpi-processor' and 'acpi-assorted'
    
    * acpi-scan:
      ACPI / bus: Move ACPI bus type registration
      ACPI / scan: Move bus operations and notification routines to bus.c
      ACPI / scan: Move device matching code to bus.c
      ACPI / scan: Move sysfs-related device code to a separate file
    
    * acpi-processor:
      PCC: Disable compilation by default
      ACPI: Decouple ACPI idle and ACPI processor drivers
      ACPI: Split out ACPI PSS from ACPI Processor driver
      PCC: Initialize PCC Mailbox earlier at boot
      ACPI / processor: remove leftover __refdata annotations
    
    * acpi-assorted:
      ACPI: fix acpi_debugfs_init prototype
      ACPI: Remove FSF mailing addresses

commit e91a398c31cef2d51786642e372c503cd43fba90
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Aug 1 02:39:43 2015 +0200

    ACPI / bus: Move duplicate code to a separate new function
    
    After merging commit 712e960f0ee9 (ACPI / PM: Attach ACPI power
    domain only once) with commit 1dcc3d3362b0 (ACPI / bus: Move ACPI
    bus type registration) there is some duplicate code in
    acpi_device_is_first_physical_node() and acpi_companion_match()
    that can be moved to a separate routine and called from both
    places.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a23903c8bea9..f39f686ed2df 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -486,6 +486,26 @@ static void acpi_device_remove_notify_handler(struct acpi_device *device)
                              Device Matching
    -------------------------------------------------------------------------- */
 
+static struct acpi_device *acpi_primary_dev_companion(struct acpi_device *adev,
+						      const struct device *dev)
+{
+	struct mutex *physical_node_lock = &adev->physical_node_lock;
+
+	mutex_lock(physical_node_lock);
+	if (list_empty(&adev->physical_node_list)) {
+		adev = NULL;
+	} else {
+		const struct acpi_device_physical_node *node;
+
+		node = list_first_entry(&adev->physical_node_list,
+					struct acpi_device_physical_node, node);
+		if (node->dev != dev)
+			adev = NULL;
+	}
+	mutex_unlock(physical_node_lock);
+	return adev;
+}
+
 /**
  * acpi_device_is_first_physical_node - Is given dev first physical node
  * @adev: ACPI companion device
@@ -500,19 +520,7 @@ static void acpi_device_remove_notify_handler(struct acpi_device *device)
 bool acpi_device_is_first_physical_node(struct acpi_device *adev,
 					const struct device *dev)
 {
-	bool ret = false;
-
-	mutex_lock(&adev->physical_node_lock);
-	if (!list_empty(&adev->physical_node_list)) {
-		const struct acpi_device_physical_node *node;
-
-		node = list_first_entry(&adev->physical_node_list,
-					struct acpi_device_physical_node, node);
-		ret = node->dev == dev;
-	}
-	mutex_unlock(&adev->physical_node_lock);
-
-	return ret;
+	return !!acpi_primary_dev_companion(adev, dev);
 }
 
 /*
@@ -539,7 +547,6 @@ bool acpi_device_is_first_physical_node(struct acpi_device *adev,
 struct acpi_device *acpi_companion_match(const struct device *dev)
 {
 	struct acpi_device *adev;
-	struct mutex *physical_node_lock;
 
 	adev = ACPI_COMPANION(dev);
 	if (!adev)
@@ -548,21 +555,7 @@ struct acpi_device *acpi_companion_match(const struct device *dev)
 	if (list_empty(&adev->pnp.ids))
 		return NULL;
 
-	physical_node_lock = &adev->physical_node_lock;
-	mutex_lock(physical_node_lock);
-	if (list_empty(&adev->physical_node_list)) {
-		adev = NULL;
-	} else {
-		const struct acpi_device_physical_node *node;
-
-		node = list_first_entry(&adev->physical_node_list,
-					struct acpi_device_physical_node, node);
-		if (node->dev != dev)
-			adev = NULL;
-	}
-	mutex_unlock(physical_node_lock);
-
-	return adev;
+	return acpi_primary_dev_companion(adev, dev);
 }
 
 /**

commit 3431e490b50356b56084305a2e93b3a980802b22
Merge: 5af310a8ee70 1dcc3d3362b0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 29 23:57:51 2015 +0200

    Merge branch 'acpi-scan' into acpi-pm
    
    Conflicts:
            drivers/acpi/scan.c
    
    The conflict is resolved by moving the just introduced
    acpi_device_is_first_physical_node() to bus.c and using
    the existing acpi_companion_match() from there.
    
    There will be an additional commit to combine the two.

commit 1dcc3d3362b0c97e48290f7786be85b4cec2a147
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 17 22:54:09 2015 +0200

    ACPI / bus: Move ACPI bus type registration
    
    Move the registration of the ACPI bus type to acpi_bus_init() and
    avoid using ACPI going forward if it fails (too many things depend on
    the presence of the ACPI bus type).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2f50fc4be1d4..7a3ad929f095 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1039,7 +1039,9 @@ static int __init acpi_bus_init(void)
 	 */
 	acpi_root_dir = proc_mkdir(ACPI_BUS_FILE_ROOT, NULL);
 
-	return 0;
+	result = bus_register(&acpi_bus_type);
+	if (!result)
+		return 0;
 
 	/* Mimic structured exception handling */
       error1:

commit 5894b0c46e49b5ecc25f22b2d1b8232aab00ce97
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 17 22:54:01 2015 +0200

    ACPI / scan: Move bus operations and notification routines to bus.c
    
    To reduce the size of scan.c and improve the readability of it, move
    code related to device notification, the definitions of the ACPI bus
    operations and the driver management code to drivers/acpi/bus.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ce805809b00b..2f50fc4be1d4 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -423,6 +423,65 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	acpi_evaluate_ost(handle, type, ost_code, NULL);
 }
 
+static void acpi_device_notify(acpi_handle handle, u32 event, void *data)
+{
+	struct acpi_device *device = data;
+
+	device->driver->ops.notify(device, event);
+}
+
+static void acpi_device_notify_fixed(void *data)
+{
+	struct acpi_device *device = data;
+
+	/* Fixed hardware devices have no handles */
+	acpi_device_notify(NULL, ACPI_FIXED_HARDWARE_EVENT, device);
+}
+
+static u32 acpi_device_fixed_event(void *data)
+{
+	acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_device_notify_fixed, data);
+	return ACPI_INTERRUPT_HANDLED;
+}
+
+static int acpi_device_install_notify_handler(struct acpi_device *device)
+{
+	acpi_status status;
+
+	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
+		status =
+		    acpi_install_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
+						     acpi_device_fixed_event,
+						     device);
+	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
+		status =
+		    acpi_install_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
+						     acpi_device_fixed_event,
+						     device);
+	else
+		status = acpi_install_notify_handler(device->handle,
+						     ACPI_DEVICE_NOTIFY,
+						     acpi_device_notify,
+						     device);
+
+	if (ACPI_FAILURE(status))
+		return -EINVAL;
+	return 0;
+}
+
+static void acpi_device_remove_notify_handler(struct acpi_device *device)
+{
+	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
+		acpi_remove_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
+						acpi_device_fixed_event);
+	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
+		acpi_remove_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
+						acpi_device_fixed_event);
+	else
+		acpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,
+					   acpi_device_notify);
+}
+
 /* --------------------------------------------------------------------------
                              Device Matching
    -------------------------------------------------------------------------- */
@@ -617,6 +676,131 @@ bool acpi_driver_match_device(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(acpi_driver_match_device);
 
+/* --------------------------------------------------------------------------
+                              ACPI Driver Management
+   -------------------------------------------------------------------------- */
+
+/**
+ * acpi_bus_register_driver - register a driver with the ACPI bus
+ * @driver: driver being registered
+ *
+ * Registers a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and binds.  Returns zero for
+ * success or a negative error status for failure.
+ */
+int acpi_bus_register_driver(struct acpi_driver *driver)
+{
+	int ret;
+
+	if (acpi_disabled)
+		return -ENODEV;
+	driver->drv.name = driver->name;
+	driver->drv.bus = &acpi_bus_type;
+	driver->drv.owner = driver->owner;
+
+	ret = driver_register(&driver->drv);
+	return ret;
+}
+
+EXPORT_SYMBOL(acpi_bus_register_driver);
+
+/**
+ * acpi_bus_unregister_driver - unregisters a driver with the ACPI bus
+ * @driver: driver to unregister
+ *
+ * Unregisters a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and unbinds.
+ */
+void acpi_bus_unregister_driver(struct acpi_driver *driver)
+{
+	driver_unregister(&driver->drv);
+}
+
+EXPORT_SYMBOL(acpi_bus_unregister_driver);
+
+/* --------------------------------------------------------------------------
+                              ACPI Bus operations
+   -------------------------------------------------------------------------- */
+
+static int acpi_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
+
+	return acpi_dev->flags.match_driver
+		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
+}
+
+static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	return __acpi_device_uevent_modalias(to_acpi_device(dev), env);
+}
+
+static int acpi_device_probe(struct device *dev)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);
+	int ret;
+
+	if (acpi_dev->handler && !acpi_is_pnp_device(acpi_dev))
+		return -EINVAL;
+
+	if (!acpi_drv->ops.add)
+		return -ENOSYS;
+
+	ret = acpi_drv->ops.add(acpi_dev);
+	if (ret)
+		return ret;
+
+	acpi_dev->driver = acpi_drv;
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Driver [%s] successfully bound to device [%s]\n",
+			  acpi_drv->name, acpi_dev->pnp.bus_id));
+
+	if (acpi_drv->ops.notify) {
+		ret = acpi_device_install_notify_handler(acpi_dev);
+		if (ret) {
+			if (acpi_drv->ops.remove)
+				acpi_drv->ops.remove(acpi_dev);
+
+			acpi_dev->driver = NULL;
+			acpi_dev->driver_data = NULL;
+			return ret;
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
+			  acpi_drv->name, acpi_dev->pnp.bus_id));
+	get_device(dev);
+	return 0;
+}
+
+static int acpi_device_remove(struct device * dev)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = acpi_dev->driver;
+
+	if (acpi_drv) {
+		if (acpi_drv->ops.notify)
+			acpi_device_remove_notify_handler(acpi_dev);
+		if (acpi_drv->ops.remove)
+			acpi_drv->ops.remove(acpi_dev);
+	}
+	acpi_dev->driver = NULL;
+	acpi_dev->driver_data = NULL;
+
+	put_device(dev);
+	return 0;
+}
+
+struct bus_type acpi_bus_type = {
+	.name		= "acpi",
+	.match		= acpi_bus_match,
+	.probe		= acpi_device_probe,
+	.remove		= acpi_device_remove,
+	.uevent		= acpi_device_uevent,
+};
+
 /* --------------------------------------------------------------------------
                              Initialization/Cleanup
    -------------------------------------------------------------------------- */

commit 68c6b148daa6e45a85b31ef60ed9c9bfd556fff0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 17 22:53:52 2015 +0200

    ACPI / scan: Move device matching code to bus.c
    
    To reduce the size of scan.c and improve the readability of it, move
    code related device matching into drivers/acpi/bus.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 513e7230e3d0..ce805809b00b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -423,6 +423,200 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	acpi_evaluate_ost(handle, type, ost_code, NULL);
 }
 
+/* --------------------------------------------------------------------------
+                             Device Matching
+   -------------------------------------------------------------------------- */
+
+/*
+ * acpi_companion_match() - Can we match via ACPI companion device
+ * @dev: Device in question
+ *
+ * Check if the given device has an ACPI companion and if that companion has
+ * a valid list of PNP IDs, and if the device is the first (primary) physical
+ * device associated with it.  Return the companion pointer if that's the case
+ * or NULL otherwise.
+ *
+ * If multiple physical devices are attached to a single ACPI companion, we need
+ * to be careful.  The usage scenario for this kind of relationship is that all
+ * of the physical devices in question use resources provided by the ACPI
+ * companion.  A typical case is an MFD device where all the sub-devices share
+ * the parent's ACPI companion.  In such cases we can only allow the primary
+ * (first) physical device to be matched with the help of the companion's PNP
+ * IDs.
+ *
+ * Additional physical devices sharing the ACPI companion can still use
+ * resources available from it but they will be matched normally using functions
+ * provided by their bus types (and analogously for their modalias).
+ */
+struct acpi_device *acpi_companion_match(const struct device *dev)
+{
+	struct acpi_device *adev;
+	struct mutex *physical_node_lock;
+
+	adev = ACPI_COMPANION(dev);
+	if (!adev)
+		return NULL;
+
+	if (list_empty(&adev->pnp.ids))
+		return NULL;
+
+	physical_node_lock = &adev->physical_node_lock;
+	mutex_lock(physical_node_lock);
+	if (list_empty(&adev->physical_node_list)) {
+		adev = NULL;
+	} else {
+		const struct acpi_device_physical_node *node;
+
+		node = list_first_entry(&adev->physical_node_list,
+					struct acpi_device_physical_node, node);
+		if (node->dev != dev)
+			adev = NULL;
+	}
+	mutex_unlock(physical_node_lock);
+
+	return adev;
+}
+
+/**
+ * acpi_of_match_device - Match device object using the "compatible" property.
+ * @adev: ACPI device object to match.
+ * @of_match_table: List of device IDs to match against.
+ *
+ * If @dev has an ACPI companion which has ACPI_DT_NAMESPACE_HID in its list of
+ * identifiers and a _DSD object with the "compatible" property, use that
+ * property to match against the given list of identifiers.
+ */
+static bool acpi_of_match_device(struct acpi_device *adev,
+				 const struct of_device_id *of_match_table)
+{
+	const union acpi_object *of_compatible, *obj;
+	int i, nval;
+
+	if (!adev)
+		return false;
+
+	of_compatible = adev->data.of_compatible;
+	if (!of_match_table || !of_compatible)
+		return false;
+
+	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+		nval = of_compatible->package.count;
+		obj = of_compatible->package.elements;
+	} else { /* Must be ACPI_TYPE_STRING. */
+		nval = 1;
+		obj = of_compatible;
+	}
+	/* Now we can look for the driver DT compatible strings */
+	for (i = 0; i < nval; i++, obj++) {
+		const struct of_device_id *id;
+
+		for (id = of_match_table; id->compatible[0]; id++)
+			if (!strcasecmp(obj->string.pointer, id->compatible))
+				return true;
+	}
+
+	return false;
+}
+
+static bool __acpi_match_device_cls(const struct acpi_device_id *id,
+				    struct acpi_hardware_id *hwid)
+{
+	int i, msk, byte_shift;
+	char buf[3];
+
+	if (!id->cls)
+		return false;
+
+	/* Apply class-code bitmask, before checking each class-code byte */
+	for (i = 1; i <= 3; i++) {
+		byte_shift = 8 * (3 - i);
+		msk = (id->cls_msk >> byte_shift) & 0xFF;
+		if (!msk)
+			continue;
+
+		sprintf(buf, "%02x", (id->cls >> byte_shift) & msk);
+		if (strncmp(buf, &hwid->id[(i - 1) * 2], 2))
+			return false;
+	}
+	return true;
+}
+
+static const struct acpi_device_id *__acpi_match_device(
+	struct acpi_device *device,
+	const struct acpi_device_id *ids,
+	const struct of_device_id *of_ids)
+{
+	const struct acpi_device_id *id;
+	struct acpi_hardware_id *hwid;
+
+	/*
+	 * If the device is not present, it is unnecessary to load device
+	 * driver for it.
+	 */
+	if (!device || !device->status.present)
+		return NULL;
+
+	list_for_each_entry(hwid, &device->pnp.ids, list) {
+		/* First, check the ACPI/PNP IDs provided by the caller. */
+		for (id = ids; id->id[0] || id->cls; id++) {
+			if (id->id[0] && !strcmp((char *) id->id, hwid->id))
+				return id;
+			else if (id->cls && __acpi_match_device_cls(id, hwid))
+				return id;
+		}
+
+		/*
+		 * Next, check ACPI_DT_NAMESPACE_HID and try to match the
+		 * "compatible" property if found.
+		 *
+		 * The id returned by the below is not valid, but the only
+		 * caller passing non-NULL of_ids here is only interested in
+		 * whether or not the return value is NULL.
+		 */
+		if (!strcmp(ACPI_DT_NAMESPACE_HID, hwid->id)
+		    && acpi_of_match_device(device, of_ids))
+			return id;
+	}
+	return NULL;
+}
+
+/**
+ * acpi_match_device - Match a struct device against a given list of ACPI IDs
+ * @ids: Array of struct acpi_device_id object to match against.
+ * @dev: The device structure to match.
+ *
+ * Check if @dev has a valid ACPI handle and if there is a struct acpi_device
+ * object for that handle and use that object to match against a given list of
+ * device IDs.
+ *
+ * Return a pointer to the first matching ID on success or %NULL on failure.
+ */
+const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
+					       const struct device *dev)
+{
+	return __acpi_match_device(acpi_companion_match(dev), ids, NULL);
+}
+EXPORT_SYMBOL_GPL(acpi_match_device);
+
+int acpi_match_device_ids(struct acpi_device *device,
+			  const struct acpi_device_id *ids)
+{
+	return __acpi_match_device(device, ids, NULL) ? 0 : -ENOENT;
+}
+EXPORT_SYMBOL(acpi_match_device_ids);
+
+bool acpi_driver_match_device(struct device *dev,
+			      const struct device_driver *drv)
+{
+	if (!drv->acpi_match_table)
+		return acpi_of_match_device(ACPI_COMPANION(dev),
+					    drv->of_match_table);
+
+	return !!__acpi_match_device(acpi_companion_match(dev),
+				     drv->acpi_match_table, drv->of_match_table);
+}
+EXPORT_SYMBOL_GPL(acpi_driver_match_device);
+
 /* --------------------------------------------------------------------------
                              Initialization/Cleanup
    -------------------------------------------------------------------------- */

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 513e7230e3d0..c8356eb79911 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -15,10 +15,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 

commit b064a8fa77dfead647564c46ac8fc5b13bd1ab73
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:33:36 2015 +0200

    ACPI / init: Switch over platform to the ACPI mode later
    
    Commit 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before
    timekeeping_init()" moved the ACPI subsystem initialization,
    including the ACPI mode enabling, to an earlier point in the
    initialization sequence, to allow the timekeeping subsystem
    use ACPI early.  Unfortunately, that resulted in boot regressions
    on some systems and the early ACPI initialization was moved toward
    its original position in the kernel initialization code by commit
    c4e1acbb35e4 "ACPI / init: Invoke early ACPI initialization later".
    
    However, that turns out to be insufficient, as boot is still broken
    on the Tyan S8812 mainboard.
    
    To fix that issue, split the ACPI early initialization code into
    two pieces so the majority of it still located in acpi_early_init()
    and the part switching over the platform into the ACPI mode goes into
    a new function, acpi_subsystem_init(), executed at the original early
    ACPI initialization spot.
    
    That fixes the Tyan S8812 boot problem, but still allows ACPI
    tables to be loaded earlier which is useful to the EFI code in
    efi_enter_virtual_mode().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=97141
    Fixes: 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before timekeeping_init()"
    Reported-and-tested-by: Marius Tolzmann <tolzmann@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c412fdb28d34..513e7230e3d0 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -470,6 +470,16 @@ static int __init acpi_bus_init_irq(void)
 	return 0;
 }
 
+/**
+ * acpi_early_init - Initialize ACPICA and populate the ACPI namespace.
+ *
+ * The ACPI tables are accessible after this, but the handling of events has not
+ * been initialized and the global lock is not available yet, so AML should not
+ * be executed at this point.
+ *
+ * Doing this before switching the EFI runtime services to virtual mode allows
+ * the EfiBootServices memory to be freed slightly earlier on boot.
+ */
 void __init acpi_early_init(void)
 {
 	acpi_status status;
@@ -533,26 +543,42 @@ void __init acpi_early_init(void)
 		acpi_gbl_FADT.sci_interrupt = acpi_sci_override_gsi;
 	}
 #endif
+	return;
+
+ error0:
+	disable_acpi();
+}
+
+/**
+ * acpi_subsystem_init - Finalize the early initialization of ACPI.
+ *
+ * Switch over the platform to the ACPI mode (if possible), initialize the
+ * handling of ACPI events, install the interrupt and global lock handlers.
+ *
+ * Doing this too early is generally unsafe, but at the same time it needs to be
+ * done before all things that really depend on ACPI.  The right spot appears to
+ * be before finalizing the EFI initialization.
+ */
+void __init acpi_subsystem_init(void)
+{
+	acpi_status status;
+
+	if (acpi_disabled)
+		return;
 
 	status = acpi_enable_subsystem(~ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to enable ACPI\n");
-		goto error0;
+		disable_acpi();
+	} else {
+		/*
+		 * If the system is using ACPI then we can be reasonably
+		 * confident that any regulators are managed by the firmware
+		 * so tell the regulator core it has everything it needs to
+		 * know.
+		 */
+		regulator_has_full_constraints();
 	}
-
-	/*
-	 * If the system is using ACPI then we can be reasonably
-	 * confident that any regulators are managed by the firmware
-	 * so tell the regulator core it has everything it needs to
-	 * know.
-	 */
-	regulator_has_full_constraints();
-
-	return;
-
-      error0:
-	disable_acpi();
-	return;
 }
 
 static int __init acpi_bus_init(void)

commit fbe61ec71ac975279cd47b6c299d5e33f63aac4e
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:48 2015 +0000

    ARM64 / ACPI: Introduce ACPI_IRQ_MODEL_GIC and register device's gsi
    
    Introduce ACPI_IRQ_MODEL_GIC which is needed for ARM64 as GIC is
    used, and then register device's gsi with the core IRQ subsystem.
    
    acpi_register_gsi() is similar to DT based irq_of_parse_and_map(),
    since gsi is unique in the system, so use hwirq number directly
    for the mapping.
    
    We are going to implement stacked domains when GICv2m, GICv3, ITS
    support are added.
    
    CC: Marc Zyngier <marc.zyngier@arm.com>
    Originally-by: Amit Daniel Kachhap <amit.daniel@samsung.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 8b67bd0f6bb5..c412fdb28d34 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -448,6 +448,9 @@ static int __init acpi_bus_init_irq(void)
 	case ACPI_IRQ_MODEL_IOSAPIC:
 		message = "IOSAPIC";
 		break;
+	case ACPI_IRQ_MODEL_GIC:
+		message = "GIC";
+		break;
 	case ACPI_IRQ_MODEL_PLATFORM:
 		message = "platform specific model";
 		break;

commit f91ce35e471ae17552ce7bfe355cfd997e3ad781
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Sep 10 15:30:08 2014 -0600

    ACPIPHP / radeon / nouveau: Remove acpi_bus_no_hotplug()
    
    Revert parts of f244d8b623da ("ACPIPHP / radeon / nouveau: Fix VGA
    switcheroo problem related to hotplug").
    
    A previous commit 5493b31f0b55 ("PCI: Add pci_ignore_hotplug() to ignore
    hotplug events for a device") added equivalent functionality implemented in
    a different way for both acpiphp and pciehp.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Acked-by: Rajat Jain <rajatxjain@gmail.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 8581f5b84f48..8b67bd0f6bb5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -177,16 +177,6 @@ void acpi_bus_detach_private_data(acpi_handle handle)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_detach_private_data);
 
-void acpi_bus_no_hotplug(acpi_handle handle)
-{
-	struct acpi_device *adev = NULL;
-
-	acpi_bus_get_device(handle, &adev);
-	if (adev)
-		adev->flags.no_hotplug = true;
-}
-EXPORT_SYMBOL_GPL(acpi_bus_no_hotplug);
-
 static void acpi_print_osc_error(acpi_handle handle,
 	struct acpi_osc_context *context, char *error)
 {

commit a8278efd84f7643d5e44e5e507b657c231b0743b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Jul 16 16:57:52 2014 +0800

    ACPICA: Linux: Add stub support for Linux specific variables and functions.
    
    There are global variables and functions not upstreamed to the ACPICA code
    base.  Such symbols still can be referenced by external users as they are
    listed in the acpixf.h.  This patch uses ACPI_GLOBAL and
    ACPI_EXTERNAL_RETURN_STATUS mechanism to add stub support for such symbols.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c5bc8cfe09fa..8581f5b84f48 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -477,9 +477,6 @@ static int __init acpi_bus_init_irq(void)
 	return 0;
 }
 
-u8 acpi_gbl_permanent_mmap;
-
-
 void __init acpi_early_init(void)
 {
 	acpi_status status;

commit 0e36d43c9c87554cdb18aa865eec9edccda17324
Merge: b04c58b1ed26 729ddb657f6a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 3 23:12:27 2014 +0200

    Merge branch 'acpica'
    
    * acpica: (63 commits)
      ACPICA: Namespace: Remove _PRP method support.
      ACPI: Fix x86 regression related to early mapping size limitation
      ACPICA: Tables: Add mechanism to control early table checksum verification.
      ACPICA: acpidump: Fix repetitive table dump in -n mode.
      ACPI: Clean up acpi_os_map/unmap_memory() to eliminate __iomem.
      ACPICA: Clean up redudant definitions already defined elsewhere
      ACPICA: Linux headers: Add <asm/acenv.h> to remove mis-ordered inclusion of <asm/acpi.h>
      ACPICA: Linux headers: Add <acpi/platform/aclinuxex.h>
      ACPICA: Linux headers: Remove ACPI_PREEMPTION_POINT() due to no usages.
      ACPICA: Update version to 20140424.
      ACPICA: Comment/format update, no functional change.
      ACPICA: Events: Update GPE handling and initialization code.
      ACPICA: Remove extraneous error message for large number of GPEs.
      ACPICA: Tables: Remove old mechanism to validate if XSDT contains NULL entries.
      ACPICA: Tables: Add new mechanism to skip NULL entries in RSDT and XSDT.
      ACPICA: acpidump: Add support to force using RSDT.
      ACPICA: Back port of improvements on exception code.
      ACPICA: Back port of _PRP update.
      ACPICA: acpidump: Fix truncated RSDP signature validation.
      ACPICA: Linux header: Add support for stubbed externals.
      ...

commit 91ab377ba3ab202c40a0da402d6c2f1507a15355
Merge: 26f8784e2d7b 73577d1df8e1 72013795a73f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 3 23:10:06 2014 +0200

    Merge branches 'acpi-tables' and 'acpi-general'
    
    * acpi-tables:
      ACPI: Fix conflict between customized DSDT and DSDT local copy
    
    * acpi-general:
      ACPI: Add acpi_bus_attach_private_data() to attach data to ACPI handle

commit 4fc0a7e889e5540305926e41931cf3bc0a60abb2
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Sat May 31 08:15:02 2014 +0800

    ACPI: Fix x86 regression related to early mapping size limitation
    
    The following warning message is triggered:
     WARNING: CPU: 0 PID: 0 at mm/early_ioremap.c:136 __early_ioremap+0x11f/0x1f2()
     Modules linked in:
     CPU: 0 PID: 0 Comm: swapper Not tainted 3.15.0-rc1-00017-g86dfc6f3-dirty #298
     Hardware name: Intel Corporation S2600CP/S2600CP, BIOS SE5C600.86B.99.99.x036.091920111209 09/19/2011
      0000000000000009 ffffffff81b75c40 ffffffff817c627b 0000000000000000
      ffffffff81b75c78 ffffffff81067b5d 000000000000007b 8000000000000563
      00000000b96b20dc 0000000000000001 ffffffffff300e0c ffffffff81b75c88
     Call Trace:
      [<ffffffff817c627b>] dump_stack+0x45/0x56
      [<ffffffff81067b5d>] warn_slowpath_common+0x7d/0xa0
      [<ffffffff81067c3a>] warn_slowpath_null+0x1a/0x20
      [<ffffffff81d4b9d5>] __early_ioremap+0x11f/0x1f2
      [<ffffffff81d4bc5b>] early_ioremap+0x13/0x15
      [<ffffffff81d2b8f3>] __acpi_map_table+0x13/0x18
      [<ffffffff817b8d1a>] acpi_os_map_memory+0x26/0x14e
      [<ffffffff813ff018>] acpi_tb_acquire_table+0x42/0x70
      [<ffffffff813ff086>] acpi_tb_validate_table+0x27/0x37
      [<ffffffff813ff0e5>] acpi_tb_verify_table+0x22/0xd8
      [<ffffffff813ff6a8>] acpi_tb_install_non_fixed_table+0x60/0x1c9
      [<ffffffff81d61024>] acpi_tb_parse_root_table+0x218/0x26a
      [<ffffffff81d1b120>] ? early_idt_handlers+0x120/0x120
      [<ffffffff81d610cd>] acpi_initialize_tables+0x57/0x59
      [<ffffffff81d5f25d>] acpi_table_init+0x1b/0x99
      [<ffffffff81d2bca0>] acpi_boot_table_init+0x1e/0x85
      [<ffffffff81d23043>] setup_arch+0x99d/0xcc6
      [<ffffffff81d1b120>] ? early_idt_handlers+0x120/0x120
      [<ffffffff81d1bbbe>] start_kernel+0x8b/0x415
      [<ffffffff81d1b120>] ? early_idt_handlers+0x120/0x120
      [<ffffffff81d1b5ee>] x86_64_start_reservations+0x2a/0x2c
      [<ffffffff81d1b72e>] x86_64_start_kernel+0x13e/0x14d
     ---[ end trace 11ae599a1898f4e7 ]---
    when installing the following table during early stage:
     ACPI: SSDT 0x00000000B9638018 07A0C4 (v02 INTEL  S2600CP  00004000 INTL 20100331)
    The regression is caused by the size limitation of the x86 early IO mapping.
    
    The root cause is:
     1. ACPICA doesn't split IO memory mapping and table mapping;
     2. Linux x86 OSL implements acpi_os_map_memory() using a size limited fix-map
        mechanism during early boot stage, which is more suitable for only IO
        mappings.
    
    This patch fixes this issue by utilizing acpi_gbl_verify_table_checksum to
    disable the table mapping during early stage and enabling it again for the
    late stage. In this way, the normal code path is not affected. Then after
    the code related to the root cause is cleaned up, the early checksum
    verification can be easily re-enabled.
    
    A new boot parameter - acpi_force_table_verification is introduced for
    the platforms that require the checksum verification to stop loading bad
    tables.
    
    This fix also covers the checksum verification for the table overrides. Now
    large tables can also be overridden using the initrd override mechanism.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Reported-and-tested-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cf925c4f36b7..cf0b5ecf55b6 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -466,6 +466,9 @@ void __init acpi_early_init(void)
 
 	printk(KERN_INFO PREFIX "Core revision %08x\n", ACPI_CA_VERSION);
 
+	/* It's safe to verify table checksums during late stage */
+	acpi_gbl_verify_table_checksum = TRUE;
+
 	/* enable workarounds, unless strict ACPI spec. compliance */
 	if (!acpi_strict)
 		acpi_gbl_enable_interpreter_slack = TRUE;

commit 72013795a73f8536d3346fa90379c987bcad0cc8
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue May 20 20:59:21 2014 +0800

    ACPI: Add acpi_bus_attach_private_data() to attach data to ACPI handle
    
    There is already acpi_bus_get_private_data() to get ACPI handle data
    which is associated with acpi_bus_private_data_handler(). This patch
    is to add acpi_bus_attach_private_data() to make a pair and facilitate
    to attach and get data to/from ACPI handle.
    
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cf925c4f36b7..8445d570f60a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -132,6 +132,21 @@ void acpi_bus_private_data_handler(acpi_handle handle,
 }
 EXPORT_SYMBOL(acpi_bus_private_data_handler);
 
+int acpi_bus_attach_private_data(acpi_handle handle, void *data)
+{
+	acpi_status status;
+
+	status = acpi_attach_data(handle,
+			acpi_bus_private_data_handler, data);
+	if (ACPI_FAILURE(status)) {
+		acpi_handle_debug(handle, "Error attaching device data\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_attach_private_data);
+
 int acpi_bus_get_private_data(acpi_handle handle, void **data)
 {
 	acpi_status status;
@@ -140,15 +155,20 @@ int acpi_bus_get_private_data(acpi_handle handle, void **data)
 		return -EINVAL;
 
 	status = acpi_get_data(handle, acpi_bus_private_data_handler, data);
-	if (ACPI_FAILURE(status) || !*data) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
-				handle));
+	if (ACPI_FAILURE(status)) {
+		acpi_handle_debug(handle, "No context for object\n");
 		return -ENODEV;
 	}
 
 	return 0;
 }
-EXPORT_SYMBOL(acpi_bus_get_private_data);
+EXPORT_SYMBOL_GPL(acpi_bus_get_private_data);
+
+void acpi_bus_detach_private_data(acpi_handle handle)
+{
+	acpi_detach_data(handle, acpi_bus_private_data_handler);
+}
+EXPORT_SYMBOL_GPL(acpi_bus_detach_private_data);
 
 void acpi_bus_no_hotplug(acpi_handle handle)
 {

commit 73577d1df8e1f31f6b1a5eebcdbc334eb0330e47
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon May 12 15:50:16 2014 +0800

    ACPI: Fix conflict between customized DSDT and DSDT local copy
    
    This patch fixes the following issue:
    If DSDT is customized, no local DSDT copy is needed.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=69711
    Signed-off-by: Enrico Etxe Arte <goitizena.generoa@gmail.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: 2.6.35+ <stable@vger.kernel.org> # 2.6.35+
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cf925c4f36b7..ed9fca0250fa 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -52,6 +52,12 @@ struct proc_dir_entry *acpi_root_dir;
 EXPORT_SYMBOL(acpi_root_dir);
 
 #ifdef CONFIG_X86
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
+static inline int set_copy_dsdt(const struct dmi_system_id *id)
+{
+	return 0;
+}
+#else
 static int set_copy_dsdt(const struct dmi_system_id *id)
 {
 	printk(KERN_NOTICE "%s detected - "
@@ -59,6 +65,7 @@ static int set_copy_dsdt(const struct dmi_system_id *id)
 	acpi_gbl_copy_dsdt_locally = 1;
 	return 0;
 }
+#endif
 
 static struct dmi_system_id dsdt_dmi_table[] __initdata = {
 	/*

commit d0103387bc21644d297cb61ee623c7114e395575
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 1 01:16:06 2014 +0200

    ACPI / notify: Clean up handling of hotplug events
    
    Make the handling of hotplug events in acpi_bus_notify() slightly
    cleaner by using an extra local variable to indicate when
    acpi_hotplug_schedule() should be called.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cf925c4f36b7..610261a1b6c8 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -340,16 +340,18 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
 	struct acpi_device *adev;
 	struct acpi_driver *driver;
-	acpi_status status;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+	bool hotplug_event = false;
 
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
+		hotplug_event = true;
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK event\n");
+		hotplug_event = true;
 		break;
 
 	case ACPI_NOTIFY_DEVICE_WAKE:
@@ -358,6 +360,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
+		hotplug_event = true;
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
@@ -393,16 +396,9 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
 		driver->ops.notify(adev, type);
 
-	switch (type) {
-	case ACPI_NOTIFY_BUS_CHECK:
-	case ACPI_NOTIFY_DEVICE_CHECK:
-	case ACPI_NOTIFY_EJECT_REQUEST:
-		status = acpi_hotplug_schedule(adev, type);
-		if (ACPI_SUCCESS(status))
-			return;
-	default:
-		break;
-	}
+	if (hotplug_event && ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
+		return;
+
 	acpi_bus_put_acpi_device(adev);
 	return;
 

commit f66abe92ce498672ac44d550f51a526597c731c4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Apr 24 19:27:49 2014 +0200

    ACPI / notify: Do not block unknown type notifications in root handler
    
    Commit 1a699476e258 "ACPI / hotplug / PCI: Hotplug notifications from
    acpi_bus_notify()" changed the root notify handler, acpi_bus_notify(),
    to block unknown type norifications, but it overlooked the fact that
    they might be propagated to drivers via the ->notify() callback.
    
    Fix the problem by allowing drivers to receive unknown type
    notifications via ->notify() as before.
    
    Fixes: 1a699476e258 (ACPI / hotplug / PCI: Hotplug notifications from acpi_bus_notify())
    Reported-and-tested-by: Mantas Mikulnas <grawity@gmail.com>
    Reported-and-tested-by: Sitsofe Wheeler <sitsofe@yahoo.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e7e5844c87d0..cf925c4f36b7 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -380,9 +380,8 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 
 	default:
-		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
-		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
-		goto err;
+		acpi_handle_debug(handle, "Unknown event type 0x%x\n", type);
+		break;
 	}
 
 	adev = acpi_bus_get_acpi_device(handle);

commit 2eb060975df2aaca635801dcfb99eaa45ede98fe
Merge: 75c44eddcb49 700b8422fb9e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 17 13:48:18 2014 +0100

    Merge branch 'acpi-ost'
    
    * acpi-ost:
      ACPI: Drop acpi_evaluate_hotplug_ost() and ACPI_HOTPLUG_OST
      ACPI: use device name LNXSYBUS.xx for ACPI \_SB and \_TZ objects
      ACPI / processor: use acpi_evaluate_ost() to replace open-coded version
      ACPI / PAD / xen: use acpi_evaluate_ost() to replace open-coded version
      ACPI / PAD: use acpi_evaluate_ost() to replace open-coded version
      ACPI: rename acpi_evaluate_hotplug_ost() to acpi_evaluate_ost()

commit 1e3bcb596c6b1cf6db93f8f506e2de260e771bad
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 3 00:40:38 2014 +0100

    ACPI / hotplug: Rework deferred execution of acpi_device_hotplug()
    
    Since the only function executed by acpi_hotplug_execute() is
    acpi_device_hotplug() and it only is called by the ACPI core,
    simplify its definition so that it only takes two arguments, the
    ACPI device object pointer and event code, rename it to
    acpi_hotplug_schedule() and move its header from acpi_bus.h to
    the ACPI core's internal header file internal.h.  Modify the
    definition of acpi_device_hotplug() so that its first argument is
    an ACPI device object pointer and modify the definition of
    struct acpi_hp_work accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e61e7b8a2eaf..afe6f9a919c1 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -400,7 +400,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	case ACPI_NOTIFY_BUS_CHECK:
 	case ACPI_NOTIFY_DEVICE_CHECK:
 	case ACPI_NOTIFY_EJECT_REQUEST:
-		status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
+		status = acpi_hotplug_schedule(adev, type);
 		if (ACPI_SUCCESS(status))
 			return;
 	default:

commit 700b8422fb9e6041907bda45a15f4e2ab0438a04
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 21 01:07:17 2014 +0100

    ACPI: Drop acpi_evaluate_hotplug_ost() and ACPI_HOTPLUG_OST
    
    Replace acpi_evaluate_hotplug_ost() with acpi_evaluate_ost()
    everywhere and drop the ACPI_HOTPLUG_OST symbol so that hotplug
    _OST is supported unconditionally.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e61e7b8a2eaf..4cefb98f274d 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -311,9 +311,7 @@ static void acpi_bus_osc_support(void)
 	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PPC_OST_SUPPORT;
 #endif
 
-#ifdef ACPI_HOTPLUG_OST
 	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_HOTPLUG_OST_SUPPORT;
-#endif
 
 	if (!ghes_disable)
 		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_APEI_SUPPORT;
@@ -410,7 +408,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	return;
 
  err:
-	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
+	acpi_evaluate_ost(handle, type, ost_code, NULL);
 }
 
 /* --------------------------------------------------------------------------

commit 1a699476e25814343766342672c655fb135224cc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 6 13:58:13 2014 +0100

    ACPI / hotplug / PCI: Hotplug notifications from acpi_bus_notify()
    
    Since acpi_bus_notify() is executed on all notifications for all
    devices anyway, make it execute acpi_device_hotplug() for all
    hotplug events instead of installing notify handlers pointing to
    the same function for all hotplug devices.
    
    This change reduces both the size and complexity of ACPI-based device
    hotplug code.  Moreover, since acpi_device_hotplug() only does
    significant things for devices that have either an ACPI scan handler,
    or a hotplug context with .eject() defined, and those devices
    had notify handlers pointing to acpi_hotplug_notify_cb() installed
    before anyway, this modification shouldn't change functionality.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c3237774632f..e61e7b8a2eaf 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -340,62 +340,77 @@ static void acpi_bus_osc_support(void)
  */
 static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
-	struct acpi_device *device;
+	struct acpi_device *adev;
 	struct acpi_driver *driver;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Notification %#02x to handle %p\n",
-			  type, handle));
+	acpi_status status;
+	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 
 	switch (type) {
-
 	case ACPI_NOTIFY_BUS_CHECK:
-		/* TBD */
+		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		/* TBD */
+		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK event\n");
 		break;
 
 	case ACPI_NOTIFY_DEVICE_WAKE:
-		/* TBD */
+		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_WAKE event\n");
 		break;
 
 	case ACPI_NOTIFY_EJECT_REQUEST:
-		/* TBD */
+		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
+		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK_LIGHT event\n");
 		/* TBD: Exactly what does 'light' mean? */
 		break;
 
 	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
-		/* TBD */
+		acpi_handle_err(handle, "Device cannot be configured due "
+				"to a frequency mismatch\n");
 		break;
 
 	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
-		/* TBD */
+		acpi_handle_err(handle, "Device cannot be configured due "
+				"to a bus mode mismatch\n");
 		break;
 
 	case ACPI_NOTIFY_POWER_FAULT:
-		/* TBD */
+		acpi_handle_err(handle, "Device has suffered a power fault\n");
 		break;
 
 	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received unknown/unsupported notification [%08x]\n",
-				  type));
-		break;
+		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
+		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
+		goto err;
 	}
 
-	device = acpi_bus_get_acpi_device(handle);
-	if (device) {
-		driver = device->driver;
-		if (driver && driver->ops.notify &&
-		    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
-			driver->ops.notify(device, type);
+	adev = acpi_bus_get_acpi_device(handle);
+	if (!adev)
+		goto err;
 
-		acpi_bus_put_acpi_device(device);
+	driver = adev->driver;
+	if (driver && driver->ops.notify &&
+	    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
+		driver->ops.notify(adev, type);
+
+	switch (type) {
+	case ACPI_NOTIFY_BUS_CHECK:
+	case ACPI_NOTIFY_DEVICE_CHECK:
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
+		if (ACPI_SUCCESS(status))
+			return;
+	default:
+		break;
 	}
+	acpi_bus_put_acpi_device(adev);
+	return;
+
+ err:
+	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 }
 
 /* --------------------------------------------------------------------------

commit 78ea4639a7647f2fcc957c3a532bde49df9895c7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 4 00:43:05 2014 +0100

    ACPI / hotplug: Fix potential race in acpi_bus_notify()
    
    There is a slight possibility for the ACPI device object pointed to
    by adev in acpi_hotplug_notify_cb() to become invalid between the
    acpi_bus_get_device() that it comes from and the subsequent dereference
    of that pointer under get_device().  Namely, if acpi_scan_drop_device()
    runs in parallel with acpi_hotplug_notify_cb(), acpi_device_del_work_fn()
    queued up by it may delete the device object in question right after
    a successful execution of acpi_bus_get_device() in acpi_bus_notify().
    
    An analogous problem is present in acpi_bus_notify() where the device
    pointer coming from acpi_bus_get_device() may become invalid before
    it subsequent dereference in the "if" block.
    
    To prevent that from happening, introduce a new function,
    acpi_bus_get_acpi_device(), working analogously to acpi_bus_get_device()
    except that it will grab a reference to the ACPI device object returned
    by it and it will do that under the ACPICA's namespace mutex.  Then,
    make both acpi_hotplug_notify_cb() and acpi_bus_notify() use
    acpi_bus_get_acpi_device() instead of acpi_bus_get_device() so as to
    ensure that the pointers used by them will not become stale at one
    point.
    
    In addition to that, introduce acpi_bus_put_acpi_device() as a wrapper
    around put_device() to be used along with acpi_bus_get_acpi_device()
    and make the (new) users of the latter use acpi_bus_put_acpi_device()
    too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index fcb59c21c68d..c3237774632f 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -340,7 +340,7 @@ static void acpi_bus_osc_support(void)
  */
 static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
-	struct acpi_device *device = NULL;
+	struct acpi_device *device;
 	struct acpi_driver *driver;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Notification %#02x to handle %p\n",
@@ -387,12 +387,14 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 	}
 
-	acpi_bus_get_device(handle, &device);
+	device = acpi_bus_get_acpi_device(handle);
 	if (device) {
 		driver = device->driver;
 		if (driver && driver->ops.notify &&
 		    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
 			driver->ops.notify(device, type);
+
+		acpi_bus_put_acpi_device(device);
 	}
 }
 

commit 82e180598b54873553fb1d285fb0c90fc54f8f23
Merge: 09da8dfa9868 f778d1218f10 a951c773bc39 49a12877d277 79c0373f3e84 481c13814a4e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 29 11:47:18 2014 +0100

    Merge branches 'acpi-processor', 'acpi-hotplug', 'acpi-init', 'acpi-pm' and 'acpica'
    
    * acpi-processor:
      ACPI / scan: reduce log level of "ACPI: \_PR_.CPU4: failed to get CPU APIC ID"
      ACPI / processor: Return specific error value when mapping lapic id
    
    * acpi-hotplug:
      ACPI / scan: Clear match_driver flag in acpi_bus_trim()
    
    * acpi-init:
      ACPI / init: Flag use of ACPI and ACPI idioms for power supplies to regulator API
    
    * acpi-pm:
      ACPI / PM: Use ACPI_COMPANION() to get ACPI companions of devices
    
    * acpica:
      ACPICA: Remove bool usage from ACPICA.

commit 49a12877d2777cadcb838981c3c4f5a424aef310
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jan 27 00:32:14 2014 +0000

    ACPI / init: Flag use of ACPI and ACPI idioms for power supplies to regulator API
    
    There is currently no facility in ACPI to express the hookup of voltage
    regulators, the expectation is that the regulators that exist in the
    system will be handled transparently by firmware if they need software
    control at all. This means that if for some reason the regulator API is
    enabled on such a system it should assume that any supplies that devices
    need are provided by the system at all relevant times without any software
    intervention.
    
    Tell the regulator core to make this assumption by calling
    regulator_has_full_constraints(). Do this as soon as we know we are using
    ACPI so that the information is available to the regulator core as early
    as possible. This will cause the regulator core to pretend that there is
    an always on regulator supplying any supply that is requested but that has
    not otherwise been mapped which is the behaviour expected on a system with
    ACPI.
    
    Should the ability to specify regulators be added in future revisions of
    ACPI then once we have support for ACPI mappings in the kernel the same
    assumptions will apply. It is also likely that systems will default to a
    mode of operation which does not require any interpretation of these
    mappings in order to be compatible with existing operating system releases
    so it should remain safe to make these assumptions even if the mappings
    exist but are not supported by the kernel.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 0710004055c8..296bec89f4a1 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -33,6 +33,7 @@
 #include <linux/proc_fs.h>
 #include <linux/acpi.h>
 #include <linux/slab.h>
+#include <linux/regulator/machine.h>
 #ifdef CONFIG_X86
 #include <asm/mpspec.h>
 #endif
@@ -576,6 +577,14 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
+	/*
+	 * If the system is using ACPI then we can be reasonably
+	 * confident that any regulators are managed by the firmware
+	 * so tell the regulator core it has everything it needs to
+	 * know.
+	 */
+	regulator_has_full_constraints();
+
 	return;
 
       error0:

commit d1badf8d4323cfc9325b06651bdfcf7df09f1f0e
Merge: caa73ea158de f244d8b623da
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 31 13:41:08 2013 +0100

    Merge branch 'acpi-pci-hotplug' into acpi-hotplug
    
    Conflicts:
            include/acpi/acpi_bus.h

commit f244d8b623dae7a7bc695b0336f67729b95a9736
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 31 13:39:42 2013 +0100

    ACPIPHP / radeon / nouveau: Fix VGA switcheroo problem related to hotplug
    
    The changes in the ACPI-based PCI hotplug (ACPIPHP) subsystem made
    during the 3.12 development cycle uncovered a problem with VGA
    switcheroo that on some systems, when the device-specific method
    (ATPX in the radeon case, _DSM in the nouveau case) is used to turn
    off the discrete graphics, the BIOS generates ACPI hotplug events for
    that device and those events cause ACPIPHP to attempt to remove the
    device from the system (they are events for a device that was present
    previously and is not present any more, so that's what should be done
    according to the spec).  Then, the system stops functioning correctly.
    
    Since the hotplug events in question were simply silently ignored
    previously, the least intrusive way to address that problem is to
    make ACPIPHP ignore them again.  For this purpose, introduce a new
    ACPI device flag, no_hotplug, and modify ACPIPHP to ignore hotplug
    events for PCI devices whose ACPI companions have that flag set.
    Next, make the radeon and nouveau switcheroo detection code set the
    no_hotplug flag for the discrete graphics' ACPI companion.
    
    Fixes: bbd34fcdd1b2 (ACPI / hotplug / PCI: Register all devices under the given bridge)
    References: https://bugzilla.kernel.org/show_bug.cgi?id=61891
    References: https://bugzilla.kernel.org/show_bug.cgi?id=64891
    Reported-and-tested-by: Mike Lothian <mike@fireburn.co.uk>
    Reported-and-tested-by: <madcatx@atlas.cz>
    Reported-and-tested-by: Joaqun Aramenda <samsagax@gmail.com>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: 3.12+ <stable@vger.kernel.org> # 3.12+

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index bba9b72e25f8..0710004055c8 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -156,6 +156,16 @@ int acpi_bus_get_private_data(acpi_handle handle, void **data)
 }
 EXPORT_SYMBOL(acpi_bus_get_private_data);
 
+void acpi_bus_no_hotplug(acpi_handle handle)
+{
+	struct acpi_device *adev = NULL;
+
+	acpi_bus_get_device(handle, &adev);
+	if (adev)
+		adev->flags.no_hotplug = true;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_no_hotplug);
+
 static void acpi_print_osc_error(acpi_handle handle,
 	struct acpi_osc_context *context, char *error)
 {

commit 9ccad66f0171578445175ecd3bf66b35a96aaf6e
Merge: 8ff47aafb25c 8b48463f8942
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 7 01:05:17 2013 +0100

    Merge branch 'acpi-cleanup' into acpi-hotplug
    
    Conflicts:
            drivers/acpi/scan.c

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index bba9b72e25f8..cfea1c58f034 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -37,8 +37,6 @@
 #include <asm/mpspec.h>
 #endif
 #include <linux/pci.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
 #include <acpi/apei.h>
 #include <linux/dmi.h>
 #include <linux/suspend.h>

commit 25db115b0bf72acfdf8a339fa8e37d8b895214d6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:56:06 2013 +0100

    ACPI: Introduce acpi_set_device_status()
    
    Introduce a static inline function for setting the status field
    of struct acpi_device on the basis of a supplied u32 number,
    acpi_set_device_status(), and use it instead of the horrible
    horrible STRUCT_TO_INT() macro wherever applicable.  Having done
    that, drop STRUCT_TO_INT() (and pretend that it has never existed).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 8b09a75f6579..f509019ee2c7 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -52,9 +52,6 @@ struct acpi_device *acpi_root;
 struct proc_dir_entry *acpi_root_dir;
 EXPORT_SYMBOL(acpi_root_dir);
 
-#define STRUCT_TO_INT(s)	(*((int*)&s))
-
-
 #ifdef CONFIG_X86
 static int set_copy_dsdt(const struct dmi_system_id *id)
 {
@@ -115,18 +112,16 @@ int acpi_bus_get_status(struct acpi_device *device)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	STRUCT_TO_INT(device->status) = (int) sta;
+	acpi_set_device_status(device, sta);
 
 	if (device->status.functional && !device->status.present) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]: "
 		       "functional but not present;\n",
-			device->pnp.bus_id,
-			(u32) STRUCT_TO_INT(device->status)));
+			device->pnp.bus_id, (u32)sta));
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n",
-			  device->pnp.bus_id,
-			  (u32) STRUCT_TO_INT(device->status)));
+			  device->pnp.bus_id, (u32)sta));
 	return 0;
 }
 EXPORT_SYMBOL(acpi_bus_get_status);

commit f4b734c35e98c343cd99824153de09e48867b97e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:55:55 2013 +0100

    ACPI / hotplug: Drop unfinished global notification handling routines
    
    There are two global hotplug notification handling routines in bus.c,
    acpi_bus_check_device() and acpi_bus_check_scope(), that have never
    been finished and don't do anything useful, so drop them.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index bba9b72e25f8..8b09a75f6579 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -329,58 +329,6 @@ static void acpi_bus_osc_support(void)
                              Notification Handling
    -------------------------------------------------------------------------- */
 
-static void acpi_bus_check_device(acpi_handle handle)
-{
-	struct acpi_device *device;
-	acpi_status status;
-	struct acpi_device_status old_status;
-
-	if (acpi_bus_get_device(handle, &device))
-		return;
-	if (!device)
-		return;
-
-	old_status = device->status;
-
-	/*
-	 * Make sure this device's parent is present before we go about
-	 * messing with the device.
-	 */
-	if (device->parent && !device->parent->status.present) {
-		device->status = device->parent->status;
-		return;
-	}
-
-	status = acpi_bus_get_status(device);
-	if (ACPI_FAILURE(status))
-		return;
-
-	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
-		return;
-
-	/*
-	 * Device Insertion/Removal
-	 */
-	if ((device->status.present) && !(old_status.present)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device insertion detected\n"));
-		/* TBD: Handle device insertion */
-	} else if (!(device->status.present) && (old_status.present)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device removal detected\n"));
-		/* TBD: Handle device removal */
-	}
-}
-
-static void acpi_bus_check_scope(acpi_handle handle)
-{
-	/* Status Change? */
-	acpi_bus_check_device(handle);
-
-	/*
-	 * TBD: Enumerate child devices within this device's scope and
-	 *       run acpi_bus_check_device()'s on them.
-	 */
-}
-
 /**
  * acpi_bus_notify
  * ---------------
@@ -397,19 +345,11 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	switch (type) {
 
 	case ACPI_NOTIFY_BUS_CHECK:
-		acpi_bus_check_scope(handle);
-		/*
-		 * TBD: We'll need to outsource certain events to non-ACPI
-		 *      drivers via the device manager (device.c).
-		 */
+		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		acpi_bus_check_device(handle);
-		/*
-		 * TBD: We'll need to outsource certain events to non-ACPI
-		 *      drivers via the device manager (device.c).
-		 */
+		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_DEVICE_WAKE:

commit 2f466d33f5f60542d3d82c0477de5863b22c94b9
Merge: f9300eaaac1c eaaeb1cb3331
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 14 14:02:00 2013 +0900

    Merge tag 'pci-v3.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Resource management
        - Fix host bridge window coalescing (Alexey Neyman)
        - Pass type, width, and prefetchability for window alignment (Wei Yang)
    
      PCI device hotplug
        - Convert acpiphp, acpiphp_ibm to dynamic debug (Lan Tianyu)
    
      Power management
        - Remove pci_pm_complete() (Liu Chuansheng)
    
      MSI
        - Fail initialization if device is not in PCI_D0 (Yijing Wang)
    
      MPS (Max Payload Size)
        - Use pcie_get_mps() and pcie_set_mps() to simplify code (Yijing Wang)
        - Use pcie_set_readrq() to simplify code (Yijing Wang)
        - Use cached pci_dev->pcie_mpss to simplify code (Yijing Wang)
    
      SR-IOV
        - Enable upstream bridges even for VFs on virtual buses (Bjorn Helgaas)
        - Use pci_is_root_bus() to avoid catching virtual buses (Wei Yang)
    
      Virtualization
        - Add x86 MSI masking ops (Konrad Rzeszutek Wilk)
    
      Freescale i.MX6
        - Support i.MX6 PCIe controller (Sean Cross)
        - Increase link startup timeout (Marek Vasut)
        - Probe PCIe in fs_initcall() (Marek Vasut)
        - Fix imprecise abort handler (Tim Harvey)
        - Remove redundant of_match_ptr (Sachin Kamat)
    
      Renesas R-Car
        - Support Gen2 internal PCIe controller (Valentine Barshak)
    
      Samsung Exynos
        - Add MSI support (Jingoo Han)
        - Turn off power when link fails (Jingoo Han)
        - Add Jingoo Han as maintainer (Jingoo Han)
        - Add clk_disable_unprepare() on error path (Wei Yongjun)
        - Remove redundant of_match_ptr (Sachin Kamat)
    
      Synopsys DesignWare
        - Add irq_create_mapping() (Pratyush Anand)
        - Add header guards (Seungwon Jeon)
    
      Miscellaneous
        - Enable native PCIe services by default on non-ACPI (Andrew Murray)
        - Cleanup _OSC usage and messages (Bjorn Helgaas)
        - Remove pcibios_last_bus boot option on non-x86 (Bjorn Helgaas)
        - Convert bus code to use bus_, drv_, and dev_groups (Greg Kroah-Hartman)
        - Remove unused pci_mem_start (Myron Stowe)
        - Make sysfs functions static (Sachin Kamat)
        - Warn on invalid return from driver probe (Stephen M. Cameron)
        - Remove Intel Haswell D3 delays (Todd E Brandt)
        - Call pci_set_master() in core if driver doesn't do it (Yinghai Lu)
        - Use pci_is_pcie() to simplify code (Yijing Wang)
        - Use PCIe capability accessors to simplify code (Yijing Wang)
        - Use cached pci_dev->pcie_cap to simplify code (Yijing Wang)
        - Removed unused "is_pcie" from struct pci_dev (Yijing Wang)
        - Simplify sysfs CPU affinity implementation (Yijing Wang)"
    
    * tag 'pci-v3.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (79 commits)
      PCI: Enable upstream bridges even for VFs on virtual buses
      PCI: Add pci_upstream_bridge()
      PCI: Add x86_msi.msi_mask_irq() and msix_mask_irq()
      PCI: Warn on driver probe return value greater than zero
      PCI: Drop warning about drivers that don't use pci_set_master()
      PCI: Workaround missing pci_set_master in pci drivers
      powerpc/pci: Use pci_is_pcie() to simplify code [fix]
      PCI: Update pcie_ports 'auto' behavior for non-ACPI platforms
      PCI: imx6: Probe the PCIe in fs_initcall()
      PCI: Add R-Car Gen2 internal PCI support
      PCI: imx6: Remove redundant of_match_ptr
      PCI: Report pci_pme_active() kmalloc failure
      mn10300/PCI: Remove useless pcibios_last_bus
      frv/PCI: Remove pcibios_last_bus
      PCI: imx6: Increase link startup timeout
      PCI: exynos: Remove redundant of_match_ptr
      PCI: imx6: Fix imprecise abort handler
      PCI: Fail MSI/MSI-X initialization if device is not in PCI_D0
      PCI: imx6: Remove redundant dev_err() in imx6_pcie_probe()
      x86/PCI: Coalesce multiple overlapping host bridge windows
      ...

commit 4b3db708b114fc35ff1e0cd28a2bfb1490dbb5d3
Author: Chen, Gong <gong.chen@linux.intel.com>
Date:   Mon Oct 21 14:29:25 2013 -0700

    ACPI, x86: Extended error log driver for x86 platform
    
    This H/W error log driver (a.k.a eMCA driver) is implemented based on
    http://www.intel.com/content/www/us/en/architecture-and-technology/enhanced-mca-logging-xeon-paper.html
    
    After errors are captured, more detailed platform specific information
    can be got via this new enhanced H/W error log driver. Most notably we
    can track memory errors back to the DIMM slot silk screen label.
    
    Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index b587ec8257b2..e1bd9a181117 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -174,7 +174,7 @@ static void acpi_print_osc_error(acpi_handle handle,
 	printk("\n");
 }
 
-static acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
+acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
 {
 	int i;
 	static int opc_map_to_uuid[16] = {6, 4, 2, 0, 11, 9, 16, 14, 19, 21,
@@ -195,6 +195,7 @@ static acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
 	}
 	return AE_OK;
 }
+EXPORT_SYMBOL_GPL(acpi_str_to_uuid);
 
 acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 {

commit b938a229c85a567de7dba2d806d9f63a7c90483e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 5 15:05:54 2013 -0600

    ACPI: Rename OSC_QUERY_TYPE to OSC_QUERY_DWORD
    
    OSC_QUERY_TYPE isn't a "type"; it's an index into the _OSC Capabilities
    Buffer of DWORDs.  Rename OSC_QUERY_TYPE, OSC_SUPPORT_TYPE, and
    OSC_CONTROL_TYPE to OSC_QUERY_DWORD, etc., to make this clear.
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index b587ec8257b2..fbcfaa682c15 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -255,7 +255,7 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 			acpi_print_osc_error(handle, context,
 				"_OSC invalid revision");
 		if (errors & OSC_CAPABILITIES_MASK_ERROR) {
-			if (((u32 *)context->cap.pointer)[OSC_QUERY_TYPE]
+			if (((u32 *)context->cap.pointer)[OSC_QUERY_DWORD]
 			    & OSC_QUERY_ENABLE)
 				goto out_success;
 			status = AE_SUPPORT;
@@ -295,30 +295,30 @@ static void acpi_bus_osc_support(void)
 	};
 	acpi_handle handle;
 
-	capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
-	capbuf[OSC_SUPPORT_TYPE] = OSC_SB_PR3_SUPPORT; /* _PR3 is in use */
+	capbuf[OSC_QUERY_DWORD] = OSC_QUERY_ENABLE;
+	capbuf[OSC_SUPPORT_DWORD] = OSC_SB_PR3_SUPPORT; /* _PR3 is in use */
 #if defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR) ||\
 			defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE)
-	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PAD_SUPPORT;
+	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PAD_SUPPORT;
 #endif
 
 #if defined(CONFIG_ACPI_PROCESSOR) || defined(CONFIG_ACPI_PROCESSOR_MODULE)
-	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PPC_OST_SUPPORT;
+	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PPC_OST_SUPPORT;
 #endif
 
 #ifdef ACPI_HOTPLUG_OST
-	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_HOTPLUG_OST_SUPPORT;
+	capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_HOTPLUG_OST_SUPPORT;
 #endif
 
 	if (!ghes_disable)
-		capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_APEI_SUPPORT;
+		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_APEI_SUPPORT;
 	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))
 		return;
 	if (ACPI_SUCCESS(acpi_run_osc(handle, &context))) {
 		u32 *capbuf_ret = context.ret.pointer;
-		if (context.ret.length > OSC_SUPPORT_TYPE)
+		if (context.ret.length > OSC_SUPPORT_DWORD)
 			osc_sb_apei_support_acked =
-				capbuf_ret[OSC_SUPPORT_TYPE] & OSC_SB_APEI_SUPPORT;
+				capbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_APEI_SUPPORT;
 		kfree(context.ret.pointer);
 	}
 	/* do we need to check other returned cap? Sounds no */

commit 0c581415b522267138d807814e526aa7534b9a61
Merge: afdca01c9821 7702ae0dd9b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:29:04 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / osl: Kill macro INVALID_TABLE().
      earlycpio.c: Fix the confusing comment of find_cpio_data().
      ACPI / x86: Print Hot-Pluggable Field in SRAT.
      ACPI / thermal: Use THERMAL_TRIPS_NONE macro to replace number
      ACPI / thermal: Remove unused macros in the driver/acpi/thermal.c
      ACPI / thermal: Remove the unused lock of struct acpi_thermal
      ACPI / osl: Fix osi_setup_entries[] __initdata attribute location
      ACPI / numa: Fix __init attribute location in slit_valid()
      ACPI / dock: Fix __init attribute location in find_dock_and_bay()
      ACPI / Sleep: Fix incorrect placement of __initdata
      ACPI / processor: Fix incorrect placement of __initdata
      ACPI / EC: Fix incorrect placement of __initdata
      ACPI / scan: Drop unnecessary label from acpi_create_platform_device()
      ACPI: Move acpi_bus_get_device() from bus.c to scan.c
      ACPI / scan: Allow platform device creation without any IO resources
      ACPI: Cleanup sparse warning on acpi_os_initialize1()
      platform / thinkpad: Remove deprecated hotkey_report_mode parameter
      ACPI: Remove the old /proc/acpi/event interface

commit caf5c03f17c33a14ef0e7033000f89e4d0910f5a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 14:38:34 2013 +0200

    ACPI: Move acpi_bus_get_device() from bus.c to scan.c
    
    Move acpi_bus_get_device() from bus.c to scan.c which allows
    acpi_bus_data_handler() to become static and clean up the latter.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 25b289ff4290..7df97d277545 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -89,27 +89,6 @@ static struct dmi_system_id dsdt_dmi_table[] __initdata = {
                                 Device Management
    -------------------------------------------------------------------------- */
 
-int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
-{
-	acpi_status status;
-
-	if (!device)
-		return -EINVAL;
-
-	/* TBD: Support fixed-feature devices */
-
-	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
-	if (ACPI_FAILURE(status) || !*device) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
-				  handle));
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-EXPORT_SYMBOL(acpi_bus_get_device);
-
 acpi_status acpi_bus_get_status_handle(acpi_handle handle,
 				       unsigned long long *sta)
 {

commit 1129c92faa069581bf3acf34cae92477bd6161d8
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Jul 23 16:11:55 2013 +0800

    ACPI: Cleanup sparse warning on acpi_os_initialize1()
    
    This patch cleans up the following sparse warning:
    
    # make C=2 drivers/acpi/osl.o
    ...
    drivers/acpi/osl.c:1775:20: warning: symbol 'acpi_os_initialize1' was not declared. Should it be static?
    ...
      CC      drivers/acpi/osl.o
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index b6e9a3786e2d..25b289ff4290 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -617,7 +617,6 @@ static int __init acpi_bus_init(void)
 {
 	int result;
 	acpi_status status;
-	extern acpi_status acpi_os_initialize1(void);
 
 	acpi_os_initialize1();
 

commit 1696d9dc57e062ce5200f6a42a6aaada15b434bb
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 15 10:15:09 2013 +0200

    ACPI: Remove the old /proc/acpi/event interface
    
    It is quite some time that this one has been deprecated.
    Get rid of it.
    
    Should some really important user be overseen, it may be reverted and
    the userspace program worked on first, but it is time to do something
    to get rid of this old stuff...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Matthew Garrett <matthew.garrett@nebula.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a5bb33bab448..b6e9a3786e2d 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -345,104 +345,6 @@ static void acpi_bus_osc_support(void)
 	/* do we need to check other returned cap? Sounds no */
 }
 
-/* --------------------------------------------------------------------------
-                                Event Management
-   -------------------------------------------------------------------------- */
-
-#ifdef CONFIG_ACPI_PROC_EVENT
-static DEFINE_SPINLOCK(acpi_bus_event_lock);
-
-LIST_HEAD(acpi_bus_event_list);
-DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
-
-extern int event_is_open;
-
-int acpi_bus_generate_proc_event4(const char *device_class, const char *bus_id, u8 type, int data)
-{
-	struct acpi_bus_event *event;
-	unsigned long flags;
-
-	/* drop event on the floor if no one's listening */
-	if (!event_is_open)
-		return 0;
-
-	event = kzalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC);
-	if (!event)
-		return -ENOMEM;
-
-	strcpy(event->device_class, device_class);
-	strcpy(event->bus_id, bus_id);
-	event->type = type;
-	event->data = data;
-
-	spin_lock_irqsave(&acpi_bus_event_lock, flags);
-	list_add_tail(&event->node, &acpi_bus_event_list);
-	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
-
-	wake_up_interruptible(&acpi_bus_event_queue);
-
-	return 0;
-
-}
-
-EXPORT_SYMBOL_GPL(acpi_bus_generate_proc_event4);
-
-int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
-{
-	if (!device)
-		return -EINVAL;
-	return acpi_bus_generate_proc_event4(device->pnp.device_class,
-					     device->pnp.bus_id, type, data);
-}
-
-EXPORT_SYMBOL(acpi_bus_generate_proc_event);
-
-int acpi_bus_receive_event(struct acpi_bus_event *event)
-{
-	unsigned long flags;
-	struct acpi_bus_event *entry = NULL;
-
-	DECLARE_WAITQUEUE(wait, current);
-
-
-	if (!event)
-		return -EINVAL;
-
-	if (list_empty(&acpi_bus_event_list)) {
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		add_wait_queue(&acpi_bus_event_queue, &wait);
-
-		if (list_empty(&acpi_bus_event_list))
-			schedule();
-
-		remove_wait_queue(&acpi_bus_event_queue, &wait);
-		set_current_state(TASK_RUNNING);
-
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-	}
-
-	spin_lock_irqsave(&acpi_bus_event_lock, flags);
-	if (!list_empty(&acpi_bus_event_list)) {
-		entry = list_entry(acpi_bus_event_list.next,
-				   struct acpi_bus_event, node);
-		list_del(&entry->node);
-	}
-	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
-
-	if (!entry)
-		return -ENODEV;
-
-	memcpy(event, entry, sizeof(struct acpi_bus_event));
-
-	kfree(entry);
-
-	return 0;
-}
-
-#endif	/* CONFIG_ACPI_PROC_EVENT */
-
 /* --------------------------------------------------------------------------
                              Notification Handling
    -------------------------------------------------------------------------- */

commit f716fc2ac037c45a6c641eb9f20ec602e8d04e14
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jun 30 23:49:55 2013 +0200

    ACPI: Drop ACPI bus notifier call chain
    
    There are no users of the ACPI bus notifier call chain,
    acpi_bus_notify_list, any more, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a5a032e2344e..6fd27a9abcda 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -499,19 +499,6 @@ static void acpi_bus_check_scope(acpi_handle handle)
 	 */
 }
 
-static BLOCKING_NOTIFIER_HEAD(acpi_bus_notify_list);
-int register_acpi_bus_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&acpi_bus_notify_list, nb);
-}
-EXPORT_SYMBOL_GPL(register_acpi_bus_notifier);
-
-void unregister_acpi_bus_notifier(struct notifier_block *nb)
-{
-	blocking_notifier_chain_unregister(&acpi_bus_notify_list, nb);
-}
-EXPORT_SYMBOL_GPL(unregister_acpi_bus_notifier);
-
 /**
  * acpi_bus_notify
  * ---------------
@@ -525,9 +512,6 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Notification %#02x to handle %p\n",
 			  type, handle));
 
-	blocking_notifier_call_chain(&acpi_bus_notify_list,
-		type, (void *)handle);
-
 	switch (type) {
 
 	case ACPI_NOTIFY_BUS_CHECK:

commit 0db98202605c3d32e023d43c30b5bd878f520976
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:39 2013 +0800

    ACPI: introduce helper function acpi_execute_simple_method()
    
    Introduce helper function acpi_execute_simple_method() and use it in
    a number of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a5bb33bab448..a5a032e2344e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -593,8 +593,6 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 static int __init acpi_bus_init_irq(void)
 {
 	acpi_status status;
-	union acpi_object arg = { ACPI_TYPE_INTEGER };
-	struct acpi_object_list arg_list = { 1, &arg };
 	char *message = NULL;
 
 
@@ -623,9 +621,7 @@ static int __init acpi_bus_init_irq(void)
 
 	printk(KERN_INFO PREFIX "Using %s for interrupt routing\n", message);
 
-	arg.integer.value = acpi_irq_model;
-
-	status = acpi_evaluate_object(NULL, "\\_PIC", &arg_list, NULL);
+	status = acpi_execute_simple_method(NULL, "\\_PIC", acpi_irq_model);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PIC"));
 		return -ENODEV;

commit 6a8c0af6e2d6c472517959b66c96900151c9cb5b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jun 3 18:20:24 2013 +0000

    ACPI: Remove useless initializers
    
    These local variables are all initialized at their first use, so there's
    no point in initializing them earlier.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 292de3cab9cc..a5bb33bab448 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -91,8 +91,7 @@ static struct dmi_system_id dsdt_dmi_table[] __initdata = {
 
 int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 {
-	acpi_status status = AE_OK;
-
+	acpi_status status;
 
 	if (!device)
 		return -EINVAL;
@@ -162,7 +161,7 @@ EXPORT_SYMBOL(acpi_bus_private_data_handler);
 
 int acpi_bus_get_private_data(acpi_handle handle, void **data)
 {
-	acpi_status status = AE_OK;
+	acpi_status status;
 
 	if (!*data)
 		return -EINVAL;
@@ -361,7 +360,7 @@ extern int event_is_open;
 int acpi_bus_generate_proc_event4(const char *device_class, const char *bus_id, u8 type, int data)
 {
 	struct acpi_bus_event *event;
-	unsigned long flags = 0;
+	unsigned long flags;
 
 	/* drop event on the floor if no one's listening */
 	if (!event_is_open)
@@ -400,7 +399,7 @@ EXPORT_SYMBOL(acpi_bus_generate_proc_event);
 
 int acpi_bus_receive_event(struct acpi_bus_event *event)
 {
-	unsigned long flags = 0;
+	unsigned long flags;
 	struct acpi_bus_event *entry = NULL;
 
 	DECLARE_WAITQUEUE(wait, current);
@@ -593,7 +592,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 
 static int __init acpi_bus_init_irq(void)
 {
-	acpi_status status = AE_OK;
+	acpi_status status;
 	union acpi_object arg = { ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg };
 	char *message = NULL;
@@ -640,7 +639,7 @@ u8 acpi_gbl_permanent_mmap;
 
 void __init acpi_early_init(void)
 {
-	acpi_status status = AE_OK;
+	acpi_status status;
 
 	if (acpi_disabled)
 		return;
@@ -714,8 +713,8 @@ void __init acpi_early_init(void)
 
 static int __init acpi_bus_init(void)
 {
-	int result = 0;
-	acpi_status status = AE_OK;
+	int result;
+	acpi_status status;
 	extern acpi_status acpi_os_initialize1(void);
 
 	acpi_os_initialize1();

commit e2cb5f08469c991b187f66fa627d7673c7f3361b
Author: Andrei Epure <epure.andrei@gmail.com>
Date:   Mon Mar 11 08:20:16 2013 +0000

    ACPI: replace kmalloc+memcpy with kmemdup
    
    Replace the combination of kmalloc() and memcpy() in acpi_run_osc()
    with a single call to kmemdup().
    
    [rjw: Changelog]
    Signed-off-by: Andrei Epure <epure.andrei@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 01708a165368..292de3cab9cc 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -288,13 +288,12 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 	}
 out_success:
 	context->ret.length = out_obj->buffer.length;
-	context->ret.pointer = kmalloc(context->ret.length, GFP_KERNEL);
+	context->ret.pointer = kmemdup(out_obj->buffer.pointer,
+				       context->ret.length, GFP_KERNEL);
 	if (!context->ret.pointer) {
 		status =  AE_NO_MEMORY;
 		goto out_kfree;
 	}
-	memcpy(context->ret.pointer, out_obj->buffer.pointer,
-		context->ret.length);
 	status =  AE_OK;
 
 out_kfree:

commit 9ce4e607111764673f7a59d7bc87a16ade5c7bba
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:08 2013 +0100

    ACPI / PM: Move device power management functions to device_pm.c
    
    Move ACPI device power management functions from drivers/acpi/bus.c
    to drivers/acpi/device_pm.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 6c9b16c16660..01708a165368 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -178,299 +178,6 @@ int acpi_bus_get_private_data(acpi_handle handle, void **data)
 }
 EXPORT_SYMBOL(acpi_bus_get_private_data);
 
-/* --------------------------------------------------------------------------
-                                 Power Management
-   -------------------------------------------------------------------------- */
-
-/**
- * acpi_power_state_string - String representation of ACPI device power state.
- * @state: ACPI device power state to return the string representation of.
- */
-const char *acpi_power_state_string(int state)
-{
-	switch (state) {
-	case ACPI_STATE_D0:
-		return "D0";
-	case ACPI_STATE_D1:
-		return "D1";
-	case ACPI_STATE_D2:
-		return "D2";
-	case ACPI_STATE_D3_HOT:
-		return "D3hot";
-	case ACPI_STATE_D3_COLD:
-		return "D3";
-	default:
-		return "(unknown)";
-	}
-}
-
-/**
- * acpi_device_get_power - Get power state of an ACPI device.
- * @device: Device to get the power state of.
- * @state: Place to store the power state of the device.
- *
- * This function does not update the device's power.state field, but it may
- * update its parent's power.state field (when the parent's power state is
- * unknown and the device's power state turns out to be D0).
- */
-int acpi_device_get_power(struct acpi_device *device, int *state)
-{
-	int result = ACPI_STATE_UNKNOWN;
-
-	if (!device || !state)
-		return -EINVAL;
-
-	if (!device->flags.power_manageable) {
-		/* TBD: Non-recursive algorithm for walking up hierarchy. */
-		*state = device->parent ?
-			device->parent->power.state : ACPI_STATE_D0;
-		goto out;
-	}
-
-	/*
-	 * Get the device's power state either directly (via _PSC) or
-	 * indirectly (via power resources).
-	 */
-	if (device->power.flags.explicit_get) {
-		unsigned long long psc;
-		acpi_status status = acpi_evaluate_integer(device->handle,
-							   "_PSC", NULL, &psc);
-		if (ACPI_FAILURE(status))
-			return -ENODEV;
-
-		result = psc;
-	}
-	/* The test below covers ACPI_STATE_UNKNOWN too. */
-	if (result <= ACPI_STATE_D2) {
-	  ; /* Do nothing. */
-	} else if (device->power.flags.power_resources) {
-		int error = acpi_power_get_inferred_state(device, &result);
-		if (error)
-			return error;
-	} else if (result == ACPI_STATE_D3_HOT) {
-		result = ACPI_STATE_D3;
-	}
-
-	/*
-	 * If we were unsure about the device parent's power state up to this
-	 * point, the fact that the device is in D0 implies that the parent has
-	 * to be in D0 too.
-	 */
-	if (device->parent && device->parent->power.state == ACPI_STATE_UNKNOWN
-	    && result == ACPI_STATE_D0)
-		device->parent->power.state = ACPI_STATE_D0;
-
-	*state = result;
-
- out:
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is %s\n",
-			  device->pnp.bus_id, acpi_power_state_string(*state)));
-
-	return 0;
-}
-
-
-/**
- * acpi_device_set_power - Set power state of an ACPI device.
- * @device: Device to set the power state of.
- * @state: New power state to set.
- *
- * Callers must ensure that the device is power manageable before using this
- * function.
- */
-int acpi_device_set_power(struct acpi_device *device, int state)
-{
-	int result = 0;
-	acpi_status status = AE_OK;
-	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
-	bool cut_power = false;
-
-	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
-		return -EINVAL;
-
-	/* Make sure this is a valid target state */
-
-	if (state == device->power.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at %s\n",
-				  acpi_power_state_string(state)));
-		return 0;
-	}
-
-	if (!device->power.states[state].flags.valid) {
-		printk(KERN_WARNING PREFIX "Device does not support %s\n",
-		       acpi_power_state_string(state));
-		return -ENODEV;
-	}
-	if (device->parent && (state < device->parent->power.state)) {
-		printk(KERN_WARNING PREFIX
-			      "Cannot set device to a higher-powered"
-			      " state than parent\n");
-		return -ENODEV;
-	}
-
-	/* For D3cold we should first transition into D3hot. */
-	if (state == ACPI_STATE_D3_COLD
-	    && device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible) {
-		state = ACPI_STATE_D3_HOT;
-		object_name[3] = '3';
-		cut_power = true;
-	}
-
-	/*
-	 * Transition Power
-	 * ----------------
-	 * On transitions to a high-powered state we first apply power (via
-	 * power resources) then evalute _PSx.  Conversly for transitions to
-	 * a lower-powered state.
-	 */
-	if (state < device->power.state) {
-		if (device->power.state >= ACPI_STATE_D3_HOT &&
-		    state != ACPI_STATE_D0) {
-			printk(KERN_WARNING PREFIX
-			      "Cannot transition to non-D0 state from D3\n");
-			return -ENODEV;
-		}
-		if (device->power.flags.power_resources) {
-			result = acpi_power_transition(device, state);
-			if (result)
-				goto end;
-		}
-		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle,
-						      object_name, NULL, NULL);
-			if (ACPI_FAILURE(status)) {
-				result = -ENODEV;
-				goto end;
-			}
-		}
-	} else {
-		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle,
-						      object_name, NULL, NULL);
-			if (ACPI_FAILURE(status)) {
-				result = -ENODEV;
-				goto end;
-			}
-		}
-		if (device->power.flags.power_resources) {
-			result = acpi_power_transition(device, state);
-			if (result)
-				goto end;
-		}
-	}
-
-	if (cut_power)
-		result = acpi_power_transition(device, ACPI_STATE_D3_COLD);
-
-      end:
-	if (result)
-		printk(KERN_WARNING PREFIX
-			      "Device [%s] failed to transition to %s\n",
-			      device->pnp.bus_id,
-			      acpi_power_state_string(state));
-	else {
-		device->power.state = state;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Device [%s] transitioned to %s\n",
-				  device->pnp.bus_id,
-				  acpi_power_state_string(state)));
-	}
-
-	return result;
-}
-EXPORT_SYMBOL(acpi_device_set_power);
-
-
-int acpi_bus_set_power(acpi_handle handle, int state)
-{
-	struct acpi_device *device;
-	int result;
-
-	result = acpi_bus_get_device(handle, &device);
-	if (result)
-		return result;
-
-	if (!device->flags.power_manageable) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"Device [%s] is not power manageable\n",
-				dev_name(&device->dev)));
-		return -ENODEV;
-	}
-
-	return acpi_device_set_power(device, state);
-}
-EXPORT_SYMBOL(acpi_bus_set_power);
-
-
-int acpi_bus_init_power(struct acpi_device *device)
-{
-	int state;
-	int result;
-
-	if (!device)
-		return -EINVAL;
-
-	device->power.state = ACPI_STATE_UNKNOWN;
-
-	result = acpi_device_get_power(device, &state);
-	if (result)
-		return result;
-
-	if (device->power.flags.power_resources)
-		result = acpi_power_on_resources(device, state);
-
-	if (!result)
-		device->power.state = state;
-
-	return result;
-}
-
-
-int acpi_bus_update_power(acpi_handle handle, int *state_p)
-{
-	struct acpi_device *device;
-	int state;
-	int result;
-
-	result = acpi_bus_get_device(handle, &device);
-	if (result)
-		return result;
-
-	result = acpi_device_get_power(device, &state);
-	if (result)
-		return result;
-
-	result = acpi_device_set_power(device, state);
-	if (!result && state_p)
-		*state_p = state;
-
-	return result;
-}
-EXPORT_SYMBOL_GPL(acpi_bus_update_power);
-
-
-bool acpi_bus_power_manageable(acpi_handle handle)
-{
-	struct acpi_device *device;
-	int result;
-
-	result = acpi_bus_get_device(handle, &device);
-	return result ? false : device->flags.power_manageable;
-}
-
-EXPORT_SYMBOL(acpi_bus_power_manageable);
-
-bool acpi_bus_can_wakeup(acpi_handle handle)
-{
-	struct acpi_device *device;
-	int result;
-
-	result = acpi_bus_get_device(handle, &device);
-	return result ? false : device->wakeup.flags.valid;
-}
-
-EXPORT_SYMBOL(acpi_bus_can_wakeup);
-
 static void acpi_print_osc_error(acpi_handle handle,
 	struct acpi_osc_context *context, char *error)
 {

commit 96bfd3cee2a741906b3ef5c1096d2f0a0b8025e0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:08 2013 +0100

    ACPI / PM: Common string representations of device power states
    
    The function returning string representations of ACPI device power
    states, state_string((), is now static, because it is only used
    internally in drivers/acpi/bus.c.  However, it will be used outside
    of that file going forward, so rename it to
    acpi_power_state_string(), add a kerneldoc comment to it and add its
    header to acpi_bus.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 0e1441cc4d7f..6c9b16c16660 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -182,7 +182,11 @@ EXPORT_SYMBOL(acpi_bus_get_private_data);
                                  Power Management
    -------------------------------------------------------------------------- */
 
-static const char *state_string(int state)
+/**
+ * acpi_power_state_string - String representation of ACPI device power state.
+ * @state: ACPI device power state to return the string representation of.
+ */
+const char *acpi_power_state_string(int state)
 {
 	switch (state) {
 	case ACPI_STATE_D0:
@@ -260,7 +264,7 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 
  out:
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is %s\n",
-			  device->pnp.bus_id, state_string(*state)));
+			  device->pnp.bus_id, acpi_power_state_string(*state)));
 
 	return 0;
 }
@@ -288,13 +292,13 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 
 	if (state == device->power.state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at %s\n",
-				  state_string(state)));
+				  acpi_power_state_string(state)));
 		return 0;
 	}
 
 	if (!device->power.states[state].flags.valid) {
 		printk(KERN_WARNING PREFIX "Device does not support %s\n",
-		       state_string(state));
+		       acpi_power_state_string(state));
 		return -ENODEV;
 	}
 	if (device->parent && (state < device->parent->power.state)) {
@@ -362,12 +366,14 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	if (result)
 		printk(KERN_WARNING PREFIX
 			      "Device [%s] failed to transition to %s\n",
-			      device->pnp.bus_id, state_string(state));
+			      device->pnp.bus_id,
+			      acpi_power_state_string(state));
 	else {
 		device->power.state = state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to %s\n",
-				  device->pnp.bus_id, state_string(state)));
+				  device->pnp.bus_id,
+				  acpi_power_state_string(state)));
 	}
 
 	return result;

commit ad0c3b0e4863185a9f8874a655a8d2999c915131
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:08 2013 +0100

    ACPI / PM: More visible function for retrieving device power states
    
    The function used for retrieving ACPI device power states,
    __acpi_bus_get_power(), is now static, because it is only used
    internally in drivers/acpi/bus.c.  However, it will be used
    outside of that file going forward, so rename it to
    acpi_device_get_power(), in analogy with acpi_device_set_power(),
    add a kerneldoc comment to it and add its header to acpi_bus.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 8e57fc49726e..0e1441cc4d7f 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -200,7 +200,16 @@ static const char *state_string(int state)
 	}
 }
 
-static int __acpi_bus_get_power(struct acpi_device *device, int *state)
+/**
+ * acpi_device_get_power - Get power state of an ACPI device.
+ * @device: Device to get the power state of.
+ * @state: Place to store the power state of the device.
+ *
+ * This function does not update the device's power.state field, but it may
+ * update its parent's power.state field (when the parent's power state is
+ * unknown and the device's power state turns out to be D0).
+ */
+int acpi_device_get_power(struct acpi_device *device, int *state)
 {
 	int result = ACPI_STATE_UNKNOWN;
 
@@ -397,7 +406,7 @@ int acpi_bus_init_power(struct acpi_device *device)
 
 	device->power.state = ACPI_STATE_UNKNOWN;
 
-	result = __acpi_bus_get_power(device, &state);
+	result = acpi_device_get_power(device, &state);
 	if (result)
 		return result;
 
@@ -421,7 +430,7 @@ int acpi_bus_update_power(acpi_handle handle, int *state_p)
 	if (result)
 		return result;
 
-	result = __acpi_bus_get_power(device, &state);
+	result = acpi_device_get_power(device, &state);
 	if (result)
 		return result;
 

commit ff0c41942fd9766a158502d8ed6965c8a7726f53
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:08 2013 +0100

    ACPI / PM: Change the way power transitions to D3cold are carried out
    
    During power transitions into D3cold from any shallower power states
    we are supposed to transition the device into D3hot and remove power
    from it afterward, but the current code in acpi_device_set_power()
    doesn't work this way.
    
    At the same time, though, we need to be careful enough to preserve
    backwards compatibility for systems that don't distinguish between
    D3hot and D3cold (e.g. designed before ACPI 4).
    
    Modify acpi_device_set_power() so that it works in accordance with
    the expectations in both cases.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 1f0d457ecbcf..8e57fc49726e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -270,6 +270,7 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	int result = 0;
 	acpi_status status = AE_OK;
 	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
+	bool cut_power = false;
 
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
 		return -EINVAL;
@@ -294,9 +295,13 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		return -ENODEV;
 	}
 
-	/* For D3cold we should execute _PS3, not _PS4. */
-	if (state == ACPI_STATE_D3_COLD)
+	/* For D3cold we should first transition into D3hot. */
+	if (state == ACPI_STATE_D3_COLD
+	    && device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible) {
+		state = ACPI_STATE_D3_HOT;
 		object_name[3] = '3';
+		cut_power = true;
+	}
 
 	/*
 	 * Transition Power
@@ -341,6 +346,9 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		}
 	}
 
+	if (cut_power)
+		result = acpi_power_transition(device, ACPI_STATE_D3_COLD);
+
       end:
 	if (result)
 		printk(KERN_WARNING PREFIX

commit ddc150f7a33ae0c9cb16eaac3641abc00f56316f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Nov 16 02:46:28 2012 +0100

    ACPI / PM: Add check preventing transitioning to non-D0 state from D3.
    
    No power transitioning from D3 state up to a non-D0 state is allowed
    so make acpi_device_set_power() fail and complain if such a transition
    is attempted.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 07a20ee3e690..1f0d457ecbcf 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -306,6 +306,12 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	 * a lower-powered state.
 	 */
 	if (state < device->power.state) {
+		if (device->power.state >= ACPI_STATE_D3_HOT &&
+		    state != ACPI_STATE_D0) {
+			printk(KERN_WARNING PREFIX
+			      "Cannot transition to non-D0 state from D3\n");
+			return -ENODEV;
+		}
 		if (device->power.flags.power_resources) {
 			result = acpi_power_transition(device, state);
 			if (result)

commit 078eb12648c2f8bba48921f60ec2cec3e1bbc051
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:45 2012 +0100

    ACPI / PM: Provide device PM functions operating on struct acpi_device
    
    If the caller of acpi_bus_set_power() already has a pointer to the
    struct acpi_device object corresponding to the device in question, it
    doesn't make sense for it to go through acpi_bus_get_device(), which
    may be costly, because it involves acquiring the global ACPI
    namespace mutex.
    
    For this reason, export the function operating on struct acpi_device
    objects used internally by acpi_bus_set_power(), so that it may be
    called instead of acpi_bus_set_power() in the above case, and change
    its name to acpi_device_set_power().
    
    Additionally, introduce two inline wrappers for checking ACPI PM
    capabilities of devices represented by struct acpi_device objects.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index d59175efc428..07a20ee3e690 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -257,7 +257,15 @@ static int __acpi_bus_get_power(struct acpi_device *device, int *state)
 }
 
 
-static int __acpi_bus_set_power(struct acpi_device *device, int state)
+/**
+ * acpi_device_set_power - Set power state of an ACPI device.
+ * @device: Device to set the power state of.
+ * @state: New power state to set.
+ *
+ * Callers must ensure that the device is power manageable before using this
+ * function.
+ */
+int acpi_device_set_power(struct acpi_device *device, int state)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
@@ -341,6 +349,7 @@ static int __acpi_bus_set_power(struct acpi_device *device, int state)
 
 	return result;
 }
+EXPORT_SYMBOL(acpi_device_set_power);
 
 
 int acpi_bus_set_power(acpi_handle handle, int state)
@@ -359,7 +368,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 		return -ENODEV;
 	}
 
-	return __acpi_bus_set_power(device, state);
+	return acpi_device_set_power(device, state);
 }
 EXPORT_SYMBOL(acpi_bus_set_power);
 
@@ -402,7 +411,7 @@ int acpi_bus_update_power(acpi_handle handle, int *state_p)
 	if (result)
 		return result;
 
-	result = __acpi_bus_set_power(device, state);
+	result = acpi_device_set_power(device, state);
 	if (!result && state_p)
 		*state_p = state;
 

commit fc54ab72959edbf229b65ac74b2f122d799ca002
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Jul 16 16:30:21 2012 +0800

    ACPI: run _OSC after ACPI_FULL_INITIALIZATION
    
    The _OSC method may exist in module level code,
    so it must be called after ACPI_FULL_INITIALIZATION
    
    On some new platforms with Zero-Power-Optical-Disk-Drive (ZPODD)
    support, this fix is necessary to save power.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Tested-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e0596954290b..d59175efc428 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -994,14 +994,18 @@ static int __init acpi_bus_init(void)
 	status = acpi_ec_ecdt_probe();
 	/* Ignore result. Not having an ECDT is not fatal. */
 
-	acpi_bus_osc_support();
-
 	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to initialize ACPI objects\n");
 		goto error1;
 	}
 
+	/*
+	 * _OSC method may exist in module level code,
+	 * so it must be run after ACPI_FULL_INITIALIZATION
+	 */
+	acpi_bus_osc_support();
+
 	/*
 	 * _PDC control method may load dynamic SSDT tables,
 	 * and we need to install the table handler before that.

commit 8f7412a792bc989d1bddd3c802282eec09456d57
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Sep 14 00:26:24 2012 +0200

    ACPI / PM: Infer parent power state from child if unknown, v2
    
    It turns out that there are ACPI BIOSes defining device objects with
    _PSx and without either _PSC or _PRx.  For devices corresponding to
    those ACPI objetcs __acpi_bus_get_power() returns ACPI_STATE_UNKNOWN
    and their initial power states are regarded as unknown as a result.
    If such a device is a parent of another power-manageable device, the
    child cannot be put into a low-power state through ACPI, because
    __acpi_bus_set_power() refuses to change power states of devices
    whose parents' power states are unknown.
    
    To work around this problem, observe that the ACPI power state of
    a device cannot be higher-power (lower-number) than the power state
    of its parent.  Thus, if the device's _PSC method or the
    configuration of its power resources indicates that the device is
    in D0, the device's parent has to be in D0 as well.  Consequently,
    if the parent's power state is unknown when we've just learned that
    its child's power state is D0, we can safely set the parent's
    power.state field to ACPI_STATE_D0.
    
    Tested-by: Aaron Lu <aaron.lu@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9628652e080c..e0596954290b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -237,6 +237,16 @@ static int __acpi_bus_get_power(struct acpi_device *device, int *state)
 	} else if (result == ACPI_STATE_D3_HOT) {
 		result = ACPI_STATE_D3;
 	}
+
+	/*
+	 * If we were unsure about the device parent's power state up to this
+	 * point, the fact that the device is in D0 implies that the parent has
+	 * to be in D0 too.
+	 */
+	if (device->parent && device->parent->power.state == ACPI_STATE_UNKNOWN
+	    && result == ACPI_STATE_D0)
+		device->parent->power.state = ACPI_STATE_D0;
+
 	*state = result;
 
  out:

commit ec033d0a02901551346b9f43f8ff9bad51378891
Merge: fa7584e13ac8 819f1a64beb6 f712c71f7b2b a58e1150225c 20ff51a36b2c 1b0a0e9a15b9 6edab08c24f9 c2f4191a9c4d f197ac13f6ee 8eaa8d6ca277 b9c7aff481f1 c3ae331d1c2f
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jul 26 00:03:58 2012 -0400

    Merge branches 'acpi_pad', 'acpica', 'apei-bugzilla-43282', 'battery', 'cpuidle-coupled', 'cpuidle-tweaks', 'intel_idle-ivb', 'ost', 'red-hat-bz-772730', 'thermal', 'thermal-spear' and 'turbostat-v2' into release

commit c2f4191a9c4dbbb5c8bc7f2c0eb5023b97dd2a49
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Wed May 23 20:25:24 2012 -0600

    ACPI: Set hotplug _OST support bit to _OSC
    
    When ACPI_HOTPLUG_OST is defined, set hotplug _OST support bit
    OSC_SB_HOTPLUG_OST_SUPPORT to indicate that the OS supports hotplug
    _OST by calling the platform-wide ACPI Operating System Capabilities
    (_OSC).
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 3188da3df8da..3d4fc7af02f7 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -548,6 +548,10 @@ static void acpi_bus_osc_support(void)
 	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PPC_OST_SUPPORT;
 #endif
 
+#ifdef ACPI_HOTPLUG_OST
+	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_HOTPLUG_OST_SUPPORT;
+#endif
+
 	if (!ghes_disable)
 		capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_APEI_SUPPORT;
 	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))

commit 38c92fff988d518fe80dc23d0d44d66bd7e47ddd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 20 13:58:00 2012 +0200

    ACPI / PM: Make __acpi_bus_get_power() cover D3cold correctly
    
    After recent changes of the ACPI device power states definitions, if
    power resources are not used for the device's power management, the
    state returned by __acpi_bus_get_power() cannot exceed D3hot, because
    the return values of _PSC are 0 through 3.  However, if the _PR3
    method is not present for the device and _PS3 returns 3, we have to
    assume that the device is in D3cold, so the value returned by
    __acpi_bus_get_power() in that case should be 4.
    
    Similarly, acpi_power_get_inferred_state() should take the power
    resources for the D3hot state into account in general, so that it
    can return 3 if those resources are "on" or 4 (D3cold) otherwise.
    
    Fix the the above two issues and make sure that if both _PSC and
    _PR3 are present for the device, the power resources listed by _PR3
    will be used to determine if the number 3 returned by _PSC is meant
    to represent D3cold or D3hot.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a41be56c1cc0..adceafda9c17 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -202,37 +202,44 @@ static const char *state_string(int state)
 
 static int __acpi_bus_get_power(struct acpi_device *device, int *state)
 {
-	int result = 0;
-	acpi_status status = 0;
-	unsigned long long psc = 0;
+	int result = ACPI_STATE_UNKNOWN;
 
 	if (!device || !state)
 		return -EINVAL;
 
-	*state = ACPI_STATE_UNKNOWN;
-
-	if (device->flags.power_manageable) {
-		/*
-		 * Get the device's power state either directly (via _PSC) or
-		 * indirectly (via power resources).
-		 */
-		if (device->power.flags.power_resources) {
-			result = acpi_power_get_inferred_state(device, state);
-			if (result)
-				return result;
-		} else if (device->power.flags.explicit_get) {
-			status = acpi_evaluate_integer(device->handle, "_PSC",
-						       NULL, &psc);
-			if (ACPI_FAILURE(status))
-				return -ENODEV;
-			*state = (int)psc;
-		}
-	} else {
+	if (!device->flags.power_manageable) {
 		/* TBD: Non-recursive algorithm for walking up hierarchy. */
 		*state = device->parent ?
 			device->parent->power.state : ACPI_STATE_D0;
+		goto out;
+	}
+
+	/*
+	 * Get the device's power state either directly (via _PSC) or
+	 * indirectly (via power resources).
+	 */
+	if (device->power.flags.explicit_get) {
+		unsigned long long psc;
+		acpi_status status = acpi_evaluate_integer(device->handle,
+							   "_PSC", NULL, &psc);
+		if (ACPI_FAILURE(status))
+			return -ENODEV;
+
+		result = psc;
+	}
+	/* The test below covers ACPI_STATE_UNKNOWN too. */
+	if (result <= ACPI_STATE_D2) {
+	  ; /* Do nothing. */
+	} else if (device->power.flags.power_resources) {
+		int error = acpi_power_get_inferred_state(device, &result);
+		if (error)
+			return error;
+	} else if (result == ACPI_STATE_D3_HOT) {
+		result = ACPI_STATE_D3;
 	}
+	*state = result;
 
+ out:
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is %s\n",
 			  device->pnp.bus_id, state_string(*state)));
 

commit 63a1a765dffb1e59d82c7948638e56d5f4f2e3a1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 20 13:57:52 2012 +0200

    ACPI / PM: Fix error messages in drivers/acpi/bus.c
    
    After recent changes of the ACPI device low-power states definitions
    kernel messages in drivers/acpi/bus.c need to be updated so that they
    include the correct names of the states in question (currently is
    "D3" for D3hot and "D4" for D3cold, which is incorrect).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 3188da3df8da..a41be56c1cc0 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -182,6 +182,24 @@ EXPORT_SYMBOL(acpi_bus_get_private_data);
                                  Power Management
    -------------------------------------------------------------------------- */
 
+static const char *state_string(int state)
+{
+	switch (state) {
+	case ACPI_STATE_D0:
+		return "D0";
+	case ACPI_STATE_D1:
+		return "D1";
+	case ACPI_STATE_D2:
+		return "D2";
+	case ACPI_STATE_D3_HOT:
+		return "D3hot";
+	case ACPI_STATE_D3_COLD:
+		return "D3";
+	default:
+		return "(unknown)";
+	}
+}
+
 static int __acpi_bus_get_power(struct acpi_device *device, int *state)
 {
 	int result = 0;
@@ -215,8 +233,8 @@ static int __acpi_bus_get_power(struct acpi_device *device, int *state)
 			device->parent->power.state : ACPI_STATE_D0;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
-			  device->pnp.bus_id, *state));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is %s\n",
+			  device->pnp.bus_id, state_string(*state)));
 
 	return 0;
 }
@@ -234,13 +252,14 @@ static int __acpi_bus_set_power(struct acpi_device *device, int state)
 	/* Make sure this is a valid target state */
 
 	if (state == device->power.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
-				  state));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at %s\n",
+				  state_string(state)));
 		return 0;
 	}
 
 	if (!device->power.states[state].flags.valid) {
-		printk(KERN_WARNING PREFIX "Device does not support D%d\n", state);
+		printk(KERN_WARNING PREFIX "Device does not support %s\n",
+		       state_string(state));
 		return -ENODEV;
 	}
 	if (device->parent && (state < device->parent->power.state)) {
@@ -294,13 +313,13 @@ static int __acpi_bus_set_power(struct acpi_device *device, int state)
       end:
 	if (result)
 		printk(KERN_WARNING PREFIX
-			      "Device [%s] failed to transition to D%d\n",
-			      device->pnp.bus_id, state);
+			      "Device [%s] failed to transition to %s\n",
+			      device->pnp.bus_id, state_string(state));
 	else {
 		device->power.state = state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Device [%s] transitioned to D%d\n",
-				  device->pnp.bus_id, state));
+				  "Device [%s] transitioned to %s\n",
+				  device->pnp.bus_id, state_string(state)));
 	}
 
 	return result;

commit 5c7dd710f691d1b44c39e32d2f05b4286ff51f99
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri May 18 00:39:35 2012 +0200

    ACPI / PCI / PM: Fix device PM regression related to D3hot/D3cold
    
    Commit 1cc0c998fdf2 ("ACPI: Fix D3hot v D3cold confusion") introduced a
    bug in __acpi_bus_set_power() and changed the behavior of
    acpi_pci_set_power_state() in such a way that it generally doesn't work
    as expected if PCI_D3hot is passed to it as the second argument.
    
    First off, if ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) is passed to
    __acpi_bus_set_power() and the explicit_set flag is set for the D3cold
    state, the function will try to execute AML method called "_PS4", which
    doesn't exist.
    
    Fix this by adding a check to ensure that the name of the AML method
    to execute for transitions to ACPI_STATE_D3_COLD is correct in
    __acpi_bus_set_power().  Also make sure that the explicit_set flag
    for ACPI_STATE_D3_COLD will be set if _PS3 is present and modify
    acpi_power_transition() to avoid accessing power resources for
    ACPI_STATE_D3_COLD, because they don't exist.
    
    Second, if PCI_D3hot is passed to acpi_pci_set_power_state() as the
    target state, the function will request a transition to
    ACPI_STATE_D3_HOT instead of ACPI_STATE_D3.  However,
    ACPI_STATE_D3_HOT is now only marked as supported if the _PR3 AML
    method is defined for the given device, which is rare.  This causes
    problems to happen on systems where devices were successfully put
    into ACPI D3 by pci_set_power_state(PCI_D3hot) which doesn't work
    now.  In particular, some unused graphics adapters are not turned
    off as a result.
    
    To fix this issue restore the old behavior of
    acpi_pci_set_power_state(), which is to request a transition to
    ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) if either PCI_D3hot or
    PCI_D3cold is passed to it as the argument.
    
    This approach is not ideal, because generally power should not
    be removed from devices if PCI_D3hot is the target power state,
    but since this behavior is relied on, we have no choice but to
    restore it at the moment and spend more time on designing a
    better solution in the future.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=43228
    Reported-by: rocko <rockorequin@hotmail.com>
    Reported-by: Cristian Rodrguez <crrodriguez@opensuse.org>
    Reported-and-tested-by: Peter <lekensteyn@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 3263b68cdfa3..3188da3df8da 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -250,6 +250,10 @@ static int __acpi_bus_set_power(struct acpi_device *device, int state)
 		return -ENODEV;
 	}
 
+	/* For D3cold we should execute _PS3, not _PS4. */
+	if (state == ACPI_STATE_D3_COLD)
+		object_name[3] = '3';
+
 	/*
 	 * Transition Power
 	 * ----------------

commit f2d4753fbd4d15c65d6ba48167aa83916ddbe518
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Jan 31 13:19:19 2012 -0500

    ACPI: export acpi_kobj
    
    Drivers may wish to add entries to /sys/firmware/acpi, so export acpi_kobj
    in order to let them do that.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9ecec98bc76e..3263b68cdfa3 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1010,6 +1010,7 @@ static int __init acpi_bus_init(void)
 }
 
 struct kobject *acpi_kobj;
+EXPORT_SYMBOL_GPL(acpi_kobj);
 
 static int __init acpi_init(void)
 {

commit 4505a2015f4c4b2f21137cc3a6b7400b0f3e073e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Nov 6 14:20:42 2011 +0100

    ACPI: Drop ACPI_NO_HARDWARE_INIT
    
    ACPI_NO_HARDWARE_INIT is only used by acpi_early_init() and
    acpi_bus_init() when calling acpi_enable_subsystem(), but
    acpi_enable_subsystem() doesn't check that flag, so it can be
    dropped.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 437ddbf0c49a..9ecec98bc76e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -911,10 +911,7 @@ void __init acpi_early_init(void)
 	}
 #endif
 
-	status =
-	    acpi_enable_subsystem(~
-				  (ACPI_NO_HARDWARE_INIT |
-				   ACPI_NO_ACPI_ENABLE));
+	status = acpi_enable_subsystem(~ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to enable ACPI\n");
 		goto error0;
@@ -935,8 +932,7 @@ static int __init acpi_bus_init(void)
 
 	acpi_os_initialize1();
 
-	status =
-	    acpi_enable_subsystem(ACPI_NO_HARDWARE_INIT | ACPI_NO_ACPI_ENABLE);
+	status = acpi_enable_subsystem(ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX
 		       "Unable to start the ACPI Interpreter\n");

commit a7e09d450b2e0b068e850d103b6ee1af537d1910
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 16 18:14:21 2011 -0400

    ACPI: APEI build fix
    
    as GHES is optional...
    
    When # CONFIG_ACPI_APEI_GHES is not set:
    
    (.init.text+0x4c22): undefined reference to `ghes_disable'
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 43ce3b0c4921..437ddbf0c49a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -544,10 +544,8 @@ static void acpi_bus_osc_support(void)
 	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PPC_OST_SUPPORT;
 #endif
 
-#ifdef CONFIG_ACPI_APEI_GHES
 	if (!ghes_disable)
 		capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_APEI_SUPPORT;
-#endif
 	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))
 		return;
 	if (ACPI_SUCCESS(acpi_run_osc(handle, &context))) {

commit eccddd32ced0df8f9130024157bf8d37df860d76
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Jul 13 13:14:20 2011 +0800

    ACPI, APEI, Add APEI bit support in generic _OSC call
    
    In APEI firmware first mode, hardware error is reported by hardware to
    firmware firstly, then firmware reports the error to Linux in a GHES
    error record via POLL/SCI/IRQ/NMI etc.
    
    This may result in some issues if OS has no full APEI support.  So
    some firmware implementation will work in a back-compatible mode by
    default.  Where firmware will only notify OS in old-fashion, without
    GHES record.  For example, for a fatal hardware error, only NMI is
    signaled, no GHES record.
    
    To gain full APEI power on these machines, APEI bit in generic _OSC
    call can be specified to tell firmware that Linux has full APEI
    support.  This patch adds the APEI bit support in generic _OSC call.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index d1e06c182cdb..43ce3b0c4921 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -39,6 +39,7 @@
 #include <linux/pci.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
+#include <acpi/apei.h>
 #include <linux/dmi.h>
 #include <linux/suspend.h>
 
@@ -519,6 +520,7 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 }
 EXPORT_SYMBOL(acpi_run_osc);
 
+bool osc_sb_apei_support_acked;
 static u8 sb_uuid_str[] = "0811B06E-4A27-44F9-8D60-3CBBC22E7B48";
 static void acpi_bus_osc_support(void)
 {
@@ -541,11 +543,21 @@ static void acpi_bus_osc_support(void)
 #if defined(CONFIG_ACPI_PROCESSOR) || defined(CONFIG_ACPI_PROCESSOR_MODULE)
 	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PPC_OST_SUPPORT;
 #endif
+
+#ifdef CONFIG_ACPI_APEI_GHES
+	if (!ghes_disable)
+		capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_APEI_SUPPORT;
+#endif
 	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))
 		return;
-	if (ACPI_SUCCESS(acpi_run_osc(handle, &context)))
+	if (ACPI_SUCCESS(acpi_run_osc(handle, &context))) {
+		u32 *capbuf_ret = context.ret.pointer;
+		if (context.ret.length > OSC_SUPPORT_TYPE)
+			osc_sb_apei_support_acked =
+				capbuf_ret[OSC_SUPPORT_TYPE] & OSC_SB_APEI_SUPPORT;
 		kfree(context.ret.pointer);
-	/* do we need to check the returned cap? Sounds no */
+	}
+	/* do we need to check other returned cap? Sounds no */
 }
 
 /* --------------------------------------------------------------------------

commit 28c2103dad04dba29ba86e22dad5735db8f0e13c
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed May 4 22:56:43 2011 +0800

    ACPI: Add D3 cold state
    
    _SxW returns an Integer containing the lowest D-state supported in state
    Sx. If OSPM has not indicated that it supports _PR3, then the value 3
    corresponds to D3.  If it has indicated _PR3 support, the value 3
    represents D3hot and the value 4 represents D3cold.
    
    Linux does set _OSC._PR3, so we should fix it to expect that _SxW can
    return 4.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9749980ca6ca..d1e06c182cdb 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -227,7 +227,7 @@ static int __acpi_bus_set_power(struct acpi_device *device, int state)
 	acpi_status status = AE_OK;
 	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
 
-	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
 		return -EINVAL;
 
 	/* Make sure this is a valid target state */

commit 6831c6edc7b272a08dd2a6c71bb183a48fe98ae6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 15 21:22:24 2011 +0100

    PM: Drop pm_flags that is not necessary
    
    The variable pm_flags is used to prevent APM from being enabled
    along with ACPI, which would lead to problems.  However, acpi_init()
    is always called before apm_init() and after acpi_init() has
    returned, it is known whether or not ACPI will be used.  Namely, if
    acpi_disabled is not set after acpi_init() has returned, this means
    that ACPI is enabled.  Thus, it is sufficient to check acpi_disabled
    in apm_init() to prevent APM from being enabled in parallel with
    ACPI.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 973b0709972c..9749980ca6ca 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1007,8 +1007,7 @@ struct kobject *acpi_kobj;
 
 static int __init acpi_init(void)
 {
-	int result = 0;
-
+	int result;
 
 	if (acpi_disabled) {
 		printk(KERN_INFO PREFIX "Interpreter disabled.\n");
@@ -1023,29 +1022,18 @@ static int __init acpi_init(void)
 
 	init_acpi_device_notify();
 	result = acpi_bus_init();
-
-	if (!result) {
-		pci_mmcfg_late_init();
-		if (pm_apm_enabled()) {
-			printk(KERN_INFO PREFIX
-			       "APM is already active, exiting\n");
-			disable_acpi();
-			result = -ENODEV;
-		} else {
-			pm_set_acpi_flag();
-		}
-	} else
+	if (result) {
 		disable_acpi();
-
-	if (acpi_disabled)
 		return result;
+	}
 
+	pci_mmcfg_late_init();
 	acpi_scan_init();
 	acpi_ec_init();
 	acpi_debugfs_init();
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();
-	return result;
+	return 0;
 }
 
 subsys_initcall(acpi_init);

commit cd51e61cf4e8b220da37dc35e9c2dc2dc258b4de
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 11 00:04:52 2011 +0100

    PM / ACPI: Remove references to pm_flags from bus.c
    
    If direct references to pm_flags are removed from drivers/acpi/bus.c,
    CONFIG_ACPI will not need to depend on CONFIG_PM any more.  Make that
    happen.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 7ced61f39492..973b0709972c 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -40,6 +40,7 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 #include <linux/dmi.h>
+#include <linux/suspend.h>
 
 #include "internal.h"
 
@@ -1025,13 +1026,13 @@ static int __init acpi_init(void)
 
 	if (!result) {
 		pci_mmcfg_late_init();
-		if (!(pm_flags & PM_APM))
-			pm_flags |= PM_ACPI;
-		else {
+		if (pm_apm_enabled()) {
 			printk(KERN_INFO PREFIX
 			       "APM is already active, exiting\n");
 			disable_acpi();
 			result = -ENODEV;
+		} else {
+			pm_set_acpi_flag();
 		}
 	} else
 		disable_acpi();

commit 53eac700b0df1fef8c957b9eedfd7f48120425e3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 11 23:45:30 2010 +0100

    ACPI / PM: Drop acpi_power_nocheck
    
    Since acpi_bus_set_power() should not use __acpi_bus_get_power() to
    update the device's device->power.state field before changing its
    power state (this may cause device->power.state to be inconsistent
    with the device power resources' reference counters), remove this
    call from it.  In consequence, the acpi_power_nocheck variable is not
    necessary any more, so it can be dropped along with the DMI table
    used for setting that variable for HP Pavilion 05.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 0baa5f97734a..7ced61f39492 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -52,22 +52,6 @@ EXPORT_SYMBOL(acpi_root_dir);
 
 #define STRUCT_TO_INT(s)	(*((int*)&s))
 
-static int set_power_nocheck(const struct dmi_system_id *id)
-{
-	printk(KERN_NOTICE PREFIX "%s detected - "
-		"disable power check in power transition\n", id->ident);
-	acpi_power_nocheck = 1;
-	return 0;
-}
-static struct dmi_system_id __cpuinitdata power_nocheck_dmi_table[] = {
-	{
-	set_power_nocheck, "HP Pavilion 05", {
-	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
-	DMI_MATCH(DMI_SYS_VENDOR, "HP Pavilion 05"),
-	DMI_MATCH(DMI_PRODUCT_VERSION, "2001211RE101GLEND") }, NULL},
-	{},
-};
-
 
 #ifdef CONFIG_X86
 static int set_copy_dsdt(const struct dmi_system_id *id)
@@ -333,23 +317,6 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 		return -ENODEV;
 	}
 
-	/*
-	 * Get device's current power state
-	 */
-	if (!acpi_power_nocheck) {
-		/*
-		 * Maybe the incorrect power state is returned on the bogus
-		 * bios, which is different with the real power state.
-		 * For example: the bios returns D0 state and the real power
-		 * state is D3. OS expects to set the device to D0 state. In
-		 * such case if OS uses the power state returned by the BIOS,
-		 * the device can't be transisted to the correct power state.
-		 * So if the acpi_power_nocheck is set, it is unnecessary to
-		 * get the power state by calling acpi_bus_get_power.
-		 */
-		__acpi_bus_get_power(device, &device->power.state);
-	}
-
 	return __acpi_bus_set_power(device, state);
 }
 EXPORT_SYMBOL(acpi_bus_set_power);
@@ -1072,12 +1039,6 @@ static int __init acpi_init(void)
 	if (acpi_disabled)
 		return result;
 
-	/*
-	 * If the laptop falls into the DMI check table, the power state check
-	 * will be disabled in the course of device power transition.
-	 */
-	dmi_check_system(power_nocheck_dmi_table);
-
 	acpi_scan_init();
 	acpi_ec_init();
 	acpi_debugfs_init();

commit f6767dcf2a4f6e62960912d0affec1e15a246191
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 11 23:44:39 2010 +0100

    ACPI / PM: Drop acpi_bus_get_power()
    
    There are no more users of acpi_bus_get_power(), so it can be
    dropped.  Moreover, it should be dropped, because it modifies
    the device->power.state field of an ACPI device without updating
    the reference counters of the device's power resources, which is
    wrong.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2ee83b5fff97..0baa5f97734a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -236,25 +236,6 @@ static int __acpi_bus_get_power(struct acpi_device *device, int *state)
 }
 
 
-int acpi_bus_get_power(acpi_handle handle, int *state)
-{
-	struct acpi_device *device;
-	int result;
-
-	result = acpi_bus_get_device(handle, &device);
-	if (result)
-		return result;
-
-	result = __acpi_bus_get_power(device, state);
-	if (result)
-		return result;
-
-	device->power.state = *state;
-	return 0;
-}
-EXPORT_SYMBOL(acpi_bus_get_power);
-
-
 static int __acpi_bus_set_power(struct acpi_device *device, int state)
 {
 	int result = 0;

commit 488a76c52606199100adf09c8eb7cbedbd94e9d9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:11:24 2010 +0100

    ACPI / Fan: Rework the handling of power resources
    
    Use the new function acpi_bus_update_power() for manipulating power
    resources used by ACPI fan devices, which allows them to be put into
    the right state during initialization and resume.  Consequently,
    remove the flags.force_power_state field from struct acpi_device,
    which is not necessary any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 47864013c0df..2ee83b5fff97 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -266,7 +266,7 @@ static int __acpi_bus_set_power(struct acpi_device *device, int state)
 
 	/* Make sure this is a valid target state */
 
-	if ((state == device->power.state) && !device->flags.force_power_state) {
+	if (state == device->power.state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
 				  state));
 		return 0;

commit 97d9a9e9f5ee68f20005ca5aa77c6b684e7cace8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:10:02 2010 +0100

    ACPI / PM: Register acpi_power_driver early
    
    The ACPI device driver used for handling power resources,
    acpi_power_driver, creates a struct acpi_power_resource object for
    each ACPI device representing a power resource.  These objects are
    then used when setting and reading the power states of devices using
    the corresponding power resources.  Unfortunately, acpi_power_driver
    is registered after acpi_scan_init() that may add devices using the
    power resources before acpi_power_driver has a chance to create
    struct acpi_power_resource objects for them (specifically, the power
    resources may be referred to during the scanning process through
    acpi_bus_get_power() before they have been initialized).
    
    As the first step towards fixing this issue, move the registration
    of acpi_power_driver into acpi_scan_init() so that power resource
    devices can be initialized by it as soon as they have been found in
    the namespace.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 19decee72e92..47864013c0df 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1099,7 +1099,6 @@ static int __init acpi_init(void)
 
 	acpi_scan_init();
 	acpi_ec_init();
-	acpi_power_init();
 	acpi_debugfs_init();
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();

commit 25eed40720fc9005c63a1f436e5f8a78836c26ff
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:09:15 2010 +0100

    ACPI / PM: Add function for updating device power state consistently
    
    Add function acpi_bus_update_power() for reading the actual power
    state of an ACPI device and updating its device->power.state field
    in such a way that its power resources' reference counters will
    remain consistent with that field.
    
    For this purpose introduce __acpi_bus_set_power() setting the
    power state of an ACPI device without updating its
    device->power.state field and make acpi_bus_set_power() and
    acpi_bus_update_power() use it (acpi_bus_set_power() retains the
    current behavior for now).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 453451090502..19decee72e92 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -255,44 +255,17 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 EXPORT_SYMBOL(acpi_bus_get_power);
 
 
-int acpi_bus_set_power(acpi_handle handle, int state)
+static int __acpi_bus_set_power(struct acpi_device *device, int state)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
-	struct acpi_device *device = NULL;
 	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
 
-
-	result = acpi_bus_get_device(handle, &device);
-	if (result)
-		return result;
-
-	if ((state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
 		return -EINVAL;
 
 	/* Make sure this is a valid target state */
 
-	if (!device->flags.power_manageable) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device `[%s]' is not power manageable\n",
-				kobject_name(&device->dev.kobj)));
-		return -ENODEV;
-	}
-	/*
-	 * Get device's current power state
-	 */
-	if (!acpi_power_nocheck) {
-		/*
-		 * Maybe the incorrect power state is returned on the bogus
-		 * bios, which is different with the real power state.
-		 * For example: the bios returns D0 state and the real power
-		 * state is D3. OS expects to set the device to D0 state. In
-		 * such case if OS uses the power state returned by the BIOS,
-		 * the device can't be transisted to the correct power state.
-		 * So if the acpi_power_nocheck is set, it is unnecessary to
-		 * get the power state by calling acpi_bus_get_power.
-		 */
-		acpi_bus_get_power(device->handle, &device->power.state);
-	}
 	if ((state == device->power.state) && !device->flags.force_power_state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
 				  state));
@@ -362,6 +335,42 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	return result;
 }
 
+
+int acpi_bus_set_power(acpi_handle handle, int state)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return result;
+
+	if (!device->flags.power_manageable) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"Device [%s] is not power manageable\n",
+				dev_name(&device->dev)));
+		return -ENODEV;
+	}
+
+	/*
+	 * Get device's current power state
+	 */
+	if (!acpi_power_nocheck) {
+		/*
+		 * Maybe the incorrect power state is returned on the bogus
+		 * bios, which is different with the real power state.
+		 * For example: the bios returns D0 state and the real power
+		 * state is D3. OS expects to set the device to D0 state. In
+		 * such case if OS uses the power state returned by the BIOS,
+		 * the device can't be transisted to the correct power state.
+		 * So if the acpi_power_nocheck is set, it is unnecessary to
+		 * get the power state by calling acpi_bus_get_power.
+		 */
+		__acpi_bus_get_power(device, &device->power.state);
+	}
+
+	return __acpi_bus_set_power(device, state);
+}
 EXPORT_SYMBOL(acpi_bus_set_power);
 
 
@@ -389,6 +398,29 @@ int acpi_bus_init_power(struct acpi_device *device)
 }
 
 
+int acpi_bus_update_power(acpi_handle handle, int *state_p)
+{
+	struct acpi_device *device;
+	int state;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return result;
+
+	result = __acpi_bus_get_power(device, &state);
+	if (result)
+		return result;
+
+	result = __acpi_bus_set_power(device, state);
+	if (!result && state_p)
+		*state_p = state;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_update_power);
+
+
 bool acpi_bus_power_manageable(acpi_handle handle)
 {
 	struct acpi_device *device;

commit ade3e7fef794781c0798d0cf0f046123842ba550
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:08:36 2010 +0100

    ACPI / PM: Add function for device power state initialization
    
    Add function acpi_bus_init_power() for getting the initial power
    state of an ACPI device and reference counting its power resources
    as appropriate.
    
    Make acpi_bus_get_power_flags() use the new function instead of
    acpi_bus_get_power() that updates device->power.state without
    reference counting the device's power resources.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9657abc4a7fb..453451090502 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -364,6 +364,31 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 
 EXPORT_SYMBOL(acpi_bus_set_power);
 
+
+int acpi_bus_init_power(struct acpi_device *device)
+{
+	int state;
+	int result;
+
+	if (!device)
+		return -EINVAL;
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	result = __acpi_bus_get_power(device, &state);
+	if (result)
+		return result;
+
+	if (device->power.flags.power_resources)
+		result = acpi_power_on_resources(device, state);
+
+	if (!result)
+		device->power.state = state;
+
+	return result;
+}
+
+
 bool acpi_bus_power_manageable(acpi_handle handle)
 {
 	struct acpi_device *device;

commit 5e6d4fe4296782f1f095575b8213a97c3e925a16
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:07:56 2010 +0100

    ACPI / PM: Introduce __acpi_bus_get_power()
    
    It sometimes is necessary to get the power state of an ACPI device
    without updating its device->power.state field, for example to
    avoid inconsistencies between device->power.state and the reference
    counters of the device's power resources.  For this purpose introduce
    __acpi_bus_get_power() that will return the given device's power
    state via a pointer (instead of modifying device->power.state)
    and make acpi_bus_get_power() use it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a9fe8e6bc40e..9657abc4a7fb 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -196,34 +196,24 @@ EXPORT_SYMBOL(acpi_bus_get_private_data);
                                  Power Management
    -------------------------------------------------------------------------- */
 
-int acpi_bus_get_power(acpi_handle handle, int *state)
+static int __acpi_bus_get_power(struct acpi_device *device, int *state)
 {
 	int result = 0;
 	acpi_status status = 0;
-	struct acpi_device *device = NULL;
 	unsigned long long psc = 0;
 
-
-	result = acpi_bus_get_device(handle, &device);
-	if (result)
-		return result;
+	if (!device || !state)
+		return -EINVAL;
 
 	*state = ACPI_STATE_UNKNOWN;
 
-	if (!device->flags.power_manageable) {
-		/* TBD: Non-recursive algorithm for walking up hierarchy */
-		if (device->parent)
-			*state = device->parent->power.state;
-		else
-			*state = ACPI_STATE_D0;
-	} else {
+	if (device->flags.power_manageable) {
 		/*
 		 * Get the device's power state either directly (via _PSC) or
 		 * indirectly (via power resources).
 		 */
 		if (device->power.flags.power_resources) {
-			result = acpi_power_get_inferred_state(device,
-							&device->power.state);
+			result = acpi_power_get_inferred_state(device, state);
 			if (result)
 				return result;
 		} else if (device->power.flags.explicit_get) {
@@ -231,20 +221,40 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 						       NULL, &psc);
 			if (ACPI_FAILURE(status))
 				return -ENODEV;
-			device->power.state = (int)psc;
+			*state = (int)psc;
 		}
-
-		*state = device->power.state;
+	} else {
+		/* TBD: Non-recursive algorithm for walking up hierarchy. */
+		*state = device->parent ?
+			device->parent->power.state : ACPI_STATE_D0;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
-			  device->pnp.bus_id, device->power.state));
+			  device->pnp.bus_id, *state));
 
 	return 0;
 }
 
+
+int acpi_bus_get_power(acpi_handle handle, int *state)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return result;
+
+	result = __acpi_bus_get_power(device, state);
+	if (result)
+		return result;
+
+	device->power.state = *state;
+	return 0;
+}
 EXPORT_SYMBOL(acpi_bus_get_power);
 
+
 int acpi_bus_set_power(acpi_handle handle, int state)
 {
 	int result = 0;

commit 32a00d274e877eab3ea7ab196b75c9be5170d25e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:05:17 2010 +0100

    ACPI / PM: Prevent acpi_power_get_inferred_state() from making changes
    
    acpi_power_get_inferred_state() should not update
    device->power.state behind the back of its caller, so make it return
    the state via a pointer instead.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index d68bd61072bb..a9fe8e6bc40e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -222,7 +222,8 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 		 * indirectly (via power resources).
 		 */
 		if (device->power.flags.power_resources) {
-			result = acpi_power_get_inferred_state(device);
+			result = acpi_power_get_inferred_state(device,
+							&device->power.state);
 			if (result)
 				return result;
 		} else if (device->power.flags.explicit_get) {

commit b1d248d96c71665c79befb81207f38f894c7c082
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 26 10:06:54 2010 +0800

    ACPI: install ACPI table handler before any dynamic tables being loaded
    
    ACPI table sysfs I/F is broken by commit
    
    78f1699659963fff97975df44db6d5dbe7218e55
    Author: Alex Chiang <achiang@hp.com>
    Date:   Sun Dec 20 12:19:09 2009 -0700
        ACPI: processor: call _PDC early
    
    because dynamic SSDT tables may be loaded in _PDC,
    before installing the ACPI table handler.
    As a result, the sysfs I/F of these dynamic tables are
    located at  /sys/firmware/acpi/tables instead of
    /sys/firmware/acpi/tables/dynamic, which is not true.
    
    Invoke acpi_sysfs_init() before acpi_early_processor_set_pdc(),
    so that the table handler is installed before any dynamic tables loaded.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=21142
    
    CC: Dennis Jansen <dennis.jansen@web.de>
    CC: Alex Chiang <achiang@hp.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 310e3b9749cb..d68bd61072bb 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -935,6 +935,12 @@ static int __init acpi_bus_init(void)
 		goto error1;
 	}
 
+	/*
+	 * _PDC control method may load dynamic SSDT tables,
+	 * and we need to install the table handler before that.
+	 */
+	acpi_sysfs_init();
+
 	acpi_early_processor_set_pdc();
 
 	/*
@@ -1026,7 +1032,6 @@ static int __init acpi_init(void)
 	acpi_scan_init();
 	acpi_ec_init();
 	acpi_power_init();
-	acpi_sysfs_init();
 	acpi_debugfs_init();
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();

commit fdb8c58a1671beb51949412e053926acd5500b5f
Merge: 23f124ca3dda b137b9942a07 64a32307b710 337279ce3aa8 100cf87788c0 539986482b0d 573b63815802 0bbba38a6128
Author: Len Brown <len.brown@intel.com>
Date:   Wed Sep 29 15:18:28 2010 -0400

    Merge branches 'apei', 'battery-mwh-fix', 'bugzilla-10807', 'bugzilla-14736', 'bugzilla-14679', 'bugzilla-16396', 'launchpad-613381' and 'misc' into release

commit 100cf87788c0e9104f6fb1b0ff5f72f73fbbbea3
Author: Len Brown <len.brown@intel.com>
Date:   Tue Sep 28 22:57:02 2010 -0400

    ACPI: invoke DSDT corruption workaround on all Toshiba Satellite
    
    Our list of Toshiba Satellite models that require this workaround
    is growing -- so invoke the workaround for the entire product line.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=14679
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 5c221ab535d5..a70ca8ea9225 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -80,23 +80,15 @@ static int set_copy_dsdt(const struct dmi_system_id *id)
 
 static struct dmi_system_id dsdt_dmi_table[] __initdata = {
 	/*
-	 * Insyde BIOS on some TOSHIBA machines corrupt the DSDT.
+	 * Invoke DSDT corruption work-around on all Toshiba Satellite.
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
 	 */
 	{
 	 .callback = set_copy_dsdt,
-	 .ident = "TOSHIBA Satellite A505",
+	 .ident = "TOSHIBA Satellite",
 	 .matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite A505"),
-		},
-	},
-	{
-	 .callback = set_copy_dsdt,
-	 .ident = "TOSHIBA Satellite L505D",
-	 .matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite L505D"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite"),
 		},
 	},
 	{}

commit 58f87ed0d45141a90167f34c0959d607160a26df
Author: Lucas De Marchi <lucas.de.marchi@gmail.com>
Date:   Tue Sep 7 12:49:45 2010 -0400

    ACPI: Fix typos
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 5c221ab535d5..cc17b352d1c5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -55,7 +55,7 @@ EXPORT_SYMBOL(acpi_root_dir);
 static int set_power_nocheck(const struct dmi_system_id *id)
 {
 	printk(KERN_NOTICE PREFIX "%s detected - "
-		"disable power check in power transistion\n", id->ident);
+		"disable power check in power transition\n", id->ident);
 	acpi_power_nocheck = 1;
 	return 0;
 }
@@ -1027,7 +1027,7 @@ static int __init acpi_init(void)
 
 	/*
 	 * If the laptop falls into the DMI check table, the power state check
-	 * will be disabled in the course of device power transistion.
+	 * will be disabled in the course of device power transition.
 	 */
 	dmi_check_system(power_nocheck_dmi_table);
 

commit 47f5c892b06797336a34f1096b4b617623aa1960
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jul 15 10:46:33 2010 +0800

    ACPI: remove deprecated ACPI procfs I/F
    
    Rmove deprecated ACPI procfs I/F, including
    /proc/acpi/debug_layer
    /proc/acpi/debug_level
    /proc/acpi/info
    /proc/acpi/dsdt
    /proc/acpi/fadt
    /proc/acpi/sleep
    
    because the sysfs I/F is already available
    and has been working well for years.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index bd9708b0f3f3..5c221ab535d5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1034,8 +1034,6 @@ static int __init acpi_init(void)
 	acpi_scan_init();
 	acpi_ec_init();
 	acpi_power_init();
-	acpi_system_init();
-	acpi_debug_init();
 	acpi_sysfs_init();
 	acpi_debugfs_init();
 	acpi_sleep_proc_init();

commit 1c8fce27e275fd7c6b75bc6455745f02d3903ee6
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jul 15 10:46:30 2010 +0800

    ACPI: introduce drivers/acpi/sysfs.c
    
    Introduce drivers/acpi/sysfs.c.
    
    code for ACPI sysfs I/F, including
    #ifdef ACPI_DEBUG
    /sys/module/acpi/parameters/debug_layer
    /sys/module/acpi/parameters/debug_level
    /sys/module/acpi/parameters/trace_method_name
    /sys/module/acpi/parameters/trace_debug_layer
    /sys/module/acpi/parameters/trace_debug_level
    /sys/module/acpi/parameters/trace_state
    #endif
    /sys/module/acpi/parameters/acpica_version
    /sys/firmware/acpi/tables/
    /sys/firmware/acpi/interrupts/
    is moved to this file.
    
    No function change in this patch.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 7136f24e3002..bd9708b0f3f3 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1036,6 +1036,7 @@ static int __init acpi_init(void)
 	acpi_power_init();
 	acpi_system_init();
 	acpi_debug_init();
+	acpi_sysfs_init();
 	acpi_debugfs_init();
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();

commit a25ee9200eef07377e1703697afbb5d81f89e500
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jul 15 10:46:15 2010 +0800

    ACPI: introduce drivers/acpi/debugfs.c
    
    Introduce drivers/acpi/debugfs.c.
    
    Code for ACPI debugfs I/F,
    i.e. /sys/kernel/debug/acpi/custom_method,
    is moved to this file.
    
    And make ACPI debugfs always built in,
    even if CONFIG_ACPI_DEBUG is cleared.
    
    BTW:this adds about 400bytes code to ACPI, when
    CONFIG_ACPI_DEBUG is cleared.
    
    [uaccess.h build fix from Andrew Morton <akpm@linux-foundation.org>]
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c1d23cd71652..7136f24e3002 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -1036,6 +1036,7 @@ static int __init acpi_init(void)
 	acpi_power_init();
 	acpi_system_init();
 	acpi_debug_init();
+	acpi_debugfs_init();
 	acpi_sleep_proc_init();
 	acpi_wakeup_device_init();
 	return result;

commit 965fd9e9a2d6d0a2704815e4579008a9f65282a0
Author: Andy Shevchenko <ext-andriy.shevchenko@nokia.com>
Date:   Mon May 24 14:33:28 2010 -0700

    drivers: acpi: don't use own implementation of hex_to_bin()
    
    Remove own implementation of hex_to_bin().
    
    Signed-off-by: Andy Shevchenko <ext-andriy.shevchenko@nokia.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9042a8579668..c1d23cd71652 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -401,11 +401,6 @@ static void acpi_print_osc_error(acpi_handle handle,
 	printk("\n");
 }
 
-static u8 hex_val(unsigned char c)
-{
-	return isdigit(c) ? c - '0' : toupper(c) - 'A' + 10;
-}
-
 static acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
 {
 	int i;
@@ -422,8 +417,8 @@ static acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
 			return AE_BAD_PARAMETER;
 	}
 	for (i = 0; i < 16; i++) {
-		uuid[i] = hex_val(str[opc_map_to_uuid[i]]) << 4;
-		uuid[i] |= hex_val(str[opc_map_to_uuid[i] + 1]);
+		uuid[i] = hex_to_bin(str[opc_map_to_uuid[i]]) << 4;
+		uuid[i] |= hex_to_bin(str[opc_map_to_uuid[i] + 1]);
 	}
 	return AE_OK;
 }

commit 04afb40593f9a3007e5ea817d009529ef10fb685
Merge: 7f06a8b26aba cce4f632db20
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 20 09:45:38 2010 -0700

    Merge branch 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (22 commits)
      ACPI: fix early DSDT dmi check warnings on ia64
      ACPICA: Update version to 20100428.
      ACPICA: Update/clarify some parameter names associated with acpi_handle
      ACPICA: Rename acpi_ex_system_do_suspend->acpi_ex_system_do_sleep
      ACPICA: Prevent possible allocation overrun during object copy
      ACPICA: Split large file, evgpeblk
      ACPICA: Add GPE support for dynamically loaded ACPI tables
      ACPICA: Clarify/rename some root table descriptor fields
      ACPICA: Update version to 20100331.
      ACPICA: Minimize the differences between linux GPE code and ACPICA code base
      ACPI: add boot option acpi=copy_dsdt to fix corrupt DSDT
      ACPICA: Update DSDT copy/detection.
      ACPICA: Add subsystem option to force copy of DSDT to local memory
      ACPICA: Add detection of corrupted/replaced DSDT
      ACPICA: Add write support for DataTable operation regions
      ACPICA: Fix for acpi_reallocate_root_table for incorrect root table copy
      ACPICA: Update comments/headers, no functional change
      ACPICA: Update version to 20100304
      ACPICA: Fix for possible fault in acpi_ex_release_mutex
      ACPICA: Standardize integer output for ACPICA warnings/errors
      ...

commit cce4f632db200aef147c59084437168174b23f11
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed May 12 09:26:48 2010 +0800

    ACPI: fix early DSDT dmi check warnings on ia64
    
    WARNING: at drivers/firmware/dmi_scan.c:423 dmi_matches+0x70/0x160()
    dmi check: not initialized yet.
    
    This is caused by commit aa2110c
    (ACPI: add boot option acpi=copy_dsdt to fix corrupt DSDT).
    DMI is not initialized yet in acpi_early_init on ia64.
    
    The DSDT DMI check table is x86 specific, so make it empty on other archs.
    And this fixes the warnings on ia64.
    
    Reported-and-tested-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 49af19bb8c9b..e1bfe7164245 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -69,6 +69,7 @@ static struct dmi_system_id __cpuinitdata power_nocheck_dmi_table[] = {
 };
 
 
+#ifdef CONFIG_X86
 static int set_copy_dsdt(const struct dmi_system_id *id)
 {
 	printk(KERN_NOTICE "%s detected - "
@@ -97,8 +98,14 @@ static struct dmi_system_id dsdt_dmi_table[] __initdata = {
 		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
 		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite L505D"),
 		},
-	}
+	},
+	{}
 };
+#else
+static struct dmi_system_id dsdt_dmi_table[] __initdata = {
+	{}
+};
+#endif
 
 /* --------------------------------------------------------------------------
                                 Device Management

commit 5cc4a0f6b72878ea4e96fdb392d5d24c892a988e
Author: Dan Carpenter <error27@gmail.com>
Date:   Tue Apr 27 00:23:37 2010 +0200

    ACPI: silence kmemcheck false positive
    
    This addresses: https://bugzilla.kernel.org/show_bug.cgi?id=14998
    
    We copy some strings into "event" but we leave the space after the NULL
    terminators uninitialized.  Later in acpi_bus_receive_event() we copy
    the whole struct to another buffer with memcpy().  If the new buffer is
    stored on the stack, kmemcheck prints a warning about the unitialized
    space after the NULL terminators.
    
    It's true that the space is uninitialized, but it's harmless.  The
    buffer is only used in acpi_system_read_event() and we don't read past
    the NULL terminators.
    
    This patch changes the kmalloc() to kzalloc() so that we initialize the
    memory and silence the kmemcheck warning.
    
    Reported-by: Christian Casteyde <casteyde.christian@free.fr>
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 37132dc2da03..743576bf1bd7 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -527,7 +527,7 @@ int acpi_bus_generate_proc_event4(const char *device_class, const char *bus_id,
 	if (!event_is_open)
 		return 0;
 
-	event = kmalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC);
+	event = kzalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC);
 	if (!event)
 		return -ENOMEM;
 

commit aa2110cb1a7510f9b834adfb39b05d4843a35d35
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Apr 8 14:34:27 2010 +0800

    ACPI: add boot option acpi=copy_dsdt to fix corrupt DSDT
    
    Some BIOS on Toshiba machines corrupt the DSDT, so add a new
    boot option acpi=copy_dsdt to workaround it.
    Add warning message to ask users to use this option if corrupt DSDT detected.
    
    Also build a DMI blacklist to check it and automatically copy DSDT.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=14679
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 37132dc2da03..49af19bb8c9b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -69,6 +69,37 @@ static struct dmi_system_id __cpuinitdata power_nocheck_dmi_table[] = {
 };
 
 
+static int set_copy_dsdt(const struct dmi_system_id *id)
+{
+	printk(KERN_NOTICE "%s detected - "
+		"force copy of DSDT to local memory\n", id->ident);
+	acpi_gbl_copy_dsdt_locally = 1;
+	return 0;
+}
+
+static struct dmi_system_id dsdt_dmi_table[] __initdata = {
+	/*
+	 * Insyde BIOS on some TOSHIBA machines corrupt the DSDT.
+	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
+	 */
+	{
+	 .callback = set_copy_dsdt,
+	 .ident = "TOSHIBA Satellite A505",
+	 .matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite A505"),
+		},
+	},
+	{
+	 .callback = set_copy_dsdt,
+	 .ident = "TOSHIBA Satellite L505D",
+	 .matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite L505D"),
+		},
+	}
+};
+
 /* --------------------------------------------------------------------------
                                 Device Management
    -------------------------------------------------------------------------- */
@@ -813,6 +844,12 @@ void __init acpi_early_init(void)
 
 	acpi_gbl_permanent_mmap = 1;
 
+	/*
+	 * If the machine falls into the DMI check table,
+	 * DSDT will be copied to memory
+	 */
+	dmi_check_system(dsdt_dmi_table);
+
 	status = acpi_reallocate_root_table();
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index b70cd3756142..37132dc2da03 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -32,6 +32,7 @@
 #include <linux/device.h>
 #include <linux/proc_fs.h>
 #include <linux/acpi.h>
+#include <linux/slab.h>
 #ifdef CONFIG_X86
 #include <asm/mpspec.h>
 #endif

commit ec28dcc6b4c00b78ad269ad5b85ebd5c2d504825
Merge: c67fcd670b55 d06070509147 f6bb13aa1ea3 0c99c5288eb9 4c81ba4900ab 7e0e9c042790 149fe9c293f7 cffdde993a01 fa80945269f3 8b7ef6d8f162 70287db87cfc 38bcb37a6f63
Author: Len Brown <len.brown@intel.com>
Date:   Sun Mar 14 21:30:17 2010 -0400

    Merge branches 'battery-2.6.34', 'bugzilla-10805', 'bugzilla-14668', 'bugzilla-531916-power-state', 'ht-warn-2.6.34', 'pnp', 'processor-rename', 'sony-2.6.34', 'suse-bugzilla-531547', 'tz-check', 'video' and 'misc-2.6.34' into release

commit 6a4e2b7503d1f630bface040cf0f5a7aac1fabdb
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Fri Jan 8 21:29:58 2010 +0800

    ACPI: Advertise to BIOS in _OSC: _OST on _PPC changes
    
    If the BIOS pokes the system-wide OSC bits to see if Linux
    supports evaluating _OST after a _PPC change notification,
    answer yes.
    
    Also, fix an oversight where we neglected to set the OSC
    bit advertising processor aggregator device support
    when acpi-pad is compiled as a module.
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cf761b904e4a..a52126e46307 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -490,9 +490,14 @@ static void acpi_bus_osc_support(void)
 
 	capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
 	capbuf[OSC_SUPPORT_TYPE] = OSC_SB_PR3_SUPPORT; /* _PR3 is in use */
-#ifdef CONFIG_ACPI_PROCESSOR_AGGREGATOR
+#if defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR) ||\
+			defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE)
 	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PAD_SUPPORT;
 #endif
+
+#if defined(CONFIG_ACPI_PROCESSOR) || defined(CONFIG_ACPI_PROCESSOR_MODULE)
+	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PPC_OST_SUPPORT;
+#endif
 	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))
 		return;
 	if (ACPI_SUCCESS(acpi_run_osc(handle, &context)))

commit 0c99c5288eb9b1bbc9684b0ec0fd7efc578749b3
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Dec 17 16:02:08 2009 +0800

    ACPI: Disable explicit power state retrieval on fans
    
    If the ACPI power state can be got both directly and indirectly,
    we prefer to get it indirectly.
    
    https://bugzilla.redhat.com/show_bug.cgi?id=531916 describes a
    system with a _PSC method for the fan that always returns "on".
    There's no benefit in us always requesting the state of the fan
    when performing transitions - we want to do everything we can
    to ensure that the fan turns on when it should do, not risk
    hardware damage by believing the hardware when it tells us the
    fan is already on. Given that the Leading Other OS(tm) works fine
    on this machine, it seems likely that it behaves in much this way.
    
    inspired-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cf761b904e4a..ae9226de93a6 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -190,16 +190,16 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 		 * Get the device's power state either directly (via _PSC) or
 		 * indirectly (via power resources).
 		 */
-		if (device->power.flags.explicit_get) {
+		if (device->power.flags.power_resources) {
+			result = acpi_power_get_inferred_state(device);
+			if (result)
+				return result;
+		} else if (device->power.flags.explicit_get) {
 			status = acpi_evaluate_integer(device->handle, "_PSC",
 						       NULL, &psc);
 			if (ACPI_FAILURE(status))
 				return -ENODEV;
 			device->power.state = (int)psc;
-		} else if (device->power.flags.power_resources) {
-			result = acpi_power_get_inferred_state(device);
-			if (result)
-				return result;
 		}
 
 		*state = device->power.state;

commit 309ddc53be1766d6ed5411a3dc1782c2040198fa
Merge: 6f5464ce154b 55b313f249e1 81074e90f5c1 78f169965996
Author: Len Brown <len.brown@intel.com>
Date:   Thu Dec 24 01:17:01 2009 -0500

    Merge branches 'bugzilla-14446', 'bugzilla-14753' and 'bugzilla-14824' into release

commit 9dc130fccb874f2959ef313d7922d306dc6d4f75
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Dec 23 17:04:11 2009 +0800

    ACPI: fix OSC regression that caused aer and pciehp not to load
    
    Executing _OSC returns a buffer, which has an acpi object in it.
    Don't directly returns the buffer, instead, we return the acpi object's
    buffer. This fixes a regression since caller of acpi_run_osc expects
    an acpi object's buffer returned.
    
    Tested-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 65f7e335f122..0c1ad3105da1 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -397,6 +397,7 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 	union acpi_object *out_obj;
 	u8 uuid[16];
 	u32 errors;
+	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
 
 	if (!context)
 		return AE_ERROR;
@@ -419,16 +420,16 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 	in_params[3].buffer.length 	= context->cap.length;
 	in_params[3].buffer.pointer 	= context->cap.pointer;
 
-	status = acpi_evaluate_object(handle, "_OSC", &input, &context->ret);
+	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
 	if (ACPI_FAILURE(status))
 		return status;
 
-	/* return buffer should have the same length as cap buffer */
-	if (context->ret.length != context->cap.length)
+	if (!output.length)
 		return AE_NULL_OBJECT;
 
-	out_obj = context->ret.pointer;
-	if (out_obj->type != ACPI_TYPE_BUFFER) {
+	out_obj = output.pointer;
+	if (out_obj->type != ACPI_TYPE_BUFFER
+		|| out_obj->buffer.length != context->cap.length) {
 		acpi_print_osc_error(handle, context,
 			"_OSC evaluation returned wrong type");
 		status = AE_TYPE;
@@ -457,11 +458,20 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 		goto out_kfree;
 	}
 out_success:
-	return AE_OK;
+	context->ret.length = out_obj->buffer.length;
+	context->ret.pointer = kmalloc(context->ret.length, GFP_KERNEL);
+	if (!context->ret.pointer) {
+		status =  AE_NO_MEMORY;
+		goto out_kfree;
+	}
+	memcpy(context->ret.pointer, out_obj->buffer.pointer,
+		context->ret.length);
+	status =  AE_OK;
 
 out_kfree:
-	kfree(context->ret.pointer);
-	context->ret.pointer = NULL;
+	kfree(output.pointer);
+	if (status != AE_OK)
+		context->ret.pointer = NULL;
 	return status;
 }
 EXPORT_SYMBOL(acpi_run_osc);

commit 78f1699659963fff97975df44db6d5dbe7218e55
Author: Alex Chiang <achiang@hp.com>
Date:   Sun Dec 20 12:19:09 2009 -0700

    ACPI: processor: call _PDC early
    
    We discovered that at least one machine (HP Envy), methods in the DSDT
    attempt to call external methods defined in a dynamically loaded SSDT.
    
    Unfortunately, the DSDT methods we are trying to call are part of the
    EC initialization, which happens very early, and the the dynamic SSDT
    is only loaded when a processor _PDC method runs much later.
    
    This results in namespace lookup errors for the (as of yet) undefined
    methods.
    
    Since Windows doesn't have any issues with this machine, we take it
    as a hint that they must be evaluating _PDC much earlier than we are.
    
    Thus, the proper thing for Linux to do should be to match the Windows
    implementation more closely.
    
    Provide a mechanism to call _PDC before we enable the EC. Doing so loads
    the dynamic tables, and allows the EC to be enabled correctly.
    
    The ACPI processor driver will still evaluate _PDC in its .add() method
    to cover the hotplug case.
    
    Resolves: http://bugzilla.kernel.org/show_bug.cgi?id=14824
    
    Cc: ming.m.lin@intel.com
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 65f7e335f122..0bdf24a6fd01 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -888,6 +888,8 @@ static int __init acpi_bus_init(void)
 		goto error1;
 	}
 
+	acpi_early_processor_set_pdc();
+
 	/*
 	 * Maybe EC region is required at bus_scan/acpi_get_devices. So it
 	 * is necessary to enable it as early as possible.

commit 3563ff964fdc36358cef0330936fdac28e65142a
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Oct 29 11:05:05 2009 +0800

    ACPI: Add platform-wide _OSC support.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 12240be58f27..65f7e335f122 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -466,6 +466,30 @@ acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
 }
 EXPORT_SYMBOL(acpi_run_osc);
 
+static u8 sb_uuid_str[] = "0811B06E-4A27-44F9-8D60-3CBBC22E7B48";
+static void acpi_bus_osc_support(void)
+{
+	u32 capbuf[2];
+	struct acpi_osc_context context = {
+		.uuid_str = sb_uuid_str,
+		.rev = 1,
+		.cap.length = 8,
+		.cap.pointer = capbuf,
+	};
+	acpi_handle handle;
+
+	capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
+	capbuf[OSC_SUPPORT_TYPE] = OSC_SB_PR3_SUPPORT; /* _PR3 is in use */
+#ifdef CONFIG_ACPI_PROCESSOR_AGGREGATOR
+	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PAD_SUPPORT;
+#endif
+	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))
+		return;
+	if (ACPI_SUCCESS(acpi_run_osc(handle, &context)))
+		kfree(context.ret.pointer);
+	/* do we need to check the returned cap? Sounds no */
+}
+
 /* --------------------------------------------------------------------------
                                 Event Management
    -------------------------------------------------------------------------- */
@@ -856,6 +880,8 @@ static int __init acpi_bus_init(void)
 	status = acpi_ec_ecdt_probe();
 	/* Ignore result. Not having an ECDT is not fatal. */
 
+	acpi_bus_osc_support();
+
 	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to initialize ACPI objects\n");

commit 70023de88c58a81a730ab4d13c51a30e537ec76e
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Oct 29 11:04:28 2009 +0800

    ACPI: Add a generic API for _OSC -v2
    
    v2->v1:
    .improve debug info as suggedted by Bjorn,Kenji
    .API is using uuid string as suggested by Alexey
    
    Add an API to execute _OSC. A lot of devices can have this method, so add a
    generic API.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 741191524353..12240be58f27 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -344,6 +344,128 @@ bool acpi_bus_can_wakeup(acpi_handle handle)
 
 EXPORT_SYMBOL(acpi_bus_can_wakeup);
 
+static void acpi_print_osc_error(acpi_handle handle,
+	struct acpi_osc_context *context, char *error)
+{
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER};
+	int i;
+
+	if (ACPI_FAILURE(acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer)))
+		printk(KERN_DEBUG "%s\n", error);
+	else {
+		printk(KERN_DEBUG "%s:%s\n", (char *)buffer.pointer, error);
+		kfree(buffer.pointer);
+	}
+	printk(KERN_DEBUG"_OSC request data:");
+	for (i = 0; i < context->cap.length; i += sizeof(u32))
+		printk("%x ", *((u32 *)(context->cap.pointer + i)));
+	printk("\n");
+}
+
+static u8 hex_val(unsigned char c)
+{
+	return isdigit(c) ? c - '0' : toupper(c) - 'A' + 10;
+}
+
+static acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
+{
+	int i;
+	static int opc_map_to_uuid[16] = {6, 4, 2, 0, 11, 9, 16, 14, 19, 21,
+		24, 26, 28, 30, 32, 34};
+
+	if (strlen(str) != 36)
+		return AE_BAD_PARAMETER;
+	for (i = 0; i < 36; i++) {
+		if (i == 8 || i == 13 || i == 18 || i == 23) {
+			if (str[i] != '-')
+				return AE_BAD_PARAMETER;
+		} else if (!isxdigit(str[i]))
+			return AE_BAD_PARAMETER;
+	}
+	for (i = 0; i < 16; i++) {
+		uuid[i] = hex_val(str[opc_map_to_uuid[i]]) << 4;
+		uuid[i] |= hex_val(str[opc_map_to_uuid[i] + 1]);
+	}
+	return AE_OK;
+}
+
+acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
+{
+	acpi_status status;
+	struct acpi_object_list input;
+	union acpi_object in_params[4];
+	union acpi_object *out_obj;
+	u8 uuid[16];
+	u32 errors;
+
+	if (!context)
+		return AE_ERROR;
+	if (ACPI_FAILURE(acpi_str_to_uuid(context->uuid_str, uuid)))
+		return AE_ERROR;
+	context->ret.length = ACPI_ALLOCATE_BUFFER;
+	context->ret.pointer = NULL;
+
+	/* Setting up input parameters */
+	input.count = 4;
+	input.pointer = in_params;
+	in_params[0].type 		= ACPI_TYPE_BUFFER;
+	in_params[0].buffer.length 	= 16;
+	in_params[0].buffer.pointer	= uuid;
+	in_params[1].type 		= ACPI_TYPE_INTEGER;
+	in_params[1].integer.value 	= context->rev;
+	in_params[2].type 		= ACPI_TYPE_INTEGER;
+	in_params[2].integer.value	= context->cap.length/sizeof(u32);
+	in_params[3].type		= ACPI_TYPE_BUFFER;
+	in_params[3].buffer.length 	= context->cap.length;
+	in_params[3].buffer.pointer 	= context->cap.pointer;
+
+	status = acpi_evaluate_object(handle, "_OSC", &input, &context->ret);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	/* return buffer should have the same length as cap buffer */
+	if (context->ret.length != context->cap.length)
+		return AE_NULL_OBJECT;
+
+	out_obj = context->ret.pointer;
+	if (out_obj->type != ACPI_TYPE_BUFFER) {
+		acpi_print_osc_error(handle, context,
+			"_OSC evaluation returned wrong type");
+		status = AE_TYPE;
+		goto out_kfree;
+	}
+	/* Need to ignore the bit0 in result code */
+	errors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);
+	if (errors) {
+		if (errors & OSC_REQUEST_ERROR)
+			acpi_print_osc_error(handle, context,
+				"_OSC request failed");
+		if (errors & OSC_INVALID_UUID_ERROR)
+			acpi_print_osc_error(handle, context,
+				"_OSC invalid UUID");
+		if (errors & OSC_INVALID_REVISION_ERROR)
+			acpi_print_osc_error(handle, context,
+				"_OSC invalid revision");
+		if (errors & OSC_CAPABILITIES_MASK_ERROR) {
+			if (((u32 *)context->cap.pointer)[OSC_QUERY_TYPE]
+			    & OSC_QUERY_ENABLE)
+				goto out_success;
+			status = AE_SUPPORT;
+			goto out_kfree;
+		}
+		status = AE_ERROR;
+		goto out_kfree;
+	}
+out_success:
+	return AE_OK;
+
+out_kfree:
+	kfree(context->ret.pointer);
+	context->ret.pointer = NULL;
+	return status;
+}
+EXPORT_SYMBOL(acpi_run_osc);
+
 /* --------------------------------------------------------------------------
                                 Event Management
    -------------------------------------------------------------------------- */

commit 402ac53614bce0c273c73a80339556bf56dd3d39
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:30:01 2009 +0000

    ACPI: add acpi_bus_get_status_handle()
    
    Add acpi_bus_get_status_handle() so we can get the status of a namespace
    object before building a struct acpi_device.
    
    This removes a use of "device->flags.dynamic_status", a cached indicator of
    whether _STA exists.  It seems simpler and more reliable to just evaluate
    _STA and catch AE_NOT_FOUND errors.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 135fbfe1825c..741191524353 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -94,36 +94,33 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 
 EXPORT_SYMBOL(acpi_bus_get_device);
 
-int acpi_bus_get_status(struct acpi_device *device)
+acpi_status acpi_bus_get_status_handle(acpi_handle handle,
+				       unsigned long long *sta)
 {
-	acpi_status status = AE_OK;
-	unsigned long long sta = 0;
-
+	acpi_status status;
 
-	if (!device)
-		return -EINVAL;
+	status = acpi_evaluate_integer(handle, "_STA", NULL, sta);
+	if (ACPI_SUCCESS(status))
+		return AE_OK;
 
-	/*
-	 * Evaluate _STA if present.
-	 */
-	if (device->flags.dynamic_status) {
-		status =
-		    acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
-		if (ACPI_FAILURE(status))
-			return -ENODEV;
-		STRUCT_TO_INT(device->status) = (int)sta;
+	if (status == AE_NOT_FOUND) {
+		*sta = ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED |
+		       ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING;
+		return AE_OK;
 	}
+	return status;
+}
 
-	/*
-	 * According to ACPI spec some device can be present and functional
-	 * even if the parent is not present but functional.
-	 * In such conditions the child device should not inherit the status
-	 * from the parent.
-	 */
-	else
-		STRUCT_TO_INT(device->status) =
-		    ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED |
-		    ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING;
+int acpi_bus_get_status(struct acpi_device *device)
+{
+	acpi_status status;
+	unsigned long long sta;
+
+	status = acpi_bus_get_status_handle(device->handle, &sta);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	STRUCT_TO_INT(device->status) = (int) sta;
 
 	if (device->status.functional && !device->status.present) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]: "
@@ -135,10 +132,8 @@ int acpi_bus_get_status(struct acpi_device *device)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n",
 			  device->pnp.bus_id,
 			  (u32) STRUCT_TO_INT(device->status)));
-
 	return 0;
 }
-
 EXPORT_SYMBOL(acpi_bus_get_status);
 
 void acpi_bus_private_data_handler(acpi_handle handle,

commit d26f0528d588e596955bf296a609afe52eafc099
Merge: b963bd39c900 df43176c934f
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 02:14:45 2009 -0400

    Merge branch 'misc-2.6.32' into release
    
    Conflicts:
            drivers/pci/dmar.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit eb27cae8adaa658a0bf31631baa1ce29d8183759
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jul 6 23:40:19 2009 -0400

    ACPI: linux/acpi.h should not include linux/dmi.h
    
    users of acpi.h that need dmi.h should include it directly.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2876fc70c3a9..0fb6b2a8b103 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -38,6 +38,7 @@
 #include <linux/pci.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
+#include <linux/dmi.h>
 
 #include "internal.h"
 

commit 8e4319c425077c4cc540696a5bb6c4d12f017dcd
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:43:27 2009 +0800

    ACPICA: Fix several acpi_attach_data problems
    
    Handler was never invoked. Now invoked if/when host node is deleted.
    Data object was not automatically deleted when host node was deleted.
    Interface to handler had an unused parameter, removed it.
    ACPICA BZ 778.
    
    http://acpica.org/bugzilla/show_bug.cgi?id=778
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2876fc70c3a9..620183f13e5e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -141,7 +141,7 @@ int acpi_bus_get_status(struct acpi_device *device)
 EXPORT_SYMBOL(acpi_bus_get_status);
 
 void acpi_bus_private_data_handler(acpi_handle handle,
-				   u32 function, void *context)
+				   void *context)
 {
 	return;
 }

commit ff754e2e85557ed7244385f0f2053c80e8ac9948
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri May 22 11:43:56 2009 -0600

    ACPI: use handle, not device, in system notification path
    
    This patch changes the global system notification path so it uses the
    acpi_handle, not the acpi_device.
    
    System notifications often deal with device presence and status change.
    In these cases, we may not have an acpi_device.  For example, we may
    get a Device Check notification on an object that previously was not
    present.  Since the object was not present, we would not have had an
    acpi_device for it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2b08c3dc79da..2876fc70c3a9 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -450,11 +450,14 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
                              Notification Handling
    -------------------------------------------------------------------------- */
 
-static void acpi_bus_check_device(struct acpi_device *device)
+static void acpi_bus_check_device(acpi_handle handle)
 {
+	struct acpi_device *device;
 	acpi_status status;
 	struct acpi_device_status old_status;
 
+	if (acpi_bus_get_device(handle, &device))
+		return;
 	if (!device)
 		return;
 
@@ -488,13 +491,10 @@ static void acpi_bus_check_device(struct acpi_device *device)
 	}
 }
 
-static void acpi_bus_check_scope(struct acpi_device *device)
+static void acpi_bus_check_scope(acpi_handle handle)
 {
-	if (!device)
-		return;
-
 	/* Status Change? */
-	acpi_bus_check_device(device);
+	acpi_bus_check_device(handle);
 
 	/*
 	 * TBD: Enumerate child devices within this device's scope and
@@ -531,13 +531,10 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	blocking_notifier_call_chain(&acpi_bus_notify_list,
 		type, (void *)handle);
 
-	if (acpi_bus_get_device(handle, &device))
-		return;
-
 	switch (type) {
 
 	case ACPI_NOTIFY_BUS_CHECK:
-		acpi_bus_check_scope(device);
+		acpi_bus_check_scope(handle);
 		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
 		 *      drivers via the device manager (device.c).
@@ -545,7 +542,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		acpi_bus_check_device(device);
+		acpi_bus_check_device(handle);
 		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
 		 *      drivers via the device manager (device.c).
@@ -583,10 +580,13 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 	}
 
-	driver = device->driver;
-	if (driver && driver->ops.notify &&
-	    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
-		driver->ops.notify(device, type);
+	acpi_bus_get_device(handle, &device);
+	if (device) {
+		driver = device->driver;
+		if (driver && driver->ops.notify &&
+		    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
+			driver->ops.notify(device, type);
+	}
 }
 
 /* --------------------------------------------------------------------------

commit cdd5b8ca122cc4239375dee7fcdc658315c119e4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri May 22 11:43:51 2009 -0600

    ACPI: remove unused return values from Bus Check & Device Check handling
    
    Remove return values from acpi_bus_check_device() and acpi_bus_check_scope()
    since nobody looks at them.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 19e78fb0a8d1..2b08c3dc79da 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -450,14 +450,13 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
                              Notification Handling
    -------------------------------------------------------------------------- */
 
-static int acpi_bus_check_device(struct acpi_device *device)
+static void acpi_bus_check_device(struct acpi_device *device)
 {
-	acpi_status status = 0;
+	acpi_status status;
 	struct acpi_device_status old_status;
 
-
 	if (!device)
-		return -EINVAL;
+		return;
 
 	old_status = device->status;
 
@@ -467,15 +466,15 @@ static int acpi_bus_check_device(struct acpi_device *device)
 	 */
 	if (device->parent && !device->parent->status.present) {
 		device->status = device->parent->status;
-		return 0;
+		return;
 	}
 
 	status = acpi_bus_get_status(device);
 	if (ACPI_FAILURE(status))
-		return -ENODEV;
+		return;
 
 	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
-		return 0;
+		return;
 
 	/*
 	 * Device Insertion/Removal
@@ -487,28 +486,20 @@ static int acpi_bus_check_device(struct acpi_device *device)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device removal detected\n"));
 		/* TBD: Handle device removal */
 	}
-
-	return 0;
 }
 
-static int acpi_bus_check_scope(struct acpi_device *device)
+static void acpi_bus_check_scope(struct acpi_device *device)
 {
-	int result = 0;
-
 	if (!device)
-		return -EINVAL;
+		return;
 
 	/* Status Change? */
-	result = acpi_bus_check_device(device);
-	if (result)
-		return result;
+	acpi_bus_check_device(device);
 
 	/*
 	 * TBD: Enumerate child devices within this device's scope and
 	 *       run acpi_bus_check_device()'s on them.
 	 */
-
-	return 0;
 }
 
 static BLOCKING_NOTIFIER_HEAD(acpi_bus_notify_list);
@@ -531,7 +522,6 @@ EXPORT_SYMBOL_GPL(unregister_acpi_bus_notifier);
  */
 static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
-	int result = 0;
 	struct acpi_device *device = NULL;
 	struct acpi_driver *driver;
 
@@ -547,7 +537,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	switch (type) {
 
 	case ACPI_NOTIFY_BUS_CHECK:
-		result = acpi_bus_check_scope(device);
+		acpi_bus_check_scope(device);
 		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
 		 *      drivers via the device manager (device.c).
@@ -555,7 +545,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		result = acpi_bus_check_device(device);
+		acpi_bus_check_device(device);
 		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
 		 *      drivers via the device manager (device.c).

commit aa8a149c0cc822e3886eb85b95cb2f7d67e5b7e6
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri May 22 11:43:46 2009 -0600

    ACPI: remove unused "status_changed" return value from Check Device handling
    
    Remove "status_changed" return from acpi_bus_check_device().  Nobody
    does anything useful based on its value.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index eb986385c57a..19e78fb0a8d1 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -450,8 +450,7 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
                              Notification Handling
    -------------------------------------------------------------------------- */
 
-static int
-acpi_bus_check_device(struct acpi_device *device, int *status_changed)
+static int acpi_bus_check_device(struct acpi_device *device)
 {
 	acpi_status status = 0;
 	struct acpi_device_status old_status;
@@ -460,9 +459,6 @@ acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 	if (!device)
 		return -EINVAL;
 
-	if (status_changed)
-		*status_changed = 0;
-
 	old_status = device->status;
 
 	/*
@@ -471,10 +467,6 @@ acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 	 */
 	if (device->parent && !device->parent->status.present) {
 		device->status = device->parent->status;
-		if (STRUCT_TO_INT(old_status) != STRUCT_TO_INT(device->status)) {
-			if (status_changed)
-				*status_changed = 1;
-		}
 		return 0;
 	}
 
@@ -485,9 +477,6 @@ acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
 		return 0;
 
-	if (status_changed)
-		*status_changed = 1;
-
 	/*
 	 * Device Insertion/Removal
 	 */
@@ -505,20 +494,15 @@ acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 static int acpi_bus_check_scope(struct acpi_device *device)
 {
 	int result = 0;
-	int status_changed = 0;
-
 
 	if (!device)
 		return -EINVAL;
 
 	/* Status Change? */
-	result = acpi_bus_check_device(device, &status_changed);
+	result = acpi_bus_check_device(device);
 	if (result)
 		return result;
 
-	if (!status_changed)
-		return 0;
-
 	/*
 	 * TBD: Enumerate child devices within this device's scope and
 	 *       run acpi_bus_check_device()'s on them.
@@ -571,7 +555,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		result = acpi_bus_check_device(device, NULL);
+		result = acpi_bus_check_device(device);
 		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
 		 *      drivers via the device manager (device.c).

commit 02c37bd8d0737c31caaed9a65bd7cb80aefb4c9a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri May 22 11:43:41 2009 -0600

    ACPI: simplify notification debug messages
    
    This replaces several messages that depend on the acpi_device struct
    with a single message that uses just the acpi_handle.  We should be
    able to deal with notifications to objects that do not yet have an
    acpi_device struct.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cdfecc0a2ac6..eb986385c57a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -551,6 +551,9 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	struct acpi_device *device = NULL;
 	struct acpi_driver *driver;
 
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Notification %#02x to handle %p\n",
+			  type, handle));
+
 	blocking_notifier_call_chain(&acpi_bus_notify_list,
 		type, (void *)handle);
 
@@ -560,9 +563,6 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	switch (type) {
 
 	case ACPI_NOTIFY_BUS_CHECK:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received BUS CHECK notification for device [%s]\n",
-				  device->pnp.bus_id));
 		result = acpi_bus_check_scope(device);
 		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
@@ -571,9 +571,6 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received DEVICE CHECK notification for device [%s]\n",
-				  device->pnp.bus_id));
 		result = acpi_bus_check_device(device, NULL);
 		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
@@ -582,44 +579,26 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 
 	case ACPI_NOTIFY_DEVICE_WAKE:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received DEVICE WAKE notification for device [%s]\n",
-				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_EJECT_REQUEST:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received EJECT REQUEST notification for device [%s]\n",
-				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received DEVICE CHECK LIGHT notification for device [%s]\n",
-				  device->pnp.bus_id));
 		/* TBD: Exactly what does 'light' mean? */
 		break;
 
 	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received FREQUENCY MISMATCH notification for device [%s]\n",
-				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received BUS MODE MISMATCH notification for device [%s]\n",
-				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_POWER_FAULT:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Received POWER FAULT notification for device [%s]\n",
-				  device->pnp.bus_id));
 		/* TBD */
 		break;
 

commit 6d2781310036a8d3fa2b590a6f83a298010fd64a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Apr 30 09:35:37 2009 -0600

    ACPI: allow drivers to request both device and system notify events
    
    System notify events (0x00-0x7f) are common across all device types
    and should be handled in Linux/ACPI, not in drivers.  However, some
    BIOSes use system notify events in device-specific ways that require
    the driver to be involved.
    
    This patch adds a ACPI_DRIVER_ALL_NOTIFY_EVENTS driver flag.  When a
    driver sets this flag and supplies a .notify method, Linux/ACPI calls
    the .notify method for ALL notify events on the device, not just the
    device-specific (0x80-0xff) events.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ae862f1798dc..cdfecc0a2ac6 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -549,6 +549,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
+	struct acpi_driver *driver;
 
 	blocking_notifier_call_chain(&acpi_bus_notify_list,
 		type, (void *)handle);
@@ -629,7 +630,10 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 	}
 
-	return;
+	driver = device->driver;
+	if (driver && driver->ops.notify &&
+	    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
+		driver->ops.notify(device, type);
 }
 
 /* --------------------------------------------------------------------------

commit ddc50b6ad634d9ce2526a777d4b7da80effdfb60
Author: Len Brown <len.brown@intel.com>
Date:   Fri May 8 00:07:30 2009 -0400

    ACPI: power: update error message
    
    "Transitioning device [%s] to D%d" is not correct.
    We print this line when we attempted to transition
    the device, and it failed.
    
    So instead, print
    "Device [%s] failed to transition to D%d\n"
    
    This can happen under two conditions:
    
    1. acpi_power_transition() fails when trying to handle the
       _ON/_OFF for associated power resource.
    
    2. acpi_evaluate_object() on the explicit _PS0/_PS3
       for that actual device could fail.
    
    this change clarifies, but doesn't fix
    http://bugzilla.kernel.org/show_bug.cgi?id=13243
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e8f7b64e92da..ae862f1798dc 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -312,7 +312,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
       end:
 	if (result)
 		printk(KERN_WARNING PREFIX
-			      "Transitioning device [%s] to D%d\n",
+			      "Device [%s] failed to transition to D%d\n",
 			      device->pnp.bus_id, state);
 	else {
 		device->power.state = state;

commit 9a38f4eec57cc5104b6a85bc6d0a91b268fbe803
Merge: 67dc09218762 018f452e9d9d
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:38:31 2009 -0400

    Merge branch 'bjorn-initcall-cleanup' into release

commit 201b8c655f7a48563f6a0b66f9e388460a1ea611
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:50:19 2009 -0600

    ACPI: call acpi_wakeup_device_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_wakeup_device_init() directly.
    Previously, acpi_wakeup_device_init() was a late_initcall (sequence 7).
    
    acpi_wakeup_device_init() depends on acpi_wakeup_device_list, which
    is populated when ACPI devices are enumerated by acpi_init() ->
    acpi_scan_init().  Using late_initcall is certainly enough to make
    sure acpi_wakeup_device_list is populated, but it is more than
    necessary.  We can just as easily call acpi_wakeup_device_init()
    directly from acpi_init(), which avoids the initcall magic.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a812e841cb64..7fe0945f7bcf 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -886,6 +886,7 @@ static int __init acpi_init(void)
 	acpi_system_init();
 	acpi_debug_init();
 	acpi_sleep_proc_init();
+	acpi_wakeup_device_init();
 	return result;
 }
 

commit 9cee43e07940bee13462e63bd75ce4430b155886
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:50:14 2009 -0600

    ACPI: call acpi_sleep_proc_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_sleep_proc_init() directly.
    Previously, acpi_sleep_proc_init() was a late_initcall (sequence 7),
    apparently to make sure that the /proc hierarchy already exists:
    
        2003/02/13 12:38:03-06:00 mochel
        acpi sleep: demote sleep proc file creation.
    
        - Make acpi_sleep_proc_init() a late_initcall(), and not called from
          acpi_sleep_init(). This guarantees that the acpi proc hierarchy is at
          least there when we create the dang file.
    
    This should no longer be an issue because acpi_bus_init() (called early
    in acpi_init()) creates acpi_root_dir (/proc/acpi).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index db9eca8d3cf2..a812e841cb64 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -885,6 +885,7 @@ static int __init acpi_init(void)
 	acpi_power_init();
 	acpi_system_init();
 	acpi_debug_init();
+	acpi_sleep_proc_init();
 	return result;
 }
 

commit 0e46517d9660ee6ae0a0c5d8a4e50451bc84d61d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:50:09 2009 -0600

    ACPI: call init_acpi_device_notify() explicitly rather than as initcall
    
    This patch makes acpi_init() call init_acpi_device_notify() directly.
    Previously, init_acpi_device_notify() was an arch_initcall (sequence 3),
    so it was called before acpi_init() (a subsys_initcall at sequence 4).
    
    init_acpi_device_notify() sets the platform_notify and
    platform_notify_remove function pointers.  These pointers
    are not used until acpi_init() enumerates ACPI devices in
    this path:
    
        acpi_init()
                acpi_scan_init()
                    acpi_bus_scan()
                        acpi_add_single_object()
                            acpi_device_register()
                                device_add()
                                    <use platform_notify>
    
    So it is sufficient to have acpi_init() call init_acpi_device_notify()
    directly before it enumerates devices.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index f32cfd64c999..db9eca8d3cf2 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -855,6 +855,7 @@ static int __init acpi_init(void)
 		acpi_kobj = NULL;
 	}
 
+	init_acpi_device_notify();
 	result = acpi_bus_init();
 
 	if (!result) {

commit 84f810c33f695e020776ce66c903e0b41872f1b2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:50:03 2009 -0600

    ACPI: call acpi_debug_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_debug_init() directly.
    Previously, both were subsys_initcalls.  acpi_debug_init()
    must happen after acpi_init(), and it's better to call it
    explicitly rather than rely on link ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c13307279f7e..f32cfd64c999 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -883,6 +883,7 @@ static int __init acpi_init(void)
 	acpi_ec_init();
 	acpi_power_init();
 	acpi_system_init();
+	acpi_debug_init();
 	return result;
 }
 

commit 141a0af3cab7de690816b17aad1682050219f774
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:49:58 2009 -0600

    ACPI: call acpi_system_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_system_init() directly.
    Previously, both were subsys_initcalls.  acpi_system_init()
    must happen after acpi_init(), and it's better to call it
    explicitly rather than rely on link ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 946610f00aa1..c13307279f7e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -882,6 +882,7 @@ static int __init acpi_init(void)
 	acpi_scan_init();
 	acpi_ec_init();
 	acpi_power_init();
+	acpi_system_init();
 	return result;
 }
 

commit 44515374cba9e46d5622256b43eb06b9c349cee1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:49:53 2009 -0600

    ACPI: call acpi_power_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_power_init() directly.
    Previously, both were subsys_initcalls.  acpi_power_init()
    must happen after acpi_init(), and it's better to call it
    explicitly rather than rely on link ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9ca683794370..946610f00aa1 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -881,6 +881,7 @@ static int __init acpi_init(void)
 
 	acpi_scan_init();
 	acpi_ec_init();
+	acpi_power_init();
 	return result;
 }
 

commit a5f820feb54a59fcdaf4a67a6381ea1ddb36cc6e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:49:48 2009 -0600

    ACPI: call acpi_ec_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_ec_init() directly.
    Previously, both were subsys_initcalls.  acpi_ec_init()
    must happen after acpi_init(), and it's better to call it
    explicitly rather than rely on link ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cdd11fda5036..9ca683794370 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -880,6 +880,7 @@ static int __init acpi_init(void)
 	dmi_check_system(power_nocheck_dmi_table);
 
 	acpi_scan_init();
+	acpi_ec_init();
 	return result;
 }
 

commit e747f274951507b5a0850155c3d709e26d20de5b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:49:43 2009 -0600

    ACPI: call acpi_scan_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_scan_init() directly.
    
    Previously, both acpi_init() and acpi_scan_init() were subsys_initcalls,
    and acpi_init() was called first based on the link order from the
    makefile (bus.o before scan.o).
    
    acpi_scan_init() registers the ACPI bus type, creates the root device,
    and enumerates fixed-feature and namespace devices.  All of this must
    be done after acpi_init(), and it's better to call acpi_scan_init()
    explicitly rather than rely on the link ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index bdeed39c3d38..cdd11fda5036 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -878,6 +878,8 @@ static int __init acpi_init(void)
 	 * will be disabled in the course of device power transistion.
 	 */
 	dmi_check_system(power_nocheck_dmi_table);
+
+	acpi_scan_init();
 	return result;
 }
 

commit 81d0273df20edff275e2eefe6b50436af3bdf9e8
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:49:38 2009 -0600

    ACPI: skip DMI power state check when ACPI disabled
    
    This patch makes acpi_init() exit early when ACPI is disabled.
    This skips a DMI check that affects ACPI power management.   The
    DMI check prints a notice that is misleading when ACPI is disabled.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2e90410a3035..bdeed39c3d38 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -869,6 +869,10 @@ static int __init acpi_init(void)
 		}
 	} else
 		disable_acpi();
+
+	if (acpi_disabled)
+		return result;
+
 	/*
 	 * If the laptop falls into the DMI check table, the power state check
 	 * will be disabled in the course of device power transistion.

commit e60cc7a6f02598fc23c68a656fe9c263d6531ca0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Mar 13 12:08:26 2009 -0600

    ACPI: move private declarations to internal.h
    
    A number of things that shouldn't be exposed outside the ACPI core
    were declared in include/acpi/acpi_drivers.h, where anybody can
    see them.  This patch moves those declarations to a new "internal.h"
    inside drivers/acpi.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 765fd1c56cd6..2e90410a3035 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -39,6 +39,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#include "internal.h"
+
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME("bus");
 

commit 176f9c1804df09f3e9b998c0642e212592ac6283
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Wed Mar 4 11:55:27 2009 -0800

    ACPI: remove doubled status checking
    
    There was a misplaced status test (two consequent tests without a
    statement in between) in acpi_bus_init for ages.  Remove it, since the
    function which should be checked (acpi_os_initialize1) has BUG_ONs on
    failure paths.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 765fd1c56cd6..bee64b73c919 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -758,8 +758,7 @@ static int __init acpi_bus_init(void)
 	acpi_status status = AE_OK;
 	extern acpi_status acpi_os_initialize1(void);
 
-
-	status = acpi_os_initialize1();
+	acpi_os_initialize1();
 
 	status =
 	    acpi_enable_subsystem(ACPI_NO_HARDWARE_INIT | ACPI_NO_ACPI_ENABLE);
@@ -769,12 +768,6 @@ static int __init acpi_bus_init(void)
 		goto error1;
 	}
 
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX
-		       "Unable to initialize ACPI OS objects\n");
-		goto error1;
-	}
-
 	/*
 	 * ACPI 2.0 requires the EC driver to be loaded and work before
 	 * the EC device is found in the namespace (i.e. before acpi_initialize_objects()

commit e76f42761197dd6e9405e2eeb35932acfede115a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Nov 13 17:30:13 2008 -0600

    ACPI: fix 2.6.28 acpi.debug_level regression
    
    acpi_early_init() was changed to over-write the cmdline param,
    making it really inconvenient to set debug flags at boot-time.
    
    Also,
    This sets the default level to "info", which is what all the ACPI
    drivers use.  So to enable messages from drivers, you only have to
    supply the "layer" (a.k.a. "component").  For non-"info" ACPI core
    and ACPI interpreter messages, you have to supply both level and
    layer masks, as before.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 7edf6d913c13..765fd1c56cd6 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -688,14 +688,6 @@ void __init acpi_early_init(void)
 	if (acpi_disabled)
 		return;
 
-	/*
-	 * ACPI CA initializes acpi_dbg_level to non-zero, which means
-	 * we get debug output merely by turning on CONFIG_ACPI_DEBUG.
-	 * Turn it off so we don't get output unless the user specifies
-	 * acpi.debug_level.
-	 */
-	acpi_dbg_level = 0;
-
 	printk(KERN_INFO PREFIX "Core revision %08x\n", ACPI_CA_VERSION);
 
 	/* enable workarounds, unless strict ACPI spec. compliance */

commit 87b586088ef953c602680e5aff8ab83a2e299498
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Nov 7 16:58:00 2008 -0700

    ACPI: turn off all debug output by default
    
    When CONFIG_ACPI_DEBUG=y, the default acpi_dbg_layer and acpi_dbg_level
    values built into the ACPI CA have some debug output enabled.  We'd
    rather be quiet unless the user actually specified the acpi.debug_level
    argument.
    
    This enables distros to ship with CONFIG_ACPI_DEBUG=y without
    inundating users with debug output.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 765fd1c56cd6..7edf6d913c13 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -688,6 +688,14 @@ void __init acpi_early_init(void)
 	if (acpi_disabled)
 		return;
 
+	/*
+	 * ACPI CA initializes acpi_dbg_level to non-zero, which means
+	 * we get debug output merely by turning on CONFIG_ACPI_DEBUG.
+	 * Turn it off so we don't get output unless the user specifies
+	 * acpi.debug_level.
+	 */
+	acpi_dbg_level = 0;
+
 	printk(KERN_INFO PREFIX "Core revision %08x\n", ACPI_CA_VERSION);
 
 	/* enable workarounds, unless strict ACPI spec. compliance */

commit 8950d89acaa8c353869e681772479d7955ae6f7a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 5 16:18:03 2008 -0700

    ACPI: remove CONFIG_ACPI_EC
    
    Remove CONFIG_ACPI_EC.  It was always set the same as CONFIG_ACPI,
    and it had no menu label, so there was no way to set it to anything
    other than "y".
    
    Per section 6.5.4 of the ACPI 3.0b specification,
    
        OSPM must make Embedded Controller operation regions, accessed
        via the Embedded Controllers described in ECDT, available before
        executing any control method.
    
    The ECDT table is optional, but if it is present, the above text
    means that the EC it describes is a required part of the ACPI
    subsystem, so CONFIG_ACPI_EC=n wouldn't make sense.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c797c6473f31..765fd1c56cd6 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -774,7 +774,7 @@ static int __init acpi_bus_init(void)
 		       "Unable to initialize ACPI OS objects\n");
 		goto error1;
 	}
-#ifdef CONFIG_ACPI_EC
+
 	/*
 	 * ACPI 2.0 requires the EC driver to be loaded and work before
 	 * the EC device is found in the namespace (i.e. before acpi_initialize_objects()
@@ -785,7 +785,6 @@ static int __init acpi_bus_init(void)
 	 */
 	status = acpi_ec_ecdt_probe();
 	/* Ignore result. Not having an ECDT is not fatal. */
-#endif
 
 	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
 	if (ACPI_FAILURE(status)) {

commit 7674416db4ee3d43813dddb650364ca994755256
Merge: 0ca9413c234a 27663c5855b1
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:33:29 2008 -0400

    Merge branch 'ull' into test
    
    Conflicts:
            drivers/acpi/bay.c
            drivers/acpi/dock.c
            drivers/ata/libata-acpi.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 0fbb3726f246aadd1bebc01114100b6e69afa5b9
Merge: 47bf31adc541 c0ff17720ec5
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:27:59 2008 -0400

    Merge branch 'ec' into test

commit 47bf31adc541bef0c20de15e800e0011f1ae70c7
Merge: 4538fad56ee1 0a918a9432cc
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:25:26 2008 -0400

    Merge branch 'dock' into test
    
    Conflicts:
            drivers/acpi/osl.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 39a0ad871000d2a016a4fa113a6e53d22aabf25d
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 13:40:22 2008 +0800

    ACPI : Load device driver according to the status of acpi device
    
    According to ACPI spec when the status of some device is not present
    but functional, the device is valid and the children of this device
    should be enumerated. It means that the device should be added to
    linux acpi device tree. But the device driver for this device should not
    be loaded.
        The detailed info can be found in the section 6.3.7 of ACPI 3.0b spec.
        _STA may return bit 0 clear (not present) with bit 3 set (device is
    functional). This case is used to indicate a valid device for which no
    device driver should be loaded (for example, a bridge device.).
    Children of this device may be present and valid. OS should continue
    enumeration below a device whose _STA returns this bit combination
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3358
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 945cd2f2807d..e9b116d2b56d 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -112,21 +112,21 @@ int acpi_bus_get_status(struct acpi_device *device)
 	}
 
 	/*
-	 * Otherwise we assume the status of our parent (unless we don't
-	 * have one, in which case status is implied).
+	 * According to ACPI spec some device can be present and functional
+	 * even if the parent is not present but functional.
+	 * In such conditions the child device should not inherit the status
+	 * from the parent.
 	 */
-	else if (device->parent)
-		device->status = device->parent->status;
 	else
 		STRUCT_TO_INT(device->status) =
 		    ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED |
 		    ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING;
 
 	if (device->status.functional && !device->status.present) {
-		printk(KERN_WARNING PREFIX "Device [%s] status [%08x]: "
-		       "functional but not present; setting present\n",
-		       device->pnp.bus_id, (u32) STRUCT_TO_INT(device->status));
-		device->status.present = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]: "
+		       "functional but not present;\n",
+			device->pnp.bus_id,
+			(u32) STRUCT_TO_INT(device->status)));
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n",

commit 6415e12ba0f92a54f02d9c4ecaa3c82f35f3d335
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 14:59:59 2008 +0800

    ACPI: Add DMI check to disable power state check in power transition
    
    Add the DMI check to disable power check in the course of device power
    transistion.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=11000
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 91bdeb3b081e..945cd2f2807d 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -48,6 +48,23 @@ EXPORT_SYMBOL(acpi_root_dir);
 
 #define STRUCT_TO_INT(s)	(*((int*)&s))
 
+static int set_power_nocheck(const struct dmi_system_id *id)
+{
+	printk(KERN_NOTICE PREFIX "%s detected - "
+		"disable power check in power transistion\n", id->ident);
+	acpi_power_nocheck = 1;
+	return 0;
+}
+static struct dmi_system_id __cpuinitdata power_nocheck_dmi_table[] = {
+	{
+	set_power_nocheck, "HP Pavilion 05", {
+	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
+	DMI_MATCH(DMI_SYS_VENDOR, "HP Pavilion 05"),
+	DMI_MATCH(DMI_PRODUCT_VERSION, "2001211RE101GLEND") }, NULL},
+	{},
+};
+
+
 /* --------------------------------------------------------------------------
                                 Device Management
    -------------------------------------------------------------------------- */
@@ -830,7 +847,11 @@ static int __init acpi_init(void)
 		}
 	} else
 		disable_acpi();
-
+	/*
+	 * If the laptop falls into the DMI check table, the power state check
+	 * will be disabled in the course of device power transistion.
+	 */
+	dmi_check_system(power_nocheck_dmi_table);
 	return result;
 }
 

commit f5adfaa372c76423b6e8e4727a9701330374f364
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 14:57:50 2008 +0800

    ACPI: Add "acpi.power_nocheck=1" to disable power state check in power transition
    
       Maybe the incorrect power state is returned on the bogus bios, which
    is different with the real power state. For example: the bios returns D0
    state and the real power state is D3. OS expects to set the device to D0
    state. In  such case if OS uses the power state returned by the BIOS and
    checks the device power state very strictly in power transition, the device
    can't be transited to the correct power state.
    
       So the boot option of "acpi.power_nocheck=1" is added to avoid checking
    the device power in the course of device power transition.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8049
    http://bugzilla.kernel.org/show_bug.cgi?id=11000
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ccae305ee55d..91bdeb3b081e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -223,7 +223,19 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	/*
 	 * Get device's current power state
 	 */
-	acpi_bus_get_power(device->handle, &device->power.state);
+	if (!acpi_power_nocheck) {
+		/*
+		 * Maybe the incorrect power state is returned on the bogus
+		 * bios, which is different with the real power state.
+		 * For example: the bios returns D0 state and the real power
+		 * state is D3. OS expects to set the device to D0 state. In
+		 * such case if OS uses the power state returned by the BIOS,
+		 * the device can't be transisted to the correct power state.
+		 * So if the acpi_power_nocheck is set, it is unnecessary to
+		 * get the power state by calling acpi_bus_get_power.
+		 */
+		acpi_bus_get_power(device->handle, &device->power.state);
+	}
 	if ((state == device->power.state) && !device->flags.force_power_state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
 				  state));

commit 27663c5855b10af9ec67bc7dfba001426ba21222
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Oct 10 02:22:59 2008 -0400

    ACPI: Change acpi_evaluate_integer to support 64-bit on 32-bit kernels
    
    As of version 2.0, ACPI can return 64-bit integers.  The current
    acpi_evaluate_integer only supports 64-bit integers on 64-bit platforms.
    Change the argument to take a pointer to an acpi_integer so we support
    64-bit integers on all platforms.
    
    lenb: replaced use of "acpi_integer" with "unsigned long long"
    lenb: fixed bug in acpi_thermal_trips_update()
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ccae305ee55d..0885fc796fa0 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -77,7 +77,7 @@ EXPORT_SYMBOL(acpi_bus_get_device);
 int acpi_bus_get_status(struct acpi_device *device)
 {
 	acpi_status status = AE_OK;
-	unsigned long sta = 0;
+	unsigned long long sta = 0;
 
 
 	if (!device)
@@ -155,7 +155,7 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 	int result = 0;
 	acpi_status status = 0;
 	struct acpi_device *device = NULL;
-	unsigned long psc = 0;
+	unsigned long long psc = 0;
 
 
 	result = acpi_bus_get_device(handle, &device);

commit 455c8793d2c49eaecad038c8de83dade9fc3759f
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Oct 6 10:31:36 2008 +0800

    ACPI: Enable EC device immediately after ACPI full initialization
    
    when there is no ECDT table and no _INI object for EC device, it will be
    enabled before scanning ACPI device. But it is too late after the following
    the commit is merged.
        >commit 7752d5cfe3d11ca0bb9c673ec38bd78ba6578f8e
        > Author: Robert Hancock <hancockr@shaw.ca>
        > Date:   Fri Feb 15 01:27:20 2008 -0800
           >x86: validate against acpi motherboard resources
    
       After the above commit is merged, OS will check whether MCFG area is
    reserved in ACPI motherboard resources by calling the function of
    acpi_get_devices when there exists MCFG table. In the acpi_get_devices the _STA
    object will be evaluated to check the status of the ACPI device. On some broken
    BIOS the MYEC object of EC device is initialized as one, which indicates that
    EC operation region is already accessible before enabling EC device.So on these
    broken BIOS the EC operation region will be accessed in course of evaluating
    the _STA object before enabling EC device, which causes that OS will print the
    following warning messages:
        >ACPI Error (evregion-0315): No handler for Region [EC__] (ffff88007f8145e8)
    [EmbeddedControl] [20080609]
        >ACPI Error (exfldio-0290): Region EmbeddedControl(3) has no handler [20080321]
        >ACPI Error (psparse-0530): Method parse/execution failed [\_SB_.PCI0.SBRG.
             EC__.BAT1._STA] (Node ffff81013fc17a00), AE_NOT_EXIST
        >ACPI Error (uteval-0233): Method execution failed [\_SB_.PCI0.SBRG.EC__.BAT1.
             _STA] (Node ffff81013fc17a00), AE_NOT_EXIST
    
    Although the above warning message is harmless, it looks confusing.
    So it is necessary to enable EC device as early as possible.Maybe it is
    appropriate to enable it immediately after ACPI full initialization.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=11255
    http://bugzilla.kernel.org/show_bug.cgi?id=11374
    http://bugzilla.kernel.org/show_bug.cgi?id=11660
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ccae305ee55d..0e0bbc6209e5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -749,6 +749,12 @@ static int __init acpi_bus_init(void)
 		goto error1;
 	}
 
+	/*
+	 * Maybe EC region is required at bus_scan/acpi_get_devices. So it
+	 * is necessary to enable it as early as possible.
+	 */
+	acpi_boot_ec_enable();
+
 	printk(KERN_INFO PREFIX "Interpreter enabled\n");
 
 	/* Initialize sleep structures */

commit 6bd00a61ab63d4ceb635ae0316353c11c900b8d8
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Aug 28 10:04:29 2008 +0800

    ACPI: introduce notifier change to avoid duplicates
    
    The battery driver already registers notification handler.
    To avoid registering notification handler again,
    introduce a notifier chain in global system notifier handler
    and use it in dock driver.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ccae305ee55d..0dc44945725e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -496,6 +496,19 @@ static int acpi_bus_check_scope(struct acpi_device *device)
 	return 0;
 }
 
+static BLOCKING_NOTIFIER_HEAD(acpi_bus_notify_list);
+int register_acpi_bus_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&acpi_bus_notify_list, nb);
+}
+EXPORT_SYMBOL_GPL(register_acpi_bus_notifier);
+
+void unregister_acpi_bus_notifier(struct notifier_block *nb)
+{
+	blocking_notifier_chain_unregister(&acpi_bus_notify_list, nb);
+}
+EXPORT_SYMBOL_GPL(unregister_acpi_bus_notifier);
+
 /**
  * acpi_bus_notify
  * ---------------
@@ -506,6 +519,8 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	int result = 0;
 	struct acpi_device *device = NULL;
 
+	blocking_notifier_call_chain(&acpi_bus_notify_list,
+		type, (void *)handle);
 
 	if (acpi_bus_get_device(handle, &device))
 		return;

commit dc7c65db2845a8d17432d89252c4227a9a7cb15f
Merge: 8a0ca91e1db5 58b6e5538460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 16 17:25:46 2008 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (72 commits)
      Revert "x86/PCI: ACPI based PCI gap calculation"
      PCI: remove unnecessary volatile in PCIe hotplug struct controller
      x86/PCI: ACPI based PCI gap calculation
      PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
      PCI PM: Fix pci_prepare_to_sleep
      x86/PCI: Fix PCI config space for domains > 0
      Fix acpi_pm_device_sleep_wake() by providing a stub for CONFIG_PM_SLEEP=n
      PCI: Simplify PCI device PM code
      PCI PM: Introduce pci_prepare_to_sleep and pci_back_from_sleep
      PCI ACPI: Rework PCI handling of wake-up
      ACPI: Introduce new device wakeup flag 'prepared'
      ACPI: Introduce acpi_device_sleep_wake function
      PCI: rework pci_set_power_state function to call platform first
      PCI: Introduce platform_pci_power_manageable function
      ACPI: Introduce acpi_bus_power_manageable function
      PCI: make pci_name use dev_name
      PCI: handle pci_name() being const
      PCI: add stub for pci_set_consistent_dma_mask()
      PCI: remove unused arch pcibios_update_resource() functions
      PCI: fix pci_setup_device()'s sprinting into a const buffer
      ...
    
    Fixed up conflicts in various files (arch/x86/kernel/setup_64.c,
    arch/x86/pci/irq.c, arch/x86/pci/pci.h, drivers/acpi/sleep/main.c,
    drivers/pci/pci.c, drivers/pci/pci.h, include/acpi/acpi_bus.h) from x86
    and ACPI updates manually.

commit 67a119f990063f5662574f6d6414fe9bc5ece86a
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Jun 10 13:42:13 2008 +0800

    ACPICA: Eliminate acpi_native_uint type v2
    
    No longer needed; replaced mostly with u32, but also acpi_size
    where a type that changes 32/64 bit on 32/64-bit platforms is
    required.
    
    v2: Fix a cast of a 32-bit int to a pointer in ACPI to avoid a compiler warning.
    from David Howells
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a6dbcf4d9ef5..afb34387d5f2 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -612,7 +612,7 @@ static int __init acpi_bus_init_irq(void)
 	return 0;
 }
 
-acpi_native_uint acpi_gbl_permanent_mmap;
+u8 acpi_gbl_permanent_mmap;
 
 
 void __init acpi_early_init(void)

commit eb9d0fe40e313c0a74115ef456a2e43a6c8da72f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:34:48 2008 +0200

    PCI ACPI: Rework PCI handling of wake-up
    
    * Introduce function acpi_pm_device_sleep_wake() for enabling and
      disabling the system wake-up capability of devices that are power
      manageable by ACPI.
    
    * Introduce function acpi_bus_can_wakeup() allowing other (dependent)
      subsystems to check if ACPI is able to enable the system wake-up
      capability of given device.
    
    * Introduce callback .sleep_wake() in struct pci_platform_pm_ops and
      for the ACPI PCI 'driver' make it use acpi_pm_device_sleep_wake().
    
    * Introduce callback .can_wakeup() in struct pci_platform_pm_ops and
      for the ACPI 'driver' make it use acpi_bus_can_wakeup().
    
    * Move the PME# handlig code out of pci_enable_wake() and split it
      into two functions, pci_pme_capable() and pci_pme_active(),
      allowing the caller to check if given device is capable of
      generating PME# from given power state and to enable/disable the
      device's PME# functionality, respectively.
    
    * Modify pci_enable_wake() to use the new ACPI callbacks and the new
      PME#-related functions.
    
    * Drop the generic .platform_enable_wakeup() callback that is not
      used any more.
    
    * Introduce device_set_wakeup_capable() that will set the
      power.can_wakeup flag of given device.
    
    * Rework PCI device PM initialization so that, if given device is
      capable of generating wake-up events, either natively through the
      PME# mechanism, or with the help of the platform, its
      power.can_wakeup flag is set and its power.should_wakeup flag is
      unset as appropriate.
    
    * Make ACPI set the power.can_wakeup flag for devices found to be
      wake-up capable by it.
    
    * Make the ACPI wake-up code enable/disable GPEs for devices that
      have the wakeup.flags.prepared flag set (which means that their
      wake-up power has been enabled).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index b9b69d9629b5..fc1110d6a078 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -306,6 +306,17 @@ bool acpi_bus_power_manageable(acpi_handle handle)
 
 EXPORT_SYMBOL(acpi_bus_power_manageable);
 
+bool acpi_bus_can_wakeup(acpi_handle handle)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	return result ? false : device->wakeup.flags.valid;
+}
+
+EXPORT_SYMBOL(acpi_bus_can_wakeup);
+
 /* --------------------------------------------------------------------------
                                 Event Management
    -------------------------------------------------------------------------- */

commit 3737b2b1046900660b42e25c904b85e78139d25b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:30:55 2008 +0200

    ACPI: Introduce acpi_bus_power_manageable function
    
    Introduce function acpi_bus_power_manageable() allowing other
    (dependent) subsystems to check if ACPI is able to power manage given
    device.  This may be useful, for example, for PCI device power
    management.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a6dbcf4d9ef5..b9b69d9629b5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -295,6 +295,17 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 
 EXPORT_SYMBOL(acpi_bus_set_power);
 
+bool acpi_bus_power_manageable(acpi_handle handle)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	return result ? false : device->flags.power_manageable;
+}
+
+EXPORT_SYMBOL(acpi_bus_power_manageable);
+
 /* --------------------------------------------------------------------------
                                 Event Management
    -------------------------------------------------------------------------- */

commit 7752d5cfe3d11ca0bb9c673ec38bd78ba6578f8e
Author: Robert Hancock <hancockr@shaw.ca>
Date:   Fri Feb 15 01:27:20 2008 -0800

    x86: validate against acpi motherboard resources
    
    This path adds validation of the MMCONFIG table against the ACPI reserved
    motherboard resources.  If the MMCONFIG table is found to be reserved in
    ACPI, we don't bother checking the E820 table.  The PCI Express firmware
    spec apparently tells BIOS developers that reservation in ACPI is required
    and E820 reservation is optional, so checking against ACPI first makes
    sense.  Many BIOSes don't reserve the MMCONFIG region in E820 even though
    it is perfectly functional, the existing check needlessly disables MMCONFIG
    in these cases.
    
    In order to do this, MMCONFIG setup has been split into two phases.  If PCI
    configuration type 1 is not available then MMCONFIG is enabled early as
    before.  Otherwise, it is enabled later after the ACPI interpreter is
    enabled, since we need to be able to execute control methods in order to
    check the ACPI reserved resources.  Presently this is just triggered off
    the end of ACPI interpreter initialization.
    
    There are a few other behavioral changes here:
    
    - Validate all MMCONFIG configurations provided, not just the first one.
    
    - Validate the entire required length of each configuration according to
      the provided ending bus number is reserved, not just the minimum required
      allocation.
    
    - Validate that the area is reserved even if we read it from the chipset
      directly and not from the MCFG table.  This catches the case where the
      BIOS didn't set the location properly in the chipset and has mapped it
      over other things it shouldn't have.
    
    This also cleans up the MMCONFIG initialization functions so that they
    simply do nothing if MMCONFIG is not compiled in.
    
    Based on an original patch by Rajesh Shah from Intel.
    
    [akpm@linux-foundation.org: many fixes and cleanups]
    Signed-off-by: Robert Hancock <hancockr@shaw.ca>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Andi Kleen <ak@suse.de>
    Cc: Rajesh Shah <rajesh.shah@intel.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 2d1955c11833..a6dbcf4d9ef5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -35,6 +35,7 @@
 #ifdef CONFIG_X86
 #include <asm/mpspec.h>
 #endif
+#include <linux/pci.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
@@ -784,6 +785,7 @@ static int __init acpi_init(void)
 	result = acpi_bus_init();
 
 	if (!result) {
+		pci_mmcfg_late_init();
 		if (!(pm_flags & PM_APM))
 			pm_flags |= PM_ACPI;
 		else {

commit f0a37e008750ead1751b7d5e89d220a260a46147
Author: Chuck Ebbert <cebbert@redhat.com>
Date:   Tue Apr 15 14:34:47 2008 -0700

    acpi: bus: check once more for an empty list after locking it
    
    List could have become empty after the unlocked check that was made earlier,
    so check again inside the lock.
    
    Should fix https://bugzilla.redhat.com/show_bug.cgi?id=427765
    
    Signed-off-by: Chuck Ebbert <cebbert@redhat.com>
    Cc: <stable@kernel.org>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 5b6760e0f957..2d1955c11833 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -373,10 +373,11 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
 	}
 
 	spin_lock_irqsave(&acpi_bus_event_lock, flags);
-	entry =
-	    list_entry(acpi_bus_event_list.next, struct acpi_bus_event, node);
-	if (entry)
+	if (!list_empty(&acpi_bus_event_list)) {
+		entry = list_entry(acpi_bus_event_list.next,
+				   struct acpi_bus_event, node);
 		list_del(&entry->node);
+	}
 	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
 
 	if (!entry)

commit 96b2dd1f1fdb9a131b7f2e79e5c7b2e4282cfcbf
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Mar 5 18:24:51 2008 -0800

    ACPI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ce3c0a2cbac4..5b6760e0f957 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -776,7 +776,7 @@ static int __init acpi_init(void)
 
 	acpi_kobj = kobject_create_and_add("acpi", firmware_kobj);
 	if (!acpi_kobj) {
-		printk(KERN_WARNING "%s: kset create error\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: kset create error\n", __func__);
 		acpi_kobj = NULL;
 	}
 

commit 6697c05296fab4d113c7144459b72b6172b485a5
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Sat Feb 9 23:24:08 2008 +0100

    x86: fix sparse warnings in acpi/bus.c
    
    Add function definition and extern variables to asm-x86/acpi.h.
    
    All of these are used in bus.c in ifdef(CONFIG_X86) sections, so are
    only added to the x86 include headers.  boot.c already includes acpi.h
    so no changes are needed there.
    
    Fixes the following:
    arch/x86/kernel/acpi/boot.c:83:4: warning: symbol 'acpi_sci_flags' was not declared. Should it be static?
    arch/x86/kernel/acpi/boot.c:84:5: warning: symbol 'acpi_sci_override_gsi' was not declared. Should it be static?
    arch/x86/kernel/acpi/boot.c:421:13: warning: symbol 'acpi_pic_sci_set_trigger' was not declared. Should it be static?
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 8b0d4b7d188a..ce3c0a2cbac4 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -31,6 +31,7 @@
 #include <linux/pm.h>
 #include <linux/device.h>
 #include <linux/proc_fs.h>
+#include <linux/acpi.h>
 #ifdef CONFIG_X86
 #include <asm/mpspec.h>
 #endif
@@ -39,9 +40,6 @@
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME("bus");
-#ifdef	CONFIG_X86
-extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
-#endif
 
 struct acpi_device *acpi_root;
 struct proc_dir_entry *acpi_root_dir;
@@ -653,8 +651,6 @@ void __init acpi_early_init(void)
 
 #ifdef CONFIG_X86
 	if (!acpi_ioapic) {
-		extern u8 acpi_sci_flags;
-
 		/* compatible (0) means level (3) */
 		if (!(acpi_sci_flags & ACPI_MADT_TRIGGER_MASK)) {
 			acpi_sci_flags &= ~ACPI_MADT_TRIGGER_MASK;
@@ -664,7 +660,6 @@ void __init acpi_early_init(void)
 		acpi_pic_sci_set_trigger(acpi_gbl_FADT.sci_interrupt,
 					 (acpi_sci_flags & ACPI_MADT_TRIGGER_MASK) >> 2);
 	} else {
-		extern int acpi_sci_override_gsi;
 		/*
 		 * now that acpi_gbl_FADT is initialized,
 		 * update it with result from INT_SRC_OVR parsing

commit a733a5da97b238e3e3167d3d0aee8fe1e8d04e97
Merge: 299cfe38081b 299cfe38081b 9e52797131e8
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:38:22 2008 -0500

    Merge branches 'release' and 'fluff' into release
    
    Conflicts:
    
            drivers/acpi/scan.c
            include/linux/acpi.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e5685b9d35c2cc0a98425b05df30cb837dd1e632
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:24:42 2007 +0200

    ACPI: misc cleanups
    
        This patch contains the following possible cleanups:
        - make the following needlessly global code static:
          - drivers/acpi/bay.c:dev_attr_eject
          - drivers/acpi/bay.c:dev_attr_present
          - drivers/acpi/dock.c:dev_attr_docked
          - drivers/acpi/dock.c:dev_attr_flags
          - drivers/acpi/dock.c:dev_attr_uid
          - drivers/acpi/dock.c:dev_attr_undock
          - drivers/acpi/pci_bind.c:acpi_pci_unbind()
          - drivers/acpi/pci_link.c:acpi_link_lock
          - drivers/acpi/sbs.c:acpi_sbs_callback()
          - drivers/acpi/sbshc.c:acpi_smbus_transaction()
          - drivers/acpi/sleep/main.c:acpi_sleep_prepare()
        - #if 0 the following unused global functions:
          - drivers/acpi/numa.c:acpi_unmap_pxm_to_node()
        - remove the following unused EXPORT_SYMBOL's:
          - acpi_register_gsi
          - acpi_unregister_gsi
          - acpi_strict
          - acpi_bus_receive_event
          - register_acpi_bus_type
          - unregister_acpi_bus_type
          - acpi_os_printf
          - acpi_os_sleep
          - acpi_os_stall
          - acpi_os_read_pci_configuration
          - acpi_os_create_semaphore
          - acpi_os_delete_semaphore
          - acpi_os_wait_semaphore
          - acpi_os_signal_semaphore
          - acpi_os_signal
          - acpi_pci_irq_enable
          - acpi_get_pxm
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 1b4cf984b081..2994bb2b22e9 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -366,7 +366,6 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
 	return 0;
 }
 
-EXPORT_SYMBOL(acpi_bus_receive_event);
 #endif	/* CONFIG_ACPI_PROC_EVENT */
 
 /* --------------------------------------------------------------------------

commit 207339398ecb0835331c748612898dad2a09fdec
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 17 15:51:21 2008 +0800

    ACPI: attach thermal zone info
    
    Intel menlow driver needs to get the pointer of themal_zone_device
    structure of an ACPI thermal zone.
    Attach this to each ACPI thermal zone device object.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Thomas Sujith <sujith.thomas@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 1b4cf984b081..8df325dafe0f 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -122,6 +122,31 @@ int acpi_bus_get_status(struct acpi_device *device)
 
 EXPORT_SYMBOL(acpi_bus_get_status);
 
+void acpi_bus_private_data_handler(acpi_handle handle,
+				   u32 function, void *context)
+{
+	return;
+}
+EXPORT_SYMBOL(acpi_bus_private_data_handler);
+
+int acpi_bus_get_private_data(acpi_handle handle, void **data)
+{
+	acpi_status status = AE_OK;
+
+	if (!*data)
+		return -EINVAL;
+
+	status = acpi_get_data(handle, acpi_bus_private_data_handler, data);
+	if (ACPI_FAILURE(status) || !*data) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
+				handle));
+		return -ENODEV;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(acpi_bus_get_private_data);
+
 /* --------------------------------------------------------------------------
                                  Power Management
    -------------------------------------------------------------------------- */

commit f62ed9e33b3ccff54d66b08f82d11940bb9e269b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 5 13:16:15 2007 -0800

    firmware: change firmware_kset to firmware_kobj
    
    There is no firmware "subsystem" it's just a directory in /sys that
    other portions of the kernel want to hook into.  So make it a kobject
    not a kset to help alivate anyone who tries to do some odd kset-like
    things with this.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e550da684a47..1b4cf984b081 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -755,7 +755,7 @@ static int __init acpi_init(void)
 		return -ENODEV;
 	}
 
-	acpi_kobj = kobject_create_and_add("acpi", &firmware_kset->kobj);
+	acpi_kobj = kobject_create_and_add("acpi", firmware_kobj);
 	if (!acpi_kobj) {
 		printk(KERN_WARNING "%s: kset create error\n", __FUNCTION__);
 		acpi_kobj = NULL;

commit 99e0d2fc6c60ca44f56203eeda9fc0e07b508f06
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 2 16:19:59 2007 -0700

    kobject: convert /sys/firmware/acpi/ to use kobject_create
    
    We don't need a kset here, a simple kobject will do just fine, so
    dynamically create the kobject and use it.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 7c172d9d7acf..e550da684a47 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -743,7 +743,7 @@ static int __init acpi_bus_init(void)
 	return -ENODEV;
 }
 
-decl_subsys(acpi, NULL);
+struct kobject *acpi_kobj;
 
 static int __init acpi_init(void)
 {
@@ -755,10 +755,11 @@ static int __init acpi_init(void)
 		return -ENODEV;
 	}
 
-	result = firmware_register(&acpi_subsys);
-	if (result < 0)
-		printk(KERN_WARNING "%s: firmware_register error: %d\n",
-			__FUNCTION__, result);
+	acpi_kobj = kobject_create_and_add("acpi", &firmware_kset->kobj);
+	if (!acpi_kobj) {
+		printk(KERN_WARNING "%s: kset create error\n", __FUNCTION__);
+		acpi_kobj = NULL;
+	}
 
 	result = acpi_bus_init();
 

commit 3514faca19a6fdc209734431c509631ea92b094e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 16 10:11:44 2007 -0600

    kobject: remove struct kobj_type from struct kset
    
    We don't need a "default" ktype for a kset.  We should set this
    explicitly every time for each kset.  This change is needed so that we
    can make ksets dynamic, and cleans up one of the odd, undocumented
    assumption that the kset/kobject/ktype model has.
    
    This patch is based on a lot of help from Kay Sievers.
    
    Nasty bug in the block code was found by Dave Young
    <hidave.darkstar@gmail.com>
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index f4487c38d9f2..7c172d9d7acf 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -743,7 +743,7 @@ static int __init acpi_bus_init(void)
 	return -ENODEV;
 }
 
-decl_subsys(acpi, NULL, NULL);
+decl_subsys(acpi, NULL);
 
 static int __init acpi_init(void)
 {

commit ec68373c04495edbe39fb94fad963fb781e062e5
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 23 22:41:20 2008 -0500

    Revert "ACPI: Fan: Drop force_power_state acpi_device option"
    
    This reverts commit 93ad7c07ad487b036add8760dabcc35666a550ef.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9798
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index d7a115c362d1..f4487c38d9f2 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -200,7 +200,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	 * Get device's current power state
 	 */
 	acpi_bus_get_power(device->handle, &device->power.state);
-	if (state == device->power.state) {
+	if ((state == device->power.state) && !device->flags.force_power_state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
 				  state));
 		return 0;

commit 9f9adecd2d0e4f88fa0e8cb06c6ec207748df70a
Author: Len Brown <len.brown@intel.com>
Date:   Thu Dec 13 17:38:03 2007 -0500

    PM: ACPI and APM must not be enabled at the same time
    
    ACPI and APM used "pm_active" to guarantee that
    they would not be simultaneously active.
    
    But pm_active was recently moved under CONFIG_PM_LEGACY,
    so that without CONFIG_PM_LEGACY, pm_active became a NOP --
    allowing ACPI and APM to both be simultaneously enabled.
    This caused unpredictable results, including boot hangs.
    
    Further, the code under CONFIG_PM_LEGACY is scheduled
    for removal.
    
    So replace pm_active with pm_flags.
    pm_flags depends only on CONFIG_PM,
    which is present for both CONFIG_APM and CONFIG_ACPI.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9194
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 49d432d0a12c..d7a115c362d1 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -29,7 +29,6 @@
 #include <linux/list.h>
 #include <linux/sched.h>
 #include <linux/pm.h>
-#include <linux/pm_legacy.h>
 #include <linux/device.h>
 #include <linux/proc_fs.h>
 #ifdef CONFIG_X86
@@ -764,16 +763,14 @@ static int __init acpi_init(void)
 	result = acpi_bus_init();
 
 	if (!result) {
-#ifdef CONFIG_PM_LEGACY
-		if (!PM_IS_ACTIVE())
-			pm_active = 1;
+		if (!(pm_flags & PM_APM))
+			pm_flags |= PM_ACPI;
 		else {
 			printk(KERN_INFO PREFIX
 			       "APM is already active, exiting\n");
 			disable_acpi();
 			result = -ENODEV;
 		}
-#endif
 	} else
 		disable_acpi();
 

commit 93ad7c07ad487b036add8760dabcc35666a550ef
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Mon Oct 22 14:19:21 2007 +0400

    ACPI: Fan: Drop force_power_state acpi_device option
    
    force_power_state was used as a workaround for invalid cached
    power state of the device. We do not cache power state, so no need for
    workaround.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index fdee82d37b7d..49d432d0a12c 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -201,7 +201,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	 * Get device's current power state
 	 */
 	acpi_bus_get_power(device->handle, &device->power.state);
-	if ((state == device->power.state) && !device->flags.force_power_state) {
+	if (state == device->power.state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
 				  state));
 		return 0;

commit c35923bc558074d4f5e6f9706e4cb9811ae55775
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Mon Oct 22 14:19:09 2007 +0400

    ACPI: power: don't cache power resource state
    
    ACPI may change power resource state behind our back, so don't
    keep our local copy, which may not be valid.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index fb2cff9a2d24..fdee82d37b7d 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -198,11 +198,9 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 		return -ENODEV;
 	}
 	/*
-	 * Get device's current power state if it's unknown
-	 * This means device power state isn't initialized or previous setting failed
+	 * Get device's current power state
 	 */
-	if ((device->power.state == ACPI_STATE_UNKNOWN) || device->flags.force_power_state)
-		acpi_bus_get_power(device->handle, &device->power.state);
+	acpi_bus_get_power(device->handle, &device->power.state);
 	if ((state == device->power.state) && !device->flags.force_power_state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
 				  state));

commit c4ec20717313daafba59225f812db89595952b83
Merge: ec2626815bf9 00a2b433557f
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Oct 19 13:12:46 2007 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (41 commits)
      ACPICA: hw: Don't carry spinlock over suspend
      ACPICA: hw: remove use_lock flag from acpi_hw_register_{read, write}
      ACPI: cpuidle: port idle timer suspend/resume workaround to cpuidle
      ACPI: clean up acpi_enter_sleep_state_prep
      Hibernation: Make sure that ACPI is enabled in acpi_hibernation_finish
      ACPI: suppress uninitialized var warning
      cpuidle: consolidate 2.6.22 cpuidle branch into one patch
      ACPI: thinkpad-acpi: skip blanks before the data when parsing sysfs
      ACPI: AC: Add sysfs interface
      ACPI: SBS: Add sysfs alarm
      ACPI: SBS: Add ACPI_PROCFS around procfs handling code.
      ACPI: SBS: Add support for power_supply class (and sysfs)
      ACPI: SBS: Make SBS reads table-driven.
      ACPI: SBS: Simplify data structures in SBS
      ACPI: SBS: Split host controller (ACPI0001) from SBS driver (ACPI0002)
      ACPI: EC: Add new query handler to list head.
      ACPI: Add acpi_bus_generate_event4() function
      ACPI: Battery: add sysfs alarm
      ACPI: Battery: Add sysfs support
      ACPI: Battery: Misc clean-ups, no functional changes
      ...
    
    Fix up conflicts in drivers/misc/thinkpad_acpi.[ch] manually

commit 19c38de88a80913351fcacefdb461cc0b585fa87
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 12 15:06:57 2007 -0700

    kobjects: fix up improper use of the kobject name field
    
    A number of different drivers incorrect access the kobject name field
    directly.  This is not correct as the name might not be in the array.
    Use the proper accessor function instead.

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index feab124d8e05..cbfc81579c9a 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -194,7 +194,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 
 	if (!device->flags.power_manageable) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device `[%s]' is not power manageable\n",
-				device->dev.kobj.name));
+				kobject_name(&device->dev.kobj)));
 		return -ENODEV;
 	}
 	/*

commit 5e32132befa5d2cefadf3141fee0bbb40cd11f0e
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Oct 11 23:53:58 2007 +0200

    ide: hook ACPI _PSx method to IDE power on/off
    
    ACPI spec defines the sequence of IDE power on/off:
    Powering down:
            Call _GTM.
            Power down drive (calls _PS3 method and turns off power planes).
    Powering up:
            Power up drive (calls _PS0 method if present and turns on power planes).
            Call _STM passing info from _GTM (possibly modified), with ID data from
            each drive.
            Initialize the channel.
            May modify the results of _GTF.
            For each drive:
                    Call _GTF.
                    Execute task file (possibly modified).
    This patch adds the missed _PS0/_PS3 methods call.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9ba778a2b484..feab124d8e05 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -262,10 +262,12 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 		printk(KERN_WARNING PREFIX
 			      "Transitioning device [%s] to D%d\n",
 			      device->pnp.bus_id, state);
-	else
+	else {
+		device->power.state = state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to D%d\n",
 				  device->pnp.bus_id, state));
+	}
 
 	return result;
 }

commit 8db85d4c9a0cc131242c80ef8456362d66561dc2
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed Sep 26 19:43:16 2007 +0400

    ACPI: Add acpi_bus_generate_event4() function
    
    acpi_bus_generate_event() takes two strings out of passed device object.
    SBS needs to supply these strings directly.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9ba778a2b484..a54234d3aac1 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -284,15 +284,11 @@ DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
 
 extern int event_is_open;
 
-int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
+int acpi_bus_generate_proc_event4(const char *device_class, const char *bus_id, u8 type, int data)
 {
-	struct acpi_bus_event *event = NULL;
+	struct acpi_bus_event *event;
 	unsigned long flags = 0;
 
-
-	if (!device)
-		return -EINVAL;
-
 	/* drop event on the floor if no one's listening */
 	if (!event_is_open)
 		return 0;
@@ -301,8 +297,8 @@ int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
 	if (!event)
 		return -ENOMEM;
 
-	strcpy(event->device_class, device->pnp.device_class);
-	strcpy(event->bus_id, device->pnp.bus_id);
+	strcpy(event->device_class, device_class);
+	strcpy(event->bus_id, bus_id);
 	event->type = type;
 	event->data = data;
 
@@ -313,6 +309,17 @@ int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
 	wake_up_interruptible(&acpi_bus_event_queue);
 
 	return 0;
+
+}
+
+EXPORT_SYMBOL_GPL(acpi_bus_generate_proc_event4);
+
+int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
+{
+	if (!device)
+		return -EINVAL;
+	return acpi_bus_generate_proc_event4(device->pnp.device_class,
+					     device->pnp.bus_id, type, data);
 }
 
 EXPORT_SYMBOL(acpi_bus_generate_proc_event);

commit 14e04fb34ffa82ee61ae69f98d8fca12d2e8e31c
Author: Len Brown <len.brown@intel.com>
Date:   Thu Aug 23 15:20:26 2007 -0400

    ACPI: Schedule /proc/acpi/event for removal
    
    Schedule /proc/acpi/event for removal in 6 months.
    
    Re-name acpi_bus_generate_event() to acpi_bus_generate_proc_event()
    to make sure there is no confusion that it is for /proc/acpi/event only.
    
    Add CONFIG_ACPI_PROC_EVENT to allow removal of /proc/acpi/event.
    There is no functional change if CONFIG_ACPI_PROC_EVENT=y
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e5084ececb6f..9ba778a2b484 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -276,6 +276,7 @@ EXPORT_SYMBOL(acpi_bus_set_power);
                                 Event Management
    -------------------------------------------------------------------------- */
 
+#ifdef CONFIG_ACPI_PROC_EVENT
 static DEFINE_SPINLOCK(acpi_bus_event_lock);
 
 LIST_HEAD(acpi_bus_event_list);
@@ -283,7 +284,7 @@ DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
 
 extern int event_is_open;
 
-int acpi_bus_generate_event(struct acpi_device *device, u8 type, int data)
+int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
 {
 	struct acpi_bus_event *event = NULL;
 	unsigned long flags = 0;
@@ -314,7 +315,7 @@ int acpi_bus_generate_event(struct acpi_device *device, u8 type, int data)
 	return 0;
 }
 
-EXPORT_SYMBOL(acpi_bus_generate_event);
+EXPORT_SYMBOL(acpi_bus_generate_proc_event);
 
 int acpi_bus_receive_event(struct acpi_bus_event *event)
 {
@@ -360,6 +361,7 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
 }
 
 EXPORT_SYMBOL(acpi_bus_receive_event);
+#endif	/* CONFIG_ACPI_PROC_EVENT */
 
 /* --------------------------------------------------------------------------
                              Notification Handling

commit 962ce8ca0604af0c3c5609f7613d4ec5fcfac623
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Aug 23 01:24:31 2007 +0800

    ACPI: don't duplicate input events on netlink
    
    The previous events patch added a netlink event for every
    user of the legacy /proc/acpi/event interface.
    
    However, some users of /proc/acpi/event are really input events,
    and they already report their events via the input layer.
    
    Introduce a new interface, acpi_bus_generate_netlink_event(),
    which is explicitly called by devices that want to repoprt
    events via netlink.  This allows the input-like events
    to opt-out of generating netlink events.  In summary:
    
    events that are sent via netlink:
            ac/battery/sbs
            thermal
            processor
            thinkpad_acpi dock/bay
    
    events that are sent via input layer:
            button
            video hotkey
            thinkpad_acpi hotkey
            asus_acpi/asus-laptop hotkey
            sonypi/sonylaptop
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 6b2658c96242..e5084ececb6f 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -292,10 +292,6 @@ int acpi_bus_generate_event(struct acpi_device *device, u8 type, int data)
 	if (!device)
 		return -EINVAL;
 
-	if (acpi_bus_generate_genetlink_event(device, type, data))
-		printk(KERN_WARNING PREFIX
-			"Failed to generate an ACPI event via genetlink!\n");
-
 	/* drop event on the floor if no one's listening */
 	if (!event_is_open)
 		return 0;

commit 864bdfb912e372670b5b2541dac9d273a4a7722a
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jun 19 11:40:03 2007 +0800

    ACPI: Export events via generic netlink
    
    Upon ACPI events, send an "acpi_event" via Generic Netlink.
    This is in addition to /proc/acpi/event, which remains intact for now.
    
    Thanks to Jamal for his great help.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index e5084ececb6f..6b2658c96242 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -292,6 +292,10 @@ int acpi_bus_generate_event(struct acpi_device *device, u8 type, int data)
 	if (!device)
 		return -EINVAL;
 
+	if (acpi_bus_generate_genetlink_event(device, type, data))
+		printk(KERN_WARNING PREFIX
+			"Failed to generate an ACPI event via genetlink!\n");
+
 	/* drop event on the floor if no one's listening */
 	if (!event_is_open)
 		return 0;

commit 0c0e8921018dbb4fe189a1034f80ac32553bc7bc
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Apr 25 14:20:58 2007 -0400

    ACPI: use _STA bit names rather than 0x0F
    
    Be explicit about what "device->status = 0x0F" really means.
    
    syntax only.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index dd49ea0d0ed3..e5084ececb6f 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -103,7 +103,9 @@ int acpi_bus_get_status(struct acpi_device *device)
 	else if (device->parent)
 		device->status = device->parent->status;
 	else
-		STRUCT_TO_INT(device->status) = 0x0F;
+		STRUCT_TO_INT(device->status) =
+		    ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED |
+		    ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING;
 
 	if (device->status.functional && !device->status.present) {
 		printk(KERN_WARNING PREFIX "Device [%s] status [%08x]: "

commit 902b236c087bf021c94cc21a2b09d928c4156c2b
Merge: 08e4a10ec82f aafbcd165a2a
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:11:57 2007 -0500

    Pull bugzilla-7887 into release branch

commit 08e4a10ec82faf5ba67c8d0115b7bc9e58071555
Merge: 4559b438225b b1028c545ced
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:11:50 2007 -0500

    Pull bugzilla-7570 into release branch

commit b1028c545ced13590dd9a9a8086543aef26c7187
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Fri Feb 16 02:23:07 2007 -0500

    ACPI: fix fan after resume from S3
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7570
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c26468da4295..be9a878557c7 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -199,15 +199,14 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	 * Get device's current power state if it's unknown
 	 * This means device power state isn't initialized or previous setting failed
 	 */
-	if (!device->flags.force_power_state) {
-		if (device->power.state == ACPI_STATE_UNKNOWN)
-			acpi_bus_get_power(device->handle, &device->power.state);
-		if (state == device->power.state) {
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
-					  state));
-			return 0;
-		}
+	if ((device->power.state == ACPI_STATE_UNKNOWN) || device->flags.force_power_state)
+		acpi_bus_get_power(device->handle, &device->power.state);
+	if ((state == device->power.state) && !device->flags.force_power_state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
+				  state));
+		return 0;
 	}
+
 	if (!device->power.states[state].flags.valid) {
 		printk(KERN_WARNING PREFIX "Device does not support D%d\n", state);
 		return -ENODEV;

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c26468da4295..fd37e19360d0 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -39,7 +39,7 @@
 #include <acpi/acpi_drivers.h>
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME("acpi_bus")
+ACPI_MODULE_NAME("bus");
 #ifdef	CONFIG_X86
 extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
 #endif

commit aafbcd165a2a02e6dff173f66772b3148229ace8
Author: Alexey Starikovskiy <alexey.y.starikovskiy@linux.intel.com>
Date:   Sat Feb 10 01:32:16 2007 -0500

    ACPI: invoke acpi_sleep_init() earlier
    
    late_initcall() is too late for acpi_sleep_init().
    Call it directly from acpi_init code.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7887
    
    Signed-off-by: Alexey Starikovskiy <alexey.y.starikovskiy@linux.intel.com>
    Signed-off-by: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index c26468da4295..41cebe5bc807 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -147,7 +147,7 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 			*state = ACPI_STATE_D0;
 	} else {
 		/*
-		 * Get the device's power state either directly (via _PSC) or 
+		 * Get the device's power state either directly (via _PSC) or
 		 * indirectly (via power resources).
 		 */
 		if (device->power.flags.explicit_get) {
@@ -462,7 +462,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 				  "Received BUS CHECK notification for device [%s]\n",
 				  device->pnp.bus_id));
 		result = acpi_bus_check_scope(device);
-		/* 
+		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
 		 *      drivers via the device manager (device.c).
 		 */
@@ -473,7 +473,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 				  "Received DEVICE CHECK notification for device [%s]\n",
 				  device->pnp.bus_id));
 		result = acpi_bus_check_device(device, NULL);
-		/* 
+		/*
 		 * TBD: We'll need to outsource certain events to non-ACPI
 		 *      drivers via the device manager (device.c).
 		 */
@@ -543,7 +543,7 @@ static int __init acpi_bus_init_irq(void)
 	char *message = NULL;
 
 
-	/* 
+	/*
 	 * Let the system know what interrupt model we are using by
 	 * evaluating the \_PIC object, if exists.
 	 */
@@ -684,7 +684,7 @@ static int __init acpi_bus_init(void)
 	 * the EC device is found in the namespace (i.e. before acpi_initialize_objects()
 	 * is called).
 	 *
-	 * This is accomplished by looking for the ECDT table, and getting 
+	 * This is accomplished by looking for the ECDT table, and getting
 	 * the EC parameters out of that.
 	 */
 	status = acpi_ec_ecdt_probe();
@@ -699,6 +699,9 @@ static int __init acpi_bus_init(void)
 
 	printk(KERN_INFO PREFIX "Interpreter enabled\n");
 
+	/* Initialize sleep structures */
+	acpi_sleep_init();
+
 	/*
 	 * Get the system interrupt model and evaluate \_PIC.
 	 */

commit 975a8e3ed2b9eab9f062a1e0ba7fe180e15204e1
Merge: 1fcb71b84b05 bfd80223d73f
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 3 01:14:35 2007 -0500

    Pull sysfs into test branch
    
    Conflicts:
    
            Documentation/feature-removal-schedule.txt
            include/acpi/acpi_drivers.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 5f3b1a8b6737b09ce5df4ec9fad4ad271aecb5fb
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:22 2007 +0300

    ACPICA: Remove duplicate table definitions (non-conflicting)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 324b0991943e..15d677e6cee9 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -620,15 +620,16 @@ void __init acpi_early_init(void)
 
 #ifdef CONFIG_X86
 	if (!acpi_ioapic) {
-		extern acpi_interrupt_flags acpi_sci_flags;
+		extern u8 acpi_sci_flags;
 
 		/* compatible (0) means level (3) */
-		if (acpi_sci_flags.trigger == 0)
-			acpi_sci_flags.trigger = 3;
-
+		if (!(acpi_sci_flags & ACPI_MADT_TRIGGER_MASK)) {
+			acpi_sci_flags &= ~ACPI_MADT_TRIGGER_MASK;
+			acpi_sci_flags |= ACPI_MADT_TRIGGER_LEVEL;
+		}
 		/* Set PIC-mode SCI trigger type */
 		acpi_pic_sci_set_trigger(acpi_gbl_FADT.sci_interrupt,
-					 acpi_sci_flags.trigger);
+					 (acpi_sci_flags & ACPI_MADT_TRIGGER_MASK) >> 2);
 	} else {
 		extern int acpi_sci_override_gsi;
 		/*

commit cee324b145a1e5488b34191de670e5ed1d346ebb
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:22 2007 +0300

    ACPICA: use new ACPI headers.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index cb807c43e59b..324b0991943e 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -627,15 +627,15 @@ void __init acpi_early_init(void)
 			acpi_sci_flags.trigger = 3;
 
 		/* Set PIC-mode SCI trigger type */
-		acpi_pic_sci_set_trigger(acpi_fadt.sci_int,
+		acpi_pic_sci_set_trigger(acpi_gbl_FADT.sci_interrupt,
 					 acpi_sci_flags.trigger);
 	} else {
 		extern int acpi_sci_override_gsi;
 		/*
-		 * now that acpi_fadt is initialized,
+		 * now that acpi_gbl_FADT is initialized,
 		 * update it with result from INT_SRC_OVR parsing
 		 */
-		acpi_fadt.sci_int = acpi_sci_override_gsi;
+		acpi_gbl_FADT.sci_interrupt = acpi_sci_override_gsi;
 	}
 #endif
 

commit ad71860a17ba33eb0e673e9e2cf5ba0d8e3e3fdd
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:19 2007 +0300

    ACPICA: minimal patch to integrate new tables into Linux
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 766332e45592..cb807c43e59b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -44,9 +44,6 @@ ACPI_MODULE_NAME("acpi_bus")
 extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
 #endif
 
-struct fadt_descriptor acpi_fadt;
-EXPORT_SYMBOL(acpi_fadt);
-
 struct acpi_device *acpi_root;
 struct proc_dir_entry *acpi_root_dir;
 EXPORT_SYMBOL(acpi_root_dir);
@@ -582,11 +579,12 @@ static int __init acpi_bus_init_irq(void)
 	return 0;
 }
 
+acpi_native_uint acpi_gbl_permanent_mmap;
+
+
 void __init acpi_early_init(void)
 {
 	acpi_status status = AE_OK;
-	struct acpi_buffer buffer = { sizeof(acpi_fadt), &acpi_fadt };
-
 
 	if (acpi_disabled)
 		return;
@@ -597,6 +595,15 @@ void __init acpi_early_init(void)
 	if (!acpi_strict)
 		acpi_gbl_enable_interpreter_slack = TRUE;
 
+	acpi_gbl_permanent_mmap = 1;
+
+	status = acpi_reallocate_root_table();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX
+		       "Unable to reallocate ACPI tables\n");
+		goto error0;
+	}
+
 	status = acpi_initialize_subsystem();
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX
@@ -611,14 +618,6 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
-	/*
-	 * Get a separate copy of the FADT for use by other drivers.
-	 */
-	status = acpi_get_table(ACPI_TABLE_ID_FADT, 1, &buffer);
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to get the FADT\n");
-		goto error0;
-	}
 #ifdef CONFIG_X86
 	if (!acpi_ioapic) {
 		extern acpi_interrupt_flags acpi_sci_flags;

commit 3948ec9406f9a60a43d63f23f6f5284db6529b9c
Author: John Keller <jpk@sgi.com>
Date:   Fri Dec 22 11:50:04 2006 -0600

    ACPI: Altix: ACPI _PRT support
    
    Provide ACPI _PRT support for SN Altix systems.
    
    The SN Altix platform does not conform to the
    IOSAPIC IRQ routing model, so a new acpi_irq_model
    (ACPI_IRQ_MODEL_PLATFORM) has been defined. The SN
    platform specific code sets acpi_irq_model to
    this new value, and keys off of it in acpi_register_gsi()
    to avoid the iosapic code path.
    
    Signed-off-by: John Keller <jpk@sgi.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 279c4bac92e5..766332e45592 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -561,6 +561,9 @@ static int __init acpi_bus_init_irq(void)
 	case ACPI_IRQ_MODEL_IOSAPIC:
 		message = "IOSAPIC";
 		break;
+	case ACPI_IRQ_MODEL_PLATFORM:
+		message = "platform specific model";
+		break;
 	default:
 		printk(KERN_WARNING PREFIX "Unknown interrupt routing model\n");
 		return -ENODEV;

commit f883d9db008deb20d4969c26475100cec2b7f6f8
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:38 2006 +0800

    ACPI: convert to sysfs framework
    
    Setup new sysfs framework
    
    1.      Remove /sys/firmware/acpi
    2.      Add ACPI device in device tree.
    
    File "eject" for every device that has _EJ0 method is moved from
    /sys/firmware to /sys/devices.
    Operation on this file is exactly the same as before.
    i.e. echo 1 to "eject" will cause hot removal of this device.
    Corresponding changes should be made in userspace for hot removal.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui<rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 279c4bac92e5..da471f647d07 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -195,7 +195,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 
 	if (!device->flags.power_manageable) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device `[%s]' is not power manageable\n",
-				device->kobj.name));
+				device->dev.kobj.name));
 		return -ENODEV;
 	}
 	/*

commit 9805cb76f7bcd3108e012270d9ef2fd8ea3bea55
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 25 13:30:57 2006 -0400

    ACPI: restore some dmesg to DEBUG-only, ala 2.6.17
    
    The ACPI_EXCEPTION() patch enabled a bunch of messages to print
    even in the non-DEBUG kernel.  Need to change a couple back,
    and note that ACPI_EXCEPTION takes no \n, but ACPI_DEBUG_PRINT does.
    
    No context for object [%p]\n
    Device `[%s]' is not power manageable\n
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 7b77ee146a80..279c4bac92e5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -69,7 +69,8 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 
 	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
 	if (ACPI_FAILURE(status) || !*device) {
-		ACPI_EXCEPTION((AE_INFO, status, "No context for object [%p]", handle));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
+				  handle));
 		return -ENODEV;
 	}
 
@@ -193,7 +194,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	/* Make sure this is a valid target state */
 
 	if (!device->flags.power_manageable) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device `[%s]' is not power manageable",
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device `[%s]' is not power manageable\n",
 				device->kobj.name));
 		return -ENODEV;
 	}

commit d568df84f987a9321c1f5826a6c8678ef2bb2b70
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jul 12 01:47:00 2006 -0400

    ACPI: handle firmware_register init errors
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index b2977695e120..7b77ee146a80 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/sched.h>
 #include <linux/pm.h>
@@ -738,7 +739,10 @@ static int __init acpi_init(void)
 		return -ENODEV;
 	}
 
-	firmware_register(&acpi_subsys);
+	result = firmware_register(&acpi_subsys);
+	if (result < 0)
+		printk(KERN_WARNING "%s: firmware_register error: %d\n",
+			__FUNCTION__, result);
 
 	result = acpi_bus_init();
 

commit af4f949c6b4ffa5119aad980626e5b04daca961b
Author: Len Brown <len.brown@intel.com>
Date:   Sun Jul 9 16:33:26 2006 -0400

    ACPI: "Device `[%s]' is not power manageable" make message debug only
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index ea5a0496a4fd..b2977695e120 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -192,8 +192,8 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	/* Make sure this is a valid target state */
 
 	if (!device->flags.power_manageable) {
-		printk(KERN_DEBUG "Device `[%s]' is not power manageable",
-				device->kobj.name);
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device `[%s]' is not power manageable",
+				device->kobj.name));
 		return -ENODEV;
 	}
 	/*

commit 345a6e6aea43cd544c682601926bbd11c09c999b
Author: Jae-hyeon Park <jhpark@tuhep.phys.tohoku.ac.jp>
Date:   Sat Jul 1 04:35:47 2006 -0700

    [PATCH] ACPI: fix not power-manageable device message
    
    Fix typo in message.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index dec044c04273..ea5a0496a4fd 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -192,7 +192,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	/* Make sure this is a valid target state */
 
 	if (!device->flags.power_manageable) {
-		printk(KERN_DEBUG "Device `[%s]is not power manageable",
+		printk(KERN_DEBUG "Device `[%s]' is not power manageable",
 				device->kobj.name);
 		return -ENODEV;
 	}

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 6c6286290127..dec044c04273 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -60,20 +60,19 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 {
 	acpi_status status = AE_OK;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_get_device");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* TBD: Support fixed-feature devices */
 
 	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
 	if (ACPI_FAILURE(status) || !*device) {
 		ACPI_EXCEPTION((AE_INFO, status, "No context for object [%p]", handle));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 EXPORT_SYMBOL(acpi_bus_get_device);
@@ -83,10 +82,9 @@ int acpi_bus_get_status(struct acpi_device *device)
 	acpi_status status = AE_OK;
 	unsigned long sta = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_get_status");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/*
 	 * Evaluate _STA if present.
@@ -95,7 +93,7 @@ int acpi_bus_get_status(struct acpi_device *device)
 		status =
 		    acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
 		if (ACPI_FAILURE(status))
-			return_VALUE(-ENODEV);
+			return -ENODEV;
 		STRUCT_TO_INT(device->status) = (int)sta;
 	}
 
@@ -119,7 +117,7 @@ int acpi_bus_get_status(struct acpi_device *device)
 			  device->pnp.bus_id,
 			  (u32) STRUCT_TO_INT(device->status)));
 
-	return_VALUE(0);
+	return 0;
 }
 
 EXPORT_SYMBOL(acpi_bus_get_status);
@@ -135,11 +133,10 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 	struct acpi_device *device = NULL;
 	unsigned long psc = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_get_power");
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	*state = ACPI_STATE_UNKNOWN;
 
@@ -158,12 +155,12 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 			status = acpi_evaluate_integer(device->handle, "_PSC",
 						       NULL, &psc);
 			if (ACPI_FAILURE(status))
-				return_VALUE(-ENODEV);
+				return -ENODEV;
 			device->power.state = (int)psc;
 		} else if (device->power.flags.power_resources) {
 			result = acpi_power_get_inferred_state(device);
 			if (result)
-				return_VALUE(result);
+				return result;
 		}
 
 		*state = device->power.state;
@@ -172,7 +169,7 @@ int acpi_bus_get_power(acpi_handle handle, int *state)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
 			  device->pnp.bus_id, device->power.state));
 
-	return_VALUE(0);
+	return 0;
 }
 
 EXPORT_SYMBOL(acpi_bus_get_power);
@@ -184,21 +181,20 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	struct acpi_device *device = NULL;
 	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
 
-	ACPI_FUNCTION_TRACE("acpi_bus_set_power");
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	if ((state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* Make sure this is a valid target state */
 
 	if (!device->flags.power_manageable) {
 		printk(KERN_DEBUG "Device `[%s]is not power manageable",
 				device->kobj.name);
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 	/*
 	 * Get device's current power state if it's unknown
@@ -210,18 +206,18 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 		if (state == device->power.state) {
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
 					  state));
-			return_VALUE(0);
+			return 0;
 		}
 	}
 	if (!device->power.states[state].flags.valid) {
 		printk(KERN_WARNING PREFIX "Device does not support D%d\n", state);
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 	if (device->parent && (state < device->parent->power.state)) {
 		printk(KERN_WARNING PREFIX
 			      "Cannot set device to a higher-powered"
 			      " state than parent\n");
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	/*
@@ -271,7 +267,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 				  "Device [%s] transitioned to D%d\n",
 				  device->pnp.bus_id, state));
 
-	return_VALUE(result);
+	return result;
 }
 
 EXPORT_SYMBOL(acpi_bus_set_power);
@@ -292,18 +288,17 @@ int acpi_bus_generate_event(struct acpi_device *device, u8 type, int data)
 	struct acpi_bus_event *event = NULL;
 	unsigned long flags = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_generate_event");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* drop event on the floor if no one's listening */
 	if (!event_is_open)
-		return_VALUE(0);
+		return 0;
 
 	event = kmalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC);
 	if (!event)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 
 	strcpy(event->device_class, device->pnp.device_class);
 	strcpy(event->bus_id, device->pnp.bus_id);
@@ -316,7 +311,7 @@ int acpi_bus_generate_event(struct acpi_device *device, u8 type, int data)
 
 	wake_up_interruptible(&acpi_bus_event_queue);
 
-	return_VALUE(0);
+	return 0;
 }
 
 EXPORT_SYMBOL(acpi_bus_generate_event);
@@ -328,10 +323,9 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
 
 	DECLARE_WAITQUEUE(wait, current);
 
-	ACPI_FUNCTION_TRACE("acpi_bus_receive_event");
 
 	if (!event)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (list_empty(&acpi_bus_event_list)) {
 
@@ -345,7 +339,7 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
 		set_current_state(TASK_RUNNING);
 
 		if (signal_pending(current))
-			return_VALUE(-ERESTARTSYS);
+			return -ERESTARTSYS;
 	}
 
 	spin_lock_irqsave(&acpi_bus_event_lock, flags);
@@ -356,13 +350,13 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
 	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
 
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	memcpy(event, entry, sizeof(struct acpi_bus_event));
 
 	kfree(entry);
 
-	return_VALUE(0);
+	return 0;
 }
 
 EXPORT_SYMBOL(acpi_bus_receive_event);
@@ -377,10 +371,9 @@ acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 	acpi_status status = 0;
 	struct acpi_device_status old_status;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_check_device");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (status_changed)
 		*status_changed = 0;
@@ -397,15 +390,15 @@ acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 			if (status_changed)
 				*status_changed = 1;
 		}
-		return_VALUE(0);
+		return 0;
 	}
 
 	status = acpi_bus_get_status(device);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
-		return_VALUE(0);
+		return 0;
 
 	if (status_changed)
 		*status_changed = 1;
@@ -421,7 +414,7 @@ acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 		/* TBD: Handle device removal */
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_bus_check_scope(struct acpi_device *device)
@@ -429,25 +422,24 @@ static int acpi_bus_check_scope(struct acpi_device *device)
 	int result = 0;
 	int status_changed = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_check_scope");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* Status Change? */
 	result = acpi_bus_check_device(device, &status_changed);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	if (!status_changed)
-		return_VALUE(0);
+		return 0;
 
 	/*
 	 * TBD: Enumerate child devices within this device's scope and
 	 *       run acpi_bus_check_device()'s on them.
 	 */
 
-	return_VALUE(0);
+	return 0;
 }
 
 /**
@@ -460,10 +452,9 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 	int result = 0;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_notify");
 
 	if (acpi_bus_get_device(handle, &device))
-		return_VOID;
+		return;
 
 	switch (type) {
 
@@ -538,7 +529,7 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 	}
 
-	return_VOID;
+	return;
 }
 
 /* --------------------------------------------------------------------------
@@ -552,7 +543,6 @@ static int __init acpi_bus_init_irq(void)
 	struct acpi_object_list arg_list = { 1, &arg };
 	char *message = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_init_irq");
 
 	/* 
 	 * Let the system know what interrupt model we are using by
@@ -571,7 +561,7 @@ static int __init acpi_bus_init_irq(void)
 		break;
 	default:
 		printk(KERN_WARNING PREFIX "Unknown interrupt routing model\n");
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	printk(KERN_INFO PREFIX "Using %s for interrupt routing\n", message);
@@ -581,10 +571,10 @@ static int __init acpi_bus_init_irq(void)
 	status = acpi_evaluate_object(NULL, "\\_PIC", &arg_list, NULL);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PIC"));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 void __init acpi_early_init(void)
@@ -592,10 +582,9 @@ void __init acpi_early_init(void)
 	acpi_status status = AE_OK;
 	struct acpi_buffer buffer = { sizeof(acpi_fadt), &acpi_fadt };
 
-	ACPI_FUNCTION_TRACE("acpi_early_init");
 
 	if (acpi_disabled)
-		return_VOID;
+		return;
 
 	printk(KERN_INFO PREFIX "Core revision %08x\n", ACPI_CA_VERSION);
 
@@ -655,11 +644,11 @@ void __init acpi_early_init(void)
 		goto error0;
 	}
 
-	return_VOID;
+	return;
 
       error0:
 	disable_acpi();
-	return_VOID;
+	return;
 }
 
 static int __init acpi_bus_init(void)
@@ -668,7 +657,6 @@ static int __init acpi_bus_init(void)
 	acpi_status status = AE_OK;
 	extern acpi_status acpi_os_initialize1(void);
 
-	ACPI_FUNCTION_TRACE("acpi_bus_init");
 
 	status = acpi_os_initialize1();
 
@@ -730,12 +718,12 @@ static int __init acpi_bus_init(void)
 	 */
 	acpi_root_dir = proc_mkdir(ACPI_BUS_FILE_ROOT, NULL);
 
-	return_VALUE(0);
+	return 0;
 
 	/* Mimic structured exception handling */
       error1:
 	acpi_terminate();
-	return_VALUE(-ENODEV);
+	return -ENODEV;
 }
 
 decl_subsys(acpi, NULL, NULL);
@@ -744,11 +732,10 @@ static int __init acpi_init(void)
 {
 	int result = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_init");
 
 	if (acpi_disabled) {
 		printk(KERN_INFO PREFIX "Interpreter disabled.\n");
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	firmware_register(&acpi_subsys);
@@ -769,7 +756,7 @@ static int __init acpi_init(void)
 	} else
 		disable_acpi();
 
-	return_VALUE(result);
+	return result;
 }
 
 subsys_initcall(acpi_init);

commit cece92969762b8ed7930d4e23008b76b06411dee
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:04:31 2006 -0400

    ACPI: un-export ACPI_WARNING() -- use printk(KERN_WARNING...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index f4a36d372cac..6c6286290127 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -214,13 +214,13 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 		}
 	}
 	if (!device->power.states[state].flags.valid) {
-		ACPI_WARNING((AE_INFO, "Device does not support D%d", state));
+		printk(KERN_WARNING PREFIX "Device does not support D%d\n", state);
 		return_VALUE(-ENODEV);
 	}
 	if (device->parent && (state < device->parent->power.state)) {
-		ACPI_WARNING((AE_INFO,
+		printk(KERN_WARNING PREFIX
 			      "Cannot set device to a higher-powered"
-			      " state than parent"));
+			      " state than parent\n");
 		return_VALUE(-ENODEV);
 	}
 
@@ -263,9 +263,9 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 
       end:
 	if (result)
-		ACPI_WARNING((AE_INFO,
-			      "Transitioning device [%s] to D%d",
-			      device->pnp.bus_id, state));
+		printk(KERN_WARNING PREFIX
+			      "Transitioning device [%s] to D%d\n",
+			      device->pnp.bus_id, state);
 	else
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to D%d\n",

commit 64dedfb8fdbbc4fabb8c131e4b597cd4bc7f3881
Author: Jae-hyeon Park <hpark@tuhep.phys.tohoku.ac.jp>
Date:   Mon Jun 26 22:34:03 2006 -0400

    ACPI: Device [kobj-name] is not power manageable
    
    print kobj name in this message.
    lenb changed to use printk.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 917bf2397b22..f4a36d372cac 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -196,7 +196,8 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	/* Make sure this is a valid target state */
 
 	if (!device->flags.power_manageable) {
-		ACPI_INFO((AE_INFO, "Device is not power manageable"));
+		printk(KERN_DEBUG "Device `[%s]is not power manageable",
+				device->kobj.name);
 		return_VALUE(-ENODEV);
 	}
 	/*

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index dd3983cece92..917bf2397b22 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -69,8 +69,7 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 
 	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
 	if (ACPI_FAILURE(status) || !*device) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "No context for object [%p]\n",
-				  handle));
+		ACPI_EXCEPTION((AE_INFO, status, "No context for object [%p]", handle));
 		return_VALUE(-ENODEV);
 	}
 
@@ -197,8 +196,7 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	/* Make sure this is a valid target state */
 
 	if (!device->flags.power_manageable) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				  "Device is not power manageable\n"));
+		ACPI_INFO((AE_INFO, "Device is not power manageable"));
 		return_VALUE(-ENODEV);
 	}
 	/*
@@ -215,13 +213,13 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 		}
 	}
 	if (!device->power.states[state].flags.valid) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n",
-				  state));
+		ACPI_WARNING((AE_INFO, "Device does not support D%d", state));
 		return_VALUE(-ENODEV);
 	}
 	if (device->parent && (state < device->parent->power.state)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				  "Cannot set device to a higher-powered state than parent\n"));
+		ACPI_WARNING((AE_INFO,
+			      "Cannot set device to a higher-powered"
+			      " state than parent"));
 		return_VALUE(-ENODEV);
 	}
 
@@ -264,9 +262,9 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 
       end:
 	if (result)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				  "Error transitioning device [%s] to D%d\n",
-				  device->pnp.bus_id, state));
+		ACPI_WARNING((AE_INFO,
+			      "Transitioning device [%s] to D%d",
+			      device->pnp.bus_id, state));
 	else
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to D%d\n",
@@ -581,7 +579,7 @@ static int __init acpi_bus_init_irq(void)
 
 	status = acpi_evaluate_object(NULL, "\\_PIC", &arg_list, NULL);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PIC\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PIC"));
 		return_VALUE(-ENODEV);
 	}
 

commit 8f2ddb37e564a9616c05fa0d5652e0049072a730
Merge: 5b542e442276 74ce1468128e
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 21:36:11 2006 -0400

    Pull bugzilla-5000 into release branch

commit b229cf92eee616c7cb5ad8cdb35a19b119f00bc8
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Apr 21 17:15:00 2006 -0400

    ACPI: ACPICA 20060421
    
    Removed a device initialization optimization introduced in
    20051216 where the _STA method was not run unless an _INI
    was also present for the same device. This optimization
    could cause problems because it could allow _INI methods
    to be run within a not-present device subtree (If a
    not-present device had no _INI, _STA would not be run,
    the not-present status would not be discovered, and the
    children of the device would be incorrectly traversed.)
    
    Implemented a new _STA optimization where namespace
    subtrees that do not contain _INI are identified and
    ignored during device initialization. Selectively running
    _STA can significantly improve boot time on large machines
    (with assistance from Len Brown.)
    
    Implemented support for the device initialization case
    where the returned _STA flags indicate a device not-present
    but functioning. In this case, _INI is not run, but the
    device children are examined for presence, as per the
    ACPI specification.
    
    Implemented an additional change to the IndexField support
    in order to conform to MS behavior. The value written to
    the Index Register is not simply a byte offset, it is a
    byte offset in units of the access width of the parent
    Index Field. (Fiodor Suietov)
    
    Defined and deployed a new OSL interface,
    acpi_os_validate_address().  This interface is called during
    the creation of all AML operation regions, and allows
    the host OS to exert control over what addresses it will
    allow the AML code to access. Operation Regions whose
    addresses are disallowed will cause a runtime exception
    when they are actually accessed (will not affect or abort
    table loading.)
    
    Defined and deployed a new OSL interface,
    acpi_os_validate_interface().  This interface allows the host OS
    to match the various "optional" interface/behavior strings
    for the _OSI predefined control method as appropriate
    (with assistance from Bjorn Helgaas.)
    
    Restructured and corrected various problems in the
    exception handling code paths within DsCallControlMethod
    and DsTerminateControlMethod in dsmethod (with assistance
    from Takayoshi Kochi.)
    
    Modified the Linux source converter to ignore quoted string
    literals while converting identifiers from mixed to lower
    case. This will correct problems with the disassembler
    and other areas where such strings must not be modified.
    
    The ACPI_FUNCTION_* macros no longer require quotes around
    the function name. This allows the Linux source converter
    to convert the names, now that the converter ignores
    quoted strings.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index b3a214db56f6..b77f03d51f0b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -619,7 +619,7 @@ void __init acpi_early_init(void)
 	/*
 	 * Get a separate copy of the FADT for use by other drivers.
 	 */
-	status = acpi_get_table(ACPI_TABLE_FADT, 1, &buffer);
+	status = acpi_get_table(ACPI_TABLE_ID_FADT, 1, &buffer);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to get the FADT\n");
 		goto error0;

commit 793c2388cae3fd023b3b5166354931752d42353c
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 31 00:00:00 2006 -0500

    ACPI: ACPICA 20060331
    
    Implemented header file support for the following
    additional ACPI tables: ASF!, BOOT, CPEP, DBGP, MCFG, SPCR,
    SPMI, TCPA, and WDRT. With this support, all current and
    known ACPI tables are now defined in the ACPICA headers and
    are available for use by device drivers and other software.
    
    Implemented support to allow tables that contain ACPI
    names with invalid characters to be loaded. Previously,
    this would cause the table load to fail, but since
    there are several known cases of such tables on
    existing machines, this change was made to enable
    ACPI support for them. Also, this matches the
    behavior of the Microsoft ACPI implementation.
    https://bugzilla.novell.com/show_bug.cgi?id=147621
    
    Fixed a couple regressions introduced during the memory
    optimization in the 20060317 release. The namespace
    node definition required additional reorganization and
    an internal datatype that had been changed to 8-bit was
    restored to 32-bit. (Valery Podrezov)
    
    Fixed a problem where a null pointer passed to
    acpi_ut_delete_generic_state() could be passed through
    to acpi_os_release_object which is unexpected. Such
    null pointers are now trapped and ignored, matching
    the behavior of the previous implementation before the
    deployment of acpi_os_release_object().  (Valery Podrezov,
    Fiodor Suietov)
    
    Fixed a memory mapping leak during the deletion of
    a SystemMemory operation region where a cached memory
    mapping was not deleted. This became a noticeable problem
    for operation regions that are defined within frequently
    used control methods. (Dana Meyers)
    
    Reorganized the ACPI table header files into two main
    files: one for the ACPI tables consumed by the ACPICA core,
    and another for the miscellaneous ACPI tables that are
    consumed by the drivers and other software. The various
    FADT definitions were merged into one common section and
    three different tables (ACPI 1.0, 1.0+, and 2.0)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 9c4ac0191f64..b3a214db56f6 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -43,7 +43,7 @@ ACPI_MODULE_NAME("acpi_bus")
 extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
 #endif
 
-FADT_DESCRIPTOR acpi_fadt;
+struct fadt_descriptor acpi_fadt;
 EXPORT_SYMBOL(acpi_fadt);
 
 struct acpi_device *acpi_root;

commit 61686124f47d7c4b78610346c5f8f9d8a6d46bb5
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 17 16:44:00 2006 -0500

    [ACPI] ACPICA 20060317
    
    Implemented the use of a cache object for all internal
    namespace nodes. Since there are about 1000 static nodes
    in a typical system, this will decrease memory use for
    cache implementations that minimize per-allocation overhead
    (such as a slab allocator.)
    
    Removed the reference count mechanism for internal
    namespace nodes, since it was deemed unnecessary. This
    reduces the size of each namespace node by about 5%-10%
    on all platforms. Nodes are now 20 bytes for the 32-bit
    case, and 32 bytes for the 64-bit case.
    
    Optimized several internal data structures to reduce
    object size on 64-bit platforms by packing data within
    the 64-bit alignment. This includes the frequently used
    ACPI_OPERAND_OBJECT, of which there can be ~1000 static
    instances corresponding to the namespace objects.
    
    Added two new strings for the predefined _OSI method:
    "Windows 2001.1 SP1" and "Windows 2006".
    
    Split the allocation tracking mechanism out to a separate
    file, from utalloc.c to uttrack.c. This mechanism appears
    to be only useful for application-level code. Kernels may
    wish to not include uttrack.c in distributions.
    
    Removed all remnants of the obsolete ACPI_REPORT_* macros
    and the associated code. (These macros have been replaced
    by the ACPI_ERROR and ACPI_WARNING macros.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 606f8733a776..9c4ac0191f64 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -596,6 +596,8 @@ void __init acpi_early_init(void)
 	if (acpi_disabled)
 		return_VOID;
 
+	printk(KERN_INFO PREFIX "Core revision %08x\n", ACPI_CA_VERSION);
+
 	/* enable workarounds, unless strict ACPI spec. compliance */
 	if (!acpi_strict)
 		acpi_gbl_enable_interpreter_slack = TRUE;
@@ -743,8 +745,6 @@ static int __init acpi_init(void)
 
 	ACPI_FUNCTION_TRACE("acpi_init");
 
-	printk(KERN_INFO PREFIX "Subsystem revision %08x\n", ACPI_CA_VERSION);
-
 	if (acpi_disabled) {
 		printk(KERN_INFO PREFIX "Interpreter disabled.\n");
 		return_VALUE(-ENODEV);

commit 0feabb01d93e5801d1127416a66cfc3963280bca
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Mon May 8 00:00:00 2006 -0400

    ACPI: create acpi_fan_suspend()/acpi_fan_resume()
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5000
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 606f8733a776..eff696f2b6bb 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -205,12 +205,14 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	 * Get device's current power state if it's unknown
 	 * This means device power state isn't initialized or previous setting failed
 	 */
-	if (device->power.state == ACPI_STATE_UNKNOWN)
-		acpi_bus_get_power(device->handle, &device->power.state);
-	if (state == device->power.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
-				  state));
-		return_VALUE(0);
+	if (!device->flags.force_power_state) {
+		if (device->power.state == ACPI_STATE_UNKNOWN)
+			acpi_bus_get_power(device->handle, &device->power.state);
+		if (state == device->power.state) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
+					  state));
+			return_VALUE(0);
+		}
 	}
 	if (!device->power.states[state].flags.valid) {
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n",

commit bca73e4bf8563d83f7856164caa44d5f42e44cca
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Nov 13 16:06:25 2005 -0800

    [PATCH] move pm_register/etc. to CONFIG_PM_LEGACY, pm_legacy.h
    
    Since few people need the support anymore, this moves the legacy
    pm_xxx functions to CONFIG_PM_LEGACY, and include/linux/pm_legacy.h.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 6a4da417c16b..606f8733a776 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -28,6 +28,7 @@
 #include <linux/list.h>
 #include <linux/sched.h>
 #include <linux/pm.h>
+#include <linux/pm_legacy.h>
 #include <linux/device.h>
 #include <linux/proc_fs.h>
 #ifdef CONFIG_X86
@@ -754,7 +755,7 @@ static int __init acpi_init(void)
 	result = acpi_bus_init();
 
 	if (!result) {
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_LEGACY
 		if (!PM_IS_ACTIVE())
 			pm_active = 1;
 		else {

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index d77c2307883c..6a4da417c16b 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -36,19 +36,17 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-
 #define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME		("acpi_bus")
-
+ACPI_MODULE_NAME("acpi_bus")
 #ifdef	CONFIG_X86
 extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
 #endif
 
-FADT_DESCRIPTOR			acpi_fadt;
+FADT_DESCRIPTOR acpi_fadt;
 EXPORT_SYMBOL(acpi_fadt);
 
-struct acpi_device		*acpi_root;
-struct proc_dir_entry		*acpi_root_dir;
+struct acpi_device *acpi_root;
+struct proc_dir_entry *acpi_root_dir;
 EXPORT_SYMBOL(acpi_root_dir);
 
 #define STRUCT_TO_INT(s)	(*((int*)&s))
@@ -57,12 +55,9 @@ EXPORT_SYMBOL(acpi_root_dir);
                                 Device Management
    -------------------------------------------------------------------------- */
 
-int
-acpi_bus_get_device (
-	acpi_handle		handle,
-	struct acpi_device	**device)
+int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 {
-	acpi_status		status = AE_OK;
+	acpi_status status = AE_OK;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_get_device");
 
@@ -71,24 +66,23 @@ acpi_bus_get_device (
 
 	/* TBD: Support fixed-feature devices */
 
-	status = acpi_get_data(handle, acpi_bus_data_handler, (void**) device);
+	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
 	if (ACPI_FAILURE(status) || !*device) {
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "No context for object [%p]\n",
-			handle));
+				  handle));
 		return_VALUE(-ENODEV);
 	}
 
 	return_VALUE(0);
 }
+
 EXPORT_SYMBOL(acpi_bus_get_device);
 
-int
-acpi_bus_get_status (
-	struct acpi_device	*device)
+int acpi_bus_get_status(struct acpi_device *device)
 {
-	acpi_status		status = AE_OK;
-	unsigned long		sta = 0;
-	
+	acpi_status status = AE_OK;
+	unsigned long sta = 0;
+
 	ACPI_FUNCTION_TRACE("acpi_bus_get_status");
 
 	if (!device)
@@ -98,10 +92,11 @@ acpi_bus_get_status (
 	 * Evaluate _STA if present.
 	 */
 	if (device->flags.dynamic_status) {
-		status = acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
+		status =
+		    acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
 		if (ACPI_FAILURE(status))
 			return_VALUE(-ENODEV);
-		STRUCT_TO_INT(device->status) = (int) sta;
+		STRUCT_TO_INT(device->status) = (int)sta;
 	}
 
 	/*
@@ -115,33 +110,30 @@ acpi_bus_get_status (
 
 	if (device->status.functional && !device->status.present) {
 		printk(KERN_WARNING PREFIX "Device [%s] status [%08x]: "
-			"functional but not present; setting present\n",
-			device->pnp.bus_id,
-			(u32) STRUCT_TO_INT(device->status));
+		       "functional but not present; setting present\n",
+		       device->pnp.bus_id, (u32) STRUCT_TO_INT(device->status));
 		device->status.present = 1;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n", 
-		device->pnp.bus_id, (u32) STRUCT_TO_INT(device->status)));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n",
+			  device->pnp.bus_id,
+			  (u32) STRUCT_TO_INT(device->status)));
 
 	return_VALUE(0);
 }
-EXPORT_SYMBOL(acpi_bus_get_status);
 
+EXPORT_SYMBOL(acpi_bus_get_status);
 
 /* --------------------------------------------------------------------------
                                  Power Management
    -------------------------------------------------------------------------- */
 
-int
-acpi_bus_get_power (
-	acpi_handle		handle,
-	int			*state)
+int acpi_bus_get_power(acpi_handle handle, int *state)
 {
-	int			result = 0;
-	acpi_status             status = 0;
-	struct acpi_device	*device = NULL;
-	unsigned long		psc = 0;
+	int result = 0;
+	acpi_status status = 0;
+	struct acpi_device *device = NULL;
+	unsigned long psc = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_get_power");
 
@@ -157,20 +149,18 @@ acpi_bus_get_power (
 			*state = device->parent->power.state;
 		else
 			*state = ACPI_STATE_D0;
-	}
-	else {
+	} else {
 		/*
 		 * Get the device's power state either directly (via _PSC) or 
 		 * indirectly (via power resources).
 		 */
 		if (device->power.flags.explicit_get) {
-			status = acpi_evaluate_integer(device->handle, "_PSC", 
-				NULL, &psc);
+			status = acpi_evaluate_integer(device->handle, "_PSC",
+						       NULL, &psc);
 			if (ACPI_FAILURE(status))
 				return_VALUE(-ENODEV);
-			device->power.state = (int) psc;
-		}
-		else if (device->power.flags.power_resources) {
+			device->power.state = (int)psc;
+		} else if (device->power.flags.power_resources) {
 			result = acpi_power_get_inferred_state(device);
 			if (result)
 				return_VALUE(result);
@@ -180,22 +170,19 @@ acpi_bus_get_power (
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
-		device->pnp.bus_id, device->power.state));
+			  device->pnp.bus_id, device->power.state));
 
 	return_VALUE(0);
 }
-EXPORT_SYMBOL(acpi_bus_get_power);
 
+EXPORT_SYMBOL(acpi_bus_get_power);
 
-int
-acpi_bus_set_power (
-	acpi_handle		handle,
-	int			state)
+int acpi_bus_set_power(acpi_handle handle, int state)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
-	char			object_name[5] = {'_','P','S','0'+state,'\0'};
+	int result = 0;
+	acpi_status status = AE_OK;
+	struct acpi_device *device = NULL;
+	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
 
 	ACPI_FUNCTION_TRACE("acpi_bus_set_power");
 
@@ -209,7 +196,8 @@ acpi_bus_set_power (
 	/* Make sure this is a valid target state */
 
 	if (!device->flags.power_manageable) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device is not power manageable\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				  "Device is not power manageable\n"));
 		return_VALUE(-ENODEV);
 	}
 	/*
@@ -219,15 +207,18 @@ acpi_bus_set_power (
 	if (device->power.state == ACPI_STATE_UNKNOWN)
 		acpi_bus_get_power(device->handle, &device->power.state);
 	if (state == device->power.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n", state));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
+				  state));
 		return_VALUE(0);
 	}
 	if (!device->power.states[state].flags.valid) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n", state));
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n",
+				  state));
 		return_VALUE(-ENODEV);
 	}
 	if (device->parent && (state < device->parent->power.state)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Cannot set device to a higher-powered state than parent\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				  "Cannot set device to a higher-powered state than parent\n"));
 		return_VALUE(-ENODEV);
 	}
 
@@ -245,18 +236,17 @@ acpi_bus_set_power (
 				goto end;
 		}
 		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle, 
-				object_name, NULL, NULL);
+			status = acpi_evaluate_object(device->handle,
+						      object_name, NULL, NULL);
 			if (ACPI_FAILURE(status)) {
 				result = -ENODEV;
 				goto end;
 			}
 		}
-	}
-	else {
+	} else {
 		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle, 
-				object_name, NULL, NULL);
+			status = acpi_evaluate_object(device->handle,
+						      object_name, NULL, NULL);
 			if (ACPI_FAILURE(status)) {
 				result = -ENODEV;
 				goto end;
@@ -269,19 +259,20 @@ acpi_bus_set_power (
 		}
 	}
 
-end:
+      end:
 	if (result)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error transitioning device [%s] to D%d\n",
-			device->pnp.bus_id, state));
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				  "Error transitioning device [%s] to D%d\n",
+				  device->pnp.bus_id, state));
 	else
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] transitioned to D%d\n",
-			device->pnp.bus_id, state));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Device [%s] transitioned to D%d\n",
+				  device->pnp.bus_id, state));
 
 	return_VALUE(result);
 }
-EXPORT_SYMBOL(acpi_bus_set_power);
-
 
+EXPORT_SYMBOL(acpi_bus_set_power);
 
 /* --------------------------------------------------------------------------
                                 Event Management
@@ -292,16 +283,12 @@ static DEFINE_SPINLOCK(acpi_bus_event_lock);
 LIST_HEAD(acpi_bus_event_list);
 DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
 
-extern int			event_is_open;
+extern int event_is_open;
 
-int
-acpi_bus_generate_event (
-	struct acpi_device	*device,
-	u8			type,
-	int			data)
+int acpi_bus_generate_event(struct acpi_device *device, u8 type, int data)
 {
-	struct acpi_bus_event	*event = NULL;
-	unsigned long		flags = 0;
+	struct acpi_bus_event *event = NULL;
+	unsigned long flags = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_generate_event");
 
@@ -329,14 +316,13 @@ acpi_bus_generate_event (
 
 	return_VALUE(0);
 }
+
 EXPORT_SYMBOL(acpi_bus_generate_event);
 
-int
-acpi_bus_receive_event (
-	struct acpi_bus_event	*event)
+int acpi_bus_receive_event(struct acpi_bus_event *event)
 {
-	unsigned long		flags = 0;
-	struct acpi_bus_event	*entry = NULL;
+	unsigned long flags = 0;
+	struct acpi_bus_event *entry = NULL;
 
 	DECLARE_WAITQUEUE(wait, current);
 
@@ -361,7 +347,8 @@ acpi_bus_receive_event (
 	}
 
 	spin_lock_irqsave(&acpi_bus_event_lock, flags);
-	entry = list_entry(acpi_bus_event_list.next, struct acpi_bus_event, node);
+	entry =
+	    list_entry(acpi_bus_event_list.next, struct acpi_bus_event, node);
 	if (entry)
 		list_del(&entry->node);
 	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
@@ -375,19 +362,17 @@ acpi_bus_receive_event (
 
 	return_VALUE(0);
 }
-EXPORT_SYMBOL(acpi_bus_receive_event);
 
+EXPORT_SYMBOL(acpi_bus_receive_event);
 
 /* --------------------------------------------------------------------------
                              Notification Handling
    -------------------------------------------------------------------------- */
 
 static int
-acpi_bus_check_device (
-	struct acpi_device	*device,
-	int			*status_changed)
+acpi_bus_check_device(struct acpi_device *device, int *status_changed)
 {
-	acpi_status             status = 0;
+	acpi_status status = 0;
 	struct acpi_device_status old_status;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_check_device");
@@ -422,15 +407,14 @@ acpi_bus_check_device (
 
 	if (status_changed)
 		*status_changed = 1;
-	
+
 	/*
 	 * Device Insertion/Removal
 	 */
 	if ((device->status.present) && !(old_status.present)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device insertion detected\n"));
 		/* TBD: Handle device insertion */
-	}
-	else if (!(device->status.present) && (old_status.present)) {
+	} else if (!(device->status.present) && (old_status.present)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device removal detected\n"));
 		/* TBD: Handle device removal */
 	}
@@ -438,13 +422,10 @@ acpi_bus_check_device (
 	return_VALUE(0);
 }
 
-
-static int
-acpi_bus_check_scope (
-	struct acpi_device	*device)
+static int acpi_bus_check_scope(struct acpi_device *device)
 {
-	int			result = 0;
-	int			status_changed = 0;
+	int result = 0;
+	int status_changed = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_check_scope");
 
@@ -467,20 +448,15 @@ acpi_bus_check_scope (
 	return_VALUE(0);
 }
 
-
 /**
  * acpi_bus_notify
  * ---------------
  * Callback for all 'system-level' device notifications (values 0x00-0x7F).
  */
-static void 
-acpi_bus_notify (
-	acpi_handle             handle,
-	u32                     type,
-	void                    *data)
+static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
-	int			result = 0;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_notify");
 
@@ -490,64 +466,73 @@ acpi_bus_notify (
 	switch (type) {
 
 	case ACPI_NOTIFY_BUS_CHECK:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS CHECK notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received BUS CHECK notification for device [%s]\n",
+				  device->pnp.bus_id));
 		result = acpi_bus_check_scope(device);
 		/* 
 		 * TBD: We'll need to outsource certain events to non-ACPI
-		 *	drivers via the device manager (device.c).
+		 *      drivers via the device manager (device.c).
 		 */
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received DEVICE CHECK notification for device [%s]\n",
+				  device->pnp.bus_id));
 		result = acpi_bus_check_device(device, NULL);
 		/* 
 		 * TBD: We'll need to outsource certain events to non-ACPI
-		 *	drivers via the device manager (device.c).
+		 *      drivers via the device manager (device.c).
 		 */
 		break;
 
 	case ACPI_NOTIFY_DEVICE_WAKE:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE WAKE notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received DEVICE WAKE notification for device [%s]\n",
+				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_EJECT_REQUEST:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received EJECT REQUEST notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received EJECT REQUEST notification for device [%s]\n",
+				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK LIGHT notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received DEVICE CHECK LIGHT notification for device [%s]\n",
+				  device->pnp.bus_id));
 		/* TBD: Exactly what does 'light' mean? */
 		break;
 
 	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received FREQUENCY MISMATCH notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received FREQUENCY MISMATCH notification for device [%s]\n",
+				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS MODE MISMATCH notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received BUS MODE MISMATCH notification for device [%s]\n",
+				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	case ACPI_NOTIFY_POWER_FAULT:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received POWER FAULT notification for device [%s]\n", 
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received POWER FAULT notification for device [%s]\n",
+				  device->pnp.bus_id));
 		/* TBD */
 		break;
 
 	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received unknown/unsupported notification [%08x]\n", 
-			type));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Received unknown/unsupported notification [%08x]\n",
+				  type));
 		break;
 	}
 
@@ -558,13 +543,12 @@ acpi_bus_notify (
                              Initialization/Cleanup
    -------------------------------------------------------------------------- */
 
-static int __init
-acpi_bus_init_irq (void)
+static int __init acpi_bus_init_irq(void)
 {
-	acpi_status		status = AE_OK;
-	union acpi_object	arg = {ACPI_TYPE_INTEGER};
-	struct acpi_object_list	arg_list = {1, &arg};
-	char			*message = NULL;
+	acpi_status status = AE_OK;
+	union acpi_object arg = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &arg };
+	char *message = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_init_irq");
 
@@ -601,12 +585,10 @@ acpi_bus_init_irq (void)
 	return_VALUE(0);
 }
 
-
-void __init
-acpi_early_init (void)
+void __init acpi_early_init(void)
 {
-	acpi_status		status = AE_OK;
-	struct acpi_buffer	buffer = {sizeof(acpi_fadt), &acpi_fadt};
+	acpi_status status = AE_OK;
+	struct acpi_buffer buffer = { sizeof(acpi_fadt), &acpi_fadt };
 
 	ACPI_FUNCTION_TRACE("acpi_early_init");
 
@@ -619,13 +601,15 @@ acpi_early_init (void)
 
 	status = acpi_initialize_subsystem();
 	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to initialize the ACPI Interpreter\n");
+		printk(KERN_ERR PREFIX
+		       "Unable to initialize the ACPI Interpreter\n");
 		goto error0;
 	}
 
 	status = acpi_load_tables();
 	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to load the System Description Tables\n");
+		printk(KERN_ERR PREFIX
+		       "Unable to load the System Description Tables\n");
 		goto error0;
 	}
 
@@ -637,7 +621,6 @@ acpi_early_init (void)
 		printk(KERN_ERR PREFIX "Unable to get the FADT\n");
 		goto error0;
 	}
-
 #ifdef CONFIG_X86
 	if (!acpi_ioapic) {
 		extern acpi_interrupt_flags acpi_sci_flags;
@@ -647,7 +630,8 @@ acpi_early_init (void)
 			acpi_sci_flags.trigger = 3;
 
 		/* Set PIC-mode SCI trigger type */
-		acpi_pic_sci_set_trigger(acpi_fadt.sci_int, acpi_sci_flags.trigger);
+		acpi_pic_sci_set_trigger(acpi_fadt.sci_int,
+					 acpi_sci_flags.trigger);
 	} else {
 		extern int acpi_sci_override_gsi;
 		/*
@@ -658,7 +642,10 @@ acpi_early_init (void)
 	}
 #endif
 
-	status = acpi_enable_subsystem(~(ACPI_NO_HARDWARE_INIT | ACPI_NO_ACPI_ENABLE));
+	status =
+	    acpi_enable_subsystem(~
+				  (ACPI_NO_HARDWARE_INIT |
+				   ACPI_NO_ACPI_ENABLE));
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to enable ACPI\n");
 		goto error0;
@@ -666,30 +653,32 @@ acpi_early_init (void)
 
 	return_VOID;
 
-error0:
+      error0:
 	disable_acpi();
 	return_VOID;
 }
 
-static int __init
-acpi_bus_init (void)
+static int __init acpi_bus_init(void)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	extern acpi_status	acpi_os_initialize1(void);
+	int result = 0;
+	acpi_status status = AE_OK;
+	extern acpi_status acpi_os_initialize1(void);
 
 	ACPI_FUNCTION_TRACE("acpi_bus_init");
 
 	status = acpi_os_initialize1();
 
-	status = acpi_enable_subsystem(ACPI_NO_HARDWARE_INIT | ACPI_NO_ACPI_ENABLE);
+	status =
+	    acpi_enable_subsystem(ACPI_NO_HARDWARE_INIT | ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to start the ACPI Interpreter\n");
+		printk(KERN_ERR PREFIX
+		       "Unable to start the ACPI Interpreter\n");
 		goto error1;
 	}
 
 	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to initialize ACPI OS objects\n");
+		printk(KERN_ERR PREFIX
+		       "Unable to initialize ACPI OS objects\n");
 		goto error1;
 	}
 #ifdef CONFIG_ACPI_EC
@@ -723,9 +712,12 @@ acpi_bus_init (void)
 	/*
 	 * Register the for all standard device notifications.
 	 */
-	status = acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY, &acpi_bus_notify, NULL);
+	status =
+	    acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY,
+					&acpi_bus_notify, NULL);
 	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to register for device notifications\n");
+		printk(KERN_ERR PREFIX
+		       "Unable to register for device notifications\n");
 		goto error1;
 	}
 
@@ -737,21 +729,20 @@ acpi_bus_init (void)
 	return_VALUE(0);
 
 	/* Mimic structured exception handling */
-error1:
+      error1:
 	acpi_terminate();
 	return_VALUE(-ENODEV);
 }
 
-decl_subsys(acpi,NULL,NULL);
+decl_subsys(acpi, NULL, NULL);
 
-static int __init acpi_init (void)
+static int __init acpi_init(void)
 {
-	int			result = 0;
+	int result = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_init");
 
-	printk(KERN_INFO PREFIX "Subsystem revision %08x\n",
-		ACPI_CA_VERSION);
+	printk(KERN_INFO PREFIX "Subsystem revision %08x\n", ACPI_CA_VERSION);
 
 	if (acpi_disabled) {
 		printk(KERN_INFO PREFIX "Interpreter disabled.\n");
@@ -767,7 +758,8 @@ static int __init acpi_init (void)
 		if (!PM_IS_ACTIVE())
 			pm_active = 1;
 		else {
-			printk(KERN_INFO PREFIX "APM is already active, exiting\n");
+			printk(KERN_INFO PREFIX
+			       "APM is already active, exiting\n");
 			disable_acpi();
 			result = -ENODEV;
 		}

commit b913100d7304ea9596d8d85ab5f3ae04bd2b0ddb
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Sat Mar 19 00:16:18 2005 -0500

    [ACPI] pci_set_power_state() now calls
            platform_pci_set_power_state()
                    and ACPI can answer
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 4edff1738579..d77c2307883c 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -212,6 +212,12 @@ acpi_bus_set_power (
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device is not power manageable\n"));
 		return_VALUE(-ENODEV);
 	}
+	/*
+	 * Get device's current power state if it's unknown
+	 * This means device power state isn't initialized or previous setting failed
+	 */
+	if (device->power.state == ACPI_STATE_UNKNOWN)
+		acpi_bus_get_power(device->handle, &device->power.state);
 	if (state == device->power.state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n", state));
 		return_VALUE(0);
@@ -231,7 +237,7 @@ acpi_bus_set_power (
 	 * On transitions to a high-powered state we first apply power (via
 	 * power resources) then evalute _PSx.  Conversly for transitions to
 	 * a lower-powered state.
-	 */ 
+	 */
 	if (state < device->power.state) {
 		if (device->power.flags.power_resources) {
 			result = acpi_power_transition(device, state);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
new file mode 100644
index 000000000000..4edff1738579
--- /dev/null
+++ b/drivers/acpi/bus.c
@@ -0,0 +1,775 @@
+/*
+ *  acpi_bus.c - ACPI Bus Driver ($Revision: 80 $)
+ *
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/pm.h>
+#include <linux/device.h>
+#include <linux/proc_fs.h>
+#ifdef CONFIG_X86
+#include <asm/mpspec.h>
+#endif
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_BUS_COMPONENT
+ACPI_MODULE_NAME		("acpi_bus")
+
+#ifdef	CONFIG_X86
+extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
+#endif
+
+FADT_DESCRIPTOR			acpi_fadt;
+EXPORT_SYMBOL(acpi_fadt);
+
+struct acpi_device		*acpi_root;
+struct proc_dir_entry		*acpi_root_dir;
+EXPORT_SYMBOL(acpi_root_dir);
+
+#define STRUCT_TO_INT(s)	(*((int*)&s))
+
+/* --------------------------------------------------------------------------
+                                Device Management
+   -------------------------------------------------------------------------- */
+
+int
+acpi_bus_get_device (
+	acpi_handle		handle,
+	struct acpi_device	**device)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_device");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* TBD: Support fixed-feature devices */
+
+	status = acpi_get_data(handle, acpi_bus_data_handler, (void**) device);
+	if (ACPI_FAILURE(status) || !*device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "No context for object [%p]\n",
+			handle));
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_bus_get_device);
+
+int
+acpi_bus_get_status (
+	struct acpi_device	*device)
+{
+	acpi_status		status = AE_OK;
+	unsigned long		sta = 0;
+	
+	ACPI_FUNCTION_TRACE("acpi_bus_get_status");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Evaluate _STA if present.
+	 */
+	if (device->flags.dynamic_status) {
+		status = acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+		STRUCT_TO_INT(device->status) = (int) sta;
+	}
+
+	/*
+	 * Otherwise we assume the status of our parent (unless we don't
+	 * have one, in which case status is implied).
+	 */
+	else if (device->parent)
+		device->status = device->parent->status;
+	else
+		STRUCT_TO_INT(device->status) = 0x0F;
+
+	if (device->status.functional && !device->status.present) {
+		printk(KERN_WARNING PREFIX "Device [%s] status [%08x]: "
+			"functional but not present; setting present\n",
+			device->pnp.bus_id,
+			(u32) STRUCT_TO_INT(device->status));
+		device->status.present = 1;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n", 
+		device->pnp.bus_id, (u32) STRUCT_TO_INT(device->status)));
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_bus_get_status);
+
+
+/* --------------------------------------------------------------------------
+                                 Power Management
+   -------------------------------------------------------------------------- */
+
+int
+acpi_bus_get_power (
+	acpi_handle		handle,
+	int			*state)
+{
+	int			result = 0;
+	acpi_status             status = 0;
+	struct acpi_device	*device = NULL;
+	unsigned long		psc = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_power");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	*state = ACPI_STATE_UNKNOWN;
+
+	if (!device->flags.power_manageable) {
+		/* TBD: Non-recursive algorithm for walking up hierarchy */
+		if (device->parent)
+			*state = device->parent->power.state;
+		else
+			*state = ACPI_STATE_D0;
+	}
+	else {
+		/*
+		 * Get the device's power state either directly (via _PSC) or 
+		 * indirectly (via power resources).
+		 */
+		if (device->power.flags.explicit_get) {
+			status = acpi_evaluate_integer(device->handle, "_PSC", 
+				NULL, &psc);
+			if (ACPI_FAILURE(status))
+				return_VALUE(-ENODEV);
+			device->power.state = (int) psc;
+		}
+		else if (device->power.flags.power_resources) {
+			result = acpi_power_get_inferred_state(device);
+			if (result)
+				return_VALUE(result);
+		}
+
+		*state = device->power.state;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
+		device->pnp.bus_id, device->power.state));
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_bus_get_power);
+
+
+int
+acpi_bus_set_power (
+	acpi_handle		handle,
+	int			state)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	char			object_name[5] = {'_','P','S','0'+state,'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_bus_set_power");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	if ((state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+		return_VALUE(-EINVAL);
+
+	/* Make sure this is a valid target state */
+
+	if (!device->flags.power_manageable) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device is not power manageable\n"));
+		return_VALUE(-ENODEV);
+	}
+	if (state == device->power.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n", state));
+		return_VALUE(0);
+	}
+	if (!device->power.states[state].flags.valid) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n", state));
+		return_VALUE(-ENODEV);
+	}
+	if (device->parent && (state < device->parent->power.state)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Cannot set device to a higher-powered state than parent\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * Transition Power
+	 * ----------------
+	 * On transitions to a high-powered state we first apply power (via
+	 * power resources) then evalute _PSx.  Conversly for transitions to
+	 * a lower-powered state.
+	 */ 
+	if (state < device->power.state) {
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (result)
+				goto end;
+		}
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle, 
+				object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+	}
+	else {
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle, 
+				object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (result)
+				goto end;
+		}
+	}
+
+end:
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error transitioning device [%s] to D%d\n",
+			device->pnp.bus_id, state));
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] transitioned to D%d\n",
+			device->pnp.bus_id, state));
+
+	return_VALUE(result);
+}
+EXPORT_SYMBOL(acpi_bus_set_power);
+
+
+
+/* --------------------------------------------------------------------------
+                                Event Management
+   -------------------------------------------------------------------------- */
+
+static DEFINE_SPINLOCK(acpi_bus_event_lock);
+
+LIST_HEAD(acpi_bus_event_list);
+DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
+
+extern int			event_is_open;
+
+int
+acpi_bus_generate_event (
+	struct acpi_device	*device,
+	u8			type,
+	int			data)
+{
+	struct acpi_bus_event	*event = NULL;
+	unsigned long		flags = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_generate_event");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* drop event on the floor if no one's listening */
+	if (!event_is_open)
+		return_VALUE(0);
+
+	event = kmalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC);
+	if (!event)
+		return_VALUE(-ENOMEM);
+
+	strcpy(event->device_class, device->pnp.device_class);
+	strcpy(event->bus_id, device->pnp.bus_id);
+	event->type = type;
+	event->data = data;
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	list_add_tail(&event->node, &acpi_bus_event_list);
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	wake_up_interruptible(&acpi_bus_event_queue);
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_bus_generate_event);
+
+int
+acpi_bus_receive_event (
+	struct acpi_bus_event	*event)
+{
+	unsigned long		flags = 0;
+	struct acpi_bus_event	*entry = NULL;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	ACPI_FUNCTION_TRACE("acpi_bus_receive_event");
+
+	if (!event)
+		return_VALUE(-EINVAL);
+
+	if (list_empty(&acpi_bus_event_list)) {
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&acpi_bus_event_queue, &wait);
+
+		if (list_empty(&acpi_bus_event_list))
+			schedule();
+
+		remove_wait_queue(&acpi_bus_event_queue, &wait);
+		set_current_state(TASK_RUNNING);
+
+		if (signal_pending(current))
+			return_VALUE(-ERESTARTSYS);
+	}
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	entry = list_entry(acpi_bus_event_list.next, struct acpi_bus_event, node);
+	if (entry)
+		list_del(&entry->node);
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	if (!entry)
+		return_VALUE(-ENODEV);
+
+	memcpy(event, entry, sizeof(struct acpi_bus_event));
+
+	kfree(entry);
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_bus_receive_event);
+
+
+/* --------------------------------------------------------------------------
+                             Notification Handling
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_bus_check_device (
+	struct acpi_device	*device,
+	int			*status_changed)
+{
+	acpi_status             status = 0;
+	struct acpi_device_status old_status;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_check_device");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (status_changed)
+		*status_changed = 0;
+
+	old_status = device->status;
+
+	/*
+	 * Make sure this device's parent is present before we go about
+	 * messing with the device.
+	 */
+	if (device->parent && !device->parent->status.present) {
+		device->status = device->parent->status;
+		if (STRUCT_TO_INT(old_status) != STRUCT_TO_INT(device->status)) {
+			if (status_changed)
+				*status_changed = 1;
+		}
+		return_VALUE(0);
+	}
+
+	status = acpi_bus_get_status(device);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
+		return_VALUE(0);
+
+	if (status_changed)
+		*status_changed = 1;
+	
+	/*
+	 * Device Insertion/Removal
+	 */
+	if ((device->status.present) && !(old_status.present)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device insertion detected\n"));
+		/* TBD: Handle device insertion */
+	}
+	else if (!(device->status.present) && (old_status.present)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device removal detected\n"));
+		/* TBD: Handle device removal */
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_check_scope (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	int			status_changed = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_check_scope");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* Status Change? */
+	result = acpi_bus_check_device(device, &status_changed);
+	if (result)
+		return_VALUE(result);
+
+	if (!status_changed)
+		return_VALUE(0);
+
+	/*
+	 * TBD: Enumerate child devices within this device's scope and
+	 *       run acpi_bus_check_device()'s on them.
+	 */
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_notify
+ * ---------------
+ * Callback for all 'system-level' device notifications (values 0x00-0x7F).
+ */
+static void 
+acpi_bus_notify (
+	acpi_handle             handle,
+	u32                     type,
+	void                    *data)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_notify");
+
+	if (acpi_bus_get_device(handle, &device))
+		return_VOID;
+
+	switch (type) {
+
+	case ACPI_NOTIFY_BUS_CHECK:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS CHECK notification for device [%s]\n", 
+			device->pnp.bus_id));
+		result = acpi_bus_check_scope(device);
+		/* 
+		 * TBD: We'll need to outsource certain events to non-ACPI
+		 *	drivers via the device manager (device.c).
+		 */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK notification for device [%s]\n", 
+			device->pnp.bus_id));
+		result = acpi_bus_check_device(device, NULL);
+		/* 
+		 * TBD: We'll need to outsource certain events to non-ACPI
+		 *	drivers via the device manager (device.c).
+		 */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_WAKE:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE WAKE notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received EJECT REQUEST notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK LIGHT notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD: Exactly what does 'light' mean? */
+		break;
+
+	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received FREQUENCY MISMATCH notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS MODE MISMATCH notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_POWER_FAULT:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received POWER FAULT notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received unknown/unsupported notification [%08x]\n", 
+			type));
+		break;
+	}
+
+	return_VOID;
+}
+
+/* --------------------------------------------------------------------------
+                             Initialization/Cleanup
+   -------------------------------------------------------------------------- */
+
+static int __init
+acpi_bus_init_irq (void)
+{
+	acpi_status		status = AE_OK;
+	union acpi_object	arg = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg};
+	char			*message = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_init_irq");
+
+	/* 
+	 * Let the system know what interrupt model we are using by
+	 * evaluating the \_PIC object, if exists.
+	 */
+
+	switch (acpi_irq_model) {
+	case ACPI_IRQ_MODEL_PIC:
+		message = "PIC";
+		break;
+	case ACPI_IRQ_MODEL_IOAPIC:
+		message = "IOAPIC";
+		break;
+	case ACPI_IRQ_MODEL_IOSAPIC:
+		message = "IOSAPIC";
+		break;
+	default:
+		printk(KERN_WARNING PREFIX "Unknown interrupt routing model\n");
+		return_VALUE(-ENODEV);
+	}
+
+	printk(KERN_INFO PREFIX "Using %s for interrupt routing\n", message);
+
+	arg.integer.value = acpi_irq_model;
+
+	status = acpi_evaluate_object(NULL, "\\_PIC", &arg_list, NULL);
+	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PIC\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+void __init
+acpi_early_init (void)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_buffer	buffer = {sizeof(acpi_fadt), &acpi_fadt};
+
+	ACPI_FUNCTION_TRACE("acpi_early_init");
+
+	if (acpi_disabled)
+		return_VOID;
+
+	/* enable workarounds, unless strict ACPI spec. compliance */
+	if (!acpi_strict)
+		acpi_gbl_enable_interpreter_slack = TRUE;
+
+	status = acpi_initialize_subsystem();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to initialize the ACPI Interpreter\n");
+		goto error0;
+	}
+
+	status = acpi_load_tables();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to load the System Description Tables\n");
+		goto error0;
+	}
+
+	/*
+	 * Get a separate copy of the FADT for use by other drivers.
+	 */
+	status = acpi_get_table(ACPI_TABLE_FADT, 1, &buffer);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to get the FADT\n");
+		goto error0;
+	}
+
+#ifdef CONFIG_X86
+	if (!acpi_ioapic) {
+		extern acpi_interrupt_flags acpi_sci_flags;
+
+		/* compatible (0) means level (3) */
+		if (acpi_sci_flags.trigger == 0)
+			acpi_sci_flags.trigger = 3;
+
+		/* Set PIC-mode SCI trigger type */
+		acpi_pic_sci_set_trigger(acpi_fadt.sci_int, acpi_sci_flags.trigger);
+	} else {
+		extern int acpi_sci_override_gsi;
+		/*
+		 * now that acpi_fadt is initialized,
+		 * update it with result from INT_SRC_OVR parsing
+		 */
+		acpi_fadt.sci_int = acpi_sci_override_gsi;
+	}
+#endif
+
+	status = acpi_enable_subsystem(~(ACPI_NO_HARDWARE_INIT | ACPI_NO_ACPI_ENABLE));
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to enable ACPI\n");
+		goto error0;
+	}
+
+	return_VOID;
+
+error0:
+	disable_acpi();
+	return_VOID;
+}
+
+static int __init
+acpi_bus_init (void)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	extern acpi_status	acpi_os_initialize1(void);
+
+	ACPI_FUNCTION_TRACE("acpi_bus_init");
+
+	status = acpi_os_initialize1();
+
+	status = acpi_enable_subsystem(ACPI_NO_HARDWARE_INIT | ACPI_NO_ACPI_ENABLE);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to start the ACPI Interpreter\n");
+		goto error1;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to initialize ACPI OS objects\n");
+		goto error1;
+	}
+#ifdef CONFIG_ACPI_EC
+	/*
+	 * ACPI 2.0 requires the EC driver to be loaded and work before
+	 * the EC device is found in the namespace (i.e. before acpi_initialize_objects()
+	 * is called).
+	 *
+	 * This is accomplished by looking for the ECDT table, and getting 
+	 * the EC parameters out of that.
+	 */
+	status = acpi_ec_ecdt_probe();
+	/* Ignore result. Not having an ECDT is not fatal. */
+#endif
+
+	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to initialize ACPI objects\n");
+		goto error1;
+	}
+
+	printk(KERN_INFO PREFIX "Interpreter enabled\n");
+
+	/*
+	 * Get the system interrupt model and evaluate \_PIC.
+	 */
+	result = acpi_bus_init_irq();
+	if (result)
+		goto error1;
+
+	/*
+	 * Register the for all standard device notifications.
+	 */
+	status = acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY, &acpi_bus_notify, NULL);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to register for device notifications\n");
+		goto error1;
+	}
+
+	/*
+	 * Create the top ACPI proc directory
+	 */
+	acpi_root_dir = proc_mkdir(ACPI_BUS_FILE_ROOT, NULL);
+
+	return_VALUE(0);
+
+	/* Mimic structured exception handling */
+error1:
+	acpi_terminate();
+	return_VALUE(-ENODEV);
+}
+
+decl_subsys(acpi,NULL,NULL);
+
+static int __init acpi_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_init");
+
+	printk(KERN_INFO PREFIX "Subsystem revision %08x\n",
+		ACPI_CA_VERSION);
+
+	if (acpi_disabled) {
+		printk(KERN_INFO PREFIX "Interpreter disabled.\n");
+		return_VALUE(-ENODEV);
+	}
+
+	firmware_register(&acpi_subsys);
+
+	result = acpi_bus_init();
+
+	if (!result) {
+#ifdef CONFIG_PM
+		if (!PM_IS_ACTIVE())
+			pm_active = 1;
+		else {
+			printk(KERN_INFO PREFIX "APM is already active, exiting\n");
+			disable_acpi();
+			result = -ENODEV;
+		}
+#endif
+	} else
+		disable_acpi();
+
+	return_VALUE(result);
+}
+
+subsys_initcall(acpi_init);
