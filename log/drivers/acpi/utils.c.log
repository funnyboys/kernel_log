commit 132565d8ec096a5a043f96092cfa4821d970d268
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu May 7 12:49:16 2020 +0200

    ACPI: utils: Add acpi_evaluate_reg() helper
    
    With a recent fix to the pinctrl-cherryview driver we now have
    2 drivers open-coding the parameter building / passing for calling
    _REG on an ACPI handle.
    
    Add a helper for this, so that these 2 drivers can be converted to this
    helper.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 804ac0df58ec..838b719ec7ce 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -605,6 +605,31 @@ acpi_status acpi_evaluate_lck(acpi_handle handle, int lock)
 	return status;
 }
 
+/**
+ * acpi_evaluate_reg: Evaluate _REG method to register OpRegion presence
+ * @handle: ACPI device handle
+ * @space_id: ACPI address space id to register OpRegion presence for
+ * @function: Parameter to pass to _REG one of ACPI_REG_CONNECT or
+ *            ACPI_REG_DISCONNECT
+ *
+ * Evaluate device's _REG method to register OpRegion presence.
+ */
+acpi_status acpi_evaluate_reg(acpi_handle handle, u8 space_id, u32 function)
+{
+	struct acpi_object_list arg_list;
+	union acpi_object params[2];
+
+	params[0].type = ACPI_TYPE_INTEGER;
+	params[0].integer.value = space_id;
+	params[1].type = ACPI_TYPE_INTEGER;
+	params[1].integer.value = function;
+	arg_list.count = 2;
+	arg_list.pointer = params;
+
+	return acpi_evaluate_object(handle, "_REG", &arg_list, NULL);
+}
+EXPORT_SYMBOL(acpi_evaluate_reg);
+
 /**
  * acpi_evaluate_dsm - evaluate device's _DSM method
  * @handle: ACPI device handle

commit 35009c807488ccd5a01cbf102033695e52794b68
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Oct 1 17:27:22 2019 +0300

    ACPI / utils: Introduce acpi_dev_hid_uid_match() helper
    
    There are users outside of ACPI realm which reimplementing the comparator
    function to check if the given device matches to given HID and UID.
    
    For better utilization, introduce a helper for everyone to use.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index dbd1c4cfd7d1..804ac0df58ec 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -701,6 +701,31 @@ bool acpi_check_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 funcs)
 }
 EXPORT_SYMBOL(acpi_check_dsm);
 
+/**
+ * acpi_dev_hid_uid_match - Match device by supplied HID and UID
+ * @adev: ACPI device to match.
+ * @hid2: Hardware ID of the device.
+ * @uid2: Unique ID of the device, pass NULL to not check _UID.
+ *
+ * Matches HID and UID in @adev with given @hid2 and @uid2.
+ * Returns true if matches.
+ */
+bool acpi_dev_hid_uid_match(struct acpi_device *adev,
+			    const char *hid2, const char *uid2)
+{
+	const char *hid1 = acpi_device_hid(adev);
+	const char *uid1 = acpi_device_uid(adev);
+
+	if (strcmp(hid1, hid2))
+		return false;
+
+	if (!uid2)
+		return true;
+
+	return uid1 && !strcmp(uid1, uid2);
+}
+EXPORT_SYMBOL(acpi_dev_hid_uid_match);
+
 /**
  * acpi_dev_found - Detect presence of a given ACPI device in the namespace.
  * @hid: Hardware ID of the device.

commit 8373f8c6a447d53b25d505905be06bdafcbd6f7b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Oct 1 17:27:20 2019 +0300

    ACPI / utils: Describe function parameters in kernel-doc
    
    Kernel documentation script complains that some of the function parameters
    are not described:
    
    drivers/acpi/utils.c:462: warning: Function parameter or member 'handle' not described in 'acpi_handle_path'
    drivers/acpi/utils.c:484: warning: Function parameter or member 'level' not described in 'acpi_handle_printk'
    drivers/acpi/utils.c:484: warning: Function parameter or member 'handle' not described in 'acpi_handle_printk'
    drivers/acpi/utils.c:484: warning: Function parameter or member 'fmt' not described in 'acpi_handle_printk'
    drivers/acpi/utils.c:513: warning: Function parameter or member 'descriptor' not described in '__acpi_handle_debug'
    drivers/acpi/utils.c:513: warning: Function parameter or member 'handle' not described in '__acpi_handle_debug'
    drivers/acpi/utils.c:513: warning: Function parameter or member 'fmt' not described in '__acpi_handle_debug'
    
    Describe function parameters where it's appropriate.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index e3974a8f8fd4..dbd1c4cfd7d1 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -455,6 +455,7 @@ EXPORT_SYMBOL(acpi_evaluate_ost);
 
 /**
  * acpi_handle_path: Return the object path of handle
+ * @handle: ACPI device handle
  *
  * Caller must free the returned buffer
  */
@@ -473,6 +474,9 @@ static char *acpi_handle_path(acpi_handle handle)
 
 /**
  * acpi_handle_printk: Print message with ACPI prefix and object path
+ * @level: log level
+ * @handle: ACPI device handle
+ * @fmt: format string
  *
  * This function is called through acpi_handle_<level> macros and prints
  * a message with ACPI prefix and object path.  This function acquires
@@ -501,6 +505,9 @@ EXPORT_SYMBOL(acpi_handle_printk);
 #if defined(CONFIG_DYNAMIC_DEBUG)
 /**
  * __acpi_handle_debug: pr_debug with ACPI prefix and object path
+ * @descriptor: Dynamic Debug descriptor
+ * @handle: ACPI device handle
+ * @fmt: format string
  *
  * This function is called through acpi_handle_debug macro and debug
  * prints a message with ACPI prefix and object path. This function

commit 418e3ea157efb0eb2c6dd412a8d5f052477c7f5a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:53:59 2019 +0100

    bus_find_device: Unify the match callback with class_find_device
    
    There is an arbitrary difference between the prototypes of
    bus_find_device() and class_find_device() preventing their callers
    from passing the same pair of data and match() arguments to both of
    them, which is the const qualifier used in the prototype of
    class_find_device().  If that qualifier is also used in the
    bus_find_device() prototype, it will be possible to pass the same
    match() callback function to both bus_find_device() and
    class_find_device(), which will allow some optimizations to be made in
    order to avoid code duplication going forward.  Also with that, constify
    the "data" parameter as it is passed as a const to the match function.
    
    For this reason, change the prototype of bus_find_device() to match
    the prototype of class_find_device() and adjust its callers to use the
    const qualifier in accordance with the new prototype of it.
    
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michael Jamet <michael.jamet@intel.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Sebastian Ott <sebott@linux.ibm.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Yehezkel Bernat <YehezkelShB@gmail.com>
    Cc: rafael@kernel.org
    Acked-by: Corey Minyard <minyard@acm.org>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for the I2C parts
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 1391b63cadfd..e3974a8f8fd4 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -730,10 +730,10 @@ struct acpi_dev_match_info {
 	s64 hrv;
 };
 
-static int acpi_dev_match_cb(struct device *dev, void *data)
+static int acpi_dev_match_cb(struct device *dev, const void *data)
 {
 	struct acpi_device *adev = to_acpi_device(dev);
-	struct acpi_dev_match_info *match = data;
+	const struct acpi_dev_match_info *match = data;
 	unsigned long long hrv;
 	acpi_status status;
 

commit e6374f6b2e9c9f9a7cf5418157ad7f30f3abd70e
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:53:58 2019 +0100

    acpi: utils: Cleanup acpi_dev_match_cb
    
    The prototype of bus_find_device() will be unified with that of
    class_find_device() subsequently, but for this purpose the callback
    functions passed to it need to take (const void *) as the second
    argument.  Consequently, they cannot modify the memory pointed to by
    that argument which currently is not the case for acpi_dev_match_cb().
    However, acpi_dev_match_cb() really need not modify the "match" object
    passed to it, because acpi_dev_get_first_match_dev() which uses it via
    bus_find_device() can easily convert the result of bus_find_device()
    into the pointer to return.
    
    For this reason, update acpi_dev_match_cb() to avoid the redundant
    memory updates.
    
    Cc: Len Brown <lenb@kernel.org>
    Cc: linux-acpi@vger.kernel.org
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 7def63ab00c0..1391b63cadfd 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -725,8 +725,6 @@ bool acpi_dev_found(const char *hid)
 EXPORT_SYMBOL(acpi_dev_found);
 
 struct acpi_dev_match_info {
-	const char *dev_name;
-	struct acpi_device *adev;
 	struct acpi_device_id hid[2];
 	const char *uid;
 	s64 hrv;
@@ -746,9 +744,6 @@ static int acpi_dev_match_cb(struct device *dev, void *data)
 	    strcmp(adev->pnp.unique_id, match->uid)))
 		return 0;
 
-	match->dev_name = acpi_dev_name(adev);
-	match->adev = adev;
-
 	if (match->hrv == -1)
 		return 1;
 
@@ -818,7 +813,7 @@ acpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv)
 	match.hrv = hrv;
 
 	dev = bus_find_device(&acpi_bus_type, NULL, &match, acpi_dev_match_cb);
-	return dev ? match.adev : NULL;
+	return dev ? to_acpi_device(dev) : NULL;
 }
 EXPORT_SYMBOL(acpi_dev_get_first_match_dev);
 

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 89363b245489..7def63ab00c0 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  acpi_utils.c - ACPI Utility Functions ($Revision: 10 $)
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
 #include <linux/kernel.h>

commit 257f9053c0204ea47491aa236004fd1226f75fa8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 28 19:17:29 2019 +0200

    ACPI / utils: Remove deprecated function since no user left
    
    There is no more user of acpi_dev_get_first_match_name(),
    which is deprecated and has no user left, so, remove it for good.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 5a2bae2b6c3a..89363b245489 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -835,22 +835,6 @@ acpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv)
 }
 EXPORT_SYMBOL(acpi_dev_get_first_match_dev);
 
-/* DEPRECATED, use acpi_dev_get_first_match_dev() instead */
-const char *
-acpi_dev_get_first_match_name(const char *hid, const char *uid, s64 hrv)
-{
-	struct acpi_dev_match_info match = {};
-	struct device *dev;
-
-	strlcpy(match.hid[0].id, hid, sizeof(match.hid[0].id));
-	match.uid = uid;
-	match.hrv = hrv;
-
-	dev = bus_find_device(&acpi_bus_type, NULL, &match, acpi_dev_match_cb);
-	return dev ? match.dev_name : NULL;
-}
-EXPORT_SYMBOL(acpi_dev_get_first_match_name);
-
 /*
  * acpi_backlight= handling, this is done here rather then in video_detect.c
  * because __setup cannot be used in modules.

commit 817b4d64da036f5559297a2fdb82b8b14f4ffdcd
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 18 23:00:54 2019 +0300

    ACPI / utils: Introduce acpi_dev_get_first_match_dev() helper
    
    The acpi_dev_get_first_match_name() is missing put_device() call
    and thus keeping reference counting unbalanced.
    
    In order to fix the issue introduce a new helper to convert existing users
    one-by-one to a better API.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index c4b06cc075f9..5a2bae2b6c3a 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -739,6 +739,7 @@ EXPORT_SYMBOL(acpi_dev_found);
 
 struct acpi_dev_match_info {
 	const char *dev_name;
+	struct acpi_device *adev;
 	struct acpi_device_id hid[2];
 	const char *uid;
 	s64 hrv;
@@ -759,6 +760,7 @@ static int acpi_dev_match_cb(struct device *dev, void *data)
 		return 0;
 
 	match->dev_name = acpi_dev_name(adev);
+	match->adev = adev;
 
 	if (match->hrv == -1)
 		return 1;
@@ -806,16 +808,34 @@ bool acpi_dev_present(const char *hid, const char *uid, s64 hrv)
 EXPORT_SYMBOL(acpi_dev_present);
 
 /**
- * acpi_dev_get_first_match_name - Return name of first match of ACPI device
+ * acpi_dev_get_first_match_dev - Return the first match of ACPI device
  * @hid: Hardware ID of the device.
  * @uid: Unique ID of the device, pass NULL to not check _UID
  * @hrv: Hardware Revision of the device, pass -1 to not check _HRV
  *
- * Return device name if a matching device was present
+ * Return the first match of ACPI device if a matching device was present
  * at the moment of invocation, or NULL otherwise.
  *
+ * The caller is responsible to call put_device() on the returned device.
+ *
  * See additional information in acpi_dev_present() as well.
  */
+struct acpi_device *
+acpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv)
+{
+	struct acpi_dev_match_info match = {};
+	struct device *dev;
+
+	strlcpy(match.hid[0].id, hid, sizeof(match.hid[0].id));
+	match.uid = uid;
+	match.hrv = hrv;
+
+	dev = bus_find_device(&acpi_bus_type, NULL, &match, acpi_dev_match_cb);
+	return dev ? match.adev : NULL;
+}
+EXPORT_SYMBOL(acpi_dev_get_first_match_dev);
+
+/* DEPRECATED, use acpi_dev_get_first_match_dev() instead */
 const char *
 acpi_dev_get_first_match_name(const char *hid, const char *uid, s64 hrv)
 {

commit 54e3aca84e571559915998aa6cc05e5ac37c043b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 18 21:47:09 2019 +0300

    ACPI / utils: Drop reference in test for device presence
    
    When commit 8661423eea1a ("ACPI / utils: Add new acpi_dev_present
    helper") introduced acpi_dev_present(), it missed the fact that
    bus_find_device() took a reference on the device found by it and
    the callers of acpi_dev_present() don't drop that reference.
    
    Drop the reference on the device in acpi_dev_present().
    
    Fixes: 8661423eea1a ("ACPI / utils: Add new acpi_dev_present helper")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 78db97687f26..c4b06cc075f9 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -800,6 +800,7 @@ bool acpi_dev_present(const char *hid, const char *uid, s64 hrv)
 	match.hrv = hrv;
 
 	dev = bus_find_device(&acpi_bus_type, NULL, &match, acpi_dev_match_cb);
+	put_device(dev);
 	return !!dev;
 }
 EXPORT_SYMBOL(acpi_dev_present);

commit 67dcf8a3e06582cb6b02952335b5612beb97889f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Jan 5 18:09:33 2018 +0200

    ACPI: utils: Introduce acpi_dev_get_first_match_name()
    
    Sometimes the user wants to have device name of the match rather than
    just checking if device present or not. To make life easier for such
    users introduce acpi_dev_get_first_match_name() helper based on code
    for acpi_dev_present().
    
    For example, GPIO driver for Intel Merrifield needs to know the device
    name of pin control to be able to apply GPIO mapping table to the proper
    device.
    
    To be more consistent with the purpose rename
    
      struct acpi_dev_present_info  -> struct acpi_dev_match_info
      acpi_dev_present_cb()         -> acpi_dev_match_cb()
    
    in the utils.c file.
    
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 9d49a1acebe3..78db97687f26 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -737,16 +737,17 @@ bool acpi_dev_found(const char *hid)
 }
 EXPORT_SYMBOL(acpi_dev_found);
 
-struct acpi_dev_present_info {
+struct acpi_dev_match_info {
+	const char *dev_name;
 	struct acpi_device_id hid[2];
 	const char *uid;
 	s64 hrv;
 };
 
-static int acpi_dev_present_cb(struct device *dev, void *data)
+static int acpi_dev_match_cb(struct device *dev, void *data)
 {
 	struct acpi_device *adev = to_acpi_device(dev);
-	struct acpi_dev_present_info *match = data;
+	struct acpi_dev_match_info *match = data;
 	unsigned long long hrv;
 	acpi_status status;
 
@@ -757,6 +758,8 @@ static int acpi_dev_present_cb(struct device *dev, void *data)
 	    strcmp(adev->pnp.unique_id, match->uid)))
 		return 0;
 
+	match->dev_name = acpi_dev_name(adev);
+
 	if (match->hrv == -1)
 		return 1;
 
@@ -789,20 +792,44 @@ static int acpi_dev_present_cb(struct device *dev, void *data)
  */
 bool acpi_dev_present(const char *hid, const char *uid, s64 hrv)
 {
-	struct acpi_dev_present_info match = {};
+	struct acpi_dev_match_info match = {};
 	struct device *dev;
 
 	strlcpy(match.hid[0].id, hid, sizeof(match.hid[0].id));
 	match.uid = uid;
 	match.hrv = hrv;
 
-	dev = bus_find_device(&acpi_bus_type, NULL, &match,
-			      acpi_dev_present_cb);
-
+	dev = bus_find_device(&acpi_bus_type, NULL, &match, acpi_dev_match_cb);
 	return !!dev;
 }
 EXPORT_SYMBOL(acpi_dev_present);
 
+/**
+ * acpi_dev_get_first_match_name - Return name of first match of ACPI device
+ * @hid: Hardware ID of the device.
+ * @uid: Unique ID of the device, pass NULL to not check _UID
+ * @hrv: Hardware Revision of the device, pass -1 to not check _HRV
+ *
+ * Return device name if a matching device was present
+ * at the moment of invocation, or NULL otherwise.
+ *
+ * See additional information in acpi_dev_present() as well.
+ */
+const char *
+acpi_dev_get_first_match_name(const char *hid, const char *uid, s64 hrv)
+{
+	struct acpi_dev_match_info match = {};
+	struct device *dev;
+
+	strlcpy(match.hid[0].id, hid, sizeof(match.hid[0].id));
+	match.uid = uid;
+	match.hrv = hrv;
+
+	dev = bus_find_device(&acpi_bus_type, NULL, &match, acpi_dev_match_cb);
+	return dev ? match.dev_name : NULL;
+}
+EXPORT_SYMBOL(acpi_dev_get_first_match_name);
+
 /*
  * acpi_backlight= handling, this is done here rather then in video_detect.c
  * because __setup cannot be used in modules.

commit 09e15086936e01d7588020be37ea724116bcefec
Author: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date:   Thu Nov 9 14:22:39 2017 +0800

    ACPI / utils: Fix memory leak in acpi_evaluate_reference() error path
    
    When package.count is larger than ACPI_MAX_HANDLES, buffer.pointer is
    not freed before the function returns AE_NO_MEMORY. Fix this possible
    memory leak by kfree'ing it.
    
    Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 0a9e5979aaa9..9d49a1acebe3 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -355,6 +355,7 @@ acpi_evaluate_reference(acpi_handle handle,
 	}
 
 	if (package->package.count > ACPI_MAX_HANDLES) {
+		kfree(package);
 		return AE_NO_MEMORY;
 	}
 	list->count = package->package.count;

commit 5aa5911a0ed9355ebb02f83de4be9ba435a45a2c
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Wed Aug 23 16:54:43 2017 -0600

    ACPI / blacklist: add acpi_match_platform_list()
    
    ACPI OEM ID / OEM Table ID / Revision can be used to identify
    a platform based on ACPI firmware info.  acpi_blacklisted(),
    intel_pstate_platform_pwr_mgmt_exists(), and some other funcs,
    have been using similar check to detect a list of platforms
    that require special handlings.
    
    Move the platform check in acpi_blacklisted() to a new common
    utility function, acpi_match_platform_list(), so that other
    drivers do not have to implement their own version.
    
    There is no change in functionality.
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index b9d956c916f5..0a9e5979aaa9 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -816,3 +816,39 @@ static int __init acpi_backlight(char *str)
 	return 1;
 }
 __setup("acpi_backlight=", acpi_backlight);
+
+/**
+ * acpi_match_platform_list - Check if the system matches with a given list
+ * @plat: pointer to acpi_platform_list table terminated by a NULL entry
+ *
+ * Return the matched index if the system is found in the platform list.
+ * Otherwise, return a negative error code.
+ */
+int acpi_match_platform_list(const struct acpi_platform_list *plat)
+{
+	struct acpi_table_header hdr;
+	int idx = 0;
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	for (; plat->oem_id[0]; plat++, idx++) {
+		if (ACPI_FAILURE(acpi_get_table_header(plat->table, 0, &hdr)))
+			continue;
+
+		if (strncmp(plat->oem_id, hdr.oem_id, ACPI_OEM_ID_SIZE))
+			continue;
+
+		if (strncmp(plat->oem_table_id, hdr.oem_table_id, ACPI_OEM_TABLE_ID_SIZE))
+			continue;
+
+		if ((plat->pred == all_versions) ||
+		    (plat->pred == less_than_or_equal && hdr.oem_revision <= plat->oem_revision) ||
+		    (plat->pred == greater_than_or_equal && hdr.oem_revision >= plat->oem_revision) ||
+		    (plat->pred == equal && hdr.oem_revision == plat->oem_revision))
+			return idx;
+	}
+
+	return -ENODEV;
+}
+EXPORT_SYMBOL(acpi_match_platform_list);

commit 94116f8126de9762751fd92731581b73b56292e5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jun 5 19:40:46 2017 +0300

    ACPI: Switch to use generic guid_t in acpi_evaluate_dsm()
    
    acpi_evaluate_dsm() and friends take a pointer to a raw buffer of 16
    bytes. Instead we convert them to use guid_t type. At the same time we
    convert current users.
    
    acpi_str_to_uuid() becomes useless after the conversion and it's safe to
    get rid of it.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Yisen Zhuang <yisen.zhuang@huawei.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 27d0dcfcf47d..b9d956c916f5 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -613,19 +613,19 @@ acpi_status acpi_evaluate_lck(acpi_handle handle, int lock)
 /**
  * acpi_evaluate_dsm - evaluate device's _DSM method
  * @handle: ACPI device handle
- * @uuid: UUID of requested functions, should be 16 bytes
+ * @guid: GUID of requested functions, should be 16 bytes
  * @rev: revision number of requested function
  * @func: requested function number
  * @argv4: the function specific parameter
  *
- * Evaluate device's _DSM method with specified UUID, revision id and
+ * Evaluate device's _DSM method with specified GUID, revision id and
  * function number. Caller needs to free the returned object.
  *
  * Though ACPI defines the fourth parameter for _DSM should be a package,
  * some old BIOSes do expect a buffer or an integer etc.
  */
 union acpi_object *
-acpi_evaluate_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 func,
+acpi_evaluate_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 func,
 		  union acpi_object *argv4)
 {
 	acpi_status ret;
@@ -638,7 +638,7 @@ acpi_evaluate_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 func,
 
 	params[0].type = ACPI_TYPE_BUFFER;
 	params[0].buffer.length = 16;
-	params[0].buffer.pointer = (char *)uuid;
+	params[0].buffer.pointer = (u8 *)guid;
 	params[1].type = ACPI_TYPE_INTEGER;
 	params[1].integer.value = rev;
 	params[2].type = ACPI_TYPE_INTEGER;
@@ -666,7 +666,7 @@ EXPORT_SYMBOL(acpi_evaluate_dsm);
 /**
  * acpi_check_dsm - check if _DSM method supports requested functions.
  * @handle: ACPI device handle
- * @uuid: UUID of requested functions, should be 16 bytes at least
+ * @guid: GUID of requested functions, should be 16 bytes at least
  * @rev: revision number of requested functions
  * @funcs: bitmap of requested functions
  *
@@ -674,7 +674,7 @@ EXPORT_SYMBOL(acpi_evaluate_dsm);
  * functions. Currently only support 64 functions at maximum, should be
  * enough for now.
  */
-bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
+bool acpi_check_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 funcs)
 {
 	int i;
 	u64 mask = 0;
@@ -683,7 +683,7 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
 	if (funcs == 0)
 		return false;
 
-	obj = acpi_evaluate_dsm(handle, uuid, rev, 0, NULL);
+	obj = acpi_evaluate_dsm(handle, guid, rev, 0, NULL);
 	if (!obj)
 		return false;
 
@@ -697,7 +697,7 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
 
 	/*
 	 * Bit 0 indicates whether there's support for any functions other than
-	 * function 0 for the specified UUID and revision.
+	 * function 0 for the specified GUID and revision.
 	 */
 	if ((mask & 0x1) && (mask & funcs) == funcs)
 		return true;

commit 8661423eea1a1b58417014716e3f1ba286072379
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Apr 19 14:02:08 2017 +0200

    ACPI / utils: Add new acpi_dev_present helper
    
    acpi_dev_found just iterates over all ACPI-ids and sees if one matches.
    This means that it will return true for devices which are in the DSDT
    but disabled (their _STA method returns 0).
    
    For some drivers it is useful to be able to check if a certain HID
    is not only present in the namespace, but also actually present as in
    acpi_device_is_present() will return true for the device. For example
    because if a certain device is present then the driver will want to use
    an extcon or IIO ADC channel provided by that device.
    
    This commit adds a new acpi_dev_present helper which drivers can use
    to this end.
    
    Like acpi_dev_found, acpi_dev_present take a HID as argument, but
    it also has 2 extra optional arguments to only check for an ACPI
    device with a specific UID and/or HRV value. This makes it more
    generic and allows it to replace custom code doing similar checks
    in several places.
    
    Arguably acpi_dev_present is what acpi_dev_found should have been, but
    there are too many users to just change acpi_dev_found without the risk
    of breaking something.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 22c09952e177..27d0dcfcf47d 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -736,6 +736,72 @@ bool acpi_dev_found(const char *hid)
 }
 EXPORT_SYMBOL(acpi_dev_found);
 
+struct acpi_dev_present_info {
+	struct acpi_device_id hid[2];
+	const char *uid;
+	s64 hrv;
+};
+
+static int acpi_dev_present_cb(struct device *dev, void *data)
+{
+	struct acpi_device *adev = to_acpi_device(dev);
+	struct acpi_dev_present_info *match = data;
+	unsigned long long hrv;
+	acpi_status status;
+
+	if (acpi_match_device_ids(adev, match->hid))
+		return 0;
+
+	if (match->uid && (!adev->pnp.unique_id ||
+	    strcmp(adev->pnp.unique_id, match->uid)))
+		return 0;
+
+	if (match->hrv == -1)
+		return 1;
+
+	status = acpi_evaluate_integer(adev->handle, "_HRV", NULL, &hrv);
+	if (ACPI_FAILURE(status))
+		return 0;
+
+	return hrv == match->hrv;
+}
+
+/**
+ * acpi_dev_present - Detect that a given ACPI device is present
+ * @hid: Hardware ID of the device.
+ * @uid: Unique ID of the device, pass NULL to not check _UID
+ * @hrv: Hardware Revision of the device, pass -1 to not check _HRV
+ *
+ * Return %true if a matching device was present at the moment of invocation.
+ * Note that if the device is pluggable, it may since have disappeared.
+ *
+ * Note that unlike acpi_dev_found() this function checks the status
+ * of the device. So for devices which are present in the dsdt, but
+ * which are disabled (their _STA callback returns 0) this function
+ * will return false.
+ *
+ * For this function to work, acpi_bus_scan() must have been executed
+ * which happens in the subsys_initcall() subsection. Hence, do not
+ * call from a subsys_initcall() or earlier (use acpi_get_devices()
+ * instead). Calling from module_init() is fine (which is synonymous
+ * with device_initcall()).
+ */
+bool acpi_dev_present(const char *hid, const char *uid, s64 hrv)
+{
+	struct acpi_dev_present_info match = {};
+	struct device *dev;
+
+	strlcpy(match.hid[0].id, hid, sizeof(match.hid[0].id));
+	match.uid = uid;
+	match.hrv = hrv;
+
+	dev = bus_find_device(&acpi_bus_type, NULL, &match,
+			      acpi_dev_present_cb);
+
+	return !!dev;
+}
+EXPORT_SYMBOL(acpi_dev_present);
+
 /*
  * acpi_backlight= handling, this is done here rather then in video_detect.c
  * because __setup cannot be used in modules.

commit a72255983f12f31f0c8d8275fb1a781546cfacb7
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jul 19 12:32:39 2016 -0700

    nfit: make DIMM DSMs optional
    
    Commit 4995734e973a "acpi, nfit: fix acpi_check_dsm() vs zero functions
    implemented" attempted to fix a QEMU regression by supporting its usage
    of a zero-mask as a valid response to a DSM-family probe request.
    However, this behavior breaks HP platforms that return a zero-mask by
    default causing the probe to misidentify the DSM-family.
    
    Instead, the QEMU regression can be fixed by simply not requiring the DSM
    family to be identified.
    
    This effectively reverts commit 4995734e973a, and removes the DSM
    requirement from the init path.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Fixes: 4995734e973a ("acpi, nfit: fix acpi_check_dsm() vs zero functions implemented")
    Reported-by: Jerry Hoemann <jerry.hoemann@hpe.com>
    Tested-by: Jerry Hoemann <jerry.hoemann@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index b4de130f2d57..22c09952e177 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -680,6 +680,9 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
 	u64 mask = 0;
 	union acpi_object *obj;
 
+	if (funcs == 0)
+		return false;
+
 	obj = acpi_evaluate_dsm(handle, uuid, rev, 0, NULL);
 	if (!obj)
 		return false;
@@ -692,9 +695,6 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
 			mask |= (((u64)obj->buffer.pointer[i]) << (i * 8));
 	ACPI_FREE(obj);
 
-	if (funcs == 0)
-		return true;
-
 	/*
 	 * Bit 0 indicates whether there's support for any functions other than
 	 * function 0 for the specified UUID and revision.

commit 4995734e973a2c2e9c6f6413cbad9913fc4df0dc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jun 24 09:07:39 2016 -0700

    acpi, nfit: fix acpi_check_dsm() vs zero functions implemented
    
    QEMU 2.6 implements nascent support for nvdimm DSMs. Depending on
    configuration it may only implement the function0 dsm to indicate that
    no other DSMs are available. Commit 31eca76ba2fc "nfit, libnvdimm:
    limited/whitelisted dimm command marshaling mechanism" breaks QEMU, but
    QEMU is spec compliant.  Per the spec the way to indicate that no
    functions are supported is:
    
        If Function Index is zero, the return is a buffer containing one bit
        for each function index, starting with zero. Bit 0 indicates whether
        there is support for any functions other than function 0 for the
        specified UUID and Revision ID. If set to zero, no functions are
        supported (other than function zero) for the specified UUID and
        Revision ID.
    
    Update the nfit driver to determine the family (interface UUID) without
    requiring the implementation to define any other functions, i.e.
    short-circuit acpi_check_dsm() to succeed per the spec.  The nfit driver
    appears to be the only user passing funcs==0 to acpi_check_dsm(), so
    this behavior change of the common routine should be limited to the
    probing done by the nfit driver.
    
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jerry Hoemann <jerry.hoemann@hpe.com>
    Acked-by: "Rafael J. Wysocki" <rafael@kernel.org>
    Fixes: 31eca76ba2fc ("nfit, libnvdimm: limited/whitelisted dimm command marshaling mechanism")
    Reported-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Tested-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 22c09952e177..b4de130f2d57 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -680,9 +680,6 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
 	u64 mask = 0;
 	union acpi_object *obj;
 
-	if (funcs == 0)
-		return false;
-
 	obj = acpi_evaluate_dsm(handle, uuid, rev, 0, NULL);
 	if (!obj)
 		return false;
@@ -695,6 +692,9 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
 			mask |= (((u64)obj->buffer.pointer[i]) << (i * 8));
 	ACPI_FREE(obj);
 
+	if (funcs == 0)
+		return true;
+
 	/*
 	 * Bit 0 indicates whether there's support for any functions other than
 	 * function 0 for the specified UUID and revision.

commit 1f40c49570eb01436786a9b5845c4469a9a1f362
Merge: 7639dad93a55 36092ee8ba69
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 11:18:01 2016 -0700

    Merge tag 'libnvdimm-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dan Williams:
     "The bulk of this update was stabilized before the merge window and
      appeared in -next.  The "device dax" implementation was revised this
      week in response to review feedback, and to address failures detected
      by the recently expanded ndctl unit test suite.
    
      Not included in this pull request are two dax topic branches (dax
      error handling, and dax radix-tree locking).  These topics were
      deferred to get a few more days of -next integration testing, and to
      coordinate a branch baseline with Ted and the ext4 tree.  Vishal and
      Ross will send the error handling and locking topics respectively in
      the next few days.
    
      This branch has received a positive build result from the kbuild robot
      across 226 configs.
    
      Summary:
    
       - Device DAX for persistent memory: Device DAX is the device-centric
         analogue of Filesystem DAX (CONFIG_FS_DAX).  It allows memory
         ranges to be allocated and mapped without need of an intervening
         file system.  Device DAX is strict, precise and predictable.
         Specifically this interface:
    
          a) Guarantees fault granularity with respect to a given page size
             (pte, pmd, or pud) set at configuration time.
    
          b) Enforces deterministic behavior by being strict about what
             fault scenarios are supported.
    
         Persistent memory is the first target, but the mechanism is also
         targeted for exclusive allocations of performance/feature
         differentiated memory ranges.
    
       - Support for the HPE DSM (device specific method) command formats.
         This enables management of these first generation devices until a
         unified DSM specification materializes.
    
       - Further ACPI 6.1 compliance with support for the common dimm
         identifier format.
    
       - Various fixes and cleanups across the subsystem"
    
    * tag 'libnvdimm-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (40 commits)
      libnvdimm, dax: fix deletion
      libnvdimm, dax: fix alignment validation
      libnvdimm, dax: autodetect support
      libnvdimm: release ida resources
      Revert "block: enable dax for raw block devices"
      /dev/dax, core: file operations and dax-mmap
      /dev/dax, pmem: direct access to persistent memory
      libnvdimm: stop requiring a driver ->remove() method
      libnvdimm, dax: record the specified alignment of a dax-device instance
      libnvdimm, dax: reserve space to store labels for device-dax
      libnvdimm, dax: introduce device-dax infrastructure
      nfit: add sysfs dimm 'family' and 'dsm_mask' attributes
      tools/testing/nvdimm: ND_CMD_CALL support
      nfit: disable vendor specific commands
      nfit: export subsystem ids as attributes
      nfit: fix format interface code byte order per ACPI6.1
      nfit, libnvdimm: limited/whitelisted dimm command marshaling mechanism
      nfit, libnvdimm: clarify "commands" vs "_DSMs"
      libnvdimm: increase max envelope size for ioctl
      acpi/nfit: Add sysfs "id" for NVDIMM ID
      ...

commit c7e16e5257ec46530e3e874af38191746c137c83
Author: Jerry Hoemann <jerry.hoemann@hpe.com>
Date:   Mon Apr 11 15:02:26 2016 -0700

    acpi: widen acpi_evaluate_dsm() revision and function-index arguments
    
    The ACPI specification states that arguments "Revision ID" and "Function
    Index" to a _DSM are type "Integer."  Type Integers are 64 bit
    quantities.
    
    The function evaluate_dsm specifies these types as simple "int" which
    are 32 bits.  Widen type passed to acpi_evaluate_dsm and its callers and
    derived callers to pass correct type.
    
    acpi_check_dsm and acpi_evaluate_dsm_typed had similar issue and were
    corrected as well.
    
    This is in preparation for libnvdimm implementing a generic _DSM
    passthrough facility to have the capacity to pass 64-bit values as the
    ACPI specification allows.
    
    [djbw: clarify the changelog, add rationale]
    Signed-off-by: Jerry Hoemann <jerry.hoemann@hpe.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 050673f0c0b3..e854dea7d5fe 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -625,7 +625,7 @@ acpi_status acpi_evaluate_lck(acpi_handle handle, int lock)
  * some old BIOSes do expect a buffer or an integer etc.
  */
 union acpi_object *
-acpi_evaluate_dsm(acpi_handle handle, const u8 *uuid, int rev, int func,
+acpi_evaluate_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 func,
 		  union acpi_object *argv4)
 {
 	acpi_status ret;
@@ -674,7 +674,7 @@ EXPORT_SYMBOL(acpi_evaluate_dsm);
  * functions. Currently only support 64 functions at maximum, should be
  * enough for now.
  */
-bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, int rev, u64 funcs)
+bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, u64 rev, u64 funcs)
 {
 	int i;
 	u64 mask = 0;

commit c68ae33e7fb4a010f9a48af3e4b87089dca96551
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Mar 24 13:15:20 2016 +0100

    ACPI / utils: Rename acpi_dev_present()
    
    acpi_dev_present() was originally named after pci_dev_present()
    to signify the similarity of the two functions.
    
    However Rafael J. Wysocki pointed out that the exported function
    acpi_dev_present() is easily confused with the non-exported
    acpi_device_is_present(). Additionally in ACPI parlance the term
    "present" usually refers to the "device is present" bit returned
    by the _STA control method, yet acpi_dev_present() merely checks
    presence in the namespace. It does not invoke _STA at all, let
    alone check the "device is present" bit.
    
    As suggested by Rafael, rename the function to acpi_dev_found()
    and adjust all existing call sites.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 050673f0c0b3..ac832bf6f8c9 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -707,7 +707,7 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, int rev, u64 funcs)
 EXPORT_SYMBOL(acpi_check_dsm);
 
 /**
- * acpi_dev_present - Detect presence of a given ACPI device in the system.
+ * acpi_dev_found - Detect presence of a given ACPI device in the namespace.
  * @hid: Hardware ID of the device.
  *
  * Return %true if the device was present at the moment of invocation.
@@ -719,7 +719,7 @@ EXPORT_SYMBOL(acpi_check_dsm);
  * instead). Calling from module_init() is fine (which is synonymous
  * with device_initcall()).
  */
-bool acpi_dev_present(const char *hid)
+bool acpi_dev_found(const char *hid)
 {
 	struct acpi_device_bus_id *acpi_device_bus_id;
 	bool found = false;
@@ -734,7 +734,7 @@ bool acpi_dev_present(const char *hid)
 
 	return found;
 }
-EXPORT_SYMBOL(acpi_dev_present);
+EXPORT_SYMBOL(acpi_dev_found);
 
 /*
  * acpi_backlight= handling, this is done here rather then in video_detect.c

commit 4a798f508f5d0809f45c939e329e17b3eb0ffbc1
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Mar 18 15:08:01 2016 +0000

    ACPI / util: cast data to u64 before shifting to fix sign extension
    
    obj->buffer.pointer[i] should be cast to u64 to prevent an unintentional
    sign extension.  For example, if pointer[7] is 0x80, then the value
    0xffffffffff000000 is or'd into mask rather than the intended value
    0xff00000000000000
    
    Detected with static analysis by CoverityScan
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index f12a72428aac..050673f0c0b3 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -692,7 +692,7 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, int rev, u64 funcs)
 		mask = obj->integer.value;
 	else if (obj->type == ACPI_TYPE_BUFFER)
 		for (i = 0; i < obj->buffer.length && i < 8; i++)
-			mask |= (((u8)obj->buffer.pointer[i]) << (i * 8));
+			mask |= (((u64)obj->buffer.pointer[i]) << (i * 8));
 	ACPI_FREE(obj);
 
 	/*

commit bea3c377c286f4f63f67f2e061c1d8851af76b7e
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun Feb 28 20:31:49 2016 +0000

    ACPI / util: remove redundant check if element is NULL
    
    element is &package->package.elements[i] which can never be NULL
    so the check to see if it is NULL is redundant and can be removed.
    
    Detected with static analysis by CoverityScan
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index f2f9873bb5c3..f12a72428aac 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -201,10 +201,6 @@ acpi_extract_package(union acpi_object *package,
 		u8 **pointer = NULL;
 		union acpi_object *element = &(package->package.elements[i]);
 
-		if (!element) {
-			return AE_BAD_DATA;
-		}
-
 		switch (element->type) {
 
 		case ACPI_TYPE_INTEGER:

commit 2d12b6b381ba059d5f92798f5ea739672a2f5fcf
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Nov 25 21:19:55 2015 +0100

    ACPI / utils: Add acpi_dev_present()
    
    There's an idiom in use by 7 Linux drivers to detect the presence of a
    particular ACPI HID by walking the namespace with acpi_get_devices().
    The callback passed to acpi_get_devices() is mostly identical across
    the drivers, leading to lots of duplicate code.
    
    Add acpi_dev_present(), the ACPI equivalent to pci_dev_present(),
    allowing us to deduplicate all that boilerplate in the drivers.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 475c9079bf85..f2f9873bb5c3 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -29,6 +29,7 @@
 #include <linux/dynamic_debug.h>
 
 #include "internal.h"
+#include "sleep.h"
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME("utils");
@@ -709,6 +710,36 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, int rev, u64 funcs)
 }
 EXPORT_SYMBOL(acpi_check_dsm);
 
+/**
+ * acpi_dev_present - Detect presence of a given ACPI device in the system.
+ * @hid: Hardware ID of the device.
+ *
+ * Return %true if the device was present at the moment of invocation.
+ * Note that if the device is pluggable, it may since have disappeared.
+ *
+ * For this function to work, acpi_bus_scan() must have been executed
+ * which happens in the subsys_initcall() subsection. Hence, do not
+ * call from a subsys_initcall() or earlier (use acpi_get_devices()
+ * instead). Calling from module_init() is fine (which is synonymous
+ * with device_initcall()).
+ */
+bool acpi_dev_present(const char *hid)
+{
+	struct acpi_device_bus_id *acpi_device_bus_id;
+	bool found = false;
+
+	mutex_lock(&acpi_device_lock);
+	list_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node)
+		if (!strcmp(acpi_device_bus_id->bus_id, hid)) {
+			found = true;
+			break;
+		}
+	mutex_unlock(&acpi_device_lock);
+
+	return found;
+}
+EXPORT_SYMBOL(acpi_dev_present);
+
 /*
  * acpi_backlight= handling, this is done here rather then in video_detect.c
  * because __setup cannot be used in modules.

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 67c548ad3764..475c9079bf85 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -16,10 +16,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 

commit 14ca7a47d0ab2a7a35faab130e6d9682f8ff1a46
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jun 16 16:27:47 2015 +0200

    acpi-video-detect: video: Make video_detect code part of the video module
    
    This is a preparation patch for the backlight interface selection logic
    cleanup, there are 2 reasons to not always build the video_detect code
    into the kernel:
    
    1) In order for the video_detect.c to also deal with / select native
    backlight interfaces on win8 systems, instead of doing this in video.c
    where it does not belong, video_detect.c needs to call into the backlight
    class code. Which cannot be done if it is builtin and the blacklight class
    is not.
    
    2) Currently all the platform/x86 drivers which have quirks to prefer
    the vendor driver over acpi-video call acpi_video_unregister_backlight()
    to remove the acpi-video backlight interface, this logic really belongs
    in video_detect.c, which will cause video_detect.c to depend on symbols of
    video.c and video.c already depends on video_detect.c symbols, so they
    really need to be a single module.
    
    Note that this commits make 2 changes so as to maintain 100% kernel
    commandline compatibility:
    
    1) The __setup call for the acpi_backlight= handling is moved to
       acpi/util.c as __setup may only be used by code which is alwasy builtin
    2) video.c is renamed to acpi_video.c so that it can be combined with
       video_detect.c into video.ko
    
    This commit also makes changes to drivers/platform/x86/Kconfig to ensure
    that drivers which use acpi_video_backlight_support() from video_detect.c,
    will not be built-in when acpi_video is not built in. This also changes
    some "select" uses to "depends on" to avoid dependency loops.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index cd49a3982b6a..67c548ad3764 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -712,3 +712,18 @@ bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, int rev, u64 funcs)
 	return false;
 }
 EXPORT_SYMBOL(acpi_check_dsm);
+
+/*
+ * acpi_backlight= handling, this is done here rather then in video_detect.c
+ * because __setup cannot be used in modules.
+ */
+char acpi_video_backlight_string[16];
+EXPORT_SYMBOL(acpi_video_backlight_string);
+
+static int __init acpi_backlight(char *str)
+{
+	strlcpy(acpi_video_backlight_string, str,
+		sizeof(acpi_video_backlight_string));
+	return 1;
+}
+__setup("acpi_backlight=", acpi_backlight);

commit be10f60d29433f712bf0887431efb80975e64438
Merge: ae5056e8573c 80167a24a274 c48cf1b9dd8f 175f8e2650f7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 18 18:42:56 2014 +0100

    Merge branches 'acpi-scan', 'acpi-utils' and 'acpi-pm'
    
    * acpi-scan:
      ACPI / scan: Change the level of _DEP-related messages to KERN_DEBUG
    
    * acpi-utils:
      ACPI / utils: Drop error messages from acpi_evaluate_reference()
    
    * acpi-pm:
      ACPI / PM: Do not disable wakeup GPEs that have not been enabled

commit c48cf1b9dd8f01358e5385d40fb58061f32313a7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 12 22:51:01 2014 +0100

    ACPI / utils: Drop error messages from acpi_evaluate_reference()
    
    Some of the error messages printed by acpi_evaluate_reference()
    with the KERN_ERR priority should really be debug messages, but then
    they would be redundant, because acpi_util_eval_error() is called
    too at the same spots (except for one).
    
    Drop the kernel messages from there entirely and leave the
    acpi_util_eval_error() to handle the debug printing.  In one case,
    replace the kernel message with a call to acpi_util_eval_error().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 371ac12d25b1..5512309d167b 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -347,22 +347,16 @@ acpi_evaluate_reference(acpi_handle handle,
 	package = buffer.pointer;
 
 	if ((buffer.length == 0) || !package) {
-		printk(KERN_ERR PREFIX "No return object (len %X ptr %p)\n",
-			    (unsigned)buffer.length, package);
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (package->type != ACPI_TYPE_PACKAGE) {
-		printk(KERN_ERR PREFIX "Expecting a [Package], found type %X\n",
-			    package->type);
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (!package->package.count) {
-		printk(KERN_ERR PREFIX "[Package] has zero elements (%p)\n",
-			    package);
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
@@ -381,17 +375,13 @@ acpi_evaluate_reference(acpi_handle handle,
 
 		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
 			status = AE_BAD_DATA;
-			printk(KERN_ERR PREFIX
-				    "Expecting a [Reference] package element, found type %X\n",
-				    element->type);
 			acpi_util_eval_error(handle, pathname, status);
 			break;
 		}
 
 		if (!element->reference.handle) {
-			printk(KERN_WARNING PREFIX "Invalid reference in"
-			       " package %s\n", pathname);
 			status = AE_NULL_ENTRY;
+			acpi_util_eval_error(handle, pathname, status);
 			break;
 		}
 		/* Get the  acpi_handle. */

commit d93de3455d0f04b1c5a60af41399b7f6f7b13c47
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sun Nov 16 10:57:00 2014 +0100

    ACPI: remove unnecessary sizeof(u8)
    
    sizeof(u8) is always 1.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 371ac12d25b1..dd8ff63ee2b4 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -136,8 +136,7 @@ acpi_extract_package(union acpi_object *package,
 				break;
 			case 'B':
 				size_required +=
-				    sizeof(u8 *) +
-				    (element->buffer.length * sizeof(u8));
+				    sizeof(u8 *) + element->buffer.length;
 				tail_offset += sizeof(u8 *);
 				break;
 			default:
@@ -255,7 +254,7 @@ acpi_extract_package(union acpi_object *package,
 				memcpy(tail, element->buffer.pointer,
 				       element->buffer.length);
 				head += sizeof(u8 *);
-				tail += element->buffer.length * sizeof(u8);
+				tail += element->buffer.length;
 				break;
 			default:
 				/* Should never get here */

commit 8264fce6de03f3915e2301f52f181a982718a8cb
Merge: 816fb4175c29 6ceaf58abe25
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 24 11:21:43 2014 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal management updates from Zhang Rui:
     "Sorry that I missed the merge window as there is a bug found in the
      last minute, and I have to fix it and wait for the code to be tested
      in linux-next tree for a few days.  Now the buggy patch has been
      dropped entirely from my next branch.  Thus I hope those changes can
      still be merged in 3.18-rc2 as most of them are platform thermal
      driver changes.
    
      Specifics:
    
       - introduce ACPI INT340X thermal drivers.
    
         Newer laptops and tablets may have thermal sensors and other
         devices with thermal control capabilities that are exposed for the
         OS to use via the ACPI INT340x device objects.  Several drivers are
         introduced to expose the temperature information and cooling
         ability from these objects to user-space via the normal thermal
         framework.
    
         From: Lu Aaron, Lan Tianyu, Jacob Pan and Zhang Rui.
    
       - introduce a new thermal governor, which just uses a hysteresis to
         switch abruptly on/off a cooling device.  This governor can be used
         to control certain fan devices that can not be throttled but just
         switched on or off.  From: Peter Feuerer.
    
       - introduce support for some new thermal interrupt functions on
         i.MX6SX, in IMX thermal driver.  From: Anson, Huang.
    
       - introduce tracing support on thermal framework.  From: Punit
         Agrawal.
    
       - small fixes in OF thermal and thermal step_wise governor"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (25 commits)
      Thermal: int340x thermal: select ACPI fan driver
      Thermal: int3400_thermal: use acpi_thermal_rel parsing APIs
      Thermal: int340x_thermal: expose acpi thermal relationship tables
      Thermal: introduce int3403 thermal driver
      Thermal: introduce INT3402 thermal driver
      Thermal: move the KELVIN_TO_MILLICELSIUS macro to thermal.h
      ACPI / Fan: support INT3404 thermal device
      ACPI / Fan: add ACPI 4.0 style fan support
      ACPI / fan: convert to platform driver
      ACPI / fan: use acpi_device_xxx_power instead of acpi_bus equivelant
      ACPI / fan: remove no need check for device pointer
      ACPI / fan: remove unused macro
      Thermal: int3400 thermal: register to thermal framework
      Thermal: int3400 thermal: add capability to detect supporting UUIDs
      Thermal: introduce int3400 thermal driver
      ACPI: add ACPI_TYPE_LOCAL_REFERENCE support to acpi_extract_package()
      ACPI: make acpi_create_platform_device() an external API
      thermal: step_wise: fix: Prevent from binary overflow when trend is dropping
      ACPI: introduce ACPI int340x thermal scan handler
      thermal: Added Bang-bang thermal governor
      ...

commit e3ec483a7e24c6ebb5eb763ee56c65c239701066
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Sun Mar 16 21:34:16 2014 +0800

    ACPI: add ACPI_TYPE_LOCAL_REFERENCE support to acpi_extract_package()
    
    Add ACPI_TYPE_LOCAL_REFERENCE support to acpi_extract_package(),
    so that we can use this helper for more cases like _ART/_TRT.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 07c8c5a5ee95..1ed7aba99d8d 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -149,6 +149,21 @@ acpi_extract_package(union acpi_object *package,
 				break;
 			}
 			break;
+		case ACPI_TYPE_LOCAL_REFERENCE:
+			switch (format_string[i]) {
+			case 'R':
+				size_required += sizeof(void *);
+				tail_offset += sizeof(void *);
+				break;
+			default:
+				printk(KERN_WARNING PREFIX "Invalid package element"
+					      " [%d] got reference,"
+					      " expecting [%c]\n",
+					      i, format_string[i]);
+				return AE_BAD_DATA;
+				break;
+			}
+			break;
 
 		case ACPI_TYPE_PACKAGE:
 		default:
@@ -247,7 +262,18 @@ acpi_extract_package(union acpi_object *package,
 				break;
 			}
 			break;
-
+		case ACPI_TYPE_LOCAL_REFERENCE:
+			switch (format_string[i]) {
+			case 'R':
+				*(void **)head =
+				    (void *)element->reference.handle;
+				head += sizeof(void *);
+				break;
+			default:
+				/* Should never get here */
+				break;
+			}
+			break;
 		case ACPI_TYPE_PACKAGE:
 			/* TBD: handle nested packages... */
 		default:

commit 5d30f7410220eb212614654677264f1ba04ae746
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Sep 15 19:36:53 2014 +0800

    ACPI / utils: Update acpi_check_dsm() comments
    
    Update function comments.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 07c8c5a5ee95..834f35c4bf8d 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -661,7 +661,6 @@ EXPORT_SYMBOL(acpi_evaluate_dsm);
  * @uuid: UUID of requested functions, should be 16 bytes at least
  * @rev: revision number of requested functions
  * @funcs: bitmap of requested functions
- * @exclude: excluding special value, used to support i915 and nouveau
  *
  * Evaluate device's _DSM method to check whether it supports requested
  * functions. Currently only support 64 functions at maximum, should be

commit 45fef5b88d1f2f47ecdefae6354372d440ca5c84
Author: Bjrn Mork <bjorn@mork.no>
Date:   Thu May 22 12:47:47 2014 +0200

    ACPI: add dynamic_debug support
    
    Commit 1a699476e258 ("ACPI / hotplug / PCI: Hotplug notifications
    from acpi_bus_notify()") added debug messages for a few common
    events. These debug messages are unconditionally enabled if
    CONFIG_DYNAMIC_DEBUG is defined, contrary to the documented
    meaning, making the ACPI system spew lots of unwanted noise on
    any kernel with dynamic debugging.
    
    The bug was introduced by commit fbfddae69657 ("ACPI: Add
    acpi_handle_<level>() interfaces"), which added the
    CONFIG_DYNAMIC_DEBUG dependency without respecting its meaning.
    
    Fix by adding real support for dynamic_debug.
    
    Fixes: fbfddae69657 ("ACPI: Add acpi_handle_<level>() interfaces")
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index bba526148583..07c8c5a5ee95 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -30,6 +30,7 @@
 #include <linux/types.h>
 #include <linux/hardirq.h>
 #include <linux/acpi.h>
+#include <linux/dynamic_debug.h>
 
 #include "internal.h"
 
@@ -456,6 +457,24 @@ acpi_evaluate_ost(acpi_handle handle, u32 source_event, u32 status_code,
 }
 EXPORT_SYMBOL(acpi_evaluate_ost);
 
+/**
+ * acpi_handle_path: Return the object path of handle
+ *
+ * Caller must free the returned buffer
+ */
+static char *acpi_handle_path(acpi_handle handle)
+{
+	struct acpi_buffer buffer = {
+		.length = ACPI_ALLOCATE_BUFFER,
+		.pointer = NULL
+	};
+
+	if (in_interrupt() ||
+	    acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer) != AE_OK)
+		return NULL;
+	return buffer.pointer;
+}
+
 /**
  * acpi_handle_printk: Print message with ACPI prefix and object path
  *
@@ -469,29 +488,50 @@ acpi_handle_printk(const char *level, acpi_handle handle, const char *fmt, ...)
 {
 	struct va_format vaf;
 	va_list args;
-	struct acpi_buffer buffer = {
-		.length = ACPI_ALLOCATE_BUFFER,
-		.pointer = NULL
-	};
 	const char *path;
 
 	va_start(args, fmt);
 	vaf.fmt = fmt;
 	vaf.va = &args;
 
-	if (in_interrupt() ||
-	    acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer) != AE_OK)
-		path = "<n/a>";
-	else
-		path = buffer.pointer;
-
-	printk("%sACPI: %s: %pV", level, path, &vaf);
+	path = acpi_handle_path(handle);
+	printk("%sACPI: %s: %pV", level, path ? path : "<n/a>" , &vaf);
 
 	va_end(args);
-	kfree(buffer.pointer);
+	kfree(path);
 }
 EXPORT_SYMBOL(acpi_handle_printk);
 
+#if defined(CONFIG_DYNAMIC_DEBUG)
+/**
+ * __acpi_handle_debug: pr_debug with ACPI prefix and object path
+ *
+ * This function is called through acpi_handle_debug macro and debug
+ * prints a message with ACPI prefix and object path. This function
+ * acquires the global namespace mutex to obtain an object path.  In
+ * interrupt context, it shows the object path as <n/a>.
+ */
+void
+__acpi_handle_debug(struct _ddebug *descriptor, acpi_handle handle,
+		    const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	const char *path;
+
+	va_start(args, fmt);
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	path = acpi_handle_path(handle);
+	__dynamic_pr_debug(descriptor, "ACPI: %s: %pV", path ? path : "<n/a>", &vaf);
+
+	va_end(args);
+	kfree(path);
+}
+EXPORT_SYMBOL(__acpi_handle_debug);
+#endif
+
 /**
  * acpi_has_method: Check whether @handle has a method named @name
  * @handle: ACPI device handle

commit 2d0acb4af981e20eb626c6ea1925e95056220b2a
Author: jhbird.choi@samsung.com <jhbird.choi@samsung.com>
Date:   Thu Mar 20 16:35:56 2014 +0900

    ACPI: Clean up memory allocations
    
    Use acpi_os_allocate_zeroed instead of acpi_os_allocate + memset.
    
    Signed-off-by: Jonghwan Choi <jhbird.choi@samsung.com>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 0f5f78fa6545..bba526148583 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -164,11 +164,10 @@ acpi_extract_package(union acpi_object *package,
 	 * Validate output buffer.
 	 */
 	if (buffer->length == ACPI_ALLOCATE_BUFFER) {
-		buffer->pointer = ACPI_ALLOCATE(size_required);
+		buffer->pointer = ACPI_ALLOCATE_ZEROED(size_required);
 		if (!buffer->pointer)
 			return AE_NO_MEMORY;
 		buffer->length = size_required;
-		memset(buffer->pointer, 0, size_required);
 	} else {
 		if (buffer->length < size_required) {
 			buffer->length = size_required;

commit 700b8422fb9e6041907bda45a15f4e2ab0438a04
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 21 01:07:17 2014 +0100

    ACPI: Drop acpi_evaluate_hotplug_ost() and ACPI_HOTPLUG_OST
    
    Replace acpi_evaluate_hotplug_ost() with acpi_evaluate_ost()
    everywhere and drop the ACPI_HOTPLUG_OST symbol so that hotplug
    _OST is supported unconditionally.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 19d016974080..0f5f78fa6545 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -422,7 +422,7 @@ acpi_get_physical_device_location(acpi_handle handle, struct acpi_pld_info **pld
 EXPORT_SYMBOL(acpi_get_physical_device_location);
 
 /**
- * acpi_evaluate_hotplug_ost: Evaluate _OST for hotplug operations
+ * acpi_evaluate_ost: Evaluate _OST for hotplug operations
  * @handle: ACPI device handle
  * @source_event: source event code
  * @status_code: status code

commit 05730c1952787faa422ea2898634a1f9cdb61161
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:02:15 2014 +0800

    ACPI: rename acpi_evaluate_hotplug_ost() to acpi_evaluate_ost()
    
    Rename acpi_evaluate_hotplug_ost() to acpi_evaluate_ost() for later
    resue.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 85e3b612bdc0..19d016974080 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -433,17 +433,15 @@ EXPORT_SYMBOL(acpi_get_physical_device_location);
  * When the platform does not support _OST, this function has no effect.
  */
 acpi_status
-acpi_evaluate_hotplug_ost(acpi_handle handle, u32 source_event,
-		u32 status_code, struct acpi_buffer *status_buf)
+acpi_evaluate_ost(acpi_handle handle, u32 source_event, u32 status_code,
+		  struct acpi_buffer *status_buf)
 {
-#ifdef ACPI_HOTPLUG_OST
 	union acpi_object params[3] = {
 		{.type = ACPI_TYPE_INTEGER,},
 		{.type = ACPI_TYPE_INTEGER,},
 		{.type = ACPI_TYPE_BUFFER,}
 	};
 	struct acpi_object_list arg_list = {3, params};
-	acpi_status status;
 
 	params[0].integer.value = source_event;
 	params[1].integer.value = status_code;
@@ -455,13 +453,9 @@ acpi_evaluate_hotplug_ost(acpi_handle handle, u32 source_event,
 		params[2].buffer.length = 0;
 	}
 
-	status = acpi_evaluate_object(handle, "_OST", &arg_list, NULL);
-	return status;
-#else
-	return AE_OK;
-#endif
+	return acpi_evaluate_object(handle, "_OST", &arg_list, NULL);
 }
-EXPORT_SYMBOL(acpi_evaluate_hotplug_ost);
+EXPORT_SYMBOL(acpi_evaluate_ost);
 
 /**
  * acpi_handle_printk: Print message with ACPI prefix and object path

commit eb5ed9a3221a30edc7b48b87af550dbcc0e82c80
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jan 30 14:56:56 2014 +0300

    ACPI / utils: remove a pointless NULL check
    
    "element" can't be NULL because it is the address of a struct member.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 0347a37eb438..85e3b612bdc0 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -99,10 +99,6 @@ acpi_extract_package(union acpi_object *package,
 
 		union acpi_object *element = &(package->package.elements[i]);
 
-		if (!element) {
-			return AE_BAD_DATA;
-		}
-
 		switch (element->type) {
 
 		case ACPI_TYPE_INTEGER:

commit fbb9c10d40f88011ac72f855c97e3bdd981026a9
Merge: 3e7cc142c1e0 7ede9f8a1805
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:45:52 2014 +0100

    Merge branch 'acpi-dsm'
    
    * acpi-dsm:
      ACPI / extlog: replace open-coded _DSM code with helper functions
      ACPI / nouveau: replace open-coded _DSM code with helper functions
      nouveau / ACPI: fix memory leak in ACPI _DSM related code
      ACPI / i915: replace open-coded _DSM code with helper functions
      ACPI / i2c-hid: replace open-coded _DSM code with helper functions
      ACPI / TPM: detect PPI features by checking availability of _DSM functions
      ACPI / TPM: replace open-coded _DSM code with helper functions
      ACPI / TPM: match node name instead of full path when searching for TPM device
      PCI / pci-label: treat PCI label with index 0 as valid label
      ACPI / PCI: replace open-coded _DSM code with helper functions
      PCI / pci-label: release allocated ACPI object on error recovery path
      ACPI: introduce helper interfaces for _DSM method

commit a65ac52041cccaf598995bc44340849027f1d79b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Dec 19 20:38:10 2013 +0800

    ACPI: introduce helper interfaces for _DSM method
    
    There are several drivers making use of ACPI _DSM method to detect
    and invoke device specific methods. Currently every driver has
    implemented its private version to support ACPI _DSM method.
    So this patch introduces three helper functions to support ACPI _DSM
    method, which will be used to replace open-coded versions.
    
    It helps to simplify code and improve code readability.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 6d408bfbbb1d..bcb2ed9e03aa 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -574,3 +574,100 @@ acpi_status acpi_evaluate_lck(acpi_handle handle, int lock)
 
 	return status;
 }
+
+/**
+ * acpi_evaluate_dsm - evaluate device's _DSM method
+ * @handle: ACPI device handle
+ * @uuid: UUID of requested functions, should be 16 bytes
+ * @rev: revision number of requested function
+ * @func: requested function number
+ * @argv4: the function specific parameter
+ *
+ * Evaluate device's _DSM method with specified UUID, revision id and
+ * function number. Caller needs to free the returned object.
+ *
+ * Though ACPI defines the fourth parameter for _DSM should be a package,
+ * some old BIOSes do expect a buffer or an integer etc.
+ */
+union acpi_object *
+acpi_evaluate_dsm(acpi_handle handle, const u8 *uuid, int rev, int func,
+		  union acpi_object *argv4)
+{
+	acpi_status ret;
+	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object params[4];
+	struct acpi_object_list input = {
+		.count = 4,
+		.pointer = params,
+	};
+
+	params[0].type = ACPI_TYPE_BUFFER;
+	params[0].buffer.length = 16;
+	params[0].buffer.pointer = (char *)uuid;
+	params[1].type = ACPI_TYPE_INTEGER;
+	params[1].integer.value = rev;
+	params[2].type = ACPI_TYPE_INTEGER;
+	params[2].integer.value = func;
+	if (argv4) {
+		params[3] = *argv4;
+	} else {
+		params[3].type = ACPI_TYPE_PACKAGE;
+		params[3].package.count = 0;
+		params[3].package.elements = NULL;
+	}
+
+	ret = acpi_evaluate_object(handle, "_DSM", &input, &buf);
+	if (ACPI_SUCCESS(ret))
+		return (union acpi_object *)buf.pointer;
+
+	if (ret != AE_NOT_FOUND)
+		acpi_handle_warn(handle,
+				"failed to evaluate _DSM (0x%x)\n", ret);
+
+	return NULL;
+}
+EXPORT_SYMBOL(acpi_evaluate_dsm);
+
+/**
+ * acpi_check_dsm - check if _DSM method supports requested functions.
+ * @handle: ACPI device handle
+ * @uuid: UUID of requested functions, should be 16 bytes at least
+ * @rev: revision number of requested functions
+ * @funcs: bitmap of requested functions
+ * @exclude: excluding special value, used to support i915 and nouveau
+ *
+ * Evaluate device's _DSM method to check whether it supports requested
+ * functions. Currently only support 64 functions at maximum, should be
+ * enough for now.
+ */
+bool acpi_check_dsm(acpi_handle handle, const u8 *uuid, int rev, u64 funcs)
+{
+	int i;
+	u64 mask = 0;
+	union acpi_object *obj;
+
+	if (funcs == 0)
+		return false;
+
+	obj = acpi_evaluate_dsm(handle, uuid, rev, 0, NULL);
+	if (!obj)
+		return false;
+
+	/* For compatibility, old BIOSes may return an integer */
+	if (obj->type == ACPI_TYPE_INTEGER)
+		mask = obj->integer.value;
+	else if (obj->type == ACPI_TYPE_BUFFER)
+		for (i = 0; i < obj->buffer.length && i < 8; i++)
+			mask |= (((u8)obj->buffer.pointer[i]) << (i * 8));
+	ACPI_FREE(obj);
+
+	/*
+	 * Bit 0 indicates whether there's support for any functions other than
+	 * function 0 for the specified UUID and revision.
+	 */
+	if ((mask & 0x1) && (mask & funcs) == funcs)
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL(acpi_check_dsm);

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 6d408bfbbb1d..1336b9151479 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -30,8 +30,6 @@
 #include <linux/types.h>
 #include <linux/hardirq.h>
 #include <linux/acpi.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
 
 #include "internal.h"
 

commit e7e92ec93f218085e37ded8338f717ffd49eed1d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Oct 29 10:34:19 2013 +0000

    ACPI: Fix spelling mistake in error messages
    
    Fix spelling mistake "expecing" --> "expecting"
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index fc2cd3284080..6d408bfbbb1d 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -121,7 +121,7 @@ acpi_extract_package(union acpi_object *package,
 				break;
 			default:
 				printk(KERN_WARNING PREFIX "Invalid package element"
-					      " [%d]: got number, expecing"
+					      " [%d]: got number, expecting"
 					      " [%c]\n",
 					      i, format_string[i]);
 				return AE_BAD_DATA;
@@ -148,7 +148,7 @@ acpi_extract_package(union acpi_object *package,
 			default:
 				printk(KERN_WARNING PREFIX "Invalid package element"
 					      " [%d] got string/buffer,"
-					      " expecing [%c]\n",
+					      " expecting [%c]\n",
 					      i, format_string[i]);
 				return AE_BAD_DATA;
 				break;

commit e83dda06242073b1c7f9a88f1001e32a4b9fcd1d
Author: Al Stone <ahs3@redhat.com>
Date:   Wed Oct 9 14:21:10 2013 -0600

    ACPI: improve acpi_extract_package() utility
    
    The current version requires one to know the size of the package
    a priori; this is almost impossible if the package is composed of
    strings of variable length.  This change allows the utility to
    allocate a buffer of the proper size if asked.
    
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 552248b0005b..fc2cd3284080 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -169,11 +169,20 @@ acpi_extract_package(union acpi_object *package,
 	/*
 	 * Validate output buffer.
 	 */
-	if (buffer->length < size_required) {
+	if (buffer->length == ACPI_ALLOCATE_BUFFER) {
+		buffer->pointer = ACPI_ALLOCATE(size_required);
+		if (!buffer->pointer)
+			return AE_NO_MEMORY;
 		buffer->length = size_required;
-		return AE_BUFFER_OVERFLOW;
-	} else if (buffer->length != size_required || !buffer->pointer) {
-		return AE_BAD_PARAMETER;
+		memset(buffer->pointer, 0, size_required);
+	} else {
+		if (buffer->length < size_required) {
+			buffer->length = size_required;
+			return AE_BUFFER_OVERFLOW;
+		} else if (buffer->length != size_required ||
+			   !buffer->pointer) {
+			return AE_BAD_PARAMETER;
+		}
 	}
 
 	head = buffer->pointer;

commit 7d2421f84b445dc48c68d33911f1fd6ce6853ee3
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:40 2013 +0800

    ACPI: introduce two helper functions for _EJ0 and _LCK
    
    Introduce two helper functions, acpi_evaluate_ej0() and
    acpi_evaluate_lck(), that will execute the _EJ0 and _LCK ACPI
    control methods, respectively, and use them to simplify the
    ACPI scan code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 87b85882b5df..552248b0005b 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -522,3 +522,46 @@ acpi_status acpi_execute_simple_method(acpi_handle handle, char *method,
 	return acpi_evaluate_object(handle, method, &arg_list, NULL);
 }
 EXPORT_SYMBOL(acpi_execute_simple_method);
+
+/**
+ * acpi_evaluate_ej0: Evaluate _EJ0 method for hotplug operations
+ * @handle: ACPI device handle
+ *
+ * Evaluate device's _EJ0 method for hotplug operations.
+ */
+acpi_status acpi_evaluate_ej0(acpi_handle handle)
+{
+	acpi_status status;
+
+	status = acpi_execute_simple_method(handle, "_EJ0", 1);
+	if (status == AE_NOT_FOUND)
+		acpi_handle_warn(handle, "No _EJ0 support for device\n");
+	else if (ACPI_FAILURE(status))
+		acpi_handle_warn(handle, "Eject failed (0x%x)\n", status);
+
+	return status;
+}
+
+/**
+ * acpi_evaluate_lck: Evaluate _LCK method to lock/unlock device
+ * @handle: ACPI device handle
+ * @lock: lock device if non-zero, otherwise unlock device
+ *
+ * Evaluate device's _LCK method if present to lock/unlock device
+ */
+acpi_status acpi_evaluate_lck(acpi_handle handle, int lock)
+{
+	acpi_status status;
+
+	status = acpi_execute_simple_method(handle, "_LCK", !!lock);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		if (lock)
+			acpi_handle_warn(handle,
+				"Locking device failed (0x%x)\n", status);
+		else
+			acpi_handle_warn(handle,
+				"Unlocking device failed (0x%x)\n", status);
+	}
+
+	return status;
+}

commit 0db98202605c3d32e023d43c30b5bd878f520976
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:39 2013 +0800

    ACPI: introduce helper function acpi_execute_simple_method()
    
    Introduce helper function acpi_execute_simple_method() and use it in
    a number of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index b08d97376f84..87b85882b5df 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -510,3 +510,15 @@ bool acpi_has_method(acpi_handle handle, char *name)
 	return ACPI_SUCCESS(acpi_get_handle(handle, name, &tmp));
 }
 EXPORT_SYMBOL(acpi_has_method);
+
+acpi_status acpi_execute_simple_method(acpi_handle handle, char *method,
+				       u64 arg)
+{
+	union acpi_object obj = { .type = ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { .count = 1, .pointer = &obj, };
+
+	obj.integer.value = arg;
+
+	return acpi_evaluate_object(handle, method, &arg_list, NULL);
+}
+EXPORT_SYMBOL(acpi_execute_simple_method);

commit 952c63e9512b63220886105cfc791507046fa39a
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:38 2013 +0800

    ACPI: introduce helper function acpi_has_method()
    
    Introduce helper function acpi_has_method() and use it in a number
    of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 744371304313..b08d97376f84 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -495,3 +495,18 @@ acpi_handle_printk(const char *level, acpi_handle handle, const char *fmt, ...)
 	kfree(buffer.pointer);
 }
 EXPORT_SYMBOL(acpi_handle_printk);
+
+/**
+ * acpi_has_method: Check whether @handle has a method named @name
+ * @handle: ACPI device handle
+ * @name: name of object or method
+ *
+ * Check whether @handle has a method named @name.
+ */
+bool acpi_has_method(acpi_handle handle, char *name)
+{
+	acpi_handle tmp;
+
+	return ACPI_SUCCESS(acpi_get_handle(handle, name, &tmp));
+}
+EXPORT_SYMBOL(acpi_has_method);

commit fbfddae696572e57a441252abbd65f7220e06030
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Wed Nov 21 01:36:28 2012 +0000

    ACPI: Add acpi_handle_<level>() interfaces
    
    This patch introduces acpi_handle_<level>(), where <level> is
    a kernel message level such as err/warn/info, to support improved
    logging messages for ACPI, esp. hot-plug operations.
    acpi_handle_<level>() appends "ACPI" prefix and ACPI object path
    to the messages.  This improves diagnosis of hotplug operations
    since an error message in a log file identifies an object that
    caused an issue.  This interface acquires the global namespace
    mutex to obtain an object path.  In interrupt context, it shows
    the object path as <n/a>.
    
    acpi_handle_<level>() takes acpi_handle as an argument, which is
    passed to ACPI hotplug notify handlers from the ACPICA.  Therefore,
    it is always available unlike other kernel objects, such as device.
    
    For example:
      acpi_handle_err(handle, "Device don't exist, dropping EJECT\n");
    logs an error message like this at KERN_ERR.
      ACPI: \_SB_.SCK4.CPU4: Device don't exist, dropping EJECT
    
    ACPI hot-plug drivers can use acpi_handle_<level>() when they need
    to identify a target ACPI object path in their messages, such as
    error cases.  The usage model is similar to dev_<level>().
    acpi_handle_<level>() can be used when a device is not created or
    is invalid during hot-plug operations.  ACPI object path is also
    consistent on the platform, unlike device name that gets incremented
    over hotplug operations.
    
    ACPI drivers should use dev_<level>() when a device object is valid.
    Device name provides more user friendly information, and avoids
    acquiring the global ACPI namespace mutex.  ACPI drivers also
    continue to use pr_<level>() when they do not need to specify device
    information, such as boot-up messages.
    
    Note: ACPI_[WARNING|INFO|ERROR]() are intended for the ACPICA and
    are not associated with the kernel message level.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Vijay Mohan Pandarathil <vijaymohan.pandarathil@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 462f7e300363..744371304313 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -28,6 +28,8 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/types.h>
+#include <linux/hardirq.h>
+#include <linux/acpi.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
@@ -457,3 +459,39 @@ acpi_evaluate_hotplug_ost(acpi_handle handle, u32 source_event,
 #endif
 }
 EXPORT_SYMBOL(acpi_evaluate_hotplug_ost);
+
+/**
+ * acpi_handle_printk: Print message with ACPI prefix and object path
+ *
+ * This function is called through acpi_handle_<level> macros and prints
+ * a message with ACPI prefix and object path.  This function acquires
+ * the global namespace mutex to obtain an object path.  In interrupt
+ * context, it shows the object path as <n/a>.
+ */
+void
+acpi_handle_printk(const char *level, acpi_handle handle, const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	struct acpi_buffer buffer = {
+		.length = ACPI_ALLOCATE_BUFFER,
+		.pointer = NULL
+	};
+	const char *path;
+
+	va_start(args, fmt);
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	if (in_interrupt() ||
+	    acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer) != AE_OK)
+		path = "<n/a>";
+	else
+		path = buffer.pointer;
+
+	printk("%sACPI: %s: %pV", level, path, &vaf);
+
+	va_end(args);
+	kfree(buffer.pointer);
+}
+EXPORT_SYMBOL(acpi_handle_printk);

commit 8ede06aba5dffa78a27a18c47a9059eb38072ada
Author: Feng Tang <feng.tang@intel.com>
Date:   Tue Aug 21 09:56:58 2012 +0800

    ACPI: Use ACPICA native way to decode the PLD buffer
    
    This patch is on top of the ACPICA 20120816 release, which implemented
    a native way to decode PLD buffer, so use it instead of leting upper
    level users do the decoding.
    
    v2: Modify the check for PLD buffer length to reject buffers whose
    length < 16
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 3e87c9c538aa..462f7e300363 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -384,7 +384,7 @@ acpi_evaluate_reference(acpi_handle handle,
 EXPORT_SYMBOL(acpi_evaluate_reference);
 
 acpi_status
-acpi_get_physical_device_location(acpi_handle handle, struct acpi_pld *pld)
+acpi_get_physical_device_location(acpi_handle handle, struct acpi_pld_info **pld)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -400,13 +400,16 @@ acpi_get_physical_device_location(acpi_handle handle, struct acpi_pld *pld)
 	if (!output || output->type != ACPI_TYPE_PACKAGE
 	    || !output->package.count
 	    || output->package.elements[0].type != ACPI_TYPE_BUFFER
-	    || output->package.elements[0].buffer.length > sizeof(*pld)) {
+	    || output->package.elements[0].buffer.length < ACPI_PLD_REV1_BUFFER_SIZE) {
 		status = AE_TYPE;
 		goto out;
 	}
 
-	memcpy(pld, output->package.elements[0].buffer.pointer,
-	       output->package.elements[0].buffer.length);
+	status = acpi_decode_pld_buffer(
+			output->package.elements[0].buffer.pointer,
+			output->package.elements[0].buffer.length,
+			pld);
+
 out:
 	kfree(buffer.pointer);
 	return status;

commit 275c58d77062bbb85dbeb3843ba04f34aa50cf8e
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Wed May 23 20:25:19 2012 -0600

    ACPI: Add an interface to evaluate _OST
    
    Added acpi_evaluate_hotplug_opt(). All ACPI hotplug handlers must call
    this function when evaluating _OST for hotplug operations. If the
    platform does not support _OST, this function returns AE_NOT_FOUND and
    has no effect on the platform.
    
    ACPI_HOTPLUG_OST is defined when all relevant ACPI hotplug operations,
    such as CPU, memory and container hotplug, are enabled. This assures
    consistent behavior among the hotplug operations with regarding the
    _OST support. When ACPI_HOTPLUG_OST is not defined, this function is
    a no-op.
    
    ACPI PCI hotplug is not enhanced to support _OST at this time since it
    is a legacy method being replaced by PCIe native hotplug. _OST support
    for ACPI PCI hotplug may be added in future if necessary.
    
    Some platforms may require the OS to support _OST in order to support
    ACPI hotplug operations. For example, if a platform has the management
    console where user can request a hotplug operation from, this _OST
    support would be required for the management console to show the result
    of the hotplug request to user.
    
    Added macro definitions of _OST source events and status codes.
    Also renamed OSC_SB_CPUHP_OST_SUPPORT to OSC_SB_HOTPLUG_OST_SUPPORT
    since this _OSC bit is not specific to CPU hotplug. This bit is
    defined in Table 6-147 of ACPI 5.0 as follows.
    
      Bits:       3
      Field Name: Insertion / Ejection _OST Processing Support
      Definition: This bit is set if OSPM will evaluate the _OST
                  object defined under a device when processing
                  insertion and ejection source event codes.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index adbbc1c80a26..3e87c9c538aa 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -412,3 +412,45 @@ acpi_get_physical_device_location(acpi_handle handle, struct acpi_pld *pld)
 	return status;
 }
 EXPORT_SYMBOL(acpi_get_physical_device_location);
+
+/**
+ * acpi_evaluate_hotplug_ost: Evaluate _OST for hotplug operations
+ * @handle: ACPI device handle
+ * @source_event: source event code
+ * @status_code: status code
+ * @status_buf: optional detailed information (NULL if none)
+ *
+ * Evaluate _OST for hotplug operations. All ACPI hotplug handlers
+ * must call this function when evaluating _OST for hotplug operations.
+ * When the platform does not support _OST, this function has no effect.
+ */
+acpi_status
+acpi_evaluate_hotplug_ost(acpi_handle handle, u32 source_event,
+		u32 status_code, struct acpi_buffer *status_buf)
+{
+#ifdef ACPI_HOTPLUG_OST
+	union acpi_object params[3] = {
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_BUFFER,}
+	};
+	struct acpi_object_list arg_list = {3, params};
+	acpi_status status;
+
+	params[0].integer.value = source_event;
+	params[1].integer.value = status_code;
+	if (status_buf != NULL) {
+		params[2].buffer.pointer = status_buf->pointer;
+		params[2].buffer.length = status_buf->length;
+	} else {
+		params[2].buffer.pointer = NULL;
+		params[2].buffer.length = 0;
+	}
+
+	status = acpi_evaluate_object(handle, "_OST", &arg_list, NULL);
+	return status;
+#else
+	return AE_OK;
+#endif
+}
+EXPORT_SYMBOL(acpi_evaluate_hotplug_ost);

commit 38ac0f1b90dc9486cc039f1a4d8b0202813e5b67
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri May 11 16:08:26 2012 +0800

    ACPI: Add _PLD support
    
    Add a simple helper function to allow drivers to obtain the physical
    device location data.
    
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index b002a471c5d4..adbbc1c80a26 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -382,3 +382,33 @@ acpi_evaluate_reference(acpi_handle handle,
 }
 
 EXPORT_SYMBOL(acpi_evaluate_reference);
+
+acpi_status
+acpi_get_physical_device_location(acpi_handle handle, struct acpi_pld *pld)
+{
+	acpi_status status;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *output;
+
+	status = acpi_evaluate_object(handle, "_PLD", NULL, &buffer);
+
+	if (ACPI_FAILURE(status))
+		return status;
+
+	output = buffer.pointer;
+
+	if (!output || output->type != ACPI_TYPE_PACKAGE
+	    || !output->package.count
+	    || output->package.elements[0].type != ACPI_TYPE_BUFFER
+	    || output->package.elements[0].buffer.length > sizeof(*pld)) {
+		status = AE_TYPE;
+		goto out;
+	}
+
+	memcpy(pld, output->package.elements[0].buffer.pointer,
+	       output->package.elements[0].buffer.length);
+out:
+	kfree(buffer.pointer);
+	return status;
+}
+EXPORT_SYMBOL(acpi_get_physical_device_location);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index c9a49f4747e6..b002a471c5d4 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -25,6 +25,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <acpi/acpi_bus.h>

commit ec28dcc6b4c00b78ad269ad5b85ebd5c2d504825
Merge: c67fcd670b55 d06070509147 f6bb13aa1ea3 0c99c5288eb9 4c81ba4900ab 7e0e9c042790 149fe9c293f7 cffdde993a01 fa80945269f3 8b7ef6d8f162 70287db87cfc 38bcb37a6f63
Author: Len Brown <len.brown@intel.com>
Date:   Sun Mar 14 21:30:17 2010 -0400

    Merge branches 'battery-2.6.34', 'bugzilla-10805', 'bugzilla-14668', 'bugzilla-531916-power-state', 'ht-warn-2.6.34', 'pnp', 'processor-rename', 'sony-2.6.34', 'suse-bugzilla-531547', 'tz-check', 'video' and 'misc-2.6.34' into release

commit 0e026445fb36852d3102cb8bb24868765fe5816a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Feb 16 03:01:42 2010 -0500

    ACPI: delete unused acpi_evaluate_string()
    
    Roel found a logic issue in the #if 0 acpi_evaluate_string():
    
    -           || (element->type != ACPI_TYPE_BUFFER)
    +           && (element->type != ACPI_TYPE_BUFFER)
    
    delete the dead code.
    
    pointed-out-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 811fec10462b..592dffb43694 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -289,51 +289,6 @@ acpi_evaluate_integer(acpi_handle handle,
 
 EXPORT_SYMBOL(acpi_evaluate_integer);
 
-#if 0
-acpi_status
-acpi_evaluate_string(acpi_handle handle,
-		     acpi_string pathname,
-		     acpi_object_list * arguments, acpi_string * data)
-{
-	acpi_status status = AE_OK;
-	acpi_object *element = NULL;
-	acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-
-
-	if (!data)
-		return AE_BAD_PARAMETER;
-
-	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
-	if (ACPI_FAILURE(status)) {
-		acpi_util_eval_error(handle, pathname, status);
-		return status;
-	}
-
-	element = (acpi_object *) buffer.pointer;
-
-	if ((element->type != ACPI_TYPE_STRING)
-	    || (element->type != ACPI_TYPE_BUFFER)
-	    || !element->string.length) {
-		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
-		return AE_BAD_DATA;
-	}
-
-	*data = kzalloc(element->string.length + 1, GFP_KERNEL);
-	if (!data) {
-		printk(KERN_ERR PREFIX "Memory allocation\n");
-		return -ENOMEM;
-	}
-
-	memcpy(*data, element->string.pointer, element->string.length);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%s]\n", *data));
-
-	kfree(buffer.pointer);
-
-	return AE_OK;
-}
-#endif
-
 acpi_status
 acpi_evaluate_reference(acpi_handle handle,
 			acpi_string pathname,

commit 439913fffd39374c3737186b22d2d56c3a0ae526
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Jan 28 10:53:19 2010 +0800

    ACPI: replace acpi_integer by u64
    
    acpi_integer is now obsolete and removed from the ACPICA code base,
    replaced by u64.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 811fec10462b..11882dbe2094 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -107,12 +107,12 @@ acpi_extract_package(union acpi_object *package,
 		case ACPI_TYPE_INTEGER:
 			switch (format_string[i]) {
 			case 'N':
-				size_required += sizeof(acpi_integer);
-				tail_offset += sizeof(acpi_integer);
+				size_required += sizeof(u64);
+				tail_offset += sizeof(u64);
 				break;
 			case 'S':
 				size_required +=
-				    sizeof(char *) + sizeof(acpi_integer) +
+				    sizeof(char *) + sizeof(u64) +
 				    sizeof(char);
 				tail_offset += sizeof(char *);
 				break;
@@ -193,17 +193,17 @@ acpi_extract_package(union acpi_object *package,
 		case ACPI_TYPE_INTEGER:
 			switch (format_string[i]) {
 			case 'N':
-				*((acpi_integer *) head) =
+				*((u64 *) head) =
 				    element->integer.value;
-				head += sizeof(acpi_integer);
+				head += sizeof(u64);
 				break;
 			case 'S':
 				pointer = (u8 **) head;
 				*pointer = tail;
-				*((acpi_integer *) tail) =
+				*((u64 *) tail) =
 				    element->integer.value;
-				head += sizeof(acpi_integer *);
-				tail += sizeof(acpi_integer);
+				head += sizeof(u64 *);
+				tail += sizeof(u64);
 				/* NULL terminate string */
 				*tail = (char)0;
 				tail += sizeof(char);

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index f844941089bb..811fec10462b 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -30,6 +30,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#include "internal.h"
+
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME("utils");
 

commit 40599072dca3ec7d4c9ff8271978be169f974638
Author: Pavel Machek <pavel@suse.cz>
Date:   Tue Nov 25 12:05:08 2008 +0100

    ACPI: scheduling in atomic via acpi_evaluate_integer ()
    
    Now I know why I had strange "scheduling in atomic" problems:
    acpi_evaluate_integer() does malloc(..., irqs_disabled() ? GFP_ATOMIC
    : GFP_KERNEL)... which is (of course) broken.
    
    There's no way to reliably tell if we need GFP_ATOMIC or not from
    code, this one for example fails to detect spinlocks held.
    
    Fortunately, allocation seems small enough to be done on stack.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Acked-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index e827be36ee8d..f844941089bb 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -259,34 +259,26 @@ acpi_evaluate_integer(acpi_handle handle,
 		      struct acpi_object_list *arguments, unsigned long long *data)
 {
 	acpi_status status = AE_OK;
-	union acpi_object *element;
+	union acpi_object element;
 	struct acpi_buffer buffer = { 0, NULL };
 
-
 	if (!data)
 		return AE_BAD_PARAMETER;
 
-	element = kzalloc(sizeof(union acpi_object), irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
-	if (!element)
-		return AE_NO_MEMORY;
-
 	buffer.length = sizeof(union acpi_object);
-	buffer.pointer = element;
+	buffer.pointer = &element;
 	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
 	if (ACPI_FAILURE(status)) {
 		acpi_util_eval_error(handle, pathname, status);
-		kfree(element);
 		return status;
 	}
 
-	if (element->type != ACPI_TYPE_INTEGER) {
+	if (element.type != ACPI_TYPE_INTEGER) {
 		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
-		kfree(element);
 		return AE_BAD_DATA;
 	}
 
-	*data = element->integer.value;
-	kfree(element);
+	*data = element.integer.value;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%llu]\n", *data));
 

commit 27663c5855b10af9ec67bc7dfba001426ba21222
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Oct 10 02:22:59 2008 -0400

    ACPI: Change acpi_evaluate_integer to support 64-bit on 32-bit kernels
    
    As of version 2.0, ACPI can return 64-bit integers.  The current
    acpi_evaluate_integer only supports 64-bit integers on 64-bit platforms.
    Change the argument to take a pointer to an acpi_integer so we support
    64-bit integers on all platforms.
    
    lenb: replaced use of "acpi_integer" with "unsigned long long"
    lenb: fixed bug in acpi_thermal_trips_update()
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 100926143818..e827be36ee8d 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -256,7 +256,7 @@ EXPORT_SYMBOL(acpi_extract_package);
 acpi_status
 acpi_evaluate_integer(acpi_handle handle,
 		      acpi_string pathname,
-		      struct acpi_object_list *arguments, unsigned long *data)
+		      struct acpi_object_list *arguments, unsigned long long *data)
 {
 	acpi_status status = AE_OK;
 	union acpi_object *element;
@@ -288,7 +288,7 @@ acpi_evaluate_integer(acpi_handle handle,
 	*data = element->integer.value;
 	kfree(element);
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%lu]\n", *data));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%llu]\n", *data));
 
 	return AE_OK;
 }

commit cd0b2248241f4146152fb04a6bf4bccb6ce0478a
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Apr 10 19:06:43 2008 +0400

    ACPICA: Fixes for external Reference Objects
    
    All Reference Objects returned via the AcpiEvaluteObject interface
    are now marked as type "REFERENCE" instead of "ANY". The type ANY
    is now reservered for NULL objects - either NULL package elements
    or unresolved named references.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 44ea60cf21c0..100926143818 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -398,7 +398,7 @@ acpi_evaluate_reference(acpi_handle handle,
 
 		element = &(package->package.elements[i]);
 
-		if (element->type != ACPI_TYPE_ANY) {
+		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
 			status = AE_BAD_DATA;
 			printk(KERN_ERR PREFIX
 				    "Expecting a [Reference] package element, found type %X\n",

commit b6a163875935ce8e8e85901a7f2b68f7a314d914
Author: Thomas Renninger <trenn@suse.de>
Date:   Wed Mar 12 01:06:24 2008 +0100

    ACPICA: Warn if packages with invalid references are evaluated
    
    And return an error to avoid NULL pointer access by the caller
    Lin Ming's patch avoids corrupted mem access when
    BIOS has invalid references included, the handle is now zero
    instead of corrupted.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index eba55b7d6c95..44ea60cf21c0 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -407,6 +407,12 @@ acpi_evaluate_reference(acpi_handle handle,
 			break;
 		}
 
+		if (!element->reference.handle) {
+			printk(KERN_WARNING PREFIX "Invalid reference in"
+			       " package %s\n", pathname);
+			status = AE_NULL_ENTRY;
+			break;
+		}
 		/* Get the  acpi_handle. */
 
 		list->handles[i] = element->reference.handle;

commit 4fd7f5188c377c1e9aa8f224f6edf96d170a7d32
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Feb 15 17:07:19 2008 -0800

    ACPI: sparse fix, replace macro with static function
    
    replace acpi_util_eval_error macro with static function.
    
    Avoid these sparse warnings due to using buffer within the macro.
    drivers/acpi/utils.c:273:3: warning: symbol 'buffer' shadows an earlier one
    drivers/acpi/utils.c:259:21: originally declared here
    drivers/acpi/utils.c:279:3: warning: symbol 'buffer' shadows an earlier one
    drivers/acpi/utils.c:259:21: originally declared here
    drivers/acpi/utils.c:368:3: warning: symbol 'buffer' shadows an earlier one
    drivers/acpi/utils.c:348:21: originally declared here
    drivers/acpi/utils.c:375:3: warning: symbol 'buffer' shadows an earlier one
    drivers/acpi/utils.c:348:21: originally declared here
    drivers/acpi/utils.c:382:3: warning: symbol 'buffer' shadows an earlier one
    drivers/acpi/utils.c:348:21: originally declared here
    drivers/acpi/utils.c:402:4: warning: symbol 'buffer' shadows an earlier one
    drivers/acpi/utils.c:348:21: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 34f157571080..eba55b7d6c95 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -36,16 +36,20 @@ ACPI_MODULE_NAME("utils");
 /* --------------------------------------------------------------------------
                             Object Evaluation Helpers
    -------------------------------------------------------------------------- */
+static void
+acpi_util_eval_error(acpi_handle h, acpi_string p, acpi_status s)
+{
 #ifdef ACPI_DEBUG_OUTPUT
-#define acpi_util_eval_error(h,p,s) {\
-	char prefix[80] = {'\0'};\
-	struct acpi_buffer buffer = {sizeof(prefix), prefix};\
-	acpi_get_name(h, ACPI_FULL_PATHNAME, &buffer);\
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate [%s.%s]: %s\n",\
-		(char *) prefix, p, acpi_format_exception(s))); }
+	char prefix[80] = {'\0'};
+	struct acpi_buffer buffer = {sizeof(prefix), prefix};
+	acpi_get_name(h, ACPI_FULL_PATHNAME, &buffer);
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate [%s.%s]: %s\n",
+		(char *) prefix, p, acpi_format_exception(s)));
 #else
-#define acpi_util_eval_error(h,p,s)
+	return;
 #endif
+}
+
 acpi_status
 acpi_extract_package(union acpi_object *package,
 		     struct acpi_buffer *format, struct acpi_buffer *buffer)

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 68a809fa7b19..34f157571080 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -31,7 +31,7 @@
 #include <acpi/acpi_drivers.h>
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME("acpi_utils")
+ACPI_MODULE_NAME("utils");
 
 /* --------------------------------------------------------------------------
                             Object Evaluation Helpers

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 91fed70a65a6..68a809fa7b19 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -262,11 +262,10 @@ acpi_evaluate_integer(acpi_handle handle,
 	if (!data)
 		return AE_BAD_PARAMETER;
 
-	element = kmalloc(sizeof(union acpi_object), irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
+	element = kzalloc(sizeof(union acpi_object), irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
 	if (!element)
 		return AE_NO_MEMORY;
 
-	memset(element, 0, sizeof(union acpi_object));
 	buffer.length = sizeof(union acpi_object);
 	buffer.pointer = element;
 	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
@@ -321,12 +320,11 @@ acpi_evaluate_string(acpi_handle handle,
 		return AE_BAD_DATA;
 	}
 
-	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
+	*data = kzalloc(element->string.length + 1, GFP_KERNEL);
 	if (!data) {
 		printk(KERN_ERR PREFIX "Memory allocation\n");
 		return -ENOMEM;
 	}
-	memset(*data, 0, element->string.length + 1);
 
 	memcpy(*data, element->string.pointer, element->string.length);
 

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index d0d84c43a9d4..91fed70a65a6 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -83,7 +83,7 @@ acpi_extract_package(union acpi_object *package,
 		return AE_BAD_DATA;
 	}
 
-	format_string = (char *)format->pointer;
+	format_string = format->pointer;
 
 	/*
 	 * Calculate size_required.
@@ -361,7 +361,7 @@ acpi_evaluate_reference(acpi_handle handle,
 	if (ACPI_FAILURE(status))
 		goto end;
 
-	package = (union acpi_object *)buffer.pointer;
+	package = buffer.pointer;
 
 	if ((buffer.length == 0) || !package) {
 		printk(KERN_ERR PREFIX "No return object (len %X ptr %p)\n",

commit d68909f4c3eee09c13d4e5c86512c6c075553dbd
Author: Len Brown <len.brown@intel.com>
Date:   Wed Aug 16 19:16:58 2006 -0400

    ACPI: avoid irqrouter_resume might_sleep oops on resume from S4
    
    __might_sleep+0x8e/0x93
    acpi_os_wait_semaphore+0x50/0xa3
    acpi_ut_acquire_mutex+0x28/0x6a
    acpi_ns_get_node+0x46/0x88
    acpi_ns_evaluate+0x2d/0xfc
    acpi_rs_set_srs_method_data+0xc5/0xe1
    acpi_set_current_resources+0x31/0x3f
    acpi_pci_link_set+0xfc/0x1a5
    irqrouter_resume+0x48/0x5f
    
    and
    
    __might_sleep+0x8e/0x93
    kmem_cache_alloc+0x2a/0x8f
    acpi_evaluate_integer+0x32/0x96
    acpi_bus_get_status+0x30/0x84
    acpi_pci_link_set+0x12a/0x1a5
    irqrouter_resume+0x48/0x5f
    
    http://bugzilla.kernel.org/show_bug.cgi?id=6810
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index f48227f4c8c9..d0d84c43a9d4 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -262,7 +262,7 @@ acpi_evaluate_integer(acpi_handle handle,
 	if (!data)
 		return AE_BAD_PARAMETER;
 
-	element = kmalloc(sizeof(union acpi_object), GFP_KERNEL);
+	element = kmalloc(sizeof(union acpi_object), irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);
 	if (!element)
 		return AE_NO_MEMORY;
 

commit 02438d8771ae6a4b215938959827692026380bf9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 30 03:19:10 2006 -0400

    ACPI: delete acpi_os_free(), use kfree() directly
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 1930e1a75b22..f48227f4c8c9 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -332,7 +332,7 @@ acpi_evaluate_string(acpi_handle handle,
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%s]\n", *data));
 
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 
 	return AE_OK;
 }
@@ -418,7 +418,7 @@ acpi_evaluate_reference(acpi_handle handle,
 		//kfree(list->handles);
 	}
 
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 
 	return status;
 }

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index a5da4efab063..1930e1a75b22 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -58,22 +58,21 @@ acpi_extract_package(union acpi_object *package,
 	u8 *head = NULL;
 	u8 *tail = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_extract_package");
 
 	if (!package || (package->type != ACPI_TYPE_PACKAGE)
 	    || (package->package.count < 1)) {
 		printk(KERN_WARNING PREFIX "Invalid package argument\n");
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 	}
 
 	if (!format || !format->pointer || (format->length < 1)) {
 		printk(KERN_WARNING PREFIX "Invalid format argument\n");
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 	}
 
 	if (!buffer) {
 		printk(KERN_WARNING PREFIX "Invalid buffer argument\n");
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 	}
 
 	format_count = (format->length / sizeof(char)) - 1;
@@ -81,7 +80,7 @@ acpi_extract_package(union acpi_object *package,
 		printk(KERN_WARNING PREFIX "Format specifies more objects [%d]"
 			      " than exist in package [%d].\n",
 			      format_count, package->package.count);
-		return_ACPI_STATUS(AE_BAD_DATA);
+		return AE_BAD_DATA;
 	}
 
 	format_string = (char *)format->pointer;
@@ -94,7 +93,7 @@ acpi_extract_package(union acpi_object *package,
 		union acpi_object *element = &(package->package.elements[i]);
 
 		if (!element) {
-			return_ACPI_STATUS(AE_BAD_DATA);
+			return AE_BAD_DATA;
 		}
 
 		switch (element->type) {
@@ -116,7 +115,7 @@ acpi_extract_package(union acpi_object *package,
 					      " [%d]: got number, expecing"
 					      " [%c]\n",
 					      i, format_string[i]);
-				return_ACPI_STATUS(AE_BAD_DATA);
+				return AE_BAD_DATA;
 				break;
 			}
 			break;
@@ -142,7 +141,7 @@ acpi_extract_package(union acpi_object *package,
 					      " [%d] got string/buffer,"
 					      " expecing [%c]\n",
 					      i, format_string[i]);
-				return_ACPI_STATUS(AE_BAD_DATA);
+				return AE_BAD_DATA;
 				break;
 			}
 			break;
@@ -153,7 +152,7 @@ acpi_extract_package(union acpi_object *package,
 					  "Found unsupported element at index=%d\n",
 					  i));
 			/* TBD: handle nested packages... */
-			return_ACPI_STATUS(AE_SUPPORT);
+			return AE_SUPPORT;
 			break;
 		}
 	}
@@ -163,9 +162,9 @@ acpi_extract_package(union acpi_object *package,
 	 */
 	if (buffer->length < size_required) {
 		buffer->length = size_required;
-		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
+		return AE_BUFFER_OVERFLOW;
 	} else if (buffer->length != size_required || !buffer->pointer) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 	}
 
 	head = buffer->pointer;
@@ -180,7 +179,7 @@ acpi_extract_package(union acpi_object *package,
 		union acpi_object *element = &(package->package.elements[i]);
 
 		if (!element) {
-			return_ACPI_STATUS(AE_BAD_DATA);
+			return AE_BAD_DATA;
 		}
 
 		switch (element->type) {
@@ -245,7 +244,7 @@ acpi_extract_package(union acpi_object *package,
 		}
 	}
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 
 EXPORT_SYMBOL(acpi_extract_package);
@@ -259,14 +258,13 @@ acpi_evaluate_integer(acpi_handle handle,
 	union acpi_object *element;
 	struct acpi_buffer buffer = { 0, NULL };
 
-	ACPI_FUNCTION_TRACE("acpi_evaluate_integer");
 
 	if (!data)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 
 	element = kmalloc(sizeof(union acpi_object), GFP_KERNEL);
 	if (!element)
-		return_ACPI_STATUS(AE_NO_MEMORY);
+		return AE_NO_MEMORY;
 
 	memset(element, 0, sizeof(union acpi_object));
 	buffer.length = sizeof(union acpi_object);
@@ -275,13 +273,13 @@ acpi_evaluate_integer(acpi_handle handle,
 	if (ACPI_FAILURE(status)) {
 		acpi_util_eval_error(handle, pathname, status);
 		kfree(element);
-		return_ACPI_STATUS(status);
+		return status;
 	}
 
 	if (element->type != ACPI_TYPE_INTEGER) {
 		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
 		kfree(element);
-		return_ACPI_STATUS(AE_BAD_DATA);
+		return AE_BAD_DATA;
 	}
 
 	*data = element->integer.value;
@@ -289,7 +287,7 @@ acpi_evaluate_integer(acpi_handle handle,
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%lu]\n", *data));
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 
 EXPORT_SYMBOL(acpi_evaluate_integer);
@@ -304,15 +302,14 @@ acpi_evaluate_string(acpi_handle handle,
 	acpi_object *element = NULL;
 	acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-	ACPI_FUNCTION_TRACE("acpi_evaluate_string");
 
 	if (!data)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 
 	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
 	if (ACPI_FAILURE(status)) {
 		acpi_util_eval_error(handle, pathname, status);
-		return_ACPI_STATUS(status);
+		return status;
 	}
 
 	element = (acpi_object *) buffer.pointer;
@@ -321,13 +318,13 @@ acpi_evaluate_string(acpi_handle handle,
 	    || (element->type != ACPI_TYPE_BUFFER)
 	    || !element->string.length) {
 		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
-		return_ACPI_STATUS(AE_BAD_DATA);
+		return AE_BAD_DATA;
 	}
 
 	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
 	if (!data) {
 		printk(KERN_ERR PREFIX "Memory allocation\n");
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	}
 	memset(*data, 0, element->string.length + 1);
 
@@ -337,7 +334,7 @@ acpi_evaluate_string(acpi_handle handle,
 
 	acpi_os_free(buffer.pointer);
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 #endif
 
@@ -353,10 +350,9 @@ acpi_evaluate_reference(acpi_handle handle,
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	u32 i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_evaluate_reference");
 
 	if (!list) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 	}
 
 	/* Evaluate object. */
@@ -390,7 +386,7 @@ acpi_evaluate_reference(acpi_handle handle,
 	}
 
 	if (package->package.count > ACPI_MAX_HANDLES) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
+		return AE_NO_MEMORY;
 	}
 	list->count = package->package.count;
 
@@ -424,7 +420,7 @@ acpi_evaluate_reference(acpi_handle handle,
 
 	acpi_os_free(buffer.pointer);
 
-	return_ACPI_STATUS(status);
+	return status;
 }
 
 EXPORT_SYMBOL(acpi_evaluate_reference);

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 040ff473d1f2..a5da4efab063 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -326,7 +326,7 @@ acpi_evaluate_string(acpi_handle handle,
 
 	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
 	if (!data) {
-		ACPI_ERROR((AE_INFO, "Memory allocation"));
+		printk(KERN_ERR PREFIX "Memory allocation\n");
 		return_VALUE(-ENOMEM);
 	}
 	memset(*data, 0, element->string.length + 1);
@@ -368,22 +368,22 @@ acpi_evaluate_reference(acpi_handle handle,
 	package = (union acpi_object *)buffer.pointer;
 
 	if ((buffer.length == 0) || !package) {
-		ACPI_ERROR((AE_INFO, "No return object (len %X ptr %p)",
-			    (unsigned)buffer.length, package));
+		printk(KERN_ERR PREFIX "No return object (len %X ptr %p)\n",
+			    (unsigned)buffer.length, package);
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (package->type != ACPI_TYPE_PACKAGE) {
-		ACPI_ERROR((AE_INFO, "Expecting a [Package], found type %X",
-			    package->type));
+		printk(KERN_ERR PREFIX "Expecting a [Package], found type %X\n",
+			    package->type);
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (!package->package.count) {
-		ACPI_ERROR((AE_INFO, "[Package] has zero elements (%p)",
-			    package));
+		printk(KERN_ERR PREFIX "[Package] has zero elements (%p)\n",
+			    package);
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
@@ -402,9 +402,9 @@ acpi_evaluate_reference(acpi_handle handle,
 
 		if (element->type != ACPI_TYPE_ANY) {
 			status = AE_BAD_DATA;
-			ACPI_ERROR((AE_INFO,
-				    "Expecting a [Reference] package element, found type %X",
-				    element->type));
+			printk(KERN_ERR PREFIX
+				    "Expecting a [Reference] package element, found type %X\n",
+				    element->type);
 			acpi_util_eval_error(handle, pathname, status);
 			break;
 		}

commit cece92969762b8ed7930d4e23008b76b06411dee
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:04:31 2006 -0400

    ACPI: un-export ACPI_WARNING() -- use printk(KERN_WARNING...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index ce093d4516ba..040ff473d1f2 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -62,25 +62,25 @@ acpi_extract_package(union acpi_object *package,
 
 	if (!package || (package->type != ACPI_TYPE_PACKAGE)
 	    || (package->package.count < 1)) {
-		ACPI_WARNING((AE_INFO, "Invalid package argument"));
+		printk(KERN_WARNING PREFIX "Invalid package argument\n");
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
 	if (!format || !format->pointer || (format->length < 1)) {
-		ACPI_WARNING((AE_INFO, "Invalid format argument"));
+		printk(KERN_WARNING PREFIX "Invalid format argument\n");
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
 	if (!buffer) {
-		ACPI_WARNING((AE_INFO, "Invalid buffer argument"));
+		printk(KERN_WARNING PREFIX "Invalid buffer argument\n");
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
 	format_count = (format->length / sizeof(char)) - 1;
 	if (format_count > package->package.count) {
-		ACPI_WARNING((AE_INFO, "Format specifies more objects [%d]"
-			      " than exist in package [%d].",
-			      format_count, package->package.count));
+		printk(KERN_WARNING PREFIX "Format specifies more objects [%d]"
+			      " than exist in package [%d].\n",
+			      format_count, package->package.count);
 		return_ACPI_STATUS(AE_BAD_DATA);
 	}
 
@@ -112,10 +112,10 @@ acpi_extract_package(union acpi_object *package,
 				tail_offset += sizeof(char *);
 				break;
 			default:
-				ACPI_WARNING((AE_INFO, "Invalid package element"
+				printk(KERN_WARNING PREFIX "Invalid package element"
 					      " [%d]: got number, expecing"
-					      " [%c]",
-					      i, format_string[i]));
+					      " [%c]\n",
+					      i, format_string[i]);
 				return_ACPI_STATUS(AE_BAD_DATA);
 				break;
 			}
@@ -138,10 +138,10 @@ acpi_extract_package(union acpi_object *package,
 				tail_offset += sizeof(u8 *);
 				break;
 			default:
-				ACPI_WARNING((AE_INFO, "Invalid package element"
+				printk(KERN_WARNING PREFIX "Invalid package element"
 					      " [%d] got string/buffer,"
-					      " expecing [%c]",
-					      i, format_string[i]));
+					      " expecing [%c]\n",
+					      i, format_string[i]);
 				return_ACPI_STATUS(AE_BAD_DATA);
 				break;
 			}

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 6b516852ac12..ce093d4516ba 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -62,26 +62,25 @@ acpi_extract_package(union acpi_object *package,
 
 	if (!package || (package->type != ACPI_TYPE_PACKAGE)
 	    || (package->package.count < 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				  "Invalid 'package' argument\n"));
+		ACPI_WARNING((AE_INFO, "Invalid package argument"));
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
 	if (!format || !format->pointer || (format->length < 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'format' argument\n"));
+		ACPI_WARNING((AE_INFO, "Invalid format argument"));
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
 	if (!buffer) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'buffer' argument\n"));
+		ACPI_WARNING((AE_INFO, "Invalid buffer argument"));
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
 	format_count = (format->length / sizeof(char)) - 1;
 	if (format_count > package->package.count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				  "Format specifies more objects [%d] than exist in package [%d].",
-				  format_count, package->package.count));
+		ACPI_WARNING((AE_INFO, "Format specifies more objects [%d]"
+			      " than exist in package [%d].",
+			      format_count, package->package.count));
 		return_ACPI_STATUS(AE_BAD_DATA);
 	}
 
@@ -113,9 +112,10 @@ acpi_extract_package(union acpi_object *package,
 				tail_offset += sizeof(char *);
 				break;
 			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-						  "Invalid package element [%d]: got number, expecing [%c].\n",
-						  i, format_string[i]));
+				ACPI_WARNING((AE_INFO, "Invalid package element"
+					      " [%d]: got number, expecing"
+					      " [%c]",
+					      i, format_string[i]));
 				return_ACPI_STATUS(AE_BAD_DATA);
 				break;
 			}
@@ -138,9 +138,10 @@ acpi_extract_package(union acpi_object *package,
 				tail_offset += sizeof(u8 *);
 				break;
 			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-						  "Invalid package element [%d] got string/buffer, expecing [%c].\n",
-						  i, format_string[i]));
+				ACPI_WARNING((AE_INFO, "Invalid package element"
+					      " [%d] got string/buffer,"
+					      " expecing [%c]",
+					      i, format_string[i]));
 				return_ACPI_STATUS(AE_BAD_DATA);
 				break;
 			}
@@ -325,7 +326,7 @@ acpi_evaluate_string(acpi_handle handle,
 
 	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
 	if (!data) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		ACPI_ERROR((AE_INFO, "Memory allocation"));
 		return_VALUE(-ENOMEM);
 	}
 	memset(*data, 0, element->string.length + 1);
@@ -367,25 +368,22 @@ acpi_evaluate_reference(acpi_handle handle,
 	package = (union acpi_object *)buffer.pointer;
 
 	if ((buffer.length == 0) || !package) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "No return object (len %X ptr %p)\n",
-				  (unsigned)buffer.length, package));
+		ACPI_ERROR((AE_INFO, "No return object (len %X ptr %p)",
+			    (unsigned)buffer.length, package));
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (package->type != ACPI_TYPE_PACKAGE) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Expecting a [Package], found type %X\n",
-				  package->type));
+		ACPI_ERROR((AE_INFO, "Expecting a [Package], found type %X",
+			    package->type));
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (!package->package.count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "[Package] has zero elements (%p)\n",
-				  package));
+		ACPI_ERROR((AE_INFO, "[Package] has zero elements (%p)",
+			    package));
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
@@ -404,9 +402,9 @@ acpi_evaluate_reference(acpi_handle handle,
 
 		if (element->type != ACPI_TYPE_ANY) {
 			status = AE_BAD_DATA;
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-					  "Expecting a [Reference] package element, found type %X\n",
-					  element->type));
+			ACPI_ERROR((AE_INFO,
+				    "Expecting a [Reference] package element, found type %X",
+				    element->type));
 			acpi_util_eval_error(handle, pathname, status);
 			break;
 		}

commit 64385f2fd8bc9d8803c8d10dcd391871cb126b77
Author: Vasily Averin <vvs@sw.ru>
Date:   Thu Apr 27 05:25:00 2006 -0400

    ACPI: fix potential memory leak in acpi_evaluate_integer() error path
    
    Signed-off-by: Vasily Averin <vvs@sw.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 6458c47f7ac2..6b516852ac12 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -273,11 +273,13 @@ acpi_evaluate_integer(acpi_handle handle,
 	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
 	if (ACPI_FAILURE(status)) {
 		acpi_util_eval_error(handle, pathname, status);
+		kfree(element);
 		return_ACPI_STATUS(status);
 	}
 
 	if (element->type != ACPI_TYPE_INTEGER) {
 		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
+		kfree(element);
 		return_ACPI_STATUS(AE_BAD_DATA);
 	}
 

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 1ce2047c3804..6458c47f7ac2 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -30,15 +30,12 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-
 #define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME		("acpi_utils")
-
+ACPI_MODULE_NAME("acpi_utils")
 
 /* --------------------------------------------------------------------------
                             Object Evaluation Helpers
    -------------------------------------------------------------------------- */
-
 #ifdef ACPI_DEBUG_OUTPUT
 #define acpi_util_eval_error(h,p,s) {\
 	char prefix[80] = {'\0'};\
@@ -49,26 +46,24 @@ ACPI_MODULE_NAME		("acpi_utils")
 #else
 #define acpi_util_eval_error(h,p,s)
 #endif
-
-
 acpi_status
-acpi_extract_package (
-	union acpi_object	*package,
-	struct acpi_buffer	*format,
-	struct acpi_buffer	*buffer)
+acpi_extract_package(union acpi_object *package,
+		     struct acpi_buffer *format, struct acpi_buffer *buffer)
 {
-	u32			size_required = 0;
-	u32			tail_offset = 0;
-	char			*format_string = NULL;
-	u32			format_count = 0;
-	u32			i = 0;
-	u8			*head = NULL;
-	u8			*tail = NULL;
+	u32 size_required = 0;
+	u32 tail_offset = 0;
+	char *format_string = NULL;
+	u32 format_count = 0;
+	u32 i = 0;
+	u8 *head = NULL;
+	u8 *tail = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_extract_package");
 
-	if (!package || (package->type != ACPI_TYPE_PACKAGE) || (package->package.count < 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'package' argument\n"));
+	if (!package || (package->type != ACPI_TYPE_PACKAGE)
+	    || (package->package.count < 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				  "Invalid 'package' argument\n"));
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
@@ -82,18 +77,20 @@ acpi_extract_package (
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
-	format_count = (format->length/sizeof(char)) - 1;
+	format_count = (format->length / sizeof(char)) - 1;
 	if (format_count > package->package.count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Format specifies more objects [%d] than exist in package [%d].", format_count, package->package.count));
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				  "Format specifies more objects [%d] than exist in package [%d].",
+				  format_count, package->package.count));
 		return_ACPI_STATUS(AE_BAD_DATA);
 	}
 
-	format_string = (char*)format->pointer;
+	format_string = (char *)format->pointer;
 
 	/*
 	 * Calculate size_required.
 	 */
-	for (i=0; i<format_count; i++) {
+	for (i = 0; i < format_count; i++) {
 
 		union acpi_object *element = &(package->package.elements[i]);
 
@@ -110,11 +107,15 @@ acpi_extract_package (
 				tail_offset += sizeof(acpi_integer);
 				break;
 			case 'S':
-				size_required += sizeof(char*) + sizeof(acpi_integer) + sizeof(char);
-				tail_offset += sizeof(char*);
+				size_required +=
+				    sizeof(char *) + sizeof(acpi_integer) +
+				    sizeof(char);
+				tail_offset += sizeof(char *);
 				break;
 			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d]: got number, expecing [%c].\n", i, format_string[i]));
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+						  "Invalid package element [%d]: got number, expecing [%c].\n",
+						  i, format_string[i]));
 				return_ACPI_STATUS(AE_BAD_DATA);
 				break;
 			}
@@ -124,15 +125,22 @@ acpi_extract_package (
 		case ACPI_TYPE_BUFFER:
 			switch (format_string[i]) {
 			case 'S':
-				size_required += sizeof(char*) + (element->string.length * sizeof(char)) + sizeof(char);
-				tail_offset += sizeof(char*);
+				size_required +=
+				    sizeof(char *) +
+				    (element->string.length * sizeof(char)) +
+				    sizeof(char);
+				tail_offset += sizeof(char *);
 				break;
 			case 'B':
-				size_required += sizeof(u8*) + (element->buffer.length * sizeof(u8));
-				tail_offset += sizeof(u8*);
+				size_required +=
+				    sizeof(u8 *) +
+				    (element->buffer.length * sizeof(u8));
+				tail_offset += sizeof(u8 *);
 				break;
 			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d] got string/buffer, expecing [%c].\n", i, format_string[i]));
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+						  "Invalid package element [%d] got string/buffer, expecing [%c].\n",
+						  i, format_string[i]));
 				return_ACPI_STATUS(AE_BAD_DATA);
 				break;
 			}
@@ -140,7 +148,9 @@ acpi_extract_package (
 
 		case ACPI_TYPE_PACKAGE:
 		default:
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unsupported element at index=%d\n", i));
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Found unsupported element at index=%d\n",
+					  i));
 			/* TBD: handle nested packages... */
 			return_ACPI_STATUS(AE_SUPPORT);
 			break;
@@ -153,8 +163,7 @@ acpi_extract_package (
 	if (buffer->length < size_required) {
 		buffer->length = size_required;
 		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
-	}
-	else if (buffer->length != size_required || !buffer->pointer) {
+	} else if (buffer->length != size_required || !buffer->pointer) {
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
@@ -164,7 +173,7 @@ acpi_extract_package (
 	/*
 	 * Extract package data.
 	 */
-	for (i=0; i<format_count; i++) {
+	for (i = 0; i < format_count; i++) {
 
 		u8 **pointer = NULL;
 		union acpi_object *element = &(package->package.elements[i]);
@@ -178,14 +187,16 @@ acpi_extract_package (
 		case ACPI_TYPE_INTEGER:
 			switch (format_string[i]) {
 			case 'N':
-				*((acpi_integer*)head) = element->integer.value;
+				*((acpi_integer *) head) =
+				    element->integer.value;
 				head += sizeof(acpi_integer);
 				break;
 			case 'S':
-				pointer = (u8**)head;
+				pointer = (u8 **) head;
 				*pointer = tail;
-				*((acpi_integer*)tail) = element->integer.value;
-				head += sizeof(acpi_integer*);
+				*((acpi_integer *) tail) =
+				    element->integer.value;
+				head += sizeof(acpi_integer *);
 				tail += sizeof(acpi_integer);
 				/* NULL terminate string */
 				*tail = (char)0;
@@ -201,20 +212,22 @@ acpi_extract_package (
 		case ACPI_TYPE_BUFFER:
 			switch (format_string[i]) {
 			case 'S':
-				pointer = (u8**)head;
+				pointer = (u8 **) head;
 				*pointer = tail;
-				memcpy(tail, element->string.pointer, element->string.length);
-				head += sizeof(char*);
+				memcpy(tail, element->string.pointer,
+				       element->string.length);
+				head += sizeof(char *);
 				tail += element->string.length * sizeof(char);
 				/* NULL terminate string */
 				*tail = (char)0;
 				tail += sizeof(char);
 				break;
 			case 'B':
-				pointer = (u8**)head;
+				pointer = (u8 **) head;
 				*pointer = tail;
-				memcpy(tail, element->buffer.pointer, element->buffer.length);
-				head += sizeof(u8*);
+				memcpy(tail, element->buffer.pointer,
+				       element->buffer.length);
+				head += sizeof(u8 *);
 				tail += element->buffer.length * sizeof(u8);
 				break;
 			default:
@@ -233,19 +246,17 @@ acpi_extract_package (
 
 	return_ACPI_STATUS(AE_OK);
 }
-EXPORT_SYMBOL(acpi_extract_package);
 
+EXPORT_SYMBOL(acpi_extract_package);
 
 acpi_status
-acpi_evaluate_integer (
-	acpi_handle		handle,
-	acpi_string		pathname,
-	struct acpi_object_list	*arguments,
-	unsigned long		*data)
+acpi_evaluate_integer(acpi_handle handle,
+		      acpi_string pathname,
+		      struct acpi_object_list *arguments, unsigned long *data)
 {
-	acpi_status             status = AE_OK;
-	union acpi_object	*element;
-	struct acpi_buffer	buffer = {0,NULL};
+	acpi_status status = AE_OK;
+	union acpi_object *element;
+	struct acpi_buffer buffer = { 0, NULL };
 
 	ACPI_FUNCTION_TRACE("acpi_evaluate_integer");
 
@@ -253,7 +264,7 @@ acpi_evaluate_integer (
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 
 	element = kmalloc(sizeof(union acpi_object), GFP_KERNEL);
-	if(!element)
+	if (!element)
 		return_ACPI_STATUS(AE_NO_MEMORY);
 
 	memset(element, 0, sizeof(union acpi_object));
@@ -277,20 +288,18 @@ acpi_evaluate_integer (
 
 	return_ACPI_STATUS(AE_OK);
 }
-EXPORT_SYMBOL(acpi_evaluate_integer);
 
+EXPORT_SYMBOL(acpi_evaluate_integer);
 
 #if 0
 acpi_status
-acpi_evaluate_string (
-	acpi_handle		handle,
-	acpi_string		pathname,
-	acpi_object_list	*arguments,
-	acpi_string		*data)
+acpi_evaluate_string(acpi_handle handle,
+		     acpi_string pathname,
+		     acpi_object_list * arguments, acpi_string * data)
 {
-	acpi_status             status = AE_OK;
-	acpi_object             *element = NULL;
-	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_status status = AE_OK;
+	acpi_object *element = NULL;
+	acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
 	ACPI_FUNCTION_TRACE("acpi_evaluate_string");
 
@@ -305,9 +314,9 @@ acpi_evaluate_string (
 
 	element = (acpi_object *) buffer.pointer;
 
-	if ((element->type != ACPI_TYPE_STRING) 
-		|| (element->type != ACPI_TYPE_BUFFER)
-		|| !element->string.length) {
+	if ((element->type != ACPI_TYPE_STRING)
+	    || (element->type != ACPI_TYPE_BUFFER)
+	    || !element->string.length) {
 		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
 		return_ACPI_STATUS(AE_BAD_DATA);
 	}
@@ -329,19 +338,17 @@ acpi_evaluate_string (
 }
 #endif
 
-
 acpi_status
-acpi_evaluate_reference (
-	acpi_handle		handle,
-	acpi_string		pathname,
-	struct acpi_object_list	*arguments,
-	struct acpi_handle_list	*list)
+acpi_evaluate_reference(acpi_handle handle,
+			acpi_string pathname,
+			struct acpi_object_list *arguments,
+			struct acpi_handle_list *list)
 {
-	acpi_status		status = AE_OK;
-	union acpi_object	*package = NULL;
-	union acpi_object	*element = NULL;
-	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	u32			i = 0;
+	acpi_status status = AE_OK;
+	union acpi_object *package = NULL;
+	union acpi_object *element = NULL;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	u32 i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_evaluate_reference");
 
@@ -355,28 +362,28 @@ acpi_evaluate_reference (
 	if (ACPI_FAILURE(status))
 		goto end;
 
-	package = (union acpi_object *) buffer.pointer;
+	package = (union acpi_object *)buffer.pointer;
 
 	if ((buffer.length == 0) || !package) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"No return object (len %X ptr %p)\n", 
-			(unsigned)buffer.length, package));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "No return object (len %X ptr %p)\n",
+				  (unsigned)buffer.length, package));
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (package->type != ACPI_TYPE_PACKAGE) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Expecting a [Package], found type %X\n", 
-			package->type));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Expecting a [Package], found type %X\n",
+				  package->type));
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
 	}
 	if (!package->package.count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"[Package] has zero elements (%p)\n", 
-			package));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "[Package] has zero elements (%p)\n",
+				  package));
 		status = AE_BAD_DATA;
 		acpi_util_eval_error(handle, pathname, status);
 		goto end;
@@ -395,9 +402,9 @@ acpi_evaluate_reference (
 
 		if (element->type != ACPI_TYPE_ANY) {
 			status = AE_BAD_DATA;
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-				"Expecting a [Reference] package element, found type %X\n",
-				element->type));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Expecting a [Reference] package element, found type %X\n",
+					  element->type));
 			acpi_util_eval_error(handle, pathname, status);
 			break;
 		}
@@ -406,10 +413,10 @@ acpi_evaluate_reference (
 
 		list->handles[i] = element->reference.handle;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found reference [%p]\n",
-			list->handles[i]));
+				  list->handles[i]));
 	}
 
-end:
+      end:
 	if (ACPI_FAILURE(status)) {
 		list->count = 0;
 		//kfree(list->handles);
@@ -419,5 +426,5 @@ acpi_evaluate_reference (
 
 	return_ACPI_STATUS(status);
 }
-EXPORT_SYMBOL(acpi_evaluate_reference);
 
+EXPORT_SYMBOL(acpi_evaluate_reference);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
new file mode 100644
index 000000000000..1ce2047c3804
--- /dev/null
+++ b/drivers/acpi/utils.c
@@ -0,0 +1,423 @@
+/*
+ *  acpi_utils.c - ACPI Utility Functions ($Revision: 10 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_BUS_COMPONENT
+ACPI_MODULE_NAME		("acpi_utils")
+
+
+/* --------------------------------------------------------------------------
+                            Object Evaluation Helpers
+   -------------------------------------------------------------------------- */
+
+#ifdef ACPI_DEBUG_OUTPUT
+#define acpi_util_eval_error(h,p,s) {\
+	char prefix[80] = {'\0'};\
+	struct acpi_buffer buffer = {sizeof(prefix), prefix};\
+	acpi_get_name(h, ACPI_FULL_PATHNAME, &buffer);\
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate [%s.%s]: %s\n",\
+		(char *) prefix, p, acpi_format_exception(s))); }
+#else
+#define acpi_util_eval_error(h,p,s)
+#endif
+
+
+acpi_status
+acpi_extract_package (
+	union acpi_object	*package,
+	struct acpi_buffer	*format,
+	struct acpi_buffer	*buffer)
+{
+	u32			size_required = 0;
+	u32			tail_offset = 0;
+	char			*format_string = NULL;
+	u32			format_count = 0;
+	u32			i = 0;
+	u8			*head = NULL;
+	u8			*tail = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_extract_package");
+
+	if (!package || (package->type != ACPI_TYPE_PACKAGE) || (package->package.count < 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'package' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!format || !format->pointer || (format->length < 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'format' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!buffer) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'buffer' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	format_count = (format->length/sizeof(char)) - 1;
+	if (format_count > package->package.count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Format specifies more objects [%d] than exist in package [%d].", format_count, package->package.count));
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	format_string = (char*)format->pointer;
+
+	/*
+	 * Calculate size_required.
+	 */
+	for (i=0; i<format_count; i++) {
+
+		union acpi_object *element = &(package->package.elements[i]);
+
+		if (!element) {
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		switch (element->type) {
+
+		case ACPI_TYPE_INTEGER:
+			switch (format_string[i]) {
+			case 'N':
+				size_required += sizeof(acpi_integer);
+				tail_offset += sizeof(acpi_integer);
+				break;
+			case 'S':
+				size_required += sizeof(char*) + sizeof(acpi_integer) + sizeof(char);
+				tail_offset += sizeof(char*);
+				break;
+			default:
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d]: got number, expecing [%c].\n", i, format_string[i]));
+				return_ACPI_STATUS(AE_BAD_DATA);
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+			switch (format_string[i]) {
+			case 'S':
+				size_required += sizeof(char*) + (element->string.length * sizeof(char)) + sizeof(char);
+				tail_offset += sizeof(char*);
+				break;
+			case 'B':
+				size_required += sizeof(u8*) + (element->buffer.length * sizeof(u8));
+				tail_offset += sizeof(u8*);
+				break;
+			default:
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d] got string/buffer, expecing [%c].\n", i, format_string[i]));
+				return_ACPI_STATUS(AE_BAD_DATA);
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+		default:
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unsupported element at index=%d\n", i));
+			/* TBD: handle nested packages... */
+			return_ACPI_STATUS(AE_SUPPORT);
+			break;
+		}
+	}
+
+	/*
+	 * Validate output buffer.
+	 */
+	if (buffer->length < size_required) {
+		buffer->length = size_required;
+		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
+	}
+	else if (buffer->length != size_required || !buffer->pointer) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	head = buffer->pointer;
+	tail = buffer->pointer + tail_offset;
+
+	/*
+	 * Extract package data.
+	 */
+	for (i=0; i<format_count; i++) {
+
+		u8 **pointer = NULL;
+		union acpi_object *element = &(package->package.elements[i]);
+
+		if (!element) {
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		switch (element->type) {
+
+		case ACPI_TYPE_INTEGER:
+			switch (format_string[i]) {
+			case 'N':
+				*((acpi_integer*)head) = element->integer.value;
+				head += sizeof(acpi_integer);
+				break;
+			case 'S':
+				pointer = (u8**)head;
+				*pointer = tail;
+				*((acpi_integer*)tail) = element->integer.value;
+				head += sizeof(acpi_integer*);
+				tail += sizeof(acpi_integer);
+				/* NULL terminate string */
+				*tail = (char)0;
+				tail += sizeof(char);
+				break;
+			default:
+				/* Should never get here */
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+			switch (format_string[i]) {
+			case 'S':
+				pointer = (u8**)head;
+				*pointer = tail;
+				memcpy(tail, element->string.pointer, element->string.length);
+				head += sizeof(char*);
+				tail += element->string.length * sizeof(char);
+				/* NULL terminate string */
+				*tail = (char)0;
+				tail += sizeof(char);
+				break;
+			case 'B':
+				pointer = (u8**)head;
+				*pointer = tail;
+				memcpy(tail, element->buffer.pointer, element->buffer.length);
+				head += sizeof(u8*);
+				tail += element->buffer.length * sizeof(u8);
+				break;
+			default:
+				/* Should never get here */
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+			/* TBD: handle nested packages... */
+		default:
+			/* Should never get here */
+			break;
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+EXPORT_SYMBOL(acpi_extract_package);
+
+
+acpi_status
+acpi_evaluate_integer (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	struct acpi_object_list	*arguments,
+	unsigned long		*data)
+{
+	acpi_status             status = AE_OK;
+	union acpi_object	*element;
+	struct acpi_buffer	buffer = {0,NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_integer");
+
+	if (!data)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	element = kmalloc(sizeof(union acpi_object), GFP_KERNEL);
+	if(!element)
+		return_ACPI_STATUS(AE_NO_MEMORY);
+
+	memset(element, 0, sizeof(union acpi_object));
+	buffer.length = sizeof(union acpi_object);
+	buffer.pointer = element;
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status)) {
+		acpi_util_eval_error(handle, pathname, status);
+		return_ACPI_STATUS(status);
+	}
+
+	if (element->type != ACPI_TYPE_INTEGER) {
+		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	*data = element->integer.value;
+	kfree(element);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%lu]\n", *data));
+
+	return_ACPI_STATUS(AE_OK);
+}
+EXPORT_SYMBOL(acpi_evaluate_integer);
+
+
+#if 0
+acpi_status
+acpi_evaluate_string (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	acpi_object_list	*arguments,
+	acpi_string		*data)
+{
+	acpi_status             status = AE_OK;
+	acpi_object             *element = NULL;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_string");
+
+	if (!data)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status)) {
+		acpi_util_eval_error(handle, pathname, status);
+		return_ACPI_STATUS(status);
+	}
+
+	element = (acpi_object *) buffer.pointer;
+
+	if ((element->type != ACPI_TYPE_STRING) 
+		|| (element->type != ACPI_TYPE_BUFFER)
+		|| !element->string.length) {
+		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
+	if (!data) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		return_VALUE(-ENOMEM);
+	}
+	memset(*data, 0, element->string.length + 1);
+
+	memcpy(*data, element->string.pointer, element->string.length);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%s]\n", *data));
+
+	acpi_os_free(buffer.pointer);
+
+	return_ACPI_STATUS(AE_OK);
+}
+#endif
+
+
+acpi_status
+acpi_evaluate_reference (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	struct acpi_object_list	*arguments,
+	struct acpi_handle_list	*list)
+{
+	acpi_status		status = AE_OK;
+	union acpi_object	*package = NULL;
+	union acpi_object	*element = NULL;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_reference");
+
+	if (!list) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Evaluate object. */
+
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status))
+		goto end;
+
+	package = (union acpi_object *) buffer.pointer;
+
+	if ((buffer.length == 0) || !package) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"No return object (len %X ptr %p)\n", 
+			(unsigned)buffer.length, package));
+		status = AE_BAD_DATA;
+		acpi_util_eval_error(handle, pathname, status);
+		goto end;
+	}
+	if (package->type != ACPI_TYPE_PACKAGE) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Expecting a [Package], found type %X\n", 
+			package->type));
+		status = AE_BAD_DATA;
+		acpi_util_eval_error(handle, pathname, status);
+		goto end;
+	}
+	if (!package->package.count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"[Package] has zero elements (%p)\n", 
+			package));
+		status = AE_BAD_DATA;
+		acpi_util_eval_error(handle, pathname, status);
+		goto end;
+	}
+
+	if (package->package.count > ACPI_MAX_HANDLES) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+	list->count = package->package.count;
+
+	/* Extract package data. */
+
+	for (i = 0; i < list->count; i++) {
+
+		element = &(package->package.elements[i]);
+
+		if (element->type != ACPI_TYPE_ANY) {
+			status = AE_BAD_DATA;
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+				"Expecting a [Reference] package element, found type %X\n",
+				element->type));
+			acpi_util_eval_error(handle, pathname, status);
+			break;
+		}
+
+		/* Get the  acpi_handle. */
+
+		list->handles[i] = element->reference.handle;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found reference [%p]\n",
+			list->handles[i]));
+	}
+
+end:
+	if (ACPI_FAILURE(status)) {
+		list->count = 0;
+		//kfree(list->handles);
+	}
+
+	acpi_os_free(buffer.pointer);
+
+	return_ACPI_STATUS(status);
+}
+EXPORT_SYMBOL(acpi_evaluate_reference);
+
